{"setup.py": "#!/usr/bin/env python\n#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom setuptools import setup\n\nsetup()\n", "pyasn1/debug.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport logging\nimport sys\n\nfrom pyasn1 import __version__\nfrom pyasn1 import error\nfrom pyasn1.compat.octets import octs2ints\n\n__all__ = ['Debug', 'setLogger', 'hexdump']\n\nDEBUG_NONE = 0x0000\nDEBUG_ENCODER = 0x0001\nDEBUG_DECODER = 0x0002\nDEBUG_ALL = 0xffff\n\nFLAG_MAP = {\n    'none': DEBUG_NONE,\n    'encoder': DEBUG_ENCODER,\n    'decoder': DEBUG_DECODER,\n    'all': DEBUG_ALL\n}\n\nLOGGEE_MAP = {}\n\n\nclass Printer(object):\n    # noinspection PyShadowingNames\n    def __init__(self, logger=None, handler=None, formatter=None):\n        if logger is None:\n            logger = logging.getLogger('pyasn1')\n\n        logger.setLevel(logging.DEBUG)\n\n        if handler is None:\n            handler = logging.StreamHandler()\n\n        if formatter is None:\n            formatter = logging.Formatter('%(asctime)s %(name)s: %(message)s')\n\n        handler.setFormatter(formatter)\n        handler.setLevel(logging.DEBUG)\n        logger.addHandler(handler)\n\n        self.__logger = logger\n\n    def __call__(self, msg):\n        self.__logger.debug(msg)\n\n    def __str__(self):\n        return '<python logging>'\n\n\nclass Debug(object):\n    defaultPrinter = Printer()\n\n    def __init__(self, *flags, **options):\n        self._flags = DEBUG_NONE\n\n        if 'loggerName' in options:\n            # route our logs to parent logger\n            self._printer = Printer(\n                logger=logging.getLogger(options['loggerName']),\n                handler=logging.NullHandler()\n            )\n\n        elif 'printer' in options:\n            self._printer = options.get('printer')\n\n        else:\n            self._printer = self.defaultPrinter\n\n        self._printer('running pyasn1 %s, debug flags %s' % (__version__, ', '.join(flags)))\n\n        for flag in flags:\n            inverse = flag and flag[0] in ('!', '~')\n            if inverse:\n                flag = flag[1:]\n            try:\n                if inverse:\n                    self._flags &= ~FLAG_MAP[flag]\n                else:\n                    self._flags |= FLAG_MAP[flag]\n            except KeyError:\n                raise error.PyAsn1Error('bad debug flag %s' % flag)\n\n            self._printer(\"debug category '%s' %s\" % (flag, inverse and 'disabled' or 'enabled'))\n\n    def __str__(self):\n        return 'logger %s, flags %x' % (self._printer, self._flags)\n\n    def __call__(self, msg):\n        self._printer(msg)\n\n    def __and__(self, flag):\n        return self._flags & flag\n\n    def __rand__(self, flag):\n        return flag & self._flags\n\n_LOG = DEBUG_NONE\n\n\ndef setLogger(userLogger):\n    global _LOG\n\n    if userLogger:\n        _LOG = userLogger\n    else:\n        _LOG = DEBUG_NONE\n\n    # Update registered logging clients\n    for module, (name, flags) in LOGGEE_MAP.items():\n        setattr(module, name, _LOG & flags and _LOG or DEBUG_NONE)\n\n\ndef registerLoggee(module, name='LOG', flags=DEBUG_NONE):\n    LOGGEE_MAP[sys.modules[module]] = name, flags\n    setLogger(_LOG)\n    return _LOG\n\n\ndef hexdump(octets):\n    return ' '.join(\n        ['%s%.2X' % (n % 16 == 0 and ('\\n%.5d: ' % n) or '', x)\n         for n, x in zip(range(len(octets)), octs2ints(octets))]\n    )\n\n\nclass Scope(object):\n    def __init__(self):\n        self._list = []\n\n    def __str__(self): return '.'.join(self._list)\n\n    def push(self, token):\n        self._list.append(token)\n\n    def pop(self):\n        return self._list.pop()\n\n\nscope = Scope()\n", "pyasn1/error.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n\n\nclass PyAsn1Error(Exception):\n    \"\"\"Base pyasn1 exception\n\n    `PyAsn1Error` is the base exception class (based on\n    :class:`Exception`) that represents all possible ASN.1 related\n    errors.\n\n    Parameters\n    ----------\n    args:\n        Opaque positional parameters\n\n    Keyword Args\n    ------------\n    kwargs:\n        Opaque keyword parameters\n\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self._args = args\n        self._kwargs = kwargs\n\n    @property\n    def context(self):\n        \"\"\"Return exception context\n\n        When exception object is created, the caller can supply some opaque\n        context for the upper layers to better understand the cause of the\n        exception.\n\n        Returns\n        -------\n        : :py:class:`dict`\n            Dict holding context specific data\n        \"\"\"\n        return self._kwargs.get('context', {})\n\n\nclass ValueConstraintError(PyAsn1Error):\n    \"\"\"ASN.1 type constraints violation exception\n\n    The `ValueConstraintError` exception indicates an ASN.1 value\n    constraint violation.\n\n    It might happen on value object instantiation (for scalar types) or on\n    serialization (for constructed types).\n    \"\"\"\n\n\nclass SubstrateUnderrunError(PyAsn1Error):\n    \"\"\"ASN.1 data structure deserialization error\n\n    The `SubstrateUnderrunError` exception indicates insufficient serialised\n    data on input of a de-serialization codec.\n    \"\"\"\n\n\nclass EndOfStreamError(SubstrateUnderrunError):\n    \"\"\"ASN.1 data structure deserialization error\n\n    The `EndOfStreamError` exception indicates the condition of the input\n    stream has been closed.\n    \"\"\"\n\n\nclass UnsupportedSubstrateError(PyAsn1Error):\n    \"\"\"Unsupported substrate type to parse as ASN.1 data.\"\"\"\n\n\nclass PyAsn1UnicodeError(PyAsn1Error, UnicodeError):\n    \"\"\"Unicode text processing error\n\n    The `PyAsn1UnicodeError` exception is a base class for errors relating to\n    unicode text de/serialization.\n\n    Apart from inheriting from :class:`PyAsn1Error`, it also inherits from\n    :class:`UnicodeError` to help the caller catching unicode-related errors.\n    \"\"\"\n    def __init__(self, message, unicode_error=None):\n        if isinstance(unicode_error, UnicodeError):\n            UnicodeError.__init__(self, *unicode_error.args)\n        PyAsn1Error.__init__(self, message)\n\n\nclass PyAsn1UnicodeDecodeError(PyAsn1UnicodeError, UnicodeDecodeError):\n    \"\"\"Unicode text decoding error\n\n    The `PyAsn1UnicodeDecodeError` exception represents a failure to\n    deserialize unicode text.\n\n    Apart from inheriting from :class:`PyAsn1UnicodeError`, it also inherits\n    from :class:`UnicodeDecodeError` to help the caller catching unicode-related\n    errors.\n    \"\"\"\n\n\nclass PyAsn1UnicodeEncodeError(PyAsn1UnicodeError, UnicodeEncodeError):\n    \"\"\"Unicode text encoding error\n\n    The `PyAsn1UnicodeEncodeError` exception represents a failure to\n    serialize unicode text.\n\n    Apart from inheriting from :class:`PyAsn1UnicodeError`, it also inherits\n    from :class:`UnicodeEncodeError` to help the caller catching\n    unicode-related errors.\n    \"\"\"\n\n\n", "pyasn1/__init__.py": "# https://www.python.org/dev/peps/pep-0396/\n__version__ = '0.6.0'\n", "pyasn1/type/constraint.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n# Original concept and code by Mike C. Fletcher.\n#\nimport sys\n\nfrom pyasn1.type import error\n\n__all__ = ['SingleValueConstraint', 'ContainedSubtypeConstraint',\n           'ValueRangeConstraint', 'ValueSizeConstraint',\n           'PermittedAlphabetConstraint', 'InnerTypeConstraint',\n           'ConstraintsExclusion', 'ConstraintsIntersection',\n           'ConstraintsUnion']\n\n\nclass AbstractConstraint(object):\n\n    def __init__(self, *values):\n        self._valueMap = set()\n        self._setValues(values)\n        self.__hash = hash((self.__class__.__name__, self._values))\n\n    def __call__(self, value, idx=None):\n        if not self._values:\n            return\n\n        try:\n            self._testValue(value, idx)\n\n        except error.ValueConstraintError:\n            raise error.ValueConstraintError(\n                '%s failed at: %r' % (self, sys.exc_info()[1])\n            )\n\n    def __repr__(self):\n        representation = '%s object' % (self.__class__.__name__)\n\n        if self._values:\n            representation += ', consts %s' % ', '.join(\n                [repr(x) for x in self._values])\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other and True or self._values == other\n\n    def __ne__(self, other):\n        return self._values != other\n\n    def __lt__(self, other):\n        return self._values < other\n\n    def __le__(self, other):\n        return self._values <= other\n\n    def __gt__(self, other):\n        return self._values > other\n\n    def __ge__(self, other):\n        return self._values >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._values and True or False\n    else:\n        def __bool__(self):\n            return self._values and True or False\n\n    def __hash__(self):\n        return self.__hash\n\n    def _setValues(self, values):\n        self._values = values\n\n    def _testValue(self, value, idx):\n        raise error.ValueConstraintError(value)\n\n    # Constraints derivation logic\n    def getValueMap(self):\n        return self._valueMap\n\n    def isSuperTypeOf(self, otherConstraint):\n        # TODO: fix possible comparison of set vs scalars here\n        return (otherConstraint is self or\n                not self._values or\n                otherConstraint == self or\n                self in otherConstraint.getValueMap())\n\n    def isSubTypeOf(self, otherConstraint):\n        return (otherConstraint is self or\n                not self or\n                otherConstraint == self or\n                otherConstraint in self._valueMap)\n\n\nclass SingleValueConstraint(AbstractConstraint):\n    \"\"\"Create a SingleValueConstraint object.\n\n    The SingleValueConstraint satisfies any value that\n    is present in the set of permitted values.\n\n    Objects of this type are iterable (emitting constraint values) and\n    can act as operands for some arithmetic operations e.g. addition\n    and subtraction. The latter can be used for combining multiple\n    SingleValueConstraint objects into one.\n\n    The SingleValueConstraint object can be applied to\n    any ASN.1 type.\n\n    Parameters\n    ----------\n    *values: :class:`int`\n        Full set of values permitted by this constraint object.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class DivisorOfSix(Integer):\n            '''\n            ASN.1 specification:\n\n            Divisor-Of-6 ::= INTEGER (1 | 2 | 3 | 6)\n            '''\n            subtypeSpec = SingleValueConstraint(1, 2, 3, 6)\n\n        # this will succeed\n        divisor_of_six = DivisorOfSix(1)\n\n        # this will raise ValueConstraintError\n        divisor_of_six = DivisorOfSix(7)\n    \"\"\"\n    def _setValues(self, values):\n        self._values = values\n        self._set = set(values)\n\n    def _testValue(self, value, idx):\n        if value not in self._set:\n            raise error.ValueConstraintError(value)\n\n    # Constrains can be merged or reduced\n\n    def __contains__(self, item):\n        return item in self._set\n\n    def __iter__(self):\n        return iter(self._set)\n\n    def __sub__(self, constraint):\n        return self.__class__(*(self._set.difference(constraint)))\n\n    def __add__(self, constraint):\n        return self.__class__(*(self._set.union(constraint)))\n\n    def __sub__(self, constraint):\n        return self.__class__(*(self._set.difference(constraint)))\n\n\nclass ContainedSubtypeConstraint(AbstractConstraint):\n    \"\"\"Create a ContainedSubtypeConstraint object.\n\n    The ContainedSubtypeConstraint satisfies any value that\n    is present in the set of permitted values and also\n    satisfies included constraints.\n\n    The ContainedSubtypeConstraint object can be applied to\n    any ASN.1 type.\n\n    Parameters\n    ----------\n    *values:\n        Full set of values and constraint objects permitted\n        by this constraint object.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class DivisorOfEighteen(Integer):\n            '''\n            ASN.1 specification:\n\n            Divisors-of-18 ::= INTEGER (INCLUDES Divisors-of-6 | 9 | 18)\n            '''\n            subtypeSpec = ContainedSubtypeConstraint(\n                SingleValueConstraint(1, 2, 3, 6), 9, 18\n            )\n\n        # this will succeed\n        divisor_of_eighteen = DivisorOfEighteen(9)\n\n        # this will raise ValueConstraintError\n        divisor_of_eighteen = DivisorOfEighteen(10)\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            if isinstance(constraint, AbstractConstraint):\n                constraint(value, idx)\n            elif value not in self._set:\n                raise error.ValueConstraintError(value)\n\n\nclass ValueRangeConstraint(AbstractConstraint):\n    \"\"\"Create a ValueRangeConstraint object.\n\n    The ValueRangeConstraint satisfies any value that\n    falls in the range of permitted values.\n\n    The ValueRangeConstraint object can only be applied\n    to :class:`~pyasn1.type.univ.Integer` and\n    :class:`~pyasn1.type.univ.Real` types.\n\n    Parameters\n    ----------\n    start: :class:`int`\n        Minimum permitted value in the range (inclusive)\n\n    end: :class:`int`\n        Maximum permitted value in the range (inclusive)\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class TeenAgeYears(Integer):\n            '''\n            ASN.1 specification:\n\n            TeenAgeYears ::= INTEGER (13 .. 19)\n            '''\n            subtypeSpec = ValueRangeConstraint(13, 19)\n\n        # this will succeed\n        teen_year = TeenAgeYears(18)\n\n        # this will raise ValueConstraintError\n        teen_year = TeenAgeYears(20)\n    \"\"\"\n    def _testValue(self, value, idx):\n        if value < self.start or value > self.stop:\n            raise error.ValueConstraintError(value)\n\n    def _setValues(self, values):\n        if len(values) != 2:\n            raise error.PyAsn1Error(\n                '%s: bad constraint values' % (self.__class__.__name__,)\n            )\n        self.start, self.stop = values\n        if self.start > self.stop:\n            raise error.PyAsn1Error(\n                '%s: screwed constraint values (start > stop): %s > %s' % (\n                    self.__class__.__name__,\n                    self.start, self.stop\n                )\n            )\n        AbstractConstraint._setValues(self, values)\n\n\nclass ValueSizeConstraint(ValueRangeConstraint):\n    \"\"\"Create a ValueSizeConstraint object.\n\n    The ValueSizeConstraint satisfies any value for\n    as long as its size falls within the range of\n    permitted sizes.\n\n    The ValueSizeConstraint object can be applied\n    to :class:`~pyasn1.type.univ.BitString`,\n    :class:`~pyasn1.type.univ.OctetString` (including\n    all :ref:`character ASN.1 types <type.char>`),\n    :class:`~pyasn1.type.univ.SequenceOf`\n    and :class:`~pyasn1.type.univ.SetOf` types.\n\n    Parameters\n    ----------\n    minimum: :class:`int`\n        Minimum permitted size of the value (inclusive)\n\n    maximum: :class:`int`\n        Maximum permitted size of the value (inclusive)\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class BaseballTeamRoster(SetOf):\n            '''\n            ASN.1 specification:\n\n            BaseballTeamRoster ::= SET SIZE (1..25) OF PlayerNames\n            '''\n            componentType = PlayerNames()\n            subtypeSpec = ValueSizeConstraint(1, 25)\n\n        # this will succeed\n        team = BaseballTeamRoster()\n        team.extend(['Jan', 'Matej'])\n        encode(team)\n\n        # this will raise ValueConstraintError\n        team = BaseballTeamRoster()\n        team.extend(['Jan'] * 26)\n        encode(team)\n\n    Note\n    ----\n    Whenever ValueSizeConstraint is applied to mutable types\n    (e.g. :class:`~pyasn1.type.univ.SequenceOf`,\n    :class:`~pyasn1.type.univ.SetOf`), constraint\n    validation only happens at the serialisation phase rather\n    than schema instantiation phase (as it is with immutable\n    types).\n    \"\"\"\n    def _testValue(self, value, idx):\n        valueSize = len(value)\n        if valueSize < self.start or valueSize > self.stop:\n            raise error.ValueConstraintError(value)\n\n\nclass PermittedAlphabetConstraint(SingleValueConstraint):\n    \"\"\"Create a PermittedAlphabetConstraint object.\n\n    The PermittedAlphabetConstraint satisfies any character\n    string for as long as all its characters are present in\n    the set of permitted characters.\n\n    Objects of this type are iterable (emitting constraint values) and\n    can act as operands for some arithmetic operations e.g. addition\n    and subtraction.\n\n    The PermittedAlphabetConstraint object can only be applied\n    to the :ref:`character ASN.1 types <type.char>` such as\n    :class:`~pyasn1.type.char.IA5String`.\n\n    Parameters\n    ----------\n    *alphabet: :class:`str`\n        Full set of characters permitted by this constraint object.\n\n    Example\n    -------\n    .. code-block:: python\n\n        class BooleanValue(IA5String):\n            '''\n            ASN.1 specification:\n\n            BooleanValue ::= IA5String (FROM ('T' | 'F'))\n            '''\n            subtypeSpec = PermittedAlphabetConstraint('T', 'F')\n\n        # this will succeed\n        truth = BooleanValue('T')\n        truth = BooleanValue('TF')\n\n        # this will raise ValueConstraintError\n        garbage = BooleanValue('TAF')\n\n    ASN.1 `FROM ... EXCEPT ...` clause can be modelled by combining multiple\n    PermittedAlphabetConstraint objects into one:\n\n    Example\n    -------\n    .. code-block:: python\n\n        class Lipogramme(IA5String):\n            '''\n            ASN.1 specification:\n\n            Lipogramme ::=\n                IA5String (FROM (ALL EXCEPT (\"e\"|\"E\")))\n            '''\n            subtypeSpec = (\n                PermittedAlphabetConstraint(*string.printable) -\n                PermittedAlphabetConstraint('e', 'E')\n            )\n\n        # this will succeed\n        lipogramme = Lipogramme('A work of fiction?')\n\n        # this will raise ValueConstraintError\n        lipogramme = Lipogramme('Eel')\n\n    Note\n    ----\n    Although `ConstraintsExclusion` object could seemingly be used for this\n    purpose, practically, for it to work, it needs to represent its operand\n    constraints as sets and intersect one with the other. That would require\n    the insight into the constraint values (and their types) that are otherwise\n    hidden inside the constraint object.\n\n    Therefore it's more practical to model `EXCEPT` clause at\n    `PermittedAlphabetConstraint` level instead.\n    \"\"\"\n    def _setValues(self, values):\n        self._values = values\n        self._set = set(values)\n\n    def _testValue(self, value, idx):\n        if not self._set.issuperset(value):\n            raise error.ValueConstraintError(value)\n\n\nclass ComponentPresentConstraint(AbstractConstraint):\n    \"\"\"Create a ComponentPresentConstraint object.\n\n    The ComponentPresentConstraint is only satisfied when the value\n    is not `None`.\n\n    The ComponentPresentConstraint object is typically used with\n    `WithComponentsConstraint`.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        present = ComponentPresentConstraint()\n\n        # this will succeed\n        present('whatever')\n\n        # this will raise ValueConstraintError\n        present(None)\n    \"\"\"\n    def _setValues(self, values):\n        self._values = ('<must be present>',)\n\n        if values:\n            raise error.PyAsn1Error('No arguments expected')\n\n    def _testValue(self, value, idx):\n        if value is None:\n            raise error.ValueConstraintError(\n                'Component is not present:')\n\n\nclass ComponentAbsentConstraint(AbstractConstraint):\n    \"\"\"Create a ComponentAbsentConstraint object.\n\n    The ComponentAbsentConstraint is only satisfied when the value\n    is `None`.\n\n    The ComponentAbsentConstraint object is typically used with\n    `WithComponentsConstraint`.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        absent = ComponentAbsentConstraint()\n\n        # this will succeed\n        absent(None)\n\n        # this will raise ValueConstraintError\n        absent('whatever')\n    \"\"\"\n    def _setValues(self, values):\n        self._values = ('<must be absent>',)\n\n        if values:\n            raise error.PyAsn1Error('No arguments expected')\n\n    def _testValue(self, value, idx):\n        if value is not None:\n            raise error.ValueConstraintError(\n                'Component is not absent: %r' % value)\n\n\nclass WithComponentsConstraint(AbstractConstraint):\n    \"\"\"Create a WithComponentsConstraint object.\n\n    The `WithComponentsConstraint` satisfies any mapping object that has\n    constrained fields present or absent, what is indicated by\n    `ComponentPresentConstraint` and `ComponentAbsentConstraint`\n    objects respectively.\n\n    The `WithComponentsConstraint` object is typically applied\n    to  :class:`~pyasn1.type.univ.Set` or\n    :class:`~pyasn1.type.univ.Sequence` types.\n\n    Parameters\n    ----------\n    *fields: :class:`tuple`\n        Zero or more tuples of (`field`, `constraint`) indicating constrained\n        fields.\n\n    Notes\n    -----\n    On top of the primary use of `WithComponentsConstraint` (ensuring presence\n    or absence of particular components of a :class:`~pyasn1.type.univ.Set` or\n    :class:`~pyasn1.type.univ.Sequence`), it is also possible to pass any other\n    constraint objects or their combinations. In case of scalar fields, these\n    constraints will be verified in addition to the constraints belonging to\n    scalar components themselves. However, formally, these additional\n    constraints do not change the type of these ASN.1 objects.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Item(Sequence):  #  Set is similar\n            '''\n            ASN.1 specification:\n\n            Item ::= SEQUENCE {\n                id    INTEGER OPTIONAL,\n                name  OCTET STRING OPTIONAL\n            } WITH COMPONENTS id PRESENT, name ABSENT | id ABSENT, name PRESENT\n            '''\n            componentType = NamedTypes(\n                OptionalNamedType('id', Integer()),\n                OptionalNamedType('name', OctetString())\n            )\n            withComponents = ConstraintsUnion(\n                WithComponentsConstraint(\n                    ('id', ComponentPresentConstraint()),\n                    ('name', ComponentAbsentConstraint())\n                ),\n                WithComponentsConstraint(\n                    ('id', ComponentAbsentConstraint()),\n                    ('name', ComponentPresentConstraint())\n                )\n            )\n\n        item = Item()\n\n        # This will succeed\n        item['id'] = 1\n\n        # This will succeed\n        item.reset()\n        item['name'] = 'John'\n\n        # This will fail (on encoding)\n        item.reset()\n        descr['id'] = 1\n        descr['name'] = 'John'\n    \"\"\"\n    def _testValue(self, value, idx):\n        for field, constraint in self._values:\n            constraint(value.get(field))\n\n    def _setValues(self, values):\n        AbstractConstraint._setValues(self, values)\n\n\n# This is a bit kludgy, meaning two op modes within a single constraint\nclass InnerTypeConstraint(AbstractConstraint):\n    \"\"\"Value must satisfy the type and presence constraints\"\"\"\n\n    def _testValue(self, value, idx):\n        if self.__singleTypeConstraint:\n            self.__singleTypeConstraint(value)\n        elif self.__multipleTypeConstraint:\n            if idx not in self.__multipleTypeConstraint:\n                raise error.ValueConstraintError(value)\n            constraint, status = self.__multipleTypeConstraint[idx]\n            if status == 'ABSENT':  # XXX presence is not checked!\n                raise error.ValueConstraintError(value)\n            constraint(value)\n\n    def _setValues(self, values):\n        self.__multipleTypeConstraint = {}\n        self.__singleTypeConstraint = None\n        for v in values:\n            if isinstance(v, tuple):\n                self.__multipleTypeConstraint[v[0]] = v[1], v[2]\n            else:\n                self.__singleTypeConstraint = v\n        AbstractConstraint._setValues(self, values)\n\n\n# Logic operations on constraints\n\nclass ConstraintsExclusion(AbstractConstraint):\n    \"\"\"Create a ConstraintsExclusion logic operator object.\n\n    The ConstraintsExclusion logic operator succeeds when the\n    value does *not* satisfy the operand constraint.\n\n    The ConstraintsExclusion object can be applied to\n    any constraint and logic operator object.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class LuckyNumber(Integer):\n            subtypeSpec = ConstraintsExclusion(\n                SingleValueConstraint(13)\n            )\n\n        # this will succeed\n        luckyNumber = LuckyNumber(12)\n\n        # this will raise ValueConstraintError\n        luckyNumber = LuckyNumber(13)\n\n    Note\n    ----\n    The `FROM ... EXCEPT ...` ASN.1 clause should be modeled by combining\n    constraint objects into one. See `PermittedAlphabetConstraint` for more\n    information.\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            try:\n                constraint(value, idx)\n\n            except error.ValueConstraintError:\n                continue\n\n            raise error.ValueConstraintError(value)\n\n    def _setValues(self, values):\n        AbstractConstraint._setValues(self, values)\n\n\nclass AbstractConstraintSet(AbstractConstraint):\n\n    def __getitem__(self, idx):\n        return self._values[idx]\n\n    def __iter__(self):\n        return iter(self._values)\n\n    def __add__(self, value):\n        return self.__class__(*(self._values + (value,)))\n\n    def __radd__(self, value):\n        return self.__class__(*((value,) + self._values))\n\n    def __len__(self):\n        return len(self._values)\n\n    # Constraints inclusion in sets\n\n    def _setValues(self, values):\n        self._values = values\n        for constraint in values:\n            if constraint:\n                self._valueMap.add(constraint)\n                self._valueMap.update(constraint.getValueMap())\n\n\nclass ConstraintsIntersection(AbstractConstraintSet):\n    \"\"\"Create a ConstraintsIntersection logic operator object.\n\n    The ConstraintsIntersection logic operator only succeeds\n    if *all* its operands succeed.\n\n    The ConstraintsIntersection object can be applied to\n    any constraint and logic operator objects.\n\n    The ConstraintsIntersection object duck-types the immutable\n    container object like Python :py:class:`tuple`.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class CapitalAndSmall(IA5String):\n            '''\n            ASN.1 specification:\n\n            CapitalAndSmall ::=\n                IA5String (FROM (\"A\"..\"Z\"|\"a\"..\"z\"))\n            '''\n            subtypeSpec = ConstraintsIntersection(\n                PermittedAlphabetConstraint('A', 'Z'),\n                PermittedAlphabetConstraint('a', 'z')\n            )\n\n        # this will succeed\n        capital_and_small = CapitalAndSmall('Hello')\n\n        # this will raise ValueConstraintError\n        capital_and_small = CapitalAndSmall('hello')\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            constraint(value, idx)\n\n\nclass ConstraintsUnion(AbstractConstraintSet):\n    \"\"\"Create a ConstraintsUnion logic operator object.\n\n    The ConstraintsUnion logic operator succeeds if\n    *at least* a single operand succeeds.\n\n    The ConstraintsUnion object can be applied to\n    any constraint and logic operator objects.\n\n    The ConstraintsUnion object duck-types the immutable\n    container object like Python :py:class:`tuple`.\n\n    Parameters\n    ----------\n    *constraints:\n        Constraint or logic operator objects.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class CapitalOrSmall(IA5String):\n            '''\n            ASN.1 specification:\n\n            CapitalOrSmall ::=\n                IA5String (FROM (\"A\"..\"Z\") | FROM (\"a\"..\"z\"))\n            '''\n            subtypeSpec = ConstraintsUnion(\n                PermittedAlphabetConstraint('A', 'Z'),\n                PermittedAlphabetConstraint('a', 'z')\n            )\n\n        # this will succeed\n        capital_or_small = CapitalAndSmall('Hello')\n\n        # this will raise ValueConstraintError\n        capital_or_small = CapitalOrSmall('hello!')\n    \"\"\"\n    def _testValue(self, value, idx):\n        for constraint in self._values:\n            try:\n                constraint(value, idx)\n            except error.ValueConstraintError:\n                pass\n            else:\n                return\n\n        raise error.ValueConstraintError(\n            'all of %s failed for \"%s\"' % (self._values, value)\n        )\n\n# TODO:\n# refactor InnerTypeConstraint\n# add tests for type check\n# implement other constraint types\n# make constraint validation easy to skip\n", "pyasn1/type/tagmap.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\n\n__all__ = ['TagMap']\n\n\nclass TagMap(object):\n    \"\"\"Map *TagSet* objects to ASN.1 types\n\n    Create an object mapping *TagSet* object to ASN.1 type.\n\n    *TagMap* objects are immutable and duck-type read-only Python\n    :class:`dict` objects holding *TagSet* objects as keys and ASN.1\n    type objects as values.\n\n    Parameters\n    ----------\n    presentTypes: :py:class:`dict`\n        Map of :class:`~pyasn1.type.tag.TagSet` to ASN.1 objects considered\n        as being unconditionally present in the *TagMap*.\n\n    skipTypes: :py:class:`dict`\n        A collection of :class:`~pyasn1.type.tag.TagSet` objects considered\n        as absent in the *TagMap* even when *defaultType* is present.\n\n    defaultType: ASN.1 type object\n        An ASN.1 type object callee *TagMap* returns for any *TagSet* key not present\n        in *presentTypes* (unless given key is present in *skipTypes*).\n    \"\"\"\n    def __init__(self, presentTypes=None, skipTypes=None, defaultType=None):\n        self.__presentTypes = presentTypes or {}\n        self.__skipTypes = skipTypes or {}\n        self.__defaultType = defaultType\n\n    def __contains__(self, tagSet):\n        return (tagSet in self.__presentTypes or\n                self.__defaultType is not None and tagSet not in self.__skipTypes)\n\n    def __getitem__(self, tagSet):\n        try:\n            return self.__presentTypes[tagSet]\n        except KeyError:\n            if self.__defaultType is None:\n                raise KeyError()\n            elif tagSet in self.__skipTypes:\n                raise error.PyAsn1Error('Key in negative map')\n            else:\n                return self.__defaultType\n\n    def __iter__(self):\n        return iter(self.__presentTypes)\n\n    def __repr__(self):\n        representation = '%s object' % self.__class__.__name__\n\n        if self.__presentTypes:\n            representation += ', present %s' % repr(self.__presentTypes)\n\n        if self.__skipTypes:\n            representation += ', skip %s' % repr(self.__skipTypes)\n\n        if self.__defaultType is not None:\n            representation += ', default %s' % repr(self.__defaultType)\n\n        return '<%s>' % representation\n\n    @property\n    def presentTypes(self):\n        \"\"\"Return *TagSet* to ASN.1 type map present in callee *TagMap*\"\"\"\n        return self.__presentTypes\n\n    @property\n    def skipTypes(self):\n        \"\"\"Return *TagSet* collection unconditionally absent in callee *TagMap*\"\"\"\n        return self.__skipTypes\n\n    @property\n    def defaultType(self):\n        \"\"\"Return default ASN.1 type being returned for any missing *TagSet*\"\"\"\n        return self.__defaultType\n\n    # Backward compatibility\n\n    def getPosMap(self):\n        return self.presentTypes\n\n    def getNegMap(self):\n        return self.skipTypes\n\n    def getDef(self):\n        return self.defaultType\n", "pyasn1/type/useful.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport datetime\n\nfrom pyasn1 import error\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\n\n__all__ = ['ObjectDescriptor', 'GeneralizedTime', 'UTCTime']\n\nNoValue = univ.NoValue\nnoValue = univ.noValue\n\n\nclass ObjectDescriptor(char.GraphicString):\n    __doc__ = char.GraphicString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.GraphicString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 7)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.GraphicString.getTypeId()\n\n\nclass TimeMixIn(object):\n\n    _yearsDigits = 4\n    _hasSubsecond = False\n    _optionalMinutes = False\n    _shortTZ = False\n\n    class FixedOffset(datetime.tzinfo):\n        \"\"\"Fixed offset in minutes east from UTC.\"\"\"\n\n        # defaulted arguments required\n        # https: // docs.python.org / 2.3 / lib / datetime - tzinfo.html\n        def __init__(self, offset=0, name='UTC'):\n            self.__offset = datetime.timedelta(minutes=offset)\n            self.__name = name\n\n        def utcoffset(self, dt):\n            return self.__offset\n\n        def tzname(self, dt):\n            return self.__name\n\n        def dst(self, dt):\n            return datetime.timedelta(0)\n\n    UTC = FixedOffset()\n\n    @property\n    def asDateTime(self):\n        \"\"\"Create :py:class:`datetime.datetime` object from a |ASN.1| object.\n\n        Returns\n        -------\n        :\n            new instance of :py:class:`datetime.datetime` object\n        \"\"\"\n        text = str(self)\n        if text.endswith('Z'):\n            tzinfo = TimeMixIn.UTC\n            text = text[:-1]\n\n        elif '-' in text or '+' in text:\n            if '+' in text:\n                text, plusminus, tz = text.partition('+')\n            else:\n                text, plusminus, tz = text.partition('-')\n\n            if self._shortTZ and len(tz) == 2:\n                tz += '00'\n\n            if len(tz) != 4:\n                raise error.PyAsn1Error('malformed time zone offset %s' % tz)\n\n            try:\n                minutes = int(tz[:2]) * 60 + int(tz[2:])\n                if plusminus == '-':\n                    minutes *= -1\n\n            except ValueError:\n                raise error.PyAsn1Error('unknown time specification %s' % self)\n\n            tzinfo = TimeMixIn.FixedOffset(minutes, '?')\n\n        else:\n            tzinfo = None\n\n        if '.' in text or ',' in text:\n            if '.' in text:\n                text, _, ms = text.partition('.')\n            else:\n                text, _, ms = text.partition(',')\n\n            try:\n                ms = int(ms) * 1000\n\n            except ValueError:\n                raise error.PyAsn1Error('bad sub-second time specification %s' % self)\n\n        else:\n            ms = 0\n\n        if self._optionalMinutes and len(text) - self._yearsDigits == 6:\n            text += '0000'\n        elif len(text) - self._yearsDigits == 8:\n            text += '00'\n\n        try:\n            dt = datetime.datetime.strptime(text, self._yearsDigits == 4 and '%Y%m%d%H%M%S' or '%y%m%d%H%M%S')\n\n        except ValueError:\n            raise error.PyAsn1Error('malformed datetime format %s' % self)\n\n        return dt.replace(microsecond=ms, tzinfo=tzinfo)\n\n    @classmethod\n    def fromDateTime(cls, dt):\n        \"\"\"Create |ASN.1| object from a :py:class:`datetime.datetime` object.\n\n        Parameters\n        ----------\n        dt: :py:class:`datetime.datetime` object\n            The `datetime.datetime` object to initialize the |ASN.1| object\n            from\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| value\n        \"\"\"\n        text = dt.strftime(cls._yearsDigits == 4 and '%Y%m%d%H%M%S' or '%y%m%d%H%M%S')\n        if cls._hasSubsecond:\n            text += '.%d' % (dt.microsecond // 1000)\n\n        if dt.utcoffset():\n            seconds = dt.utcoffset().seconds\n            if seconds < 0:\n                text += '-'\n            else:\n                text += '+'\n            text += '%.2d%.2d' % (seconds // 3600, seconds % 3600)\n        else:\n            text += 'Z'\n\n        return cls(text)\n\n\nclass GeneralizedTime(char.VisibleString, TimeMixIn):\n    __doc__ = char.VisibleString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.VisibleString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 24)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.VideotexString.getTypeId()\n\n    _yearsDigits = 4\n    _hasSubsecond = True\n    _optionalMinutes = True\n    _shortTZ = True\n\n\nclass UTCTime(char.VisibleString, TimeMixIn):\n    __doc__ = char.VisibleString.__doc__\n\n    #: Default :py:class:`~pyasn1.type.tag.TagSet` object for |ASN.1| objects\n    tagSet = char.VisibleString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 23)\n    )\n\n    # Optimization for faster codec lookup\n    typeId = char.VideotexString.getTypeId()\n\n    _yearsDigits = 2\n    _hasSubsecond = False\n    _optionalMinutes = False\n    _shortTZ = False\n", "pyasn1/type/tag.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\n\n__all__ = ['tagClassUniversal', 'tagClassApplication', 'tagClassContext',\n           'tagClassPrivate', 'tagFormatSimple', 'tagFormatConstructed',\n           'tagCategoryImplicit', 'tagCategoryExplicit',\n           'tagCategoryUntagged', 'Tag', 'TagSet']\n\n#: Identifier for ASN.1 class UNIVERSAL\ntagClassUniversal = 0x00\n\n#: Identifier for ASN.1 class APPLICATION\ntagClassApplication = 0x40\n\n#: Identifier for ASN.1 class context-specific\ntagClassContext = 0x80\n\n#: Identifier for ASN.1 class private\ntagClassPrivate = 0xC0\n\n#: Identifier for \"simple\" ASN.1 structure (e.g. scalar)\ntagFormatSimple = 0x00\n\n#: Identifier for \"constructed\" ASN.1 structure (e.g. may have inner components)\ntagFormatConstructed = 0x20\n\ntagCategoryImplicit = 0x01\ntagCategoryExplicit = 0x02\ntagCategoryUntagged = 0x04\n\n\nclass Tag(object):\n    \"\"\"Create ASN.1 tag\n\n    Represents ASN.1 tag that can be attached to a ASN.1 type to make\n    types distinguishable from each other.\n\n    *Tag* objects are immutable and duck-type Python :class:`tuple` objects\n    holding three integer components of a tag.\n\n    Parameters\n    ----------\n    tagClass: :py:class:`int`\n        Tag *class* value\n\n    tagFormat: :py:class:`int`\n        Tag *format* value\n\n    tagId: :py:class:`int`\n        Tag ID value\n    \"\"\"\n    def __init__(self, tagClass, tagFormat, tagId):\n        if tagId < 0:\n            raise error.PyAsn1Error('Negative tag ID (%s) not allowed' % tagId)\n        self.__tagClass = tagClass\n        self.__tagFormat = tagFormat\n        self.__tagId = tagId\n        self.__tagClassId = tagClass, tagId\n        self.__hash = hash(self.__tagClassId)\n\n    def __repr__(self):\n        representation = '[%s:%s:%s]' % (\n            self.__tagClass, self.__tagFormat, self.__tagId)\n        return '<%s object, tag %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__tagClassId == other\n\n    def __ne__(self, other):\n        return self.__tagClassId != other\n\n    def __lt__(self, other):\n        return self.__tagClassId < other\n\n    def __le__(self, other):\n        return self.__tagClassId <= other\n\n    def __gt__(self, other):\n        return self.__tagClassId > other\n\n    def __ge__(self, other):\n        return self.__tagClassId >= other\n\n    def __hash__(self):\n        return self.__hash\n\n    def __getitem__(self, idx):\n        if idx == 0:\n            return self.__tagClass\n        elif idx == 1:\n            return self.__tagFormat\n        elif idx == 2:\n            return self.__tagId\n        else:\n            raise IndexError()\n\n    def __iter__(self):\n        yield self.__tagClass\n        yield self.__tagFormat\n        yield self.__tagId\n\n    def __and__(self, otherTag):\n        return self.__class__(self.__tagClass & otherTag.tagClass,\n                              self.__tagFormat & otherTag.tagFormat,\n                              self.__tagId & otherTag.tagId)\n\n    def __or__(self, otherTag):\n        return self.__class__(self.__tagClass | otherTag.tagClass,\n                              self.__tagFormat | otherTag.tagFormat,\n                              self.__tagId | otherTag.tagId)\n\n    @property\n    def tagClass(self):\n        \"\"\"ASN.1 tag class\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag class\n        \"\"\"\n        return self.__tagClass\n\n    @property\n    def tagFormat(self):\n        \"\"\"ASN.1 tag format\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag format\n        \"\"\"\n        return self.__tagFormat\n\n    @property\n    def tagId(self):\n        \"\"\"ASN.1 tag ID\n\n        Returns\n        -------\n        : :py:class:`int`\n            Tag ID\n        \"\"\"\n        return self.__tagId\n\n\nclass TagSet(object):\n    \"\"\"Create a collection of ASN.1 tags\n\n    Represents a combination of :class:`~pyasn1.type.tag.Tag` objects\n    that can be attached to a ASN.1 type to make types distinguishable\n    from each other.\n\n    *TagSet* objects are immutable and duck-type Python :class:`tuple` objects\n    holding arbitrary number of :class:`~pyasn1.type.tag.Tag` objects.\n\n    Parameters\n    ----------\n    baseTag: :class:`~pyasn1.type.tag.Tag`\n        Base *Tag* object. This tag survives IMPLICIT tagging.\n\n    *superTags: :class:`~pyasn1.type.tag.Tag`\n        Additional *Tag* objects taking part in subtyping.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class OrderNumber(NumericString):\n            '''\n            ASN.1 specification\n\n            Order-number ::=\n                [APPLICATION 5] IMPLICIT NumericString\n            '''\n            tagSet = NumericString.tagSet.tagImplicitly(\n                Tag(tagClassApplication, tagFormatSimple, 5)\n            )\n\n        orderNumber = OrderNumber('1234')\n    \"\"\"\n    def __init__(self, baseTag=(), *superTags):\n        self.__baseTag = baseTag\n        self.__superTags = superTags\n        self.__superTagsClassId = tuple(\n            [(superTag.tagClass, superTag.tagId) for superTag in superTags]\n        )\n        self.__lenOfSuperTags = len(superTags)\n        self.__hash = hash(self.__superTagsClassId)\n\n    def __repr__(self):\n        representation = '-'.join(['%s:%s:%s' % (x.tagClass, x.tagFormat, x.tagId)\n                                   for x in self.__superTags])\n        if representation:\n            representation = 'tags ' + representation\n        else:\n            representation = 'untagged'\n\n        return '<%s object, %s>' % (self.__class__.__name__, representation)\n\n    def __add__(self, superTag):\n        return self.__class__(self.__baseTag, *self.__superTags + (superTag,))\n\n    def __radd__(self, superTag):\n        return self.__class__(self.__baseTag, *(superTag,) + self.__superTags)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.__class__(self.__baseTag, *self.__superTags[i])\n        else:\n            return self.__superTags[i]\n\n    def __eq__(self, other):\n        return self.__superTagsClassId == other\n\n    def __ne__(self, other):\n        return self.__superTagsClassId != other\n\n    def __lt__(self, other):\n        return self.__superTagsClassId < other\n\n    def __le__(self, other):\n        return self.__superTagsClassId <= other\n\n    def __gt__(self, other):\n        return self.__superTagsClassId > other\n\n    def __ge__(self, other):\n        return self.__superTagsClassId >= other\n\n    def __hash__(self):\n        return self.__hash\n\n    def __len__(self):\n        return self.__lenOfSuperTags\n\n    @property\n    def baseTag(self):\n        \"\"\"Return base ASN.1 tag\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.Tag`\n            Base tag of this *TagSet*\n        \"\"\"\n        return self.__baseTag\n\n    @property\n    def superTags(self):\n        \"\"\"Return ASN.1 tags\n\n        Returns\n        -------\n        : :py:class:`tuple`\n            Tuple of :class:`~pyasn1.type.tag.Tag` objects that this *TagSet* contains\n        \"\"\"\n        return self.__superTags\n\n    def tagExplicitly(self, superTag):\n        \"\"\"Return explicitly tagged *TagSet*\n\n        Create a new *TagSet* representing callee *TagSet* explicitly tagged\n        with passed tag(s). With explicit tagging mode, new tags are appended\n        to existing tag(s).\n\n        Parameters\n        ----------\n        superTag: :class:`~pyasn1.type.tag.Tag`\n            *Tag* object to tag this *TagSet*\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.TagSet`\n            New *TagSet* object\n        \"\"\"\n        if superTag.tagClass == tagClassUniversal:\n            raise error.PyAsn1Error(\"Can't tag with UNIVERSAL class tag\")\n        if superTag.tagFormat != tagFormatConstructed:\n            superTag = Tag(superTag.tagClass, tagFormatConstructed, superTag.tagId)\n        return self + superTag\n\n    def tagImplicitly(self, superTag):\n        \"\"\"Return implicitly tagged *TagSet*\n\n        Create a new *TagSet* representing callee *TagSet* implicitly tagged\n        with passed tag(s). With implicit tagging mode, new tag(s) replace the\n        last existing tag.\n\n        Parameters\n        ----------\n        superTag: :class:`~pyasn1.type.tag.Tag`\n            *Tag* object to tag this *TagSet*\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tag.TagSet`\n            New *TagSet* object\n        \"\"\"\n        if self.__superTags:\n            superTag = Tag(superTag.tagClass, self.__superTags[-1].tagFormat, superTag.tagId)\n        return self[:-1] + superTag\n\n    def isSuperTagSetOf(self, tagSet):\n        \"\"\"Test type relationship against given *TagSet*\n\n        The callee is considered to be a supertype of given *TagSet*\n        tag-wise if all tags in *TagSet* are present in the callee and\n        they are in the same order.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pyasn1.type.tag.TagSet`\n            *TagSet* object to evaluate against the callee\n\n        Returns\n        -------\n        : :py:class:`bool`\n            :obj:`True` if callee is a supertype of *tagSet*\n        \"\"\"\n        if len(tagSet) < self.__lenOfSuperTags:\n            return False\n        return self.__superTags == tagSet[:self.__lenOfSuperTags]\n\n    # Backward compatibility\n\n    def getBaseTag(self):\n        return self.__baseTag\n\ndef initTagSet(tag):\n    return TagSet(tag, tag)\n", "pyasn1/type/base.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import constraint\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\n__all__ = ['Asn1Item', 'Asn1Type', 'SimpleAsn1Type',\n           'ConstructedAsn1Type']\n\n\nclass Asn1Item(object):\n    @classmethod\n    def getTypeId(cls, increment=1):\n        try:\n            Asn1Item._typeCounter += increment\n        except AttributeError:\n            Asn1Item._typeCounter = increment\n        return Asn1Item._typeCounter\n\n\nclass Asn1Type(Asn1Item):\n    \"\"\"Base class for all classes representing ASN.1 types.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n    #: Set or return a :py:class:`~pyasn1.type.tag.TagSet` object representing\n    #: ASN.1 tag(s) associated with |ASN.1| type.\n    tagSet = tag.TagSet()\n\n    #: Default :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n    #: object imposing constraints on initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = None\n\n    def __init__(self, **kwargs):\n        readOnly = {\n            'tagSet': self.tagSet,\n            'subtypeSpec': self.subtypeSpec\n        }\n\n        readOnly.update(kwargs)\n\n        self.__dict__.update(readOnly)\n\n        self._readOnly = readOnly\n\n    def __setattr__(self, name, value):\n        if name[0] != '_' and name in self._readOnly:\n            raise error.PyAsn1Error('read-only instance attribute \"%s\"' % name)\n\n        self.__dict__[name] = value\n\n    def __str__(self):\n        return self.prettyPrint()\n\n    @property\n    def readOnly(self):\n        return self._readOnly\n\n    @property\n    def effectiveTagSet(self):\n        \"\"\"For |ASN.1| type is equivalent to *tagSet*\n        \"\"\"\n        return self.tagSet  # used by untagged types\n\n    @property\n    def tagMap(self):\n        \"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping ASN.1 tags to ASN.1 objects within callee object.\n        \"\"\"\n        return tagmap.TagMap({self.tagSet: self})\n\n    def isSameTypeWith(self, other, matchTags=True, matchConstraints=True):\n        \"\"\"Examine |ASN.1| type for equality with other ASN.1 type.\n\n        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints\n        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying\n        out ASN.1 types comparison.\n\n        Python class inheritance relationship is NOT considered.\n\n        Parameters\n        ----------\n        other: a pyasn1 type object\n            Class instance representing ASN.1 type.\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if *other* is |ASN.1| type,\n            :obj:`False` otherwise.\n        \"\"\"\n        return (self is other or\n                (not matchTags or self.tagSet == other.tagSet) and\n                (not matchConstraints or self.subtypeSpec == other.subtypeSpec))\n\n    def isSuperTypeOf(self, other, matchTags=True, matchConstraints=True):\n        \"\"\"Examine |ASN.1| type for subtype relationship with other ASN.1 type.\n\n        ASN.1 tags (:py:mod:`~pyasn1.type.tag`) and constraints\n        (:py:mod:`~pyasn1.type.constraint`) are examined when carrying\n        out ASN.1 types comparison.\n\n        Python class inheritance relationship is NOT considered.\n\n        Parameters\n        ----------\n            other: a pyasn1 type object\n                Class instance representing ASN.1 type.\n\n        Returns\n        -------\n            : :class:`bool`\n                :obj:`True` if *other* is a subtype of |ASN.1| type,\n                :obj:`False` otherwise.\n        \"\"\"\n        return (not matchTags or\n                (self.tagSet.isSuperTagSetOf(other.tagSet)) and\n                 (not matchConstraints or self.subtypeSpec.isSuperTypeOf(other.subtypeSpec)))\n\n    @staticmethod\n    def isNoValue(*values):\n        for value in values:\n            if value is not noValue:\n                return False\n        return True\n\n    def prettyPrint(self, scope=0):\n        raise NotImplementedError()\n\n    # backward compatibility\n\n    def getTagSet(self):\n        return self.tagSet\n\n    def getEffectiveTagSet(self):\n        return self.effectiveTagSet\n\n    def getTagMap(self):\n        return self.tagMap\n\n    def getSubtypeSpec(self):\n        return self.subtypeSpec\n\n    # backward compatibility\n    def hasValue(self):\n        return self.isValue\n\n# Backward compatibility\nAsn1ItemBase = Asn1Type\n\n\nclass NoValue(object):\n    \"\"\"Create a singleton instance of NoValue class.\n\n    The *NoValue* sentinel object represents an instance of ASN.1 schema\n    object as opposed to ASN.1 value object.\n\n    Only ASN.1 schema-related operations can be performed on ASN.1\n    schema objects.\n\n    Warning\n    -------\n    Any operation attempted on the *noValue* object will raise the\n    *PyAsn1Error* exception.\n    \"\"\"\n    skipMethods = {\n        '__slots__',\n        # attributes\n        '__getattribute__',\n        '__getattr__',\n        '__setattr__',\n        '__delattr__',\n        # class instance\n        '__class__',\n        '__init__',\n        '__del__',\n        '__new__',\n        '__repr__',\n        '__qualname__',\n        '__objclass__',\n        'im_class',\n        '__sizeof__',\n        # pickle protocol\n        '__reduce__',\n        '__reduce_ex__',\n        '__getnewargs__',\n        '__getinitargs__',\n        '__getstate__',\n        '__setstate__',\n    }\n\n    _instance = None\n\n    def __new__(cls):\n        if cls._instance is None:\n            def getPlug(name):\n                def plug(self, *args, **kw):\n                    raise error.PyAsn1Error('Attempted \"%s\" operation on ASN.1 schema object' % name)\n                return plug\n\n            op_names = [name\n                        for typ in (str, int, list, dict)\n                        for name in dir(typ)\n                        if (name not in cls.skipMethods and\n                            name.startswith('__') and\n                            name.endswith('__') and\n                            callable(getattr(typ, name)))]\n\n            for name in set(op_names):\n                setattr(cls, name, getPlug(name))\n\n            cls._instance = object.__new__(cls)\n\n        return cls._instance\n\n    def __getattr__(self, attr):\n        if attr in self.skipMethods:\n            raise AttributeError('Attribute %s not present' % attr)\n\n        raise error.PyAsn1Error('Attempted \"%s\" operation on ASN.1 schema object' % attr)\n\n    def __repr__(self):\n        return '<%s object>' % self.__class__.__name__\n\n\nnoValue = NoValue()\n\n\nclass SimpleAsn1Type(Asn1Type):\n    \"\"\"Base class for all simple classes representing ASN.1 types.\n\n    ASN.1 distinguishes types by their ability to hold other objects.\n    Scalar types are known as *simple* in ASN.1.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n    #: Default payload value\n    defaultValue = noValue\n\n    def __init__(self, value=noValue, **kwargs):\n        Asn1Type.__init__(self, **kwargs)\n        if value is noValue:\n            value = self.defaultValue\n        else:\n            value = self.prettyIn(value)\n            try:\n                self.subtypeSpec(value)\n\n            except error.PyAsn1Error:\n                exType, exValue, exTb = sys.exc_info()\n                raise exType('%s at %s' % (exValue, self.__class__.__name__))\n\n        self._value = value\n\n    def __repr__(self):\n        representation = '%s %s object' % (\n            self.__class__.__name__, self.isValue and 'value' or 'schema')\n\n        for attr, value in self.readOnly.items():\n            if value:\n                representation += ', %s %s' % (attr, value)\n\n        if self.isValue:\n            value = self.prettyPrint()\n            if len(value) > 32:\n                value = value[:16] + '...' + value[-16:]\n            representation += ', payload [%s]' % value\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other and True or self._value == other\n\n    def __ne__(self, other):\n        return self._value != other\n\n    def __lt__(self, other):\n        return self._value < other\n\n    def __le__(self, other):\n        return self._value <= other\n\n    def __gt__(self, other):\n        return self._value > other\n\n    def __ge__(self, other):\n        return self._value >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._value and True or False\n    else:\n        def __bool__(self):\n            return self._value and True or False\n\n    def __hash__(self):\n        return hash(self._value)\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just\n        ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema\n        features, this object can also be used like a Python built-in object\n        (e.g. :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        return self._value is not noValue\n\n    def clone(self, value=noValue, **kwargs):\n        \"\"\"Create a modified version of |ASN.1| schema or value object.\n\n        The `clone()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all arguments\n        of the `clone()` method are optional.\n\n        Whatever arguments are supplied, they are used to create a copy\n        of `self` taking precedence over the ones used to instantiate `self`.\n\n        Note\n        ----\n        Due to the immutable nature of the |ASN.1| object, if no arguments\n        are supplied, no new |ASN.1| object will be created and `self` will\n        be returned instead.\n        \"\"\"\n        if value is noValue:\n            if not kwargs:\n                return self\n\n            value = self._value\n\n        initializers = self.readOnly.copy()\n        initializers.update(kwargs)\n\n        return self.__class__(value, **initializers)\n\n    def subtype(self, value=noValue, **kwargs):\n        \"\"\"Create a specialization of |ASN.1| schema or value object.\n\n        The subtype relationship between ASN.1 types has no correlation with\n        subtype relationship between Python types. ASN.1 type is mainly identified\n        by its tag(s) (:py:class:`~pyasn1.type.tag.TagSet`) and value range\n        constraints (:py:class:`~pyasn1.type.constraint.ConstraintsIntersection`).\n        These ASN.1 type properties are implemented as |ASN.1| attributes.  \n\n        The `subtype()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all parameters\n        of the `subtype()` method are optional.\n\n        With the exception of the arguments described below, the rest of\n        supplied arguments they are used to create a copy of `self` taking\n        precedence over the ones used to instantiate `self`.\n\n        The following arguments to `subtype()` create a ASN.1 subtype out of\n        |ASN.1| type:\n\n        Other Parameters\n        ----------------\n        implicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Implicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        explicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Explicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n            Add ASN.1 constraints object to one of the `self`'s, then\n            use the result as new object's ASN.1 constraints.\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| schema or value object\n\n        Note\n        ----\n        Due to the immutable nature of the |ASN.1| object, if no arguments\n        are supplied, no new |ASN.1| object will be created and `self` will\n        be returned instead.\n        \"\"\"\n        if value is noValue:\n            if not kwargs:\n                return self\n\n            value = self._value\n\n        initializers = self.readOnly.copy()\n\n        implicitTag = kwargs.pop('implicitTag', None)\n        if implicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagImplicitly(implicitTag)\n\n        explicitTag = kwargs.pop('explicitTag', None)\n        if explicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagExplicitly(explicitTag)\n\n        for arg, option in kwargs.items():\n            initializers[arg] += option\n\n        return self.__class__(value, **initializers)\n\n    def prettyIn(self, value):\n        return value\n\n    def prettyOut(self, value):\n        return str(value)\n\n    def prettyPrint(self, scope=0):\n        return self.prettyOut(self._value)\n\n    def prettyPrintType(self, scope=0):\n        return '%s -> %s' % (self.tagSet, self.__class__.__name__)\n\n# Backward compatibility\nAbstractSimpleAsn1Item = SimpleAsn1Type\n\n#\n# Constructed types:\n# * There are five of them: Sequence, SequenceOf/SetOf, Set and Choice\n# * ASN1 types and values are represened by Python class instances\n# * Value initialization is made for defaulted components only\n# * Primary method of component addressing is by-position. Data model for base\n#   type is Python sequence. Additional type-specific addressing methods\n#   may be implemented for particular types.\n# * SequenceOf and SetOf types do not implement any additional methods\n# * Sequence, Set and Choice types also implement by-identifier addressing\n# * Sequence, Set and Choice types also implement by-asn1-type (tag) addressing\n# * Sequence and Set types may include optional and defaulted\n#   components\n# * Constructed types hold a reference to component types used for value\n#   verification and ordering.\n# * Component type is a scalar type for SequenceOf/SetOf types and a list\n#   of types for Sequence/Set/Choice.\n#\n\n\nclass ConstructedAsn1Type(Asn1Type):\n    \"\"\"Base class for all constructed classes representing ASN.1 types.\n\n    ASN.1 distinguishes types by their ability to hold other objects.\n    Those \"nesting\" types are known as *constructed* in ASN.1.\n\n    In the user code, |ASN.1| class is normally used only for telling\n    ASN.1 objects from others.\n\n    Note\n    ----\n    For as long as ASN.1 is concerned, a way to compare ASN.1 types\n    is to use :meth:`isSameTypeWith` and :meth:`isSuperTypeOf` methods.\n    \"\"\"\n\n    #: If :obj:`True`, requires exact component type matching,\n    #: otherwise subtype relation is only enforced\n    strictConstraints = False\n\n    componentType = None\n\n    # backward compatibility, unused\n    sizeSpec = constraint.ConstraintsIntersection()\n\n    def __init__(self, **kwargs):\n        readOnly = {\n            'componentType': self.componentType,\n            # backward compatibility, unused\n            'sizeSpec': self.sizeSpec\n        }\n\n        # backward compatibility: preserve legacy sizeSpec support\n        kwargs = self._moveSizeSpec(**kwargs)\n\n        readOnly.update(kwargs)\n\n        Asn1Type.__init__(self, **readOnly)\n\n    def _moveSizeSpec(self, **kwargs):\n        # backward compatibility, unused\n        sizeSpec = kwargs.pop('sizeSpec', self.sizeSpec)\n        if sizeSpec:\n            subtypeSpec = kwargs.pop('subtypeSpec', self.subtypeSpec)\n            if subtypeSpec:\n                subtypeSpec = sizeSpec\n\n            else:\n                subtypeSpec += sizeSpec\n\n            kwargs['subtypeSpec'] = subtypeSpec\n\n        return kwargs\n\n    def __repr__(self):\n        representation = '%s %s object' % (\n            self.__class__.__name__, self.isValue and 'value' or 'schema'\n        )\n\n        for attr, value in self.readOnly.items():\n            if value is not noValue:\n                representation += ', %s=%r' % (attr, value)\n\n        if self.isValue and self.components:\n            representation += ', payload [%s]' % ', '.join(\n                [repr(x) for x in self.components])\n\n        return '<%s>' % representation\n\n    def __eq__(self, other):\n        return self is other or self.components == other\n\n    def __ne__(self, other):\n        return self.components != other\n\n    def __lt__(self, other):\n        return self.components < other\n\n    def __le__(self, other):\n        return self.components <= other\n\n    def __gt__(self, other):\n        return self.components > other\n\n    def __ge__(self, other):\n        return self.components >= other\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return bool(self.components)\n    else:\n        def __bool__(self):\n            return bool(self.components)\n\n    @property\n    def components(self):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        pass\n\n    def clone(self, **kwargs):\n        \"\"\"Create a modified version of |ASN.1| schema object.\n\n        The `clone()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all arguments\n        of the `clone()` method are optional.\n\n        Whatever arguments are supplied, they are used to create a copy\n        of `self` taking precedence over the ones used to instantiate `self`.\n\n        Possible values of `self` are never copied over thus `clone()` can\n        only create a new schema object.\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| type/value\n\n        Note\n        ----\n        Due to the mutable nature of the |ASN.1| object, even if no arguments\n        are supplied, a new |ASN.1| object will be created and returned.\n        \"\"\"\n        cloneValueFlag = kwargs.pop('cloneValueFlag', False)\n\n        initializers = self.readOnly.copy()\n        initializers.update(kwargs)\n\n        clone = self.__class__(**initializers)\n\n        if cloneValueFlag:\n            self._cloneComponentValues(clone, cloneValueFlag)\n\n        return clone\n\n    def subtype(self, **kwargs):\n        \"\"\"Create a specialization of |ASN.1| schema object.\n\n        The `subtype()` method accepts the same set arguments as |ASN.1|\n        class takes on instantiation except that all parameters\n        of the `subtype()` method are optional.\n\n        With the exception of the arguments described below, the rest of\n        supplied arguments they are used to create a copy of `self` taking\n        precedence over the ones used to instantiate `self`.\n\n        The following arguments to `subtype()` create a ASN.1 subtype out of\n        |ASN.1| type.\n\n        Other Parameters\n        ----------------\n        implicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Implicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        explicitTag: :py:class:`~pyasn1.type.tag.Tag`\n            Explicitly apply given ASN.1 tag object to `self`'s\n            :py:class:`~pyasn1.type.tag.TagSet`, then use the result as\n            new object's ASN.1 tag(s).\n\n        subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n            Add ASN.1 constraints object to one of the `self`'s, then\n            use the result as new object's ASN.1 constraints.\n\n\n        Returns\n        -------\n        :\n            new instance of |ASN.1| type/value\n\n        Note\n        ----\n        Due to the mutable nature of the |ASN.1| object, even if no arguments\n        are supplied, a new |ASN.1| object will be created and returned.\n        \"\"\"\n\n        initializers = self.readOnly.copy()\n\n        cloneValueFlag = kwargs.pop('cloneValueFlag', False)\n\n        implicitTag = kwargs.pop('implicitTag', None)\n        if implicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagImplicitly(implicitTag)\n\n        explicitTag = kwargs.pop('explicitTag', None)\n        if explicitTag is not None:\n            initializers['tagSet'] = self.tagSet.tagExplicitly(explicitTag)\n\n        for arg, option in kwargs.items():\n            initializers[arg] += option\n\n        clone = self.__class__(**initializers)\n\n        if cloneValueFlag:\n            self._cloneComponentValues(clone, cloneValueFlag)\n\n        return clone\n\n    def getComponentByPosition(self, idx):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def setComponentByPosition(self, idx, value, verifyConstraints=True):\n        raise error.PyAsn1Error('Method not implemented')\n\n    def setComponents(self, *args, **kwargs):\n        for idx, value in enumerate(args):\n            self[idx] = value\n        for k in kwargs:\n            self[k] = kwargs[k]\n        return self\n\n    # backward compatibility\n\n    def setDefaultComponents(self):\n        pass\n\n    def getComponentType(self):\n        return self.componentType\n\n    # backward compatibility, unused\n    def verifySizeSpec(self):\n        self.subtypeSpec(self)\n\n\n        # Backward compatibility\nAbstractConstructedAsn1Item = ConstructedAsn1Type\n", "pyasn1/type/opentype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n\n__all__ = ['OpenType']\n\n\nclass OpenType(object):\n    \"\"\"Create ASN.1 type map indexed by a value\n\n    The *OpenType* object models an untyped field of a constructed ASN.1\n    type. In ASN.1 syntax it is usually represented by the\n    `ANY DEFINED BY` for scalars or `SET OF ANY DEFINED BY`,\n    `SEQUENCE OF ANY DEFINED BY` for container types clauses. Typically\n    used together with :class:`~pyasn1.type.univ.Any` object.\n\n    OpenType objects duck-type a read-only Python :class:`dict` objects,\n    however the passed `typeMap` is not copied, but stored by reference.\n    That means the user can manipulate `typeMap` at run time having this\n    reflected on *OpenType* object behavior.\n\n    The |OpenType| class models an untyped field of a constructed ASN.1\n    type. In ASN.1 syntax it is usually represented by the\n    `ANY DEFINED BY` for scalars or `SET OF ANY DEFINED BY`,\n    `SEQUENCE OF ANY DEFINED BY` for container types clauses. Typically\n    used with :class:`~pyasn1.type.univ.Any` type.\n\n    Parameters\n    ----------\n    name: :py:class:`str`\n        Field name\n\n    typeMap: :py:class:`dict`\n        A map of value->ASN.1 type. It's stored by reference and can be\n        mutated later to register new mappings.\n\n    Examples\n    --------\n\n    For untyped scalars:\n\n    .. code-block:: python\n\n        openType = OpenType(\n            'id', {1: Integer(),\n                   2: OctetString()}\n        )\n        Sequence(\n            componentType=NamedTypes(\n                NamedType('id', Integer()),\n                NamedType('blob', Any(), openType=openType)\n            )\n        )\n\n    For untyped `SET OF` or `SEQUENCE OF` vectors:\n\n    .. code-block:: python\n\n        openType = OpenType(\n            'id', {1: Integer(),\n                   2: OctetString()}\n        )\n        Sequence(\n            componentType=NamedTypes(\n                NamedType('id', Integer()),\n                NamedType('blob', SetOf(componentType=Any()),\n                          openType=openType)\n            )\n        )\n    \"\"\"\n\n    def __init__(self, name, typeMap=None):\n        self.__name = name\n        if typeMap is None:\n            self.__typeMap = {}\n        else:\n            self.__typeMap = typeMap\n\n    @property\n    def name(self):\n        return self.__name\n\n    # Python dict protocol\n\n    def values(self):\n        return self.__typeMap.values()\n\n    def keys(self):\n        return self.__typeMap.keys()\n\n    def items(self):\n        return self.__typeMap.items()\n\n    def __contains__(self, key):\n        return key in self.__typeMap\n\n    def __getitem__(self, key):\n        return self.__typeMap[key]\n\n    def __iter__(self):\n        return iter(self.__typeMap)\n", "pyasn1/type/namedtype.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\n__all__ = ['NamedType', 'OptionalNamedType', 'DefaultedNamedType',\n           'NamedTypes']\n\ntry:\n    any\n\nexcept NameError:\n    any = lambda x: bool(filter(bool, x))\n\n\nclass NamedType(object):\n    \"\"\"Create named field object for a constructed ASN.1 type.\n\n    The |NamedType| object represents a single name and ASN.1 type of a constructed ASN.1 type.\n\n    |NamedType| objects are immutable and duck-type Python :class:`tuple` objects\n    holding *name* and *asn1Object* components.\n\n    Parameters\n    ----------\n    name: :py:class:`str`\n        Field name\n\n    asn1Object:\n        ASN.1 type object\n    \"\"\"\n    isOptional = False\n    isDefaulted = False\n\n    def __init__(self, name, asn1Object, openType=None):\n        self.__name = name\n        self.__type = asn1Object\n        self.__nameAndType = name, asn1Object\n        self.__openType = openType\n\n    def __repr__(self):\n        representation = '%s=%r' % (self.name, self.asn1Object)\n\n        if self.openType:\n            representation += ', open type %r' % self.openType\n\n        return '<%s object, type %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__nameAndType == other\n\n    def __ne__(self, other):\n        return self.__nameAndType != other\n\n    def __lt__(self, other):\n        return self.__nameAndType < other\n\n    def __le__(self, other):\n        return self.__nameAndType <= other\n\n    def __gt__(self, other):\n        return self.__nameAndType > other\n\n    def __ge__(self, other):\n        return self.__nameAndType >= other\n\n    def __hash__(self):\n        return hash(self.__nameAndType)\n\n    def __getitem__(self, idx):\n        return self.__nameAndType[idx]\n\n    def __iter__(self):\n        return iter(self.__nameAndType)\n\n    @property\n    def name(self):\n        return self.__name\n\n    @property\n    def asn1Object(self):\n        return self.__type\n\n    @property\n    def openType(self):\n        return self.__openType\n\n    # Backward compatibility\n\n    def getName(self):\n        return self.name\n\n    def getType(self):\n        return self.asn1Object\n\n\nclass OptionalNamedType(NamedType):\n    __doc__ = NamedType.__doc__\n\n    isOptional = True\n\n\nclass DefaultedNamedType(NamedType):\n    __doc__ = NamedType.__doc__\n\n    isDefaulted = True\n\n\nclass NamedTypes(object):\n    \"\"\"Create a collection of named fields for a constructed ASN.1 type.\n\n    The NamedTypes object represents a collection of named fields of a constructed ASN.1 type.\n\n    *NamedTypes* objects are immutable and duck-type Python :class:`dict` objects\n    holding *name* as keys and ASN.1 type object as values.\n\n    Parameters\n    ----------\n    *namedTypes: :class:`~pyasn1.type.namedtype.NamedType`\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Description(Sequence):\n            '''\n            ASN.1 specification:\n\n            Description ::= SEQUENCE {\n                surname    IA5String,\n                first-name IA5String OPTIONAL,\n                age        INTEGER DEFAULT 40\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('surname', IA5String()),\n                OptionalNamedType('first-name', IA5String()),\n                DefaultedNamedType('age', Integer(40))\n            )\n\n        descr = Description()\n        descr['surname'] = 'Smith'\n        descr['first-name'] = 'John'\n    \"\"\"\n    def __init__(self, *namedTypes, **kwargs):\n        self.__namedTypes = namedTypes\n        self.__namedTypesLen = len(self.__namedTypes)\n        self.__minTagSet = self.__computeMinTagSet()\n        self.__nameToPosMap = self.__computeNameToPosMap()\n        self.__tagToPosMap = self.__computeTagToPosMap()\n        self.__ambiguousTypes = 'terminal' not in kwargs and self.__computeAmbiguousTypes() or {}\n        self.__uniqueTagMap = self.__computeTagMaps(unique=True)\n        self.__nonUniqueTagMap = self.__computeTagMaps(unique=False)\n        self.__hasOptionalOrDefault = any([True for namedType in self.__namedTypes\n                                           if namedType.isDefaulted or namedType.isOptional])\n        self.__hasOpenTypes = any([True for namedType in self.__namedTypes\n                                   if namedType.openType])\n\n        self.__requiredComponents = frozenset(\n                [idx for idx, nt in enumerate(self.__namedTypes) if not nt.isOptional and not nt.isDefaulted]\n            )\n        self.__keys = frozenset([namedType.name for namedType in self.__namedTypes])\n        self.__values = tuple([namedType.asn1Object for namedType in self.__namedTypes])\n        self.__items = tuple([(namedType.name, namedType.asn1Object) for namedType in self.__namedTypes])\n\n    def __repr__(self):\n        representation = ', '.join(['%r' % x for x in self.__namedTypes])\n        return '<%s object, types %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return self.__namedTypes == other\n\n    def __ne__(self, other):\n        return self.__namedTypes != other\n\n    def __lt__(self, other):\n        return self.__namedTypes < other\n\n    def __le__(self, other):\n        return self.__namedTypes <= other\n\n    def __gt__(self, other):\n        return self.__namedTypes > other\n\n    def __ge__(self, other):\n        return self.__namedTypes >= other\n\n    def __hash__(self):\n        return hash(self.__namedTypes)\n\n    def __getitem__(self, idx):\n        try:\n            return self.__namedTypes[idx]\n\n        except TypeError:\n            return self.__namedTypes[self.__nameToPosMap[idx]]\n\n    def __contains__(self, key):\n        return key in self.__nameToPosMap\n\n    def __iter__(self):\n        return (x[0] for x in self.__namedTypes)\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self.__namedTypesLen > 0\n    else:\n        def __bool__(self):\n            return self.__namedTypesLen > 0\n\n    def __len__(self):\n        return self.__namedTypesLen\n\n    # Python dict protocol\n\n    def values(self):\n        return self.__values\n\n    def keys(self):\n        return self.__keys\n\n    def items(self):\n        return self.__items\n\n    def clone(self):\n        return self.__class__(*self.__namedTypes)\n\n    class PostponedError(object):\n        def __init__(self, errorMsg):\n            self.__errorMsg = errorMsg\n\n        def __getitem__(self, item):\n            raise  error.PyAsn1Error(self.__errorMsg)\n\n    def __computeTagToPosMap(self):\n        tagToPosMap = {}\n        for idx, namedType in enumerate(self.__namedTypes):\n            tagMap = namedType.asn1Object.tagMap\n            if isinstance(tagMap, NamedTypes.PostponedError):\n                return tagMap\n            if not tagMap:\n                continue\n            for _tagSet in tagMap.presentTypes:\n                if _tagSet in tagToPosMap:\n                    return NamedTypes.PostponedError('Duplicate component tag %s at %s' % (_tagSet, namedType))\n                tagToPosMap[_tagSet] = idx\n\n        return tagToPosMap\n\n    def __computeNameToPosMap(self):\n        nameToPosMap = {}\n        for idx, namedType in enumerate(self.__namedTypes):\n            if namedType.name in nameToPosMap:\n                return NamedTypes.PostponedError('Duplicate component name %s at %s' % (namedType.name, namedType))\n            nameToPosMap[namedType.name] = idx\n\n        return nameToPosMap\n\n    def __computeAmbiguousTypes(self):\n        ambiguousTypes = {}\n        partialAmbiguousTypes = ()\n        for idx, namedType in reversed(tuple(enumerate(self.__namedTypes))):\n            if namedType.isOptional or namedType.isDefaulted:\n                partialAmbiguousTypes = (namedType,) + partialAmbiguousTypes\n            else:\n                partialAmbiguousTypes = (namedType,)\n            if len(partialAmbiguousTypes) == len(self.__namedTypes):\n                ambiguousTypes[idx] = self\n            else:\n                ambiguousTypes[idx] = NamedTypes(*partialAmbiguousTypes, **dict(terminal=True))\n        return ambiguousTypes\n\n    def getTypeByPosition(self, idx):\n        \"\"\"Return ASN.1 type object by its position in fields set.\n\n        Parameters\n        ----------\n        idx: :py:class:`int`\n            Field index\n\n        Returns\n        -------\n        :\n            ASN.1 type\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given position is out of fields range\n        \"\"\"\n        try:\n            return self.__namedTypes[idx].asn1Object\n\n        except IndexError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionByType(self, tagSet):\n        \"\"\"Return field position by its ASN.1 type.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pysnmp.type.tag.TagSet`\n            ASN.1 tag set distinguishing one ASN.1 type from others.\n\n        Returns\n        -------\n        : :py:class:`int`\n            ASN.1 type position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *tagSet* is not present or ASN.1 types are not unique within callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__tagToPosMap[tagSet]\n\n        except KeyError:\n            raise error.PyAsn1Error('Type %s not found' % (tagSet,))\n\n    def getNameByPosition(self, idx):\n        \"\"\"Return field name by its position in fields set.\n\n        Parameters\n        ----------\n        idx: :py:class:`idx`\n            Field index\n\n        Returns\n        -------\n        : :py:class:`str`\n            Field name\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given field name is not present in callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__namedTypes[idx].name\n\n        except IndexError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionByName(self, name):\n        \"\"\"Return field position by filed name.\n\n        Parameters\n        ----------\n        name: :py:class:`str`\n            Field name\n\n        Returns\n        -------\n        : :py:class:`int`\n            Field position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *name* is not present or not unique within callee *NamedTypes*\n        \"\"\"\n        try:\n            return self.__nameToPosMap[name]\n\n        except KeyError:\n            raise error.PyAsn1Error('Name %s not found' % (name,))\n\n    def getTagMapNearPosition(self, idx):\n        \"\"\"Return ASN.1 types that are allowed at or past given field position.\n\n        Some ASN.1 serialisation allow for skipping optional and defaulted fields.\n        Some constructed ASN.1 types allow reordering of the fields. When recovering\n        such objects it may be important to know which types can possibly be\n        present at any given position in the field sets.\n\n        Parameters\n        ----------\n        idx: :py:class:`int`\n            Field index\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tagmap.TagMap`\n            Map if ASN.1 types allowed at given field position\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If given position is out of fields range\n        \"\"\"\n        try:\n            return self.__ambiguousTypes[idx].tagMap\n\n        except KeyError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def getPositionNearType(self, tagSet, idx):\n        \"\"\"Return the closest field position where given ASN.1 type is allowed.\n\n        Some ASN.1 serialisation allow for skipping optional and defaulted fields.\n        Some constructed ASN.1 types allow reordering of the fields. When recovering\n        such objects it may be important to know at which field position, in field set,\n        given *tagSet* is allowed at or past *idx* position.\n\n        Parameters\n        ----------\n        tagSet: :class:`~pyasn1.type.tag.TagSet`\n           ASN.1 type which field position to look up\n\n        idx: :py:class:`int`\n            Field position at or past which to perform ASN.1 type look up\n\n        Returns\n        -------\n        : :py:class:`int`\n            Field position in fields set\n\n        Raises\n        ------\n        ~pyasn1.error.PyAsn1Error\n            If *tagSet* is not present or not unique within callee *NamedTypes*\n            or *idx* is out of fields range\n        \"\"\"\n        try:\n            return idx + self.__ambiguousTypes[idx].getPositionByType(tagSet)\n\n        except KeyError:\n            raise error.PyAsn1Error('Type position out of range')\n\n    def __computeMinTagSet(self):\n        minTagSet = None\n        for namedType in self.__namedTypes:\n            asn1Object = namedType.asn1Object\n\n            try:\n                tagSet = asn1Object.minTagSet\n\n            except AttributeError:\n                tagSet = asn1Object.tagSet\n\n            if minTagSet is None or tagSet < minTagSet:\n                minTagSet = tagSet\n\n        return minTagSet or tag.TagSet()\n\n    @property\n    def minTagSet(self):\n        \"\"\"Return the minimal TagSet among ASN.1 type in callee *NamedTypes*.\n\n        Some ASN.1 types/serialisation protocols require ASN.1 types to be\n        arranged based on their numerical tag value. The *minTagSet* property\n        returns that.\n\n        Returns\n        -------\n        : :class:`~pyasn1.type.tagset.TagSet`\n            Minimal TagSet among ASN.1 types in callee *NamedTypes*\n        \"\"\"\n        return self.__minTagSet\n\n    def __computeTagMaps(self, unique):\n        presentTypes = {}\n        skipTypes = {}\n        defaultType = None\n        for namedType in self.__namedTypes:\n            tagMap = namedType.asn1Object.tagMap\n            if isinstance(tagMap, NamedTypes.PostponedError):\n                return tagMap\n            for tagSet in tagMap:\n                if unique and tagSet in presentTypes:\n                    return NamedTypes.PostponedError('Non-unique tagSet %s of %s at %s' % (tagSet, namedType, self))\n                presentTypes[tagSet] = namedType.asn1Object\n            skipTypes.update(tagMap.skipTypes)\n\n            if defaultType is None:\n                defaultType = tagMap.defaultType\n            elif tagMap.defaultType is not None:\n                return NamedTypes.PostponedError('Duplicate default ASN.1 type at %s' % (self,))\n\n        return tagmap.TagMap(presentTypes, skipTypes, defaultType)\n\n    @property\n    def tagMap(self):\n        \"\"\"Return a *TagMap* object from tags and types recursively.\n\n        Return a :class:`~pyasn1.type.tagmap.TagMap` object by\n        combining tags from *TagMap* objects of children types and\n        associating them with their immediate child type.\n\n        Example\n        -------\n        .. code-block:: python\n\n           OuterType ::= CHOICE {\n               innerType INTEGER\n           }\n\n        Calling *.tagMap* on *OuterType* will yield a map like this:\n\n        .. code-block:: python\n\n           Integer.tagSet -> Choice\n        \"\"\"\n        return self.__nonUniqueTagMap\n\n    @property\n    def tagMapUnique(self):\n        \"\"\"Return a *TagMap* object from unique tags and types recursively.\n\n        Return a :class:`~pyasn1.type.tagmap.TagMap` object by\n        combining tags from *TagMap* objects of children types and\n        associating them with their immediate child type.\n\n        Example\n        -------\n        .. code-block:: python\n\n           OuterType ::= CHOICE {\n               innerType INTEGER\n           }\n\n        Calling *.tagMapUnique* on *OuterType* will yield a map like this:\n\n        .. code-block:: python\n\n           Integer.tagSet -> Choice\n\n        Note\n        ----\n\n        Duplicate *TagSet* objects found in the tree of children\n        types would cause error.\n        \"\"\"\n        return self.__uniqueTagMap\n\n    @property\n    def hasOptionalOrDefault(self):\n        return self.__hasOptionalOrDefault\n\n    @property\n    def hasOpenTypes(self):\n        return self.__hasOpenTypes\n\n    @property\n    def namedTypes(self):\n        return tuple(self.__namedTypes)\n\n    @property\n    def requiredComponents(self):\n        return self.__requiredComponents\n", "pyasn1/type/error.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.error import PyAsn1Error\n\n\nclass ValueConstraintError(PyAsn1Error):\n    pass\n", "pyasn1/type/char.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\n\n__all__ = ['NumericString', 'PrintableString', 'TeletexString', 'T61String', 'VideotexString',\n           'IA5String', 'GraphicString', 'VisibleString', 'ISO646String',\n           'GeneralString', 'UniversalString', 'BMPString', 'UTF8String']\n\nNoValue = univ.NoValue\nnoValue = univ.noValue\n\n\nclass AbstractCharacterString(univ.OctetString):\n    \"\"\"Creates |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`,\n    its objects are immutable and duck-type Python 2 :class:`str` or Python 3\n    :class:`bytes`. When used in octet-stream context, |ASN.1| type assumes\n    \"|encoding|\" encoding.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        :class:`unicode` object (Python 2) or :class:`str` (Python 3),\n        alternatively :class:`str` (Python 2) or :class:`bytes` (Python 3)\n        representing octet-stream of serialised unicode string\n        (note `encoding` parameter) or |ASN.1| class instance.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in octet-stream context.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n    \"\"\"\n\n    if sys.version_info[0] <= 2:\n        def __str__(self):\n            try:\n                # `str` is Py2 text representation\n                return self._value.encode(self.encoding)\n\n            except UnicodeEncodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeEncodeError(\n                    \"Can't encode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def __unicode__(self):\n            return unicode(self._value)\n\n        def prettyIn(self, value):\n            try:\n                if isinstance(value, unicode):\n                    return value\n                elif isinstance(value, str):\n                    return value.decode(self.encoding)\n                elif isinstance(value, (tuple, list)):\n                    return self.prettyIn(''.join([chr(x) for x in value]))\n                elif isinstance(value, univ.OctetString):\n                    return value.asOctets().decode(self.encoding)\n                else:\n                    return unicode(value)\n\n            except (UnicodeDecodeError, LookupError):\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (value, self.encoding), exc\n                )\n\n        def asOctets(self, padding=True):\n            return str(self)\n\n        def asNumbers(self, padding=True):\n            return tuple([ord(x) for x in str(self)])\n\n    else:\n        def __str__(self):\n            # `unicode` is Py3 text representation\n            return str(self._value)\n\n        def __bytes__(self):\n            try:\n                return self._value.encode(self.encoding)\n            except UnicodeEncodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeEncodeError(\n                    \"Can't encode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def prettyIn(self, value):\n            try:\n                if isinstance(value, str):\n                    return value\n                elif isinstance(value, bytes):\n                    return value.decode(self.encoding)\n                elif isinstance(value, (tuple, list)):\n                    return self.prettyIn(bytes(value))\n                elif isinstance(value, univ.OctetString):\n                    return value.asOctets().decode(self.encoding)\n                else:\n                    return str(value)\n\n            except (UnicodeDecodeError, LookupError):\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (value, self.encoding), exc\n                )\n\n        def asOctets(self, padding=True):\n            return bytes(self)\n\n        def asNumbers(self, padding=True):\n            return tuple(bytes(self))\n\n    #\n    # See OctetString.prettyPrint() for the explanation\n    #\n\n    def prettyOut(self, value):\n        return value\n\n    def prettyPrint(self, scope=0):\n        # first see if subclass has its own .prettyOut()\n        value = self.prettyOut(self._value)\n\n        if value is not self._value:\n            return value\n\n        return AbstractCharacterString.__str__(self)\n\n    def __reversed__(self):\n        return reversed(self._value)\n\n\nclass NumericString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 18)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass PrintableString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 19)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass TeletexString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 20)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass T61String(TeletexString):\n    __doc__ = TeletexString.__doc__\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass VideotexString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 21)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass IA5String(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 22)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass GraphicString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 25)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass VisibleString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 26)\n    )\n    encoding = 'us-ascii'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass ISO646String(VisibleString):\n    __doc__ = VisibleString.__doc__\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\nclass GeneralString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 27)\n    )\n    encoding = 'iso-8859-1'\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass UniversalString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 28)\n    )\n    encoding = \"utf-32-be\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass BMPString(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 30)\n    )\n    encoding = \"utf-16-be\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n\n\nclass UTF8String(AbstractCharacterString):\n    __doc__ = AbstractCharacterString.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = AbstractCharacterString.tagSet.tagImplicitly(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 12)\n    )\n    encoding = \"utf-8\"\n\n    # Optimization for faster codec lookup\n    typeId = AbstractCharacterString.getTypeId()\n", "pyasn1/type/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/type/namedval.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\n# ASN.1 named integers\n#\nfrom pyasn1 import error\n\n__all__ = ['NamedValues']\n\n\nclass NamedValues(object):\n    \"\"\"Create named values object.\n\n    The |NamedValues| object represents a collection of string names\n    associated with numeric IDs. These objects are used for giving\n    names to otherwise numerical values.\n\n    |NamedValues| objects are immutable and duck-type Python\n    :class:`dict` object mapping ID to name and vice-versa.\n\n    Parameters\n    ----------\n    *args: variable number of two-element :py:class:`tuple`\n\n        name: :py:class:`str`\n            Value label\n\n        value: :py:class:`int`\n            Numeric value\n\n    Keyword Args\n    ------------\n    name: :py:class:`str`\n        Value label\n\n    value: :py:class:`int`\n        Numeric value\n\n    Examples\n    --------\n\n    .. code-block:: pycon\n\n        >>> nv = NamedValues('a', 'b', ('c', 0), d=1)\n        >>> nv\n        >>> {'c': 0, 'd': 1, 'a': 2, 'b': 3}\n        >>> nv[0]\n        'c'\n        >>> nv['a']\n        2\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        self.__names = {}\n        self.__numbers = {}\n\n        anonymousNames = []\n\n        for namedValue in args:\n            if isinstance(namedValue, (tuple, list)):\n                try:\n                    name, number = namedValue\n\n                except ValueError:\n                    raise error.PyAsn1Error('Not a proper attribute-value pair %r' % (namedValue,))\n\n            else:\n                anonymousNames.append(namedValue)\n                continue\n\n            if name in self.__names:\n                raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n            if number in self.__numbers:\n                raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))\n\n            self.__names[name] = number\n            self.__numbers[number] = name\n\n        for name, number in kwargs.items():\n            if name in self.__names:\n                raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n            if number in self.__numbers:\n                raise error.PyAsn1Error('Duplicate number  %s=%s' % (name, number))\n\n            self.__names[name] = number\n            self.__numbers[number] = name\n\n        if anonymousNames:\n\n            number = self.__numbers and max(self.__numbers) + 1 or 0\n\n            for name in anonymousNames:\n\n                if name in self.__names:\n                    raise error.PyAsn1Error('Duplicate name %s' % (name,))\n\n                self.__names[name] = number\n                self.__numbers[number] = name\n\n                number += 1\n\n    def __repr__(self):\n        representation = ', '.join(['%s=%d' % x for x in self.items()])\n\n        if len(representation) > 64:\n            representation = representation[:32] + '...' + representation[-32:]\n\n        return '<%s object, enums %s>' % (\n            self.__class__.__name__, representation)\n\n    def __eq__(self, other):\n        return dict(self) == other\n\n    def __ne__(self, other):\n        return dict(self) != other\n\n    def __lt__(self, other):\n        return dict(self) < other\n\n    def __le__(self, other):\n        return dict(self) <= other\n\n    def __gt__(self, other):\n        return dict(self) > other\n\n    def __ge__(self, other):\n        return dict(self) >= other\n\n    def __hash__(self):\n        return hash(self.items())\n\n    # Python dict protocol (read-only)\n\n    def __getitem__(self, key):\n        try:\n            return self.__numbers[key]\n\n        except KeyError:\n            return self.__names[key]\n\n    def __len__(self):\n        return len(self.__names)\n\n    def __contains__(self, key):\n        return key in self.__names or key in self.__numbers\n\n    def __iter__(self):\n        return iter(self.__names)\n\n    def values(self):\n        return iter(self.__numbers)\n\n    def keys(self):\n        return iter(self.__names)\n\n    def items(self):\n        for name in self.__names:\n            yield name, self.__names[name]\n\n    # support merging\n\n    def __add__(self, namedValues):\n        return self.__class__(*tuple(self.items()) + tuple(namedValues.items()))\n\n    # XXX clone/subtype?\n\n    def clone(self, *args, **kwargs):\n        new = self.__class__(*args, **kwargs)\n        return self + new\n\n    # legacy protocol\n\n    def getName(self, value):\n        if value in self.__numbers:\n            return self.__numbers[value]\n\n    def getValue(self, name):\n        if name in self.__names:\n            return self.__names[name]\n\n    def getValues(self, *names):\n        try:\n            return [self.__names[name] for name in names]\n\n        except KeyError:\n            raise error.PyAsn1Error(\n                'Unknown bit identifier(s): %s' % (set(names).difference(self.__names),)\n            )\n", "pyasn1/type/univ.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport math\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.compat import integer\nfrom pyasn1.compat import octets\nfrom pyasn1.type import base\nfrom pyasn1.type import constraint\nfrom pyasn1.type import namedtype\nfrom pyasn1.type import namedval\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\n\nNoValue = base.NoValue\nnoValue = NoValue()\n\n__all__ = ['Integer', 'Boolean', 'BitString', 'OctetString', 'Null',\n           'ObjectIdentifier', 'Real', 'Enumerated',\n           'SequenceOfAndSetOfBase', 'SequenceOf', 'SetOf',\n           'SequenceAndSetBase', 'Sequence', 'Set', 'Choice', 'Any',\n           'NoValue', 'noValue']\n\n# \"Simple\" ASN.1 types (yet incomplete)\n\n\nclass Integer(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| class\n        instance. If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class ErrorCode(Integer):\n            '''\n            ASN.1 specification:\n\n            ErrorCode ::=\n                INTEGER { disk-full(1), no-disk(-1),\n                          disk-not-formatted(2) }\n\n            error ErrorCode ::= disk-full\n            '''\n            namedValues = NamedValues(\n                ('disk-full', 1), ('no-disk', -1),\n                ('disk-not-formatted', 2)\n            )\n\n        error = ErrorCode('disk-full')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x02)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __init__(self, value=noValue, **kwargs):\n        if 'namedValues' not in kwargs:\n            kwargs['namedValues'] = self.namedValues\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    def __and__(self, value):\n        return self.clone(self._value & value)\n\n    def __rand__(self, value):\n        return self.clone(value & self._value)\n\n    def __or__(self, value):\n        return self.clone(self._value | value)\n\n    def __ror__(self, value):\n        return self.clone(value | self._value)\n\n    def __xor__(self, value):\n        return self.clone(self._value ^ value)\n\n    def __rxor__(self, value):\n        return self.clone(value ^ self._value)\n\n    def __lshift__(self, value):\n        return self.clone(self._value << value)\n\n    def __rshift__(self, value):\n        return self.clone(self._value >> value)\n\n    def __add__(self, value):\n        return self.clone(self._value + value)\n\n    def __radd__(self, value):\n        return self.clone(value + self._value)\n\n    def __sub__(self, value):\n        return self.clone(self._value - value)\n\n    def __rsub__(self, value):\n        return self.clone(value - self._value)\n\n    def __mul__(self, value):\n        return self.clone(self._value * value)\n\n    def __rmul__(self, value):\n        return self.clone(value * self._value)\n\n    def __mod__(self, value):\n        return self.clone(self._value % value)\n\n    def __rmod__(self, value):\n        return self.clone(value % self._value)\n\n    def __pow__(self, value, modulo=None):\n        return self.clone(pow(self._value, value, modulo))\n\n    def __rpow__(self, value):\n        return self.clone(pow(value, self._value))\n\n    def __floordiv__(self, value):\n        return self.clone(self._value // value)\n\n    def __rfloordiv__(self, value):\n        return self.clone(value // self._value)\n\n    if sys.version_info[0] <= 2:\n        def __div__(self, value):\n            if isinstance(value, float):\n                return Real(self._value / value)\n            else:\n                return self.clone(self._value / value)\n\n        def __rdiv__(self, value):\n            if isinstance(value, float):\n                return Real(value / self._value)\n            else:\n                return self.clone(value / self._value)\n    else:\n        def __truediv__(self, value):\n            return Real(self._value / value)\n\n        def __rtruediv__(self, value):\n            return Real(value / self._value)\n\n        def __divmod__(self, value):\n            return self.clone(divmod(self._value, value))\n\n        def __rdivmod__(self, value):\n            return self.clone(divmod(value, self._value))\n\n        __hash__ = base.SimpleAsn1Type.__hash__\n\n    def __int__(self):\n        return int(self._value)\n\n    if sys.version_info[0] <= 2:\n        def __long__(self):\n            return long(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    def __abs__(self):\n        return self.clone(abs(self._value))\n\n    def __index__(self):\n        return int(self._value)\n\n    def __pos__(self):\n        return self.clone(+self._value)\n\n    def __neg__(self):\n        return self.clone(-self._value)\n\n    def __invert__(self):\n        return self.clone(~self._value)\n\n    def __round__(self, n=0):\n        r = round(self._value, n)\n        if n:\n            return self.clone(r)\n        else:\n            return r\n\n    def __floor__(self):\n        return math.floor(self._value)\n\n    def __ceil__(self):\n        return math.ceil(self._value)\n\n    def __trunc__(self):\n        return self.clone(math.trunc(self._value))\n\n    def __lt__(self, value):\n        return self._value < value\n\n    def __le__(self, value):\n        return self._value <= value\n\n    def __eq__(self, value):\n        return self._value == value\n\n    def __ne__(self, value):\n        return self._value != value\n\n    def __gt__(self, value):\n        return self._value > value\n\n    def __ge__(self, value):\n        return self._value >= value\n\n    def prettyIn(self, value):\n        try:\n            return int(value)\n\n        except ValueError:\n            try:\n                return self.namedValues[value]\n\n            except KeyError:\n                raise error.PyAsn1Error(\n                    'Can\\'t coerce %r into integer: %s' % (value, sys.exc_info()[1])\n                )\n\n    def prettyOut(self, value):\n        try:\n            return str(self.namedValues[value])\n\n        except KeyError:\n            return str(value)\n\n    # backward compatibility\n\n    def getNamedValues(self):\n        return self.namedValues\n\n\nclass Boolean(Integer):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| class\n        instance. If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class RoundResult(Boolean):\n            '''\n            ASN.1 specification:\n\n            RoundResult ::= BOOLEAN\n\n            ok RoundResult ::= TRUE\n            ko RoundResult ::= FALSE\n            '''\n        ok = RoundResult(True)\n        ko = RoundResult(False)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x01),\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = Integer.subtypeSpec + constraint.SingleValueConstraint(0, 1)\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues(('False', 0), ('True', 1))\n\n    # Optimization for faster codec lookup\n    typeId = Integer.getTypeId()\n\nif sys.version_info[0] < 3:\n    SizedIntegerBase = long\nelse:\n    SizedIntegerBase = int\n\n\nclass SizedInteger(SizedIntegerBase):\n    bitLength = leadingZeroBits = None\n\n    def setBitLength(self, bitLength):\n        self.bitLength = bitLength\n        self.leadingZeroBits = max(bitLength - integer.bitLength(self), 0)\n        return self\n\n    def __len__(self):\n        if self.bitLength is None:\n            self.setBitLength(integer.bitLength(self))\n\n        return self.bitLength\n\n\nclass BitString(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type both Python :class:`tuple` (as a tuple\n    of bits) and :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal representing binary\n        or hexadecimal number or sequence of integer bits or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Rights(BitString):\n            '''\n            ASN.1 specification:\n\n            Rights ::= BIT STRING { user-read(0), user-write(1),\n                                    group-read(2), group-write(3),\n                                    other-read(4), other-write(5) }\n\n            group1 Rights ::= { group-read, group-write }\n            group2 Rights ::= '0011'B\n            group3 Rights ::= '3'H\n            '''\n            namedValues = NamedValues(\n                ('user-read', 0), ('user-write', 1),\n                ('group-read', 2), ('group-write', 3),\n                ('other-read', 4), ('other-write', 5)\n            )\n\n        group1 = Rights(('group-read', 'group-write'))\n        group2 = Rights('0011')\n        group3 = Rights(0x3)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x03)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    defaultBinValue = defaultHexValue = noValue\n\n    def __init__(self, value=noValue, **kwargs):\n        if value is noValue:\n            if kwargs:\n                try:\n                    value = self.fromBinaryString(kwargs.pop('binValue'), internalFormat=True)\n\n                except KeyError:\n                    pass\n\n                try:\n                    value = self.fromHexString(kwargs.pop('hexValue'), internalFormat=True)\n\n                except KeyError:\n                    pass\n\n        if value is noValue:\n            if self.defaultBinValue is not noValue:\n                value = self.fromBinaryString(self.defaultBinValue, internalFormat=True)\n\n            elif self.defaultHexValue is not noValue:\n                value = self.fromHexString(self.defaultHexValue, internalFormat=True)\n\n        if 'namedValues' not in kwargs:\n            kwargs['namedValues'] = self.namedValues\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    def __str__(self):\n        return self.asBinary()\n\n    def __eq__(self, other):\n        other = self.prettyIn(other)\n        return self is other or self._value == other and len(self._value) == len(other)\n\n    def __ne__(self, other):\n        other = self.prettyIn(other)\n        return self._value != other or len(self._value) != len(other)\n\n    def __lt__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) < len(other) or len(self._value) == len(other) and self._value < other\n\n    def __le__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) <= len(other) or len(self._value) == len(other) and self._value <= other\n\n    def __gt__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) > len(other) or len(self._value) == len(other) and self._value > other\n\n    def __ge__(self, other):\n        other = self.prettyIn(other)\n        return len(self._value) >= len(other) or len(self._value) == len(other) and self._value >= other\n\n    # Immutable sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone([self[x] for x in range(*i.indices(len(self)))])\n        else:\n            length = len(self._value) - 1\n            if i > length or i < 0:\n                raise IndexError('bit index out of range')\n            return (self._value >> (length - i)) & 1\n\n    def __iter__(self):\n        length = len(self._value)\n        while length:\n            length -= 1\n            yield (self._value >> length) & 1\n\n    def __reversed__(self):\n        return reversed(tuple(self))\n\n    # arithmetic operators\n\n    def __add__(self, value):\n        value = self.prettyIn(value)\n        return self.clone(SizedInteger(self._value << len(value) | value).setBitLength(len(self._value) + len(value)))\n\n    def __radd__(self, value):\n        value = self.prettyIn(value)\n        return self.clone(SizedInteger(value << len(self._value) | self._value).setBitLength(len(self._value) + len(value)))\n\n    def __mul__(self, value):\n        bitString = self._value\n        while value > 1:\n            bitString <<= len(self._value)\n            bitString |= self._value\n            value -= 1\n        return self.clone(bitString)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __lshift__(self, count):\n        return self.clone(SizedInteger(self._value << count).setBitLength(len(self._value) + count))\n\n    def __rshift__(self, count):\n        return self.clone(SizedInteger(self._value >> count).setBitLength(max(0, len(self._value) - count)))\n\n    def __int__(self):\n        return int(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    if sys.version_info[0] < 3:\n        def __long__(self):\n            return self._value\n\n    def asNumbers(self):\n        \"\"\"Get |ASN.1| value as a sequence of 8-bit integers.\n\n        If |ASN.1| object length is not a multiple of 8, result\n        will be left-padded with zeros.\n        \"\"\"\n        return tuple(octets.octs2ints(self.asOctets()))\n\n    def asOctets(self):\n        \"\"\"Get |ASN.1| value as a sequence of octets.\n\n        If |ASN.1| object length is not a multiple of 8, result\n        will be left-padded with zeros.\n        \"\"\"\n        return integer.to_bytes(self._value, length=len(self))\n\n    def asInteger(self):\n        \"\"\"Get |ASN.1| value as a single integer value.\n        \"\"\"\n        return self._value\n\n    def asBinary(self):\n        \"\"\"Get |ASN.1| value as a text string of bits.\n        \"\"\"\n        binString = bin(self._value)[2:]\n        return '0' * (len(self._value) - len(binString)) + binString\n\n    @classmethod\n    def fromHexString(cls, value, internalFormat=False, prepend=None):\n        \"\"\"Create a |ASN.1| object initialized from the hex string.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like 'DEADBEEF'\n        \"\"\"\n        try:\n            value = SizedInteger(value, 16).setBitLength(len(value) * 4)\n\n        except ValueError:\n            raise error.PyAsn1Error('%s.fromHexString() error: %s' % (cls.__name__, sys.exc_info()[1]))\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    @classmethod\n    def fromBinaryString(cls, value, internalFormat=False, prepend=None):\n        \"\"\"Create a |ASN.1| object initialized from a string of '0' and '1'.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like '1010111'\n        \"\"\"\n        try:\n            value = SizedInteger(value or '0', 2).setBitLength(len(value))\n\n        except ValueError:\n            raise error.PyAsn1Error('%s.fromBinaryString() error: %s' % (cls.__name__, sys.exc_info()[1]))\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    @classmethod\n    def fromOctetString(cls, value, internalFormat=False, prepend=None, padding=0):\n        \"\"\"Create a |ASN.1| object initialized from a string.\n\n        Parameters\n        ----------\n        value: :class:`str` (Py2) or :class:`bytes` (Py3)\n            Text string like '\\\\\\\\x01\\\\\\\\xff' (Py2) or b'\\\\\\\\x01\\\\\\\\xff' (Py3)\n        \"\"\"\n        value = SizedInteger(integer.from_bytes(value) >> padding).setBitLength(len(value) * 8 - padding)\n\n        if prepend is not None:\n            value = SizedInteger(\n                (SizedInteger(prepend) << len(value)) | value\n            ).setBitLength(len(prepend) + len(value))\n\n        if not internalFormat:\n            value = cls(value)\n\n        return value\n\n    def prettyIn(self, value):\n        if isinstance(value, SizedInteger):\n            return value\n        elif octets.isStringType(value):\n            if not value:\n                return SizedInteger(0).setBitLength(0)\n\n            elif value[0] == '\\'':  # \"'1011'B\" -- ASN.1 schema representation (deprecated)\n                if value[-2:] == '\\'B':\n                    return self.fromBinaryString(value[1:-2], internalFormat=True)\n                elif value[-2:] == '\\'H':\n                    return self.fromHexString(value[1:-2], internalFormat=True)\n                else:\n                    raise error.PyAsn1Error(\n                        'Bad BIT STRING value notation %s' % (value,)\n                    )\n\n            elif self.namedValues and not value.isdigit():  # named bits like 'Urgent, Active'\n                names = [x.strip() for x in value.split(',')]\n\n                try:\n\n                    bitPositions = [self.namedValues[name] for name in names]\n\n                except KeyError:\n                    raise error.PyAsn1Error('unknown bit name(s) in %r' % (names,))\n\n                rightmostPosition = max(bitPositions)\n\n                number = 0\n                for bitPosition in bitPositions:\n                    number |= 1 << (rightmostPosition - bitPosition)\n\n                return SizedInteger(number).setBitLength(rightmostPosition + 1)\n\n            elif value.startswith('0x'):\n                return self.fromHexString(value[2:], internalFormat=True)\n\n            elif value.startswith('0b'):\n                return self.fromBinaryString(value[2:], internalFormat=True)\n\n            else:  # assume plain binary string like '1011'\n                return self.fromBinaryString(value, internalFormat=True)\n\n        elif isinstance(value, (tuple, list)):\n            return self.fromBinaryString(''.join([b and '1' or '0' for b in value]), internalFormat=True)\n\n        elif isinstance(value, BitString):\n            return SizedInteger(value).setBitLength(len(value))\n\n        elif isinstance(value, intTypes):\n            return SizedInteger(value)\n\n        else:\n            raise error.PyAsn1Error(\n                'Bad BitString initializer type \\'%s\\'' % (value,)\n            )\n\n\nclass OctetString(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python 2 :class:`str` or\n    Python 3 :class:`bytes`. When used in Unicode context, |ASN.1| type\n    assumes \"|encoding|\" serialisation.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        class:`str` (Python 2) or :class:`bytes` (Python 3), alternatively\n        class:`unicode` object (Python 2) or :class:`str` (Python 3)\n        representing character string to be serialised into octets\n        (note `encoding` parameter) or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in text string context.\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Icon(OctetString):\n            '''\n            ASN.1 specification:\n\n            Icon ::= OCTET STRING\n\n            icon1 Icon ::= '001100010011001000110011'B\n            icon2 Icon ::= '313233'H\n            '''\n        icon1 = Icon.fromBinaryString('001100010011001000110011')\n        icon2 = Icon.fromHexString('313233')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x04)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    defaultBinValue = defaultHexValue = noValue\n    encoding = 'iso-8859-1'\n\n    def __init__(self, value=noValue, **kwargs):\n        if kwargs:\n            if value is noValue:\n                try:\n                    value = self.fromBinaryString(kwargs.pop('binValue'))\n\n                except KeyError:\n                    pass\n\n                try:\n                    value = self.fromHexString(kwargs.pop('hexValue'))\n\n                except KeyError:\n                    pass\n\n        if value is noValue:\n            if self.defaultBinValue is not noValue:\n                value = self.fromBinaryString(self.defaultBinValue)\n\n            elif self.defaultHexValue is not noValue:\n                value = self.fromHexString(self.defaultHexValue)\n\n        if 'encoding' not in kwargs:\n            kwargs['encoding'] = self.encoding\n\n        base.SimpleAsn1Type.__init__(self, value, **kwargs)\n\n    if sys.version_info[0] <= 2:\n        def prettyIn(self, value):\n            if isinstance(value, str):\n                return value\n\n            elif isinstance(value, unicode):\n                try:\n                    return value.encode(self.encoding)\n\n                except (LookupError, UnicodeEncodeError):\n                    exc = sys.exc_info()[1]\n                    raise error.PyAsn1UnicodeEncodeError(\n                        \"Can't encode string '%s' with codec \"\n                        \"%s\" % (value, self.encoding), exc\n                    )\n\n            elif isinstance(value, (tuple, list)):\n                try:\n                    return ''.join([chr(x) for x in value])\n\n                except ValueError:\n                    raise error.PyAsn1Error(\n                        \"Bad %s initializer '%s'\" % (self.__class__.__name__, value)\n                    )\n\n            else:\n                return str(value)\n\n        def __str__(self):\n            return str(self._value)\n\n        def __unicode__(self):\n            try:\n                return self._value.decode(self.encoding)\n\n            except UnicodeDecodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with codec \"\n                    \"%s\" % (self._value, self.encoding), exc\n                )\n\n        def asOctets(self):\n            return str(self._value)\n\n        def asNumbers(self):\n            return tuple([ord(x) for x in self._value])\n\n    else:\n        def prettyIn(self, value):\n            if isinstance(value, bytes):\n                return value\n\n            elif isinstance(value, str):\n                try:\n                    return value.encode(self.encoding)\n\n                except UnicodeEncodeError:\n                    exc = sys.exc_info()[1]\n                    raise error.PyAsn1UnicodeEncodeError(\n                        \"Can't encode string '%s' with '%s' \"\n                        \"codec\" % (value, self.encoding), exc\n                    )\n            elif isinstance(value, OctetString):  # a shortcut, bytes() would work the same way\n                return value.asOctets()\n\n            elif isinstance(value, base.SimpleAsn1Type):  # this mostly targets Integer objects\n                return self.prettyIn(str(value))\n\n            elif isinstance(value, (tuple, list)):\n                return self.prettyIn(bytes(value))\n\n            else:\n                return bytes(value)\n\n        def __str__(self):\n            try:\n                return self._value.decode(self.encoding)\n\n            except UnicodeDecodeError:\n                exc = sys.exc_info()[1]\n                raise error.PyAsn1UnicodeDecodeError(\n                    \"Can't decode string '%s' with '%s' codec at \"\n                    \"'%s'\" % (self._value, self.encoding,\n                              self.__class__.__name__), exc\n                )\n\n        def __bytes__(self):\n            return bytes(self._value)\n\n        def asOctets(self):\n            return bytes(self._value)\n\n        def asNumbers(self):\n            return tuple(self._value)\n\n    #\n    # Normally, `.prettyPrint()` is called from `__str__()`. Historically,\n    # OctetString.prettyPrint() used to return hexified payload\n    # representation in cases when non-printable content is present. At the\n    # same time `str()` used to produce either octet-stream (Py2) or\n    # text (Py3) representations.\n    #\n    # Therefore `OctetString.__str__()` -> `.prettyPrint()` call chain is\n    # reversed to preserve the original behaviour.\n    #\n    # Eventually we should deprecate `.prettyPrint()` / `.prettyOut()` harness\n    # and end up with just `__str__()` producing hexified representation while\n    # both text and octet-stream representation should only be requested via\n    # the `.asOctets()` method.\n    #\n    # Note: ASN.1 OCTET STRING is never mean to contain text!\n    #\n\n    def prettyOut(self, value):\n        return value\n\n    def prettyPrint(self, scope=0):\n        # first see if subclass has its own .prettyOut()\n        value = self.prettyOut(self._value)\n\n        if value is not self._value:\n            return value\n\n        numbers = self.asNumbers()\n\n        for x in numbers:\n            # hexify if needed\n            if x < 32 or x > 126:\n                return '0x' + ''.join(('%.2x' % x for x in numbers))\n        else:\n            # this prevents infinite recursion\n            return OctetString.__str__(self)\n\n    @staticmethod\n    def fromBinaryString(value):\n        \"\"\"Create a |ASN.1| object initialized from a string of '0' and '1'.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like '1010111'\n        \"\"\"\n        bitNo = 8\n        byte = 0\n        r = []\n        for v in value:\n            if bitNo:\n                bitNo -= 1\n            else:\n                bitNo = 7\n                r.append(byte)\n                byte = 0\n            if v in ('0', '1'):\n                v = int(v)\n            else:\n                raise error.PyAsn1Error(\n                    'Non-binary OCTET STRING initializer %s' % (v,)\n                )\n            byte |= v << bitNo\n\n        r.append(byte)\n\n        return octets.ints2octs(r)\n\n    @staticmethod\n    def fromHexString(value):\n        \"\"\"Create a |ASN.1| object initialized from the hex string.\n\n        Parameters\n        ----------\n        value: :class:`str`\n            Text string like 'DEADBEEF'\n        \"\"\"\n        r = []\n        p = []\n        for v in value:\n            if p:\n                r.append(int(p + v, 16))\n                p = None\n            else:\n                p = v\n        if p:\n            r.append(int(p + '0', 16))\n\n        return octets.ints2octs(r)\n\n    # Immutable sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def __add__(self, value):\n        return self.clone(self._value + self.prettyIn(value))\n\n    def __radd__(self, value):\n        return self.clone(self.prettyIn(value) + self._value)\n\n    def __mul__(self, value):\n        return self.clone(self._value * value)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __int__(self):\n        return int(self._value)\n\n    def __float__(self):\n        return float(self._value)\n\n    def __reversed__(self):\n        return reversed(self._value)\n\n\nclass Null(OctetString):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`str` objects\n    (always empty).\n\n    Keyword Args\n    ------------\n    value: :class:`str` or |ASN.1| object\n        Python empty :class:`str` literal or any object that evaluates to :obj:`False`\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Ack(Null):\n            '''\n            ASN.1 specification:\n\n            Ack ::= NULL\n            '''\n        ack = Ack('')\n    \"\"\"\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x05)\n    )\n    subtypeSpec = OctetString.subtypeSpec + constraint.SingleValueConstraint(octets.str2octs(''))\n\n    # Optimization for faster codec lookup\n    typeId = OctetString.getTypeId()\n\n    def prettyIn(self, value):\n        if value:\n            return value\n\n        return octets.str2octs('')\n\nif sys.version_info[0] <= 2:\n    intTypes = (int, long)\nelse:\n    intTypes = (int,)\n\nnumericTypes = intTypes + (float,)\n\n\nclass ObjectIdentifier(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`tuple` objects\n    (tuple of non-negative integers).\n\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`str` or |ASN.1| object\n        Python sequence of :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class ID(ObjectIdentifier):\n            '''\n            ASN.1 specification:\n\n            ID ::= OBJECT IDENTIFIER\n\n            id-edims ID ::= { joint-iso-itu-t mhs-motif(6) edims(7) }\n            id-bp ID ::= { id-edims 11 }\n            '''\n        id_edims = ID('2.6.7')\n        id_bp = id_edims + (11,)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x06)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __add__(self, other):\n        return self.clone(self._value + other)\n\n    def __radd__(self, other):\n        return self.clone(other + self._value)\n\n    def asTuple(self):\n        return self._value\n\n    # Sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def index(self, suboid):\n        return self._value.index(suboid)\n\n    def isPrefixOf(self, other):\n        \"\"\"Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.\n\n        Parameters\n        ----------\n        other: |ASN.1| object\n            |ASN.1| object\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object\n            or :obj:`False` otherwise.\n        \"\"\"\n        l = len(self)\n        if l <= len(other):\n            if self._value[:l] == other[:l]:\n                return True\n        return False\n\n    def prettyIn(self, value):\n        if isinstance(value, ObjectIdentifier):\n            return tuple(value)\n        elif octets.isStringType(value):\n            if '-' in value:\n                raise error.PyAsn1Error(\n                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n            try:\n                return tuple([int(subOid) for subOid in value.split('.') if subOid])\n            except ValueError:\n                raise error.PyAsn1Error(\n                    'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n\n        try:\n            tupleOfInts = tuple([int(subOid) for subOid in value if subOid >= 0])\n\n        except (ValueError, TypeError):\n            raise error.PyAsn1Error(\n                'Malformed Object ID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n            )\n\n        if len(tupleOfInts) == len(value):\n            return tupleOfInts\n\n        raise error.PyAsn1Error('Malformed Object ID %s at %s' % (value, self.__class__.__name__))\n\n    def prettyOut(self, value):\n        return '.'.join([str(x) for x in value])\n\n\nclass RelativeOID(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`tuple` objects\n    (tuple of non-negative integers).\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`str` or |ASN.1| object\n        Python sequence of :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n    Examples\n    --------\n    .. code-block:: python\n        class RelOID(RelativeOID):\n            '''\n            ASN.1 specification:\n            id-pad-null RELATIVE-OID ::= { 0 }\n            id-pad-once RELATIVE-OID ::= { 5 6 }\n            id-pad-twice RELATIVE-OID ::= { 5 6 7 }\n            '''\n        id_pad_null = RelOID('0')\n        id_pad_once = RelOID('5.6')\n        id_pad_twice = id_pad_once + (7,)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0d)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    def __add__(self, other):\n        return self.clone(self._value + other)\n\n    def __radd__(self, other):\n        return self.clone(other + self._value)\n\n    def asTuple(self):\n        return self._value\n\n    # Sequence object protocol\n\n    def __len__(self):\n        return len(self._value)\n\n    def __getitem__(self, i):\n        if i.__class__ is slice:\n            return self.clone(self._value[i])\n        else:\n            return self._value[i]\n\n    def __iter__(self):\n        return iter(self._value)\n\n    def __contains__(self, value):\n        return value in self._value\n\n    def index(self, suboid):\n        return self._value.index(suboid)\n\n    def isPrefixOf(self, other):\n        \"\"\"Indicate if this |ASN.1| object is a prefix of other |ASN.1| object.\n        Parameters\n        ----------\n        other: |ASN.1| object\n            |ASN.1| object\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if this |ASN.1| object is a parent (e.g. prefix) of the other |ASN.1| object\n            or :obj:`False` otherwise.\n        \"\"\"\n        l = len(self)\n        if l <= len(other):\n            if self._value[:l] == other[:l]:\n                return True\n        return False\n\n    def prettyIn(self, value):\n        if isinstance(value, RelativeOID):\n            return tuple(value)\n        elif octets.isStringType(value):\n            if '-' in value:\n                raise error.PyAsn1Error(\n                    'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n            try:\n                return tuple([int(subOid) for subOid in value.split('.') if subOid])\n            except ValueError:\n                raise error.PyAsn1Error(\n                    'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n                )\n\n        try:\n            tupleOfInts = tuple([int(subOid) for subOid in value if subOid >= 0])\n\n        except (ValueError, TypeError):\n            raise error.PyAsn1Error(\n                'Malformed RELATIVE-OID %s at %s: %s' % (value, self.__class__.__name__, sys.exc_info()[1])\n            )\n\n        if len(tupleOfInts) == len(value):\n            return tupleOfInts\n\n        raise error.PyAsn1Error('Malformed RELATIVE-OID %s at %s' % (value, self.__class__.__name__))\n\n    def prettyOut(self, value):\n        return '.'.join([str(x) for x in value])\n\n\nclass Real(base.SimpleAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`float` objects.\n    Additionally, |ASN.1| objects behave like a :class:`tuple` in which case its\n    elements are mantissa, base and exponent.\n\n    Keyword Args\n    ------------\n    value: :class:`tuple`, :class:`float` or |ASN.1| object\n        Python sequence of :class:`int` (representing mantissa, base and\n        exponent) or :class:`float` instance or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Pi(Real):\n            '''\n            ASN.1 specification:\n\n            Pi ::= REAL\n\n            pi Pi ::= { mantissa 314159, base 10, exponent -5 }\n\n            '''\n        pi = Pi((314159, 10, -5))\n    \"\"\"\n    binEncBase = None  # binEncBase = 16 is recommended for large numbers\n\n    try:\n        _plusInf = float('inf')\n        _minusInf = float('-inf')\n        _inf = _plusInf, _minusInf\n\n    except ValueError:\n        # Infinity support is platform and Python dependent\n        _plusInf = _minusInf = None\n        _inf = ()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x09)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = base.SimpleAsn1Type.getTypeId()\n\n    @staticmethod\n    def __normalizeBase10(value):\n        m, b, e = value\n        while m and m % 10 == 0:\n            m /= 10\n            e += 1\n        return m, b, e\n\n    def prettyIn(self, value):\n        if isinstance(value, tuple) and len(value) == 3:\n            if (not isinstance(value[0], numericTypes) or\n                    not isinstance(value[1], intTypes) or\n                    not isinstance(value[2], intTypes)):\n                raise error.PyAsn1Error('Lame Real value syntax: %s' % (value,))\n            if (isinstance(value[0], float) and\n                    self._inf and value[0] in self._inf):\n                return value[0]\n            if value[1] not in (2, 10):\n                raise error.PyAsn1Error(\n                    'Prohibited base for Real value: %s' % (value[1],)\n                )\n            if value[1] == 10:\n                value = self.__normalizeBase10(value)\n            return value\n        elif isinstance(value, intTypes):\n            return self.__normalizeBase10((value, 10, 0))\n        elif isinstance(value, float) or octets.isStringType(value):\n            if octets.isStringType(value):\n                try:\n                    value = float(value)\n                except ValueError:\n                    raise error.PyAsn1Error(\n                        'Bad real value syntax: %s' % (value,)\n                    )\n            if self._inf and value in self._inf:\n                return value\n            else:\n                e = 0\n                while int(value) != value:\n                    value *= 10\n                    e -= 1\n                return self.__normalizeBase10((int(value), 10, e))\n        elif isinstance(value, Real):\n            return tuple(value)\n        raise error.PyAsn1Error(\n            'Bad real value syntax: %s' % (value,)\n        )\n\n    def prettyPrint(self, scope=0):\n        try:\n            return self.prettyOut(float(self))\n\n        except OverflowError:\n            return '<overflow>'\n\n    @property\n    def isPlusInf(self):\n        \"\"\"Indicate PLUS-INFINITY object value\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if calling object represents plus infinity\n            or :obj:`False` otherwise.\n\n        \"\"\"\n        return self._value == self._plusInf\n\n    @property\n    def isMinusInf(self):\n        \"\"\"Indicate MINUS-INFINITY object value\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`True` if calling object represents minus infinity\n            or :obj:`False` otherwise.\n        \"\"\"\n        return self._value == self._minusInf\n\n    @property\n    def isInf(self):\n        return self._value in self._inf\n\n    def __add__(self, value):\n        return self.clone(float(self) + value)\n\n    def __radd__(self, value):\n        return self + value\n\n    def __mul__(self, value):\n        return self.clone(float(self) * value)\n\n    def __rmul__(self, value):\n        return self * value\n\n    def __sub__(self, value):\n        return self.clone(float(self) - value)\n\n    def __rsub__(self, value):\n        return self.clone(value - float(self))\n\n    def __mod__(self, value):\n        return self.clone(float(self) % value)\n\n    def __rmod__(self, value):\n        return self.clone(value % float(self))\n\n    def __pow__(self, value, modulo=None):\n        return self.clone(pow(float(self), value, modulo))\n\n    def __rpow__(self, value):\n        return self.clone(pow(value, float(self)))\n\n    if sys.version_info[0] <= 2:\n        def __div__(self, value):\n            return self.clone(float(self) / value)\n\n        def __rdiv__(self, value):\n            return self.clone(value / float(self))\n    else:\n        def __truediv__(self, value):\n            return self.clone(float(self) / value)\n\n        def __rtruediv__(self, value):\n            return self.clone(value / float(self))\n\n        def __divmod__(self, value):\n            return self.clone(float(self) // value)\n\n        def __rdivmod__(self, value):\n            return self.clone(value // float(self))\n\n    def __int__(self):\n        return int(float(self))\n\n    if sys.version_info[0] <= 2:\n        def __long__(self):\n            return long(float(self))\n\n    def __float__(self):\n        if self._value in self._inf:\n            return self._value\n        else:\n            return float(\n                self._value[0] * pow(self._value[1], self._value[2])\n            )\n\n    def __abs__(self):\n        return self.clone(abs(float(self)))\n\n    def __pos__(self):\n        return self.clone(+float(self))\n\n    def __neg__(self):\n        return self.clone(-float(self))\n\n    def __round__(self, n=0):\n        r = round(float(self), n)\n        if n:\n            return self.clone(r)\n        else:\n            return r\n\n    def __floor__(self):\n        return self.clone(math.floor(float(self)))\n\n    def __ceil__(self):\n        return self.clone(math.ceil(float(self)))\n\n    def __trunc__(self):\n        return self.clone(math.trunc(float(self)))\n\n    def __lt__(self, value):\n        return float(self) < value\n\n    def __le__(self, value):\n        return float(self) <= value\n\n    def __eq__(self, value):\n        return float(self) == value\n\n    def __ne__(self, value):\n        return float(self) != value\n\n    def __gt__(self, value):\n        return float(self) > value\n\n    def __ge__(self, value):\n        return float(self) >= value\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return bool(float(self))\n    else:\n        def __bool__(self):\n            return bool(float(self))\n\n        __hash__ = base.SimpleAsn1Type.__hash__\n\n    def __getitem__(self, idx):\n        if self._value in self._inf:\n            raise error.PyAsn1Error('Invalid infinite value operation')\n        else:\n            return self._value[idx]\n\n    # compatibility stubs\n\n    def isPlusInfinity(self):\n        return self.isPlusInf\n\n    def isMinusInfinity(self):\n        return self.isMinusInf\n\n    def isInfinity(self):\n        return self.isInf\n\n\nclass Enumerated(Integer):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`, its\n    objects are immutable and duck-type Python :class:`int` objects.\n\n    Keyword Args\n    ------------\n    value: :class:`int`, :class:`str` or |ASN.1| object\n        Python :class:`int` or :class:`str` literal or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    namedValues: :py:class:`~pyasn1.type.namedval.NamedValues`\n        Object representing non-default symbolic aliases for numbers\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class RadioButton(Enumerated):\n            '''\n            ASN.1 specification:\n\n            RadioButton ::= ENUMERATED { button1(0), button2(1),\n                                         button3(2) }\n\n            selected-by-default RadioButton ::= button1\n            '''\n            namedValues = NamedValues(\n                ('button1', 0), ('button2', 1),\n                ('button3', 2)\n            )\n\n        selected_by_default = RadioButton('button1')\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x0A)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Optimization for faster codec lookup\n    typeId = Integer.getTypeId()\n\n    #: Default :py:class:`~pyasn1.type.namedval.NamedValues` object\n    #: representing symbolic aliases for numbers\n    namedValues = namedval.NamedValues()\n\n\n# \"Structured\" ASN.1 types\n\nclass SequenceOfAndSetOfBase(base.ConstructedAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`list` objects.\n\n    Keyword Args\n    ------------\n    componentType : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n        A pyasn1 object representing ASN.1 type allowed within |ASN.1| type\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class LotteryDraw(SequenceOf):  #  SetOf is similar\n            '''\n            ASN.1 specification:\n\n            LotteryDraw ::= SEQUENCE OF INTEGER\n            '''\n            componentType = Integer()\n\n        lotteryDraw = LotteryDraw()\n        lotteryDraw.extend([123, 456, 789])\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n        # support positional params for backward compatibility\n        if args:\n            for key, value in zip(('componentType', 'tagSet',\n                                   'subtypeSpec'), args):\n                if key in kwargs:\n                    raise error.PyAsn1Error('Conflicting positional and keyword params!')\n                kwargs['componentType'] = value\n\n        self._componentValues = noValue\n\n        base.ConstructedAsn1Type.__init__(self, **kwargs)\n\n    # Python list protocol\n\n    def __getitem__(self, idx):\n        try:\n            return self.getComponentByPosition(idx)\n\n        except error.PyAsn1Error:\n            raise IndexError(sys.exc_info()[1])\n\n    def __setitem__(self, idx, value):\n        try:\n            self.setComponentByPosition(idx, value)\n\n        except error.PyAsn1Error:\n            raise IndexError(sys.exc_info()[1])\n\n    def append(self, value):\n        if self._componentValues is noValue:\n            pos = 0\n\n        else:\n            pos = len(self._componentValues)\n\n        self[pos] = value\n\n    def count(self, value):\n        return list(self._componentValues.values()).count(value)\n\n    def extend(self, values):\n        for value in values:\n            self.append(value)\n\n        if self._componentValues is noValue:\n            self._componentValues = {}\n\n    def index(self, value, start=0, stop=None):\n        if stop is None:\n            stop = len(self)\n\n        indices, values = zip(*self._componentValues.items())\n\n        # TODO: remove when Py2.5 support is gone\n        values = list(values)\n\n        try:\n            return indices[values.index(value, start, stop)]\n\n        except error.PyAsn1Error:\n            raise ValueError(sys.exc_info()[1])\n\n    def reverse(self):\n        self._componentValues.reverse()\n\n    def sort(self, key=None, reverse=False):\n        self._componentValues = dict(\n            enumerate(sorted(self._componentValues.values(),\n                             key=key, reverse=reverse)))\n\n    def __len__(self):\n        if self._componentValues is noValue or not self._componentValues:\n            return 0\n\n        return max(self._componentValues) + 1\n\n    def __iter__(self):\n        for idx in range(0, len(self)):\n            yield self.getComponentByPosition(idx)\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        for idx, componentValue in self._componentValues.items():\n            if componentValue is not noValue:\n                if isinstance(componentValue, base.ConstructedAsn1Type):\n                    myClone.setComponentByPosition(\n                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)\n                    )\n                else:\n                    myClone.setComponentByPosition(idx, componentValue.clone())\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        \"\"\"Return |ASN.1| type component value by position.\n\n        Equivalent to Python sequence subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx : :class:`int`\n            Component index (zero-based). Must either refer to an existing\n            component or to N+1 component (if *componentType* is set). In the latter\n            case a new component type gets instantiated and appended to the |ASN.1|\n            sequence.\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue` object will be\n            returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            Instantiate |ASN.1| component type or return existing component value\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            # can also be SetOf\n            class MySequenceOf(SequenceOf):\n                componentType = OctetString()\n\n            s = MySequenceOf()\n\n            # returns component #0 with `.isValue` property False\n            s.getComponentByPosition(0)\n\n            # returns None\n            s.getComponentByPosition(0, default=None)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n\n            # sets component #0 to OctetString() ASN.1 schema\n            # object and returns it\n            s.getComponentByPosition(0, instantiate=True)\n\n            # sets component #0 to ASN.1 value object\n            s.setComponentByPosition(0, 'ABCD')\n\n            # returns OctetString('ABCD') value object\n            s.getComponentByPosition(0, instantiate=False)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n        \"\"\"\n        if isinstance(idx, slice):\n            indices = tuple(range(len(self)))\n            return [self.getComponentByPosition(subidx, default, instantiate)\n                    for subidx in indices[idx]]\n\n        if idx < 0:\n            idx = len(self) + idx\n            if idx < 0:\n                raise error.PyAsn1Error(\n                    'SequenceOf/SetOf index is out of range')\n\n        try:\n            componentValue = self._componentValues[idx]\n\n        except (KeyError, error.PyAsn1Error):\n            if not instantiate:\n                return default\n\n            self.setComponentByPosition(idx)\n\n            componentValue = self._componentValues[idx]\n\n        if default is noValue or componentValue.isValue:\n            return componentValue\n        else:\n            return default\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`)\n        or list.append() (when idx == len(self)).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component or to N+1 component. In the latter case a new component\n            type gets instantiated (if *componentType* is set, or given ASN.1\n            object is taken otherwise) and appended to the |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints: :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n\n        Raises\n        ------\n        ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n            On constraint violation or bad initializer\n        IndexError\n            When idx > len(self)\n        \"\"\"\n        if isinstance(idx, slice):\n            indices = tuple(range(len(self)))\n            startIdx = indices and indices[idx][0] or 0\n            for subIdx, subValue in enumerate(value):\n                self.setComponentByPosition(\n                    startIdx + subIdx, subValue, verifyConstraints,\n                    matchTags, matchConstraints)\n            return self\n\n        if idx < 0:\n            idx = len(self) + idx\n            if idx < 0:\n                raise error.PyAsn1Error(\n                    'SequenceOf/SetOf index is out of range')\n\n        componentType = self.componentType\n\n        if self._componentValues is noValue:\n            componentValues = {}\n\n        else:\n            componentValues = self._componentValues\n\n        currentValue = componentValues.get(idx, noValue)\n\n        if value is noValue:\n            if componentType is not None:\n                value = componentType.clone()\n\n            elif currentValue is noValue:\n                raise error.PyAsn1Error('Component type not defined')\n\n        elif not isinstance(value, base.Asn1Item):\n            if (componentType is not None and\n                    isinstance(componentType, base.SimpleAsn1Type)):\n                value = componentType.clone(value=value)\n\n            elif (currentValue is not noValue and\n                    isinstance(currentValue, base.SimpleAsn1Type)):\n                value = currentValue.clone(value=value)\n\n            else:\n                raise error.PyAsn1Error(\n                    'Non-ASN.1 value %r and undefined component'\n                    ' type at %r' % (value, self))\n\n        elif componentType is not None and (matchTags or matchConstraints):\n            subtypeChecker = (\n                    self.strictConstraints and\n                    componentType.isSameTypeWith or\n                    componentType.isSuperTypeOf)\n\n            if not subtypeChecker(value, verifyConstraints and matchTags,\n                                  verifyConstraints and matchConstraints):\n                # TODO: we should wrap componentType with UnnamedType to carry\n                # additional properties associated with componentType\n                if componentType.typeId != Any.typeId:\n                    raise error.PyAsn1Error(\n                        'Component value is tag-incompatible: %r vs '\n                        '%r' % (value, componentType))\n\n        componentValues[idx] = value\n\n        self._componentValues = componentValues\n\n        return self\n\n    @property\n    def componentTagMap(self):\n        if self.componentType is not None:\n            return self.componentType.tagMap\n\n    @property\n    def components(self):\n        return [self._componentValues[idx]\n                for idx in sorted(self._componentValues)]\n\n    def clear(self):\n        \"\"\"Remove all components and become an empty |ASN.1| value object.\n\n        Has the same effect on |ASN.1| object as it does on :class:`list`\n        built-in.\n        \"\"\"\n        self._componentValues = {}\n        return self\n\n    def reset(self):\n        \"\"\"Remove all components and become a |ASN.1| schema object.\n\n        See :meth:`isValue` property for more information on the\n        distinction between value and schema objects.\n        \"\"\"\n        self._componentValues = noValue\n        return self\n\n    def prettyPrint(self, scope=0):\n        scope += 1\n        representation = self.__class__.__name__ + ':\\n'\n\n        if not self.isValue:\n            return representation\n\n        for idx, componentValue in enumerate(self):\n            representation += ' ' * scope\n            if (componentValue is noValue and\n                    self.componentType is not None):\n                representation += '<empty>'\n            else:\n                representation += componentValue.prettyPrint(scope)\n\n        return representation\n\n    def prettyPrintType(self, scope=0):\n        scope += 1\n        representation = '%s -> %s {\\n' % (self.tagSet, self.__class__.__name__)\n        if self.componentType is not None:\n            representation += ' ' * scope\n            representation += self.componentType.prettyPrintType(scope)\n        return representation + '\\n' + ' ' * (scope - 1) + '}'\n\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object\n        (e.g. :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        if self._componentValues is noValue:\n            return False\n\n        if len(self._componentValues) != len(self):\n            return False\n\n        for componentValue in self._componentValues.values():\n            if componentValue is noValue or not componentValue.isValue:\n                return False\n\n        return True\n\n    @property\n    def isInconsistent(self):\n        \"\"\"Run necessary checks to ensure |ASN.1| object consistency.\n\n        Default action is to verify |ASN.1| object against constraints imposed\n        by `subtypeSpec`.\n\n        Raises\n        ------\n        :py:class:`~pyasn1.error.PyAsn1tError` on any inconsistencies found\n        \"\"\"\n        if self.componentType is noValue or not self.subtypeSpec:\n            return False\n\n        if self._componentValues is noValue:\n            return True\n\n        mapping = {}\n\n        for idx, value in self._componentValues.items():\n            # Absent fields are not in the mapping\n            if value is noValue:\n                continue\n\n            mapping[idx] = value\n\n        try:\n            # Represent SequenceOf/SetOf as a bare dict to constraints chain\n            self.subtypeSpec(mapping)\n\n        except error.PyAsn1Error:\n            exc = sys.exc_info()[1]\n            return exc\n\n        return False\n\nclass SequenceOf(SequenceOfAndSetOfBase):\n    __doc__ = SequenceOfAndSetOfBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n    )\n\n    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = None\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceOfAndSetOfBase.getTypeId()\n\n\nclass SetOf(SequenceOfAndSetOfBase):\n    __doc__ = SequenceOfAndSetOfBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n    )\n\n    #: Default :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = None\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceOfAndSetOfBase.getTypeId()\n\n\nclass SequenceAndSetBase(base.ConstructedAsn1Type):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`dict` objects.\n\n    Keyword Args\n    ------------\n    componentType: :py:class:`~pyasn1.type.namedtype.NamedType`\n        Object holding named ASN.1 types allowed within this collection\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).  Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Description(Sequence):  #  Set is similar\n            '''\n            ASN.1 specification:\n\n            Description ::= SEQUENCE {\n                surname    IA5String,\n                first-name IA5String OPTIONAL,\n                age        INTEGER DEFAULT 40\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('surname', IA5String()),\n                OptionalNamedType('first-name', IA5String()),\n                DefaultedNamedType('age', Integer(40))\n            )\n\n        descr = Description()\n        descr['surname'] = 'Smith'\n        descr['first-name'] = 'John'\n    \"\"\"\n    #: Default :py:class:`~pyasn1.type.namedtype.NamedTypes`\n    #: object representing named ASN.1 types allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n\n    class DynamicNames(object):\n        \"\"\"Fields names/positions mapping for component-less objects\"\"\"\n        def __init__(self):\n            self._keyToIdxMap = {}\n            self._idxToKeyMap = {}\n\n        def __len__(self):\n            return len(self._keyToIdxMap)\n\n        def __contains__(self, item):\n            return item in self._keyToIdxMap or item in self._idxToKeyMap\n\n        def __iter__(self):\n            return (self._idxToKeyMap[idx] for idx in range(len(self._idxToKeyMap)))\n\n        def __getitem__(self, item):\n            try:\n                return self._keyToIdxMap[item]\n\n            except KeyError:\n                return self._idxToKeyMap[item]\n\n        def getNameByPosition(self, idx):\n            try:\n                return self._idxToKeyMap[idx]\n\n            except KeyError:\n                raise error.PyAsn1Error('Type position out of range')\n\n        def getPositionByName(self, name):\n            try:\n                return self._keyToIdxMap[name]\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        def addField(self, idx):\n            self._keyToIdxMap['field-%d' % idx] = idx\n            self._idxToKeyMap[idx] = 'field-%d' % idx\n\n\n    def __init__(self, **kwargs):\n        base.ConstructedAsn1Type.__init__(self, **kwargs)\n        self._componentTypeLen = len(self.componentType)\n        if self._componentTypeLen:\n            self._componentValues = []\n        else:\n            self._componentValues = noValue\n        self._dynamicNames = self._componentTypeLen or self.DynamicNames()\n\n    def __getitem__(self, idx):\n        if octets.isStringType(idx):\n            try:\n                return self.getComponentByName(idx)\n\n            except error.PyAsn1Error:\n                # duck-typing dict\n                raise KeyError(sys.exc_info()[1])\n\n        else:\n            try:\n                return self.getComponentByPosition(idx)\n\n            except error.PyAsn1Error:\n                # duck-typing list\n                raise IndexError(sys.exc_info()[1])\n\n    def __setitem__(self, idx, value):\n        if octets.isStringType(idx):\n            try:\n                self.setComponentByName(idx, value)\n\n            except error.PyAsn1Error:\n                # duck-typing dict\n                raise KeyError(sys.exc_info()[1])\n\n        else:\n            try:\n                self.setComponentByPosition(idx, value)\n\n            except error.PyAsn1Error:\n                # duck-typing list\n                raise IndexError(sys.exc_info()[1])\n\n    def __contains__(self, key):\n        if self._componentTypeLen:\n            return key in self.componentType\n        else:\n            return key in self._dynamicNames\n\n    def __len__(self):\n        return len(self._componentValues)\n\n    def __iter__(self):\n        return iter(self.componentType or self._dynamicNames)\n\n    # Python dict protocol\n\n    def values(self):\n        for idx in range(self._componentTypeLen or len(self._dynamicNames)):\n            yield self[idx]\n\n    def keys(self):\n        return iter(self)\n\n    def items(self):\n        for idx in range(self._componentTypeLen or len(self._dynamicNames)):\n            if self._componentTypeLen:\n                yield self.componentType[idx].name, self[idx]\n            else:\n                yield self._dynamicNames[idx], self[idx]\n\n    def update(self, *iterValue, **mappingValue):\n        for k, v in iterValue:\n            self[k] = v\n        for k in mappingValue:\n            self[k] = mappingValue[k]\n\n    def clear(self):\n        \"\"\"Remove all components and become an empty |ASN.1| value object.\n\n        Has the same effect on |ASN.1| object as it does on :class:`dict`\n        built-in.\n        \"\"\"\n        self._componentValues = []\n        self._dynamicNames = self.DynamicNames()\n        return self\n\n    def reset(self):\n        \"\"\"Remove all components and become a |ASN.1| schema object.\n\n        See :meth:`isValue` property for more information on the\n        distinction between value and schema objects.\n        \"\"\"\n        self._componentValues = noValue\n        self._dynamicNames = self.DynamicNames()\n        return self\n\n    @property\n    def components(self):\n        return self._componentValues\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        if self._componentValues is noValue:\n            return\n\n        for idx, componentValue in enumerate(self._componentValues):\n            if componentValue is not noValue:\n                if isinstance(componentValue, base.ConstructedAsn1Type):\n                    myClone.setComponentByPosition(\n                        idx, componentValue.clone(cloneValueFlag=cloneValueFlag)\n                    )\n                else:\n                    myClone.setComponentByPosition(idx, componentValue.clone())\n\n    def getComponentByName(self, name, default=noValue, instantiate=True):\n        \"\"\"Returns |ASN.1| type component by name.\n\n        Equivalent to Python :class:`dict` subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        name: :class:`str`\n            |ASN.1| type component name\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            Instantiate |ASN.1| component type or return existing\n            component value\n        \"\"\"\n        if self._componentTypeLen:\n            idx = self.componentType.getPositionByName(name)\n        else:\n            try:\n                idx = self._dynamicNames.getPositionByName(name)\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        return self.getComponentByPosition(idx, default=default, instantiate=instantiate)\n\n    def setComponentByName(self, name, value=noValue,\n                           verifyConstraints=True,\n                           matchTags=True,\n                           matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by name.\n\n        Equivalent to Python :class:`dict` item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        name: :class:`str`\n            |ASN.1| type component name\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints: :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        if self._componentTypeLen:\n            idx = self.componentType.getPositionByName(name)\n        else:\n            try:\n                idx = self._dynamicNames.getPositionByName(name)\n\n            except KeyError:\n                raise error.PyAsn1Error('Name %s not found' % (name,))\n\n        return self.setComponentByPosition(\n            idx, value, verifyConstraints, matchTags, matchConstraints\n        )\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        \"\"\"Returns |ASN.1| type component by index.\n\n        Equivalent to Python sequence subscription operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to an existing\n            component or (if *componentType* is set) new ASN.1 schema object gets\n            instantiated.\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`NoValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a PyASN1 object\n\n        Examples\n        --------\n\n        .. code-block:: python\n\n            # can also be Set\n            class MySequence(Sequence):\n                componentType = NamedTypes(\n                    NamedType('id', OctetString())\n                )\n\n            s = MySequence()\n\n            # returns component #0 with `.isValue` property False\n            s.getComponentByPosition(0)\n\n            # returns None\n            s.getComponentByPosition(0, default=None)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n\n            # sets component #0 to OctetString() ASN.1 schema\n            # object and returns it\n            s.getComponentByPosition(0, instantiate=True)\n\n            # sets component #0 to ASN.1 value object\n            s.setComponentByPosition(0, 'ABCD')\n\n            # returns OctetString('ABCD') value object\n            s.getComponentByPosition(0, instantiate=False)\n\n            s.clear()\n\n            # returns noValue\n            s.getComponentByPosition(0, instantiate=False)\n        \"\"\"\n        try:\n            if self._componentValues is noValue:\n                componentValue = noValue\n\n            else:\n                componentValue = self._componentValues[idx]\n\n        except IndexError:\n            componentValue = noValue\n\n        if not instantiate:\n            if componentValue is noValue or not componentValue.isValue:\n                return default\n            else:\n                return componentValue\n\n        if componentValue is noValue:\n            self.setComponentByPosition(idx)\n\n        componentValue = self._componentValues[idx]\n\n        if default is noValue or componentValue.isValue:\n            return componentValue\n        else:\n            return default\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx : :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component (if *componentType* is set) or to N+1 component\n            otherwise. In the latter case a new component of given ASN.1\n            type gets instantiated and appended to |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n             If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n             If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n             If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        componentType = self.componentType\n        componentTypeLen = self._componentTypeLen\n\n        if self._componentValues is noValue:\n            componentValues = []\n\n        else:\n            componentValues = self._componentValues\n\n        try:\n            currentValue = componentValues[idx]\n\n        except IndexError:\n            currentValue = noValue\n            if componentTypeLen:\n                if componentTypeLen < idx:\n                    raise error.PyAsn1Error('component index out of range')\n\n                componentValues = [noValue] * componentTypeLen\n\n        if value is noValue:\n            if componentTypeLen:\n                value = componentType.getTypeByPosition(idx)\n                if isinstance(value, base.ConstructedAsn1Type):\n                    value = value.clone(cloneValueFlag=componentType[idx].isDefaulted)\n\n            elif currentValue is noValue:\n                raise error.PyAsn1Error('Component type not defined')\n\n        elif not isinstance(value, base.Asn1Item):\n            if componentTypeLen:\n                subComponentType = componentType.getTypeByPosition(idx)\n                if isinstance(subComponentType, base.SimpleAsn1Type):\n                    value = subComponentType.clone(value=value)\n\n                else:\n                    raise error.PyAsn1Error('%s can cast only scalar values' % componentType.__class__.__name__)\n\n            elif currentValue is not noValue and isinstance(currentValue, base.SimpleAsn1Type):\n                value = currentValue.clone(value=value)\n\n            else:\n                raise error.PyAsn1Error('%s undefined component type' % componentType.__class__.__name__)\n\n        elif ((verifyConstraints or matchTags or matchConstraints) and\n              componentTypeLen):\n            subComponentType = componentType.getTypeByPosition(idx)\n            if subComponentType is not noValue:\n                subtypeChecker = (self.strictConstraints and\n                                  subComponentType.isSameTypeWith or\n                                  subComponentType.isSuperTypeOf)\n\n                if not subtypeChecker(value, verifyConstraints and matchTags,\n                                      verifyConstraints and matchConstraints):\n                    if not componentType[idx].openType:\n                        raise error.PyAsn1Error('Component value is tag-incompatible: %r vs %r' % (value, componentType))\n\n        if componentTypeLen or idx in self._dynamicNames:\n            componentValues[idx] = value\n\n        elif len(componentValues) == idx:\n            componentValues.append(value)\n            self._dynamicNames.addField(idx)\n\n        else:\n            raise error.PyAsn1Error('Component index out of range')\n\n        self._componentValues = componentValues\n\n        return self\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object (e.g.\n        :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a\n            normal value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n\n        It is sufficient for |ASN.1| objects to have all non-optional and non-defaulted\n        components being value objects to be considered as a value objects as a whole.\n        In other words, even having one or more optional components not turned into\n        value objects, |ASN.1| object is still considered as a value object. Defaulted\n        components are normally value objects by default.\n        \"\"\"\n        if self._componentValues is noValue:\n            return False\n\n        componentType = self.componentType\n\n        if componentType:\n            for idx, subComponentType in enumerate(componentType.namedTypes):\n                if subComponentType.isDefaulted or subComponentType.isOptional:\n                    continue\n\n                if not self._componentValues:\n                    return False\n\n                componentValue = self._componentValues[idx]\n                if componentValue is noValue or not componentValue.isValue:\n                    return False\n\n        else:\n            for componentValue in self._componentValues:\n                if componentValue is noValue or not componentValue.isValue:\n                    return False\n\n        return True\n\n    @property\n    def isInconsistent(self):\n        \"\"\"Run necessary checks to ensure |ASN.1| object consistency.\n\n        Default action is to verify |ASN.1| object against constraints imposed\n        by `subtypeSpec`.\n\n        Raises\n        ------\n        :py:class:`~pyasn1.error.PyAsn1tError` on any inconsistencies found\n        \"\"\"\n        if self.componentType is noValue or not self.subtypeSpec:\n            return False\n\n        if self._componentValues is noValue:\n            return True\n\n        mapping = {}\n\n        for idx, value in enumerate(self._componentValues):\n            # Absent fields are not in the mapping\n            if value is noValue:\n                continue\n\n            name = self.componentType.getNameByPosition(idx)\n\n            mapping[name] = value\n\n        try:\n            # Represent Sequence/Set as a bare dict to constraints chain\n            self.subtypeSpec(mapping)\n\n        except error.PyAsn1Error:\n            exc = sys.exc_info()[1]\n            return exc\n\n        return False\n\n    def prettyPrint(self, scope=0):\n        \"\"\"Return an object representation string.\n\n        Returns\n        -------\n        : :class:`str`\n            Human-friendly object representation.\n        \"\"\"\n        scope += 1\n        representation = self.__class__.__name__ + ':\\n'\n        for idx, componentValue in enumerate(self._componentValues):\n            if componentValue is not noValue and componentValue.isValue:\n                representation += ' ' * scope\n                if self.componentType:\n                    representation += self.componentType.getNameByPosition(idx)\n                else:\n                    representation += self._dynamicNames.getNameByPosition(idx)\n                representation = '%s=%s\\n' % (\n                    representation, componentValue.prettyPrint(scope)\n                )\n        return representation\n\n    def prettyPrintType(self, scope=0):\n        scope += 1\n        representation = '%s -> %s {\\n' % (self.tagSet, self.__class__.__name__)\n        for idx, componentType in enumerate(self.componentType.values() or self._componentValues):\n            representation += ' ' * scope\n            if self.componentType:\n                representation += '\"%s\"' % self.componentType.getNameByPosition(idx)\n            else:\n                representation += '\"%s\"' % self._dynamicNames.getNameByPosition(idx)\n            representation = '%s = %s\\n' % (\n                representation, componentType.prettyPrintType(scope)\n            )\n        return representation + '\\n' + ' ' * (scope - 1) + '}'\n\n    # backward compatibility\n\n    def setDefaultComponents(self):\n        return self\n\n    def getComponentType(self):\n        if self._componentTypeLen:\n            return self.componentType\n\n    def getNameByPosition(self, idx):\n        if self._componentTypeLen:\n            return self.componentType[idx].name\n\nclass Sequence(SequenceAndSetBase):\n    __doc__ = SequenceAndSetBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x10)\n    )\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object imposing size constraint on |ASN.1| objects\n    componentType = namedtype.NamedTypes()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceAndSetBase.getTypeId()\n\n    # backward compatibility\n\n    def getComponentTagMapNearPosition(self, idx):\n        if self.componentType:\n            return self.componentType.getTagMapNearPosition(idx)\n\n    def getComponentPositionNearType(self, tagSet, idx):\n        if self.componentType:\n            return self.componentType.getPositionNearType(tagSet, idx)\n        else:\n            return idx\n\n\nclass Set(SequenceAndSetBase):\n    __doc__ = SequenceAndSetBase.__doc__\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatConstructed, 0x11)\n    )\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = SequenceAndSetBase.getTypeId()\n\n    def getComponent(self, innerFlag=False):\n        return self\n\n    def getComponentByType(self, tagSet, default=noValue,\n                           instantiate=True, innerFlag=False):\n        \"\"\"Returns |ASN.1| type component by ASN.1 tag.\n\n        Parameters\n        ----------\n        tagSet : :py:class:`~pyasn1.type.tag.TagSet`\n            Object representing ASN.1 tags to identify one of\n            |ASN.1| object component\n\n        Keyword Args\n        ------------\n        default: :class:`object`\n            If set and requested component is a schema object, return the `default`\n            object instead of the requested component.\n\n        instantiate: :class:`bool`\n            If :obj:`True` (default), inner component will be automatically\n            instantiated.\n            If :obj:`False` either existing component or the :class:`noValue`\n            object will be returned.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a pyasn1 object\n        \"\"\"\n        componentValue = self.getComponentByPosition(\n            self.componentType.getPositionByType(tagSet),\n            default=default, instantiate=instantiate\n        )\n        if innerFlag and isinstance(componentValue, Set):\n            # get inner component by inner tagSet\n            return componentValue.getComponent(innerFlag=True)\n        else:\n            # get outer component by inner tagSet\n            return componentValue\n\n    def setComponentByType(self, tagSet, value=noValue,\n                           verifyConstraints=True,\n                           matchTags=True,\n                           matchConstraints=True,\n                           innerFlag=False):\n        \"\"\"Assign |ASN.1| type component by ASN.1 tag.\n\n        Parameters\n        ----------\n        tagSet : :py:class:`~pyasn1.type.tag.TagSet`\n            Object representing ASN.1 tags to identify one of\n            |ASN.1| object component\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n            If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n            If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n            If :obj:`False`, skip component constraints matching\n\n        innerFlag: :class:`bool`\n            If :obj:`True`, search for matching *tagSet* recursively.\n\n        Returns\n        -------\n        self\n        \"\"\"\n        idx = self.componentType.getPositionByType(tagSet)\n\n        if innerFlag:  # set inner component by inner tagSet\n            componentType = self.componentType.getTypeByPosition(idx)\n\n            if componentType.tagSet:\n                return self.setComponentByPosition(\n                    idx, value, verifyConstraints, matchTags, matchConstraints\n                )\n            else:\n                componentType = self.getComponentByPosition(idx)\n                return componentType.setComponentByType(\n                    tagSet, value, verifyConstraints, matchTags, matchConstraints, innerFlag=innerFlag\n                )\n        else:  # set outer component by inner tagSet\n            return self.setComponentByPosition(\n                idx, value, verifyConstraints, matchTags, matchConstraints\n            )\n\n    @property\n    def componentTagMap(self):\n        if self.componentType:\n            return self.componentType.tagMapUnique\n\n\nclass Choice(Set):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.ConstructedAsn1Type`,\n    its objects are mutable and duck-type Python :class:`list` objects.\n\n    Keyword Args\n    ------------\n    componentType: :py:class:`~pyasn1.type.namedtype.NamedType`\n        Object holding named ASN.1 types allowed within this collection\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s).  Constraints\n        verification for |ASN.1| type can only occur on explicit\n        `.isInconsistent` call.\n\n    Examples\n    --------\n\n    .. code-block:: python\n\n        class Afters(Choice):\n            '''\n            ASN.1 specification:\n\n            Afters ::= CHOICE {\n                cheese  [0] IA5String,\n                dessert [1] IA5String\n            }\n            '''\n            componentType = NamedTypes(\n                NamedType('cheese', IA5String().subtype(\n                    implicitTag=Tag(tagClassContext, tagFormatSimple, 0)\n                ),\n                NamedType('dessert', IA5String().subtype(\n                    implicitTag=Tag(tagClassContext, tagFormatSimple, 1)\n                )\n            )\n\n        afters = Afters()\n        afters['cheese'] = 'Mascarpone'\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.TagSet()  # untagged\n\n    #: Default collection of ASN.1 types of component (e.g. :py:class:`~pyasn1.type.namedtype.NamedType`)\n    #: object representing ASN.1 type allowed within |ASN.1| type\n    componentType = namedtype.NamedTypes()\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection(\n        constraint.ValueSizeConstraint(1, 1)\n    )\n\n    # Disambiguation ASN.1 types identification\n    typeId = Set.getTypeId()\n\n    _currentIdx = None\n\n    def __eq__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] == other\n        return NotImplemented\n\n    def __ne__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] != other\n        return NotImplemented\n\n    def __lt__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] < other\n        return NotImplemented\n\n    def __le__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] <= other\n        return NotImplemented\n\n    def __gt__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] > other\n        return NotImplemented\n\n    def __ge__(self, other):\n        if self._componentValues:\n            return self._componentValues[self._currentIdx] >= other\n        return NotImplemented\n\n    if sys.version_info[0] <= 2:\n        def __nonzero__(self):\n            return self._componentValues and True or False\n    else:\n        def __bool__(self):\n            return self._componentValues and True or False\n\n    def __len__(self):\n        return self._currentIdx is not None and 1 or 0\n\n    def __contains__(self, key):\n        if self._currentIdx is None:\n            return False\n        return key == self.componentType[self._currentIdx].getName()\n\n    def __iter__(self):\n        if self._currentIdx is None:\n            raise StopIteration\n        yield self.componentType[self._currentIdx].getName()\n\n    # Python dict protocol\n\n    def values(self):\n        if self._currentIdx is not None:\n            yield self._componentValues[self._currentIdx]\n\n    def keys(self):\n        if self._currentIdx is not None:\n            yield self.componentType[self._currentIdx].getName()\n\n    def items(self):\n        if self._currentIdx is not None:\n            yield self.componentType[self._currentIdx].getName(), self[self._currentIdx]\n\n    def checkConsistency(self):\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n\n    def _cloneComponentValues(self, myClone, cloneValueFlag):\n        try:\n            component = self.getComponent()\n        except error.PyAsn1Error:\n            pass\n        else:\n            if isinstance(component, Choice):\n                tagSet = component.effectiveTagSet\n            else:\n                tagSet = component.tagSet\n            if isinstance(component, base.ConstructedAsn1Type):\n                myClone.setComponentByType(\n                    tagSet, component.clone(cloneValueFlag=cloneValueFlag)\n                )\n            else:\n                myClone.setComponentByType(tagSet, component.clone())\n\n    def getComponentByPosition(self, idx, default=noValue, instantiate=True):\n        __doc__ = Set.__doc__\n\n        if self._currentIdx is None or self._currentIdx != idx:\n            return Set.getComponentByPosition(self, idx, default=default,\n                                              instantiate=instantiate)\n\n        return self._componentValues[idx]\n\n    def setComponentByPosition(self, idx, value=noValue,\n                               verifyConstraints=True,\n                               matchTags=True,\n                               matchConstraints=True):\n        \"\"\"Assign |ASN.1| type component by position.\n\n        Equivalent to Python sequence item assignment operation (e.g. `[]`).\n\n        Parameters\n        ----------\n        idx: :class:`int`\n            Component index (zero-based). Must either refer to existing\n            component or to N+1 component. In the latter case a new component\n            type gets instantiated (if *componentType* is set, or given ASN.1\n            object is taken otherwise) and appended to the |ASN.1| sequence.\n\n        Keyword Args\n        ------------\n        value: :class:`object` or :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n            A Python value to initialize |ASN.1| component with (if *componentType* is set)\n            or ASN.1 value object to assign to |ASN.1| component. Once a new value is\n            set to *idx* component, previous value is dropped.\n            If `value` is not given, schema object will be set as a component.\n\n        verifyConstraints : :class:`bool`\n            If :obj:`False`, skip constraints validation\n\n        matchTags: :class:`bool`\n            If :obj:`False`, skip component tags matching\n\n        matchConstraints: :class:`bool`\n            If :obj:`False`, skip component constraints matching\n\n        Returns\n        -------\n        self\n        \"\"\"\n        oldIdx = self._currentIdx\n        Set.setComponentByPosition(self, idx, value, verifyConstraints, matchTags, matchConstraints)\n        self._currentIdx = idx\n        if oldIdx is not None and oldIdx != idx:\n            self._componentValues[oldIdx] = noValue\n        return self\n\n    @property\n    def effectiveTagSet(self):\n        \"\"\"Return a :class:`~pyasn1.type.tag.TagSet` object of the currently initialized component or self (if |ASN.1| is tagged).\"\"\"\n        if self.tagSet:\n            return self.tagSet\n        else:\n            component = self.getComponent()\n            return component.effectiveTagSet\n\n    @property\n    def tagMap(self):\n        \"\"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping\n            ASN.1 tags to ASN.1 objects contained within callee.\n        \"\"\"\n        if self.tagSet:\n            return Set.tagMap.fget(self)\n        else:\n            return self.componentType.tagMapUnique\n\n    def getComponent(self, innerFlag=False):\n        \"\"\"Return currently assigned component of the |ASN.1| object.\n\n        Returns\n        -------\n        : :py:class:`~pyasn1.type.base.PyAsn1Item`\n            a PyASN1 object\n        \"\"\"\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n        else:\n            c = self._componentValues[self._currentIdx]\n            if innerFlag and isinstance(c, Choice):\n                return c.getComponent(innerFlag)\n            else:\n                return c\n\n    def getName(self, innerFlag=False):\n        \"\"\"Return the name of currently assigned component of the |ASN.1| object.\n\n        Returns\n        -------\n        : :py:class:`str`\n            |ASN.1| component name\n        \"\"\"\n        if self._currentIdx is None:\n            raise error.PyAsn1Error('Component not chosen')\n        else:\n            if innerFlag:\n                c = self._componentValues[self._currentIdx]\n                if isinstance(c, Choice):\n                    return c.getName(innerFlag)\n            return self.componentType.getNameByPosition(self._currentIdx)\n\n    @property\n    def isValue(self):\n        \"\"\"Indicate that |ASN.1| object represents ASN.1 value.\n\n        If *isValue* is :obj:`False` then this object represents just ASN.1 schema.\n\n        If *isValue* is :obj:`True` then, in addition to its ASN.1 schema features,\n        this object can also be used like a Python built-in object (e.g.\n        :class:`int`, :class:`str`, :class:`dict` etc.).\n\n        Returns\n        -------\n        : :class:`bool`\n            :obj:`False` if object represents just ASN.1 schema.\n            :obj:`True` if object represents ASN.1 schema and can be used as a normal\n            value.\n\n        Note\n        ----\n        There is an important distinction between PyASN1 schema and value objects.\n        The PyASN1 schema objects can only participate in ASN.1 schema-related\n        operations (e.g. defining or testing the structure of the data). Most\n        obvious uses of ASN.1 schema is to guide serialisation codecs whilst\n        encoding/decoding serialised ASN.1 contents.\n\n        The PyASN1 value objects can **additionally** participate in many operations\n        involving regular Python objects (e.g. arithmetic, comprehension etc).\n        \"\"\"\n        if self._currentIdx is None:\n            return False\n\n        componentValue = self._componentValues[self._currentIdx]\n\n        return componentValue is not noValue and componentValue.isValue\n\n    def clear(self):\n        self._currentIdx = None\n        return Set.clear(self)\n\n    # compatibility stubs\n\n    def getMinTagSet(self):\n        return self.minTagSet\n\n\nclass Any(OctetString):\n    \"\"\"Create |ASN.1| schema or value object.\n\n    |ASN.1| class is based on :class:`~pyasn1.type.base.SimpleAsn1Type`,\n    its objects are immutable and duck-type Python 2 :class:`str` or Python 3\n    :class:`bytes`. When used in Unicode context, |ASN.1| type assumes\n    \"|encoding|\" serialisation.\n\n    Keyword Args\n    ------------\n    value: :class:`unicode`, :class:`str`, :class:`bytes` or |ASN.1| object\n        :class:`str` (Python 2) or :class:`bytes` (Python 3), alternatively\n        :class:`unicode` object (Python 2) or :class:`str` (Python 3)\n        representing character string to be serialised into octets (note\n        `encoding` parameter) or |ASN.1| object.\n        If `value` is not given, schema object will be created.\n\n    tagSet: :py:class:`~pyasn1.type.tag.TagSet`\n        Object representing non-default ASN.1 tag(s)\n\n    subtypeSpec: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection`\n        Object representing non-default ASN.1 subtype constraint(s). Constraints\n        verification for |ASN.1| type occurs automatically on object\n        instantiation.\n\n    encoding: :py:class:`str`\n        Unicode codec ID to encode/decode :class:`unicode` (Python 2) or\n        :class:`str` (Python 3) the payload when |ASN.1| object is used\n        in text string context.\n\n    binValue: :py:class:`str`\n        Binary string initializer to use instead of the *value*.\n        Example: '10110011'.\n\n    hexValue: :py:class:`str`\n        Hexadecimal string initializer to use instead of the *value*.\n        Example: 'DEADBEEF'.\n\n    Raises\n    ------\n    ~pyasn1.error.ValueConstraintError, ~pyasn1.error.PyAsn1Error\n        On constraint violation or bad initializer.\n\n    Examples\n    --------\n    .. code-block:: python\n\n        class Error(Sequence):\n            '''\n            ASN.1 specification:\n\n            Error ::= SEQUENCE {\n                code      INTEGER,\n                parameter ANY DEFINED BY code  -- Either INTEGER or REAL\n            }\n            '''\n            componentType=NamedTypes(\n                NamedType('code', Integer()),\n                NamedType('parameter', Any(),\n                          openType=OpenType('code', {1: Integer(),\n                                                     2: Real()}))\n            )\n\n        error = Error()\n        error['code'] = 1\n        error['parameter'] = Integer(1234)\n    \"\"\"\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.tag.TagSet` object representing ASN.1 tag(s)\n    #: associated with |ASN.1| type.\n    tagSet = tag.TagSet()  # untagged\n\n    #: Set (on class, not on instance) or return a\n    #: :py:class:`~pyasn1.type.constraint.ConstraintsIntersection` object\n    #: imposing constraints on |ASN.1| type initialization values.\n    subtypeSpec = constraint.ConstraintsIntersection()\n\n    # Disambiguation ASN.1 types identification\n    typeId = OctetString.getTypeId()\n\n    @property\n    def tagMap(self):\n        \"\"\"\"Return a :class:`~pyasn1.type.tagmap.TagMap` object mapping\n            ASN.1 tags to ASN.1 objects contained within callee.\n        \"\"\"\n        try:\n            return self._tagMap\n\n        except AttributeError:\n            self._tagMap = tagmap.TagMap(\n                {self.tagSet: self},\n                {eoo.endOfOctets.tagSet: eoo.endOfOctets},\n                self\n            )\n\n            return self._tagMap\n\n# XXX\n# coercion rules?\n", "pyasn1/compat/octets.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom sys import version_info\n\nif version_info[0] <= 2:\n    int2oct = chr\n    # noinspection PyPep8\n    ints2octs = lambda s: ''.join([int2oct(x) for x in s])\n    null = ''\n    oct2int = ord\n    # TODO: refactor to return a sequence of ints\n    # noinspection PyPep8\n    octs2ints = lambda s: [oct2int(x) for x in s]\n    # noinspection PyPep8\n    str2octs = lambda x: x\n    # noinspection PyPep8\n    octs2str = lambda x: x\n    # noinspection PyPep8\n    isOctetsType = lambda s: isinstance(s, str)\n    # noinspection PyPep8\n    isStringType = lambda s: isinstance(s, (str, unicode))\n    # noinspection PyPep8\n    ensureString = str\nelse:\n    ints2octs = bytes\n    # noinspection PyPep8\n    int2oct = lambda x: ints2octs((x,))\n    null = ints2octs()\n    # noinspection PyPep8\n    oct2int = lambda x: x\n    # noinspection PyPep8\n    octs2ints = lambda x: x\n    # noinspection PyPep8\n    str2octs = lambda x: x.encode('iso-8859-1')\n    # noinspection PyPep8\n    octs2str = lambda x: x.decode('iso-8859-1')\n    # noinspection PyPep8\n    isOctetsType = lambda s: isinstance(s, bytes)\n    # noinspection PyPep8\n    isStringType = lambda s: isinstance(s, str)\n    # noinspection PyPep8\n    ensureString = bytes\n", "pyasn1/compat/integer.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\nimport platform\n\nfrom pyasn1.compat.octets import oct2int, null, ensureString\n\n\nimplementation = platform.python_implementation()\n\nif sys.version_info[0] < 3:\n    from binascii import a2b_hex, b2a_hex\n\n    def from_bytes(octets, signed=False):\n        if not octets:\n            return 0\n\n        value = long(b2a_hex(ensureString(octets)), 16)\n\n        if signed and oct2int(octets[0]) & 0x80:\n            return value - (1 << len(octets) * 8)\n\n        return value\n\n    def to_bytes(value, signed=False, length=0):\n        if value < 0:\n            if signed:\n                bits = bitLength(value)\n\n                # two's complement form\n                maxValue = 1 << bits\n                valueToEncode = (value + maxValue) % maxValue\n\n            else:\n                raise OverflowError('can\\'t convert negative int to unsigned')\n        elif value == 0 and length == 0:\n            return null\n        else:\n            bits = 0\n            valueToEncode = value\n\n        hexValue = hex(valueToEncode)[2:]\n        if hexValue.endswith('L'):\n            hexValue = hexValue[:-1]\n\n        if len(hexValue) & 1:\n            hexValue = '0' + hexValue\n\n        # padding may be needed for two's complement encoding\n        if value != valueToEncode or length:\n            hexLength = len(hexValue) * 4\n\n            padLength = max(length, bits)\n\n            if padLength > hexLength:\n                hexValue = '00' * ((padLength - hexLength - 1) // 8 + 1) + hexValue\n            elif length and hexLength - length > 7:\n                raise OverflowError('int too big to convert')\n\n        firstOctet = int(hexValue[:2], 16)\n\n        if signed:\n            if firstOctet & 0x80:\n                if value >= 0:\n                    hexValue = '00' + hexValue\n            elif value < 0:\n                hexValue = 'ff' + hexValue\n\n        octets_value = a2b_hex(hexValue)\n\n        return octets_value\n\n    def bitLength(number):\n        # bits in unsigned number\n        hexValue = hex(abs(number))\n        bits = len(hexValue) - 2\n        if hexValue.endswith('L'):\n            bits -= 1\n        if bits & 1:\n            bits += 1\n        bits *= 4\n        # TODO: strip lhs zeros\n        return bits\n\nelse:\n\n    def from_bytes(octets, signed=False):\n        return int.from_bytes(bytes(octets), 'big', signed=signed)\n\n    def to_bytes(value, signed=False, length=0):\n        length = max(value.bit_length(), length)\n\n        if signed and length % 8 == 0:\n            length += 1\n\n        return value.to_bytes(length // 8 + (length % 8 and 1 or 0), 'big', signed=signed)\n\n    def bitLength(number):\n        return int(number).bit_length()\n", "pyasn1/compat/__init__.py": "# This file is necessary to make this directory a package.\n\n# sentinal for missing argument\n_MISSING = object()\n", "pyasn1/codec/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/streaming.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2019, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport io\nimport os\nimport sys\n\nfrom pyasn1 import error\nfrom pyasn1.type import univ\n\n_PY2 = sys.version_info < (3,)\n\n\nclass CachingStreamWrapper(io.IOBase):\n    \"\"\"Wrapper around non-seekable streams.\n\n    Note that the implementation is tied to the decoder,\n    not checking for dangerous arguments for the sake\n    of performance.\n\n    The read bytes are kept in an internal cache until\n    setting _markedPosition which may reset the cache.\n    \"\"\"\n    def __init__(self, raw):\n        self._raw = raw\n        self._cache = io.BytesIO()\n        self._markedPosition = 0\n\n    def peek(self, n):\n        result = self.read(n)\n        self._cache.seek(-len(result), os.SEEK_CUR)\n        return result\n\n    def seekable(self):\n        return True\n\n    def seek(self, n=-1, whence=os.SEEK_SET):\n        # Note that this not safe for seeking forward.\n        return self._cache.seek(n, whence)\n\n    def read(self, n=-1):\n        read_from_cache = self._cache.read(n)\n        if n != -1:\n            n -= len(read_from_cache)\n            if not n:  # 0 bytes left to read\n                return read_from_cache\n\n        read_from_raw = self._raw.read(n)\n\n        self._cache.write(read_from_raw)\n\n        return read_from_cache + read_from_raw\n\n    @property\n    def markedPosition(self):\n        \"\"\"Position where the currently processed element starts.\n\n        This is used for back-tracking in SingleItemDecoder.__call__\n        and (indefLen)ValueDecoder and should not be used for other purposes.\n        The client is not supposed to ever seek before this position.\n        \"\"\"\n        return self._markedPosition\n\n    @markedPosition.setter\n    def markedPosition(self, value):\n        # By setting the value, we ensure we won't seek back before it.\n        # `value` should be the same as the current position\n        # We don't check for this for performance reasons.\n        self._markedPosition = value\n\n        # Whenever we set _marked_position, we know for sure\n        # that we will not return back, and thus it is\n        # safe to drop all cached data.\n        if self._cache.tell() > io.DEFAULT_BUFFER_SIZE:\n            self._cache = io.BytesIO(self._cache.read())\n            self._markedPosition = 0\n\n    def tell(self):\n        return self._cache.tell()\n\n\ndef asSeekableStream(substrate):\n    \"\"\"Convert object to seekable byte-stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`bytes` or :py:class:`io.IOBase` or :py:class:`univ.OctetString`\n\n    Returns\n    -------\n    : :py:class:`io.IOBase`\n\n    Raises\n    ------\n    : :py:class:`~pyasn1.error.PyAsn1Error`\n        If the supplied substrate cannot be converted to a seekable stream.\n    \"\"\"\n    if isinstance(substrate, io.BytesIO):\n        return substrate\n\n    elif isinstance(substrate, bytes):\n        return io.BytesIO(substrate)\n\n    elif isinstance(substrate, univ.OctetString):\n        return io.BytesIO(substrate.asOctets())\n\n    try:\n        # Special case: impossible to set attributes on `file` built-in\n        # XXX: broken, BufferedReader expects a \"readable\" attribute.\n        if _PY2 and isinstance(substrate, file):\n            return io.BufferedReader(substrate)\n\n        elif substrate.seekable():  # Will fail for most invalid types\n            return substrate\n\n        else:\n            return CachingStreamWrapper(substrate)\n\n    except AttributeError:\n        raise error.UnsupportedSubstrateError(\n            \"Cannot convert \" + substrate.__class__.__name__ +\n            \" to a seekable bit stream.\")\n\n\ndef isEndOfStream(substrate):\n    \"\"\"Check whether we have reached the end of a stream.\n\n    Although it is more effective to read and catch exceptions, this\n    function\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to check\n\n    Returns\n    -------\n    : :py:class:`bool`\n    \"\"\"\n    if isinstance(substrate, io.BytesIO):\n        cp = substrate.tell()\n        substrate.seek(0, os.SEEK_END)\n        result = substrate.tell() == cp\n        substrate.seek(cp, os.SEEK_SET)\n        yield result\n\n    else:\n        received = substrate.read(1)\n        if received is None:\n            yield\n\n        if received:\n            substrate.seek(-1, os.SEEK_CUR)\n\n        yield not received\n\n\ndef peekIntoStream(substrate, size=-1):\n    \"\"\"Peek into stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to read from.\n\n    size: :py:class:`int`\n        How many bytes to peek (-1 = all available)\n\n    Returns\n    -------\n    : :py:class:`bytes` or :py:class:`str`\n        The return type depends on Python major version\n    \"\"\"\n    if hasattr(substrate, \"peek\"):\n        received = substrate.peek(size)\n        if received is None:\n            yield\n\n        while len(received) < size:\n            yield\n\n        yield received\n\n    else:\n        current_position = substrate.tell()\n        try:\n            for chunk in readFromStream(substrate, size):\n                yield chunk\n\n        finally:\n            substrate.seek(current_position)\n\n\ndef readFromStream(substrate, size=-1, context=None):\n    \"\"\"Read from the stream.\n\n    Parameters\n    ----------\n    substrate: :py:class:`IOBase`\n        Stream to read from.\n\n    Keyword parameters\n    ------------------\n    size: :py:class:`int`\n        How many bytes to read (-1 = all available)\n\n    context: :py:class:`dict`\n        Opaque caller context will be attached to exception objects created\n        by this function.\n\n    Yields\n    ------\n    : :py:class:`bytes` or :py:class:`str` or :py:class:`SubstrateUnderrunError`\n        Read data or :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        object if no `size` bytes is readily available in the stream. The\n        data type depends on Python major version\n\n    Raises\n    ------\n    : :py:class:`~pyasn1.error.EndOfStreamError`\n        Input stream is exhausted\n    \"\"\"\n    while True:\n        # this will block unless stream is non-blocking\n        received = substrate.read(size)\n        if received is None:  # non-blocking stream can do this\n            yield error.SubstrateUnderrunError(context=context)\n\n        elif not received and size != 0:  # end-of-stream\n            raise error.EndOfStreamError(context=context)\n\n        elif len(received) < size:\n            substrate.seek(-len(received), os.SEEK_CUR)\n\n            # behave like a non-blocking stream\n            yield error.SubstrateUnderrunError(context=context)\n\n        else:\n            break\n\n    yield received\n", "pyasn1/codec/cer/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.streaming import readFromStream\nfrom pyasn1.codec.ber import decoder\nfrom pyasn1.compat.octets import oct2int\nfrom pyasn1.type import univ\n\n__all__ = ['decode', 'StreamingDecoder']\n\nSubstrateUnderrunError = error.SubstrateUnderrunError\n\n\nclass BooleanPayloadDecoder(decoder.AbstractSimplePayloadDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if length != 1:\n            raise error.PyAsn1Error('Not single-octet Boolean payload')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        byte = oct2int(chunk[0])\n\n        # CER/DER specifies encoding of TRUE as 0xFF and FALSE as 0x0, while\n        # BER allows any non-zero value as TRUE; cf. sections 8.2.2. and 11.1 \n        # in https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf\n        if byte == 0xff:\n            value = 1\n\n        elif byte == 0x00:\n            value = 0\n\n        else:\n            raise error.PyAsn1Error('Unexpected Boolean payload: %s' % byte)\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\n# TODO: prohibit non-canonical encoding\nBitStringPayloadDecoder = decoder.BitStringPayloadDecoder\nOctetStringPayloadDecoder = decoder.OctetStringPayloadDecoder\nRealPayloadDecoder = decoder.RealPayloadDecoder\n\nTAG_MAP = decoder.TAG_MAP.copy()\nTAG_MAP.update(\n    {univ.Boolean.tagSet: BooleanPayloadDecoder(),\n     univ.BitString.tagSet: BitStringPayloadDecoder(),\n     univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n     univ.Real.tagSet: RealPayloadDecoder()}\n)\n\nTYPE_MAP = decoder.TYPE_MAP.copy()\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\nclass SingleItemDecoder(decoder.SingleItemDecoder):\n    __doc__ = decoder.SingleItemDecoder.__doc__\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass StreamingDecoder(decoder.StreamingDecoder):\n    __doc__ = decoder.StreamingDecoder.__doc__\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n\nclass Decoder(decoder.Decoder):\n    __doc__ = decoder.Decoder.__doc__\n\n    STREAMING_DECODER = StreamingDecoder\n\n\n#: Turns CER octet stream into an ASN.1 object.\n#:\n#: Takes CER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     CER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from CER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode CER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode CER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/cer/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/cer/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import encoder\nfrom pyasn1.compat.octets import str2octs, null\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['Encoder', 'encode']\n\n\nclass BooleanEncoder(encoder.IntegerEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if value == 0:\n            substrate = (0,)\n        else:\n            substrate = (255,)\n        return substrate, False, False\n\n\nclass RealEncoder(encoder.RealEncoder):\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        return self._dropFloatingPoint(m, b, e)\n\n\n# specialized GeneralStringEncoder here\n\nclass TimeEncoderMixIn(object):\n    Z_CHAR = ord('Z')\n    PLUS_CHAR = ord('+')\n    MINUS_CHAR = ord('-')\n    COMMA_CHAR = ord(',')\n    DOT_CHAR = ord('.')\n    ZERO_CHAR = ord('0')\n\n    MIN_LENGTH = 12\n    MAX_LENGTH = 19\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        # CER encoding constraints:\n        # - minutes are mandatory, seconds are optional\n        # - sub-seconds must NOT be zero / no meaningless zeros\n        # - no hanging fraction dot\n        # - time in UTC (Z)\n        # - only dot is allowed for fractions\n\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        numbers = value.asNumbers()\n\n        if self.PLUS_CHAR in numbers or self.MINUS_CHAR in numbers:\n            raise error.PyAsn1Error('Must be UTC time: %r' % value)\n\n        if numbers[-1] != self.Z_CHAR:\n            raise error.PyAsn1Error('Missing \"Z\" time zone specifier: %r' % value)\n\n        if self.COMMA_CHAR in numbers:\n            raise error.PyAsn1Error('Comma in fractions disallowed: %r' % value)\n\n        if self.DOT_CHAR in numbers:\n\n            isModified = False\n\n            numbers = list(numbers)\n\n            searchIndex = min(numbers.index(self.DOT_CHAR) + 4, len(numbers) - 1)\n\n            while numbers[searchIndex] != self.DOT_CHAR:\n                if numbers[searchIndex] == self.ZERO_CHAR:\n                    del numbers[searchIndex]\n                    isModified = True\n\n                searchIndex -= 1\n\n            searchIndex += 1\n\n            if searchIndex < len(numbers):\n                if numbers[searchIndex] == self.Z_CHAR:\n                    # drop hanging comma\n                    del numbers[searchIndex - 1]\n                    isModified = True\n\n            if isModified:\n                value = value.clone(numbers)\n\n        if not self.MIN_LENGTH < len(numbers) < self.MAX_LENGTH:\n            raise error.PyAsn1Error('Length constraint violated: %r' % value)\n\n        options.update(maxChunkSize=1000)\n\n        return encoder.OctetStringEncoder.encodeValue(\n            self, value, asn1Spec, encodeFun, **options\n        )\n\n\nclass GeneralizedTimeEncoder(TimeEncoderMixIn, encoder.OctetStringEncoder):\n    MIN_LENGTH = 12\n    MAX_LENGTH = 20\n\n\nclass UTCTimeEncoder(TimeEncoderMixIn, encoder.OctetStringEncoder):\n    MIN_LENGTH = 10\n    MAX_LENGTH = 14\n\n\nclass SetOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        # sort by serialised and padded components\n        if len(chunks) > 1:\n            zero = str2octs('\\x00')\n            maxLen = max(map(len, chunks))\n            paddedChunks = [\n                (x.ljust(maxLen, zero), x) for x in chunks\n            ]\n            paddedChunks.sort(key=lambda x: x[0])\n\n            chunks = [x[1] for x in paddedChunks]\n\n        return null.join(chunks), True, True\n\n\nclass SequenceOfEncoder(encoder.SequenceOfEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        if options.get('ifNotEmpty', False) and not len(value):\n            return null, True, True\n\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        return null.join(chunks), True, True\n\n\nclass SetEncoder(encoder.SequenceEncoder):\n    @staticmethod\n    def _componentSortKey(componentAndType):\n        \"\"\"Sort SET components by tag\n\n        Sort regardless of the Choice value (static sort)\n        \"\"\"\n        component, asn1Spec = componentAndType\n\n        if asn1Spec is None:\n            asn1Spec = component\n\n        if asn1Spec.typeId == univ.Choice.typeId and not asn1Spec.tagSet:\n            if asn1Spec.tagSet:\n                return asn1Spec.tagSet\n            else:\n                return asn1Spec.componentType.minTagSet\n        else:\n            return asn1Spec.tagSet\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        substrate = null\n\n        comps = []\n        compsMap = {}\n\n        if asn1Spec is None:\n            # instance of ASN.1 schema\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n            namedTypes = value.componentType\n\n            for idx, component in enumerate(value.values()):\n                if namedTypes:\n                    namedType = namedTypes[idx]\n\n                    if namedType.isOptional and not component.isValue:\n                            continue\n\n                    if namedType.isDefaulted and component == namedType.asn1Object:\n                            continue\n\n                    compsMap[id(component)] = namedType\n\n                else:\n                    compsMap[id(component)] = None\n\n                comps.append((component, asn1Spec))\n\n        else:\n            # bare Python value + ASN.1 schema\n            for idx, namedType in enumerate(asn1Spec.componentType.namedTypes):\n\n                try:\n                    component = value[namedType.name]\n\n                except KeyError:\n                    raise error.PyAsn1Error('Component name \"%s\" not found in %r' % (namedType.name, value))\n\n                if namedType.isOptional and namedType.name not in value:\n                    continue\n\n                if namedType.isDefaulted and component == namedType.asn1Object:\n                    continue\n\n                compsMap[id(component)] = namedType\n                comps.append((component, asn1Spec[idx]))\n\n        for comp, compType in sorted(comps, key=self._componentSortKey):\n            namedType = compsMap[id(comp)]\n\n            if namedType:\n                options.update(ifNotEmpty=namedType.isOptional)\n\n            chunk = encodeFun(comp, compType, **options)\n\n            # wrap open type blob if needed\n            if namedType and namedType.openType:\n                wrapType = namedType.asn1Object\n                if wrapType.tagSet and not wrapType.isSameTypeWith(comp):\n                    chunk = encodeFun(chunk, wrapType, **options)\n\n            substrate += chunk\n\n        return substrate, True, True\n\n\nclass SequenceEncoder(encoder.SequenceEncoder):\n    omitEmptyOptionals = True\n\n\nTAG_MAP = encoder.TAG_MAP.copy()\n\nTAG_MAP.update({\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimeEncoder(),\n    useful.UTCTime.tagSet: UTCTimeEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SetOf.tagSet: SetOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder()\n})\n\nTYPE_MAP = encoder.TYPE_MAP.copy()\n\nTYPE_MAP.update({\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    useful.GeneralizedTime.typeId: GeneralizedTimeEncoder(),\n    useful.UTCTime.typeId: UTCTimeEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SetOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder()\n})\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(encoder.SingleItemEncoder):\n    fixedDefLengthMode = False\n    fixedChunkSize = 1000\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass Encoder(encoder.Encoder):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n\n#: Turns ASN.1 object into CER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a CER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octet-stream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into CER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00'\n#:\n#: Encode ASN.1 value object into CER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\x80\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x00\\x00'\n#:\nencode = Encoder()\n\n# EncoderFactory queries class instance and builds a map of tags -> encoders\n", "pyasn1/codec/ber/eoo.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.type import base\nfrom pyasn1.type import tag\n\n__all__ = ['endOfOctets']\n\n\nclass EndOfOctets(base.SimpleAsn1Type):\n    defaultValue = 0\n    tagSet = tag.initTagSet(\n        tag.Tag(tag.tagClassUniversal, tag.tagFormatSimple, 0x00)\n    )\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = object.__new__(cls, *args, **kwargs)\n\n        return cls._instance\n\n\nendOfOctets = EndOfOctets()\n", "pyasn1/codec/ber/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport io\nimport os\nimport sys\n\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.codec.streaming import asSeekableStream\nfrom pyasn1.codec.streaming import isEndOfStream\nfrom pyasn1.codec.streaming import peekIntoStream\nfrom pyasn1.codec.streaming import readFromStream\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.compat.integer import from_bytes\nfrom pyasn1.compat.octets import oct2int, octs2ints, ints2octs, null\nfrom pyasn1.error import PyAsn1Error\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import tagmap\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['StreamingDecoder', 'Decoder', 'decode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_DECODER)\n\nnoValue = base.noValue\n\nSubstrateUnderrunError = error.SubstrateUnderrunError\n\n\nclass AbstractPayloadDecoder(object):\n    protoComponent = None\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        \"\"\"Decode value with fixed byte length.\n\n        The decoder is allowed to consume as many bytes as necessary.\n        \"\"\"\n        raise error.PyAsn1Error('SingleItemDecoder not implemented for %s' % (tagSet,))  # TODO: Seems more like an NotImplementedError?\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        \"\"\"Decode value with undefined length.\n\n        The decoder is allowed to consume as many bytes as necessary.\n        \"\"\"\n        raise error.PyAsn1Error('Indefinite length mode decoder not implemented for %s' % (tagSet,)) # TODO: Seems more like an NotImplementedError?\n\n    @staticmethod\n    def _passAsn1Object(asn1Object, options):\n        if 'asn1Object' not in options:\n            options['asn1Object'] = asn1Object\n\n        return options\n\n\nclass AbstractSimplePayloadDecoder(AbstractPayloadDecoder):\n    @staticmethod\n    def substrateCollector(asn1Object, substrate, length, options):\n        for chunk in readFromStream(substrate, length, options):\n            yield chunk\n\n    def _createComponent(self, asn1Spec, tagSet, value, **options):\n        if options.get('native'):\n            return value\n        elif asn1Spec is None:\n            return self.protoComponent.clone(value, tagSet=tagSet)\n        elif value is noValue:\n            return asn1Spec\n        else:\n            return asn1Spec.clone(value)\n\n\nclass RawPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Any('')\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, '', **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        for value in decodeFun(substrate, asn1Spec, tagSet, length, **options):\n            yield value\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, '', **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        while True:\n            for value in decodeFun(\n                    substrate, asn1Spec, tagSet, length,\n                    allowEoo=True, **options):\n\n                if value is eoo.endOfOctets:\n                    return\n\n                yield value\n\n\nrawPayloadDecoder = RawPayloadDecoder()\n\n\nclass IntegerPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Integer(0)\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if chunk:\n            value = from_bytes(chunk, signed=True)\n\n        else:\n            value = 0\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\nclass BooleanPayloadDecoder(IntegerPayloadDecoder):\n    protoComponent = univ.Boolean(0)\n\n    def _createComponent(self, asn1Spec, tagSet, value, **options):\n        return IntegerPayloadDecoder._createComponent(\n            self, asn1Spec, tagSet, value and 1 or 0, **options)\n\n\nclass BitStringPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.BitString(())\n    supportConstructedForm = True\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if not length:\n            raise error.PyAsn1Error('Empty BIT STRING substrate')\n\n        for chunk in isEndOfStream(substrate):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if chunk:\n            raise error.PyAsn1Error('Empty BIT STRING substrate')\n\n        if tagSet[0].tagFormat == tag.tagFormatSimple:  # XXX what tag to check?\n\n            for trailingBits in readFromStream(substrate, 1, options):\n                if isinstance(trailingBits, SubstrateUnderrunError):\n                    yield trailingBits\n\n            trailingBits = ord(trailingBits)\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            for chunk in readFromStream(substrate, length - 1, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            value = self.protoComponent.fromOctetString(\n                chunk, internalFormat=True, padding=trailingBits)\n\n            yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n            return\n\n        if not self.supportConstructedForm:\n            raise error.PyAsn1Error('Constructed encoding form prohibited '\n                                    'at %s' % self.__class__.__name__)\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        bitString = self.protoComponent.fromOctetString(null, internalFormat=True)\n\n        current_position = substrate.tell()\n\n        while substrate.tell() - current_position < length:\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            trailingBits = oct2int(component[0])\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            bitString = self.protoComponent.fromOctetString(\n                component[1:], internalFormat=True,\n                prepend=bitString, padding=trailingBits\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, bitString, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        bitString = self.protoComponent.fromOctetString(null, internalFormat=True)\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if component is eoo.endOfOctets:\n                    break\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            if component is eoo.endOfOctets:\n                break\n\n            trailingBits = oct2int(component[0])\n            if trailingBits > 7:\n                raise error.PyAsn1Error(\n                    'Trailing bits overflow %s' % trailingBits\n                )\n\n            bitString = self.protoComponent.fromOctetString(\n                component[1:], internalFormat=True,\n                prepend=bitString, padding=trailingBits\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, bitString, **options)\n\n\nclass OctetStringPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.OctetString('')\n    supportConstructedForm = True\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if substrateFun:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if tagSet[0].tagFormat == tag.tagFormatSimple:  # XXX what tag to check?\n            for chunk in readFromStream(substrate, length, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n            return\n\n        if not self.supportConstructedForm:\n            raise error.PyAsn1Error('Constructed encoding form prohibited at %s' % self.__class__.__name__)\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        header = null\n\n        original_position = substrate.tell()\n        # head = popSubstream(substrate, length)\n        while substrate.tell() - original_position < length:\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            header += component\n\n        yield self._createComponent(asn1Spec, tagSet, header, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if substrateFun and substrateFun is not self.substrateCollector:\n            asn1Object = self._createComponent(asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        header = null\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, self.protoComponent, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n            if component is eoo.endOfOctets:\n                break\n\n            header += component\n\n        yield self._createComponent(asn1Spec, tagSet, header, **options)\n\n\nclass NullPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Null('')\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        component = self._createComponent(asn1Spec, tagSet, '', **options)\n\n        if chunk:\n            raise error.PyAsn1Error('Unexpected %d-octet substrate for Null' % length)\n\n        yield component\n\n\nclass ObjectIdentifierPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.ObjectIdentifier(())\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            raise error.PyAsn1Error('Empty substrate')\n\n        chunk = octs2ints(chunk)\n\n        oid = ()\n        index = 0\n        substrateLen = len(chunk)\n        while index < substrateLen:\n            subId = chunk[index]\n            index += 1\n            if subId < 128:\n                oid += (subId,)\n            elif subId > 128:\n                # Construct subid from a number of octets\n                nextSubId = subId\n                subId = 0\n                while nextSubId >= 128:\n                    subId = (subId << 7) + (nextSubId & 0x7F)\n                    if index >= substrateLen:\n                        raise error.SubstrateUnderrunError(\n                            'Short substrate for sub-OID past %s' % (oid,)\n                        )\n                    nextSubId = chunk[index]\n                    index += 1\n                oid += ((subId << 7) + nextSubId,)\n            elif subId == 128:\n                # ASN.1 spec forbids leading zeros (0x80) in OID\n                # encoding, tolerating it opens a vulnerability. See\n                # https://www.esat.kuleuven.be/cosic/publications/article-1432.pdf\n                # page 7\n                raise error.PyAsn1Error('Invalid octet 0x80 in OID encoding')\n\n        # Decode two leading arcs\n        if 0 <= oid[0] <= 39:\n            oid = (0,) + oid\n        elif 40 <= oid[0] <= 79:\n            oid = (1, oid[0] - 40) + oid[1:]\n        elif oid[0] >= 80:\n            oid = (2, oid[0] - 80) + oid[1:]\n        else:\n            raise error.PyAsn1Error('Malformed first OID octet: %s' % chunk[0])\n\n        yield self._createComponent(asn1Spec, tagSet, oid, **options)\n\n\nclass RelativeOIDPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.RelativeOID(())\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            raise error.PyAsn1Error('Empty substrate')\n\n        chunk = octs2ints(chunk)\n\n        reloid = ()\n        index = 0\n        substrateLen = len(chunk)\n        while index < substrateLen:\n            subId = chunk[index]\n            index += 1\n            if subId < 128:\n                reloid += (subId,)\n            elif subId > 128:\n                # Construct subid from a number of octets\n                nextSubId = subId\n                subId = 0\n                while nextSubId >= 128:\n                    subId = (subId << 7) + (nextSubId & 0x7F)\n                    if index >= substrateLen:\n                        raise error.SubstrateUnderrunError(\n                            'Short substrate for sub-OID past %s' % (reloid,)\n                        )\n                    nextSubId = chunk[index]\n                    index += 1\n                reloid += ((subId << 7) + nextSubId,)\n            elif subId == 128:\n                # ASN.1 spec forbids leading zeros (0x80) in OID\n                # encoding, tolerating it opens a vulnerability. See\n                # https://www.esat.kuleuven.be/cosic/publications/article-1432.pdf\n                # page 7\n                raise error.PyAsn1Error('Invalid octet 0x80 in RELATIVE-OID encoding')\n\n        yield self._createComponent(asn1Spec, tagSet, reloid, **options)\n\n\nclass RealPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Real()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatSimple:\n            raise error.PyAsn1Error('Simple tag format expected')\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        if not chunk:\n            yield self._createComponent(asn1Spec, tagSet, 0.0, **options)\n            return\n\n        fo = oct2int(chunk[0])\n        chunk = chunk[1:]\n        if fo & 0x80:  # binary encoding\n            if not chunk:\n                raise error.PyAsn1Error(\"Incomplete floating-point value\")\n\n            if LOG:\n                LOG('decoding binary encoded REAL')\n\n            n = (fo & 0x03) + 1\n\n            if n == 4:\n                n = oct2int(chunk[0])\n                chunk = chunk[1:]\n\n            eo, chunk = chunk[:n], chunk[n:]\n\n            if not eo or not chunk:\n                raise error.PyAsn1Error('Real exponent screwed')\n\n            e = oct2int(eo[0]) & 0x80 and -1 or 0\n\n            while eo:  # exponent\n                e <<= 8\n                e |= oct2int(eo[0])\n                eo = eo[1:]\n\n            b = fo >> 4 & 0x03  # base bits\n\n            if b > 2:\n                raise error.PyAsn1Error('Illegal Real base')\n\n            if b == 1:  # encbase = 8\n                e *= 3\n\n            elif b == 2:  # encbase = 16\n                e *= 4\n            p = 0\n\n            while chunk:  # value\n                p <<= 8\n                p |= oct2int(chunk[0])\n                chunk = chunk[1:]\n\n            if fo & 0x40:  # sign bit\n                p = -p\n\n            sf = fo >> 2 & 0x03  # scale bits\n            p *= 2 ** sf\n            value = (p, 2, e)\n\n        elif fo & 0x40:  # infinite value\n            if LOG:\n                LOG('decoding infinite REAL')\n\n            value = fo & 0x01 and '-inf' or 'inf'\n\n        elif fo & 0xc0 == 0:  # character encoding\n            if not chunk:\n                raise error.PyAsn1Error(\"Incomplete floating-point value\")\n\n            if LOG:\n                LOG('decoding character encoded REAL')\n\n            try:\n                if fo & 0x3 == 0x1:  # NR1\n                    value = (int(chunk), 10, 0)\n\n                elif fo & 0x3 == 0x2:  # NR2\n                    value = float(chunk)\n\n                elif fo & 0x3 == 0x3:  # NR3\n                    value = float(chunk)\n\n                else:\n                    raise error.SubstrateUnderrunError(\n                        'Unknown NR (tag %s)' % fo\n                    )\n\n            except ValueError:\n                raise error.SubstrateUnderrunError(\n                    'Bad character Real syntax'\n                )\n\n        else:\n            raise error.SubstrateUnderrunError(\n                'Unknown encoding (tag %s)' % fo\n            )\n\n        yield self._createComponent(asn1Spec, tagSet, value, **options)\n\n\nclass AbstractConstructedPayloadDecoder(AbstractPayloadDecoder):\n    protoComponent = None\n\n\nclass ConstructedPayloadDecoderBase(AbstractConstructedPayloadDecoder):\n    protoRecordComponent = None\n    protoSequenceComponent = None\n\n    def _getComponentTagMap(self, asn1Object, idx):\n        raise NotImplementedError()\n\n    def _getComponentPositionByType(self, asn1Object, tagSet, idx):\n        raise NotImplementedError()\n\n    def _decodeComponentsSchemaless(\n            self, substrate, tagSet=None, decodeFun=None,\n            length=None, **options):\n\n        asn1Object = None\n\n        components = []\n        componentTypes = set()\n\n        original_position = substrate.tell()\n\n        while length == -1 or substrate.tell() < original_position + length:\n            for component in decodeFun(substrate, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n            if length == -1 and component is eoo.endOfOctets:\n                break\n\n            components.append(component)\n            componentTypes.add(component.tagSet)\n\n            # Now we have to guess is it SEQUENCE/SET or SEQUENCE OF/SET OF\n            # The heuristics is:\n            # * 1+ components of different types -> likely SEQUENCE/SET\n            # * otherwise -> likely SEQUENCE OF/SET OF\n            if len(componentTypes) > 1:\n                protoComponent = self.protoRecordComponent\n\n            else:\n                protoComponent = self.protoSequenceComponent\n\n            asn1Object = protoComponent.clone(\n                # construct tagSet from base tag from prototype ASN.1 object\n                # and additional tags recovered from the substrate\n                tagSet=tag.TagSet(protoComponent.tagSet.baseTag, *tagSet.superTags)\n            )\n\n        if LOG:\n            LOG('guessed %r container type (pass `asn1Spec` to guide the '\n                'decoder)' % asn1Object)\n\n        for idx, component in enumerate(components):\n            asn1Object.setComponentByPosition(\n                idx, component,\n                verifyConstraints=False,\n                matchTags=False, matchConstraints=False\n            )\n\n        yield asn1Object\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if tagSet[0].tagFormat != tag.tagFormatConstructed:\n            raise error.PyAsn1Error('Constructed tag format expected')\n\n        original_position = substrate.tell()\n\n        if substrateFun:\n            if asn1Spec is not None:\n                asn1Object = asn1Spec.clone()\n\n            elif self.protoComponent is not None:\n                asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n            else:\n                asn1Object = self.protoRecordComponent, self.protoSequenceComponent\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if asn1Spec is None:\n            for asn1Object in self._decodeComponentsSchemaless(\n                    substrate, tagSet=tagSet, decodeFun=decodeFun,\n                    length=length, **options):\n                if isinstance(asn1Object, SubstrateUnderrunError):\n                    yield asn1Object\n\n            if substrate.tell() < original_position + length:\n                if LOG:\n                    for trailing in readFromStream(substrate, context=options):\n                        if isinstance(trailing, SubstrateUnderrunError):\n                            yield trailing\n\n                    LOG('Unused trailing %d octets encountered: %s' % (\n                        len(trailing), debug.hexdump(trailing)))\n\n            yield asn1Object\n\n            return\n\n        asn1Object = asn1Spec.clone()\n        asn1Object.clear()\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Spec.typeId in (univ.Sequence.typeId, univ.Set.typeId):\n\n            namedTypes = asn1Spec.componentType\n\n            isSetType = asn1Spec.typeId == univ.Set.typeId\n            isDeterministic = not isSetType and not namedTypes.hasOptionalOrDefault\n\n            if LOG:\n                LOG('decoding %sdeterministic %s type %r chosen by type ID' % (\n                    not isDeterministic and 'non-' or '', isSetType and 'SET' or '',\n                    asn1Spec))\n\n            seenIndices = set()\n            idx = 0\n            while substrate.tell() - original_position < length:\n                if not namedTypes:\n                    componentType = None\n\n                elif isSetType:\n                    componentType = namedTypes.tagMapUnique\n\n                else:\n                    try:\n                        if isDeterministic:\n                            componentType = namedTypes[idx].asn1Object\n\n                        elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                            componentType = namedTypes.getTagMapNearPosition(idx)\n\n                        else:\n                            componentType = namedTypes[idx].asn1Object\n\n                    except IndexError:\n                        raise error.PyAsn1Error(\n                            'Excessive components decoded at %r' % (asn1Spec,)\n                        )\n\n                for component in decodeFun(substrate, componentType, **options):\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                if not isDeterministic and namedTypes:\n                    if isSetType:\n                        idx = namedTypes.getPositionByType(component.effectiveTagSet)\n\n                    elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                        idx = namedTypes.getPositionNearType(component.effectiveTagSet, idx)\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                seenIndices.add(idx)\n                idx += 1\n\n            if LOG:\n                LOG('seen component indices %s' % seenIndices)\n\n            if namedTypes:\n                if not namedTypes.requiredComponents.issubset(seenIndices):\n                    raise error.PyAsn1Error(\n                        'ASN.1 object %s has uninitialized '\n                        'components' % asn1Object.__class__.__name__)\n\n                if  namedTypes.hasOpenTypes:\n\n                    openTypes = options.get('openTypes', {})\n\n                    if LOG:\n                        LOG('user-specified open types map:')\n\n                        for k, v in openTypes.items():\n                            LOG('%s -> %r' % (k, v))\n\n                    if openTypes or options.get('decodeOpenTypes', False):\n\n                        for idx, namedType in enumerate(namedTypes.namedTypes):\n                            if not namedType.openType:\n                                continue\n\n                            if namedType.isOptional and not asn1Object.getComponentByPosition(idx).isValue:\n                                continue\n\n                            governingValue = asn1Object.getComponentByName(\n                                namedType.openType.name\n                            )\n\n                            try:\n                                openType = openTypes[governingValue]\n\n                            except KeyError:\n\n                                if LOG:\n                                    LOG('default open types map of component '\n                                        '\"%s.%s\" governed by component \"%s.%s\"'\n                                        ':' % (asn1Object.__class__.__name__,\n                                               namedType.name,\n                                               asn1Object.__class__.__name__,\n                                               namedType.openType.name))\n\n                                    for k, v in namedType.openType.items():\n                                        LOG('%s -> %r' % (k, v))\n\n                                try:\n                                    openType = namedType.openType[governingValue]\n\n                                except KeyError:\n                                    if LOG:\n                                        LOG('failed to resolve open type by governing '\n                                            'value %r' % (governingValue,))\n                                    continue\n\n                            if LOG:\n                                LOG('resolved open type %r by governing '\n                                    'value %r' % (openType, governingValue))\n\n                            containerValue = asn1Object.getComponentByPosition(idx)\n\n                            if containerValue.typeId in (\n                                    univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                                for pos, containerElement in enumerate(\n                                        containerValue):\n\n                                    stream = asSeekableStream(containerValue[pos].asOctets())\n\n                                    for component in decodeFun(stream, asn1Spec=openType, **options):\n                                        if isinstance(component, SubstrateUnderrunError):\n                                            yield component\n\n                                    containerValue[pos] = component\n\n                            else:\n                                stream = asSeekableStream(asn1Object.getComponentByPosition(idx).asOctets())\n\n                                for component in decodeFun(stream, asn1Spec=openType, **options):\n                                    if isinstance(component, SubstrateUnderrunError):\n                                        yield component\n\n                                asn1Object.setComponentByPosition(idx, component)\n\n            else:\n                inconsistency = asn1Object.isInconsistent\n                if inconsistency:\n                    raise inconsistency\n\n        else:\n            componentType = asn1Spec.componentType\n\n            if LOG:\n                LOG('decoding type %r chosen by given `asn1Spec`' % componentType)\n\n            idx = 0\n\n            while substrate.tell() - original_position < length:\n                for component in decodeFun(substrate, componentType, **options):\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                idx += 1\n\n        yield asn1Object\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if tagSet[0].tagFormat != tag.tagFormatConstructed:\n            raise error.PyAsn1Error('Constructed tag format expected')\n\n        if substrateFun is not None:\n            if asn1Spec is not None:\n                asn1Object = asn1Spec.clone()\n\n            elif self.protoComponent is not None:\n                asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n            else:\n                asn1Object = self.protoRecordComponent, self.protoSequenceComponent\n\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        if asn1Spec is None:\n            for asn1Object in self._decodeComponentsSchemaless(\n                    substrate, tagSet=tagSet, decodeFun=decodeFun,\n                    length=length, **dict(options, allowEoo=True)):\n                if isinstance(asn1Object, SubstrateUnderrunError):\n                    yield asn1Object\n\n            yield asn1Object\n\n            return\n\n        asn1Object = asn1Spec.clone()\n        asn1Object.clear()\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Spec.typeId in (univ.Sequence.typeId, univ.Set.typeId):\n\n            namedTypes = asn1Object.componentType\n\n            isSetType = asn1Object.typeId == univ.Set.typeId\n            isDeterministic = not isSetType and not namedTypes.hasOptionalOrDefault\n\n            if LOG:\n                LOG('decoding %sdeterministic %s type %r chosen by type ID' % (\n                    not isDeterministic and 'non-' or '', isSetType and 'SET' or '',\n                    asn1Spec))\n\n            seenIndices = set()\n\n            idx = 0\n\n            while True:  # loop over components\n                if len(namedTypes) <= idx:\n                    asn1Spec = None\n\n                elif isSetType:\n                    asn1Spec = namedTypes.tagMapUnique\n\n                else:\n                    try:\n                        if isDeterministic:\n                            asn1Spec = namedTypes[idx].asn1Object\n\n                        elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                            asn1Spec = namedTypes.getTagMapNearPosition(idx)\n\n                        else:\n                            asn1Spec = namedTypes[idx].asn1Object\n\n                    except IndexError:\n                        raise error.PyAsn1Error(\n                            'Excessive components decoded at %r' % (asn1Object,)\n                        )\n\n                for component in decodeFun(substrate, asn1Spec, allowEoo=True, **options):\n\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                    if component is eoo.endOfOctets:\n                        break\n\n                if component is eoo.endOfOctets:\n                    break\n\n                if not isDeterministic and namedTypes:\n                    if isSetType:\n                        idx = namedTypes.getPositionByType(component.effectiveTagSet)\n\n                    elif namedTypes[idx].isOptional or namedTypes[idx].isDefaulted:\n                        idx = namedTypes.getPositionNearType(component.effectiveTagSet, idx)\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                seenIndices.add(idx)\n                idx += 1\n\n            if LOG:\n                LOG('seen component indices %s' % seenIndices)\n\n            if namedTypes:\n                if not namedTypes.requiredComponents.issubset(seenIndices):\n                    raise error.PyAsn1Error(\n                        'ASN.1 object %s has uninitialized '\n                        'components' % asn1Object.__class__.__name__)\n\n                if namedTypes.hasOpenTypes:\n\n                    openTypes = options.get('openTypes', {})\n\n                    if LOG:\n                        LOG('user-specified open types map:')\n\n                        for k, v in openTypes.items():\n                            LOG('%s -> %r' % (k, v))\n\n                    if openTypes or options.get('decodeOpenTypes', False):\n\n                        for idx, namedType in enumerate(namedTypes.namedTypes):\n                            if not namedType.openType:\n                                continue\n\n                            if namedType.isOptional and not asn1Object.getComponentByPosition(idx).isValue:\n                                continue\n\n                            governingValue = asn1Object.getComponentByName(\n                                namedType.openType.name\n                            )\n\n                            try:\n                                openType = openTypes[governingValue]\n\n                            except KeyError:\n\n                                if LOG:\n                                    LOG('default open types map of component '\n                                        '\"%s.%s\" governed by component \"%s.%s\"'\n                                        ':' % (asn1Object.__class__.__name__,\n                                               namedType.name,\n                                               asn1Object.__class__.__name__,\n                                               namedType.openType.name))\n\n                                    for k, v in namedType.openType.items():\n                                        LOG('%s -> %r' % (k, v))\n\n                                try:\n                                    openType = namedType.openType[governingValue]\n\n                                except KeyError:\n                                    if LOG:\n                                        LOG('failed to resolve open type by governing '\n                                            'value %r' % (governingValue,))\n                                    continue\n\n                            if LOG:\n                                LOG('resolved open type %r by governing '\n                                    'value %r' % (openType, governingValue))\n\n                            containerValue = asn1Object.getComponentByPosition(idx)\n\n                            if containerValue.typeId in (\n                                    univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                                for pos, containerElement in enumerate(\n                                        containerValue):\n\n                                    stream = asSeekableStream(containerValue[pos].asOctets())\n\n                                    for component in decodeFun(stream, asn1Spec=openType,\n                                                               **dict(options, allowEoo=True)):\n                                        if isinstance(component, SubstrateUnderrunError):\n                                            yield component\n\n                                        if component is eoo.endOfOctets:\n                                            break\n\n                                    containerValue[pos] = component\n\n                            else:\n                                stream = asSeekableStream(asn1Object.getComponentByPosition(idx).asOctets())\n                                for component in decodeFun(stream, asn1Spec=openType,\n                                                           **dict(options, allowEoo=True)):\n                                    if isinstance(component, SubstrateUnderrunError):\n                                        yield component\n\n                                    if component is eoo.endOfOctets:\n                                        break\n\n                                    asn1Object.setComponentByPosition(idx, component)\n\n                else:\n                    inconsistency = asn1Object.isInconsistent\n                    if inconsistency:\n                        raise inconsistency\n\n        else:\n            componentType = asn1Spec.componentType\n\n            if LOG:\n                LOG('decoding type %r chosen by given `asn1Spec`' % componentType)\n\n            idx = 0\n\n            while True:\n\n                for component in decodeFun(\n                        substrate, componentType, allowEoo=True, **options):\n\n                    if isinstance(component, SubstrateUnderrunError):\n                        yield component\n\n                    if component is eoo.endOfOctets:\n                        break\n\n                if component is eoo.endOfOctets:\n                    break\n\n                asn1Object.setComponentByPosition(\n                    idx, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False\n                )\n\n                idx += 1\n\n        yield asn1Object\n\n\nclass SequenceOrSequenceOfPayloadDecoder(ConstructedPayloadDecoderBase):\n    protoRecordComponent = univ.Sequence()\n    protoSequenceComponent = univ.SequenceOf()\n\n\nclass SequencePayloadDecoder(SequenceOrSequenceOfPayloadDecoder):\n    protoComponent = univ.Sequence()\n\n\nclass SequenceOfPayloadDecoder(SequenceOrSequenceOfPayloadDecoder):\n    protoComponent = univ.SequenceOf()\n\n\nclass SetOrSetOfPayloadDecoder(ConstructedPayloadDecoderBase):\n    protoRecordComponent = univ.Set()\n    protoSequenceComponent = univ.SetOf()\n\n\nclass SetPayloadDecoder(SetOrSetOfPayloadDecoder):\n    protoComponent = univ.Set()\n\n\nclass SetOfPayloadDecoder(SetOrSetOfPayloadDecoder):\n    protoComponent = univ.SetOf()\n\n\nclass ChoicePayloadDecoder(ConstructedPayloadDecoderBase):\n    protoComponent = univ.Choice()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if asn1Spec is None:\n            asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n        else:\n            asn1Object = asn1Spec.clone()\n\n        if substrateFun:\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        if asn1Object.tagSet == tagSet:\n            if LOG:\n                LOG('decoding %s as explicitly tagged CHOICE' % (tagSet,))\n\n            for component in decodeFun(\n                    substrate, asn1Object.componentTagMap, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n        else:\n            if LOG:\n                LOG('decoding %s as untagged CHOICE' % (tagSet,))\n\n            for component in decodeFun(\n                    substrate, asn1Object.componentTagMap, tagSet, length,\n                    state, **options):\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n        effectiveTagSet = component.effectiveTagSet\n\n        if LOG:\n            LOG('decoded component %s, effective tag set %s' % (component, effectiveTagSet))\n\n        asn1Object.setComponentByType(\n            effectiveTagSet, component,\n            verifyConstraints=False,\n            matchTags=False, matchConstraints=False,\n            innerFlag=False\n        )\n\n        yield asn1Object\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if asn1Spec is None:\n            asn1Object = self.protoComponent.clone(tagSet=tagSet)\n\n        else:\n            asn1Object = asn1Spec.clone()\n\n        if substrateFun:\n            for chunk in substrateFun(asn1Object, substrate, length, options):\n                yield chunk\n\n            return\n\n        options = self._passAsn1Object(asn1Object, options)\n\n        isTagged = asn1Object.tagSet == tagSet\n\n        if LOG:\n            LOG('decoding %s as %stagged CHOICE' % (\n                tagSet, isTagged and 'explicitly ' or 'un'))\n\n        while True:\n\n            if isTagged:\n                iterator = decodeFun(\n                    substrate, asn1Object.componentType.tagMapUnique,\n                    **dict(options, allowEoo=True))\n\n            else:\n                iterator = decodeFun(\n                    substrate, asn1Object.componentType.tagMapUnique,\n                    tagSet, length, state, **dict(options, allowEoo=True))\n\n            for component in iterator:\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n                effectiveTagSet = component.effectiveTagSet\n\n                if LOG:\n                    LOG('decoded component %s, effective tag set '\n                        '%s' % (component, effectiveTagSet))\n\n                asn1Object.setComponentByType(\n                    effectiveTagSet, component,\n                    verifyConstraints=False,\n                    matchTags=False, matchConstraints=False,\n                    innerFlag=False\n                )\n\n                if not isTagged:\n                    break\n\n            if not isTagged or component is eoo.endOfOctets:\n                break\n\n        yield asn1Object\n\n\nclass AnyPayloadDecoder(AbstractSimplePayloadDecoder):\n    protoComponent = univ.Any()\n\n    def valueDecoder(self, substrate, asn1Spec,\n                     tagSet=None, length=None, state=None,\n                     decodeFun=None, substrateFun=None,\n                     **options):\n        if asn1Spec is None:\n            isUntagged = True\n\n        elif asn1Spec.__class__ is tagmap.TagMap:\n            isUntagged = tagSet not in asn1Spec.tagMap\n\n        else:\n            isUntagged = tagSet != asn1Spec.tagSet\n\n        if isUntagged:\n            fullPosition = substrate.markedPosition\n            currentPosition = substrate.tell()\n\n            substrate.seek(fullPosition, os.SEEK_SET)\n            length += currentPosition - fullPosition\n\n            if LOG:\n                for chunk in peekIntoStream(substrate, length):\n                    if isinstance(chunk, SubstrateUnderrunError):\n                        yield chunk\n                LOG('decoding as untagged ANY, substrate '\n                    '%s' % debug.hexdump(chunk))\n\n        if substrateFun:\n            for chunk in substrateFun(\n                    self._createComponent(asn1Spec, tagSet, noValue, **options),\n                    substrate, length, options):\n                yield chunk\n\n            return\n\n        for chunk in readFromStream(substrate, length, options):\n            if isinstance(chunk, SubstrateUnderrunError):\n                yield chunk\n\n        yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n    def indefLenValueDecoder(self, substrate, asn1Spec,\n                             tagSet=None, length=None, state=None,\n                             decodeFun=None, substrateFun=None,\n                             **options):\n        if asn1Spec is None:\n            isTagged = False\n\n        elif asn1Spec.__class__ is tagmap.TagMap:\n            isTagged = tagSet in asn1Spec.tagMap\n\n        else:\n            isTagged = tagSet == asn1Spec.tagSet\n\n        if isTagged:\n            # tagged Any type -- consume header substrate\n            chunk = null\n\n            if LOG:\n                LOG('decoding as tagged ANY')\n\n        else:\n            # TODO: Seems not to be tested\n            fullPosition = substrate.markedPosition\n            currentPosition = substrate.tell()\n\n            substrate.seek(fullPosition, os.SEEK_SET)\n            for chunk in readFromStream(substrate, currentPosition - fullPosition, options):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield chunk\n\n            if LOG:\n                LOG('decoding as untagged ANY, header substrate %s' % debug.hexdump(chunk))\n\n        # Any components do not inherit initial tag\n        asn1Spec = self.protoComponent\n\n        if substrateFun and substrateFun is not self.substrateCollector:\n            asn1Object = self._createComponent(\n                asn1Spec, tagSet, noValue, **options)\n\n            for chunk in substrateFun(\n                    asn1Object, chunk + substrate, length + len(chunk), options):\n                yield chunk\n\n            return\n\n        if LOG:\n            LOG('assembling constructed serialization')\n\n        # All inner fragments are of the same type, treat them as octet string\n        substrateFun = self.substrateCollector\n\n        while True:  # loop over fragments\n\n            for component in decodeFun(\n                    substrate, asn1Spec, substrateFun=substrateFun,\n                    allowEoo=True, **options):\n\n                if isinstance(component, SubstrateUnderrunError):\n                    yield component\n\n                if component is eoo.endOfOctets:\n                    break\n\n            if component is eoo.endOfOctets:\n                break\n\n            chunk += component\n\n        if substrateFun:\n            yield chunk  # TODO: Weird\n\n        else:\n            yield self._createComponent(asn1Spec, tagSet, chunk, **options)\n\n\n# character string types\nclass UTF8StringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.UTF8String()\n\n\nclass NumericStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.NumericString()\n\n\nclass PrintableStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.PrintableString()\n\n\nclass TeletexStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.TeletexString()\n\n\nclass VideotexStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.VideotexString()\n\n\nclass IA5StringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.IA5String()\n\n\nclass GraphicStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.GraphicString()\n\n\nclass VisibleStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.VisibleString()\n\n\nclass GeneralStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.GeneralString()\n\n\nclass UniversalStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.UniversalString()\n\n\nclass BMPStringPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = char.BMPString()\n\n\n# \"useful\" types\nclass ObjectDescriptorPayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.ObjectDescriptor()\n\n\nclass GeneralizedTimePayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.GeneralizedTime()\n\n\nclass UTCTimePayloadDecoder(OctetStringPayloadDecoder):\n    protoComponent = useful.UTCTime()\n\n\nTAG_MAP = {\n    univ.Integer.tagSet: IntegerPayloadDecoder(),\n    univ.Boolean.tagSet: BooleanPayloadDecoder(),\n    univ.BitString.tagSet: BitStringPayloadDecoder(),\n    univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n    univ.Null.tagSet: NullPayloadDecoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierPayloadDecoder(),\n    univ.RelativeOID.tagSet: RelativeOIDPayloadDecoder(),\n    univ.Enumerated.tagSet: IntegerPayloadDecoder(),\n    univ.Real.tagSet: RealPayloadDecoder(),\n    univ.Sequence.tagSet: SequenceOrSequenceOfPayloadDecoder(),  # conflicts with SequenceOf\n    univ.Set.tagSet: SetOrSetOfPayloadDecoder(),  # conflicts with SetOf\n    univ.Choice.tagSet: ChoicePayloadDecoder(),  # conflicts with Any\n    # character string types\n    char.UTF8String.tagSet: UTF8StringPayloadDecoder(),\n    char.NumericString.tagSet: NumericStringPayloadDecoder(),\n    char.PrintableString.tagSet: PrintableStringPayloadDecoder(),\n    char.TeletexString.tagSet: TeletexStringPayloadDecoder(),\n    char.VideotexString.tagSet: VideotexStringPayloadDecoder(),\n    char.IA5String.tagSet: IA5StringPayloadDecoder(),\n    char.GraphicString.tagSet: GraphicStringPayloadDecoder(),\n    char.VisibleString.tagSet: VisibleStringPayloadDecoder(),\n    char.GeneralString.tagSet: GeneralStringPayloadDecoder(),\n    char.UniversalString.tagSet: UniversalStringPayloadDecoder(),\n    char.BMPString.tagSet: BMPStringPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: ObjectDescriptorPayloadDecoder(),\n    useful.GeneralizedTime.tagSet: GeneralizedTimePayloadDecoder(),\n    useful.UTCTime.tagSet: UTCTimePayloadDecoder()\n}\n\n# Type-to-codec map for ambiguous ASN.1 types\nTYPE_MAP = {\n    univ.Set.typeId: SetPayloadDecoder(),\n    univ.SetOf.typeId: SetOfPayloadDecoder(),\n    univ.Sequence.typeId: SequencePayloadDecoder(),\n    univ.SequenceOf.typeId: SequenceOfPayloadDecoder(),\n    univ.Choice.typeId: ChoicePayloadDecoder(),\n    univ.Any.typeId: AnyPayloadDecoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\n(stDecodeTag,\n stDecodeLength,\n stGetValueDecoder,\n stGetValueDecoderByAsn1Spec,\n stGetValueDecoderByTag,\n stTryAsExplicitTag,\n stDecodeValue,\n stDumpRawValue,\n stErrorCondition,\n stStop) = [x for x in range(10)]\n\n\nEOO_SENTINEL = ints2octs((0, 0))\n\n\nclass SingleItemDecoder(object):\n    defaultErrorState = stErrorCondition\n    #defaultErrorState = stDumpRawValue\n    defaultRawDecoder = AnyPayloadDecoder()\n\n    supportIndefLength = True\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n        # Tag & TagSet objects caches\n        self._tagCache = {}\n        self._tagSetCache = {}\n\n    def __call__(self, substrate, asn1Spec=None,\n                 tagSet=None, length=None, state=stDecodeTag,\n                 decodeFun=None, substrateFun=None,\n                 **options):\n\n        allowEoo = options.pop('allowEoo', False)\n\n        if LOG:\n            LOG('decoder called at scope %s with state %d, working with up '\n                'to %s octets of substrate: '\n                '%s' % (debug.scope, state, length, substrate))\n\n        # Look for end-of-octets sentinel\n        if allowEoo and self.supportIndefLength:\n\n            for eoo_candidate in readFromStream(substrate, 2, options):\n                if isinstance(eoo_candidate, SubstrateUnderrunError):\n                    yield eoo_candidate\n\n            if eoo_candidate == EOO_SENTINEL:\n                if LOG:\n                    LOG('end-of-octets sentinel found')\n                yield eoo.endOfOctets\n                return\n\n            else:\n                substrate.seek(-2, os.SEEK_CUR)\n\n        tagMap = self._tagMap\n        typeMap = self._typeMap\n        tagCache = self._tagCache\n        tagSetCache = self._tagSetCache\n\n        value = noValue\n\n        substrate.markedPosition = substrate.tell()\n\n        while state is not stStop:\n\n            if state is stDecodeTag:\n                # Decode tag\n                isShortTag = True\n\n                for firstByte in readFromStream(substrate, 1, options):\n                    if isinstance(firstByte, SubstrateUnderrunError):\n                        yield firstByte\n\n                firstOctet = ord(firstByte)\n\n                try:\n                    lastTag = tagCache[firstOctet]\n\n                except KeyError:\n                    integerTag = firstOctet\n                    tagClass = integerTag & 0xC0\n                    tagFormat = integerTag & 0x20\n                    tagId = integerTag & 0x1F\n\n                    if tagId == 0x1F:\n                        isShortTag = False\n                        lengthOctetIdx = 0\n                        tagId = 0\n\n                        while True:\n                            for integerByte in readFromStream(substrate, 1, options):\n                                if isinstance(integerByte, SubstrateUnderrunError):\n                                    yield integerByte\n\n                            if not integerByte:\n                                raise error.SubstrateUnderrunError(\n                                    'Short octet stream on long tag decoding'\n                                )\n\n                            integerTag = ord(integerByte)\n                            lengthOctetIdx += 1\n                            tagId <<= 7\n                            tagId |= (integerTag & 0x7F)\n\n                            if not integerTag & 0x80:\n                                break\n\n                    lastTag = tag.Tag(\n                        tagClass=tagClass, tagFormat=tagFormat, tagId=tagId\n                    )\n\n                    if isShortTag:\n                        # cache short tags\n                        tagCache[firstOctet] = lastTag\n\n                if tagSet is None:\n                    if isShortTag:\n                        try:\n                            tagSet = tagSetCache[firstOctet]\n\n                        except KeyError:\n                            # base tag not recovered\n                            tagSet = tag.TagSet((), lastTag)\n                            tagSetCache[firstOctet] = tagSet\n                    else:\n                        tagSet = tag.TagSet((), lastTag)\n\n                else:\n                    tagSet = lastTag + tagSet\n\n                state = stDecodeLength\n\n                if LOG:\n                    LOG('tag decoded into %s, decoding length' % tagSet)\n\n            if state is stDecodeLength:\n                # Decode length\n                for firstOctet in readFromStream(substrate, 1, options):\n                    if isinstance(firstOctet, SubstrateUnderrunError):\n                        yield firstOctet\n\n                firstOctet = ord(firstOctet)\n\n                if firstOctet < 128:\n                    length = firstOctet\n\n                elif firstOctet > 128:\n                    size = firstOctet & 0x7F\n                    # encoded in size bytes\n                    for encodedLength in readFromStream(substrate, size, options):\n                        if isinstance(encodedLength, SubstrateUnderrunError):\n                            yield encodedLength\n                    encodedLength = list(encodedLength)\n                    # missing check on maximum size, which shouldn't be a\n                    # problem, we can handle more than is possible\n                    if len(encodedLength) != size:\n                        raise error.SubstrateUnderrunError(\n                            '%s<%s at %s' % (size, len(encodedLength), tagSet)\n                        )\n\n                    length = 0\n                    for lengthOctet in encodedLength:\n                        length <<= 8\n                        length |= oct2int(lengthOctet)\n                    size += 1\n\n                else:  # 128 means indefinite\n                    length = -1\n\n                if length == -1 and not self.supportIndefLength:\n                    raise error.PyAsn1Error('Indefinite length encoding not supported by this codec')\n\n                state = stGetValueDecoder\n\n                if LOG:\n                    LOG('value length decoded into %d' % length)\n\n            if state is stGetValueDecoder:\n                if asn1Spec is None:\n                    state = stGetValueDecoderByTag\n\n                else:\n                    state = stGetValueDecoderByAsn1Spec\n            #\n            # There're two ways of creating subtypes in ASN.1 what influences\n            # decoder operation. These methods are:\n            # 1) Either base types used in or no IMPLICIT tagging has been\n            #    applied on subtyping.\n            # 2) Subtype syntax drops base type information (by means of\n            #    IMPLICIT tagging.\n            # The first case allows for complete tag recovery from substrate\n            # while the second one requires original ASN.1 type spec for\n            # decoding.\n            #\n            # In either case a set of tags (tagSet) is coming from substrate\n            # in an incremental, tag-by-tag fashion (this is the case of\n            # EXPLICIT tag which is most basic). Outermost tag comes first\n            # from the wire.\n            #\n            if state is stGetValueDecoderByTag:\n                try:\n                    concreteDecoder = tagMap[tagSet]\n\n                except KeyError:\n                    concreteDecoder = None\n\n                if concreteDecoder:\n                    state = stDecodeValue\n\n                else:\n                    try:\n                        concreteDecoder = tagMap[tagSet[:1]]\n\n                    except KeyError:\n                        concreteDecoder = None\n\n                    if concreteDecoder:\n                        state = stDecodeValue\n                    else:\n                        state = stTryAsExplicitTag\n\n                if LOG:\n                    LOG('codec %s chosen by a built-in type, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as explicit tag'))\n                    debug.scope.push(concreteDecoder is None and '?' or concreteDecoder.protoComponent.__class__.__name__)\n\n            if state is stGetValueDecoderByAsn1Spec:\n\n                if asn1Spec.__class__ is tagmap.TagMap:\n                    try:\n                        chosenSpec = asn1Spec[tagSet]\n\n                    except KeyError:\n                        chosenSpec = None\n\n                    if LOG:\n                        LOG('candidate ASN.1 spec is a map of:')\n\n                        for firstOctet, v in asn1Spec.presentTypes.items():\n                            LOG('  %s -> %s' % (firstOctet, v.__class__.__name__))\n\n                        if asn1Spec.skipTypes:\n                            LOG('but neither of: ')\n                            for firstOctet, v in asn1Spec.skipTypes.items():\n                                LOG('  %s -> %s' % (firstOctet, v.__class__.__name__))\n                        LOG('new candidate ASN.1 spec is %s, chosen by %s' % (chosenSpec is None and '<none>' or chosenSpec.prettyPrintType(), tagSet))\n\n                elif tagSet == asn1Spec.tagSet or tagSet in asn1Spec.tagMap:\n                    chosenSpec = asn1Spec\n                    if LOG:\n                        LOG('candidate ASN.1 spec is %s' % asn1Spec.__class__.__name__)\n\n                else:\n                    chosenSpec = None\n\n                if chosenSpec is not None:\n                    try:\n                        # ambiguous type or just faster codec lookup\n                        concreteDecoder = typeMap[chosenSpec.typeId]\n\n                        if LOG:\n                            LOG('value decoder chosen for an ambiguous type by type ID %s' % (chosenSpec.typeId,))\n\n                    except KeyError:\n                        # use base type for codec lookup to recover untagged types\n                        baseTagSet = tag.TagSet(chosenSpec.tagSet.baseTag,  chosenSpec.tagSet.baseTag)\n                        try:\n                            # base type or tagged subtype\n                            concreteDecoder = tagMap[baseTagSet]\n\n                            if LOG:\n                                LOG('value decoder chosen by base %s' % (baseTagSet,))\n\n                        except KeyError:\n                            concreteDecoder = None\n\n                    if concreteDecoder:\n                        asn1Spec = chosenSpec\n                        state = stDecodeValue\n\n                    else:\n                        state = stTryAsExplicitTag\n\n                else:\n                    concreteDecoder = None\n                    state = stTryAsExplicitTag\n\n                if LOG:\n                    LOG('codec %s chosen by ASN.1 spec, decoding %s' % (state is stDecodeValue and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as explicit tag'))\n                    debug.scope.push(chosenSpec is None and '?' or chosenSpec.__class__.__name__)\n\n            if state is stDecodeValue:\n                if not options.get('recursiveFlag', True) and not substrateFun:  # deprecate this\n                    def substrateFun(asn1Object, _substrate, _length, _options):\n                        \"\"\"Legacy hack to keep the recursiveFlag=False option supported.\n\n                        The decode(..., substrateFun=userCallback) option was introduced in 0.1.4 as a generalization\n                        of the old recursiveFlag=False option. Users should pass their callback instead of using\n                        recursiveFlag.\n                        \"\"\"\n                        yield asn1Object\n\n                original_position = substrate.tell()\n\n                if length == -1:  # indef length\n                    for value in concreteDecoder.indefLenValueDecoder(\n                            substrate, asn1Spec,\n                            tagSet, length, stGetValueDecoder,\n                            self, substrateFun, **options):\n                        if isinstance(value, SubstrateUnderrunError):\n                            yield value\n\n                else:\n                    for value in concreteDecoder.valueDecoder(\n                            substrate, asn1Spec,\n                            tagSet, length, stGetValueDecoder,\n                            self, substrateFun, **options):\n                        if isinstance(value, SubstrateUnderrunError):\n                            yield value\n\n                    bytesRead = substrate.tell() - original_position\n                    if not substrateFun and bytesRead != length:\n                        raise PyAsn1Error(\n                            \"Read %s bytes instead of expected %s.\" % (bytesRead, length))\n                    elif substrateFun and bytesRead > length:\n                        # custom substrateFun may be used for partial decoding, reading less is expected there\n                        raise PyAsn1Error(\n                            \"Read %s bytes are more than expected %s.\" % (bytesRead, length))\n\n                if LOG:\n                   LOG('codec %s yields type %s, value:\\n%s\\n...' % (\n                       concreteDecoder.__class__.__name__, value.__class__.__name__,\n                       isinstance(value, base.Asn1Item) and value.prettyPrint() or value))\n\n                state = stStop\n                break\n\n            if state is stTryAsExplicitTag:\n                if (tagSet and\n                        tagSet[0].tagFormat == tag.tagFormatConstructed and\n                        tagSet[0].tagClass != tag.tagClassUniversal):\n                    # Assume explicit tagging\n                    concreteDecoder = rawPayloadDecoder\n                    state = stDecodeValue\n\n                else:\n                    concreteDecoder = None\n                    state = self.defaultErrorState\n\n                if LOG:\n                    LOG('codec %s chosen, decoding %s' % (concreteDecoder and concreteDecoder.__class__.__name__ or \"<none>\", state is stDecodeValue and 'value' or 'as failure'))\n\n            if state is stDumpRawValue:\n                concreteDecoder = self.defaultRawDecoder\n\n                if LOG:\n                    LOG('codec %s chosen, decoding value' % concreteDecoder.__class__.__name__)\n\n                state = stDecodeValue\n\n            if state is stErrorCondition:\n                raise error.PyAsn1Error(\n                    '%s not in asn1Spec: %r' % (tagSet, asn1Spec)\n                )\n\n        if LOG:\n            debug.scope.pop()\n            LOG('decoder left scope %s, call completed' % debug.scope)\n\n        yield value\n\n\nclass StreamingDecoder(object):\n    \"\"\"Create an iterator that turns BER/CER/DER byte stream into ASN.1 objects.\n\n    On each iteration, consume whatever BER/CER/DER serialization is\n    available in the `substrate` stream-like object and turns it into\n    one or more, possibly nested, ASN.1 objects.\n\n    Parameters\n    ----------\n    substrate: :py:class:`file`, :py:class:`io.BytesIO`\n        BER/CER/DER serialization in form of a byte stream\n\n    Keyword Args\n    ------------\n    asn1Spec: :py:class:`~pyasn1.type.base.PyAsn1Item`\n        A pyasn1 type object to act as a template guiding the decoder.\n        Depending on the ASN.1 structure being decoded, `asn1Spec` may\n        or may not be required. One of the reasons why `asn1Spec` may\n        me required is that ASN.1 structure is encoded in the *IMPLICIT*\n        tagging mode.\n\n    Yields\n    ------\n    : :py:class:`~pyasn1.type.base.PyAsn1Item`, :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        Decoded ASN.1 object (possibly, nested) or\n        :py:class:`~pyasn1.error.SubstrateUnderrunError` object indicating\n        insufficient BER/CER/DER serialization on input to fully recover ASN.1\n        objects from it.\n        \n        In the latter case the caller is advised to ensure some more data in\n        the input stream, then call the iterator again. The decoder will resume\n        the decoding process using the newly arrived data.\n\n        The `context` property of :py:class:`~pyasn1.error.SubstrateUnderrunError`\n        object might hold a reference to the partially populated ASN.1 object\n        being reconstructed.\n\n    Raises\n    ------\n    ~pyasn1.error.PyAsn1Error, ~pyasn1.error.EndOfStreamError\n        `PyAsn1Error` on deserialization error, `EndOfStreamError` on\n         premature stream closure.\n\n    Examples\n    --------\n    Decode BER serialisation without ASN.1 schema\n\n    .. code-block:: pycon\n\n        >>> stream = io.BytesIO(\n        ...    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n        >>>\n        >>> for asn1Object in StreamingDecoder(stream):\n        ...     print(asn1Object)\n        >>>\n        SequenceOf:\n         1 2 3\n\n    Decode BER serialisation with ASN.1 schema\n\n    .. code-block:: pycon\n\n        >>> stream = io.BytesIO(\n        ...    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n        >>>\n        >>> schema = SequenceOf(componentType=Integer())\n        >>>\n        >>> decoder = StreamingDecoder(stream, asn1Spec=schema)\n        >>> for asn1Object in decoder:\n        ...     print(asn1Object)\n        >>>\n        SequenceOf:\n         1 2 3\n    \"\"\"\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n    def __init__(self, substrate, asn1Spec=None, **options):\n        self._singleItemDecoder = self.SINGLE_ITEM_DECODER(**options)\n        self._substrate = asSeekableStream(substrate)\n        self._asn1Spec = asn1Spec\n        self._options = options\n\n    def __iter__(self):\n        while True:\n            for asn1Object in self._singleItemDecoder(\n                    self._substrate, self._asn1Spec, **self._options):\n                yield asn1Object\n\n            for chunk in isEndOfStream(self._substrate):\n                if isinstance(chunk, SubstrateUnderrunError):\n                    yield\n\n                break\n\n            if chunk:\n                break\n\n\nclass Decoder(object):\n    \"\"\"Create a BER decoder object.\n\n    Parse BER/CER/DER octet-stream into one, possibly nested, ASN.1 object.\n    \"\"\"\n    STREAMING_DECODER = StreamingDecoder\n\n    @classmethod\n    def __call__(cls, substrate, asn1Spec=None, **options):\n        \"\"\"Turns BER/CER/DER octet stream into an ASN.1 object.\n\n        Takes BER/CER/DER octet-stream in form of :py:class:`bytes` (Python 3)\n        or :py:class:`str` (Python 2) and decode it into an ASN.1 object\n        (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n        may be a scalar or an arbitrary nested structure.\n\n        Parameters\n        ----------\n        substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n            BER/CER/DER octet-stream to parse\n\n        Keyword Args\n        ------------\n        asn1Spec: :py:class:`~pyasn1.type.base.PyAsn1Item`\n            A pyasn1 type object (:py:class:`~pyasn1.type.base.PyAsn1Item`\n            derivative) to act as a template guiding the decoder.\n            Depending on the ASN.1 structure being decoded, `asn1Spec` may or\n            may not be required. Most common reason for it to require is that\n            ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n\n        substrateFun: :py:class:`Union[\n                Callable[[pyasn1.type.base.PyAsn1Item, bytes, int],\n                         Tuple[pyasn1.type.base.PyAsn1Item, bytes]],\n                Callable[[pyasn1.type.base.PyAsn1Item, io.BytesIO, int, dict],\n                         Generator[Union[pyasn1.type.base.PyAsn1Item,\n                                         pyasn1.error.SubstrateUnderrunError],\n                                   None, None]]\n            ]`\n            User callback meant to generalize special use cases like non-recursive or\n            partial decoding. A 3-arg non-streaming variant is supported for backwards\n            compatiblilty in addition to the newer 4-arg streaming variant.\n            The callback will receive the uninitialized object recovered from substrate\n            as 1st argument, the uninterpreted payload as 2nd argument, and the length\n            of the uninterpreted payload as 3rd argument. The streaming variant will\n            additionally receive the decode(..., **options) kwargs as 4th argument.\n            The non-streaming variant shall return an object that will be propagated\n            as decode() return value as 1st item, and the remainig payload for further\n            decode passes as 2nd item.\n            The streaming variant shall yield an object that will be propagated as\n            decode() return value, and leave the remaining payload in the stream.\n\n        Returns\n        -------\n        : :py:class:`tuple`\n            A tuple of :py:class:`~pyasn1.type.base.PyAsn1Item` object\n            recovered from BER/CER/DER substrate and the unprocessed trailing\n            portion of the `substrate` (may be empty)\n\n        Raises\n        ------\n        : :py:class:`~pyasn1.error.PyAsn1Error`\n            :py:class:`~pyasn1.error.SubstrateUnderrunError` on insufficient\n            input or :py:class:`~pyasn1.error.PyAsn1Error` on decoding error.\n\n        Examples\n        --------\n        Decode BER/CER/DER serialisation without ASN.1 schema\n\n        .. code-block:: pycon\n\n           >>> s, unprocessed = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n           >>> str(s)\n           SequenceOf:\n            1 2 3\n\n        Decode BER/CER/DER serialisation with ASN.1 schema\n\n        .. code-block:: pycon\n\n           >>> seq = SequenceOf(componentType=Integer())\n           >>> s, unprocessed = decode(\n                b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n           >>> str(s)\n           SequenceOf:\n            1 2 3\n\n        \"\"\"\n        substrate = asSeekableStream(substrate)\n\n        if \"substrateFun\" in options:\n            origSubstrateFun = options[\"substrateFun\"]\n\n            def substrateFunWrapper(asn1Object, substrate, length, options=None):\n                \"\"\"Support both 0.4 and 0.5 style APIs.\n\n                substrateFun API has changed in 0.5 for use with streaming decoders. To stay backwards compatible,\n                we first try if we received a streaming user callback. If that fails,we assume we've received a\n                non-streaming v0.4 user callback and convert it for streaming on the fly\n                \"\"\"\n                try:\n                    substrate_gen = origSubstrateFun(asn1Object, substrate, length, options)\n                except TypeError:\n                    _type, _value, traceback = sys.exc_info()\n                    if traceback.tb_next:\n                        # Traceback depth > 1 means TypeError from inside user provided function\n                        raise\n                    # invariant maintained at Decoder.__call__ entry\n                    assert isinstance(substrate, io.BytesIO)  # nosec assert_used\n                    substrate_gen = Decoder._callSubstrateFunV4asV5(origSubstrateFun, asn1Object, substrate, length)\n                for value in substrate_gen:\n                    yield value\n\n            options[\"substrateFun\"] = substrateFunWrapper\n\n        streamingDecoder = cls.STREAMING_DECODER(\n            substrate, asn1Spec, **options)\n\n        for asn1Object in streamingDecoder:\n            if isinstance(asn1Object, SubstrateUnderrunError):\n                raise error.SubstrateUnderrunError('Short substrate on input')\n\n            try:\n                tail = next(readFromStream(substrate))\n\n            except error.EndOfStreamError:\n                tail = null\n\n            return asn1Object, tail\n\n    @staticmethod\n    def _callSubstrateFunV4asV5(substrateFunV4, asn1Object, substrate, length):\n        substrate_bytes = substrate.read()\n        if length == -1:\n            length = len(substrate_bytes)\n        value, nextSubstrate = substrateFunV4(asn1Object, substrate_bytes, length)\n        nbytes = substrate.write(nextSubstrate)\n        substrate.truncate()\n        substrate.seek(-nbytes, os.SEEK_CUR)\n        yield value\n\n#: Turns BER octet stream into an ASN.1 object.\n#:\n#: Takes BER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     BER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from BER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Notes\n#: -----\n#: This function is deprecated. Please use :py:class:`Decoder` or\n#: :py:class:`StreamingDecoder` class instance.\n#:\n#: Examples\n#: --------\n#: Decode BER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode BER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/ber/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/ber/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nimport sys\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.codec.ber import eoo\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.compat.integer import to_bytes\nfrom pyasn1.compat.octets import (int2oct, oct2int, ints2octs, null,\n                                  str2octs, isOctetsType)\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['Encoder', 'encode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_ENCODER)\n\n\nclass AbstractItemEncoder(object):\n    supportIndefLenMode = True\n\n    # An outcome of otherwise legit call `encodeFun(eoo.endOfOctets)`\n    eooIntegerSubstrate = (0, 0)\n    eooOctetsSubstrate = ints2octs(eooIntegerSubstrate)\n\n    # noinspection PyMethodMayBeStatic\n    def encodeTag(self, singleTag, isConstructed):\n        tagClass, tagFormat, tagId = singleTag\n        encodedTag = tagClass | tagFormat\n        if isConstructed:\n            encodedTag |= tag.tagFormatConstructed\n\n        if tagId < 31:\n            return encodedTag | tagId,\n\n        else:\n            substrate = tagId & 0x7f,\n\n            tagId >>= 7\n\n            while tagId:\n                substrate = (0x80 | (tagId & 0x7f),) + substrate\n                tagId >>= 7\n\n            return (encodedTag | 0x1F,) + substrate\n\n    def encodeLength(self, length, defMode):\n        if not defMode and self.supportIndefLenMode:\n            return (0x80,)\n\n        if length < 0x80:\n            return length,\n\n        else:\n            substrate = ()\n            while length:\n                substrate = (length & 0xff,) + substrate\n                length >>= 8\n\n            substrateLen = len(substrate)\n\n            if substrateLen > 126:\n                raise error.PyAsn1Error('Length octets overflow (%d)' % substrateLen)\n\n            return (0x80 | substrateLen,) + substrate\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        raise error.PyAsn1Error('Not implemented')\n\n    def encode(self, value, asn1Spec=None, encodeFun=None, **options):\n\n        if asn1Spec is None:\n            tagSet = value.tagSet\n        else:\n            tagSet = asn1Spec.tagSet\n\n        # untagged item?\n        if not tagSet:\n            substrate, isConstructed, isOctets = self.encodeValue(\n                value, asn1Spec, encodeFun, **options\n            )\n            return substrate\n\n        defMode = options.get('defMode', True)\n\n        substrate = null\n\n        for idx, singleTag in enumerate(tagSet.superTags):\n\n            defModeOverride = defMode\n\n            # base tag?\n            if not idx:\n                try:\n                    substrate, isConstructed, isOctets = self.encodeValue(\n                        value, asn1Spec, encodeFun, **options\n                    )\n\n                except error.PyAsn1Error:\n                    exc = sys.exc_info()\n                    raise error.PyAsn1Error(\n                        'Error encoding %r: %s' % (value, exc[1]))\n\n                if LOG:\n                    LOG('encoded %svalue %s into %s' % (\n                        isConstructed and 'constructed ' or '', value, substrate\n                    ))\n\n                if not substrate and isConstructed and options.get('ifNotEmpty', False):\n                    return substrate\n\n                if not isConstructed:\n                    defModeOverride = True\n\n                    if LOG:\n                        LOG('overridden encoding mode into definitive for primitive type')\n\n            header = self.encodeTag(singleTag, isConstructed)\n\n            if LOG:\n                LOG('encoded %stag %s into %s' % (\n                    isConstructed and 'constructed ' or '',\n                    singleTag, debug.hexdump(ints2octs(header))))\n\n            header += self.encodeLength(len(substrate), defModeOverride)\n\n            if LOG:\n                LOG('encoded %s octets (tag + payload) into %s' % (\n                    len(substrate), debug.hexdump(ints2octs(header))))\n\n            if isOctets:\n                substrate = ints2octs(header) + substrate\n\n                if not defModeOverride:\n                    substrate += self.eooOctetsSubstrate\n\n            else:\n                substrate = header + substrate\n\n                if not defModeOverride:\n                    substrate += self.eooIntegerSubstrate\n\n        if not isOctets:\n            substrate = ints2octs(substrate)\n\n        return substrate\n\n\nclass EndOfOctetsEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return null, False, True\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return value and (1,) or (0,), False, False\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n    supportCompactZero = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if value == 0:\n            if LOG:\n                LOG('encoding %spayload for zero INTEGER' % (\n                    self.supportCompactZero and 'no ' or ''\n                ))\n\n            # de-facto way to encode zero\n            if self.supportCompactZero:\n                return (), False, False\n            else:\n                return (0,), False, False\n\n        return to_bytes(int(value), signed=True), False, True\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            # TODO: try to avoid ASN.1 schema instantiation\n            value = asn1Spec.clone(value)\n\n        valueLength = len(value)\n        if valueLength % 8:\n            alignedValue = value << (8 - valueLength % 8)\n        else:\n            alignedValue = value\n\n        maxChunkSize = options.get('maxChunkSize', 0)\n        if not maxChunkSize or len(alignedValue) <= maxChunkSize * 8:\n            substrate = alignedValue.asOctets()\n            return int2oct(len(substrate) * 8 - valueLength) + substrate, False, True\n\n        if LOG:\n            LOG('encoding into up to %s-octet chunks' % maxChunkSize)\n\n        baseTag = value.tagSet.baseTag\n\n        # strip off explicit tags\n        if baseTag:\n            tagSet = tag.TagSet(baseTag, baseTag)\n\n        else:\n            tagSet = tag.TagSet()\n\n        alignedValue = alignedValue.clone(tagSet=tagSet)\n\n        stop = 0\n        substrate = null\n        while stop < valueLength:\n            start = stop\n            stop = min(start + maxChunkSize * 8, valueLength)\n            substrate += encodeFun(alignedValue[start:stop], asn1Spec, **options)\n\n        return substrate, True, True\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        if asn1Spec is None:\n            substrate = value.asOctets()\n\n        elif not isOctetsType(value):\n            substrate = asn1Spec.clone(value).asOctets()\n\n        else:\n            substrate = value\n\n        maxChunkSize = options.get('maxChunkSize', 0)\n\n        if not maxChunkSize or len(substrate) <= maxChunkSize:\n            return substrate, False, True\n\n        if LOG:\n            LOG('encoding into up to %s-octet chunks' % maxChunkSize)\n\n        # strip off explicit tags for inner chunks\n\n        if asn1Spec is None:\n            baseTag = value.tagSet.baseTag\n\n            # strip off explicit tags\n            if baseTag:\n                tagSet = tag.TagSet(baseTag, baseTag)\n\n            else:\n                tagSet = tag.TagSet()\n\n            asn1Spec = value.clone(tagSet=tagSet)\n\n        elif not isOctetsType(value):\n            baseTag = asn1Spec.tagSet.baseTag\n\n            # strip off explicit tags\n            if baseTag:\n                tagSet = tag.TagSet(baseTag, baseTag)\n\n            else:\n                tagSet = tag.TagSet()\n\n            asn1Spec = asn1Spec.clone(tagSet=tagSet)\n\n        pos = 0\n        substrate = null\n\n        while True:\n            chunk = value[pos:pos + maxChunkSize]\n            if not chunk:\n                break\n\n            substrate += encodeFun(chunk, asn1Spec, **options)\n            pos += maxChunkSize\n\n        return substrate, True, True\n\n\nclass NullEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        return null, False, True\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        oid = value.asTuple()\n\n        # Build the first pair\n        try:\n            first = oid[0]\n            second = oid[1]\n\n        except IndexError:\n            raise error.PyAsn1Error('Short OID %s' % (value,))\n\n        if 0 <= second <= 39:\n            if first == 1:\n                oid = (second + 40,) + oid[2:]\n            elif first == 0:\n                oid = (second,) + oid[2:]\n            elif first == 2:\n                oid = (second + 80,) + oid[2:]\n            else:\n                raise error.PyAsn1Error('Impossible first/second arcs at %s' % (value,))\n\n        elif first == 2:\n            oid = (second + 80,) + oid[2:]\n\n        else:\n            raise error.PyAsn1Error('Impossible first/second arcs at %s' % (value,))\n\n        octets = ()\n\n        # Cycle through subIds\n        for subOid in oid:\n            if 0 <= subOid <= 127:\n                # Optimize for the common case\n                octets += (subOid,)\n\n            elif subOid > 127:\n                # Pack large Sub-Object IDs\n                res = (subOid & 0x7f,)\n                subOid >>= 7\n\n                while subOid:\n                    res = (0x80 | (subOid & 0x7f),) + res\n                    subOid >>= 7\n\n                # Add packed Sub-Object ID to resulted Object ID\n                octets += res\n\n            else:\n                raise error.PyAsn1Error('Negative OID arc %s at %s' % (subOid, value))\n\n        return octets, False, False\n\n\nclass RelativeOIDEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        octets = ()\n\n        # Cycle through subIds\n        for subOid in value.asTuple():\n            if 0 <= subOid <= 127:\n                # Optimize for the common case\n                octets += (subOid,)\n\n            elif subOid > 127:\n                # Pack large Sub-Object IDs\n                res = (subOid & 0x7f,)\n                subOid >>= 7\n\n                while subOid:\n                    res = (0x80 | (subOid & 0x7f),) + res\n                    subOid >>= 7\n\n                # Add packed Sub-Object ID to resulted RELATIVE-OID\n                octets += res\n\n            else:\n                raise error.PyAsn1Error('Negative RELATIVE-OID arc %s at %s' % (subOid, value))\n\n        return octets, False, False\n\n\nclass RealEncoder(AbstractItemEncoder):\n    supportIndefLenMode = False\n    binEncBase = 2  # set to None to choose encoding base automatically\n\n    @staticmethod\n    def _dropFloatingPoint(m, encbase, e):\n        ms, es = 1, 1\n        if m < 0:\n            ms = -1  # mantissa sign\n\n        if e < 0:\n            es = -1  # exponent sign\n\n        m *= ms\n\n        if encbase == 8:\n            m *= 2 ** (abs(e) % 3 * es)\n            e = abs(e) // 3 * es\n\n        elif encbase == 16:\n            m *= 2 ** (abs(e) % 4 * es)\n            e = abs(e) // 4 * es\n\n        while True:\n            if int(m) != m:\n                m *= encbase\n                e -= 1\n                continue\n            break\n\n        return ms, int(m), encbase, e\n\n    def _chooseEncBase(self, value):\n        m, b, e = value\n        encBase = [2, 8, 16]\n        if value.binEncBase in encBase:\n            return self._dropFloatingPoint(m, value.binEncBase, e)\n\n        elif self.binEncBase in encBase:\n            return self._dropFloatingPoint(m, self.binEncBase, e)\n\n        # auto choosing base 2/8/16\n        mantissa = [m, m, m]\n        exponent = [e, e, e]\n        sign = 1\n        encbase = 2\n        e = float('inf')\n\n        for i in range(3):\n            (sign,\n             mantissa[i],\n             encBase[i],\n             exponent[i]) = self._dropFloatingPoint(mantissa[i], encBase[i], exponent[i])\n\n            if abs(exponent[i]) < abs(e) or (abs(exponent[i]) == abs(e) and mantissa[i] < m):\n                e = exponent[i]\n                m = int(mantissa[i])\n                encbase = encBase[i]\n\n        if LOG:\n            LOG('automatically chosen REAL encoding base %s, sign %s, mantissa %s, '\n                'exponent %s' % (encbase, sign, m, e))\n\n        return sign, m, encbase, e\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is not None:\n            value = asn1Spec.clone(value)\n\n        if value.isPlusInf:\n            return (0x40,), False, False\n\n        if value.isMinusInf:\n            return (0x41,), False, False\n\n        m, b, e = value\n\n        if not m:\n            return null, False, True\n\n        if b == 10:\n            if LOG:\n                LOG('encoding REAL into character form')\n\n            return str2octs('\\x03%dE%s%d' % (m, e == 0 and '+' or '', e)), False, True\n\n        elif b == 2:\n            fo = 0x80  # binary encoding\n            ms, m, encbase, e = self._chooseEncBase(value)\n\n            if ms < 0:  # mantissa sign\n                fo |= 0x40  # sign bit\n\n            # exponent & mantissa normalization\n            if encbase == 2:\n                while m & 0x1 == 0:\n                    m >>= 1\n                    e += 1\n\n            elif encbase == 8:\n                while m & 0x7 == 0:\n                    m >>= 3\n                    e += 1\n                fo |= 0x10\n\n            else:  # encbase = 16\n                while m & 0xf == 0:\n                    m >>= 4\n                    e += 1\n                fo |= 0x20\n\n            sf = 0  # scale factor\n\n            while m & 0x1 == 0:\n                m >>= 1\n                sf += 1\n\n            if sf > 3:\n                raise error.PyAsn1Error('Scale factor overflow')  # bug if raised\n\n            fo |= sf << 2\n            eo = null\n            if e == 0 or e == -1:\n                eo = int2oct(e & 0xff)\n\n            else:\n                while e not in (0, -1):\n                    eo = int2oct(e & 0xff) + eo\n                    e >>= 8\n\n                if e == 0 and eo and oct2int(eo[0]) & 0x80:\n                    eo = int2oct(0) + eo\n\n                if e == -1 and eo and not (oct2int(eo[0]) & 0x80):\n                    eo = int2oct(0xff) + eo\n\n            n = len(eo)\n            if n > 0xff:\n                raise error.PyAsn1Error('Real exponent overflow')\n\n            if n == 1:\n                pass\n\n            elif n == 2:\n                fo |= 1\n\n            elif n == 3:\n                fo |= 2\n\n            else:\n                fo |= 3\n                eo = int2oct(n & 0xff) + eo\n\n            po = null\n\n            while m:\n                po = int2oct(m & 0xff) + po\n                m >>= 8\n\n            substrate = int2oct(fo) + eo + po\n\n            return substrate, False, True\n\n        else:\n            raise error.PyAsn1Error('Prohibited Real base %s' % b)\n\n\nclass SequenceEncoder(AbstractItemEncoder):\n    omitEmptyOptionals = False\n\n    # TODO: handling three flavors of input is too much -- split over codecs\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n\n        substrate = null\n\n        omitEmptyOptionals = options.get(\n            'omitEmptyOptionals', self.omitEmptyOptionals)\n\n        if LOG:\n            LOG('%sencoding empty OPTIONAL components' % (\n                    omitEmptyOptionals and 'not ' or ''))\n\n        if asn1Spec is None:\n            # instance of ASN.1 schema\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n            namedTypes = value.componentType\n\n            for idx, component in enumerate(value.values()):\n                if namedTypes:\n                    namedType = namedTypes[idx]\n\n                    if namedType.isOptional and not component.isValue:\n                        if LOG:\n                            LOG('not encoding OPTIONAL component %r' % (namedType,))\n                        continue\n\n                    if namedType.isDefaulted and component == namedType.asn1Object:\n                        if LOG:\n                            LOG('not encoding DEFAULT component %r' % (namedType,))\n                        continue\n\n                    if omitEmptyOptionals:\n                        options.update(ifNotEmpty=namedType.isOptional)\n\n                # wrap open type blob if needed\n                if namedTypes and namedType.openType:\n\n                    wrapType = namedType.asn1Object\n\n                    if wrapType.typeId in (\n                            univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                        substrate += encodeFun(\n                                component, asn1Spec,\n                                **dict(options, wrapType=wrapType.componentType))\n\n                    else:\n                        chunk = encodeFun(component, asn1Spec, **options)\n\n                        if wrapType.isSameTypeWith(component):\n                            substrate += chunk\n\n                        else:\n                            substrate += encodeFun(chunk, wrapType, **options)\n\n                            if LOG:\n                                LOG('wrapped with wrap type %r' % (wrapType,))\n\n                else:\n                    substrate += encodeFun(component, asn1Spec, **options)\n\n        else:\n            # bare Python value + ASN.1 schema\n            for idx, namedType in enumerate(asn1Spec.componentType.namedTypes):\n\n                try:\n                    component = value[namedType.name]\n\n                except KeyError:\n                    raise error.PyAsn1Error('Component name \"%s\" not found in %r' % (\n                        namedType.name, value))\n\n                if namedType.isOptional and namedType.name not in value:\n                    if LOG:\n                        LOG('not encoding OPTIONAL component %r' % (namedType,))\n                    continue\n\n                if namedType.isDefaulted and component == namedType.asn1Object:\n                    if LOG:\n                        LOG('not encoding DEFAULT component %r' % (namedType,))\n                    continue\n\n                if omitEmptyOptionals:\n                    options.update(ifNotEmpty=namedType.isOptional)\n\n                componentSpec = namedType.asn1Object\n\n                # wrap open type blob if needed\n                if namedType.openType:\n\n                    if componentSpec.typeId in (\n                            univ.SetOf.typeId, univ.SequenceOf.typeId):\n\n                        substrate += encodeFun(\n                                component, componentSpec,\n                                **dict(options, wrapType=componentSpec.componentType))\n\n                    else:\n                        chunk = encodeFun(component, componentSpec, **options)\n\n                        if componentSpec.isSameTypeWith(component):\n                            substrate += chunk\n\n                        else:\n                            substrate += encodeFun(chunk, componentSpec, **options)\n\n                            if LOG:\n                                LOG('wrapped with wrap type %r' % (componentSpec,))\n\n                else:\n                    substrate += encodeFun(component, componentSpec, **options)\n\n        return substrate, True, True\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def _encodeComponents(self, value, asn1Spec, encodeFun, **options):\n\n        if asn1Spec is None:\n            inconsistency = value.isInconsistent\n            if inconsistency:\n                raise inconsistency\n\n        else:\n            asn1Spec = asn1Spec.componentType\n\n        chunks = []\n\n        wrapType = options.pop('wrapType', None)\n\n        for idx, component in enumerate(value):\n            chunk = encodeFun(component, asn1Spec, **options)\n\n            if (wrapType is not None and\n                    not wrapType.isSameTypeWith(component)):\n                # wrap encoded value with wrapper container (e.g. ANY)\n                chunk = encodeFun(chunk, wrapType, **options)\n\n                if LOG:\n                    LOG('wrapped with wrap type %r' % (wrapType,))\n\n            chunks.append(chunk)\n\n        return chunks\n\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        chunks = self._encodeComponents(\n            value, asn1Spec, encodeFun, **options)\n\n        return null.join(chunks), True, True\n\n\nclass ChoiceEncoder(AbstractItemEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is None:\n            component = value.getComponent()\n        else:\n            names = [namedType.name for namedType in asn1Spec.componentType.namedTypes\n                     if namedType.name in value]\n            if len(names) != 1:\n                raise error.PyAsn1Error('%s components for Choice at %r' % (len(names) and 'Multiple ' or 'None ', value))\n\n            name = names[0]\n\n            component = value[name]\n            asn1Spec = asn1Spec[name]\n\n        return encodeFun(component, asn1Spec, **options), True, True\n\n\nclass AnyEncoder(OctetStringEncoder):\n    def encodeValue(self, value, asn1Spec, encodeFun, **options):\n        if asn1Spec is None:\n            value = value.asOctets()\n        elif not isOctetsType(value):\n            value = asn1Spec.clone(value).asOctets()\n\n        return value, not options.get('defMode', True), True\n\n\nTAG_MAP = {\n    eoo.endOfOctets.tagSet: EndOfOctetsEncoder(),\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.RelativeOID.tagSet: RelativeOIDEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n    # character string types\n    char.UTF8String.tagSet: OctetStringEncoder(),\n    char.NumericString.tagSet: OctetStringEncoder(),\n    char.PrintableString.tagSet: OctetStringEncoder(),\n    char.TeletexString.tagSet: OctetStringEncoder(),\n    char.VideotexString.tagSet: OctetStringEncoder(),\n    char.IA5String.tagSet: OctetStringEncoder(),\n    char.GraphicString.tagSet: OctetStringEncoder(),\n    char.VisibleString.tagSet: OctetStringEncoder(),\n    char.GeneralString.tagSet: OctetStringEncoder(),\n    char.UniversalString.tagSet: OctetStringEncoder(),\n    char.BMPString.tagSet: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Integer.typeId: IntegerEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Null.typeId: NullEncoder(),\n    univ.ObjectIdentifier.typeId: ObjectIdentifierEncoder(),\n    univ.RelativeOID.typeId: RelativeOIDEncoder(),\n    univ.Enumerated.typeId: IntegerEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SequenceEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder(),\n    # character string types\n    char.UTF8String.typeId: OctetStringEncoder(),\n    char.NumericString.typeId: OctetStringEncoder(),\n    char.PrintableString.typeId: OctetStringEncoder(),\n    char.TeletexString.typeId: OctetStringEncoder(),\n    char.VideotexString.typeId: OctetStringEncoder(),\n    char.IA5String.typeId: OctetStringEncoder(),\n    char.GraphicString.typeId: OctetStringEncoder(),\n    char.VisibleString.typeId: OctetStringEncoder(),\n    char.GeneralString.typeId: OctetStringEncoder(),\n    char.UniversalString.typeId: OctetStringEncoder(),\n    char.BMPString.typeId: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: OctetStringEncoder(),\n    useful.GeneralizedTime.typeId: OctetStringEncoder(),\n    useful.UTCTime.typeId: OctetStringEncoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(object):\n    fixedDefLengthMode = None\n    fixedChunkSize = None\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, value, asn1Spec=None, **options):\n        try:\n            if asn1Spec is None:\n                typeId = value.typeId\n            else:\n                typeId = asn1Spec.typeId\n\n        except AttributeError:\n            raise error.PyAsn1Error('Value %r is not ASN.1 type instance '\n                                    'and \"asn1Spec\" not given' % (value,))\n\n        if LOG:\n            LOG('encoder called in %sdef mode, chunk size %s for type %s, '\n                'value:\\n%s' % (not options.get('defMode', True) and 'in' or '',\n                                options.get('maxChunkSize', 0),\n                                asn1Spec is None and value.prettyPrintType() or\n                                asn1Spec.prettyPrintType(), value))\n\n        if self.fixedDefLengthMode is not None:\n            options.update(defMode=self.fixedDefLengthMode)\n\n        if self.fixedChunkSize is not None:\n            options.update(maxChunkSize=self.fixedChunkSize)\n\n        try:\n            concreteEncoder = self._typeMap[typeId]\n\n            if LOG:\n                LOG('using value codec %s chosen by type ID '\n                    '%s' % (concreteEncoder.__class__.__name__, typeId))\n\n        except KeyError:\n            if asn1Spec is None:\n                tagSet = value.tagSet\n            else:\n                tagSet = asn1Spec.tagSet\n\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(tagSet.baseTag, tagSet.baseTag)\n\n            try:\n                concreteEncoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('No encoder for %r (%s)' % (value, tagSet))\n\n            if LOG:\n                LOG('using value codec %s chosen by tagSet '\n                    '%s' % (concreteEncoder.__class__.__name__, tagSet))\n\n        substrate = concreteEncoder.encode(value, asn1Spec, self, **options)\n\n        if LOG:\n            LOG('codec %s built %s octets of substrate: %s\\nencoder '\n                'completed' % (concreteEncoder, len(substrate),\n                               debug.hexdump(substrate)))\n\n        return substrate\n\n\nclass Encoder(object):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **options):\n        self._singleItemEncoder = self.SINGLE_ITEM_ENCODER(\n            tagMap=tagMap, typeMap=typeMap, **options\n        )\n\n    def __call__(self, pyObject, asn1Spec=None, **options):\n        return self._singleItemEncoder(\n            pyObject, asn1Spec=asn1Spec, **options)\n\n\n#: Turns ASN.1 object into BER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a BER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: defMode: :py:class:`bool`\n#:     If :obj:`False`, produces indefinite length encoding\n#:\n#: maxChunkSize: :py:class:`int`\n#:     Maximum chunk size in chunked encoding mode (0 denotes unlimited chunk size)\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octetstream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into BER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\n#: Encode ASN.1 value object into BER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\nencode = Encoder()\n", "pyasn1/codec/der/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1.codec.cer import decoder\nfrom pyasn1.type import univ\n\n__all__ = ['decode', 'StreamingDecoder']\n\n\nclass BitStringPayloadDecoder(decoder.BitStringPayloadDecoder):\n    supportConstructedForm = False\n\n\nclass OctetStringPayloadDecoder(decoder.OctetStringPayloadDecoder):\n    supportConstructedForm = False\n\n\n# TODO: prohibit non-canonical encoding\nRealPayloadDecoder = decoder.RealPayloadDecoder\n\nTAG_MAP = decoder.TAG_MAP.copy()\nTAG_MAP.update(\n    {univ.BitString.tagSet: BitStringPayloadDecoder(),\n     univ.OctetString.tagSet: OctetStringPayloadDecoder(),\n     univ.Real.tagSet: RealPayloadDecoder()}\n)\n\nTYPE_MAP = decoder.TYPE_MAP.copy()\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n# Put in non-ambiguous types for faster codec lookup\nfor typeDecoder in TAG_MAP.values():\n    if typeDecoder.protoComponent is not None:\n        typeId = typeDecoder.protoComponent.__class__.typeId\n        if typeId is not None and typeId not in TYPE_MAP:\n            TYPE_MAP[typeId] = typeDecoder\n\n\nclass SingleItemDecoder(decoder.SingleItemDecoder):\n    __doc__ = decoder.SingleItemDecoder.__doc__\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    supportIndefLength = False\n\n\nclass StreamingDecoder(decoder.StreamingDecoder):\n    __doc__ = decoder.StreamingDecoder.__doc__\n\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n\nclass Decoder(decoder.Decoder):\n    __doc__ = decoder.Decoder.__doc__\n\n    STREAMING_DECODER = StreamingDecoder\n\n\n#: Turns DER octet stream into an ASN.1 object.\n#:\n#: Takes DER octet-stream and decode it into an ASN.1 object\n#: (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: substrate: :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     DER octet-stream\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. Depending on the ASN.1 structure\n#:     being decoded, *asn1Spec* may or may not be required. Most common reason for\n#:     it to require is that ASN.1 structure is encoded in *IMPLICIT* tagging mode.\n#:\n#: Returns\n#: -------\n#: : :py:class:`tuple`\n#:     A tuple of pyasn1 object recovered from DER substrate (:py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     and the unprocessed trailing portion of the *substrate* (may be empty)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error, ~pyasn1.error.SubstrateUnderrunError\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode DER serialisation without ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03')\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\n#: Decode DER serialisation with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode(b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03', asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/der/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/der/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import error\nfrom pyasn1.codec.cer import encoder\nfrom pyasn1.type import univ\n\n__all__ = ['Encoder', 'encode']\n\n\nclass SetEncoder(encoder.SetEncoder):\n    @staticmethod\n    def _componentSortKey(componentAndType):\n        \"\"\"Sort SET components by tag\n\n        Sort depending on the actual Choice value (dynamic sort)\n        \"\"\"\n        component, asn1Spec = componentAndType\n\n        if asn1Spec is None:\n            compType = component\n        else:\n            compType = asn1Spec\n\n        if compType.typeId == univ.Choice.typeId and not compType.tagSet:\n            if asn1Spec is None:\n                return component.getComponent().tagSet\n            else:\n                # TODO: move out of sorting key function\n                names = [namedType.name for namedType in asn1Spec.componentType.namedTypes\n                         if namedType.name in component]\n                if len(names) != 1:\n                    raise error.PyAsn1Error(\n                        '%s components for Choice at %r' % (len(names) and 'Multiple ' or 'None ', component))\n\n                # TODO: support nested CHOICE ordering\n                return asn1Spec[names[0]].tagSet\n\n        else:\n            return compType.tagSet\n\n\nTAG_MAP = encoder.TAG_MAP.copy()\n\nTAG_MAP.update({\n    # Set & SetOf have same tags\n    univ.Set.tagSet: SetEncoder()\n})\n\nTYPE_MAP = encoder.TYPE_MAP.copy()\n\nTYPE_MAP.update({\n    # Set & SetOf have same tags\n    univ.Set.typeId: SetEncoder()\n})\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(encoder.SingleItemEncoder):\n    fixedDefLengthMode = True\n    fixedChunkSize = 0\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n\nclass Encoder(encoder.Encoder):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n\n#: Turns ASN.1 object into DER octet stream.\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a DER octet stream.\n#:\n#: Parameters\n#: ----------\n#: value: either a Python or pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     A Python or pyasn1 object to encode. If Python object is given, `asnSpec`\n#:     parameter is required to guide the encoding process.\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec:\n#:     Optional ASN.1 schema or value object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:\n#: Returns\n#: -------\n#: : :py:class:`bytes` (Python 3) or :py:class:`str` (Python 2)\n#:     Given ASN.1 object encoded into BER octet-stream\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode Python value into DER with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> encode([1, 2, 3], asn1Spec=seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\n#: Encode ASN.1 value object into DER\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    b'0\\t\\x02\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03'\n#:\nencode = Encoder()\n", "pyasn1/codec/native/decoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['decode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_DECODER)\n\n\nclass AbstractScalarPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        return asn1Spec.clone(pyObject)\n\n\nclass BitStringPayloadDecoder(AbstractScalarPayloadDecoder):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        return asn1Spec.clone(univ.BitString.fromBinaryString(pyObject))\n\n\nclass SequenceOrSetPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.componentType\n\n        for field in asn1Value:\n            if field in pyObject:\n                asn1Value[field] = decodeFun(pyObject[field], componentsTypes[field].asn1Object, **options)\n\n        return asn1Value\n\n\nclass SequenceOfOrSetOfPayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        for pyValue in pyObject:\n            asn1Value.append(decodeFun(pyValue, asn1Spec.componentType), **options)\n\n        return asn1Value\n\n\nclass ChoicePayloadDecoder(object):\n    def __call__(self, pyObject, asn1Spec, decodeFun=None, **options):\n        asn1Value = asn1Spec.clone()\n\n        componentsTypes = asn1Spec.componentType\n\n        for field in pyObject:\n            if field in componentsTypes:\n                asn1Value[field] = decodeFun(pyObject[field], componentsTypes[field].asn1Object, **options)\n                break\n\n        return asn1Value\n\n\nTAG_MAP = {\n    univ.Integer.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Boolean.tagSet: AbstractScalarPayloadDecoder(),\n    univ.BitString.tagSet: BitStringPayloadDecoder(),\n    univ.OctetString.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Null.tagSet: AbstractScalarPayloadDecoder(),\n    univ.ObjectIdentifier.tagSet: AbstractScalarPayloadDecoder(),\n    univ.RelativeOID.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Enumerated.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Real.tagSet: AbstractScalarPayloadDecoder(),\n    univ.Sequence.tagSet: SequenceOrSetPayloadDecoder(),  # conflicts with SequenceOf\n    univ.Set.tagSet: SequenceOrSetPayloadDecoder(),  # conflicts with SetOf\n    univ.Choice.tagSet: ChoicePayloadDecoder(),  # conflicts with Any\n    # character string types\n    char.UTF8String.tagSet: AbstractScalarPayloadDecoder(),\n    char.NumericString.tagSet: AbstractScalarPayloadDecoder(),\n    char.PrintableString.tagSet: AbstractScalarPayloadDecoder(),\n    char.TeletexString.tagSet: AbstractScalarPayloadDecoder(),\n    char.VideotexString.tagSet: AbstractScalarPayloadDecoder(),\n    char.IA5String.tagSet: AbstractScalarPayloadDecoder(),\n    char.GraphicString.tagSet: AbstractScalarPayloadDecoder(),\n    char.VisibleString.tagSet: AbstractScalarPayloadDecoder(),\n    char.GeneralString.tagSet: AbstractScalarPayloadDecoder(),\n    char.UniversalString.tagSet: AbstractScalarPayloadDecoder(),\n    char.BMPString.tagSet: AbstractScalarPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: AbstractScalarPayloadDecoder(),\n    useful.GeneralizedTime.tagSet: AbstractScalarPayloadDecoder(),\n    useful.UTCTime.tagSet: AbstractScalarPayloadDecoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Integer.typeId: AbstractScalarPayloadDecoder(),\n    univ.Boolean.typeId: AbstractScalarPayloadDecoder(),\n    univ.BitString.typeId: BitStringPayloadDecoder(),\n    univ.OctetString.typeId: AbstractScalarPayloadDecoder(),\n    univ.Null.typeId: AbstractScalarPayloadDecoder(),\n    univ.ObjectIdentifier.typeId: AbstractScalarPayloadDecoder(),\n    univ.RelativeOID.typeId: AbstractScalarPayloadDecoder(),\n    univ.Enumerated.typeId: AbstractScalarPayloadDecoder(),\n    univ.Real.typeId: AbstractScalarPayloadDecoder(),\n    # ambiguous base types\n    univ.Set.typeId: SequenceOrSetPayloadDecoder(),\n    univ.SetOf.typeId: SequenceOfOrSetOfPayloadDecoder(),\n    univ.Sequence.typeId: SequenceOrSetPayloadDecoder(),\n    univ.SequenceOf.typeId: SequenceOfOrSetOfPayloadDecoder(),\n    univ.Choice.typeId: ChoicePayloadDecoder(),\n    univ.Any.typeId: AbstractScalarPayloadDecoder(),\n    # character string types\n    char.UTF8String.typeId: AbstractScalarPayloadDecoder(),\n    char.NumericString.typeId: AbstractScalarPayloadDecoder(),\n    char.PrintableString.typeId: AbstractScalarPayloadDecoder(),\n    char.TeletexString.typeId: AbstractScalarPayloadDecoder(),\n    char.VideotexString.typeId: AbstractScalarPayloadDecoder(),\n    char.IA5String.typeId: AbstractScalarPayloadDecoder(),\n    char.GraphicString.typeId: AbstractScalarPayloadDecoder(),\n    char.VisibleString.typeId: AbstractScalarPayloadDecoder(),\n    char.GeneralString.typeId: AbstractScalarPayloadDecoder(),\n    char.UniversalString.typeId: AbstractScalarPayloadDecoder(),\n    char.BMPString.typeId: AbstractScalarPayloadDecoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: AbstractScalarPayloadDecoder(),\n    useful.GeneralizedTime.typeId: AbstractScalarPayloadDecoder(),\n    useful.UTCTime.typeId: AbstractScalarPayloadDecoder()\n}\n\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemDecoder(object):\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, pyObject, asn1Spec, **options):\n\n        if LOG:\n            debug.scope.push(type(pyObject).__name__)\n            LOG('decoder called at scope %s, working with '\n                'type %s' % (debug.scope, type(pyObject).__name__))\n\n        if asn1Spec is None or not isinstance(asn1Spec, base.Asn1Item):\n            raise error.PyAsn1Error(\n                'asn1Spec is not valid (should be an instance of an ASN.1 '\n                'Item, not %s)' % asn1Spec.__class__.__name__)\n\n        try:\n            valueDecoder = self._typeMap[asn1Spec.typeId]\n\n        except KeyError:\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(asn1Spec.tagSet.baseTag, asn1Spec.tagSet.baseTag)\n\n            try:\n                valueDecoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('Unknown ASN.1 tag %s' % asn1Spec.tagSet)\n\n        if LOG:\n            LOG('calling decoder %s on Python type %s '\n                '<%s>' % (type(valueDecoder).__name__,\n                          type(pyObject).__name__, repr(pyObject)))\n\n        value = valueDecoder(pyObject, asn1Spec, self, **options)\n\n        if LOG:\n            LOG('decoder %s produced ASN.1 type %s '\n                '<%s>' % (type(valueDecoder).__name__,\n                          type(value).__name__, repr(value)))\n            debug.scope.pop()\n\n        return value\n\n\nclass Decoder(object):\n    SINGLE_ITEM_DECODER = SingleItemDecoder\n\n    def __init__(self, **options):\n        self._singleItemDecoder = self.SINGLE_ITEM_DECODER(**options)\n\n    def __call__(self, pyObject, asn1Spec=None, **kwargs):\n        return self._singleItemDecoder(pyObject, asn1Spec=asn1Spec, **kwargs)\n\n\n#: Turns Python objects of built-in types into ASN.1 objects.\n#:\n#: Takes Python objects of built-in types and turns them into a tree of\n#: ASN.1 objects (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative) which\n#: may be a scalar or an arbitrary nested structure.\n#:\n#: Parameters\n#: ----------\n#: pyObject: :py:class:`object`\n#:     A scalar or nested Python objects\n#:\n#: Keyword Args\n#: ------------\n#: asn1Spec: any pyasn1 type object e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A pyasn1 type object to act as a template guiding the decoder. It is required\n#:     for successful interpretation of Python objects mapping into their ASN.1\n#:     representations.\n#:\n#: Returns\n#: -------\n#: : :py:class:`~pyasn1.type.base.PyAsn1Item` derivative\n#:     A scalar or constructed pyasn1 object\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On decoding errors\n#:\n#: Examples\n#: --------\n#: Decode native Python object into ASN.1 objects with ASN.1 schema\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> s, _ = decode([1, 2, 3], asn1Spec=seq)\n#:    >>> str(s)\n#:    SequenceOf:\n#:     1 2 3\n#:\ndecode = Decoder()\n", "pyasn1/codec/native/__init__.py": "# This file is necessary to make this directory a package.\n", "pyasn1/codec/native/encoder.py": "#\n# This file is part of pyasn1 software.\n#\n# Copyright (c) 2005-2020, Ilya Etingof <etingof@gmail.com>\n# License: https://pyasn1.readthedocs.io/en/latest/license.html\n#\nfrom collections import OrderedDict\n\nfrom pyasn1 import debug\nfrom pyasn1 import error\nfrom pyasn1.compat import _MISSING\nfrom pyasn1.type import base\nfrom pyasn1.type import char\nfrom pyasn1.type import tag\nfrom pyasn1.type import univ\nfrom pyasn1.type import useful\n\n__all__ = ['encode']\n\nLOG = debug.registerLoggee(__name__, flags=debug.DEBUG_ENCODER)\n\n\nclass AbstractItemEncoder(object):\n    def encode(self, value, encodeFun, **options):\n        raise error.PyAsn1Error('Not implemented')\n\n\nclass BooleanEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return bool(value)\n\n\nclass IntegerEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return int(value)\n\n\nclass BitStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass OctetStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return value.asOctets()\n\n\nclass TextStringEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass NullEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return None\n\n\nclass ObjectIdentifierEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass RelativeOIDEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return str(value)\n\n\nclass RealEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return float(value)\n\n\nclass SetEncoder(AbstractItemEncoder):\n    protoDict = dict\n\n    def encode(self, value, encodeFun, **options):\n        inconsistency = value.isInconsistent\n        if inconsistency:\n            raise inconsistency\n\n        namedTypes = value.componentType\n        substrate = self.protoDict()\n\n        for idx, (key, subValue) in enumerate(value.items()):\n            if namedTypes and namedTypes[idx].isOptional and not value[idx].isValue:\n                continue\n            substrate[key] = encodeFun(subValue, **options)\n        return substrate\n\n\nclass SequenceEncoder(SetEncoder):\n    protoDict = OrderedDict\n\n\nclass SequenceOfEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        inconsistency = value.isInconsistent\n        if inconsistency:\n            raise inconsistency\n        return [encodeFun(x, **options) for x in value]\n\n\nclass ChoiceEncoder(SequenceEncoder):\n    pass\n\n\nclass AnyEncoder(AbstractItemEncoder):\n    def encode(self, value, encodeFun, **options):\n        return value.asOctets()\n\n\nTAG_MAP = {\n    univ.Boolean.tagSet: BooleanEncoder(),\n    univ.Integer.tagSet: IntegerEncoder(),\n    univ.BitString.tagSet: BitStringEncoder(),\n    univ.OctetString.tagSet: OctetStringEncoder(),\n    univ.Null.tagSet: NullEncoder(),\n    univ.ObjectIdentifier.tagSet: ObjectIdentifierEncoder(),\n    univ.RelativeOID.tagSet: RelativeOIDEncoder(),\n    univ.Enumerated.tagSet: IntegerEncoder(),\n    univ.Real.tagSet: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.SequenceOf.tagSet: SequenceOfEncoder(),\n    univ.SetOf.tagSet: SequenceOfEncoder(),\n    univ.Choice.tagSet: ChoiceEncoder(),\n    # character string types\n    char.UTF8String.tagSet: TextStringEncoder(),\n    char.NumericString.tagSet: TextStringEncoder(),\n    char.PrintableString.tagSet: TextStringEncoder(),\n    char.TeletexString.tagSet: TextStringEncoder(),\n    char.VideotexString.tagSet: TextStringEncoder(),\n    char.IA5String.tagSet: TextStringEncoder(),\n    char.GraphicString.tagSet: TextStringEncoder(),\n    char.VisibleString.tagSet: TextStringEncoder(),\n    char.GeneralString.tagSet: TextStringEncoder(),\n    char.UniversalString.tagSet: TextStringEncoder(),\n    char.BMPString.tagSet: TextStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.tagSet: OctetStringEncoder(),\n    useful.GeneralizedTime.tagSet: OctetStringEncoder(),\n    useful.UTCTime.tagSet: OctetStringEncoder()\n}\n\n# Put in ambiguous & non-ambiguous types for faster codec lookup\nTYPE_MAP = {\n    univ.Boolean.typeId: BooleanEncoder(),\n    univ.Integer.typeId: IntegerEncoder(),\n    univ.BitString.typeId: BitStringEncoder(),\n    univ.OctetString.typeId: OctetStringEncoder(),\n    univ.Null.typeId: NullEncoder(),\n    univ.ObjectIdentifier.typeId: ObjectIdentifierEncoder(),\n    univ.RelativeOID.typeId: RelativeOIDEncoder(),\n    univ.Enumerated.typeId: IntegerEncoder(),\n    univ.Real.typeId: RealEncoder(),\n    # Sequence & Set have same tags as SequenceOf & SetOf\n    univ.Set.typeId: SetEncoder(),\n    univ.SetOf.typeId: SequenceOfEncoder(),\n    univ.Sequence.typeId: SequenceEncoder(),\n    univ.SequenceOf.typeId: SequenceOfEncoder(),\n    univ.Choice.typeId: ChoiceEncoder(),\n    univ.Any.typeId: AnyEncoder(),\n    # character string types\n    char.UTF8String.typeId: OctetStringEncoder(),\n    char.NumericString.typeId: OctetStringEncoder(),\n    char.PrintableString.typeId: OctetStringEncoder(),\n    char.TeletexString.typeId: OctetStringEncoder(),\n    char.VideotexString.typeId: OctetStringEncoder(),\n    char.IA5String.typeId: OctetStringEncoder(),\n    char.GraphicString.typeId: OctetStringEncoder(),\n    char.VisibleString.typeId: OctetStringEncoder(),\n    char.GeneralString.typeId: OctetStringEncoder(),\n    char.UniversalString.typeId: OctetStringEncoder(),\n    char.BMPString.typeId: OctetStringEncoder(),\n    # useful types\n    useful.ObjectDescriptor.typeId: OctetStringEncoder(),\n    useful.GeneralizedTime.typeId: OctetStringEncoder(),\n    useful.UTCTime.typeId: OctetStringEncoder()\n}\n\n# deprecated aliases, https://github.com/pyasn1/pyasn1/issues/9\ntagMap = TAG_MAP\ntypeMap = TYPE_MAP\n\n\nclass SingleItemEncoder(object):\n\n    TAG_MAP = TAG_MAP\n    TYPE_MAP = TYPE_MAP\n\n    def __init__(self, tagMap=_MISSING, typeMap=_MISSING, **ignored):\n        self._tagMap = tagMap if tagMap is not _MISSING else self.TAG_MAP\n        self._typeMap = typeMap if typeMap is not _MISSING else self.TYPE_MAP\n\n    def __call__(self, value, **options):\n        if not isinstance(value, base.Asn1Item):\n            raise error.PyAsn1Error(\n                'value is not valid (should be an instance of an ASN.1 Item)')\n\n        if LOG:\n            debug.scope.push(type(value).__name__)\n            LOG('encoder called for type %s '\n                '<%s>' % (type(value).__name__, value.prettyPrint()))\n\n        tagSet = value.tagSet\n\n        try:\n            concreteEncoder = self._typeMap[value.typeId]\n\n        except KeyError:\n            # use base type for codec lookup to recover untagged types\n            baseTagSet = tag.TagSet(\n                value.tagSet.baseTag, value.tagSet.baseTag)\n\n            try:\n                concreteEncoder = self._tagMap[baseTagSet]\n\n            except KeyError:\n                raise error.PyAsn1Error('No encoder for %s' % (value,))\n\n        if LOG:\n            LOG('using value codec %s chosen by '\n                '%s' % (concreteEncoder.__class__.__name__, tagSet))\n\n        pyObject = concreteEncoder.encode(value, self, **options)\n\n        if LOG:\n            LOG('encoder %s produced: '\n                '%s' % (type(concreteEncoder).__name__, repr(pyObject)))\n            debug.scope.pop()\n\n        return pyObject\n\n\nclass Encoder(object):\n    SINGLE_ITEM_ENCODER = SingleItemEncoder\n\n    def __init__(self, **options):\n        self._singleItemEncoder = self.SINGLE_ITEM_ENCODER(**options)\n\n    def __call__(self, pyObject, asn1Spec=None, **options):\n        return self._singleItemEncoder(\n            pyObject, asn1Spec=asn1Spec, **options)\n\n\n#: Turns ASN.1 object into a Python built-in type object(s).\n#:\n#: Takes any ASN.1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#: walks all its components recursively and produces a Python built-in type or a tree\n#: of those.\n#:\n#: One exception is that instead of :py:class:`dict`, the :py:class:`OrderedDict`\n#: is used to preserve ordering of the components in ASN.1 SEQUENCE.\n#:\n#: Parameters\n#: ----------\n#  asn1Value: any pyasn1 object (e.g. :py:class:`~pyasn1.type.base.PyAsn1Item` derivative)\n#:     pyasn1 object to encode (or a tree of them)\n#:\n#: Returns\n#: -------\n#: : :py:class:`object`\n#:     Python built-in type instance (or a tree of them)\n#:\n#: Raises\n#: ------\n#: ~pyasn1.error.PyAsn1Error\n#:     On encoding errors\n#:\n#: Examples\n#: --------\n#: Encode ASN.1 value object into native Python types\n#:\n#: .. code-block:: pycon\n#:\n#:    >>> seq = SequenceOf(componentType=Integer())\n#:    >>> seq.extend([1, 2, 3])\n#:    >>> encode(seq)\n#:    [1, 2, 3]\n#:\nencode = SingleItemEncoder()\n"}