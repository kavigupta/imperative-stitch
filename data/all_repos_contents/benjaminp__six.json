{"test_six.py": "# Copyright (c) 2010-2020 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nimport operator\nimport sys\nimport types\nimport unittest\nimport abc\n\nimport pytest\n\nimport six\n\n\ndef test_add_doc():\n    def f():\n        \"\"\"Icky doc\"\"\"\n        pass\n    six._add_doc(f, \"\"\"New doc\"\"\")\n    assert f.__doc__ == \"New doc\"\n\n\ndef test_import_module():\n    from logging import handlers\n    m = six._import_module(\"logging.handlers\")\n    assert m is handlers\n\n\ndef test_integer_types():\n    assert isinstance(1, six.integer_types)\n    assert isinstance(-1, six.integer_types)\n    assert isinstance(six.MAXSIZE + 23, six.integer_types)\n    assert not isinstance(.1, six.integer_types)\n\n\ndef test_string_types():\n    assert isinstance(\"hi\", six.string_types)\n    assert isinstance(six.u(\"hi\"), six.string_types)\n    assert issubclass(six.text_type, six.string_types)\n\n\ndef test_class_types():\n    class X:\n        pass\n    class Y(object):\n        pass\n    assert isinstance(X, six.class_types)\n    assert isinstance(Y, six.class_types)\n    assert not isinstance(X(), six.class_types)\n\n\ndef test_text_type():\n    assert type(six.u(\"hi\")) is six.text_type\n\n\ndef test_binary_type():\n    assert type(six.b(\"hi\")) is six.binary_type\n\n\ndef test_MAXSIZE():\n    try:\n        # This shouldn't raise an overflow error.\n        six.MAXSIZE.__index__()\n    except AttributeError:\n        # Before Python 2.6.\n        pass\n    pytest.raises(\n        (ValueError, OverflowError),\n        operator.mul, [None], six.MAXSIZE + 1)\n\n\ndef test_lazy():\n    if six.PY3:\n        html_name = \"html.parser\"\n    else:\n        html_name = \"HTMLParser\"\n    assert html_name not in sys.modules\n    mod = six.moves.html_parser\n    assert sys.modules[html_name] is mod\n    assert \"htmlparser\" not in six._MovedItems.__dict__\n\n\ntry:\n    import _tkinter\nexcept ImportError:\n    have_tkinter = False\nelse:\n    have_tkinter = True\n\nhave_gdbm = True\ntry:\n    import gdbm\nexcept ImportError:\n    try:\n        import dbm.gnu\n    except ImportError:\n        have_gdbm = False\n\nhave_ndbm = True\ntry:\n    import dbm\nexcept ImportError:\n    try:\n        import dbm.ndbm\n    except ImportError:\n        have_ndbm = False\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._moved_attributes])\ndef test_move_items(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    try:\n        item = getattr(six.moves, item_name)\n        if isinstance(item, types.ModuleType):\n            __import__(\"six.moves.\" + item_name)\n    except ImportError:\n        if item_name == \"winreg\" and not sys.platform.startswith(\"win\"):\n            pytest.skip(\"Windows only module\")\n        if item_name.startswith(\"tkinter\"):\n            if not have_tkinter:\n                pytest.skip(\"requires tkinter\")\n            if item_name == \"tkinter_tix\" and sys.version_info >= (3, 13):\n                pytest.skip(\"tkinter.tix removed from Python 3.13\")\n        if item_name == \"dbm_gnu\" and not have_gdbm:\n            pytest.skip(\"requires gdbm\")\n        if item_name == \"dbm_ndbm\":\n            pytest.skip(\"requires ndbm\")\n        raise\n    assert item_name in dir(six.moves)\n\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._urllib_parse_moved_attributes])\ndef test_move_items_urllib_parse(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    assert item_name in dir(six.moves.urllib.parse)\n    getattr(six.moves.urllib.parse, item_name)\n\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._urllib_error_moved_attributes])\ndef test_move_items_urllib_error(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    assert item_name in dir(six.moves.urllib.error)\n    getattr(six.moves.urllib.error, item_name)\n\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._urllib_request_moved_attributes])\ndef test_move_items_urllib_request(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    assert item_name in dir(six.moves.urllib.request)\n    getattr(six.moves.urllib.request, item_name)\n\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._urllib_response_moved_attributes])\ndef test_move_items_urllib_response(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    assert item_name in dir(six.moves.urllib.response)\n    getattr(six.moves.urllib.response, item_name)\n\n\n@pytest.mark.parametrize(\"item_name\",\n                          [item.name for item in six._urllib_robotparser_moved_attributes])\ndef test_move_items_urllib_robotparser(item_name):\n    \"\"\"Ensure that everything loads correctly.\"\"\"\n    assert item_name in dir(six.moves.urllib.robotparser)\n    getattr(six.moves.urllib.robotparser, item_name)\n\n\ndef test_import_moves_error_1():\n    from six.moves.urllib.parse import urljoin\n    from six import moves\n    # In 1.4.1: AttributeError: 'Module_six_moves_urllib_parse' object has no attribute 'urljoin'\n    assert moves.urllib.parse.urljoin\n\n\ndef test_import_moves_error_2():\n    from six import moves\n    assert moves.urllib.parse.urljoin\n    # In 1.4.1: ImportError: cannot import name urljoin\n    from six.moves.urllib.parse import urljoin\n\n\ndef test_import_moves_error_3():\n    from six.moves.urllib.parse import urljoin\n    # In 1.4.1: ImportError: cannot import name urljoin\n    from six.moves.urllib_parse import urljoin\n\n\ndef test_from_imports():\n    from six.moves.queue import Queue\n    assert isinstance(Queue, six.class_types)\n    from six.moves.configparser import ConfigParser\n    assert isinstance(ConfigParser, six.class_types)\n\n\ndef test_filter():\n    from six.moves import filter\n    f = filter(lambda x: x % 2, range(10))\n    assert six.advance_iterator(f) == 1\n\n\ndef test_filter_false():\n    from six.moves import filterfalse\n    f = filterfalse(lambda x: x % 3, range(10))\n    assert six.advance_iterator(f) == 0\n    assert six.advance_iterator(f) == 3\n    assert six.advance_iterator(f) == 6\n\ndef test_map():\n    from six.moves import map\n    assert six.advance_iterator(map(lambda x: x + 1, range(2))) == 1\n\n\ndef test_getoutput():\n    from six.moves import getoutput\n    output = getoutput('echo \"foo\"')\n    assert output == 'foo'\n\n\ndef test_zip():\n    from six.moves import zip\n    assert six.advance_iterator(zip(range(2), range(2))) == (0, 0)\n\n\ndef test_zip_longest():\n    from six.moves import zip_longest\n    it = zip_longest(range(2), range(1))\n\n    assert six.advance_iterator(it) == (0, 0)\n    assert six.advance_iterator(it) == (1, None)\n\n\nclass TestCustomizedMoves:\n\n    def teardown_method(self, meth):\n        try:\n            del six._MovedItems.spam\n        except AttributeError:\n            pass\n        try:\n            del six.moves.__dict__[\"spam\"]\n        except KeyError:\n            pass\n\n\n    def test_moved_attribute(self):\n        attr = six.MovedAttribute(\"spam\", \"foo\", \"bar\")\n        if six.PY3:\n            assert attr.mod == \"bar\"\n        else:\n            assert attr.mod == \"foo\"\n        assert attr.attr == \"spam\"\n        attr = six.MovedAttribute(\"spam\", \"foo\", \"bar\", \"lemma\")\n        assert attr.attr == \"lemma\"\n        attr = six.MovedAttribute(\"spam\", \"foo\", \"bar\", \"lemma\", \"theorm\")\n        if six.PY3:\n            assert attr.attr == \"theorm\"\n        else:\n            assert attr.attr == \"lemma\"\n\n\n    def test_moved_module(self):\n        attr = six.MovedModule(\"spam\", \"foo\")\n        if six.PY3:\n            assert attr.mod == \"spam\"\n        else:\n            assert attr.mod == \"foo\"\n        attr = six.MovedModule(\"spam\", \"foo\", \"bar\")\n        if six.PY3:\n            assert attr.mod == \"bar\"\n        else:\n            assert attr.mod == \"foo\"\n\n\n    def test_custom_move_module(self):\n        attr = six.MovedModule(\"spam\", \"six\", \"six\")\n        six.add_move(attr)\n        six.remove_move(\"spam\")\n        assert not hasattr(six.moves, \"spam\")\n        attr = six.MovedModule(\"spam\", \"six\", \"six\")\n        six.add_move(attr)\n        from six.moves import spam\n        assert spam is six\n        six.remove_move(\"spam\")\n        assert not hasattr(six.moves, \"spam\")\n\n\n    def test_custom_move_attribute(self):\n        attr = six.MovedAttribute(\"spam\", \"six\", \"six\", \"u\", \"u\")\n        six.add_move(attr)\n        six.remove_move(\"spam\")\n        assert not hasattr(six.moves, \"spam\")\n        attr = six.MovedAttribute(\"spam\", \"six\", \"six\", \"u\", \"u\")\n        six.add_move(attr)\n        from six.moves import spam\n        assert spam is six.u\n        six.remove_move(\"spam\")\n        assert not hasattr(six.moves, \"spam\")\n\n\n    def test_empty_remove(self):\n        pytest.raises(AttributeError, six.remove_move, \"eggs\")\n\n\ndef test_get_unbound_function():\n    class X(object):\n        def m(self):\n            pass\n    assert six.get_unbound_function(X.m) is X.__dict__[\"m\"]\n\n\ndef test_get_method_self():\n    class X(object):\n        def m(self):\n            pass\n    x = X()\n    assert six.get_method_self(x.m) is x\n    pytest.raises(AttributeError, six.get_method_self, 42)\n\n\ndef test_get_method_function():\n    class X(object):\n        def m(self):\n            pass\n    x = X()\n    assert six.get_method_function(x.m) is X.__dict__[\"m\"]\n    pytest.raises(AttributeError, six.get_method_function, hasattr)\n\n\ndef test_get_function_closure():\n    def f():\n        x = 42\n        def g():\n            return x\n        return g\n    cell = six.get_function_closure(f())[0]\n    assert type(cell).__name__ == \"cell\"\n\n\ndef test_get_function_code():\n    def f():\n        pass\n    assert isinstance(six.get_function_code(f), types.CodeType)\n    if not hasattr(sys, \"pypy_version_info\"):\n        pytest.raises(AttributeError, six.get_function_code, hasattr)\n\n\ndef test_get_function_defaults():\n    def f(x, y=3, b=4):\n        pass\n    assert six.get_function_defaults(f) == (3, 4)\n\n\ndef test_get_function_globals():\n    def f():\n        pass\n    assert six.get_function_globals(f) is globals()\n\n\ndef test_dictionary_iterators(monkeypatch):\n    def stock_method_name(iterwhat):\n        \"\"\"Given a method suffix like \"lists\" or \"values\", return the name\n        of the dict method that delivers those on the version of Python\n        we're running in.\"\"\"\n        if six.PY3:\n            return iterwhat\n        return 'iter' + iterwhat\n\n    class MyDict(dict):\n        if not six.PY3:\n            def lists(self, **kw):\n                return [1, 2, 3]\n        def iterlists(self, **kw):\n            return iter([1, 2, 3])\n    f = MyDict.iterlists\n    del MyDict.iterlists\n    setattr(MyDict, stock_method_name('lists'), f)\n\n    d = MyDict(zip(range(10), reversed(range(10))))\n    for name in \"keys\", \"values\", \"items\", \"lists\":\n        meth = getattr(six, \"iter\" + name)\n        it = meth(d)\n        assert not isinstance(it, list)\n        assert list(it) == list(getattr(d, name)())\n        pytest.raises(StopIteration, six.advance_iterator, it)\n        record = []\n        def with_kw(*args, **kw):\n            record.append(kw[\"kw\"])\n            return old(*args)\n        old = getattr(MyDict, stock_method_name(name))\n        monkeypatch.setattr(MyDict, stock_method_name(name), with_kw)\n        meth(d, kw=42)\n        assert record == [42]\n        monkeypatch.undo()\n\n\ndef test_dictionary_views():\n    d = dict(zip(range(10), (range(11, 20))))\n    for name in \"keys\", \"values\", \"items\":\n        meth = getattr(six, \"view\" + name)\n        view = meth(d)\n        assert set(view) == set(getattr(d, name)())\n\n\ndef test_advance_iterator():\n    assert six.next is six.advance_iterator\n    l = [1, 2]\n    it = iter(l)\n    assert six.next(it) == 1\n    assert six.next(it) == 2\n    pytest.raises(StopIteration, six.next, it)\n    pytest.raises(StopIteration, six.next, it)\n\n\ndef test_iterator():\n    class myiter(six.Iterator):\n        def __next__(self):\n            return 13\n    assert six.advance_iterator(myiter()) == 13\n    class myitersub(myiter):\n        def __next__(self):\n            return 14\n    assert six.advance_iterator(myitersub()) == 14\n\n\ndef test_callable():\n    class X:\n        def __call__(self):\n            pass\n        def method(self):\n            pass\n    assert six.callable(X)\n    assert six.callable(X())\n    assert six.callable(test_callable)\n    assert six.callable(hasattr)\n    assert six.callable(X.method)\n    assert six.callable(X().method)\n    assert not six.callable(4)\n    assert not six.callable(\"string\")\n\n\ndef test_create_bound_method():\n    class X(object):\n        pass\n    def f(self):\n        return self\n    x = X()\n    b = six.create_bound_method(f, x)\n    assert isinstance(b, types.MethodType)\n    assert b() is x\n\n\ndef test_create_unbound_method():\n    class X(object):\n        pass\n\n    def f(self):\n        return self\n    u = six.create_unbound_method(f, X)\n    pytest.raises(TypeError, u)\n    if six.PY2:\n        assert isinstance(u, types.MethodType)\n    x = X()\n    assert f(x) is x\n\n\nif six.PY3:\n\n    def test_b():\n        data = six.b(\"\\xff\")\n        assert isinstance(data, bytes)\n        assert len(data) == 1\n        assert data == bytes([255])\n\n\n    def test_u():\n        s = six.u(\"hi \\u0439 \\U00000439 \\\\ \\\\\\\\ \\n\")\n        assert isinstance(s, str)\n        assert s == \"hi \\u0439 \\U00000439 \\\\ \\\\\\\\ \\n\"\n\nelse:\n\n    def test_b():\n        data = six.b(\"\\xff\")\n        assert isinstance(data, str)\n        assert len(data) == 1\n        assert data == \"\\xff\"\n\n\n    def test_u():\n        s = six.u(\"hi \\u0439 \\U00000439 \\\\ \\\\\\\\ \\n\")\n        assert isinstance(s, unicode)\n        assert s == \"hi \\xd0\\xb9 \\xd0\\xb9 \\\\ \\\\\\\\ \\n\".decode(\"utf8\")\n\n\ndef test_u_escapes():\n    s = six.u(\"\\u1234\")\n    assert len(s) == 1\n\n\ndef test_unichr():\n    assert six.u(\"\\u1234\") == six.unichr(0x1234)\n    assert type(six.u(\"\\u1234\")) is type(six.unichr(0x1234))\n\n\ndef test_int2byte():\n    assert six.int2byte(3) == six.b(\"\\x03\")\n    pytest.raises(Exception, six.int2byte, 256)\n\n\ndef test_byte2int():\n    assert six.byte2int(six.b(\"\\x03\")) == 3\n    assert six.byte2int(six.b(\"\\x03\\x04\")) == 3\n    pytest.raises(IndexError, six.byte2int, six.b(\"\"))\n\n\ndef test_bytesindex():\n    assert six.indexbytes(six.b(\"hello\"), 3) == ord(\"l\")\n\n\ndef test_bytesiter():\n    it = six.iterbytes(six.b(\"hi\"))\n    assert six.next(it) == ord(\"h\")\n    assert six.next(it) == ord(\"i\")\n    pytest.raises(StopIteration, six.next, it)\n\n\ndef test_StringIO():\n    fp = six.StringIO()\n    fp.write(six.u(\"hello\"))\n    assert fp.getvalue() == six.u(\"hello\")\n\n\ndef test_BytesIO():\n    fp = six.BytesIO()\n    fp.write(six.b(\"hello\"))\n    assert fp.getvalue() == six.b(\"hello\")\n\n\ndef test_exec_():\n    def f():\n        l = []\n        six.exec_(\"l.append(1)\")\n        assert l == [1]\n    f()\n    ns = {}\n    six.exec_(\"x = 42\", ns)\n    assert ns[\"x\"] == 42\n    glob = {}\n    loc = {}\n    six.exec_(\"global y; y = 42; x = 12\", glob, loc)\n    assert glob[\"y\"] == 42\n    assert \"x\" not in glob\n    assert loc[\"x\"] == 12\n    assert \"y\" not in loc\n\n\ndef test_reraise():\n    def get_next(tb):\n        if six.PY3:\n            return tb.tb_next.tb_next\n        else:\n            return tb.tb_next\n    e = Exception(\"blah\")\n    try:\n        raise e\n    except Exception:\n        tp, val, tb = sys.exc_info()\n    try:\n        six.reraise(tp, val, tb)\n    except Exception:\n        tp2, value2, tb2 = sys.exc_info()\n        assert tp2 is Exception\n        assert value2 is e\n        assert tb is get_next(tb2)\n    try:\n        six.reraise(tp, val)\n    except Exception:\n        tp2, value2, tb2 = sys.exc_info()\n        assert tp2 is Exception\n        assert value2 is e\n        assert tb2 is not tb\n    try:\n        six.reraise(tp, val, tb2)\n    except Exception:\n        tp2, value2, tb3 = sys.exc_info()\n        assert tp2 is Exception\n        assert value2 is e\n        assert get_next(tb3) is tb2\n    try:\n        six.reraise(tp, None, tb)\n    except Exception:\n        tp2, value2, tb2 = sys.exc_info()\n        assert tp2 is Exception\n        assert value2 is not val\n        assert isinstance(value2, Exception)\n        assert tb is get_next(tb2)\n\n\ndef test_raise_from():\n    try:\n        try:\n            raise Exception(\"blah\")\n        except Exception:\n            ctx = sys.exc_info()[1]\n            f = Exception(\"foo\")\n            six.raise_from(f, None)\n    except Exception:\n        tp, val, tb = sys.exc_info()\n    if sys.version_info[:2] > (3, 0):\n        # We should have done a raise f from None equivalent.\n        assert val.__cause__ is None\n        assert val.__context__ is ctx\n        # And that should suppress the context on the exception.\n        assert val.__suppress_context__\n    # For all versions the outer exception should have raised successfully.\n    assert str(val) == \"foo\"\n\n\ndef test_print_():\n    save = sys.stdout\n    out = sys.stdout = six.moves.StringIO()\n    try:\n        six.print_(\"Hello,\", \"person!\")\n    finally:\n        sys.stdout = save\n    assert out.getvalue() == \"Hello, person!\\n\"\n    out = six.StringIO()\n    six.print_(\"Hello,\", \"person!\", file=out)\n    assert out.getvalue() == \"Hello, person!\\n\"\n    out = six.StringIO()\n    six.print_(\"Hello,\", \"person!\", file=out, end=\"\")\n    assert out.getvalue() == \"Hello, person!\"\n    out = six.StringIO()\n    six.print_(\"Hello,\", \"person!\", file=out, sep=\"X\")\n    assert out.getvalue() == \"Hello,Xperson!\\n\"\n    out = six.StringIO()\n    six.print_(six.u(\"Hello,\"), six.u(\"person!\"), file=out)\n    result = out.getvalue()\n    assert isinstance(result, six.text_type)\n    assert result == six.u(\"Hello, person!\\n\")\n    six.print_(\"Hello\", file=None) # This works.\n    out = six.StringIO()\n    six.print_(None, file=out)\n    assert out.getvalue() == \"None\\n\"\n    class FlushableStringIO(six.StringIO):\n        def __init__(self):\n            six.StringIO.__init__(self)\n            self.flushed = False\n        def flush(self):\n            self.flushed = True\n    out = FlushableStringIO()\n    six.print_(\"Hello\", file=out)\n    assert not out.flushed\n    six.print_(\"Hello\", file=out, flush=True)\n    assert out.flushed\n\n\ndef test_print_exceptions():\n    pytest.raises(TypeError, six.print_, x=3)\n    pytest.raises(TypeError, six.print_, end=3)\n    pytest.raises(TypeError, six.print_, sep=42)\n\n\ndef test_with_metaclass():\n    class Meta(type):\n        pass\n    class X(six.with_metaclass(Meta)):\n        pass\n    assert type(X) is Meta\n    assert issubclass(X, object)\n    class Base(object):\n        pass\n    class X(six.with_metaclass(Meta, Base)):\n        pass\n    assert type(X) is Meta\n    assert issubclass(X, Base)\n    class Base2(object):\n        pass\n    class X(six.with_metaclass(Meta, Base, Base2)):\n        pass\n    assert type(X) is Meta\n    assert issubclass(X, Base)\n    assert issubclass(X, Base2)\n    assert X.__mro__ == (X, Base, Base2, object)\n    class X(six.with_metaclass(Meta)):\n        pass\n    class MetaSub(Meta):\n        pass\n    class Y(six.with_metaclass(MetaSub, X)):\n        pass\n    assert type(Y) is MetaSub\n    assert Y.__mro__ == (Y, X, object)\n\n\ndef test_with_metaclass_typing():\n    try:\n        import typing\n    except ImportError:\n        pytest.skip(\"typing module required\")\n    class Meta(type):\n        pass\n    if sys.version_info[:2] < (3, 7):\n        # Generics with custom metaclasses were broken on older versions.\n        class Meta(Meta, typing.GenericMeta):\n            pass\n    T = typing.TypeVar('T')\n    class G(six.with_metaclass(Meta, typing.Generic[T])):\n        pass\n    class GA(six.with_metaclass(abc.ABCMeta, typing.Generic[T])):\n        pass\n    assert isinstance(G, Meta)\n    assert isinstance(GA, abc.ABCMeta)\n    assert G[int] is not G[G[int]]\n    assert GA[int] is not GA[GA[int]]\n    assert G.__bases__ == (typing.Generic,)\n    assert G.__orig_bases__ == (typing.Generic[T],)\n\n\n@pytest.mark.skipif(\"sys.version_info[:2] < (3, 7)\")\ndef test_with_metaclass_pep_560():\n    class Meta(type):\n        pass\n    class A:\n        pass\n    class B:\n        pass\n    class Fake:\n        def __mro_entries__(self, bases):\n            return (A, B)\n    fake = Fake()\n    class G(six.with_metaclass(Meta, fake)):\n        pass\n    class GA(six.with_metaclass(abc.ABCMeta, fake)):\n        pass\n    assert isinstance(G, Meta)\n    assert isinstance(GA, abc.ABCMeta)\n    assert G.__bases__ == (A, B)\n    assert G.__orig_bases__ == (fake,)\n\n\n@pytest.mark.skipif(\"sys.version_info[:2] < (3, 0)\")\ndef test_with_metaclass_prepare():\n    \"\"\"Test that with_metaclass causes Meta.__prepare__ to be called with the correct arguments.\"\"\"\n\n    class MyDict(dict):\n        pass\n\n    class Meta(type):\n\n        @classmethod\n        def __prepare__(cls, name, bases):\n            namespace = MyDict(super().__prepare__(name, bases), cls=cls, bases=bases)\n            namespace['namespace'] = namespace\n            return namespace\n\n    class Base(object):\n        pass\n\n    bases = (Base,)\n\n    class X(six.with_metaclass(Meta, *bases)):\n        pass\n\n    assert getattr(X, 'cls', type) is Meta\n    assert getattr(X, 'bases', ()) == bases\n    assert isinstance(getattr(X, 'namespace', {}), MyDict)\n\n\ndef test_wraps():\n    def f(g):\n        @six.wraps(g)\n        def w():\n            return 42\n        return w\n    def k():\n        pass\n    original_k = k\n    k = f(f(k))\n    assert hasattr(k, '__wrapped__')\n    k = k.__wrapped__\n    assert hasattr(k, '__wrapped__')\n    k = k.__wrapped__\n    assert k is original_k\n    assert not hasattr(k, '__wrapped__')\n\n    def f(g, assign, update):\n        def w():\n            return 42\n        w.glue = {\"foo\": \"bar\"}\n        w.xyzzy = {\"qux\": \"quux\"}\n        return six.wraps(g, assign, update)(w)\n    k.glue = {\"melon\": \"egg\"}\n    k.turnip = 43\n    k = f(k, [\"turnip\", \"baz\"], [\"glue\", \"xyzzy\"])\n    assert k.__name__ == \"w\"\n    assert k.turnip == 43\n    assert not hasattr(k, \"baz\")\n    assert k.glue == {\"melon\": \"egg\", \"foo\": \"bar\"}\n    assert k.xyzzy == {\"qux\": \"quux\"}\n\n\ndef test_wraps_raises_on_missing_updated_field_on_wrapper():\n    \"\"\"Ensure six.wraps doesn't ignore missing attrs wrapper.\n\n    Because that's what happens in Py3's functools.update_wrapper.\n    \"\"\"\n    def wrapped():\n        pass\n\n    def wrapper():\n        pass\n\n    with pytest.raises(AttributeError, match='has no attribute.*xyzzy'):\n        six.wraps(wrapped, [], ['xyzzy'])(wrapper)\n\n\n\ndef test_add_metaclass():\n    class Meta(type):\n        pass\n    class X:\n        \"success\"\n    X = six.add_metaclass(Meta)(X)\n    assert type(X) is Meta\n    assert issubclass(X, object)\n    assert X.__module__ == __name__\n    assert X.__doc__ == \"success\"\n    class Base(object):\n        pass\n    class X(Base):\n        pass\n    X = six.add_metaclass(Meta)(X)\n    assert type(X) is Meta\n    assert issubclass(X, Base)\n    class Base2(object):\n        pass\n    class X(Base, Base2):\n        pass\n    X = six.add_metaclass(Meta)(X)\n    assert type(X) is Meta\n    assert issubclass(X, Base)\n    assert issubclass(X, Base2)\n\n    # Test a second-generation subclass of a type.\n    class Meta1(type):\n        m1 = \"m1\"\n    class Meta2(Meta1):\n        m2 = \"m2\"\n    class Base:\n        b = \"b\"\n    Base = six.add_metaclass(Meta1)(Base)\n    class X(Base):\n        x = \"x\"\n    X = six.add_metaclass(Meta2)(X)\n    assert type(X) is Meta2\n    assert issubclass(X, Base)\n    assert type(Base) is Meta1\n    assert \"__dict__\" not in vars(X)\n    instance = X()\n    instance.attr = \"test\"\n    assert vars(instance) == {\"attr\": \"test\"}\n    assert instance.b == Base.b\n    assert instance.x == X.x\n\n    # Test a class with slots.\n    class MySlots(object):\n        __slots__ = [\"a\", \"b\"]\n    MySlots = six.add_metaclass(Meta1)(MySlots)\n\n    assert MySlots.__slots__ == [\"a\", \"b\"]\n    instance = MySlots()\n    instance.a = \"foo\"\n    pytest.raises(AttributeError, setattr, instance, \"c\", \"baz\")\n\n    # Test a class with string for slots.\n    class MyStringSlots(object):\n        __slots__ = \"ab\"\n    MyStringSlots = six.add_metaclass(Meta1)(MyStringSlots)\n    assert MyStringSlots.__slots__ == \"ab\"\n    instance = MyStringSlots()\n    instance.ab = \"foo\"\n    pytest.raises(AttributeError, setattr, instance, \"a\", \"baz\")\n    pytest.raises(AttributeError, setattr, instance, \"b\", \"baz\")\n\n    class MySlotsWeakref(object):\n        __slots__ = \"__weakref__\",\n    MySlotsWeakref = six.add_metaclass(Meta)(MySlotsWeakref)\n    assert type(MySlotsWeakref) is Meta\n\n\n@pytest.mark.skipif(\"sys.version_info[:2] < (3, 3)\")\ndef test_add_metaclass_nested():\n    # Regression test for https://github.com/benjaminp/six/issues/259\n    class Meta(type):\n        pass\n\n    class A:\n        class B: pass\n\n    expected = 'test_add_metaclass_nested.<locals>.A.B'\n\n    assert A.B.__qualname__ == expected\n\n    class A:\n        @six.add_metaclass(Meta)\n        class B: pass\n\n    assert A.B.__qualname__ == expected\n\n\ndef test_assertCountEqual():\n    class TestAssertCountEqual(unittest.TestCase):\n        def test(self):\n            with self.assertRaises(AssertionError):\n                six.assertCountEqual(self, (1, 2), [3, 4, 5])\n\n            six.assertCountEqual(self, (1, 2), [2, 1])\n\n    TestAssertCountEqual('test').test()\n\n\ndef test_assertRegex():\n    class TestAssertRegex(unittest.TestCase):\n        def test(self):\n            with self.assertRaises(AssertionError):\n                six.assertRegex(self, 'test', r'^a')\n\n            six.assertRegex(self, 'test', r'^t')\n\n    TestAssertRegex('test').test()\n\n\ndef test_assertNotRegex():\n    class TestAssertNotRegex(unittest.TestCase):\n        def test(self):\n            with self.assertRaises(AssertionError):\n                six.assertNotRegex(self, 'test', r'^t')\n\n            six.assertNotRegex(self, 'test', r'^a')\n\n    TestAssertNotRegex('test').test()\n\n\ndef test_assertRaisesRegex():\n    class TestAssertRaisesRegex(unittest.TestCase):\n        def test(self):\n            with six.assertRaisesRegex(self, AssertionError, '^Foo'):\n                raise AssertionError('Foo')\n\n            with self.assertRaises(AssertionError):\n                with six.assertRaisesRegex(self, AssertionError, r'^Foo'):\n                    raise AssertionError('Bar')\n\n    TestAssertRaisesRegex('test').test()\n\n\ndef test_python_2_unicode_compatible():\n    @six.python_2_unicode_compatible\n    class MyTest(object):\n        def __str__(self):\n            return six.u('hello')\n\n        def __bytes__(self):\n            return six.b('hello')\n\n    my_test = MyTest()\n\n    if six.PY2:\n        assert str(my_test) == six.b(\"hello\")\n        assert unicode(my_test) == six.u(\"hello\")\n    elif six.PY3:\n        assert bytes(my_test) == six.b(\"hello\")\n        assert str(my_test) == six.u(\"hello\")\n\n    assert getattr(six.moves.builtins, 'bytes', str)(my_test) == six.b(\"hello\")\n\n\nclass EnsureTests:\n\n    # grinning face emoji\n    UNICODE_EMOJI = six.u(\"\\U0001F600\")\n    BINARY_EMOJI = b\"\\xf0\\x9f\\x98\\x80\"\n\n    def test_ensure_binary_raise_type_error(self):\n        with pytest.raises(TypeError):\n            six.ensure_str(8)\n\n    def test_errors_and_encoding(self):\n        six.ensure_binary(self.UNICODE_EMOJI, encoding='latin-1', errors='ignore')\n        with pytest.raises(UnicodeEncodeError):\n            six.ensure_binary(self.UNICODE_EMOJI, encoding='latin-1', errors='strict')\n\n    def test_ensure_binary_raise(self):\n        converted_unicode = six.ensure_binary(self.UNICODE_EMOJI, encoding='utf-8', errors='strict')\n        converted_binary = six.ensure_binary(self.BINARY_EMOJI, encoding=\"utf-8\", errors='strict')\n        if six.PY2:\n            # PY2: unicode -> str\n            assert converted_unicode == self.BINARY_EMOJI and isinstance(converted_unicode, str)\n            # PY2: str -> str\n            assert converted_binary == self.BINARY_EMOJI and isinstance(converted_binary, str)\n        else:\n            # PY3: str -> bytes\n            assert converted_unicode == self.BINARY_EMOJI and isinstance(converted_unicode, bytes)\n            # PY3: bytes -> bytes\n            assert converted_binary == self.BINARY_EMOJI and isinstance(converted_binary, bytes)\n\n    def test_ensure_str(self):\n        converted_unicode = six.ensure_str(self.UNICODE_EMOJI, encoding='utf-8', errors='strict')\n        converted_binary = six.ensure_str(self.BINARY_EMOJI, encoding=\"utf-8\", errors='strict')\n        if six.PY2:\n            # PY2: unicode -> str\n            assert converted_unicode == self.BINARY_EMOJI and isinstance(converted_unicode, str)\n            # PY2: str -> str\n            assert converted_binary == self.BINARY_EMOJI and isinstance(converted_binary, str)\n        else:\n            # PY3: str -> str\n            assert converted_unicode == self.UNICODE_EMOJI and isinstance(converted_unicode, str)\n            # PY3: bytes -> str\n            assert converted_binary == self.UNICODE_EMOJI and isinstance(converted_unicode, str)\n\n    def test_ensure_text(self):\n        converted_unicode = six.ensure_text(self.UNICODE_EMOJI, encoding='utf-8', errors='strict')\n        converted_binary = six.ensure_text(self.BINARY_EMOJI, encoding=\"utf-8\", errors='strict')\n        if six.PY2:\n            # PY2: unicode -> unicode\n            assert converted_unicode == self.UNICODE_EMOJI and isinstance(converted_unicode, unicode)\n            # PY2: str -> unicode\n            assert converted_binary == self.UNICODE_EMOJI and isinstance(converted_unicode, unicode)\n        else:\n            # PY3: str -> str\n            assert converted_unicode == self.UNICODE_EMOJI and isinstance(converted_unicode, str)\n            # PY3: bytes -> str\n            assert converted_binary == self.UNICODE_EMOJI and isinstance(converted_unicode, str)\n", "setup.py": "# Copyright (c) 2010-2020 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\nfrom __future__ import with_statement\n\n# Six is a dependency of setuptools, so using setuptools creates a\n# circular dependency when building a Python stack from source. We\n# therefore allow falling back to distutils to install six.\ntry:\n    from setuptools import setup\nexcept ImportError:\n    from distutils.core import setup\n\nimport six\n\nsix_classifiers = [\n    \"Development Status :: 5 - Production/Stable\",\n    \"Programming Language :: Python :: 2\",\n    \"Programming Language :: Python :: 3\",\n    \"Intended Audience :: Developers\",\n    \"License :: OSI Approved :: MIT License\",\n    \"Topic :: Software Development :: Libraries\",\n    \"Topic :: Utilities\",\n]\n\nwith open(\"README.rst\", \"r\") as fp:\n    six_long_description = fp.read()\n\nsetup(name=\"six\",\n      version=six.__version__,\n      author=\"Benjamin Peterson\",\n      author_email=\"benjamin@python.org\",\n      url=\"https://github.com/benjaminp/six\",\n      tests_require=[\"pytest\"],\n      py_modules=[\"six\"],\n      description=\"Python 2 and 3 compatibility utilities\",\n      long_description=six_long_description,\n      license=\"MIT\",\n      classifiers=six_classifiers,\n      python_requires=\">=2.7, !=3.0.*, !=3.1.*, !=3.2.*\",\n      )\n", "six.py": "# Copyright (c) 2010-2020 Benjamin Peterson\n#\n# Permission is hereby granted, free of charge, to any person obtaining a copy\n# of this software and associated documentation files (the \"Software\"), to deal\n# in the Software without restriction, including without limitation the rights\n# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n# copies of the Software, and to permit persons to whom the Software is\n# furnished to do so, subject to the following conditions:\n#\n# The above copyright notice and this permission notice shall be included in all\n# copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n# SOFTWARE.\n\n\"\"\"Utilities for writing code that runs on Python 2 and 3\"\"\"\n\nfrom __future__ import absolute_import\n\nimport functools\nimport itertools\nimport operator\nimport sys\nimport types\n\n__author__ = \"Benjamin Peterson <benjamin@python.org>\"\n__version__ = \"1.16.0\"\n\n\n# Useful for very coarse version differentiation.\nPY2 = sys.version_info[0] == 2\nPY3 = sys.version_info[0] == 3\nPY34 = sys.version_info[0:2] >= (3, 4)\n\nif PY3:\n    string_types = str,\n    integer_types = int,\n    class_types = type,\n    text_type = str\n    binary_type = bytes\n\n    MAXSIZE = sys.maxsize\nelse:\n    string_types = basestring,\n    integer_types = (int, long)\n    class_types = (type, types.ClassType)\n    text_type = unicode\n    binary_type = str\n\n    if sys.platform.startswith(\"java\"):\n        # Jython always uses 32 bits.\n        MAXSIZE = int((1 << 31) - 1)\n    else:\n        # It's possible to have sizeof(long) != sizeof(Py_ssize_t).\n        class X(object):\n\n            def __len__(self):\n                return 1 << 31\n        try:\n            len(X())\n        except OverflowError:\n            # 32-bit\n            MAXSIZE = int((1 << 31) - 1)\n        else:\n            # 64-bit\n            MAXSIZE = int((1 << 63) - 1)\n        del X\n\nif PY34:\n    from importlib.util import spec_from_loader\nelse:\n    spec_from_loader = None\n\n\ndef _add_doc(func, doc):\n    \"\"\"Add documentation to a function.\"\"\"\n    func.__doc__ = doc\n\n\ndef _import_module(name):\n    \"\"\"Import module, returning the module after the last dot.\"\"\"\n    __import__(name)\n    return sys.modules[name]\n\n\nclass _LazyDescr(object):\n\n    def __init__(self, name):\n        self.name = name\n\n    def __get__(self, obj, tp):\n        result = self._resolve()\n        setattr(obj, self.name, result)  # Invokes __set__.\n        try:\n            # This is a bit ugly, but it avoids running this again by\n            # removing this descriptor.\n            delattr(obj.__class__, self.name)\n        except AttributeError:\n            pass\n        return result\n\n\nclass MovedModule(_LazyDescr):\n\n    def __init__(self, name, old, new=None):\n        super(MovedModule, self).__init__(name)\n        if PY3:\n            if new is None:\n                new = name\n            self.mod = new\n        else:\n            self.mod = old\n\n    def _resolve(self):\n        return _import_module(self.mod)\n\n    def __getattr__(self, attr):\n        _module = self._resolve()\n        value = getattr(_module, attr)\n        setattr(self, attr, value)\n        return value\n\n\nclass _LazyModule(types.ModuleType):\n\n    def __init__(self, name):\n        super(_LazyModule, self).__init__(name)\n        self.__doc__ = self.__class__.__doc__\n\n    def __dir__(self):\n        attrs = [\"__doc__\", \"__name__\"]\n        attrs += [attr.name for attr in self._moved_attributes]\n        return attrs\n\n    # Subclasses should override this\n    _moved_attributes = []\n\n\nclass MovedAttribute(_LazyDescr):\n\n    def __init__(self, name, old_mod, new_mod, old_attr=None, new_attr=None):\n        super(MovedAttribute, self).__init__(name)\n        if PY3:\n            if new_mod is None:\n                new_mod = name\n            self.mod = new_mod\n            if new_attr is None:\n                if old_attr is None:\n                    new_attr = name\n                else:\n                    new_attr = old_attr\n            self.attr = new_attr\n        else:\n            self.mod = old_mod\n            if old_attr is None:\n                old_attr = name\n            self.attr = old_attr\n\n    def _resolve(self):\n        module = _import_module(self.mod)\n        return getattr(module, self.attr)\n\n\nclass _SixMetaPathImporter(object):\n\n    \"\"\"\n    A meta path importer to import six.moves and its submodules.\n\n    This class implements a PEP302 finder and loader. It should be compatible\n    with Python 2.5 and all existing versions of Python3\n    \"\"\"\n\n    def __init__(self, six_module_name):\n        self.name = six_module_name\n        self.known_modules = {}\n\n    def _add_module(self, mod, *fullnames):\n        for fullname in fullnames:\n            self.known_modules[self.name + \".\" + fullname] = mod\n\n    def _get_module(self, fullname):\n        return self.known_modules[self.name + \".\" + fullname]\n\n    def find_module(self, fullname, path=None):\n        if fullname in self.known_modules:\n            return self\n        return None\n\n    def find_spec(self, fullname, path, target=None):\n        if fullname in self.known_modules:\n            return spec_from_loader(fullname, self)\n        return None\n\n    def __get_module(self, fullname):\n        try:\n            return self.known_modules[fullname]\n        except KeyError:\n            raise ImportError(\"This loader does not know module \" + fullname)\n\n    def load_module(self, fullname):\n        try:\n            # in case of a reload\n            return sys.modules[fullname]\n        except KeyError:\n            pass\n        mod = self.__get_module(fullname)\n        if isinstance(mod, MovedModule):\n            mod = mod._resolve()\n        else:\n            mod.__loader__ = self\n        sys.modules[fullname] = mod\n        return mod\n\n    def is_package(self, fullname):\n        \"\"\"\n        Return true, if the named module is a package.\n\n        We need this method to get correct spec objects with\n        Python 3.4 (see PEP451)\n        \"\"\"\n        return hasattr(self.__get_module(fullname), \"__path__\")\n\n    def get_code(self, fullname):\n        \"\"\"Return None\n\n        Required, if is_package is implemented\"\"\"\n        self.__get_module(fullname)  # eventually raises ImportError\n        return None\n    get_source = get_code  # same as get_code\n\n    def create_module(self, spec):\n        return self.load_module(spec.name)\n\n    def exec_module(self, module):\n        pass\n\n_importer = _SixMetaPathImporter(__name__)\n\n\nclass _MovedItems(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects\"\"\"\n    __path__ = []  # mark as package\n\n\n_moved_attributes = [\n    MovedAttribute(\"cStringIO\", \"cStringIO\", \"io\", \"StringIO\"),\n    MovedAttribute(\"filter\", \"itertools\", \"builtins\", \"ifilter\", \"filter\"),\n    MovedAttribute(\"filterfalse\", \"itertools\", \"itertools\", \"ifilterfalse\", \"filterfalse\"),\n    MovedAttribute(\"input\", \"__builtin__\", \"builtins\", \"raw_input\", \"input\"),\n    MovedAttribute(\"intern\", \"__builtin__\", \"sys\"),\n    MovedAttribute(\"map\", \"itertools\", \"builtins\", \"imap\", \"map\"),\n    MovedAttribute(\"getcwd\", \"os\", \"os\", \"getcwdu\", \"getcwd\"),\n    MovedAttribute(\"getcwdb\", \"os\", \"os\", \"getcwd\", \"getcwdb\"),\n    MovedAttribute(\"getoutput\", \"commands\", \"subprocess\"),\n    MovedAttribute(\"range\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),\n    MovedAttribute(\"reload_module\", \"__builtin__\", \"importlib\" if PY34 else \"imp\", \"reload\"),\n    MovedAttribute(\"reduce\", \"__builtin__\", \"functools\"),\n    MovedAttribute(\"shlex_quote\", \"pipes\", \"shlex\", \"quote\"),\n    MovedAttribute(\"StringIO\", \"StringIO\", \"io\"),\n    MovedAttribute(\"UserDict\", \"UserDict\", \"collections\", \"IterableUserDict\", \"UserDict\"),\n    MovedAttribute(\"UserList\", \"UserList\", \"collections\"),\n    MovedAttribute(\"UserString\", \"UserString\", \"collections\"),\n    MovedAttribute(\"xrange\", \"__builtin__\", \"builtins\", \"xrange\", \"range\"),\n    MovedAttribute(\"zip\", \"itertools\", \"builtins\", \"izip\", \"zip\"),\n    MovedAttribute(\"zip_longest\", \"itertools\", \"itertools\", \"izip_longest\", \"zip_longest\"),\n    MovedModule(\"builtins\", \"__builtin__\"),\n    MovedModule(\"configparser\", \"ConfigParser\"),\n    MovedModule(\"collections_abc\", \"collections\", \"collections.abc\" if sys.version_info >= (3, 3) else \"collections\"),\n    MovedModule(\"copyreg\", \"copy_reg\"),\n    MovedModule(\"dbm_gnu\", \"gdbm\", \"dbm.gnu\"),\n    MovedModule(\"dbm_ndbm\", \"dbm\", \"dbm.ndbm\"),\n    MovedModule(\"_dummy_thread\", \"dummy_thread\", \"_dummy_thread\" if sys.version_info < (3, 9) else \"_thread\"),\n    MovedModule(\"http_cookiejar\", \"cookielib\", \"http.cookiejar\"),\n    MovedModule(\"http_cookies\", \"Cookie\", \"http.cookies\"),\n    MovedModule(\"html_entities\", \"htmlentitydefs\", \"html.entities\"),\n    MovedModule(\"html_parser\", \"HTMLParser\", \"html.parser\"),\n    MovedModule(\"http_client\", \"httplib\", \"http.client\"),\n    MovedModule(\"email_mime_base\", \"email.MIMEBase\", \"email.mime.base\"),\n    MovedModule(\"email_mime_image\", \"email.MIMEImage\", \"email.mime.image\"),\n    MovedModule(\"email_mime_multipart\", \"email.MIMEMultipart\", \"email.mime.multipart\"),\n    MovedModule(\"email_mime_nonmultipart\", \"email.MIMENonMultipart\", \"email.mime.nonmultipart\"),\n    MovedModule(\"email_mime_text\", \"email.MIMEText\", \"email.mime.text\"),\n    MovedModule(\"BaseHTTPServer\", \"BaseHTTPServer\", \"http.server\"),\n    MovedModule(\"CGIHTTPServer\", \"CGIHTTPServer\", \"http.server\"),\n    MovedModule(\"SimpleHTTPServer\", \"SimpleHTTPServer\", \"http.server\"),\n    MovedModule(\"cPickle\", \"cPickle\", \"pickle\"),\n    MovedModule(\"queue\", \"Queue\"),\n    MovedModule(\"reprlib\", \"repr\"),\n    MovedModule(\"socketserver\", \"SocketServer\"),\n    MovedModule(\"_thread\", \"thread\", \"_thread\"),\n    MovedModule(\"tkinter\", \"Tkinter\"),\n    MovedModule(\"tkinter_dialog\", \"Dialog\", \"tkinter.dialog\"),\n    MovedModule(\"tkinter_filedialog\", \"FileDialog\", \"tkinter.filedialog\"),\n    MovedModule(\"tkinter_scrolledtext\", \"ScrolledText\", \"tkinter.scrolledtext\"),\n    MovedModule(\"tkinter_simpledialog\", \"SimpleDialog\", \"tkinter.simpledialog\"),\n    MovedModule(\"tkinter_tix\", \"Tix\", \"tkinter.tix\"),\n    MovedModule(\"tkinter_ttk\", \"ttk\", \"tkinter.ttk\"),\n    MovedModule(\"tkinter_constants\", \"Tkconstants\", \"tkinter.constants\"),\n    MovedModule(\"tkinter_dnd\", \"Tkdnd\", \"tkinter.dnd\"),\n    MovedModule(\"tkinter_colorchooser\", \"tkColorChooser\",\n                \"tkinter.colorchooser\"),\n    MovedModule(\"tkinter_commondialog\", \"tkCommonDialog\",\n                \"tkinter.commondialog\"),\n    MovedModule(\"tkinter_tkfiledialog\", \"tkFileDialog\", \"tkinter.filedialog\"),\n    MovedModule(\"tkinter_font\", \"tkFont\", \"tkinter.font\"),\n    MovedModule(\"tkinter_messagebox\", \"tkMessageBox\", \"tkinter.messagebox\"),\n    MovedModule(\"tkinter_tksimpledialog\", \"tkSimpleDialog\",\n                \"tkinter.simpledialog\"),\n    MovedModule(\"urllib_parse\", __name__ + \".moves.urllib_parse\", \"urllib.parse\"),\n    MovedModule(\"urllib_error\", __name__ + \".moves.urllib_error\", \"urllib.error\"),\n    MovedModule(\"urllib\", __name__ + \".moves.urllib\", __name__ + \".moves.urllib\"),\n    MovedModule(\"urllib_robotparser\", \"robotparser\", \"urllib.robotparser\"),\n    MovedModule(\"xmlrpc_client\", \"xmlrpclib\", \"xmlrpc.client\"),\n    MovedModule(\"xmlrpc_server\", \"SimpleXMLRPCServer\", \"xmlrpc.server\"),\n]\n# Add windows specific modules.\nif sys.platform == \"win32\":\n    _moved_attributes += [\n        MovedModule(\"winreg\", \"_winreg\"),\n    ]\n\nfor attr in _moved_attributes:\n    setattr(_MovedItems, attr.name, attr)\n    if isinstance(attr, MovedModule):\n        _importer._add_module(attr, \"moves.\" + attr.name)\ndel attr\n\n_MovedItems._moved_attributes = _moved_attributes\n\nmoves = _MovedItems(__name__ + \".moves\")\n_importer._add_module(moves, \"moves\")\n\n\nclass Module_six_moves_urllib_parse(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_parse\"\"\"\n\n\n_urllib_parse_moved_attributes = [\n    MovedAttribute(\"ParseResult\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"SplitResult\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"parse_qs\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"parse_qsl\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urldefrag\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urljoin\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlparse\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlsplit\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlunparse\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"urlunsplit\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"quote\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"quote_plus\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote_plus\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"unquote_to_bytes\", \"urllib\", \"urllib.parse\", \"unquote\", \"unquote_to_bytes\"),\n    MovedAttribute(\"urlencode\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splitquery\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splittag\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splituser\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"splitvalue\", \"urllib\", \"urllib.parse\"),\n    MovedAttribute(\"uses_fragment\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_netloc\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_params\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_query\", \"urlparse\", \"urllib.parse\"),\n    MovedAttribute(\"uses_relative\", \"urlparse\", \"urllib.parse\"),\n]\nfor attr in _urllib_parse_moved_attributes:\n    setattr(Module_six_moves_urllib_parse, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_parse._moved_attributes = _urllib_parse_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_parse(__name__ + \".moves.urllib_parse\"),\n                      \"moves.urllib_parse\", \"moves.urllib.parse\")\n\n\nclass Module_six_moves_urllib_error(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_error\"\"\"\n\n\n_urllib_error_moved_attributes = [\n    MovedAttribute(\"URLError\", \"urllib2\", \"urllib.error\"),\n    MovedAttribute(\"HTTPError\", \"urllib2\", \"urllib.error\"),\n    MovedAttribute(\"ContentTooShortError\", \"urllib\", \"urllib.error\"),\n]\nfor attr in _urllib_error_moved_attributes:\n    setattr(Module_six_moves_urllib_error, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_error._moved_attributes = _urllib_error_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_error(__name__ + \".moves.urllib.error\"),\n                      \"moves.urllib_error\", \"moves.urllib.error\")\n\n\nclass Module_six_moves_urllib_request(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_request\"\"\"\n\n\n_urllib_request_moved_attributes = [\n    MovedAttribute(\"urlopen\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"install_opener\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"build_opener\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"pathname2url\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"url2pathname\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"getproxies\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"Request\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"OpenerDirector\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPDefaultErrorHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPRedirectHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPCookieProcessor\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"BaseHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPPasswordMgr\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPPasswordMgrWithDefaultRealm\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"AbstractBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyBasicAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"AbstractDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"ProxyDigestAuthHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPSHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"FileHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"FTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"CacheFTPHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"UnknownHandler\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"HTTPErrorProcessor\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"urlretrieve\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"urlcleanup\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"URLopener\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"FancyURLopener\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"proxy_bypass\", \"urllib\", \"urllib.request\"),\n    MovedAttribute(\"parse_http_list\", \"urllib2\", \"urllib.request\"),\n    MovedAttribute(\"parse_keqv_list\", \"urllib2\", \"urllib.request\"),\n]\nfor attr in _urllib_request_moved_attributes:\n    setattr(Module_six_moves_urllib_request, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_request._moved_attributes = _urllib_request_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_request(__name__ + \".moves.urllib.request\"),\n                      \"moves.urllib_request\", \"moves.urllib.request\")\n\n\nclass Module_six_moves_urllib_response(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_response\"\"\"\n\n\n_urllib_response_moved_attributes = [\n    MovedAttribute(\"addbase\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addclosehook\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addinfo\", \"urllib\", \"urllib.response\"),\n    MovedAttribute(\"addinfourl\", \"urllib\", \"urllib.response\"),\n]\nfor attr in _urllib_response_moved_attributes:\n    setattr(Module_six_moves_urllib_response, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_response._moved_attributes = _urllib_response_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_response(__name__ + \".moves.urllib.response\"),\n                      \"moves.urllib_response\", \"moves.urllib.response\")\n\n\nclass Module_six_moves_urllib_robotparser(_LazyModule):\n\n    \"\"\"Lazy loading of moved objects in six.moves.urllib_robotparser\"\"\"\n\n\n_urllib_robotparser_moved_attributes = [\n    MovedAttribute(\"RobotFileParser\", \"robotparser\", \"urllib.robotparser\"),\n]\nfor attr in _urllib_robotparser_moved_attributes:\n    setattr(Module_six_moves_urllib_robotparser, attr.name, attr)\ndel attr\n\nModule_six_moves_urllib_robotparser._moved_attributes = _urllib_robotparser_moved_attributes\n\n_importer._add_module(Module_six_moves_urllib_robotparser(__name__ + \".moves.urllib.robotparser\"),\n                      \"moves.urllib_robotparser\", \"moves.urllib.robotparser\")\n\n\nclass Module_six_moves_urllib(types.ModuleType):\n\n    \"\"\"Create a six.moves.urllib namespace that resembles the Python 3 namespace\"\"\"\n    __path__ = []  # mark as package\n    parse = _importer._get_module(\"moves.urllib_parse\")\n    error = _importer._get_module(\"moves.urllib_error\")\n    request = _importer._get_module(\"moves.urllib_request\")\n    response = _importer._get_module(\"moves.urllib_response\")\n    robotparser = _importer._get_module(\"moves.urllib_robotparser\")\n\n    def __dir__(self):\n        return ['parse', 'error', 'request', 'response', 'robotparser']\n\n_importer._add_module(Module_six_moves_urllib(__name__ + \".moves.urllib\"),\n                      \"moves.urllib\")\n\n\ndef add_move(move):\n    \"\"\"Add an item to six.moves.\"\"\"\n    setattr(_MovedItems, move.name, move)\n\n\ndef remove_move(name):\n    \"\"\"Remove item from six.moves.\"\"\"\n    try:\n        delattr(_MovedItems, name)\n    except AttributeError:\n        try:\n            del moves.__dict__[name]\n        except KeyError:\n            raise AttributeError(\"no such move, %r\" % (name,))\n\n\nif PY3:\n    _meth_func = \"__func__\"\n    _meth_self = \"__self__\"\n\n    _func_closure = \"__closure__\"\n    _func_code = \"__code__\"\n    _func_defaults = \"__defaults__\"\n    _func_globals = \"__globals__\"\nelse:\n    _meth_func = \"im_func\"\n    _meth_self = \"im_self\"\n\n    _func_closure = \"func_closure\"\n    _func_code = \"func_code\"\n    _func_defaults = \"func_defaults\"\n    _func_globals = \"func_globals\"\n\n\ntry:\n    advance_iterator = next\nexcept NameError:\n    def advance_iterator(it):\n        return it.next()\nnext = advance_iterator\n\n\ntry:\n    callable = callable\nexcept NameError:\n    def callable(obj):\n        return any(\"__call__\" in klass.__dict__ for klass in type(obj).__mro__)\n\n\nif PY3:\n    def get_unbound_function(unbound):\n        return unbound\n\n    create_bound_method = types.MethodType\n\n    def create_unbound_method(func, cls):\n        return func\n\n    Iterator = object\nelse:\n    def get_unbound_function(unbound):\n        return unbound.im_func\n\n    def create_bound_method(func, obj):\n        return types.MethodType(func, obj, obj.__class__)\n\n    def create_unbound_method(func, cls):\n        return types.MethodType(func, None, cls)\n\n    class Iterator(object):\n\n        def next(self):\n            return type(self).__next__(self)\n\n    callable = callable\n_add_doc(get_unbound_function,\n         \"\"\"Get the function out of a possibly unbound function\"\"\")\n\n\nget_method_function = operator.attrgetter(_meth_func)\nget_method_self = operator.attrgetter(_meth_self)\nget_function_closure = operator.attrgetter(_func_closure)\nget_function_code = operator.attrgetter(_func_code)\nget_function_defaults = operator.attrgetter(_func_defaults)\nget_function_globals = operator.attrgetter(_func_globals)\n\n\nif PY3:\n    def iterkeys(d, **kw):\n        return iter(d.keys(**kw))\n\n    def itervalues(d, **kw):\n        return iter(d.values(**kw))\n\n    def iteritems(d, **kw):\n        return iter(d.items(**kw))\n\n    def iterlists(d, **kw):\n        return iter(d.lists(**kw))\n\n    viewkeys = operator.methodcaller(\"keys\")\n\n    viewvalues = operator.methodcaller(\"values\")\n\n    viewitems = operator.methodcaller(\"items\")\nelse:\n    def iterkeys(d, **kw):\n        return d.iterkeys(**kw)\n\n    def itervalues(d, **kw):\n        return d.itervalues(**kw)\n\n    def iteritems(d, **kw):\n        return d.iteritems(**kw)\n\n    def iterlists(d, **kw):\n        return d.iterlists(**kw)\n\n    viewkeys = operator.methodcaller(\"viewkeys\")\n\n    viewvalues = operator.methodcaller(\"viewvalues\")\n\n    viewitems = operator.methodcaller(\"viewitems\")\n\n_add_doc(iterkeys, \"Return an iterator over the keys of a dictionary.\")\n_add_doc(itervalues, \"Return an iterator over the values of a dictionary.\")\n_add_doc(iteritems,\n         \"Return an iterator over the (key, value) pairs of a dictionary.\")\n_add_doc(iterlists,\n         \"Return an iterator over the (key, [values]) pairs of a dictionary.\")\n\n\nif PY3:\n    def b(s):\n        return s.encode(\"latin-1\")\n\n    def u(s):\n        return s\n    unichr = chr\n    import struct\n    int2byte = struct.Struct(\">B\").pack\n    del struct\n    byte2int = operator.itemgetter(0)\n    indexbytes = operator.getitem\n    iterbytes = iter\n    import io\n    StringIO = io.StringIO\n    BytesIO = io.BytesIO\n    del io\n    _assertCountEqual = \"assertCountEqual\"\n    if sys.version_info[1] <= 1:\n        _assertRaisesRegex = \"assertRaisesRegexp\"\n        _assertRegex = \"assertRegexpMatches\"\n        _assertNotRegex = \"assertNotRegexpMatches\"\n    else:\n        _assertRaisesRegex = \"assertRaisesRegex\"\n        _assertRegex = \"assertRegex\"\n        _assertNotRegex = \"assertNotRegex\"\nelse:\n    def b(s):\n        return s\n    # Workaround for standalone backslash\n\n    def u(s):\n        return unicode(s.replace(r'\\\\', r'\\\\\\\\'), \"unicode_escape\")\n    unichr = unichr\n    int2byte = chr\n\n    def byte2int(bs):\n        return ord(bs[0])\n\n    def indexbytes(buf, i):\n        return ord(buf[i])\n    iterbytes = functools.partial(itertools.imap, ord)\n    import StringIO\n    StringIO = BytesIO = StringIO.StringIO\n    _assertCountEqual = \"assertItemsEqual\"\n    _assertRaisesRegex = \"assertRaisesRegexp\"\n    _assertRegex = \"assertRegexpMatches\"\n    _assertNotRegex = \"assertNotRegexpMatches\"\n_add_doc(b, \"\"\"Byte literal\"\"\")\n_add_doc(u, \"\"\"Text literal\"\"\")\n\n\ndef assertCountEqual(self, *args, **kwargs):\n    return getattr(self, _assertCountEqual)(*args, **kwargs)\n\n\ndef assertRaisesRegex(self, *args, **kwargs):\n    return getattr(self, _assertRaisesRegex)(*args, **kwargs)\n\n\ndef assertRegex(self, *args, **kwargs):\n    return getattr(self, _assertRegex)(*args, **kwargs)\n\n\ndef assertNotRegex(self, *args, **kwargs):\n    return getattr(self, _assertNotRegex)(*args, **kwargs)\n\n\nif PY3:\n    exec_ = getattr(moves.builtins, \"exec\")\n\n    def reraise(tp, value, tb=None):\n        try:\n            if value is None:\n                value = tp()\n            if value.__traceback__ is not tb:\n                raise value.with_traceback(tb)\n            raise value\n        finally:\n            value = None\n            tb = None\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    try:\n        raise tp, value, tb\n    finally:\n        tb = None\n\"\"\")\n\n\nif sys.version_info[:2] > (3,):\n    exec_(\"\"\"def raise_from(value, from_value):\n    try:\n        raise value from from_value\n    finally:\n        value = None\n\"\"\")\nelse:\n    def raise_from(value, from_value):\n        raise value\n\n\nprint_ = getattr(moves.builtins, \"print\", None)\nif print_ is None:\n    def print_(*args, **kwargs):\n        \"\"\"The new-style print function for Python 2.4 and 2.5.\"\"\"\n        fp = kwargs.pop(\"file\", sys.stdout)\n        if fp is None:\n            return\n\n        def write(data):\n            if not isinstance(data, basestring):\n                data = str(data)\n            # If the file has an encoding, encode unicode with it.\n            if (isinstance(fp, file) and\n                    isinstance(data, unicode) and\n                    fp.encoding is not None):\n                errors = getattr(fp, \"errors\", None)\n                if errors is None:\n                    errors = \"strict\"\n                data = data.encode(fp.encoding, errors)\n            fp.write(data)\n        want_unicode = False\n        sep = kwargs.pop(\"sep\", None)\n        if sep is not None:\n            if isinstance(sep, unicode):\n                want_unicode = True\n            elif not isinstance(sep, str):\n                raise TypeError(\"sep must be None or a string\")\n        end = kwargs.pop(\"end\", None)\n        if end is not None:\n            if isinstance(end, unicode):\n                want_unicode = True\n            elif not isinstance(end, str):\n                raise TypeError(\"end must be None or a string\")\n        if kwargs:\n            raise TypeError(\"invalid keyword arguments to print()\")\n        if not want_unicode:\n            for arg in args:\n                if isinstance(arg, unicode):\n                    want_unicode = True\n                    break\n        if want_unicode:\n            newline = unicode(\"\\n\")\n            space = unicode(\" \")\n        else:\n            newline = \"\\n\"\n            space = \" \"\n        if sep is None:\n            sep = space\n        if end is None:\n            end = newline\n        for i, arg in enumerate(args):\n            if i:\n                write(sep)\n            write(arg)\n        write(end)\nif sys.version_info[:2] < (3, 3):\n    _print = print_\n\n    def print_(*args, **kwargs):\n        fp = kwargs.get(\"file\", sys.stdout)\n        flush = kwargs.pop(\"flush\", False)\n        _print(*args, **kwargs)\n        if flush and fp is not None:\n            fp.flush()\n\n_add_doc(reraise, \"\"\"Reraise an exception.\"\"\")\n\nif sys.version_info[0:2] < (3, 4):\n    # This does exactly the same what the :func:`py3:functools.update_wrapper`\n    # function does on Python versions after 3.2. It sets the ``__wrapped__``\n    # attribute on ``wrapper`` object and it doesn't raise an error if any of\n    # the attributes mentioned in ``assigned`` and ``updated`` are missing on\n    # ``wrapped`` object.\n    def _update_wrapper(wrapper, wrapped,\n                        assigned=functools.WRAPPER_ASSIGNMENTS,\n                        updated=functools.WRAPPER_UPDATES):\n        for attr in assigned:\n            try:\n                value = getattr(wrapped, attr)\n            except AttributeError:\n                continue\n            else:\n                setattr(wrapper, attr, value)\n        for attr in updated:\n            getattr(wrapper, attr).update(getattr(wrapped, attr, {}))\n        wrapper.__wrapped__ = wrapped\n        return wrapper\n    _update_wrapper.__doc__ = functools.update_wrapper.__doc__\n\n    def wraps(wrapped, assigned=functools.WRAPPER_ASSIGNMENTS,\n              updated=functools.WRAPPER_UPDATES):\n        return functools.partial(_update_wrapper, wrapped=wrapped,\n                                 assigned=assigned, updated=updated)\n    wraps.__doc__ = functools.wraps.__doc__\n\nelse:\n    wraps = functools.wraps\n\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    # This requires a bit of explanation: the basic idea is to make a dummy\n    # metaclass for one level of class instantiation that replaces itself with\n    # the actual metaclass.\n    class metaclass(type):\n\n        def __new__(cls, name, this_bases, d):\n            if sys.version_info[:2] >= (3, 7):\n                # This version introduced PEP 560 that requires a bit\n                # of extra care (we mimic what is done by __build_class__).\n                resolved_bases = types.resolve_bases(bases)\n                if resolved_bases is not bases:\n                    d['__orig_bases__'] = bases\n            else:\n                resolved_bases = bases\n            return meta(name, resolved_bases, d)\n\n        @classmethod\n        def __prepare__(cls, name, this_bases):\n            return meta.__prepare__(name, bases)\n    return type.__new__(metaclass, 'temporary_class', (), {})\n\n\ndef add_metaclass(metaclass):\n    \"\"\"Class decorator for creating a class with a metaclass.\"\"\"\n    def wrapper(cls):\n        orig_vars = cls.__dict__.copy()\n        slots = orig_vars.get('__slots__')\n        if slots is not None:\n            if isinstance(slots, str):\n                slots = [slots]\n            for slots_var in slots:\n                orig_vars.pop(slots_var)\n        orig_vars.pop('__dict__', None)\n        orig_vars.pop('__weakref__', None)\n        if hasattr(cls, '__qualname__'):\n            orig_vars['__qualname__'] = cls.__qualname__\n        return metaclass(cls.__name__, cls.__bases__, orig_vars)\n    return wrapper\n\n\ndef ensure_binary(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce **s** to six.binary_type.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> encoded to `bytes`\n      - `bytes` -> `bytes`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s\n    if isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    raise TypeError(\"not expecting type '%s'\" % type(s))\n\n\ndef ensure_str(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to `str`.\n\n    For Python 2:\n      - `unicode` -> encoded to `str`\n      - `str` -> `str`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    # Optimization: Fast return for the common case.\n    if type(s) is str:\n        return s\n    if PY2 and isinstance(s, text_type):\n        return s.encode(encoding, errors)\n    elif PY3 and isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif not isinstance(s, (text_type, binary_type)):\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n    return s\n\n\ndef ensure_text(s, encoding='utf-8', errors='strict'):\n    \"\"\"Coerce *s* to six.text_type.\n\n    For Python 2:\n      - `unicode` -> `unicode`\n      - `str` -> `unicode`\n\n    For Python 3:\n      - `str` -> `str`\n      - `bytes` -> decoded to `str`\n    \"\"\"\n    if isinstance(s, binary_type):\n        return s.decode(encoding, errors)\n    elif isinstance(s, text_type):\n        return s\n    else:\n        raise TypeError(\"not expecting type '%s'\" % type(s))\n\n\ndef python_2_unicode_compatible(klass):\n    \"\"\"\n    A class decorator that defines __unicode__ and __str__ methods under Python 2.\n    Under Python 3 it does nothing.\n\n    To support Python 2 and 3 with a single code base, define a __str__ method\n    returning text and apply this decorator to the class.\n    \"\"\"\n    if PY2:\n        if '__str__' not in klass.__dict__:\n            raise ValueError(\"@python_2_unicode_compatible cannot be applied \"\n                             \"to %s because it doesn't define __str__().\" %\n                             klass.__name__)\n        klass.__unicode__ = klass.__str__\n        klass.__str__ = lambda self: self.__unicode__().encode('utf-8')\n    return klass\n\n\n# Complete the moves implementation.\n# This code is at the end of this module to speed up module loading.\n# Turn this module into a package.\n__path__ = []  # required for PEP 302 and PEP 451\n__package__ = __name__  # see PEP 366 @ReservedAssignment\nif globals().get(\"__spec__\") is not None:\n    __spec__.submodule_search_locations = []  # PEP 451 @UndefinedVariable\n# Remove other six meta path importers, since they cause problems. This can\n# happen if six is removed from sys.modules and then reloaded. (Setuptools does\n# this for some reason.)\nif sys.meta_path:\n    for i, importer in enumerate(sys.meta_path):\n        # Here's some real nastiness: Another \"instance\" of the six module might\n        # be floating around. Therefore, we can't use isinstance() to check for\n        # the six meta path importer, since the other six instance will have\n        # inserted an importer with different class.\n        if (type(importer).__name__ == \"_SixMetaPathImporter\" and\n                importer.name == __name__):\n            del sys.meta_path[i]\n            break\n    del i, importer\n# Finally, add the importer to the meta path import hook.\nsys.meta_path.append(_importer)\n", "documentation/conf.py": "# -*- coding: utf-8 -*-\n#\n# six documentation build configuration file\n\nimport os\nimport sys\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.append(os.path.abspath('.'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \"1.0\"\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\"sphinx.ext.intersphinx\"]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n#source_encoding = \"utf-8-sig\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = u\"six\"\ncopyright = u\"2010-2020, Benjamin Peterson\"\n\nsys.path.append(os.path.abspath(os.path.join(\".\", \"..\")))\nfrom six import __version__ as six_version\nsys.path.pop()\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = six_version[:-2]\n# The full version, including alpha/beta/rc tags.\nrelease = six_version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"default\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = ''\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'sixdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  (\"index\", \"six.tex\", u\"six Documentation\",\n   u\"Benjamin Peterson\", \"manual\"),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\"index\", \"six\", u\"six Documentation\",\n     [u\"Benjamin Peterson\"], 1)\n]\n\n# -- Intersphinx ---------------------------------------------------------------\n\nintersphinx_mapping = {\"py2\" : (\"https://docs.python.org/2/\", None),\n                       \"py3\" : (\"https://docs.python.org/3/\", None)}\n"}