{"noxfile.py": "from pathlib import Path\nfrom tempfile import TemporaryDirectory\nimport os\n\nimport nox\n\nROOT = Path(__file__).parent\nTESTS = ROOT / \"tests\"\nPYPROJECT = ROOT / \"pyproject.toml\"\nDOCS = ROOT / \"docs\"\n\nREQUIREMENTS = dict(\n    docs=DOCS / \"requirements.txt\",\n    tests=TESTS / \"requirements.txt\",\n)\nREQUIREMENTS_IN = [  # this is actually ordered, as files depend on each other\n    path.parent / f\"{path.stem}.in\" for path in REQUIREMENTS.values()\n]\n\nSUPPORTED = [\"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\", \"pypy3.10\"]\nLATEST = \"3.12\"\n\nnox.options.sessions = []\n\n\ndef session(default=True, python=LATEST, **kwargs):  # noqa: D103\n    def _session(fn):\n        if default:\n            nox.options.sessions.append(kwargs.get(\"name\", fn.__name__))\n        return nox.session(python=python, **kwargs)(fn)\n\n    return _session\n\n\n@session(python=SUPPORTED)\ndef tests(session):\n    \"\"\"\n    Run the test suite with a corresponding Python version.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"tests\"])\n\n    if session.posargs and session.posargs[0] == \"coverage\":\n        if len(session.posargs) > 1 and session.posargs[1] == \"github\":\n            github = Path(os.environ[\"GITHUB_STEP_SUMMARY\"])\n        else:\n            github = None\n\n        session.install(\"coverage[toml]\")\n        session.run(\"coverage\", \"run\", \"-m\", \"pytest\", TESTS)\n        if github is None:\n            session.run(\"coverage\", \"report\")\n        else:\n            with github.open(\"a\") as summary:\n                summary.write(\"### Coverage\\n\\n\")\n                summary.flush()  # without a flush, output seems out of order.\n                session.run(\n                    \"coverage\",\n                    \"report\",\n                    \"--format=markdown\",\n                    stdout=summary,\n                )\n    else:\n        session.run(\"pytest\", *session.posargs, TESTS)\n\n\n@session()\ndef audit(session):\n    \"\"\"\n    Audit dependencies for vulnerabilities.\n    \"\"\"\n    session.install(\"pip-audit\", ROOT)\n    session.run(\"python\", \"-m\", \"pip_audit\")\n\n\n@session(tags=[\"build\"])\ndef build(session):\n    \"\"\"\n    Build a distribution suitable for PyPI and check its validity.\n    \"\"\"\n    session.install(\"build\", \"twine\")\n    with TemporaryDirectory() as tmpdir:\n        session.run(\"python\", \"-m\", \"build\", ROOT, \"--outdir\", tmpdir)\n        session.run(\"twine\", \"check\", \"--strict\", tmpdir + \"/*\")\n\n\n@session(tags=[\"style\"])\ndef style(session):\n    \"\"\"\n    Check Python code style.\n    \"\"\"\n    session.install(\"ruff\")\n    session.run(\"ruff\", \"check\", ROOT)\n\n\n@session(tags=[\"docs\"])\n@nox.parametrize(\n    \"builder\",\n    [\n        nox.param(name, id=name)\n        for name in [\n            \"dirhtml\",\n            \"doctest\",\n            \"linkcheck\",\n            \"man\",\n            \"spelling\",\n        ]\n    ],\n)\ndef docs(session, builder):\n    \"\"\"\n    Build the documentation using a specific Sphinx builder.\n    \"\"\"\n    session.install(\"-r\", REQUIREMENTS[\"docs\"])\n    with TemporaryDirectory() as tmpdir_str:\n        tmpdir = Path(tmpdir_str)\n        argv = [\"-n\", \"-T\", \"-W\"]\n        if builder != \"spelling\":\n            argv += [\"-q\"]\n        posargs = session.posargs or [tmpdir / builder]\n        session.run(\n            \"python\",\n            \"-m\",\n            \"sphinx\",\n            \"-b\",\n            builder,\n            DOCS,\n            *argv,\n            *posargs,\n        )\n\n\n@session(tags=[\"docs\", \"style\"], name=\"docs(style)\")\ndef docs_style(session):\n    \"\"\"\n    Check the documentation style.\n    \"\"\"\n    session.install(\n        \"doc8\",\n        \"pygments\",\n        \"pygments-github-lexers\",\n    )\n    session.run(\"python\", \"-m\", \"doc8\", \"--config\", PYPROJECT, DOCS)\n\n\n@session(default=False)\ndef requirements(session):\n    \"\"\"\n    Update the project's pinned requirements. Commit the result.\n    \"\"\"\n    session.install(\"pip-tools\")\n    for each in REQUIREMENTS_IN:\n        session.run(\n            \"pip-compile\",\n            \"--resolver\",\n            \"backtracking\",\n            \"--strip-extras\",\n            \"-U\",\n            each.relative_to(ROOT),\n        )\n", "docs/conf.py": "import importlib.metadata\nimport re\n\nfrom url import URL\n\nGITHUB = URL.parse(\"https://github.com/\")\nHOMEPAGE = GITHUB / \"crate-py/rpds\"\n\nproject = \"rpds.py\"\nauthor = \"Julian Berman\"\ncopyright = f\"2023, {author}\"\n\nrelease = importlib.metadata.version(\"rpds.py\")\nversion = release.partition(\"-\")[0]\n\nlanguage = \"en\"\ndefault_role = \"any\"\n\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.napoleon\",\n    \"sphinx.ext.todo\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx_copybutton\",\n    \"sphinxcontrib.spelling\",\n    \"sphinxext.opengraph\",\n]\n\npygments_style = \"lovelace\"\npygments_dark_style = \"one-dark\"\n\nhtml_theme = \"furo\"\n\n\ndef entire_domain(host):\n    return r\"http.?://\" + re.escape(host) + r\"($|/.*)\"\n\n\nlinkcheck_ignore = [\n    entire_domain(\"img.shields.io\"),\n    f\"{GITHUB}.*#.*\",\n    str(HOMEPAGE / \"actions\"),\n    str(HOMEPAGE / \"workflows/CI/badge.svg\"),\n]\n\n# = Extensions =\n\n# -- autodoc --\n\nautodoc_default_options = {\n    \"members\": True,\n    \"member-order\": \"bysource\",\n}\n\n# -- autosectionlabel --\n\nautosectionlabel_prefix_document = True\n\n# -- intersphinx --\n\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/\", None),\n}\n\n# -- extlinks --\n\nextlinks = {\n    \"gh\": (str(HOMEPAGE) + \"/%s\", None),\n    \"github\": (str(GITHUB) + \"/%s\", None),\n}\nextlinks_detect_hardcoded_links = True\n\n# -- sphinx-copybutton --\n\ncopybutton_prompt_text = r\">>> |\\.\\.\\. |\\$\"\ncopybutton_prompt_is_regexp = True\n\n# -- sphinxcontrib-spelling --\n\nspelling_word_list_filename = \"spelling-wordlist.txt\"\nspelling_show_suggestions = True\n", "tests/test_hash_trie_map.py": "\"\"\"\nModified from the pyrsistent test suite.\n\nPre-modification, these were MIT licensed, and are copyright:\n\n    Copyright (c) 2022 Tobias Gustafsson\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\n\nfrom collections import abc\nfrom operator import methodcaller\nimport pickle\n\nimport pytest\n\nfrom rpds import HashTrieMap\n\nHASH_MSG = \"Not sure HashTrieMap implements Hash, it has mutable methods\"\n\n\n@pytest.mark.xfail(reason=HASH_MSG)\ndef test_instance_of_hashable():\n    assert isinstance(HashTrieMap(), abc.Hashable)\n\n\ndef test_instance_of_map():\n    assert isinstance(HashTrieMap(), abc.Mapping)\n\n\ndef test_literalish_works():\n    assert HashTrieMap() == HashTrieMap()\n    assert HashTrieMap(a=1, b=2) == HashTrieMap({\"a\": 1, \"b\": 2})\n\n\ndef test_empty_initialization():\n    a_map = HashTrieMap()\n    assert len(a_map) == 0\n\n\ndef test_initialization_with_one_element():\n    the_map = HashTrieMap({\"a\": 2})\n    assert len(the_map) == 1\n    assert the_map[\"a\"] == 2\n    assert \"a\" in the_map\n\n    empty_map = the_map.remove(\"a\")\n    assert len(empty_map) == 0\n    assert \"a\" not in empty_map\n\n\ndef test_index_non_existing_raises_key_error():\n    m1 = HashTrieMap()\n    with pytest.raises(KeyError) as error:\n        m1[\"foo\"]\n\n    assert str(error.value) == \"'foo'\"\n\n\ndef test_remove_non_existing_element_raises_key_error():\n    m1 = HashTrieMap(a=1)\n\n    with pytest.raises(KeyError) as error:\n        m1.remove(\"b\")\n\n    assert str(error.value) == \"'b'\"\n\n\ndef test_various_iterations():\n    assert {\"a\", \"b\"} == set(HashTrieMap(a=1, b=2))\n    assert [\"a\", \"b\"] == sorted(HashTrieMap(a=1, b=2).keys())\n    assert [1, 2] == sorted(HashTrieMap(a=1, b=2).values())\n    assert {(\"a\", 1), (\"b\", 2)} == set(HashTrieMap(a=1, b=2).items())\n\n    pm = HashTrieMap({k: k for k in range(100)})\n    assert len(pm) == len(pm.keys())\n    assert len(pm) == len(pm.values())\n    assert len(pm) == len(pm.items())\n    ks = pm.keys()\n    assert all(k in pm for k in ks)\n    assert all(k in ks for k in ks)\n    us = pm.items()\n    assert all(pm[k] == v for (k, v) in us)\n    vs = pm.values()\n    assert all(v in vs for v in vs)\n\n\ndef test_initialization_with_two_elements():\n    map1 = HashTrieMap({\"a\": 2, \"b\": 3})\n    assert len(map1) == 2\n    assert map1[\"a\"] == 2\n    assert map1[\"b\"] == 3\n\n    map2 = map1.remove(\"a\")\n    assert \"a\" not in map2\n    assert map2[\"b\"] == 3\n\n\ndef test_initialization_with_many_elements():\n    init_dict = {str(x): x for x in range(1700)}\n    the_map = HashTrieMap(init_dict)\n\n    assert len(the_map) == 1700\n    assert the_map[\"16\"] == 16\n    assert the_map[\"1699\"] == 1699\n    assert the_map.insert(\"256\", 256) == the_map\n\n    new_map = the_map.remove(\"1600\")\n    assert len(new_map) == 1699\n    assert \"1600\" not in new_map\n    assert new_map[\"1601\"] == 1601\n\n    # Some NOP properties\n    assert new_map.discard(\"18888\") == new_map\n    assert \"19999\" not in new_map\n    assert new_map[\"1500\"] == 1500\n    assert new_map.insert(\"1500\", new_map[\"1500\"]) == new_map\n\n\ndef test_access_non_existing_element():\n    map1 = HashTrieMap()\n    assert len(map1) == 0\n\n    map2 = map1.insert(\"1\", 1)\n    assert \"1\" not in map1\n    assert map2[\"1\"] == 1\n    assert \"2\" not in map2\n\n\ndef test_overwrite_existing_element():\n    map1 = HashTrieMap({\"a\": 2})\n    map2 = map1.insert(\"a\", 3)\n\n    assert len(map2) == 1\n    assert map2[\"a\"] == 3\n\n\n@pytest.mark.xfail(reason=HASH_MSG)\ndef test_hash():\n    x = HashTrieMap(a=1, b=2, c=3)\n    y = HashTrieMap(a=1, b=2, c=3)\n\n    assert hash(x) == hash(y)\n\n\ndef test_same_hash_when_content_the_same_but_underlying_vector_size_differs():\n    x = HashTrieMap({x: x for x in range(1000)})\n    y = HashTrieMap({10: 10, 200: 200, 700: 700})\n\n    for z in x:\n        if z not in y:\n            x = x.remove(z)\n\n    assert x == y\n    # assert hash(x) == hash(y)  # noqa: ERA001\n\n\nclass HashabilityControlled:\n    hashable = True\n\n    def __hash__(self):\n        if self.hashable:\n            return 4  # Proven random\n        raise ValueError(\"I am not currently hashable.\")\n\n\n@pytest.mark.xfail(reason=HASH_MSG)\ndef test_map_does_not_hash_values_on_second_hash_invocation():\n    hashable = HashabilityControlled()\n    x = HashTrieMap(dict(el=hashable))\n    hash(x)\n    hashable.hashable = False\n    hash(x)\n\n\ndef test_equal():\n    x = HashTrieMap(a=1, b=2, c=3)\n    y = HashTrieMap(a=1, b=2, c=3)\n\n    assert x == y\n    assert not (x != y)\n\n    assert y == x\n    assert not (y != x)\n\n\ndef test_equal_with_different_insertion_order():\n    x = HashTrieMap([(i, i) for i in range(50)])\n    y = HashTrieMap([(i, i) for i in range(49, -1, -1)])\n\n    assert x == y\n    assert not (x != y)\n\n    assert y == x\n    assert not (y != x)\n\n\ndef test_not_equal():\n    x = HashTrieMap(a=1, b=2, c=3)\n    y = HashTrieMap(a=1, b=2)\n\n    assert x != y\n    assert not (x == y)\n\n    assert y != x\n    assert not (y == x)\n\n\ndef test_not_equal_to_dict():\n    x = HashTrieMap(a=1, b=2, c=3)\n    y = dict(a=1, b=2, d=4)\n\n    assert x != y\n    assert not (x == y)\n\n    assert y != x\n    assert not (y == x)\n\n\ndef test_update_with_multiple_arguments():\n    # If same value is present in multiple sources, the rightmost is used.\n    x = HashTrieMap(a=1, b=2, c=3)\n    y = x.update(HashTrieMap(b=4, c=5), {\"c\": 6})\n\n    assert y == HashTrieMap(a=1, b=4, c=6)\n\n\ndef test_update_one_argument():\n    x = HashTrieMap(a=1)\n\n    assert x.update({\"b\": 2}) == HashTrieMap(a=1, b=2)\n\n\ndef test_update_no_arguments():\n    x = HashTrieMap(a=1)\n\n    assert x.update() == x\n\n\nclass HashDummy:\n    def __hash__(self):\n        return 6528039219058920  # Hash of '33'\n\n    def __eq__(self, other):\n        return self is other\n\n\ndef test_iteration_with_many_elements():\n    values = list(range(2000))\n    keys = [str(x) for x in values]\n    init_dict = dict(zip(keys, values))\n\n    hash_dummy1 = HashDummy()\n    hash_dummy2 = HashDummy()\n\n    # Throw in a couple of hash collision nodes to tests\n    # those properly as well\n    init_dict[hash_dummy1] = 12345\n    init_dict[hash_dummy2] = 54321\n    a_map = HashTrieMap(init_dict)\n\n    actual_values = set()\n    actual_keys = set()\n\n    for k, v in a_map.items():\n        actual_values.add(v)\n        actual_keys.add(k)\n\n    assert actual_keys == {*keys, hash_dummy1, hash_dummy2}\n    assert actual_values == {*values, 12345, 54321}\n\n\ndef test_repr():\n    rep = repr(HashTrieMap({\"foo\": \"12\", \"\": 37}))\n    assert rep in {\n        \"HashTrieMap({'foo': '12', '': 37})\",\n        \"HashTrieMap({'': 37, 'foo': '12'})\",\n    }\n\n\ndef test_str():\n    s = str(HashTrieMap({1: 2, 3: 4}))\n    assert s == \"HashTrieMap({1: 2, 3: 4})\" or s == \"HashTrieMap({3: 4, 1: 2})\"\n\n\ndef test_empty_truthiness():\n    assert HashTrieMap(a=1)\n    assert not HashTrieMap()\n\n\ndef test_iterable():\n    m = HashTrieMap((i, i * 2) for i in range(3))\n    assert m == HashTrieMap({0: 0, 1: 2, 2: 4})\n\n\ndef test_convert_hashtriemap():\n    m = HashTrieMap({i: i * 2 for i in range(3)})\n    assert HashTrieMap.convert({i: i * 2 for i in range(3)}) == m\n\n\ndef test_fast_convert_hashtriemap():\n    m = HashTrieMap({i: i * 2 for i in range(3)})\n    assert HashTrieMap.convert(m) is m\n\n\n# Non-pyrsistent-test-suite tests\n\n\ndef test_more_eq():\n    o = object()\n\n    assert HashTrieMap([(o, o), (1, o)]) == HashTrieMap([(o, o), (1, o)])\n    assert HashTrieMap([(o, \"foo\")]) == HashTrieMap([(o, \"foo\")])\n    assert HashTrieMap() == HashTrieMap([])\n\n    assert HashTrieMap({1: 2}) != HashTrieMap({1: 3})\n    assert HashTrieMap({o: 1}) != HashTrieMap({o: o})\n    assert HashTrieMap([]) != HashTrieMap([(o, 1)])\n\n\ndef test_pickle():\n    assert pickle.loads(\n        pickle.dumps(HashTrieMap([(1, 2), (3, 4)])),\n    ) == HashTrieMap([(1, 2), (3, 4)])\n\n\ndef test_get():\n    m1 = HashTrieMap({\"foo\": \"bar\"})\n    assert m1.get(\"foo\") == \"bar\"\n    assert m1.get(\"baz\") is None\n    assert m1.get(\"spam\", \"eggs\") == \"eggs\"\n\n\n@pytest.mark.parametrize(\n    \"view\",\n    [pytest.param(methodcaller(p), id=p) for p in [\"keys\", \"values\", \"items\"]],\n)\n@pytest.mark.parametrize(\n    \"cls\",\n    [\n        abc.Set,\n        abc.MappingView,\n        abc.KeysView,\n        abc.ValuesView,\n        abc.ItemsView,\n    ],\n)\ndef test_views_abc(view, cls):\n    m, d = HashTrieMap(), {}\n    assert isinstance(view(m), cls) == isinstance(view(d), cls)\n\n\ndef test_keys():\n    d = HashTrieMap({1: 2, 3: 4})\n    k = d.keys()\n\n    assert 1 in k\n    assert 2 not in k\n    assert object() not in k\n\n    assert len(k) == 2\n\n    assert k == d.keys()\n    assert k == HashTrieMap({1: 2, 3: 4}).keys()\n    assert k == {1, 3}\n\n    assert k != iter({1, 3})\n    assert k != {1, 2, 3}\n    assert k != {1, 4}\n    assert not k == {1, 4}\n\n    assert k != object()\n\n\ndef test_keys_setlike():\n    assert {1: 2, 3: 4}.keys() & HashTrieMap({1: 2}).keys() == {1}\n    assert {1: 2, 3: 4}.keys() & HashTrieMap({1: 2}).keys() != {1, 2}\n    assert HashTrieMap({1: 2}).keys() & {1: 2, 3: 4}.keys() == {1}\n    assert HashTrieMap({1: 2}).keys() & {1: 2, 3: 4}.keys() != {2}\n    assert not HashTrieMap({1: 2}).keys() & {}.keys()\n    assert HashTrieMap({1: 2}).keys() & {1} == {1}\n    assert HashTrieMap({1: 2}).keys() & [1] == {1}\n\n    assert HashTrieMap({1: 2}).keys() | {3} == {1, 3}\n    assert HashTrieMap({1: 2}).keys() | [3] == {1, 3}\n\n    # these don't really exist on the KeysView protocol but it's nice to have\n    s = (1, \"foo\")\n    assert HashTrieMap({1: 2, \"foo\": 7}).keys().intersection(s) == set(s)\n    assert not HashTrieMap({1: 2}).keys().intersection({})\n    assert HashTrieMap({1: 2}).keys().union({3}) == {1, 3}\n\n    assert HashTrieMap({1: 2, 3: 4}).keys() < {1, 2, 3}\n    assert HashTrieMap({1: 2, 3: 4}).keys() <= {1, 2, 3}\n    assert not HashTrieMap({1: 2}).keys() < {1}\n    assert HashTrieMap({1: 2}).keys() > set()\n    assert HashTrieMap({1: 2}).keys() >= set()\n\n\ndef test_keys_repr():\n    m = HashTrieMap({\"foo\": 3, 37: \"bar\"})\n    assert repr(m.keys()) in {\n        \"keys_view({'foo', 37})\",\n        \"keys_view({37, 'foo'})\",\n    }\n\n\ndef test_values():\n    d = HashTrieMap({1: 2, 3: 4})\n    v = d.values()\n\n    assert 2 in v\n    assert 3 not in v\n    assert object() not in v\n\n    assert len(v) == 2\n\n    assert v == v\n    # https://bugs.python.org/issue12445 which was WONTFIXed\n    assert v != HashTrieMap({1: 2, 3: 4}).values()\n    assert v != [2, 4]\n\n    assert set(v) == {2, 4}\n\n\ndef test_values_repr():\n    m = HashTrieMap({\"foo\": 3, 37: \"bar\", \"baz\": 3})\n    assert repr(m.values()) in {\n        \"values_view(['bar', 3, 3])\",\n        \"values_view([3, 'bar', 3])\",\n        \"values_view([3, 3, 'bar'])\",\n    }\n\n\ndef test_items():\n    d = HashTrieMap({1: 2, 3: 4})\n    i = d.items()\n\n    assert (1, 2) in i\n    assert (1, 4) not in i\n\n    assert len(i) == 2\n\n    assert i == d.items()\n    assert i == HashTrieMap({1: 2, 3: 4}).items()\n    assert i == {(1, 2), (3, 4)}\n\n    assert i != iter({(1, 2), (3, 4)})\n    assert i != {(1, 2, 3), (3, 4, 5)}\n    assert i == {1: 2, 3: 4}.items()\n    assert i != {(1, 2), (3, 4), (5, 6)}\n    assert i != {(1, 2)}\n    assert not i == {1, 4}\n\n    assert i != object()\n\n\ndef test_items_setlike():\n    assert {1: 2, 3: 4}.items() & HashTrieMap({1: 2}).items() == {(1, 2)}\n    assert {1: 2, 3: 4}.items() & HashTrieMap({1: 2}).items() != {(1, 2), 3}\n\n    assert HashTrieMap({1: 2}).items() & {1: 2, 3: 4}.items() == {(1, 2)}\n    assert HashTrieMap({1: 2}).items() & {1: 2, 3: 4}.items() != {(3, 4)}\n    assert not HashTrieMap({1: 2}).items() & {}.items()\n\n    assert HashTrieMap({1: 2}).items() & [(1, 2)] == {(1, 2)}\n    assert HashTrieMap({1: 2}).items() & [[1, 2]] == set()\n\n    assert HashTrieMap({1: 2}).items() | {(3, 4)} == {(1, 2), (3, 4)}\n    assert HashTrieMap({1: 2}).items() | [7] == {(1, 2), 7}\n\n    s = ((1, 2), (\"foo\", 37))\n    assert HashTrieMap({1: 2, \"foo\": 7}).items().intersection(s) == {(1, 2)}\n    assert not HashTrieMap({1: 2}).items().intersection({})\n\n    assert HashTrieMap({1: 2}).items().union({3}) == {(1, 2), 3}\n\n    assert HashTrieMap({1: 2, 3: 4}).items() < {(1, 2), (3, 4), (\"foo\", \"bar\")}\n    assert HashTrieMap({1: 2, 3: 4}).items() <= {(1, 2), (3, 4)}\n    assert not HashTrieMap({1: 2}).keys() < {1}\n    assert HashTrieMap({1: 2}).items() > set()\n    assert HashTrieMap({1: 2}).items() >= set()\n\n\ndef test_items_repr():\n    m = HashTrieMap({\"foo\": 3, 37: \"bar\", \"baz\": 3})\n    assert repr(m.items()) in {\n        \"items_view([('foo', 3), (37, 'bar'), ('baz', 3)])\",\n        \"items_view([('foo', 3), ('baz', 3), (37, 'bar')])\",\n        \"items_view([(37, 'bar'), ('foo', 3), ('baz', 3)])\",\n        \"items_view([(37, 'bar'), ('baz', 3), ('foo', 3)])\",\n        \"items_view([('baz', 3), (37, 'bar'), ('foo', 3)])\",\n        \"items_view([('baz', 3), ('foo', 3), (37, 'bar')])\",\n    }\n\n\ndef test_fromkeys():\n    keys = list(range(10))\n    got = HashTrieMap.fromkeys(keys)\n    expected = HashTrieMap((i, None) for i in keys)\n    assert got == HashTrieMap(dict.fromkeys(keys)) == expected\n\n\ndef test_fromkeys_explicit_value():\n    keys = list(range(10))\n    expected = HashTrieMap((i, \"foo\") for i in keys)\n    got = HashTrieMap.fromkeys(keys, \"foo\")\n    expected = HashTrieMap((i, \"foo\") for i in keys)\n    assert got == HashTrieMap(dict.fromkeys(keys, \"foo\")) == expected\n\n\ndef test_fromkeys_explicit_value_not_copied():\n    keys = list(range(5))\n\n    got = HashTrieMap.fromkeys(keys, [])\n    got[3].append(1)\n\n    assert got == HashTrieMap((i, [1]) for i in keys)\n\n\ndef test_update_with_iterable_of_kvs():\n    assert HashTrieMap({1: 2}).update(iter([(3, 4), (\"5\", 6)])) == HashTrieMap(\n        {\n            1: 2,\n            3: 4,\n            \"5\": 6,\n        },\n    )\n", "tests/test_list.py": "\"\"\"\nModified from the pyrsistent test suite.\n\nPre-modification, these were MIT licensed, and are copyright:\n\n    Copyright (c) 2022 Tobias Gustafsson\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\n\nimport pickle\n\nimport pytest\n\nfrom rpds import List\n\nHASH_MSG = \"Not sure List implements Hash, it has mutable methods\"\n\n\ndef test_literalish_works():\n    assert List(1, 2, 3) == List([1, 2, 3])\n\n\ndef test_first_and_rest():\n    pl = List([1, 2])\n    assert pl.first == 1\n    assert pl.rest.first == 2\n    assert pl.rest.rest == List()\n\n\ndef test_instantiate_large_list():\n    assert List(range(1000)).first == 0\n\n\ndef test_iteration():\n    assert list(List()) == []\n    assert list(List([1, 2, 3])) == [1, 2, 3]\n\n\ndef test_push_front():\n    assert List([1, 2, 3]).push_front(0) == List([0, 1, 2, 3])\n\n\ndef test_push_front_empty_list():\n    assert List().push_front(0) == List([0])\n\n\ndef test_truthiness():\n    assert List([1])\n    assert not List()\n\n\ndef test_len():\n    assert len(List([1, 2, 3])) == 3\n    assert len(List()) == 0\n\n\ndef test_first_illegal_on_empty_list():\n    with pytest.raises(IndexError):\n        List().first\n\n\ndef test_rest_return_self_on_empty_list():\n    assert List().rest == List()\n\n\ndef test_reverse():\n    assert reversed(List([1, 2, 3])) == List([3, 2, 1])\n\n    assert reversed(List()) == List()\n\n\ndef test_inequality():\n    assert List([1, 2]) != List([1, 3])\n    assert List([1, 2]) != List([1, 2, 3])\n    assert List() != List([1, 2, 3])\n\n\ndef test_repr():\n    assert str(List()) == \"List([])\"\n    assert str(List([1, 2, 3])) in \"List([1, 2, 3])\"\n\n\n@pytest.mark.xfail(reason=HASH_MSG)\ndef test_hashing():\n    assert hash(List([1, 2])) == hash(List([1, 2]))\n    assert hash(List([1, 2])) != hash(List([2, 1]))\n\n\ndef test_sequence():\n    m = List(\"asdf\")\n    assert m == List([\"a\", \"s\", \"d\", \"f\"])\n\n\n# Non-pyrsistent-test-suite tests\n\n\ndef test_drop_first():\n    assert List([1, 2, 3]).drop_first() == List([2, 3])\n\n\ndef test_drop_first_empty():\n    \"\"\"\n    rpds itself returns an Option<List> here but we try IndexError instead.\n    \"\"\"\n    with pytest.raises(IndexError):\n        List([]).drop_first()\n\n\ndef test_more_eq():\n    o = object()\n\n    assert List([o, o]) == List([o, o])\n    assert List([o]) == List([o])\n    assert List() == List([])\n    assert not (List([1, 2]) == List([1, 3]))\n    assert not (List([o]) == List([o, o]))\n    assert not (List([]) == List([o]))\n\n    assert List([1, 2]) != List([1, 3])\n    assert List([o]) != List([o, o])\n    assert List([]) != List([o])\n    assert not (List([o, o]) != List([o, o]))\n    assert not (List([o]) != List([o]))\n    assert not (List() != List([]))\n\n\ndef test_pickle():\n    assert pickle.loads(pickle.dumps(List([1, 2, 3, 4]))) == List([1, 2, 3, 4])\n", "tests/test_hash_trie_set.py": "\"\"\"\nModified from the pyrsistent test suite.\n\nPre-modification, these were MIT licensed, and are copyright:\n\n    Copyright (c) 2022 Tobias Gustafsson\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\n\nfrom collections import abc\nimport pickle\n\nimport pytest\n\nfrom rpds import HashTrieSet\n\nHASH_MSG = \"Not sure HashTrieSet implements Hash, it has mutable methods\"\n\n\ndef test_key_is_tuple():\n    with pytest.raises(KeyError):\n        HashTrieSet().remove((1, 1))\n\n\ndef test_key_is_not_tuple():\n    with pytest.raises(KeyError):\n        HashTrieSet().remove(\"asdf\")\n\n\n@pytest.mark.xfail(reason=HASH_MSG)\ndef test_supports_hash():\n    assert hash(HashTrieSet((1, 2))) == hash(HashTrieSet(1, 2))\n\n\ndef test_empty_truthiness():\n    assert HashTrieSet([1])\n    assert not HashTrieSet()\n\n\ndef test_contains_elements_that_it_was_initialized_with():\n    initial = [1, 2, 3]\n    s = HashTrieSet(initial)\n\n    assert set(s) == set(initial)\n    assert len(s) == len(set(initial))\n\n\ndef test_is_immutable():\n    s1 = HashTrieSet([1])\n    s2 = s1.insert(2)\n\n    assert s1 == HashTrieSet([1])\n    assert s2 == HashTrieSet([1, 2])\n\n    s3 = s2.remove(1)\n    assert s2 == HashTrieSet([1, 2])\n    assert s3 == HashTrieSet([2])\n\n\ndef test_remove_when_not_present():\n    s1 = HashTrieSet([1, 2, 3])\n    with pytest.raises(KeyError):\n        s1.remove(4)\n\n\ndef test_discard():\n    s1 = HashTrieSet((1, 2, 3))\n    assert s1.discard(3) == HashTrieSet((1, 2))\n    assert s1.discard(4) == s1\n\n\ndef test_is_iterable():\n    assert sum(HashTrieSet([1, 2, 3])) == 6\n\n\ndef test_contains():\n    s = HashTrieSet([1, 2, 3])\n\n    assert 2 in s\n    assert 4 not in s\n\n\ndef test_supports_set_operations():\n    s1 = HashTrieSet([1, 2, 3])\n    s2 = HashTrieSet([3, 4, 5])\n\n    assert s1 | s2 == HashTrieSet([1, 2, 3, 4, 5])\n    assert s1.union(s2) == s1 | s2\n\n    assert s1 & s2 == HashTrieSet([3])\n    assert s1.intersection(s2) == s1 & s2\n\n    assert s1 - s2 == HashTrieSet([1, 2])\n    assert s1.difference(s2) == s1 - s2\n\n    assert s1 ^ s2 == HashTrieSet([1, 2, 4, 5])\n    assert s1.symmetric_difference(s2) == s1 ^ s2\n\n\ndef test_supports_set_comparisons():\n    s1 = HashTrieSet([1, 2, 3])\n    s3 = HashTrieSet([1, 2])\n    s4 = HashTrieSet([1, 2, 3])\n\n    assert HashTrieSet([1, 2, 3, 3, 5]) == HashTrieSet([1, 2, 3, 5])\n    assert s1 != s3\n\n    assert s3 < s1\n    assert s3 <= s1\n    assert s3 <= s4\n\n    assert s1 > s3\n    assert s1 >= s3\n    assert s4 >= s3\n\n\ndef test_repr():\n    rep = repr(HashTrieSet([1, 2]))\n    assert rep == \"HashTrieSet({1, 2})\" or rep == \"HashTrieSet({2, 1})\"\n\n    rep = repr(HashTrieSet([\"1\", \"2\"]))\n    assert rep == \"HashTrieSet({'1', '2'})\" or rep == \"HashTrieSet({'2', '1'})\"\n\n\ndef test_update():\n    assert HashTrieSet([1, 2, 3]).update([3, 4, 4, 5]) == HashTrieSet(\n        [1, 2, 3, 4, 5],\n    )\n\n\ndef test_update_no_elements():\n    s1 = HashTrieSet([1, 2])\n    assert s1.update([]) == s1\n\n\ndef test_iterable():\n    assert HashTrieSet(iter(\"a\")) == HashTrieSet(iter(\"a\"))\n\n\ndef test_more_eq():\n    # Non-pyrsistent-test-suite test\n    o = object()\n\n    assert HashTrieSet([o]) == HashTrieSet([o])\n    assert HashTrieSet([o, o]) == HashTrieSet([o, o])\n    assert HashTrieSet([o]) == HashTrieSet([o, o])\n    assert HashTrieSet() == HashTrieSet([])\n    assert not (HashTrieSet([1, 2]) == HashTrieSet([1, 3]))\n    assert not (HashTrieSet([o, 1]) == HashTrieSet([o, o]))\n    assert not (HashTrieSet([]) == HashTrieSet([o]))\n\n    assert HashTrieSet([1, 2]) != HashTrieSet([1, 3])\n    assert HashTrieSet([]) != HashTrieSet([o])\n    assert not (HashTrieSet([o]) != HashTrieSet([o]))\n    assert not (HashTrieSet([o, o]) != HashTrieSet([o, o]))\n    assert not (HashTrieSet([o]) != HashTrieSet([o, o]))\n    assert not (HashTrieSet() != HashTrieSet([]))\n\n    assert HashTrieSet([1, 2]) == {1, 2}\n    assert HashTrieSet([1, 2]) != {1, 2, 3}\n    assert HashTrieSet([1, 2]) != [1, 2]\n\n\ndef test_more_set_comparisons():\n    s = HashTrieSet([1, 2, 3])\n\n    assert s == s\n    assert not (s < s)\n    assert s <= s\n    assert not (s > s)\n    assert s >= s\n\n\ndef test_pickle():\n    assert pickle.loads(\n        pickle.dumps(HashTrieSet([1, 2, 3, 4])),\n    ) == HashTrieSet([1, 2, 3, 4])\n\n\ndef test_instance_of_set():\n    assert isinstance(HashTrieSet(), abc.Set)\n\n\ndef test_lt_le_gt_ge():\n    assert HashTrieSet({}) < {1}\n    assert HashTrieSet({}) <= {1}\n    assert HashTrieSet({1}) > set()\n    assert HashTrieSet({1}) >= set()\n", "tests/test_queue.py": "\"\"\"\nModified from the pyrsistent test suite.\n\nPre-modification, these were MIT licensed, and are copyright:\n\n    Copyright (c) 2022 Tobias Gustafsson\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\"\"\"\n\nimport pytest\n\nfrom rpds import Queue\n\nHASH_MSG = \"Not sure Queue implements Hash, it has mutable methods\"\n\n\ndef test_literalish_works():\n    assert Queue(1, 2, 3) == Queue([1, 2, 3])\n\n\ndef test_peek_dequeue():\n    pl = Queue([1, 2])\n    assert pl.peek == 1\n    assert pl.dequeue().peek == 2\n    assert pl.dequeue().dequeue().is_empty\n    with pytest.raises(IndexError):\n        pl.dequeue().dequeue().dequeue()\n\n\ndef test_instantiate_large_list():\n    assert Queue(range(1000)).peek == 0\n\n\ndef test_iteration():\n    assert list(Queue()) == []\n    assert list(Queue([1, 2, 3])) == [1, 2, 3]\n\n\ndef test_enqueue():\n    assert Queue([1, 2, 3]).enqueue(4) == Queue([1, 2, 3, 4])\n\n\ndef test_enqueue_empty_list():\n    assert Queue().enqueue(0) == Queue([0])\n\n\ndef test_truthiness():\n    assert Queue([1])\n    assert not Queue()\n\n\ndef test_len():\n    assert len(Queue([1, 2, 3])) == 3\n    assert len(Queue()) == 0\n\n\ndef test_peek_illegal_on_empty_list():\n    with pytest.raises(IndexError):\n        Queue().peek\n\n\ndef test_inequality():\n    assert Queue([1, 2]) != Queue([1, 3])\n    assert Queue([1, 2]) != Queue([1, 2, 3])\n    assert Queue() != Queue([1, 2, 3])\n\n\ndef test_repr():\n    assert str(Queue()) == \"Queue([])\"\n    assert str(Queue([1, 2, 3])) in \"Queue([1, 2, 3])\"\n\n\ndef test_sequence():\n    m = Queue(\"asdf\")\n    assert m == Queue([\"a\", \"s\", \"d\", \"f\"])\n\n\n# Non-pyrsistent-test-suite tests\n\n\ndef test_dequeue():\n    assert Queue([1, 2, 3]).dequeue() == Queue([2, 3])\n\n\ndef test_dequeue_empty():\n    \"\"\"\n    rpds itself returns an Option<Queue> here but we try IndexError instead.\n    \"\"\"\n    with pytest.raises(IndexError):\n        Queue([]).dequeue()\n\n\ndef test_more_eq():\n    o = object()\n\n    assert Queue([o, o]) == Queue([o, o])\n    assert Queue([o]) == Queue([o])\n    assert Queue() == Queue([])\n    assert not (Queue([1, 2]) == Queue([1, 3]))\n    assert not (Queue([o]) == Queue([o, o]))\n    assert not (Queue([]) == Queue([o]))\n\n    assert Queue([1, 2]) != Queue([1, 3])\n    assert Queue([o]) != Queue([o, o])\n    assert Queue([]) != Queue([o])\n    assert not (Queue([o, o]) != Queue([o, o]))\n    assert not (Queue([o]) != Queue([o]))\n    assert not (Queue() != Queue([]))\n\n\ndef test_hashing():\n    assert hash(Queue([1, 2])) == hash(Queue([1, 2]))\n    assert hash(Queue([1, 2])) != hash(Queue([2, 1]))\n    assert len({Queue([1, 2]), Queue([1, 2])}) == 1\n\n\ndef test_unhashable_contents():\n    q = Queue([1, {1}])\n    with pytest.raises(TypeError):\n        hash(q)\n", "tests/__init__.py": ""}