{"visual_chatgpt.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\n# coding: utf-8\nimport os\nimport gradio as gr\nimport random\nimport torch\nimport cv2\nimport re\nimport uuid\nfrom PIL import Image, ImageDraw, ImageOps, ImageFont\nimport math\nimport numpy as np\nimport argparse\nimport inspect\nimport tempfile\nfrom transformers import CLIPSegProcessor, CLIPSegForImageSegmentation\nfrom transformers import pipeline, BlipProcessor, BlipForConditionalGeneration, BlipForQuestionAnswering\nfrom transformers import AutoImageProcessor, UperNetForSemanticSegmentation\n\nfrom diffusers import StableDiffusionPipeline, StableDiffusionInpaintPipeline, StableDiffusionInstructPix2PixPipeline\nfrom diffusers import EulerAncestralDiscreteScheduler\nfrom diffusers import StableDiffusionControlNetPipeline, ControlNetModel, UniPCMultistepScheduler\nfrom diffusers.pipelines.stable_diffusion import StableDiffusionSafetyChecker\n\nfrom controlnet_aux import OpenposeDetector, MLSDdetector, HEDdetector\n\nfrom langchain.agents.initialize import initialize_agent\nfrom langchain.agents.tools import Tool\nfrom langchain.chains.conversation.memory import ConversationBufferMemory\nfrom langchain.llms.openai import OpenAI\n\n# Grounding DINO\nimport groundingdino.datasets.transforms as T\nfrom groundingdino.models import build_model\nfrom groundingdino.util import box_ops\nfrom groundingdino.util.slconfig import SLConfig\nfrom groundingdino.util.utils import clean_state_dict, get_phrases_from_posmap\n\n# segment anything\nfrom segment_anything import build_sam, SamPredictor, SamAutomaticMaskGenerator\nimport cv2\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport wget\n\nVISUAL_CHATGPT_PREFIX = \"\"\"Visual ChatGPT is designed to be able to assist with a wide range of text and visual related tasks, from answering simple questions to providing in-depth explanations and discussions on a wide range of topics. Visual ChatGPT is able to generate human-like text based on the input it receives, allowing it to engage in natural-sounding conversations and provide responses that are coherent and relevant to the topic at hand.\n\nVisual ChatGPT is able to process and understand large amounts of text and images. As a language model, Visual ChatGPT can not directly read images, but it has a list of tools to finish different visual tasks. Each image will have a file name formed as \"image/xxx.png\", and Visual ChatGPT can invoke different tools to indirectly understand pictures. When talking about images, Visual ChatGPT is very strict to the file name and will never fabricate nonexistent files. When using tools to generate new image files, Visual ChatGPT is also known that the image may not be the same as the user's demand, and will use other visual question answering tools or description tools to observe the real image. Visual ChatGPT is able to use tools in a sequence, and is loyal to the tool observation outputs rather than faking the image content and image file name. It will remember to provide the file name from the last tool observation, if a new image is generated.\n\nHuman may provide new figures to Visual ChatGPT with a description. The description helps Visual ChatGPT to understand this image, but Visual ChatGPT should use tools to finish following tasks, rather than directly imagine from the description.\n\nOverall, Visual ChatGPT is a powerful visual dialogue assistant tool that can help with a wide range of tasks and provide valuable insights and information on a wide range of topics. \n\n\nTOOLS:\n------\n\nVisual ChatGPT  has access to the following tools:\"\"\"\n\nVISUAL_CHATGPT_FORMAT_INSTRUCTIONS = \"\"\"To use a tool, please use the following format:\n\n```\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n```\n\nWhen you have a response to say to the Human, or if you do not need to use a tool, you MUST use the format:\n\n```\nThought: Do I need to use a tool? No\n{ai_prefix}: [your response here]\n```\n\"\"\"\n\nVISUAL_CHATGPT_SUFFIX = \"\"\"You are very strict to the filename correctness and will never fake a file name if it does not exist.\nYou will remember to provide the image file name loyally if it's provided in the last tool observation.\n\nBegin!\n\nPrevious conversation history:\n{chat_history}\n\nNew input: {input}\nSince Visual ChatGPT is a text language model, Visual ChatGPT must use tools to observe images rather than imagination.\nThe thoughts and observations are only visible for Visual ChatGPT, Visual ChatGPT should remember to repeat important information in the final response for Human. \nThought: Do I need to use a tool? {agent_scratchpad} Let's think step by step.\n\"\"\"\n\nVISUAL_CHATGPT_PREFIX_CN = \"\"\"Visual ChatGPT \u65e8\u5728\u80fd\u591f\u534f\u52a9\u5b8c\u6210\u8303\u56f4\u5e7f\u6cdb\u7684\u6587\u672c\u548c\u89c6\u89c9\u76f8\u5173\u4efb\u52a1\uff0c\u4ece\u56de\u7b54\u7b80\u5355\u7684\u95ee\u9898\u5230\u63d0\u4f9b\u5bf9\u5e7f\u6cdb\u4e3b\u9898\u7684\u6df1\u5165\u89e3\u91ca\u548c\u8ba8\u8bba\u3002 Visual ChatGPT \u80fd\u591f\u6839\u636e\u6536\u5230\u7684\u8f93\u5165\u751f\u6210\u7c7b\u4f3c\u4eba\u7c7b\u7684\u6587\u672c\uff0c\u4f7f\u5176\u80fd\u591f\u8fdb\u884c\u542c\u8d77\u6765\u81ea\u7136\u7684\u5bf9\u8bdd\uff0c\u5e76\u63d0\u4f9b\u8fde\u8d2f\u4e14\u4e0e\u624b\u5934\u4e3b\u9898\u76f8\u5173\u7684\u54cd\u5e94\u3002\n\nVisual ChatGPT \u80fd\u591f\u5904\u7406\u548c\u7406\u89e3\u5927\u91cf\u6587\u672c\u548c\u56fe\u50cf\u3002\u4f5c\u4e3a\u4e00\u79cd\u8bed\u8a00\u6a21\u578b\uff0cVisual ChatGPT \u4e0d\u80fd\u76f4\u63a5\u8bfb\u53d6\u56fe\u50cf\uff0c\u4f46\u5b83\u6709\u4e00\u7cfb\u5217\u5de5\u5177\u6765\u5b8c\u6210\u4e0d\u540c\u7684\u89c6\u89c9\u4efb\u52a1\u3002\u6bcf\u5f20\u56fe\u7247\u90fd\u4f1a\u6709\u4e00\u4e2a\u6587\u4ef6\u540d\uff0c\u683c\u5f0f\u4e3a\u201cimage/xxx.png\u201d\uff0cVisual ChatGPT\u53ef\u4ee5\u8c03\u7528\u4e0d\u540c\u7684\u5de5\u5177\u6765\u95f4\u63a5\u7406\u89e3\u56fe\u7247\u3002\u5728\u8c08\u8bba\u56fe\u7247\u65f6\uff0cVisual ChatGPT \u5bf9\u6587\u4ef6\u540d\u7684\u8981\u6c42\u975e\u5e38\u4e25\u683c\uff0c\u7edd\u4e0d\u4f1a\u4f2a\u9020\u4e0d\u5b58\u5728\u7684\u6587\u4ef6\u3002\u5728\u4f7f\u7528\u5de5\u5177\u751f\u6210\u65b0\u7684\u56fe\u50cf\u6587\u4ef6\u65f6\uff0cVisual ChatGPT\u4e5f\u77e5\u9053\u56fe\u50cf\u53ef\u80fd\u4e0e\u7528\u6237\u9700\u6c42\u4e0d\u4e00\u6837\uff0c\u4f1a\u4f7f\u7528\u5176\u4ed6\u89c6\u89c9\u95ee\u7b54\u5de5\u5177\u6216\u63cf\u8ff0\u5de5\u5177\u6765\u89c2\u5bdf\u771f\u5b9e\u56fe\u50cf\u3002 Visual ChatGPT \u80fd\u591f\u6309\u987a\u5e8f\u4f7f\u7528\u5de5\u5177\uff0c\u5e76\u4e14\u5fe0\u4e8e\u5de5\u5177\u89c2\u5bdf\u8f93\u51fa\uff0c\u800c\u4e0d\u662f\u4f2a\u9020\u56fe\u50cf\u5185\u5bb9\u548c\u56fe\u50cf\u6587\u4ef6\u540d\u3002\u5982\u679c\u751f\u6210\u65b0\u56fe\u50cf\uff0c\u5b83\u5c06\u8bb0\u5f97\u63d0\u4f9b\u4e0a\u6b21\u5de5\u5177\u89c2\u5bdf\u7684\u6587\u4ef6\u540d\u3002\n\nHuman \u53ef\u80fd\u4f1a\u5411 Visual ChatGPT \u63d0\u4f9b\u5e26\u6709\u63cf\u8ff0\u7684\u65b0\u56fe\u5f62\u3002\u63cf\u8ff0\u5e2e\u52a9 Visual ChatGPT \u7406\u89e3\u8fd9\u4e2a\u56fe\u50cf\uff0c\u4f46 Visual ChatGPT \u5e94\u8be5\u4f7f\u7528\u5de5\u5177\u6765\u5b8c\u6210\u4ee5\u4e0b\u4efb\u52a1\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u4ece\u63cf\u8ff0\u4e2d\u60f3\u8c61\u3002\u6709\u4e9b\u5de5\u5177\u5c06\u4f1a\u8fd4\u56de\u82f1\u6587\u63cf\u8ff0\uff0c\u4f46\u4f60\u5bf9\u7528\u6237\u7684\u804a\u5929\u5e94\u5f53\u91c7\u7528\u4e2d\u6587\u3002\n\n\u603b\u7684\u6765\u8bf4\uff0cVisual ChatGPT \u662f\u4e00\u4e2a\u5f3a\u5927\u7684\u53ef\u89c6\u5316\u5bf9\u8bdd\u8f85\u52a9\u5de5\u5177\uff0c\u53ef\u4ee5\u5e2e\u52a9\u5904\u7406\u8303\u56f4\u5e7f\u6cdb\u7684\u4efb\u52a1\uff0c\u5e76\u63d0\u4f9b\u5173\u4e8e\u8303\u56f4\u5e7f\u6cdb\u7684\u4e3b\u9898\u7684\u6709\u4ef7\u503c\u7684\u89c1\u89e3\u548c\u4fe1\u606f\u3002\n\n\u5de5\u5177\u5217\u8868:\n------\n\nVisual ChatGPT \u53ef\u4ee5\u4f7f\u7528\u8fd9\u4e9b\u5de5\u5177:\"\"\"\n\nVISUAL_CHATGPT_FORMAT_INSTRUCTIONS_CN = \"\"\"\u7528\u6237\u4f7f\u7528\u4e2d\u6587\u548c\u4f60\u8fdb\u884c\u804a\u5929\uff0c\u4f46\u662f\u5de5\u5177\u7684\u53c2\u6570\u5e94\u5f53\u4f7f\u7528\u82f1\u6587\u3002\u5982\u679c\u8981\u8c03\u7528\u5de5\u5177\uff0c\u4f60\u5fc5\u987b\u9075\u5faa\u5982\u4e0b\u683c\u5f0f:\n\n```\nThought: Do I need to use a tool? Yes\nAction: the action to take, should be one of [{tool_names}]\nAction Input: the input to the action\nObservation: the result of the action\n```\n\n\u5f53\u4f60\u4e0d\u518d\u9700\u8981\u7ee7\u7eed\u8c03\u7528\u5de5\u5177\uff0c\u800c\u662f\u5bf9\u89c2\u5bdf\u7ed3\u679c\u8fdb\u884c\u603b\u7ed3\u56de\u590d\u65f6\uff0c\u4f60\u5fc5\u987b\u4f7f\u7528\u5982\u4e0b\u683c\u5f0f\uff1a\n\n\n```\nThought: Do I need to use a tool? No\n{ai_prefix}: [your response here]\n```\n\"\"\"\n\nVISUAL_CHATGPT_SUFFIX_CN = \"\"\"\u4f60\u5bf9\u6587\u4ef6\u540d\u7684\u6b63\u786e\u6027\u975e\u5e38\u4e25\u683c\uff0c\u800c\u4e14\u6c38\u8fdc\u4e0d\u4f1a\u4f2a\u9020\u4e0d\u5b58\u5728\u7684\u6587\u4ef6\u3002\n\n\u5f00\u59cb!\n\n\u56e0\u4e3aVisual ChatGPT\u662f\u4e00\u4e2a\u6587\u672c\u8bed\u8a00\u6a21\u578b\uff0c\u5fc5\u987b\u4f7f\u7528\u5de5\u5177\u53bb\u89c2\u5bdf\u56fe\u7247\u800c\u4e0d\u662f\u4f9d\u9760\u60f3\u8c61\u3002\n\u63a8\u7406\u60f3\u6cd5\u548c\u89c2\u5bdf\u7ed3\u679c\u53ea\u5bf9Visual ChatGPT\u53ef\u89c1\uff0c\u9700\u8981\u8bb0\u5f97\u5728\u6700\u7ec8\u56de\u590d\u65f6\u628a\u91cd\u8981\u7684\u4fe1\u606f\u91cd\u590d\u7ed9\u7528\u6237\uff0c\u4f60\u53ea\u80fd\u7ed9\u7528\u6237\u8fd4\u56de\u4e2d\u6587\u53e5\u5b50\u3002\u6211\u4eec\u4e00\u6b65\u4e00\u6b65\u601d\u8003\u3002\u5728\u4f60\u4f7f\u7528\u5de5\u5177\u65f6\uff0c\u5de5\u5177\u7684\u53c2\u6570\u53ea\u80fd\u662f\u82f1\u6587\u3002\n\n\u804a\u5929\u5386\u53f2:\n{chat_history}\n\n\u65b0\u8f93\u5165: {input}\nThought: Do I need to use a tool? {agent_scratchpad}\n\"\"\"\n\nos.makedirs('image', exist_ok=True)\n\n\ndef seed_everything(seed):\n    random.seed(seed)\n    np.random.seed(seed)\n    torch.manual_seed(seed)\n    torch.cuda.manual_seed_all(seed)\n    return seed\n\n\ndef prompts(name, description):\n    def decorator(func):\n        func.name = name\n        func.description = description\n        return func\n\n    return decorator\n\n\ndef blend_gt2pt(old_image, new_image, sigma=0.15, steps=100):\n    new_size = new_image.size\n    old_size = old_image.size\n    easy_img = np.array(new_image)\n    gt_img_array = np.array(old_image)\n    pos_w = (new_size[0] - old_size[0]) // 2\n    pos_h = (new_size[1] - old_size[1]) // 2\n\n    kernel_h = cv2.getGaussianKernel(old_size[1], old_size[1] * sigma)\n    kernel_w = cv2.getGaussianKernel(old_size[0], old_size[0] * sigma)\n    kernel = np.multiply(kernel_h, np.transpose(kernel_w))\n\n    kernel[steps:-steps, steps:-steps] = 1\n    kernel[:steps, :steps] = kernel[:steps, :steps] / kernel[steps - 1, steps - 1]\n    kernel[:steps, -steps:] = kernel[:steps, -steps:] / kernel[steps - 1, -(steps)]\n    kernel[-steps:, :steps] = kernel[-steps:, :steps] / kernel[-steps, steps - 1]\n    kernel[-steps:, -steps:] = kernel[-steps:, -steps:] / kernel[-steps, -steps]\n    kernel = np.expand_dims(kernel, 2)\n    kernel = np.repeat(kernel, 3, 2)\n\n    weight = np.linspace(0, 1, steps)\n    top = np.expand_dims(weight, 1)\n    top = np.repeat(top, old_size[0] - 2 * steps, 1)\n    top = np.expand_dims(top, 2)\n    top = np.repeat(top, 3, 2)\n\n    weight = np.linspace(1, 0, steps)\n    down = np.expand_dims(weight, 1)\n    down = np.repeat(down, old_size[0] - 2 * steps, 1)\n    down = np.expand_dims(down, 2)\n    down = np.repeat(down, 3, 2)\n\n    weight = np.linspace(0, 1, steps)\n    left = np.expand_dims(weight, 0)\n    left = np.repeat(left, old_size[1] - 2 * steps, 0)\n    left = np.expand_dims(left, 2)\n    left = np.repeat(left, 3, 2)\n\n    weight = np.linspace(1, 0, steps)\n    right = np.expand_dims(weight, 0)\n    right = np.repeat(right, old_size[1] - 2 * steps, 0)\n    right = np.expand_dims(right, 2)\n    right = np.repeat(right, 3, 2)\n\n    kernel[:steps, steps:-steps] = top\n    kernel[-steps:, steps:-steps] = down\n    kernel[steps:-steps, :steps] = left\n    kernel[steps:-steps, -steps:] = right\n\n    pt_gt_img = easy_img[pos_h:pos_h + old_size[1], pos_w:pos_w + old_size[0]]\n    gaussian_gt_img = kernel * gt_img_array + (1 - kernel) * pt_gt_img  # gt img with blur img\n    gaussian_gt_img = gaussian_gt_img.astype(np.int64)\n    easy_img[pos_h:pos_h + old_size[1], pos_w:pos_w + old_size[0]] = gaussian_gt_img\n    gaussian_img = Image.fromarray(easy_img)\n    return gaussian_img\n\n\ndef cut_dialogue_history(history_memory, keep_last_n_words=500):\n    if history_memory is None or len(history_memory) == 0:\n        return history_memory\n    tokens = history_memory.split()\n    n_tokens = len(tokens)\n    print(f\"history_memory:{history_memory}, n_tokens: {n_tokens}\")\n    if n_tokens < keep_last_n_words:\n        return history_memory\n    paragraphs = history_memory.split('\\n')\n    last_n_tokens = n_tokens\n    while last_n_tokens >= keep_last_n_words:\n        last_n_tokens -= len(paragraphs[0].split(' '))\n        paragraphs = paragraphs[1:]\n    return '\\n' + '\\n'.join(paragraphs)\n\n\ndef get_new_image_name(org_img_name, func_name=\"update\"):\n    head_tail = os.path.split(org_img_name)\n    head = head_tail[0]\n    tail = head_tail[1]\n    name_split = tail.split('.')[0].split('_')\n    this_new_uuid = str(uuid.uuid4())[:4]\n    if len(name_split) == 1:\n        most_org_file_name = name_split[0]\n    else:\n        assert len(name_split) == 4\n        most_org_file_name = name_split[3]\n    recent_prev_file_name = name_split[0]\n    new_file_name = f'{this_new_uuid}_{func_name}_{recent_prev_file_name}_{most_org_file_name}.png'\n    return os.path.join(head, new_file_name)\n\nclass InstructPix2Pix:\n    def __init__(self, device):\n        print(f\"Initializing InstructPix2Pix to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n       \n        self.pipe = StableDiffusionInstructPix2PixPipeline.from_pretrained(\"timbrooks/instruct-pix2pix\",\n                                                                           safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n                                                                           torch_dtype=self.torch_dtype).to(device)\n        self.pipe.scheduler = EulerAncestralDiscreteScheduler.from_config(self.pipe.scheduler.config)\n\n    @prompts(name=\"Instruct Image Using Text\",\n             description=\"useful when you want to the style of the image to be like the text. \"\n                         \"like: make it look like a painting. or make it like a robot. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the text. \")\n    def inference(self, inputs):\n        \"\"\"Change style of image.\"\"\"\n        print(\"===>Starting InstructPix2Pix Inference\")\n        image_path, text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        original_image = Image.open(image_path)\n        image = self.pipe(text, image=original_image, num_inference_steps=40, image_guidance_scale=1.2).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"pix2pix\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed InstructPix2Pix, Input Image: {image_path}, Instruct Text: {text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Text2Image:\n    def __init__(self, device):\n        print(f\"Initializing Text2Image to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.pipe = StableDiffusionPipeline.from_pretrained(\"runwayml/stable-diffusion-v1-5\",\n                                                            torch_dtype=self.torch_dtype)\n        self.pipe.to(device)\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                        'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image From User Input Text\",\n             description=\"useful when you want to generate an image from a user input text and save it to a file. \"\n                         \"like: generate an image of an object or something, or generate an image that includes some objects. \"\n                         \"The input to this tool should be a string, representing the text used to generate image. \")\n    def inference(self, text):\n        image_filename = os.path.join('image', f\"{str(uuid.uuid4())[:8]}.png\")\n        prompt = text + ', ' + self.a_prompt\n        image = self.pipe(prompt, negative_prompt=self.n_prompt).images[0]\n        image.save(image_filename)\n        print(\n            f\"\\nProcessed Text2Image, Input Text: {text}, Output Image: {image_filename}\")\n        return image_filename\n\n\nclass ImageCaptioning:\n    def __init__(self, device):\n        print(f\"Initializing ImageCaptioning to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.processor = BlipProcessor.from_pretrained(\"Salesforce/blip-image-captioning-base\")\n        self.model = BlipForConditionalGeneration.from_pretrained(\n            \"Salesforce/blip-image-captioning-base\", torch_dtype=self.torch_dtype).to(self.device)\n\n    @prompts(name=\"Get Photo Description\",\n             description=\"useful when you want to know what is inside the photo. receives image_path as input. \"\n                         \"The input to this tool should be a string, representing the image_path. \")\n    def inference(self, image_path):\n        inputs = self.processor(Image.open(image_path), return_tensors=\"pt\").to(self.device, self.torch_dtype)\n        out = self.model.generate(**inputs)\n        captions = self.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed ImageCaptioning, Input Image: {image_path}, Output Text: {captions}\")\n        return captions\n\n\nclass Image2Canny:\n    def __init__(self, device):\n        print(\"Initializing Image2Canny\")\n        self.low_threshold = 100\n        self.high_threshold = 200\n\n    @prompts(name=\"Edge Detection On Image\",\n             description=\"useful when you want to detect the edge of the image. \"\n                         \"like: detect the edges of this image, or canny detection on image, \"\n                         \"or perform edge detection on this image, or detect the canny image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        image = np.array(image)\n        canny = cv2.Canny(image, self.low_threshold, self.high_threshold)\n        canny = canny[:, :, None]\n        canny = np.concatenate([canny, canny, canny], axis=2)\n        canny = Image.fromarray(canny)\n        updated_image_path = get_new_image_name(inputs, func_name=\"edge\")\n        canny.save(updated_image_path)\n        print(f\"\\nProcessed Image2Canny, Input Image: {inputs}, Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass CannyText2Image:\n    def __init__(self, device):\n        print(f\"Initializing CannyText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-canny\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Canny Image\",\n             description=\"useful when you want to generate a new real image from both the user description and a canny image.\"\n                         \" like: generate a real image of a object or something from this canny image,\"\n                         \" or generate a new real image of a object or something from this edge image. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description. \")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"canny2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed CannyText2Image, Input Canny: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Line:\n    def __init__(self, device):\n        print(\"Initializing Image2Line\")\n        self.detector = MLSDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Line Detection On Image\",\n             description=\"useful when you want to detect the straight line of the image. \"\n                         \"like: detect the straight lines of this image, or straight line detection on image, \"\n                         \"or perform straight line detection on this image, or detect the straight line image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        mlsd = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"line-of\")\n        mlsd.save(updated_image_path)\n        print(f\"\\nProcessed Image2Line, Input Image: {inputs}, Output Line: {updated_image_path}\")\n        return updated_image_path\n\n\nclass LineText2Image:\n    def __init__(self, device):\n        print(f\"Initializing LineText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-mlsd\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Line Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a straight line image. \"\n                         \"like: generate a real image of a object or something from this straight line image, \"\n                         \"or generate a new real image of a object or something from this straight lines. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description. \")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"line2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed LineText2Image, Input Line: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Text: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Hed:\n    def __init__(self, device):\n        print(\"Initializing Image2Hed\")\n        self.detector = HEDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Hed Detection On Image\",\n             description=\"useful when you want to detect the soft hed boundary of the image. \"\n                         \"like: detect the soft hed boundary of this image, or hed boundary detection on image, \"\n                         \"or perform hed boundary detection on this image, or detect soft hed boundary image of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        hed = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"hed-boundary\")\n        hed.save(updated_image_path)\n        print(f\"\\nProcessed Image2Hed, Input Image: {inputs}, Output Hed: {updated_image_path}\")\n        return updated_image_path\n\n\nclass HedText2Image:\n    def __init__(self, device):\n        print(f\"Initializing HedText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-hed\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Soft Hed Boundary Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a soft hed boundary image. \"\n                         \"like: generate a real image of a object or something from this soft hed boundary image, \"\n                         \"or generate a new real image of a object or something from this hed boundary. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"hed2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed HedText2Image, Input Hed: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Scribble:\n    def __init__(self, device):\n        print(\"Initializing Image2Scribble\")\n        self.detector = HEDdetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Sketch Detection On Image\",\n             description=\"useful when you want to generate a scribble of the image. \"\n                         \"like: generate a scribble of this image, or generate a sketch from this image, \"\n                         \"detect the sketch from this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        scribble = self.detector(image, scribble=True)\n        updated_image_path = get_new_image_name(inputs, func_name=\"scribble\")\n        scribble.save(updated_image_path)\n        print(f\"\\nProcessed Image2Scribble, Input Image: {inputs}, Output Scribble: {updated_image_path}\")\n        return updated_image_path\n\n\nclass ScribbleText2Image:\n    def __init__(self, device):\n        print(f\"Initializing ScribbleText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-scribble\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype\n        )\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                            'fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Sketch Image\",\n             description=\"useful when you want to generate a new real image from both the user description and \"\n                         \"a scribble image or a sketch image. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"scribble2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed ScribbleText2Image, Input Scribble: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Pose:\n    def __init__(self, device):\n        print(\"Initializing Image2Pose\")\n        self.detector = OpenposeDetector.from_pretrained('lllyasviel/ControlNet')\n\n    @prompts(name=\"Pose Detection On Image\",\n             description=\"useful when you want to detect the human pose of the image. \"\n                         \"like: generate human poses of this image, or generate a pose image from this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        pose = self.detector(image)\n        updated_image_path = get_new_image_name(inputs, func_name=\"human-pose\")\n        pose.save(updated_image_path)\n        print(f\"\\nProcessed Image2Pose, Input Image: {inputs}, Output Pose: {updated_image_path}\")\n        return updated_image_path\n\n\nclass PoseText2Image:\n    def __init__(self, device):\n        print(f\"Initializing PoseText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-openpose\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.num_inference_steps = 20\n        self.seed = -1\n        self.unconditional_guidance_scale = 9.0\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Pose Image\",\n             description=\"useful when you want to generate a new real image from both the user description \"\n                         \"and a human pose image. \"\n                         \"like: generate a real image of a human from this human pose image, \"\n                         \"or generate a new real image of a human from this pose. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"pose2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed PoseText2Image, Input Pose: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\nclass SegText2Image:\n    def __init__(self, device):\n        print(f\"Initializing SegText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\"fusing/stable-diffusion-v1-5-controlnet-seg\",\n                                                          torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Segmentations\",\n             description=\"useful when you want to generate a new real image from both the user description and segmentations. \"\n                         \"like: generate a real image of a object or something from this segmentation image, \"\n                         \"or generate a new real image of a object or something from these segmentations. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"segment2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed SegText2Image, Input Seg: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Depth:\n    def __init__(self, device):\n        print(\"Initializing Image2Depth\")\n        self.depth_estimator = pipeline('depth-estimation')\n\n    @prompts(name=\"Predict Depth On Image\",\n             description=\"useful when you want to detect depth of the image. like: generate the depth from this image, \"\n                         \"or detect the depth map on this image, or predict the depth for this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        depth = self.depth_estimator(image)['depth']\n        depth = np.array(depth)\n        depth = depth[:, :, None]\n        depth = np.concatenate([depth, depth, depth], axis=2)\n        depth = Image.fromarray(depth)\n        updated_image_path = get_new_image_name(inputs, func_name=\"depth\")\n        depth.save(updated_image_path)\n        print(f\"\\nProcessed Image2Depth, Input Image: {inputs}, Output Depth: {updated_image_path}\")\n        return updated_image_path\n\n\nclass DepthText2Image:\n    def __init__(self, device):\n        print(f\"Initializing DepthText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\n            \"fusing/stable-diffusion-v1-5-controlnet-depth\", torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Depth\",\n             description=\"useful when you want to generate a new real image from both the user description and depth image. \"\n                         \"like: generate a real image of a object or something from this depth image, \"\n                         \"or generate a new real image of a object or something from the depth map. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"depth2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed DepthText2Image, Input Depth: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Image2Normal:\n    def __init__(self, device):\n        print(\"Initializing Image2Normal\")\n        self.depth_estimator = pipeline(\"depth-estimation\", model=\"Intel/dpt-hybrid-midas\")\n        self.bg_threhold = 0.4\n\n    @prompts(name=\"Predict Normal Map On Image\",\n             description=\"useful when you want to detect norm map of the image. \"\n                         \"like: generate normal map from this image, or predict normal map of this image. \"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference(self, inputs):\n        image = Image.open(inputs)\n        original_size = image.size\n        image = self.depth_estimator(image)['predicted_depth'][0]\n        image = image.numpy()\n        image_depth = image.copy()\n        image_depth -= np.min(image_depth)\n        image_depth /= np.max(image_depth)\n        x = cv2.Sobel(image, cv2.CV_32F, 1, 0, ksize=3)\n        x[image_depth < self.bg_threhold] = 0\n        y = cv2.Sobel(image, cv2.CV_32F, 0, 1, ksize=3)\n        y[image_depth < self.bg_threhold] = 0\n        z = np.ones_like(x) * np.pi * 2.0\n        image = np.stack([x, y, z], axis=2)\n        image /= np.sum(image ** 2.0, axis=2, keepdims=True) ** 0.5\n        image = (image * 127.5 + 127.5).clip(0, 255).astype(np.uint8)\n        image = Image.fromarray(image)\n        image = image.resize(original_size)\n        updated_image_path = get_new_image_name(inputs, func_name=\"normal-map\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed Image2Normal, Input Image: {inputs}, Output Depth: {updated_image_path}\")\n        return updated_image_path\n\n\nclass NormalText2Image:\n    def __init__(self, device):\n        print(f\"Initializing NormalText2Image to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.controlnet = ControlNetModel.from_pretrained(\n            \"fusing/stable-diffusion-v1-5-controlnet-normal\", torch_dtype=self.torch_dtype)\n        self.pipe = StableDiffusionControlNetPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-v1-5\", controlnet=self.controlnet, safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker'),\n            torch_dtype=self.torch_dtype)\n        self.pipe.scheduler = UniPCMultistepScheduler.from_config(self.pipe.scheduler.config)\n        self.pipe.to(device)\n        self.seed = -1\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit,' \\\n                            ' fewer digits, cropped, worst quality, low quality'\n\n    @prompts(name=\"Generate Image Condition On Normal Map\",\n             description=\"useful when you want to generate a new real image from both the user description and normal map. \"\n                         \"like: generate a real image of a object or something from this normal map, \"\n                         \"or generate a new real image of a object or something from the normal map. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the user description\")\n    def inference(self, inputs):\n        image_path, instruct_text = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        image = Image.open(image_path)\n        self.seed = random.randint(0, 65535)\n        seed_everything(self.seed)\n        prompt = f'{instruct_text}, {self.a_prompt}'\n        image = self.pipe(prompt, image, num_inference_steps=20, eta=0.0, negative_prompt=self.n_prompt,\n                          guidance_scale=9.0).images[0]\n        updated_image_path = get_new_image_name(image_path, func_name=\"normal2image\")\n        image.save(updated_image_path)\n        print(f\"\\nProcessed NormalText2Image, Input Normal: {image_path}, Input Text: {instruct_text}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass VisualQuestionAnswering:\n    def __init__(self, device):\n        print(f\"Initializing VisualQuestionAnswering to {device}\")\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.device = device\n        self.processor = BlipProcessor.from_pretrained(\"Salesforce/blip-vqa-base\")\n        self.model = BlipForQuestionAnswering.from_pretrained(\n            \"Salesforce/blip-vqa-base\", torch_dtype=self.torch_dtype).to(self.device)\n\n    @prompts(name=\"Answer Question About The Image\",\n             description=\"useful when you need an answer for a question based on an image. \"\n                         \"like: what is the background color of the last image, how many cats in this figure, what is in this figure. \"\n                         \"The input to this tool should be a comma separated string of two, representing the image_path and the question\")\n    def inference(self, inputs):\n        image_path, question = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        raw_image = Image.open(image_path).convert('RGB')\n        inputs = self.processor(raw_image, question, return_tensors=\"pt\").to(self.device, self.torch_dtype)\n        out = self.model.generate(**inputs)\n        answer = self.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed VisualQuestionAnswering, Input Image: {image_path}, Input Question: {question}, \"\n              f\"Output Answer: {answer}\")\n        return answer\n\n\nclass Segmenting:\n    def __init__(self, device):\n        print(f\"Inintializing Segmentation to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.model_checkpoint_path = os.path.join(\"checkpoints\",\"sam\")\n\n        self.download_parameters()\n        self.sam = build_sam(checkpoint=self.model_checkpoint_path).to(device)\n        self.sam_predictor = SamPredictor(self.sam)\n        self.mask_generator = SamAutomaticMaskGenerator(self.sam)\n        \n        self.saved_points = []\n        self.saved_labels = []\n\n    def download_parameters(self):\n        url = \"https://dl.fbaipublicfiles.com/segment_anything/sam_vit_h_4b8939.pth\"\n        if not os.path.exists(self.model_checkpoint_path):\n            wget.download(url,out=self.model_checkpoint_path)\n\n        \n    def show_mask(self, mask: np.ndarray,image: np.ndarray,\n                random_color: bool = False, transparency=1) -> np.ndarray:\n        \n        \"\"\"Visualize a mask on top of an image.\n        Args:\n            mask (np.ndarray): A 2D array of shape (H, W).\n            image (np.ndarray): A 3D array of shape (H, W, 3).\n            random_color (bool): Whether to use a random color for the mask.\n        Outputs:\n            np.ndarray: A 3D array of shape (H, W, 3) with the mask\n            visualized on top of the image.\n            transparenccy: the transparency of the segmentation mask\n        \"\"\"\n        \n        if random_color:\n            color = np.concatenate([np.random.random(3)], axis=0)\n        else:\n            color = np.array([30 / 255, 144 / 255, 255 / 255])\n        h, w = mask.shape[-2:]\n        mask_image = mask.reshape(h, w, 1) * color.reshape(1, 1, -1) * 255\n\n        image = cv2.addWeighted(image, 0.7, mask_image.astype('uint8'), transparency, 0)\n\n\n        return image\n\n    def show_box(self, box, ax, label):\n        x0, y0 = box[0], box[1]\n        w, h = box[2] - box[0], box[3] - box[1]\n        ax.add_patch(plt.Rectangle((x0, y0), w, h, edgecolor='green', facecolor=(0,0,0,0), lw=2)) \n        ax.text(x0, y0, label)\n\n    \n    def get_mask_with_boxes(self, image_pil, image, boxes_filt):\n\n        size = image_pil.size\n        H, W = size[1], size[0]\n        for i in range(boxes_filt.size(0)):\n            boxes_filt[i] = boxes_filt[i] * torch.Tensor([W, H, W, H])\n            boxes_filt[i][:2] -= boxes_filt[i][2:] / 2\n            boxes_filt[i][2:] += boxes_filt[i][:2]\n\n        boxes_filt = boxes_filt.cpu()\n        transformed_boxes = self.sam_predictor.transform.apply_boxes_torch(boxes_filt, image.shape[:2]).to(self.device)\n\n        masks, _, _ = self.sam_predictor.predict_torch(\n            point_coords = None,\n            point_labels = None,\n            boxes = transformed_boxes.to(self.device),\n            multimask_output = False,\n        )\n        return masks\n    \n    def segment_image_with_boxes(self, image_pil, image_path, boxes_filt, pred_phrases):\n\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam_predictor.set_image(image)\n\n        masks = self.get_mask_with_boxes(image_pil, image, boxes_filt)\n\n        # draw output image\n\n        for mask in masks:\n            image = self.show_mask(mask[0].cpu().numpy(), image, random_color=True, transparency=0.3)\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"segmentation\")\n        \n        new_image = Image.fromarray(image)\n        new_image.save(updated_image_path)\n\n        return updated_image_path\n\n    def set_image(self, img) -> None:\n        \"\"\"Set the image for the predictor.\"\"\"\n        with torch.cuda.amp.autocast():\n            self.sam_predictor.set_image(img)\n\n    def show_points(self, coords: np.ndarray, labels: np.ndarray,\n                image: np.ndarray) -> np.ndarray:\n        \"\"\"Visualize points on top of an image.\n\n        Args:\n            coords (np.ndarray): A 2D array of shape (N, 2).\n            labels (np.ndarray): A 1D array of shape (N,).\n            image (np.ndarray): A 3D array of shape (H, W, 3).\n        Returns:\n            np.ndarray: A 3D array of shape (H, W, 3) with the points\n            visualized on top of the image.\n        \"\"\"\n        pos_points = coords[labels == 1]\n        neg_points = coords[labels == 0]\n        for p in pos_points:\n            image = cv2.circle(\n                image, p.astype(int), radius=3, color=(0, 255, 0), thickness=-1)\n        for p in neg_points:\n            image = cv2.circle(\n                image, p.astype(int), radius=3, color=(255, 0, 0), thickness=-1)\n        return image\n\n\n    def segment_image_with_click(self, img, is_positive: bool,\n                            evt: gr.SelectData):\n                            \n        self.sam_predictor.set_image(img)\n        self.saved_points.append([evt.index[0], evt.index[1]])\n        self.saved_labels.append(1 if is_positive else 0)\n        input_point = np.array(self.saved_points)\n        input_label = np.array(self.saved_labels)\n        \n        # Predict the mask\n        with torch.cuda.amp.autocast():\n            masks, scores, logits = self.sam_predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                multimask_output=False,\n            )\n\n        img = self.show_mask(masks[0], img, random_color=False, transparency=0.3)\n\n        img = self.show_points(input_point, input_label, img)\n\n        return img\n\n    def segment_image_with_coordinate(self, img, is_positive: bool,\n                            coordinate: tuple):\n        '''\n            Args:\n                img (numpy.ndarray): the given image, shape: H x W x 3.\n                is_positive: whether the click is positive, if want to add mask use True else False.\n                coordinate: the position of the click\n                          If the position is (x,y), means click at the x-th column and y-th row of the pixel matrix.\n                          So x correspond to W, and y correspond to H.\n            Output:\n                img (PLI.Image.Image): the result image\n                result_mask (numpy.ndarray): the result mask, shape: H x W\n\n            Other parameters:\n                transparency (float): the transparenccy of the mask\n                                      to control he degree of transparency after the mask is superimposed.\n                                      if transparency=1, then the masked part will be completely replaced with other colors.\n        '''\n        self.sam_predictor.set_image(img)\n        self.saved_points.append([coordinate[0], coordinate[1]])\n        self.saved_labels.append(1 if is_positive else 0)\n        input_point = np.array(self.saved_points)\n        input_label = np.array(self.saved_labels)\n\n        # Predict the mask\n        with torch.cuda.amp.autocast():\n            masks, scores, logits = self.sam_predictor.predict(\n                point_coords=input_point,\n                point_labels=input_label,\n                multimask_output=False,\n            )\n\n\n        img = self.show_mask(masks[0], img, random_color=False, transparency=0.3)\n\n        img = self.show_points(input_point, input_label, img)\n\n        img = Image.fromarray(img)\n        \n        result_mask = masks[0]\n\n        return img, result_mask\n\n    @prompts(name=\"Segment the Image\",\n             description=\"useful when you want to segment all the part of the image, but not segment a certain object.\"\n                         \"like: segment all the object in this image, or generate segmentations on this image, \"\n                         \"or segment the image,\"\n                         \"or perform segmentation on this image, \"\n                         \"or segment all the object in this image.\"\n                         \"The input to this tool should be a string, representing the image_path\")\n    def inference_all(self,image_path):\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        masks = self.mask_generator.generate(image)\n        plt.figure(figsize=(20,20))\n        plt.imshow(image)\n        if len(masks) == 0:\n            return\n        sorted_anns = sorted(masks, key=(lambda x: x['area']), reverse=True)\n        ax = plt.gca()\n        ax.set_autoscale_on(False)\n        polygons = []\n        color = []\n        for ann in sorted_anns:\n            m = ann['segmentation']\n            img = np.ones((m.shape[0], m.shape[1], 3))\n            color_mask = np.random.random((1, 3)).tolist()[0]\n            for i in range(3):\n                img[:,:,i] = color_mask[i]\n            ax.imshow(np.dstack((img, m)))\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"segment-image\")\n        plt.axis('off')\n        plt.savefig(\n            updated_image_path, \n            bbox_inches=\"tight\", dpi=300, pad_inches=0.0\n        )\n        return updated_image_path\n    \nclass Text2Box:\n    def __init__(self, device):\n        print(f\"Initializing ObjectDetection to {device}\")\n        self.device = device\n        self.torch_dtype = torch.float16 if 'cuda' in device else torch.float32\n        self.model_checkpoint_path = os.path.join(\"checkpoints\",\"groundingdino\")\n        self.model_config_path = os.path.join(\"checkpoints\",\"grounding_config.py\")\n        self.download_parameters()\n        self.box_threshold = 0.3\n        self.text_threshold = 0.25\n        self.grounding = (self.load_model()).to(self.device)\n\n    def download_parameters(self):\n        url = \"https://github.com/IDEA-Research/GroundingDINO/releases/download/v0.1.0-alpha/groundingdino_swint_ogc.pth\"\n        if not os.path.exists(self.model_checkpoint_path):\n            wget.download(url,out=self.model_checkpoint_path)\n        config_url = \"https://raw.githubusercontent.com/IDEA-Research/GroundingDINO/main/groundingdino/config/GroundingDINO_SwinT_OGC.py\"\n        if not os.path.exists(self.model_config_path):\n            wget.download(config_url,out=self.model_config_path)\n    def load_image(self,image_path):\n         # load image\n        image_pil = Image.open(image_path).convert(\"RGB\")  # load image\n\n        transform = T.Compose(\n            [\n                T.RandomResize([512], max_size=1333),\n                T.ToTensor(),\n                T.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225]),\n            ]\n        )\n        image, _ = transform(image_pil, None)  # 3, h, w\n        return image_pil, image\n\n    def load_model(self):\n        args = SLConfig.fromfile(self.model_config_path)\n        args.device = self.device\n        model = build_model(args)\n        checkpoint = torch.load(self.model_checkpoint_path, map_location=\"cpu\")\n        load_res = model.load_state_dict(clean_state_dict(checkpoint[\"model\"]), strict=False)\n        print(load_res)\n        _ = model.eval()\n        return model\n\n    def get_grounding_boxes(self, image, caption, with_logits=True):\n        caption = caption.lower()\n        caption = caption.strip()\n        if not caption.endswith(\".\"):\n            caption = caption + \".\"\n        image = image.to(self.device)\n        with torch.no_grad():\n            outputs = self.grounding(image[None], captions=[caption])\n        logits = outputs[\"pred_logits\"].cpu().sigmoid()[0]  # (nq, 256)\n        boxes = outputs[\"pred_boxes\"].cpu()[0]  # (nq, 4)\n        logits.shape[0]\n\n        # filter output\n        logits_filt = logits.clone()\n        boxes_filt = boxes.clone()\n        filt_mask = logits_filt.max(dim=1)[0] > self.box_threshold\n        logits_filt = logits_filt[filt_mask]  # num_filt, 256\n        boxes_filt = boxes_filt[filt_mask]  # num_filt, 4\n        logits_filt.shape[0]\n\n        # get phrase\n        tokenlizer = self.grounding.tokenizer\n        tokenized = tokenlizer(caption)\n        # build pred\n        pred_phrases = []\n        for logit, box in zip(logits_filt, boxes_filt):\n            pred_phrase = get_phrases_from_posmap(logit > self.text_threshold, tokenized, tokenlizer)\n            if with_logits:\n                pred_phrases.append(pred_phrase + f\"({str(logit.max().item())[:4]})\")\n            else:\n                pred_phrases.append(pred_phrase)\n\n        return boxes_filt, pred_phrases\n    \n    def plot_boxes_to_image(self, image_pil, tgt):\n        H, W = tgt[\"size\"]\n        boxes = tgt[\"boxes\"]\n        labels = tgt[\"labels\"]\n        assert len(boxes) == len(labels), \"boxes and labels must have same length\"\n\n        draw = ImageDraw.Draw(image_pil)\n        mask = Image.new(\"L\", image_pil.size, 0)\n        mask_draw = ImageDraw.Draw(mask)\n\n        # draw boxes and masks\n        for box, label in zip(boxes, labels):\n            # from 0..1 to 0..W, 0..H\n            box = box * torch.Tensor([W, H, W, H])\n            # from xywh to xyxy\n            box[:2] -= box[2:] / 2\n            box[2:] += box[:2]\n            # random color\n            color = tuple(np.random.randint(0, 255, size=3).tolist())\n            # draw\n            x0, y0, x1, y1 = box\n            x0, y0, x1, y1 = int(x0), int(y0), int(x1), int(y1)\n\n            draw.rectangle([x0, y0, x1, y1], outline=color, width=6)\n            # draw.text((x0, y0), str(label), fill=color)\n\n            font = ImageFont.load_default()\n            if hasattr(font, \"getbbox\"):\n                bbox = draw.textbbox((x0, y0), str(label), font)\n            else:\n                w, h = draw.textsize(str(label), font)\n                bbox = (x0, y0, w + x0, y0 + h)\n            # bbox = draw.textbbox((x0, y0), str(label))\n            draw.rectangle(bbox, fill=color)\n            draw.text((x0, y0), str(label), fill=\"white\")\n\n            mask_draw.rectangle([x0, y0, x1, y1], fill=255, width=2)\n\n        return image_pil, mask\n    \n    @prompts(name=\"Detect the Give Object\",\n             description=\"useful when you only want to detect or find out given objects in the picture\"  \n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path, the text description of the object to be found\")\n    def inference(self, inputs):\n        image_path, det_prompt = inputs.split(\",\")\n        print(f\"image_path={image_path}, text_prompt={det_prompt}\")\n        image_pil, image = self.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.get_grounding_boxes(image, det_prompt)\n\n        size = image_pil.size\n        pred_dict = {\n        \"boxes\": boxes_filt,\n        \"size\": [size[1], size[0]],  # H,W\n        \"labels\": pred_phrases,}\n\n        image_with_box = self.plot_boxes_to_image(image_pil, pred_dict)[0]\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"detect-something\")\n        updated_image = image_with_box.resize(size)\n        updated_image.save(updated_image_path)\n        print(\n            f\"\\nProcessed ObejectDetecting, Input Image: {image_path}, Object to be Detect {det_prompt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\nclass Inpainting:\n    def __init__(self, device):\n        self.device = device\n        self.revision = 'fp16' if 'cuda' in self.device else None\n        self.torch_dtype = torch.float16 if 'cuda' in self.device else torch.float32\n\n        self.inpaint = StableDiffusionInpaintPipeline.from_pretrained(\n            \"runwayml/stable-diffusion-inpainting\", revision=self.revision, torch_dtype=self.torch_dtype,safety_checker=StableDiffusionSafetyChecker.from_pretrained('CompVis/stable-diffusion-safety-checker')).to(device)\n    def __call__(self, prompt, image, mask_image, height=512, width=512, num_inference_steps=50):\n        update_image = self.inpaint(prompt=prompt, image=image.resize((width, height)),\n                                     mask_image=mask_image.resize((width, height)), height=height, width=width, num_inference_steps=num_inference_steps).images[0]\n        return update_image\n\nclass InfinityOutPainting:\n    template_model = True # Add this line to show this is a template model.\n    def __init__(self, ImageCaptioning, Inpainting, VisualQuestionAnswering):\n        self.llm = OpenAI(temperature=0)\n        self.ImageCaption = ImageCaptioning\n        self.inpaint = Inpainting\n        self.ImageVQA = VisualQuestionAnswering\n        self.a_prompt = 'best quality, extremely detailed'\n        self.n_prompt = 'longbody, lowres, bad anatomy, bad hands, missing fingers, extra digit, ' \\\n                        'fewer digits, cropped, worst quality, low quality'\n\n    def get_BLIP_vqa(self, image, question):\n        inputs = self.ImageVQA.processor(image, question, return_tensors=\"pt\").to(self.ImageVQA.device,\n                                                                                  self.ImageVQA.torch_dtype)\n        out = self.ImageVQA.model.generate(**inputs)\n        answer = self.ImageVQA.processor.decode(out[0], skip_special_tokens=True)\n        print(f\"\\nProcessed VisualQuestionAnswering, Input Question: {question}, Output Answer: {answer}\")\n        return answer\n\n    def get_BLIP_caption(self, image):\n        inputs = self.ImageCaption.processor(image, return_tensors=\"pt\").to(self.ImageCaption.device,\n                                                                                self.ImageCaption.torch_dtype)\n        out = self.ImageCaption.model.generate(**inputs)\n        BLIP_caption = self.ImageCaption.processor.decode(out[0], skip_special_tokens=True)\n        return BLIP_caption\n\n    def check_prompt(self, prompt):\n        check = f\"Here is a paragraph with adjectives. \" \\\n                f\"{prompt} \" \\\n                f\"Please change all plural forms in the adjectives to singular forms. \"\n        return self.llm(check)\n\n    def get_imagine_caption(self, image, imagine):\n        BLIP_caption = self.get_BLIP_caption(image)\n        background_color = self.get_BLIP_vqa(image, 'what is the background color of this image')\n        style = self.get_BLIP_vqa(image, 'what is the style of this image')\n        imagine_prompt = f\"let's pretend you are an excellent painter and now \" \\\n                         f\"there is an incomplete painting with {BLIP_caption} in the center, \" \\\n                         f\"please imagine the complete painting and describe it\" \\\n                         f\"you should consider the background color is {background_color}, the style is {style}\" \\\n                         f\"You should make the painting as vivid and realistic as possible\" \\\n                         f\"You can not use words like painting or picture\" \\\n                         f\"and you should use no more than 50 words to describe it\"\n        caption = self.llm(imagine_prompt) if imagine else BLIP_caption\n        caption = self.check_prompt(caption)\n        print(f'BLIP observation: {BLIP_caption}, ChatGPT imagine to {caption}') if imagine else print(\n            f'Prompt: {caption}')\n        return caption\n\n    def resize_image(self, image, max_size=1000000, multiple=8):\n        aspect_ratio = image.size[0] / image.size[1]\n        new_width = int(math.sqrt(max_size * aspect_ratio))\n        new_height = int(new_width / aspect_ratio)\n        new_width, new_height = new_width - (new_width % multiple), new_height - (new_height % multiple)\n        return image.resize((new_width, new_height))\n\n    def dowhile(self, original_img, tosize, expand_ratio, imagine, usr_prompt):\n        old_img = original_img\n        while (old_img.size != tosize):\n            prompt = self.check_prompt(usr_prompt) if usr_prompt else self.get_imagine_caption(old_img, imagine)\n            crop_w = 15 if old_img.size[0] != tosize[0] else 0\n            crop_h = 15 if old_img.size[1] != tosize[1] else 0\n            old_img = ImageOps.crop(old_img, (crop_w, crop_h, crop_w, crop_h))\n            temp_canvas_size = (expand_ratio * old_img.width if expand_ratio * old_img.width < tosize[0] else tosize[0],\n                                expand_ratio * old_img.height if expand_ratio * old_img.height < tosize[1] else tosize[\n                                    1])\n            temp_canvas, temp_mask = Image.new(\"RGB\", temp_canvas_size, color=\"white\"), Image.new(\"L\", temp_canvas_size,\n                                                                                                  color=\"white\")\n            x, y = (temp_canvas.width - old_img.width) // 2, (temp_canvas.height - old_img.height) // 2\n            temp_canvas.paste(old_img, (x, y))\n            temp_mask.paste(0, (x, y, x + old_img.width, y + old_img.height))\n            resized_temp_canvas, resized_temp_mask = self.resize_image(temp_canvas), self.resize_image(temp_mask)\n            image = self.inpaint(prompt=prompt, image=resized_temp_canvas, mask_image=resized_temp_mask,\n                                              height=resized_temp_canvas.height, width=resized_temp_canvas.width,\n                                              num_inference_steps=50).resize(\n                (temp_canvas.width, temp_canvas.height), Image.ANTIALIAS)\n            image = blend_gt2pt(old_img, image)\n            old_img = image\n        return old_img\n\n    @prompts(name=\"Extend An Image\",\n             description=\"useful when you need to extend an image into a larger image.\"\n                         \"like: extend the image into a resolution of 2048x1024, extend the image into 2048x1024. \"\n                         \"The input to this tool should be a comma separated string of two, representing the image_path and the resolution of widthxheight\")\n    def inference(self, inputs):\n        image_path, resolution = inputs.split(',')\n        width, height = resolution.split('x')\n        tosize = (int(width), int(height))\n        image = Image.open(image_path)\n        image = ImageOps.crop(image, (10, 10, 10, 10))\n        out_painted_image = self.dowhile(image, tosize, 4, True, False)\n        updated_image_path = get_new_image_name(image_path, func_name=\"outpainting\")\n        out_painted_image.save(updated_image_path)\n        print(f\"\\nProcessed InfinityOutPainting, Input Image: {image_path}, Input Resolution: {resolution}, \"\n              f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n\n\nclass ObjectSegmenting:\n    template_model = True # Add this line to show this is a template model.\n    def __init__(self,  Text2Box:Text2Box, Segmenting:Segmenting):\n        # self.llm = OpenAI(temperature=0)\n        self.grounding = Text2Box\n        self.sam = Segmenting\n\n\n    @prompts(name=\"Segment the given object\",\n            description=\"useful when you only want to segment the certain objects in the picture\"\n                        \"according to the given text\"  \n                        \"like: segment the cat,\"\n                        \"or can you segment an obeject for me\"\n                        \"The input to this tool should be a comma separated string of two, \"\n                        \"representing the image_path, the text description of the object to be found\")\n    def inference(self, inputs):\n        image_path, det_prompt = inputs.split(\",\")\n        print(f\"image_path={image_path}, text_prompt={det_prompt}\")\n        image_pil, image = self.grounding.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, det_prompt)\n        updated_image_path = self.sam.segment_image_with_boxes(image_pil,image_path,boxes_filt,pred_phrases)\n        print(\n            f\"\\nProcessed ObejectSegmenting, Input Image: {image_path}, Object to be Segment {det_prompt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\n    def merge_masks(self, masks):\n        '''\n            Args:\n                mask (numpy.ndarray): shape N x 1 x H x W\n            Outputs:\n                new_mask (numpy.ndarray): shape H x W       \n        '''\n        if type(masks) == torch.Tensor:\n            x = masks\n        elif type(masks) == np.ndarray:\n            x = torch.tensor(masks,dtype=int)\n        else:   \n            raise TypeError(\"the type of the input masks must be numpy.ndarray or torch.tensor\")\n        x = x.squeeze(dim=1)\n        value, _ = x.max(dim=0)\n        new_mask = value.cpu().numpy()\n        new_mask.astype(np.uint8)\n        return new_mask\n    \n    def get_mask(self, image_path, text_prompt):\n\n        print(f\"image_path={image_path}, text_prompt={text_prompt}\")\n        # image_pil (PIL.Image.Image) -> size: W x H\n        # image (numpy.ndarray) -> H x W x 3\n        image_pil, image = self.grounding.load_image(image_path)\n\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, text_prompt)\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam.sam_predictor.set_image(image)\n        \n        # masks (torch.tensor) -> N x 1 x H x W \n        masks = self.sam.get_mask_with_boxes(image_pil, image, boxes_filt)\n\n        # merged_mask -> H x W\n        merged_mask = self.merge_masks(masks)\n        # draw output image\n\n        for mask in masks:\n            image = self.sam.show_mask(mask[0].cpu().numpy(), image, random_color=True, transparency=0.3)\n\n\n        merged_mask_image = Image.fromarray(merged_mask)\n\n        return merged_mask\n\n\nclass ImageEditing:\n    template_model = True\n    def __init__(self, Text2Box:Text2Box, Segmenting:Segmenting, Inpainting:Inpainting):\n        print(f\"Initializing ImageEditing\")\n        self.sam = Segmenting\n        self.grounding = Text2Box\n        self.inpaint = Inpainting\n\n    def pad_edge(self,mask,padding):\n        #mask Tensor [H,W]\n        mask = mask.numpy()\n        true_indices = np.argwhere(mask)\n        mask_array = np.zeros_like(mask, dtype=bool)\n        for idx in true_indices:\n            padded_slice = tuple(slice(max(0, i - padding), i + padding + 1) for i in idx)\n            mask_array[padded_slice] = True\n        new_mask = (mask_array * 255).astype(np.uint8)\n        #new_mask\n        return new_mask\n\n    @prompts(name=\"Remove Something From The Photo\",\n             description=\"useful when you want to remove and object or something from the photo \"\n                         \"from its description or location. \"\n                         \"The input to this tool should be a comma separated string of two, \"\n                         \"representing the image_path and the object need to be removed. \")    \n    def inference_remove(self, inputs):\n        image_path, to_be_removed_txt = inputs.split(\",\")[0], ','.join(inputs.split(',')[1:])\n        return self.inference_replace_sam(f\"{image_path},{to_be_removed_txt},background\")\n\n    @prompts(name=\"Replace Something From The Photo\",\n            description=\"useful when you want to replace an object from the object description or \"\n                        \"location with another object from its description. \"\n                        \"The input to this tool should be a comma separated string of three, \"\n                        \"representing the image_path, the object to be replaced, the object to be replaced with \")\n    def inference_replace_sam(self,inputs):\n        image_path, to_be_replaced_txt, replace_with_txt = inputs.split(\",\")\n        \n        print(f\"image_path={image_path}, to_be_replaced_txt={to_be_replaced_txt}\")\n        image_pil, image = self.grounding.load_image(image_path)\n        boxes_filt, pred_phrases = self.grounding.get_grounding_boxes(image, to_be_replaced_txt)\n        image = cv2.imread(image_path)\n        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n        self.sam.sam_predictor.set_image(image)\n        masks = self.sam.get_mask_with_boxes(image_pil, image, boxes_filt)\n        mask = torch.sum(masks, dim=0).unsqueeze(0)\n        mask = torch.where(mask > 0, True, False)\n        mask = mask.squeeze(0).squeeze(0).cpu() #tensor\n\n        mask = self.pad_edge(mask,padding=20) #numpy\n        mask_image = Image.fromarray(mask)\n\n        updated_image = self.inpaint(prompt=replace_with_txt, image=image_pil,\n                                     mask_image=mask_image)\n        updated_image_path = get_new_image_name(image_path, func_name=\"replace-something\")\n        updated_image = updated_image.resize(image_pil.size)\n        updated_image.save(updated_image_path)\n        print(\n            f\"\\nProcessed ImageEditing, Input Image: {image_path}, Replace {to_be_replaced_txt} to {replace_with_txt}, \"\n            f\"Output Image: {updated_image_path}\")\n        return updated_image_path\n\nclass BackgroundRemoving:\n    '''\n        using to remove the background of the given picture\n    '''\n    template_model = True\n    def __init__(self,VisualQuestionAnswering:VisualQuestionAnswering, Text2Box:Text2Box, Segmenting:Segmenting):\n        self.vqa = VisualQuestionAnswering\n        self.obj_segmenting = ObjectSegmenting(Text2Box,Segmenting)\n\n    @prompts(name=\"Remove the background\",\n             description=\"useful when you want to extract the object or remove the background,\"\n                         \"the input should be a string image_path\"\n                                )\n    def inference(self, image_path):\n        '''\n            given a image, return the picture only contains the extracted main object\n        '''\n        updated_image_path = None\n\n        mask = self.get_mask(image_path)\n\n        image = Image.open(image_path)\n        mask = Image.fromarray(mask)\n        image.putalpha(mask)\n\n        updated_image_path = get_new_image_name(image_path, func_name=\"detect-something\")\n        image.save(updated_image_path)\n\n        return updated_image_path\n\n    def get_mask(self, image_path):\n        '''\n            Description:\n                given an image path, return the mask of the main object.\n            Args:\n                image_path (string): the file path of the image\n            Outputs:\n                mask (numpy.ndarray): H x W\n        '''\n        vqa_input = f\"{image_path}, what is the main object in the image?\"\n        text_prompt = self.vqa.inference(vqa_input)\n\n        mask = self.obj_segmenting.get_mask(image_path,text_prompt)\n\n        return mask\n\n\nclass ConversationBot:\n    def __init__(self, load_dict):\n        # load_dict = {'VisualQuestionAnswering':'cuda:0', 'ImageCaptioning':'cuda:1',...}\n        print(f\"Initializing VisualChatGPT, load_dict={load_dict}\")\n        if 'ImageCaptioning' not in load_dict:\n            raise ValueError(\"You have to load ImageCaptioning as a basic function for VisualChatGPT\")\n\n        self.models = {}\n        # Load Basic Foundation Models\n        for class_name, device in load_dict.items():\n            self.models[class_name] = globals()[class_name](device=device)\n\n        # Load Template Foundation Models\n        for class_name, module in globals().items():\n            if getattr(module, 'template_model', False):\n                template_required_names = {k for k in inspect.signature(module.__init__).parameters.keys() if k!='self'}\n                loaded_names = set([type(e).__name__ for e in self.models.values()])\n                if template_required_names.issubset(loaded_names):\n                    self.models[class_name] = globals()[class_name](\n                        **{name: self.models[name] for name in template_required_names})\n        \n        print(f\"All the Available Functions: {self.models}\")\n\n        self.tools = []\n        for instance in self.models.values():\n            for e in dir(instance):\n                if e.startswith('inference'):\n                    func = getattr(instance, e)\n                    self.tools.append(Tool(name=func.name, description=func.description, func=func))\n        self.llm = OpenAI(temperature=0)\n        self.memory = ConversationBufferMemory(memory_key=\"chat_history\", output_key='output')\n\n    def init_agent(self, lang):\n        self.memory.clear() #clear previous history\n        if lang=='English':\n            PREFIX, FORMAT_INSTRUCTIONS, SUFFIX = VISUAL_CHATGPT_PREFIX, VISUAL_CHATGPT_FORMAT_INSTRUCTIONS, VISUAL_CHATGPT_SUFFIX\n            place = \"Enter text and press enter, or upload an image\"\n            label_clear = \"Clear\"\n        else:\n            PREFIX, FORMAT_INSTRUCTIONS, SUFFIX = VISUAL_CHATGPT_PREFIX_CN, VISUAL_CHATGPT_FORMAT_INSTRUCTIONS_CN, VISUAL_CHATGPT_SUFFIX_CN\n            place = \"\u8f93\u5165\u6587\u5b57\u5e76\u56de\u8f66\uff0c\u6216\u8005\u4e0a\u4f20\u56fe\u7247\"\n            label_clear = \"\u6e05\u9664\"\n        self.agent = initialize_agent(\n            self.tools,\n            self.llm,\n            agent=\"conversational-react-description\",\n            verbose=True,\n            memory=self.memory,\n            return_intermediate_steps=True,\n            agent_kwargs={'prefix': PREFIX, 'format_instructions': FORMAT_INSTRUCTIONS,\n                          'suffix': SUFFIX}, )\n        return gr.update(visible = True), gr.update(visible = False), gr.update(placeholder=place), gr.update(value=label_clear)\n\n    def run_text(self, text, state):\n        self.agent.memory.buffer = cut_dialogue_history(self.agent.memory.buffer, keep_last_n_words=500)\n        res = self.agent({\"input\": text.strip()})\n        res['output'] = res['output'].replace(\"\\\\\", \"/\")\n        response = re.sub('(image/[-\\w]*.png)', lambda m: f'![](file={m.group(0)})*{m.group(0)}*', res['output'])\n        state = state + [(text, response)]\n        print(f\"\\nProcessed run_text, Input text: {text}\\nCurrent state: {state}\\n\"\n              f\"Current Memory: {self.agent.memory.buffer}\")\n        return state, state\n\n    def run_image(self, image, state, txt, lang):\n        image_filename = os.path.join('image', f\"{str(uuid.uuid4())[:8]}.png\")\n        print(\"======>Auto Resize Image...\")\n        img = Image.open(image.name)\n        width, height = img.size\n        ratio = min(512 / width, 512 / height)\n        width_new, height_new = (round(width * ratio), round(height * ratio))\n        width_new = int(np.round(width_new / 64.0)) * 64\n        height_new = int(np.round(height_new / 64.0)) * 64\n        img = img.resize((width_new, height_new))\n        img = img.convert('RGB')\n        img.save(image_filename, \"PNG\")\n        print(f\"Resize image form {width}x{height} to {width_new}x{height_new}\")\n        description = self.models['ImageCaptioning'].inference(image_filename)\n        if lang == 'Chinese':\n            Human_prompt = f'\\nHuman: \u63d0\u4f9b\u4e00\u5f20\u540d\u4e3a {image_filename}\u7684\u56fe\u7247\u3002\u5b83\u7684\u63cf\u8ff0\u662f: {description}\u3002 \u8fd9\u4e9b\u4fe1\u606f\u5e2e\u52a9\u4f60\u7406\u89e3\u8fd9\u4e2a\u56fe\u50cf\uff0c\u4f46\u662f\u4f60\u5e94\u8be5\u4f7f\u7528\u5de5\u5177\u6765\u5b8c\u6210\u4e0b\u9762\u7684\u4efb\u52a1\uff0c\u800c\u4e0d\u662f\u76f4\u63a5\u4ece\u6211\u7684\u63cf\u8ff0\u4e2d\u60f3\u8c61\u3002 \u5982\u679c\u4f60\u660e\u767d\u4e86, \u8bf4 \\\"\u6536\u5230\\\". \\n'\n            AI_prompt = \"\u6536\u5230\u3002  \"\n        else:\n            Human_prompt = f'\\nHuman: provide a figure named {image_filename}. The description is: {description}. This information helps you to understand this image, but you should use tools to finish following tasks, rather than directly imagine from my description. If you understand, say \\\"Received\\\". \\n'\n            AI_prompt = \"Received.  \"\n        self.agent.memory.buffer = self.agent.memory.buffer + Human_prompt + 'AI: ' + AI_prompt\n        state = state + [(f\"![](file={image_filename})*{image_filename}*\", AI_prompt)]\n        print(f\"\\nProcessed run_image, Input image: {image_filename}\\nCurrent state: {state}\\n\"\n              f\"Current Memory: {self.agent.memory.buffer}\")\n        return state, state, f'{txt} {image_filename} '\n\n\nif __name__ == '__main__':\n    if not os.path.exists(\"checkpoints\"):\n        os.mkdir(\"checkpoints\")\n    parser = argparse.ArgumentParser()\n    parser.add_argument('--load', type=str, default=\"ImageCaptioning_cuda:0,Text2Image_cuda:0\")\n    args = parser.parse_args()\n    load_dict = {e.split('_')[0].strip(): e.split('_')[1].strip() for e in args.load.split(',')}\n    bot = ConversationBot(load_dict=load_dict)\n    with gr.Blocks(css=\"#chatbot .overflow-y-auto{height:500px}\") as demo:\n        lang = gr.Radio(choices = ['Chinese','English'], value=None, label='Language')\n        chatbot = gr.Chatbot(elem_id=\"chatbot\", label=\"Visual ChatGPT\")\n        state = gr.State([])\n        with gr.Row(visible=False) as input_raws:\n            with gr.Column(scale=0.7):\n                txt = gr.Textbox(show_label=False, placeholder=\"Enter text and press enter, or upload an image\").style(\n                    container=False)\n            with gr.Column(scale=0.15, min_width=0):\n                clear = gr.Button(\"Clear\")\n            with gr.Column(scale=0.15, min_width=0):\n                btn = gr.UploadButton(label=\"\ud83d\uddbc\ufe0f\",file_types=[\"image\"])\n\n        lang.change(bot.init_agent, [lang], [input_raws, lang, txt, clear])\n        txt.submit(bot.run_text, [txt, state], [chatbot, state])\n        txt.submit(lambda: \"\", None, txt)\n        btn.upload(bot.run_image, [btn, state, txt, lang], [chatbot, state, txt])\n        clear.click(bot.memory.clear)\n        clear.click(lambda: [], None, chatbot)\n        clear.click(lambda: [], None, state)\n    demo.launch(server_name=\"0.0.0.0\", server_port=7861)\n", "LowCodeLLM/src/lowCodeLLM.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\nfrom planningLLM import planningLLM\nfrom executingLLM import executingLLM\nimport json\n\nclass lowCodeLLM:\n    def __init__(self, PLLM_temperature=0.4, ELLM_temperature=0):\n        self.PLLM = planningLLM(PLLM_temperature)\n        self.ELLM = executingLLM(ELLM_temperature)\n\n    def get_workflow(self, task_prompt):\n        return self.PLLM.get_workflow(task_prompt)\n\n    def extend_workflow(self, task_prompt, current_workflow, step=''):\n        ''' generate a sub-workflow for one of steps \n            - input: the current workflow, the step needs to extend\n            - output: sub-workflow '''\n        workflow = self._json2txt(current_workflow)\n        return self.PLLM.extend_workflow(task_prompt, workflow, step)\n\n    def execute(self, task_prompt,confirmed_workflow, history, curr_input):\n        ''' chat with the workflow-equipped low-code LLM '''\n        prompt = [{'role': 'system', \"content\": 'The overall task you are facing is: '+task_prompt+\n                '\\nThe standard operating procedure(SOP) is:\\n'+self._json2txt(confirmed_workflow)}]\n        history = prompt + history\n        response = self.ELLM.execute(curr_input, history)\n        return response\n    \n    def _json2txt(self, workflow_json):\n        ''' convert the json workflow to text'''\n        def json2text_step(step):\n            step_res = \"\"\n            step_res += step[\"stepId\"] + \": [\" + step[\"stepName\"] + \"]\"\n            step_res += \"[\" + step[\"stepDescription\"] + \"][\"\n            for jump in step[\"jumpLogic\"]:\n                step_res += \"[[\" + jump[\"Condition\"] + \"][\" + jump[\"Target\"] + \"]],\"\n            step_res += \"]\\n\"\n            return step_res\n\n        workflow_txt = \"\"\n        for step in json.loads(workflow_json):\n            workflow_txt += json2text_step(step)\n            for substep in step['extension']:\n                workflow_txt += json2text_step(substep)\n        return workflow_txt", "LowCodeLLM/src/executingLLM.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\nfrom openAIWrapper import OpenAIWrapper\n\nEXECUTING_LLM_PREFIX = \"\"\"Executing LLM is designed to provide outstanding responses.\nExecuting LLM will be given a overall task as the background of the conversation between the Executing LLM and human.\nWhen providing response, Executing LLM MUST STICTLY follow the provided standard operating procedure (SOP).\nthe SOP is formatted as:\n'''\nSTEP 1: [step name][step descriptions][[[if 'condition1'][Jump to STEP]], [[if 'condition2'][Jump to STEP]], ...]\n'''\nhere \"[[[if 'condition1'][Jump to STEP n]]]\" is judgmental logic. It means when you're performing this step, and if 'condition1' is satisfied, you will perform STEP n next.\n\nRemember: \nExecuting LLM is facing a real human, who does not know what SOP is. \nSo, Do not show him/her the SOP steps you are following, or it will make him/her confused. Just response the answer.\n\"\"\"\n\nEXECUTING_LLM_SUFFIX = \"\"\"\nRemember: \nExecuting LLM is facing a real human, who does not know what SOP is. \nSo, Do not show him/her the SOP steps you are following, or it will make him/her confused. Just response the answer.\n\"\"\"\n\nclass executingLLM:\n    def __init__(self, temperature) -> None:\n        self.prefix = EXECUTING_LLM_PREFIX\n        self.suffix = EXECUTING_LLM_SUFFIX\n        self.LLM = OpenAIWrapper(temperature)\n        self.messages = [{\"role\": \"system\", \"content\": \"You are a helpful assistant.\"},\n                         {\"role\": \"system\", \"content\": self.prefix}]\n\n    def execute(self, current_prompt, history):\n        ''' provide LLM the dialogue history and the current prompt to get response '''\n        messages = self.messages + history\n        messages.append({'role': 'user', \"content\": current_prompt + self.suffix})\n        response, status = self.LLM.run(messages)\n        if status:\n            return response\n        else:\n            return \"OpenAI API error.\"", "LowCodeLLM/src/app.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\nimport os\nfrom flask import Flask, request, send_from_directory\nfrom flask_cors import CORS, cross_origin\nfrom lowCodeLLM import lowCodeLLM\nfrom flask.logging import default_handler\nimport logging\n\napp = Flask('lowcode-llm', static_folder='', template_folder='')\napp.debug = True\nllm = lowCodeLLM()\ngunicorn_logger = logging.getLogger('gunicorn.error')\napp.logger = gunicorn_logger\nlogging_format = logging.Formatter(\n    '%(asctime)s - %(levelname)s - %(filename)s - %(funcName)s - %(lineno)s - %(message)s')\ndefault_handler.setFormatter(logging_format)\n\n@app.route(\"/\")\ndef index():\n    return send_from_directory(\".\", \"index.html\")\n\n@app.route('/api/get_workflow', methods=['POST'])\n@cross_origin()\ndef get_workflow():\n    try:\n        request_content = request.get_json()\n        task_prompt = request_content['task_prompt']\n        workflow = llm.get_workflow(task_prompt)\n        return workflow, 200\n    except Exception as e:\n        app.logger.error(\n            'failed to get_workflow, msg:%s, request data:%s' % (str(e), request.json))\n        return {'errmsg': 'internal errors'}, 500\n\n@app.route('/api/extend_workflow', methods=['POST'])\n@cross_origin()\ndef extend_workflow():\n    try:\n        request_content = request.get_json()\n        task_prompt = request_content['task_prompt']\n        current_workflow = request_content['current_workflow']\n        step = request_content['step']\n        sub_workflow = llm.extend_workflow(task_prompt, current_workflow, step)\n        return sub_workflow, 200\n    except Exception as e:\n        app.logger.error(\n            'failed to extend_workflow, msg:%s, request data:%s' % (str(e), request.json))\n        return {'errmsg': 'internal errors'}, 500\n\n@app.route('/api/execute', methods=['POST'])\n@cross_origin()\ndef execute():\n    try:\n        request_content = request.get_json()\n        task_prompt = request_content['task_prompt']\n        confirmed_workflow = request_content['confirmed_workflow']\n        curr_input = request_content['curr_input']\n        history = request_content['history']\n        response = llm.execute(task_prompt,confirmed_workflow, history, curr_input)\n        return response, 200\n    except Exception as e:\n        app.logger.error(\n            'failed to execute, msg:%s, request data:%s' % (str(e), request.json))\n        return {'errmsg': 'internal errors'}, 500\n", "LowCodeLLM/src/planningLLM.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\nimport re\nimport json\nfrom openAIWrapper import OpenAIWrapper\n\nPLANNING_LLM_PREFIX = \"\"\"Planning LLM is designed to provide a standard operating procedure so that an difficult task will be broken down into several steps, and the task will be easily solved by following these steps.\nPlanning LLM is a powerful problem-solving assistant, and it only needs to analyze the task and provide standard operating procedure as guidance, but does not need actually to solve the problem.\nSometimes there exists some unknown or undetermined situation, thus judgmental logic is needed: some \"conditions\" are listed, and the next step that should be carried out if a \"condition\" is satisfied is also listed. The judgmental logics are not necessary.\nPlanning LLM MUST only provide standard operating procedure in the following format without any other words:\n'''\nSTEP 1: [step name][step descriptions][[[if 'condition1'][Jump to STEP]], [[[if 'condition1'][Jump to STEP]], [[if 'condition2'][Jump to STEP]], ...]\nSTEP 2: [step name][step descriptions][[[if 'condition1'][Jump to STEP]], [[[if 'condition1'][Jump to STEP]], [[if 'condition2'][Jump to STEP]], ...]\n...\n'''\n\nFor example:\n'''\nSTEP 1: [Brainstorming][Choose a topic or prompt, and generate ideas and organize them into an outline][]\nSTEP 2: [Research][Gather information, take notes and organize them into the outline][[[lack of ideas][Jump to STEP 1]]]\n...\n'''\n\"\"\"\n\nEXTEND_PREFIX = \"\"\"\n\\nsome steps of the SOP provided by Planning LLM are too rough, so Planning LLM can also provide a detailed sub-SOP for the given step.\nRemember, Planning LLM take the overall SOP into consideration, and the sub-SOP MUST be consistent with the rest of the steps, and there MUST be no duplication in content between the extension and the original SOP.\n\nFor example:\nIf the overall SOP is:\n'''\nSTEP 1: [Brainstorming][Choose a topic or prompt, and generate ideas and organize them into an outline][]\nSTEP 2: [Write][write the text][]\n'''\nIf the STEP 2: \"write the text\" is too rough and needs to be extended, then the response could be:\n'''\nSTEP 2.1: [Write the title][write the title of the essay][]\nSTEP 2.2: [Write the body][write the body of the essay][[[if lack of materials][Jump to STEP 1]]]\n'''\n\"\"\"\n\nPLANNING_LLM_SUFFIX = \"\"\"\\nRemember: Planning LLM is very strict to the format and NEVER reply any word other than the standard operating procedure.\n\"\"\"\n\nclass planningLLM:\n    def __init__(self, temperature) -> None:\n        self.prefix = PLANNING_LLM_PREFIX\n        self.suffix = PLANNING_LLM_SUFFIX\n        self.LLM = OpenAIWrapper(temperature)\n        self.messages = [{\"role\": \"system\", \"content\": \"You are a helpful assistant.\"}]\n\n    def get_workflow(self, task_prompt):\n        '''\n        - input: task_prompt\n        - output: workflow (json)\n        '''\n        messages = self.messages + [{'role': 'user', \"content\": PLANNING_LLM_PREFIX+'\\nThe task is:\\n'+task_prompt+PLANNING_LLM_SUFFIX}]\n        response, status = self.LLM.run(messages)\n        if status:\n            return self._txt2json(response)\n        else:\n            return \"OpenAI API error.\"\n\n    def extend_workflow(self, task_prompt, current_workflow, step):\n        messages = self.messages + [{'role': 'user', \"content\": PLANNING_LLM_PREFIX+'\\nThe task is:\\n'+task_prompt+PLANNING_LLM_SUFFIX}]\n        messages.append({'role': 'user', \"content\": EXTEND_PREFIX+\n                         'The current SOP is:\\n'+current_workflow+\n                         '\\nThe step needs to be extended is:\\n'+step+\n                         PLANNING_LLM_SUFFIX})\n        response, status = self.LLM.run(messages)\n        if status:\n            return self._txt2json(response)\n        else:\n            return \"OpenAI API error.\"\n\n    def _txt2json(self, workflow_txt):\n        ''' convert the workflow in natural language to json format '''\n        workflow = []\n        try:\n            steps = workflow_txt.split('\\n')\n            for step in steps:\n                if step[0:4] != \"STEP\":\n                    continue\n                left_indices = [_.start() for _ in re.finditer(\"\\[\", step)]\n                right_indices = [_.start() for _ in re.finditer(\"\\]\", step)]\n                step_id = step[: left_indices[0]-2]\n                step_name = step[left_indices[0]+1: right_indices[0]]\n                step_description = step[left_indices[1]+1: right_indices[1]]\n                jump_str = step[left_indices[2]+1: right_indices[-1]]\n                if re.findall(re.compile(r'[A-Za-z]',re.S), jump_str) == []:\n                    workflow.append({\"stepId\": step_id, \"stepName\": step_name, \"stepDescription\": step_description, \"jumpLogic\": [], \"extension\": []})\n                    continue\n                jump_logic = []\n                left_indices = [_.start() for _ in re.finditer('\\[', jump_str)]\n                right_indices = [_.start() for _ in re.finditer('\\]', jump_str)]\n                i = 1\n                while i < len(left_indices):\n                    jump = {\"Condition\": jump_str[left_indices[i]+1: right_indices[i-1]], \"Target\": re.search(r'STEP\\s\\d', jump_str[left_indices[i+1]+1: right_indices[i]]).group(0)}\n                    jump_logic.append(jump)\n                    i += 3\n                workflow.append({\"stepId\": step_id, \"stepName\": step_name, \"stepDescription\": step_description, \"jumpLogic\": jump_logic, \"extension\": []})\n            return json.dumps(workflow)\n        except:\n            print(\"Format error, please try again.\")", "LowCodeLLM/src/openAIWrapper.py": "# Copyright (c) Microsoft Corporation.\n# Licensed under the MIT License.\n\nimport os\nimport openai\n\nclass OpenAIWrapper:\n    def __init__(self, temperature):\n        self.key = os.environ.get(\"OPENAIKEY\")\n        openai.api_key = self.key\n\n        # Access the USE_AZURE environment variable\n        self.use_azure = os.environ.get('USE_AZURE')\n\n        # Check if USE_AZURE is defined\n        if self.use_azure is not None:\n            # Convert the USE_AZURE value to boolean\n            self.use_azure = self.use_azure.lower() == 'true'\n        else:\n            self.use_azure = False\n\n        if self.use_azure:\n            openai.api_type = \"azure\"\n            self.api_base = os.environ.get('API_BASE')\n            openai.api_base = self.api_base\n            self.api_version = os.environ.get('API_VERSION')\n            openai.api_version = self.api_version\n            self.engine = os.environ.get('MODEL')\n        else:\n            self.chat_model_id = \"gpt-3.5-turbo\"\n            \n        self.temperature = temperature\n        self.max_tokens = 2048\n        self.top_p = 1\n        self.time_out = 7\n    \n    def run(self, prompt):\n        return self._post_request_chat(prompt)\n\n    def _post_request_chat(self, messages):\n        try:\n            if self.use_azure:\n                response = openai.ChatCompletion.create(\n                    engine=self.engine,\n                    messages=messages,\n                    temperature=self.temperature,\n                    max_tokens=self.max_tokens,\n                    frequency_penalty=0,\n                    presence_penalty=0\n                )\n            else:\n                response = openai.ChatCompletion.create(\n                    model=self.chat_model_id,\n                    messages=messages,\n                    temperature=self.temperature,\n                    max_tokens=self.max_tokens,\n                    frequency_penalty=0,\n                    presence_penalty=0\n                )\n            res = response['choices'][0]['message']['content']\n            return res, True\n        except Exception as e:\n            return \"\", False\n"}