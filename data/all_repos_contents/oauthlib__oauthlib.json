{"setup.py": "#!/usr/bin/env python3\n# Hack because logging + setuptools sucks.\nimport contextlib\nwith contextlib.suppress(ImportError):\n    import multiprocessing\n\n\nfrom os.path import dirname, join\n\nfrom setuptools import find_packages, setup\n\nimport oauthlib\n\n\ndef fread(fn):\n    with open(join(dirname(__file__), fn), 'r') as f:\n        return f.read()\n\n\nrsa_require = ['cryptography>=3.0.0']\nsignedtoken_require = ['cryptography>=3.0.0', 'pyjwt>=2.0.0,<3']\nsignals_require = ['blinker>=1.4.0']\n\nsetup(\n    name='oauthlib',\n    version=oauthlib.__version__,\n    description='A generic, spec-compliant, thorough implementation of the OAuth request-signing logic',\n    long_description=fread('README.rst'),\n    long_description_content_type='text/x-rst',\n    author='The OAuthlib Community',\n    author_email='idan@gazit.me',\n    maintainer='Ib Lundgren',\n    maintainer_email='ib.lundgren@gmail.com',\n    url='https://github.com/oauthlib/oauthlib',\n    platforms='any',\n    license='BSD-3-Clause',\n    packages=find_packages(exclude=('docs', 'tests', 'tests.*')),\n    python_requires='>=3.8',\n    extras_require={\n        'rsa': rsa_require,\n        'signedtoken': signedtoken_require,\n        'signals': signals_require,\n    },\n    classifiers=[\n        'Development Status :: 5 - Production/Stable',\n        'Environment :: Web Environment',\n        'Intended Audience :: Developers',\n        'License :: OSI Approved',\n        'License :: OSI Approved :: BSD License',\n        'Operating System :: MacOS',\n        'Operating System :: POSIX',\n        'Operating System :: POSIX :: Linux',\n        'Programming Language :: Python',\n        'Programming Language :: Python :: 3',\n        'Programming Language :: Python :: 3.8',\n        'Programming Language :: Python :: 3.9',\n        'Programming Language :: Python :: 3.10',\n        'Programming Language :: Python :: 3.11',\n        'Programming Language :: Python :: 3.12',\n        'Programming Language :: Python :: 3 :: Only',\n        'Programming Language :: Python :: Implementation',\n        'Programming Language :: Python :: Implementation :: CPython',\n        'Programming Language :: Python :: Implementation :: PyPy',\n        'Topic :: Software Development :: Libraries :: Python Modules',\n    ]\n)\n", "oauthlib/common.py": "\"\"\"\noauthlib.common\n~~~~~~~~~~~~~~\n\nThis module provides data structures and utilities common\nto all implementations of OAuth.\n\"\"\"\nimport collections\nimport datetime\nimport logging\nimport re\nimport time\nimport urllib.parse as urlparse\nfrom urllib.parse import (\n    quote as _quote, unquote as _unquote, urlencode as _urlencode,\n)\n\nfrom . import get_debug\n\ntry:\n    from secrets import SystemRandom, randbits\nexcept ImportError:\n    from random import SystemRandom, getrandbits as randbits\n\nUNICODE_ASCII_CHARACTER_SET = ('abcdefghijklmnopqrstuvwxyz'\n                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                               '0123456789')\n\nCLIENT_ID_CHARACTER_SET = (r' !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMN'\n                           'OPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}')\n\nSANITIZE_PATTERN = re.compile(r'([^&;]*(?:password|token)[^=]*=)[^&;]+', re.IGNORECASE)\nINVALID_HEX_PATTERN = re.compile(r'%[^0-9A-Fa-f]|%[0-9A-Fa-f][^0-9A-Fa-f]')\n\nalways_safe = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n               'abcdefghijklmnopqrstuvwxyz'\n               '0123456789_.-')\n\nlog = logging.getLogger('oauthlib')\n\n\n# 'safe' must be bytes (Python 2.6 requires bytes, other versions allow either)\ndef quote(s, safe=b'/'):\n    s = s.encode('utf-8') if isinstance(s, str) else s\n    s = _quote(s, safe)\n    # PY3 always returns unicode.  PY2 may return either, depending on whether\n    # it had to modify the string.\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    return s\n\n\ndef unquote(s):\n    s = _unquote(s)\n    # PY3 always returns unicode.  PY2 seems to always return what you give it,\n    # which differs from quote's behavior.  Just to be safe, make sure it is\n    # unicode before we return.\n    if isinstance(s, bytes):\n        s = s.decode('utf-8')\n    return s\n\n\ndef urlencode(params):\n    utf8_params = encode_params_utf8(params)\n    urlencoded = _urlencode(utf8_params)\n    if isinstance(urlencoded, str):\n        return urlencoded\n    else:\n        return urlencoded.decode(\"utf-8\")\n\n\ndef encode_params_utf8(params):\n    \"\"\"Ensures that all parameters in a list of 2-element tuples are encoded to\n    bytestrings using UTF-8\n    \"\"\"\n    encoded = []\n    for k, v in params:\n        encoded.append((\n            k.encode('utf-8') if isinstance(k, str) else k,\n            v.encode('utf-8') if isinstance(v, str) else v))\n    return encoded\n\n\ndef decode_params_utf8(params):\n    \"\"\"Ensures that all parameters in a list of 2-element tuples are decoded to\n    unicode using UTF-8.\n    \"\"\"\n    decoded = []\n    for k, v in params:\n        decoded.append((\n            k.decode('utf-8') if isinstance(k, bytes) else k,\n            v.decode('utf-8') if isinstance(v, bytes) else v))\n    return decoded\n\n\nurlencoded = set(always_safe) | set('=&;:%+~,*@!()/?\\'$')\n\n\ndef urldecode(query):\n    \"\"\"Decode a query string in x-www-form-urlencoded format into a sequence\n    of two-element tuples.\n\n    Unlike urlparse.parse_qsl(..., strict_parsing=True) urldecode will enforce\n    correct formatting of the query string by validation. If validation fails\n    a ValueError will be raised. urllib.parse_qsl will only raise errors if\n    any of name-value pairs omits the equals sign.\n    \"\"\"\n    # Check if query contains invalid characters\n    if query and not set(query) <= urlencoded:\n        error = (\"Error trying to decode a non urlencoded string. \"\n                 \"Found invalid characters: %s \"\n                 \"in the string: '%s'. \"\n                 \"Please ensure the request/response body is \"\n                 \"x-www-form-urlencoded.\")\n        raise ValueError(error % (set(query) - urlencoded, query))\n\n    # Check for correctly hex encoded values using a regular expression\n    # All encoded values begin with % followed by two hex characters\n    # correct = %00, %A0, %0A, %FF\n    # invalid = %G0, %5H, %PO\n    if INVALID_HEX_PATTERN.search(query):\n        raise ValueError('Invalid hex encoding in query string.')\n\n    # We want to allow queries such as \"c2\" whereas urlparse.parse_qsl\n    # with the strict_parsing flag will not.\n    params = urlparse.parse_qsl(query, keep_blank_values=True)\n\n    # unicode all the things\n    return decode_params_utf8(params)\n\n\ndef extract_params(raw):\n    \"\"\"Extract parameters and return them as a list of 2-tuples.\n\n    Will successfully extract parameters from urlencoded query strings,\n    dicts, or lists of 2-tuples. Empty strings/dicts/lists will return an\n    empty list of parameters. Any other input will result in a return\n    value of None.\n    \"\"\"\n    if isinstance(raw, (bytes, str)):\n        try:\n            params = urldecode(raw)\n        except ValueError:\n            params = None\n    elif hasattr(raw, '__iter__'):\n        try:\n            dict(raw)\n        except ValueError:\n            params = None\n        except TypeError:\n            params = None\n        else:\n            params = list(raw.items() if isinstance(raw, dict) else raw)\n            params = decode_params_utf8(params)\n    else:\n        params = None\n\n    return params\n\n\ndef generate_nonce():\n    \"\"\"Generate pseudorandom nonce that is unlikely to repeat.\n\n    Per `section 3.3`_ of the OAuth 1 RFC 5849 spec.\n    Per `section 3.2.1`_ of the MAC Access Authentication spec.\n\n    A random 64-bit number is appended to the epoch timestamp for both\n    randomness and to decrease the likelihood of collisions.\n\n    .. _`section 3.2.1`: https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.2.1\n    .. _`section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3\n    \"\"\"\n    return str(str(randbits(64)) + generate_timestamp())\n\n\ndef generate_timestamp():\n    \"\"\"Get seconds since epoch (UTC).\n\n    Per `section 3.3`_ of the OAuth 1 RFC 5849 spec.\n    Per `section 3.2.1`_ of the MAC Access Authentication spec.\n\n    .. _`section 3.2.1`: https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-3.2.1\n    .. _`section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3\n    \"\"\"\n    return str(int(time.time()))\n\n\ndef generate_token(length=30, chars=UNICODE_ASCII_CHARACTER_SET):\n    \"\"\"Generates a non-guessable OAuth token\n\n    OAuth (1 and 2) does not specify the format of tokens except that they\n    should be strings of random characters. Tokens should not be guessable\n    and entropy when generating the random characters is important. Which is\n    why SystemRandom is used instead of the default random.choice method.\n    \"\"\"\n    rand = SystemRandom()\n    return ''.join(rand.choice(chars) for x in range(length))\n\n\ndef generate_signed_token(private_pem, request):\n    import jwt\n\n    now = datetime.datetime.utcnow()\n\n    claims = {\n        'scope': request.scope,\n        'exp': now + datetime.timedelta(seconds=request.expires_in)\n    }\n\n    claims.update(request.claims)\n\n    token = jwt.encode(claims, private_pem, 'RS256')\n    token = to_unicode(token, \"UTF-8\")\n\n    return token\n\n\ndef verify_signed_token(public_pem, token):\n    import jwt\n\n    return jwt.decode(token, public_pem, algorithms=['RS256'])\n\n\ndef generate_client_id(length=30, chars=CLIENT_ID_CHARACTER_SET):\n    \"\"\"Generates an OAuth client_id\n\n    OAuth 2 specify the format of client_id in\n    https://tools.ietf.org/html/rfc6749#appendix-A.\n    \"\"\"\n    return generate_token(length, chars)\n\n\ndef add_params_to_qs(query, params):\n    \"\"\"Extend a query with a list of two-tuples.\"\"\"\n    if isinstance(params, dict):\n        params = params.items()\n    queryparams = urlparse.parse_qsl(query, keep_blank_values=True)\n    queryparams.extend(params)\n    return urlencode(queryparams)\n\n\ndef add_params_to_uri(uri, params, fragment=False):\n    \"\"\"Add a list of two-tuples to the uri query components.\"\"\"\n    sch, net, path, par, query, fra = urlparse.urlparse(uri)\n    if fragment:\n        fra = add_params_to_qs(fra, params)\n    else:\n        query = add_params_to_qs(query, params)\n    return urlparse.urlunparse((sch, net, path, par, query, fra))\n\n\ndef safe_string_equals(a, b):\n    \"\"\" Near-constant time string comparison.\n\n    Used in order to avoid timing attacks on sensitive information such\n    as secret keys during request verification (`rootLabs`_).\n\n    .. _`rootLabs`: http://rdist.root.org/2010/01/07/timing-independent-array-comparison/\n\n    \"\"\"\n    if len(a) != len(b):\n        return False\n\n    result = 0\n    for x, y in zip(a, b):\n        result |= ord(x) ^ ord(y)\n    return result == 0\n\n\ndef to_unicode(data, encoding='UTF-8'):\n    \"\"\"Convert a number of different types of objects to unicode.\"\"\"\n    if isinstance(data, str):\n        return data\n\n    if isinstance(data, bytes):\n        return str(data, encoding=encoding)\n\n    if hasattr(data, '__iter__'):\n        try:\n            dict(data)\n        except TypeError:\n            pass\n        except ValueError:\n            # Assume it's a one dimensional data structure\n            return (to_unicode(i, encoding) for i in data)\n        else:\n            # We support 2.6 which lacks dict comprehensions\n            if hasattr(data, 'items'):\n                data = data.items()\n            return {to_unicode(k, encoding): to_unicode(v, encoding) for k, v in data}\n\n    return data\n\n\nclass CaseInsensitiveDict(dict):\n\n    \"\"\"Basic case insensitive dict with strings only keys.\"\"\"\n\n    proxy = {}\n\n    def __init__(self, data):\n        self.proxy = {k.lower(): k for k in data}\n        for k in data:\n            self[k] = data[k]\n\n    def __contains__(self, k):\n        return k.lower() in self.proxy\n\n    def __delitem__(self, k):\n        key = self.proxy[k.lower()]\n        super().__delitem__(key)\n        del self.proxy[k.lower()]\n\n    def __getitem__(self, k):\n        key = self.proxy[k.lower()]\n        return super().__getitem__(key)\n\n    def get(self, k, default=None):\n        return self[k] if k in self else default\n\n    def __setitem__(self, k, v):\n        super().__setitem__(k, v)\n        self.proxy[k.lower()] = k\n\n    def update(self, *args, **kwargs):\n        super().update(*args, **kwargs)\n        for k in dict(*args, **kwargs):\n            self.proxy[k.lower()] = k\n\n\nclass Request:\n\n    \"\"\"A malleable representation of a signable HTTP request.\n\n    Body argument may contain any data, but parameters will only be decoded if\n    they are one of:\n\n    * urlencoded query string\n    * dict\n    * list of 2-tuples\n\n    Anything else will be treated as raw body data to be passed through\n    unmolested.\n    \"\"\"\n\n    def __init__(self, uri, http_method='GET', body=None, headers=None,\n                 encoding='utf-8'):\n        # Convert to unicode using encoding if given, else assume unicode\n        def encode(x):\n            return to_unicode(x, encoding) if encoding else x\n\n        self.uri = encode(uri)\n        self.http_method = encode(http_method)\n        self.headers = CaseInsensitiveDict(encode(headers or {}))\n        self.body = encode(body)\n        self.decoded_body = extract_params(self.body)\n        self.oauth_params = []\n        self.validator_log = {}\n\n        self._params = {\n            \"access_token\": None,\n            \"client\": None,\n            \"client_id\": None,\n            \"client_secret\": None,\n            \"code\": None,\n            \"code_challenge\": None,\n            \"code_challenge_method\": None,\n            \"code_verifier\": None,\n            \"extra_credentials\": None,\n            \"grant_type\": None,\n            \"redirect_uri\": None,\n            \"refresh_token\": None,\n            \"request_token\": None,\n            \"response_type\": None,\n            \"scope\": None,\n            \"scopes\": None,\n            \"state\": None,\n            \"token\": None,\n            \"user\": None,\n            \"token_type_hint\": None,\n\n            # OpenID Connect\n            \"response_mode\": None,\n            \"nonce\": None,\n            \"display\": None,\n            \"prompt\": None,\n            \"claims\": None,\n            \"max_age\": None,\n            \"ui_locales\": None,\n            \"id_token_hint\": None,\n            \"login_hint\": None,\n            \"acr_values\": None\n        }\n        self._params.update(dict(urldecode(self.uri_query)))\n        self._params.update(dict(self.decoded_body or []))\n\n    def __getattr__(self, name):\n        if name in self._params:\n            return self._params[name]\n        else:\n            raise AttributeError(name)\n\n    def __repr__(self):\n        if not get_debug():\n            return \"<oauthlib.Request SANITIZED>\"\n        body = self.body\n        headers = self.headers.copy()\n        if body:\n            body = SANITIZE_PATTERN.sub('\\1<SANITIZED>', str(body))\n        if 'Authorization' in headers:\n            headers['Authorization'] = '<SANITIZED>'\n        return '<oauthlib.Request url=\"{}\", http_method=\"{}\", headers=\"{}\", body=\"{}\">'.format(\n            self.uri, self.http_method, headers, body)\n\n    @property\n    def uri_query(self):\n        return urlparse.urlparse(self.uri).query\n\n    @property\n    def uri_query_params(self):\n        if not self.uri_query:\n            return []\n        return urlparse.parse_qsl(self.uri_query, keep_blank_values=True,\n                                  strict_parsing=True)\n\n    @property\n    def duplicate_params(self):\n        seen_keys = collections.defaultdict(int)\n        all_keys = (p[0]\n                    for p in (self.decoded_body or []) + self.uri_query_params)\n        for k in all_keys:\n            seen_keys[k] += 1\n        return [k for k, c in seen_keys.items() if c > 1]\n", "oauthlib/signals.py": "\"\"\"\n    Implements signals based on blinker if available, otherwise\n    falls silently back to a noop. Shamelessly stolen from flask.signals:\n    https://github.com/mitsuhiko/flask/blob/master/flask/signals.py\n\"\"\"\nsignals_available = False\ntry:\n    from blinker import Namespace\n    signals_available = True\nexcept ImportError:\n    class Namespace:\n        def signal(self, name, doc=None):\n            return _FakeSignal(name, doc)\n\n    class _FakeSignal:\n        \"\"\"If blinker is unavailable, create a fake class with the same\n        interface that allows sending of signals but will fail with an\n        error on anything else.  Instead of doing anything on send, it\n        will just ignore the arguments and do nothing instead.\n        \"\"\"\n\n        def __init__(self, name, doc=None):\n            self.name = name\n            self.__doc__ = doc\n        def _fail(self, *args, **kwargs):\n            raise RuntimeError('signalling support is unavailable '\n                               'because the blinker library is '\n                               'not installed.')\n        def send(*a, **kw):\n            return None\n        connect = disconnect = has_receivers_for = receivers_for = \\\n            temporarily_connected_to = connected_to = _fail\n        del _fail\n\n# The namespace for code signals.  If you are not oauthlib code, do\n# not put signals in here.  Create your own namespace instead.\n_signals = Namespace()\n\n\n# Core signals.\nscope_changed = _signals.signal('scope-changed')\n", "oauthlib/uri_validate.py": "\"\"\"\nRegex for URIs\n\nThese regex are directly derived from the collected ABNF in RFC3986\n(except for DIGIT, ALPHA and HEXDIG, defined by RFC2234).\n\nThey should be processed with re.VERBOSE.\n\nThanks Mark Nottingham for this code - https://gist.github.com/138549\n\"\"\"\nimport re\n\n# basics\n\nDIGIT = r\"[\\x30-\\x39]\"\n\nALPHA = r\"[\\x41-\\x5A\\x61-\\x7A]\"\n\nHEXDIG = r\"[\\x30-\\x39A-Fa-f]\"\n\n#   pct-encoded   = \"%\" HEXDIG HEXDIG\npct_encoded = r\" %% %(HEXDIG)s %(HEXDIG)s\" % locals()\n\n#   unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\nunreserved = r\"(?: %(ALPHA)s | %(DIGIT)s | \\- | \\. | _ | ~ )\" % locals()\n\n# gen-delims    = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\ngen_delims = r\"(?: : | / | \\? | \\# | \\[ | \\] | @ )\"\n\n#   sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n#                 / \"*\" / \"+\" / \",\" / \";\" / \"=\"\nsub_delims = r\"\"\"(?: ! | \\$ | & | ' | \\( | \\) |\n                     \\* | \\+ | , | ; | = )\"\"\"\n\n#   pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\npchar = r\"(?: %(unreserved)s | %(pct_encoded)s | %(sub_delims)s | : | @ )\" % locals(\n)\n\n#   reserved      = gen-delims / sub-delims\nreserved = r\"(?: %(gen_delims)s | %(sub_delims)s )\" % locals()\n\n\n# scheme\n\n#   scheme        = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\nscheme = r\"%(ALPHA)s (?: %(ALPHA)s | %(DIGIT)s | \\+ | \\- | \\. )*\" % locals()\n\n\n# authority\n\n#   dec-octet     = DIGIT                 ; 0-9\n#                 / %x31-39 DIGIT         ; 10-99\n#                 / \"1\" 2DIGIT            ; 100-199\n#                 / \"2\" %x30-34 DIGIT     ; 200-249\n#                 / \"25\" %x30-35          ; 250-255\ndec_octet = r\"\"\"(?: %(DIGIT)s |\n                    [\\x31-\\x39] %(DIGIT)s |\n                    1 %(DIGIT)s{2} |\n                    2 [\\x30-\\x34] %(DIGIT)s |\n                    25 [\\x30-\\x35]\n                )\n\"\"\" % locals()\n\n#  IPv4address   = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\nIPv4address = r\"%(dec_octet)s \\. %(dec_octet)s \\. %(dec_octet)s \\. %(dec_octet)s\" % locals(\n)\n\n#   IPv6address\nIPv6address = r\"([A-Fa-f0-9:]+[:$])[A-Fa-f0-9]{1,4}\"\n\n#   IPvFuture     = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\nIPvFuture = r\"v %(HEXDIG)s+ \\. (?: %(unreserved)s | %(sub_delims)s | : )+\" % locals()\n\n#   IP-literal    = \"[\" ( IPv6address / IPvFuture  ) \"]\"\nIP_literal = r\"\\[ (?: %(IPv6address)s | %(IPvFuture)s ) \\]\" % locals()\n\n#   reg-name      = *( unreserved / pct-encoded / sub-delims )\nreg_name = r\"(?: %(unreserved)s | %(pct_encoded)s | %(sub_delims)s )*\" % locals()\n\n#   userinfo      = *( unreserved / pct-encoded / sub-delims / \":\" )\nuserinfo = r\"(?: %(unreserved)s | %(pct_encoded)s | %(sub_delims)s | : )\" % locals(\n)\n\n#   host          = IP-literal / IPv4address / reg-name\nhost = r\"(?: %(IP_literal)s | %(IPv4address)s | %(reg_name)s )\" % locals()\n\n#   port          = *DIGIT\nport = r\"(?: %(DIGIT)s )*\" % locals()\n\n#   authority     = [ userinfo \"@\" ] host [ \":\" port ]\nauthority = r\"(?: %(userinfo)s @)? %(host)s (?: : %(port)s)?\" % locals()\n\n# Path\n\n#   segment       = *pchar\nsegment = r\"%(pchar)s*\" % locals()\n\n#   segment-nz    = 1*pchar\nsegment_nz = r\"%(pchar)s+\" % locals()\n\n#   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n#                 ; non-zero-length segment without any colon \":\"\nsegment_nz_nc = r\"(?: %(unreserved)s | %(pct_encoded)s | %(sub_delims)s | @ )+\" % locals()\n\n#   path-abempty  = *( \"/\" segment )\npath_abempty = r\"(?: / %(segment)s )*\" % locals()\n\n#   path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\npath_absolute = r\"/ (?: %(segment_nz)s (?: / %(segment)s )* )?\" % locals()\n\n#   path-noscheme = segment-nz-nc *( \"/\" segment )\npath_noscheme = r\"%(segment_nz_nc)s (?: / %(segment)s )*\" % locals()\n\n#   path-rootless = segment-nz *( \"/\" segment )\npath_rootless = r\"%(segment_nz)s (?: / %(segment)s )*\" % locals()\n\n#   path-empty    = 0<pchar>\npath_empty = r\"\"  # FIXME\n\n#   path          = path-abempty    ; begins with \"/\" or is empty\n#                 / path-absolute   ; begins with \"/\" but not \"//\"\n#                 / path-noscheme   ; begins with a non-colon segment\n#                 / path-rootless   ; begins with a segment\n#                 / path-empty      ; zero characters\npath = r\"\"\"(?: %(path_abempty)s |\n               %(path_absolute)s |\n               %(path_noscheme)s |\n               %(path_rootless)s |\n               %(path_empty)s\n            )\n\"\"\" % locals()\n\n### Query and Fragment\n\n#   query         = *( pchar / \"/\" / \"?\" )\nquery = r\"(?: %(pchar)s | / | \\? )*\" % locals()\n\n#   fragment      = *( pchar / \"/\" / \"?\" )\nfragment = r\"(?: %(pchar)s | / | \\? )*\" % locals()\n\n# URIs\n\n#   hier-part     = \"//\" authority path-abempty\n#                 / path-absolute\n#                 / path-rootless\n#                 / path-empty\nhier_part = r\"\"\"(?: (?: // %(authority)s %(path_abempty)s ) |\n                    %(path_absolute)s |\n                    %(path_rootless)s |\n                    %(path_empty)s\n                )\n\"\"\" % locals()\n\n#   relative-part = \"//\" authority path-abempty\n#                 / path-absolute\n#                 / path-noscheme\n#                 / path-empty\nrelative_part = r\"\"\"(?: (?: // %(authority)s %(path_abempty)s ) |\n                        %(path_absolute)s |\n                        %(path_noscheme)s |\n                        %(path_empty)s\n                    )\n\"\"\" % locals()\n\n# relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\nrelative_ref = r\"%(relative_part)s (?: \\? %(query)s)? (?: \\# %(fragment)s)?\" % locals(\n)\n\n# URI           = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\nURI = r\"^(?: %(scheme)s : %(hier_part)s (?: \\? %(query)s )? (?: \\# %(fragment)s )? )$\" % locals(\n)\n\n#   URI-reference = URI / relative-ref\nURI_reference = r\"^(?: %(URI)s | %(relative_ref)s )$\" % locals()\n\n#   absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\nabsolute_URI = r\"^(?: %(scheme)s : %(hier_part)s (?: \\? %(query)s )? )$\" % locals()  # noqa: N816\n\n\ndef is_uri(uri):\n    return re.match(URI, uri, re.VERBOSE)\n\n\ndef is_uri_reference(uri):\n    return re.match(URI_reference, uri, re.VERBOSE)\n\n\ndef is_absolute_uri(uri):\n    return re.match(absolute_URI, uri, re.VERBOSE)\n", "oauthlib/__init__.py": "\"\"\"\n    oauthlib\n    ~~~~~~~~\n\n    A generic, spec-compliant, thorough implementation of the OAuth\n    request-signing logic.\n\n    :copyright: (c) 2019 by The OAuthlib Community\n    :license: BSD, see LICENSE for details.\n\"\"\"\nimport logging\nfrom logging import NullHandler\n\n__author__ = 'The OAuthlib Community'\n__version__ = '3.2.2'\n\nlogging.getLogger('oauthlib').addHandler(NullHandler())\n\n_DEBUG = False\n\ndef set_debug(debug_val):\n    \"\"\"Set value of debug flag\n\n    :param debug_val: Value to set. Must be a bool value.\n    \"\"\"\n    global _DEBUG  # noqa: PLW0603\n    _DEBUG = debug_val\n\ndef get_debug():\n    \"\"\"Get debug mode value.\n\n    :return: `True` if debug mode is on, `False` otherwise\n    \"\"\"\n    return _DEBUG\n", "oauthlib/oauth2/__init__.py": "\"\"\"\noauthlib.oauth2\n~~~~~~~~~~~~~~\n\nThis module is a wrapper for the most recent implementation of OAuth 2.0 Client\nand Server classes.\n\"\"\"\nfrom .rfc6749.clients import (\n    BackendApplicationClient, Client, LegacyApplicationClient,\n    MobileApplicationClient, ServiceApplicationClient, WebApplicationClient,\n)\nfrom .rfc6749.endpoints import (\n    AuthorizationEndpoint, BackendApplicationServer, IntrospectEndpoint,\n    LegacyApplicationServer, MetadataEndpoint, MobileApplicationServer,\n    ResourceEndpoint, RevocationEndpoint, Server, TokenEndpoint,\n    WebApplicationServer,\n)\nfrom .rfc6749.errors import (\n    AccessDeniedError, FatalClientError, InsecureTransportError,\n    InvalidClientError, InvalidClientIdError, InvalidGrantError,\n    InvalidRedirectURIError, InvalidRequestError, InvalidRequestFatalError,\n    InvalidScopeError, MismatchingRedirectURIError, MismatchingStateError,\n    MissingClientIdError, MissingCodeError, MissingRedirectURIError,\n    MissingResponseTypeError, MissingTokenError, MissingTokenTypeError,\n    OAuth2Error, ServerError, TemporarilyUnavailableError, TokenExpiredError,\n    UnauthorizedClientError, UnsupportedGrantTypeError,\n    UnsupportedResponseTypeError, UnsupportedTokenTypeError,\n)\nfrom .rfc6749.grant_types import (\n    AuthorizationCodeGrant, ClientCredentialsGrant, ImplicitGrant,\n    RefreshTokenGrant, ResourceOwnerPasswordCredentialsGrant,\n)\nfrom .rfc6749.request_validator import RequestValidator\nfrom .rfc6749.tokens import BearerToken, OAuth2Token\nfrom .rfc6749.utils import is_secure_transport\nfrom .rfc8628.clients import DeviceClient\n", "oauthlib/oauth2/rfc8628/__init__.py": "\"\"\"\noauthlib.oauth2.rfc8628\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 Device Authorization RFC8628.\n\"\"\"\nimport logging\n\nlog = logging.getLogger(__name__)\n", "oauthlib/oauth2/rfc8628/clients/device.py": "\"\"\"\noauthlib.oauth2.rfc8628\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 Device Authorization RFC8628.\n\"\"\"\nfrom oauthlib.common import add_params_to_uri\nfrom oauthlib.oauth2 import BackendApplicationClient, Client\nfrom oauthlib.oauth2.rfc6749.errors import InsecureTransportError\nfrom oauthlib.oauth2.rfc6749.parameters import prepare_token_request\nfrom oauthlib.oauth2.rfc6749.utils import is_secure_transport, list_to_scope\n\n\nclass DeviceClient(Client):\n\n    \"\"\"A public client utilizing the device authorization workflow.\n\n    The client can request an access token using a device code and\n    a public client id associated with the device code as defined\n    in RFC8628.\n\n    The device authorization grant type can be used to obtain both\n    access tokens and refresh tokens and is intended to be used in\n    a scenario where the device being authorized does not have a\n    user interface that is suitable for performing authentication.\n    \"\"\"\n\n    grant_type = 'urn:ietf:params:oauth:grant-type:device_code'\n\n    def __init__(self, client_id, **kwargs):\n        super().__init__(client_id, **kwargs)\n        self.client_secret = kwargs.get('client_secret')\n\n    def prepare_request_uri(self, uri, scope=None, **kwargs):\n        if not is_secure_transport(uri):\n            raise InsecureTransportError()\n\n        scope = self.scope if scope is None else scope\n        params = [(('client_id', self.client_id)), (('grant_type', self.grant_type))]\n\n        if self.client_secret is not None:\n            params.append(('client_secret', self.client_secret))\n\n        if scope:\n            params.append(('scope', list_to_scope(scope)))\n\n        for k in kwargs:\n            if kwargs[k]:\n                params.append((str(k), kwargs[k]))\n\n        return add_params_to_uri(uri, params)\n\n    def prepare_request_body(self, device_code, body='', scope=None,\n                             include_client_id=False, **kwargs):\n        \"\"\"Add device_code to request body\n\n        The client makes a request to the token endpoint by adding the\n        device_code as a parameter using the\n        \"application/x-www-form-urlencoded\" format to the HTTP request\n        body.\n\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n        :param scope:   The scope of the access request as described by\n                        `Section 3.3`_.\n\n        :param include_client_id: `True` to send the `client_id` in the\n                                  body of the upstream request. This is required\n                                  if the client is not authenticating with the\n                                  authorization server as described in\n                                  `Section 3.2.1`_. False otherwise (default).\n        :type include_client_id: Boolean\n\n        :param kwargs:  Extra credentials to include in the token request.\n\n        The prepared body will include all provided device_code as well as\n        the ``grant_type`` parameter set to\n        ``urn:ietf:params:oauth:grant-type:device_code``::\n\n            >>> from oauthlib.oauth2 import DeviceClient\n            >>> client = DeviceClient('your_id', 'your_code')\n            >>> client.prepare_request_body(scope=['hello', 'world'])\n            'grant_type=urn:ietf:params:oauth:grant-type:device_code&scope=hello+world'\n\n        .. _`Section 3.2.1`: https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1\n        .. _`Section 3.3`: https://datatracker.ietf.org/doc/html/rfc6749#section-3.3\n        .. _`Section 3.4`: https://datatracker.ietf.org/doc/html/rfc8628#section-3.4\n        \"\"\"\n\n        kwargs['client_id'] = self.client_id\n        kwargs['include_client_id'] = include_client_id\n        scope = self.scope if scope is None else scope\n        return prepare_token_request(self.grant_type, body=body, device_code=device_code,\n                                     scope=scope, **kwargs)\n", "oauthlib/oauth2/rfc8628/clients/__init__.py": "\"\"\"\noauthlib.oauth2.rfc8628\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming OAuth 2.0 Device Authorization RFC8628.\n\"\"\"\nfrom .device import DeviceClient\n", "oauthlib/oauth2/rfc6749/tokens.py": "\"\"\"\noauthlib.oauth2.rfc6749.tokens\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains methods for adding two types of access tokens to requests.\n\n- Bearer https://tools.ietf.org/html/rfc6750\n- MAC https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01\n\"\"\"\nimport hashlib\nimport hmac\nimport warnings\nfrom binascii import b2a_base64\nfrom urllib.parse import urlparse\n\nfrom oauthlib import common\nfrom oauthlib.common import add_params_to_qs, add_params_to_uri\n\nfrom . import utils\n\n\nclass OAuth2Token(dict):\n\n    def __init__(self, params, old_scope=None):\n        super().__init__(params)\n        self._new_scope = None\n        if 'scope' in params and params['scope']:\n            self._new_scope = set(utils.scope_to_list(params['scope']))\n        if old_scope is not None:\n            self._old_scope = set(utils.scope_to_list(old_scope))\n            if self._new_scope is None:\n                # the rfc says that if the scope hasn't changed, it's optional\n                # in params so set the new scope to the old scope\n                self._new_scope = self._old_scope\n        else:\n            self._old_scope = self._new_scope\n\n    @property\n    def scope_changed(self):\n        return self._new_scope != self._old_scope\n\n    @property\n    def old_scope(self):\n        return utils.list_to_scope(self._old_scope)\n\n    @property\n    def old_scopes(self):\n        return list(self._old_scope)\n\n    @property\n    def scope(self):\n        return utils.list_to_scope(self._new_scope)\n\n    @property\n    def scopes(self):\n        return list(self._new_scope)\n\n    @property\n    def missing_scopes(self):\n        return list(self._old_scope - self._new_scope)\n\n    @property\n    def additional_scopes(self):\n        return list(self._new_scope - self._old_scope)\n\n\ndef prepare_mac_header(token, uri, key, http_method,\n                       nonce=None,\n                       headers=None,\n                       body=None,\n                       ext='',\n                       hash_algorithm='hmac-sha-1',\n                       issue_time=None,\n                       draft=0):\n    \"\"\"Add an `MAC Access Authentication`_ signature to headers.\n\n    Unlike OAuth 1, this HMAC signature does not require inclusion of the\n    request payload/body, neither does it use a combination of client_secret\n    and token_secret but rather a mac_key provided together with the access\n    token.\n\n    Currently two algorithms are supported, \"hmac-sha-1\" and \"hmac-sha-256\",\n    `extension algorithms`_ are not supported.\n\n    Example MAC Authorization header, linebreaks added for clarity\n\n    Authorization: MAC id=\"h480djs93hd8\",\n                       nonce=\"1336363200:dj83hs9s\",\n                       mac=\"bhCQXTVyfj5cmA9uKkPFx1zeOXM=\"\n\n    .. _`MAC Access Authentication`: https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01\n    .. _`extension algorithms`: https://tools.ietf.org/html/draft-ietf-oauth-v2-http-mac-01#section-7.1\n\n    :param token:\n    :param uri: Request URI.\n    :param key: MAC given provided by token endpoint.\n    :param http_method: HTTP Request method.\n    :param nonce:\n    :param headers: Request headers as a dictionary.\n    :param body:\n    :param ext:\n    :param hash_algorithm: HMAC algorithm provided by token endpoint.\n    :param issue_time: Time when the MAC credentials were issued (datetime).\n    :param draft: MAC authentication specification version.\n    :return: headers dictionary with the authorization field added.\n    \"\"\"\n    http_method = http_method.upper()\n    host, port = utils.host_from_uri(uri)\n\n    if hash_algorithm.lower() == 'hmac-sha-1':\n        h = hashlib.sha1\n    elif hash_algorithm.lower() == 'hmac-sha-256':\n        h = hashlib.sha256\n    else:\n        raise ValueError('unknown hash algorithm')\n\n    if draft == 0:\n        nonce = nonce or '{}:{}'.format(utils.generate_age(issue_time),\n                                          common.generate_nonce())\n    else:\n        ts = common.generate_timestamp()\n        nonce = common.generate_nonce()\n\n    sch, net, path, par, query, fra = urlparse(uri)\n\n    request_uri = path + '?' + query if query else path\n\n    # Hash the body/payload\n    if body is not None and draft == 0:\n        body = body.encode('utf-8')\n        bodyhash = b2a_base64(h(body).digest())[:-1].decode('utf-8')\n    else:\n        bodyhash = ''\n\n    # Create the normalized base string\n    base = []\n    if draft == 0:\n        base.append(nonce)\n    else:\n        base.append(ts)\n        base.append(nonce)\n    base.append(http_method.upper())\n    base.append(request_uri)\n    base.append(host)\n    base.append(port)\n    if draft == 0:\n        base.append(bodyhash)\n    base.append(ext or '')\n    base_string = '\\n'.join(base) + '\\n'\n\n    # hmac struggles with unicode strings - http://bugs.python.org/issue5285\n    if isinstance(key, str):\n        key = key.encode('utf-8')\n    sign = hmac.new(key, base_string.encode('utf-8'), h)\n    sign = b2a_base64(sign.digest())[:-1].decode('utf-8')\n\n    header = []\n    header.append('MAC id=\"%s\"' % token)\n    if draft != 0:\n        header.append('ts=\"%s\"' % ts)\n    header.append('nonce=\"%s\"' % nonce)\n    if bodyhash:\n        header.append('bodyhash=\"%s\"' % bodyhash)\n    if ext:\n        header.append('ext=\"%s\"' % ext)\n    header.append('mac=\"%s\"' % sign)\n\n    headers = headers or {}\n    headers['Authorization'] = ', '.join(header)\n    return headers\n\n\ndef prepare_bearer_uri(token, uri):\n    \"\"\"Add a `Bearer Token`_ to the request URI.\n    Not recommended, use only if client can't use authorization header or body.\n\n    http://www.example.com/path?access_token=h480djs93hd8\n\n    .. _`Bearer Token`: https://tools.ietf.org/html/rfc6750\n\n    :param token:\n    :param uri:\n    \"\"\"\n    return add_params_to_uri(uri, [(('access_token', token))])\n\n\ndef prepare_bearer_headers(token, headers=None):\n    \"\"\"Add a `Bearer Token`_ to the request URI.\n    Recommended method of passing bearer tokens.\n\n    Authorization: Bearer h480djs93hd8\n\n    .. _`Bearer Token`: https://tools.ietf.org/html/rfc6750\n\n    :param token:\n    :param headers:\n    \"\"\"\n    headers = headers or {}\n    headers['Authorization'] = 'Bearer %s' % token\n    return headers\n\n\ndef prepare_bearer_body(token, body=''):\n    \"\"\"Add a `Bearer Token`_ to the request body.\n\n    access_token=h480djs93hd8\n\n    .. _`Bearer Token`: https://tools.ietf.org/html/rfc6750\n\n    :param token:\n    :param body:\n    \"\"\"\n    return add_params_to_qs(body, [(('access_token', token))])\n\n\ndef random_token_generator(request, refresh_token=False):\n    \"\"\"\n    :param request: OAuthlib request.\n    :type request: oauthlib.common.Request\n    :param refresh_token:\n    \"\"\"\n    return common.generate_token()\n\n\ndef signed_token_generator(private_pem, **kwargs):\n    \"\"\"\n    :param private_pem:\n    \"\"\"\n    def signed_token_generator(request):\n        request.claims = kwargs\n        return common.generate_signed_token(private_pem, request)\n\n    return signed_token_generator\n\n\ndef get_token_from_header(request):\n    \"\"\"\n    Helper function to extract a token from the request header.\n\n    :param request: OAuthlib request.\n    :type request: oauthlib.common.Request\n    :return: Return the token or None if the Authorization header is malformed.\n    \"\"\"\n    token = None\n\n    if 'Authorization' in request.headers:\n        split_header = request.headers.get('Authorization').split()\n        if len(split_header) == 2 and split_header[0].lower() == 'bearer':\n            token = split_header[1]\n    else:\n        token = request.access_token\n\n    return token\n\n\nclass TokenBase:\n    __slots__ = ()\n\n    def __call__(self, request, refresh_token=False):\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def estimate_type(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n\nclass BearerToken(TokenBase):\n    __slots__ = (\n        'request_validator', 'token_generator',\n        'refresh_token_generator', 'expires_in'\n    )\n\n    def __init__(self, request_validator=None, token_generator=None,\n                 expires_in=None, refresh_token_generator=None):\n        self.request_validator = request_validator\n        self.token_generator = token_generator or random_token_generator\n        self.refresh_token_generator = (\n            refresh_token_generator or self.token_generator\n        )\n        self.expires_in = expires_in or 3600\n\n    def create_token(self, request, refresh_token=False, **kwargs):\n        \"\"\"\n        Create a BearerToken, by default without refresh token.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param refresh_token:\n        \"\"\"\n        if \"save_token\" in kwargs:\n            warnings.warn(\"`save_token` has been deprecated, it was not called internally.\"\n                          \"If you do, call `request_validator.save_token()` instead.\",\n                          DeprecationWarning)\n\n        expires_in = self.expires_in(request) if callable(self.expires_in) else self.expires_in\n\n        request.expires_in = expires_in\n\n        token = {\n            'access_token': self.token_generator(request),\n            'expires_in': expires_in,\n            'token_type': 'Bearer',\n        }\n\n        # If provided, include - this is optional in some cases https://tools.ietf.org/html/rfc6749#section-3.3 but\n        # there is currently no mechanism to coordinate issuing a token for only a subset of the requested scopes so\n        # all tokens issued are for the entire set of requested scopes.\n        if request.scopes is not None:\n            token['scope'] = ' '.join(request.scopes)\n\n        if refresh_token:\n            if (request.refresh_token and\n                    not self.request_validator.rotate_refresh_token(request)):\n                token['refresh_token'] = request.refresh_token\n            else:\n                token['refresh_token'] = self.refresh_token_generator(request)\n\n        token.update(request.extra_credentials or {})\n        return OAuth2Token(token)\n\n    def validate_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        token = get_token_from_header(request)\n        return self.request_validator.validate_bearer_token(\n            token, request.scopes, request)\n\n    def estimate_type(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        if request.headers.get('Authorization', '').split(' ')[0].lower() == 'bearer':\n            return 9\n        elif request.access_token is not None:\n            return 5\n        else:\n            return 0\n", "oauthlib/oauth2/rfc6749/utils.py": "\"\"\"\noauthlib.utils\n~~~~~~~~~~~~~~\n\nThis module contains utility methods used by various parts of the OAuth 2 spec.\n\"\"\"\nimport datetime\nimport os\nfrom urllib.parse import quote, urlparse\n\nfrom oauthlib.common import urldecode\n\n\ndef list_to_scope(scope):\n    \"\"\"Convert a list of scopes to a space separated string.\"\"\"\n    if isinstance(scope, str) or scope is None:\n        return scope\n    elif isinstance(scope, (set, tuple, list)):\n        return \" \".join([str(s) for s in scope])\n    else:\n        raise ValueError(\"Invalid scope (%s), must be string, tuple, set, or list.\" % scope)\n\n\ndef scope_to_list(scope):\n    \"\"\"Convert a space separated string to a list of scopes.\"\"\"\n    if isinstance(scope, (tuple, list, set)):\n        return [str(s) for s in scope]\n    elif scope is None:\n        return None\n    else:\n        return scope.strip().split(\" \")\n\n\ndef params_from_uri(uri):\n    params = dict(urldecode(urlparse(uri).query))\n    if 'scope' in params:\n        params['scope'] = scope_to_list(params['scope'])\n    return params\n\n\ndef host_from_uri(uri):\n    \"\"\"Extract hostname and port from URI.\n\n    Will use default port for HTTP and HTTPS if none is present in the URI.\n    \"\"\"\n    default_ports = {\n        'HTTP': '80',\n        'HTTPS': '443',\n    }\n\n    sch, netloc, path, par, query, fra = urlparse(uri)\n    if ':' in netloc:\n        netloc, port = netloc.split(':', 1)\n    else:\n        port = default_ports.get(sch.upper())\n\n    return netloc, port\n\n\ndef escape(u):\n    \"\"\"Escape a string in an OAuth-compatible fashion.\n\n    TODO: verify whether this can in fact be used for OAuth 2\n\n    \"\"\"\n    if not isinstance(u, str):\n        raise ValueError('Only unicode objects are escapable.')\n    return quote(u.encode('utf-8'), safe=b'~')\n\n\ndef generate_age(issue_time):\n    \"\"\"Generate a age parameter for MAC authentication draft 00.\"\"\"\n    td = datetime.datetime.now() - issue_time\n    age = (td.microseconds + (td.seconds + td.days * 24 * 3600)\n           * 10 ** 6) / 10 ** 6\n    return str(age)\n\n\ndef is_secure_transport(uri):\n    \"\"\"Check if the uri is over ssl.\"\"\"\n    if os.environ.get('OAUTHLIB_INSECURE_TRANSPORT'):\n        return True\n    return uri.lower().startswith('https://')\n", "oauthlib/oauth2/rfc6749/errors.py": "\"\"\"\noauthlib.oauth2.rfc6749.errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nError used both by OAuth 2 clients and providers to represent the spec\ndefined error responses for all four core grant types.\n\"\"\"\nimport json\n\nfrom oauthlib.common import add_params_to_uri, urlencode\n\n\nclass OAuth2Error(Exception):\n    error = None\n    status_code = 400\n    description = ''\n\n    def __init__(self, description=None, uri=None, state=None,\n                 status_code=None, request=None):\n        \"\"\"\n        :param description: A human-readable ASCII [USASCII] text providing\n                            additional information, used to assist the client\n                            developer in understanding the error that occurred.\n                            Values for the \"error_description\" parameter\n                            MUST NOT include characters outside the set\n                            x20-21 / x23-5B / x5D-7E.\n\n        :param uri: A URI identifying a human-readable web page with information\n                    about the error, used to provide the client developer with\n                    additional information about the error.  Values for the\n                    \"error_uri\" parameter MUST conform to the URI- Reference\n                    syntax, and thus MUST NOT include characters outside the set\n                    x21 / x23-5B / x5D-7E.\n\n        :param state: A CSRF protection value received from the client.\n\n        :param status_code:\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        if description is not None:\n            self.description = description\n\n        message = '({}) {}'.format(self.error, self.description)\n        if request:\n            message += ' ' + repr(request)\n        super().__init__(message)\n\n        self.uri = uri\n        self.state = state\n\n        if status_code:\n            self.status_code = status_code\n\n        if request:\n            self.redirect_uri = request.redirect_uri\n            self.client_id = request.client_id\n            self.scopes = request.scopes\n            self.response_type = request.response_type\n            self.response_mode = request.response_mode\n            self.grant_type = request.grant_type\n            if state is None:\n                self.state = request.state\n        else:\n            self.redirect_uri = None\n            self.client_id = None\n            self.scopes = None\n            self.response_type = None\n            self.response_mode = None\n            self.grant_type = None\n\n    def in_uri(self, uri):\n        fragment = self.response_mode == \"fragment\"\n        return add_params_to_uri(uri, self.twotuples, fragment)\n\n    @property\n    def twotuples(self):\n        error = [('error', self.error)]\n        if self.description:\n            error.append(('error_description', self.description))\n        if self.uri:\n            error.append(('error_uri', self.uri))\n        if self.state:\n            error.append(('state', self.state))\n        return error\n\n    @property\n    def urlencoded(self):\n        return urlencode(self.twotuples)\n\n    @property\n    def json(self):\n        return json.dumps(dict(self.twotuples))\n\n    @property\n    def headers(self):\n        if self.status_code == 401:\n            \"\"\"\n            https://tools.ietf.org/html/rfc6750#section-3\n\n            All challenges defined by this specification MUST use the auth-scheme\n            value \"Bearer\".  This scheme MUST be followed by one or more\n            auth-param values.\n            \"\"\"\n            authvalues = ['error=\"{}\"'.format(self.error)]\n            if self.description:\n                authvalues.append('error_description=\"{}\"'.format(self.description))\n            if self.uri:\n                authvalues.append('error_uri=\"{}\"'.format(self.uri))\n            return {\"WWW-Authenticate\": \"Bearer \" + \", \".join(authvalues)}\n        return {}\n\n\nclass TokenExpiredError(OAuth2Error):\n    error = 'token_expired'\n\n\nclass InsecureTransportError(OAuth2Error):\n    error = 'insecure_transport'\n    description = 'OAuth 2 MUST utilize https.'\n\n\nclass MismatchingStateError(OAuth2Error):\n    error = 'mismatching_state'\n    description = 'CSRF Warning! State not equal in request and response.'\n\n\nclass MissingCodeError(OAuth2Error):\n    error = 'missing_code'\n\n\nclass MissingTokenError(OAuth2Error):\n    error = 'missing_token'\n\n\nclass MissingTokenTypeError(OAuth2Error):\n    error = 'missing_token_type'\n\n\nclass FatalClientError(OAuth2Error):\n    \"\"\"\n    Errors during authorization where user should not be redirected back.\n\n    If the request fails due to a missing, invalid, or mismatching\n    redirection URI, or if the client identifier is missing or invalid,\n    the authorization server SHOULD inform the resource owner of the\n    error and MUST NOT automatically redirect the user-agent to the\n    invalid redirection URI.\n\n    Instead the user should be informed of the error by the provider itself.\n    \"\"\"\n\n\nclass InvalidRequestFatalError(FatalClientError):\n    \"\"\"\n    For fatal errors, the request is missing a required parameter, includes\n    an invalid parameter value, includes a parameter more than once, or is\n    otherwise malformed.\n    \"\"\"\n    error = 'invalid_request'\n\n\nclass InvalidRedirectURIError(InvalidRequestFatalError):\n    description = 'Invalid redirect URI.'\n\n\nclass MissingRedirectURIError(InvalidRequestFatalError):\n    description = 'Missing redirect URI.'\n\n\nclass MismatchingRedirectURIError(InvalidRequestFatalError):\n    description = 'Mismatching redirect URI.'\n\n\nclass InvalidClientIdError(InvalidRequestFatalError):\n    description = 'Invalid client_id parameter value.'\n\n\nclass MissingClientIdError(InvalidRequestFatalError):\n    description = 'Missing client_id parameter.'\n\n\nclass InvalidRequestError(OAuth2Error):\n    \"\"\"\n    The request is missing a required parameter, includes an invalid\n    parameter value, includes a parameter more than once, or is\n    otherwise malformed.\n    \"\"\"\n    error = 'invalid_request'\n\n\nclass MissingResponseTypeError(InvalidRequestError):\n    description = 'Missing response_type parameter.'\n\n\nclass MissingCodeChallengeError(InvalidRequestError):\n    \"\"\"\n    If the server requires Proof Key for Code Exchange (PKCE) by OAuth\n    public clients and the client does not send the \"code_challenge\" in\n    the request, the authorization endpoint MUST return the authorization\n    error response with the \"error\" value set to \"invalid_request\".  The\n    \"error_description\" or the response of \"error_uri\" SHOULD explain the\n    nature of error, e.g., code challenge required.\n    \"\"\"\n    description = 'Code challenge required.'\n\n\nclass MissingCodeVerifierError(InvalidRequestError):\n    \"\"\"\n    The request to the token endpoint, when PKCE is enabled, has\n    the parameter `code_verifier` REQUIRED.\n    \"\"\"\n    description = 'Code verifier required.'\n\n\nclass AccessDeniedError(OAuth2Error):\n    \"\"\"\n    The resource owner or authorization server denied the request.\n    \"\"\"\n    error = 'access_denied'\n\n\nclass UnsupportedResponseTypeError(OAuth2Error):\n    \"\"\"\n    The authorization server does not support obtaining an authorization\n    code using this method.\n    \"\"\"\n    error = 'unsupported_response_type'\n\n\nclass UnsupportedCodeChallengeMethodError(InvalidRequestError):\n    \"\"\"\n    If the server supporting PKCE does not support the requested\n    transformation, the authorization endpoint MUST return the\n    authorization error response with \"error\" value set to\n    \"invalid_request\".  The \"error_description\" or the response of\n    \"error_uri\" SHOULD explain the nature of error, e.g., transform\n    algorithm not supported.\n    \"\"\"\n    description = 'Transform algorithm not supported.'\n\n\nclass InvalidScopeError(OAuth2Error):\n    \"\"\"\n    The requested scope is invalid, unknown, or malformed, or\n    exceeds the scope granted by the resource owner.\n\n    https://tools.ietf.org/html/rfc6749#section-5.2\n    \"\"\"\n    error = 'invalid_scope'\n\n\nclass ServerError(OAuth2Error):\n    \"\"\"\n    The authorization server encountered an unexpected condition that\n    prevented it from fulfilling the request.  (This error code is needed\n    because a 500 Internal Server Error HTTP status code cannot be returned\n    to the client via a HTTP redirect.)\n    \"\"\"\n    error = 'server_error'\n\n\nclass TemporarilyUnavailableError(OAuth2Error):\n    \"\"\"\n    The authorization server is currently unable to handle the request\n    due to a temporary overloading or maintenance of the server.\n    (This error code is needed because a 503 Service Unavailable HTTP\n    status code cannot be returned to the client via a HTTP redirect.)\n    \"\"\"\n    error = 'temporarily_unavailable'\n\n\nclass InvalidClientError(FatalClientError):\n    \"\"\"\n    Client authentication failed (e.g. unknown client, no client\n    authentication included, or unsupported authentication method).\n    The authorization server MAY return an HTTP 401 (Unauthorized) status\n    code to indicate which HTTP authentication schemes are supported.\n    If the client attempted to authenticate via the \"Authorization\" request\n    header field, the authorization server MUST respond with an\n    HTTP 401 (Unauthorized) status code, and include the \"WWW-Authenticate\"\n    response header field matching the authentication scheme used by the\n    client.\n    \"\"\"\n    error = 'invalid_client'\n    status_code = 401\n\n\nclass InvalidGrantError(OAuth2Error):\n    \"\"\"\n    The provided authorization grant (e.g. authorization code, resource\n    owner credentials) or refresh token is invalid, expired, revoked, does\n    not match the redirection URI used in the authorization request, or was\n    issued to another client.\n\n    https://tools.ietf.org/html/rfc6749#section-5.2\n    \"\"\"\n    error = 'invalid_grant'\n    status_code = 400\n\n\nclass UnauthorizedClientError(OAuth2Error):\n    \"\"\"\n    The authenticated client is not authorized to use this authorization\n    grant type.\n    \"\"\"\n    error = 'unauthorized_client'\n\n\nclass UnsupportedGrantTypeError(OAuth2Error):\n    \"\"\"\n    The authorization grant type is not supported by the authorization\n    server.\n    \"\"\"\n    error = 'unsupported_grant_type'\n\n\nclass UnsupportedTokenTypeError(OAuth2Error):\n    \"\"\"\n    The authorization server does not support the hint of the\n    presented token type.  I.e. the client tried to revoke an access token\n    on a server not supporting this feature.\n    \"\"\"\n    error = 'unsupported_token_type'\n\n\nclass InvalidTokenError(OAuth2Error):\n    \"\"\"\n    The access token provided is expired, revoked, malformed, or\n    invalid for other reasons.  The resource SHOULD respond with\n    the HTTP 401 (Unauthorized) status code.  The client MAY\n    request a new access token and retry the protected resource\n    request.\n    \"\"\"\n    error = 'invalid_token'\n    status_code = 401\n    description = (\"The access token provided is expired, revoked, malformed, \"\n                   \"or invalid for other reasons.\")\n\n\nclass InsufficientScopeError(OAuth2Error):\n    \"\"\"\n    The request requires higher privileges than provided by the\n    access token.  The resource server SHOULD respond with the HTTP\n    403 (Forbidden) status code and MAY include the \"scope\"\n    attribute with the scope necessary to access the protected\n    resource.\n    \"\"\"\n    error = 'insufficient_scope'\n    status_code = 403\n    description = (\"The request requires higher privileges than provided by \"\n                   \"the access token.\")\n\n\nclass ConsentRequired(OAuth2Error):\n    \"\"\"\n    The Authorization Server requires End-User consent.\n\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface for End-User consent.\n    \"\"\"\n    error = 'consent_required'\n\n\nclass LoginRequired(OAuth2Error):\n    \"\"\"\n    The Authorization Server requires End-User authentication.\n\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface for End-User authentication.\n    \"\"\"\n    error = 'login_required'\n\n\nclass CustomOAuth2Error(OAuth2Error):\n    \"\"\"\n    This error is a placeholder for all custom errors not described by the RFC.\n    Some of the popular OAuth2 providers are using custom errors.\n    \"\"\"\n    def __init__(self, error, *args, **kwargs):\n        self.error = error\n        super().__init__(*args, **kwargs)\n\n\ndef raise_from_error(error, params=None):\n    import inspect\n    import sys\n    kwargs = {\n        'description': params.get('error_description'),\n        'uri': params.get('error_uri'),\n        'state': params.get('state')\n    }\n    for _, cls in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n        if cls.error == error:\n            raise cls(**kwargs)\n    raise CustomOAuth2Error(error=error, **kwargs)\n", "oauthlib/oauth2/rfc6749/parameters.py": "\"\"\"\noauthlib.oauth2.rfc6749.parameters\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains methods related to `Section 4`_ of the OAuth 2 RFC.\n\n.. _`Section 4`: https://tools.ietf.org/html/rfc6749#section-4\n\"\"\"\nimport json\nimport os\nimport time\nimport urllib.parse as urlparse\n\nfrom oauthlib.common import add_params_to_qs, add_params_to_uri\nfrom oauthlib.signals import scope_changed\n\nfrom .errors import (\n    InsecureTransportError, MismatchingStateError, MissingCodeError,\n    MissingTokenError, MissingTokenTypeError, raise_from_error,\n)\nfrom .tokens import OAuth2Token\nfrom .utils import is_secure_transport, list_to_scope, scope_to_list\n\n\ndef prepare_grant_uri(uri, client_id, response_type, redirect_uri=None,\n                      scope=None, state=None, code_challenge=None, code_challenge_method='plain', **kwargs):\n    \"\"\"Prepare the authorization grant request URI.\n\n    The client constructs the request URI by adding the following\n    parameters to the query component of the authorization endpoint URI\n    using the ``application/x-www-form-urlencoded`` format as defined by\n    [`W3C.REC-html401-19991224`_]:\n\n    :param uri:\n    :param client_id: The client identifier as described in `Section 2.2`_.\n    :param response_type: To indicate which OAuth 2 grant/flow is required,\n                          \"code\" and \"token\".\n    :param redirect_uri: The client provided URI to redirect back to after\n                         authorization as described in `Section 3.1.2`_.\n    :param scope: The scope of the access request as described by\n                  `Section 3.3`_.\n    :param state: An opaque value used by the client to maintain\n                  state between the request and callback.  The authorization\n                  server includes this value when redirecting the user-agent\n                  back to the client.  The parameter SHOULD be used for\n                  preventing cross-site request forgery as described in\n                  `Section 10.12`_.\n    :param code_challenge: PKCE parameter. A challenge derived from the\n                           code_verifier that is sent in the authorization\n                           request, to be verified against later.\n    :param code_challenge_method: PKCE parameter. A method that was used to derive the\n                                  code_challenge. Defaults to \"plain\" if not present in the request.\n    :param kwargs: Extra arguments to embed in the grant/authorization URL.\n\n    An example of an authorization code grant authorization URL:\n\n    .. code-block:: http\n\n        GET /authorize?response_type=code&client_id=s6BhdRkqt3&state=xyz\n            &code_challenge=kjasBS523KdkAILD2k78NdcJSk2k3KHG6&code_challenge_method=S256\n            &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb HTTP/1.1\n        Host: server.example.com\n\n    .. _`W3C.REC-html401-19991224`: https://tools.ietf.org/html/rfc6749#ref-W3C.REC-html401-19991224\n    .. _`Section 2.2`: https://tools.ietf.org/html/rfc6749#section-2.2\n    .. _`Section 3.1.2`: https://tools.ietf.org/html/rfc6749#section-3.1.2\n    .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n    .. _`section 10.12`: https://tools.ietf.org/html/rfc6749#section-10.12\n    \"\"\"\n    if not is_secure_transport(uri):\n        raise InsecureTransportError()\n\n    params = [(('response_type', response_type)),\n              (('client_id', client_id))]\n\n    if redirect_uri:\n        params.append(('redirect_uri', redirect_uri))\n    if scope:\n        params.append(('scope', list_to_scope(scope)))\n    if state:\n        params.append(('state', state))\n    if code_challenge is not None:\n        params.append(('code_challenge', code_challenge))\n        params.append(('code_challenge_method', code_challenge_method))\n\n    for k in kwargs:\n        if kwargs[k]:\n            params.append((str(k), kwargs[k]))\n\n    return add_params_to_uri(uri, params)\n\n\ndef prepare_token_request(grant_type, body='', include_client_id=True, code_verifier=None, **kwargs):\n    \"\"\"Prepare the access token request.\n\n    The client makes a request to the token endpoint by adding the\n    following parameters using the ``application/x-www-form-urlencoded``\n    format in the HTTP request entity-body:\n\n    :param grant_type: To indicate grant type being used, i.e. \"password\",\n                       \"authorization_code\" or \"client_credentials\".\n\n    :param body: Existing request body (URL encoded string) to embed parameters\n                 into. This may contain extra parameters. Default ''.\n\n    :param include_client_id: `True` (default) to send the `client_id` in the\n                              body of the upstream request. This is required\n                              if the client is not authenticating with the\n                              authorization server as described in\n                              `Section 3.2.1`_.\n    :type include_client_id: Boolean\n\n    :param client_id: Unicode client identifier. Will only appear if\n                      `include_client_id` is True. *\n\n    :param client_secret: Unicode client secret. Will only appear if set to a\n                          value that is not `None`. Invoking this function with\n                          an empty string will send an empty `client_secret`\n                          value to the server. *\n\n    :param code: If using authorization_code grant, pass the previously\n                 obtained authorization code as the ``code`` argument. *\n\n    :param redirect_uri: If the \"redirect_uri\" parameter was included in the\n                         authorization request as described in\n                         `Section 4.1.1`_, and their values MUST be identical. *\n\n    :param code_verifier: PKCE parameter. A cryptographically random string that is used to correlate the\n                          authorization request to the token request.\n\n    :param kwargs: Extra arguments to embed in the request body.\n\n    Parameters marked with a `*` above are not explicit arguments in the\n    function signature, but are specially documented arguments for items\n    appearing in the generic `**kwargs` keyworded input.\n\n    An example of an authorization code token request body:\n\n    .. code-block:: http\n\n        grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA\n        &redirect_uri=https%3A%2F%2Fclient%2Eexample%2Ecom%2Fcb\n\n    .. _`Section 4.1.1`: https://tools.ietf.org/html/rfc6749#section-4.1.1\n    \"\"\"\n    params = [('grant_type', grant_type)]\n\n    if 'scope' in kwargs:\n        kwargs['scope'] = list_to_scope(kwargs['scope'])\n\n    # pull the `client_id` out of the kwargs.\n    client_id = kwargs.pop('client_id', None)\n    if include_client_id and client_id is not None:\n        params.append(('client_id', client_id))\n\n    # use code_verifier if code_challenge was passed in the authorization request\n    if code_verifier is not None:\n        params.append(('code_verifier', code_verifier))\n\n    # the kwargs iteration below only supports including boolean truth (truthy)\n    # values, but some servers may require an empty string for `client_secret`\n    client_secret = kwargs.pop('client_secret', None)\n    if client_secret is not None:\n        params.append(('client_secret', client_secret))\n\n    # this handles: `code`, `redirect_uri`, and other undocumented params\n    for k in kwargs:\n        if kwargs[k]:\n            params.append((str(k), kwargs[k]))\n\n    return add_params_to_qs(body, params)\n\n\ndef prepare_token_revocation_request(url, token, token_type_hint=\"access_token\",\n        callback=None, body='', **kwargs):\n    \"\"\"Prepare a token revocation request.\n\n    The client constructs the request by including the following parameters\n    using the ``application/x-www-form-urlencoded`` format in the HTTP request\n    entity-body:\n\n    :param token: REQUIRED.  The token that the client wants to get revoked.\n\n    :param token_type_hint: OPTIONAL.  A hint about the type of the token\n                            submitted for revocation. Clients MAY pass this\n                            parameter in order to help the authorization server\n                            to optimize the token lookup.  If the server is\n                            unable to locate the token using the given hint, it\n                            MUST extend its search across all of its supported\n                            token types.  An authorization server MAY ignore\n                            this parameter, particularly if it is able to detect\n                            the token type automatically.\n\n    This specification defines two values for `token_type_hint`:\n\n        * access_token: An access token as defined in [RFC6749],\n             `Section 1.4`_\n\n        * refresh_token: A refresh token as defined in [RFC6749],\n             `Section 1.5`_\n\n        Specific implementations, profiles, and extensions of this\n        specification MAY define other values for this parameter using the\n        registry defined in `Section 4.1.2`_.\n\n    .. _`Section 1.4`: https://tools.ietf.org/html/rfc6749#section-1.4\n    .. _`Section 1.5`: https://tools.ietf.org/html/rfc6749#section-1.5\n    .. _`Section 4.1.2`: https://tools.ietf.org/html/rfc7009#section-4.1.2\n\n    \"\"\"\n    if not is_secure_transport(url):\n        raise InsecureTransportError()\n\n    params = [('token', token)]\n\n    if token_type_hint:\n        params.append(('token_type_hint', token_type_hint))\n\n    for k in kwargs:\n        if kwargs[k]:\n            params.append((str(k), kwargs[k]))\n\n    headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n\n    if callback:\n        params.append(('callback', callback))\n        return add_params_to_uri(url, params), headers, body\n    else:\n        return url, headers, add_params_to_qs(body, params)\n\n\ndef parse_authorization_code_response(uri, state=None):\n    \"\"\"Parse authorization grant response URI into a dict.\n\n    If the resource owner grants the access request, the authorization\n    server issues an authorization code and delivers it to the client by\n    adding the following parameters to the query component of the\n    redirection URI using the ``application/x-www-form-urlencoded`` format:\n\n    **code**\n            REQUIRED.  The authorization code generated by the\n            authorization server.  The authorization code MUST expire\n            shortly after it is issued to mitigate the risk of leaks.  A\n            maximum authorization code lifetime of 10 minutes is\n            RECOMMENDED.  The client MUST NOT use the authorization code\n            more than once.  If an authorization code is used more than\n            once, the authorization server MUST deny the request and SHOULD\n            revoke (when possible) all tokens previously issued based on\n            that authorization code.  The authorization code is bound to\n            the client identifier and redirection URI.\n\n    **state**\n            REQUIRED if the \"state\" parameter was present in the client\n            authorization request.  The exact value received from the\n            client.\n\n    :param uri: The full redirect URL back to the client.\n    :param state: The state parameter from the authorization request.\n\n    For example, the authorization server redirects the user-agent by\n    sending the following HTTP response:\n\n    .. code-block:: http\n\n        HTTP/1.1 302 Found\n        Location: https://client.example.com/cb?code=SplxlOBeZQQYbYS6WxSbIA\n                &state=xyz\n\n    \"\"\"\n    if not is_secure_transport(uri):\n        raise InsecureTransportError()\n\n    query = urlparse.urlparse(uri).query\n    params = dict(urlparse.parse_qsl(query))\n\n    if state and params.get('state', None) != state:\n        raise MismatchingStateError()\n\n    if 'error' in params:\n        raise_from_error(params.get('error'), params)\n\n    if 'code' not in params:\n        raise MissingCodeError(\"Missing code parameter in response.\")\n\n    return params\n\n\ndef parse_implicit_response(uri, state=None, scope=None):\n    \"\"\"Parse the implicit token response URI into a dict.\n\n    If the resource owner grants the access request, the authorization\n    server issues an access token and delivers it to the client by adding\n    the following parameters to the fragment component of the redirection\n    URI using the ``application/x-www-form-urlencoded`` format:\n\n    **access_token**\n            REQUIRED.  The access token issued by the authorization server.\n\n    **token_type**\n            REQUIRED.  The type of the token issued as described in\n            Section 7.1.  Value is case insensitive.\n\n    **expires_in**\n            RECOMMENDED.  The lifetime in seconds of the access token.  For\n            example, the value \"3600\" denotes that the access token will\n            expire in one hour from the time the response was generated.\n            If omitted, the authorization server SHOULD provide the\n            expiration time via other means or document the default value.\n\n    **scope**\n            OPTIONAL, if identical to the scope requested by the client,\n            otherwise REQUIRED.  The scope of the access token as described\n            by Section 3.3.\n\n    **state**\n            REQUIRED if the \"state\" parameter was present in the client\n            authorization request.  The exact value received from the\n            client.\n\n    :param uri:\n    :param state:\n    :param scope:\n\n    Similar to the authorization code response, but with a full token provided\n    in the URL fragment:\n\n    .. code-block:: http\n\n        HTTP/1.1 302 Found\n        Location: http://example.com/cb#access_token=2YotnFZFEjr1zCsicMWpAA\n                &state=xyz&token_type=example&expires_in=3600\n    \"\"\"\n    if not is_secure_transport(uri):\n        raise InsecureTransportError()\n\n    fragment = urlparse.urlparse(uri).fragment\n    params = dict(urlparse.parse_qsl(fragment, keep_blank_values=True))\n\n    for key in ('expires_in',):\n        if key in params:  # cast things to int\n            params[key] = int(params[key])\n\n    if 'scope' in params:\n        params['scope'] = scope_to_list(params['scope'])\n\n    if 'expires_in' in params:\n        params['expires_at'] = round(time.time()) + int(params['expires_in'])\n\n    if state and params.get('state', None) != state:\n        raise ValueError(\"Mismatching or missing state in params.\")\n\n    params = OAuth2Token(params, old_scope=scope)\n    validate_token_parameters(params)\n    return params\n\n\ndef parse_token_response(body, scope=None):\n    \"\"\"Parse the JSON token response body into a dict.\n\n    The authorization server issues an access token and optional refresh\n    token, and constructs the response by adding the following parameters\n    to the entity body of the HTTP response with a 200 (OK) status code:\n\n    access_token\n            REQUIRED.  The access token issued by the authorization server.\n    token_type\n            REQUIRED.  The type of the token issued as described in\n            `Section 7.1`_.  Value is case insensitive.\n    expires_in\n            RECOMMENDED.  The lifetime in seconds of the access token.  For\n            example, the value \"3600\" denotes that the access token will\n            expire in one hour from the time the response was generated.\n            If omitted, the authorization server SHOULD provide the\n            expiration time via other means or document the default value.\n    refresh_token\n            OPTIONAL.  The refresh token which can be used to obtain new\n            access tokens using the same authorization grant as described\n            in `Section 6`_.\n    scope\n            OPTIONAL, if identical to the scope requested by the client,\n            otherwise REQUIRED.  The scope of the access token as described\n            by `Section 3.3`_.\n\n    The parameters are included in the entity body of the HTTP response\n    using the \"application/json\" media type as defined by [`RFC4627`_].  The\n    parameters are serialized into a JSON structure by adding each\n    parameter at the highest structure level.  Parameter names and string\n    values are included as JSON strings.  Numerical values are included\n    as JSON numbers.  The order of parameters does not matter and can\n    vary.\n\n    :param body: The full json encoded response body.\n    :param scope: The scope requested during authorization.\n\n    For example:\n\n    .. code-block:: http\n\n        HTTP/1.1 200 OK\n        Content-Type: application/json\n        Cache-Control: no-store\n        Pragma: no-cache\n\n        {\n            \"access_token\":\"2YotnFZFEjr1zCsicMWpAA\",\n            \"token_type\":\"example\",\n            \"expires_in\":3600,\n            \"refresh_token\":\"tGzv3JOkF0XG5Qx2TlKWIA\",\n            \"example_parameter\":\"example_value\"\n        }\n\n    .. _`Section 7.1`: https://tools.ietf.org/html/rfc6749#section-7.1\n    .. _`Section 6`: https://tools.ietf.org/html/rfc6749#section-6\n    .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n    .. _`RFC4627`: https://tools.ietf.org/html/rfc4627\n    \"\"\"\n    try:\n        params = json.loads(body)\n    except ValueError:\n\n        # Fall back to URL-encoded string, to support old implementations,\n        # including (at time of writing) Facebook. See:\n        #   https://github.com/oauthlib/oauthlib/issues/267\n\n        params = dict(urlparse.parse_qsl(body))\n        for key in ('expires_in',):\n            if key in params:  # cast things to int\n                params[key] = int(params[key])\n\n    if 'scope' in params:\n        params['scope'] = scope_to_list(params['scope'])\n\n    if 'expires_in' in params:\n        if params['expires_in'] is None:\n            params.pop('expires_in')\n        else:\n            params['expires_at'] = time.time() + int(params['expires_in'])\n\n    if isinstance(params.get('expires_at'), float):\n        params['expires_at'] = round(params['expires_at'])\n\n    params = OAuth2Token(params, old_scope=scope)\n    validate_token_parameters(params)\n    return params\n\n\ndef validate_token_parameters(params):\n    \"\"\"Ensures token presence, token type, expiration and scope in params.\"\"\"\n    if 'error' in params:\n        raise_from_error(params.get('error'), params)\n\n    if 'access_token' not in params:\n        raise MissingTokenError(description=\"Missing access token parameter.\")\n\n    if 'token_type' not in params and os.environ.get('OAUTHLIB_STRICT_TOKEN_TYPE'):\n        raise MissingTokenTypeError()\n\n    # If the issued access token scope is different from the one requested by\n    # the client, the authorization server MUST include the \"scope\" response\n    # parameter to inform the client of the actual scope granted.\n    # https://tools.ietf.org/html/rfc6749#section-3.3\n    if params.scope_changed:\n        message = 'Scope has changed from \"{old}\" to \"{new}\".'.format(\n            old=params.old_scope, new=params.scope,\n        )\n        scope_changed.send(message=message, old=params.old_scopes, new=params.scopes)\n        if not os.environ.get('OAUTHLIB_RELAX_TOKEN_SCOPE', None):\n            w = Warning(message)\n            w.token = params\n            w.old_scope = params.old_scopes\n            w.new_scope = params.scopes\n            raise w\n", "oauthlib/oauth2/rfc6749/__init__.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport functools\nimport logging\n\nfrom .endpoints.base import BaseEndpoint, catch_errors_and_unavailability\nfrom .errors import (\n    FatalClientError, OAuth2Error, ServerError, TemporarilyUnavailableError,\n)\n\nlog = logging.getLogger(__name__)\n", "oauthlib/oauth2/rfc6749/request_validator.py": "\"\"\"\noauthlib.oauth2.rfc6749.request_validator\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nlog = logging.getLogger(__name__)\n\n\nclass RequestValidator:\n\n    def client_authentication_required(self, request, *args, **kwargs):\n        \"\"\"Determine if client authentication is required for current request.\n\n        According to the rfc6749, client authentication is required in the following cases:\n            - Resource Owner Password Credentials Grant, when Client type is Confidential or when\n              Client was issued client credentials or whenever Client provided client\n              authentication, see `Section 4.3.2`_.\n            - Authorization Code Grant, when Client type is Confidential or when Client was issued\n              client credentials or whenever Client provided client authentication,\n              see `Section 4.1.3`_.\n            - Refresh Token Grant, when Client type is Confidential or when Client was issued\n              client credentials or whenever Client provided client authentication, see\n              `Section 6`_\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Resource Owner Password Credentials Grant\n            - Refresh Token Grant\n\n        .. _`Section 4.3.2`: https://tools.ietf.org/html/rfc6749#section-4.3.2\n        .. _`Section 4.1.3`: https://tools.ietf.org/html/rfc6749#section-4.1.3\n        .. _`Section 6`: https://tools.ietf.org/html/rfc6749#section-6\n        \"\"\"\n        return True\n\n    def authenticate_client(self, request, *args, **kwargs):\n        \"\"\"Authenticate client through means outside the OAuth 2 spec.\n\n        Means of authentication is negotiated beforehand and may for example\n        be `HTTP Basic Authentication Scheme`_ which utilizes the Authorization\n        header.\n\n        Headers may be accesses through request.headers and parameters found in\n        both body and query can be obtained by direct attribute access, i.e.\n        request.client_id for client_id in the URL query.\n\n        The authentication process is required to contain the identification of\n        the client (i.e. search the database based on the client_id). In case the\n        client doesn't exist based on the received client_id, this method has to\n        return False and the HTTP response created by the library will contain\n        'invalid_client' message.\n\n        After the client identification succeeds, this method needs to set the\n        client on the request, i.e. request.client = client. A client object's\n        class must contain the 'client_id' attribute and the 'client_id' must have\n        a value.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Resource Owner Password Credentials Grant (may be disabled)\n            - Client Credentials Grant\n            - Refresh Token Grant\n\n        .. _`HTTP Basic Authentication Scheme`: https://tools.ietf.org/html/rfc1945#section-11.1\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def authenticate_client_id(self, client_id, request, *args, **kwargs):\n        \"\"\"Ensure client_id belong to a non-confidential client.\n\n        A non-confidential client is one that is not required to authenticate\n        through other means, such as using HTTP Basic.\n\n        Note, while not strictly necessary it can often be very convenient\n        to set request.client to the client object associated with the\n        given client_id.\n\n        :param client_id: Unicode client identifier.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def confirm_redirect_uri(self, client_id, code, redirect_uri, client, request,\n                             *args, **kwargs):\n        \"\"\"Ensure that the authorization process represented by this authorization\n        code began with this 'redirect_uri'.\n\n        If the client specifies a redirect_uri when obtaining code then that\n        redirect URI must be bound to the code and verified equal in this\n        method, according to RFC 6749 section 4.1.3.  Do not compare against\n        the client's allowed redirect URIs, but against the URI used when the\n        code was saved.\n\n        :param client_id: Unicode client identifier.\n        :param code: Unicode authorization_code.\n        :param redirect_uri: Unicode absolute URI.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant (during token request)\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_default_redirect_uri(self, client_id, request, *args, **kwargs):\n        \"\"\"Get the default redirect URI for the client.\n\n        :param client_id: Unicode client identifier.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: The default redirect URI for the client\n\n        Method is used by:\n            - Authorization Code Grant\n            - Implicit Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_default_scopes(self, client_id, request, *args, **kwargs):\n        \"\"\"Get the default scopes for the client.\n\n        :param client_id: Unicode client identifier.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: List of default scopes\n\n        Method is used by all core grant types:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Resource Owner Password Credentials Grant\n            - Client Credentials grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_original_scopes(self, refresh_token, request, *args, **kwargs):\n        \"\"\"Get the list of scopes associated with the refresh token.\n\n        :param refresh_token: Unicode refresh token.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: List of scopes.\n\n        Method is used by:\n            - Refresh token grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def is_within_original_scope(self, request_scopes, refresh_token, request, *args, **kwargs):\n        \"\"\"Check if requested scopes are within a scope of the refresh token.\n\n        When access tokens are refreshed the scope of the new token\n        needs to be within the scope of the original token. This is\n        ensured by checking that all requested scopes strings are on\n        the list returned by the get_original_scopes. If this check\n        fails, is_within_original_scope is called. The method can be\n        used in situations where returning all valid scopes from the\n        get_original_scopes is not practical.\n\n        :param request_scopes: A list of scopes that were requested by client.\n        :param refresh_token: Unicode refresh_token.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Refresh token grant\n        \"\"\"\n        return False\n\n    def introspect_token(self, token, token_type_hint, request, *args, **kwargs):\n        \"\"\"Introspect an access or refresh token.\n\n        Called once the introspect request is validated. This method should\n        verify the *token* and either return a dictionary with the list of\n        claims associated, or `None` in case the token is unknown.\n\n        Below the list of registered claims you should be interested in:\n\n        - scope : space-separated list of scopes\n        - client_id : client identifier\n        - username : human-readable identifier for the resource owner\n        - token_type : type of the token\n        - exp : integer timestamp indicating when this token will expire\n        - iat : integer timestamp indicating when this token was issued\n        - nbf : integer timestamp indicating when it can be \"not-before\" used\n        - sub : subject of the token - identifier of the resource owner\n        - aud : list of string identifiers representing the intended audience\n        - iss : string representing issuer of this token\n        - jti : string identifier for the token\n\n        Note that most of them are coming directly from JWT RFC. More details\n        can be found in `Introspect Claims`_ or `JWT Claims`_.\n\n        The implementation can use *token_type_hint* to improve lookup\n        efficiency, but must fallback to other types to be compliant with RFC.\n\n        The dict of claims is added to request.token after this method.\n\n        :param token: The token string.\n        :param token_type_hint: access_token or refresh_token.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        Method is used by:\n            - Introspect Endpoint (all grants are compatible)\n\n        .. _`Introspect Claims`: https://tools.ietf.org/html/rfc7662#section-2.2\n        .. _`JWT Claims`: https://tools.ietf.org/html/rfc7519#section-4\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def invalidate_authorization_code(self, client_id, code, request, *args, **kwargs):\n        \"\"\"Invalidate an authorization code after use.\n\n        :param client_id: Unicode client identifier.\n        :param code: The authorization code grant (request.code).\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        Method is used by:\n            - Authorization Code Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def revoke_token(self, token, token_type_hint, request, *args, **kwargs):\n        \"\"\"Revoke an access or refresh token.\n\n        :param token: The token string.\n        :param token_type_hint: access_token or refresh_token.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        Method is used by:\n            - Revocation Endpoint\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def rotate_refresh_token(self, request):\n        \"\"\"Determine whether to rotate the refresh token. Default, yes.\n\n        When access tokens are refreshed the old refresh token can be kept\n        or replaced with a new one (rotated). Return True to rotate and\n        and False for keeping original.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Refresh Token Grant\n        \"\"\"\n        return True\n\n    def save_authorization_code(self, client_id, code, request, *args, **kwargs):\n        \"\"\"Persist the authorization_code.\n\n        The code should at minimum be stored with:\n            - the client_id (``client_id``)\n            - the redirect URI used (``request.redirect_uri``)\n            - a resource owner / user (``request.user``)\n            - the authorized scopes (``request.scopes``)\n\n        To support PKCE, you MUST associate the code with:\n            - Code Challenge (``request.code_challenge``) and\n            - Code Challenge Method (``request.code_challenge_method``)\n\n        To support OIDC, you MUST associate the code with:\n            - nonce, if present (``code[\"nonce\"]``)\n\n        The ``code`` argument is actually a dictionary, containing at least a\n        ``code`` key with the actual authorization code:\n\n            ``{'code': 'sdf345jsdf0934f'}``\n\n        It may also have a ``claims`` parameter which, when present, will be a dict\n        deserialized from JSON as described at\n        http://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter\n        This value should be saved in this method and used again in ``.validate_code``.\n\n        :param client_id: Unicode client identifier.\n        :param code: A dict of the authorization code grant and, optionally, state.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        Method is used by:\n            - Authorization Code Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def save_token(self, token, request, *args, **kwargs):\n        \"\"\"Persist the token with a token type specific method.\n\n        Currently, only save_bearer_token is supported.\n\n        :param token: A (Bearer) token dict.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        return self.save_bearer_token(token, request, *args, **kwargs)\n\n    def save_bearer_token(self, token, request, *args, **kwargs):\n        \"\"\"Persist the Bearer token.\n\n        The Bearer token should at minimum be associated with:\n            - a client and it's client_id, if available\n            - a resource owner / user (request.user)\n            - authorized scopes (request.scopes)\n            - an expiration time\n            - a refresh token, if issued\n            - a claims document, if present in request.claims\n\n        The Bearer token dict may hold a number of items::\n\n            {\n                'token_type': 'Bearer',\n                'access_token': 'askfjh234as9sd8',\n                'expires_in': 3600,\n                'scope': 'string of space separated authorized scopes',\n                'refresh_token': '23sdf876234',  # if issued\n                'state': 'given_by_client',  # if supplied by client (implicit ONLY)\n            }\n\n        Note that while \"scope\" is a string-separated list of authorized scopes,\n        the original list is still available in request.scopes.\n\n        The token dict is passed as a reference so any changes made to the dictionary\n        will go back to the user.  If additional information must return to the client\n        user, and it is only possible to get this information after writing the token\n        to storage, it should be added to the token dictionary.  If the token\n        dictionary must be modified but the changes should not go back to the user,\n        a copy of the dictionary must be made before making the changes.\n\n        Also note that if an Authorization Code grant request included a valid claims\n        parameter (for OpenID Connect) then the request.claims property will contain\n        the claims dict, which should be saved for later use when generating the\n        id_token and/or UserInfo response content.\n\n        :param token: A Bearer token dict.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: The default redirect URI for the client\n\n        Method is used by all core grant types issuing Bearer tokens:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Resource Owner Password Credentials Grant (might not associate a client)\n            - Client Credentials grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_bearer_token(self, token, scopes, request):\n        \"\"\"Ensure the Bearer token is valid and authorized access to scopes.\n\n        :param token: A string of random characters.\n        :param scopes: A list of scopes associated with the protected resource.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        A key to OAuth 2 security and restricting impact of leaked tokens is\n        the short expiration time of tokens, *always ensure the token has not\n        expired!*.\n\n        Two different approaches to scope validation:\n\n            1) all(scopes). The token must be authorized access to all scopes\n                            associated with the resource. For example, the\n                            token has access to ``read-only`` and ``images``,\n                            thus the client can view images but not upload new.\n                            Allows for fine grained access control through\n                            combining various scopes.\n\n            2) any(scopes). The token must be authorized access to one of the\n                            scopes associated with the resource. For example,\n                            token has access to ``read-only-images``.\n                            Allows for fine grained, although arguably less\n                            convenient, access control.\n\n        A powerful way to use scopes would mimic UNIX ACLs and see a scope\n        as a group with certain privileges. For a restful API these might\n        map to HTTP verbs instead of read, write and execute.\n\n        Note, the request.user attribute can be set to the resource owner\n        associated with this token. Similarly the request.client and\n        request.scopes attribute can be set to associated client object\n        and authorized scopes. If you then use a decorator such as the\n        one provided for django these attributes will be made available\n        in all protected views as keyword arguments.\n\n        :param token: Unicode Bearer token\n        :param scopes: List of scopes (defined by you)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is indirectly used by all core Bearer token issuing grant types:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Resource Owner Password Credentials Grant\n            - Client Credentials Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_client_id(self, client_id, request, *args, **kwargs):\n        \"\"\"Ensure client_id belong to a valid and active client.\n\n        Note, while not strictly necessary it can often be very convenient\n        to set request.client to the client object associated with the\n        given client_id.\n\n        :param client_id: Unicode client identifier.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Implicit Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_code(self, client_id, code, client, request, *args, **kwargs):\n        \"\"\"Verify that the authorization_code is valid and assigned to the given\n        client.\n\n        Before returning true, set the following based on the information stored\n        with the code in 'save_authorization_code':\n\n            - request.user\n            - request.scopes\n            - request.claims (if given)\n\n        OBS! The request.user attribute should be set to the resource owner\n        associated with this authorization code. Similarly request.scopes\n        must also be set.\n\n        The request.claims property, if it was given, should assigned a dict.\n\n        If PKCE is enabled (see 'is_pkce_required' and 'save_authorization_code')\n        you MUST set the following based on the information stored:\n\n            - request.code_challenge\n            - request.code_challenge_method\n\n        :param client_id: Unicode client identifier.\n        :param code: Unicode authorization code.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_grant_type(self, client_id, grant_type, client, request, *args, **kwargs):\n        \"\"\"Ensure client is authorized to use the grant_type requested.\n\n        :param client_id: Unicode client identifier.\n        :param grant_type: Unicode grant type, i.e. authorization_code, password.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Resource Owner Password Credentials Grant\n            - Client Credentials Grant\n            - Refresh Token Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_redirect_uri(self, client_id, redirect_uri, request, *args, **kwargs):\n        \"\"\"Ensure client is authorized to redirect to the redirect_uri requested.\n\n        All clients should register the absolute URIs of all URIs they intend\n        to redirect to. The registration is outside of the scope of oauthlib.\n\n        :param client_id: Unicode client identifier.\n        :param redirect_uri: Unicode absolute URI.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Implicit Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_refresh_token(self, refresh_token, client, request, *args, **kwargs):\n        \"\"\"Ensure the Bearer token is valid and authorized access to scopes.\n\n        OBS! The request.user attribute should be set to the resource owner\n        associated with this refresh token.\n\n        :param refresh_token: Unicode refresh token.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant (indirectly by issuing refresh tokens)\n            - Resource Owner Password Credentials Grant (also indirectly)\n            - Refresh Token Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_response_type(self, client_id, response_type, client, request, *args, **kwargs):\n        \"\"\"Ensure client is authorized to use the response_type requested.\n\n        :param client_id: Unicode client identifier.\n        :param response_type: Unicode response type, i.e. code, token.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n            - Implicit Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_scopes(self, client_id, scopes, client, request, *args, **kwargs):\n        \"\"\"Ensure the client is authorized access to requested scopes.\n\n        :param client_id: Unicode client identifier.\n        :param scopes: List of scopes (defined by you).\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by all core grant types:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Resource Owner Password Credentials Grant\n            - Client Credentials Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_user(self, username, password, client, request, *args, **kwargs):\n        \"\"\"Ensure the username and password is valid.\n\n        OBS! The validation should also set the user attribute of the request\n        to a valid resource owner, i.e. request.user = username or similar. If\n        not set you will be unable to associate a token with a user in the\n        persistence method used (commonly, save_bearer_token).\n\n        :param username: Unicode username.\n        :param password: Unicode password.\n        :param client: Client object set by you, see ``.authenticate_client``.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Resource Owner Password Credentials Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def is_pkce_required(self, client_id, request):\n        \"\"\"Determine if current request requires PKCE. Default, False.\n        This is called for both \"authorization\" and \"token\" requests.\n\n        Override this method by ``return True`` to enable PKCE for everyone.\n        You might want to enable it only for public clients.\n        Note that PKCE can also be used in addition of a client authentication.\n\n        OAuth 2.0 public clients utilizing the Authorization Code Grant are\n        susceptible to the authorization code interception attack.  This\n        specification describes the attack as well as a technique to mitigate\n        against the threat through the use of Proof Key for Code Exchange\n        (PKCE, pronounced \"pixy\"). See `RFC7636`_.\n\n        :param client_id: Client identifier.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - Authorization Code Grant\n\n        .. _`RFC7636`: https://tools.ietf.org/html/rfc7636\n        \"\"\"\n        return False\n\n    def get_code_challenge(self, code, request):\n        \"\"\"Is called for every \"token\" requests.\n\n        When the server issues the authorization code in the authorization\n        response, it MUST associate the ``code_challenge`` and\n        ``code_challenge_method`` values with the authorization code so it can\n        be verified later.\n\n        Typically, the ``code_challenge`` and ``code_challenge_method`` values\n        are stored in encrypted form in the ``code`` itself but could\n        alternatively be stored on the server associated with the code.  The\n        server MUST NOT include the ``code_challenge`` value in client requests\n        in a form that other entities can extract.\n\n        Return the ``code_challenge`` associated to the code.\n        If ``None`` is returned, code is considered to not be associated to any\n        challenges.\n\n        :param code: Authorization code.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: code_challenge string\n\n        Method is used by:\n            - Authorization Code Grant - when PKCE is active\n\n        \"\"\"\n        return None\n\n    def get_code_challenge_method(self, code, request):\n        \"\"\"Is called during the \"token\" request processing, when a\n        ``code_verifier`` and a ``code_challenge`` has been provided.\n\n        See ``.get_code_challenge``.\n\n        Must return ``plain`` or ``S256``. You can return a custom value if you have\n        implemented your own ``AuthorizationCodeGrant`` class.\n\n        :param code: Authorization code.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: code_challenge_method string\n\n        Method is used by:\n            - Authorization Code Grant - when PKCE is active\n\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def is_origin_allowed(self, client_id, origin, request, *args, **kwargs):\n        \"\"\"Indicate if the given origin is allowed to access the token endpoint\n        via Cross-Origin Resource Sharing (CORS).  CORS is used by browser-based\n        clients, such as Single-Page Applications, to perform the Authorization\n        Code Grant.\n\n        (Note:  If performing Authorization Code Grant via a public client such\n        as a browser, you should use PKCE as well.)\n\n        If this method returns true, the appropriate CORS headers will be added\n        to the response.  By default this method always returns False, meaning\n        CORS is disabled.\n\n        :param client_id: Unicode client identifier.\n        :param redirect_uri: Unicode origin.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: bool\n\n        Method is used by:\n            - Authorization Code Grant\n            - Refresh Token Grant\n\n        \"\"\"\n        return False\n", "oauthlib/oauth2/rfc6749/grant_types/client_credentials.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport json\nimport logging\n\nfrom .. import errors\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass ClientCredentialsGrant(GrantTypeBase):\n\n    \"\"\"`Client Credentials Grant`_\n\n    The client can request an access token using only its client\n    credentials (or other supported means of authentication) when the\n    client is requesting access to the protected resources under its\n    control, or those of another resource owner that have been previously\n    arranged with the authorization server (the method of which is beyond\n    the scope of this specification).\n\n    The client credentials grant type MUST only be used by confidential\n    clients::\n\n        +---------+                                  +---------------+\n        :         :                                  :               :\n        :         :>-- A - Client Authentication --->: Authorization :\n        : Client  :                                  :     Server    :\n        :         :<-- B ---- Access Token ---------<:               :\n        :         :                                  :               :\n        +---------+                                  +---------------+\n\n    Figure 6: Client Credentials Flow\n\n    The flow illustrated in Figure 6 includes the following steps:\n\n    (A)  The client authenticates with the authorization server and\n            requests an access token from the token endpoint.\n\n    (B)  The authorization server authenticates the client, and if valid,\n            issues an access token.\n\n    .. _`Client Credentials Grant`: https://tools.ietf.org/html/rfc6749#section-4.4\n    \"\"\"\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Return token or error in JSON format.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        If the access token request is valid and authorized, the\n        authorization server issues an access token as described in\n        `Section 5.1`_.  A refresh token SHOULD NOT be included.  If the request\n        failed client authentication or is invalid, the authorization server\n        returns an error response as described in `Section 5.2`_.\n\n        .. _`Section 5.1`: https://tools.ietf.org/html/rfc6749#section-5.1\n        .. _`Section 5.2`: https://tools.ietf.org/html/rfc6749#section-5.2\n        \"\"\"\n        headers = self._get_default_headers()\n        try:\n            log.debug('Validating access token request, %r.', request)\n            self.validate_token_request(request)\n        except errors.OAuth2Error as e:\n            log.debug('Client error in token request. %s.', e)\n            headers.update(e.headers)\n            return headers, e.json, e.status_code\n\n        token = token_handler.create_token(request, refresh_token=False)\n\n        for modifier in self._token_modifiers:\n            token = modifier(token)\n\n        self.request_validator.save_token(token, request)\n\n        log.debug('Issuing token to client id %r (%r), %r.',\n                  request.client_id, request.client, token)\n        return headers, json.dumps(token), 200\n\n    def validate_token_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        for validator in self.custom_validators.pre_token:\n            validator(request)\n\n        if not getattr(request, 'grant_type', None):\n            raise errors.InvalidRequestError('Request is missing grant type.',\n                                             request=request)\n\n        if not request.grant_type == 'client_credentials':\n            raise errors.UnsupportedGrantTypeError(request=request)\n\n        for param in ('grant_type', 'scope'):\n            if param in request.duplicate_params:\n                raise errors.InvalidRequestError(description='Duplicate %s parameter.' % param,\n                                                 request=request)\n\n        log.debug('Authenticating client, %r.', request)\n        if not self.request_validator.authenticate_client(request):\n            log.debug('Client authentication failed, %r.', request)\n            raise errors.InvalidClientError(request=request)\n        elif not hasattr(request.client, 'client_id'):\n            raise NotImplementedError('Authenticate client must set the '\n                                      'request.client.client_id attribute '\n                                      'in authenticate_client.')\n        # Ensure client is authorized use of this grant type\n        self.validate_grant_type(request)\n\n        request.client_id = request.client_id or request.client.client_id\n        log.debug('Authorizing access to client %r.', request.client_id)\n        self.validate_scopes(request)\n\n        for validator in self.custom_validators.post_token:\n            validator(request)\n", "oauthlib/oauth2/rfc6749/grant_types/authorization_code.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport base64\nimport hashlib\nimport json\nimport logging\n\nfrom oauthlib import common\n\nfrom .. import errors\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\ndef code_challenge_method_s256(verifier, challenge):\n    \"\"\"\n    If the \"code_challenge_method\" from `Section 4.3`_ was \"S256\", the\n    received \"code_verifier\" is hashed by SHA-256, base64url-encoded, and\n    then compared to the \"code_challenge\", i.e.:\n\n    BASE64URL-ENCODE(SHA256(ASCII(code_verifier))) == code_challenge\n\n    How to implement a base64url-encoding\n    function without padding, based upon the standard base64-encoding\n    function that uses padding.\n\n    To be concrete, example C# code implementing these functions is shown\n    below.  Similar code could be used in other languages.\n\n    static string base64urlencode(byte [] arg)\n    {\n        string s = Convert.ToBase64String(arg); // Regular base64 encoder\n        s = s.Split('=')[0]; // Remove any trailing '='s\n        s = s.Replace('+', '-'); // 62nd char of encoding\n        s = s.Replace('/', '_'); // 63rd char of encoding\n        return s;\n    }\n\n    In python urlsafe_b64encode is already replacing '+' and '/', but preserve\n    the trailing '='. So we have to remove it.\n\n    .. _`Section 4.3`: https://tools.ietf.org/html/rfc7636#section-4.3\n    \"\"\"\n    return base64.urlsafe_b64encode(\n        hashlib.sha256(verifier.encode()).digest()\n    ).decode().rstrip('=') == challenge\n\n\ndef code_challenge_method_plain(verifier, challenge):\n    \"\"\"\n    If the \"code_challenge_method\" from `Section 4.3`_ was \"plain\", they are\n    compared directly, i.e.:\n\n    code_verifier == code_challenge.\n\n    .. _`Section 4.3`: https://tools.ietf.org/html/rfc7636#section-4.3\n    \"\"\"\n    return verifier == challenge\n\n\nclass AuthorizationCodeGrant(GrantTypeBase):\n\n    \"\"\"`Authorization Code Grant`_\n\n    The authorization code grant type is used to obtain both access\n    tokens and refresh tokens and is optimized for confidential clients.\n    Since this is a redirection-based flow, the client must be capable of\n    interacting with the resource owner's user-agent (typically a web\n    browser) and capable of receiving incoming requests (via redirection)\n    from the authorization server::\n\n        +----------+\n        | Resource |\n        |   Owner  |\n        |          |\n        +----------+\n             ^\n             |\n            (B)\n        +----|-----+          Client Identifier      +---------------+\n        |         -+----(A)-- & Redirection URI ---->|               |\n        |  User-   |                                 | Authorization |\n        |  Agent  -+----(B)-- User authenticates --->|     Server    |\n        |          |                                 |               |\n        |         -+----(C)-- Authorization Code ---<|               |\n        +-|----|---+                                 +---------------+\n          |    |                                         ^      v\n         (A)  (C)                                        |      |\n          |    |                                         |      |\n          ^    v                                         |      |\n        +---------+                                      |      |\n        |         |>---(D)-- Authorization Code ---------'      |\n        |  Client |          & Redirection URI                  |\n        |         |                                             |\n        |         |<---(E)----- Access Token -------------------'\n        +---------+       (w/ Optional Refresh Token)\n\n    Note: The lines illustrating steps (A), (B), and (C) are broken into\n    two parts as they pass through the user-agent.\n\n    Figure 3: Authorization Code Flow\n\n    The flow illustrated in Figure 3 includes the following steps:\n\n    (A)  The client initiates the flow by directing the resource owner's\n         user-agent to the authorization endpoint.  The client includes\n         its client identifier, requested scope, local state, and a\n         redirection URI to which the authorization server will send the\n         user-agent back once access is granted (or denied).\n\n    (B)  The authorization server authenticates the resource owner (via\n         the user-agent) and establishes whether the resource owner\n         grants or denies the client's access request.\n\n    (C)  Assuming the resource owner grants access, the authorization\n         server redirects the user-agent back to the client using the\n         redirection URI provided earlier (in the request or during\n         client registration).  The redirection URI includes an\n         authorization code and any local state provided by the client\n         earlier.\n\n    (D)  The client requests an access token from the authorization\n         server's token endpoint by including the authorization code\n         received in the previous step.  When making the request, the\n         client authenticates with the authorization server.  The client\n         includes the redirection URI used to obtain the authorization\n         code for verification.\n\n    (E)  The authorization server authenticates the client, validates the\n         authorization code, and ensures that the redirection URI\n         received matches the URI used to redirect the client in\n         step (C).  If valid, the authorization server responds back with\n         an access token and, optionally, a refresh token.\n\n    OAuth 2.0 public clients utilizing the Authorization Code Grant are\n    susceptible to the authorization code interception attack.\n\n    A technique to mitigate against the threat through the use of Proof Key for Code\n    Exchange (PKCE, pronounced \"pixy\") is implemented in the current oauthlib\n    implementation.\n\n    .. _`Authorization Code Grant`: https://tools.ietf.org/html/rfc6749#section-4.1\n    .. _`PKCE`: https://tools.ietf.org/html/rfc7636\n    \"\"\"\n\n    default_response_mode = 'query'\n    response_types = ['code']\n\n    # This dict below is private because as RFC mention it:\n    # \"S256\" is Mandatory To Implement (MTI) on the server.\n    #\n    _code_challenge_methods = {\n        'plain': code_challenge_method_plain,\n        'S256': code_challenge_method_s256\n    }\n\n    def create_authorization_code(self, request):\n        \"\"\"\n        Generates an authorization grant represented as a dictionary.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        grant = {'code': common.generate_token()}\n        if hasattr(request, 'state') and request.state:\n            grant['state'] = request.state\n        log.debug('Created authorization code grant %r for request %r.',\n                  grant, request)\n        return grant\n\n    def create_authorization_response(self, request, token_handler):\n        \"\"\"\n        The client constructs the request URI by adding the following\n        parameters to the query component of the authorization endpoint URI\n        using the \"application/x-www-form-urlencoded\" format, per `Appendix B`_:\n\n        response_type\n                REQUIRED.  Value MUST be set to \"code\" for standard OAuth2\n                authorization flow.  For OpenID Connect it must be one of\n                \"code token\", \"code id_token\", or \"code token id_token\" - we\n                essentially test that \"code\" appears in the response_type.\n        client_id\n                REQUIRED.  The client identifier as described in `Section 2.2`_.\n        redirect_uri\n                OPTIONAL.  As described in `Section 3.1.2`_.\n        scope\n                OPTIONAL.  The scope of the access request as described by\n                `Section 3.3`_.\n        state\n                RECOMMENDED.  An opaque value used by the client to maintain\n                state between the request and callback.  The authorization\n                server includes this value when redirecting the user-agent back\n                to the client.  The parameter SHOULD be used for preventing\n                cross-site request forgery as described in `Section 10.12`_.\n\n        The client directs the resource owner to the constructed URI using an\n        HTTP redirection response, or by other means available to it via the\n        user-agent.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n        :returns: headers, body, status\n        :raises: FatalClientError on invalid redirect URI or client id.\n\n        A few examples::\n\n            >>> from your_validator import your_validator\n            >>> request = Request('https://example.com/authorize?client_id=valid'\n            ...                   '&redirect_uri=http%3A%2F%2Fclient.com%2F')\n            >>> from oauthlib.common import Request\n            >>> from oauthlib.oauth2 import AuthorizationCodeGrant, BearerToken\n            >>> token = BearerToken(your_validator)\n            >>> grant = AuthorizationCodeGrant(your_validator)\n            >>> request.scopes = ['authorized', 'in', 'some', 'form']\n            >>> grant.create_authorization_response(request, token)\n            (u'http://client.com/?error=invalid_request&error_description=Missing+response_type+parameter.', None, None, 400)\n            >>> request = Request('https://example.com/authorize?client_id=valid'\n            ...                   '&redirect_uri=http%3A%2F%2Fclient.com%2F'\n            ...                   '&response_type=code')\n            >>> request.scopes = ['authorized', 'in', 'some', 'form']\n            >>> grant.create_authorization_response(request, token)\n            (u'http://client.com/?code=u3F05aEObJuP2k7DordviIgW5wl52N', None, None, 200)\n            >>> # If the client id or redirect uri fails validation\n            >>> grant.create_authorization_response(request, token)\n            Traceback (most recent call last):\n                File \"<stdin>\", line 1, in <module>\n                File \"oauthlib/oauth2/rfc6749/grant_types.py\", line 515, in create_authorization_response\n                    >>> grant.create_authorization_response(request, token)\n                File \"oauthlib/oauth2/rfc6749/grant_types.py\", line 591, in validate_authorization_request\n            oauthlib.oauth2.rfc6749.errors.InvalidClientIdError\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 2.2`: https://tools.ietf.org/html/rfc6749#section-2.2\n        .. _`Section 3.1.2`: https://tools.ietf.org/html/rfc6749#section-3.1.2\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 10.12`: https://tools.ietf.org/html/rfc6749#section-10.12\n        \"\"\"\n        try:\n            self.validate_authorization_request(request)\n            log.debug('Pre resource owner authorization validation ok for %r.',\n                      request)\n\n        # If the request fails due to a missing, invalid, or mismatching\n        # redirection URI, or if the client identifier is missing or invalid,\n        # the authorization server SHOULD inform the resource owner of the\n        # error and MUST NOT automatically redirect the user-agent to the\n        # invalid redirection URI.\n        except errors.FatalClientError as e:\n            log.debug('Fatal client error during validation of %r. %r.',\n                      request, e)\n            raise\n\n        # If the resource owner denies the access request or if the request\n        # fails for reasons other than a missing or invalid redirection URI,\n        # the authorization server informs the client by adding the following\n        # parameters to the query component of the redirection URI using the\n        # \"application/x-www-form-urlencoded\" format, per Appendix B:\n        # https://tools.ietf.org/html/rfc6749#appendix-B\n        except errors.OAuth2Error as e:\n            log.debug('Client error during validation of %r. %r.', request, e)\n            request.redirect_uri = request.redirect_uri or self.error_uri\n            redirect_uri = common.add_params_to_uri(\n                request.redirect_uri, e.twotuples,\n                fragment=request.response_mode == \"fragment\")\n            return {'Location': redirect_uri}, None, 302\n\n        grant = self.create_authorization_code(request)\n        for modifier in self._code_modifiers:\n            grant = modifier(grant, token_handler, request)\n        if 'access_token' in grant:\n            self.request_validator.save_token(grant, request)\n        log.debug('Saving grant %r for %r.', grant, request)\n        self.request_validator.save_authorization_code(\n            request.client_id, grant, request)\n        return self.prepare_authorization_response(\n            request, grant, {}, None, 302)\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Validate the authorization code.\n\n        The client MUST NOT use the authorization code more than once. If an\n        authorization code is used more than once, the authorization server\n        MUST deny the request and SHOULD revoke (when possible) all tokens\n        previously issued based on that authorization code. The authorization\n        code is bound to the client identifier and redirection URI.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        \"\"\"\n        headers = self._get_default_headers()\n        try:\n            self.validate_token_request(request)\n            log.debug('Token request validation ok for %r.', request)\n        except errors.OAuth2Error as e:\n            log.debug('Client error during validation of %r. %r.', request, e)\n            headers.update(e.headers)\n            return headers, e.json, e.status_code\n\n        token = token_handler.create_token(request, refresh_token=self.refresh_token)\n\n        for modifier in self._token_modifiers:\n            token = modifier(token, token_handler, request)\n\n        self.request_validator.save_token(token, request)\n        self.request_validator.invalidate_authorization_code(\n            request.client_id, request.code, request)\n        headers.update(self._create_cors_headers(request))\n        return headers, json.dumps(token), 200\n\n    def validate_authorization_request(self, request):\n        \"\"\"Check the authorization request for normal and fatal errors.\n\n        A normal error could be a missing response_type parameter or the client\n        attempting to access scope it is not allowed to ask authorization for.\n        Normal errors can safely be included in the redirection URI and\n        sent back to the client.\n\n        Fatal errors occur when the client_id or redirect_uri is invalid or\n        missing. These must be caught by the provider and handled, how this\n        is done is outside of the scope of OAuthLib but showing an error\n        page describing the issue is a good idea.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n\n        # First check for fatal errors\n\n        # If the request fails due to a missing, invalid, or mismatching\n        # redirection URI, or if the client identifier is missing or invalid,\n        # the authorization server SHOULD inform the resource owner of the\n        # error and MUST NOT automatically redirect the user-agent to the\n        # invalid redirection URI.\n\n        # First check duplicate parameters\n        for param in ('client_id', 'response_type', 'redirect_uri', 'scope', 'state'):\n            try:\n                duplicate_params = request.duplicate_params\n            except ValueError:\n                raise errors.InvalidRequestFatalError(description='Unable to parse query string', request=request)\n            if param in duplicate_params:\n                raise errors.InvalidRequestFatalError(description='Duplicate %s parameter.' % param, request=request)\n\n        # REQUIRED. The client identifier as described in Section 2.2.\n        # https://tools.ietf.org/html/rfc6749#section-2.2\n        if not request.client_id:\n            raise errors.MissingClientIdError(request=request)\n\n        if not self.request_validator.validate_client_id(request.client_id, request):\n            raise errors.InvalidClientIdError(request=request)\n\n        # OPTIONAL. As described in Section 3.1.2.\n        # https://tools.ietf.org/html/rfc6749#section-3.1.2\n        log.debug('Validating redirection uri %s for client %s.',\n                  request.redirect_uri, request.client_id)\n\n        # OPTIONAL. As described in Section 3.1.2.\n        # https://tools.ietf.org/html/rfc6749#section-3.1.2\n        self._handle_redirects(request)\n\n        # Then check for normal errors.\n\n        # If the resource owner denies the access request or if the request\n        # fails for reasons other than a missing or invalid redirection URI,\n        # the authorization server informs the client by adding the following\n        # parameters to the query component of the redirection URI using the\n        # \"application/x-www-form-urlencoded\" format, per Appendix B.\n        # https://tools.ietf.org/html/rfc6749#appendix-B\n\n        # Note that the correct parameters to be added are automatically\n        # populated through the use of specific exceptions.\n\n        request_info = {}\n        for validator in self.custom_validators.pre_auth:\n            request_info.update(validator(request))\n\n        # REQUIRED.\n        if request.response_type is None:\n            raise errors.MissingResponseTypeError(request=request)\n        # Value MUST be set to \"code\" or one of the OpenID authorization code including\n        # response_types \"code token\", \"code id_token\", \"code token id_token\"\n        elif 'code' not in request.response_type and request.response_type != 'none':\n            raise errors.UnsupportedResponseTypeError(request=request)\n\n        if not self.request_validator.validate_response_type(request.client_id,\n                                                             request.response_type,\n                                                             request.client, request):\n\n            log.debug('Client %s is not authorized to use response_type %s.',\n                      request.client_id, request.response_type)\n            raise errors.UnauthorizedClientError(request=request)\n\n        # OPTIONAL. Validate PKCE request or reply with \"error\"/\"invalid_request\"\n        # https://tools.ietf.org/html/rfc6749#section-4.4.1\n        if self.request_validator.is_pkce_required(request.client_id, request) is True and request.code_challenge is None:\n            raise errors.MissingCodeChallengeError(request=request)\n\n        if request.code_challenge is not None:\n            request_info[\"code_challenge\"] = request.code_challenge\n\n            # OPTIONAL, defaults to \"plain\" if not present in the request.\n            if request.code_challenge_method is None:\n                request.code_challenge_method = \"plain\"\n\n            if request.code_challenge_method not in self._code_challenge_methods:\n                raise errors.UnsupportedCodeChallengeMethodError(request=request)\n            request_info[\"code_challenge_method\"] = request.code_challenge_method\n\n        # OPTIONAL. The scope of the access request as described by Section 3.3\n        # https://tools.ietf.org/html/rfc6749#section-3.3\n        self.validate_scopes(request)\n\n        request_info.update({\n            'client_id': request.client_id,\n            'redirect_uri': request.redirect_uri,\n            'response_type': request.response_type,\n            'state': request.state,\n            'request': request\n        })\n\n        for validator in self.custom_validators.post_auth:\n            request_info.update(validator(request))\n\n        return request.scopes, request_info\n\n    def validate_token_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        # REQUIRED. Value MUST be set to \"authorization_code\".\n        if request.grant_type not in ('authorization_code', 'openid'):\n            raise errors.UnsupportedGrantTypeError(request=request)\n\n        for validator in self.custom_validators.pre_token:\n            validator(request)\n\n        if request.code is None:\n            raise errors.InvalidRequestError(\n                description='Missing code parameter.', request=request)\n\n        for param in ('client_id', 'grant_type', 'redirect_uri'):\n            if param in request.duplicate_params:\n                raise errors.InvalidRequestError(description='Duplicate %s parameter.' % param,\n                                                 request=request)\n\n        if self.request_validator.client_authentication_required(request):\n            # If the client type is confidential or the client was issued client\n            # credentials (or assigned other authentication requirements), the\n            # client MUST authenticate with the authorization server as described\n            # in Section 3.2.1.\n            # https://tools.ietf.org/html/rfc6749#section-3.2.1\n            if not self.request_validator.authenticate_client(request):\n                log.debug('Client authentication failed, %r.', request)\n                raise errors.InvalidClientError(request=request)\n        elif not self.request_validator.authenticate_client_id(request.client_id, request):\n            # REQUIRED, if the client is not authenticating with the\n            # authorization server as described in Section 3.2.1.\n            # https://tools.ietf.org/html/rfc6749#section-3.2.1\n            log.debug('Client authentication failed, %r.', request)\n            raise errors.InvalidClientError(request=request)\n\n        if not hasattr(request.client, 'client_id'):\n            raise NotImplementedError('Authenticate client must set the '\n                                      'request.client.client_id attribute '\n                                      'in authenticate_client.')\n\n        request.client_id = request.client_id or request.client.client_id\n\n        # Ensure client is authorized use of this grant type\n        self.validate_grant_type(request)\n\n        # REQUIRED. The authorization code received from the\n        # authorization server.\n        if not self.request_validator.validate_code(request.client_id,\n                                                    request.code, request.client, request):\n            log.debug('Client, %r (%r), is not allowed access to scopes %r.',\n                      request.client_id, request.client, request.scopes)\n            raise errors.InvalidGrantError(request=request)\n\n        # OPTIONAL. Validate PKCE code_verifier\n        challenge = self.request_validator.get_code_challenge(request.code, request)\n\n        if challenge is not None:\n            if request.code_verifier is None:\n                raise errors.MissingCodeVerifierError(request=request)\n\n            challenge_method = self.request_validator.get_code_challenge_method(request.code, request)\n            if challenge_method is None:\n                raise errors.InvalidGrantError(request=request, description=\"Challenge method not found\")\n\n            if challenge_method not in self._code_challenge_methods:\n                raise errors.ServerError(\n                    description=\"code_challenge_method {} is not supported.\".format(challenge_method),\n                    request=request\n                )\n\n            if not self.validate_code_challenge(challenge,\n                                                challenge_method,\n                                                request.code_verifier):\n                log.debug('request provided a invalid code_verifier.')\n                raise errors.InvalidGrantError(request=request)\n        elif self.request_validator.is_pkce_required(request.client_id, request) is True:\n            if request.code_verifier is None:\n                raise errors.MissingCodeVerifierError(request=request)\n            raise errors.InvalidGrantError(request=request, description=\"Challenge not found\")\n\n        for attr in ('user', 'scopes'):\n            if getattr(request, attr, None) is None:\n                log.debug('request.%s was not set on code validation.', attr)\n\n        # REQUIRED, if the \"redirect_uri\" parameter was included in the\n        # authorization request as described in Section 4.1.1, and their\n        # values MUST be identical.\n        if request.redirect_uri is None:\n            request.using_default_redirect_uri = True\n            request.redirect_uri = self.request_validator.get_default_redirect_uri(\n                request.client_id, request)\n            log.debug('Using default redirect_uri %s.', request.redirect_uri)\n            if not request.redirect_uri:\n                raise errors.MissingRedirectURIError(request=request)\n        else:\n            request.using_default_redirect_uri = False\n            log.debug('Using provided redirect_uri %s', request.redirect_uri)\n\n        if not self.request_validator.confirm_redirect_uri(request.client_id, request.code,\n                                                           request.redirect_uri, request.client,\n                                                           request):\n            log.debug('Redirect_uri (%r) invalid for client %r (%r).',\n                      request.redirect_uri, request.client_id, request.client)\n            raise errors.MismatchingRedirectURIError(request=request)\n\n        for validator in self.custom_validators.post_token:\n            validator(request)\n\n    def validate_code_challenge(self, challenge, challenge_method, verifier):\n        if challenge_method in self._code_challenge_methods:\n            return self._code_challenge_methods[challenge_method](verifier, challenge)\n        raise NotImplementedError('Unknown challenge_method %s' % challenge_method)\n", "oauthlib/oauth2/rfc6749/grant_types/refresh_token.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport json\nimport logging\n\nfrom .. import errors, utils\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass RefreshTokenGrant(GrantTypeBase):\n\n    \"\"\"`Refresh token grant`_\n\n    .. _`Refresh token grant`: https://tools.ietf.org/html/rfc6749#section-6\n    \"\"\"\n\n    def __init__(self, request_validator=None,\n                 issue_new_refresh_tokens=True,\n                 **kwargs):\n        super().__init__(\n            request_validator,\n            issue_new_refresh_tokens=issue_new_refresh_tokens,\n            **kwargs)\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Create a new access token from a refresh_token.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        If valid and authorized, the authorization server issues an access\n        token as described in `Section 5.1`_. If the request failed\n        verification or is invalid, the authorization server returns an error\n        response as described in `Section 5.2`_.\n\n        The authorization server MAY issue a new refresh token, in which case\n        the client MUST discard the old refresh token and replace it with the\n        new refresh token. The authorization server MAY revoke the old\n        refresh token after issuing a new refresh token to the client. If a\n        new refresh token is issued, the refresh token scope MUST be\n        identical to that of the refresh token included by the client in the\n        request.\n\n        .. _`Section 5.1`: https://tools.ietf.org/html/rfc6749#section-5.1\n        .. _`Section 5.2`: https://tools.ietf.org/html/rfc6749#section-5.2\n        \"\"\"\n        headers = self._get_default_headers()\n        try:\n            log.debug('Validating refresh token request, %r.', request)\n            self.validate_token_request(request)\n        except errors.OAuth2Error as e:\n            log.debug('Client error in token request, %s.', e)\n            headers.update(e.headers)\n            return headers, e.json, e.status_code\n\n        token = token_handler.create_token(request,\n                                           refresh_token=self.issue_new_refresh_tokens)\n\n        for modifier in self._token_modifiers:\n            token = modifier(token, token_handler, request)\n\n        self.request_validator.save_token(token, request)\n\n        log.debug('Issuing new token to client id %r (%r), %r.',\n                  request.client_id, request.client, token)\n        headers.update(self._create_cors_headers(request))\n        return headers, json.dumps(token), 200\n\n    def validate_token_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        # REQUIRED. Value MUST be set to \"refresh_token\".\n        if request.grant_type != 'refresh_token':\n            raise errors.UnsupportedGrantTypeError(request=request)\n\n        for validator in self.custom_validators.pre_token:\n            validator(request)\n\n        if request.refresh_token is None:\n            raise errors.InvalidRequestError(\n                description='Missing refresh token parameter.',\n                request=request)\n\n        # Because refresh tokens are typically long-lasting credentials used to\n        # request additional access tokens, the refresh token is bound to the\n        # client to which it was issued.  If the client type is confidential or\n        # the client was issued client credentials (or assigned other\n        # authentication requirements), the client MUST authenticate with the\n        # authorization server as described in Section 3.2.1.\n        # https://tools.ietf.org/html/rfc6749#section-3.2.1\n        if self.request_validator.client_authentication_required(request):\n            log.debug('Authenticating client, %r.', request)\n            if not self.request_validator.authenticate_client(request):\n                log.debug('Invalid client (%r), denying access.', request)\n                raise errors.InvalidClientError(request=request)\n            # Ensure that request.client_id is set.\n            if request.client_id is None and request.client is not None:\n                request.client_id = request.client.client_id\n        elif not self.request_validator.authenticate_client_id(request.client_id, request):\n            log.debug('Client authentication failed, %r.', request)\n            raise errors.InvalidClientError(request=request)\n\n        # Ensure client is authorized use of this grant type\n        self.validate_grant_type(request)\n\n        # REQUIRED. The refresh token issued to the client.\n        log.debug('Validating refresh token %s for client %r.',\n                  request.refresh_token, request.client)\n        if not self.request_validator.validate_refresh_token(\n                request.refresh_token, request.client, request):\n            log.debug('Invalid refresh token, %s, for client %r.',\n                      request.refresh_token, request.client)\n            raise errors.InvalidGrantError(request=request)\n\n        original_scopes = utils.scope_to_list(\n            self.request_validator.get_original_scopes(\n                request.refresh_token, request))\n\n        if request.scope:\n            request.scopes = utils.scope_to_list(request.scope)\n            if (not all(s in original_scopes for s in request.scopes)\n                and not self.request_validator.is_within_original_scope(\n                    request.scopes, request.refresh_token, request)):\n                log.debug('Refresh token %s lack requested scopes, %r.',\n                          request.refresh_token, request.scopes)\n                raise errors.InvalidScopeError(request=request)\n        else:\n            request.scopes = original_scopes\n\n        for validator in self.custom_validators.post_token:\n            validator(request)\n", "oauthlib/oauth2/rfc6749/grant_types/base.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\nfrom itertools import chain\n\nfrom oauthlib.common import add_params_to_uri\nfrom oauthlib.oauth2.rfc6749 import errors, utils\nfrom oauthlib.uri_validate import is_absolute_uri\n\nfrom ..request_validator import RequestValidator\nfrom ..utils import is_secure_transport\n\nlog = logging.getLogger(__name__)\n\n\nclass ValidatorsContainer:\n    \"\"\"\n    Container object for holding custom validator callables to be invoked\n    as part of the grant type `validate_authorization_request()` or\n    `validate_authorization_request()` methods on the various grant types.\n\n    Authorization validators must be callables that take a request object and\n    return a dict, which may contain items to be added to the `request_info`\n    returned from the grant_type after validation.\n\n    Token validators must be callables that take a request object and\n    return None.\n\n    Both authorization validators and token validators may raise OAuth2\n    exceptions if validation conditions fail.\n\n    Authorization validators added to `pre_auth` will be run BEFORE\n    the standard validations (but after the critical ones that raise\n    fatal errors) as part of `validate_authorization_request()`\n\n    Authorization validators added to `post_auth` will be run AFTER\n    the standard validations as part of `validate_authorization_request()`\n\n    Token validators added to `pre_token` will be run BEFORE\n    the standard validations as part of `validate_token_request()`\n\n    Token validators added to `post_token` will be run AFTER\n    the standard validations as part of `validate_token_request()`\n\n    For example:\n\n    >>> def my_auth_validator(request):\n    ...    return {'myval': True}\n    >>> auth_code_grant = AuthorizationCodeGrant(request_validator)\n    >>> auth_code_grant.custom_validators.pre_auth.append(my_auth_validator)\n    >>> def my_token_validator(request):\n    ...     if not request.everything_okay:\n    ...         raise errors.OAuth2Error(\"uh-oh\")\n    >>> auth_code_grant.custom_validators.post_token.append(my_token_validator)\n    \"\"\"\n\n    def __init__(self, post_auth, post_token,\n                 pre_auth, pre_token):\n        self.pre_auth = pre_auth\n        self.post_auth = post_auth\n        self.pre_token = pre_token\n        self.post_token = post_token\n\n    @property\n    def all_pre(self):\n        return chain(self.pre_auth, self.pre_token)\n\n    @property\n    def all_post(self):\n        return chain(self.post_auth, self.post_token)\n\n\nclass GrantTypeBase:\n    error_uri = None\n    request_validator = None\n    default_response_mode = 'fragment'\n    refresh_token = True\n    response_types = ['code']\n\n    def __init__(self, request_validator=None, **kwargs):\n        self.request_validator = request_validator or RequestValidator()\n\n        # Transforms class variables into instance variables:\n        self.response_types = self.response_types\n        self.refresh_token = self.refresh_token\n        self._setup_custom_validators(kwargs)\n        self._code_modifiers = []\n        self._token_modifiers = []\n\n        for kw, val in kwargs.items():\n            setattr(self, kw, val)\n\n    def _setup_custom_validators(self, kwargs):\n        post_auth = kwargs.get('post_auth', [])\n        post_token = kwargs.get('post_token', [])\n        pre_auth = kwargs.get('pre_auth', [])\n        pre_token = kwargs.get('pre_token', [])\n        if not hasattr(self, 'validate_authorization_request'):\n            if post_auth or pre_auth:\n                msg = (\"{} does not support authorization validators. Use \"\n                       \"token validators instead.\").format(self.__class__.__name__)\n                raise ValueError(msg)\n            # Using tuples here because they can't be appended to:\n            post_auth, pre_auth = (), ()\n        self.custom_validators = ValidatorsContainer(post_auth, post_token,\n                                                     pre_auth, pre_token)\n\n    def register_response_type(self, response_type):\n        self.response_types.append(response_type)\n\n    def register_code_modifier(self, modifier):\n        self._code_modifiers.append(modifier)\n\n    def register_token_modifier(self, modifier):\n        self._token_modifiers.append(modifier)\n\n    def create_authorization_response(self, request, token_handler):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def add_token(self, token, token_handler, request):\n        \"\"\"\n        :param token:\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        # Only add a hybrid access token on auth step if asked for\n        if request.response_type not in [\"token\", \"code token\", \"id_token token\", \"code id_token token\"]:\n            return token\n\n        token.update(token_handler.create_token(request, refresh_token=False))\n        return token\n\n    def validate_grant_type(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        client_id = getattr(request, 'client_id', None)\n        if not self.request_validator.validate_grant_type(client_id,\n                                                          request.grant_type, request.client, request):\n            log.debug('Unauthorized from %r (%r) access to grant type %s.',\n                      request.client_id, request.client, request.grant_type)\n            raise errors.UnauthorizedClientError(request=request)\n\n    def validate_scopes(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        if not request.scopes:\n            request.scopes = utils.scope_to_list(request.scope) or utils.scope_to_list(\n                self.request_validator.get_default_scopes(request.client_id, request))\n        log.debug('Validating access to scopes %r for client %r (%r).',\n                  request.scopes, request.client_id, request.client)\n        if not self.request_validator.validate_scopes(request.client_id,\n                                                      request.scopes, request.client, request):\n            raise errors.InvalidScopeError(request=request)\n\n    def prepare_authorization_response(self, request, token, headers, body, status):\n        \"\"\"Place token according to response mode.\n\n        Base classes can define a default response mode for their authorization\n        response by overriding the static `default_response_mode` member.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token:\n        :param headers:\n        :param body:\n        :param status:\n        \"\"\"\n        request.response_mode = request.response_mode or self.default_response_mode\n\n        if request.response_mode not in ('query', 'fragment'):\n            log.debug('Overriding invalid response mode %s with %s',\n                      request.response_mode, self.default_response_mode)\n            request.response_mode = self.default_response_mode\n\n        token_items = token.items()\n\n        if request.response_type == 'none':\n            state = token.get('state', None)\n            token_items = [('state', state)] if state else []\n\n        if request.response_mode == 'query':\n            headers['Location'] = add_params_to_uri(\n                request.redirect_uri, token_items, fragment=False)\n            return headers, body, status\n\n        if request.response_mode == 'fragment':\n            headers['Location'] = add_params_to_uri(\n                request.redirect_uri, token_items, fragment=True)\n            return headers, body, status\n\n        raise NotImplementedError(\n            'Subclasses must set a valid default_response_mode')\n\n    def _get_default_headers(self):\n        \"\"\"Create default headers for grant responses.\"\"\"\n        return {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-store',\n            'Pragma': 'no-cache',\n        }\n\n    def _handle_redirects(self, request):\n        if request.redirect_uri is not None:\n            request.using_default_redirect_uri = False\n            log.debug('Using provided redirect_uri %s', request.redirect_uri)\n            if not is_absolute_uri(request.redirect_uri):\n                raise errors.InvalidRedirectURIError(request=request)\n\n            # The authorization server MUST verify that the redirection URI\n            # to which it will redirect the access token matches a\n            # redirection URI registered by the client as described in\n            # Section 3.1.2.\n            # https://tools.ietf.org/html/rfc6749#section-3.1.2\n            if not self.request_validator.validate_redirect_uri(\n                    request.client_id, request.redirect_uri, request):\n                raise errors.MismatchingRedirectURIError(request=request)\n        else:\n            request.redirect_uri = self.request_validator.get_default_redirect_uri(\n                request.client_id, request)\n            request.using_default_redirect_uri = True\n            log.debug('Using default redirect_uri %s.', request.redirect_uri)\n            if not request.redirect_uri:\n                raise errors.MissingRedirectURIError(request=request)\n            if not is_absolute_uri(request.redirect_uri):\n                raise errors.InvalidRedirectURIError(request=request)\n\n    def _create_cors_headers(self, request):\n        \"\"\"If CORS is allowed, create the appropriate headers.\"\"\"\n        if 'origin' not in request.headers:\n            return {}\n\n        origin = request.headers['origin']\n        if not is_secure_transport(origin):\n            log.debug('Origin \"%s\" is not HTTPS, CORS not allowed.', origin)\n            return {}\n        elif not self.request_validator.is_origin_allowed(\n            request.client_id, origin, request):\n            log.debug('Invalid origin \"%s\", CORS not allowed.', origin)\n            return {}\n        else:\n            log.debug('Valid origin \"%s\", injecting CORS headers.', origin)\n            return {'Access-Control-Allow-Origin': origin}\n", "oauthlib/oauth2/rfc6749/grant_types/implicit.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib import common\n\nfrom .. import errors\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass ImplicitGrant(GrantTypeBase):\n\n    \"\"\"`Implicit Grant`_\n\n    The implicit grant type is used to obtain access tokens (it does not\n    support the issuance of refresh tokens) and is optimized for public\n    clients known to operate a particular redirection URI.  These clients\n    are typically implemented in a browser using a scripting language\n    such as JavaScript.\n\n    Unlike the authorization code grant type, in which the client makes\n    separate requests for authorization and for an access token, the\n    client receives the access token as the result of the authorization\n    request.\n\n    The implicit grant type does not include client authentication, and\n    relies on the presence of the resource owner and the registration of\n    the redirection URI.  Because the access token is encoded into the\n    redirection URI, it may be exposed to the resource owner and other\n    applications residing on the same device::\n\n        +----------+\n        | Resource |\n        |  Owner   |\n        |          |\n        +----------+\n             ^\n             |\n            (B)\n        +----|-----+          Client Identifier     +---------------+\n        |         -+----(A)-- & Redirection URI --->|               |\n        |  User-   |                                | Authorization |\n        |  Agent  -|----(B)-- User authenticates -->|     Server    |\n        |          |                                |               |\n        |          |<---(C)--- Redirection URI ----<|               |\n        |          |          with Access Token     +---------------+\n        |          |            in Fragment\n        |          |                                +---------------+\n        |          |----(D)--- Redirection URI ---->|   Web-Hosted  |\n        |          |          without Fragment      |     Client    |\n        |          |                                |    Resource   |\n        |     (F)  |<---(E)------- Script ---------<|               |\n        |          |                                +---------------+\n        +-|--------+\n          |    |\n         (A)  (G) Access Token\n          |    |\n          ^    v\n        +---------+\n        |         |\n        |  Client |\n        |         |\n        +---------+\n\n   Note: The lines illustrating steps (A) and (B) are broken into two\n   parts as they pass through the user-agent.\n\n   Figure 4: Implicit Grant Flow\n\n   The flow illustrated in Figure 4 includes the following steps:\n\n   (A)  The client initiates the flow by directing the resource owner's\n        user-agent to the authorization endpoint.  The client includes\n        its client identifier, requested scope, local state, and a\n        redirection URI to which the authorization server will send the\n        user-agent back once access is granted (or denied).\n\n   (B)  The authorization server authenticates the resource owner (via\n        the user-agent) and establishes whether the resource owner\n        grants or denies the client's access request.\n\n   (C)  Assuming the resource owner grants access, the authorization\n        server redirects the user-agent back to the client using the\n        redirection URI provided earlier.  The redirection URI includes\n        the access token in the URI fragment.\n\n   (D)  The user-agent follows the redirection instructions by making a\n        request to the web-hosted client resource (which does not\n        include the fragment per [RFC2616]).  The user-agent retains the\n        fragment information locally.\n\n   (E)  The web-hosted client resource returns a web page (typically an\n        HTML document with an embedded script) capable of accessing the\n        full redirection URI including the fragment retained by the\n        user-agent, and extracting the access token (and other\n        parameters) contained in the fragment.\n\n   (F)  The user-agent executes the script provided by the web-hosted\n        client resource locally, which extracts the access token.\n\n   (G)  The user-agent passes the access token to the client.\n\n    See `Section 10.3`_ and `Section 10.16`_ for important security considerations\n    when using the implicit grant.\n\n    .. _`Implicit Grant`: https://tools.ietf.org/html/rfc6749#section-4.2\n    .. _`Section 10.3`: https://tools.ietf.org/html/rfc6749#section-10.3\n    .. _`Section 10.16`: https://tools.ietf.org/html/rfc6749#section-10.16\n    \"\"\"\n\n    response_types = ['token']\n    grant_allows_refresh_token = False\n\n    def create_authorization_response(self, request, token_handler):\n        \"\"\"Create an authorization response.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        The client constructs the request URI by adding the following\n        parameters to the query component of the authorization endpoint URI\n        using the \"application/x-www-form-urlencoded\" format, per `Appendix B`_:\n\n        response_type\n                REQUIRED.  Value MUST be set to \"token\" for standard OAuth2 implicit flow\n                           or \"id_token token\" or just \"id_token\" for OIDC implicit flow\n\n        client_id\n                REQUIRED.  The client identifier as described in `Section 2.2`_.\n\n        redirect_uri\n                OPTIONAL.  As described in `Section 3.1.2`_.\n\n        scope\n                OPTIONAL.  The scope of the access request as described by\n                `Section 3.3`_.\n\n        state\n                RECOMMENDED.  An opaque value used by the client to maintain\n                state between the request and callback.  The authorization\n                server includes this value when redirecting the user-agent back\n                to the client.  The parameter SHOULD be used for preventing\n                cross-site request forgery as described in `Section 10.12`_.\n\n        The authorization server validates the request to ensure that all\n        required parameters are present and valid.  The authorization server\n        MUST verify that the redirection URI to which it will redirect the\n        access token matches a redirection URI registered by the client as\n        described in `Section 3.1.2`_.\n\n        .. _`Section 2.2`: https://tools.ietf.org/html/rfc6749#section-2.2\n        .. _`Section 3.1.2`: https://tools.ietf.org/html/rfc6749#section-3.1.2\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 10.12`: https://tools.ietf.org/html/rfc6749#section-10.12\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        \"\"\"\n        return self.create_token_response(request, token_handler)\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Return token or error embedded in the URI fragment.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        If the resource owner grants the access request, the authorization\n        server issues an access token and delivers it to the client by adding\n        the following parameters to the fragment component of the redirection\n        URI using the \"application/x-www-form-urlencoded\" format, per\n        `Appendix B`_:\n\n        access_token\n                REQUIRED.  The access token issued by the authorization server.\n\n        token_type\n                REQUIRED.  The type of the token issued as described in\n                `Section 7.1`_.  Value is case insensitive.\n\n        expires_in\n                RECOMMENDED.  The lifetime in seconds of the access token.  For\n                example, the value \"3600\" denotes that the access token will\n                expire in one hour from the time the response was generated.\n                If omitted, the authorization server SHOULD provide the\n                expiration time via other means or document the default value.\n\n        scope\n                OPTIONAL, if identical to the scope requested by the client;\n                otherwise, REQUIRED.  The scope of the access token as\n                described by `Section 3.3`_.\n\n        state\n                REQUIRED if the \"state\" parameter was present in the client\n                authorization request.  The exact value received from the\n                client.\n\n        The authorization server MUST NOT issue a refresh token.\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 7.1`: https://tools.ietf.org/html/rfc6749#section-7.1\n        \"\"\"\n        try:\n            self.validate_token_request(request)\n\n        # If the request fails due to a missing, invalid, or mismatching\n        # redirection URI, or if the client identifier is missing or invalid,\n        # the authorization server SHOULD inform the resource owner of the\n        # error and MUST NOT automatically redirect the user-agent to the\n        # invalid redirection URI.\n        except errors.FatalClientError as e:\n            log.debug('Fatal client error during validation of %r. %r.',\n                      request, e)\n            raise\n\n        # If the resource owner denies the access request or if the request\n        # fails for reasons other than a missing or invalid redirection URI,\n        # the authorization server informs the client by adding the following\n        # parameters to the fragment component of the redirection URI using the\n        # \"application/x-www-form-urlencoded\" format, per Appendix B:\n        # https://tools.ietf.org/html/rfc6749#appendix-B\n        except errors.OAuth2Error as e:\n            log.debug('Client error during validation of %r. %r.', request, e)\n            return {'Location': common.add_params_to_uri(request.redirect_uri, e.twotuples,\n                                                         fragment=True)}, None, 302\n\n        # In OIDC implicit flow it is possible to have a request_type that does not include the access_token!\n        # \"id_token token\" - return the access token and the id token\n        # \"id_token\" - don't return the access token\n        token = token_handler.create_token(request, refresh_token=False) if 'token' in request.response_type.split() else {}\n\n        if request.state is not None:\n            token['state'] = request.state\n\n        for modifier in self._token_modifiers:\n            token = modifier(token, token_handler, request)\n\n        # In OIDC implicit flow it is possible to have a request_type that does\n        # not include the access_token! In this case there is no need to save a token.\n        if \"token\" in request.response_type.split():\n            self.request_validator.save_token(token, request)\n\n        return self.prepare_authorization_response(\n            request, token, {}, None, 302)\n\n    def validate_authorization_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        \"\"\"\n        return self.validate_token_request(request)\n\n    def validate_token_request(self, request):\n        \"\"\"Check the token request for normal and fatal errors.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        This method is very similar to validate_authorization_request in\n        the AuthorizationCodeGrant but differ in a few subtle areas.\n\n        A normal error could be a missing response_type parameter or the client\n        attempting to access scope it is not allowed to ask authorization for.\n        Normal errors can safely be included in the redirection URI and\n        sent back to the client.\n\n        Fatal errors occur when the client_id or redirect_uri is invalid or\n        missing. These must be caught by the provider and handled, how this\n        is done is outside of the scope of OAuthLib but showing an error\n        page describing the issue is a good idea.\n        \"\"\"\n\n        # First check for fatal errors\n\n        # If the request fails due to a missing, invalid, or mismatching\n        # redirection URI, or if the client identifier is missing or invalid,\n        # the authorization server SHOULD inform the resource owner of the\n        # error and MUST NOT automatically redirect the user-agent to the\n        # invalid redirection URI.\n\n        # First check duplicate parameters\n        for param in ('client_id', 'response_type', 'redirect_uri', 'scope', 'state'):\n            try:\n                duplicate_params = request.duplicate_params\n            except ValueError:\n                raise errors.InvalidRequestFatalError(description='Unable to parse query string', request=request)\n            if param in duplicate_params:\n                raise errors.InvalidRequestFatalError(description='Duplicate %s parameter.' % param, request=request)\n\n        # REQUIRED. The client identifier as described in Section 2.2.\n        # https://tools.ietf.org/html/rfc6749#section-2.2\n        if not request.client_id:\n            raise errors.MissingClientIdError(request=request)\n\n        if not self.request_validator.validate_client_id(request.client_id, request):\n            raise errors.InvalidClientIdError(request=request)\n\n        # OPTIONAL. As described in Section 3.1.2.\n        # https://tools.ietf.org/html/rfc6749#section-3.1.2\n        self._handle_redirects(request)\n\n        # Then check for normal errors.\n\n        request_info = self._run_custom_validators(request,\n                                                   self.custom_validators.all_pre)\n\n        # If the resource owner denies the access request or if the request\n        # fails for reasons other than a missing or invalid redirection URI,\n        # the authorization server informs the client by adding the following\n        # parameters to the fragment component of the redirection URI using the\n        # \"application/x-www-form-urlencoded\" format, per Appendix B.\n        # https://tools.ietf.org/html/rfc6749#appendix-B\n\n        # Note that the correct parameters to be added are automatically\n        # populated through the use of specific exceptions\n\n        # REQUIRED.\n        if request.response_type is None:\n            raise errors.MissingResponseTypeError(request=request)\n        # Value MUST be one of our registered types: \"token\" by default or if using OIDC \"id_token\" or \"id_token token\"\n        elif not set(request.response_type.split()).issubset(self.response_types):\n            raise errors.UnsupportedResponseTypeError(request=request)\n\n        log.debug('Validating use of response_type token for client %r (%r).',\n                  request.client_id, request.client)\n        if not self.request_validator.validate_response_type(request.client_id,\n                                                             request.response_type,\n                                                             request.client, request):\n\n            log.debug('Client %s is not authorized to use response_type %s.',\n                      request.client_id, request.response_type)\n            raise errors.UnauthorizedClientError(request=request)\n\n        # OPTIONAL. The scope of the access request as described by Section 3.3\n        # https://tools.ietf.org/html/rfc6749#section-3.3\n        self.validate_scopes(request)\n\n        request_info.update({\n            'client_id': request.client_id,\n            'redirect_uri': request.redirect_uri,\n            'response_type': request.response_type,\n            'state': request.state,\n            'request': request,\n        })\n\n        request_info = self._run_custom_validators(\n            request,\n            self.custom_validators.all_post,\n            request_info\n        )\n\n        return request.scopes, request_info\n\n    def _run_custom_validators(self,\n                               request,\n                               validations,\n                               request_info=None):\n        # Make a copy so we don't modify the existing request_info dict\n        request_info = {} if request_info is None else request_info.copy()\n        # For implicit grant, auth_validators and token_validators are\n        # basically equivalent since the token is returned from the\n        # authorization endpoint.\n        for validator in validations:\n            result = validator(request)\n            if result is not None:\n                request_info.update(result)\n        return request_info\n", "oauthlib/oauth2/rfc6749/grant_types/__init__.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nfrom .authorization_code import AuthorizationCodeGrant\nfrom .client_credentials import ClientCredentialsGrant\nfrom .implicit import ImplicitGrant\nfrom .refresh_token import RefreshTokenGrant\nfrom .resource_owner_password_credentials import (\n    ResourceOwnerPasswordCredentialsGrant,\n)\n", "oauthlib/oauth2/rfc6749/grant_types/resource_owner_password_credentials.py": "\"\"\"\noauthlib.oauth2.rfc6749.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport json\nimport logging\n\nfrom .. import errors\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass ResourceOwnerPasswordCredentialsGrant(GrantTypeBase):\n\n    \"\"\"`Resource Owner Password Credentials Grant`_\n\n    The resource owner password credentials grant type is suitable in\n    cases where the resource owner has a trust relationship with the\n    client, such as the device operating system or a highly privileged\n    application.  The authorization server should take special care when\n    enabling this grant type and only allow it when other flows are not\n    viable.\n\n    This grant type is suitable for clients capable of obtaining the\n    resource owner's credentials (username and password, typically using\n    an interactive form).  It is also used to migrate existing clients\n    using direct authentication schemes such as HTTP Basic or Digest\n    authentication to OAuth by converting the stored credentials to an\n    access token::\n\n            +----------+\n            | Resource |\n            |  Owner   |\n            |          |\n            +----------+\n                 v\n                 |    Resource Owner\n                (A) Password Credentials\n                 |\n                 v\n            +---------+                                  +---------------+\n            |         |>--(B)---- Resource Owner ------->|               |\n            |         |         Password Credentials     | Authorization |\n            | Client  |                                  |     Server    |\n            |         |<--(C)---- Access Token ---------<|               |\n            |         |    (w/ Optional Refresh Token)   |               |\n            +---------+                                  +---------------+\n\n    Figure 5: Resource Owner Password Credentials Flow\n\n    The flow illustrated in Figure 5 includes the following steps:\n\n    (A)  The resource owner provides the client with its username and\n            password.\n\n    (B)  The client requests an access token from the authorization\n            server's token endpoint by including the credentials received\n            from the resource owner.  When making the request, the client\n            authenticates with the authorization server.\n\n    (C)  The authorization server authenticates the client and validates\n            the resource owner credentials, and if valid, issues an access\n            token.\n\n    .. _`Resource Owner Password Credentials Grant`: https://tools.ietf.org/html/rfc6749#section-4.3\n    \"\"\"\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Return token or error in json format.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param token_handler: A token handler instance, for example of type\n                              oauthlib.oauth2.BearerToken.\n\n        If the access token request is valid and authorized, the\n        authorization server issues an access token and optional refresh\n        token as described in `Section 5.1`_.  If the request failed client\n        authentication or is invalid, the authorization server returns an\n        error response as described in `Section 5.2`_.\n\n        .. _`Section 5.1`: https://tools.ietf.org/html/rfc6749#section-5.1\n        .. _`Section 5.2`: https://tools.ietf.org/html/rfc6749#section-5.2\n        \"\"\"\n        headers = self._get_default_headers()\n        try:\n            if self.request_validator.client_authentication_required(request):\n                log.debug('Authenticating client, %r.', request)\n                if not self.request_validator.authenticate_client(request):\n                    log.debug('Client authentication failed, %r.', request)\n                    raise errors.InvalidClientError(request=request)\n            elif not self.request_validator.authenticate_client_id(request.client_id, request):\n                log.debug('Client authentication failed, %r.', request)\n                raise errors.InvalidClientError(request=request)\n            log.debug('Validating access token request, %r.', request)\n            self.validate_token_request(request)\n        except errors.OAuth2Error as e:\n            log.debug('Client error in token request, %s.', e)\n            headers.update(e.headers)\n            return headers, e.json, e.status_code\n\n        token = token_handler.create_token(request, self.refresh_token)\n\n        for modifier in self._token_modifiers:\n            token = modifier(token)\n\n        self.request_validator.save_token(token, request)\n\n        log.debug('Issuing token %r to client id %r (%r) and username %s.',\n                  token, request.client_id, request.client, request.username)\n        return headers, json.dumps(token), 200\n\n    def validate_token_request(self, request):\n        \"\"\"\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        The client makes a request to the token endpoint by adding the\n        following parameters using the \"application/x-www-form-urlencoded\"\n        format per Appendix B with a character encoding of UTF-8 in the HTTP\n        request entity-body:\n\n        grant_type\n                REQUIRED.  Value MUST be set to \"password\".\n\n        username\n                REQUIRED.  The resource owner username.\n\n        password\n                REQUIRED.  The resource owner password.\n\n        scope\n                OPTIONAL.  The scope of the access request as described by\n                `Section 3.3`_.\n\n        If the client type is confidential or the client was issued client\n        credentials (or assigned other authentication requirements), the\n        client MUST authenticate with the authorization server as described\n        in `Section 3.2.1`_.\n\n        The authorization server MUST:\n\n        o  require client authentication for confidential clients or for any\n            client that was issued client credentials (or with other\n            authentication requirements),\n\n        o  authenticate the client if client authentication is included, and\n\n        o  validate the resource owner password credentials using its\n            existing password validation algorithm.\n\n        Since this access token request utilizes the resource owner's\n        password, the authorization server MUST protect the endpoint against\n        brute force attacks (e.g., using rate-limitation or generating\n        alerts).\n\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 3.2.1`: https://tools.ietf.org/html/rfc6749#section-3.2.1\n        \"\"\"\n        for validator in self.custom_validators.pre_token:\n            validator(request)\n\n        for param in ('grant_type', 'username', 'password'):\n            if not getattr(request, param, None):\n                raise errors.InvalidRequestError(\n                    'Request is missing %s parameter.' % param, request=request)\n\n        for param in ('grant_type', 'username', 'password', 'scope'):\n            if param in request.duplicate_params:\n                raise errors.InvalidRequestError(description='Duplicate %s parameter.' % param, request=request)\n\n        # This error should rarely (if ever) occur if requests are routed to\n        # grant type handlers based on the grant_type parameter.\n        if not request.grant_type == 'password':\n            raise errors.UnsupportedGrantTypeError(request=request)\n\n        log.debug('Validating username %s.', request.username)\n        if not self.request_validator.validate_user(request.username,\n                                                    request.password, request.client, request):\n            raise errors.InvalidGrantError(\n                'Invalid credentials given.', request=request)\n        elif not hasattr(request.client, 'client_id'):\n            raise NotImplementedError(\n                'Validate user must set the '\n                'request.client.client_id attribute '\n                'in authenticate_client.')\n        log.debug('Authorizing access to user %r.', request.user)\n\n        # Ensure client is authorized use of this grant type\n        self.validate_grant_type(request)\n\n        if request.client:\n            request.client_id = request.client_id or request.client.client_id\n        self.validate_scopes(request)\n\n        for validator in self.custom_validators.post_token:\n            validator(request)\n", "oauthlib/oauth2/rfc6749/endpoints/introspect.py": "\"\"\"\noauthlib.oauth2.rfc6749.endpoint.introspect\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAn implementation of the OAuth 2.0 `Token Introspection`.\n\n.. _`Token Introspection`: https://tools.ietf.org/html/rfc7662\n\"\"\"\nimport json\nimport logging\n\nfrom oauthlib.common import Request\n\nfrom ..errors import OAuth2Error\nfrom .base import BaseEndpoint, catch_errors_and_unavailability\n\nlog = logging.getLogger(__name__)\n\n\nclass IntrospectEndpoint(BaseEndpoint):\n\n    \"\"\"Introspect token endpoint.\n\n   This endpoint defines a method to query an OAuth 2.0 authorization\n   server to determine the active state of an OAuth 2.0 token and to\n   determine meta-information about this token. OAuth 2.0 deployments\n   can use this method to convey information about the authorization\n   context of the token from the authorization server to the protected\n   resource.\n\n   To prevent the values of access tokens from leaking into\n   server-side logs via query parameters, an authorization server\n   offering token introspection MAY disallow the use of HTTP GET on\n   the introspection endpoint and instead require the HTTP POST method\n   to be used at the introspection endpoint.\n   \"\"\"\n\n    valid_token_types = ('access_token', 'refresh_token')\n    valid_request_methods = ('POST',)\n\n    def __init__(self, request_validator, supported_token_types=None):\n        BaseEndpoint.__init__(self)\n        self.request_validator = request_validator\n        self.supported_token_types = (\n            supported_token_types or self.valid_token_types)\n\n    @catch_errors_and_unavailability\n    def create_introspect_response(self, uri, http_method='POST', body=None,\n                                   headers=None):\n        \"\"\"Create introspect valid or invalid response\n\n        If the authorization server is unable to determine the state\n        of the token without additional information, it SHOULD return\n        an introspection response indicating the token is not active\n        as described in Section 2.2.\n        \"\"\"\n        resp_headers = {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-store',\n            'Pragma': 'no-cache',\n        }\n        request = Request(uri, http_method, body, headers)\n        try:\n            self.validate_introspect_request(request)\n            log.debug('Token introspect valid for %r.', request)\n        except OAuth2Error as e:\n            log.debug('Client error during validation of %r. %r.', request, e)\n            resp_headers.update(e.headers)\n            return resp_headers, e.json, e.status_code\n\n        claims = self.request_validator.introspect_token(\n            request.token,\n            request.token_type_hint,\n            request\n        )\n        if claims is None:\n            return resp_headers, json.dumps({'active': False}), 200\n        if \"active\" in claims:\n            claims.pop(\"active\")\n        return resp_headers, json.dumps(dict(active=True, **claims)), 200\n\n    def validate_introspect_request(self, request):\n        \"\"\"Ensure the request is valid.\n\n        The protected resource calls the introspection endpoint using\n        an HTTP POST request with parameters sent as\n        \"application/x-www-form-urlencoded\".\n\n        * token REQUIRED.  The string value of the token.\n        * token_type_hint OPTIONAL.\n\n        A hint about the type of the token submitted for\n        introspection.  The protected resource MAY pass this parameter to\n        help the authorization server optimize the token lookup.  If the\n        server is unable to locate the token using the given hint, it MUST\n        extend its search across all of its supported token types.  An\n        authorization server MAY ignore this parameter, particularly if it\n        is able to detect the token type automatically.\n\n        *  access_token: An Access Token as defined in [`RFC6749`], `section 1.4`_\n        *  refresh_token: A Refresh Token as defined in [`RFC6749`], `section 1.5`_\n\n        The introspection endpoint MAY accept other OPTIONAL\n        parameters to provide further context to the query.  For\n        instance, an authorization server may desire to know the IP\n        address of the client accessing the protected resource to\n        determine if the correct client is likely to be presenting the\n        token.  The definition of this or any other parameters are\n        outside the scope of this specification, to be defined by\n        service documentation or extensions to this specification.\n\n        .. _`section 1.4`: http://tools.ietf.org/html/rfc6749#section-1.4\n        .. _`section 1.5`: http://tools.ietf.org/html/rfc6749#section-1.5\n        .. _`RFC6749`: http://tools.ietf.org/html/rfc6749\n        \"\"\"\n        self._raise_on_bad_method(request)\n        self._raise_on_bad_post_request(request)\n        self._raise_on_missing_token(request)\n        self._raise_on_invalid_client(request)\n        self._raise_on_unsupported_token(request)\n", "oauthlib/oauth2/rfc6749/endpoints/revocation.py": "\"\"\"\noauthlib.oauth2.rfc6749.endpoint.revocation\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAn implementation of the OAuth 2 `Token Revocation`_ spec (draft 11).\n\n.. _`Token Revocation`: https://tools.ietf.org/html/draft-ietf-oauth-revocation-11\n\"\"\"\nimport logging\n\nfrom oauthlib.common import Request\n\nfrom ..errors import OAuth2Error\nfrom .base import BaseEndpoint, catch_errors_and_unavailability\n\nlog = logging.getLogger(__name__)\n\n\nclass RevocationEndpoint(BaseEndpoint):\n\n    \"\"\"Token revocation endpoint.\n\n    Endpoint used by authenticated clients to revoke access and refresh tokens.\n    Commonly this will be part of the Authorization Endpoint.\n    \"\"\"\n\n    valid_token_types = ('access_token', 'refresh_token')\n    valid_request_methods = ('POST',)\n\n    def __init__(self, request_validator, supported_token_types=None,\n            enable_jsonp=False):\n        BaseEndpoint.__init__(self)\n        self.request_validator = request_validator\n        self.supported_token_types = (\n            supported_token_types or self.valid_token_types)\n        self.enable_jsonp = enable_jsonp\n\n    @catch_errors_and_unavailability\n    def create_revocation_response(self, uri, http_method='POST', body=None,\n                                   headers=None):\n        \"\"\"Revoke supplied access or refresh token.\n\n\n        The authorization server responds with HTTP status code 200 if the\n        token has been revoked successfully or if the client submitted an\n        invalid token.\n\n        Note: invalid tokens do not cause an error response since the client\n        cannot handle such an error in a reasonable way.  Moreover, the purpose\n        of the revocation request, invalidating the particular token, is\n        already achieved.\n\n        The content of the response body is ignored by the client as all\n        necessary information is conveyed in the response code.\n\n        An invalid token type hint value is ignored by the authorization server\n        and does not influence the revocation response.\n        \"\"\"\n        resp_headers = {\n            'Content-Type': 'application/json',\n            'Cache-Control': 'no-store',\n            'Pragma': 'no-cache',\n        }\n        request = Request(\n            uri, http_method=http_method, body=body, headers=headers)\n        try:\n            self.validate_revocation_request(request)\n            log.debug('Token revocation valid for %r.', request)\n        except OAuth2Error as e:\n            log.debug('Client error during validation of %r. %r.', request, e)\n            response_body = e.json\n            if self.enable_jsonp and request.callback:\n                response_body = '{}({});'.format(request.callback, response_body)\n            resp_headers.update(e.headers)\n            return resp_headers, response_body, e.status_code\n\n        self.request_validator.revoke_token(request.token,\n                                            request.token_type_hint, request)\n\n        response_body = ''\n        if self.enable_jsonp and request.callback:\n            response_body = request.callback + '();'\n        return {}, response_body, 200\n\n    def validate_revocation_request(self, request):\n        \"\"\"Ensure the request is valid.\n\n        The client constructs the request by including the following parameters\n        using the \"application/x-www-form-urlencoded\" format in the HTTP\n        request entity-body:\n\n        token (REQUIRED).  The token that the client wants to get revoked.\n\n        token_type_hint (OPTIONAL).  A hint about the type of the token\n        submitted for revocation.  Clients MAY pass this parameter in order to\n        help the authorization server to optimize the token lookup.  If the\n        server is unable to locate the token using the given hint, it MUST\n        extend its search across all of its supported token types.  An\n        authorization server MAY ignore this parameter, particularly if it is\n        able to detect the token type automatically.  This specification\n        defines two such values:\n\n                *  access_token: An Access Token as defined in [RFC6749],\n                    `section 1.4`_\n\n                *  refresh_token: A Refresh Token as defined in [RFC6749],\n                    `section 1.5`_\n\n                Specific implementations, profiles, and extensions of this\n                specification MAY define other values for this parameter using\n                the registry defined in `Section 4.1.2`_.\n\n        The client also includes its authentication credentials as described in\n        `Section 2.3`_. of [`RFC6749`_].\n\n        .. _`section 1.4`: https://tools.ietf.org/html/rfc6749#section-1.4\n        .. _`section 1.5`: https://tools.ietf.org/html/rfc6749#section-1.5\n        .. _`section 2.3`: https://tools.ietf.org/html/rfc6749#section-2.3\n        .. _`Section 4.1.2`: https://tools.ietf.org/html/draft-ietf-oauth-revocation-11#section-4.1.2\n        .. _`RFC6749`: https://tools.ietf.org/html/rfc6749\n        \"\"\"\n        self._raise_on_bad_method(request)\n        self._raise_on_bad_post_request(request)\n        self._raise_on_missing_token(request)\n        self._raise_on_invalid_client(request)\n        self._raise_on_unsupported_token(request)\n", "oauthlib/oauth2/rfc6749/endpoints/base.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport functools\nimport logging\n\nfrom ..errors import (\n    FatalClientError, InvalidClientError, InvalidRequestError, OAuth2Error,\n    ServerError, TemporarilyUnavailableError, UnsupportedTokenTypeError,\n)\n\nlog = logging.getLogger(__name__)\n\n\nclass BaseEndpoint:\n\n    def __init__(self):\n        self._available = True\n        self._catch_errors = False\n        self._valid_request_methods = None\n\n    @property\n    def valid_request_methods(self):\n        return self._valid_request_methods\n\n    @valid_request_methods.setter\n    def valid_request_methods(self, valid_request_methods):\n        if valid_request_methods is not None:\n            valid_request_methods = [x.upper() for x in valid_request_methods]\n        self._valid_request_methods = valid_request_methods\n\n\n    @property\n    def available(self):\n        return self._available\n\n    @available.setter\n    def available(self, available):\n        self._available = available\n\n    @property\n    def catch_errors(self):\n        return self._catch_errors\n\n    @catch_errors.setter\n    def catch_errors(self, catch_errors):\n        self._catch_errors = catch_errors\n\n    def _raise_on_missing_token(self, request):\n        \"\"\"Raise error on missing token.\"\"\"\n        if not request.token:\n            raise InvalidRequestError(request=request,\n                                      description='Missing token parameter.')\n    def _raise_on_invalid_client(self, request):\n        \"\"\"Raise on failed client authentication.\"\"\"\n        if self.request_validator.client_authentication_required(request):\n            if not self.request_validator.authenticate_client(request):\n                log.debug('Client authentication failed, %r.', request)\n                raise InvalidClientError(request=request)\n        elif not self.request_validator.authenticate_client_id(request.client_id, request):\n            log.debug('Client authentication failed, %r.', request)\n            raise InvalidClientError(request=request)\n\n    def _raise_on_unsupported_token(self, request):\n        \"\"\"Raise on unsupported tokens.\"\"\"\n        if (request.token_type_hint and\n            request.token_type_hint in self.valid_token_types and\n            request.token_type_hint not in self.supported_token_types):\n            raise UnsupportedTokenTypeError(request=request)\n\n    def _raise_on_bad_method(self, request):\n        if self.valid_request_methods is None:\n            raise ValueError('Configure \"valid_request_methods\" property first')\n        if request.http_method.upper() not in self.valid_request_methods:\n            raise InvalidRequestError(request=request,\n                                      description=('Unsupported request method %s' % request.http_method.upper()))\n\n    def _raise_on_bad_post_request(self, request):\n        \"\"\"Raise if invalid POST request received\n        \"\"\"\n        if request.http_method.upper() == 'POST':\n            query_params = request.uri_query or \"\"\n            if query_params:\n                raise InvalidRequestError(request=request,\n                                          description=('URL query parameters are not allowed'))\n\ndef catch_errors_and_unavailability(f):\n    @functools.wraps(f)\n    def wrapper(endpoint, uri, *args, **kwargs):\n        if not endpoint.available:\n            e = TemporarilyUnavailableError()\n            log.info('Endpoint unavailable, ignoring request %s.' % uri)\n            return {}, e.json, 503\n\n        if endpoint.catch_errors:\n            try:\n                return f(endpoint, uri, *args, **kwargs)\n            except OAuth2Error:\n                raise\n            except FatalClientError:\n                raise\n            except Exception as e:\n                error = ServerError()\n                log.warning(\n                    'Exception caught while processing request, %s.' % e)\n                return {}, error.json, 500\n        else:\n            return f(endpoint, uri, *args, **kwargs)\n    return wrapper\n", "oauthlib/oauth2/rfc6749/endpoints/pre_configured.py": "\"\"\"\noauthlib.oauth2.rfc6749.endpoints.pre_configured\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various endpoints needed\nfor providing OAuth 2.0 RFC6749 servers.\n\"\"\"\nfrom ..grant_types import (\n    AuthorizationCodeGrant, ClientCredentialsGrant, ImplicitGrant,\n    RefreshTokenGrant, ResourceOwnerPasswordCredentialsGrant,\n)\nfrom ..tokens import BearerToken\nfrom .authorization import AuthorizationEndpoint\nfrom .introspect import IntrospectEndpoint\nfrom .resource import ResourceEndpoint\nfrom .revocation import RevocationEndpoint\nfrom .token import TokenEndpoint\n\n\nclass Server(AuthorizationEndpoint, IntrospectEndpoint, TokenEndpoint,\n             ResourceEndpoint, RevocationEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring all four major grant types.\"\"\"\n\n    def __init__(self, request_validator, token_expires_in=None,\n                 token_generator=None, refresh_token_generator=None,\n                 *args, **kwargs):\n        \"\"\"Construct a new all-grants-in-one server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.auth_grant = AuthorizationCodeGrant(request_validator)\n        self.implicit_grant = ImplicitGrant(request_validator)\n        self.password_grant = ResourceOwnerPasswordCredentialsGrant(\n            request_validator)\n        self.credentials_grant = ClientCredentialsGrant(request_validator)\n        self.refresh_grant = RefreshTokenGrant(request_validator)\n\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n\n        AuthorizationEndpoint.__init__(self, default_response_type='code',\n                                       response_types={\n                                           'code': self.auth_grant,\n                                           'token': self.implicit_grant,\n                                           'none': self.auth_grant\n                                       },\n                                       default_token_type=self.bearer)\n\n        TokenEndpoint.__init__(self, default_grant_type='authorization_code',\n                               grant_types={\n                                   'authorization_code': self.auth_grant,\n                                   'password': self.password_grant,\n                                   'client_credentials': self.credentials_grant,\n                                   'refresh_token': self.refresh_grant,\n                               },\n                               default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer})\n        RevocationEndpoint.__init__(self, request_validator)\n        IntrospectEndpoint.__init__(self, request_validator)\n\n\nclass WebApplicationServer(AuthorizationEndpoint, IntrospectEndpoint, TokenEndpoint,\n                           ResourceEndpoint, RevocationEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring Authorization code grant and Bearer tokens.\"\"\"\n\n    def __init__(self, request_validator, token_generator=None,\n                 token_expires_in=None, refresh_token_generator=None, **kwargs):\n        \"\"\"Construct a new web application server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.auth_grant = AuthorizationCodeGrant(request_validator)\n        self.refresh_grant = RefreshTokenGrant(request_validator)\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n        AuthorizationEndpoint.__init__(self, default_response_type='code',\n                                       response_types={'code': self.auth_grant},\n                                       default_token_type=self.bearer)\n        TokenEndpoint.__init__(self, default_grant_type='authorization_code',\n                               grant_types={\n                                   'authorization_code': self.auth_grant,\n                                   'refresh_token': self.refresh_grant,\n                               },\n                               default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer})\n        RevocationEndpoint.__init__(self, request_validator)\n        IntrospectEndpoint.__init__(self, request_validator)\n\n\nclass MobileApplicationServer(AuthorizationEndpoint, IntrospectEndpoint,\n                              ResourceEndpoint, RevocationEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring Implicit code grant and Bearer tokens.\"\"\"\n\n    def __init__(self, request_validator, token_generator=None,\n                 token_expires_in=None, refresh_token_generator=None, **kwargs):\n        \"\"\"Construct a new implicit grant server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.implicit_grant = ImplicitGrant(request_validator)\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n        AuthorizationEndpoint.__init__(self, default_response_type='token',\n                                       response_types={\n                                           'token': self.implicit_grant},\n                                       default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer})\n        RevocationEndpoint.__init__(self, request_validator,\n                                    supported_token_types=['access_token'])\n        IntrospectEndpoint.__init__(self, request_validator,\n                                    supported_token_types=['access_token'])\n\n\nclass LegacyApplicationServer(TokenEndpoint, IntrospectEndpoint,\n                              ResourceEndpoint, RevocationEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring Resource Owner Password Credentials grant and Bearer tokens.\"\"\"\n\n    def __init__(self, request_validator, token_generator=None,\n                 token_expires_in=None, refresh_token_generator=None, **kwargs):\n        \"\"\"Construct a resource owner password credentials grant server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.password_grant = ResourceOwnerPasswordCredentialsGrant(\n            request_validator)\n        self.refresh_grant = RefreshTokenGrant(request_validator)\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n        TokenEndpoint.__init__(self, default_grant_type='password',\n                               grant_types={\n                                   'password': self.password_grant,\n                                   'refresh_token': self.refresh_grant,\n                               },\n                               default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer})\n        RevocationEndpoint.__init__(self, request_validator)\n        IntrospectEndpoint.__init__(self, request_validator)\n\n\nclass BackendApplicationServer(TokenEndpoint, IntrospectEndpoint,\n                               ResourceEndpoint, RevocationEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring Client Credentials grant and Bearer tokens.\"\"\"\n\n    def __init__(self, request_validator, token_generator=None,\n                 token_expires_in=None, refresh_token_generator=None, **kwargs):\n        \"\"\"Construct a client credentials grant server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.credentials_grant = ClientCredentialsGrant(request_validator)\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n        TokenEndpoint.__init__(self, default_grant_type='client_credentials',\n                               grant_types={\n                                   'client_credentials': self.credentials_grant},\n                               default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer})\n        RevocationEndpoint.__init__(self, request_validator,\n                                    supported_token_types=['access_token'])\n        IntrospectEndpoint.__init__(self, request_validator,\n                                    supported_token_types=['access_token'])\n", "oauthlib/oauth2/rfc6749/endpoints/authorization.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport logging\n\nfrom oauthlib.common import Request\nfrom oauthlib.oauth2.rfc6749 import utils\n\nfrom .base import BaseEndpoint, catch_errors_and_unavailability\n\nlog = logging.getLogger(__name__)\n\n\nclass AuthorizationEndpoint(BaseEndpoint):\n\n    \"\"\"Authorization endpoint - used by the client to obtain authorization\n    from the resource owner via user-agent redirection.\n\n    The authorization endpoint is used to interact with the resource\n    owner and obtain an authorization grant.  The authorization server\n    MUST first verify the identity of the resource owner.  The way in\n    which the authorization server authenticates the resource owner (e.g.\n    username and password login, session cookies) is beyond the scope of\n    this specification.\n\n    The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n    formatted (per `Appendix B`_) query component,\n    which MUST be retained when adding additional query parameters.  The\n    endpoint URI MUST NOT include a fragment component::\n\n        https://example.com/path?query=component             # OK\n        https://example.com/path?query=component#fragment    # Not OK\n\n    Since requests to the authorization endpoint result in user\n    authentication and the transmission of clear-text credentials (in the\n    HTTP response), the authorization server MUST require the use of TLS\n    as described in Section 1.6 when sending requests to the\n    authorization endpoint::\n\n        # We will deny any request which URI schema is not with https\n\n    The authorization server MUST support the use of the HTTP \"GET\"\n    method [RFC2616] for the authorization endpoint, and MAY support the\n    use of the \"POST\" method as well::\n\n        # HTTP method is currently not enforced\n\n    Parameters sent without a value MUST be treated as if they were\n    omitted from the request.  The authorization server MUST ignore\n    unrecognized request parameters.  Request and response parameters\n    MUST NOT be included more than once::\n\n        # Enforced through the design of oauthlib.common.Request\n\n    .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n    \"\"\"\n\n    def __init__(self, default_response_type, default_token_type,\n                 response_types):\n        BaseEndpoint.__init__(self)\n        self._response_types = response_types\n        self._default_response_type = default_response_type\n        self._default_token_type = default_token_type\n\n    @property\n    def response_types(self):\n        return self._response_types\n\n    @property\n    def default_response_type(self):\n        return self._default_response_type\n\n    @property\n    def default_response_type_handler(self):\n        return self.response_types.get(self.default_response_type)\n\n    @property\n    def default_token_type(self):\n        return self._default_token_type\n\n    @catch_errors_and_unavailability\n    def create_authorization_response(self, uri, http_method='GET', body=None,\n                                      headers=None, scopes=None, credentials=None):\n        \"\"\"Extract response_type and route to the designated handler.\"\"\"\n        request = Request(\n            uri, http_method=http_method, body=body, headers=headers)\n        request.scopes = scopes\n        # TODO: decide whether this should be a required argument\n        request.user = None     # TODO: explain this in docs\n        for k, v in (credentials or {}).items():\n            setattr(request, k, v)\n        response_type_handler = self.response_types.get(\n            request.response_type, self.default_response_type_handler)\n        log.debug('Dispatching response_type %s request to %r.',\n                  request.response_type, response_type_handler)\n        return response_type_handler.create_authorization_response(\n            request, self.default_token_type)\n\n    @catch_errors_and_unavailability\n    def validate_authorization_request(self, uri, http_method='GET', body=None,\n                                       headers=None):\n        \"\"\"Extract response_type and route to the designated handler.\"\"\"\n        request = Request(\n            uri, http_method=http_method, body=body, headers=headers)\n\n        request.scopes = utils.scope_to_list(request.scope)\n\n        response_type_handler = self.response_types.get(\n            request.response_type, self.default_response_type_handler)\n        return response_type_handler.validate_authorization_request(request)\n", "oauthlib/oauth2/rfc6749/endpoints/token.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport logging\n\nfrom oauthlib.common import Request\nfrom oauthlib.oauth2.rfc6749 import utils\n\nfrom .base import BaseEndpoint, catch_errors_and_unavailability\n\nlog = logging.getLogger(__name__)\n\n\nclass TokenEndpoint(BaseEndpoint):\n\n    \"\"\"Token issuing endpoint.\n\n    The token endpoint is used by the client to obtain an access token by\n    presenting its authorization grant or refresh token.  The token\n    endpoint is used with every authorization grant except for the\n    implicit grant type (since an access token is issued directly).\n\n    The means through which the client obtains the location of the token\n    endpoint are beyond the scope of this specification, but the location\n    is typically provided in the service documentation.\n\n    The endpoint URI MAY include an \"application/x-www-form-urlencoded\"\n    formatted (per `Appendix B`_) query component,\n    which MUST be retained when adding additional query parameters.  The\n    endpoint URI MUST NOT include a fragment component::\n\n        https://example.com/path?query=component             # OK\n        https://example.com/path?query=component#fragment    # Not OK\n\n    Since requests to the token endpoint result in the transmission of\n    clear-text credentials (in the HTTP request and response), the\n    authorization server MUST require the use of TLS as described in\n    Section 1.6 when sending requests to the token endpoint::\n\n        # We will deny any request which URI schema is not with https\n\n    The client MUST use the HTTP \"POST\" method when making access token\n    requests::\n\n        # HTTP method is currently not enforced\n\n    Parameters sent without a value MUST be treated as if they were\n    omitted from the request.  The authorization server MUST ignore\n    unrecognized request parameters.  Request and response parameters\n    MUST NOT be included more than once::\n\n        # Delegated to each grant type.\n\n    .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n    \"\"\"\n\n    valid_request_methods = ('POST',)\n\n    def __init__(self, default_grant_type, default_token_type, grant_types):\n        BaseEndpoint.__init__(self)\n        self._grant_types = grant_types\n        self._default_token_type = default_token_type\n        self._default_grant_type = default_grant_type\n\n    @property\n    def grant_types(self):\n        return self._grant_types\n\n    @property\n    def default_grant_type(self):\n        return self._default_grant_type\n\n    @property\n    def default_grant_type_handler(self):\n        return self.grant_types.get(self.default_grant_type)\n\n    @property\n    def default_token_type(self):\n        return self._default_token_type\n\n    @catch_errors_and_unavailability\n    def create_token_response(self, uri, http_method='POST', body=None,\n                              headers=None, credentials=None, grant_type_for_scope=None,\n                              claims=None):\n        \"\"\"Extract grant_type and route to the designated handler.\"\"\"\n        request = Request(\n            uri, http_method=http_method, body=body, headers=headers)\n        self.validate_token_request(request)\n        # 'scope' is an allowed Token Request param in both the \"Resource Owner Password Credentials Grant\"\n        # and \"Client Credentials Grant\" flows\n        # https://tools.ietf.org/html/rfc6749#section-4.3.2\n        # https://tools.ietf.org/html/rfc6749#section-4.4.2\n        request.scopes = utils.scope_to_list(request.scope)\n\n        request.extra_credentials = credentials\n        if grant_type_for_scope:\n            request.grant_type = grant_type_for_scope\n\n        # OpenID Connect claims, if provided.  The server using oauthlib might choose\n        # to implement the claims parameter of the Authorization Request.  In this case\n        # it should retrieve those claims and pass them via the claims argument here,\n        # as a dict.\n        if claims:\n            request.claims = claims\n\n        grant_type_handler = self.grant_types.get(request.grant_type,\n                                                  self.default_grant_type_handler)\n        log.debug('Dispatching grant_type %s request to %r.',\n                  request.grant_type, grant_type_handler)\n        return grant_type_handler.create_token_response(\n            request, self.default_token_type)\n\n    def validate_token_request(self, request):\n        self._raise_on_bad_method(request)\n        self._raise_on_bad_post_request(request)\n", "oauthlib/oauth2/rfc6749/endpoints/__init__.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nfrom .authorization import AuthorizationEndpoint\nfrom .introspect import IntrospectEndpoint\nfrom .metadata import MetadataEndpoint\nfrom .pre_configured import (\n    BackendApplicationServer, LegacyApplicationServer, MobileApplicationServer,\n    Server, WebApplicationServer,\n)\nfrom .resource import ResourceEndpoint\nfrom .revocation import RevocationEndpoint\nfrom .token import TokenEndpoint\n", "oauthlib/oauth2/rfc6749/endpoints/resource.py": "\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport logging\n\nfrom oauthlib.common import Request\n\nfrom .base import BaseEndpoint, catch_errors_and_unavailability\n\nlog = logging.getLogger(__name__)\n\n\nclass ResourceEndpoint(BaseEndpoint):\n\n    \"\"\"Authorizes access to protected resources.\n\n    The client accesses protected resources by presenting the access\n    token to the resource server.  The resource server MUST validate the\n    access token and ensure that it has not expired and that its scope\n    covers the requested resource.  The methods used by the resource\n    server to validate the access token (as well as any error responses)\n    are beyond the scope of this specification but generally involve an\n    interaction or coordination between the resource server and the\n    authorization server::\n\n        # For most cases, returning a 403 should suffice.\n\n    The method in which the client utilizes the access token to\n    authenticate with the resource server depends on the type of access\n    token issued by the authorization server.  Typically, it involves\n    using the HTTP \"Authorization\" request header field [RFC2617] with an\n    authentication scheme defined by the specification of the access\n    token type used, such as [RFC6750]::\n\n        # Access tokens may also be provided in query and body\n        https://example.com/protected?access_token=kjfch2345sdf   # Query\n        access_token=sdf23409df   # Body\n    \"\"\"\n\n    def __init__(self, default_token, token_types):\n        BaseEndpoint.__init__(self)\n        self._tokens = token_types\n        self._default_token = default_token\n\n    @property\n    def default_token(self):\n        return self._default_token\n\n    @property\n    def default_token_type_handler(self):\n        return self.tokens.get(self.default_token)\n\n    @property\n    def tokens(self):\n        return self._tokens\n\n    @catch_errors_and_unavailability\n    def verify_request(self, uri, http_method='GET', body=None, headers=None,\n                       scopes=None):\n        \"\"\"Validate client, code etc, return body + headers\"\"\"\n        request = Request(uri, http_method, body, headers)\n        request.token_type = self.find_token_type(request)\n        request.scopes = scopes\n        token_type_handler = self.tokens.get(request.token_type,\n                                             self.default_token_type_handler)\n        log.debug('Dispatching token_type %s request to %r.',\n                  request.token_type, token_type_handler)\n        return token_type_handler.validate_request(request), request\n\n    def find_token_type(self, request):\n        \"\"\"Token type identification.\n\n        RFC 6749 does not provide a method for easily differentiating between\n        different token types during protected resource access. We estimate\n        the most likely token type (if any) by asking each known token type\n        to give an estimation based on the request.\n        \"\"\"\n        estimates = sorted(((t.estimate_type(request), n)\n                            for n, t in self.tokens.items()), reverse=True)\n        return estimates[0][1] if len(estimates) else None\n", "oauthlib/oauth2/rfc6749/clients/web_application.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport warnings\n\nfrom ..parameters import (\n    parse_authorization_code_response, prepare_grant_uri,\n    prepare_token_request,\n)\nfrom .base import Client\n\n\nclass WebApplicationClient(Client):\n\n    \"\"\"A client utilizing the authorization code grant workflow.\n\n    A web application is a confidential client running on a web\n    server.  Resource owners access the client via an HTML user\n    interface rendered in a user-agent on the device used by the\n    resource owner.  The client credentials as well as any access\n    token issued to the client are stored on the web server and are\n    not exposed to or accessible by the resource owner.\n\n    The authorization code grant type is used to obtain both access\n    tokens and refresh tokens and is optimized for confidential clients.\n    As a redirection-based flow, the client must be capable of\n    interacting with the resource owner's user-agent (typically a web\n    browser) and capable of receiving incoming requests (via redirection)\n    from the authorization server.\n    \"\"\"\n\n    grant_type = 'authorization_code'\n\n    def __init__(self, client_id, code=None, **kwargs):\n        super().__init__(client_id, **kwargs)\n        self.code = code\n\n    def prepare_request_uri(self, uri, redirect_uri=None, scope=None,\n                            state=None, code_challenge=None, code_challenge_method='plain', **kwargs):\n        \"\"\"Prepare the authorization code request URI\n\n        The client constructs the request URI by adding the following\n        parameters to the query component of the authorization endpoint URI\n        using the \"application/x-www-form-urlencoded\" format, per `Appendix B`_:\n\n        :param redirect_uri:  OPTIONAL. The redirect URI must be an absolute URI\n                              and it should have been registered with the OAuth\n                              provider prior to use. As described in `Section 3.1.2`_.\n\n        :param scope:  OPTIONAL. The scope of the access request as described by\n                       Section 3.3`_. These may be any string but are commonly\n                       URIs or various categories such as ``videos`` or ``documents``.\n\n        :param state:   RECOMMENDED.  An opaque value used by the client to maintain\n                        state between the request and callback.  The authorization\n                        server includes this value when redirecting the user-agent back\n                        to the client.  The parameter SHOULD be used for preventing\n                        cross-site request forgery as described in `Section 10.12`_.\n\n        :param code_challenge: OPTIONAL. PKCE parameter. REQUIRED if PKCE is enforced.\n                        A challenge derived from the code_verifier that is sent in the\n                        authorization request, to be verified against later.\n\n        :param code_challenge_method: OPTIONAL. PKCE parameter. A method that was used to derive code challenge.\n                                      Defaults to \"plain\" if not present in the request.\n\n        :param kwargs:  Extra arguments to include in the request URI.\n\n        In addition to supplied parameters, OAuthLib will append the ``client_id``\n        that was provided in the constructor as well as the mandatory ``response_type``\n        argument, set to ``code``::\n\n            >>> from oauthlib.oauth2 import WebApplicationClient\n            >>> client = WebApplicationClient('your_id')\n            >>> client.prepare_request_uri('https://example.com')\n            'https://example.com?client_id=your_id&response_type=code'\n            >>> client.prepare_request_uri('https://example.com', redirect_uri='https://a.b/callback')\n            'https://example.com?client_id=your_id&response_type=code&redirect_uri=https%3A%2F%2Fa.b%2Fcallback'\n            >>> client.prepare_request_uri('https://example.com', scope=['profile', 'pictures'])\n            'https://example.com?client_id=your_id&response_type=code&scope=profile+pictures'\n            >>> client.prepare_request_uri('https://example.com', code_challenge='kjasBS523KdkAILD2k78NdcJSk2k3KHG6')\n            'https://example.com?client_id=your_id&response_type=code&code_challenge=kjasBS523KdkAILD2k78NdcJSk2k3KHG6'\n            >>> client.prepare_request_uri('https://example.com', code_challenge_method='S256')\n            'https://example.com?client_id=your_id&response_type=code&code_challenge_method=S256'\n            >>> client.prepare_request_uri('https://example.com', foo='bar')\n            'https://example.com?client_id=your_id&response_type=code&foo=bar'\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 2.2`: https://tools.ietf.org/html/rfc6749#section-2.2\n        .. _`Section 3.1.2`: https://tools.ietf.org/html/rfc6749#section-3.1.2\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 10.12`: https://tools.ietf.org/html/rfc6749#section-10.12\n        \"\"\"\n        scope = self.scope if scope is None else scope\n        return prepare_grant_uri(uri, self.client_id, 'code',\n                                 redirect_uri=redirect_uri, scope=scope, state=state, code_challenge=code_challenge,\n                                 code_challenge_method=code_challenge_method, **kwargs)\n\n    def prepare_request_body(self, code=None, redirect_uri=None, body='',\n                             include_client_id=True, code_verifier=None, **kwargs):\n        \"\"\"Prepare the access token request body.\n\n        The client makes a request to the token endpoint by adding the\n        following parameters using the \"application/x-www-form-urlencoded\"\n        format in the HTTP request entity-body:\n\n        :param code:    REQUIRED. The authorization code received from the\n                        authorization server.\n\n        :param redirect_uri:    REQUIRED, if the \"redirect_uri\" parameter was included in the\n                                authorization request as described in `Section 4.1.1`_, and their\n                                values MUST be identical.\n\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n\n        :param include_client_id: `True` (default) to send the `client_id` in the\n                                  body of the upstream request. This is required\n                                  if the client is not authenticating with the\n                                  authorization server as described in `Section 3.2.1`_.\n        :type include_client_id: Boolean\n\n        :param code_verifier: OPTIONAL. A cryptographically random string that is used to correlate the\n                                        authorization request to the token request.\n\n        :param kwargs: Extra parameters to include in the token request.\n\n        In addition OAuthLib will add the ``grant_type`` parameter set to\n        ``authorization_code``.\n\n        If the client type is confidential or the client was issued client\n        credentials (or assigned other authentication requirements), the\n        client MUST authenticate with the authorization server as described\n        in `Section 3.2.1`_::\n\n            >>> from oauthlib.oauth2 import WebApplicationClient\n            >>> client = WebApplicationClient('your_id')\n            >>> client.prepare_request_body(code='sh35ksdf09sf')\n            'grant_type=authorization_code&code=sh35ksdf09sf'\n            >>> client.prepare_request_body(code_verifier='KB46DCKJ873NCGXK5GD682NHDKK34GR')\n            'grant_type=authorization_code&code_verifier=KB46DCKJ873NCGXK5GD682NHDKK34GR'\n            >>> client.prepare_request_body(code='sh35ksdf09sf', foo='bar')\n            'grant_type=authorization_code&code=sh35ksdf09sf&foo=bar'\n\n        `Section 3.2.1` also states:\n            In the \"authorization_code\" \"grant_type\" request to the token\n            endpoint, an unauthenticated client MUST send its \"client_id\" to\n            prevent itself from inadvertently accepting a code intended for a\n            client with a different \"client_id\".  This protects the client from\n            substitution of the authentication code.  (It provides no additional\n            security for the protected resource.)\n\n        .. _`Section 4.1.1`: https://tools.ietf.org/html/rfc6749#section-4.1.1\n        .. _`Section 3.2.1`: https://tools.ietf.org/html/rfc6749#section-3.2.1\n        \"\"\"\n        code = code or self.code\n        if 'client_id' in kwargs:\n            warnings.warn(\"`client_id` has been deprecated in favor of \"\n                          \"`include_client_id`, a boolean value which will \"\n                          \"include the already configured `self.client_id`.\",\n                          DeprecationWarning)\n            if kwargs['client_id'] != self.client_id:\n                raise ValueError(\"`client_id` was supplied as an argument, but \"\n                                 \"it does not match `self.client_id`\")\n\n        kwargs['client_id'] = self.client_id\n        kwargs['include_client_id'] = include_client_id\n        return prepare_token_request(self.grant_type, code=code, body=body,\n                                     redirect_uri=redirect_uri, code_verifier=code_verifier, **kwargs)\n\n    def parse_request_uri_response(self, uri, state=None):\n        \"\"\"Parse the URI query for code and state.\n\n        If the resource owner grants the access request, the authorization\n        server issues an authorization code and delivers it to the client by\n        adding the following parameters to the query component of the\n        redirection URI using the \"application/x-www-form-urlencoded\" format:\n\n        :param uri: The callback URI that resulted from the user being redirected\n                    back from the provider to you, the client.\n        :param state: The state provided in the authorization request.\n\n        **code**\n            The authorization code generated by the authorization server.\n            The authorization code MUST expire shortly after it is issued\n            to mitigate the risk of leaks. A maximum authorization code\n            lifetime of 10 minutes is RECOMMENDED. The client MUST NOT\n            use the authorization code more than once. If an authorization\n            code is used more than once, the authorization server MUST deny\n            the request and SHOULD revoke (when possible) all tokens\n            previously issued based on that authorization code.\n            The authorization code is bound to the client identifier and\n            redirection URI.\n\n        **state**\n                If the \"state\" parameter was present in the authorization request.\n\n        This method is mainly intended to enforce strict state checking with\n        the added benefit of easily extracting parameters from the URI::\n\n            >>> from oauthlib.oauth2 import WebApplicationClient\n            >>> client = WebApplicationClient('your_id')\n            >>> uri = 'https://example.com/callback?code=sdfkjh345&state=sfetw45'\n            >>> client.parse_request_uri_response(uri, state='sfetw45')\n            {'state': 'sfetw45', 'code': 'sdfkjh345'}\n            >>> client.parse_request_uri_response(uri, state='other')\n            Traceback (most recent call last):\n                File \"<stdin>\", line 1, in <module>\n                File \"oauthlib/oauth2/rfc6749/__init__.py\", line 357, in parse_request_uri_response\n                    back from the provider to you, the client.\n                File \"oauthlib/oauth2/rfc6749/parameters.py\", line 153, in parse_authorization_code_response\n                    raise MismatchingStateError()\n            oauthlib.oauth2.rfc6749.errors.MismatchingStateError\n        \"\"\"\n        response = parse_authorization_code_response(uri, state=state)\n        self.populate_code_attributes(response)\n        return response\n", "oauthlib/oauth2/rfc6749/clients/backend_application.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nfrom ..parameters import prepare_token_request\nfrom .base import Client\n\n\nclass BackendApplicationClient(Client):\n\n    \"\"\"A public client utilizing the client credentials grant workflow.\n\n    The client can request an access token using only its client\n    credentials (or other supported means of authentication) when the\n    client is requesting access to the protected resources under its\n    control, or those of another resource owner which has been previously\n    arranged with the authorization server (the method of which is beyond\n    the scope of this specification).\n\n    The client credentials grant type MUST only be used by confidential\n    clients.\n\n    Since the client authentication is used as the authorization grant,\n    no additional authorization request is needed.\n    \"\"\"\n\n    grant_type = 'client_credentials'\n\n    def prepare_request_body(self, body='', scope=None,\n                             include_client_id=False, **kwargs):\n        \"\"\"Add the client credentials to the request body.\n\n        The client makes a request to the token endpoint by adding the\n        following parameters using the \"application/x-www-form-urlencoded\"\n        format per `Appendix B`_ in the HTTP request entity-body:\n\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n        :param scope:   The scope of the access request as described by\n                        `Section 3.3`_.\n\n        :param include_client_id: `True` to send the `client_id` in the\n                                  body of the upstream request. This is required\n                                  if the client is not authenticating with the\n                                  authorization server as described in\n                                  `Section 3.2.1`_. False otherwise (default).\n        :type include_client_id: Boolean\n\n        :param kwargs:  Extra credentials to include in the token request.\n\n        The client MUST authenticate with the authorization server as\n        described in `Section 3.2.1`_.\n\n        The prepared body will include all provided credentials as well as\n        the ``grant_type`` parameter set to ``client_credentials``::\n\n            >>> from oauthlib.oauth2 import BackendApplicationClient\n            >>> client = BackendApplicationClient('your_id')\n            >>> client.prepare_request_body(scope=['hello', 'world'])\n            'grant_type=client_credentials&scope=hello+world'\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 3.2.1`: https://tools.ietf.org/html/rfc6749#section-3.2.1\n        \"\"\"\n        kwargs['client_id'] = self.client_id\n        kwargs['include_client_id'] = include_client_id\n        scope = self.scope if scope is None else scope\n        return prepare_token_request(self.grant_type, body=body,\n                                     scope=scope, **kwargs)\n", "oauthlib/oauth2/rfc6749/clients/legacy_application.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nfrom ..parameters import prepare_token_request\nfrom .base import Client\n\n\nclass LegacyApplicationClient(Client):\n\n    \"\"\"A public client using the resource owner password and username directly.\n\n    The resource owner password credentials grant type is suitable in\n    cases where the resource owner has a trust relationship with the\n    client, such as the device operating system or a highly privileged\n    application.  The authorization server should take special care when\n    enabling this grant type, and only allow it when other flows are not\n    viable.\n\n    The grant type is suitable for clients capable of obtaining the\n    resource owner's credentials (username and password, typically using\n    an interactive form).  It is also used to migrate existing clients\n    using direct authentication schemes such as HTTP Basic or Digest\n    authentication to OAuth by converting the stored credentials to an\n    access token.\n\n    The method through which the client obtains the resource owner\n    credentials is beyond the scope of this specification.  The client\n    MUST discard the credentials once an access token has been obtained.\n    \"\"\"\n\n    grant_type = 'password'\n\n    def __init__(self, client_id, **kwargs):\n        super().__init__(client_id, **kwargs)\n\n    def prepare_request_body(self, username, password, body='', scope=None,\n                             include_client_id=False, **kwargs):\n        \"\"\"Add the resource owner password and username to the request body.\n\n        The client makes a request to the token endpoint by adding the\n        following parameters using the \"application/x-www-form-urlencoded\"\n        format per `Appendix B`_ in the HTTP request entity-body:\n\n        :param username:    The resource owner username.\n        :param password:    The resource owner password.\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n        :param scope:   The scope of the access request as described by\n                        `Section 3.3`_.\n        :param include_client_id: `True` to send the `client_id` in the\n                                  body of the upstream request. This is required\n                                  if the client is not authenticating with the\n                                  authorization server as described in\n                                  `Section 3.2.1`_. False otherwise (default).\n        :type include_client_id: Boolean\n        :param kwargs:  Extra credentials to include in the token request.\n\n        If the client type is confidential or the client was issued client\n        credentials (or assigned other authentication requirements), the\n        client MUST authenticate with the authorization server as described\n        in `Section 3.2.1`_.\n\n        The prepared body will include all provided credentials as well as\n        the ``grant_type`` parameter set to ``password``::\n\n            >>> from oauthlib.oauth2 import LegacyApplicationClient\n            >>> client = LegacyApplicationClient('your_id')\n            >>> client.prepare_request_body(username='foo', password='bar', scope=['hello', 'world'])\n            'grant_type=password&username=foo&scope=hello+world&password=bar'\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 3.2.1`: https://tools.ietf.org/html/rfc6749#section-3.2.1\n        \"\"\"\n        kwargs['client_id'] = self.client_id\n        kwargs['include_client_id'] = include_client_id\n        scope = self.scope if scope is None else scope\n        return prepare_token_request(self.grant_type, body=body, username=username,\n                                     password=password, scope=scope, **kwargs)\n", "oauthlib/oauth2/rfc6749/clients/base.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming OAuth 2.0 RFC6749.\n\"\"\"\nimport base64\nimport hashlib\nimport re\nimport secrets\nimport time\nimport warnings\n\nfrom oauthlib.common import generate_token\nfrom oauthlib.oauth2.rfc6749 import tokens\nfrom oauthlib.oauth2.rfc6749.errors import (\n    InsecureTransportError, TokenExpiredError,\n)\nfrom oauthlib.oauth2.rfc6749.parameters import (\n    parse_token_response, prepare_token_request,\n    prepare_token_revocation_request,\n)\nfrom oauthlib.oauth2.rfc6749.utils import is_secure_transport\n\nAUTH_HEADER = 'auth_header'\nURI_QUERY = 'query'\nBODY = 'body'\n\nFORM_ENC_HEADERS = {\n    'Content-Type': 'application/x-www-form-urlencoded'\n}\n\n\nclass Client:\n    \"\"\"Base OAuth2 client responsible for access token management.\n\n    This class also acts as a generic interface providing methods common to all\n    client types such as ``prepare_authorization_request`` and\n    ``prepare_token_revocation_request``. The ``prepare_x_request`` methods are\n    the recommended way of interacting with clients (as opposed to the abstract\n    prepare uri/body/etc methods). They are recommended over the older set\n    because they are easier to use (more consistent) and add a few additional\n    security checks, such as HTTPS and state checking.\n\n    Some of these methods require further implementation only provided by the\n    specific purpose clients such as\n    :py:class:`oauthlib.oauth2.MobileApplicationClient` and thus you should always\n    seek to use the client class matching the OAuth workflow you need. For\n    Python, this is usually :py:class:`oauthlib.oauth2.WebApplicationClient`.\n\n    \"\"\"\n    refresh_token_key = 'refresh_token'\n\n    def __init__(self, client_id,\n                 default_token_placement=AUTH_HEADER,\n                 token_type='Bearer',\n                 access_token=None,\n                 refresh_token=None,\n                 mac_key=None,\n                 mac_algorithm=None,\n                 token=None,\n                 scope=None,\n                 state=None,\n                 redirect_url=None,\n                 state_generator=generate_token,\n                 code_verifier=None,\n                 code_challenge=None,\n                 code_challenge_method=None,\n                 **kwargs):\n        \"\"\"Initialize a client with commonly used attributes.\n\n        :param client_id: Client identifier given by the OAuth provider upon\n        registration.\n\n        :param default_token_placement: Tokens can be supplied in the Authorization\n        header (default), the URL query component (``query``) or the request\n        body (``body``).\n\n        :param token_type: OAuth 2 token type. Defaults to Bearer. Change this\n        if you specify the ``access_token`` parameter and know it is of a\n        different token type, such as a MAC, JWT or SAML token. Can\n        also be supplied as ``token_type`` inside the ``token`` dict parameter.\n\n        :param access_token: An access token (string) used to authenticate\n        requests to protected resources. Can also be supplied inside the\n        ``token`` dict parameter.\n\n        :param refresh_token: A refresh token (string) used to refresh expired\n        tokens. Can also be supplied inside the ``token`` dict parameter.\n\n        :param mac_key: Encryption key used with MAC tokens.\n\n        :param mac_algorithm:  Hashing algorithm for MAC tokens.\n\n        :param token: A dict of token attributes such as ``access_token``,\n        ``token_type`` and ``expires_at``.\n\n        :param scope: A list of default scopes to request authorization for.\n\n        :param state: A CSRF protection string used during authorization.\n\n        :param redirect_url: The redirection endpoint on the client side to which\n        the user returns after authorization.\n\n        :param state_generator: A no argument state generation callable. Defaults\n        to :py:meth:`oauthlib.common.generate_token`.\n\n        :param code_verifier: PKCE parameter. A cryptographically random string that is used to correlate the\n        authorization request to the token request.\n\n        :param code_challenge: PKCE parameter. A challenge derived from the code verifier that is sent in the\n        authorization request, to be verified against later.\n\n        :param code_challenge_method: PKCE parameter. A method that was used to derive code challenge.\n        Defaults to \"plain\" if not present in the request.\n        \"\"\"\n\n        self.client_id = client_id\n        self.default_token_placement = default_token_placement\n        self.token_type = token_type\n        self.access_token = access_token\n        self.refresh_token = refresh_token\n        self.mac_key = mac_key\n        self.mac_algorithm = mac_algorithm\n        self.token = token or {}\n        self.scope = scope\n        self.state_generator = state_generator\n        self.state = state\n        self.redirect_url = redirect_url\n        self.code_verifier = code_verifier\n        self.code_challenge = code_challenge\n        self.code_challenge_method = code_challenge_method\n        self.code = None\n        self.expires_in = None\n        self._expires_at = None\n        self.populate_token_attributes(self.token)\n\n    @property\n    def token_types(self):\n        \"\"\"Supported token types and their respective methods\n\n        Additional tokens can be supported by extending this dictionary.\n\n        The Bearer token spec is stable and safe to use.\n\n        The MAC token spec is not yet stable and support for MAC tokens\n        is experimental and currently matching version 00 of the spec.\n        \"\"\"\n        return {\n            'Bearer': self._add_bearer_token,\n            'MAC': self._add_mac_token\n        }\n\n    def prepare_request_uri(self, *args, **kwargs):\n        \"\"\"Abstract method used to create request URIs.\"\"\"\n        raise NotImplementedError(\"Must be implemented by inheriting classes.\")\n\n    def prepare_request_body(self, *args, **kwargs):\n        \"\"\"Abstract method used to create request bodies.\"\"\"\n        raise NotImplementedError(\"Must be implemented by inheriting classes.\")\n\n    def parse_request_uri_response(self, *args, **kwargs):\n        \"\"\"Abstract method used to parse redirection responses.\"\"\"\n        raise NotImplementedError(\"Must be implemented by inheriting classes.\")\n\n    def add_token(self, uri, http_method='GET', body=None, headers=None,\n                  token_placement=None, **kwargs):\n        \"\"\"Add token to the request uri, body or authorization header.\n\n        The access token type provides the client with the information\n        required to successfully utilize the access token to make a protected\n        resource request (along with type-specific attributes).  The client\n        MUST NOT use an access token if it does not understand the token\n        type.\n\n        For example, the \"bearer\" token type defined in\n        [`I-D.ietf-oauth-v2-bearer`_] is utilized by simply including the access\n        token string in the request:\n\n        .. code-block:: http\n\n            GET /resource/1 HTTP/1.1\n            Host: example.com\n            Authorization: Bearer mF_9.B5f-4.1JqM\n\n        while the \"mac\" token type defined in [`I-D.ietf-oauth-v2-http-mac`_] is\n        utilized by issuing a MAC key together with the access token which is\n        used to sign certain components of the HTTP requests:\n\n        .. code-block:: http\n\n            GET /resource/1 HTTP/1.1\n            Host: example.com\n            Authorization: MAC id=\"h480djs93hd8\",\n                                nonce=\"274312:dj83hs9s\",\n                                mac=\"kDZvddkndxvhGRXZhvuDjEWhGeE=\"\n\n        .. _`I-D.ietf-oauth-v2-bearer`: https://tools.ietf.org/html/rfc6749#section-12.2\n        .. _`I-D.ietf-oauth-v2-http-mac`: https://tools.ietf.org/html/rfc6749#section-12.2\n        \"\"\"\n        if not is_secure_transport(uri):\n            raise InsecureTransportError()\n\n        token_placement = token_placement or self.default_token_placement\n\n        case_insensitive_token_types = {\n            k.lower(): v for k, v in self.token_types.items()}\n        if self.token_type.lower() not in case_insensitive_token_types:\n            raise ValueError(\"Unsupported token type: %s\" % self.token_type)\n\n        if not (self.access_token or self.token.get('access_token')):\n            raise ValueError(\"Missing access token.\")\n\n        if self._expires_at and self._expires_at < time.time():\n            raise TokenExpiredError()\n\n        return case_insensitive_token_types[self.token_type.lower()](uri, http_method, body,\n                                                                     headers, token_placement, **kwargs)\n\n    def prepare_authorization_request(self, authorization_url, state=None,\n                                      redirect_url=None, scope=None, **kwargs):\n        \"\"\"Prepare the authorization request.\n\n        This is the first step in many OAuth flows in which the user is\n        redirected to a certain authorization URL. This method adds\n        required parameters to the authorization URL.\n\n        :param authorization_url: Provider authorization endpoint URL.\n        :param state: CSRF protection string. Will be automatically created if\n            not provided. The generated state is available via the ``state``\n            attribute. Clients should verify that the state is unchanged and\n            present in the authorization response. This verification is done\n            automatically if using the ``authorization_response`` parameter\n            with ``prepare_token_request``.\n        :param redirect_url: Redirect URL to which the user will be returned\n            after authorization. Must be provided unless previously setup with\n            the provider. If provided then it must also be provided in the\n            token request.\n        :param scope: List of scopes to request. Must be equal to\n            or a subset of the scopes granted when obtaining the refresh\n            token. If none is provided, the ones provided in the constructor are\n            used.\n        :param kwargs: Additional parameters to included in the request.\n        :returns: The prepared request tuple with (url, headers, body).\n        \"\"\"\n        if not is_secure_transport(authorization_url):\n            raise InsecureTransportError()\n\n        self.state = state or self.state_generator()\n        self.redirect_url = redirect_url or self.redirect_url\n        # do not assign scope to self automatically anymore\n        scope = self.scope if scope is None else scope\n        auth_url = self.prepare_request_uri(\n            authorization_url, redirect_uri=self.redirect_url,\n            scope=scope, state=self.state, **kwargs)\n        return auth_url, FORM_ENC_HEADERS, ''\n\n    def prepare_token_request(self, token_url, authorization_response=None,\n                              redirect_url=None, state=None, body='', **kwargs):\n        \"\"\"Prepare a token creation request.\n\n        Note that these requests usually require client authentication, either\n        by including client_id or a set of provider specific authentication\n        credentials.\n\n        :param token_url: Provider token creation endpoint URL.\n        :param authorization_response: The full redirection URL string, i.e.\n            the location to which the user was redirected after successful\n            authorization. Used to mine credentials needed to obtain a token\n            in this step, such as authorization code.\n        :param redirect_url: The redirect_url supplied with the authorization\n            request (if there was one).\n        :param state:\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n        :param kwargs: Additional parameters to included in the request.\n        :returns: The prepared request tuple with (url, headers, body).\n        \"\"\"\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        state = state or self.state\n        if authorization_response:\n            self.parse_request_uri_response(\n                authorization_response, state=state)\n        self.redirect_url = redirect_url or self.redirect_url\n        body = self.prepare_request_body(body=body,\n                                         redirect_uri=self.redirect_url, **kwargs)\n\n        return token_url, FORM_ENC_HEADERS, body\n\n    def prepare_refresh_token_request(self, token_url, refresh_token=None,\n                                      body='', scope=None, **kwargs):\n        \"\"\"Prepare an access token refresh request.\n\n        Expired access tokens can be replaced by new access tokens without\n        going through the OAuth dance if the client obtained a refresh token.\n        This refresh token and authentication credentials can be used to\n        obtain a new access token, and possibly a new refresh token.\n\n        :param token_url: Provider token refresh endpoint URL.\n        :param refresh_token: Refresh token string.\n        :param body: Existing request body (URL encoded string) to embed parameters\n            into. This may contain extra parameters. Default ''.\n        :param scope: List of scopes to request. Must be equal to\n            or a subset of the scopes granted when obtaining the refresh\n            token. If none is provided, the ones provided in the constructor are\n            used.\n        :param kwargs: Additional parameters to included in the request.\n        :returns: The prepared request tuple with (url, headers, body).\n        \"\"\"\n        if not is_secure_transport(token_url):\n            raise InsecureTransportError()\n\n        # do not assign scope to self automatically anymore\n        scope = self.scope if scope is None else scope\n        body = self.prepare_refresh_body(body=body,\n                                         refresh_token=refresh_token, scope=scope, **kwargs)\n        return token_url, FORM_ENC_HEADERS, body\n\n    def prepare_token_revocation_request(self, revocation_url, token,\n                                         token_type_hint=\"access_token\", body='', callback=None, **kwargs):\n        \"\"\"Prepare a token revocation request.\n\n        :param revocation_url: Provider token revocation endpoint URL.\n        :param token: The access or refresh token to be revoked (string).\n        :param token_type_hint: ``\"access_token\"`` (default) or\n            ``\"refresh_token\"``. This is optional and if you wish to not pass it you\n            must provide ``token_type_hint=None``.\n        :param body:\n        :param callback: A jsonp callback such as ``package.callback`` to be invoked\n            upon receiving the response. Not that it should not include a () suffix.\n        :param kwargs: Additional parameters to included in the request.\n        :returns: The prepared request tuple with (url, headers, body).\n\n        Note that JSONP request may use GET requests as the parameters will\n        be added to the request URL query as opposed to the request body.\n\n        An example of a revocation request\n\n        .. code-block:: http\n\n            POST /revoke HTTP/1.1\n            Host: server.example.com\n            Content-Type: application/x-www-form-urlencoded\n            Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n\n            token=45ghiukldjahdnhzdauz&token_type_hint=refresh_token\n\n        An example of a jsonp revocation request\n\n        .. code-block:: http\n\n            GET /revoke?token=agabcdefddddafdd&callback=package.myCallback HTTP/1.1\n            Host: server.example.com\n            Content-Type: application/x-www-form-urlencoded\n            Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW\n\n        and an error response\n\n        .. code-block:: javascript\n\n            package.myCallback({\"error\":\"unsupported_token_type\"});\n\n        Note that these requests usually require client credentials, client_id in\n        the case for public clients and provider specific authentication\n        credentials for confidential clients.\n        \"\"\"\n        if not is_secure_transport(revocation_url):\n            raise InsecureTransportError()\n\n        return prepare_token_revocation_request(revocation_url, token,\n                                                token_type_hint=token_type_hint, body=body, callback=callback,\n                                                **kwargs)\n\n    def parse_request_body_response(self, body, scope=None, **kwargs):\n        \"\"\"Parse the JSON response body.\n\n        If the access token request is valid and authorized, the\n        authorization server issues an access token as described in\n        `Section 5.1`_.  A refresh token SHOULD NOT be included.  If the request\n        failed client authentication or is invalid, the authorization server\n        returns an error response as described in `Section 5.2`_.\n\n        :param body: The response body from the token request.\n        :param scope: Scopes originally requested. If none is provided, the ones\n            provided in the constructor are used.\n        :return: Dictionary of token parameters.\n        :raises: Warning if scope has changed. :py:class:`oauthlib.oauth2.errors.OAuth2Error`\n            if response is invalid.\n\n        These response are json encoded and could easily be parsed without\n        the assistance of OAuthLib. However, there are a few subtle issues\n        to be aware of regarding the response which are helpfully addressed\n        through the raising of various errors.\n\n        A successful response should always contain\n\n        **access_token**\n                The access token issued by the authorization server. Often\n                a random string.\n\n        **token_type**\n            The type of the token issued as described in `Section 7.1`_.\n            Commonly ``Bearer``.\n\n        While it is not mandated it is recommended that the provider include\n\n        **expires_in**\n            The lifetime in seconds of the access token.  For\n            example, the value \"3600\" denotes that the access token will\n            expire in one hour from the time the response was generated.\n            If omitted, the authorization server SHOULD provide the\n            expiration time via other means or document the default value.\n\n         **scope**\n            Providers may supply this in all responses but are required to only\n            if it has changed since the authorization request.\n\n        .. _`Section 5.1`: https://tools.ietf.org/html/rfc6749#section-5.1\n        .. _`Section 5.2`: https://tools.ietf.org/html/rfc6749#section-5.2\n        .. _`Section 7.1`: https://tools.ietf.org/html/rfc6749#section-7.1\n        \"\"\"\n        scope = self.scope if scope is None else scope\n        self.token = parse_token_response(body, scope=scope)\n        self.populate_token_attributes(self.token)\n        return self.token\n\n    def prepare_refresh_body(self, body='', refresh_token=None, scope=None, **kwargs):\n        \"\"\"Prepare an access token request, using a refresh token.\n\n        If the authorization server issued a refresh token to the client, the\n        client makes a refresh request to the token endpoint by adding the\n        following parameters using the `application/x-www-form-urlencoded`\n        format in the HTTP request entity-body:\n\n        :param refresh_token: REQUIRED.  The refresh token issued to the client.\n        :param scope:  OPTIONAL.  The scope of the access request as described by\n            Section 3.3.  The requested scope MUST NOT include any scope\n            not originally granted by the resource owner, and if omitted is\n            treated as equal to the scope originally granted by the\n            resource owner. Note that if none is provided, the ones provided\n            in the constructor are used if any.\n        \"\"\"\n        refresh_token = refresh_token or self.refresh_token\n        scope = self.scope if scope is None else scope\n        return prepare_token_request(self.refresh_token_key, body=body, scope=scope,\n                                     refresh_token=refresh_token, **kwargs)\n\n    def _add_bearer_token(self, uri, http_method='GET', body=None,\n                          headers=None, token_placement=None):\n        \"\"\"Add a bearer token to the request uri, body or authorization header.\"\"\"\n        if token_placement == AUTH_HEADER:\n            headers = tokens.prepare_bearer_headers(self.access_token, headers)\n\n        elif token_placement == URI_QUERY:\n            uri = tokens.prepare_bearer_uri(self.access_token, uri)\n\n        elif token_placement == BODY:\n            body = tokens.prepare_bearer_body(self.access_token, body)\n\n        else:\n            raise ValueError(\"Invalid token placement.\")\n        return uri, headers, body\n\n    def create_code_verifier(self, length):\n        \"\"\"Create PKCE **code_verifier** used in computing **code_challenge**.\n        See `RFC7636 Section 4.1`_\n\n        :param length: REQUIRED. The length of the code_verifier.\n\n        The client first creates a code verifier, \"code_verifier\", for each\n        OAuth 2.0 [RFC6749] Authorization Request, in the following manner:\n\n        .. code-block:: text\n\n               code_verifier = high-entropy cryptographic random STRING using the\n               unreserved characters [A-Z] / [a-z] / [0-9] / \"-\" / \".\" / \"_\" / \"~\"\n               from Section 2.3 of [RFC3986], with a minimum length of 43 characters\n               and a maximum length of 128 characters.\n\n        .. _`RFC7636 Section 4.1`: https://tools.ietf.org/html/rfc7636#section-4.1\n        \"\"\"\n        code_verifier = None\n\n        if not length >= 43:\n            raise ValueError(\"Length must be greater than or equal to 43\")\n\n        if not length <= 128:\n            raise ValueError(\"Length must be less than or equal to 128\")\n\n        allowed_characters = re.compile('^[A-Zaa-z0-9-._~]')\n        code_verifier = secrets.token_urlsafe(length)\n\n        if not re.search(allowed_characters, code_verifier):\n            raise ValueError(\"code_verifier contains invalid characters\")\n\n        self.code_verifier = code_verifier\n\n        return code_verifier\n\n    def create_code_challenge(self, code_verifier, code_challenge_method=None):\n        \"\"\"Create PKCE **code_challenge** derived from the  **code_verifier**.\n        See `RFC7636 Section 4.2`_\n\n        :param code_verifier: REQUIRED. The **code_verifier** generated from `create_code_verifier()`.\n        :param code_challenge_method: OPTIONAL. The method used to derive the **code_challenge**. Acceptable values include `S256`. DEFAULT is `plain`.\n\n               The client then creates a code challenge derived from the code\n               verifier by using one of the following transformations on the code\n               verifier::\n\n                   plain\n                      code_challenge = code_verifier\n                   S256\n                      code_challenge = BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))\n\n               If the client is capable of using `S256`, it MUST use `S256`, as\n               `S256` is Mandatory To Implement (MTI) on the server.  Clients are\n               permitted to use `plain` only if they cannot support `S256` for some\n               technical reason and know via out-of-band configuration that the\n               server supports `plain`.\n\n               The plain transformation is for compatibility with existing\n               deployments and for constrained environments that can't use the S256 transformation.\n\n        .. _`RFC7636 Section 4.2`: https://tools.ietf.org/html/rfc7636#section-4.2\n        \"\"\"\n        code_challenge = None\n\n        if code_verifier is None:\n            raise ValueError(\"Invalid code_verifier\")\n\n        if code_challenge_method is None:\n            code_challenge_method = \"plain\"\n            self.code_challenge_method = code_challenge_method\n            code_challenge = code_verifier\n            self.code_challenge = code_challenge\n\n        if code_challenge_method == \"S256\":\n            h = hashlib.sha256()\n            h.update(code_verifier.encode(encoding='ascii'))\n            sha256_val = h.digest()\n            code_challenge = bytes.decode(base64.urlsafe_b64encode(sha256_val))\n            # replace '+' with '-', '/' with '_', and remove trailing '='\n            code_challenge = code_challenge.replace(\"+\", \"-\").replace(\"/\", \"_\").replace(\"=\", \"\")\n            self.code_challenge = code_challenge\n\n        return code_challenge\n\n    def _add_mac_token(self, uri, http_method='GET', body=None,\n                       headers=None, token_placement=AUTH_HEADER, ext=None, **kwargs):\n        \"\"\"Add a MAC token to the request authorization header.\n\n        Warning: MAC token support is experimental as the spec is not yet stable.\n        \"\"\"\n        if token_placement != AUTH_HEADER:\n            raise ValueError(\"Invalid token placement.\")\n\n        headers = tokens.prepare_mac_header(self.access_token, uri,\n                                            self.mac_key, http_method, headers=headers, body=body, ext=ext,\n                                            hash_algorithm=self.mac_algorithm, **kwargs)\n        return uri, headers, body\n\n    def _populate_attributes(self, response):\n        warnings.warn(\"Please switch to the public method \"\n                      \"populate_token_attributes.\", DeprecationWarning)\n        return self.populate_token_attributes(response)\n\n    def populate_code_attributes(self, response):\n        \"\"\"Add attributes from an auth code response to self.\"\"\"\n\n        if 'code' in response:\n            self.code = response.get('code')\n\n    def populate_token_attributes(self, response):\n        \"\"\"Add attributes from a token exchange response to self.\"\"\"\n\n        if 'access_token' in response:\n            self.access_token = response.get('access_token')\n\n        if 'refresh_token' in response:\n            self.refresh_token = response.get('refresh_token')\n\n        if 'token_type' in response:\n            self.token_type = response.get('token_type')\n\n        if 'expires_in' in response:\n            self.expires_in = response.get('expires_in')\n            self._expires_at = round(time.time()) + int(self.expires_in)\n\n        if 'expires_at' in response:\n            try:\n                self._expires_at = round(float(response.get('expires_at')))\n            except:\n                self._expires_at = None\n\n        if 'mac_key' in response:\n            self.mac_key = response.get('mac_key')\n\n        if 'mac_algorithm' in response:\n            self.mac_algorithm = response.get('mac_algorithm')\n", "oauthlib/oauth2/rfc6749/clients/service_application.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nimport time\n\nfrom oauthlib.common import to_unicode\n\nfrom ..parameters import prepare_token_request\nfrom .base import Client\n\n\nclass ServiceApplicationClient(Client):\n    \"\"\"A public client utilizing the JWT bearer grant.\n\n    JWT bearer tokes can be used to request an access token when a client\n    wishes to utilize an existing trust relationship, expressed through the\n    semantics of (and digital signature or keyed message digest calculated\n    over) the JWT, without a direct user approval step at the authorization\n    server.\n\n    This grant type does not involve an authorization step. It may be\n    used by both public and confidential clients.\n    \"\"\"\n\n    grant_type = 'urn:ietf:params:oauth:grant-type:jwt-bearer'\n\n    def __init__(self, client_id, private_key=None, subject=None, issuer=None,\n                 audience=None, **kwargs):\n        \"\"\"Initialize a JWT client with defaults for implicit use later.\n\n        :param client_id: Client identifier given by the OAuth provider upon\n                          registration.\n\n        :param private_key: Private key used for signing and encrypting.\n                            Must be given as a string.\n\n        :param subject: The principal that is the subject of the JWT, i.e.\n                        which user is the token requested on behalf of.\n                        For example, ``foo@example.com.\n\n        :param issuer: The JWT MUST contain an \"iss\" (issuer) claim that\n                       contains a unique identifier for the entity that issued\n                       the JWT. For example, ``your-client@provider.com``.\n\n        :param audience: A value identifying the authorization server as an\n                         intended audience, e.g.\n                         ``https://provider.com/oauth2/token``.\n\n        :param kwargs: Additional arguments to pass to base client, such as\n                       state and token. See ``Client.__init__.__doc__`` for\n                       details.\n        \"\"\"\n        super().__init__(client_id, **kwargs)\n        self.private_key = private_key\n        self.subject = subject\n        self.issuer = issuer\n        self.audience = audience\n\n    def prepare_request_body(self,\n                             private_key=None,\n                             subject=None,\n                             issuer=None,\n                             audience=None,\n                             expires_at=None,\n                             issued_at=None,\n                             extra_claims=None,\n                             body='',\n                             scope=None,\n                             include_client_id=False,\n                             **kwargs):\n        \"\"\"Create and add a JWT assertion to the request body.\n\n        :param private_key: Private key used for signing and encrypting.\n                            Must be given as a string.\n\n        :param subject: (sub) The principal that is the subject of the JWT,\n                        i.e.  which user is the token requested on behalf of.\n                        For example, ``foo@example.com.\n\n        :param issuer: (iss) The JWT MUST contain an \"iss\" (issuer) claim that\n                       contains a unique identifier for the entity that issued\n                       the JWT. For example, ``your-client@provider.com``.\n\n        :param audience: (aud) A value identifying the authorization server as an\n                         intended audience, e.g.\n                         ``https://provider.com/oauth2/token``.\n\n        :param expires_at: A unix expiration timestamp for the JWT. Defaults\n                           to an hour from now, i.e. ``time.time() + 3600``.\n\n        :param issued_at: A unix timestamp of when the JWT was created.\n                          Defaults to now, i.e. ``time.time()``.\n\n        :param extra_claims: A dict of additional claims to include in the JWT.\n\n        :param body: Existing request body (URL encoded string) to embed parameters\n                     into. This may contain extra parameters. Default ''.\n\n        :param scope: The scope of the access request.\n\n        :param include_client_id: `True` to send the `client_id` in the\n                                  body of the upstream request. This is required\n                                  if the client is not authenticating with the\n                                  authorization server as described in\n                                  `Section 3.2.1`_. False otherwise (default).\n        :type include_client_id: Boolean\n\n        :param not_before: A unix timestamp after which the JWT may be used.\n                           Not included unless provided. *\n\n        :param jwt_id: A unique JWT token identifier. Not included unless\n                       provided. *\n\n        :param kwargs: Extra credentials to include in the token request.\n\n        Parameters marked with a `*` above are not explicit arguments in the\n        function signature, but are specially documented arguments for items\n        appearing in the generic `**kwargs` keyworded input.\n\n        The \"scope\" parameter may be used, as defined in the Assertion\n        Framework for OAuth 2.0 Client Authentication and Authorization Grants\n        [I-D.ietf-oauth-assertions] specification, to indicate the requested\n        scope.\n\n        Authentication of the client is optional, as described in\n        `Section 3.2.1`_ of OAuth 2.0 [RFC6749] and consequently, the\n        \"client_id\" is only needed when a form of client authentication that\n        relies on the parameter is used.\n\n        The following non-normative example demonstrates an Access Token\n        Request with a JWT as an authorization grant (with extra line breaks\n        for display purposes only):\n\n        .. code-block: http\n\n            POST /token.oauth2 HTTP/1.1\n            Host: as.example.com\n            Content-Type: application/x-www-form-urlencoded\n\n            grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Ajwt-bearer\n            &assertion=eyJhbGciOiJFUzI1NiJ9.\n            eyJpc3Mi[...omitted for brevity...].\n            J9l-ZhwP[...omitted for brevity...]\n\n        .. _`Section 3.2.1`: https://tools.ietf.org/html/rfc6749#section-3.2.1\n        \"\"\"\n        import jwt\n\n        key = private_key or self.private_key\n        if not key:\n            raise ValueError('An encryption key must be supplied to make JWT'\n                             ' token requests.')\n        claim = {\n            'iss': issuer or self.issuer,\n            'aud': audience or self.audience,\n            'sub': subject or self.subject,\n            'exp': int(expires_at or time.time() + 3600),\n            'iat': int(issued_at or time.time()),\n        }\n\n        for attr in ('iss', 'aud', 'sub'):\n            if claim[attr] is None:\n                raise ValueError(\n                        'Claim must include %s but none was given.' % attr)\n\n        if 'not_before' in kwargs:\n            claim['nbf'] = kwargs.pop('not_before')\n\n        if 'jwt_id' in kwargs:\n            claim['jti'] = kwargs.pop('jwt_id')\n\n        claim.update(extra_claims or {})\n\n        assertion = jwt.encode(claim, key, 'RS256')\n        assertion = to_unicode(assertion)\n\n        kwargs['client_id'] = self.client_id\n        kwargs['include_client_id'] = include_client_id\n        scope = self.scope if scope is None else scope\n        return prepare_token_request(self.grant_type,\n                                     body=body,\n                                     assertion=assertion,\n                                     scope=scope,\n                                     **kwargs)\n", "oauthlib/oauth2/rfc6749/clients/mobile_application.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OAuth 2.0 RFC6749.\n\"\"\"\nfrom ..parameters import parse_implicit_response, prepare_grant_uri\nfrom .base import Client\n\n\nclass MobileApplicationClient(Client):\n\n    \"\"\"A public client utilizing the implicit code grant workflow.\n\n    A user-agent-based application is a public client in which the\n    client code is downloaded from a web server and executes within a\n    user-agent (e.g. web browser) on the device used by the resource\n    owner.  Protocol data and credentials are easily accessible (and\n    often visible) to the resource owner.  Since such applications\n    reside within the user-agent, they can make seamless use of the\n    user-agent capabilities when requesting authorization.\n\n    The implicit grant type is used to obtain access tokens (it does not\n    support the issuance of refresh tokens) and is optimized for public\n    clients known to operate a particular redirection URI.  These clients\n    are typically implemented in a browser using a scripting language\n    such as JavaScript.\n\n    As a redirection-based flow, the client must be capable of\n    interacting with the resource owner's user-agent (typically a web\n    browser) and capable of receiving incoming requests (via redirection)\n    from the authorization server.\n\n    Unlike the authorization code grant type in which the client makes\n    separate requests for authorization and access token, the client\n    receives the access token as the result of the authorization request.\n\n    The implicit grant type does not include client authentication, and\n    relies on the presence of the resource owner and the registration of\n    the redirection URI.  Because the access token is encoded into the\n    redirection URI, it may be exposed to the resource owner and other\n    applications residing on the same device.\n    \"\"\"\n\n    response_type = 'token'\n\n    def prepare_request_uri(self, uri, redirect_uri=None, scope=None,\n                            state=None, **kwargs):\n        \"\"\"Prepare the implicit grant request URI.\n\n        The client constructs the request URI by adding the following\n        parameters to the query component of the authorization endpoint URI\n        using the \"application/x-www-form-urlencoded\" format, per `Appendix B`_:\n\n        :param redirect_uri:  OPTIONAL. The redirect URI must be an absolute URI\n                              and it should have been registered with the OAuth\n                              provider prior to use. As described in `Section 3.1.2`_.\n\n        :param scope:  OPTIONAL. The scope of the access request as described by\n                       Section 3.3`_. These may be any string but are commonly\n                       URIs or various categories such as ``videos`` or ``documents``.\n\n        :param state:   RECOMMENDED.  An opaque value used by the client to maintain\n                        state between the request and callback.  The authorization\n                        server includes this value when redirecting the user-agent back\n                        to the client.  The parameter SHOULD be used for preventing\n                        cross-site request forgery as described in `Section 10.12`_.\n\n        :param kwargs:  Extra arguments to include in the request URI.\n\n        In addition to supplied parameters, OAuthLib will append the ``client_id``\n        that was provided in the constructor as well as the mandatory ``response_type``\n        argument, set to ``token``::\n\n            >>> from oauthlib.oauth2 import MobileApplicationClient\n            >>> client = MobileApplicationClient('your_id')\n            >>> client.prepare_request_uri('https://example.com')\n            'https://example.com?client_id=your_id&response_type=token'\n            >>> client.prepare_request_uri('https://example.com', redirect_uri='https://a.b/callback')\n            'https://example.com?client_id=your_id&response_type=token&redirect_uri=https%3A%2F%2Fa.b%2Fcallback'\n            >>> client.prepare_request_uri('https://example.com', scope=['profile', 'pictures'])\n            'https://example.com?client_id=your_id&response_type=token&scope=profile+pictures'\n            >>> client.prepare_request_uri('https://example.com', foo='bar')\n            'https://example.com?client_id=your_id&response_type=token&foo=bar'\n\n        .. _`Appendix B`: https://tools.ietf.org/html/rfc6749#appendix-B\n        .. _`Section 2.2`: https://tools.ietf.org/html/rfc6749#section-2.2\n        .. _`Section 3.1.2`: https://tools.ietf.org/html/rfc6749#section-3.1.2\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        .. _`Section 10.12`: https://tools.ietf.org/html/rfc6749#section-10.12\n        \"\"\"\n        scope = self.scope if scope is None else scope\n        return prepare_grant_uri(uri, self.client_id, self.response_type,\n                                 redirect_uri=redirect_uri, state=state, scope=scope, **kwargs)\n\n    def parse_request_uri_response(self, uri, state=None, scope=None):\n        \"\"\"Parse the response URI fragment.\n\n        If the resource owner grants the access request, the authorization\n        server issues an access token and delivers it to the client by adding\n        the following parameters to the fragment component of the redirection\n        URI using the \"application/x-www-form-urlencoded\" format:\n\n        :param uri: The callback URI that resulted from the user being redirected\n                    back from the provider to you, the client.\n        :param state: The state provided in the authorization request.\n        :param scope: The scopes provided in the authorization request.\n        :return: Dictionary of token parameters.\n        :raises: OAuth2Error if response is invalid.\n\n        A successful response should always contain\n\n        **access_token**\n                The access token issued by the authorization server. Often\n                a random string.\n\n        **token_type**\n            The type of the token issued as described in `Section 7.1`_.\n            Commonly ``Bearer``.\n\n        **state**\n            If you provided the state parameter in the authorization phase, then\n            the provider is required to include that exact state value in the\n            response.\n\n        While it is not mandated it is recommended that the provider include\n\n        **expires_in**\n            The lifetime in seconds of the access token.  For\n            example, the value \"3600\" denotes that the access token will\n            expire in one hour from the time the response was generated.\n            If omitted, the authorization server SHOULD provide the\n            expiration time via other means or document the default value.\n\n        **scope**\n            Providers may supply this in all responses but are required to only\n            if it has changed since the authorization request.\n\n        A few example responses can be seen below::\n\n            >>> response_uri = 'https://example.com/callback#access_token=sdlfkj452&state=ss345asyht&token_type=Bearer&scope=hello+world'\n            >>> from oauthlib.oauth2 import MobileApplicationClient\n            >>> client = MobileApplicationClient('your_id')\n            >>> client.parse_request_uri_response(response_uri)\n            {\n                'access_token': 'sdlfkj452',\n                'token_type': 'Bearer',\n                'state': 'ss345asyht',\n                'scope': [u'hello', u'world']\n            }\n            >>> client.parse_request_uri_response(response_uri, state='other')\n            Traceback (most recent call last):\n                File \"<stdin>\", line 1, in <module>\n                File \"oauthlib/oauth2/rfc6749/__init__.py\", line 598, in parse_request_uri_response\n                    **scope**\n                File \"oauthlib/oauth2/rfc6749/parameters.py\", line 197, in parse_implicit_response\n                    raise ValueError(\"Mismatching or missing state in params.\")\n            ValueError: Mismatching or missing state in params.\n            >>> def alert_scope_changed(message, old, new):\n            ...     print(message, old, new)\n            ...\n            >>> oauthlib.signals.scope_changed.connect(alert_scope_changed)\n            >>> client.parse_request_body_response(response_body, scope=['other'])\n            ('Scope has changed from \"other\" to \"hello world\".', ['other'], ['hello', 'world'])\n\n        .. _`Section 7.1`: https://tools.ietf.org/html/rfc6749#section-7.1\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc6749#section-3.3\n        \"\"\"\n        scope = self.scope if scope is None else scope\n        self.token = parse_implicit_response(uri, state=state, scope=scope)\n        self.populate_token_attributes(self.token)\n        return self.token\n", "oauthlib/oauth2/rfc6749/clients/__init__.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth2.rfc6749\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming OAuth 2.0 RFC6749.\n\"\"\"\nfrom .backend_application import BackendApplicationClient\nfrom .base import AUTH_HEADER, BODY, URI_QUERY, Client\nfrom .legacy_application import LegacyApplicationClient\nfrom .mobile_application import MobileApplicationClient\nfrom .service_application import ServiceApplicationClient\nfrom .web_application import WebApplicationClient\n", "oauthlib/oauth1/__init__.py": "\"\"\"\noauthlib.oauth1\n~~~~~~~~~~~~~~\n\nThis module is a wrapper for the most recent implementation of OAuth 1.0 Client\nand Server classes.\n\"\"\"\nfrom .rfc5849 import (\n    SIGNATURE_HMAC, SIGNATURE_HMAC_SHA1, SIGNATURE_HMAC_SHA256,\n    SIGNATURE_HMAC_SHA512, SIGNATURE_PLAINTEXT, SIGNATURE_RSA,\n    SIGNATURE_RSA_SHA1, SIGNATURE_RSA_SHA256, SIGNATURE_RSA_SHA512,\n    SIGNATURE_TYPE_AUTH_HEADER, SIGNATURE_TYPE_BODY, SIGNATURE_TYPE_QUERY,\n    Client,\n)\nfrom .rfc5849.endpoints import (\n    AccessTokenEndpoint, AuthorizationEndpoint, RequestTokenEndpoint,\n    ResourceEndpoint, SignatureOnlyEndpoint, WebApplicationServer,\n)\nfrom .rfc5849.errors import (\n    InsecureTransportError, InvalidClientError, InvalidRequestError,\n    InvalidSignatureMethodError, OAuth1Error,\n)\nfrom .rfc5849.request_validator import RequestValidator\n", "oauthlib/oauth1/rfc5849/signature.py": "\"\"\"\nThis module is an implementation of `section 3.4`_ of RFC 5849.\n\n**Usage**\n\nSteps for signing a request:\n\n1. Collect parameters from the request using ``collect_parameters``.\n2. Normalize those parameters using ``normalize_parameters``.\n3. Create the *base string URI* using ``base_string_uri``.\n4. Create the *signature base string* from the above three components\n   using ``signature_base_string``.\n5. Pass the *signature base string* and the client credentials to one of the\n   sign-with-client functions. The HMAC-based signing functions needs\n   client credentials with secrets. The RSA-based signing functions needs\n   client credentials with an RSA private key.\n\nTo verify a request, pass the request and credentials to one of the verify\nfunctions. The HMAC-based signing functions needs the shared secrets. The\nRSA-based verify functions needs the RSA public key.\n\n**Scope**\n\nAll of the functions in this module should be considered internal to OAuthLib,\nsince they are not imported into the \"oauthlib.oauth1\" module. Programs using\nOAuthLib should not use directly invoke any of the functions in this module.\n\n**Deprecated functions**\n\nThe \"sign_\" methods that are not \"_with_client\" have been deprecated. They may\nbe removed in a future release. Since they are all internal functions, this\nshould have no impact on properly behaving programs.\n\n.. _`section 3.4`: https://tools.ietf.org/html/rfc5849#section-3.4\n\"\"\"\n\nimport binascii\nimport hashlib\nimport hmac\nimport ipaddress\nimport logging\nimport urllib.parse as urlparse\nimport warnings\n\nfrom oauthlib.common import extract_params, safe_string_equals, urldecode\n\nfrom . import utils\nimport contextlib\n\nlog = logging.getLogger(__name__)\n\n\n# ==== Common functions ==========================================\n\ndef signature_base_string(\n        http_method: str,\n        base_str_uri: str,\n        normalized_encoded_request_parameters: str) -> str:\n    \"\"\"\n    Construct the signature base string.\n\n    The *signature base string* is the value that is calculated and signed by\n    the client. It is also independently calculated by the server to verify\n    the signature, and therefore must produce the exact same value at both\n    ends or the signature won't verify.\n\n    The rules for calculating the *signature base string* are defined in\n    section 3.4.1.1`_ of RFC 5849.\n\n    .. _`section 3.4.1.1`: https://tools.ietf.org/html/rfc5849#section-3.4.1.1\n    \"\"\"\n\n    # The signature base string is constructed by concatenating together,\n    # in order, the following HTTP request elements:\n\n    # 1.  The HTTP request method in uppercase.  For example: \"HEAD\",\n    #     \"GET\", \"POST\", etc.  If the request uses a custom HTTP method, it\n    #     MUST be encoded (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    base_string = utils.escape(http_method.upper())\n\n    # 2.  An \"&\" character (ASCII code 38).\n    base_string += '&'\n\n    # 3.  The base string URI from `Section 3.4.1.2`_, after being encoded\n    #     (`Section 3.6`_).\n    #\n    # .. _`Section 3.4.1.2`: https://tools.ietf.org/html/rfc5849#section-3.4.1.2\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    base_string += utils.escape(base_str_uri)\n\n    # 4.  An \"&\" character (ASCII code 38).\n    base_string += '&'\n\n    # 5.  The request parameters as normalized in `Section 3.4.1.3.2`_, after\n    #     being encoded (`Section 3.6`).\n    #\n    # .. _`Sec 3.4.1.3.2`: https://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    base_string += utils.escape(normalized_encoded_request_parameters)\n\n    return base_string\n\n\ndef base_string_uri(uri: str, host: str = None) -> str:\n    \"\"\"\n    Calculates the _base string URI_.\n\n    The *base string URI* is one of the components that make up the\n     *signature base string*.\n\n    The ``host`` is optional. If provided, it is used to override any host and\n    port values in the ``uri``. The value for ``host`` is usually extracted from\n    the \"Host\" request header from the HTTP request. Its value may be just the\n    hostname, or the hostname followed by a colon and a TCP/IP port number\n    (hostname:port). If a value for the``host`` is provided but it does not\n    contain a port number, the default port number is used (i.e. if the ``uri``\n    contained a port number, it will be discarded).\n\n    The rules for calculating the *base string URI* are defined in\n    section 3.4.1.2`_ of RFC 5849.\n\n    .. _`section 3.4.1.2`: https://tools.ietf.org/html/rfc5849#section-3.4.1.2\n\n    :param uri: URI\n    :param host: hostname with optional port number, separated by a colon\n    :return: base string URI\n    \"\"\"\n\n    if not isinstance(uri, str):\n        raise ValueError('uri must be a string.')\n\n    # FIXME: urlparse does not support unicode\n    output = urlparse.urlparse(uri)\n    scheme = output.scheme\n    hostname = output.hostname\n    port = output.port\n    path = output.path\n    params = output.params\n\n    # The scheme, authority, and path of the request resource URI `RFC3986`\n    # are included by constructing an \"http\" or \"https\" URI representing\n    # the request resource (without the query or fragment) as follows:\n    #\n    # .. _`RFC3986`: https://tools.ietf.org/html/rfc3986\n\n    if not scheme:\n        raise ValueError('missing scheme')\n\n    # Per `RFC 2616 section 5.1.2`_:\n    #\n    # Note that the absolute path cannot be empty; if none is present in\n    # the original URI, it MUST be given as \"/\" (the server root).\n    #\n    # .. _`RFC 2616 5.1.2`: https://tools.ietf.org/html/rfc2616#section-5.1.2\n    if not path:\n        path = '/'\n\n    # 1.  The scheme and host MUST be in lowercase.\n    scheme = scheme.lower()\n    # Note: if ``host`` is used, it will be converted to lowercase below\n    if hostname is not None:\n        hostname = hostname.lower()\n\n    # 2.  The host and port values MUST match the content of the HTTP\n    #     request \"Host\" header field.\n    if host is not None:\n        # NOTE: override value in uri with provided host\n        # Host argument is equal to netloc. It means it's missing scheme.\n        # Add it back, before parsing.\n\n        host = host.lower()\n        host = f\"{scheme}://{host}\"\n        output = urlparse.urlparse(host)\n        hostname = output.hostname\n        port = output.port\n\n    # 3.  The port MUST be included if it is not the default port for the\n    #     scheme, and MUST be excluded if it is the default.  Specifically,\n    #     the port MUST be excluded when making an HTTP request `RFC2616`_\n    #     to port 80 or when making an HTTPS request `RFC2818`_ to port 443.\n    #     All other non-default port numbers MUST be included.\n    #\n    # .. _`RFC2616`: https://tools.ietf.org/html/rfc2616\n    # .. _`RFC2818`: https://tools.ietf.org/html/rfc2818\n\n    if hostname is None:\n        raise ValueError('missing host')\n\n    # NOTE: Try guessing if we're dealing with IP or hostname\n    with contextlib.suppress(ValueError):\n        hostname = ipaddress.ip_address(hostname)\n\n\n    if isinstance(hostname, ipaddress.IPv6Address):\n        hostname = f\"[{hostname}]\"\n    elif isinstance(hostname, ipaddress.IPv4Address):\n        hostname = f\"{hostname}\"\n\n    if port is not None and not (0 < port <= 65535):\n        raise ValueError('port out of range')  # 16-bit unsigned ints\n    if (scheme, port) in (('http', 80), ('https', 443)):\n        netloc = hostname  # default port for scheme: exclude port num\n    elif port:\n        netloc = f\"{hostname}:{port}\"  # use hostname:port\n    else:\n        netloc = hostname\n\n    v = urlparse.urlunparse((scheme, netloc, path, params, '', ''))\n\n    # RFC 5849 does not specify which characters are encoded in the\n    # \"base string URI\", nor how they are encoded - which is very bad, since\n    # the signatures won't match if there are any differences. Fortunately,\n    # most URIs only use characters that are clearly not encoded (e.g. digits\n    # and A-Z, a-z), so have avoided any differences between implementations.\n    #\n    # The example from its section 3.4.1.2 illustrates that spaces in\n    # the path are percent encoded. But it provides no guidance as to what other\n    # characters (if any) must be encoded (nor how); nor if characters in the\n    # other components are to be encoded or not.\n    #\n    # This implementation **assumes** that **only** the space is percent-encoded\n    # and it is done to the entire value (not just to spaces in the path).\n    #\n    # This code may need to be changed if it is discovered that other characters\n    # are expected to be encoded.\n    #\n    # Note: the \"base string URI\" returned by this function will be encoded\n    # again before being concatenated into the \"signature base string\". So any\n    # spaces in the URI will actually appear in the \"signature base string\"\n    # as \"%2520\" (the \"%20\" further encoded according to section 3.6).\n\n    return v.replace(' ', '%20')\n\n\ndef collect_parameters(uri_query='', body=None, headers=None,\n                       exclude_oauth_signature=True, with_realm=False):\n    \"\"\"\n    Gather the request parameters from all the parameter sources.\n\n    This function is used to extract all the parameters, which are then passed\n    to ``normalize_parameters`` to produce one of the components that make up\n    the *signature base string*.\n\n    Parameters starting with `oauth_` will be unescaped.\n\n    Body parameters must be supplied as a dict, a list of 2-tuples, or a\n    form encoded query string.\n\n    Headers must be supplied as a dict.\n\n    The rules where the parameters must be sourced from are defined in\n    `section 3.4.1.3.1`_ of RFC 5849.\n\n    .. _`Sec 3.4.1.3.1`: https://tools.ietf.org/html/rfc5849#section-3.4.1.3.1\n    \"\"\"\n    if body is None:\n        body = []\n    headers = headers or {}\n    params = []\n\n    # The parameters from the following sources are collected into a single\n    # list of name/value pairs:\n\n    # *  The query component of the HTTP request URI as defined by\n    #    `RFC3986, Section 3.4`_.  The query component is parsed into a list\n    #    of name/value pairs by treating it as an\n    #    \"application/x-www-form-urlencoded\" string, separating the names\n    #    and values and decoding them as defined by W3C.REC-html40-19980424\n    #    `W3C-HTML-4.0`_, Section 17.13.4.\n    #\n    # .. _`RFC3986, Sec 3.4`: https://tools.ietf.org/html/rfc3986#section-3.4\n    # .. _`W3C-HTML-4.0`: https://www.w3.org/TR/1998/REC-html40-19980424/\n    if uri_query:\n        params.extend(urldecode(uri_query))\n\n    # *  The OAuth HTTP \"Authorization\" header field (`Section 3.5.1`_) if\n    #    present.  The header's content is parsed into a list of name/value\n    #    pairs excluding the \"realm\" parameter if present.  The parameter\n    #    values are decoded as defined by `Section 3.5.1`_.\n    #\n    # .. _`Section 3.5.1`: https://tools.ietf.org/html/rfc5849#section-3.5.1\n    if headers:\n        headers_lower = {k.lower(): v for k, v in headers.items()}\n        authorization_header = headers_lower.get('authorization')\n        if authorization_header is not None:\n            params.extend([i for i in utils.parse_authorization_header(\n                authorization_header) if with_realm or i[0] != 'realm'])\n\n    # *  The HTTP request entity-body, but only if all of the following\n    #    conditions are met:\n    #     *  The entity-body is single-part.\n    #\n    #     *  The entity-body follows the encoding requirements of the\n    #        \"application/x-www-form-urlencoded\" content-type as defined by\n    #        W3C.REC-html40-19980424 `W3C-HTML-4.0`_.\n\n    #     *  The HTTP request entity-header includes the \"Content-Type\"\n    #        header field set to \"application/x-www-form-urlencoded\".\n    #\n    # .. _`W3C-HTML-4.0`: https://www.w3.org/TR/1998/REC-html40-19980424/\n\n    # TODO: enforce header param inclusion conditions\n    bodyparams = extract_params(body) or []\n    params.extend(bodyparams)\n\n    # ensure all oauth params are unescaped\n    unescaped_params = []\n    for k, v in params:\n        if k.startswith('oauth_'):\n            v = utils.unescape(v)\n        unescaped_params.append((k, v))\n\n    # The \"oauth_signature\" parameter MUST be excluded from the signature\n    # base string if present.\n    if exclude_oauth_signature:\n        unescaped_params = list(filter(lambda i: i[0] != 'oauth_signature',\n                                       unescaped_params))\n\n    return unescaped_params\n\n\ndef normalize_parameters(params) -> str:\n    \"\"\"\n    Calculate the normalized request parameters.\n\n    The *normalized request parameters* is one of the components that make up\n    the *signature base string*.\n\n    The rules for parameter normalization are defined in `section 3.4.1.3.2`_ of\n    RFC 5849.\n\n    .. _`Sec 3.4.1.3.2`: https://tools.ietf.org/html/rfc5849#section-3.4.1.3.2\n    \"\"\"\n\n    # The parameters collected in `Section 3.4.1.3`_ are normalized into a\n    # single string as follows:\n    #\n    # .. _`Section 3.4.1.3`: https://tools.ietf.org/html/rfc5849#section-3.4.1.3\n\n    # 1.  First, the name and value of each parameter are encoded\n    #     (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    key_values = [(utils.escape(k), utils.escape(v)) for k, v in params]\n\n    # 2.  The parameters are sorted by name, using ascending byte value\n    #     ordering.  If two or more parameters share the same name, they\n    #     are sorted by their value.\n    key_values.sort()\n\n    # 3.  The name of each parameter is concatenated to its corresponding\n    #     value using an \"=\" character (ASCII code 61) as a separator, even\n    #     if the value is empty.\n    parameter_parts = ['{}={}'.format(k, v) for k, v in key_values]\n\n    # 4.  The sorted name/value pairs are concatenated together into a\n    #     single string by using an \"&\" character (ASCII code 38) as\n    #     separator.\n    return '&'.join(parameter_parts)\n\n\n# ==== Common functions for HMAC-based signature methods =========\n\ndef _sign_hmac(hash_algorithm_name: str,\n               sig_base_str: str,\n               client_secret: str,\n               resource_owner_secret: str):\n    \"\"\"\n    **HMAC-SHA256**\n\n    The \"HMAC-SHA256\" signature method uses the HMAC-SHA256 signature\n    algorithm as defined in `RFC4634`_::\n\n        digest = HMAC-SHA256 (key, text)\n\n    Per `section 3.4.2`_ of the spec.\n\n    .. _`RFC4634`: https://tools.ietf.org/html/rfc4634\n    .. _`section 3.4.2`: https://tools.ietf.org/html/rfc5849#section-3.4.2\n    \"\"\"\n\n    # The HMAC-SHA256 function variables are used in following way:\n\n    # text is set to the value of the signature base string from\n    # `Section 3.4.1.1`_.\n    #\n    # .. _`Section 3.4.1.1`: https://tools.ietf.org/html/rfc5849#section-3.4.1.1\n    text = sig_base_str\n\n    # key is set to the concatenated values of:\n    # 1.  The client shared-secret, after being encoded (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    key = utils.escape(client_secret or '')\n\n    # 2.  An \"&\" character (ASCII code 38), which MUST be included\n    #     even when either secret is empty.\n    key += '&'\n\n    # 3.  The token shared-secret, after being encoded (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    key += utils.escape(resource_owner_secret or '')\n\n    # Get the hashing algorithm to use\n\n    m = {\n        'SHA-1': hashlib.sha1,\n        'SHA-256': hashlib.sha256,\n        'SHA-512': hashlib.sha512,\n    }\n    hash_alg = m[hash_algorithm_name]\n\n    # Calculate the signature\n\n    # FIXME: HMAC does not support unicode!\n    key_utf8 = key.encode('utf-8')\n    text_utf8 = text.encode('utf-8')\n    signature = hmac.new(key_utf8, text_utf8, hash_alg)\n\n    # digest  is used to set the value of the \"oauth_signature\" protocol\n    #         parameter, after the result octet string is base64-encoded\n    #         per `RFC2045, Section 6.8`.\n    #\n    # .. _`RFC2045, Sec 6.8`: https://tools.ietf.org/html/rfc2045#section-6.8\n    return binascii.b2a_base64(signature.digest())[:-1].decode('utf-8')\n\n\ndef _verify_hmac(hash_algorithm_name: str,\n                 request,\n                 client_secret=None,\n                 resource_owner_secret=None):\n    \"\"\"Verify a HMAC-SHA1 signature.\n\n    Per `section 3.4`_ of the spec.\n\n    .. _`section 3.4`: https://tools.ietf.org/html/rfc5849#section-3.4\n\n    To satisfy `RFC2616 section 5.2`_ item 1, the request argument's uri\n    attribute MUST be an absolute URI whose netloc part identifies the\n    origin server or gateway on which the resource resides. Any Host\n    item of the request argument's headers dict attribute will be\n    ignored.\n\n    .. _`RFC2616 section 5.2`: https://tools.ietf.org/html/rfc2616#section-5.2\n\n    \"\"\"\n    norm_params = normalize_parameters(request.params)\n    bs_uri = base_string_uri(request.uri)\n    sig_base_str = signature_base_string(request.http_method, bs_uri,\n                                         norm_params)\n    signature = _sign_hmac(hash_algorithm_name, sig_base_str,\n                           client_secret, resource_owner_secret)\n    match = safe_string_equals(signature, request.signature)\n    if not match:\n        log.debug('Verify HMAC failed: signature base string: %s', sig_base_str)\n    return match\n\n\n# ==== HMAC-SHA1 =================================================\n\ndef sign_hmac_sha1_with_client(sig_base_str, client):\n    return _sign_hmac('SHA-1', sig_base_str,\n                      client.client_secret, client.resource_owner_secret)\n\n\ndef verify_hmac_sha1(request, client_secret=None, resource_owner_secret=None):\n    return _verify_hmac('SHA-1', request, client_secret, resource_owner_secret)\n\n\ndef sign_hmac_sha1(base_string, client_secret, resource_owner_secret):\n    \"\"\"\n    Deprecated function for calculating a HMAC-SHA1 signature.\n\n    This function has been replaced by invoking ``sign_hmac`` with \"SHA-1\"\n    as the hash algorithm name.\n\n    This function was invoked by sign_hmac_sha1_with_client and\n    test_signatures.py, but does any application invoke it directly? If not,\n    it can be removed.\n    \"\"\"\n    warnings.warn('use sign_hmac_sha1_with_client instead of sign_hmac_sha1',\n                  DeprecationWarning)\n\n    # For some unknown reason, the original implementation assumed base_string\n    # could either be bytes or str. The signature base string calculating\n    # function always returned a str, so the new ``sign_rsa`` only expects that.\n\n    base_string = base_string.decode('ascii') \\\n        if isinstance(base_string, bytes) else base_string\n\n    return _sign_hmac('SHA-1', base_string,\n                      client_secret, resource_owner_secret)\n\n\n# ==== HMAC-SHA256 ===============================================\n\ndef sign_hmac_sha256_with_client(sig_base_str, client):\n    return _sign_hmac('SHA-256', sig_base_str,\n                      client.client_secret, client.resource_owner_secret)\n\n\ndef verify_hmac_sha256(request, client_secret=None, resource_owner_secret=None):\n    return _verify_hmac('SHA-256', request,\n                        client_secret, resource_owner_secret)\n\n\ndef sign_hmac_sha256(base_string, client_secret, resource_owner_secret):\n    \"\"\"\n    Deprecated function for calculating a HMAC-SHA256 signature.\n\n    This function has been replaced by invoking ``sign_hmac`` with \"SHA-256\"\n    as the hash algorithm name.\n\n    This function was invoked by sign_hmac_sha256_with_client and\n    test_signatures.py, but does any application invoke it directly? If not,\n    it can be removed.\n    \"\"\"\n    warnings.warn(\n        'use sign_hmac_sha256_with_client instead of sign_hmac_sha256',\n        DeprecationWarning)\n\n    # For some unknown reason, the original implementation assumed base_string\n    # could either be bytes or str. The signature base string calculating\n    # function always returned a str, so the new ``sign_rsa`` only expects that.\n\n    base_string = base_string.decode('ascii') \\\n        if isinstance(base_string, bytes) else base_string\n\n    return _sign_hmac('SHA-256', base_string,\n                      client_secret, resource_owner_secret)\n\n\n# ==== HMAC-SHA512 ===============================================\n\ndef sign_hmac_sha512_with_client(sig_base_str: str,\n                                 client):\n    return _sign_hmac('SHA-512', sig_base_str,\n                      client.client_secret, client.resource_owner_secret)\n\n\ndef verify_hmac_sha512(request,\n                       client_secret: str = None,\n                       resource_owner_secret: str = None):\n    return _verify_hmac('SHA-512', request,\n                        client_secret, resource_owner_secret)\n\n\n# ==== Common functions for RSA-based signature methods ==========\n\n_jwt_rsa = {}  # cache of RSA-hash implementations from PyJWT jwt.algorithms\n\n\ndef _get_jwt_rsa_algorithm(hash_algorithm_name: str):\n    \"\"\"\n    Obtains an RSAAlgorithm object that implements RSA with the hash algorithm.\n\n    This method maintains the ``_jwt_rsa`` cache.\n\n    Returns a jwt.algorithm.RSAAlgorithm.\n    \"\"\"\n    if hash_algorithm_name in _jwt_rsa:\n        # Found in cache: return it\n        return _jwt_rsa[hash_algorithm_name]\n    else:\n        # Not in cache: instantiate a new RSAAlgorithm\n\n        # PyJWT has some nice pycrypto/cryptography abstractions\n        import jwt.algorithms as jwt_algorithms\n        m = {\n            'SHA-1': jwt_algorithms.hashes.SHA1,\n            'SHA-256': jwt_algorithms.hashes.SHA256,\n            'SHA-512': jwt_algorithms.hashes.SHA512,\n        }\n        v = jwt_algorithms.RSAAlgorithm(m[hash_algorithm_name])\n\n        _jwt_rsa[hash_algorithm_name] = v  # populate cache\n\n        return v\n\n\ndef _prepare_key_plus(alg, keystr):\n    \"\"\"\n    Prepare a PEM encoded key (public or private), by invoking the `prepare_key`\n    method on alg with the keystr.\n\n    The keystr should be a string or bytes.  If the keystr is bytes, it is\n    decoded as UTF-8 before being passed to prepare_key. Otherwise, it\n    is passed directly.\n    \"\"\"\n    if isinstance(keystr, bytes):\n        keystr = keystr.decode('utf-8')\n    return alg.prepare_key(keystr)\n\n\ndef _sign_rsa(hash_algorithm_name: str,\n              sig_base_str: str,\n              rsa_private_key: str):\n    \"\"\"\n    Calculate the signature for an RSA-based signature method.\n\n    The ``alg`` is used to calculate the digest over the signature base string.\n    For the \"RSA_SHA1\" signature method, the alg must be SHA-1. While OAuth 1.0a\n    only defines the RSA-SHA1 signature method, this function can be used for\n    other non-standard signature methods that only differ from RSA-SHA1 by the\n    digest algorithm.\n\n    Signing for the RSA-SHA1 signature method is defined in\n    `section 3.4.3`_ of RFC 5849.\n\n    The RSASSA-PKCS1-v1_5 signature algorithm used defined by\n    `RFC3447, Section 8.2`_ (also known as PKCS#1), with the `alg` as the\n    hash function for EMSA-PKCS1-v1_5.  To\n    use this method, the client MUST have established client credentials\n    with the server that included its RSA public key (in a manner that is\n    beyond the scope of this specification).\n\n    .. _`section 3.4.3`: https://tools.ietf.org/html/rfc5849#section-3.4.3\n    .. _`RFC3447, Section 8.2`: https://tools.ietf.org/html/rfc3447#section-8.2\n    \"\"\"\n\n    # Get the implementation of RSA-hash\n\n    alg = _get_jwt_rsa_algorithm(hash_algorithm_name)\n\n    # Check private key\n\n    if not rsa_private_key:\n        raise ValueError('rsa_private_key required for RSA with ' +\n                         alg.hash_alg.name + ' signature method')\n\n    # Convert the \"signature base string\" into a sequence of bytes (M)\n    #\n    # The signature base string, by definition, only contain printable US-ASCII\n    # characters. So encoding it as 'ascii' will always work. It will raise a\n    # ``UnicodeError`` if it can't encode the value, which will never happen\n    # if the signature base string was created correctly. Therefore, using\n    # 'ascii' encoding provides an extra level of error checking.\n\n    m = sig_base_str.encode('ascii')\n\n    # Perform signing: S = RSASSA-PKCS1-V1_5-SIGN (K, M)\n\n    key = _prepare_key_plus(alg, rsa_private_key)\n    s = alg.sign(m, key)\n\n    # base64-encoded per RFC2045 section 6.8.\n    #\n    # 1. While b2a_base64 implements base64 defined by RFC 3548. As used here,\n    #    it is the same as base64 defined by RFC 2045.\n    # 2. b2a_base64 includes a \"\\n\" at the end of its result ([:-1] removes it)\n    # 3. b2a_base64 produces a binary string. Use decode to produce a str.\n    #    It should only contain only printable US-ASCII characters.\n\n    return binascii.b2a_base64(s)[:-1].decode('ascii')\n\n\ndef _verify_rsa(hash_algorithm_name: str,\n                request,\n                rsa_public_key: str):\n    \"\"\"\n    Verify a base64 encoded signature for a RSA-based signature method.\n\n    The ``alg`` is used to calculate the digest over the signature base string.\n    For the \"RSA_SHA1\" signature method, the alg must be SHA-1. While OAuth 1.0a\n    only defines the RSA-SHA1 signature method, this function can be used for\n    other non-standard signature methods that only differ from RSA-SHA1 by the\n    digest algorithm.\n\n    Verification for the RSA-SHA1 signature method is defined in\n    `section 3.4.3`_ of RFC 5849.\n\n    .. _`section 3.4.3`: https://tools.ietf.org/html/rfc5849#section-3.4.3\n\n        To satisfy `RFC2616 section 5.2`_ item 1, the request argument's uri\n        attribute MUST be an absolute URI whose netloc part identifies the\n        origin server or gateway on which the resource resides. Any Host\n        item of the request argument's headers dict attribute will be\n        ignored.\n\n        .. _`RFC2616 Sec 5.2`: https://tools.ietf.org/html/rfc2616#section-5.2\n    \"\"\"\n\n    try:\n        # Calculate the *signature base string* of the actual received request\n\n        norm_params = normalize_parameters(request.params)\n        bs_uri = base_string_uri(request.uri)\n        sig_base_str = signature_base_string(\n            request.http_method, bs_uri, norm_params)\n\n        # Obtain the signature that was received in the request\n\n        sig = binascii.a2b_base64(request.signature.encode('ascii'))\n\n        # Get the implementation of RSA-with-hash algorithm to use\n\n        alg = _get_jwt_rsa_algorithm(hash_algorithm_name)\n\n        # Verify the received signature was produced by the private key\n        # corresponding to the `rsa_public_key`, signing exact same\n        # *signature base string*.\n        #\n        #     RSASSA-PKCS1-V1_5-VERIFY ((n, e), M, S)\n\n        key = _prepare_key_plus(alg, rsa_public_key)\n\n        # The signature base string only contain printable US-ASCII characters.\n        # The ``encode`` method with the default \"strict\" error handling will\n        # raise a ``UnicodeError`` if it can't encode the value. So using\n        # \"ascii\" will always work.\n\n        verify_ok = alg.verify(sig_base_str.encode('ascii'), key, sig)\n\n        if not verify_ok:\n            log.debug('Verify failed: RSA with ' + alg.hash_alg.name +\n                      ': signature base string=%s' + sig_base_str)\n        return verify_ok\n\n    except UnicodeError:\n        # A properly encoded signature will only contain printable US-ASCII\n        # characters. The ``encode`` method with the default \"strict\" error\n        # handling will raise a ``UnicodeError`` if it can't decode the value.\n        # So using \"ascii\" will work with all valid signatures. But an\n        # incorrectly or maliciously produced signature could contain other\n        # bytes.\n        #\n        # This implementation treats that situation as equivalent to the\n        # signature verification having failed.\n        #\n        # Note: simply changing the encode to use 'utf-8' will not remove this\n        # case, since an incorrect or malicious request can contain bytes which\n        # are invalid as UTF-8.\n        return False\n\n\n# ==== RSA-SHA1 ==================================================\n\ndef sign_rsa_sha1_with_client(sig_base_str, client):\n    # For some reason, this function originally accepts both str and bytes.\n    # This behaviour is preserved here. But won't be done for the newer\n    # sign_rsa_sha256_with_client and sign_rsa_sha512_with_client functions,\n    # which will only accept strings. The function to calculate a\n    # \"signature base string\" always produces a string, so it is not clear\n    # why support for bytes would ever be needed.\n    sig_base_str = sig_base_str.decode('ascii')\\\n        if isinstance(sig_base_str, bytes) else sig_base_str\n\n    return _sign_rsa('SHA-1', sig_base_str, client.rsa_key)\n\n\ndef verify_rsa_sha1(request, rsa_public_key: str):\n    return _verify_rsa('SHA-1', request, rsa_public_key)\n\n\ndef sign_rsa_sha1(base_string, rsa_private_key):\n    \"\"\"\n    Deprecated function for calculating a RSA-SHA1 signature.\n\n    This function has been replaced by invoking ``sign_rsa`` with \"SHA-1\"\n    as the hash algorithm name.\n\n    This function was invoked by sign_rsa_sha1_with_client and\n    test_signatures.py, but does any application invoke it directly? If not,\n    it can be removed.\n    \"\"\"\n    warnings.warn('use _sign_rsa(\"SHA-1\", ...) instead of sign_rsa_sha1',\n                  DeprecationWarning)\n\n    if isinstance(base_string, bytes):\n        base_string = base_string.decode('ascii')\n\n    return _sign_rsa('SHA-1', base_string, rsa_private_key)\n\n\n# ==== RSA-SHA256 ================================================\n\ndef sign_rsa_sha256_with_client(sig_base_str: str, client):\n    return _sign_rsa('SHA-256', sig_base_str, client.rsa_key)\n\n\ndef verify_rsa_sha256(request, rsa_public_key: str):\n    return _verify_rsa('SHA-256', request, rsa_public_key)\n\n\n# ==== RSA-SHA512 ================================================\n\ndef sign_rsa_sha512_with_client(sig_base_str: str, client):\n    return _sign_rsa('SHA-512', sig_base_str, client.rsa_key)\n\n\ndef verify_rsa_sha512(request, rsa_public_key: str):\n    return _verify_rsa('SHA-512', request, rsa_public_key)\n\n\n# ==== PLAINTEXT =================================================\n\ndef sign_plaintext_with_client(_signature_base_string, client):\n    # _signature_base_string is not used because the signature with PLAINTEXT\n    # is just the secret: it isn't a real signature.\n    return sign_plaintext(client.client_secret, client.resource_owner_secret)\n\n\ndef sign_plaintext(client_secret, resource_owner_secret):\n    \"\"\"Sign a request using plaintext.\n\n    Per `section 3.4.4`_ of the spec.\n\n    The \"PLAINTEXT\" method does not employ a signature algorithm.  It\n    MUST be used with a transport-layer mechanism such as TLS or SSL (or\n    sent over a secure channel with equivalent protections).  It does not\n    utilize the signature base string or the \"oauth_timestamp\" and\n    \"oauth_nonce\" parameters.\n\n    .. _`section 3.4.4`: https://tools.ietf.org/html/rfc5849#section-3.4.4\n\n    \"\"\"\n\n    # The \"oauth_signature\" protocol parameter is set to the concatenated\n    # value of:\n\n    # 1.  The client shared-secret, after being encoded (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    signature = utils.escape(client_secret or '')\n\n    # 2.  An \"&\" character (ASCII code 38), which MUST be included even\n    #     when either secret is empty.\n    signature += '&'\n\n    # 3.  The token shared-secret, after being encoded (`Section 3.6`_).\n    #\n    # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n    signature += utils.escape(resource_owner_secret or '')\n\n    return signature\n\n\ndef verify_plaintext(request, client_secret=None, resource_owner_secret=None):\n    \"\"\"Verify a PLAINTEXT signature.\n\n    Per `section 3.4`_ of the spec.\n\n    .. _`section 3.4`: https://tools.ietf.org/html/rfc5849#section-3.4\n    \"\"\"\n    signature = sign_plaintext(client_secret, resource_owner_secret)\n    match = safe_string_equals(signature, request.signature)\n    if not match:\n        log.debug('Verify PLAINTEXT failed')\n    return match\n", "oauthlib/oauth1/rfc5849/utils.py": "\"\"\"\noauthlib.utils\n~~~~~~~~~~~~~~\n\nThis module contains utility methods used by various parts of the OAuth\nspec.\n\"\"\"\nimport urllib.request as urllib2\n\nfrom oauthlib.common import quote, unquote\n\nUNICODE_ASCII_CHARACTER_SET = ('abcdefghijklmnopqrstuvwxyz'\n                               'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n                               '0123456789')\n\n\ndef filter_params(target):\n    \"\"\"Decorator which filters params to remove non-oauth_* parameters\n\n    Assumes the decorated method takes a params dict or list of tuples as its\n    first argument.\n    \"\"\"\n    def wrapper(params, *args, **kwargs):\n        params = filter_oauth_params(params)\n        return target(params, *args, **kwargs)\n\n    wrapper.__doc__ = target.__doc__\n    return wrapper\n\n\ndef filter_oauth_params(params):\n    \"\"\"Removes all non oauth parameters from a dict or a list of params.\"\"\"\n    def is_oauth(kv):\n        return kv[0].startswith('oauth_')\n    if isinstance(params, dict):\n        return list(filter(is_oauth, list(params.items())))\n    else:\n        return list(filter(is_oauth, params))\n\n\ndef escape(u):\n    \"\"\"Escape a unicode string in an OAuth-compatible fashion.\n\n    Per `section 3.6`_ of the spec.\n\n    .. _`section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n\n    \"\"\"\n    if not isinstance(u, str):\n        raise ValueError('Only unicode objects are escapable. ' +\n                         'Got {!r} of type {}.'.format(u, type(u)))\n    # Letters, digits, and the characters '_.-' are already treated as safe\n    # by urllib.quote(). We need to add '~' to fully support rfc5849.\n    return quote(u, safe=b'~')\n\n\ndef unescape(u):\n    if not isinstance(u, str):\n        raise ValueError('Only unicode objects are unescapable.')\n    return unquote(u)\n\n\ndef parse_keqv_list(l):  # noqa: E741\n    \"\"\"A unicode-safe version of urllib2.parse_keqv_list\"\"\"\n    # With Python 2.6, parse_http_list handles unicode fine\n    return urllib2.parse_keqv_list(l)\n\n\ndef parse_http_list(u):\n    \"\"\"A unicode-safe version of urllib2.parse_http_list\"\"\"\n    # With Python 2.6, parse_http_list handles unicode fine\n    return urllib2.parse_http_list(u)\n\n\ndef parse_authorization_header(authorization_header):\n    \"\"\"Parse an OAuth authorization header into a list of 2-tuples\"\"\"\n    auth_scheme = 'OAuth '.lower()\n    if authorization_header[:len(auth_scheme)].lower().startswith(auth_scheme):\n        items = parse_http_list(authorization_header[len(auth_scheme):])\n        try:\n            return list(parse_keqv_list(items).items())\n        except (IndexError, ValueError):\n            pass\n    raise ValueError('Malformed authorization header')\n", "oauthlib/oauth1/rfc5849/errors.py": "\"\"\"\noauthlib.oauth1.rfc5849.errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nError used both by OAuth 1 clients and provicers to represent the spec\ndefined error responses for all four core grant types.\n\"\"\"\nfrom oauthlib.common import add_params_to_uri, urlencode\n\n\nclass OAuth1Error(Exception):\n    error = None\n    description = ''\n\n    def __init__(self, description=None, uri=None, status_code=400,\n                 request=None):\n        \"\"\"\n        description:    A human-readable ASCII [USASCII] text providing\n                        additional information, used to assist the client\n                        developer in understanding the error that occurred.\n                        Values for the \"error_description\" parameter MUST NOT\n                        include characters outside the set\n                        x20-21 / x23-5B / x5D-7E.\n\n        uri:    A URI identifying a human-readable web page with information\n                about the error, used to provide the client developer with\n                additional information about the error.  Values for the\n                \"error_uri\" parameter MUST conform to the URI- Reference\n                syntax, and thus MUST NOT include characters outside the set\n                x21 / x23-5B / x5D-7E.\n\n        state:  A CSRF protection value received from the client.\n\n        request:  Oauthlib Request object\n        \"\"\"\n        self.description = description or self.description\n        message = '({}) {}'.format(self.error, self.description)\n        if request:\n            message += ' ' + repr(request)\n        super().__init__(message)\n\n        self.uri = uri\n        self.status_code = status_code\n\n    def in_uri(self, uri):\n        return add_params_to_uri(uri, self.twotuples)\n\n    @property\n    def twotuples(self):\n        error = [('error', self.error)]\n        if self.description:\n            error.append(('error_description', self.description))\n        if self.uri:\n            error.append(('error_uri', self.uri))\n        return error\n\n    @property\n    def urlencoded(self):\n        return urlencode(self.twotuples)\n\n\nclass InsecureTransportError(OAuth1Error):\n    error = 'insecure_transport_protocol'\n    description = 'Only HTTPS connections are permitted.'\n\n\nclass InvalidSignatureMethodError(OAuth1Error):\n    error = 'invalid_signature_method'\n\n\nclass InvalidRequestError(OAuth1Error):\n    error = 'invalid_request'\n\n\nclass InvalidClientError(OAuth1Error):\n    error = 'invalid_client'\n", "oauthlib/oauth1/rfc5849/parameters.py": "\"\"\"\noauthlib.parameters\n~~~~~~~~~~~~~~~~~~~\n\nThis module contains methods related to `section 3.5`_ of the OAuth 1.0a spec.\n\n.. _`section 3.5`: https://tools.ietf.org/html/rfc5849#section-3.5\n\"\"\"\nfrom urllib.parse import urlparse, urlunparse\n\nfrom oauthlib.common import extract_params, urlencode\n\nfrom . import utils\n\n\n# TODO: do we need filter_params now that oauth_params are handled by Request?\n#       We can easily pass in just oauth protocol params.\n@utils.filter_params\ndef prepare_headers(oauth_params, headers=None, realm=None):\n    \"\"\"**Prepare the Authorization header.**\n    Per `section 3.5.1`_ of the spec.\n\n    Protocol parameters can be transmitted using the HTTP \"Authorization\"\n    header field as defined by `RFC2617`_ with the auth-scheme name set to\n    \"OAuth\" (case insensitive).\n\n    For example::\n\n        Authorization: OAuth realm=\"Example\",\n            oauth_consumer_key=\"0685bd9184jfhq22\",\n            oauth_token=\"ad180jjd733klru7\",\n            oauth_signature_method=\"HMAC-SHA1\",\n            oauth_signature=\"wOJIO9A2W5mFwDgiDvZbTSMK%2FPY%3D\",\n            oauth_timestamp=\"137131200\",\n            oauth_nonce=\"4572616e48616d6d65724c61686176\",\n            oauth_version=\"1.0\"\n\n\n    .. _`section 3.5.1`: https://tools.ietf.org/html/rfc5849#section-3.5.1\n    .. _`RFC2617`: https://tools.ietf.org/html/rfc2617\n    \"\"\"\n    headers = headers or {}\n\n    # Protocol parameters SHALL be included in the \"Authorization\" header\n    # field as follows:\n    authorization_header_parameters_parts = []\n    for oauth_parameter_name, value in oauth_params:\n        # 1.  Parameter names and values are encoded per Parameter Encoding\n        #     (`Section 3.6`_)\n        #\n        # .. _`Section 3.6`: https://tools.ietf.org/html/rfc5849#section-3.6\n        escaped_name = utils.escape(oauth_parameter_name)\n        escaped_value = utils.escape(value)\n\n        # 2.  Each parameter's name is immediately followed by an \"=\" character\n        #     (ASCII code 61), a \"\"\" character (ASCII code 34), the parameter\n        #     value (MAY be empty), and another \"\"\" character (ASCII code 34).\n        part = '{}=\"{}\"'.format(escaped_name, escaped_value)\n\n        authorization_header_parameters_parts.append(part)\n\n    # 3.  Parameters are separated by a \",\" character (ASCII code 44) and\n    #     OPTIONAL linear whitespace per `RFC2617`_.\n    #\n    # .. _`RFC2617`: https://tools.ietf.org/html/rfc2617\n    authorization_header_parameters = ', '.join(\n        authorization_header_parameters_parts)\n\n    # 4.  The OPTIONAL \"realm\" parameter MAY be added and interpreted per\n    #     `RFC2617 section 1.2`_.\n    #\n    # .. _`RFC2617 section 1.2`: https://tools.ietf.org/html/rfc2617#section-1.2\n    if realm:\n        # NOTE: realm should *not* be escaped\n        authorization_header_parameters = ('realm=\"%s\", ' % realm +\n                                           authorization_header_parameters)\n\n    # the auth-scheme name set to \"OAuth\" (case insensitive).\n    authorization_header = 'OAuth %s' % authorization_header_parameters\n\n    # contribute the Authorization header to the given headers\n    full_headers = {}\n    full_headers.update(headers)\n    full_headers['Authorization'] = authorization_header\n    return full_headers\n\n\ndef _append_params(oauth_params, params):\n    \"\"\"Append OAuth params to an existing set of parameters.\n\n    Both params and oauth_params is must be lists of 2-tuples.\n\n    Per `section 3.5.2`_ and `3.5.3`_ of the spec.\n\n    .. _`section 3.5.2`: https://tools.ietf.org/html/rfc5849#section-3.5.2\n    .. _`3.5.3`: https://tools.ietf.org/html/rfc5849#section-3.5.3\n\n    \"\"\"\n    merged = list(params)\n    merged.extend(oauth_params)\n    # The request URI / entity-body MAY include other request-specific\n    # parameters, in which case, the protocol parameters SHOULD be appended\n    # following the request-specific parameters, properly separated by an \"&\"\n    # character (ASCII code 38)\n    merged.sort(key=lambda i: i[0].startswith('oauth_'))\n    return merged\n\n\ndef prepare_form_encoded_body(oauth_params, body):\n    \"\"\"Prepare the Form-Encoded Body.\n\n    Per `section 3.5.2`_ of the spec.\n\n    .. _`section 3.5.2`: https://tools.ietf.org/html/rfc5849#section-3.5.2\n\n    \"\"\"\n    # append OAuth params to the existing body\n    return _append_params(oauth_params, body)\n\n\ndef prepare_request_uri_query(oauth_params, uri):\n    \"\"\"Prepare the Request URI Query.\n\n    Per `section 3.5.3`_ of the spec.\n\n    .. _`section 3.5.3`: https://tools.ietf.org/html/rfc5849#section-3.5.3\n\n    \"\"\"\n    # append OAuth params to the existing set of query components\n    sch, net, path, par, query, fra = urlparse(uri)\n    query = urlencode(\n        _append_params(oauth_params, extract_params(query) or []))\n    return urlunparse((sch, net, path, par, query, fra))\n", "oauthlib/oauth1/rfc5849/__init__.py": "\"\"\"\noauthlib.oauth1.rfc5849\n~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor signing and checking OAuth 1.0 RFC 5849 requests.\n\nIt supports all three standard signature methods defined in RFC 5849:\n\n- HMAC-SHA1\n- RSA-SHA1\n- PLAINTEXT\n\nIt also supports signature methods that are not defined in RFC 5849. These are\nbased on the standard ones but replace SHA-1 with the more secure SHA-256:\n\n- HMAC-SHA256\n- RSA-SHA256\n\n\"\"\"\nimport base64\nimport hashlib\nimport logging\nimport urllib.parse as urlparse\n\nfrom oauthlib.common import (\n    Request, generate_nonce, generate_timestamp, to_unicode, urlencode,\n)\n\nfrom . import parameters, signature\n\nlog = logging.getLogger(__name__)\n\n# Available signature methods\n#\n# Note: SIGNATURE_HMAC and SIGNATURE_RSA are kept for backward compatibility\n# with previous versions of this library, when it the only HMAC-based and\n# RSA-based signature methods were HMAC-SHA1 and RSA-SHA1. But now that it\n# supports other hashing algorithms besides SHA1, explicitly identifying which\n# hashing algorithm is being used is recommended.\n#\n# Note: if additional values are defined here, don't forget to update the\n# imports in \"../__init__.py\" so they are available outside this module.\n\nSIGNATURE_HMAC_SHA1 = \"HMAC-SHA1\"\nSIGNATURE_HMAC_SHA256 = \"HMAC-SHA256\"\nSIGNATURE_HMAC_SHA512 = \"HMAC-SHA512\"\nSIGNATURE_HMAC = SIGNATURE_HMAC_SHA1  # deprecated variable for HMAC-SHA1\n\nSIGNATURE_RSA_SHA1 = \"RSA-SHA1\"\nSIGNATURE_RSA_SHA256 = \"RSA-SHA256\"\nSIGNATURE_RSA_SHA512 = \"RSA-SHA512\"\nSIGNATURE_RSA = SIGNATURE_RSA_SHA1  # deprecated variable for RSA-SHA1\n\nSIGNATURE_PLAINTEXT = \"PLAINTEXT\"\n\nSIGNATURE_METHODS = (\n    SIGNATURE_HMAC_SHA1,\n    SIGNATURE_HMAC_SHA256,\n    SIGNATURE_HMAC_SHA512,\n    SIGNATURE_RSA_SHA1,\n    SIGNATURE_RSA_SHA256,\n    SIGNATURE_RSA_SHA512,\n    SIGNATURE_PLAINTEXT\n)\n\nSIGNATURE_TYPE_AUTH_HEADER = 'AUTH_HEADER'\nSIGNATURE_TYPE_QUERY = 'QUERY'\nSIGNATURE_TYPE_BODY = 'BODY'\n\nCONTENT_TYPE_FORM_URLENCODED = 'application/x-www-form-urlencoded'\n\n\nclass Client:\n\n    \"\"\"A client used to sign OAuth 1.0 RFC 5849 requests.\"\"\"\n    SIGNATURE_METHODS = {\n        SIGNATURE_HMAC_SHA1: signature.sign_hmac_sha1_with_client,\n        SIGNATURE_HMAC_SHA256: signature.sign_hmac_sha256_with_client,\n        SIGNATURE_HMAC_SHA512: signature.sign_hmac_sha512_with_client,\n        SIGNATURE_RSA_SHA1: signature.sign_rsa_sha1_with_client,\n        SIGNATURE_RSA_SHA256: signature.sign_rsa_sha256_with_client,\n        SIGNATURE_RSA_SHA512: signature.sign_rsa_sha512_with_client,\n        SIGNATURE_PLAINTEXT: signature.sign_plaintext_with_client\n    }\n\n    @classmethod\n    def register_signature_method(cls, method_name, method_callback):\n        cls.SIGNATURE_METHODS[method_name] = method_callback\n\n    def __init__(self, client_key,\n                 client_secret=None,\n                 resource_owner_key=None,\n                 resource_owner_secret=None,\n                 callback_uri=None,\n                 signature_method=SIGNATURE_HMAC_SHA1,\n                 signature_type=SIGNATURE_TYPE_AUTH_HEADER,\n                 rsa_key=None, verifier=None, realm=None,\n                 encoding='utf-8', decoding=None,\n                 nonce=None, timestamp=None):\n        \"\"\"Create an OAuth 1 client.\n\n        :param client_key: Client key (consumer key), mandatory.\n        :param resource_owner_key: Resource owner key (oauth token).\n        :param resource_owner_secret: Resource owner secret (oauth token secret).\n        :param callback_uri: Callback used when obtaining request token.\n        :param signature_method: SIGNATURE_HMAC, SIGNATURE_RSA or SIGNATURE_PLAINTEXT.\n        :param signature_type: SIGNATURE_TYPE_AUTH_HEADER (default),\n                               SIGNATURE_TYPE_QUERY or SIGNATURE_TYPE_BODY\n                               depending on where you want to embed the oauth\n                               credentials.\n        :param rsa_key: RSA key used with SIGNATURE_RSA.\n        :param verifier: Verifier used when obtaining an access token.\n        :param realm: Realm (scope) to which access is being requested.\n        :param encoding: If you provide non-unicode input you may use this\n                         to have oauthlib automatically convert.\n        :param decoding: If you wish that the returned uri, headers and body\n                         from sign be encoded back from unicode, then set\n                         decoding to your preferred encoding, i.e. utf-8.\n        :param nonce: Use this nonce instead of generating one. (Mainly for testing)\n        :param timestamp: Use this timestamp instead of using current. (Mainly for testing)\n        \"\"\"\n        # Convert to unicode using encoding if given, else assume unicode\n        def encode(x):\n            return to_unicode(x, encoding) if encoding else x\n\n        self.client_key = encode(client_key)\n        self.client_secret = encode(client_secret)\n        self.resource_owner_key = encode(resource_owner_key)\n        self.resource_owner_secret = encode(resource_owner_secret)\n        self.signature_method = encode(signature_method)\n        self.signature_type = encode(signature_type)\n        self.callback_uri = encode(callback_uri)\n        self.rsa_key = encode(rsa_key)\n        self.verifier = encode(verifier)\n        self.realm = encode(realm)\n        self.encoding = encode(encoding)\n        self.decoding = encode(decoding)\n        self.nonce = encode(nonce)\n        self.timestamp = encode(timestamp)\n\n    def __repr__(self):\n        attrs = vars(self).copy()\n        attrs['client_secret'] = '****' if attrs['client_secret'] else None\n        attrs['rsa_key'] = '****' if attrs['rsa_key'] else None\n        attrs[\n            'resource_owner_secret'] = '****' if attrs['resource_owner_secret'] else None\n        attribute_str = ', '.join('{}={}'.format(k, v) for k, v in attrs.items())\n        return '<{} {}>'.format(self.__class__.__name__, attribute_str)\n\n    def get_oauth_signature(self, request):\n        \"\"\"Get an OAuth signature to be used in signing a request\n\n        To satisfy `section 3.4.1.2`_ item 2, if the request argument's\n        headers dict attribute contains a Host item, its value will\n        replace any netloc part of the request argument's uri attribute\n        value.\n\n        .. _`section 3.4.1.2`: https://tools.ietf.org/html/rfc5849#section-3.4.1.2\n        \"\"\"\n        if self.signature_method == SIGNATURE_PLAINTEXT:\n            # fast-path\n            return signature.sign_plaintext(self.client_secret,\n                                            self.resource_owner_secret)\n\n        uri, headers, body = self._render(request)\n\n        collected_params = signature.collect_parameters(\n            uri_query=urlparse.urlparse(uri).query,\n            body=body,\n            headers=headers)\n        log.debug(\"Collected params: {}\".format(collected_params))\n\n        normalized_params = signature.normalize_parameters(collected_params)\n        normalized_uri = signature.base_string_uri(uri, headers.get('Host', None))\n        log.debug(\"Normalized params: {}\".format(normalized_params))\n        log.debug(\"Normalized URI: {}\".format(normalized_uri))\n\n        base_string = signature.signature_base_string(request.http_method,\n                                                      normalized_uri, normalized_params)\n\n        log.debug(\"Signing: signature base string: {}\".format(base_string))\n\n        if self.signature_method not in self.SIGNATURE_METHODS:\n            raise ValueError('Invalid signature method.')\n\n        sig = self.SIGNATURE_METHODS[self.signature_method](base_string, self)\n\n        log.debug(\"Signature: {}\".format(sig))\n        return sig\n\n    def get_oauth_params(self, request):\n        \"\"\"Get the basic OAuth parameters to be used in generating a signature.\n        \"\"\"\n        nonce = (generate_nonce()\n                 if self.nonce is None else self.nonce)\n        timestamp = (generate_timestamp()\n                     if self.timestamp is None else self.timestamp)\n        params = [\n            ('oauth_nonce', nonce),\n            ('oauth_timestamp', timestamp),\n            ('oauth_version', '1.0'),\n            ('oauth_signature_method', self.signature_method),\n            ('oauth_consumer_key', self.client_key),\n        ]\n        if self.resource_owner_key:\n            params.append(('oauth_token', self.resource_owner_key))\n        if self.callback_uri:\n            params.append(('oauth_callback', self.callback_uri))\n        if self.verifier:\n            params.append(('oauth_verifier', self.verifier))\n\n        # providing body hash for requests other than x-www-form-urlencoded\n        # as described in https://tools.ietf.org/html/draft-eaton-oauth-bodyhash-00#section-4.1.1\n        # 4.1.1. When to include the body hash\n        #    *  [...] MUST NOT include an oauth_body_hash parameter on requests with form-encoded request bodies\n        #    *  [...] SHOULD include the oauth_body_hash parameter on all other requests.\n        # Note that SHA-1 is vulnerable. The spec acknowledges that in https://tools.ietf.org/html/draft-eaton-oauth-bodyhash-00#section-6.2\n        # At this time, no further effort has been made to replace SHA-1 for the OAuth Request Body Hash extension.\n        content_type = request.headers.get('Content-Type', None)\n        content_type_eligible = content_type and content_type.find('application/x-www-form-urlencoded') < 0\n        if request.body is not None and content_type_eligible:\n            params.append(('oauth_body_hash', base64.b64encode(hashlib.sha1(request.body.encode('utf-8')).digest()).decode('utf-8')))  # noqa: S324\n\n        return params\n\n    def _render(self, request, formencode=False, realm=None):\n        \"\"\"Render a signed request according to signature type\n\n        Returns a 3-tuple containing the request URI, headers, and body.\n\n        If the formencode argument is True and the body contains parameters, it\n        is escaped and returned as a valid formencoded string.\n        \"\"\"\n        # TODO what if there are body params on a header-type auth?\n        # TODO what if there are query params on a body-type auth?\n\n        uri, headers, body = request.uri, request.headers, request.body\n\n        # TODO: right now these prepare_* methods are very narrow in scope--they\n        # only affect their little thing. In some cases (for example, with\n        # header auth) it might be advantageous to allow these methods to touch\n        # other parts of the request, like the headers\u2014so the prepare_headers\n        # method could also set the Content-Type header to x-www-form-urlencoded\n        # like the spec requires. This would be a fundamental change though, and\n        # I'm not sure how I feel about it.\n        if self.signature_type == SIGNATURE_TYPE_AUTH_HEADER:\n            headers = parameters.prepare_headers(\n                request.oauth_params, request.headers, realm=realm)\n        elif self.signature_type == SIGNATURE_TYPE_BODY and request.decoded_body is not None:\n            body = parameters.prepare_form_encoded_body(\n                request.oauth_params, request.decoded_body)\n            if formencode:\n                body = urlencode(body)\n            headers['Content-Type'] = 'application/x-www-form-urlencoded'\n        elif self.signature_type == SIGNATURE_TYPE_QUERY:\n            uri = parameters.prepare_request_uri_query(\n                request.oauth_params, request.uri)\n        else:\n            raise ValueError('Unknown signature type specified.')\n\n        return uri, headers, body\n\n    def sign(self, uri, http_method='GET', body=None, headers=None, realm=None):\n        \"\"\"Sign a request\n\n        Signs an HTTP request with the specified parts.\n\n        Returns a 3-tuple of the signed request's URI, headers, and body.\n        Note that http_method is not returned as it is unaffected by the OAuth\n        signing process. Also worth noting is that duplicate parameters\n        will be included in the signature, regardless of where they are\n        specified (query, body).\n\n        The body argument may be a dict, a list of 2-tuples, or a formencoded\n        string. The Content-Type header must be 'application/x-www-form-urlencoded'\n        if it is present.\n\n        If the body argument is not one of the above, it will be returned\n        verbatim as it is unaffected by the OAuth signing process. Attempting to\n        sign a request with non-formencoded data using the OAuth body signature\n        type is invalid and will raise an exception.\n\n        If the body does contain parameters, it will be returned as a properly-\n        formatted formencoded string.\n\n        Body may not be included if the http_method is either GET or HEAD as\n        this changes the semantic meaning of the request.\n\n        All string data MUST be unicode or be encoded with the same encoding\n        scheme supplied to the Client constructor, default utf-8. This includes\n        strings inside body dicts, for example.\n        \"\"\"\n        # normalize request data\n        request = Request(uri, http_method, body, headers,\n                          encoding=self.encoding)\n\n        # sanity check\n        content_type = request.headers.get('Content-Type', None)\n        multipart = content_type and content_type.startswith('multipart/')\n        should_have_params = content_type == CONTENT_TYPE_FORM_URLENCODED\n        has_params = request.decoded_body is not None\n        # 3.4.1.3.1.  Parameter Sources\n        # [Parameters are collected from the HTTP request entity-body, but only\n        # if [...]:\n        #    *  The entity-body is single-part.\n        if multipart and has_params:\n            raise ValueError(\n                \"Headers indicate a multipart body but body contains parameters.\")\n        #    *  The entity-body follows the encoding requirements of the\n        #       \"application/x-www-form-urlencoded\" content-type as defined by\n        #       [W3C.REC-html40-19980424].\n        elif should_have_params and not has_params:\n            raise ValueError(\n                \"Headers indicate a formencoded body but body was not decodable.\")\n        #    *  The HTTP request entity-header includes the \"Content-Type\"\n        #       header field set to \"application/x-www-form-urlencoded\".\n        elif not should_have_params and has_params:\n            raise ValueError(\n                \"Body contains parameters but Content-Type header was {} \"\n                \"instead of {}\".format(content_type or \"not set\",\n                                        CONTENT_TYPE_FORM_URLENCODED))\n\n        # 3.5.2.  Form-Encoded Body\n        # Protocol parameters can be transmitted in the HTTP request entity-\n        # body, but only if the following REQUIRED conditions are met:\n        # o  The entity-body is single-part.\n        # o  The entity-body follows the encoding requirements of the\n        #    \"application/x-www-form-urlencoded\" content-type as defined by\n        #    [W3C.REC-html40-19980424].\n        # o  The HTTP request entity-header includes the \"Content-Type\" header\n        #    field set to \"application/x-www-form-urlencoded\".\n        elif self.signature_type == SIGNATURE_TYPE_BODY and not (\n                should_have_params and has_params and not multipart):\n            raise ValueError(\n                'Body signatures may only be used with form-urlencoded content')\n\n        # We amend https://tools.ietf.org/html/rfc5849#section-3.4.1.3.1\n        # with the clause that parameters from body should only be included\n        # in non GET or HEAD requests. Extracting the request body parameters\n        # and including them in the signature base string would give semantic\n        # meaning to the body, which it should not have according to the\n        # HTTP 1.1 spec.\n        elif http_method.upper() in ('GET', 'HEAD') and has_params:\n            raise ValueError('GET/HEAD requests should not include body.')\n\n        # generate the basic OAuth parameters\n        request.oauth_params = self.get_oauth_params(request)\n\n        # generate the signature\n        request.oauth_params.append(\n            ('oauth_signature', self.get_oauth_signature(request)))\n\n        # render the signed request and return it\n        uri, headers, body = self._render(request, formencode=True,\n                                          realm=(realm or self.realm))\n\n        if self.decoding:\n            log.debug('Encoding URI, headers and body to %s.', self.decoding)\n            uri = uri.encode(self.decoding)\n            body = body.encode(self.decoding) if body else body\n            new_headers = {}\n            for k, v in headers.items():\n                new_headers[k.encode(self.decoding)] = v.encode(self.decoding)\n            headers = new_headers\n        return uri, headers, body\n", "oauthlib/oauth1/rfc5849/request_validator.py": "\"\"\"\noauthlib.oauth1.rfc5849\n~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor signing and checking OAuth 1.0 RFC 5849 requests.\n\"\"\"\nfrom . import SIGNATURE_METHODS, utils\n\n\nclass RequestValidator:\n\n    \"\"\"A validator/datastore interaction base class for OAuth 1 providers.\n\n    OAuth providers should inherit from RequestValidator and implement the\n    methods and properties outlined below. Further details are provided in the\n    documentation for each method and property.\n\n    Methods used to check the format of input parameters. Common tests include\n    length, character set, membership, range or pattern. These tests are\n    referred to as `whitelisting or blacklisting`_. Whitelisting is better\n    but blacklisting can be useful to spot malicious activity.\n    The following have methods a default implementation:\n\n    - check_client_key\n    - check_request_token\n    - check_access_token\n    - check_nonce\n    - check_verifier\n    - check_realms\n\n    The methods above default to whitelist input parameters, checking that they\n    are alphanumerical and between a minimum and maximum length. Rather than\n    overloading the methods a few properties can be used to configure these\n    methods.\n\n    * @safe_characters -> (character set)\n    * @client_key_length -> (min, max)\n    * @request_token_length -> (min, max)\n    * @access_token_length -> (min, max)\n    * @nonce_length -> (min, max)\n    * @verifier_length -> (min, max)\n    * @realms -> [list, of, realms]\n\n    Methods used to validate/invalidate input parameters. These checks usually\n    hit either persistent or temporary storage such as databases or the\n    filesystem. See each methods documentation for detailed usage.\n    The following methods must be implemented:\n\n    - validate_client_key\n    - validate_request_token\n    - validate_access_token\n    - validate_timestamp_and_nonce\n    - validate_redirect_uri\n    - validate_requested_realms\n    - validate_realms\n    - validate_verifier\n    - invalidate_request_token\n\n    Methods used to retrieve sensitive information from storage.\n    The following methods must be implemented:\n\n    - get_client_secret\n    - get_request_token_secret\n    - get_access_token_secret\n    - get_rsa_key\n    - get_realms\n    - get_default_realms\n    - get_redirect_uri\n\n    Methods used to save credentials.\n    The following methods must be implemented:\n\n    - save_request_token\n    - save_verifier\n    - save_access_token\n\n    Methods used to verify input parameters. This methods are used during\n    authorizing request token by user (AuthorizationEndpoint), to check if\n    parameters are valid. During token authorization request is not signed,\n    thus 'validation' methods can not be used. The following methods must be\n    implemented:\n\n    - verify_realms\n    - verify_request_token\n\n    To prevent timing attacks it is necessary to not exit early even if the\n    client key or resource owner key is invalid. Instead dummy values should\n    be used during the remaining verification process. It is very important\n    that the dummy client and token are valid input parameters to the methods\n    get_client_secret, get_rsa_key and get_(access/request)_token_secret and\n    that the running time of those methods when given a dummy value remain\n    equivalent to the running time when given a valid client/resource owner.\n    The following properties must be implemented:\n\n    * @dummy_client\n    * @dummy_request_token\n    * @dummy_access_token\n\n    Example implementations have been provided, note that the database used is\n    a simple dictionary and serves only an illustrative purpose. Use whichever\n    database suits your project and how to access it is entirely up to you.\n    The methods are introduced in an order which should make understanding\n    their use more straightforward and as such it could be worth reading what\n    follows in chronological order.\n\n    .. _`whitelisting or blacklisting`: https://www.schneier.com/blog/archives/2011/01/whitelisting_vs.html\n    \"\"\"\n\n    def __init__(self):\n        pass\n\n    @property\n    def allowed_signature_methods(self):\n        return SIGNATURE_METHODS\n\n    @property\n    def safe_characters(self):\n        return set(utils.UNICODE_ASCII_CHARACTER_SET)\n\n    @property\n    def client_key_length(self):\n        return 20, 30\n\n    @property\n    def request_token_length(self):\n        return 20, 30\n\n    @property\n    def access_token_length(self):\n        return 20, 30\n\n    @property\n    def timestamp_lifetime(self):\n        return 600\n\n    @property\n    def nonce_length(self):\n        return 20, 30\n\n    @property\n    def verifier_length(self):\n        return 20, 30\n\n    @property\n    def realms(self):\n        return []\n\n    @property\n    def enforce_ssl(self):\n        return True\n\n    def check_client_key(self, client_key):\n        \"\"\"Check that the client key only contains safe characters\n        and is no shorter than lower and no longer than upper.\n        \"\"\"\n        lower, upper = self.client_key_length\n        return (set(client_key) <= self.safe_characters and\n                lower <= len(client_key) <= upper)\n\n    def check_request_token(self, request_token):\n        \"\"\"Checks that the request token contains only safe characters\n        and is no shorter than lower and no longer than upper.\n        \"\"\"\n        lower, upper = self.request_token_length\n        return (set(request_token) <= self.safe_characters and\n                lower <= len(request_token) <= upper)\n\n    def check_access_token(self, request_token):\n        \"\"\"Checks that the token contains only safe characters\n        and is no shorter than lower and no longer than upper.\n        \"\"\"\n        lower, upper = self.access_token_length\n        return (set(request_token) <= self.safe_characters and\n                lower <= len(request_token) <= upper)\n\n    def check_nonce(self, nonce):\n        \"\"\"Checks that the nonce only contains only safe characters\n        and is no shorter than lower and no longer than upper.\n        \"\"\"\n        lower, upper = self.nonce_length\n        return (set(nonce) <= self.safe_characters and\n                lower <= len(nonce) <= upper)\n\n    def check_verifier(self, verifier):\n        \"\"\"Checks that the verifier contains only safe characters\n        and is no shorter than lower and no longer than upper.\n        \"\"\"\n        lower, upper = self.verifier_length\n        return (set(verifier) <= self.safe_characters and\n                lower <= len(verifier) <= upper)\n\n    def check_realms(self, realms):\n        \"\"\"Check that the realm is one of a set allowed realms.\"\"\"\n        return all(r in self.realms for r in realms)\n\n    def _subclass_must_implement(self, fn):\n        \"\"\"\n        Returns a NotImplementedError for a function that should be implemented.\n        :param fn: name of the function\n        \"\"\"\n        m = \"Missing function implementation in {}: {}\".format(type(self), fn)\n        return NotImplementedError(m)\n\n    @property\n    def dummy_client(self):\n        \"\"\"Dummy client used when an invalid client key is supplied.\n\n        :returns: The dummy client key string.\n\n        The dummy client should be associated with either a client secret,\n        a rsa key or both depending on which signature methods are supported.\n        Providers should make sure that\n\n        get_client_secret(dummy_client)\n        get_rsa_key(dummy_client)\n\n        return a valid secret or key for the dummy client.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        * RequestTokenEndpoint\n        * ResourceEndpoint\n        * SignatureOnlyEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"dummy_client\")\n\n    @property\n    def dummy_request_token(self):\n        \"\"\"Dummy request token used when an invalid token was supplied.\n\n        :returns: The dummy request token string.\n\n        The dummy request token should be associated with a request token\n        secret such that get_request_token_secret(.., dummy_request_token)\n        returns a valid secret.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"dummy_request_token\")\n\n    @property\n    def dummy_access_token(self):\n        \"\"\"Dummy access token used when an invalid token was supplied.\n\n        :returns: The dummy access token string.\n\n        The dummy access token should be associated with an access token\n        secret such that get_access_token_secret(.., dummy_access_token)\n        returns a valid secret.\n\n        This method is used by\n\n        * ResourceEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"dummy_access_token\")\n\n    def get_client_secret(self, client_key, request):\n        \"\"\"Retrieves the client secret associated with the client key.\n\n        :param client_key: The client/consumer key.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The client secret as a string.\n\n        This method must allow the use of a dummy client_key value.\n        Fetching the secret using the dummy key must take the same amount of\n        time as fetching a secret for a valid client::\n\n            # Unlikely to be near constant time as it uses two database\n            # lookups for a valid client, and only one for an invalid.\n            from your_datastore import ClientSecret\n            if ClientSecret.has(client_key):\n                return ClientSecret.get(client_key)\n            else:\n                return 'dummy'\n\n            # Aim to mimic number of latency inducing operations no matter\n            # whether the client is valid or not.\n            from your_datastore import ClientSecret\n            return ClientSecret.get(client_key, 'dummy')\n\n        Note that the returned key must be in plaintext.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        * RequestTokenEndpoint\n        * ResourceEndpoint\n        * SignatureOnlyEndpoint\n        \"\"\"\n        raise self._subclass_must_implement('get_client_secret')\n\n    def get_request_token_secret(self, client_key, token, request):\n        \"\"\"Retrieves the shared secret associated with the request token.\n\n        :param client_key: The client/consumer key.\n        :param token: The request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The token secret as a string.\n\n        This method must allow the use of a dummy values and the running time\n        must be roughly equivalent to that of the running time of valid values::\n\n            # Unlikely to be near constant time as it uses two database\n            # lookups for a valid client, and only one for an invalid.\n            from your_datastore import RequestTokenSecret\n            if RequestTokenSecret.has(client_key):\n                return RequestTokenSecret.get((client_key, request_token))\n            else:\n                return 'dummy'\n\n            # Aim to mimic number of latency inducing operations no matter\n            # whether the client is valid or not.\n            from your_datastore import RequestTokenSecret\n            return ClientSecret.get((client_key, request_token), 'dummy')\n\n        Note that the returned key must be in plaintext.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement('get_request_token_secret')\n\n    def get_access_token_secret(self, client_key, token, request):\n        \"\"\"Retrieves the shared secret associated with the access token.\n\n        :param client_key: The client/consumer key.\n        :param token: The access token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The token secret as a string.\n\n        This method must allow the use of a dummy values and the running time\n        must be roughly equivalent to that of the running time of valid values::\n\n            # Unlikely to be near constant time as it uses two database\n            # lookups for a valid client, and only one for an invalid.\n            from your_datastore import AccessTokenSecret\n            if AccessTokenSecret.has(client_key):\n                return AccessTokenSecret.get((client_key, request_token))\n            else:\n                return 'dummy'\n\n            # Aim to mimic number of latency inducing operations no matter\n            # whether the client is valid or not.\n            from your_datastore import AccessTokenSecret\n            return ClientSecret.get((client_key, request_token), 'dummy')\n\n        Note that the returned key must be in plaintext.\n\n        This method is used by\n\n        * ResourceEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"get_access_token_secret\")\n\n    def get_default_realms(self, client_key, request):\n        \"\"\"Get the default realms for a client.\n\n        :param client_key: The client/consumer key.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The list of default realms associated with the client.\n\n        The list of default realms will be set during client registration and\n        is outside the scope of OAuthLib.\n\n        This method is used by\n\n        * RequestTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"get_default_realms\")\n\n    def get_realms(self, token, request):\n        \"\"\"Get realms associated with a request token.\n\n        :param token: The request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The list of realms associated with the request token.\n\n        This method is used by\n\n        * AuthorizationEndpoint\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"get_realms\")\n\n    def get_redirect_uri(self, token, request):\n        \"\"\"Get the redirect URI associated with a request token.\n\n        :param token: The request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The redirect URI associated with the request token.\n\n        It may be desirable to return a custom URI if the redirect is set to \"oob\".\n        In this case, the user will be redirected to the returned URI and at that\n        endpoint the verifier can be displayed.\n\n        This method is used by\n\n        * AuthorizationEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"get_redirect_uri\")\n\n    def get_rsa_key(self, client_key, request):\n        \"\"\"Retrieves a previously stored client provided RSA key.\n\n        :param client_key: The client/consumer key.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The rsa public key as a string.\n\n        This method must allow the use of a dummy client_key value. Fetching\n        the rsa key using the dummy key must take the same amount of time\n        as fetching a key for a valid client. The dummy key must also be of\n        the same bit length as client keys.\n\n        Note that the key must be returned in plaintext.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        * RequestTokenEndpoint\n        * ResourceEndpoint\n        * SignatureOnlyEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"get_rsa_key\")\n\n    def invalidate_request_token(self, client_key, request_token, request):\n        \"\"\"Invalidates a used request token.\n\n        :param client_key: The client/consumer key.\n        :param request_token: The request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: None\n\n        Per `Section 2.3`_ of the spec:\n\n        \"The server MUST (...) ensure that the temporary\n        credentials have not expired or been used before.\"\n\n        .. _`Section 2.3`: https://tools.ietf.org/html/rfc5849#section-2.3\n\n        This method should ensure that provided token won't validate anymore.\n        It can be simply removing RequestToken from storage or setting\n        specific flag that makes it invalid (note that such flag should be\n        also validated during request token validation).\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"invalidate_request_token\")\n\n    def validate_client_key(self, client_key, request):\n        \"\"\"Validates that supplied client key is a registered and valid client.\n\n        :param client_key: The client/consumer key.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        Note that if the dummy client is supplied it should validate in same\n        or nearly the same amount of time as a valid one.\n\n        Ensure latency inducing tasks are mimiced even for dummy clients.\n        For example, use::\n\n            from your_datastore import Client\n            try:\n                return Client.exists(client_key, access_token)\n            except DoesNotExist:\n                return False\n\n        Rather than::\n\n            from your_datastore import Client\n            if access_token == self.dummy_access_token:\n                return False\n            else:\n                return Client.exists(client_key, access_token)\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        * RequestTokenEndpoint\n        * ResourceEndpoint\n        * SignatureOnlyEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_client_key\")\n\n    def validate_request_token(self, client_key, token, request):\n        \"\"\"Validates that supplied request token is registered and valid.\n\n        :param client_key: The client/consumer key.\n        :param token: The request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        Note that if the dummy request_token is supplied it should validate in\n        the same nearly the same amount of time as a valid one.\n\n        Ensure latency inducing tasks are mimiced even for dummy clients.\n        For example, use::\n\n            from your_datastore import RequestToken\n            try:\n                return RequestToken.exists(client_key, access_token)\n            except DoesNotExist:\n                return False\n\n        Rather than::\n\n            from your_datastore import RequestToken\n            if access_token == self.dummy_access_token:\n                return False\n            else:\n                return RequestToken.exists(client_key, access_token)\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_request_token\")\n\n    def validate_access_token(self, client_key, token, request):\n        \"\"\"Validates that supplied access token is registered and valid.\n\n        :param client_key: The client/consumer key.\n        :param token: The access token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        Note that if the dummy access token is supplied it should validate in\n        the same or nearly the same amount of time as a valid one.\n\n        Ensure latency inducing tasks are mimiced even for dummy clients.\n        For example, use::\n\n            from your_datastore import AccessToken\n            try:\n                return AccessToken.exists(client_key, access_token)\n            except DoesNotExist:\n                return False\n\n        Rather than::\n\n            from your_datastore import AccessToken\n            if access_token == self.dummy_access_token:\n                return False\n            else:\n                return AccessToken.exists(client_key, access_token)\n\n        This method is used by\n\n        * ResourceEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_access_token\")\n\n    def validate_timestamp_and_nonce(self, client_key, timestamp, nonce,\n                                     request, request_token=None, access_token=None):\n        \"\"\"Validates that the nonce has not been used before.\n\n        :param client_key: The client/consumer key.\n        :param timestamp: The ``oauth_timestamp`` parameter.\n        :param nonce: The ``oauth_nonce`` parameter.\n        :param request_token: Request token string, if any.\n        :param access_token: Access token string, if any.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        Per `Section 3.3`_ of the spec.\n\n        \"A nonce is a random string, uniquely generated by the client to allow\n        the server to verify that a request has never been made before and\n        helps prevent replay attacks when requests are made over a non-secure\n        channel.  The nonce value MUST be unique across all requests with the\n        same timestamp, client credentials, and token combinations.\"\n\n        .. _`Section 3.3`: https://tools.ietf.org/html/rfc5849#section-3.3\n\n        One of the first validation checks that will be made is for the validity\n        of the nonce and timestamp, which are associated with a client key and\n        possibly a token. If invalid then immediately fail the request\n        by returning False. If the nonce/timestamp pair has been used before and\n        you may just have detected a replay attack. Therefore it is an essential\n        part of OAuth security that you not allow nonce/timestamp reuse.\n        Note that this validation check is done before checking the validity of\n        the client and token.::\n\n           nonces_and_timestamps_database = [\n              (u'foo', 1234567890, u'rannoMstrInghere', u'bar')\n           ]\n\n           def validate_timestamp_and_nonce(self, client_key, timestamp, nonce,\n              request_token=None, access_token=None):\n\n              return ((client_key, timestamp, nonce, request_token or access_token)\n                       not in self.nonces_and_timestamps_database)\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        * RequestTokenEndpoint\n        * ResourceEndpoint\n        * SignatureOnlyEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_timestamp_and_nonce\")\n\n    def validate_redirect_uri(self, client_key, redirect_uri, request):\n        \"\"\"Validates the client supplied redirection URI.\n\n        :param client_key: The client/consumer key.\n        :param redirect_uri: The URI the client which to redirect back to after\n                             authorization is successful.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        It is highly recommended that OAuth providers require their clients\n        to register all redirection URIs prior to using them in requests and\n        register them as absolute URIs. See `CWE-601`_ for more information\n        about open redirection attacks.\n\n        By requiring registration of all redirection URIs it should be\n        straightforward for the provider to verify whether the supplied\n        redirect_uri is valid or not.\n\n        Alternatively per `Section 2.1`_ of the spec:\n\n        \"If the client is unable to receive callbacks or a callback URI has\n        been established via other means, the parameter value MUST be set to\n        \"oob\" (case sensitive), to indicate an out-of-band configuration.\"\n\n        .. _`CWE-601`: http://cwe.mitre.org/top25/index.html#CWE-601\n        .. _`Section 2.1`: https://tools.ietf.org/html/rfc5849#section-2.1\n\n        This method is used by\n\n        * RequestTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_redirect_uri\")\n\n    def validate_requested_realms(self, client_key, realms, request):\n        \"\"\"Validates that the client may request access to the realm.\n\n        :param client_key: The client/consumer key.\n        :param realms: The list of realms that client is requesting access to.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        This method is invoked when obtaining a request token and should\n        tie a realm to the request token and after user authorization\n        this realm restriction should transfer to the access token.\n\n        This method is used by\n\n        * RequestTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_requested_realms\")\n\n    def validate_realms(self, client_key, token, request, uri=None,\n                        realms=None):\n        \"\"\"Validates access to the request realm.\n\n        :param client_key: The client/consumer key.\n        :param token: A request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param uri: The URI the realms is protecting.\n        :param realms: A list of realms that must have been granted to\n                       the access token.\n        :returns: True or False\n\n        How providers choose to use the realm parameter is outside the OAuth\n        specification but it is commonly used to restrict access to a subset\n        of protected resources such as \"photos\".\n\n        realms is a convenience parameter which can be used to provide\n        a per view method pre-defined list of allowed realms.\n\n        Can be as simple as::\n\n            from your_datastore import RequestToken\n            request_token = RequestToken.get(token, None)\n\n            if not request_token:\n                return False\n            return set(request_token.realms).issuperset(set(realms))\n\n        This method is used by\n\n        * ResourceEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_realms\")\n\n    def validate_verifier(self, client_key, token, verifier, request):\n        \"\"\"Validates a verification code.\n\n        :param client_key: The client/consumer key.\n        :param token: A request token string.\n        :param verifier: The authorization verifier string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        OAuth providers issue a verification code to clients after the\n        resource owner authorizes access. This code is used by the client to\n        obtain token credentials and the provider must verify that the\n        verifier is valid and associated with the client as well as the\n        resource owner.\n\n        Verifier validation should be done in near constant time\n        (to avoid verifier enumeration). To achieve this we need a\n        constant time string comparison which is provided by OAuthLib\n        in ``oauthlib.common.safe_string_equals``::\n\n            from your_datastore import Verifier\n            correct_verifier = Verifier.get(client_key, request_token)\n            from oauthlib.common import safe_string_equals\n            return safe_string_equals(verifier, correct_verifier)\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"validate_verifier\")\n\n    def verify_request_token(self, token, request):\n        \"\"\"Verify that the given OAuth1 request token is valid.\n\n        :param token: A request token string.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        This method is used only in AuthorizationEndpoint to check whether the\n        oauth_token given in the authorization URL is valid or not.\n        This request is not signed and thus similar ``validate_request_token``\n        method can not be used.\n\n        This method is used by\n\n        * AuthorizationEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"verify_request_token\")\n\n    def verify_realms(self, token, realms, request):\n        \"\"\"Verify authorized realms to see if they match those given to token.\n\n        :param token: An access token string.\n        :param realms: A list of realms the client attempts to access.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: True or False\n\n        This prevents the list of authorized realms sent by the client during\n        the authorization step to be altered to include realms outside what\n        was bound with the request token.\n\n        Can be as simple as::\n\n            valid_realms = self.get_realms(token)\n            return all((r in valid_realms for r in realms))\n\n        This method is used by\n\n        * AuthorizationEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"verify_realms\")\n\n    def save_access_token(self, token, request):\n        \"\"\"Save an OAuth1 access token.\n\n        :param token: A dict with token credentials.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        The token dictionary will at minimum include\n\n        * ``oauth_token`` the access token string.\n        * ``oauth_token_secret`` the token specific secret used in signing.\n        * ``oauth_authorized_realms`` a space separated list of realms.\n\n        Client key can be obtained from ``request.client_key``.\n\n        The list of realms (not joined string) can be obtained from\n        ``request.realm``.\n\n        This method is used by\n\n        * AccessTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"save_access_token\")\n\n    def save_request_token(self, token, request):\n        \"\"\"Save an OAuth1 request token.\n\n        :param token: A dict with token credentials.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        The token dictionary will at minimum include\n\n        * ``oauth_token`` the request token string.\n        * ``oauth_token_secret`` the token specific secret used in signing.\n        * ``oauth_callback_confirmed`` the string ``true``.\n\n        Client key can be obtained from ``request.client_key``.\n\n        This method is used by\n\n        * RequestTokenEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"save_request_token\")\n\n    def save_verifier(self, token, verifier, request):\n        \"\"\"Associate an authorization verifier with a request token.\n\n        :param token: A request token string.\n        :param verifier: A dictionary containing the oauth_verifier and\n                        oauth_token\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n\n        We need to associate verifiers with tokens for validation during the\n        access token request.\n\n        Note that unlike save_x_token token here is the ``oauth_token`` token\n        string from the request token saved previously.\n\n        This method is used by\n\n        * AuthorizationEndpoint\n        \"\"\"\n        raise self._subclass_must_implement(\"save_verifier\")\n", "oauthlib/oauth1/rfc5849/endpoints/signature_only.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.signature_only\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of the signing logic of OAuth 1.0 RFC 5849.\n\"\"\"\n\nimport logging\n\nfrom .. import errors\nfrom .base import BaseEndpoint\n\nlog = logging.getLogger(__name__)\n\n\nclass SignatureOnlyEndpoint(BaseEndpoint):\n\n    \"\"\"An endpoint only responsible for verifying an oauth signature.\"\"\"\n\n    def validate_request(self, uri, http_method='GET',\n                         body=None, headers=None):\n        \"\"\"Validate a signed OAuth request.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :returns: A tuple of 2 elements.\n                  1. True if valid, False otherwise.\n                  2. An oauthlib.common.Request object.\n        \"\"\"\n        try:\n            request = self._create_request(uri, http_method, body, headers)\n        except errors.OAuth1Error as err:\n            log.info(\n                'Exception caught while validating request, %s.' % err)\n            return False, None\n\n        try:\n            self._check_transport_security(request)\n            self._check_mandatory_parameters(request)\n        except errors.OAuth1Error as err:\n            log.info(\n                'Exception caught while validating request, %s.' % err)\n            return False, request\n\n        if not self.request_validator.validate_timestamp_and_nonce(\n                request.client_key, request.timestamp, request.nonce, request):\n            log.debug('[Failure] verification failed: timestamp/nonce')\n            return False, request\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid client credentials.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy client is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable client enumeration\n        valid_client = self.request_validator.validate_client_key(\n            request.client_key, request)\n        if not valid_client:\n            request.client_key = self.request_validator.dummy_client\n\n        valid_signature = self._check_signature(request)\n\n        # log the results to the validator_log\n        # this lets us handle internal reporting and analysis\n        request.validator_log['client'] = valid_client\n        request.validator_log['signature'] = valid_signature\n\n        # We delay checking validity until the very end, using dummy values for\n        # calculations and fetching secrets/keys to ensure the flow of every\n        # request remains almost identical regardless of whether valid values\n        # have been supplied. This ensures near constant time execution and\n        # prevents malicious users from guessing sensitive information\n        v = all((valid_client, valid_signature))\n        if not v:\n            log.info(\"[Failure] request verification failed.\")\n            log.info(\"Valid client: %s\", valid_client)\n            log.info(\"Valid signature: %s\", valid_signature)\n        return v, request\n", "oauthlib/oauth1/rfc5849/endpoints/base.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.base\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor signing and checking OAuth 1.0 RFC 5849 requests.\n\"\"\"\nimport time\n\nfrom oauthlib.common import CaseInsensitiveDict, Request, generate_token\n\nfrom .. import (\n    CONTENT_TYPE_FORM_URLENCODED, SIGNATURE_HMAC_SHA1, SIGNATURE_HMAC_SHA256,\n    SIGNATURE_HMAC_SHA512, SIGNATURE_PLAINTEXT, SIGNATURE_RSA_SHA1,\n    SIGNATURE_RSA_SHA256, SIGNATURE_RSA_SHA512, SIGNATURE_TYPE_AUTH_HEADER,\n    SIGNATURE_TYPE_BODY, SIGNATURE_TYPE_QUERY, errors, signature, utils,\n)\n\n\nclass BaseEndpoint:\n\n    def __init__(self, request_validator, token_generator=None):\n        self.request_validator = request_validator\n        self.token_generator = token_generator or generate_token\n\n    def _get_signature_type_and_params(self, request):\n        \"\"\"Extracts parameters from query, headers and body. Signature type\n        is set to the source in which parameters were found.\n        \"\"\"\n        # Per RFC5849, only the Authorization header may contain the 'realm'\n        # optional parameter.\n        header_params = signature.collect_parameters(headers=request.headers,\n                                                     exclude_oauth_signature=False, with_realm=True)\n        body_params = signature.collect_parameters(body=request.body,\n                                                   exclude_oauth_signature=False)\n        query_params = signature.collect_parameters(uri_query=request.uri_query,\n                                                    exclude_oauth_signature=False)\n\n        params = []\n        params.extend(header_params)\n        params.extend(body_params)\n        params.extend(query_params)\n        signature_types_with_oauth_params = list(filter(lambda s: s[2], (\n            (SIGNATURE_TYPE_AUTH_HEADER, params,\n                utils.filter_oauth_params(header_params)),\n            (SIGNATURE_TYPE_BODY, params,\n                utils.filter_oauth_params(body_params)),\n            (SIGNATURE_TYPE_QUERY, params,\n                utils.filter_oauth_params(query_params))\n        )))\n\n        if len(signature_types_with_oauth_params) > 1:\n            found_types = [s[0] for s in signature_types_with_oauth_params]\n            raise errors.InvalidRequestError(\n                description=('oauth_ params must come from only 1 signature'\n                             'type but were found in %s',\n                             ', '.join(found_types)))\n\n        try:\n            signature_type, params, oauth_params = signature_types_with_oauth_params[\n                0]\n        except IndexError:\n            raise errors.InvalidRequestError(\n                description='Missing mandatory OAuth parameters.')\n\n        return signature_type, params, oauth_params\n\n    def _create_request(self, uri, http_method, body, headers):\n        # Only include body data from x-www-form-urlencoded requests\n        headers = CaseInsensitiveDict(headers or {})\n        if \"Content-Type\" in headers and CONTENT_TYPE_FORM_URLENCODED in headers[\"Content-Type\"]:  # noqa: SIM108\n            request = Request(uri, http_method, body, headers)\n        else:\n            request = Request(uri, http_method, '', headers)\n        signature_type, params, oauth_params = (\n            self._get_signature_type_and_params(request))\n\n        # The server SHOULD return a 400 (Bad Request) status code when\n        # receiving a request with duplicated protocol parameters.\n        if len(dict(oauth_params)) != len(oauth_params):\n            raise errors.InvalidRequestError(\n                description='Duplicate OAuth1 entries.')\n\n        oauth_params = dict(oauth_params)\n        request.signature = oauth_params.get('oauth_signature')\n        request.client_key = oauth_params.get('oauth_consumer_key')\n        request.resource_owner_key = oauth_params.get('oauth_token')\n        request.nonce = oauth_params.get('oauth_nonce')\n        request.timestamp = oauth_params.get('oauth_timestamp')\n        request.redirect_uri = oauth_params.get('oauth_callback')\n        request.verifier = oauth_params.get('oauth_verifier')\n        request.signature_method = oauth_params.get('oauth_signature_method')\n        request.realm = dict(params).get('realm')\n        request.oauth_params = oauth_params\n\n        # Parameters to Client depend on signature method which may vary\n        # for each request. Note that HMAC-SHA1 and PLAINTEXT share parameters\n        request.params = [(k, v) for k, v in params if k != \"oauth_signature\"]\n\n        if 'realm' in request.headers.get('Authorization', ''):\n            request.params = [(k, v)\n                              for k, v in request.params if k != \"realm\"]\n\n        return request\n\n    def _check_transport_security(self, request):\n        # TODO: move into oauthlib.common from oauth2.utils\n        if (self.request_validator.enforce_ssl and\n                not request.uri.lower().startswith(\"https://\")):\n            raise errors.InsecureTransportError()\n\n    def _check_mandatory_parameters(self, request):\n        # The server SHOULD return a 400 (Bad Request) status code when\n        # receiving a request with missing parameters.\n        if not all((request.signature, request.client_key,\n                    request.nonce, request.timestamp,\n                    request.signature_method)):\n            raise errors.InvalidRequestError(\n                description='Missing mandatory OAuth parameters.')\n\n        # OAuth does not mandate a particular signature method, as each\n        # implementation can have its own unique requirements.  Servers are\n        # free to implement and document their own custom methods.\n        # Recommending any particular method is beyond the scope of this\n        # specification.  Implementers should review the Security\n        # Considerations section (`Section 4`_) before deciding on which\n        # method to support.\n        # .. _`Section 4`: https://tools.ietf.org/html/rfc5849#section-4\n        if (request.signature_method not in self.request_validator.allowed_signature_methods):\n            raise errors.InvalidSignatureMethodError(\n                description=\"Invalid signature, {} not in {!r}.\".format(\n                    request.signature_method,\n                    self.request_validator.allowed_signature_methods))\n\n        # Servers receiving an authenticated request MUST validate it by:\n        #   If the \"oauth_version\" parameter is present, ensuring its value is\n        #   \"1.0\".\n        if ('oauth_version' in request.oauth_params and\n                request.oauth_params['oauth_version'] != '1.0'):\n            raise errors.InvalidRequestError(\n                description='Invalid OAuth version.')\n\n        # The timestamp value MUST be a positive integer. Unless otherwise\n        # specified by the server's documentation, the timestamp is expressed\n        # in the number of seconds since January 1, 1970 00:00:00 GMT.\n        if len(request.timestamp) != 10:\n            raise errors.InvalidRequestError(\n                description='Invalid timestamp size')\n\n        try:\n            ts = int(request.timestamp)\n\n        except ValueError:\n            raise errors.InvalidRequestError(\n                description='Timestamp must be an integer.')\n\n        else:\n            # To avoid the need to retain an infinite number of nonce values for\n            # future checks, servers MAY choose to restrict the time period after\n            # which a request with an old timestamp is rejected.\n            if abs(time.time() - ts) > self.request_validator.timestamp_lifetime:\n                raise errors.InvalidRequestError(\n                    description=('Timestamp given is invalid, differ from '\n                                 'allowed by over %s seconds.' % (\n                                     self.request_validator.timestamp_lifetime)))\n\n        # Provider specific validation of parameters, used to enforce\n        # restrictions such as character set and length.\n        if not self.request_validator.check_client_key(request.client_key):\n            raise errors.InvalidRequestError(\n                description='Invalid client key format.')\n\n        if not self.request_validator.check_nonce(request.nonce):\n            raise errors.InvalidRequestError(\n                description='Invalid nonce format.')\n\n    def _check_signature(self, request, is_token_request=False):\n        # ---- RSA Signature verification ----\n        if request.signature_method in {SIGNATURE_RSA_SHA1, SIGNATURE_RSA_SHA256, SIGNATURE_RSA_SHA512}:\n            # RSA-based signature method\n\n            # The server verifies the signature per `[RFC3447] section 8.2.2`_\n            # .. _`[RFC3447] section 8.2.2`: https://tools.ietf.org/html/rfc3447#section-8.2.1\n\n            rsa_key = self.request_validator.get_rsa_key(\n                request.client_key, request)\n\n            if request.signature_method == SIGNATURE_RSA_SHA1:\n                valid_signature = signature.verify_rsa_sha1(request, rsa_key)\n            elif request.signature_method == SIGNATURE_RSA_SHA256:\n                valid_signature = signature.verify_rsa_sha256(request, rsa_key)\n            elif request.signature_method == SIGNATURE_RSA_SHA512:\n                valid_signature = signature.verify_rsa_sha512(request, rsa_key)\n            else:\n                valid_signature = False\n\n        # ---- HMAC or Plaintext Signature verification ----\n        else:\n            # Non-RSA based signature method\n\n            # Servers receiving an authenticated request MUST validate it by:\n            #   Recalculating the request signature independently as described in\n            #   `Section 3.4`_ and comparing it to the value received from the\n            #   client via the \"oauth_signature\" parameter.\n            # .. _`Section 3.4`: https://tools.ietf.org/html/rfc5849#section-3.4\n\n            client_secret = self.request_validator.get_client_secret(\n                request.client_key, request)\n\n            resource_owner_secret = None\n            if request.resource_owner_key:\n                if is_token_request:\n                    resource_owner_secret = \\\n                        self.request_validator.get_request_token_secret(\n                            request.client_key, request.resource_owner_key,\n                            request)\n                else:\n                    resource_owner_secret = \\\n                        self.request_validator.get_access_token_secret(\n                            request.client_key, request.resource_owner_key,\n                            request)\n\n            if request.signature_method == SIGNATURE_HMAC_SHA1:\n                valid_signature = signature.verify_hmac_sha1(\n                    request, client_secret, resource_owner_secret)\n            elif request.signature_method == SIGNATURE_HMAC_SHA256:\n                valid_signature = signature.verify_hmac_sha256(\n                    request, client_secret, resource_owner_secret)\n            elif request.signature_method == SIGNATURE_HMAC_SHA512:\n                valid_signature = signature.verify_hmac_sha512(\n                    request, client_secret, resource_owner_secret)\n            elif request.signature_method == SIGNATURE_PLAINTEXT:\n                valid_signature = signature.verify_plaintext(\n                    request, client_secret, resource_owner_secret)\n            else:\n                valid_signature = False\n\n        return valid_signature\n", "oauthlib/oauth1/rfc5849/endpoints/pre_configured.py": "from . import (\n    AccessTokenEndpoint, AuthorizationEndpoint, RequestTokenEndpoint,\n    ResourceEndpoint,\n)\n\n\nclass WebApplicationServer(RequestTokenEndpoint, AuthorizationEndpoint,\n                           AccessTokenEndpoint, ResourceEndpoint):\n\n    def __init__(self, request_validator):\n        RequestTokenEndpoint.__init__(self, request_validator)\n        AuthorizationEndpoint.__init__(self, request_validator)\n        AccessTokenEndpoint.__init__(self, request_validator)\n        ResourceEndpoint.__init__(self, request_validator)\n", "oauthlib/oauth1/rfc5849/endpoints/authorization.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.authorization\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor signing and checking OAuth 1.0 RFC 5849 requests.\n\"\"\"\nfrom urllib.parse import urlencode\n\nfrom oauthlib.common import add_params_to_uri\n\nfrom .. import errors\nfrom .base import BaseEndpoint\n\n\nclass AuthorizationEndpoint(BaseEndpoint):\n\n    \"\"\"An endpoint responsible for letting authenticated users authorize access\n    to their protected resources to a client.\n\n    Typical use would be to have two views, one for displaying the authorization\n    form and one to process said form on submission.\n\n    The first view will want to utilize ``get_realms_and_credentials`` to fetch\n    requested realms and useful client credentials, such as name and\n    description, to be used when creating the authorization form.\n\n    During form processing you can use ``create_authorization_response`` to\n    validate the request, create a verifier as well as prepare the final\n    redirection URI used to send the user back to the client.\n\n    See :doc:`/oauth1/validator` for details on which validator methods to implement\n    for this endpoint.\n    \"\"\"\n\n    def create_verifier(self, request, credentials):\n        \"\"\"Create and save a new request token.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param credentials: A dict of extra token credentials.\n        :returns: The verifier as a dict.\n        \"\"\"\n        verifier = {\n            'oauth_token': request.resource_owner_key,\n            'oauth_verifier': self.token_generator(),\n        }\n        verifier.update(credentials)\n        self.request_validator.save_verifier(\n            request.resource_owner_key, verifier, request)\n        return verifier\n\n    def create_authorization_response(self, uri, http_method='GET', body=None,\n                                      headers=None, realms=None, credentials=None):\n        \"\"\"Create an authorization response, with a new request token if valid.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :param credentials: A list of credentials to include in the verifier.\n        :returns: A tuple of 3 elements.\n                  1. A dict of headers to set on the response.\n                  2. The response body as a string.\n                  3. The response status code as an integer.\n\n        If the callback URI tied to the current token is \"oob\", a response with\n        a 200 status code will be returned. In this case, it may be desirable to\n        modify the response to better display the verifier to the client.\n\n        An example of an authorization request::\n\n            >>> from your_validator import your_validator\n            >>> from oauthlib.oauth1 import AuthorizationEndpoint\n            >>> endpoint = AuthorizationEndpoint(your_validator)\n            >>> h, b, s = endpoint.create_authorization_response(\n            ...     'https://your.provider/authorize?oauth_token=...',\n            ...     credentials={\n            ...         'extra': 'argument',\n            ...     })\n            >>> h\n            {'Location': 'https://the.client/callback?oauth_verifier=...&extra=argument'}\n            >>> b\n            None\n            >>> s\n            302\n\n        An example of a request with an \"oob\" callback::\n\n            >>> from your_validator import your_validator\n            >>> from oauthlib.oauth1 import AuthorizationEndpoint\n            >>> endpoint = AuthorizationEndpoint(your_validator)\n            >>> h, b, s = endpoint.create_authorization_response(\n            ...     'https://your.provider/authorize?foo=bar',\n            ...     credentials={\n            ...         'extra': 'argument',\n            ...     })\n            >>> h\n            {'Content-Type': 'application/x-www-form-urlencoded'}\n            >>> b\n            'oauth_verifier=...&extra=argument'\n            >>> s\n            200\n        \"\"\"\n        request = self._create_request(uri, http_method=http_method, body=body,\n                                       headers=headers)\n\n        if not request.resource_owner_key:\n            raise errors.InvalidRequestError(\n                'Missing mandatory parameter oauth_token.')\n        if not self.request_validator.verify_request_token(\n                request.resource_owner_key, request):\n            raise errors.InvalidClientError()\n\n        request.realms = realms\n        if (request.realms and not self.request_validator.verify_realms(\n                request.resource_owner_key, request.realms, request)):\n            raise errors.InvalidRequestError(\n                description=('User granted access to realms outside of '\n                             'what the client may request.'))\n\n        verifier = self.create_verifier(request, credentials or {})\n        redirect_uri = self.request_validator.get_redirect_uri(\n            request.resource_owner_key, request)\n        if redirect_uri == 'oob':\n            response_headers = {\n                'Content-Type': 'application/x-www-form-urlencoded'}\n            response_body = urlencode(verifier)\n            return response_headers, response_body, 200\n        else:\n            populated_redirect = add_params_to_uri(\n                redirect_uri, verifier.items())\n            return {'Location': populated_redirect}, None, 302\n\n    def get_realms_and_credentials(self, uri, http_method='GET', body=None,\n                                   headers=None):\n        \"\"\"Fetch realms and credentials for the presented request token.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :returns: A tuple of 2 elements.\n                  1. A list of request realms.\n                  2. A dict of credentials which may be useful in creating the\n                  authorization form.\n        \"\"\"\n        request = self._create_request(uri, http_method=http_method, body=body,\n                                       headers=headers)\n\n        if not self.request_validator.verify_request_token(\n                request.resource_owner_key, request):\n            raise errors.InvalidClientError()\n\n        realms = self.request_validator.get_realms(\n            request.resource_owner_key, request)\n        return realms, {'resource_owner_key': request.resource_owner_key}\n", "oauthlib/oauth1/rfc5849/endpoints/__init__.py": "from .access_token import AccessTokenEndpoint\nfrom .authorization import AuthorizationEndpoint\nfrom .base import BaseEndpoint\nfrom .request_token import RequestTokenEndpoint\nfrom .resource import ResourceEndpoint\nfrom .signature_only import SignatureOnlyEndpoint\n\nfrom .pre_configured import WebApplicationServer  # isort:skip\n", "oauthlib/oauth1/rfc5849/endpoints/access_token.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.access_token\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of the access token provider logic of\nOAuth 1.0 RFC 5849. It validates the correctness of access token requests,\ncreates and persists tokens as well as create the proper response to be\nreturned to the client.\n\"\"\"\nimport logging\n\nfrom oauthlib.common import urlencode\n\nfrom .. import errors\nfrom .base import BaseEndpoint\n\nlog = logging.getLogger(__name__)\n\n\nclass AccessTokenEndpoint(BaseEndpoint):\n\n    \"\"\"An endpoint responsible for providing OAuth 1 access tokens.\n\n    Typical use is to instantiate with a request validator and invoke the\n    ``create_access_token_response`` from a view function. The tuple returned\n    has all information necessary (body, status, headers) to quickly form\n    and return a proper response. See :doc:`/oauth1/validator` for details on which\n    validator methods to implement for this endpoint.\n    \"\"\"\n\n    def create_access_token(self, request, credentials):\n        \"\"\"Create and save a new access token.\n\n        Similar to OAuth 2, indication of granted scopes will be included as a\n        space separated list in ``oauth_authorized_realms``.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :returns: The token as an urlencoded string.\n        \"\"\"\n        request.realms = self.request_validator.get_realms(\n            request.resource_owner_key, request)\n        token = {\n            'oauth_token': self.token_generator(),\n            'oauth_token_secret': self.token_generator(),\n            # Backport the authorized scopes indication used in OAuth2\n            'oauth_authorized_realms': ' '.join(request.realms)\n        }\n        token.update(credentials)\n        self.request_validator.save_access_token(token, request)\n        return urlencode(token.items())\n\n    def create_access_token_response(self, uri, http_method='GET', body=None,\n                                     headers=None, credentials=None):\n        \"\"\"Create an access token response, with a new request token if valid.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :param credentials: A list of extra credentials to include in the token.\n        :returns: A tuple of 3 elements.\n                  1. A dict of headers to set on the response.\n                  2. The response body as a string.\n                  3. The response status code as an integer.\n\n        An example of a valid request::\n\n            >>> from your_validator import your_validator\n            >>> from oauthlib.oauth1 import AccessTokenEndpoint\n            >>> endpoint = AccessTokenEndpoint(your_validator)\n            >>> h, b, s = endpoint.create_access_token_response(\n            ...     'https://your.provider/access_token?foo=bar',\n            ...     headers={\n            ...         'Authorization': 'OAuth oauth_token=234lsdkf....'\n            ...     },\n            ...     credentials={\n            ...         'my_specific': 'argument',\n            ...     })\n            >>> h\n            {'Content-Type': 'application/x-www-form-urlencoded'}\n            >>> b\n            'oauth_token=lsdkfol23w54jlksdef&oauth_token_secret=qwe089234lkjsdf&oauth_authorized_realms=movies+pics&my_specific=argument'\n            >>> s\n            200\n\n        An response to invalid request would have a different body and status::\n\n            >>> b\n            'error=invalid_request&description=missing+resource+owner+key'\n            >>> s\n            400\n\n        The same goes for an an unauthorized request:\n\n            >>> b\n            ''\n            >>> s\n            401\n        \"\"\"\n        resp_headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n        try:\n            request = self._create_request(uri, http_method, body, headers)\n            valid, processed_request = self.validate_access_token_request(\n                request)\n            if valid:\n                token = self.create_access_token(request, credentials or {})\n                self.request_validator.invalidate_request_token(\n                    request.client_key,\n                    request.resource_owner_key,\n                    request)\n                return resp_headers, token, 200\n            else:\n                return {}, None, 401\n        except errors.OAuth1Error as e:\n            return resp_headers, e.urlencoded, e.status_code\n\n    def validate_access_token_request(self, request):\n        \"\"\"Validate an access token request.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :raises: OAuth1Error if the request is invalid.\n        :returns: A tuple of 2 elements.\n                  1. The validation result (True or False).\n                  2. The request object.\n        \"\"\"\n        self._check_transport_security(request)\n        self._check_mandatory_parameters(request)\n\n        if not request.resource_owner_key:\n            raise errors.InvalidRequestError(\n                description='Missing resource owner.')\n\n        if not self.request_validator.check_request_token(\n                request.resource_owner_key):\n            raise errors.InvalidRequestError(\n                description='Invalid resource owner key format.')\n\n        if not request.verifier:\n            raise errors.InvalidRequestError(\n                description='Missing verifier.')\n\n        if not self.request_validator.check_verifier(request.verifier):\n            raise errors.InvalidRequestError(\n                description='Invalid verifier format.')\n\n        if not self.request_validator.validate_timestamp_and_nonce(\n                request.client_key, request.timestamp, request.nonce, request,\n                request_token=request.resource_owner_key):\n            return False, request\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid client credentials.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy client is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable client enumeration\n        valid_client = self.request_validator.validate_client_key(\n            request.client_key, request)\n        if not valid_client:\n            request.client_key = self.request_validator.dummy_client\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid or expired token.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy token is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable resource owner enumeration\n        valid_resource_owner = self.request_validator.validate_request_token(\n            request.client_key, request.resource_owner_key, request)\n        if not valid_resource_owner:\n            request.resource_owner_key = self.request_validator.dummy_request_token\n\n        # The server MUST verify (Section 3.2) the validity of the request,\n        # ensure that the resource owner has authorized the provisioning of\n        # token credentials to the client, and ensure that the temporary\n        # credentials have not expired or been used before.  The server MUST\n        # also verify the verification code received from the client.\n        # .. _`Section 3.2`: https://tools.ietf.org/html/rfc5849#section-3.2\n        #\n        # Note that early exit would enable resource owner authorization\n        # verifier enumertion.\n        valid_verifier = self.request_validator.validate_verifier(\n            request.client_key,\n            request.resource_owner_key,\n            request.verifier,\n            request)\n\n        valid_signature = self._check_signature(request, is_token_request=True)\n\n        # log the results to the validator_log\n        # this lets us handle internal reporting and analysis\n        request.validator_log['client'] = valid_client\n        request.validator_log['resource_owner'] = valid_resource_owner\n        request.validator_log['verifier'] = valid_verifier\n        request.validator_log['signature'] = valid_signature\n\n        # We delay checking validity until the very end, using dummy values for\n        # calculations and fetching secrets/keys to ensure the flow of every\n        # request remains almost identical regardless of whether valid values\n        # have been supplied. This ensures near constant time execution and\n        # prevents malicious users from guessing sensitive information\n        v = all((valid_client, valid_resource_owner, valid_verifier,\n                 valid_signature))\n        if not v:\n            log.info(\"[Failure] request verification failed.\")\n            log.info(\"Valid client:, %s\", valid_client)\n            log.info(\"Valid token:, %s\", valid_resource_owner)\n            log.info(\"Valid verifier:, %s\", valid_verifier)\n            log.info(\"Valid signature:, %s\", valid_signature)\n        return v, request\n", "oauthlib/oauth1/rfc5849/endpoints/resource.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.resource\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of the resource protection provider logic of\nOAuth 1.0 RFC 5849.\n\"\"\"\nimport logging\n\nfrom .. import errors\nfrom .base import BaseEndpoint\n\nlog = logging.getLogger(__name__)\n\n\nclass ResourceEndpoint(BaseEndpoint):\n\n    \"\"\"An endpoint responsible for protecting resources.\n\n    Typical use is to instantiate with a request validator and invoke the\n    ``validate_protected_resource_request`` in a decorator around a view\n    function. If the request is valid, invoke and return the response of the\n    view. If invalid create and return an error response directly from the\n    decorator.\n\n    See :doc:`/oauth1/validator` for details on which validator methods to implement\n    for this endpoint.\n\n    An example decorator::\n\n        from functools import wraps\n        from your_validator import your_validator\n        from oauthlib.oauth1 import ResourceEndpoint\n        endpoint = ResourceEndpoint(your_validator)\n\n        def require_oauth(realms=None):\n            def decorator(f):\n                @wraps(f)\n                def wrapper(request, *args, **kwargs):\n                    v, r = provider.validate_protected_resource_request(\n                            request.url,\n                            http_method=request.method,\n                            body=request.data,\n                            headers=request.headers,\n                            realms=realms or [])\n                    if v:\n                        return f(*args, **kwargs)\n                    else:\n                        return abort(403)\n    \"\"\"\n\n    def validate_protected_resource_request(self, uri, http_method='GET',\n                                            body=None, headers=None, realms=None):\n        \"\"\"Create a request token response, with a new request token if valid.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :param realms: A list of realms the resource is protected under.\n                       This will be supplied to the ``validate_realms``\n                       method of the request validator.\n        :returns: A tuple of 2 elements.\n                  1. True if valid, False otherwise.\n                  2. An oauthlib.common.Request object.\n        \"\"\"\n        try:\n            request = self._create_request(uri, http_method, body, headers)\n        except errors.OAuth1Error:\n            return False, None\n\n        try:\n            self._check_transport_security(request)\n            self._check_mandatory_parameters(request)\n        except errors.OAuth1Error:\n            return False, request\n\n        if not request.resource_owner_key:\n            return False, request\n\n        if not self.request_validator.check_access_token(\n                request.resource_owner_key):\n            return False, request\n\n        if not self.request_validator.validate_timestamp_and_nonce(\n                request.client_key, request.timestamp, request.nonce, request,\n                access_token=request.resource_owner_key):\n            return False, request\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid client credentials.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy client is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable client enumeration\n        valid_client = self.request_validator.validate_client_key(\n            request.client_key, request)\n        if not valid_client:\n            request.client_key = self.request_validator.dummy_client\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid or expired token.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy token is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable resource owner enumeration\n        valid_resource_owner = self.request_validator.validate_access_token(\n            request.client_key, request.resource_owner_key, request)\n        if not valid_resource_owner:\n            request.resource_owner_key = self.request_validator.dummy_access_token\n\n        # Note that `realm`_ is only used in authorization headers and how\n        # it should be interpreted is not included in the OAuth spec.\n        # However they could be seen as a scope or realm to which the\n        # client has access and as such every client should be checked\n        # to ensure it is authorized access to that scope or realm.\n        # .. _`realm`: https://tools.ietf.org/html/rfc2617#section-1.2\n        #\n        # Note that early exit would enable client realm access enumeration.\n        #\n        # The require_realm indicates this is the first step in the OAuth\n        # workflow where a client requests access to a specific realm.\n        # This first step (obtaining request token) need not require a realm\n        # and can then be identified by checking the require_resource_owner\n        # flag and absence of realm.\n        #\n        # Clients obtaining an access token will not supply a realm and it will\n        # not be checked. Instead the previously requested realm should be\n        # transferred from the request token to the access token.\n        #\n        # Access to protected resources will always validate the realm but note\n        # that the realm is now tied to the access token and not provided by\n        # the client.\n        valid_realm = self.request_validator.validate_realms(request.client_key,\n                                                             request.resource_owner_key, request, uri=request.uri,\n                                                             realms=realms)\n\n        valid_signature = self._check_signature(request)\n\n        # log the results to the validator_log\n        # this lets us handle internal reporting and analysis\n        request.validator_log['client'] = valid_client\n        request.validator_log['resource_owner'] = valid_resource_owner\n        request.validator_log['realm'] = valid_realm\n        request.validator_log['signature'] = valid_signature\n\n        # We delay checking validity until the very end, using dummy values for\n        # calculations and fetching secrets/keys to ensure the flow of every\n        # request remains almost identical regardless of whether valid values\n        # have been supplied. This ensures near constant time execution and\n        # prevents malicious users from guessing sensitive information\n        v = all((valid_client, valid_resource_owner, valid_realm,\n                 valid_signature))\n        if not v:\n            log.info(\"[Failure] request verification failed.\")\n            log.info(\"Valid client: %s\", valid_client)\n            log.info(\"Valid token: %s\", valid_resource_owner)\n            log.info(\"Valid realm: %s\", valid_realm)\n            log.info(\"Valid signature: %s\", valid_signature)\n        return v, request\n", "oauthlib/oauth1/rfc5849/endpoints/request_token.py": "# -*- coding: utf-8 -*-\n\"\"\"\noauthlib.oauth1.rfc5849.endpoints.request_token\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of the request token provider logic of\nOAuth 1.0 RFC 5849. It validates the correctness of request token requests,\ncreates and persists tokens as well as create the proper response to be\nreturned to the client.\n\"\"\"\nimport logging\n\nfrom oauthlib.common import urlencode\n\nfrom .. import errors\nfrom .base import BaseEndpoint\n\nlog = logging.getLogger(__name__)\n\n\nclass RequestTokenEndpoint(BaseEndpoint):\n\n    \"\"\"An endpoint responsible for providing OAuth 1 request tokens.\n\n    Typical use is to instantiate with a request validator and invoke the\n    ``create_request_token_response`` from a view function. The tuple returned\n    has all information necessary (body, status, headers) to quickly form\n    and return a proper response. See :doc:`/oauth1/validator` for details on which\n    validator methods to implement for this endpoint.\n    \"\"\"\n\n    def create_request_token(self, request, credentials):\n        \"\"\"Create and save a new request token.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :param credentials: A dict of extra token credentials.\n        :returns: The token as an urlencoded string.\n        \"\"\"\n        token = {\n            'oauth_token': self.token_generator(),\n            'oauth_token_secret': self.token_generator(),\n            'oauth_callback_confirmed': 'true'\n        }\n        token.update(credentials)\n        self.request_validator.save_request_token(token, request)\n        return urlencode(token.items())\n\n    def create_request_token_response(self, uri, http_method='GET', body=None,\n                                      headers=None, credentials=None):\n        \"\"\"Create a request token response, with a new request token if valid.\n\n        :param uri: The full URI of the token request.\n        :param http_method: A valid HTTP verb, i.e. GET, POST, PUT, HEAD, etc.\n        :param body: The request body as a string.\n        :param headers: The request headers as a dict.\n        :param credentials: A list of extra credentials to include in the token.\n        :returns: A tuple of 3 elements.\n                  1. A dict of headers to set on the response.\n                  2. The response body as a string.\n                  3. The response status code as an integer.\n\n        An example of a valid request::\n\n            >>> from your_validator import your_validator\n            >>> from oauthlib.oauth1 import RequestTokenEndpoint\n            >>> endpoint = RequestTokenEndpoint(your_validator)\n            >>> h, b, s = endpoint.create_request_token_response(\n            ...     'https://your.provider/request_token?foo=bar',\n            ...     headers={\n            ...         'Authorization': 'OAuth realm=movies user, oauth_....'\n            ...     },\n            ...     credentials={\n            ...         'my_specific': 'argument',\n            ...     })\n            >>> h\n            {'Content-Type': 'application/x-www-form-urlencoded'}\n            >>> b\n            'oauth_token=lsdkfol23w54jlksdef&oauth_token_secret=qwe089234lkjsdf&oauth_callback_confirmed=true&my_specific=argument'\n            >>> s\n            200\n\n        An response to invalid request would have a different body and status::\n\n            >>> b\n            'error=invalid_request&description=missing+callback+uri'\n            >>> s\n            400\n\n        The same goes for an an unauthorized request:\n\n            >>> b\n            ''\n            >>> s\n            401\n        \"\"\"\n        resp_headers = {'Content-Type': 'application/x-www-form-urlencoded'}\n        try:\n            request = self._create_request(uri, http_method, body, headers)\n            valid, processed_request = self.validate_request_token_request(\n                request)\n            if valid:\n                token = self.create_request_token(request, credentials or {})\n                return resp_headers, token, 200\n            else:\n                return {}, None, 401\n        except errors.OAuth1Error as e:\n            return resp_headers, e.urlencoded, e.status_code\n\n    def validate_request_token_request(self, request):\n        \"\"\"Validate a request token request.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :raises: OAuth1Error if the request is invalid.\n        :returns: A tuple of 2 elements.\n                  1. The validation result (True or False).\n                  2. The request object.\n        \"\"\"\n        self._check_transport_security(request)\n        self._check_mandatory_parameters(request)\n\n        if request.realm:\n            request.realms = request.realm.split(' ')\n        else:\n            request.realms = self.request_validator.get_default_realms(\n                request.client_key, request)\n        if not self.request_validator.check_realms(request.realms):\n            raise errors.InvalidRequestError(\n                description='Invalid realm {}. Allowed are {!r}.'.format(\n                    request.realms, self.request_validator.realms))\n\n        if not request.redirect_uri:\n            raise errors.InvalidRequestError(\n                description='Missing callback URI.')\n\n        if not self.request_validator.validate_timestamp_and_nonce(\n                request.client_key, request.timestamp, request.nonce, request,\n                request_token=request.resource_owner_key):\n            return False, request\n\n        # The server SHOULD return a 401 (Unauthorized) status code when\n        # receiving a request with invalid client credentials.\n        # Note: This is postponed in order to avoid timing attacks, instead\n        # a dummy client is assigned and used to maintain near constant\n        # time request verification.\n        #\n        # Note that early exit would enable client enumeration\n        valid_client = self.request_validator.validate_client_key(\n            request.client_key, request)\n        if not valid_client:\n            request.client_key = self.request_validator.dummy_client\n\n        # Note that `realm`_ is only used in authorization headers and how\n        # it should be interpreted is not included in the OAuth spec.\n        # However they could be seen as a scope or realm to which the\n        # client has access and as such every client should be checked\n        # to ensure it is authorized access to that scope or realm.\n        # .. _`realm`: https://tools.ietf.org/html/rfc2617#section-1.2\n        #\n        # Note that early exit would enable client realm access enumeration.\n        #\n        # The require_realm indicates this is the first step in the OAuth\n        # workflow where a client requests access to a specific realm.\n        # This first step (obtaining request token) need not require a realm\n        # and can then be identified by checking the require_resource_owner\n        # flag and absence of realm.\n        #\n        # Clients obtaining an access token will not supply a realm and it will\n        # not be checked. Instead the previously requested realm should be\n        # transferred from the request token to the access token.\n        #\n        # Access to protected resources will always validate the realm but note\n        # that the realm is now tied to the access token and not provided by\n        # the client.\n        valid_realm = self.request_validator.validate_requested_realms(\n            request.client_key, request.realms, request)\n\n        # Callback is normally never required, except for requests for\n        # a Temporary Credential as described in `Section 2.1`_\n        # .._`Section 2.1`: https://tools.ietf.org/html/rfc5849#section-2.1\n        valid_redirect = self.request_validator.validate_redirect_uri(\n            request.client_key, request.redirect_uri, request)\n        if not request.redirect_uri:\n            raise NotImplementedError('Redirect URI must either be provided '\n                                      'or set to a default during validation.')\n\n        valid_signature = self._check_signature(request)\n\n        # log the results to the validator_log\n        # this lets us handle internal reporting and analysis\n        request.validator_log['client'] = valid_client\n        request.validator_log['realm'] = valid_realm\n        request.validator_log['callback'] = valid_redirect\n        request.validator_log['signature'] = valid_signature\n\n        # We delay checking validity until the very end, using dummy values for\n        # calculations and fetching secrets/keys to ensure the flow of every\n        # request remains almost identical regardless of whether valid values\n        # have been supplied. This ensures near constant time execution and\n        # prevents malicious users from guessing sensitive information\n        v = all((valid_client, valid_realm, valid_redirect, valid_signature))\n        if not v:\n            log.info(\"[Failure] request verification failed.\")\n            log.info(\"Valid client: %s.\", valid_client)\n            log.info(\"Valid realm: %s.\", valid_realm)\n            log.info(\"Valid callback: %s.\", valid_redirect)\n            log.info(\"Valid signature: %s.\", valid_signature)\n        return v, request\n", "oauthlib/openid/__init__.py": "\"\"\"\noauthlib.openid\n~~~~~~~~~~~~~~\n\n\"\"\"\nfrom .connect.core.endpoints import Server, UserInfoEndpoint\nfrom .connect.core.request_validator import RequestValidator\n", "oauthlib/openid/connect/__init__.py": "", "oauthlib/openid/connect/core/tokens.py": "\"\"\"\nauthlib.openid.connect.core.tokens\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module contains methods for adding JWT tokens to requests.\n\"\"\"\nfrom oauthlib.oauth2.rfc6749.tokens import (\n    TokenBase, get_token_from_header, random_token_generator,\n)\n\n\nclass JWTToken(TokenBase):\n    __slots__ = (\n        'request_validator', 'token_generator',\n        'refresh_token_generator', 'expires_in'\n    )\n\n    def __init__(self, request_validator=None, token_generator=None,\n                 expires_in=None, refresh_token_generator=None):\n        self.request_validator = request_validator\n        self.token_generator = token_generator or random_token_generator\n        self.refresh_token_generator = (\n            refresh_token_generator or self.token_generator\n        )\n        self.expires_in = expires_in or 3600\n\n    def create_token(self, request, refresh_token=False):\n        \"\"\"Create a JWT Token, using requestvalidator method.\"\"\"\n\n        expires_in = self.expires_in(request) if callable(self.expires_in) else self.expires_in\n\n        request.expires_in = expires_in\n\n        return self.request_validator.get_jwt_bearer_token(None, None, request)\n\n    def validate_request(self, request):\n        token = get_token_from_header(request)\n        return self.request_validator.validate_jwt_bearer_token(\n            token, request.scopes, request)\n\n    def estimate_type(self, request):\n        token = get_token_from_header(request)\n        if token and token.startswith('ey') and token.count('.') in (2, 4):\n            return 10\n        return 0\n", "oauthlib/openid/connect/core/exceptions.py": "\"\"\"\noauthlib.oauth2.rfc6749.errors\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nError used both by OAuth 2 clients and providers to represent the spec\ndefined error responses for all four core grant types.\n\"\"\"\nfrom oauthlib.oauth2.rfc6749.errors import FatalClientError, OAuth2Error\n\n\nclass FatalOpenIDClientError(FatalClientError):\n    pass\n\n\nclass OpenIDClientError(OAuth2Error):\n    pass\n\n\nclass InteractionRequired(OpenIDClientError):\n    \"\"\"\n    The Authorization Server requires End-User interaction to proceed.\n\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface for End-User interaction.\n    \"\"\"\n    error = 'interaction_required'\n    status_code = 401\n\n\nclass LoginRequired(OpenIDClientError):\n    \"\"\"\n    The Authorization Server requires End-User authentication.\n\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface for End-User authentication.\n    \"\"\"\n    error = 'login_required'\n    status_code = 401\n\n\nclass AccountSelectionRequired(OpenIDClientError):\n    \"\"\"\n    The End-User is REQUIRED to select a session at the Authorization Server.\n\n    The End-User MAY be authenticated at the Authorization Server with\n    different associated accounts, but the End-User did not select a session.\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface to prompt for a session to\n    use.\n    \"\"\"\n    error = 'account_selection_required'\n\n\nclass ConsentRequired(OpenIDClientError):\n    \"\"\"\n    The Authorization Server requires End-User consent.\n\n    This error MAY be returned when the prompt parameter value in the\n    Authentication Request is none, but the Authentication Request cannot be\n    completed without displaying a user interface for End-User consent.\n    \"\"\"\n    error = 'consent_required'\n    status_code = 401\n\n\nclass InvalidRequestURI(OpenIDClientError):\n    \"\"\"\n    The request_uri in the Authorization Request returns an error or\n    contains invalid data.\n    \"\"\"\n    error = 'invalid_request_uri'\n    description = ('The request_uri in the Authorization Request returns an '\n                  'error or contains invalid data.')\n\n\nclass InvalidRequestObject(OpenIDClientError):\n    \"\"\"\n    The request parameter contains an invalid Request Object.\n    \"\"\"\n    error = 'invalid_request_object'\n    description = 'The request parameter contains an invalid Request Object.'\n\n\nclass RequestNotSupported(OpenIDClientError):\n    \"\"\"\n    The OP does not support use of the request parameter.\n    \"\"\"\n    error = 'request_not_supported'\n    description = 'The request parameter is not supported.'\n\n\nclass RequestURINotSupported(OpenIDClientError):\n    \"\"\"\n    The OP does not support use of the request_uri parameter.\n    \"\"\"\n    error = 'request_uri_not_supported'\n    description = 'The request_uri parameter is not supported.'\n\n\nclass RegistrationNotSupported(OpenIDClientError):\n    \"\"\"\n    The OP does not support use of the registration parameter.\n    \"\"\"\n    error = 'registration_not_supported'\n    description = 'The registration parameter is not supported.'\n\n\nclass InvalidTokenError(OAuth2Error):\n    \"\"\"\n    The access token provided is expired, revoked, malformed, or\n    invalid for other reasons.  The resource SHOULD respond with\n    the HTTP 401 (Unauthorized) status code.  The client MAY\n    request a new access token and retry the protected resource\n    request.\n    \"\"\"\n    error = 'invalid_token'\n    status_code = 401\n    description = (\"The access token provided is expired, revoked, malformed, \"\n                   \"or invalid for other reasons.\")\n\n\nclass InsufficientScopeError(OAuth2Error):\n    \"\"\"\n    The request requires higher privileges than provided by the\n    access token.  The resource server SHOULD respond with the HTTP\n    403 (Forbidden) status code and MAY include the \"scope\"\n    attribute with the scope necessary to access the protected\n    resource.\n    \"\"\"\n    error = 'insufficient_scope'\n    status_code = 403\n    description = (\"The request requires higher privileges than provided by \"\n                   \"the access token.\")\n\n\ndef raise_from_error(error, params=None):\n    import inspect\n    import sys\n    kwargs = {\n        'description': params.get('error_description'),\n        'uri': params.get('error_uri'),\n        'state': params.get('state')\n    }\n    for _, cls in inspect.getmembers(sys.modules[__name__], inspect.isclass):\n        if cls.error == error:\n            raise cls(**kwargs)\n", "oauthlib/openid/connect/core/__init__.py": "", "oauthlib/openid/connect/core/request_validator.py": "\"\"\"\noauthlib.openid.connect.core.request_validator\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib.oauth2.rfc6749.request_validator import (\n    RequestValidator as OAuth2RequestValidator,\n)\n\nlog = logging.getLogger(__name__)\n\n\nclass RequestValidator(OAuth2RequestValidator):\n\n    def get_authorization_code_scopes(self, client_id, code, redirect_uri, request):\n        \"\"\" Extracts scopes from saved authorization code.\n\n        The scopes returned by this method is used to route token requests\n        based on scopes passed to Authorization Code requests.\n\n        With that the token endpoint knows when to include OpenIDConnect\n        id_token in token response only based on authorization code scopes.\n\n        Only code param should be sufficient to retrieve grant code from\n        any storage you are using, `client_id` and `redirect_uri` can have a\n        blank value `\"\"` don't forget to check it before using those values\n        in a select query if a database is used.\n\n        :param client_id: Unicode client identifier\n        :param code: Unicode authorization code grant\n        :param redirect_uri: Unicode absolute URI\n        :return: A list of scope\n\n        Method is used by:\n            - Authorization Token Grant Dispatcher\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_authorization_code_nonce(self, client_id, code, redirect_uri, request):\n        \"\"\" Extracts nonce from saved authorization code.\n\n        If present in the Authentication Request, Authorization\n        Servers MUST include a nonce Claim in the ID Token with the\n        Claim Value being the nonce value sent in the Authentication\n        Request. Authorization Servers SHOULD perform no other\n        processing on nonce values used. The nonce value is a\n        case-sensitive string.\n\n        Only code param should be sufficient to retrieve grant code from\n        any storage you are using. However, `client_id` and `redirect_uri`\n        have been validated and can be used also.\n\n        :param client_id: Unicode client identifier\n        :param code: Unicode authorization code grant\n        :param redirect_uri: Unicode absolute URI\n        :return: Unicode nonce\n\n        Method is used by:\n            - Authorization Token Grant Dispatcher\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_jwt_bearer_token(self, token, token_handler, request):\n        \"\"\"Get JWT Bearer token or OpenID Connect ID token\n\n        If using OpenID Connect this SHOULD call `oauthlib.oauth2.RequestValidator.get_id_token`\n\n        :param token: A Bearer token dict\n        :param token_handler: the token handler (BearerToken class)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :return: The JWT Bearer token or OpenID Connect ID token (a JWS signed JWT)\n\n        Method is used by JWT Bearer and OpenID Connect tokens:\n            - JWTToken.create_token\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_id_token(self, token, token_handler, request):\n        \"\"\"Get OpenID Connect ID token\n\n        This method is OPTIONAL and is NOT RECOMMENDED.\n        `finalize_id_token` SHOULD be implemented instead. However, if you\n        want a full control over the minting of the `id_token`, you\n        MAY want to override `get_id_token` instead of using\n        `finalize_id_token`.\n\n        In the OpenID Connect workflows when an ID Token is requested this method is called.\n        Subclasses should implement the construction, signing and optional encryption of the\n        ID Token as described in the OpenID Connect spec.\n\n        In addition to the standard OAuth2 request properties, the request may also contain\n        these OIDC specific properties which are useful to this method:\n\n            - nonce, if workflow is implicit or hybrid and it was provided\n            - claims, if provided to the original Authorization Code request\n\n        The token parameter is a dict which may contain an ``access_token`` entry, in which\n        case the resulting ID Token *should* include a calculated ``at_hash`` claim.\n\n        Similarly, when the request parameter has a ``code`` property defined, the ID Token\n        *should* include a calculated ``c_hash`` claim.\n\n        http://openid.net/specs/openid-connect-core-1_0.html (sections `3.1.3.6`_, `3.2.2.10`_, `3.3.2.11`_)\n\n        .. _`3.1.3.6`: http://openid.net/specs/openid-connect-core-1_0.html#CodeIDToken\n        .. _`3.2.2.10`: http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDToken\n        .. _`3.3.2.11`: http://openid.net/specs/openid-connect-core-1_0.html#HybridIDToken\n\n        :param token: A Bearer token dict\n        :param token_handler: the token handler (BearerToken class)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :return: The ID Token (a JWS signed JWT)\n        \"\"\"\n        return None\n\n    def finalize_id_token(self, id_token, token, token_handler, request):\n        \"\"\"Finalize OpenID Connect ID token & Sign or Encrypt.\n\n        In the OpenID Connect workflows when an ID Token is requested\n        this method is called.  Subclasses should implement the\n        construction, signing and optional encryption of the ID Token\n        as described in the OpenID Connect spec.\n\n        The `id_token` parameter is a dict containing a couple of OIDC\n        technical fields related to the specification. Prepopulated\n        attributes are:\n\n        - `aud`, equals to `request.client_id`.\n        - `iat`, equals to current time.\n        - `nonce`, if present, is equals to the `nonce` from the\n          authorization request.\n        - `at_hash`, hash of `access_token`, if relevant.\n        - `c_hash`, hash of `code`, if relevant.\n\n        This method MUST provide required fields as below:\n\n        - `iss`, REQUIRED. Issuer Identifier for the Issuer of the response.\n        - `sub`, REQUIRED. Subject Identifier\n        - `exp`, REQUIRED. Expiration time on or after which the ID\n          Token MUST NOT be accepted by the RP when performing\n          authentication with the OP.\n\n        Additional claims must be added, note that `request.scope`\n        should be used to determine the list of claims.\n\n        More information can be found at `OpenID Connect Core#Claims`_\n\n        .. _`OpenID Connect Core#Claims`: https://openid.net/specs/openid-connect-core-1_0.html#Claims\n\n        :param id_token: A dict containing technical fields of id_token\n        :param token: A Bearer token dict\n        :param token_handler: the token handler (BearerToken class)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :return: The ID Token (a JWS signed JWT or JWE encrypted JWT)\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_jwt_bearer_token(self, token, scopes, request):\n        \"\"\"Ensure the JWT Bearer token or OpenID Connect ID token are valids and authorized access to scopes.\n\n        If using OpenID Connect this SHOULD call `oauthlib.oauth2.RequestValidator.get_id_token`\n\n        If not using OpenID Connect this can `return None` to avoid 5xx rather 401/3 response.\n\n        OpenID connect core 1.0 describe how to validate an id_token:\n            - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#HybridIDTValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#HybridIDTValidation2\n\n        :param token: Unicode Bearer token\n        :param scopes: List of scopes (defined by you)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is indirectly used by all core OpenID connect JWT token issuing grant types:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Hybrid Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_id_token(self, token, scopes, request):\n        \"\"\"Ensure the id token is valid and authorized access to scopes.\n\n        OpenID connect core 1.0 describe how to validate an id_token:\n            - http://openid.net/specs/openid-connect-core-1_0.html#IDTokenValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#ImplicitIDTValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#HybridIDTValidation\n            - http://openid.net/specs/openid-connect-core-1_0.html#HybridIDTValidation2\n\n        :param token: Unicode Bearer token\n        :param scopes: List of scopes (defined by you)\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is indirectly used by all core OpenID connect JWT token issuing grant types:\n            - Authorization Code Grant\n            - Implicit Grant\n            - Hybrid Grant\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_silent_authorization(self, request):\n        \"\"\"Ensure the logged in user has authorized silent OpenID authorization.\n\n        Silent OpenID authorization allows access tokens and id tokens to be\n        granted to clients without any user prompt or interaction.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - OpenIDConnectAuthCode\n            - OpenIDConnectImplicit\n            - OpenIDConnectHybrid\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_silent_login(self, request):\n        \"\"\"Ensure session user has authorized silent OpenID login.\n\n        If no user is logged in or has not authorized silent login, this\n        method should return False.\n\n        If the user is logged in but associated with multiple accounts and\n        not selected which one to link to the token then this method should\n        raise an oauthlib.oauth2.AccountSelectionRequired error.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - OpenIDConnectAuthCode\n            - OpenIDConnectImplicit\n            - OpenIDConnectHybrid\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def validate_user_match(self, id_token_hint, scopes, claims, request):\n        \"\"\"Ensure client supplied user id hint matches session user.\n\n        If the sub claim or id_token_hint is supplied then the session\n        user must match the given ID.\n\n        :param id_token_hint: User identifier string.\n        :param scopes: List of OAuth 2 scopes and OpenID claims (strings).\n        :param claims: OpenID Connect claims dict.\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            - OpenIDConnectAuthCode\n            - OpenIDConnectImplicit\n            - OpenIDConnectHybrid\n        \"\"\"\n        raise NotImplementedError('Subclasses must implement this method.')\n\n    def get_userinfo_claims(self, request):\n        \"\"\"Return the UserInfo claims in JSON or Signed or Encrypted.\n\n        The UserInfo Claims MUST be returned as the members of a JSON object\n         unless a signed or encrypted response was requested during Client\n         Registration. The Claims defined in Section 5.1 can be returned, as can\n         additional Claims not specified there.\n\n        For privacy reasons, OpenID Providers MAY elect to not return values for\n        some requested Claims.\n\n        If a Claim is not returned, that Claim Name SHOULD be omitted from the\n        JSON object representing the Claims; it SHOULD NOT be present with a\n        null or empty string value.\n\n        The sub (subject) Claim MUST always be returned in the UserInfo\n        Response.\n\n        Upon receipt of the UserInfo Request, the UserInfo Endpoint MUST return\n        the JSON Serialization of the UserInfo Response as in Section 13.3 in\n        the HTTP response body unless a different format was specified during\n        Registration [OpenID.Registration].\n\n        If the UserInfo Response is signed and/or encrypted, then the Claims are\n        returned in a JWT and the content-type MUST be application/jwt. The\n        response MAY be encrypted without also being signed. If both signing and\n        encryption are requested, the response MUST be signed then encrypted,\n        with the result being a Nested JWT, as defined in [JWT].\n\n        If signed, the UserInfo Response SHOULD contain the Claims iss (issuer)\n        and aud (audience) as members. The iss value SHOULD be the OP's Issuer\n        Identifier URL. The aud value SHOULD be or include the RP's Client ID\n        value.\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: Claims as a dict OR JWT/JWS/JWE as a string\n\n        Method is used by:\n            UserInfoEndpoint\n        \"\"\"\n\n    def refresh_id_token(self, request):\n        \"\"\"Whether the id token should be refreshed. Default, True\n\n        :param request: OAuthlib request.\n        :type request: oauthlib.common.Request\n        :rtype: True or False\n\n        Method is used by:\n            RefreshTokenGrant\n        \"\"\"\n        return True\n", "oauthlib/openid/connect/core/grant_types/hybrid.py": "\"\"\"\noauthlib.openid.connect.core.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib.oauth2.rfc6749.errors import InvalidRequestError\nfrom oauthlib.oauth2.rfc6749.grant_types.authorization_code import (\n    AuthorizationCodeGrant as OAuth2AuthorizationCodeGrant,\n)\n\nfrom ..request_validator import RequestValidator\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass HybridGrant(GrantTypeBase):\n\n    def __init__(self, request_validator=None, **kwargs):\n        self.request_validator = request_validator or RequestValidator()\n\n        self.proxy_target = OAuth2AuthorizationCodeGrant(\n            request_validator=request_validator, **kwargs)\n        # All hybrid response types should be fragment-encoded.\n        self.proxy_target.default_response_mode = \"fragment\"\n        self.register_response_type('code id_token')\n        self.register_response_type('code token')\n        self.register_response_type('code id_token token')\n        self.custom_validators.post_auth.append(\n            self.openid_authorization_validator)\n        # Hybrid flows can return the id_token from the authorization\n        # endpoint as part of the 'code' response\n        self.register_code_modifier(self.add_token)\n        self.register_code_modifier(self.add_id_token)\n        self.register_token_modifier(self.add_id_token)\n\n    def add_id_token(self, token, token_handler, request):\n        return super().add_id_token(token, token_handler, request, nonce=request.nonce)\n\n    def openid_authorization_validator(self, request):\n        \"\"\"Additional validation when following the Authorization Code flow.\n        \"\"\"\n        request_info = super().openid_authorization_validator(request)\n        if not request_info:  # returns immediately if OAuth2.0\n            return request_info\n\n        # REQUIRED if the Response Type of the request is `code\n        # id_token` or `code id_token token` and OPTIONAL when the\n        # Response Type of the request is `code token`. It is a string\n        # value used to associate a Client session with an ID Token,\n        # and to mitigate replay attacks. The value is passed through\n        # unmodified from the Authentication Request to the ID\n        # Token. Sufficient entropy MUST be present in the `nonce`\n        # values used to prevent attackers from guessing values. For\n        # implementation notes, see Section 15.5.2.\n        if request.response_type in [\"code id_token\", \"code id_token token\"] and not request.nonce:\n            raise InvalidRequestError(\n                request=request,\n                description='Request is missing mandatory nonce parameter.'\n            )\n        return request_info\n", "oauthlib/openid/connect/core/grant_types/authorization_code.py": "\"\"\"\noauthlib.openid.connect.core.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib.oauth2.rfc6749.grant_types.authorization_code import (\n    AuthorizationCodeGrant as OAuth2AuthorizationCodeGrant,\n)\n\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass AuthorizationCodeGrant(GrantTypeBase):\n\n    def __init__(self, request_validator=None, **kwargs):\n        self.proxy_target = OAuth2AuthorizationCodeGrant(\n            request_validator=request_validator, **kwargs)\n        self.custom_validators.post_auth.append(\n            self.openid_authorization_validator)\n        self.register_token_modifier(self.add_id_token)\n\n    def add_id_token(self, token, token_handler, request):\n        \"\"\"\n        Construct an initial version of id_token, and let the\n        request_validator sign or encrypt it.\n\n        The authorization_code version of this method is used to\n        retrieve the nonce accordingly to the code storage.\n        \"\"\"\n        # Treat it as normal OAuth 2 auth code request if openid is not present\n        if not request.scopes or 'openid' not in request.scopes:\n            return token\n\n        nonce = self.request_validator.get_authorization_code_nonce(\n            request.client_id,\n            request.code,\n            request.redirect_uri,\n            request\n        )\n        return super().add_id_token(token, token_handler, request, nonce=nonce)\n", "oauthlib/openid/connect/core/grant_types/refresh_token.py": "\"\"\"\noauthlib.openid.connect.core.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib.oauth2.rfc6749.grant_types.refresh_token import (\n    RefreshTokenGrant as OAuth2RefreshTokenGrant,\n)\n\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass RefreshTokenGrant(GrantTypeBase):\n\n    def __init__(self, request_validator=None, **kwargs):\n        self.proxy_target = OAuth2RefreshTokenGrant(\n            request_validator=request_validator, **kwargs)\n        self.register_token_modifier(self.add_id_token)\n\n    def add_id_token(self, token, token_handler, request):\n        \"\"\"\n        Construct an initial version of id_token, and let the\n        request_validator sign or encrypt it.\n\n        The authorization_code version of this method is used to\n        retrieve the nonce accordingly to the code storage.\n        \"\"\"\n        if not self.request_validator.refresh_id_token(request):\n            return token\n\n        return super().add_id_token(token, token_handler, request)\n", "oauthlib/openid/connect/core/grant_types/base.py": "import base64\nimport hashlib\nimport logging\nimport time\nfrom json import loads\n\nfrom oauthlib.oauth2.rfc6749.errors import (\n    ConsentRequired, InvalidRequestError, LoginRequired,\n)\n\nlog = logging.getLogger(__name__)\n\n\nclass GrantTypeBase:\n\n    # Just proxy the majority of method calls through to the\n    # proxy_target grant type handler, which will usually be either\n    # the standard OAuth2 AuthCode or Implicit grant types.\n    def __getattr__(self, attr):\n        return getattr(self.proxy_target, attr)\n\n    def __setattr__(self, attr, value):\n        proxied_attrs = {'refresh_token', 'response_types'}\n        if attr in proxied_attrs:\n            setattr(self.proxy_target, attr, value)\n        else:\n            super(OpenIDConnectBase, self).__setattr__(attr, value)\n\n    def validate_authorization_request(self, request):\n        \"\"\"Validates the OpenID Connect authorization request parameters.\n\n        :returns: (list of scopes, dict of request info)\n        \"\"\"\n        return self.proxy_target.validate_authorization_request(request)\n\n    def _inflate_claims(self, request):\n        # this may be called multiple times in a single request so make sure we only de-serialize the claims once\n        if request.claims and not isinstance(request.claims, dict):\n            # specific claims are requested during the Authorization Request and may be requested for inclusion\n            # in either the id_token or the UserInfo endpoint response\n            # see http://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter\n            try:\n                request.claims = loads(request.claims)\n            except Exception as ex:\n                raise InvalidRequestError(description=\"Malformed claims parameter\",\n                                          uri=\"http://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter\")\n\n    def id_token_hash(self, value, hashfunc=hashlib.sha256):\n        \"\"\"\n        Its value is the base64url encoding of the left-most half of the\n        hash of the octets of the ASCII representation of the access_token\n        value, where the hash algorithm used is the hash algorithm used in\n        the alg Header Parameter of the ID Token's JOSE Header.\n\n        For instance, if the alg is RS256, hash the access_token value\n        with SHA-256, then take the left-most 128 bits and\n        base64url-encode them.\n        For instance, if the alg is HS512, hash the code value with\n        SHA-512, then take the left-most 256 bits and base64url-encode\n        them. The c_hash value is a case-sensitive string.\n\n        Example of hash from OIDC specification (bound to a JWS using RS256):\n\n        code:\n        Qcb0Orv1zh30vL1MPRsbm-diHiMwcLyZvn1arpZv-Jxf_11jnpEX3Tgfvk\n\n        c_hash:\n        LDktKdoQak3Pk0cnXxCltA\n        \"\"\"\n        digest = hashfunc(value.encode()).digest()\n        left_most = len(digest) // 2\n        return base64.urlsafe_b64encode(digest[:left_most]).decode().rstrip(\"=\")\n\n    def add_id_token(self, token, token_handler, request, nonce=None):\n        \"\"\"\n        Construct an initial version of id_token, and let the\n        request_validator sign or encrypt it.\n\n        The initial version can contain the fields below, accordingly\n        to the spec:\n        - aud\n        - iat\n        - nonce\n        - at_hash\n        - c_hash\n        \"\"\"\n        # Treat it as normal OAuth 2 auth code request if openid is not present\n        if not request.scopes or 'openid' not in request.scopes:\n            return token\n\n        # Only add an id token on auth/token step if asked for.\n        if request.response_type and 'id_token' not in request.response_type:\n            return token\n\n        # Implementation mint its own id_token without help.\n        id_token = self.request_validator.get_id_token(token, token_handler, request)\n        if id_token:\n            token['id_token'] = id_token\n            return token\n\n        # Fallback for asking some help from oauthlib framework.\n        # Start with technicals fields bound to the specification.\n        id_token = {}\n        id_token['aud'] = request.client_id\n        id_token['iat'] = int(time.time())\n\n        # nonce is REQUIRED when response_type value is:\n        # - id_token token (Implicit)\n        # - id_token (Implicit)\n        # - code id_token (Hybrid)\n        # - code id_token token (Hybrid)\n        #\n        # nonce is OPTIONAL when response_type value is:\n        # - code (Authorization Code)\n        # - code token (Hybrid)\n        if nonce is not None:\n            id_token[\"nonce\"] = nonce\n\n        # at_hash is REQUIRED when response_type value is:\n        # - id_token token (Implicit)\n        # - code id_token token (Hybrid)\n        #\n        # at_hash is OPTIONAL when:\n        # - code (Authorization code)\n        # - code id_token (Hybrid)\n        # - code token (Hybrid)\n        #\n        # at_hash MAY NOT be used when:\n        # - id_token (Implicit)\n        if \"access_token\" in token:\n            id_token[\"at_hash\"] = self.id_token_hash(token[\"access_token\"])\n\n        # c_hash is REQUIRED when response_type value is:\n        # - code id_token (Hybrid)\n        # - code id_token token (Hybrid)\n        #\n        # c_hash is OPTIONAL for others.\n        if \"code\" in token:\n            id_token[\"c_hash\"] = self.id_token_hash(token[\"code\"])\n\n        # Call request_validator to complete/sign/encrypt id_token\n        token['id_token'] = self.request_validator.finalize_id_token(id_token, token, token_handler, request)\n\n        return token\n\n    def openid_authorization_validator(self, request):\n        \"\"\"Perform OpenID Connect specific authorization request validation.\n\n        nonce\n                OPTIONAL. String value used to associate a Client session with\n                an ID Token, and to mitigate replay attacks. The value is\n                passed through unmodified from the Authentication Request to\n                the ID Token. Sufficient entropy MUST be present in the nonce\n                values used to prevent attackers from guessing values\n\n        display\n                OPTIONAL. ASCII string value that specifies how the\n                Authorization Server displays the authentication and consent\n                user interface pages to the End-User. The defined values are:\n\n                    page - The Authorization Server SHOULD display the\n                    authentication and consent UI consistent with a full User\n                    Agent page view. If the display parameter is not specified,\n                    this is the default display mode.\n\n                    popup - The Authorization Server SHOULD display the\n                    authentication and consent UI consistent with a popup User\n                    Agent window. The popup User Agent window should be of an\n                    appropriate size for a login-focused dialog and should not\n                    obscure the entire window that it is popping up over.\n\n                    touch - The Authorization Server SHOULD display the\n                    authentication and consent UI consistent with a device that\n                    leverages a touch interface.\n\n                    wap - The Authorization Server SHOULD display the\n                    authentication and consent UI consistent with a \"feature\n                    phone\" type display.\n\n                The Authorization Server MAY also attempt to detect the\n                capabilities of the User Agent and present an appropriate\n                display.\n\n        prompt\n                OPTIONAL. Space delimited, case sensitive list of ASCII string\n                values that specifies whether the Authorization Server prompts\n                the End-User for reauthentication and consent. The defined\n                values are:\n\n                    none - The Authorization Server MUST NOT display any\n                    authentication or consent user interface pages. An error is\n                    returned if an End-User is not already authenticated or the\n                    Client does not have pre-configured consent for the\n                    requested Claims or does not fulfill other conditions for\n                    processing the request. The error code will typically be\n                    login_required, interaction_required, or another code\n                    defined in Section 3.1.2.6. This can be used as a method to\n                    check for existing authentication and/or consent.\n\n                    login - The Authorization Server SHOULD prompt the End-User\n                    for reauthentication. If it cannot reauthenticate the\n                    End-User, it MUST return an error, typically\n                    login_required.\n\n                    consent - The Authorization Server SHOULD prompt the\n                    End-User for consent before returning information to the\n                    Client. If it cannot obtain consent, it MUST return an\n                    error, typically consent_required.\n\n                    select_account - The Authorization Server SHOULD prompt the\n                    End-User to select a user account. This enables an End-User\n                    who has multiple accounts at the Authorization Server to\n                    select amongst the multiple accounts that they might have\n                    current sessions for. If it cannot obtain an account\n                    selection choice made by the End-User, it MUST return an\n                    error, typically account_selection_required.\n\n                The prompt parameter can be used by the Client to make sure\n                that the End-User is still present for the current session or\n                to bring attention to the request. If this parameter contains\n                none with any other value, an error is returned.\n\n        max_age\n                OPTIONAL. Maximum Authentication Age. Specifies the allowable\n                elapsed time in seconds since the last time the End-User was\n                actively authenticated by the OP. If the elapsed time is\n                greater than this value, the OP MUST attempt to actively\n                re-authenticate the End-User. (The max_age request parameter\n                corresponds to the OpenID 2.0 PAPE [OpenID.PAPE] max_auth_age\n                request parameter.) When max_age is used, the ID Token returned\n                MUST include an auth_time Claim Value.\n\n        ui_locales\n                OPTIONAL. End-User's preferred languages and scripts for the\n                user interface, represented as a space-separated list of BCP47\n                [RFC5646] language tag values, ordered by preference. For\n                instance, the value \"fr-CA fr en\" represents a preference for\n                French as spoken in Canada, then French (without a region\n                designation), followed by English (without a region\n                designation). An error SHOULD NOT result if some or all of the\n                requested locales are not supported by the OpenID Provider.\n\n        id_token_hint\n                OPTIONAL. ID Token previously issued by the Authorization\n                Server being passed as a hint about the End-User's current or\n                past authenticated session with the Client. If the End-User\n                identified by the ID Token is logged in or is logged in by the\n                request, then the Authorization Server returns a positive\n                response; otherwise, it SHOULD return an error, such as\n                login_required. When possible, an id_token_hint SHOULD be\n                present when prompt=none is used and an invalid_request error\n                MAY be returned if it is not; however, the server SHOULD\n                respond successfully when possible, even if it is not present.\n                The Authorization Server need not be listed as an audience of\n                the ID Token when it is used as an id_token_hint value. If the\n                ID Token received by the RP from the OP is encrypted, to use it\n                as an id_token_hint, the Client MUST decrypt the signed ID\n                Token contained within the encrypted ID Token. The Client MAY\n                re-encrypt the signed ID token to the Authentication Server\n                using a key that enables the server to decrypt the ID Token,\n                and use the re-encrypted ID token as the id_token_hint value.\n\n        login_hint\n                OPTIONAL. Hint to the Authorization Server about the login\n                identifier the End-User might use to log in (if necessary).\n                This hint can be used by an RP if it first asks the End-User\n                for their e-mail address (or other identifier) and then wants\n                to pass that value as a hint to the discovered authorization\n                service. It is RECOMMENDED that the hint value match the value\n                used for discovery. This value MAY also be a phone number in\n                the format specified for the phone_number Claim. The use of\n                this parameter is left to the OP's discretion.\n\n        acr_values\n                OPTIONAL. Requested Authentication Context Class Reference\n                values. Space-separated string that specifies the acr values\n                that the Authorization Server is being requested to use for\n                processing this Authentication Request, with the values\n                appearing in order of preference. The Authentication Context\n                Class satisfied by the authentication performed is returned as\n                the acr Claim Value, as specified in Section 2. The acr Claim\n                is requested as a Voluntary Claim by this parameter.\n        \"\"\"\n\n        # Treat it as normal OAuth 2 auth code request if openid is not present\n        if not request.scopes or 'openid' not in request.scopes:\n            return {}\n\n        prompt = request.prompt if request.prompt else []\n        if hasattr(prompt, 'split'):\n            prompt = prompt.strip().split()\n        prompt = set(prompt)\n\n        if 'none' in prompt:\n\n            if len(prompt) > 1:\n                msg = \"Prompt none is mutually exclusive with other values.\"\n                raise InvalidRequestError(request=request, description=msg)\n\n            if not self.request_validator.validate_silent_login(request):\n                raise LoginRequired(request=request)\n\n            if not self.request_validator.validate_silent_authorization(request):\n                raise ConsentRequired(request=request)\n\n        self._inflate_claims(request)\n\n        if not self.request_validator.validate_user_match(\n                request.id_token_hint, request.scopes, request.claims, request):\n            msg = \"Session user does not match client supplied user.\"\n            raise LoginRequired(request=request, description=msg)\n\n        request_info = {\n            'display': request.display,\n            'nonce': request.nonce,\n            'prompt': prompt,\n            'ui_locales': request.ui_locales.split() if request.ui_locales else [],\n            'id_token_hint': request.id_token_hint,\n            'login_hint': request.login_hint,\n            'claims': request.claims\n        }\n\n        return request_info\n\n\nOpenIDConnectBase = GrantTypeBase\n", "oauthlib/openid/connect/core/grant_types/implicit.py": "\"\"\"\noauthlib.openid.connect.core.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nimport logging\n\nfrom oauthlib.oauth2.rfc6749.errors import InvalidRequestError\nfrom oauthlib.oauth2.rfc6749.grant_types.implicit import (\n    ImplicitGrant as OAuth2ImplicitGrant,\n)\n\nfrom .base import GrantTypeBase\n\nlog = logging.getLogger(__name__)\n\n\nclass ImplicitGrant(GrantTypeBase):\n\n    def __init__(self, request_validator=None, **kwargs):\n        self.proxy_target = OAuth2ImplicitGrant(\n            request_validator=request_validator, **kwargs)\n        self.register_response_type('id_token')\n        self.register_response_type('id_token token')\n        self.custom_validators.post_auth.append(\n            self.openid_authorization_validator)\n        self.register_token_modifier(self.add_id_token)\n\n    def add_id_token(self, token, token_handler, request):\n        if 'state' not in token and request.state:\n            token['state'] = request.state\n        return super().add_id_token(token, token_handler, request, nonce=request.nonce)\n\n    def openid_authorization_validator(self, request):\n        \"\"\"Additional validation when following the implicit flow.\n        \"\"\"\n        request_info = super().openid_authorization_validator(request)\n        if not request_info:  # returns immediately if OAuth2.0\n            return request_info\n\n        # REQUIRED. String value used to associate a Client session with an ID\n        # Token, and to mitigate replay attacks. The value is passed through\n        # unmodified from the Authentication Request to the ID Token.\n        # Sufficient entropy MUST be present in the nonce values used to\n        # prevent attackers from guessing values. For implementation notes, see\n        # Section 15.5.2.\n        if not request.nonce:\n            raise InvalidRequestError(\n                request=request,\n                description='Request is missing mandatory nonce parameter.'\n            )\n        return request_info\n", "oauthlib/openid/connect/core/grant_types/dispatchers.py": "import logging\n\nlog = logging.getLogger(__name__)\n\n\nclass Dispatcher:\n    default_grant = None\n    oidc_grant = None\n\n\nclass AuthorizationCodeGrantDispatcher(Dispatcher):\n    \"\"\"\n    This is an adapter class that will route simple Authorization Code\n    requests, those that have `response_type=code` and a scope including\n    `openid` to either the `default_grant` or the `oidc_grant` based on\n    the scopes requested.\n    \"\"\"\n    def __init__(self, default_grant=None, oidc_grant=None):\n        self.default_grant = default_grant\n        self.oidc_grant = oidc_grant\n\n    def _handler_for_request(self, request):\n        handler = self.default_grant\n\n        if request.scopes and \"openid\" in request.scopes:\n            handler = self.oidc_grant\n\n        log.debug('Selecting handler for request %r.', handler)\n        return handler\n\n    def create_authorization_response(self, request, token_handler):\n        \"\"\"Read scope and route to the designated handler.\"\"\"\n        return self._handler_for_request(request).create_authorization_response(request, token_handler)\n\n    def validate_authorization_request(self, request):\n        \"\"\"Read scope and route to the designated handler.\"\"\"\n        return self._handler_for_request(request).validate_authorization_request(request)\n\n\nclass ImplicitTokenGrantDispatcher(Dispatcher):\n    \"\"\"\n    This is an adapter class that will route simple Authorization\n    requests, those that have `id_token` in `response_type` and a scope\n    including `openid` to either the `default_grant` or the `oidc_grant`\n    based on the scopes requested.\n    \"\"\"\n    def __init__(self, default_grant=None, oidc_grant=None):\n        self.default_grant = default_grant\n        self.oidc_grant = oidc_grant\n\n    def _handler_for_request(self, request):\n        handler = self.default_grant\n\n        if request.scopes and \"openid\" in request.scopes and 'id_token' in request.response_type:\n            handler = self.oidc_grant\n\n        log.debug('Selecting handler for request %r.', handler)\n        return handler\n\n    def create_authorization_response(self, request, token_handler):\n        \"\"\"Read scope and route to the designated handler.\"\"\"\n        return self._handler_for_request(request).create_authorization_response(request, token_handler)\n\n    def validate_authorization_request(self, request):\n        \"\"\"Read scope and route to the designated handler.\"\"\"\n        return self._handler_for_request(request).validate_authorization_request(request)\n\n\nclass AuthorizationTokenGrantDispatcher(Dispatcher):\n    \"\"\"\n    This is an adapter class that will route simple Token requests, those that authorization_code have a scope\n    including 'openid' to either the default_grant or the oidc_grant based on the scopes requested.\n    \"\"\"\n    def __init__(self, request_validator, default_grant=None, oidc_grant=None):\n        self.default_grant = default_grant\n        self.oidc_grant = oidc_grant\n        self.request_validator = request_validator\n\n    def _handler_for_request(self, request):\n        handler = self.default_grant\n        scopes = ()\n        parameters = dict(request.decoded_body)\n        client_id = parameters.get('client_id', None)\n        code = parameters.get('code', None)\n        redirect_uri = parameters.get('redirect_uri', None)\n\n        # If code is not present fallback to `default_grant` which will\n        # raise an error for the missing `code` in `create_token_response` step.\n        if code:\n            scopes = self.request_validator.get_authorization_code_scopes(client_id, code, redirect_uri, request)\n\n        if 'openid' in scopes:\n            handler = self.oidc_grant\n\n        log.debug('Selecting handler for request %r.', handler)\n        return handler\n\n    def create_token_response(self, request, token_handler):\n        \"\"\"Read scope and route to the designated handler.\"\"\"\n        handler = self._handler_for_request(request)\n        return handler.create_token_response(request, token_handler)\n", "oauthlib/openid/connect/core/grant_types/__init__.py": "\"\"\"\noauthlib.openid.connect.core.grant_types\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\"\"\"\nfrom .authorization_code import AuthorizationCodeGrant\nfrom .base import GrantTypeBase\nfrom .dispatchers import (\n    AuthorizationCodeGrantDispatcher, AuthorizationTokenGrantDispatcher,\n    ImplicitTokenGrantDispatcher,\n)\nfrom .hybrid import HybridGrant\nfrom .implicit import ImplicitGrant\nfrom .refresh_token import RefreshTokenGrant\n", "oauthlib/openid/connect/core/endpoints/pre_configured.py": "\"\"\"\noauthlib.openid.connect.core.endpoints.pre_configured\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various endpoints needed\nfor providing OpenID Connect servers.\n\"\"\"\nfrom oauthlib.oauth2.rfc6749.endpoints import (\n    AuthorizationEndpoint, IntrospectEndpoint, ResourceEndpoint,\n    RevocationEndpoint, TokenEndpoint,\n)\nfrom oauthlib.oauth2.rfc6749.grant_types import (\n    AuthorizationCodeGrant as OAuth2AuthorizationCodeGrant,\n    ClientCredentialsGrant, ImplicitGrant as OAuth2ImplicitGrant,\n    ResourceOwnerPasswordCredentialsGrant,\n)\nfrom oauthlib.oauth2.rfc6749.tokens import BearerToken\n\nfrom ..grant_types import (\n    AuthorizationCodeGrant, HybridGrant, ImplicitGrant, RefreshTokenGrant\n)\nfrom ..grant_types.dispatchers import (\n    AuthorizationCodeGrantDispatcher, AuthorizationTokenGrantDispatcher,\n    ImplicitTokenGrantDispatcher,\n)\nfrom ..tokens import JWTToken\nfrom .userinfo import UserInfoEndpoint\n\n\nclass Server(AuthorizationEndpoint, IntrospectEndpoint, TokenEndpoint,\n             ResourceEndpoint, RevocationEndpoint, UserInfoEndpoint):\n\n    \"\"\"An all-in-one endpoint featuring all four major grant types.\"\"\"\n\n    def __init__(self, request_validator, token_expires_in=None,\n                 token_generator=None, refresh_token_generator=None,\n                 *args, **kwargs):\n        \"\"\"Construct a new all-grants-in-one server.\n\n        :param request_validator: An implementation of\n                                  oauthlib.oauth2.RequestValidator.\n        :param token_expires_in: An int or a function to generate a token\n                                 expiration offset (in seconds) given a\n                                 oauthlib.common.Request object.\n        :param token_generator: A function to generate a token from a request.\n        :param refresh_token_generator: A function to generate a token from a\n                                        request for the refresh token.\n        :param kwargs: Extra parameters to pass to authorization-,\n                       token-, resource-, and revocation-endpoint constructors.\n        \"\"\"\n        self.auth_grant = OAuth2AuthorizationCodeGrant(request_validator)\n        self.implicit_grant = OAuth2ImplicitGrant(request_validator)\n        self.password_grant = ResourceOwnerPasswordCredentialsGrant(\n            request_validator)\n        self.credentials_grant = ClientCredentialsGrant(request_validator)\n        self.refresh_grant = RefreshTokenGrant(request_validator)\n        self.openid_connect_auth = AuthorizationCodeGrant(request_validator)\n        self.openid_connect_implicit = ImplicitGrant(request_validator)\n        self.openid_connect_hybrid = HybridGrant(request_validator)\n\n        self.bearer = BearerToken(request_validator, token_generator,\n                             token_expires_in, refresh_token_generator)\n\n        self.jwt = JWTToken(request_validator, token_generator,\n                       token_expires_in, refresh_token_generator)\n\n        self.auth_grant_choice = AuthorizationCodeGrantDispatcher(default_grant=self.auth_grant, oidc_grant=self.openid_connect_auth)\n        self.implicit_grant_choice = ImplicitTokenGrantDispatcher(default_grant=self.implicit_grant, oidc_grant=self.openid_connect_implicit)\n\n        # See http://openid.net/specs/oauth-v2-multiple-response-types-1_0.html#Combinations for valid combinations\n        # internally our AuthorizationEndpoint will ensure they can appear in any order for any valid combination\n        AuthorizationEndpoint.__init__(self, default_response_type='code',\n                                       response_types={\n                                           'code': self.auth_grant_choice,\n                                           'token': self.implicit_grant_choice,\n                                           'id_token': self.openid_connect_implicit,\n                                           'id_token token': self.openid_connect_implicit,\n                                           'code token': self.openid_connect_hybrid,\n                                           'code id_token': self.openid_connect_hybrid,\n                                           'code id_token token': self.openid_connect_hybrid,\n                                           'none': self.auth_grant\n                                       },\n                                       default_token_type=self.bearer)\n\n        self.token_grant_choice = AuthorizationTokenGrantDispatcher(request_validator, default_grant=self.auth_grant, oidc_grant=self.openid_connect_auth)\n\n        TokenEndpoint.__init__(self, default_grant_type='authorization_code',\n                               grant_types={\n                                   'authorization_code': self.token_grant_choice,\n                                   'password': self.password_grant,\n                                   'client_credentials': self.credentials_grant,\n                                   'refresh_token': self.refresh_grant,\n                               },\n                               default_token_type=self.bearer)\n        ResourceEndpoint.__init__(self, default_token='Bearer',\n                                  token_types={'Bearer': self.bearer, 'JWT': self.jwt})\n        RevocationEndpoint.__init__(self, request_validator)\n        IntrospectEndpoint.__init__(self, request_validator)\n        UserInfoEndpoint.__init__(self, request_validator)\n", "oauthlib/openid/connect/core/endpoints/userinfo.py": "\"\"\"\noauthlib.openid.connect.core.endpoints.userinfo\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of userinfo endpoint.\n\"\"\"\nimport json\nimport logging\n\nfrom oauthlib.common import Request\nfrom oauthlib.oauth2.rfc6749 import errors\nfrom oauthlib.oauth2.rfc6749.endpoints.base import (\n    BaseEndpoint, catch_errors_and_unavailability,\n)\nfrom oauthlib.oauth2.rfc6749.tokens import BearerToken\n\nlog = logging.getLogger(__name__)\n\n\nclass UserInfoEndpoint(BaseEndpoint):\n    \"\"\"Authorizes access to userinfo resource.\n    \"\"\"\n    def __init__(self, request_validator):\n        self.bearer = BearerToken(request_validator, None, None, None)\n        self.request_validator = request_validator\n        BaseEndpoint.__init__(self)\n\n    @catch_errors_and_unavailability\n    def create_userinfo_response(self, uri, http_method='GET', body=None, headers=None):\n        \"\"\"Validate BearerToken and return userinfo from RequestValidator\n\n        The UserInfo Endpoint MUST return a\n        content-type header to indicate which format is being returned. The\n        content-type of the HTTP response MUST be application/json if the\n        response body is a text JSON object; the response body SHOULD be encoded\n        using UTF-8.\n        \"\"\"\n        request = Request(uri, http_method, body, headers)\n        request.scopes = [\"openid\"]\n        self.validate_userinfo_request(request)\n\n        claims = self.request_validator.get_userinfo_claims(request)\n        if claims is None:\n            log.error('Userinfo MUST have claims for %r.', request)\n            raise errors.ServerError(status_code=500)\n\n        if isinstance(claims, dict):\n            resp_headers = {\n                'Content-Type': 'application/json'\n            }\n            if \"sub\" not in claims:\n                log.error('Userinfo MUST have \"sub\" for %r.', request)\n                raise errors.ServerError(status_code=500)\n            body = json.dumps(claims)\n        elif isinstance(claims, str):\n            resp_headers = {\n                'Content-Type': 'application/jwt'\n            }\n            body = claims\n        else:\n            log.error('Userinfo return unknown response for %r.', request)\n            raise errors.ServerError(status_code=500)\n        log.debug('Userinfo access valid for %r.', request)\n        return resp_headers, body, 200\n\n    def validate_userinfo_request(self, request):\n        \"\"\"Ensure the request is valid.\n\n        5.3.1.  UserInfo Request\n        The Client sends the UserInfo Request using either HTTP GET or HTTP\n        POST. The Access Token obtained from an OpenID Connect Authentication\n        Request MUST be sent as a Bearer Token, per `Section 2`_ of OAuth 2.0\n        Bearer Token Usage [RFC6750].\n\n        It is RECOMMENDED that the request use the HTTP GET method and the\n        Access Token be sent using the Authorization header field.\n\n        The following is a non-normative example of a UserInfo Request:\n\n        .. code-block:: http\n\n            GET /userinfo HTTP/1.1\n            Host: server.example.com\n            Authorization: Bearer SlAV32hkKG\n\n        5.3.3. UserInfo Error Response\n        When an error condition occurs, the UserInfo Endpoint returns an Error\n        Response as defined in `Section 3`_ of OAuth 2.0 Bearer Token Usage\n        [RFC6750]. (HTTP errors unrelated to RFC 6750 are returned to the User\n        Agent using the appropriate HTTP status code.)\n\n        The following is a non-normative example of a UserInfo Error Response:\n\n        .. code-block:: http\n\n            HTTP/1.1 401 Unauthorized\n            WWW-Authenticate: Bearer error=\"invalid_token\",\n                error_description=\"The Access Token expired\"\n\n        .. _`Section 2`: https://datatracker.ietf.org/doc/html/rfc6750#section-2\n        .. _`Section 3`: https://datatracker.ietf.org/doc/html/rfc6750#section-3\n        \"\"\"\n        if not self.bearer.validate_request(request):\n            raise errors.InvalidTokenError()\n        if \"openid\" not in request.scopes:\n            raise errors.InsufficientScopeError()\n", "oauthlib/openid/connect/core/endpoints/__init__.py": "\"\"\"\noauthlib.oopenid.core\n~~~~~~~~~~~~~~~~~~~~~~~\n\nThis module is an implementation of various logic needed\nfor consuming and providing OpenID Connect\n\"\"\"\nfrom .pre_configured import Server\nfrom .userinfo import UserInfoEndpoint\n", "examples/skeleton_oauth2_web_application_server.py": "# Skeleton for an OAuth 2 Web Application Server which is an OAuth\n# provider configured for Authorization Code, Refresh Token grants and\n# for dispensing Bearer Tokens.\n\n# This example is meant to act as a supplement to the documentation,\n# see https://oauthlib.readthedocs.io/en/latest/.\n\nfrom oauthlib.oauth2 import RequestValidator, WebApplicationServer\n\n\nclass SkeletonValidator(RequestValidator):\n\n    # Ordered roughly in order of appearance in the authorization grant flow\n\n    # Pre- and post-authorization.\n\n    def validate_client_id(self, client_id, request, *args, **kwargs):\n        # Simple validity check, does client exist? Not banned?\n        pass\n\n    def validate_redirect_uri(self, client_id, redirect_uri, request, *args, **kwargs):\n        # Is the client allowed to use the supplied redirect_uri? i.e. has\n        # the client previously registered this EXACT redirect uri.\n        pass\n\n    def get_default_redirect_uri(self, client_id, request, *args, **kwargs):\n        # The redirect used if none has been supplied.\n        # Prefer your clients to pre register a redirect uri rather than\n        # supplying one on each authorization request.\n        pass\n\n    def validate_scopes(self, client_id, scopes, client, request, *args, **kwargs):\n        # Is the client allowed to access the requested scopes?\n        pass\n\n    def get_default_scopes(self, client_id, request, *args, **kwargs):\n        # Scopes a client will authorize for if none are supplied in the\n        # authorization request.\n        pass\n\n    def validate_response_type(self, client_id, response_type, client, request, *args, **kwargs):\n        # Clients should only be allowed to use one type of response type, the\n        # one associated with their one allowed grant type.\n        # In this case it must be \"code\".\n        pass\n\n    # Post-authorization\n\n    def save_authorization_code(self, client_id, code, request, *args, **kwargs):\n        # Remember to associate it with request.scopes, request.redirect_uri\n        # request.client and request.user (the last is passed in\n        # post_authorization credentials, i.e. { 'user': request.user}.\n        pass\n\n    # Token request\n\n    def client_authentication_required(self, request, *args, **kwargs):\n        # Check if the client provided authentication information that needs to\n        # be validated, e.g. HTTP Basic auth\n        pass\n\n    def authenticate_client(self, request, *args, **kwargs):\n        # Whichever authentication method suits you, HTTP Basic might work\n        pass\n\n    def authenticate_client_id(self, client_id, request, *args, **kwargs):\n        # The client_id must match an existing public (non-confidential) client\n        pass\n\n    def validate_code(self, client_id, code, client, request, *args, **kwargs):\n        # Validate the code belongs to the client. Add associated scopes\n        # and user to request.scopes and request.user.\n        pass\n\n    def confirm_redirect_uri(self, client_id, code, redirect_uri, client, request, *args, **kwargs):\n        # You did save the redirect uri with the authorization code right?\n        pass\n\n    def validate_grant_type(self, client_id, grant_type, client, request, *args, **kwargs):\n        # Clients should only be allowed to use one type of grant.\n        # In this case, it must be \"authorization_code\" or \"refresh_token\"\n        pass\n\n    def save_bearer_token(self, token, request, *args, **kwargs):\n        # Remember to associate it with request.scopes, request.user and\n        # request.client. The two former will be set when you validate\n        # the authorization code. Don't forget to save both the\n        # access_token and the refresh_token and set expiration for the\n        # access_token to now + expires_in seconds.\n        pass\n\n    def invalidate_authorization_code(self, client_id, code, request, *args, **kwargs):\n        # Authorization codes are use once, invalidate it when a Bearer token\n        # has been acquired.\n        pass\n\n    # Protected resource request\n\n    def validate_bearer_token(self, token, scopes, request):\n        # Remember to check expiration and scope membership\n        pass\n\n    # Token refresh request\n\n    def get_original_scopes(self, refresh_token, request, *args, **kwargs):\n        # Obtain the token associated with the given refresh_token and\n        # return its scopes, these will be passed on to the refreshed\n        # access token if the client did not specify a scope during the\n        # request.\n        pass\n\n\nvalidator = SkeletonValidator()\nserver = WebApplicationServer(validator)\n", "examples/__init__.py": ""}