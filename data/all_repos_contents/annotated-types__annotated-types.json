{"annotated_types/__init__.py": "import math\nimport sys\nimport types\nfrom dataclasses import dataclass\nfrom datetime import tzinfo\nfrom typing import TYPE_CHECKING, Any, Callable, Iterator, Optional, SupportsFloat, SupportsIndex, TypeVar, Union\n\nif sys.version_info < (3, 8):\n    from typing_extensions import Protocol, runtime_checkable\nelse:\n    from typing import Protocol, runtime_checkable\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Annotated, Literal\nelse:\n    from typing import Annotated, Literal\n\nif sys.version_info < (3, 10):\n    EllipsisType = type(Ellipsis)\n    KW_ONLY = {}\n    SLOTS = {}\nelse:\n    from types import EllipsisType\n\n    KW_ONLY = {\"kw_only\": True}\n    SLOTS = {\"slots\": True}\n\n\n__all__ = (\n    'BaseMetadata',\n    'GroupedMetadata',\n    'Gt',\n    'Ge',\n    'Lt',\n    'Le',\n    'Interval',\n    'MultipleOf',\n    'MinLen',\n    'MaxLen',\n    'Len',\n    'Timezone',\n    'Predicate',\n    'LowerCase',\n    'UpperCase',\n    'IsDigits',\n    'IsFinite',\n    'IsNotFinite',\n    'IsNan',\n    'IsNotNan',\n    'IsInfinite',\n    'IsNotInfinite',\n    'doc',\n    'DocInfo',\n    '__version__',\n)\n\n__version__ = '0.7.0'\n\n\nT = TypeVar('T')\n\n\n# arguments that start with __ are considered\n# positional only\n# see https://peps.python.org/pep-0484/#positional-only-arguments\n\n\nclass SupportsGt(Protocol):\n    def __gt__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsGe(Protocol):\n    def __ge__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsLt(Protocol):\n    def __lt__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsLe(Protocol):\n    def __le__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsMod(Protocol):\n    def __mod__(self: T, __other: T) -> T:\n        ...\n\n\nclass SupportsDiv(Protocol):\n    def __div__(self: T, __other: T) -> T:\n        ...\n\n\nclass BaseMetadata:\n    \"\"\"Base class for all metadata.\n\n    This exists mainly so that implementers\n    can do `isinstance(..., BaseMetadata)` while traversing field annotations.\n    \"\"\"\n\n    __slots__ = ()\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Gt(BaseMetadata):\n    \"\"\"Gt(gt=x) implies that the value must be greater than x.\n\n    It can be used with any type that supports the ``>`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    gt: SupportsGt\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Ge(BaseMetadata):\n    \"\"\"Ge(ge=x) implies that the value must be greater than or equal to x.\n\n    It can be used with any type that supports the ``>=`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    ge: SupportsGe\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Lt(BaseMetadata):\n    \"\"\"Lt(lt=x) implies that the value must be less than x.\n\n    It can be used with any type that supports the ``<`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    lt: SupportsLt\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Le(BaseMetadata):\n    \"\"\"Le(le=x) implies that the value must be less than or equal to x.\n\n    It can be used with any type that supports the ``<=`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    le: SupportsLe\n\n\n@runtime_checkable\nclass GroupedMetadata(Protocol):\n    \"\"\"A grouping of multiple objects, like typing.Unpack.\n\n    `GroupedMetadata` on its own is not metadata and has no meaning.\n    All of the constraints and metadata should be fully expressable\n    in terms of the `BaseMetadata`'s returned by `GroupedMetadata.__iter__()`.\n\n    Concrete implementations should override `GroupedMetadata.__iter__()`\n    to add their own metadata.\n    For example:\n\n    >>> @dataclass\n    >>> class Field(GroupedMetadata):\n    >>>     gt: float | None = None\n    >>>     description: str | None = None\n    ...\n    >>>     def __iter__(self) -> Iterable[object]:\n    >>>         if self.gt is not None:\n    >>>             yield Gt(self.gt)\n    >>>         if self.description is not None:\n    >>>             yield Description(self.gt)\n\n    Also see the implementation of `Interval` below for an example.\n\n    Parsers should recognize this and unpack it so that it can be used\n    both with and without unpacking:\n\n    - `Annotated[int, Field(...)]` (parser must unpack Field)\n    - `Annotated[int, *Field(...)]` (PEP-646)\n    \"\"\"  # noqa: trailing-whitespace\n\n    @property\n    def __is_annotated_types_grouped_metadata__(self) -> Literal[True]:\n        return True\n\n    def __iter__(self) -> Iterator[object]:\n        ...\n\n    if not TYPE_CHECKING:\n        __slots__ = ()  # allow subclasses to use slots\n\n        def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:\n            # Basic ABC like functionality without the complexity of an ABC\n            super().__init_subclass__(*args, **kwargs)\n            if cls.__iter__ is GroupedMetadata.__iter__:\n                raise TypeError(\"Can't subclass GroupedMetadata without implementing __iter__\")\n\n        def __iter__(self) -> Iterator[object]:  # noqa: F811\n            raise NotImplementedError  # more helpful than \"None has no attribute...\" type errors\n\n\n@dataclass(frozen=True, **KW_ONLY, **SLOTS)\nclass Interval(GroupedMetadata):\n    \"\"\"Interval can express inclusive or exclusive bounds with a single object.\n\n    It accepts keyword arguments ``gt``, ``ge``, ``lt``, and/or ``le``, which\n    are interpreted the same way as the single-bound constraints.\n    \"\"\"\n\n    gt: Union[SupportsGt, None] = None\n    ge: Union[SupportsGe, None] = None\n    lt: Union[SupportsLt, None] = None\n    le: Union[SupportsLe, None] = None\n\n    def __iter__(self) -> Iterator[BaseMetadata]:\n        \"\"\"Unpack an Interval into zero or more single-bounds.\"\"\"\n        if self.gt is not None:\n            yield Gt(self.gt)\n        if self.ge is not None:\n            yield Ge(self.ge)\n        if self.lt is not None:\n            yield Lt(self.lt)\n        if self.le is not None:\n            yield Le(self.le)\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MultipleOf(BaseMetadata):\n    \"\"\"MultipleOf(multiple_of=x) might be interpreted in two ways:\n\n    1. Python semantics, implying ``value % multiple_of == 0``, or\n    2. JSONschema semantics, where ``int(value / multiple_of) == value / multiple_of``\n\n    We encourage users to be aware of these two common interpretations,\n    and libraries to carefully document which they implement.\n    \"\"\"\n\n    multiple_of: Union[SupportsDiv, SupportsMod]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MinLen(BaseMetadata):\n    \"\"\"\n    MinLen() implies minimum inclusive length,\n    e.g. ``len(value) >= min_length``.\n    \"\"\"\n\n    min_length: Annotated[int, Ge(0)]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MaxLen(BaseMetadata):\n    \"\"\"\n    MaxLen() implies maximum inclusive length,\n    e.g. ``len(value) <= max_length``.\n    \"\"\"\n\n    max_length: Annotated[int, Ge(0)]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Len(GroupedMetadata):\n    \"\"\"\n    Len() implies that ``min_length <= len(value) <= max_length``.\n\n    Upper bound may be omitted or ``None`` to indicate no upper length bound.\n    \"\"\"\n\n    min_length: Annotated[int, Ge(0)] = 0\n    max_length: Optional[Annotated[int, Ge(0)]] = None\n\n    def __iter__(self) -> Iterator[BaseMetadata]:\n        \"\"\"Unpack a Len into zone or more single-bounds.\"\"\"\n        if self.min_length > 0:\n            yield MinLen(self.min_length)\n        if self.max_length is not None:\n            yield MaxLen(self.max_length)\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Timezone(BaseMetadata):\n    \"\"\"Timezone(tz=...) requires a datetime to be aware (or ``tz=None``, naive).\n\n    ``Annotated[datetime, Timezone(None)]`` must be a naive datetime.\n    ``Timezone[...]`` (the ellipsis literal) expresses that the datetime must be\n    tz-aware but any timezone is allowed.\n\n    You may also pass a specific timezone string or tzinfo object such as\n    ``Timezone(timezone.utc)`` or ``Timezone(\"Africa/Abidjan\")`` to express that\n    you only allow a specific timezone, though we note that this is often\n    a symptom of poor design.\n    \"\"\"\n\n    tz: Union[str, tzinfo, EllipsisType, None]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Unit(BaseMetadata):\n    \"\"\"Indicates that the value is a physical quantity with the specified unit.\n\n    It is intended for usage with numeric types, where the value represents the\n    magnitude of the quantity. For example, ``distance: Annotated[float, Unit('m')]``\n    or ``speed: Annotated[float, Unit('m/s')]``.\n\n    Interpretation of the unit string is left to the discretion of the consumer.\n    It is suggested to follow conventions established by python libraries that work\n    with physical quantities, such as\n\n    - ``pint`` : <https://pint.readthedocs.io/en/stable/>\n    - ``astropy.units``: <https://docs.astropy.org/en/stable/units/>\n\n    For indicating a quantity with a certain dimensionality but without a specific unit\n    it is recommended to use square brackets, e.g. `Annotated[float, Unit('[time]')]`.\n    Note, however, ``annotated_types`` itself makes no use of the unit string.\n    \"\"\"\n\n    unit: str\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Predicate(BaseMetadata):\n    \"\"\"``Predicate(func: Callable)`` implies `func(value)` is truthy for valid values.\n\n    Users should prefer statically inspectable metadata, but if you need the full\n    power and flexibility of arbitrary runtime predicates... here it is.\n\n    We provide a few predefined predicates for common string constraints:\n    ``IsLower = Predicate(str.islower)``, ``IsUpper = Predicate(str.isupper)``, and\n    ``IsDigits = Predicate(str.isdigit)``. Users are encouraged to use methods which\n    can be given special handling, and avoid indirection like ``lambda s: s.lower()``.\n\n    Some libraries might have special logic to handle certain predicates, e.g. by\n    checking for `str.isdigit` and using its presence to both call custom logic to\n    enforce digit-only strings, and customise some generated external schema.\n\n    We do not specify what behaviour should be expected for predicates that raise\n    an exception.  For example `Annotated[int, Predicate(str.isdigit)]` might silently\n    skip invalid constraints, or statically raise an error; or it might try calling it\n    and then propagate or discard the resulting exception.\n    \"\"\"\n\n    func: Callable[[Any], bool]\n\n    def __repr__(self) -> str:\n        if getattr(self.func, \"__name__\", \"<lambda>\") == \"<lambda>\":\n            return f\"{self.__class__.__name__}({self.func!r})\"\n        if isinstance(self.func, (types.MethodType, types.BuiltinMethodType)) and (\n            namespace := getattr(self.func.__self__, \"__name__\", None)\n        ):\n            return f\"{self.__class__.__name__}({namespace}.{self.func.__name__})\"\n        if isinstance(self.func, type(str.isascii)):  # method descriptor\n            return f\"{self.__class__.__name__}({self.func.__qualname__})\"\n        return f\"{self.__class__.__name__}({self.func.__name__})\"\n\n\n@dataclass\nclass Not:\n    func: Callable[[Any], bool]\n\n    def __call__(self, __v: Any) -> bool:\n        return not self.func(__v)\n\n\n_StrType = TypeVar(\"_StrType\", bound=str)\n\nLowerCase = Annotated[_StrType, Predicate(str.islower)]\n\"\"\"\nReturn True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.\n\"\"\"  # noqa: E501\nUpperCase = Annotated[_StrType, Predicate(str.isupper)]\n\"\"\"\nReturn True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.\n\"\"\"  # noqa: E501\nIsDigit = Annotated[_StrType, Predicate(str.isdigit)]\nIsDigits = IsDigit  # type: ignore  # plural for backwards compatibility, see #63\n\"\"\"\nReturn True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there is at least one character in the string.\n\"\"\"  # noqa: E501\nIsAscii = Annotated[_StrType, Predicate(str.isascii)]\n\"\"\"\nReturn True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.\n\"\"\"\n\n_NumericType = TypeVar('_NumericType', bound=Union[SupportsFloat, SupportsIndex])\nIsFinite = Annotated[_NumericType, Predicate(math.isfinite)]\n\"\"\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"\"\"\nIsNotFinite = Annotated[_NumericType, Predicate(Not(math.isfinite))]\n\"\"\"Return True if x is one of infinity or NaN, and False otherwise\"\"\"\nIsNan = Annotated[_NumericType, Predicate(math.isnan)]\n\"\"\"Return True if x is a NaN (not a number), and False otherwise.\"\"\"\nIsNotNan = Annotated[_NumericType, Predicate(Not(math.isnan))]\n\"\"\"Return True if x is anything but NaN (not a number), and False otherwise.\"\"\"\nIsInfinite = Annotated[_NumericType, Predicate(math.isinf)]\n\"\"\"Return True if x is a positive or negative infinity, and False otherwise.\"\"\"\nIsNotInfinite = Annotated[_NumericType, Predicate(Not(math.isinf))]\n\"\"\"Return True if x is neither a positive or negative infinity, and False otherwise.\"\"\"\n\ntry:\n    from typing_extensions import DocInfo, doc  # type: ignore [attr-defined]\nexcept ImportError:\n\n    @dataclass(frozen=True, **SLOTS)\n    class DocInfo:  # type: ignore [no-redef]\n        \"\"\" \"\n        The return value of doc(), mainly to be used by tools that want to extract the\n        Annotated documentation at runtime.\n        \"\"\"\n\n        documentation: str\n        \"\"\"The documentation string passed to doc().\"\"\"\n\n    def doc(\n        documentation: str,\n    ) -> DocInfo:\n        \"\"\"\n        Add documentation to a type annotation inside of Annotated.\n\n        For example:\n\n        >>> def hi(name: Annotated[int, doc(\"The name of the user\")]) -> None: ...\n        \"\"\"\n        return DocInfo(documentation)\n"}