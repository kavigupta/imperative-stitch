{"tests/test_grouped_metadata.py": "import sys\nfrom typing import Iterator\n\nimport pytest\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Literal\nelse:\n    from typing import Literal\n\nfrom annotated_types import BaseMetadata, GroupedMetadata, Gt\n\n\ndef test_subclass_without_implementing_iter() -> None:\n    with pytest.raises(TypeError):\n\n        class Foo1(GroupedMetadata):\n            pass\n\n    class Foo2(GroupedMetadata):\n        def __iter__(self) -> Iterator[BaseMetadata]:\n            raise NotImplementedError\n\n    with pytest.raises(NotImplementedError):\n        for _ in Foo2():\n            pass\n\n\ndef test_non_subclass_implementer() -> None:\n    class Foo:\n        __is_annotated_types_grouped_metadata__: Literal[True] = True\n\n        def __iter__(self) -> Iterator[BaseMetadata]:\n            return\n            yield Gt(0)\n\n    _: GroupedMetadata = Foo()  # type checker will fail if not valid\n", "tests/test_main.py": "import math\nimport sys\nfrom datetime import datetime, timezone\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, Iterable, Iterator, Type, Union\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Annotated, get_args, get_origin\nelse:\n    from typing import Annotated, get_args, get_origin\n\nimport pytest\n\nif TYPE_CHECKING:\n    from _pytest.mark import ParameterSet\n\nimport annotated_types\nfrom annotated_types.test_cases import Case, cases\n\nConstraint = Union[annotated_types.BaseMetadata, slice]\n\n\ndef check_gt(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Gt)\n    return val > constraint.gt\n\n\ndef check_lt(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Lt)\n    return val < constraint.lt\n\n\ndef check_ge(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Ge)\n    return val >= constraint.ge\n\n\ndef check_le(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Le)\n    return val <= constraint.le\n\n\ndef check_multiple_of(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.MultipleOf)\n    return val % constraint.multiple_of == 0\n\n\ndef check_min_len(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.MinLen)\n    return len(val) >= constraint.min_length\n\n\ndef check_max_len(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.MaxLen)\n    return len(val) <= constraint.max_length\n\n\ndef check_predicate(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Predicate)\n    # this is a relatively pointless branch since Not is itself callable\n    # but it serves to demonstrate that Not can be introspected\n    # and the wrapped predicate can be extracted / matched\n    if isinstance(constraint.func, annotated_types.Not):\n        return not constraint.func.func(val)\n    return constraint.func(val)\n\n\ndef check_timezone(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Timezone)\n    assert isinstance(val, datetime)\n    if isinstance(constraint.tz, str):\n        return val.tzinfo is not None and constraint.tz == val.tzname()\n    elif isinstance(constraint.tz, timezone):\n        return val.tzinfo is not None and val.tzinfo == constraint.tz\n    elif constraint.tz is None:\n        return val.tzinfo is None\n    # ellipsis\n    return val.tzinfo is not None\n\n\ndef check_quantity(constraint: Constraint, val: Any) -> bool:\n    assert isinstance(constraint, annotated_types.Unit)\n    return isinstance(val, (float, int))\n\n\nValidator = Callable[[Constraint, Any], bool]\n\n\nVALIDATORS: Dict[Type[Constraint], Validator] = {\n    annotated_types.Gt: check_gt,\n    annotated_types.Lt: check_lt,\n    annotated_types.Ge: check_ge,\n    annotated_types.Le: check_le,\n    annotated_types.MultipleOf: check_multiple_of,\n    annotated_types.Predicate: check_predicate,\n    annotated_types.MinLen: check_min_len,\n    annotated_types.MaxLen: check_max_len,\n    annotated_types.Timezone: check_timezone,\n    annotated_types.Unit: check_quantity,\n}\n\n\ndef get_constraints(tp: type) -> Iterator[Constraint]:\n    origin = get_origin(tp)\n    assert origin is Annotated\n    args = iter(get_args(tp))\n    next(args)\n    for arg in args:\n        if isinstance(arg, annotated_types.BaseMetadata):\n            yield arg\n        elif isinstance(arg, annotated_types.GroupedMetadata):\n            yield from arg  # type: ignore\n        elif isinstance(arg, slice):\n            yield from annotated_types.Len(arg.start or 0, arg.stop)\n\n\ndef is_valid(tp: type, value: Any) -> bool:\n    for constraint in get_constraints(tp):\n        if not VALIDATORS[type(constraint)](constraint, value):\n            return False\n    return True\n\n\ndef extract_valid_testcases(case: Case) -> \"Iterable[ParameterSet]\":\n    for example in case.valid_cases:\n        yield pytest.param(case.annotation, example, id=f\"{case.annotation} is valid for {repr(example)}\")\n\n\ndef extract_invalid_testcases(case: Case) -> \"Iterable[ParameterSet]\":\n    for example in case.invalid_cases:\n        yield pytest.param(case.annotation, example, id=f\"{case.annotation} is invalid for {repr(example)}\")\n\n\n@pytest.mark.parametrize(\n    \"annotation, example\", [testcase for case in cases() for testcase in extract_valid_testcases(case)]\n)\ndef test_valid_cases(annotation: type, example: Any) -> None:\n    assert is_valid(annotation, example) is True\n\n\n@pytest.mark.parametrize(\n    \"annotation, example\", [testcase for case in cases() for testcase in extract_invalid_testcases(case)]\n)\ndef test_invalid_cases(annotation: type, example: Any) -> None:\n    assert is_valid(annotation, example) is False\n\n\ndef a_predicate_fn(x: object) -> bool:\n    return not x\n\n\n@pytest.mark.parametrize(\n    \"pred, repr_\",\n    [\n        (annotated_types.Predicate(func=a_predicate_fn), \"Predicate(a_predicate_fn)\"),\n        (annotated_types.Predicate(func=str.isascii), \"Predicate(str.isascii)\"),\n        (annotated_types.Predicate(func=math.isfinite), \"Predicate(math.isfinite)\"),\n        (annotated_types.Predicate(func=bool), \"Predicate(bool)\"),\n        (annotated_types.Predicate(func := lambda _: True), f\"Predicate({func!r})\"),\n    ],\n)\ndef test_predicate_repr(pred: annotated_types.Predicate, repr_: str) -> None:\n    assert repr(pred) == repr_\n", "tests/__init__.py": "", "annotated_types/test_cases.py": "import math\nimport sys\nfrom datetime import date, datetime, timedelta, timezone\nfrom decimal import Decimal\nfrom typing import Any, Dict, Iterable, Iterator, List, NamedTuple, Set, Tuple\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Annotated\nelse:\n    from typing import Annotated\n\nimport annotated_types as at\n\n\nclass Case(NamedTuple):\n    \"\"\"\n    A test case for `annotated_types`.\n    \"\"\"\n\n    annotation: Any\n    valid_cases: Iterable[Any]\n    invalid_cases: Iterable[Any]\n\n\ndef cases() -> Iterable[Case]:\n    # Gt, Ge, Lt, Le\n    yield Case(Annotated[int, at.Gt(4)], (5, 6, 1000), (4, 0, -1))\n    yield Case(Annotated[float, at.Gt(0.5)], (0.6, 0.7, 0.8, 0.9), (0.5, 0.0, -0.1))\n    yield Case(\n        Annotated[datetime, at.Gt(datetime(2000, 1, 1))],\n        [datetime(2000, 1, 2), datetime(2000, 1, 3)],\n        [datetime(2000, 1, 1), datetime(1999, 12, 31)],\n    )\n    yield Case(\n        Annotated[datetime, at.Gt(date(2000, 1, 1))],\n        [date(2000, 1, 2), date(2000, 1, 3)],\n        [date(2000, 1, 1), date(1999, 12, 31)],\n    )\n    yield Case(\n        Annotated[datetime, at.Gt(Decimal('1.123'))],\n        [Decimal('1.1231'), Decimal('123')],\n        [Decimal('1.123'), Decimal('0')],\n    )\n\n    yield Case(Annotated[int, at.Ge(4)], (4, 5, 6, 1000, 4), (0, -1))\n    yield Case(Annotated[float, at.Ge(0.5)], (0.5, 0.6, 0.7, 0.8, 0.9), (0.4, 0.0, -0.1))\n    yield Case(\n        Annotated[datetime, at.Ge(datetime(2000, 1, 1))],\n        [datetime(2000, 1, 2), datetime(2000, 1, 3)],\n        [datetime(1998, 1, 1), datetime(1999, 12, 31)],\n    )\n\n    yield Case(Annotated[int, at.Lt(4)], (0, -1), (4, 5, 6, 1000, 4))\n    yield Case(Annotated[float, at.Lt(0.5)], (0.4, 0.0, -0.1), (0.5, 0.6, 0.7, 0.8, 0.9))\n    yield Case(\n        Annotated[datetime, at.Lt(datetime(2000, 1, 1))],\n        [datetime(1999, 12, 31), datetime(1999, 12, 31)],\n        [datetime(2000, 1, 2), datetime(2000, 1, 3)],\n    )\n\n    yield Case(Annotated[int, at.Le(4)], (4, 0, -1), (5, 6, 1000))\n    yield Case(Annotated[float, at.Le(0.5)], (0.5, 0.0, -0.1), (0.6, 0.7, 0.8, 0.9))\n    yield Case(\n        Annotated[datetime, at.Le(datetime(2000, 1, 1))],\n        [datetime(2000, 1, 1), datetime(1999, 12, 31)],\n        [datetime(2000, 1, 2), datetime(2000, 1, 3)],\n    )\n\n    # Interval\n    yield Case(Annotated[int, at.Interval(gt=4)], (5, 6, 1000), (4, 0, -1))\n    yield Case(Annotated[int, at.Interval(gt=4, lt=10)], (5, 6), (4, 10, 1000, 0, -1))\n    yield Case(Annotated[float, at.Interval(ge=0.5, le=1)], (0.5, 0.9, 1), (0.49, 1.1))\n    yield Case(\n        Annotated[datetime, at.Interval(gt=datetime(2000, 1, 1), le=datetime(2000, 1, 3))],\n        [datetime(2000, 1, 2), datetime(2000, 1, 3)],\n        [datetime(2000, 1, 1), datetime(2000, 1, 4)],\n    )\n\n    yield Case(Annotated[int, at.MultipleOf(multiple_of=3)], (0, 3, 9), (1, 2, 4))\n    yield Case(Annotated[float, at.MultipleOf(multiple_of=0.5)], (0, 0.5, 1, 1.5), (0.4, 1.1))\n\n    # lengths\n\n    yield Case(Annotated[str, at.MinLen(3)], ('123', '1234', 'x' * 10), ('', '1', '12'))\n    yield Case(Annotated[str, at.Len(3)], ('123', '1234', 'x' * 10), ('', '1', '12'))\n    yield Case(Annotated[List[int], at.MinLen(3)], ([1, 2, 3], [1, 2, 3, 4], [1] * 10), ([], [1], [1, 2]))\n    yield Case(Annotated[List[int], at.Len(3)], ([1, 2, 3], [1, 2, 3, 4], [1] * 10), ([], [1], [1, 2]))\n\n    yield Case(Annotated[str, at.MaxLen(4)], ('', '1234'), ('12345', 'x' * 10))\n    yield Case(Annotated[str, at.Len(0, 4)], ('', '1234'), ('12345', 'x' * 10))\n    yield Case(Annotated[List[str], at.MaxLen(4)], ([], ['a', 'bcdef'], ['a', 'b', 'c']), (['a'] * 5, ['b'] * 10))\n    yield Case(Annotated[List[str], at.Len(0, 4)], ([], ['a', 'bcdef'], ['a', 'b', 'c']), (['a'] * 5, ['b'] * 10))\n\n    yield Case(Annotated[str, at.Len(3, 5)], ('123', '12345'), ('', '1', '12', '123456', 'x' * 10))\n    yield Case(Annotated[str, at.Len(3, 3)], ('123',), ('12', '1234'))\n\n    yield Case(Annotated[Dict[int, int], at.Len(2, 3)], [{1: 1, 2: 2}], [{}, {1: 1}, {1: 1, 2: 2, 3: 3, 4: 4}])\n    yield Case(Annotated[Set[int], at.Len(2, 3)], ({1, 2}, {1, 2, 3}), (set(), {1}, {1, 2, 3, 4}))\n    yield Case(Annotated[Tuple[int, ...], at.Len(2, 3)], ((1, 2), (1, 2, 3)), ((), (1,), (1, 2, 3, 4)))\n\n    # Timezone\n\n    yield Case(\n        Annotated[datetime, at.Timezone(None)], [datetime(2000, 1, 1)], [datetime(2000, 1, 1, tzinfo=timezone.utc)]\n    )\n    yield Case(\n        Annotated[datetime, at.Timezone(...)], [datetime(2000, 1, 1, tzinfo=timezone.utc)], [datetime(2000, 1, 1)]\n    )\n    yield Case(\n        Annotated[datetime, at.Timezone(timezone.utc)],\n        [datetime(2000, 1, 1, tzinfo=timezone.utc)],\n        [datetime(2000, 1, 1), datetime(2000, 1, 1, tzinfo=timezone(timedelta(hours=6)))],\n    )\n    yield Case(\n        Annotated[datetime, at.Timezone('Europe/London')],\n        [datetime(2000, 1, 1, tzinfo=timezone(timedelta(0), name='Europe/London'))],\n        [datetime(2000, 1, 1), datetime(2000, 1, 1, tzinfo=timezone(timedelta(hours=6)))],\n    )\n\n    # Quantity\n\n    yield Case(Annotated[float, at.Unit(unit='m')], (5, 4.2), ('5m', '4.2m'))\n\n    # predicate types\n\n    yield Case(at.LowerCase[str], ['abc', 'foobar'], ['', 'A', 'Boom'])\n    yield Case(at.UpperCase[str], ['ABC', 'DEFO'], ['', 'a', 'abc', 'AbC'])\n    yield Case(at.IsDigit[str], ['123'], ['', 'ab', 'a1b2'])\n    yield Case(at.IsAscii[str], ['123', 'foo bar'], ['\u00a3100', '\ud83d\ude0a', 'whatever \ud83d\udc40'])\n\n    yield Case(Annotated[int, at.Predicate(lambda x: x % 2 == 0)], [0, 2, 4], [1, 3, 5])\n\n    yield Case(at.IsFinite[float], [1.23], [math.nan, math.inf, -math.inf])\n    yield Case(at.IsNotFinite[float], [math.nan, math.inf], [1.23])\n    yield Case(at.IsNan[float], [math.nan], [1.23, math.inf])\n    yield Case(at.IsNotNan[float], [1.23, math.inf], [math.nan])\n    yield Case(at.IsInfinite[float], [math.inf], [math.nan, 1.23])\n    yield Case(at.IsNotInfinite[float], [math.nan, 1.23], [math.inf])\n\n    # check stacked predicates\n    yield Case(at.IsInfinite[Annotated[float, at.Predicate(lambda x: x > 0)]], [math.inf], [-math.inf, 1.23, math.nan])\n\n    # doc\n    yield Case(Annotated[int, at.doc(\"A number\")], [1, 2], [])\n\n    # custom GroupedMetadata\n    class MyCustomGroupedMetadata(at.GroupedMetadata):\n        def __iter__(self) -> Iterator[at.Predicate]:\n            yield at.Predicate(lambda x: float(x).is_integer())\n\n    yield Case(Annotated[float, MyCustomGroupedMetadata()], [0, 2.0], [0.01, 1.5])\n", "annotated_types/__init__.py": "import math\nimport sys\nimport types\nfrom dataclasses import dataclass\nfrom datetime import tzinfo\nfrom typing import TYPE_CHECKING, Any, Callable, Iterator, Optional, SupportsFloat, SupportsIndex, TypeVar, Union\n\nif sys.version_info < (3, 8):\n    from typing_extensions import Protocol, runtime_checkable\nelse:\n    from typing import Protocol, runtime_checkable\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Annotated, Literal\nelse:\n    from typing import Annotated, Literal\n\nif sys.version_info < (3, 10):\n    EllipsisType = type(Ellipsis)\n    KW_ONLY = {}\n    SLOTS = {}\nelse:\n    from types import EllipsisType\n\n    KW_ONLY = {\"kw_only\": True}\n    SLOTS = {\"slots\": True}\n\n\n__all__ = (\n    'BaseMetadata',\n    'GroupedMetadata',\n    'Gt',\n    'Ge',\n    'Lt',\n    'Le',\n    'Interval',\n    'MultipleOf',\n    'MinLen',\n    'MaxLen',\n    'Len',\n    'Timezone',\n    'Predicate',\n    'LowerCase',\n    'UpperCase',\n    'IsDigits',\n    'IsFinite',\n    'IsNotFinite',\n    'IsNan',\n    'IsNotNan',\n    'IsInfinite',\n    'IsNotInfinite',\n    'doc',\n    'DocInfo',\n    '__version__',\n)\n\n__version__ = '0.7.0'\n\n\nT = TypeVar('T')\n\n\n# arguments that start with __ are considered\n# positional only\n# see https://peps.python.org/pep-0484/#positional-only-arguments\n\n\nclass SupportsGt(Protocol):\n    def __gt__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsGe(Protocol):\n    def __ge__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsLt(Protocol):\n    def __lt__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsLe(Protocol):\n    def __le__(self: T, __other: T) -> bool:\n        ...\n\n\nclass SupportsMod(Protocol):\n    def __mod__(self: T, __other: T) -> T:\n        ...\n\n\nclass SupportsDiv(Protocol):\n    def __div__(self: T, __other: T) -> T:\n        ...\n\n\nclass BaseMetadata:\n    \"\"\"Base class for all metadata.\n\n    This exists mainly so that implementers\n    can do `isinstance(..., BaseMetadata)` while traversing field annotations.\n    \"\"\"\n\n    __slots__ = ()\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Gt(BaseMetadata):\n    \"\"\"Gt(gt=x) implies that the value must be greater than x.\n\n    It can be used with any type that supports the ``>`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    gt: SupportsGt\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Ge(BaseMetadata):\n    \"\"\"Ge(ge=x) implies that the value must be greater than or equal to x.\n\n    It can be used with any type that supports the ``>=`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    ge: SupportsGe\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Lt(BaseMetadata):\n    \"\"\"Lt(lt=x) implies that the value must be less than x.\n\n    It can be used with any type that supports the ``<`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    lt: SupportsLt\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Le(BaseMetadata):\n    \"\"\"Le(le=x) implies that the value must be less than or equal to x.\n\n    It can be used with any type that supports the ``<=`` operator,\n    including numbers, dates and times, strings, sets, and so on.\n    \"\"\"\n\n    le: SupportsLe\n\n\n@runtime_checkable\nclass GroupedMetadata(Protocol):\n    \"\"\"A grouping of multiple objects, like typing.Unpack.\n\n    `GroupedMetadata` on its own is not metadata and has no meaning.\n    All of the constraints and metadata should be fully expressable\n    in terms of the `BaseMetadata`'s returned by `GroupedMetadata.__iter__()`.\n\n    Concrete implementations should override `GroupedMetadata.__iter__()`\n    to add their own metadata.\n    For example:\n\n    >>> @dataclass\n    >>> class Field(GroupedMetadata):\n    >>>     gt: float | None = None\n    >>>     description: str | None = None\n    ...\n    >>>     def __iter__(self) -> Iterable[object]:\n    >>>         if self.gt is not None:\n    >>>             yield Gt(self.gt)\n    >>>         if self.description is not None:\n    >>>             yield Description(self.gt)\n\n    Also see the implementation of `Interval` below for an example.\n\n    Parsers should recognize this and unpack it so that it can be used\n    both with and without unpacking:\n\n    - `Annotated[int, Field(...)]` (parser must unpack Field)\n    - `Annotated[int, *Field(...)]` (PEP-646)\n    \"\"\"  # noqa: trailing-whitespace\n\n    @property\n    def __is_annotated_types_grouped_metadata__(self) -> Literal[True]:\n        return True\n\n    def __iter__(self) -> Iterator[object]:\n        ...\n\n    if not TYPE_CHECKING:\n        __slots__ = ()  # allow subclasses to use slots\n\n        def __init_subclass__(cls, *args: Any, **kwargs: Any) -> None:\n            # Basic ABC like functionality without the complexity of an ABC\n            super().__init_subclass__(*args, **kwargs)\n            if cls.__iter__ is GroupedMetadata.__iter__:\n                raise TypeError(\"Can't subclass GroupedMetadata without implementing __iter__\")\n\n        def __iter__(self) -> Iterator[object]:  # noqa: F811\n            raise NotImplementedError  # more helpful than \"None has no attribute...\" type errors\n\n\n@dataclass(frozen=True, **KW_ONLY, **SLOTS)\nclass Interval(GroupedMetadata):\n    \"\"\"Interval can express inclusive or exclusive bounds with a single object.\n\n    It accepts keyword arguments ``gt``, ``ge``, ``lt``, and/or ``le``, which\n    are interpreted the same way as the single-bound constraints.\n    \"\"\"\n\n    gt: Union[SupportsGt, None] = None\n    ge: Union[SupportsGe, None] = None\n    lt: Union[SupportsLt, None] = None\n    le: Union[SupportsLe, None] = None\n\n    def __iter__(self) -> Iterator[BaseMetadata]:\n        \"\"\"Unpack an Interval into zero or more single-bounds.\"\"\"\n        if self.gt is not None:\n            yield Gt(self.gt)\n        if self.ge is not None:\n            yield Ge(self.ge)\n        if self.lt is not None:\n            yield Lt(self.lt)\n        if self.le is not None:\n            yield Le(self.le)\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MultipleOf(BaseMetadata):\n    \"\"\"MultipleOf(multiple_of=x) might be interpreted in two ways:\n\n    1. Python semantics, implying ``value % multiple_of == 0``, or\n    2. JSONschema semantics, where ``int(value / multiple_of) == value / multiple_of``\n\n    We encourage users to be aware of these two common interpretations,\n    and libraries to carefully document which they implement.\n    \"\"\"\n\n    multiple_of: Union[SupportsDiv, SupportsMod]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MinLen(BaseMetadata):\n    \"\"\"\n    MinLen() implies minimum inclusive length,\n    e.g. ``len(value) >= min_length``.\n    \"\"\"\n\n    min_length: Annotated[int, Ge(0)]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass MaxLen(BaseMetadata):\n    \"\"\"\n    MaxLen() implies maximum inclusive length,\n    e.g. ``len(value) <= max_length``.\n    \"\"\"\n\n    max_length: Annotated[int, Ge(0)]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Len(GroupedMetadata):\n    \"\"\"\n    Len() implies that ``min_length <= len(value) <= max_length``.\n\n    Upper bound may be omitted or ``None`` to indicate no upper length bound.\n    \"\"\"\n\n    min_length: Annotated[int, Ge(0)] = 0\n    max_length: Optional[Annotated[int, Ge(0)]] = None\n\n    def __iter__(self) -> Iterator[BaseMetadata]:\n        \"\"\"Unpack a Len into zone or more single-bounds.\"\"\"\n        if self.min_length > 0:\n            yield MinLen(self.min_length)\n        if self.max_length is not None:\n            yield MaxLen(self.max_length)\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Timezone(BaseMetadata):\n    \"\"\"Timezone(tz=...) requires a datetime to be aware (or ``tz=None``, naive).\n\n    ``Annotated[datetime, Timezone(None)]`` must be a naive datetime.\n    ``Timezone[...]`` (the ellipsis literal) expresses that the datetime must be\n    tz-aware but any timezone is allowed.\n\n    You may also pass a specific timezone string or tzinfo object such as\n    ``Timezone(timezone.utc)`` or ``Timezone(\"Africa/Abidjan\")`` to express that\n    you only allow a specific timezone, though we note that this is often\n    a symptom of poor design.\n    \"\"\"\n\n    tz: Union[str, tzinfo, EllipsisType, None]\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Unit(BaseMetadata):\n    \"\"\"Indicates that the value is a physical quantity with the specified unit.\n\n    It is intended for usage with numeric types, where the value represents the\n    magnitude of the quantity. For example, ``distance: Annotated[float, Unit('m')]``\n    or ``speed: Annotated[float, Unit('m/s')]``.\n\n    Interpretation of the unit string is left to the discretion of the consumer.\n    It is suggested to follow conventions established by python libraries that work\n    with physical quantities, such as\n\n    - ``pint`` : <https://pint.readthedocs.io/en/stable/>\n    - ``astropy.units``: <https://docs.astropy.org/en/stable/units/>\n\n    For indicating a quantity with a certain dimensionality but without a specific unit\n    it is recommended to use square brackets, e.g. `Annotated[float, Unit('[time]')]`.\n    Note, however, ``annotated_types`` itself makes no use of the unit string.\n    \"\"\"\n\n    unit: str\n\n\n@dataclass(frozen=True, **SLOTS)\nclass Predicate(BaseMetadata):\n    \"\"\"``Predicate(func: Callable)`` implies `func(value)` is truthy for valid values.\n\n    Users should prefer statically inspectable metadata, but if you need the full\n    power and flexibility of arbitrary runtime predicates... here it is.\n\n    We provide a few predefined predicates for common string constraints:\n    ``IsLower = Predicate(str.islower)``, ``IsUpper = Predicate(str.isupper)``, and\n    ``IsDigits = Predicate(str.isdigit)``. Users are encouraged to use methods which\n    can be given special handling, and avoid indirection like ``lambda s: s.lower()``.\n\n    Some libraries might have special logic to handle certain predicates, e.g. by\n    checking for `str.isdigit` and using its presence to both call custom logic to\n    enforce digit-only strings, and customise some generated external schema.\n\n    We do not specify what behaviour should be expected for predicates that raise\n    an exception.  For example `Annotated[int, Predicate(str.isdigit)]` might silently\n    skip invalid constraints, or statically raise an error; or it might try calling it\n    and then propagate or discard the resulting exception.\n    \"\"\"\n\n    func: Callable[[Any], bool]\n\n    def __repr__(self) -> str:\n        if getattr(self.func, \"__name__\", \"<lambda>\") == \"<lambda>\":\n            return f\"{self.__class__.__name__}({self.func!r})\"\n        if isinstance(self.func, (types.MethodType, types.BuiltinMethodType)) and (\n            namespace := getattr(self.func.__self__, \"__name__\", None)\n        ):\n            return f\"{self.__class__.__name__}({namespace}.{self.func.__name__})\"\n        if isinstance(self.func, type(str.isascii)):  # method descriptor\n            return f\"{self.__class__.__name__}({self.func.__qualname__})\"\n        return f\"{self.__class__.__name__}({self.func.__name__})\"\n\n\n@dataclass\nclass Not:\n    func: Callable[[Any], bool]\n\n    def __call__(self, __v: Any) -> bool:\n        return not self.func(__v)\n\n\n_StrType = TypeVar(\"_StrType\", bound=str)\n\nLowerCase = Annotated[_StrType, Predicate(str.islower)]\n\"\"\"\nReturn True if the string is a lowercase string, False otherwise.\n\nA string is lowercase if all cased characters in the string are lowercase and there is at least one cased character in the string.\n\"\"\"  # noqa: E501\nUpperCase = Annotated[_StrType, Predicate(str.isupper)]\n\"\"\"\nReturn True if the string is an uppercase string, False otherwise.\n\nA string is uppercase if all cased characters in the string are uppercase and there is at least one cased character in the string.\n\"\"\"  # noqa: E501\nIsDigit = Annotated[_StrType, Predicate(str.isdigit)]\nIsDigits = IsDigit  # type: ignore  # plural for backwards compatibility, see #63\n\"\"\"\nReturn True if the string is a digit string, False otherwise.\n\nA string is a digit string if all characters in the string are digits and there is at least one character in the string.\n\"\"\"  # noqa: E501\nIsAscii = Annotated[_StrType, Predicate(str.isascii)]\n\"\"\"\nReturn True if all characters in the string are ASCII, False otherwise.\n\nASCII characters have code points in the range U+0000-U+007F. Empty string is ASCII too.\n\"\"\"\n\n_NumericType = TypeVar('_NumericType', bound=Union[SupportsFloat, SupportsIndex])\nIsFinite = Annotated[_NumericType, Predicate(math.isfinite)]\n\"\"\"Return True if x is neither an infinity nor a NaN, and False otherwise.\"\"\"\nIsNotFinite = Annotated[_NumericType, Predicate(Not(math.isfinite))]\n\"\"\"Return True if x is one of infinity or NaN, and False otherwise\"\"\"\nIsNan = Annotated[_NumericType, Predicate(math.isnan)]\n\"\"\"Return True if x is a NaN (not a number), and False otherwise.\"\"\"\nIsNotNan = Annotated[_NumericType, Predicate(Not(math.isnan))]\n\"\"\"Return True if x is anything but NaN (not a number), and False otherwise.\"\"\"\nIsInfinite = Annotated[_NumericType, Predicate(math.isinf)]\n\"\"\"Return True if x is a positive or negative infinity, and False otherwise.\"\"\"\nIsNotInfinite = Annotated[_NumericType, Predicate(Not(math.isinf))]\n\"\"\"Return True if x is neither a positive or negative infinity, and False otherwise.\"\"\"\n\ntry:\n    from typing_extensions import DocInfo, doc  # type: ignore [attr-defined]\nexcept ImportError:\n\n    @dataclass(frozen=True, **SLOTS)\n    class DocInfo:  # type: ignore [no-redef]\n        \"\"\" \"\n        The return value of doc(), mainly to be used by tools that want to extract the\n        Annotated documentation at runtime.\n        \"\"\"\n\n        documentation: str\n        \"\"\"The documentation string passed to doc().\"\"\"\n\n    def doc(\n        documentation: str,\n    ) -> DocInfo:\n        \"\"\"\n        Add documentation to a type annotation inside of Annotated.\n\n        For example:\n\n        >>> def hi(name: Annotated[int, doc(\"The name of the user\")]) -> None: ...\n        \"\"\"\n        return DocInfo(documentation)\n"}