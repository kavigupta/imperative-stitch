{"update_pyparsing_timestamp.py": "from datetime import datetime\nfrom pathlib import Path\nfrom pyparsing import quoted_string\n\nnw = datetime.utcnow()\nnow_string = f'\"{nw.strftime(\"%d %b %Y %X\")[:-3]} UTC\"'\nprint(now_string)\n\nquoted_time = quoted_string()\nquoted_time.set_parse_action(lambda: now_string)\n\nversion_time = \"__version_time__ = \" + quoted_time\n\npp_init = Path(\"pyparsing/__init__.py\")\norig_code = pp_init.read_text()\nnew_code = version_time.transform_string(orig_code)\npp_init.write_text(new_code)\n", "docs/conf.py": "#\n# Configuration file for the Sphinx documentation builder.\n#\n# This file does only contain a selection of the most common options. For a\n# full list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\nsys.path.insert(0, os.path.abspath(\"..\"))\n\nfrom pyparsing import __version__ as pyparsing_version\n\n# -- Project information -----------------------------------------------------\n\nproject = \"PyParsing\"\ncopyright = \"2018-2022, Paul T. McGuire\"\nauthor = \"Paul T. McGuire\"\n\n# The short X.Y version\nversion = pyparsing_version\n# The full version, including alpha/beta/rc tags\nrelease = pyparsing_version\n\n\n# -- General configuration ---------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = \".rst\"\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = None\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path .\nexclude_patterns = []\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"alabaster\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# Custom sidebar templates, must be a dictionary that maps document names\n# to template names.\n#\n# The default sidebars (for documents that don't match any pattern) are\n# defined by theme itself.  Builtin themes are using these templates by\n# default: ``['localtoc.html', 'relations.html', 'sourcelink.html',\n# 'searchbox.html']``.\n#\n# html_sidebars = {}\n\n\n# -- Options for HTMLHelp output ---------------------------------------------\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"PyParsingdoc\"\n\n\n# -- Options for LaTeX output ------------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        \"PyParsing.tex\",\n        \"PyParsing Documentation\",\n        \"Paul T. McGuire\",\n        \"manual\",\n    ),\n]\n\n\n# -- Options for manual page output ------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, \"pyparsing\", \"PyParsing Documentation\", [author], 1)]\n\n\n# -- Options for Texinfo output ----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"PyParsing\",\n        \"PyParsing Documentation\",\n        author,\n        \"PyParsing\",\n        \"Python PEG parsing library.\",\n        \"Miscellaneous\",\n    ),\n]\n\n\n# -- Options for Epub output -------------------------------------------------\n\n# Bibliographic Dublin Core info.\nepub_title = project\nepub_author = author\nepub_publisher = author\nepub_copyright = copyright\n\n# The unique identifier of the text. This can be a ISBN number\n# or the project homepage.\n#\n# epub_identifier = ''\n\n# A unique identification for the text.\n#\n# epub_uid = ''\n\n# A list of files that should not be packed into the epub file.\nepub_exclude_files = [\"search.html\"]\n\n\n# -- Extension configuration -------------------------------------------------\n", "tests/test_unit.py": "#\n# test_unit.py\n#\n# Unit tests for pyparsing module\n#\n# Copyright 2002-2021, Paul McGuire\n#\n#\nimport collections\nimport contextlib\nimport datetime\nimport random\nimport re\nimport shlex\nimport sys\nimport sysconfig\nimport warnings\nfrom types import SimpleNamespace\nfrom io import StringIO\nfrom textwrap import dedent\nfrom typing import Any\nimport unittest\n\nimport pyparsing as pp\nfrom examples.jsonParser import jsonObject\nfrom pyparsing import ParserElement, ParseException, ParseFatalException\nfrom tests.json_parser_tests import test1, test2, test3, test4, test5\nimport platform\n\npython_full_version = sys.version_info\npython_version = python_full_version[:2]\n\nppc = pp.pyparsing_common\nppt = pp.pyparsing_test\n\n# see which Python implementation we are running\npython_impl = platform.python_implementation()\nCPYTHON_ENV = python_impl == \"CPython\"\nIRON_PYTHON_ENV = python_impl == \"IronPython\"\nJYTHON_ENV = python_impl == \"Jython\"\nPYPY_ENV = python_impl == \"PyPy\"\n\n# get full stack traces during testing\npp.ParserElement.verbose_stacktrace = True\n\n\n# simple utility for flattening nested lists\ndef flatten(nested_list):\n    if not isinstance(nested_list, list):\n        return [nested_list]\n    if not nested_list:\n        return nested_list\n    return flatten(nested_list[0]) + flatten(nested_list[1:])\n\n\nclass resetting:\n    def __init__(self, *args):\n        ob = args[0]\n        attrnames = args[1:]\n        self.ob = ob\n        self.save_attrs = attrnames\n        self.save_values = [getattr(ob, attrname) for attrname in attrnames]\n\n    def __enter__(self):\n        pass\n\n    def __exit__(self, *args):\n        for attr, value in zip(self.save_attrs, self.save_values):\n            setattr(self.ob, attr, value)\n\n\ndef find_all_re_matches(patt, s):\n    ret = []\n    start = 0\n    if isinstance(patt, str):\n        patt = re.compile(patt)\n    while True:\n        found = patt.search(s, pos=start)\n        if found:\n            ret.append(found)\n            start = found.end()\n        else:\n            break\n    return ret\n\n\ndef current_method_name(level=2):\n    import traceback\n\n    stack = traceback.extract_stack(limit=level)\n    return stack[0].name\n\n\ndef __():\n    return f\"{current_method_name(3)}: \"\n\n\nclass TestCase(unittest.TestCase):\n    @contextlib.contextmanager\n    def assertRaises(self, expected_exception_type: Any, msg: Any = None):\n        \"\"\"\n        Simple wrapper to print out the exceptions raised after assertRaises\n        \"\"\"\n        with super().assertRaises(expected_exception_type, msg=msg) as ar:\n            yield\n\n        if getattr(ar, \"exception\", None) is not None:\n            print(\n                f\"Raised expected exception: {type(ar.exception).__name__}: {ar.exception}\"\n            )\n        else:\n            print(f\"Expected {expected_exception_type.__name__} exception not raised\")\n        return ar\n\n    @contextlib.contextmanager\n    def assertWarns(self, expected_warning_type: Any, msg: Any = None):\n        \"\"\"\n        Simple wrapper to print out the warnings raised after assertWarns\n        \"\"\"\n        with super().assertWarns(expected_warning_type, msg=msg) as ar:\n            yield\n\n        if getattr(ar, \"warning\", None) is not None:\n            print(f\"Raised expected warning: {type(ar.warning).__name__}: {ar.warning}\")\n        else:\n            print(f\"Expected {expected_warning_type.__name__} warning not raised\")\n        return ar\n\n    @contextlib.contextmanager\n    def assertDoesNotWarn(self, warning_type: type = UserWarning, msg: str = None):\n        with warnings.catch_warnings(record=True) as w:\n            warnings.simplefilter(\"error\")\n            try:\n                yield\n            except Exception as e:\n                if msg is None:\n                    msg = f\"unexpected warning {e} raised\"\n                if isinstance(e, warning_type):\n                    self.fail(f\"{msg}: {e}\")\n                else:\n                    raise\n\n\nclass Test01_PyparsingTestInit(TestCase):\n    def runTest(self):\n        print(\n            \"Beginning test of pyparsing, version\",\n            pp.__version__,\n            pp.__version_time__,\n        )\n        python_jit_enabled = \"--enable-experimental-jit\" in shlex.split(\n            sysconfig.get_config_vars().get(\"CONFIG_ARGS\", \"\")\n        )\n        print(\n            f\"Python version {sys.version} {'(JIT enabled)' if python_jit_enabled else ''}\"\n        )\n        print(f\"__version_info__     : {pp.__version_info__}\")\n        print(f\"__version_info__ repr: {repr(pp.__version_info__)}\")\n\n\nclass Test01a_PyparsingEnvironmentTests(TestCase):\n    def runTest(self):\n        # test warnings enable detection\n        # fmt: off\n        tests = [\n            (([], \"\",), False),\n            (([\"d\", ], \"\",), True),\n            (([\"d\", \"i:::pyparsing\", ], \"\",), False),\n            (([\"d:::pyparsing\", ], \"\",), True),\n            (([\"d:::pyparsing\", \"i\", ], \"\",), False),\n            (([\"d:::blah\", ], \"\",), False),\n            (([\"i\", ], \"\",), False),\n            (([], \"1\",), True),\n            (([\"d\", ], \"1\",), True),\n            (([\"d\", \"i:::pyparsing\", ], \"1\",), False),\n            (([\"d:::pyparsing\", ], \"1\",), True),\n            (([\"d:::pyparsing\", \"i\", ], \"1\",), False),\n            (([\"d:::blah\", ], \"1\",), True),\n            (([\"i\", ], \"1\",), False),\n        ]\n        # fmt: on\n\n        all_success = True\n        for args, expected in tests:\n            message = f\"{args} should be {expected}\"\n            print(message, end=\" -> \")\n            actual = pp.core._should_enable_warnings(*args)\n            print(\"PASS\" if actual == expected else \"FAIL\")\n            if actual != expected:\n                all_success = False\n        self.assertTrue(all_success, \"failed warnings enable test\")\n\n\nclass Test01b_PyparsingUnitTestUtilitiesTests(TestCase):\n    def runTest(self):\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_on_parse_using_empty_Forward)\n\n            # test assertDoesNotWarn raises an AssertionError\n            with self.assertRaises(AssertionError):\n                with self.assertDoesNotWarn(\n                    msg=\"warned when parsing with an empty Forward expression warning was suppressed\",\n                ):\n                    base = pp.Forward()\n                    try:\n                        print(base.parseString(\"x\"))\n                    except ParseException as pe:\n                        pass\n\n\nclass Test02_WithoutPackrat(ppt.TestParseResultsAsserts, TestCase):\n    suite_context = None\n    save_suite_context = None\n\n    def setUp(self):\n        self.suite_context.restore()\n\n    def test000_assert_packrat_status(self):\n        print(\"Packrat enabled:\", ParserElement._packratEnabled)\n        self.assertFalse(ParserElement._packratEnabled, \"packrat enabled\")\n\n    def testScanStringWithOverlap(self):\n        parser = pp.Word(pp.alphas, exact=3)\n        without_overlaps = sum(t for t, s, e in parser.scanString(\"ABCDEFGHI\")).asList()\n        self.assertEqual(\n            [\"ABC\", \"DEF\", \"GHI\"],\n            without_overlaps,\n            msg=\"scanString without overlaps failed\",\n        )\n        with_overlaps = sum(\n            t for t, s, e in parser.scanString(\"ABCDEFGHI\", overlap=True)\n        ).asList()\n        self.assertEqual(\n            [\"ABC\", \"BCD\", \"CDE\", \"DEF\", \"EFG\", \"FGH\", \"GHI\"],\n            with_overlaps,\n            msg=\"scanString with overlaps failed\",\n        )\n\n    def testCombineWithResultsNames(self):\n        # test case reproducing Issue #350\n        from pyparsing import White, alphas, Word\n\n        parser = White(\" \\t\").set_results_name(\"indent\") + Word(\n            alphas\n        ).set_results_name(\"word\")\n        result = parser.parse_string(\"    test\")\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result, [\"    \", \"test\"], {\"indent\": \"    \", \"word\": \"test\"}\n        )\n\n        parser = White(\" \\t\") + Word(alphas).set_results_name(\"word\")\n        result = parser.parse_string(\"    test\")\n        print(result.dump())\n        self.assertParseResultsEquals(result, [\"    \", \"test\"], {\"word\": \"test\"})\n\n    def testTransformString(self):\n        make_int_with_commas = ppc.integer().addParseAction(lambda t: f\"{t[0]:,}\")\n        lower_case_words = pp.Word(pp.alphas.lower(), asKeyword=True) + pp.Optional(\n            pp.White()\n        )\n        nested_list = pp.nestedExpr().addParseAction(pp.ParseResults.asList)\n        transformer = make_int_with_commas | nested_list | lower_case_words.suppress()\n\n        in_string = (\n            \"I wish to buy 12345 shares of Acme Industries (as a gift to my (ex)wife)\"\n        )\n        print(in_string)\n        out_string = transformer.transformString(in_string)\n        print(out_string)\n        self.assertEqual(\n            \"I 12,345 Acme Industries asagifttomyexwife\",\n            out_string,\n            msg=\"failure in transformString\",\n        )\n\n    def testTransformStringWithLeadingWhitespace(self):\n        sample = \"\\n\\ncheck\"\n        sample = \"    check\"\n        keywords = pp.oneOf(\"aaa bbb\", asKeyword=True)\n        ident = ~keywords + pp.Word(pp.alphas)\n        ident = pp.Combine(~keywords + pp.Word(pp.alphas))\n        # ident.add_parse_action(lambda t: t[0].upper())\n        ident.add_parse_action(ppc.upcaseTokens)\n        transformed = ident.transformString(sample)\n\n        print(ppt.with_line_numbers(sample))\n        print(ppt.with_line_numbers(transformed))\n        self.assertEqual(sample.replace(\"check\", \"CHECK\"), transformed)\n\n    def testTransformStringWithLeadingNotAny(self):\n        sample = \"print a100\"\n        keywords = set(\"print read\".split())\n        ident = pp.Word(pp.alphas, pp.alphanums).add_condition(\n            lambda t: t[0] not in keywords\n        )\n        print(ident.searchString(sample))\n\n    def testTransformStringWithExpectedLeadingWhitespace(self):\n        sample1 = \"\\n\\ncheck aaa\"\n        sample2 = \"    check aaa\"\n        keywords = pp.oneOf(\"aaa bbb\", asKeyword=True)\n        # This construct only works with parse_string, not with scan_string or its siblings\n        # ident = ~keywords + pp.Word(pp.alphas)\n        ident = pp.Word(pp.alphas)\n        ident.add_parse_action(ppc.upcaseTokens)\n\n        for sample in sample1, sample2:\n            transformed = (keywords | ident).transformString(sample)\n            print(ppt.with_line_numbers(sample))\n            print(ppt.with_line_numbers(transformed))\n            self.assertEqual(sample.replace(\"check\", \"CHECK\"), transformed)\n            print()\n\n    def testTransformStringWithLeadingWhitespaceFromTranslateProject(self):\n        from pyparsing import Keyword, Word, alphas, alphanums, Combine\n\n        block_start = (Keyword(\"{\") | Keyword(\"BEGIN\")).set_name(\"block_start\")\n        block_end = (Keyword(\"}\") | Keyword(\"END\")).set_name(\"block_end\")\n        reserved_words = block_start | block_end\n\n        # this is the first critical part of this test, an And with a leading NotAny\n        # This construct only works with parse_string, not with scan_string or its siblings\n        # name_id = ~reserved_words + Word(alphas, alphanums + \"_\").set_name(\"name_id\")\n        name_id = Word(alphas, alphanums + \"_\").set_name(\"name_id\")\n\n        dialog = name_id(\"block_id\") + (Keyword(\"DIALOGEX\") | Keyword(\"DIALOG\"))(\n            \"block_type\"\n        )\n        string_table = Keyword(\"STRINGTABLE\")(\"block_type\")\n\n        test_string = (\n            \"\"\"\\r\\nSTRINGTABLE\\r\\nBEGIN\\r\\n// Comment\\r\\nIDS_1 \"Copied\"\\r\\nEND\\r\\n\"\"\"\n        )\n        print(\"Original:\")\n        print(repr(test_string))\n        print(\"Should match:\")\n        # this is the second critical part of this test, an Or or MatchFirst including dialog\n        for parser in (dialog ^ string_table, dialog | string_table):\n            result = (reserved_words | parser).transformString(test_string)\n            print(repr(result))\n            self.assertEqual(\n                test_string,\n                result,\n                \"Failed whitespace skipping with NotAny and MatchFirst/Or\",\n            )\n\n    def testUpdateDefaultWhitespace(self):\n        prev_default_whitespace_chars = pp.ParserElement.DEFAULT_WHITE_CHARS\n        try:\n            pp.dblQuotedString.copyDefaultWhiteChars = False\n            pp.ParserElement.setDefaultWhitespaceChars(\" \\t\")\n            self.assertEqual(\n                set(\" \\t\"),\n                set(pp.sglQuotedString.whiteChars),\n                \"setDefaultWhitespaceChars did not update sglQuotedString\",\n            )\n            self.assertEqual(\n                set(prev_default_whitespace_chars),\n                set(pp.dblQuotedString.whiteChars),\n                \"setDefaultWhitespaceChars updated dblQuotedString but should not\",\n            )\n        finally:\n            pp.dblQuotedString.copyDefaultWhiteChars = True\n            pp.ParserElement.setDefaultWhitespaceChars(prev_default_whitespace_chars)\n\n            self.assertEqual(\n                set(prev_default_whitespace_chars),\n                set(pp.dblQuotedString.whiteChars),\n                \"setDefaultWhitespaceChars updated dblQuotedString\",\n            )\n\n        with ppt.reset_pyparsing_context():\n            pp.ParserElement.setDefaultWhitespaceChars(\" \\t\")\n            self.assertNotEqual(\n                set(prev_default_whitespace_chars),\n                set(pp.dblQuotedString.whiteChars),\n                \"setDefaultWhitespaceChars updated dblQuotedString but should not\",\n            )\n\n            EOL = pp.LineEnd().suppress().setName(\"EOL\")\n\n            # Identifiers is a string + optional $\n            identifier = pp.Combine(pp.Word(pp.alphas) + pp.Optional(\"$\"))\n\n            # Literals (number or double quoted string)\n            literal = ppc.number | pp.dblQuotedString\n            expression = literal | identifier\n            # expression.setName(\"expression\").setDebug()\n            # ppc.number.setDebug()\n            # ppc.integer.setDebug()\n\n            line_number = ppc.integer\n\n            # Keywords\n            PRINT = pp.CaselessKeyword(\"print\")\n            print_stmt = PRINT - pp.ZeroOrMore(expression | \";\")\n            statement = print_stmt\n            code_line = pp.Group(line_number + statement + EOL)\n            program = pp.ZeroOrMore(code_line)\n\n            test = \"\"\"\\\n            10 print 123;\n            20 print 234; 567;\n            30 print 890\n            \"\"\"\n\n            parsed_program = program.parseString(test, parseAll=True)\n            print(parsed_program.dump())\n            self.assertEqual(\n                3,\n                len(parsed_program),\n                \"failed to apply new whitespace chars to existing builtins\",\n            )\n\n    def testUpdateDefaultWhitespace2(self):\n        with ppt.reset_pyparsing_context():\n            expr_tests = [\n                (pp.dblQuotedString, '\"abc\"'),\n                (pp.sglQuotedString, \"'def'\"),\n                (ppc.integer, \"123\"),\n                (ppc.number, \"4.56\"),\n                (ppc.identifier, \"a_bc\"),\n            ]\n            NL = pp.LineEnd()\n\n            for expr, test_str in expr_tests:\n                parser = pp.Group(expr[1, ...] + pp.Optional(NL))[1, ...]\n                test_string = \"\\n\".join([test_str] * 3)\n                result = parser.parseString(test_string, parseAll=True)\n                print(result.dump())\n                self.assertEqual(1, len(result), f\"failed {test_string!r}\")\n\n            pp.ParserElement.setDefaultWhitespaceChars(\" \\t\")\n\n            for expr, test_str in expr_tests:\n                parser = pp.Group(expr[1, ...] + pp.Optional(NL))[1, ...]\n                test_string = \"\\n\".join([test_str] * 3)\n                result = parser.parseString(test_string, parseAll=True)\n                print(result.dump())\n                self.assertEqual(3, len(result), f\"failed {test_string!r}\")\n\n            pp.ParserElement.setDefaultWhitespaceChars(\" \\n\\t\")\n\n            for expr, test_str in expr_tests:\n                parser = pp.Group(expr[1, ...] + pp.Optional(NL))[1, ...]\n                test_string = \"\\n\".join([test_str] * 3)\n                result = parser.parseString(test_string, parseAll=True)\n                print(result.dump())\n                self.assertEqual(1, len(result), f\"failed {test_string!r}\")\n\n    def testParseFourFn(self):\n        import examples.fourFn as fourFn\n        import math\n\n        def test(s, ans):\n            fourFn.exprStack[:] = []\n            results = fourFn.BNF().parseString(s, parseAll=True)\n            try:\n                resultValue = fourFn.evaluate_stack(fourFn.exprStack)\n            except Exception:\n                self.assertIsNone(ans, f\"exception raised for expression {s!r}\")\n            else:\n                self.assertEqual(\n                    ans,\n                    resultValue,\n                    f\"failed to evaluate {s}, got {resultValue:f}\",\n                )\n                print(s, \"->\", resultValue)\n\n        test(\"9\", 9)\n        test(\"-9\", -9)\n        test(\"--9\", 9)\n        test(\"-E\", -math.e)\n        test(\"9 + 3 + 5\", 9 + 3 + 5)\n        test(\"9 + 3 / 11\", 9 + 3.0 / 11)\n        test(\"(9 + 3)\", (9 + 3))\n        test(\"(9+3) / 11\", (9 + 3.0) / 11)\n        test(\"9 - 12 - 6\", 9 - 12 - 6)\n        test(\"9 - (12 - 6)\", 9 - (12 - 6))\n        test(\"2*3.14159\", 2 * 3.14159)\n        test(\"3.1415926535*3.1415926535 / 10\", 3.1415926535 * 3.1415926535 / 10)\n        test(\"PI * PI / 10\", math.pi * math.pi / 10)\n        test(\"PI*PI/10\", math.pi * math.pi / 10)\n        test(\"PI^2\", math.pi**2)\n        test(\"round(PI^2)\", round(math.pi**2))\n        test(\"6.02E23 * 8.048\", 6.02e23 * 8.048)\n        test(\"e / 3\", math.e / 3)\n        test(\"sin(PI/2)\", math.sin(math.pi / 2))\n        test(\"10+sin(PI/4)^2\", 10 + math.sin(math.pi / 4) ** 2)\n        test(\"trunc(E)\", int(math.e))\n        test(\"trunc(-E)\", int(-math.e))\n        test(\"round(E)\", round(math.e))\n        test(\"round(-E)\", round(-math.e))\n        test(\"E^PI\", math.e**math.pi)\n        test(\"exp(0)\", 1)\n        test(\"exp(1)\", math.e)\n        test(\"2^3^2\", 2**3**2)\n        test(\"(2^3)^2\", (2**3) ** 2)\n        test(\"2^3+2\", 2**3 + 2)\n        test(\"2^3+5\", 2**3 + 5)\n        test(\"2^9\", 2**9)\n        test(\"sgn(-2)\", -1)\n        test(\"sgn(0)\", 0)\n        test(\"sgn(0.1)\", 1)\n        test(\"foo(0.1)\", None)\n        test(\"round(E, 3)\", round(math.e, 3))\n        test(\"round(PI^2, 3)\", round(math.pi**2, 3))\n        test(\"sgn(cos(PI/4))\", 1)\n        test(\"sgn(cos(PI/2))\", 0)\n        test(\"sgn(cos(PI*3/4))\", -1)\n        test(\"+(sgn(cos(PI/4)))\", 1)\n        test(\"-(sgn(cos(PI/4)))\", -1)\n\n    def testParseSQL(self):\n        # SQL parser uses packrat parsing, not compatible with LR\n        if ParserElement._left_recursion_enabled:\n            return\n\n        import examples.simpleSQL as simpleSQL\n\n        def test(s, num_expected_toks, expected_errloc=-1):\n            try:\n                sqlToks = flatten(\n                    simpleSQL.simpleSQL.parseString(s, parseAll=True).asList()\n                )\n                print(s, sqlToks, len(sqlToks))\n                self.assertEqual(\n                    num_expected_toks,\n                    len(sqlToks),\n                    f\"invalid parsed tokens, expected {num_expected_toks}, found {len(sqlToks)} ({sqlToks})\",\n                )\n            except ParseException as e:\n                if expected_errloc >= 0:\n                    self.assertEqual(\n                        expected_errloc,\n                        e.loc,\n                        f\"expected error at {expected_errloc}, found at {e.loc}\",\n                    )\n\n        test(\"SELECT * from XYZZY, ABC\", 6)\n        test(\"select * from SYS.XYZZY\", 5)\n        test(\"Select A from Sys.dual\", 5)\n        test(\"Select A,B,C from Sys.dual\", 7)\n        test(\"Select A, B, C from Sys.dual\", 7)\n        test(\"Select A, B, C from Sys.dual, Table2   \", 8)\n        test(\"Xelect A, B, C from Sys.dual\", 0, 0)\n        test(\"Select A, B, C frox Sys.dual\", 0, 15)\n        test(\"Select\", 0, 6)\n        test(\"Select &&& frox Sys.dual\", 0, 7)\n        test(\"Select A from Sys.dual where a in ('RED','GREEN','BLUE')\", 12)\n        test(\n            \"Select A from Sys.dual where a in ('RED','GREEN','BLUE') and b in (10,20,30)\",\n            20,\n        )\n        test(\n            \"Select A,b from table1,table2 where table1.id eq table2.id -- test out comparison operators\",\n            10,\n        )\n\n    def testParseConfigFile(self):\n        from examples import configParse\n\n        def test(fnam, num_expected_toks, resCheckList):\n            print(\"Parsing\", fnam, \"...\", end=\" \")\n            with open(fnam) as infile:\n                iniFileLines = \"\\n\".join(infile.read().splitlines())\n            iniData = configParse.inifile_BNF().parseString(iniFileLines, parseAll=True)\n            print(len(flatten(iniData.asList())))\n            print(list(iniData.keys()))\n            self.assertEqual(\n                num_expected_toks,\n                len(flatten(iniData.asList())),\n                f\"file {fnam} not parsed correctly\",\n            )\n            for chkkey, chkexpect in resCheckList:\n                var = iniData\n                for attr in chkkey.split(\".\"):\n                    var = getattr(var, attr)\n                print(chkkey, var, chkexpect)\n                self.assertEqual(\n                    chkexpect,\n                    var,\n                    f\"ParseConfigFileTest: failed to parse ini {chkkey!r} as expected {chkexpect!r}, found {var}\",\n                )\n            print(\"OK\")\n\n        test(\n            \"tests/karthik.ini\",\n            23,\n            [(\"users.K\", \"8\"), (\"users.mod_scheme\", \"'QPSK'\"), (\"users.Na\", \"K+2\")],\n        )\n        test(\n            \"examples/Setup.ini\",\n            125,\n            [\n                (\"Startup.audioinf\", \"M3i\"),\n                (\"Languages.key1\", \"0x0003\"),\n                (\"test.foo\", \"bar\"),\n            ],\n        )\n\n    def testParseJSONData(self):\n        expected = [\n            {\n                \"glossary\": {\n                    \"GlossDiv\": {\n                        \"GlossList\": [\n                            {\n                                \"Abbrev\": \"ISO 8879:1986\",\n                                \"Acronym\": \"SGML\",\n                                \"AvogadroNumber\": 6.02e23,\n                                \"EmptyDict\": {},\n                                \"EmptyList\": [],\n                                \"EvenPrimesGreaterThan2\": [],\n                                \"FermatTheoremInMargin\": False,\n                                \"GlossDef\": \"A meta-markup language, \"\n                                \"used to create markup \"\n                                \"languages such as \"\n                                \"DocBook.\",\n                                \"GlossSeeAlso\": [\"GML\", \"XML\", \"markup\"],\n                                \"GlossTerm\": \"Standard Generalized \" \"Markup Language\",\n                                \"ID\": \"SGML\",\n                                \"LargestPrimeLessThan100\": 97,\n                                \"MapRequiringFiveColors\": None,\n                                \"PrimesLessThan10\": [2, 3, 5, 7],\n                                \"SortAs\": \"SGML\",\n                            }\n                        ],\n                        \"title\": \"S\",\n                    },\n                    \"title\": \"example glossary\",\n                }\n            },\n            {\n                \"menu\": {\n                    \"id\": \"file\",\n                    \"popup\": {\n                        \"menuitem\": [\n                            {\"onclick\": \"CreateNewDoc()\", \"value\": \"New\"},\n                            {\"onclick\": \"OpenDoc()\", \"value\": \"Open\"},\n                            {\"onclick\": \"CloseDoc()\", \"value\": \"Close\"},\n                        ]\n                    },\n                    \"value\": \"File:\",\n                }\n            },\n            {\n                \"widget\": {\n                    \"debug\": \"on\",\n                    \"image\": {\n                        \"alignment\": \"center\",\n                        \"hOffset\": 250,\n                        \"name\": \"sun1\",\n                        \"src\": \"Images/Sun.png\",\n                        \"vOffset\": 250,\n                    },\n                    \"text\": {\n                        \"alignment\": \"center\",\n                        \"data\": \"Click Here\",\n                        \"hOffset\": 250,\n                        \"name\": \"text1\",\n                        \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\",\n                        \"size\": 36,\n                        \"style\": \"bold\",\n                        \"vOffset\": 100,\n                    },\n                    \"window\": {\n                        \"height\": 500,\n                        \"name\": \"main_window\",\n                        \"title\": \"Sample Konfabulator Widget\",\n                        \"width\": 500,\n                    },\n                }\n            },\n            {\n                \"web-app\": {\n                    \"servlet\": [\n                        {\n                            \"init-param\": {\n                                \"cachePackageTagsRefresh\": 60,\n                                \"cachePackageTagsStore\": 200,\n                                \"cachePackageTagsTrack\": 200,\n                                \"cachePagesDirtyRead\": 10,\n                                \"cachePagesRefresh\": 10,\n                                \"cachePagesStore\": 100,\n                                \"cachePagesTrack\": 200,\n                                \"cacheTemplatesRefresh\": 15,\n                                \"cacheTemplatesStore\": 50,\n                                \"cacheTemplatesTrack\": 100,\n                                \"configGlossary:adminEmail\": \"ksm@pobox.com\",\n                                \"configGlossary:installationAt\": \"Philadelphia, \" \"PA\",\n                                \"configGlossary:poweredBy\": \"Cofax\",\n                                \"configGlossary:poweredByIcon\": \"/images/cofax.gif\",\n                                \"configGlossary:staticPath\": \"/content/static\",\n                                \"dataStoreClass\": \"org.cofax.SqlDataStore\",\n                                \"dataStoreConnUsageLimit\": 100,\n                                \"dataStoreDriver\": \"com.microsoft.jdbc.sqlserver.SQLServerDriver\",\n                                \"dataStoreInitConns\": 10,\n                                \"dataStoreLogFile\": \"/usr/local/tomcat/logs/datastore.log\",\n                                \"dataStoreLogLevel\": \"debug\",\n                                \"dataStoreMaxConns\": 100,\n                                \"dataStoreName\": \"cofax\",\n                                \"dataStorePassword\": \"dataStoreTestQuery\",\n                                \"dataStoreTestQuery\": \"SET NOCOUNT \"\n                                \"ON;select \"\n                                \"test='test';\",\n                                \"dataStoreUrl\": \"jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon\",\n                                \"dataStoreUser\": \"sa\",\n                                \"defaultFileTemplate\": \"articleTemplate.htm\",\n                                \"defaultListTemplate\": \"listTemplate.htm\",\n                                \"jspFileTemplate\": \"articleTemplate.jsp\",\n                                \"jspListTemplate\": \"listTemplate.jsp\",\n                                \"maxUrlLength\": 500,\n                                \"redirectionClass\": \"org.cofax.SqlRedirection\",\n                                \"searchEngineFileTemplate\": \"forSearchEngines.htm\",\n                                \"searchEngineListTemplate\": \"forSearchEnginesList.htm\",\n                                \"searchEngineRobotsDb\": \"WEB-INF/robots.db\",\n                                \"templateLoaderClass\": \"org.cofax.FilesTemplateLoader\",\n                                \"templateOverridePath\": \"\",\n                                \"templatePath\": \"templates\",\n                                \"templateProcessorClass\": \"org.cofax.WysiwygTemplate\",\n                                \"useDataStore\": True,\n                                \"useJSP\": False,\n                            },\n                            \"servlet-class\": \"org.cofax.cds.CDSServlet\",\n                            \"servlet-name\": \"cofaxCDS\",\n                        },\n                        {\n                            \"init-param\": {\n                                \"mailHost\": \"mail1\",\n                                \"mailHostOverride\": \"mail2\",\n                            },\n                            \"servlet-class\": \"org.cofax.cds.EmailServlet\",\n                            \"servlet-name\": \"cofaxEmail\",\n                        },\n                        {\n                            \"servlet-class\": \"org.cofax.cds.AdminServlet\",\n                            \"servlet-name\": \"cofaxAdmin\",\n                        },\n                        {\n                            \"servlet-class\": \"org.cofax.cds.FileServlet\",\n                            \"servlet-name\": \"fileServlet\",\n                        },\n                        {\n                            \"init-param\": {\n                                \"adminGroupID\": 4,\n                                \"betaServer\": True,\n                                \"dataLog\": 1,\n                                \"dataLogLocation\": \"/usr/local/tomcat/logs/dataLog.log\",\n                                \"dataLogMaxSize\": \"\",\n                                \"fileTransferFolder\": \"/usr/local/tomcat/webapps/content/fileTransferFolder\",\n                                \"log\": 1,\n                                \"logLocation\": \"/usr/local/tomcat/logs/CofaxTools.log\",\n                                \"logMaxSize\": \"\",\n                                \"lookInContext\": 1,\n                                \"removePageCache\": \"/content/admin/remove?cache=pages&id=\",\n                                \"removeTemplateCache\": \"/content/admin/remove?cache=templates&id=\",\n                                \"templatePath\": \"toolstemplates/\",\n                            },\n                            \"servlet-class\": \"org.cofax.cms.CofaxToolsServlet\",\n                            \"servlet-name\": \"cofaxTools\",\n                        },\n                    ],\n                    \"servlet-mapping\": {\n                        \"cofaxAdmin\": \"/admin/*\",\n                        \"cofaxCDS\": \"/\",\n                        \"cofaxEmail\": \"/cofaxutil/aemail/*\",\n                        \"cofaxTools\": \"/tools/*\",\n                        \"fileServlet\": \"/static/*\",\n                    },\n                    \"taglib\": {\n                        \"taglib-location\": \"/WEB-INF/tlds/cofax.tld\",\n                        \"taglib-uri\": \"cofax.tld\",\n                    },\n                }\n            },\n            {\n                \"menu\": {\n                    \"header\": \"SVG Viewer\",\n                    \"items\": [\n                        {\"id\": \"Open\"},\n                        {\"id\": \"OpenNew\", \"label\": \"Open New\"},\n                        None,\n                        {\"id\": \"ZoomIn\", \"label\": \"Zoom In\"},\n                        {\"id\": \"ZoomOut\", \"label\": \"Zoom Out\"},\n                        {\"id\": \"OriginalView\", \"label\": \"Original View\"},\n                        None,\n                        {\"id\": \"Quality\"},\n                        {\"id\": \"Pause\"},\n                        {\"id\": \"Mute\"},\n                        None,\n                        {\"id\": \"Find\", \"label\": \"Find...\"},\n                        {\"id\": \"FindAgain\", \"label\": \"Find Again\"},\n                        {\"id\": \"Copy\"},\n                        {\"id\": \"CopyAgain\", \"label\": \"Copy Again\"},\n                        {\"id\": \"CopySVG\", \"label\": \"Copy SVG\"},\n                        {\"id\": \"ViewSVG\", \"label\": \"View SVG\"},\n                        {\"id\": \"ViewSource\", \"label\": \"View Source\"},\n                        {\"id\": \"SaveAs\", \"label\": \"Save As\"},\n                        None,\n                        {\"id\": \"Help\"},\n                        {\"id\": \"About\", \"label\": \"About Adobe CVG Viewer...\"},\n                    ],\n                }\n            },\n        ]\n\n        for t, exp_result in zip((test1, test2, test3, test4, test5), expected):\n            result = jsonObject.parseString(t, parseAll=True)\n            self.assertEqual(exp_result, result[0])\n\n    def testParseCommaSeparatedValues(self):\n        testData = [\n            \"a,b,c,100.2,,3\",\n            \"d, e, j k , m  \",\n            \"'Hello, World', f, g , , 5.1,x\",\n            \"John Doe, 123 Main St., Cleveland, Ohio\",\n            \"Jane Doe, 456 St. James St., Los Angeles , California   \",\n            \"\",\n        ]\n        testVals = [\n            [(3, \"100.2\"), (4, \"\"), (5, \"3\")],\n            [(2, \"j k\"), (3, \"m\")],\n            [(0, \"'Hello, World'\"), (2, \"g\"), (3, \"\")],\n            [(0, \"John Doe\"), (1, \"123 Main St.\"), (2, \"Cleveland\"), (3, \"Ohio\")],\n            [\n                (0, \"Jane Doe\"),\n                (1, \"456 St. James St.\"),\n                (2, \"Los Angeles\"),\n                (3, \"California\"),\n            ],\n        ]\n        for line, tests in zip(testData, testVals):\n            print(f\"Parsing: {line!r} ->\", end=\" \")\n            results = ppc.comma_separated_list.parseString(line, parseAll=True)\n            print(results)\n            for t in tests:\n                if not (len(results) > t[0] and results[t[0]] == t[1]):\n                    print(\"$$$\", results.dump())\n                    print(\"$$$\", results[0])\n                self.assertTrue(\n                    len(results) > t[0] and results[t[0]] == t[1],\n                    f\"failed on {line}, item {t[0]:d} s/b '{t[1]}', got '{results.asList()}'\",\n                )\n\n    def testParseEBNF(self):\n        from examples import ebnf\n\n        print(\"Constructing EBNF parser with pyparsing...\")\n\n        grammar = \"\"\"\n        syntax = (syntax_rule), {(syntax_rule)};\n        syntax_rule = meta_identifier, '=', definitions_list, ';';\n        definitions_list = single_definition, {'|', single_definition};\n        single_definition = syntactic_term, {',', syntactic_term};\n        syntactic_term = syntactic_factor,['-', syntactic_factor];\n        syntactic_factor = [integer, '*'], syntactic_primary;\n        syntactic_primary = optional_sequence | repeated_sequence |\n          grouped_sequence | meta_identifier | terminal_string;\n        optional_sequence = '[', definitions_list, ']';\n        repeated_sequence = '{', definitions_list, '}';\n        grouped_sequence = '(', definitions_list, ')';\n        (*\n        terminal_string = \"'\", character - \"'\", {character - \"'\"}, \"'\" |\n          '\"', character - '\"', {character - '\"'}, '\"';\n         meta_identifier = letter, {letter | digit};\n        integer = digit, {digit};\n        *)\n        \"\"\"\n\n        table = {}\n        table[\"terminal_string\"] = pp.quotedString\n        table[\"meta_identifier\"] = pp.Word(pp.alphas + \"_\", pp.alphas + \"_\" + pp.nums)\n        table[\"integer\"] = pp.Word(pp.nums)\n\n        print(\"Parsing EBNF grammar with EBNF parser...\")\n        parsers = ebnf.parse(grammar, table)\n        ebnf_parser = parsers[\"syntax\"]\n        ebnf_comment = pp.Literal(\"(*\") + ... + \"*)\"\n        ebnf_parser.ignore(ebnf_comment)\n        print(\"-\", \"\\n- \".join(parsers.keys()))\n        self.assertEqual(\n            13, len(list(parsers.keys())), \"failed to construct syntax grammar\"\n        )\n\n        print(\"Parsing EBNF grammar with generated EBNF parser...\")\n        parsed_chars = ebnf_parser.parseString(grammar, parseAll=True)\n        parsed_char_len = len(parsed_chars)\n\n        print(\"],\\n\".join(str(parsed_chars.asList()).split(\"],\")))\n        self.assertEqual(\n            98,\n            len(flatten(parsed_chars.asList())),\n            \"failed to tokenize grammar correctly\",\n        )\n\n    def testParseIDL(self):\n        from examples import idlParse\n\n        def test(strng, numToks, expectedErrloc=0):\n            print(strng)\n            try:\n                bnf = idlParse.CORBA_IDL_BNF()\n                tokens = bnf.parseString(strng, parseAll=True)\n                print(\"tokens = \")\n                tokens.pprint()\n                tokens = flatten(tokens.asList())\n                print(len(tokens))\n                self.assertEqual(\n                    numToks,\n                    len(tokens),\n                    f\"error matching IDL string, {strng} -> {tokens}\",\n                )\n            except ParseException as err:\n                print(err.line)\n                print(f\"{' ' * (err.column - 1)}^\")\n                print(err)\n                self.assertEqual(\n                    0,\n                    numToks,\n                    f\"unexpected ParseException while parsing {strng}, {err}\",\n                )\n                self.assertEqual(\n                    expectedErrloc,\n                    err.loc,\n                    f\"expected ParseException at {expectedErrloc}, found exception at {err.loc}\",\n                )\n\n        test(\n            \"\"\"\n            /*\n             * a block comment *\n             */\n            typedef string[10] tenStrings;\n            typedef sequence<string> stringSeq;\n            typedef sequence< sequence<string> > stringSeqSeq;\n\n            interface QoSAdmin {\n                stringSeq method1(in string arg1, inout long arg2);\n                stringSeqSeq method2(in string arg1, inout long arg2, inout long arg3);\n                string method3();\n              };\n            \"\"\",\n            59,\n        )\n        test(\n            \"\"\"\n            /*\n             * a block comment *\n             */\n            typedef string[10] tenStrings;\n            typedef\n                /** ** *** **** *\n                 * a block comment *\n                 */\n                sequence<string> /*comment inside an And */ stringSeq;\n            /* */  /**/ /***/ /****/\n            typedef sequence< sequence<string> > stringSeqSeq;\n\n            interface QoSAdmin {\n                stringSeq method1(in string arg1, inout long arg2);\n                stringSeqSeq method2(in string arg1, inout long arg2, inout long arg3);\n                string method3();\n              };\n            \"\"\",\n            59,\n        )\n        test(\n            r\"\"\"\n              const string test=\"Test String\\n\";\n              const long  a = 0;\n              const long  b = -100;\n              const float c = 3.14159;\n              const long  d = 0x007f7f7f;\n              exception TestException\n                {\n                string msg;\n                sequence<string> dataStrings;\n                };\n\n              interface TestInterface\n                {\n                void method1(in string arg1, inout long arg2);\n                };\n            \"\"\",\n            60,\n        )\n        test(\n            \"\"\"\n            module Test1\n              {\n              exception TestException\n                {\n                string msg;\n                ];\n\n              interface TestInterface\n                {\n                void method1(in string arg1, inout long arg2)\n                  raises (TestException);\n                };\n              };\n            \"\"\",\n            0,\n            56,\n        )\n        test(\n            \"\"\"\n            module Test1\n              {\n              exception TestException\n                {\n                string msg;\n                };\n\n              };\n            \"\"\",\n            13,\n        )\n\n    def testParseVerilog(self):\n        pass\n\n    def testScanString(self):\n        testdata = \"\"\"\n            <table border=\"0\" cellpadding=\"3\" cellspacing=\"3\" frame=\"\" width=\"90%\">\n                <tr align=\"left\" valign=\"top\">\n                        <td><b>Name</b></td>\n                        <td><b>IP Address</b></td>\n                        <td><b>Location</b></td>\n                </tr>\n                <tr align=\"left\" valign=\"top\" bgcolor=\"#c7efce\">\n                        <td>time-a.nist.gov</td>\n                        <td>129.6.15.28</td>\n                        <td>NIST, Gaithersburg, Maryland</td>\n                </tr>\n                <tr align=\"left\" valign=\"top\">\n                        <td>time-b.nist.gov</td>\n                        <td>129.6.15.29</td>\n                        <td>NIST, Gaithersburg, Maryland</td>\n                </tr>\n                <tr align=\"left\" valign=\"top\" bgcolor=\"#c7efce\">\n                        <td>time-a.timefreq.bldrdoc.gov</td>\n                        <td>132.163.4.101</td>\n                        <td>NIST, Boulder, Colorado</td>\n                </tr>\n                <tr align=\"left\" valign=\"top\">\n                        <td>time-b.timefreq.bldrdoc.gov</td>\n                        <td>132.163.4.102</td>\n                        <td>NIST, Boulder, Colorado</td>\n                </tr>\n                <tr align=\"left\" valign=\"top\" bgcolor=\"#c7efce\">\n                        <td>time-c.timefreq.bldrdoc.gov</td>\n                        <td>132.163.4.103</td>\n                        <td>NIST, Boulder, Colorado</td>\n                </tr>\n            </table>\n            \"\"\"\n        integer = pp.Word(pp.nums)\n        ipAddress = pp.Combine(integer + \".\" + integer + \".\" + integer + \".\" + integer)\n        tdStart = pp.Suppress(\"<td>\")\n        tdEnd = pp.Suppress(\"</td>\")\n        timeServerPattern = (\n            tdStart\n            + ipAddress(\"ipAddr\")\n            + tdEnd\n            + tdStart\n            + pp.CharsNotIn(\"<\")(\"loc\")\n            + tdEnd\n        )\n        servers = [\n            srvr.ipAddr\n            for srvr, startloc, endloc in timeServerPattern.scanString(testdata)\n        ]\n\n        print(servers)\n        self.assertEqual(\n            [\n                \"129.6.15.28\",\n                \"129.6.15.29\",\n                \"132.163.4.101\",\n                \"132.163.4.102\",\n                \"132.163.4.103\",\n            ],\n            servers,\n            \"failed scanString()\",\n        )\n\n        # test for stringEnd detection in scanString\n        foundStringEnds = [r for r in pp.StringEnd().scanString(\"xyzzy\")]\n        print(foundStringEnds)\n        self.assertTrue(foundStringEnds, \"Failed to find StringEnd in scanString\")\n\n    def testQuotedStrings(self):\n        testData = \"\"\"\n                'a valid single quoted string'\n                'an invalid single quoted string\n                 because it spans lines'\n                \"a valid double quoted string\"\n                \"an invalid double quoted string\n                 because it spans lines\"\n            \"\"\"\n        print(testData)\n\n        with self.subTest():\n            sglStrings = [\n                (t[0], b, e) for (t, b, e) in pp.sglQuotedString.scanString(testData)\n            ]\n            print(sglStrings)\n            self.assertTrue(\n                len(sglStrings) == 1\n                and (sglStrings[0][1] == 17 and sglStrings[0][2] == 47),\n                \"single quoted string failure\",\n            )\n\n        with self.subTest():\n            dblStrings = [\n                (t[0], b, e) for (t, b, e) in pp.dblQuotedString.scanString(testData)\n            ]\n            print(dblStrings)\n            self.assertTrue(\n                len(dblStrings) == 1\n                and (dblStrings[0][1] == 154 and dblStrings[0][2] == 184),\n                \"double quoted string failure\",\n            )\n\n        with self.subTest():\n            allStrings = [\n                (t[0], b, e) for (t, b, e) in pp.quotedString.scanString(testData)\n            ]\n            print(allStrings)\n            self.assertTrue(\n                len(allStrings) == 2\n                and (allStrings[0][1] == 17 and allStrings[0][2] == 47)\n                and (allStrings[1][1] == 154 and allStrings[1][2] == 184),\n                \"quoted string failure\",\n            )\n\n        escapedQuoteTest = r\"\"\"\n                'This string has an escaped (\\') quote character'\n                \"This string has an escaped (\\\") quote character\"\n            \"\"\"\n\n        with self.subTest():\n            sglStrings = [\n                (t[0], b, e)\n                for (t, b, e) in pp.sglQuotedString.scanString(escapedQuoteTest)\n            ]\n            print(sglStrings)\n            self.assertTrue(\n                len(sglStrings) == 1\n                and (sglStrings[0][1] == 17 and sglStrings[0][2] == 66),\n                f\"single quoted string escaped quote failure ({sglStrings[0]})\",\n            )\n\n        with self.subTest():\n            dblStrings = [\n                (t[0], b, e)\n                for (t, b, e) in pp.dblQuotedString.scanString(escapedQuoteTest)\n            ]\n            print(dblStrings)\n            self.assertTrue(\n                len(dblStrings) == 1\n                and (dblStrings[0][1] == 83 and dblStrings[0][2] == 132),\n                f\"double quoted string escaped quote failure ({dblStrings[0]})\",\n            )\n\n        with self.subTest():\n            allStrings = [\n                (t[0], b, e)\n                for (t, b, e) in pp.quotedString.scanString(escapedQuoteTest)\n            ]\n            print(allStrings)\n            self.assertTrue(\n                len(allStrings) == 2\n                and (\n                    allStrings[0][1] == 17\n                    and allStrings[0][2] == 66\n                    and allStrings[1][1] == 83\n                    and allStrings[1][2] == 132\n                ),\n                f\"quoted string escaped quote failure ({[str(s[0]) for s in allStrings]})\",\n            )\n\n        dblQuoteTest = r\"\"\"\n                'This string has an doubled ('') quote character'\n                \"This string has an doubled (\"\") quote character\"\n            \"\"\"\n        with self.subTest():\n            sglStrings = [\n                (t[0], b, e)\n                for (t, b, e) in pp.sglQuotedString.scanString(dblQuoteTest)\n            ]\n            print(sglStrings)\n            self.assertTrue(\n                len(sglStrings) == 1\n                and (sglStrings[0][1] == 17 and sglStrings[0][2] == 66),\n                f\"single quoted string escaped quote failure ({sglStrings[0]})\",\n            )\n\n        with self.subTest():\n            dblStrings = [\n                (t[0], b, e)\n                for (t, b, e) in pp.dblQuotedString.scanString(dblQuoteTest)\n            ]\n            print(dblStrings)\n            self.assertTrue(\n                len(dblStrings) == 1\n                and (dblStrings[0][1] == 83 and dblStrings[0][2] == 132),\n                f\"double quoted string escaped quote failure ({dblStrings[0]})\",\n            )\n\n        with self.subTest():\n            allStrings = [\n                (t[0], b, e) for (t, b, e) in pp.quotedString.scanString(dblQuoteTest)\n            ]\n            print(allStrings)\n            self.assertTrue(\n                len(allStrings) == 2\n                and (\n                    allStrings[0][1] == 17\n                    and allStrings[0][2] == 66\n                    and allStrings[1][1] == 83\n                    and allStrings[1][2] == 132\n                ),\n                f\"quoted string escaped quote failure ({[str(s[0]) for s in allStrings]})\",\n            )\n\n        print(\n            \"testing catastrophic RE backtracking in implementation of dblQuotedString\"\n        )\n        for expr, test_string in [\n            (pp.dblQuotedString, '\"' + \"\\\\xff\" * 500),\n            (pp.sglQuotedString, \"'\" + \"\\\\xff\" * 500),\n            (pp.quotedString, '\"' + \"\\\\xff\" * 500),\n            (pp.quotedString, \"'\" + \"\\\\xff\" * 500),\n            (pp.QuotedString('\"'), '\"' + \"\\\\xff\" * 500),\n            (pp.QuotedString(\"'\"), \"'\" + \"\\\\xff\" * 500),\n        ]:\n            with self.subTest(expr=expr, test_string=test_string):\n                expr.parseString(test_string + test_string[0], parseAll=True)\n                try:\n                    expr.parseString(test_string, parseAll=True)\n                except Exception:\n                    continue\n\n        # test invalid endQuoteChar\n        with self.subTest():\n            with self.assertRaises(\n                ValueError, msg=\"issue raising error for invalid endQuoteChar\"\n            ):\n                expr = pp.QuotedString('\"', endQuoteChar=\" \")\n\n        with self.subTest():\n            source = \"\"\"\n                '''\n                multiline quote with comment # this is a comment\n                '''\n                \\\"\\\"\\\"\n                multiline quote with comment # this is a comment\n                \\\"\\\"\\\"\n                \"single line quote with comment # this is a comment\"\n                'single line quote with comment # this is a comment'\n            \"\"\"\n            stripped = (\n                pp.python_style_comment.ignore(pp.python_quoted_string)\n                .suppress()\n                .transform_string(source)\n            )\n            self.assertEqual(source, stripped)\n\n    def testQuotedStringUnquotesAndConvertWhitespaceEscapes(self):\n        # test for Issue #474\n        # fmt: off\n        backslash = chr(92)  # a single backslash\n        tab = \"\\t\"\n        newline = \"\\n\"\n        test_string_0 = f'\"{backslash}{backslash}n\"'              # r\"\\\\n\"\n        test_string_1 = f'\"{backslash}t{backslash}{backslash}n\"'  # r\"\\t\\\\n\"\n        test_string_2 = f'\"a{backslash}tb\"'                       # r\"a\\tb\"\n        test_string_3 = f'\"{backslash}{backslash}{backslash}n\"'   # r\"\\\\\\n\"\n        T, F = True, False  # these make the test cases format nicely\n        for test_parameters in (\n                # Parameters are the arguments to creating a QuotedString\n                # and the expected parsed list of characters):\n                # - unquote_results\n                # - convert_whitespace_escapes\n                # - test string\n                # - expected parsed characters (broken out as separate\n                #   list items (all those doubled backslashes make it\n                #   difficult to interpret the output)\n                (T, T, test_string_0, [backslash, \"n\"]),\n                (T, F, test_string_0, [backslash, \"n\"]),\n                (F, F, test_string_0, ['\"', backslash, backslash, \"n\", '\"']),\n                (T, T, test_string_1, [tab, backslash, \"n\"]),\n                (T, F, test_string_1, [\"t\", backslash, \"n\"]),\n                (F, F, test_string_1, ['\"', backslash, \"t\", backslash, backslash, \"n\", '\"']),\n                (T, T, test_string_2, [\"a\", tab, \"b\"]),\n                (T, F, test_string_2, [\"a\", \"t\", \"b\"]),\n                (F, F, test_string_2, ['\"', \"a\", backslash, \"t\", \"b\", '\"']),\n                (T, T, test_string_3, [backslash, newline]),\n                (T, F, test_string_3, [backslash, \"n\"]),\n                (F, F, test_string_3, ['\"', backslash, backslash, backslash, \"n\", '\"']),\n        ):\n            unquote_results, convert_ws_escapes, test_string, expected_list = test_parameters\n            test_description = f\"Testing with parameters {test_parameters}\"\n            with self.subTest(msg=test_description):\n                print(test_description)\n                print(f\"unquote_results: {unquote_results}\"\n                      f\"\\nconvert_whitespace_escapes: {convert_ws_escapes}\")\n                qs_expr = pp.QuotedString(\n                        quoteChar='\"',\n                        escChar='\\\\',\n                        unquote_results=unquote_results,\n                        convert_whitespace_escapes=convert_ws_escapes\n                    )\n                result = qs_expr.parse_string(test_string)\n\n                # do this instead of assertParserAndCheckList to explicitly\n                # check and display the separate items in the list\n                print(\"Results:\")\n                control_chars = {newline: \"<NEWLINE>\", backslash: \"<BACKSLASH>\", tab: \"<TAB>\"}\n                print(f\"[{', '.join(control_chars.get(c, repr(c)) for c in result[0])}]\")\n                self.assertEqual(expected_list, list(result[0]))\n\n                print()\n        # fmt: on\n\n    def testPythonQuotedStrings(self):\n        # fmt: off\n        success1, _ = pp.python_quoted_string.run_tests([\n            '\"\"\"xyz\"\"\"',\n            '''\"\"\"xyz\n            \"\"\"''',\n            '\"\"\"xyz \"\" \"\"\"',\n            '''\"\"\"xyz \"\"\n            \"\"\"''',\n            '\"\"\"xyz \" \"\"\"',\n            '''\"\"\"xyz \"\n            \"\"\"''',\n            r'''\"\"\"xyz \\\"\"\"\n\n            \"\"\"''',\n            \"'''xyz'''\",\n            \"\"\"'''xyz\n            '''\"\"\",\n            \"'''xyz '' '''\",\n            \"\"\"'''xyz ''\n            '''\"\"\",\n            \"'''xyz ' '''\",\n            \"\"\"'''xyz '\n            '''\"\"\",\n            r\"\"\"'''xyz \\'''\n            '''\"\"\",\n        ])\n\n        print(\"\\n\\nFailure tests\")\n        success2, _ = pp.python_quoted_string.run_tests([\n            '\"xyz\"\"\"',\n        ], failure_tests=True)\n\n        self.assertTrue(success1 and success2, \"Python quoted string matching failure\")\n        # fmt: on\n\n    def testCaselessOneOf(self):\n        caseless1 = pp.oneOf(\"d a b c aA B A C\", caseless=True)\n        caseless1str = str(caseless1)\n        print(caseless1str)\n        caseless2 = pp.oneOf(\"d a b c Aa B A C\", caseless=True)\n        caseless2str = str(caseless2)\n        print(caseless2str)\n        self.assertEqual(\n            caseless1str.upper(),\n            caseless2str.upper(),\n            \"oneOf not handling caseless option properly\",\n        )\n        self.assertNotEqual(\n            caseless1str, caseless2str, \"Caseless option properly sorted\"\n        )\n\n        res = caseless1[...].parseString(\"AAaaAaaA\", parseAll=True)\n        print(res)\n        self.assertEqual(4, len(res), \"caseless1 oneOf failed\")\n        self.assertEqual(\n            \"aA\" * 4, \"\".join(res), \"caseless1 CaselessLiteral return failed\"\n        )\n\n        res = caseless2[...].parseString(\"AAaaAaaA\", parseAll=True)\n        print(res)\n        self.assertEqual(4, len(res), \"caseless2 oneOf failed\")\n        self.assertEqual(\n            \"Aa\" * 4, \"\".join(res), \"caseless1 CaselessLiteral return failed\"\n        )\n\n    def testCommentParser(self):\n        print(\"verify processing of C and HTML comments\")\n        testdata = \"\"\"\n        /* */\n        /** **/\n        /**/\n        /***/\n        /****/\n        /* /*/\n        /** /*/\n        /*** /*/\n        /*\n         ablsjdflj\n         */\n        \"\"\"\n        found_lines = [\n            pp.lineno(s, testdata) for t, s, e in pp.cStyleComment.scanString(testdata)\n        ]\n        self.assertEqual(\n            list(range(11))[2:],\n            found_lines,\n            f\"only found C comments on lines {found_lines}\",\n        )\n        testdata = \"\"\"\n        <!-- -->\n        <!--- --->\n        <!---->\n        <!----->\n        <!------>\n        <!-- /-->\n        <!--- /-->\n        <!---- /-->\n        <!---- /- ->\n        <!---- / -- >\n        <!--\n         ablsjdflj\n         -->\n        \"\"\"\n        found_lines = [\n            pp.lineno(s, testdata) for t, s, e in pp.htmlComment.scanString(testdata)\n        ]\n        self.assertEqual(\n            list(range(11))[2:],\n            found_lines,\n            f\"only found HTML comments on lines {found_lines}\",\n        )\n\n        # test C++ single line comments that have line terminated with '\\' (should continue comment to following line)\n        testSource = r\"\"\"\n            // comment1\n            // comment2 \\\n            still comment 2\n            // comment 3\n            \"\"\"\n        self.assertEqual(\n            41,\n            len(pp.cppStyleComment.searchString(testSource)[1][0]),\n            r\"failed to match single-line comment with '\\' at EOL\",\n        )\n\n    def testParseExpressionResults(self):\n        a = pp.Word(\"a\", pp.alphas).setName(\"A\")\n        b = pp.Word(\"b\", pp.alphas).setName(\"B\")\n        c = pp.Word(\"c\", pp.alphas).setName(\"C\")\n        ab = (a + b).setName(\"AB\")\n        abc = (ab + c).setName(\"ABC\")\n        word = pp.Word(pp.alphas).setName(\"word\")\n\n        words = pp.Group(pp.OneOrMore(~a + word)).setName(\"words\")\n\n        phrase = (\n            words(\"Head\")\n            + pp.Group(a + pp.Optional(b + pp.Optional(c)))(\"ABC\")\n            + words(\"Tail\")\n        )\n\n        results = phrase.parseString(\n            \"xavier yeti alpha beta charlie will beaver\", parseAll=True\n        )\n        print(results, results.Head, results.ABC, results.Tail)\n        for key, ln in [(\"Head\", 2), (\"ABC\", 3), (\"Tail\", 2)]:\n            self.assertEqual(\n                ln,\n                len(results[key]),\n                f\"expected {ln:d} elements in {key}, found {results[key]}\",\n            )\n\n    def testParseKeyword(self):\n        kw = pp.Keyword(\"if\")\n        lit = pp.Literal(\"if\")\n\n        def test(s, litShouldPass, kwShouldPass):\n            print(\"Test\", s)\n            print(\"Match Literal\", end=\" \")\n            try:\n                print(lit.parseString(s, parseAll=False))\n            except Exception:\n                print(\"failed\")\n                if litShouldPass:\n                    self.fail(f\"Literal failed to match {s}, should have\")\n            else:\n                if not litShouldPass:\n                    self.fail(f\"Literal matched {s}, should not have\")\n\n            print(\"Match Keyword\", end=\" \")\n            try:\n                print(kw.parseString(s, parseAll=False))\n            except Exception:\n                print(\"failed\")\n                if kwShouldPass:\n                    self.fail(f\"Keyword failed to match {s}, should have\")\n            else:\n                if not kwShouldPass:\n                    self.fail(f\"Keyword matched {s}, should not have\")\n\n        test(\"ifOnlyIfOnly\", True, False)\n        test(\"if(OnlyIfOnly)\", True, True)\n        test(\"if (OnlyIf Only)\", True, True)\n\n        kw = pp.Keyword(\"if\", caseless=True)\n\n        test(\"IFOnlyIfOnly\", False, False)\n        test(\"If(OnlyIfOnly)\", False, True)\n        test(\"iF (OnlyIf Only)\", False, True)\n\n        with self.assertRaises(\n            ValueError, msg=\"failed to warn empty string passed to Keyword\"\n        ):\n            kw = pp.Keyword(\"\")\n\n    def testParseExpressionResultsAccumulate(self):\n        num = pp.Word(pp.nums).setName(\"num\")(\"base10*\")\n        hexnum = pp.Combine(\"0x\" + pp.Word(pp.nums)).setName(\"hexnum\")(\"hex*\")\n        name = pp.Word(pp.alphas).setName(\"word\")(\"word*\")\n        list_of_num = pp.delimitedList(hexnum | num | name, \",\")\n\n        tokens = list_of_num.parseString(\"1, 0x2, 3, 0x4, aaa\", parseAll=True)\n        print(tokens.dump())\n        self.assertParseResultsEquals(\n            tokens,\n            expected_list=[\"1\", \"0x2\", \"3\", \"0x4\", \"aaa\"],\n            expected_dict={\n                \"base10\": [\"1\", \"3\"],\n                \"hex\": [\"0x2\", \"0x4\"],\n                \"word\": [\"aaa\"],\n            },\n        )\n\n        lbrack = pp.Literal(\"(\").suppress()\n        rbrack = pp.Literal(\")\").suppress()\n        integer = pp.Word(pp.nums).setName(\"int\")\n        variable = pp.Word(pp.alphas, max=1).setName(\"variable\")\n        relation_body_item = (\n            variable | integer | pp.quotedString().setParseAction(pp.removeQuotes)\n        )\n        relation_name = pp.Word(pp.alphas + \"_\", pp.alphanums + \"_\")\n        relation_body = lbrack + pp.Group(pp.delimitedList(relation_body_item)) + rbrack\n        Goal = pp.Dict(pp.Group(relation_name + relation_body))\n        Comparison_Predicate = pp.Group(variable + pp.oneOf(\"< >\") + integer)(\"pred*\")\n        Query = Goal(\"head\") + \":-\" + pp.delimitedList(Goal | Comparison_Predicate)\n\n        test = \"\"\"Q(x,y,z):-Bloo(x,\"Mitsis\",y),Foo(y,z,1243),y>28,x<12,x>3\"\"\"\n\n        queryRes = Query.parseString(test, parseAll=True)\n        print(queryRes.dump())\n        self.assertParseResultsEquals(\n            queryRes.pred,\n            expected_list=[[\"y\", \">\", \"28\"], [\"x\", \"<\", \"12\"], [\"x\", \">\", \"3\"]],\n            msg=f\"Incorrect list for attribute pred, {queryRes.pred.asList()}\",\n        )\n\n    def testReStringRange(self):\n        testCases = (\n            r\"[A-Z]\",\n            r\"[A-A]\",\n            r\"[A-Za-z]\",\n            r\"[A-z]\",\n            r\"[\\ -\\~]\",\n            r\"[\\0x20-0]\",\n            r\"[\\0x21-\\0x7E]\",\n            r\"[\\0xa1-\\0xfe]\",\n            r\"[\\040-0]\",\n            r\"[A-Za-z0-9]\",\n            r\"[A-Za-z0-9_]\",\n            r\"[A-Za-z0-9_$]\",\n            r\"[A-Za-z0-9_$\\-]\",\n            r\"[^0-9\\\\]\",\n            r\"[a-zA-Z]\",\n            r\"[/\\^~]\",\n            r\"[=\\+\\-!]\",\n            r\"[A-]\",\n            r\"[-A]\",\n            r\"[\\x21]\",\n            r\"[\u0430-\u044f\u0410-\u042f\u0451\u0401A-Z$_\\041\u03b1-\u03c9]\",\n            r\"[\\0xc0-\\0xd6\\0xd8-\\0xf6\\0xf8-\\0xff]\",\n            r\"[\\0xa1-\\0xbf\\0xd7\\0xf7]\",\n            r\"[\\0xc0-\\0xd6\\0xd8-\\0xf6\\0xf8-\\0xff]\",\n            r\"[\\0xa1-\\0xbf\\0xd7\\0xf7]\",\n            r\"[\\\\[\\]\\/\\-\\*\\.\\$\\+\\^\\?()~ ]\",\n        )\n        expectedResults = (\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n            \"A\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz\",\n            \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\",\n            \" !\\\"#$%&'()*+,-./0\",\n            \"!\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\",\n            \"\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\u00ad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d7\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f7\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\",\n            \" !\\\"#$%&'()*+,-./0\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$-\",\n            \"0123456789\\\\\",\n            \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\",\n            \"/^~\",\n            \"=+-!\",\n            \"A-\",\n            \"-A\",\n            \"!\",\n            \"\u0430\u0431\u0432\u0433\u0434\u0435\u0436\u0437\u0438\u0439\u043a\u043b\u043c\u043d\u043e\u043f\u0440\u0441\u0442\u0443\u0444\u0445\u0446\u0447\u0448\u0449\u044a\u044b\u044c\u044d\u044e\u044f\u0410\u0411\u0412\u0413\u0414\u0415\u0416\u0417\u0418\u0419\u041a\u041b\u041c\u041d\u041e\u041f\u0420\u0421\u0422\u0423\u0424\u0425\u0426\u0427\u0428\u0429\u042a\u042b\u042c\u042d\u042e\u042f\u0451\u0401ABCDEFGHIJKLMNOPQRSTUVWXYZ$_!\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\u03b9\u03ba\u03bb\u03bc\u03bd\u03be\u03bf\u03c0\u03c1\u03c2\u03c3\u03c4\u03c5\u03c6\u03c7\u03c8\u03c9\",\n            \"\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\",\n            \"\u00a1\u00a2\u00a3\u00a4\u00a5\u00a6\u00a7\u00a8\u00a9\u00aa\u00ab\u00ac\\xad\u00ae\u00af\u00b0\u00b1\u00b2\u00b3\u00b4\u00b5\u00b6\u00b7\u00b8\u00b9\u00ba\u00bb\u00bc\u00bd\u00be\u00bf\u00d7\u00f7\",\n            pp.alphas8bit,\n            pp.punc8bit,\n            r\"\\[]/-*.$+^?()~ \",\n        )\n        for test in zip(testCases, expectedResults):\n            t, exp = test\n            res = pp.srange(t)\n            # print(t, \"->\", res)\n            self.assertEqual(\n                exp,\n                res,\n                f\"srange error, srange({t!r})->'{res!r}', expected '{exp!r}'\",\n            )\n\n    def testSkipToParserTests(self):\n        thingToFind = pp.Literal(\"working\")\n        testExpr = (\n            pp.SkipTo(pp.Literal(\";\"), include=True, ignore=pp.cStyleComment)\n            + thingToFind\n        )\n\n        def test_parse(someText):\n            print(testExpr.parseString(someText, parseAll=True))\n\n        # This first test works, as the SkipTo expression is immediately following the ignore expression (cStyleComment)\n        test_parse(\"some text /* comment with ; in */; working\")\n        # This second test previously failed, as there is text following the ignore expression, and before the SkipTo expression.\n        test_parse(\"some text /* comment with ; in */some other stuff; working\")\n\n        # tests for optional failOn argument\n        testExpr = (\n            pp.SkipTo(\n                pp.Literal(\";\"), include=True, ignore=pp.cStyleComment, failOn=\"other\"\n            )\n            + thingToFind\n        )\n        test_parse(\"some text /* comment with ; in */; working\")\n\n        with self.assertRaisesParseException():\n            test_parse(\"some text /* comment with ; in */some other stuff; working\")\n\n        # test that we correctly create named results\n        text = \"prefixDATAsuffix\"\n        data = pp.Literal(\"DATA\")\n        suffix = pp.Literal(\"suffix\")\n        expr = pp.SkipTo(data + suffix)(\"prefix\") + data + suffix\n        result = expr.parseString(text, parseAll=True)\n        self.assertTrue(\n            isinstance(result.prefix, str),\n            \"SkipTo created with wrong saveAsList attribute\",\n        )\n\n        alpha_word = (~pp.Literal(\"end\") + pp.Word(pp.alphas, asKeyword=True)).setName(\n            \"alpha\"\n        )\n        num_word = pp.Word(pp.nums, asKeyword=True).setName(\"int\")\n\n        def test(expr, test_string, expected_list, expected_dict):\n            if (expected_list, expected_dict) == (None, None):\n                with self.assertRaises(\n                    Exception, msg=f\"{expr} failed to parse {test_string!r}\"\n                ):\n                    expr.parseString(test_string, parseAll=True)\n            else:\n                result = expr.parseString(test_string, parseAll=True)\n                self.assertParseResultsEquals(\n                    result, expected_list=expected_list, expected_dict=expected_dict\n                )\n\n        # ellipses for SkipTo\n        e = ... + pp.Literal(\"end\")\n        test(e, \"start 123 end\", [\"start 123 \", \"end\"], {\"_skipped\": [\"start 123 \"]})\n\n        e = pp.Suppress(...) + pp.Literal(\"end\")\n        test(e, \"start 123 end\", [\"end\"], {})\n\n        e = pp.Literal(\"start\") + ... + pp.Literal(\"end\")\n        test(e, \"start 123 end\", [\"start\", \"123 \", \"end\"], {\"_skipped\": [\"123 \"]})\n\n        e = ... + pp.Literal(\"middle\") + ... + pp.Literal(\"end\")\n        test(\n            e,\n            \"start 123 middle 456 end\",\n            [\"start 123 \", \"middle\", \"456 \", \"end\"],\n            {\"_skipped\": [\"start 123 \", \"456 \"]},\n        )\n\n        e = pp.Suppress(...) + pp.Literal(\"middle\") + ... + pp.Literal(\"end\")\n        test(\n            e,\n            \"start 123 middle 456 end\",\n            [\"middle\", \"456 \", \"end\"],\n            {\"_skipped\": [\"456 \"]},\n        )\n\n        e = pp.Literal(\"start\") + ...\n        test(e, \"start 123 end\", None, None)\n\n        e = pp.And([\"start\", ..., \"end\"])\n        test(e, \"start 123 end\", [\"start\", \"123 \", \"end\"], {\"_skipped\": [\"123 \"]})\n\n        e = pp.And([..., \"end\"])\n        test(e, \"start 123 end\", [\"start 123 \", \"end\"], {\"_skipped\": [\"start 123 \"]})\n\n        e = \"start\" + (num_word | ...) + \"end\"\n        test(e, \"start 456 end\", [\"start\", \"456\", \"end\"], {})\n        test(\n            e,\n            \"start 123 456 end\",\n            [\"start\", \"123\", \"456 \", \"end\"],\n            {\"_skipped\": [\"456 \"]},\n        )\n        test(e, \"start end\", [\"start\", \"\", \"end\"], {\"_skipped\": [\"missing <int>\"]})\n\n        # e = define_expr('\"start\" + (num_word | ...)(\"inner\") + \"end\"')\n        # test(e, \"start 456 end\", ['start', '456', 'end'], {'inner': '456'})\n\n        e = \"start\" + (alpha_word[...] & num_word[...] | ...) + \"end\"\n        test(e, \"start 456 red end\", [\"start\", \"456\", \"red\", \"end\"], {})\n        test(e, \"start red 456 end\", [\"start\", \"red\", \"456\", \"end\"], {})\n        test(\n            e,\n            \"start 456 red + end\",\n            [\"start\", \"456\", \"red\", \"+ \", \"end\"],\n            {\"_skipped\": [\"+ \"]},\n        )\n        test(e, \"start red end\", [\"start\", \"red\", \"end\"], {})\n        test(e, \"start 456 end\", [\"start\", \"456\", \"end\"], {})\n        test(e, \"start end\", [\"start\", \"end\"], {})\n        test(e, \"start 456 + end\", [\"start\", \"456\", \"+ \", \"end\"], {\"_skipped\": [\"+ \"]})\n\n        e = \"start\" + (alpha_word[1, ...] & num_word[1, ...] | ...) + \"end\"\n        test(e, \"start 456 red end\", [\"start\", \"456\", \"red\", \"end\"], {})\n        test(e, \"start red 456 end\", [\"start\", \"red\", \"456\", \"end\"], {})\n        test(\n            e,\n            \"start 456 red + end\",\n            [\"start\", \"456\", \"red\", \"+ \", \"end\"],\n            {\"_skipped\": [\"+ \"]},\n        )\n        test(e, \"start red end\", [\"start\", \"red \", \"end\"], {\"_skipped\": [\"red \"]})\n        test(e, \"start 456 end\", [\"start\", \"456 \", \"end\"], {\"_skipped\": [\"456 \"]})\n        test(\n            e,\n            \"start end\",\n            [\"start\", \"\", \"end\"],\n            {\"_skipped\": [\"missing <{{alpha}... & {int}...}>\"]},\n        )\n        test(e, \"start 456 + end\", [\"start\", \"456 + \", \"end\"], {\"_skipped\": [\"456 + \"]})\n\n        e = \"start\" + (alpha_word | ...) + (num_word | ...) + \"end\"\n        test(e, \"start red 456 end\", [\"start\", \"red\", \"456\", \"end\"], {})\n        test(\n            e,\n            \"start red end\",\n            [\"start\", \"red\", \"\", \"end\"],\n            {\"_skipped\": [\"missing <int>\"]},\n        )\n        test(\n            e,\n            \"start end\",\n            [\"start\", \"\", \"\", \"end\"],\n            {\"_skipped\": [\"missing <alpha>\", \"missing <int>\"]},\n        )\n\n        e = pp.Literal(\"start\") + ... + \"+\" + ... + \"end\"\n        test(\n            e,\n            \"start red + 456 end\",\n            [\"start\", \"red \", \"+\", \"456 \", \"end\"],\n            {\"_skipped\": [\"red \", \"456 \"]},\n        )\n\n    def testSkipToPreParseIgnoreExprs(self):\n        # added to verify fix to Issue #475\n        from pyparsing import Word, alphanums, python_style_comment\n\n        some_grammar = Word(alphanums) + \":=\" + ... + \";\"\n        some_grammar.ignore(python_style_comment)\n        try:\n            result = some_grammar.parse_string(\n                \"\"\"\\\n                var1 := 2 # 3; <== this semi-colon will match!\n                      + 1;\n                \"\"\",\n                parse_all=True,\n            )\n        except ParseException as pe:\n            print(pe.explain())\n            raise\n        else:\n            print(result.dump())\n\n    def testSkipToIgnoreExpr2(self):\n        a, star = pp.Literal.using_each(\"a*\")\n        wrapper = a + ... + a\n        expr = star + pp.SkipTo(star, ignore=wrapper) + star\n\n        # pyparsing 3.0.9 -> ['*', 'a_*_a', '*']\n        # pyparsing 3.1.0 -> ['*', '', '*']\n        self.assertParseAndCheckList(expr, \"*a_*_a*\", [\"*\", \"a_*_a\", \"*\"])\n\n    def testEllipsisRepetition(self):\n        word = pp.Word(pp.alphas).setName(\"word\")\n        num = pp.Word(pp.nums).setName(\"num\")\n\n        exprs = [\n            word[...] + num,\n            word * ... + num,\n            word[0, ...] + num,\n            word[1, ...] + num,\n            word[2, ...] + num,\n            word[..., 3] + num,\n            word[2] + num,\n        ]\n\n        expected_res = [\n            r\"([abcd]+ )*\\d+\",\n            r\"([abcd]+ )*\\d+\",\n            r\"([abcd]+ )*\\d+\",\n            r\"([abcd]+ )+\\d+\",\n            r\"([abcd]+ ){2,}\\d+\",\n            r\"([abcd]+ ){0,3}\\d+\",\n            r\"([abcd]+ ){2}\\d+\",\n        ]\n\n        tests = [\"aa bb cc dd 123\", \"bb cc dd 123\", \"cc dd 123\", \"dd 123\", \"123\"]\n\n        all_success = True\n        for expr, expected_re in zip(exprs, expected_res):\n            successful_tests = [t for t in tests if re.match(expected_re, t)]\n            failure_tests = [t for t in tests if not re.match(expected_re, t)]\n            success1, _ = expr.runTests(successful_tests)\n            success2, _ = expr.runTests(failure_tests, failureTests=True)\n            all_success = all_success and success1 and success2\n            if not all_success:\n                print(\"Failed expression:\", expr)\n                break\n\n        self.assertTrue(all_success, \"failed getItem_ellipsis test\")\n\n    def testEllipsisRepetitionWithResultsNames(self):\n        label = pp.Word(pp.alphas)\n        val = ppc.integer()\n        parser = label(\"label\") + pp.ZeroOrMore(val)(\"values\")\n\n        _, results = parser.runTests(\n            \"\"\"\n            a 1\n            b 1 2 3\n            c\n            \"\"\"\n        )\n        expected = [\n            ([\"a\", 1], {\"label\": \"a\", \"values\": [1]}),\n            ([\"b\", 1, 2, 3], {\"label\": \"b\", \"values\": [1, 2, 3]}),\n            ([\"c\"], {\"label\": \"c\", \"values\": []}),\n        ]\n        for obs, exp in zip(results, expected):\n            test, result = obs\n            exp_list, exp_dict = exp\n            self.assertParseResultsEquals(\n                result, expected_list=exp_list, expected_dict=exp_dict\n            )\n\n        parser = label(\"label\") + val[...](\"values\")\n\n        _, results = parser.runTests(\n            \"\"\"\n            a 1\n            b 1 2 3\n            c\n            \"\"\"\n        )\n        expected = [\n            ([\"a\", 1], {\"label\": \"a\", \"values\": [1]}),\n            ([\"b\", 1, 2, 3], {\"label\": \"b\", \"values\": [1, 2, 3]}),\n            ([\"c\"], {\"label\": \"c\", \"values\": []}),\n        ]\n        for obs, exp in zip(results, expected):\n            test, result = obs\n            exp_list, exp_dict = exp\n            self.assertParseResultsEquals(\n                result, expected_list=exp_list, expected_dict=exp_dict\n            )\n\n        pt = pp.Group(val(\"x\") + pp.Suppress(\",\") + val(\"y\"))\n        parser = label(\"label\") + pt[...](\"points\")\n        _, results = parser.runTests(\n            \"\"\"\n            a 1,1\n            b 1,1 2,2 3,3\n            c\n            \"\"\"\n        )\n        expected = [\n            ([\"a\", [1, 1]], {\"label\": \"a\", \"points\": [{\"x\": 1, \"y\": 1}]}),\n            (\n                [\"b\", [1, 1], [2, 2], [3, 3]],\n                {\n                    \"label\": \"b\",\n                    \"points\": [{\"x\": 1, \"y\": 1}, {\"x\": 2, \"y\": 2}, {\"x\": 3, \"y\": 3}],\n                },\n            ),\n            ([\"c\"], {\"label\": \"c\", \"points\": []}),\n        ]\n        for obs, exp in zip(results, expected):\n            test, result = obs\n            exp_list, exp_dict = exp\n            self.assertParseResultsEquals(\n                result, expected_list=exp_list, expected_dict=exp_dict\n            )\n\n    def testCustomQuotes(self):\n        testString = r\"\"\"\n            sdlfjs :sdf\\:jls::djf: sl:kfsjf\n            sdlfjs -sdf\\:jls::--djf: sl-kfsjf\n            sdlfjs -sdf\\:::jls::--djf: sl:::-kfsjf\n            sdlfjs ^sdf\\:jls^^--djf^ sl-kfsjf\n            sdlfjs ^^^==sdf\\:j=lz::--djf: sl=^^=kfsjf\n            sdlfjs ==sdf\\:j=ls::--djf: sl==kfsjf^^^\n        \"\"\"\n        print(testString)\n\n        colonQuotes = pp.QuotedString(\":\", \"\\\\\", \"::\")\n        dashQuotes = pp.QuotedString(\"-\", \"\\\\\", \"--\")\n        hatQuotes = pp.QuotedString(\"^\", \"\\\\\")\n        hatQuotes1 = pp.QuotedString(\"^\", \"\\\\\", \"^^\")\n        dblEqQuotes = pp.QuotedString(\"==\", \"\\\\\")\n\n        def test(label, quoteExpr, expected):\n            print(label)\n            print(quoteExpr.pattern)\n            print(quoteExpr.searchString(testString))\n            print(quoteExpr.searchString(testString)[0][0])\n            print(f\"{expected}\")\n            self.assertEqual(\n                expected,\n                quoteExpr.searchString(testString)[0][0],\n                f\"failed to match {quoteExpr}, expected '{expected}', got '{quoteExpr.searchString(testString)[0]}'\",\n            )\n            print()\n\n        test(\"colonQuotes\", colonQuotes, r\"sdf:jls:djf\")\n        test(\"dashQuotes\", dashQuotes, r\"sdf:jls::-djf: sl\")\n        test(\"hatQuotes\", hatQuotes, r\"sdf:jls\")\n        test(\"hatQuotes1\", hatQuotes1, r\"sdf:jls^--djf\")\n        test(\"dblEqQuotes\", dblEqQuotes, r\"sdf:j=ls::--djf: sl\")\n        test(\"::: quotes\", pp.QuotedString(\":::\"), \"jls::--djf: sl\")\n        test(\"==-- quotes\", pp.QuotedString(\"==\", endQuoteChar=\"--\"), r\"sdf\\:j=lz::\")\n        test(\n            \"^^^ multiline quotes\",\n            pp.QuotedString(\"^^^\", multiline=True),\n            r\"\"\"==sdf\\:j=lz::--djf: sl=^^=kfsjf\n            sdlfjs ==sdf\\:j=ls::--djf: sl==kfsjf\"\"\",\n        )\n        with self.assertRaises(ValueError):\n            pp.QuotedString(\"\", \"\\\\\")\n\n    def testCustomQuotes2(self):\n        qs = pp.QuotedString(quote_char=\".[\", end_quote_char=\"].\")\n        print(qs.reString)\n        self.assertParseAndCheckList(qs, \".[...].\", [\"...\"])\n        self.assertParseAndCheckList(qs, \".[].\", [\"\"])\n        self.assertParseAndCheckList(qs, \".[]].\", [\"]\"])\n        self.assertParseAndCheckList(qs, \".[]]].\", [\"]]\"])\n\n        qs = pp.QuotedString(quote_char=\"+*\", end_quote_char=\"*+\")\n        print(qs.reString)\n        self.assertParseAndCheckList(qs, \"+*...*+\", [\"...\"])\n        self.assertParseAndCheckList(qs, \"+**+\", [\"\"])\n        self.assertParseAndCheckList(qs, \"+***+\", [\"*\"])\n        self.assertParseAndCheckList(qs, \"+****+\", [\"**\"])\n\n        qs = pp.QuotedString(quote_char=\"*/\", end_quote_char=\"/*\")\n        print(qs.reString)\n        self.assertParseAndCheckList(qs, \"*/.../*\", [\"...\"])\n        self.assertParseAndCheckList(qs, \"*//*\", [\"\"])\n        self.assertParseAndCheckList(qs, \"*///*\", [\"/\"])\n        self.assertParseAndCheckList(qs, \"*////*\", [\"//\"])\n\n    def testRepeater(self):\n        if ParserElement._packratEnabled or ParserElement._left_recursion_enabled:\n            print(\"skipping this test, not compatible with memoization\")\n            return\n\n        first = pp.Word(\"abcdef\").setName(\"word1\")\n        bridge = pp.Word(pp.nums).setName(\"number\")\n        second = pp.matchPreviousLiteral(first).setName(\"repeat(word1Literal)\")\n\n        seq = first + bridge + second\n\n        tests = [\n            (\"abc12abc\", True),\n            (\"abc12aabc\", False),\n            (\"abc12cba\", True),\n            (\"abc12bca\", True),\n        ]\n\n        for tst, expected in tests:\n            found = False\n            for tokens, start, end in seq.scanString(tst):\n                f, b, s = tokens\n                print(f, b, s)\n                found = True\n            if not found:\n                print(\"No literal match in\", tst)\n            self.assertEqual(\n                expected,\n                found,\n                f\"Failed repeater for test: {tst}, matching {seq}\",\n            )\n        print()\n\n        # retest using matchPreviousExpr instead of matchPreviousLiteral\n        second = pp.matchPreviousExpr(first).setName(\"repeat(word1expr)\")\n        seq = first + bridge + second\n\n        tests = [(\"abc12abc\", True), (\"abc12cba\", False), (\"abc12abcdef\", False)]\n\n        for tst, expected in tests:\n            found = False\n            for tokens, start, end in seq.scanString(tst):\n                print(tokens)\n                found = True\n            if not found:\n                print(\"No expression match in\", tst)\n            self.assertEqual(\n                expected,\n                found,\n                f\"Failed repeater for test: {tst}, matching {seq}\",\n            )\n\n        print()\n\n        first = pp.Word(\"abcdef\").setName(\"word1\")\n        bridge = pp.Word(pp.nums).setName(\"number\")\n        second = pp.matchPreviousExpr(first).setName(\"repeat(word1)\")\n        seq = first + bridge + second\n        csFirst = seq.setName(\"word-num-word\")\n        csSecond = pp.matchPreviousExpr(csFirst)\n        compoundSeq = csFirst + \":\" + csSecond\n        compoundSeq.streamline()\n        print(compoundSeq)\n\n        tests = [\n            (\"abc12abc:abc12abc\", True),\n            (\"abc12cba:abc12abc\", False),\n            (\"abc12abc:abc12abcdef\", False),\n        ]\n\n        for tst, expected in tests:\n            found = False\n            for tokens, start, end in compoundSeq.scanString(tst):\n                print(\"match:\", tokens)\n                found = True\n                break\n            if not found:\n                print(\"No expression match in\", tst)\n            self.assertEqual(\n                expected,\n                found,\n                f\"Failed repeater for test: {tst}, matching {seq}\",\n            )\n\n        print()\n        eFirst = pp.Word(pp.nums)\n        eSecond = pp.matchPreviousExpr(eFirst)\n        eSeq = eFirst + \":\" + eSecond\n\n        tests = [(\"1:1A\", True), (\"1:10\", False)]\n\n        for tst, expected in tests:\n            found = False\n            for tokens, start, end in eSeq.scanString(tst):\n                print(tokens)\n                found = True\n            if not found:\n                print(\"No match in\", tst)\n            self.assertEqual(\n                expected,\n                found,\n                f\"Failed repeater for test: {tst}, matching {seq}\",\n            )\n\n    def testRepeater2(self):\n        \"\"\"test matchPreviousLiteral with empty repeater\"\"\"\n\n        if ParserElement._packratEnabled or ParserElement._left_recursion_enabled:\n            print(\"skipping this test, not compatible with memoization\")\n            return\n\n        first = pp.Optional(pp.Word(\"abcdef\").setName(\"words1\"))\n        bridge = pp.Word(pp.nums).setName(\"number\")\n        second = pp.matchPreviousLiteral(first).setName(\"repeat(word1Literal)\")\n\n        seq = first + bridge + second\n\n        tst = \"12\"\n        expected = [\"12\"]\n        result = seq.parseString(tst, parseAll=True)\n        print(result.dump())\n\n        self.assertParseResultsEquals(result, expected_list=expected)\n\n    def testRepeater3(self):\n        \"\"\"test matchPreviousLiteral with multiple repeater tokens\"\"\"\n\n        if ParserElement._packratEnabled or ParserElement._left_recursion_enabled:\n            print(\"skipping this test, not compatible with memoization\")\n            return\n\n        first = pp.Word(\"a\") + pp.Word(\"d\")\n        bridge = pp.Word(pp.nums).setName(\"number\")\n        second = pp.matchPreviousLiteral(first)  # (\"second\")\n\n        seq = first + bridge + second\n\n        tst = \"aaaddd12aaaddd\"\n        expected = [\"aaa\", \"ddd\", \"12\", \"aaa\", \"ddd\"]\n        result = seq.parseString(tst, parseAll=True)\n        print(result.dump())\n\n        self.assertParseResultsEquals(result, expected_list=expected)\n\n    def testRepeater4(self):\n        \"\"\"test matchPreviousExpr with multiple repeater tokens\"\"\"\n\n        if ParserElement._packratEnabled or ParserElement._left_recursion_enabled:\n            print(\"skipping this test, not compatible with memoization\")\n            return\n\n        first = pp.Group(pp.Word(pp.alphas) + pp.Word(pp.alphas))\n        bridge = pp.Word(pp.nums)\n\n        # no matching is used - this is just here for a sanity check\n        # second = pp.Group(pp.Word(pp.alphas) + pp.Word(pp.alphas))(\"second\")\n        # second = pp.Group(pp.Word(pp.alphas) + pp.Word(pp.alphas)).setResultsName(\"second\")\n\n        # ISSUE: when matchPreviousExpr returns multiple tokens the matching tokens are nested an extra level deep.\n        #           This behavior is not seen with a single return token (see testRepeater5 directly below.)\n        second = pp.matchPreviousExpr(first)\n\n        expr = first + bridge.suppress() + second\n\n        tst = \"aaa ddd 12 aaa ddd\"\n        expected = [[\"aaa\", \"ddd\"], [\"aaa\", \"ddd\"]]\n        result = expr.parseString(tst, parseAll=True)\n        print(result.dump())\n\n        self.assertParseResultsEquals(result, expected_list=expected)\n\n    def testRepeater5(self):\n        \"\"\"a simplified testRepeater4 to examine matchPreviousExpr with a single repeater token\"\"\"\n\n        if ParserElement._packratEnabled or ParserElement._left_recursion_enabled:\n            print(\"skipping this test, not compatible with memoization\")\n            return\n\n        first = pp.Word(pp.alphas)\n        bridge = pp.Word(pp.nums)\n        second = pp.matchPreviousExpr(first)\n\n        expr = first + bridge.suppress() + second\n\n        tst = \"aaa 12 aaa\"\n        expected = tst.replace(\"12\", \"\").split()\n        result = expr.parseString(tst, parseAll=True)\n        print(result.dump())\n\n        self.assertParseResultsEquals(result, expected_list=expected)\n\n    def testRecursiveCombine(self):\n        testInput = \"myc(114)r(11)dd\"\n        stream = pp.Forward()\n        stream <<= pp.Optional(pp.Word(pp.alphas)) + pp.Optional(\n            \"(\" + pp.Word(pp.nums) + \")\" + stream\n        )\n        expected = [\"\".join(stream.parseString(testInput, parseAll=True))]\n        print(expected)\n\n        stream = pp.Forward()\n        stream << pp.Combine(\n            pp.Optional(pp.Word(pp.alphas))\n            + pp.Optional(\"(\" + pp.Word(pp.nums) + \")\" + stream)\n        )\n        testVal = stream.parseString(testInput, parseAll=True)\n        print(testVal)\n\n        self.assertParseResultsEquals(testVal, expected_list=expected)\n\n    def testCombineSetName(self):\n        ab = pp.Combine(\n            pp.Literal(\"a\").set_name(\"AAA\") | pp.Literal(\"b\").set_name(\"BBB\")\n        ).set_name(\"AB\")\n        self.assertEqual(\"AB\", ab.name)\n        self.assertEqual(\"AB\", str(ab))\n        try:\n            ab.parse_string(\"C\")\n        except ParseException as pe:\n            self.assertTrue(str(pe).startswith(\"Expected AB\"))\n\n    def testHTMLEntities(self):\n        html_source = dedent(\n            \"\"\"\\\n            This &amp; that\n            2 &gt; 1\n            0 &lt; 1\n            Don&apos;t get excited!\n            I said &quot;Don&apos;t get excited!&quot;\n            Copyright &copy; 2021\n            Dot &longrightarrow; &dot;\n            \"\"\"\n        )\n        transformer = pp.common_html_entity.add_parse_action(pp.replace_html_entity)\n        transformed = transformer.transform_string(html_source)\n        print(transformed)\n\n        expected = dedent(\n            \"\"\"\\\n            This & that\n            2 > 1\n            0 < 1\n            Don't get excited!\n            I said \"Don't get excited!\"\n            Copyright \u00a9 2021\n            Dot \u27f6 \u02d9\n            \"\"\"\n        )\n        self.assertEqual(expected, transformed)\n\n    def testInfixNotationBasicArithEval(self):\n        import ast\n\n        integer = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        variable = pp.Word(pp.alphas, exact=1)\n        operand = integer | variable\n\n        expop = pp.Literal(\"^\")\n        signop = pp.oneOf(\"+ -\")\n        multop = pp.oneOf(\"* /\")\n        plusop = pp.oneOf(\"+ -\")\n        factop = pp.Literal(\"!\")\n\n        # fmt: off\n        expr = pp.infixNotation(\n            operand,\n            [\n                (factop, 1, pp.opAssoc.LEFT),\n                (expop, 2, pp.opAssoc.RIGHT),\n                (signop, 1, pp.opAssoc.RIGHT),\n                (multop, 2, pp.opAssoc.LEFT),\n                (plusop, 2, pp.opAssoc.LEFT),\n            ],\n        )\n        # fmt: on\n\n        test = [\n            \"9 + 2 + 3\",\n            \"9 + 2 * 3\",\n            \"(9 + 2) * 3\",\n            \"(9 + -2) * 3\",\n            \"(9 + --2) * 3\",\n            \"(9 + -2) * 3^2^2\",\n            \"(9! + -2) * 3^2^2\",\n            \"M*X + B\",\n            \"M*(X + B)\",\n            \"1+2*-3^4*5+-+-6\",\n            \"3!!\",\n        ]\n        expected = \"\"\"[[9, '+', 2, '+', 3]]\n                    [[9, '+', [2, '*', 3]]]\n                    [[[9, '+', 2], '*', 3]]\n                    [[[9, '+', ['-', 2]], '*', 3]]\n                    [[[9, '+', ['-', ['-', 2]]], '*', 3]]\n                    [[[9, '+', ['-', 2]], '*', [3, '^', [2, '^', 2]]]]\n                    [[[[9, '!'], '+', ['-', 2]], '*', [3, '^', [2, '^', 2]]]]\n                    [[['M', '*', 'X'], '+', 'B']]\n                    [['M', '*', ['X', '+', 'B']]]\n                    [[1, '+', [2, '*', ['-', [3, '^', 4]], '*', 5], '+', ['-', ['+', ['-', 6]]]]]\n                    [[3, '!', '!']]\"\"\".split(\n            \"\\n\"\n        )\n        expected = [ast.literal_eval(x.strip()) for x in expected]\n        for test_str, exp_list in zip(test, expected):\n            self.assertParseAndCheckList(expr, test_str, exp_list, verbose=True)\n\n    def testInfixNotationEvalBoolExprUsingAstClasses(self):\n        boolVars = {\"True\": True, \"False\": False}\n\n        class BoolOperand:\n            reprsymbol = \"\"\n\n            def __init__(self, t):\n                self.args = t[0][0::2]\n\n            def __str__(self):\n                sep = f\" {self.reprsymbol} \"\n                return f\"({sep.join(map(str, self.args))})\"\n\n        class BoolAnd(BoolOperand):\n            reprsymbol = \"&\"\n\n            def __bool__(self):\n                for a in self.args:\n                    if isinstance(a, str):\n                        v = boolVars[a]\n                    else:\n                        v = bool(a)\n                    if not v:\n                        return False\n                return True\n\n        class BoolOr(BoolOperand):\n            reprsymbol = \"|\"\n\n            def __bool__(self):\n                for a in self.args:\n                    if isinstance(a, str):\n                        v = boolVars[a]\n                    else:\n                        v = bool(a)\n                    if v:\n                        return True\n                return False\n\n        class BoolNot:\n            def __init__(self, t):\n                self.arg = t[0][1]\n\n            def __str__(self):\n                return f\"~{self.arg}\"\n\n            def __bool__(self):\n                if isinstance(self.arg, str):\n                    v = boolVars[self.arg]\n                else:\n                    v = bool(self.arg)\n                return not v\n\n        boolOperand = pp.Word(pp.alphas, max=1, asKeyword=True) | pp.oneOf(\"True False\")\n        # fmt: off\n        boolExpr = pp.infixNotation(\n            boolOperand,\n            [\n                (\"not\", 1, pp.opAssoc.RIGHT, BoolNot),\n                (\"and\", 2, pp.opAssoc.LEFT, BoolAnd),\n                (\"or\", 2, pp.opAssoc.LEFT, BoolOr),\n            ],\n        )\n        # fmt: on\n        test = [\n            \"p and not q\",\n            \"not not p\",\n            \"not(p and q)\",\n            \"q or not p and r\",\n            \"q or not p or not r\",\n            \"q or not (p and r)\",\n            \"p or q or r\",\n            \"p or q or r and False\",\n            \"(p or q or r) and False\",\n        ]\n\n        boolVars[\"p\"] = True\n        boolVars[\"q\"] = False\n        boolVars[\"r\"] = True\n        print(\"p =\", boolVars[\"p\"])\n        print(\"q =\", boolVars[\"q\"])\n        print(\"r =\", boolVars[\"r\"])\n        print()\n        for t in test:\n            res = boolExpr.parseString(t, parseAll=True)\n            print(t, \"\\n\", res[0], \"=\", bool(res[0]), \"\\n\")\n            expected = eval(t, {}, boolVars)\n            self.assertEqual(expected, bool(res[0]), f\"failed boolean eval test {t}\")\n\n    def testInfixNotationMinimalParseActionCalls(self):\n        count = 0\n\n        def evaluate_int(t):\n            nonlocal count\n            value = int(t[0])\n            print(\"evaluate_int\", value)\n            count += 1\n            return value\n\n        integer = pp.Word(pp.nums).setParseAction(evaluate_int)\n        variable = pp.Word(pp.alphas, exact=1)\n        operand = integer | variable\n\n        expop = pp.Literal(\"^\")\n        signop = pp.oneOf(\"+ -\")\n        multop = pp.oneOf(\"* /\")\n        plusop = pp.oneOf(\"+ -\")\n        factop = pp.Literal(\"!\")\n\n        # fmt: off\n        expr = pp.infixNotation(\n            operand,\n            [\n                (factop, 1, pp.opAssoc.LEFT),\n                (expop, 2, pp.opAssoc.LEFT),\n                (signop, 1, pp.opAssoc.RIGHT),\n                (multop, 2, pp.opAssoc.LEFT),\n                (plusop, 2, pp.opAssoc.LEFT),\n            ],\n        )\n        # fmt: on\n\n        test = [\"9\"]\n        for t in test:\n            count = 0\n            print(f\"{t!r} => {expr.parseString(t, parseAll=True)} (count={count})\")\n            self.assertEqual(1, count, \"count evaluated too many times!\")\n\n    def testInfixNotationWithParseActions(self):\n        word = pp.Word(pp.alphas)\n\n        def supLiteral(s):\n            \"\"\"Returns the suppressed literal s\"\"\"\n            return pp.Literal(s).suppress()\n\n        def booleanExpr(atom):\n            ops = [\n                (supLiteral(\"!\"), 1, pp.opAssoc.RIGHT, lambda s, l, t: [\"!\", t[0][0]]),\n                (pp.oneOf(\"= !=\"), 2, pp.opAssoc.LEFT),\n                (supLiteral(\"&\"), 2, pp.opAssoc.LEFT, lambda s, l, t: [\"&\", t[0]]),\n                (supLiteral(\"|\"), 2, pp.opAssoc.LEFT, lambda s, l, t: [\"|\", t[0]]),\n            ]\n            return pp.infixNotation(atom, ops)\n\n        f = booleanExpr(word) + pp.StringEnd()\n\n        tests = [\n            (\"bar = foo\", [[\"bar\", \"=\", \"foo\"]]),\n            (\n                \"bar = foo & baz = fee\",\n                [\"&\", [[\"bar\", \"=\", \"foo\"], [\"baz\", \"=\", \"fee\"]]],\n            ),\n        ]\n        for test, expected in tests:\n            print(test)\n            results = f.parseString(test, parseAll=True)\n            print(results)\n            self.assertParseResultsEquals(results, expected_list=expected)\n            print()\n\n    def testInfixNotationGrammarTest5(self):\n        expop = pp.Literal(\"**\")\n        signop = pp.oneOf(\"+ -\")\n        multop = pp.oneOf(\"* /\")\n        plusop = pp.oneOf(\"+ -\")\n\n        class ExprNode:\n            def __init__(self, tokens):\n                self.tokens = tokens[0]\n\n            def eval(self):\n                return None\n\n        class NumberNode(ExprNode):\n            def eval(self):\n                return self.tokens\n\n        class SignOp(ExprNode):\n            def eval(self):\n                mult = {\"+\": 1, \"-\": -1}[self.tokens[0]]\n                return mult * self.tokens[1].eval()\n\n        class BinOp(ExprNode):\n            opn_map = {}\n\n            def eval(self):\n                ret = self.tokens[0].eval()\n                for op, operand in zip(self.tokens[1::2], self.tokens[2::2]):\n                    ret = self.opn_map[op](ret, operand.eval())\n                return ret\n\n        class ExpOp(BinOp):\n            opn_map = {\"**\": lambda a, b: b**a}\n\n        class MultOp(BinOp):\n            import operator\n\n            opn_map = {\"*\": operator.mul, \"/\": operator.truediv}\n\n        class AddOp(BinOp):\n            import operator\n\n            opn_map = {\"+\": operator.add, \"-\": operator.sub}\n\n        operand = ppc.number().setParseAction(NumberNode)\n        # fmt: off\n        expr = pp.infixNotation(\n            operand,\n            [\n                (expop, 2, pp.opAssoc.LEFT, (lambda pr: [pr[0][::-1]], ExpOp)),\n                (signop, 1, pp.opAssoc.RIGHT, SignOp),\n                (multop, 2, pp.opAssoc.LEFT, MultOp),\n                (plusop, 2, pp.opAssoc.LEFT, AddOp),\n            ],\n        )\n        # fmt: on\n\n        tests = \"\"\"\\\n            2+7\n            2**3\n            2**3**2\n            3**9\n            3**3**2\n            \"\"\"\n\n        for t in tests.splitlines():\n            t = t.strip()\n            if not t:\n                continue\n\n            parsed = expr.parseString(t, parseAll=True)\n            eval_value = parsed[0].eval()\n            self.assertEqual(\n                eval(t),\n                eval_value,\n                f\"Error evaluating {t!r}, expected {eval(t)!r}, got {eval_value!r}\",\n            )\n\n    def testInfixNotationExceptions(self):\n        num = pp.Word(pp.nums)\n\n        # fmt: off\n\n        # arity 3 with None opExpr - should raise ValueError\n        with self.assertRaises(ValueError):\n            expr = pp.infixNotation(\n                num,\n                [\n                    (None, 3, pp.opAssoc.LEFT),\n                ]\n            )\n\n        # arity 3 with invalid tuple - should raise ValueError\n        with self.assertRaises(ValueError):\n            expr = pp.infixNotation(\n                num,\n                [\n                    ((\"+\", \"-\", \"*\"), 3, pp.opAssoc.LEFT),\n                ]\n            )\n\n        # left arity > 3 - should raise ValueError\n        with self.assertRaises(ValueError):\n            expr = pp.infixNotation(\n                num,\n                [\n                    (\"*\", 4, pp.opAssoc.LEFT),\n                ]\n            )\n\n        # right arity > 3 - should raise ValueError\n        with self.assertRaises(ValueError):\n            expr = pp.infixNotation(\n                num,\n                [\n                    (\"*\", 4, pp.opAssoc.RIGHT),\n                ]\n            )\n\n        # assoc not from opAssoc - should raise ValueError\n        with self.assertRaises(ValueError):\n            expr = pp.infixNotation(\n                num,\n                [\n                    (\"*\", 2, \"LEFT\"),\n                ]\n            )\n        # fmt: on\n\n    def testInfixNotationWithNonOperators(self):\n        # left arity 2 with None expr\n        # right arity 2 with None expr\n        num = pp.Word(pp.nums).addParseAction(pp.tokenMap(int))\n        ident = ppc.identifier()\n\n        # fmt: off\n        for assoc in (pp.opAssoc.LEFT, pp.opAssoc.RIGHT):\n            expr = pp.infixNotation(\n                num | ident,\n                [\n                    (None, 2, assoc),\n                    (\"+\", 2, pp.opAssoc.LEFT),\n                ]\n            )\n            self.assertParseAndCheckList(expr, \"3x+2\", [[[3, \"x\"], \"+\", 2]])\n        # fmt: on\n\n    def testInfixNotationTernaryOperator(self):\n        # left arity 3\n        # right arity 3\n        num = pp.Word(pp.nums).addParseAction(pp.tokenMap(int))\n\n        # fmt: off\n        for assoc in (pp.opAssoc.LEFT, pp.opAssoc.RIGHT):\n            expr = pp.infixNotation(\n                num,\n                [\n                    (\"+\", 2, pp.opAssoc.LEFT),\n                    ((\"?\", \":\"), 3, assoc),\n                ]\n            )\n            self.assertParseAndCheckList(\n                expr, \"3 + 2? 12: 13\", [[[3, \"+\", 2], \"?\", 12, \":\", 13]]\n            )\n        # fmt: on\n\n    def testInfixNotationWithAlternateParenSymbols(self):\n        num = pp.Word(pp.nums).addParseAction(pp.tokenMap(int))\n\n        # fmt: off\n        expr = pp.infixNotation(\n            num,\n            [\n                (\"+\", 2, pp.opAssoc.LEFT),\n            ],\n            lpar=\"(\",\n            rpar=\")\",\n        )\n        self.assertParseAndCheckList(\n            expr, \"3 + (2 + 11)\", [[3, '+', [2, '+', 11]]]\n        )\n\n        expr = pp.infixNotation(\n            num,\n            [\n                (\"+\", 2, pp.opAssoc.LEFT),\n            ],\n            lpar=\"<\",\n            rpar=\">\",\n        )\n        self.assertParseAndCheckList(\n            expr, \"3 + <2 + 11>\", [[3, '+', [2, '+', 11]]]\n        )\n\n        expr = pp.infixNotation(\n            num,\n            [\n                (\"+\", 2, pp.opAssoc.LEFT),\n            ],\n            lpar=pp.Literal(\"<\"),\n            rpar=pp.Literal(\">\"),\n        )\n        self.assertParseAndCheckList(\n            expr, \"3 + <2 + 11>\", [[3, '+', ['<', [2, '+', 11], '>']]]\n        )\n\n        expr = pp.infixNotation(\n            num,\n            [\n                (\"+\", 2, pp.opAssoc.LEFT),\n            ],\n            lpar=pp.Literal(\"<<\"),\n            rpar=pp.Literal(\">>\"),\n        )\n        self.assertParseAndCheckList(\n            expr, \"3 + <<2 + 11>>\", [[3, '+', ['<<', [2, '+', 11], '>>']]]\n        )\n\n        # fmt: on\n\n    def testParseResultsPickle(self):\n        import pickle\n\n        # test 1\n        body = pp.makeHTMLTags(\"BODY\")[0]\n        result = body.parseString(\n            \"<BODY BGCOLOR='#00FFBB' FGCOLOR=black>\", parseAll=True\n        )\n        print(result.dump())\n\n        for protocol in range(pickle.HIGHEST_PROTOCOL + 1):\n            print(\"Test pickle dump protocol\", protocol)\n            try:\n                pickleString = pickle.dumps(result, protocol)\n            except Exception as e:\n                print(\"dumps exception:\", e)\n                newresult = pp.ParseResults()\n            else:\n                newresult = pickle.loads(pickleString)\n                print(newresult.dump())\n\n            self.assertEqual(\n                result.dump(),\n                newresult.dump(),\n                f\"Error pickling ParseResults object (protocol={protocol})\",\n            )\n\n    def testParseResultsPickle2(self):\n        import pickle\n\n        word = pp.Word(pp.alphas + \"'.\")\n        salutation = pp.OneOrMore(word)\n        comma = pp.Literal(\",\")\n        greetee = pp.OneOrMore(word)\n        endpunc = pp.oneOf(\"! ?\")\n        greeting = (\n            salutation(\"greeting\")\n            + pp.Suppress(comma)\n            + greetee(\"greetee\")\n            + endpunc(\"punc*\")[1, ...]\n        )\n\n        string = \"Good morning, Miss Crabtree!\"\n\n        result = greeting.parseString(string, parseAll=True)\n        self.assertParseResultsEquals(\n            result,\n            [\"Good\", \"morning\", \"Miss\", \"Crabtree\", \"!\"],\n            {\n                \"greeting\": [\"Good\", \"morning\"],\n                \"greetee\": [\"Miss\", \"Crabtree\"],\n                \"punc\": [\"!\"],\n            },\n        )\n        print(result.dump())\n\n        for protocol in range(pickle.HIGHEST_PROTOCOL + 1):\n            print(\"Test pickle dump protocol\", protocol)\n            try:\n                pickleString = pickle.dumps(result, protocol)\n            except Exception as e:\n                print(\"dumps exception:\", e)\n                newresult = pp.ParseResults()\n            else:\n                newresult = pickle.loads(pickleString)\n            print(newresult.dump())\n            self.assertEqual(\n                newresult.dump(),\n                result.dump(),\n                f\"failed to pickle/unpickle ParseResults: expected {result!r}, got {newresult!r}\",\n            )\n\n    def testParseResultsPickle3(self):\n        import pickle\n\n        # result with aslist=False\n        res_not_as_list = pp.Word(\"ABC\").parseString(\"BABBAB\", parseAll=True)\n\n        # result with aslist=True\n        res_as_list = pp.Group(pp.Word(\"ABC\")).parseString(\"BABBAB\", parseAll=True)\n\n        # result with modal=True\n        res_modal = pp.Word(\"ABC\")(\"name\").parseString(\"BABBAB\", parseAll=True)\n        # self.assertTrue(res_modal._modal)\n\n        # result with modal=False\n        res_not_modal = pp.Word(\"ABC\")(\"name*\").parseString(\"BABBAB\", parseAll=True)\n        # self.assertFalse(res_not_modal._modal)\n\n        for result in (res_as_list, res_not_as_list, res_modal, res_not_modal):\n            for protocol in range(pickle.HIGHEST_PROTOCOL + 1):\n                print(\"Test pickle dump protocol\", protocol)\n                try:\n                    pickleString = pickle.dumps(result, protocol)\n                except Exception as e:\n                    print(\"dumps exception:\", e)\n                    newresult = pp.ParseResults()\n                else:\n                    newresult = pickle.loads(pickleString)\n                print(newresult.dump())\n                self.assertEqual(\n                    newresult.dump(),\n                    result.dump(),\n                    f\"failed to pickle/unpickle ParseResults: expected {result!r}, got {newresult!r}\",\n                )\n\n    def testParseResultsInsertWithResultsNames(self):\n        test_string = \"1 2 3 dice rolled first try\"\n\n        wd = pp.Word(pp.alphas)\n        num = ppc.number\n\n        expr = (\n            pp.Group(num[1, ...])(\"nums\")\n            + wd(\"label\")\n            + pp.Group(wd[...])(\"additional\")\n        )\n\n        result = expr.parseString(test_string, parseAll=True)\n        print(\"Pre-insert\")\n        print(result.dump())\n\n        result.insert(1, sum(result.nums))\n\n        print(\"\\nPost-insert\")\n        print(result.dump())\n\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[[1, 2, 3], 6, \"dice\", [\"rolled\", \"first\", \"try\"]],\n            expected_dict={\n                \"additional\": [\"rolled\", \"first\", \"try\"],\n                \"label\": \"dice\",\n                \"nums\": [1, 2, 3],\n            },\n        )\n\n    def testParseResultsStringListUsingCombine(self):\n        test_string = \"1 2 3 dice rolled first try\"\n\n        wd = pp.Word(pp.alphas)\n        num = ppc.number\n\n        expr = pp.Combine(\n            pp.Group(num[1, ...])(\"nums\")\n            + wd(\"label\")\n            + pp.Group(wd[...])(\"additional\"),\n            joinString=\"/\",\n            adjacent=False,\n        )\n        self.assertEqual(\n            \"123/dice/rolledfirsttry\", expr.parseString(test_string, parseAll=True)[0]\n        )\n\n    def testParseResultsAcceptingACollectionTypeValue(self):\n        # from Issue #276 - ParseResults parameterizes generic types if passed as the value of toklist parameter\n        # https://github.com/pyparsing/pyparsing/issues/276?notification_referrer_id=MDE4Ok5vdGlmaWNhdGlvblRocmVhZDE4MzU4NDYwNzI6MzgzODc1\n        #\n        # behavior of ParseResults code changed with Python 3.9\n\n        results_with_int = pp.ParseResults(toklist=int, name=\"type_\", asList=False)\n        self.assertEqual(int, results_with_int[\"type_\"])\n\n        results_with_tuple = pp.ParseResults(toklist=tuple, name=\"type_\", asList=False)\n        self.assertEqual(tuple, results_with_tuple[\"type_\"])\n\n    def testParseResultsReturningDunderAttribute(self):\n        # from Issue #208\n        parser = pp.Word(pp.alphas)(\"A\")\n        result = parser.parseString(\"abc\", parseAll=True)\n        print(result.dump())\n        self.assertEqual(\"abc\", result.A)\n        self.assertEqual(\"\", result.B)\n        with self.assertRaises(AttributeError):\n            result.__xyz__\n\n    def testParseResultsNamedResultWithEmptyString(self):\n        # from Issue #470\n\n        # Check which values can be returned from a parse action\n        for test_value, expected_in_result_by_name in [\n            (\"x\", True),\n            (\"\", True),\n            (True, True),\n            (False, True),\n            (1, True),\n            (0, True),\n            (None, True),\n            (b\"\", True),\n            (b\"a\", True),\n            ([], False),\n            ((), False),\n        ]:\n            msg = (\n                f\"value = {test_value!r},\"\n                f\" expected X {'not ' if not expected_in_result_by_name else ''}in result\"\n            )\n            with self.subTest(msg):\n                print(msg)\n                grammar = (\n                    (pp.Suppress(\"a\") + pp.ZeroOrMore(\"x\"))\n                    .add_parse_action(lambda p: test_value)\n                    .set_results_name(\"X\")\n                )\n                result = grammar.parse_string(\"a\")\n                print(result.dump())\n                if expected_in_result_by_name:\n                    self.assertIn(\n                        \"X\",\n                        result,\n                        f\"Expected X not found for parse action value {test_value!r}\",\n                    )\n                    print(repr(result[\"X\"]))\n                else:\n                    self.assertNotIn(\n                        \"X\",\n                        result,\n                        f\"Unexpected X found for parse action value {test_value!r}\",\n                    )\n                    with self.assertRaises(KeyError):\n                        print(repr(result[\"X\"]))\n                print()\n\n        # Do not add a parse result.\n        msg = \"value = <no parse action defined>, expected X in result\"\n        with self.subTest(msg):\n            print(msg)\n            grammar = (pp.Suppress(\"a\") + pp.ZeroOrMore(\"x\")).set_results_name(\"X\")\n            result = grammar.parse_string(\"a\")\n            print(result.dump())\n            self.assertIn(\"X\", result, f\"Expected X not found with no parse action\")\n            print()\n\n        # Test by directly creating a ParseResults\n        print(\"Create empty string value directly\")\n        result = pp.ParseResults(\"\", name=\"X\")\n        print(result.dump())\n        self.assertIn(\n            \"X\",\n            result,\n            \"failed to construct ParseResults with named value using empty string\",\n        )\n        print(repr(result[\"X\"]))\n        print()\n\n        print(\"Create empty string value from a dict\")\n        result = pp.ParseResults.from_dict({\"X\": \"\"})\n        print(result.dump())\n        self.assertIn(\n            \"X\",\n            result,\n            \"failed to construct ParseResults with named value using from_dict\",\n        )\n        print(repr(result[\"X\"]))\n\n    def testMatchOnlyAtCol(self):\n        \"\"\"successfully use matchOnlyAtCol helper function\"\"\"\n\n        expr = pp.Word(pp.nums)\n        expr.setParseAction(pp.matchOnlyAtCol(5))\n        largerExpr = pp.ZeroOrMore(pp.Word(\"A\")) + expr + pp.ZeroOrMore(pp.Word(\"A\"))\n\n        res = largerExpr.parseString(\"A A 3 A\", parseAll=True)\n        print(res.dump())\n\n    def testMatchOnlyAtColErr(self):\n        \"\"\"raise a ParseException in matchOnlyAtCol with incorrect col\"\"\"\n\n        expr = pp.Word(pp.nums)\n        expr.setParseAction(pp.matchOnlyAtCol(1))\n        largerExpr = pp.ZeroOrMore(pp.Word(\"A\")) + expr + pp.ZeroOrMore(pp.Word(\"A\"))\n\n        with self.assertRaisesParseException():\n            largerExpr.parseString(\"A A 3 A\", parseAll=True)\n\n    def testParseResultsWithNamedTuple(self):\n        expr = pp.Literal(\"A\")(\"Achar\")\n        expr.setParseAction(pp.replaceWith(tuple([\"A\", \"Z\"])))\n\n        res = expr.parseString(\"A\", parseAll=True)\n        print(repr(res))\n        print(res.Achar)\n        self.assertParseResultsEquals(\n            res,\n            expected_dict={\"Achar\": (\"A\", \"Z\")},\n            msg=f\"Failed accessing named results containing a tuple, got {res.Achar!r}\",\n        )\n\n    def testParserElementAddOperatorWithOtherTypes(self):\n        \"\"\"test the overridden \"+\" operator with other data types\"\"\"\n\n        # ParserElement + str\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\") + \"suf\"\n            result = expr.parseString(\"spam eggs suf\", parseAll=True)\n            print(result)\n\n            expected_l = [\"spam\", \"eggs\", \"suf\"]\n            self.assertParseResultsEquals(\n                result, expected_l, msg=\"issue with ParserElement + str\"\n            )\n\n        # str + ParserElement\n        with self.subTest():\n            expr = \"pre\" + pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n            result = expr.parseString(\"pre spam eggs\", parseAll=True)\n            print(result)\n\n            expected_l = [\"pre\", \"spam\", \"eggs\"]\n            self.assertParseResultsEquals(\n                result, expected_l, msg=\"issue with str + ParserElement\"\n            )\n\n        # ParserElement + int\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn ParserElement + int\"):\n                expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\") + 12\n            self.assertEqual(expr, None)\n\n        # int + ParserElement\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn int + ParserElement\"):\n                expr = 12 + pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n            self.assertEqual(expr, None)\n\n    def testParserElementSubOperatorWithOtherTypes(self):\n        \"\"\"test the overridden \"-\" operator with other data types\"\"\"\n\n        # ParserElement - str\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\") - \"suf\"\n            result = expr.parseString(\"spam eggs suf\", parseAll=True)\n            print(result)\n            expected = [\"spam\", \"eggs\", \"suf\"]\n            self.assertParseResultsEquals(\n                result, expected, msg=\"issue with ParserElement - str\"\n            )\n\n        # str - ParserElement\n        with self.subTest():\n            expr = \"pre\" - pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n            result = expr.parseString(\"pre spam eggs\", parseAll=True)\n            print(result)\n            expected = [\"pre\", \"spam\", \"eggs\"]\n            self.assertParseResultsEquals(\n                result, expected, msg=\"issue with str - ParserElement\"\n            )\n\n        # ParserElement - int\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn ParserElement - int\"):\n                expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\") - 12\n            self.assertEqual(expr, None)\n\n        # int - ParserElement\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn int - ParserElement\"):\n                expr = 12 - pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n            self.assertEqual(expr, None)\n\n    def testParserElementMulOperatorWithTuples(self):\n        \"\"\"test ParserElement \"*\" with various tuples\"\"\"\n\n        # ParserElement * (None, n)\n        expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second*\") * (None, 3)\n\n        with self.subTest():\n            results1 = expr.parseString(\"spam\", parseAll=True)\n            print(results1.dump())\n            expected = [\"spam\"]\n            self.assertParseResultsEquals(\n                results1, expected, msg=\"issue with ParserElement * w/ optional matches\"\n            )\n\n        with self.subTest():\n            results2 = expr.parseString(\"spam 12 23 34\", parseAll=True)\n            print(results2.dump())\n            expected = [\"spam\", \"12\", \"23\", \"34\"]\n            self.assertParseResultsEquals(\n                results2, expected, msg=\"issue with ParserElement * w/ optional matches\"\n            )\n\n        # ParserElement * (1, 1)\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second*\") * (1, 1)\n            results = expr.parseString(\"spam 45\", parseAll=True)\n            print(results.dump())\n\n            expected = [\"spam\", \"45\"]\n            self.assertParseResultsEquals(\n                results, expected, msg=\"issue with ParserElement * (1, 1)\"\n            )\n\n        # ParserElement * (1, 1+n)\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second*\") * (1, 3)\n\n            results1 = expr.parseString(\"spam 100\", parseAll=True)\n            print(results1.dump())\n            expected = [\"spam\", \"100\"]\n            self.assertParseResultsEquals(\n                results1, expected, msg=\"issue with ParserElement * (1, 1+n)\"\n            )\n\n        with self.subTest():\n            results2 = expr.parseString(\"spam 100 200 300\", parseAll=True)\n            print(results2.dump())\n            expected = [\"spam\", \"100\", \"200\", \"300\"]\n            self.assertParseResultsEquals(\n                results2, expected, msg=\"issue with ParserElement * (1, 1+n)\"\n            )\n\n        # ParserElement * (lesser, greater)\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second*\") * (2, 3)\n\n            results1 = expr.parseString(\"spam 1 2\", parseAll=True)\n            print(results1.dump())\n            expected = [\"spam\", \"1\", \"2\"]\n            self.assertParseResultsEquals(\n                results1, expected, msg=\"issue with ParserElement * (lesser, greater)\"\n            )\n\n        with self.subTest():\n            results2 = expr.parseString(\"spam 1 2 3\", parseAll=True)\n            print(results2.dump())\n            expected = [\"spam\", \"1\", \"2\", \"3\"]\n            self.assertParseResultsEquals(\n                results2, expected, msg=\"issue with ParserElement * (lesser, greater)\"\n            )\n\n        # ParserElement * (greater, lesser)\n        with self.subTest():\n            with self.assertRaises(\n                ValueError, msg=\"ParserElement * (greater, lesser) should raise error\"\n            ):\n                expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second\") * (3, 2)\n\n        # ParserElement * (str, str)\n        with self.subTest():\n            with self.assertRaises(\n                TypeError, msg=\"ParserElement * (str, str) should raise error\"\n            ):\n                expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second\") * (\n                    \"2\",\n                    \"3\",\n                )\n\n    def testParserElementMulByZero(self):\n        alpwd = pp.Word(pp.alphas)\n        numwd = pp.Word(pp.nums)\n\n        test_string = \"abd def ghi jkl\"\n\n        with self.subTest():\n            parser = alpwd * 2 + numwd * 0 + alpwd * 2\n            self.assertParseAndCheckList(\n                parser, test_string, expected_list=test_string.split()\n            )\n\n        with self.subTest():\n            parser = alpwd * 2 + numwd * (0, 0) + alpwd * 2\n            self.assertParseAndCheckList(\n                parser, test_string, expected_list=test_string.split()\n            )\n\n    def testParserElementMulOperatorWithOtherTypes(self):\n        \"\"\"test the overridden \"*\" operator with other data types\"\"\"\n\n        # ParserElement * str\n        with self.subTest():\n            with self.assertRaises(\n                TypeError, msg=\"ParserElement * str should raise error\"\n            ):\n                expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second\") * \"3\"\n\n        # str * ParserElement\n        with self.subTest():\n            with self.assertRaises(\n                TypeError, msg=\"str * ParserElement should raise error\"\n            ):\n                expr = pp.Word(pp.alphas)(\"first\") + \"3\" * pp.Word(pp.nums)(\"second\")\n\n        # ParserElement * int\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.nums)(\"second*\") * 2\n            results = expr.parseString(\"spam 11 22\", parseAll=True)\n\n            print(results.dump())\n            expected = [\"spam\", \"11\", \"22\"]\n            self.assertParseResultsEquals(\n                results, expected, msg=\"issue with ParserElement * int\"\n            )\n\n        # int * ParserElement\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + 2 * pp.Word(pp.nums)(\"second*\")\n            results = expr.parseString(\"spam 111 222\", parseAll=True)\n\n            print(results.dump())\n            expected = [\"spam\", \"111\", \"222\"]\n            self.assertParseResultsEquals(\n                results, expected, msg=\"issue with int * ParserElement\"\n            )\n\n    def testParserElementMatchFirstOperatorWithOtherTypes(self):\n        \"\"\"test the overridden \"|\" operator with other data types\"\"\"\n\n        # ParserElement | int\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn ParserElement | int\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (pp.Word(pp.alphas)(\"second\") | 12)\n            self.assertEqual(expr, None)\n\n        # int | ParserElement\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn int | ParserElement\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (12 | pp.Word(pp.alphas)(\"second\"))\n            self.assertEqual(expr, None)\n\n    def testParserElementMatchLongestWithOtherTypes(self):\n        \"\"\"test the overridden \"^\" operator with other data types\"\"\"\n\n        # ParserElement ^ str\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + (pp.Word(pp.nums)(\"second\") ^ \"eggs\")\n            result = expr.parseString(\"spam eggs\", parseAll=True)\n            print(result)\n\n            expected = [\"spam\", \"eggs\"]\n            self.assertParseResultsEquals(\n                result, expected, msg=\"issue with ParserElement ^ str\"\n            )\n\n        # str ^ ParserElement\n        with self.subTest():\n            expr = (\"pre\" ^ pp.Word(\"pr\")(\"first\")) + pp.Word(pp.alphas)(\"second\")\n            result = expr.parseString(\"pre eggs\", parseAll=True)\n            print(result)\n\n            expected = [\"pre\", \"eggs\"]\n            self.assertParseResultsEquals(\n                result, expected, msg=\"issue with str ^ ParserElement\"\n            )\n\n        # ParserElement ^ int\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn ParserElement ^ int\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (pp.Word(pp.alphas)(\"second\") ^ 54)\n            self.assertEqual(expr, None)\n\n        # int ^ ParserElement\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn int ^ ParserElement\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (65 ^ pp.Word(pp.alphas)(\"second\"))\n            self.assertEqual(expr, None)\n\n    def testParserElementEachOperatorWithOtherTypes(self):\n        \"\"\"test the overridden \"&\" operator with other data types\"\"\"\n\n        # ParserElement & str\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + (pp.Word(pp.alphas)(\"second\") & \"and\")\n            with self.assertRaisesParseException(msg=\"issue with ParserElement & str\"):\n                result = expr.parseString(\"spam and eggs\", parseAll=True)\n\n        # str & ParserElement\n        with self.subTest():\n            expr = pp.Word(pp.alphas)(\"first\") + (\"and\" & pp.Word(pp.alphas)(\"second\"))\n            result = expr.parseString(\"spam and eggs\", parseAll=True)\n\n            print(result.dump())\n            expected_l = [\"spam\", \"and\", \"eggs\"]\n            expected_d = {\"first\": \"spam\", \"second\": \"eggs\"}\n            self.assertParseResultsEquals(\n                result,\n                expected_list=expected_l,\n                expected_dict=expected_d,\n                msg=\"issue with str & ParserElement\",\n            )\n\n        # ParserElement & int\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn ParserElement & int\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (pp.Word(pp.alphas) & 78)\n            self.assertEqual(expr, None)\n\n        # int & ParserElement\n        with self.subTest():\n            expr = None\n            with self.assertRaises(TypeError, msg=\"failed to warn int & ParserElement\"):\n                expr = pp.Word(pp.alphas)(\"first\") + (89 & pp.Word(pp.alphas))\n            self.assertEqual(expr, None)\n\n    def testLshiftOperatorWithOtherTypes(self):\n        # Forward << ParserElement\n        with self.subTest():\n            f = pp.Forward()\n            f << pp.Word(pp.alphas)[...]\n            test_string = \"sljdf sldkjf Ljs\"\n            result = f.parse_string(test_string)\n            print(result)\n            self.assertEqual(test_string.split(), result.as_list())\n\n        # Forward << str\n        with self.subTest():\n            f = pp.Forward()\n            f << \"AAA\"\n            test_string = \"AAA\"\n            result = f.parse_string(test_string)\n            print(result)\n            self.assertEqual(test_string.split(), result.as_list())\n\n        # Forward << int\n        with self.subTest():\n            f = pp.Forward()\n            with self.assertRaises(TypeError, msg=\"failed to warn int & ParserElement\"):\n                f << 12\n\n    def testParserElementPassedThreeArgsToMultiplierShorthand(self):\n        \"\"\"test the ParserElement form expr[m,n,o]\"\"\"\n\n        with self.assertRaises(\n            TypeError, msg=\"failed to warn three index arguments to expr[m, n, o]\"\n        ):\n            expr = pp.Word(pp.alphas)[2, 3, 4]\n\n    def testParserElementPassedStrToMultiplierShorthand(self):\n        \"\"\"test the ParserElement form expr[str]\"\"\"\n\n        with self.assertRaises(\n            TypeError, msg=\"failed to raise expected error using string multiplier\"\n        ):\n            expr2 = pp.Word(pp.alphas)[\"2\"]\n\n    def testParseResultsNewEdgeCases(self):\n        \"\"\"test less common paths of ParseResults.__new__()\"\"\"\n\n        parser = pp.Word(pp.alphas)[...]\n        result = parser.parseString(\"sldkjf sldkjf\", parseAll=True)\n\n        # hasattr uses __getattr__, which for ParseResults will return \"\" if the\n        # results name is not defined. So hasattr() won't work with ParseResults.\n        # Have to use __contains__ instead to test for existence.\n        # self.assertFalse(hasattr(result, \"A\"))\n        self.assertFalse(\"A\" in result)\n\n        # create new ParseResults w/ None\n        result1 = pp.ParseResults(None)\n        print(result1.dump())\n        self.assertParseResultsEquals(\n            result1, [], msg=\"ParseResults(None) should return empty ParseResults\"\n        )\n\n        # create new ParseResults w/ integer name\n        result2 = pp.ParseResults(name=12)\n        print(result2.dump())\n        self.assertEqual(\n            \"12\",\n            result2.getName(),\n            \"ParseResults int name should be accepted and converted to str\",\n        )\n\n        # create new ParseResults w/ generator type\n        gen = (a for a in range(1, 6))\n        result3 = pp.ParseResults(gen)\n        print(result3.dump())\n        expected3 = [1, 2, 3, 4, 5]\n        self.assertParseResultsEquals(\n            result3, expected3, msg=\"issue initializing ParseResults w/ gen type\"\n        )\n\n    def testParseResultsReversed(self):\n        \"\"\"test simple case of reversed(ParseResults)\"\"\"\n\n        tst = \"1 2 3 4 5\"\n        expr = pp.OneOrMore(pp.Word(pp.nums))\n        result = expr.parseString(tst, parseAll=True)\n\n        reversed_list = [ii for ii in reversed(result)]\n        print(reversed_list)\n        expected = [\"5\", \"4\", \"3\", \"2\", \"1\"]\n        self.assertEqual(\n            expected, reversed_list, msg=\"issue calling reversed(ParseResults)\"\n        )\n\n    def testParseResultsValues(self):\n        \"\"\"test simple case of ParseResults.values()\"\"\"\n\n        expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n        result = expr.parseString(\"spam eggs\", parseAll=True)\n\n        values_set = set(result.values())\n        print(values_set)\n        expected = {\"spam\", \"eggs\"}\n        self.assertEqual(\n            expected, values_set, msg=\"issue calling ParseResults.values()\"\n        )\n\n    def testParseResultsAppend(self):\n        \"\"\"test simple case of ParseResults.append()\"\"\"\n\n        # use a parse action to compute the sum of the parsed integers, and add it to the end\n        def append_sum(tokens):\n            tokens.append(sum(map(int, tokens)))\n\n        expr = pp.OneOrMore(pp.Word(pp.nums)).addParseAction(append_sum)\n        result = expr.parseString(\"0 123 321\", parseAll=True)\n\n        expected = [\"0\", \"123\", \"321\", 444]\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with ParseResults.append()\"\n        )\n\n    def testParseResultsClear(self):\n        \"\"\"test simple case of ParseResults.clear()\"\"\"\n\n        tst = \"spam eggs\"\n        expr = pp.Word(pp.alphas)(\"first\") + pp.Word(pp.alphas)(\"second\")\n        result = expr.parseString(tst, parseAll=True)\n\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result, [\"spam\", \"eggs\"], msg=\"issue with ParseResults before clear()\"\n        )\n\n        result.clear()\n\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[],\n            expected_dict={},\n            msg=\"issue with ParseResults.clear()\",\n        )\n\n    def testParseResultsExtendWithString(self):\n        \"\"\"test ParseResults.extend() with input of type str\"\"\"\n\n        # use a parse action to append the reverse of the matched strings to make a palindrome\n        def make_palindrome(tokens):\n            tokens.extend(reversed([t[::-1] for t in tokens]))\n\n        tst = \"abc def ghi\"\n        expr = pp.OneOrMore(pp.Word(pp.alphas))\n        result = expr.addParseAction(make_palindrome).parseString(tst, parseAll=True)\n        print(result.dump())\n\n        expected = [\"abc\", \"def\", \"ghi\", \"ihg\", \"fed\", \"cba\"]\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with ParseResults.extend(str)\"\n        )\n\n    def testParseResultsExtendWithParseResults(self):\n        \"\"\"test ParseResults.extend() with input of type ParseResults\"\"\"\n\n        expr = pp.OneOrMore(pp.Word(pp.alphas))\n        result1 = expr.parseString(\"spam eggs\", parseAll=True)\n        result2 = expr.parseString(\"foo bar\", parseAll=True)\n\n        result1.extend(result2)\n        print(result1.dump())\n        expected = [\"spam\", \"eggs\", \"foo\", \"bar\"]\n        self.assertParseResultsEquals(\n            result1, expected, msg=\"issue with ParseResults.extend(ParseResults)\"\n        )\n\n    def testQuotedStringLoc(self):\n        expr = pp.QuotedString(\"'\")\n        expr.add_parse_action(lambda t: t[0].upper())\n\n        test_string = \"Using 'quotes' for 'sarcasm' or 'emphasis' is not good 'style'.\"\n        transformed = expr.transform_string(test_string)\n        print(test_string)\n        print(transformed)\n        expected = re.sub(r\"'([^']+)'\", lambda match: match[1].upper(), test_string)\n        self.assertEqual(expected, transformed)\n\n    def testParseResultsWithNestedNames(self):\n        from pyparsing import (\n            Dict,\n            Literal,\n            Group,\n            Optional,\n            Regex,\n            QuotedString,\n            oneOf,\n            Or,\n            CaselessKeyword,\n            ZeroOrMore,\n        )\n\n        RELATION_SYMBOLS = \"= > < >= <= <> ==\"\n\n        def _set_info(string, location, tokens):\n            for t in tokens:\n                try:\n                    t[\"_info_\"] = (string, location)\n                except TypeError:\n                    pass\n            tokens[\"_info_\"] = (string, location)\n\n        def keywords(name):\n            words = \"any all within encloses adj\".split()\n            return Or(map(CaselessKeyword, words))\n\n        charString1 = Group(Regex(r'[^()=<>\"/\\s]+'))(\"identifier\")\n        charString1.addParseAction(_set_info)\n        charString2 = Group(QuotedString('\"', \"\\\\\"))(\"quoted\")\n        charString2.addParseAction(_set_info)\n\n        term = Group(charString1 | charString2)\n        modifier_key = charString1\n\n        # relations\n        comparitor_symbol = oneOf(RELATION_SYMBOLS)\n        named_comparitors = keywords(\"comparitors\")\n        comparitor = Group(comparitor_symbol | named_comparitors)(\"comparitor\")\n        comparitor.addParseAction(_set_info)\n\n        def modifier_list1(key):\n            modifier = Dict(\n                Literal(\"/\")\n                + Group(modifier_key(key))(\"name\")\n                + Optional(comparitor_symbol(\"symbol\") + term(\"value\"))\n            )(\"modifier\")\n            modifier.addParseAction(_set_info)\n            return ZeroOrMore(modifier)(\"modifier_list\")\n\n        def modifier_list2(key):\n            modifier = Dict(\n                Literal(\"/\")\n                + Group(modifier_key(key))(\"name\")\n                + Optional(comparitor_symbol(\"symbol\") + term(\"value\")),\n                asdict=True,\n            )(\"modifier\")\n            modifier.addParseAction(_set_info)\n            return ZeroOrMore(modifier)(\"modifier_list\")\n\n        def modifier_list3(key):\n            modifier = Group(  # this line is different from the others, must group to get results names\n                Dict(\n                    Literal(\"/\")\n                    + Group(modifier_key(key))(\"name\")\n                    + Optional(comparitor_symbol(\"symbol\") + term(\"value\"))\n                )\n            )\n            modifier.addParseAction(_set_info)\n            return ZeroOrMore(modifier)(\"modifier_list\")\n\n        def modifier_list4(key):\n            modifier = Dict(\n                Literal(\"/\")\n                + Group(modifier_key(key))(\"name\")\n                + Optional(comparitor_symbol(\"symbol\") + term(\"value\")),\n                asdict=True,\n            )\n            modifier.addParseAction(_set_info)\n            return ZeroOrMore(modifier)(\"modifier_list\")\n\n        for modifier_list_fn in (\n            modifier_list1,\n            modifier_list2,\n            modifier_list3,\n            modifier_list4,\n        ):\n            modifier_parser = modifier_list_fn(\"default\")\n\n            result = modifier_parser.parseString(\n                \"/respectaccents/ignoreaccents\", parseAll=True\n            )\n            for r in result:\n                print(r)\n                print(r.get(\"_info_\"))\n            self.assertEqual([0, 15], [r[\"_info_\"][1] for r in result])\n\n    def testParseResultsFromDict(self):\n        \"\"\"test helper classmethod ParseResults.from_dict()\"\"\"\n\n        dict = {\n            \"first\": \"123\",\n            \"second\": 456,\n            \"third\": {\"threeStr\": \"789\", \"threeInt\": 789},\n        }\n        name = \"trios\"\n        result = pp.ParseResults.from_dict(dict, name=name)\n\n        print(result.dump())\n        expected = {name: dict}\n        self.assertParseResultsEquals(\n            result,\n            expected_dict=expected,\n            msg=\"issue creating ParseResults.from _dict()\",\n        )\n\n    def testParseResultsDir(self):\n        \"\"\"test dir(ParseResults)\"\"\"\n\n        dict = {\"first\": \"123\", \"second\": \"456\", \"third\": \"789\"}\n        name = \"trios\"\n        result = pp.ParseResults.from_dict(dict, name=name)\n        dir_result = dir(result)\n\n        print(dir_result)\n        self.assertIn(\n            name, dir_result, msg=\"name value wasn't returned by dir(ParseResults)\"\n        )\n        self.assertIn(\n            \"asList\", dir_result, msg=\"asList was not returned by dir(ParseResults)\"\n        )\n\n    def testParseResultsInsert(self):\n        \"\"\"test ParseResults.insert() with named tokens\"\"\"\n\n        from random import randint\n\n        result = pp.Word(pp.alphas)[...].parseString(\n            \"A B C D E F G H I J\", parseAll=True\n        )\n        compare_list = result.asList()\n\n        print(result)\n        print(compare_list)\n\n        for s in \"abcdefghij\":\n            index = randint(-5, 5)\n            result.insert(index, s)\n            compare_list.insert(index, s)\n\n        print(result)\n        print(compare_list)\n\n        self.assertParseResultsEquals(\n            result, compare_list, msg=\"issue with ParseResults.insert()\"\n        )\n\n    def testParseResultsAddingSuppressedTokenWithResultsName(self):\n        parser = \"aaa\" + (pp.NoMatch() | pp.Suppress(\"-\"))(\"B\")\n        try:\n            dd = parser.parse_string(\"aaa -\").as_dict()\n        except RecursionError:\n            self.fail(\"fail getting named result when empty\")\n\n    def testParseResultsBool(self):\n        result = pp.Word(pp.alphas)[...].parseString(\"AAA\", parseAll=True)\n        self.assertTrue(result, \"non-empty ParseResults evaluated as False\")\n\n        result = pp.Word(pp.alphas)[...].parseString(\"\", parseAll=True)\n        self.assertFalse(result, \"empty ParseResults evaluated as True\")\n\n        result[\"A\"] = 0\n        self.assertTrue(\n            result,\n            \"ParseResults with empty list but containing a results name evaluated as False\",\n        )\n\n    def testParseResultsCopy(self):\n        expr = (\n            pp.Word(pp.nums)\n            + pp.Group(pp.Word(pp.alphas)(\"key\") + \"=\" + pp.Word(pp.nums)(\"value\"))[...]\n        )\n        result = expr.parse_string(\"1 a=100 b=200 c=300\")\n        print(result.dump())\n\n        r2 = result.copy()\n        print(r2.dump())\n\n        # check copy is different, but contained results is the same as in original\n        self.assertFalse(r2 is result, \"copy failed\")\n        self.assertTrue(r2[1] is result[1], \"shallow copy failed\")\n\n        # update result sub-element in place\n        result[1][0] = \"z\"\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[\n                \"1\",\n                [\"z\", \"=\", \"100\"],\n                [\"b\", \"=\", \"200\"],\n                [\"c\", \"=\", \"300\"],\n            ],\n        )\n\n        # update contained results, verify list and dict contents are updated as expected\n        result[1][0] = result[1][\"key\"] = \"q\"\n        result[1][\"xyz\"] = 1000\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[\n                \"1\",\n                [\"q\", \"=\", \"100\"],\n                [\"b\", \"=\", \"200\"],\n                [\"c\", \"=\", \"300\"],\n            ],\n        )\n        self.assertParseResultsEquals(\n            result[1], expected_dict={\"key\": \"q\", \"value\": \"100\", \"xyz\": 1000}\n        )\n\n        # verify that list and dict contents are the same in copy\n        self.assertParseResultsEquals(\n            r2,\n            expected_list=[\n                \"1\",\n                [\"q\", \"=\", \"100\"],\n                [\"b\", \"=\", \"200\"],\n                [\"c\", \"=\", \"300\"],\n            ],\n        )\n        self.assertParseResultsEquals(\n            r2[1], expected_dict={\"key\": \"q\", \"value\": \"100\", \"xyz\": 1000}\n        )\n\n    def testParseResultsDeepcopy(self):\n        expr = (\n            pp.Word(pp.nums)\n            + pp.Group(pp.Word(pp.alphas)(\"key\") + \"=\" + pp.Word(pp.nums)(\"value\"))[...]\n        )\n        result = expr.parse_string(\"1 a=100 b=200 c=300\")\n\n        r2 = result.deepcopy()\n        print(r2.dump())\n\n        # check copy and contained results are different from original\n        self.assertFalse(r2 is result, \"copy failed\")\n        self.assertFalse(r2[1] is result[1], \"deep copy failed\")\n\n        # update contained results\n        result[1][0] = result[1][\"key\"] = \"q\"\n        result[1][\"xyz\"] = 1000\n        print(result.dump())\n\n        # verify that list and dict contents are unchanged in the copy\n        self.assertParseResultsEquals(\n            r2,\n            expected_list=[\n                \"1\",\n                [\"a\", \"=\", \"100\"],\n                [\"b\", \"=\", \"200\"],\n                [\"c\", \"=\", \"300\"],\n            ],\n        )\n        self.assertParseResultsEquals(r2[1], expected_dict={\"key\": \"a\", \"value\": \"100\"})\n\n    def testParseResultsDeepcopy2(self):\n        expr = (\n            pp.Word(pp.nums)\n            + pp.Group(\n                pp.Word(pp.alphas)(\"key\") + \"=\" + pp.Word(pp.nums)(\"value\"), aslist=True\n            )[...]\n        )\n        result = expr.parse_string(\"1 a=100 b=200 c=300\")\n\n        r2 = result.deepcopy()\n        print(r2.dump())\n\n        # check copy and contained results are different from original\n        self.assertFalse(r2 is result, \"copy failed\")\n        self.assertFalse(r2[1] is result[1], \"deep copy failed\")\n\n        # update contained results\n        result[1][0] = \"q\"\n        print(result.dump())\n\n        # verify that list and dict contents are unchanged in the copy\n        self.assertParseResultsEquals(\n            r2,\n            expected_list=[\n                \"1\",\n                [\"a\", \"=\", \"100\"],\n                [\"b\", \"=\", \"200\"],\n                [\"c\", \"=\", \"300\"],\n            ],\n        )\n\n    def testParseResultsDeepcopy3(self):\n        expr = (\n            pp.Word(pp.nums)\n            + pp.Group(\n                (\n                    pp.Word(pp.alphas)(\"key\") + \"=\" + pp.Word(pp.nums)(\"value\")\n                ).add_parse_action(lambda t: tuple(t))\n            )[...]\n        )\n        result = expr.parse_string(\"1 a=100 b=200 c=300\")\n\n        r2 = result.deepcopy()\n        print(r2.dump())\n\n        # check copy and contained results are different from original\n        self.assertFalse(r2 is result, \"copy failed\")\n        self.assertFalse(r2[1] is result[1], \"deep copy failed\")\n\n        # update contained results\n        result[1][0] = \"q\"\n        print(result.dump())\n\n        # verify that list and dict contents are unchanged in the copy\n        self.assertParseResultsEquals(\n            r2,\n            expected_list=[\n                \"1\",\n                [(\"a\", \"=\", \"100\")],\n                [(\"b\", \"=\", \"200\")],\n                [(\"c\", \"=\", \"300\")],\n            ],\n        )\n\n    def testIgnoreString(self):\n        \"\"\"test ParserElement.ignore() passed a string arg\"\"\"\n\n        tst = \"I like totally like love pickles\"\n        expr = pp.Word(pp.alphas)[...].ignore(\"like\")\n        result = expr.parseString(tst, parseAll=True)\n\n        print(result)\n        expected = [\"I\", \"totally\", \"love\", \"pickles\"]\n        self.assertParseResultsEquals(result, expected, msg=\"issue with ignore(string)\")\n\n    def testParseHTMLTags(self):\n        test = \"\"\"\n            <BODY>\n            <BODY BGCOLOR=\"#00FFCC\">\n            <BODY BGCOLOR=\"#00FFAA\"/>\n            <BODY BGCOLOR='#00FFBB' FGCOLOR=black>\n            <BODY/>\n            </BODY>\n        \"\"\"\n        results = [\n            (\"startBody\", False, \"\", \"\"),\n            (\"startBody\", False, \"#00FFCC\", \"\"),\n            (\"startBody\", True, \"#00FFAA\", \"\"),\n            (\"startBody\", False, \"#00FFBB\", \"black\"),\n            (\"startBody\", True, \"\", \"\"),\n            (\"endBody\", False, \"\", \"\"),\n        ]\n\n        bodyStart, bodyEnd = pp.makeHTMLTags(\"BODY\")\n        resIter = iter(results)\n        for t, s, e in (bodyStart | bodyEnd).scanString(test):\n            print(test[s:e], \"->\", t)\n            (expectedType, expectedEmpty, expectedBG, expectedFG) = next(resIter)\n\n            print(t.dump())\n            if \"startBody\" in t:\n                self.assertEqual(\n                    expectedEmpty,\n                    bool(t.empty),\n                    f\"expected {expectedEmpty and 'empty' or 'not empty'} token,\"\n                    f\" got {t.empty and 'empty' or 'not empty'}\",\n                )\n                self.assertEqual(\n                    expectedBG,\n                    t.bgcolor,\n                    f\"failed to match BGCOLOR, expected {expectedBG}, got {t.bgcolor}\",\n                )\n                self.assertEqual(\n                    expectedFG,\n                    t.fgcolor,\n                    f\"failed to match FGCOLOR, expected {expectedFG}, got {t.bgcolor}\",\n                )\n            elif \"endBody\" in t:\n                print(\"end tag\")\n                pass\n            else:\n                print(\"BAD!!!\")\n\n    def testSetParseActionUncallableErr(self):\n        \"\"\"raise a TypeError in setParseAction() by adding uncallable arg\"\"\"\n\n        expr = pp.Literal(\"A\")(\"Achar\")\n        uncallable = 12\n\n        with self.assertRaises(TypeError):\n            expr.setParseAction(uncallable)\n\n        res = expr.parseString(\"A\", parseAll=True)\n        print(res.dump())\n\n    def testMulWithNegativeNumber(self):\n        \"\"\"raise a ValueError in __mul__ by multiplying a negative number\"\"\"\n\n        with self.assertRaises(ValueError):\n            pp.Literal(\"A\")(\"Achar\") * (-1)\n\n    def testMulWithEllipsis(self):\n        \"\"\"multiply an expression with Ellipsis as ``expr * ...`` to match ZeroOrMore\"\"\"\n\n        expr = pp.Literal(\"A\")(\"Achar\") * ...\n        res = expr.parseString(\"A\", parseAll=True)\n        self.assertEqual([\"A\"], res.asList(), \"expected expr * ... to match ZeroOrMore\")\n        print(res.dump())\n\n    def testUpcaseDowncaseUnicode(self):\n        import sys\n\n        ppu = pp.pyparsing_unicode\n\n        a = \"\\u00bfC\\u00f3mo esta usted?\"\n        if not JYTHON_ENV:\n            ualphas = ppu.alphas\n        else:\n            ualphas = \"\".join(\n                chr(i)\n                for i in list(range(0xD800)) + list(range(0xE000, sys.maxunicode))\n                if chr(i).isalpha()\n            )\n        uword = pp.Word(ualphas).setParseAction(ppc.upcaseTokens)\n\n        print = lambda *args: None\n        print(uword.searchString(a))\n\n        uword = pp.Word(ualphas).setParseAction(ppc.downcaseTokens)\n\n        print(uword.searchString(a))\n\n        kw = pp.Keyword(\"mykey\", caseless=True).setParseAction(ppc.upcaseTokens)(\n            \"rname\"\n        )\n        ret = kw.parseString(\"mykey\", parseAll=True)\n        print(ret.rname)\n        self.assertEqual(\n            \"MYKEY\", ret.rname, \"failed to upcase with named result (pyparsing_common)\"\n        )\n\n        kw = pp.Keyword(\"MYKEY\", caseless=True).setParseAction(ppc.downcaseTokens)(\n            \"rname\"\n        )\n        ret = kw.parseString(\"mykey\", parseAll=True)\n        print(ret.rname)\n        self.assertEqual(\"mykey\", ret.rname, \"failed to upcase with named result\")\n\n        if not IRON_PYTHON_ENV:\n            # test html data\n            html = \"<TR class=maintxt bgColor=#ffffff> \\\n                <TD vAlign=top>\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c, \u043c\u043e\u0434\u0435\u043b\u044c</TD> \\\n                <TD vAlign=top><STRONG>BenQ-Siemens CF61</STRONG></TD> \\\n            \"  # .decode('utf-8')\n\n            # 'Manufacturer, model\n            text_manuf = \"\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c, \u043c\u043e\u0434\u0435\u043b\u044c\"\n            manufacturer = pp.Literal(text_manuf)\n\n            td_start, td_end = pp.makeHTMLTags(\"td\")\n            manuf_body = (\n                td_start.suppress()\n                + manufacturer\n                + pp.SkipTo(td_end)(\"cells*\")\n                + td_end.suppress()\n            )\n\n    def testParseUsingRegex(self):\n        signedInt = pp.Regex(r\"[-+][0-9]+\")\n        unsignedInt = pp.Regex(r\"[0-9]+\")\n        simpleString = pp.Regex(r'(\"[^\\\"]*\")|(\\'[^\\']*\\')')\n        namedGrouping = pp.Regex(r'(\"(?P<content>[^\\\"]*)\")')\n        compiledRE = pp.Regex(re.compile(r\"[A-Z]+\"))\n\n        def testMatch(expression, instring, shouldPass, expectedString=None):\n            if shouldPass:\n                try:\n                    result = expression.parseString(instring, parseAll=False)\n                    print(f\"{repr(expression)} correctly matched {repr(instring)}\")\n                    if expectedString != result[0]:\n                        print(\"\\tbut failed to match the pattern as expected:\")\n                        print(\n                            f\"\\tproduced {repr(result[0])} instead of {repr(expectedString)}\"\n                        )\n                    return True\n                except pp.ParseException:\n                    print(f\"{expression!r} incorrectly failed to match {instring!r}\")\n            else:\n                try:\n                    result = expression.parseString(instring, parseAll=False)\n                    print(f\"{expression!r} incorrectly matched {instring!r}\")\n                    print(f\"\\tproduced {result[0]!r} as a result\")\n                except pp.ParseException:\n                    print(f\"{expression!r} correctly failed to match {instring!r}\")\n                    return True\n            return False\n\n        # These should fail\n        self.assertTrue(\n            testMatch(signedInt, \"1234 foo\", False), \"Re: (1) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(signedInt, \"    +foo\", False), \"Re: (2) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(unsignedInt, \"abc\", False), \"Re: (3) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(unsignedInt, \"+123 foo\", False), \"Re: (4) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(simpleString, \"foo\", False), \"Re: (5) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(simpleString, \"\\\"foo bar'\", False),\n            \"Re: (6) passed, expected fail\",\n        )\n        self.assertTrue(\n            testMatch(simpleString, \"'foo bar\\\"\", False),\n            \"Re: (7) passed, expected fail\",\n        )\n\n        # These should pass\n        self.assertTrue(\n            testMatch(signedInt, \"   +123\", True, \"+123\"),\n            \"Re: (8) failed, expected pass\",\n        )\n        self.assertTrue(\n            testMatch(signedInt, \"+123\", True, \"+123\"), \"Re: (9) failed, expected pass\"\n        )\n        self.assertTrue(\n            testMatch(signedInt, \"+123 foo\", True, \"+123\"),\n            \"Re: (10) failed, expected pass\",\n        )\n        self.assertTrue(\n            testMatch(signedInt, \"-0 foo\", True, \"-0\"), \"Re: (11) failed, expected pass\"\n        )\n        self.assertTrue(\n            testMatch(unsignedInt, \"123 foo\", True, \"123\"),\n            \"Re: (12) failed, expected pass\",\n        )\n        self.assertTrue(\n            testMatch(unsignedInt, \"0 foo\", True, \"0\"), \"Re: (13) failed, expected pass\"\n        )\n        self.assertTrue(\n            testMatch(simpleString, '\"foo\"', True, '\"foo\"'),\n            \"Re: (14) failed, expected pass\",\n        )\n        self.assertTrue(\n            testMatch(simpleString, \"'foo bar' baz\", True, \"'foo bar'\"),\n            \"Re: (15) failed, expected pass\",\n        )\n\n        self.assertTrue(\n            testMatch(compiledRE, \"blah\", False), \"Re: (16) passed, expected fail\"\n        )\n        self.assertTrue(\n            testMatch(compiledRE, \"BLAH\", True, \"BLAH\"),\n            \"Re: (17) failed, expected pass\",\n        )\n\n        self.assertTrue(\n            testMatch(namedGrouping, '\"foo bar\" baz', True, '\"foo bar\"'),\n            \"Re: (16) failed, expected pass\",\n        )\n        ret = namedGrouping.parseString('\"zork\" blah', parseAll=False)\n        print(ret)\n        print(list(ret.items()))\n        print(ret.content)\n        self.assertEqual(\"zork\", ret.content, \"named group lookup failed\")\n\n        self.assertEqual(\n            simpleString.parseString('\"zork\" blah', parseAll=False)[0],\n            ret[0],\n            \"Regex not properly returning ParseResults for named vs. unnamed groups\",\n        )\n\n        try:\n            print(\"lets try an invalid RE\")\n            invRe = pp.Regex(\"(\\\"[^\\\"]*\\\")|('[^']*'\").re\n        except ValueError as e:\n            print(\"successfully rejected an invalid RE:\", end=\" \")\n            print(e)\n        else:\n            self.fail(\"failed to reject invalid RE\")\n\n        with self.assertRaises(\n            ValueError, msg=\"failed to warn empty string passed to Regex\"\n        ):\n            pp.Regex(\"\").re\n\n    def testRegexAsType(self):\n        test_str = \"sldkjfj 123 456 lsdfkj\"\n\n        print(\"return as list of match groups\")\n        expr = pp.Regex(r\"\\w+ (\\d+) (\\d+) (\\w+)\", asGroupList=True)\n        expected_group_list = [tuple(test_str.split()[1:])]\n        result = expr.parseString(test_str, parseAll=True)\n        print(result.dump())\n        print(expected_group_list)\n        self.assertParseResultsEquals(\n            result,\n            expected_list=expected_group_list,\n            msg=\"incorrect group list returned by Regex)\",\n        )\n\n        print(\"return as re.match instance\")\n        expr = pp.Regex(\n            r\"\\w+ (?P<num1>\\d+) (?P<num2>\\d+) (?P<last_word>\\w+)\", asMatch=True\n        )\n        result = expr.parseString(test_str, parseAll=True)\n        print(result.dump())\n        print(result[0].groups())\n        print(expected_group_list)\n        self.assertEqual(\n            {\"num1\": \"123\", \"num2\": \"456\", \"last_word\": \"lsdfkj\"},\n            result[0].groupdict(),\n            \"invalid group dict from Regex(asMatch=True)\",\n        )\n        self.assertEqual(\n            expected_group_list[0],\n            result[0].groups(),\n            \"incorrect group list returned by Regex(asMatch)\",\n        )\n\n    def testRegexSub(self):\n        print(\"test sub with string\")\n        expr = pp.Regex(r\"<title>\").sub(\"'Richard III'\")\n        result = expr.transformString(\"This is the title: <title>\")\n        print(result)\n        self.assertEqual(\n            \"This is the title: 'Richard III'\",\n            result,\n            \"incorrect Regex.sub result with simple string\",\n        )\n\n        print(\"test sub with re string\")\n        expr = pp.Regex(r\"([Hh]\\d):\\s*(.*)\").sub(r\"<\\1>\\2</\\1>\")\n        result = expr.transformString(\n            \"h1: This is the main heading\\nh2: This is the sub-heading\"\n        )\n        print(result)\n        self.assertEqual(\n            \"<h1>This is the main heading</h1>\\n<h2>This is the sub-heading</h2>\",\n            result,\n            \"incorrect Regex.sub result with re string\",\n        )\n\n        print(\"test sub with re string (Regex returns re.match)\")\n        expr = pp.Regex(r\"([Hh]\\d):\\s*(.*)\", asMatch=True).sub(r\"<\\1>\\2</\\1>\")\n        result = expr.transformString(\n            \"h1: This is the main heading\\nh2: This is the sub-heading\"\n        )\n        print(result)\n        self.assertEqual(\n            \"<h1>This is the main heading</h1>\\n<h2>This is the sub-heading</h2>\",\n            result,\n            \"incorrect Regex.sub result with re string\",\n        )\n\n        print(\"test sub with callable that return str\")\n        expr = pp.Regex(r\"<(.*?)>\").sub(lambda m: m.group(1).upper())\n        result = expr.transformString(\"I want this in upcase: <what? what?>\")\n        print(result)\n        self.assertEqual(\n            \"I want this in upcase: WHAT? WHAT?\",\n            result,\n            \"incorrect Regex.sub result with callable\",\n        )\n\n        with self.assertRaises(TypeError):\n            pp.Regex(r\"<(.*?)>\", asMatch=True).sub(lambda m: m.group(1).upper())\n\n        with self.assertRaises(TypeError):\n            pp.Regex(r\"<(.*?)>\", asGroupList=True).sub(lambda m: m.group(1).upper())\n\n        with self.assertRaises(TypeError):\n            pp.Regex(r\"<(.*?)>\", asGroupList=True).sub(\"\")\n\n    def testRegexInvalidType(self):\n        \"\"\"test Regex of an invalid type\"\"\"\n\n        with self.assertRaises(TypeError, msg=\"issue with Regex of type int\"):\n            expr = pp.Regex(12)\n\n    def testPrecededBy(self):\n        num = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        interesting_num = pp.PrecededBy(pp.Char(\"abc\")(\"prefix*\")) + num\n        semi_interesting_num = pp.PrecededBy(\"_\") + num\n        crazy_num = pp.PrecededBy(pp.Word(\"^\", \"$%^\")(\"prefix*\"), 10) + num\n        boring_num = ~pp.PrecededBy(pp.Char(\"abc_$%^\" + pp.nums)) + num\n        very_boring_num = pp.PrecededBy(pp.WordStart()) + num\n        finicky_num = pp.PrecededBy(pp.Word(\"^\", \"$%^\"), retreat=3) + num\n\n        s = \"c384 b8324 _9293874 _293 404 $%^$^%$2939\"\n        print(s)\n        for expr, expected_list, expected_dict in [\n            (interesting_num, [384, 8324], {\"prefix\": [\"c\", \"b\"]}),\n            (semi_interesting_num, [9293874, 293], {}),\n            (boring_num, [404], {}),\n            (crazy_num, [2939], {\"prefix\": [\"^%$\"]}),\n            (finicky_num, [2939], {}),\n            (very_boring_num, [404], {}),\n        ]:\n            # print(expr.searchString(s))\n            result = sum(expr.searchString(s))\n            print(result.dump())\n            self.assertParseResultsEquals(result, expected_list, expected_dict)\n\n        # infinite loop test - from Issue #127\n        string_test = \"notworking\"\n        # negs = pp.Or(['not', 'un'])('negs')\n        negs_pb = pp.PrecededBy(\"not\", retreat=100)(\"negs_lb\")\n        # negs_pb = pp.PrecededBy(negs, retreat=100)('negs_lb')\n        pattern = (negs_pb + pp.Literal(\"working\"))(\"main\")\n\n        results = pattern.searchString(string_test)\n        try:\n            print(results.dump())\n        except RecursionError:\n            self.fail(\"got maximum excursion limit exception\")\n        else:\n            print(\"got maximum excursion limit exception\")\n\n    def testCountedArray(self):\n        testString = \"2 5 7 6 0 1 2 3 4 5 0 3 5 4 3\"\n\n        integer = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        countedField = pp.countedArray(integer)\n\n        r = pp.OneOrMore(pp.Group(countedField)).parseString(testString, parseAll=True)\n        print(testString)\n        print(r)\n\n        self.assertParseResultsEquals(\n            r, expected_list=[[5, 7], [0, 1, 2, 3, 4, 5], [], [5, 4, 3]]\n        )\n\n    # addresses bug raised by Ralf Vosseler\n    def testCountedArrayTest2(self):\n        testString = \"2 5 7 6 0 1 2 3 4 5 0 3 5 4 3\"\n\n        integer = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        countedField = pp.countedArray(integer)\n\n        dummy = pp.Word(\"A\")\n        r = pp.OneOrMore(pp.Group(dummy ^ countedField)).parseString(\n            testString, parseAll=True\n        )\n        print(testString)\n        print(r)\n\n        self.assertParseResultsEquals(\n            r, expected_list=[[5, 7], [0, 1, 2, 3, 4, 5], [], [5, 4, 3]]\n        )\n\n    def testCountedArrayTest3(self):\n        int_chars = \"_\" + pp.alphas\n        array_counter = pp.Word(int_chars).setParseAction(\n            lambda t: int_chars.index(t[0])\n        )\n\n        #             123456789012345678901234567890\n        testString = \"B 5 7 F 0 1 2 3 4 5 _ C 5 4 3\"\n\n        integer = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        countedField = pp.countedArray(integer, intExpr=array_counter)\n\n        r = pp.OneOrMore(pp.Group(countedField)).parseString(testString, parseAll=True)\n        print(testString)\n        print(r)\n\n        self.assertParseResultsEquals(\n            r, expected_list=[[5, 7], [0, 1, 2, 3, 4, 5], [], [5, 4, 3]]\n        )\n\n    def testCountedArrayTest4(self):\n        ppc = pp.pyparsing_common\n\n        # array counter contains several fields - first field *must* be the number of\n        # items in the array\n        # - number of elements\n        # - type of elements\n        # - source of elements\n        counter_with_metadata = (\n            ppc.integer(\"count\") + ppc.identifier(\"type\") + ppc.identifier(\"source\")\n        )\n\n        countedField = pp.countedArray(\n            pp.Word(pp.alphanums), intExpr=counter_with_metadata\n        )\n\n        testString = (\n            \"5 string input item1 item2 item3 item4 item5 0 int user 2 int file 3 8\"\n        )\n        r = pp.Group(countedField(\"items\"))[...].parseString(testString, parseAll=True)\n\n        print(testString)\n        print(r.dump())\n        print(f\"type = {r.type!r}\")\n        print(f\"source = {r.source!r}\")\n\n        self.assertParseResultsEquals(\n            r,\n            expected_list=[\n                [\"item1\", \"item2\", \"item3\", \"item4\", \"item5\"],\n                [],\n                [\"3\", \"8\"],\n            ],\n        )\n\n        self.assertParseResultsEquals(\n            r[0],\n            expected_dict={\n                \"count\": 5,\n                \"source\": \"input\",\n                \"type\": \"string\",\n                \"items\": [\"item1\", \"item2\", \"item3\", \"item4\", \"item5\"],\n            },\n        )\n\n        # parse with additional fields between the count and the actual list items\n        count_with_metadata = ppc.integer + pp.Word(pp.alphas)(\"type\")\n        typed_array = pp.countedArray(\n            pp.Word(pp.alphanums), intExpr=count_with_metadata\n        )(\"items\")\n        result = typed_array.parseString(\"3 bool True True False\", parseAll=True)\n        print(result.dump())\n\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[\"True\", \"True\", \"False\"],\n            expected_dict={\"type\": \"bool\", \"items\": [\"True\", \"True\", \"False\"]},\n        )\n\n    def testLineStart(self):\n        pass_tests = [\n            \"\"\"\\\n            AAA\n            BBB\n            \"\"\",\n            \"\"\"\\\n            AAA...\n            BBB\n            \"\"\",\n        ]\n        fail_tests = [\n            \"\"\"\\\n            AAA...\n            ...BBB\n            \"\"\",\n            \"\"\"\\\n            AAA  BBB\n            \"\"\",\n        ]\n\n        # cleanup test strings\n        pass_tests = [\n            \"\\n\".join(s.lstrip() for s in t.splitlines()).replace(\".\", \" \")\n            for t in pass_tests\n        ]\n        fail_tests = [\n            \"\\n\".join(s.lstrip() for s in t.splitlines()).replace(\".\", \" \")\n            for t in fail_tests\n        ]\n\n        test_patt = pp.Word(\"A\") - pp.LineStart() + pp.Word(\"B\")\n        print(test_patt.streamline())\n        success = test_patt.runTests(pass_tests)[0]\n        self.assertTrue(success, \"failed LineStart passing tests (1)\")\n\n        success = test_patt.runTests(fail_tests, failureTests=True)[0]\n        self.assertTrue(success, \"failed LineStart failure mode tests (1)\")\n\n        with ppt.reset_pyparsing_context():\n            print(r\"no \\n in default whitespace chars\")\n            pp.ParserElement.setDefaultWhitespaceChars(\" \")\n\n            test_patt = pp.Word(\"A\") - pp.LineStart() + pp.Word(\"B\")\n            print(test_patt.streamline())\n            # should fail the pass tests too, since \\n is no longer valid whitespace and we aren't parsing for it\n            success = test_patt.runTests(pass_tests, failureTests=True)[0]\n            self.assertTrue(success, \"failed LineStart passing tests (2)\")\n\n            success = test_patt.runTests(fail_tests, failureTests=True)[0]\n            self.assertTrue(success, \"failed LineStart failure mode tests (2)\")\n\n            test_patt = (\n                pp.Word(\"A\")\n                - pp.LineEnd().suppress()\n                + pp.LineStart()\n                + pp.Word(\"B\")\n                + pp.LineEnd().suppress()\n            )\n            print(test_patt.streamline())\n            success = test_patt.runTests(pass_tests)[0]\n            self.assertTrue(success, \"failed LineStart passing tests (3)\")\n\n            success = test_patt.runTests(fail_tests, failureTests=True)[0]\n            self.assertTrue(success, \"failed LineStart failure mode tests (3)\")\n\n    def testLineStart2(self):\n        test = \"\"\"\\\n        AAA 1\n        AAA 2\n\n          AAA\n\n        B AAA\n\n        \"\"\"\n\n        test = dedent(test)\n        print(pp.testing.with_line_numbers(test))\n\n        print(\"normal parsing\")\n        for t, s, e in (pp.LineStart() + \"AAA\").scanString(test):\n            print(s, e, pp.lineno(s, test), pp.line(s, test), repr(t))\n            print()\n            self.assertEqual(\n                \"A\", t[0][0], \"failed LineStart with insignificant newlines\"\n            )\n\n        print(r\"parsing without \\n in whitespace chars\")\n        with ppt.reset_pyparsing_context():\n            pp.ParserElement.setDefaultWhitespaceChars(\" \")\n            for t, s, e in (pp.LineStart() + \"AAA\").scanString(test):\n                print(s, e, pp.lineno(s, test), pp.line(s, test), repr(test[s]))\n                print()\n                self.assertEqual(\n                    \"A\", t[0][0], \"failed LineStart with insignificant newlines\"\n                )\n\n    def testLineStartWithLeadingSpaces(self):\n        # testing issue #272\n        # reverted in 3.0.2 - LineStart() + expr will match expr even if there\n        # are leading spaces. To force \"only at column 1\" matching, use\n        # AtLineStart(expr).\n        instring = dedent(\n            \"\"\"\n            a\n             b\n              c\n            d\n            e\n             f\n              g\n            \"\"\"\n        )\n        print(pp.testing.with_line_numbers(instring))\n\n        alpha_line = (\n            pp.LineStart().leaveWhitespace()\n            + pp.Word(pp.alphas)\n            + pp.LineEnd().suppress()\n        )\n\n        tests = [\n            alpha_line,\n            pp.Group(alpha_line),\n            alpha_line | pp.Word(\"_\"),\n            alpha_line | alpha_line,\n            pp.MatchFirst([alpha_line, alpha_line]),\n            alpha_line ^ pp.Word(\"_\"),\n            alpha_line ^ alpha_line,\n            pp.Or([alpha_line, pp.Word(\"_\")]),\n            pp.LineStart() + pp.Word(pp.alphas) + pp.LineEnd().suppress(),\n            pp.And([pp.LineStart(), pp.Word(pp.alphas), pp.LineEnd().suppress()]),\n        ]\n        fails = []\n        for test in tests:\n            print(test.searchString(instring))\n            if [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"] != flatten(\n                sum(test.search_string(instring)).as_list()\n            ):\n                fails.append(test)\n        if fails:\n            self.fail(\n                \"failed LineStart tests:\\n{}\".format(\n                    \"\\n\".join(str(expr) for expr in fails)\n                )\n            )\n\n    def testAtLineStart(self):\n        test = dedent(\n            \"\"\"\\\n        AAA this line\n        AAA and this line\n          AAA but not this one\n        B AAA and definitely not this one\n        \"\"\"\n        )\n\n        expr = pp.AtLineStart(\"AAA\") + pp.restOfLine\n        for t in expr.search_string(test):\n            print(t)\n\n        self.assertEqual(\n            [\"AAA\", \" this line\", \"AAA\", \" and this line\"],\n            sum(expr.search_string(test)).as_list(),\n        )\n\n    def testStringStart(self):\n        self.assertParseAndCheckList(\n            pp.StringStart() + pp.Word(pp.nums), \"123\", [\"123\"]\n        )\n        self.assertParseAndCheckList(\n            pp.StringStart() + pp.Word(pp.nums), \"   123\", [\"123\"]\n        )\n        self.assertParseAndCheckList(pp.StringStart() + \"123\", \"123\", [\"123\"])\n        self.assertParseAndCheckList(pp.StringStart() + \"123\", \"   123\", [\"123\"])\n        self.assertParseAndCheckList(pp.AtStringStart(pp.Word(pp.nums)), \"123\", [\"123\"])\n\n        self.assertParseAndCheckList(pp.AtStringStart(\"123\"), \"123\", [\"123\"])\n\n        with self.assertRaisesParseException():\n            pp.AtStringStart(pp.Word(pp.nums)).parse_string(\"    123\")\n\n        with self.assertRaisesParseException():\n            pp.AtStringStart(\"123\").parse_string(\"    123\")\n\n    def testStringStartAndLineStartInsideAnd(self):\n        # fmt: off\n        P_MTARG = (\n                pp.StringStart()\n                + pp.Word(\"abcde\")\n                + pp.StringEnd()\n        )\n\n        P_MTARG2 = (\n                pp.LineStart()\n                + pp.Word(\"abcde\")\n                + pp.StringEnd()\n        )\n\n        P_MTARG3 = (\n                pp.AtLineStart(pp.Word(\"abcde\"))\n                + pp.StringEnd()\n        )\n        # fmt: on\n\n        def test(expr, string):\n            expr.streamline()\n            print(expr, repr(string), end=\" \")\n            print(expr.parse_string(string))\n\n        test(P_MTARG, \"aaa\")\n        test(P_MTARG2, \"aaa\")\n        test(P_MTARG2, \"\\naaa\")\n        test(P_MTARG2, \"   aaa\")\n        test(P_MTARG2, \"\\n   aaa\")\n\n        with self.assertRaisesParseException():\n            test(P_MTARG3, \"   aaa\")\n        with self.assertRaisesParseException():\n            test(P_MTARG3, \"\\n   aaa\")\n\n    def testLineAndStringEnd(self):\n        NLs = pp.OneOrMore(pp.lineEnd)\n        bnf1 = pp.delimitedList(pp.Word(pp.alphanums).leaveWhitespace(), NLs)\n        bnf2 = pp.Word(pp.alphanums) + pp.stringEnd\n        bnf3 = pp.Word(pp.alphanums) + pp.SkipTo(pp.stringEnd)\n        tests = [\n            (\"testA\\ntestB\\ntestC\\n\", [\"testA\", \"testB\", \"testC\"]),\n            (\"testD\\ntestE\\ntestF\", [\"testD\", \"testE\", \"testF\"]),\n            (\"a\", [\"a\"]),\n        ]\n\n        for test, expected in tests:\n            res1 = bnf1.parseString(test, parseAll=True)\n            print(res1, \"=?\", expected)\n            self.assertParseResultsEquals(\n                res1,\n                expected_list=expected,\n                msg=f\"Failed lineEnd/stringEnd test (1): {test!r} -> {res1}\",\n            )\n\n            res2 = bnf2.searchString(test)[0]\n            print(res2, \"=?\", expected[-1:])\n            self.assertParseResultsEquals(\n                res2,\n                expected_list=expected[-1:],\n                msg=f\"Failed lineEnd/stringEnd test (2): {test!r} -> {res2}\",\n            )\n\n            res3 = bnf3.parseString(test, parseAll=True)\n            first = res3[0]\n            rest = res3[1]\n            # ~ print res3.dump()\n            print(repr(rest), \"=?\", repr(test[len(first) + 1 :]))\n            self.assertEqual(\n                rest,\n                test[len(first) + 1 :],\n                msg=f\"Failed lineEnd/stringEnd test (3): {test!r} -> {res3.as_list()}\",\n            )\n            print()\n\n        k = pp.Regex(r\"a+\", flags=re.S + re.M)\n        k = k.parseWithTabs()\n        k = k.leaveWhitespace()\n\n        tests = [\n            (r\"aaa\", [\"aaa\"]),\n            (r\"\\naaa\", None),\n            (r\"a\\naa\", None),\n            (r\"aaa\\n\", None),\n        ]\n        for i, (src, expected) in enumerate(tests):\n            with self.subTest(\"\", src=src, expected=expected):\n                print(i, repr(src).replace(\"\\\\\\\\\", \"\\\\\"), end=\" \")\n                if expected is None:\n                    with self.assertRaisesParseException():\n                        k.parseString(src, parseAll=True)\n                else:\n                    res = k.parseString(src, parseAll=True)\n                    self.assertParseResultsEquals(\n                        res, expected, msg=f\"Failed on parseAll=True test {i}\"\n                    )\n\n    def testVariableParseActionArgs(self):\n        pa3 = lambda s, l, t: t\n        pa2 = lambda l, t: t\n        pa1 = lambda t: t\n        pa0 = lambda: None\n\n        class Callable3:\n            def __call__(self, s, l, t):\n                return t\n\n        class Callable2:\n            def __call__(self, l, t):\n                return t\n\n        class Callable1:\n            def __call__(self, t):\n                return t\n\n        class Callable0:\n            def __call__(self):\n                return\n\n        class CallableS3:\n            @staticmethod\n            def __call__(s, l, t):\n                return t\n\n        class CallableS2:\n            @staticmethod\n            def __call__(l, t):\n                return t\n\n        class CallableS1:\n            @staticmethod\n            def __call__(t):\n                return t\n\n        class CallableS0:\n            @staticmethod\n            def __call__():\n                return\n\n        class CallableC3:\n            @classmethod\n            def __call__(cls, s, l, t):\n                return t\n\n        class CallableC2:\n            @classmethod\n            def __call__(cls, l, t):\n                return t\n\n        class CallableC1:\n            @classmethod\n            def __call__(cls, t):\n                return t\n\n        class CallableC0:\n            @classmethod\n            def __call__(cls):\n                return\n\n        class parseActionHolder:\n            @staticmethod\n            def pa3(s, l, t):\n                return t\n\n            @staticmethod\n            def pa2(l, t):\n                return t\n\n            @staticmethod\n            def pa1(t):\n                return t\n\n            @staticmethod\n            def pa0():\n                return\n\n        def paArgs(*args):\n            print(args)\n            return args[2]\n\n        class ClassAsPA0:\n            def __init__(self):\n                pass\n\n            def __str__(self):\n                return \"A\"\n\n        class ClassAsPA1:\n            def __init__(self, t):\n                print(\"making a ClassAsPA1\")\n                self.t = t\n\n            def __str__(self):\n                return self.t[0]\n\n        class ClassAsPA2:\n            def __init__(self, l, t):\n                self.t = t\n\n            def __str__(self):\n                return self.t[0]\n\n        class ClassAsPA3:\n            def __init__(self, s, l, t):\n                self.t = t\n\n            def __str__(self):\n                return self.t[0]\n\n        class ClassAsPAStarNew(tuple):\n            def __new__(cls, *args):\n                print(\"make a ClassAsPAStarNew\", args)\n                return tuple.__new__(cls, *args[2].asList())\n\n            def __str__(self):\n                return \"\".join(self)\n\n        A = pp.Literal(\"A\").setParseAction(pa0)\n        B = pp.Literal(\"B\").setParseAction(pa1)\n        C = pp.Literal(\"C\").setParseAction(pa2)\n        D = pp.Literal(\"D\").setParseAction(pa3)\n        E = pp.Literal(\"E\").setParseAction(Callable0())\n        F = pp.Literal(\"F\").setParseAction(Callable1())\n        G = pp.Literal(\"G\").setParseAction(Callable2())\n        H = pp.Literal(\"H\").setParseAction(Callable3())\n        I = pp.Literal(\"I\").setParseAction(CallableS0())\n        J = pp.Literal(\"J\").setParseAction(CallableS1())\n        K = pp.Literal(\"K\").setParseAction(CallableS2())\n        L = pp.Literal(\"L\").setParseAction(CallableS3())\n        M = pp.Literal(\"M\").setParseAction(CallableC0())\n        N = pp.Literal(\"N\").setParseAction(CallableC1())\n        O = pp.Literal(\"O\").setParseAction(CallableC2())\n        P = pp.Literal(\"P\").setParseAction(CallableC3())\n        Q = pp.Literal(\"Q\").setParseAction(paArgs)\n        R = pp.Literal(\"R\").setParseAction(parseActionHolder.pa3)\n        S = pp.Literal(\"S\").setParseAction(parseActionHolder.pa2)\n        T = pp.Literal(\"T\").setParseAction(parseActionHolder.pa1)\n        U = pp.Literal(\"U\").setParseAction(parseActionHolder.pa0)\n        V = pp.Literal(\"V\")\n\n        # fmt: off\n        gg = pp.OneOrMore(\n            A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | U | V | B | T\n        )\n        # fmt: on\n        testString = \"VUTSRQPONMLKJIHGFEDCBA\"\n        res = gg.parseString(testString, parseAll=True)\n        print(res)\n        self.assertParseResultsEquals(\n            res,\n            expected_list=list(testString),\n            msg=\"Failed to parse using variable length parse actions\",\n        )\n\n        A = pp.Literal(\"A\").setParseAction(ClassAsPA0)\n        B = pp.Literal(\"B\").setParseAction(ClassAsPA1)\n        C = pp.Literal(\"C\").setParseAction(ClassAsPA2)\n        D = pp.Literal(\"D\").setParseAction(ClassAsPA3)\n        E = pp.Literal(\"E\").setParseAction(ClassAsPAStarNew)\n\n        # fmt: off\n        gg = pp.OneOrMore(\n            A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V\n        )\n        # fmt: on\n        testString = \"VUTSRQPONMLKJIHGFEDCBA\"\n        res = gg.parseString(testString, parseAll=True)\n        print(list(map(str, res)))\n        self.assertEqual(\n            list(testString),\n            list(map(str, res)),\n            \"Failed to parse using variable length parse actions \"\n            \"using class constructors as parse actions\",\n        )\n\n    def testSingleArgException(self):\n        testMessage = \"just one arg\"\n        try:\n            raise pp.ParseFatalException(testMessage)\n        except pp.ParseBaseException as pbe:\n            print(\"Received expected exception:\", pbe)\n            raisedMsg = pbe.msg\n            self.assertEqual(\n                testMessage, raisedMsg, \"Failed to get correct exception message\"\n            )\n\n    def testOriginalTextFor(self):\n        def rfn(t):\n            return f\"{t.src}:{len(''.join(t))}\"\n\n        makeHTMLStartTag = lambda tag: pp.originalTextFor(\n            pp.makeHTMLTags(tag)[0], asString=False\n        )\n\n        # use the lambda, Luke\n        start = makeHTMLStartTag(\"IMG\")\n\n        # don't replace our fancy parse action with rfn,\n        # append rfn to the list of parse actions\n        start.addParseAction(rfn)\n\n        text = \"\"\"_<img src=\"images/cal.png\"\n            alt=\"cal image\" width=\"16\" height=\"15\">_\"\"\"\n        s = start.transformString(text)\n        print(s)\n        self.assertTrue(\n            s.startswith(\"_images/cal.png:\"), \"failed to preserve input s properly\"\n        )\n        self.assertTrue(\n            s.endswith(\"77_\"), \"failed to return full original text properly\"\n        )\n\n        tag_fields = makeHTMLStartTag(\"IMG\").searchString(text)[0]\n        print(sorted(tag_fields.keys()))\n        self.assertEqual(\n            [\"alt\", \"empty\", \"height\", \"src\", \"startImg\", \"tag\", \"width\"],\n            sorted(tag_fields.keys()),\n            \"failed to preserve results names in originalTextFor\",\n        )\n\n    def testPackratParsingCacheCopy(self):\n        integer = pp.Word(pp.nums).setName(\"integer\")\n        id = pp.Word(pp.alphas + \"_\", pp.alphanums + \"_\")\n        simpleType = pp.Literal(\"int\")\n        arrayType = simpleType + (\"[\" + pp.delimitedList(integer) + \"]\")[...]\n        varType = arrayType | simpleType\n        varDec = varType + pp.delimitedList(id + pp.Optional(\"=\" + integer)) + \";\"\n\n        codeBlock = pp.Literal(\"{}\")\n\n        funcDef = (\n            pp.Optional(varType | \"void\")\n            + id\n            + \"(\"\n            + (pp.delimitedList(varType + id) | \"void\" | pp.empty)\n            + \")\"\n            + codeBlock\n        )\n\n        program = varDec | funcDef\n        input = \"int f(){}\"\n        self.assertParseAndCheckList(\n            program,\n            input,\n            [\"int\", \"f\", \"(\", \")\", \"{}\"],\n            msg=\"Error in packrat parsing\",\n            verbose=True,\n        )\n\n    def testPackratParsingCacheCopyTest2(self):\n        DO, AA = list(map(pp.Keyword, \"DO AA\".split()))\n        LPAR, RPAR = list(map(pp.Suppress, \"()\"))\n        identifier = ~AA + pp.Word(\"Z\")\n\n        function_name = identifier.copy()\n        # ~ function_name = ~AA + Word(\"Z\")  #identifier.copy()\n        expr = pp.Forward().setName(\"expr\")\n        expr <<= pp.Group(\n            function_name + LPAR + pp.Optional(pp.delimitedList(expr)) + RPAR\n        ).setName(\"functionCall\") | identifier.setName(\n            \"ident\"\n        )  # .setDebug()#.setBreak()\n\n        stmt = DO + pp.Group(pp.delimitedList(identifier + \".*\" | expr))\n        result = stmt.parseString(\"DO Z\", parseAll=True)\n        print(result.asList())\n        self.assertEqual(\n            1, len(result[1]), \"packrat parsing is duplicating And term exprs\"\n        )\n\n    def testParseResultsDel(self):\n        grammar = pp.OneOrMore(pp.Word(pp.nums))(\"ints\") + pp.OneOrMore(\n            pp.Word(pp.alphas)\n        )(\"words\")\n        res = grammar.parseString(\"123 456 ABC DEF\", parseAll=True)\n        print(res.dump())\n        origInts = res.ints.asList()\n        origWords = res.words.asList()\n        del res[1]\n        del res[\"words\"]\n        print(res.dump())\n        self.assertEqual(\"ABC\", res[1], \"failed to delete 0'th element correctly\")\n        self.assertEqual(\n            origInts,\n            res.ints.asList(),\n            \"updated named attributes, should have updated list only\",\n        )\n        self.assertEqual(\"\", res.words, \"failed to update named attribute correctly\")\n        self.assertEqual(\n            \"DEF\", res[-1], \"updated list, should have updated named attributes only\"\n        )\n\n    def testWithAttributeParseAction(self):\n        \"\"\"\n        This unit test checks withAttribute in these ways:\n\n        * Argument forms as keywords and tuples\n        * Selecting matching tags by attribute\n        * Case-insensitive attribute matching\n        * Correctly matching tags having the attribute, and rejecting tags not having the attribute\n\n        (Unit test written by voigts as part of the Google Highly Open Participation Contest)\n        \"\"\"\n\n        data = \"\"\"\n        <a>1</a>\n        <a b=\"x\">2</a>\n        <a B=\"x\">3</a>\n        <a b=\"X\">4</a>\n        <a b=\"y\">5</a>\n        <a class=\"boo\">8</ a>\n        \"\"\"\n        tagStart, tagEnd = pp.makeHTMLTags(\"a\")\n\n        expr = tagStart + pp.Word(pp.nums)(\"value\") + tagEnd\n\n        expected = (\n            [\n                [\"a\", [\"b\", \"x\"], False, \"2\", \"</a>\"],\n                [\"a\", [\"b\", \"x\"], False, \"3\", \"</a>\"],\n            ],\n            [\n                [\"a\", [\"b\", \"x\"], False, \"2\", \"</a>\"],\n                [\"a\", [\"b\", \"x\"], False, \"3\", \"</a>\"],\n            ],\n            [[\"a\", [\"class\", \"boo\"], False, \"8\", \"</a>\"]],\n        )\n\n        for attrib, exp in zip(\n            [\n                pp.withAttribute(b=\"x\"),\n                # withAttribute(B=\"x\"),\n                pp.withAttribute((\"b\", \"x\")),\n                # withAttribute((\"B\", \"x\")),\n                pp.withClass(\"boo\"),\n            ],\n            expected,\n        ):\n            tagStart.setParseAction(attrib)\n            result = expr.searchString(data)\n\n            print(result.dump())\n            self.assertParseResultsEquals(\n                result,\n                expected_list=exp,\n                msg=f\"Failed test, expected {expected}, got {result.asList()}\",\n            )\n\n    def testNestedExpressions(self):\n        \"\"\"\n        This unit test checks nestedExpr in these ways:\n        - use of default arguments\n        - use of non-default arguments (such as a pyparsing-defined comment\n          expression in place of quotedString)\n        - use of a custom content expression\n        - use of a pyparsing expression for opener and closer is *OPTIONAL*\n        - use of input data containing nesting delimiters\n        - correct grouping of parsed tokens according to nesting of opening\n          and closing delimiters in the input string\n\n        (Unit test written by christoph... as part of the Google Highly Open Participation Contest)\n        \"\"\"\n\n        # All defaults. Straight out of the example script. Also, qualifies for\n        # the bonus: note the fact that (Z | (E^F) & D) is not parsed :-).\n        # Tests for bug fixed in 1.4.10\n        print(\"Test defaults:\")\n        teststring = \"((ax + by)*C) (Z | (E^F) & D)\"\n\n        expr = pp.nestedExpr()\n\n        expected = [[[\"ax\", \"+\", \"by\"], \"*C\"]]\n        result = expr.parseString(teststring, parseAll=False)\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result,\n            expected_list=expected,\n            msg=f\"Defaults didn't work. That's a bad sign. Expected: {expected}, got: {result}\",\n        )\n\n        # Going through non-defaults, one by one; trying to think of anything\n        # odd that might not be properly handled.\n\n        # Change opener\n        print(\"\\nNon-default opener\")\n        teststring = \"[[ ax + by)*C)\"\n        expected = [[[\"ax\", \"+\", \"by\"], \"*C\"]]\n        expr = pp.nestedExpr(\"[\")\n        self.assertParseAndCheckList(\n            expr,\n            teststring,\n            expected,\n            f\"Non-default opener didn't work. Expected: {expected}, got: {result}\",\n            verbose=True,\n        )\n\n        # Change closer\n        print(\"\\nNon-default closer\")\n\n        teststring = \"((ax + by]*C]\"\n        expected = [[[\"ax\", \"+\", \"by\"], \"*C\"]]\n        expr = pp.nestedExpr(closer=\"]\")\n        self.assertParseAndCheckList(\n            expr,\n            teststring,\n            expected,\n            f\"Non-default closer didn't work. Expected: {expected}, got: {result}\",\n            verbose=True,\n        )\n\n        # #Multicharacter opener, closer\n        # opener = \"bar\"\n        # closer = \"baz\"\n        print(\"\\nLiteral expressions for opener and closer\")\n\n        opener, closer = map(pp.Literal, \"bar baz\".split())\n        expr = pp.nestedExpr(\n            opener, closer, content=pp.Regex(r\"([^b ]|b(?!a)|ba(?![rz]))+\")\n        )\n\n        teststring = \"barbar ax + bybaz*Cbaz\"\n        expected = [[[\"ax\", \"+\", \"by\"], \"*C\"]]\n        self.assertParseAndCheckList(\n            expr,\n            teststring,\n            expected,\n            f\"Multicharacter opener and closer didn't work. Expected: {expected}, got: {result}\",\n            verbose=True,\n        )\n\n        # Lisp-ish comments\n        print(\"\\nUse ignore expression (1)\")\n        comment = pp.Regex(r\";;.*\")\n        teststring = \"\"\"\n        (let ((greeting \"Hello, world!\")) ;;(foo bar\n           (display greeting))\n        \"\"\"\n\n        expected = [\n            [\n                \"let\",\n                [[\"greeting\", '\"Hello,', 'world!\"']],\n                \";;(foo bar\",\n                [\"display\", \"greeting\"],\n            ]\n        ]\n        expr = pp.nestedExpr(ignoreExpr=comment)\n        self.assertParseAndCheckList(\n            expr,\n            teststring,\n            expected,\n            f'Lisp-ish comments (\";; <...> $\") didn\\'t work. Expected: {expected}, got: {result}',\n            verbose=True,\n        )\n\n        # Lisp-ish comments, using a standard bit of pyparsing, and an Or.\n        print(\"\\nUse ignore expression (2)\")\n        comment = \";;\" + pp.restOfLine\n\n        teststring = \"\"\"\n        (let ((greeting \"Hello, )world!\")) ;;(foo bar\n           (display greeting))\n        \"\"\"\n\n        expected = [\n            [\n                \"let\",\n                [[\"greeting\", '\"Hello, )world!\"']],\n                \";;\",\n                \"(foo bar\",\n                [\"display\", \"greeting\"],\n            ]\n        ]\n        expr = pp.nestedExpr(ignoreExpr=(comment ^ pp.quotedString))\n        self.assertParseAndCheckList(\n            expr,\n            teststring,\n            expected,\n            f'Lisp-ish comments (\";; <...> $\") and quoted strings didn\\'t work. Expected: {expected}, got: {result}',\n            verbose=True,\n        )\n\n    def testNestedExpressions2(self):\n        \"\"\"test nestedExpr with conditions that explore other paths\n\n        identical opener and closer\n        opener and/or closer of type other than string or iterable\n        multi-character opener and/or closer\n        single character opener and closer with ignoreExpr=None\n        multi-character opener and/or closer with ignoreExpr=None\n        \"\"\"\n\n        name = pp.Word(pp.alphanums + \"_\")\n\n        # identical opener and closer\n        with self.assertRaises(\n            ValueError, msg=\"matching opener and closer should raise error\"\n        ):\n            expr = name + pp.nestedExpr(opener=\"{\", closer=\"{\")\n\n        # opener and/or closer of type other than string or iterable\n        with self.assertRaises(\n            ValueError, msg=\"opener and closer as ints should raise error\"\n        ):\n            expr = name + pp.nestedExpr(opener=12, closer=18)\n\n        # multi-character opener and/or closer\n        tstMulti = \"aName {{ outer {{ 'inner with opener {{ and closer }} in quoted string' }} }}\"\n        expr = name + pp.nestedExpr(opener=\"{{\", closer=\"}}\")\n        result = expr.parseString(tstMulti, parseAll=True)\n        expected = [\n            \"aName\",\n            [\"outer\", [\"'inner with opener {{ and closer }} in quoted string'\"]],\n        ]\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with multi-character opener and closer\"\n        )\n\n        # single character opener and closer with ignoreExpr=None\n        tst = \"aName { outer { 'inner with opener { and closer } in quoted string' }}\"\n        expr = name + pp.nestedExpr(opener=\"{\", closer=\"}\", ignoreExpr=None)\n        singleCharResult = expr.parseString(tst, parseAll=True)\n        print(singleCharResult.dump())\n\n        # multi-character opener and/or closer with ignoreExpr=None\n        expr = name + pp.nestedExpr(opener=\"{{\", closer=\"}}\", ignoreExpr=None)\n        multiCharResult = expr.parseString(tstMulti, parseAll=True)\n        print(multiCharResult.dump())\n\n        self.assertParseResultsEquals(\n            singleCharResult,\n            multiCharResult.asList(),\n            msg=\"using different openers and closers shouldn't affect resulting ParseResults\",\n        )\n\n    def testWordMinMaxArgs(self):\n        parsers = [\n            \"A\" + pp.Word(pp.nums),\n            \"A\" + pp.Word(pp.nums, min=1),\n            \"A\" + pp.Word(pp.nums, max=6),\n            \"A\" + pp.Word(pp.nums, min=1, max=6),\n            \"A\" + pp.Word(pp.nums, min=1),\n            \"A\" + pp.Word(pp.nums, min=2),\n            \"A\" + pp.Word(pp.nums, min=2, max=6),\n            pp.Word(\"A\", pp.nums),\n            pp.Word(\"A\", pp.nums, min=1),\n            pp.Word(\"A\", pp.nums, max=6),\n            pp.Word(\"A\", pp.nums, min=1, max=6),\n            pp.Word(\"A\", pp.nums, min=1),\n            pp.Word(\"A\", pp.nums, min=2),\n            pp.Word(\"A\", pp.nums, min=2, max=6),\n            pp.Word(pp.alphas, pp.nums),\n            pp.Word(pp.alphas, pp.nums, min=1),\n            pp.Word(pp.alphas, pp.nums, max=6),\n            pp.Word(pp.alphas, pp.nums, min=1, max=6),\n            pp.Word(pp.alphas, pp.nums, min=1),\n            pp.Word(pp.alphas, pp.nums, min=2),\n            pp.Word(pp.alphas, pp.nums, min=2, max=6),\n        ]\n\n        fails = []\n        for p in parsers:\n            print(p, getattr(p, \"reString\", \"...\"), end=\" \", flush=True)\n            try:\n                p.parseString(\"A123\", parseAll=True)\n            except Exception as e:\n                print(\"      <<< FAIL\")\n                fails.append(p)\n            else:\n                print()\n        if fails:\n            self.fail(f\"{','.join(str(f) for f in fails)} failed to match\")\n\n    def testWordMinMaxExactArgs(self):\n        for minarg in range(1, 9):\n            for maxarg in range(minarg, 10):\n                with self.subTest(minarg=minarg, maxarg=maxarg):\n                    expr = pp.Word(\"AB\", pp.nums, min=minarg, max=maxarg)\n                    print(minarg, maxarg, expr.reString, end=\" \")\n                    trailing = expr.reString.rpartition(\"]\")[-1]\n                    expected_special = {\n                        (1, 1): \"\",\n                        (1, 2): \"?\",\n                        (2, 2): \"\",\n                    }\n                    expected_default = (\n                        f\"{{{minarg - 1}}}\"\n                        if minarg == maxarg\n                        else f\"{{{minarg - 1},{maxarg - 1}}}\"\n                    )\n                    expected = expected_special.get((minarg, maxarg), expected_default)\n\n                    print(trailing == expected)\n\n                    self.assertEqual(trailing, expected)\n\n                    self.assertParseAndCheckList(\n                        expr + pp.restOfLine.suppress(),\n                        \"A1234567890\",\n                        [\"A1234567890\"[:maxarg]],\n                    )\n\n        for exarg in range(1, 9):\n            with self.subTest(exarg=exarg):\n                expr = pp.Word(\"AB\", pp.nums, exact=exarg)\n                print(exarg, expr.reString, end=\" \")\n                trailing = expr.reString.rpartition(\"]\")[-1]\n                if exarg < 3:\n                    expected = \"\"\n                else:\n                    expected = f\"{{{exarg - 1}}}\"\n                print(trailing == expected)\n\n                self.assertEqual(trailing, expected)\n\n                self.assertParseAndCheckList(\n                    expr + pp.restOfLine.suppress(),\n                    \"A1234567890\",\n                    [\"A1234567890\"[:exarg]],\n                )\n\n    def testWordMin(self):\n        # failing tests\n        for min_val in range(3, 5):\n            with self.subTest(min_val=min_val):\n                wd = pp.Word(\"a\", \"1\", min=min_val)\n                print(min_val, wd.reString)\n                with self.assertRaisesParseException():\n                    wd.parse_string(\"a1\")\n\n        for min_val in range(2, 5):\n            with self.subTest(min_val=min_val):\n                wd = pp.Word(\"a\", min=min_val)\n                print(min_val, wd.reString)\n                with self.assertRaisesParseException():\n                    wd.parse_string(\"a\")\n\n        for min_val in range(3, 5):\n            with self.subTest(min_val=min_val):\n                wd = pp.Word(\"a\", \"1\", min=min_val)\n                print(min_val, wd.reString)\n                with self.assertRaisesParseException():\n                    wd.parse_string(\"a1\")\n\n        # passing tests\n        for min_val in range(2, 5):\n            with self.subTest(min_val=min_val):\n                wd = pp.Word(\"a\", min=min_val)\n                test_string = \"a\" * min_val\n                self.assertParseAndCheckList(\n                    wd,\n                    test_string,\n                    [test_string],\n                    msg=f\"Word(min={min_val}) failed\",\n                    verbose=True,\n                )\n\n        for min_val in range(2, 5):\n            with self.subTest(min_val=min_val):\n                wd = pp.Word(\"a\", \"1\", min=min_val)\n                test_string = \"a\" + \"1\" * (min_val - 1)\n                self.assertParseAndCheckList(\n                    wd,\n                    test_string,\n                    [test_string],\n                    msg=f\"Word(min={min_val}) failed\",\n                    verbose=True,\n                )\n\n    def testWordExact(self):\n        # failing tests\n        for exact_val in range(2, 5):\n            with self.subTest(exact_val=exact_val):\n                wd = pp.Word(\"a\", exact=exact_val)\n                print(exact_val, wd.reString)\n                with self.assertRaisesParseException():\n                    wd.parse_string(\"a\")\n\n        # passing tests\n        for exact_val in range(2, 5):\n            with self.subTest(exact_val=exact_val):\n                wd = pp.Word(\"a\", exact=exact_val)\n                test_string = \"a\" * exact_val\n                self.assertParseAndCheckList(\n                    wd,\n                    test_string,\n                    [test_string],\n                    msg=f\"Word(exact={exact_val}) failed\",\n                    verbose=True,\n                )\n\n    def testInvalidMinMaxArgs(self):\n        with self.assertRaises(ValueError):\n            wd = pp.Word(min=2, max=1)\n\n    def testWordExclude(self):\n        allButPunc = pp.Word(pp.printables, excludeChars=\".,:;-_!?\")\n\n        test = \"Hello, Mr. Ed, it's Wilbur!\"\n        result = allButPunc.searchString(test).asList()\n        print(result)\n        self.assertEqual(\n            [[\"Hello\"], [\"Mr\"], [\"Ed\"], [\"it's\"], [\"Wilbur\"]],\n            result,\n            \"failed WordExcludeTest\",\n        )\n\n    def testWordExclude2(self):\n        punc_chars = \".,:;-_!?\"\n\n        all_but_punc = pp.Word(pp.printables, excludeChars=punc_chars)\n        all_and_punc = pp.Word(pp.printables)\n\n        assert set(punc_chars) & set(all_but_punc.initChars) == set()\n\n        expr = all_but_punc(\"no_punc*\") | all_and_punc(\"with_punc*\")\n\n        self.assertParseAndCheckDict(\n            expr[...],\n            \"Mr. Ed,\",\n            {\"no_punc\": [\"Mr\", \"Ed\"], \"with_punc\": [\".\", \",\"]},\n            \"failed matching with excludeChars (1)\",\n        )\n\n        self.assertParseAndCheckDict(\n            expr[...],\n            \":Mr. Ed,\",\n            {\"no_punc\": [\"Ed\"], \"with_punc\": [\":Mr.\", \",\"]},\n            \"failed matching with excludeChars (2)\",\n        )\n\n    def testWordMinOfZero(self):\n        \"\"\"test a Word with min=0\"\"\"\n\n        with self.assertRaises(ValueError, msg=\"expected min 0 to error\"):\n            expr = pp.Word(pp.nums, min=0, max=10)\n\n    @staticmethod\n    def setup_testWordMaxGreaterThanZeroAndAsKeyword():\n        # fmt: off\n        bool_operand = (\n                pp.Word(pp.alphas, max=1, asKeyword=True)\n                | pp.one_of(\"True False\")\n        )\n        test_string = \"p q r False\"\n        return SimpleNamespace(**locals())\n        # fmt: on\n\n    def testWordMaxGreaterThanZeroAndAsKeyword1(self):\n        \"\"\"test a Word with max>0 and asKeyword=True\"\"\"\n        setup = self.setup_testWordMaxGreaterThanZeroAndAsKeyword()\n\n        result = setup.bool_operand[...].parseString(setup.test_string, parseAll=True)\n        self.assertParseAndCheckList(\n            setup.bool_operand[...],\n            setup.test_string,\n            setup.test_string.split(),\n            msg=f\"{__()}Failed to parse Word(max=1, asKeyword=True)\",\n            verbose=True,\n        )\n\n    def testWordMaxGreaterThanZeroAndAsKeyword2(self):\n        \"\"\"test a Word with max>0 and asKeyword=True\"\"\"\n        setup = self.setup_testWordMaxGreaterThanZeroAndAsKeyword()\n\n        with self.assertRaisesParseException(\n            msg=f\"{__()}Failed to detect Word with max > 0 and asKeyword=True\"\n        ):\n            setup.bool_operand.parseString(\"abc\", parseAll=True)\n\n    def testCharAsKeyword(self):\n        \"\"\"test a Char with asKeyword=True\"\"\"\n\n        grade = pp.OneOrMore(pp.Char(\"ABCDF\", asKeyword=True))\n\n        # all single char words\n        result = grade.parseString(\"B B C A D\", parseAll=True)\n\n        print(result)\n        expected = [\"B\", \"B\", \"C\", \"A\", \"D\"]\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with Char asKeyword=True\"\n        )\n\n        # NOT all single char words\n        test2 = \"B BB C A D\"\n        result2 = grade.parseString(test2, parseAll=False)\n\n        print(result2)\n        expected2 = [\"B\"]\n        self.assertParseResultsEquals(\n            result2, expected2, msg=\"issue with Char asKeyword=True parsing 2 chars\"\n        )\n\n    def testCharRe(self):\n        expr = pp.Char(\"ABCDEFG\")\n        self.assertEqual(\"[A-G]\", expr.reString)\n\n    def testCharsNotIn(self):\n        \"\"\"test CharsNotIn initialized with various arguments\"\"\"\n\n        vowels = \"AEIOU\"\n        tst = \"bcdfghjklmnpqrstvwxyz\"\n\n        # default args\n        consonants = pp.CharsNotIn(vowels)\n        result = consonants.parseString(tst, parseAll=True)\n        print(result)\n        self.assertParseResultsEquals(\n            result, [tst], msg=\"issue with CharsNotIn w/ default args\"\n        )\n\n        # min = 0\n        with self.assertRaises(ValueError, msg=\"issue with CharsNotIn w/ min=0\"):\n            consonants = pp.CharsNotIn(vowels, min=0)\n\n        # max > 0\n        consonants = pp.CharsNotIn(vowels, max=5)\n        result = consonants.parseString(tst, parseAll=False)\n        print(result)\n        self.assertParseResultsEquals(\n            result, [tst[:5]], msg=\"issue with CharsNotIn w max > 0\"\n        )\n\n        # exact > 0\n        consonants = pp.CharsNotIn(vowels, exact=10)\n        result = consonants.parseString(tst[:10], parseAll=True)\n        print(result)\n        self.assertParseResultsEquals(\n            result, [tst[:10]], msg=\"issue with CharsNotIn w/ exact > 0\"\n        )\n\n        # min > length\n        consonants = pp.CharsNotIn(vowels, min=25)\n        with self.assertRaisesParseException(msg=\"issue with CharsNotIn min > tokens\"):\n            result = consonants.parseString(tst, parseAll=True)\n\n    def testParseAll(self):\n        testExpr = pp.Word(\"A\")\n\n        tests = [\n            (\"AAAAA\", False, True),\n            (\"AAAAA\", True, True),\n            (\"AAABB\", False, True),\n            (\"AAABB\", True, False),\n        ]\n        for s, parseAllFlag, shouldSucceed in tests:\n            try:\n                print(f\"'{s}' parseAll={parseAllFlag} (shouldSucceed={shouldSucceed})\")\n                testExpr.parseString(s, parseAll=parseAllFlag)\n                self.assertTrue(\n                    shouldSucceed, \"successfully parsed when should have failed\"\n                )\n            except ParseException as pe:\n                print(pe.explain())\n                self.assertFalse(\n                    shouldSucceed, \"failed to parse when should have succeeded\"\n                )\n\n        # add test for trailing comments\n        testExpr.ignore(pp.cppStyleComment)\n\n        tests = [\n            (\"AAAAA //blah\", False, True),\n            (\"AAAAA //blah\", True, True),\n            (\"AAABB //blah\", False, True),\n            (\"AAABB //blah\", True, False),\n        ]\n        for s, parseAllFlag, shouldSucceed in tests:\n            try:\n                print(f\"'{s}' parseAll={parseAllFlag} (shouldSucceed={shouldSucceed})\")\n                testExpr.parseString(s, parseAll=parseAllFlag)\n                self.assertTrue(\n                    shouldSucceed, \"successfully parsed when should have failed\"\n                )\n            except ParseException as pe:\n                print(pe.explain())\n                self.assertFalse(\n                    shouldSucceed, \"failed to parse when should have succeeded\"\n                )\n\n        # add test with very long expression string\n        # testExpr = pp.MatchFirst([pp.Literal(c) for c in pp.printables if c != 'B'])[1, ...]\n        anything_but_an_f = pp.OneOrMore(\n            pp.MatchFirst([pp.Literal(c) for c in pp.printables if c != \"f\"])\n        )\n        testExpr = pp.Word(\"012\") + anything_but_an_f\n\n        tests = [\n            (\"00aab\", False, True),\n            (\"00aab\", True, True),\n            (\"00aaf\", False, True),\n            (\"00aaf\", True, False),\n        ]\n        for s, parseAllFlag, shouldSucceed in tests:\n            try:\n                print(f\"'{s}' parseAll={parseAllFlag} (shouldSucceed={shouldSucceed})\")\n                testExpr.parseString(s, parseAll=parseAllFlag)\n                self.assertTrue(\n                    shouldSucceed, \"successfully parsed when should have failed\"\n                )\n            except ParseException as pe:\n                print(pe.explain())\n                self.assertFalse(\n                    shouldSucceed, \"failed to parse when should have succeeded\"\n                )\n\n    def testGreedyQuotedStrings(self):\n        src = \"\"\"\\\n           \"string1\", \"strin\"\"g2\"\n           'string1', 'string2'\n           ^string1^, ^string2^\n           <string1>, <string2>\"\"\"\n\n        testExprs = (\n            pp.sglQuotedString,\n            pp.dblQuotedString,\n            pp.quotedString,\n            pp.QuotedString('\"', escQuote='\"\"'),\n            pp.QuotedString(\"'\", escQuote=\"''\"),\n            pp.QuotedString(\"^\"),\n            pp.QuotedString(\"<\", endQuoteChar=\">\"),\n        )\n        for expr in testExprs:\n            strs = pp.delimitedList(expr).searchString(src)\n            print(strs)\n            self.assertTrue(\n                bool(strs), f\"no matches found for test expression '{expr}'\"\n            )\n            for lst in strs:\n                self.assertEqual(\n                    2, len(lst), f\"invalid match found for test expression '{expr}'\"\n                )\n\n        src = \"\"\"'ms1',1,0,'2009-12-22','2009-12-22 10:41:22') ON DUPLICATE KEY UPDATE sent_count = sent_count + 1, mtime = '2009-12-22 10:41:22';\"\"\"\n        tok_sql_quoted_value = pp.QuotedString(\n            \"'\", \"\\\\\", \"''\", True, False\n        ) ^ pp.QuotedString('\"', \"\\\\\", '\"\"', True, False)\n        tok_sql_computed_value = pp.Word(pp.nums)\n        tok_sql_identifier = pp.Word(pp.alphas)\n\n        val = tok_sql_quoted_value | tok_sql_computed_value | tok_sql_identifier\n        vals = pp.delimitedList(val)\n        print(vals.parseString(src, parseAll=False))\n        self.assertEqual(\n            5,\n            len(vals.parseString(src, parseAll=False)),\n            \"error in greedy quote escaping\",\n        )\n\n    def testQuotedStringEscapedQuotes(self):\n        quoted = pp.QuotedString('\"', escQuote='\"\"')\n        res = quoted.parseString('\"like \"\"SQL\"\"\"', parseAll=True)\n        print(res.asList())\n        self.assertEqual(['like \"SQL\"'], res.asList())\n\n        # Issue #263 - handle case when the escQuote is not a repeated character\n        quoted = pp.QuotedString(\"y\", escChar=None, escQuote=\"xy\")\n        res = quoted.parseString(\"yaaay\", parseAll=True)\n        self.assertEqual([\"aaa\"], res.asList())\n        res = quoted.parseString(\"yaaaxyaaay\", parseAll=True)\n        print(res.asList())\n        self.assertEqual([\"aaayaaa\"], res.asList())\n\n    def testWordBoundaryExpressions(self):\n        ws = pp.WordStart()\n        we = pp.WordEnd()\n        vowel = pp.oneOf(list(\"AEIOUY\"))\n        consonant = pp.oneOf(list(\"BCDFGHJKLMNPQRSTVWXZ\"))\n\n        leadingVowel = ws + vowel\n        trailingVowel = vowel + we\n        leadingConsonant = ws + consonant\n        trailingConsonant = consonant + we\n        internalVowel = ~ws + vowel + ~we\n\n        bnf = leadingVowel | trailingVowel\n\n        tests = \"\"\"\\\n        ABC DEF GHI\n          JKL MNO PQR\n        STU VWX YZ  \"\"\".splitlines()\n        tests.append(\"\\n\".join(tests))\n\n        expectedResult = [\n            [[\"D\", \"G\"], [\"A\"], [\"C\", \"F\"], [\"I\"], [\"E\"], [\"A\", \"I\"]],\n            [[\"J\", \"M\", \"P\"], [], [\"L\", \"R\"], [\"O\"], [], [\"O\"]],\n            [[\"S\", \"V\"], [\"Y\"], [\"X\", \"Z\"], [\"U\"], [], [\"U\", \"Y\"]],\n            [\n                [\"D\", \"G\", \"J\", \"M\", \"P\", \"S\", \"V\"],\n                [\"A\", \"Y\"],\n                [\"C\", \"F\", \"L\", \"R\", \"X\", \"Z\"],\n                [\"I\", \"O\", \"U\"],\n                [\"E\"],\n                [\"A\", \"I\", \"O\", \"U\", \"Y\"],\n            ],\n        ]\n\n        for t, expected in zip(tests, expectedResult):\n            print(t)\n            results = [\n                flatten(e.searchString(t).asList())\n                for e in [\n                    leadingConsonant,\n                    leadingVowel,\n                    trailingConsonant,\n                    trailingVowel,\n                    internalVowel,\n                    bnf,\n                ]\n            ]\n            print(results)\n            print()\n            self.assertEqual(\n                expected,\n                results,\n                f\"Failed WordBoundaryTest, expected {expected}, got {results}\",\n            )\n\n    def testWordBoundaryExpressions2(self):\n        from itertools import product\n\n        ws1 = pp.WordStart(pp.alphas)\n        ws2 = pp.WordStart(wordChars=pp.alphas)\n        ws3 = pp.WordStart(word_chars=pp.alphas)\n        we1 = pp.WordEnd(pp.alphas)\n        we2 = pp.WordEnd(wordChars=pp.alphas)\n        we3 = pp.WordEnd(word_chars=pp.alphas)\n\n        for i, (ws, we) in enumerate(product((ws1, ws2, ws3), (we1, we2, we3))):\n            try:\n                expr = \"(\" + ws + pp.Word(pp.alphas) + we + \")\"\n                expr.parseString(\"(abc)\", parseAll=True)\n            except pp.ParseException as pe:\n                self.fail(f\"Test {i} failed: {pe}\")\n            else:\n                pass\n\n    def testRequiredEach(self):\n        parser = pp.Keyword(\"bam\") & pp.Keyword(\"boo\")\n        try:\n            res1 = parser.parseString(\"bam boo\", parseAll=True)\n            print(res1.asList())\n            res2 = parser.parseString(\"boo bam\", parseAll=True)\n            print(res2.asList())\n        except ParseException:\n            failed = True\n        else:\n            failed = False\n            self.assertFalse(failed, \"invalid logic in Each\")\n\n            self.assertEqual(\n                set(res1),\n                set(res2),\n                f\"Failed RequiredEachTest, expected {res1.as_list()}\"\n                f\" and {res2.as_list} to contain the same words in any order\",\n            )\n\n    def testOptionalEachTest1(self):\n        for the_input in [\n            \"Tal Weiss Major\",\n            \"Tal Major\",\n            \"Weiss Major\",\n            \"Major\",\n            \"Major Tal\",\n            \"Major Weiss\",\n            \"Major Tal Weiss\",\n        ]:\n            print(the_input)\n            parser1 = (pp.Optional(\"Tal\") + pp.Optional(\"Weiss\")) & pp.Keyword(\"Major\")\n            parser2 = pp.Optional(\n                pp.Optional(\"Tal\") + pp.Optional(\"Weiss\")\n            ) & pp.Keyword(\"Major\")\n            p1res = parser1.parseString(the_input, parseAll=True)\n            p2res = parser2.parseString(the_input, parseAll=True)\n            self.assertEqual(\n                p1res.asList(),\n                p2res.asList(),\n                f\"Each failed to match with nested Optionals, {p1res.as_list()} should match {p2res.as_list()}\",\n            )\n\n    def testOptionalEachTest2(self):\n        word = pp.Word(pp.alphanums + \"_\").setName(\"word\")\n        with_stmt = \"with\" + pp.OneOrMore(pp.Group(word(\"key\") + \"=\" + word(\"value\")))(\n            \"overrides\"\n        )\n        using_stmt = \"using\" + pp.Regex(\"id-[0-9a-f]{8}\")(\"id\")\n        modifiers = pp.Optional(with_stmt(\"with_stmt\")) & pp.Optional(\n            using_stmt(\"using_stmt\")\n        )\n\n        self.assertEqual(\"with foo=bar bing=baz using id-deadbeef\", modifiers)\n        self.assertNotEqual(\n            \"with foo=bar bing=baz using id-deadbeef using id-feedfeed\", modifiers\n        )\n\n    def testOptionalEachTest3(self):\n        foo = pp.Literal(\"foo\")\n        bar = pp.Literal(\"bar\")\n\n        openBrace = pp.Suppress(pp.Literal(\"{\"))\n        closeBrace = pp.Suppress(pp.Literal(\"}\"))\n\n        exp = openBrace + (foo[1, ...](\"foo\") & bar[...](\"bar\")) + closeBrace\n\n        tests = \"\"\"\\\n            {foo}\n            {bar foo bar foo bar foo}\n            \"\"\".splitlines()\n        for test in tests:\n            test = test.strip()\n            if not test:\n                continue\n            self.assertParseAndCheckList(\n                exp,\n                test,\n                test.strip(\"{}\").split(),\n                f\"failed to parse Each expression {test!r}\",\n                verbose=True,\n            )\n\n        with self.assertRaisesParseException():\n            exp.parseString(\"{bar}\", parseAll=True)\n\n    def testOptionalEachTest4(self):\n        expr = (~ppc.iso8601_date + ppc.integer(\"id\")) & (\n            pp.Group(ppc.iso8601_date)(\"date*\")[...]\n        )\n\n        expr.runTests(\n            \"\"\"\n            1999-12-31 100 2001-01-01\n            42\n            \"\"\"\n        )\n\n    def testEachWithParseFatalException(self):\n        option_expr = pp.Keyword(\"options\") - \"(\" + ppc.integer + \")\"\n        step_expr1 = pp.Keyword(\"step\") - \"(\" + ppc.integer + \")\"\n        step_expr2 = pp.Keyword(\"step\") - \"(\" + ppc.integer + \"Z\" + \")\"\n        step_expr = step_expr1 ^ step_expr2\n\n        parser = option_expr & step_expr[...]\n        tests = [\n            (\n                \"options(100) step(A)\",\n                \"Expected integer, found 'A'  (at char 18), (line:1, col:19)\",\n            ),\n            (\n                \"step(A) options(100)\",\n                \"Expected integer, found 'A'  (at char 5), (line:1, col:6)\",\n            ),\n            (\n                \"options(100) step(100A)\",\n                \"\"\"Expected 'Z', found 'A'  (at char 21), (line:1, col:22)\"\"\",\n            ),\n            (\n                \"options(100) step(22) step(100ZA)\",\n                \"\"\"Expected ')', found 'A'  (at char 31), (line:1, col:32)\"\"\",\n            ),\n        ]\n        test_lookup = dict(tests)\n\n        success, output = parser.runTests((t[0] for t in tests), failureTests=True)\n        for test_str, result in output:\n            self.assertEqual(\n                test_lookup[test_str],\n                str(result),\n                f\"incorrect exception raised for test string {test_str!r}\",\n            )\n\n    def testEachWithMultipleMatch(self):\n        size = \"size\" + pp.oneOf(\"S M L XL\")\n        color = pp.Group(\n            \"color\" + pp.oneOf(\"red orange yellow green blue purple white black brown\")\n        )\n        size.setName(\"size_spec\")\n        color.setName(\"color_spec\")\n\n        spec0 = size(\"size\") & color[...](\"colors\")\n        spec1 = size(\"size\") & color[1, ...](\"colors\")\n\n        for spec in (spec0, spec1):\n            for test, expected_dict in [\n                (\n                    \"size M color red color yellow\",\n                    {\n                        \"colors\": [[\"color\", \"red\"], [\"color\", \"yellow\"]],\n                        \"size\": [\"size\", \"M\"],\n                    },\n                ),\n                (\n                    \"color green size M color red color yellow\",\n                    {\n                        \"colors\": [\n                            [\"color\", \"green\"],\n                            [\"color\", \"red\"],\n                            [\"color\", \"yellow\"],\n                        ],\n                        \"size\": [\"size\", \"M\"],\n                    },\n                ),\n            ]:\n                result = spec.parseString(test, parseAll=True)\n                self.assertParseResultsEquals(result, expected_dict=expected_dict)\n\n    def testSumParseResults(self):\n        samplestr1 = \"garbage;DOB 10-10-2010;more garbage\\nID PARI12345678;more garbage\"\n        samplestr2 = \"garbage;ID PARI12345678;more garbage\\nDOB 10-10-2010;more garbage\"\n        samplestr3 = \"garbage;DOB 10-10-2010\"\n        samplestr4 = \"garbage;ID PARI12345678;more garbage- I am cool\"\n\n        res1 = \"ID:PARI12345678 DOB:10-10-2010 INFO:\"\n        res2 = \"ID:PARI12345678 DOB:10-10-2010 INFO:\"\n        res3 = \"ID: DOB:10-10-2010 INFO:\"\n        res4 = \"ID:PARI12345678 DOB: INFO: I am cool\"\n\n        dob_ref = \"DOB\" + pp.Regex(r\"\\d{2}-\\d{2}-\\d{4}\")(\"dob\")\n        id_ref = \"ID\" + pp.Word(pp.alphanums, exact=12)(\"id\")\n        info_ref = \"-\" + pp.restOfLine(\"info\")\n\n        person_data = dob_ref | id_ref | info_ref\n\n        tests = (samplestr1, samplestr2, samplestr3, samplestr4)\n        results = (res1, res2, res3, res4)\n        for test, expected in zip(tests, results):\n            person = sum(person_data.searchString(test))\n            result = f\"ID:{person.id} DOB:{person.dob} INFO:{person.info}\"\n            print(test)\n            print(expected)\n            print(result)\n            for pd in person_data.searchString(test):\n                print(pd.dump())\n            print()\n            self.assertEqual(\n                expected,\n                result,\n                f\"Failed to parse '{test}' correctly, \\nexpected '{expected}', got '{result}'\",\n            )\n\n    def testMarkInputLine(self):\n        samplestr1 = \"DOB 100-10-2010;more garbage\\nID PARI12345678;more garbage\"\n\n        dob_ref = \"DOB\" + pp.Regex(r\"\\d{2}-\\d{2}-\\d{4}\")(\"dob\")\n\n        try:\n            res = dob_ref.parseString(samplestr1, parseAll=True)\n        except ParseException as pe:\n            outstr = pe.markInputline()\n            print(outstr)\n            self.assertEqual(\n                \"DOB >!<100-10-2010;more garbage\",\n                outstr,\n                \"did not properly create marked input line\",\n            )\n        else:\n            self.fail(\"test construction failed - should have raised an exception\")\n\n    def testLocatedExpr(self):\n        #             012345678901234567890123456789012345678901234567890\n        samplestr1 = \"DOB 10-10-2010;more garbage;ID PARI12345678  ;more garbage\"\n\n        id_ref = pp.locatedExpr(\"ID\" + pp.Word(pp.alphanums, exact=12)(\"id\"))\n\n        res = id_ref.searchString(samplestr1)[0][0]\n        print(res.dump())\n        self.assertEqual(\n            \"ID PARI12345678\",\n            samplestr1[res.locn_start : res.locn_end],\n            \"incorrect location calculation\",\n        )\n\n    def testLocatedExprUsingLocated(self):\n        #             012345678901234567890123456789012345678901234567890\n        samplestr1 = \"DOB 10-10-2010;more garbage;ID PARI12345678  ;more garbage\"\n\n        id_ref = pp.Located(\"ID\" + pp.Word(pp.alphanums, exact=12)(\"id\"))\n\n        res = id_ref.searchString(samplestr1)[0]\n        print(res.dump())\n        self.assertEqual(\n            \"ID PARI12345678\",\n            samplestr1[res.locn_start : res.locn_end],\n            \"incorrect location calculation\",\n        )\n        self.assertParseResultsEquals(\n            res,\n            [28, [\"ID\", \"PARI12345678\"], 43],\n            {\"locn_end\": 43, \"locn_start\": 28, \"value\": {\"id\": \"PARI12345678\"}},\n        )\n        self.assertEqual(\"PARI12345678\", res.value.id)\n\n        # if Located has a results name, handle appropriately\n        id_ref = pp.Located(\"ID\" + pp.Word(pp.alphanums, exact=12)(\"id\"))(\"loc\")\n\n        res = id_ref.searchString(samplestr1)[0]\n        print(res.dump())\n        self.assertEqual(\n            \"ID PARI12345678\",\n            samplestr1[res.loc.locn_start : res.loc.locn_end],\n            \"incorrect location calculation\",\n        )\n        self.assertParseResultsEquals(\n            res.loc,\n            [28, [\"ID\", \"PARI12345678\"], 43],\n            {\"locn_end\": 43, \"locn_start\": 28, \"value\": {\"id\": \"PARI12345678\"}},\n        )\n        self.assertEqual(\"PARI12345678\", res.loc.value.id)\n\n        wd = pp.Word(pp.alphas)\n        test_string = \"ljsdf123lksdjjf123lkkjj1222\"\n        pp_matches = pp.Located(wd).searchString(test_string)\n        re_matches = find_all_re_matches(\"[a-z]+\", test_string)\n        for pp_match, re_match in zip(pp_matches, re_matches):\n            self.assertParseResultsEquals(\n                pp_match, [re_match.start(), [re_match.group(0)], re_match.end()]\n            )\n            print(pp_match)\n            print(re_match)\n            print(pp_match.value)\n\n    def testPop(self):\n        source = \"AAA 123 456 789 234\"\n        patt = pp.Word(pp.alphas)(\"name\") + pp.Word(pp.nums) * (1,)\n\n        result = patt.parseString(source, parseAll=True)\n        tests = [\n            (0, \"AAA\", [\"123\", \"456\", \"789\", \"234\"]),\n            (None, \"234\", [\"123\", \"456\", \"789\"]),\n            (\"name\", \"AAA\", [\"123\", \"456\", \"789\"]),\n            (-1, \"789\", [\"123\", \"456\"]),\n        ]\n        for test in tests:\n            idx, val, remaining = test\n            if idx is not None:\n                ret = result.pop(idx)\n            else:\n                ret = result.pop()\n            print(\"EXP:\", val, remaining)\n            print(\"GOT:\", ret, result.asList())\n            print(ret, result.asList())\n            self.assertEqual(\n                val,\n                ret,\n                f\"wrong value returned, got {ret!r}, expected {val!r}\",\n            )\n            self.assertEqual(\n                remaining,\n                result.asList(),\n                f\"list is in wrong state after pop, got {result.asList()!r}, expected {remaining!r}\",\n            )\n            print()\n\n        prevlist = result.asList()\n        ret = result.pop(\"name\", default=\"noname\")\n        print(ret)\n        print(result.asList())\n        self.assertEqual(\n            \"noname\",\n            ret,\n            f\"default value not successfully returned, got {ret!r}, expected {'noname'!r}\",\n        )\n        self.assertEqual(\n            prevlist,\n            result.asList(),\n            f\"list is in wrong state after pop, got {result.asList()!r}, expected {remaining!r}\",\n        )\n\n    def testPopKwargsErr(self):\n        \"\"\"raise a TypeError in pop by adding invalid named args\"\"\"\n\n        source = \"AAA 123 456 789 234\"\n        patt = pp.Word(pp.alphas)(\"name\") + pp.Word(pp.nums) * (1,)\n        result = patt.parseString(source, parseAll=True)\n        print(result.dump())\n\n        with self.assertRaises(TypeError):\n            result.pop(notDefault=\"foo\")\n\n    def testAddCondition(self):\n        numParser = pp.Word(pp.nums)\n        numParser.addParseAction(lambda s, l, t: int(t[0]))\n        numParser.addCondition(lambda s, l, t: t[0] % 2)\n        numParser.addCondition(lambda s, l, t: t[0] >= 7)\n\n        result = numParser.searchString(\"1 2 3 4 5 6 7 8 9 10\")\n        print(result.asList())\n        self.assertEqual(\n            [[7], [9]], result.asList(), \"failed to properly process conditions\"\n        )\n\n        numParser = pp.Word(pp.nums)\n        numParser.addParseAction(lambda s, l, t: int(t[0]))\n        rangeParser = numParser(\"from_\") + pp.Suppress(\"-\") + numParser(\"to\")\n\n        result = rangeParser.searchString(\"1-4 2-4 4-3 5 6 7 8 9 10\")\n        print(result.asList())\n        self.assertEqual(\n            [[1, 4], [2, 4], [4, 3]],\n            result.asList(),\n            \"failed to properly process conditions\",\n        )\n\n        rangeParser.addCondition(\n            lambda t: t.to > t.from_, message=\"from must be <= to\", fatal=False\n        )\n        result = rangeParser.searchString(\"1-4 2-4 4-3 5 6 7 8 9 10\")\n        print(result.asList())\n        self.assertEqual(\n            [[1, 4], [2, 4]], result.asList(), \"failed to properly process conditions\"\n        )\n\n        rangeParser = numParser(\"from_\") + pp.Suppress(\"-\") + numParser(\"to\")\n        rangeParser.addCondition(\n            lambda t: t.to > t.from_, message=\"from must be <= to\", fatal=True\n        )\n        try:\n            result = rangeParser.searchString(\"1-4 2-4 4-3 5 6 7 8 9 10\")\n            self.fail(\"failed to interrupt parsing on fatal condition failure\")\n        except ParseFatalException:\n            print(\"detected fatal condition\")\n\n    def testPatientOr(self):\n        # Two expressions and a input string which could - syntactically - be matched against\n        # both expressions. The \"Literal\" expression is considered invalid though, so this PE\n        # should always detect the \"Word\" expression.\n        def validate(token):\n            if token[0] == \"def\":\n                raise pp.ParseException(\"signalling invalid token\")\n            return token\n\n        a = pp.Word(\"de\").setName(\"Word\")  # .setDebug()\n        b = pp.Literal(\"def\").setName(\"Literal\").setParseAction(validate)  # .setDebug()\n        c = pp.Literal(\"d\").setName(\"d\")  # .setDebug()\n\n        # The \"Literal\" expressions's ParseAction is not executed directly after syntactically\n        # detecting the \"Literal\" Expression but only after the Or-decision has been made\n        # (which is too late)...\n        try:\n            result = (a ^ b ^ c).parseString(\"def\", parseAll=False)\n            print(result)\n            self.assertEqual(\n                [\"de\"],\n                result.asList(),\n                f\"failed to select longest match, chose {result}\",\n            )\n        except ParseException:\n            failed = True\n        else:\n            failed = False\n\n        if failed:\n            self.fail(\n                \"invalid logic in Or, fails on longest match with exception in parse action\"\n            )\n\n        # from issue #93\n        word = pp.Word(pp.alphas).setName(\"word\")\n        word_1 = (\n            pp.Word(pp.alphas).setName(\"word_1\").addCondition(lambda t: len(t[0]) == 1)\n        )\n\n        a = word + (word_1 + word ^ word)\n        b = word * 3\n        c = a ^ b\n        c.streamline()\n        print(c)\n        test_string = \"foo bar temp\"\n        result = c.parseString(test_string, parseAll=True)\n        print(test_string, \"->\", result.asList())\n\n        self.assertEqual(\n            test_string.split(), result.asList(), \"failed to match longest choice\"\n        )\n\n    def testEachWithOptionalWithResultsName(self):\n        result = (pp.Optional(\"foo\")(\"one\") & pp.Optional(\"bar\")(\"two\")).parseString(\n            \"bar foo\", parseAll=True\n        )\n        print(result.dump())\n        self.assertEqual(sorted([\"one\", \"two\"]), sorted(result.keys()))\n\n    def testUnicodeExpression(self):\n        z = \"a\" | pp.Literal(\"\\u1111\")\n        z.streamline()\n        try:\n            z.parseString(\"b\", parseAll=True)\n        except ParseException as pe:\n            self.assertEqual(\n                r\"\"\"Expected {'a' | '\u1111'}\"\"\",\n                pe.msg,\n                f\"Invalid error message raised, got {pe.msg!r}\",\n            )\n\n    def testSetName(self):\n        a = pp.oneOf(\"a b c\")\n        b = pp.oneOf(\"d e f\")\n        # fmt: off\n        arith_expr = pp.infixNotation(\n            pp.Word(pp.nums),\n            [\n                (pp.oneOf(\"* /\"), 2, pp.opAssoc.LEFT),\n                (pp.oneOf(\"+ -\"), 2, pp.opAssoc.LEFT),\n            ],\n        )\n        arith_expr2 = pp.infixNotation(\n            pp.Word(pp.nums),\n            [\n                ((\"?\", \":\"), 3, pp.opAssoc.LEFT),\n            ]\n        )\n        # fmt: on\n        recursive = pp.Forward()\n        recursive <<= a + (b + recursive)[...]\n\n        tests = [\n            a,\n            b,\n            (a | b),\n            arith_expr,\n            arith_expr.expr,\n            arith_expr2,\n            arith_expr2.expr,\n            recursive,\n            pp.delimitedList(pp.Word(pp.nums).setName(\"int\")),\n            pp.countedArray(pp.Word(pp.nums).setName(\"int\")),\n            pp.nestedExpr(),\n            pp.makeHTMLTags(\"Z\"),\n            (pp.anyOpenTag, pp.anyCloseTag),\n            pp.commonHTMLEntity,\n            pp.commonHTMLEntity.setParseAction(pp.replaceHTMLEntity).transformString(\n                \"lsdjkf &lt;lsdjkf&gt;&amp;&apos;&quot;&xyzzy;\"\n            ),\n        ]\n\n        expected = map(\n            str.strip,\n            \"\"\"\\\n            a | b | c\n            d | e | f\n            {a | b | c | d | e | f}\n            Forward: + | - term\n            + | - term\n            Forward: ?: term\n            ?: term\n            Forward: {a | b | c [{d | e | f : ...}]...}\n            int [, int]...\n            (len) int...\n            nested () expression\n            (<Z>, </Z>)\n            (<any tag>, </any tag>)\n            common HTML entity\n            lsdjkf <lsdjkf>&'\"&xyzzy;\"\"\".splitlines(),\n        )\n\n        for t, e in zip(tests, expected):\n            tname = str(t)\n            print(tname)\n            self.assertEqual(\n                e,\n                tname,\n                f\"expression name mismatch, expected {e} got {tname}\",\n            )\n\n    def testTrimArityExceptionMasking(self):\n        invalid_message = \"<lambda>() missing 1 required positional argument: 't'\"\n        try:\n            pp.Word(\"a\").setParseAction(lambda t: t[0] + 1).parseString(\n                \"aaa\", parseAll=True\n            )\n        except Exception as e:\n            exc_msg = str(e)\n            self.assertNotEqual(\n                exc_msg,\n                invalid_message,\n                \"failed to catch TypeError thrown in _trim_arity\",\n            )\n\n    def testTrimArityExceptionMaskingTest2(self):\n        # construct deep call tree\n        def A():\n            import traceback\n\n            traceback.print_stack(limit=2)\n\n            invalid_message = \"<lambda>() missing 1 required positional argument: 't'\"\n            try:\n                pp.Word(\"a\").setParseAction(lambda t: t[0] + 1).parseString(\n                    \"aaa\", parseAll=True\n                )\n            except Exception as e:\n                exc_msg = str(e)\n                self.assertNotEqual(\n                    exc_msg,\n                    invalid_message,\n                    \"failed to catch TypeError thrown in _trim_arity\",\n                )\n\n        def B():\n            A()\n\n        def C():\n            B()\n\n        def D():\n            C()\n\n        def E():\n            D()\n\n        def F():\n            E()\n\n        def G():\n            F()\n\n        def H():\n            G()\n\n        def J():\n            H()\n\n        def K():\n            J()\n\n        K()\n\n    def testClearParseActions(self):\n        realnum = ppc.real()\n        self.assertEqual(\n            3.14159,\n            realnum.parseString(\"3.14159\", parseAll=True)[0],\n            \"failed basic real number parsing\",\n        )\n\n        # clear parse action that converts to float\n        realnum.setParseAction(None)\n        self.assertEqual(\n            \"3.14159\",\n            realnum.parseString(\"3.14159\", parseAll=True)[0],\n            \"failed clearing parse action\",\n        )\n\n        # add a new parse action that tests if a '.' is prsent\n        realnum.addParseAction(lambda t: \".\" in t[0])\n        self.assertEqual(\n            True,\n            realnum.parseString(\"3.14159\", parseAll=True)[0],\n            \"failed setting new parse action after clearing parse action\",\n        )\n\n    def testOneOrMoreStop(self):\n        test = \"BEGIN aaa bbb ccc END\"\n        BEGIN, END = map(pp.Keyword, \"BEGIN,END\".split(\",\"))\n        body_word = pp.Word(pp.alphas).setName(\"word\")\n        for ender in (END, \"END\", pp.CaselessKeyword(\"END\")):\n            expr = BEGIN + pp.OneOrMore(body_word, stopOn=ender) + END\n            self.assertEqual(\n                expr, test, f\"Did not successfully stop on ending expression {ender!r}\"\n            )\n\n            expr = BEGIN + body_word[1, ...].stopOn(ender) + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n            expr = BEGIN + body_word[1, ...:ender] + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n            expr = BEGIN + body_word[(1, ...):ender] + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n        number = pp.Word(pp.nums + \",.()\").setName(\"number with optional commas\")\n        parser = pp.OneOrMore(pp.Word(pp.alphanums + \"-/.\"), stopOn=number)(\n            \"id\"\n        ).setParseAction(\" \".join) + number(\"data\")\n        self.assertParseAndCheckList(\n            parser,\n            \"        XXX Y/123          1,234.567890\",\n            [\"XXX Y/123\", \"1,234.567890\"],\n            f\"Did not successfully stop on ending expression {number!r}\",\n            verbose=True,\n        )\n\n    def testZeroOrMoreStop(self):\n        test = \"BEGIN END\"\n        BEGIN, END = map(pp.Keyword, \"BEGIN,END\".split(\",\"))\n        body_word = pp.Word(pp.alphas).setName(\"word\")\n        for ender in (END, \"END\", pp.CaselessKeyword(\"END\")):\n            expr = BEGIN + pp.ZeroOrMore(body_word, stopOn=ender) + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n            expr = BEGIN + body_word[...].stopOn(ender) + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n            expr = BEGIN + body_word[...:ender] + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n            expr = BEGIN + body_word[:ender] + END\n            self.assertParseAndCheckList(\n                expr,\n                test,\n                test.split(),\n                f\"Did not successfully stop on ending expression {ender!r}\",\n            )\n\n    def testNestedAsDict(self):\n        equals = pp.Literal(\"=\").suppress()\n        lbracket = pp.Literal(\"[\").suppress()\n        rbracket = pp.Literal(\"]\").suppress()\n        lbrace = pp.Literal(\"{\").suppress()\n        rbrace = pp.Literal(\"}\").suppress()\n\n        value_dict = pp.Forward()\n        value_list = pp.Forward()\n        value_string = pp.Word(pp.alphanums + \"@. \")\n\n        value = value_list ^ value_dict ^ value_string\n        values = pp.Group(pp.delimitedList(value, \",\"))\n        # ~ values              = delimitedList(value, \",\").setParseAction(lambda toks: [toks.asList()])\n\n        value_list <<= lbracket + values + rbracket\n\n        identifier = pp.Word(pp.alphanums + \"_.\")\n\n        assignment = pp.Group(identifier + equals + pp.Optional(value))\n        assignments = pp.Dict(pp.delimitedList(assignment, \";\"))\n        value_dict <<= lbrace + assignments + rbrace\n\n        response = assignments\n\n        rsp = (\n            \"username=goat; errors={username=[already taken, too short]}; empty_field=\"\n        )\n        result_dict = response.parseString(rsp, parseAll=True).asDict()\n        print(result_dict)\n        self.assertEqual(\n            \"goat\",\n            result_dict[\"username\"],\n            \"failed to process string in ParseResults correctly\",\n        )\n        self.assertEqual(\n            [\"already taken\", \"too short\"],\n            result_dict[\"errors\"][\"username\"],\n            \"failed to process nested ParseResults correctly\",\n        )\n\n    def testTraceParseActionDecorator(self):\n        @pp.traceParseAction\n        def convert_to_int(t):\n            return int(t[0])\n\n        class Z:\n            def __call__(self, other):\n                return other[0] * 1000\n\n        integer = pp.Word(pp.nums).addParseAction(convert_to_int)\n        integer.addParseAction(pp.traceParseAction(lambda t: t[0] * 10))\n        integer.addParseAction(pp.traceParseAction(Z()))\n        integer.parseString(\"132\", parseAll=True)\n\n    def testTraceParseActionDecorator_with_exception(self):\n        @pp.trace_parse_action\n        def convert_to_int_raising_type_error(t):\n            return int(t[0]) + \".000\"\n\n        @pp.trace_parse_action\n        def convert_to_int_raising_index_error(t):\n            return int(t[1])\n\n        @pp.trace_parse_action\n        def convert_to_int_raising_value_error(t):\n            a, b = t[0]\n            return int(t[1])\n\n        @pp.trace_parse_action\n        def convert_to_int_raising_parse_exception(t):\n            pp.Word(pp.alphas).parse_string(\"123\")\n\n        for pa, expected_message in (\n            (convert_to_int_raising_type_error, \"TypeError:\"),\n            (convert_to_int_raising_index_error, \"IndexError:\"),\n            (convert_to_int_raising_value_error, \"ValueError:\"),\n            (convert_to_int_raising_parse_exception, \"ParseException:\"),\n        ):\n            print(f\"Using parse action {pa.__name__!r}\")\n            integer = pp.Word(pp.nums).set_parse_action(pa)\n            stderr_capture = StringIO()\n            try:\n                with contextlib.redirect_stderr(stderr_capture):\n                    integer.parse_string(\"132\", parse_all=True)\n            except Exception as exc:\n                print(f\"Exception raised: {type(exc).__name__}: {exc}\")\n            else:\n                print(\"No exception raised\")\n            stderr_text = stderr_capture.getvalue()\n            print(stderr_text)\n            self.assertTrue(\n                expected_message in stderr_text,\n                f\"Expected exception type {expected_message!r} not found in trace_parse_action output\"\n            )\n\n\n    def testRunTests(self):\n        integer = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        intrange = integer(\"start\") + \"-\" + integer(\"end\")\n        intrange.addCondition(\n            lambda t: t.end > t.start,\n            message=\"invalid range, start must be <= end\",\n            fatal=True,\n        )\n        intrange.addParseAction(lambda t: list(range(t.start, t.end + 1)))\n\n        indices = pp.delimitedList(intrange | integer)\n        indices.addParseAction(lambda t: sorted(set(t)))\n\n        tests = \"\"\"\\\n            # normal data\n            1-3,2-4,6,8-10,16\n\n            # lone integer\n            11\"\"\"\n        results = indices.runTests(tests, printResults=False)[1]\n\n        expectedResults = [[1, 2, 3, 4, 6, 8, 9, 10, 16], [11]]\n        for res, expected in zip(results, expectedResults):\n            print(res[1].asList())\n            print(expected)\n            self.assertEqual(expected, res[1].asList(), \"failed test: \" + str(expected))\n\n        tests = \"\"\"\\\n            # invalid range\n            1-2, 3-1, 4-6, 7, 12\n            \"\"\"\n        success = indices.runTests(tests, printResults=False, failureTests=True)[0]\n        self.assertTrue(success, \"failed to raise exception on improper range test\")\n\n    def testRunTestsPostParse(self):\n        integer = ppc.integer\n        fraction = integer(\"numerator\") + \"/\" + integer(\"denominator\")\n\n        accum = []\n\n        def eval_fraction(test, result):\n            accum.append((test, result.asList()))\n            return f\"eval: {result.numerator / result.denominator}\"\n\n        success = fraction.runTests(\n            \"\"\"\\\n            1/2\n            1/0\n        \"\"\",\n            postParse=eval_fraction,\n        )[0]\n        print(success)\n\n        self.assertTrue(success, \"failed to parse fractions in RunTestsPostParse\")\n\n        expected_accum = [(\"1/2\", [1, \"/\", 2]), (\"1/0\", [1, \"/\", 0])]\n        self.assertEqual(\n            expected_accum, accum, \"failed to call postParse method during runTests\"\n        )\n\n    def testConvertToDateErr(self):\n        \"\"\"raise a ParseException in convertToDate with incompatible date str\"\"\"\n\n        expr = pp.Word(pp.alphanums + \"-\")\n        expr.addParseAction(ppc.convertToDate())\n\n        with self.assertRaisesParseException():\n            expr.parseString(\"1997-07-error\", parseAll=True)\n\n    def testConvertToDatetimeErr(self):\n        \"\"\"raise a ParseException in convertToDatetime with incompatible datetime str\"\"\"\n\n        expr = pp.Word(pp.alphanums + \"-\")\n        expr.addParseAction(ppc.convertToDatetime())\n\n        with self.assertRaisesParseException():\n            expr.parseString(\"1997-07-error\", parseAll=True)\n\n    def testCommonExpressions(self):\n        import ast\n\n        with self.subTest(\"MAC address success run_tests\"):\n            success = ppc.mac_address.runTests(\n                \"\"\"\n                AA:BB:CC:DD:EE:FF\n                AA.BB.CC.DD.EE.FF\n                AA-BB-CC-DD-EE-FF\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid MAC address\")\n\n        with self.subTest(\"MAC address expected failure run_tests\"):\n            success = ppc.mac_address.runTests(\n                \"\"\"\n                # mixed delimiters\n                AA.BB:CC:DD:EE:FF\n                \"\"\",\n                failureTests=True,\n            )[0]\n            self.assertTrue(success, \"error in detecting invalid mac address\")\n\n        with self.subTest(\"IPv4 address success run_tests\"):\n            success = ppc.ipv4_address.runTests(\n                \"\"\"\n                0.0.0.0\n                1.1.1.1\n                127.0.0.1\n                1.10.100.199\n                255.255.255.255\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid IPv4 address\")\n\n        with self.subTest(\"IPv4 address expected failure run_tests\"):\n            success = ppc.ipv4_address.runTests(\n                \"\"\"\n                # out of range value\n                256.255.255.255\n                \"\"\",\n                failureTests=True,\n            )[0]\n            self.assertTrue(success, \"error in detecting invalid IPv4 address\")\n\n        with self.subTest(\"IPv6 address success run_tests\"):\n            success = ppc.ipv6_address.runTests(\n                \"\"\"\n                2001:0db8:85a3:0000:0000:8a2e:0370:7334\n                2134::1234:4567:2468:1236:2444:2106\n                0:0:0:0:0:0:A00:1\n                1080::8:800:200C:417A\n                ::A00:1\n    \n                # loopback address\n                ::1\n    \n                # the null address\n                ::\n    \n                # ipv4 compatibility form\n                ::ffff:192.168.0.1\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid IPv6 address\")\n\n        with self.subTest(\"IPv6 address expected failure run_tests\"):\n            success = ppc.ipv6_address.runTests(\n                \"\"\"\n                # too few values\n                1080:0:0:0:8:800:200C\n    \n                # too many ::'s, only 1 allowed\n                2134::1234:4567::2444:2106\n                \"\"\",\n                failureTests=True,\n            )[0]\n            self.assertTrue(success, \"error in detecting invalid IPv6 address\")\n\n        with self.subTest(\"ppc.number success run_tests\"):\n            success = ppc.number.runTests(\n                \"\"\"\n                100\n                -100\n                +100\n                3.14159\n                6.02e23\n                1e-12\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid numerics\")\n\n        with self.subTest(\"ppc.sci_real success run_tests\"):\n            success = ppc.sci_real.runTests(\n                \"\"\"\n                1e12\n                -1e12\n                3.14159\n                6.02e23\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid scientific notation reals\")\n\n        # any int or real number, returned as float\n        with self.subTest(\"ppc.fnumber success run_tests\"):\n            success = ppc.fnumber.runTests(\n                \"\"\"\n                100\n                -100\n                +100\n                3.14159\n                6.02e23\n                1e-12\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid numerics\")\n\n        with self.subTest(\"ppc.ieee_float success run_tests\"):\n            success = ppc.ieee_float.runTests(\n                \"\"\"\n                100\n                3.14159\n                6.02e23\n                1E-12\n                0\n                -0\n                NaN\n                -nan\n                inf\n                -Infinity\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"error in parsing valid floating-point literals\")\n\n        with self.subTest(\"ppc.iso8601_date success run_tests\"):\n            success, results = ppc.iso8601_date.runTests(\n                \"\"\"\n                1997\n                1997-07\n                1997-07-16\n                \"\"\"\n            )\n            self.assertTrue(success, \"error in parsing valid iso8601_date\")\n            expected = [\n                (\"1997\", None, None),\n                (\"1997\", \"07\", None),\n                (\"1997\", \"07\", \"16\"),\n            ]\n            for r, exp in zip(results, expected):\n                self.assertEqual(\n                    exp,\n                    (r[1].year, r[1].month, r[1].day),\n                    \"failed to parse date into fields\",\n                )\n\n        with self.subTest(\"ppc.iso8601_date conversion success run_tests\"):\n            success, results = (\n                ppc.iso8601_date()\n                .addParseAction(ppc.convertToDate())\n                .runTests(\n                    \"\"\"\n                1997-07-16\n                \"\"\"\n                )\n            )\n            self.assertTrue(\n                success, \"error in parsing valid iso8601_date with parse action\"\n            )\n            self.assertEqual(\n                datetime.date(1997, 7, 16),\n                results[0][1][0],\n                \"error in parsing valid iso8601_date with parse action - incorrect value\",\n            )\n\n        with self.subTest(\"ppc.iso8601_datetime success run_tests\"):\n            success, results = ppc.iso8601_datetime.runTests(\n                \"\"\"\n                1997-07-16T19:20+01:00\n                1997-07-16T19:20:30+01:00\n                1997-07-16T19:20:30.45Z\n                1997-07-16 19:20:30.45\n                \"\"\"\n            )\n            self.assertTrue(success, \"error in parsing valid iso8601_datetime\")\n\n        with self.subTest(\"ppc.iso8601_datetime conversion success run_tests\"):\n            success, results = (\n                ppc.iso8601_datetime()\n                .addParseAction(ppc.convertToDatetime())\n                .runTests(\n                    \"\"\"\n                1997-07-16T19:20:30.45\n                \"\"\"\n                )\n            )\n\n            self.assertTrue(success, \"error in parsing valid iso8601_datetime\")\n            self.assertEqual(\n                datetime.datetime(1997, 7, 16, 19, 20, 30, 450000),\n                results[0][1][0],\n                \"error in parsing valid iso8601_datetime - incorrect value\",\n            )\n\n        with self.subTest(\"ppc.uuid success run_tests\"):\n            success = ppc.uuid.runTests(\n                \"\"\"\n                123e4567-e89b-12d3-a456-426655440000\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"failed to parse valid uuid\")\n\n        with self.subTest(\"ppc.fraction success run_tests\"):\n            success = ppc.fraction.runTests(\n                \"\"\"\n                1/2\n                -15/16\n                -3/-4\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"failed to parse valid fraction\")\n\n        with self.subTest(\"ppc.mixed_integer success run_tests\"):\n            success = ppc.mixed_integer.runTests(\n                \"\"\"\n                1/2\n                -15/16\n                -3/-4\n                1 1/2\n                2 -15/16\n                0 -3/-4\n                12\n                \"\"\"\n            )[0]\n            self.assertTrue(success, \"failed to parse valid mixed integer\")\n\n        with self.subTest(\"ppc.number success run_tests\"):\n            success, results = ppc.number.runTests(\n                \"\"\"\n                100\n                -3\n                1.732\n                -3.14159\n                6.02e23\"\"\"\n            )\n            self.assertTrue(success, \"failed to parse numerics\")\n\n            for test, result in results:\n                expected = ast.literal_eval(test)\n                self.assertEqual(\n                    expected,\n                    result[0],\n                    f\"numeric parse failed (wrong value) ({result[0]} should be {expected})\",\n                )\n                self.assertEqual(\n                    type(expected),\n                    type(result[0]),\n                    f\"numeric parse failed (wrong type) ({type(result[0])} should be {type(expected)})\",\n                )\n\n    def testCommonUrl(self):\n        url_good_tests = \"\"\"\\\n            http://foo.com/blah_blah\n            http://foo.com/blah_blah/\n            http://foo.com/blah_blah_(wikipedia)\n            http://foo.com/blah_blah_(wikipedia)_(again)\n            http://www.example.com/wpstyle/?p=364\n            https://www.example.com/foo/?bar=baz&inga=42&quux\n            http://\u272adf.ws/123\n            http://userid:password@example.com:8080\n            http://userid:password@example.com:8080/\n            http://userid@example.com\n            http://userid@example.com/\n            http://userid@example.com:8080\n            http://userid@example.com:8080/\n            http://userid:password@example.com\n            http://userid:password@example.com/\n            http://142.42.1.1/\n            http://142.42.1.1:8080/\n            http://\u27a1.ws/\u4a39\n            http://\u2318.ws\n            http://\u2318.ws/\n            http://foo.com/blah_(wikipedia)#cite-1\n            http://foo.com/blah_(wikipedia)_blah#cite-1\n            http://foo.com/unicode_(\u272a)_in_parens\n            http://foo.com/(something)?after=parens\n            http://\u263a.damowmow.com/\n            http://code.google.com/events/#&product=browser\n            http://j.mp\n            ftp://foo.bar/baz\n            http://foo.bar/?q=Test%20URL-encoded%20stuff\n            http://\u0645\u062b\u0627\u0644.\u0625\u062e\u062a\u0628\u0627\u0631\n            \"\"\"\n        success, report = ppc.url.runTests(url_good_tests)\n        self.assertTrue(success)\n\n        url_bad_tests = \"\"\"\\\n            http://\n            http://.\n            http://..\n            http://../\n            http://?\n            http://??\n            http://??/\n            http://#\n            http://##\n            http://##/\n            # skip: http://foo.bar?q=Spaces should be encoded\n            //\n            //a\n            ///a\n            ///\n            http:///a\n            foo.com\n            rdar://1234\n            h://test\n            http:// shouldfail.com\n\n            :// should fail\n            http://foo.bar/foo(bar)baz quux\n            ftps://foo.bar/\n            http://-error-.invalid/\n            # skip: http://a.b--c.de/\n            http://-a.b.co\n            http://a.b-.co\n            http://0.0.0.0\n            http://10.1.1.0\n            http://10.1.1.255\n            http://224.1.1.1\n            http://1.1.1.1.1\n            http://123.123.123\n            http://3628126748\n            http://.www.foo.bar/\n            # skip: http://www.foo.bar./\n            http://.www.foo.bar./\n            http://10.1.1.1\n            \"\"\"\n        success, report = ppc.url.runTests(url_bad_tests, failure_tests=True)\n        self.assertTrue(success)\n\n    def testCommonUrlParts(self):\n        from urllib.parse import urlparse\n\n        sample_url = \"https://bob:secret@www.example.com:8080/path/to/resource?filter=int#book-mark\"\n\n        parts = urlparse(sample_url)\n        expected = {\n            \"scheme\": parts.scheme,\n            \"auth\": f\"{parts.username}:{parts.password}\",\n            \"host\": parts.hostname,\n            \"port\": str(parts.port),\n            \"path\": parts.path,\n            \"query\": parts.query,\n            \"fragment\": parts.fragment,\n            \"url\": sample_url,\n        }\n\n        self.assertParseAndCheckDict(ppc.url, sample_url, expected, verbose=True)\n\n    def testCommonUrlExprs(self):\n        def extract_parts(s, split=\" \"):\n            return [[_.strip(split)] for _ in s.strip(split).split(split)]\n\n        test_string = \"http://example.com https://blah.org \"\n        self.assertParseAndCheckList(\n            pp.Group(ppc.url)[...], test_string, extract_parts(test_string)\n        )\n\n        test_string = test_string.replace(\" \", \" , \")\n        self.assertParseAndCheckList(\n            pp.delimited_list(pp.Group(ppc.url), allow_trailing_delim=True),\n            test_string,\n            extract_parts(test_string, \" , \"),\n        )\n\n    def testNumericExpressions(self):\n        # disable parse actions that do type conversion so we don't accidentally trigger\n        # conversion exceptions when what we want to check is the parsing expression\n        real = ppc.real().setParseAction(None)\n        sci_real = ppc.sci_real().setParseAction(None)\n        signed_integer = ppc.signed_integer().setParseAction(None)\n\n        from itertools import product\n\n        def make_tests():\n            leading_sign = [\"+\", \"-\", \"\"]\n            leading_digit = [\"0\", \"\"]\n            dot = [\".\", \"\"]\n            decimal_digit = [\"1\", \"\"]\n            e = [\"e\", \"E\", \"\"]\n            e_sign = [\"+\", \"-\", \"\"]\n            e_int = [\"22\", \"\"]\n            stray = [\"9\", \".\", \"\"]\n\n            seen = set()\n            seen.add(\"\")\n            for parts in product(\n                leading_sign,\n                stray,\n                leading_digit,\n                dot,\n                decimal_digit,\n                stray,\n                e,\n                e_sign,\n                e_int,\n                stray,\n            ):\n                parts_str = \"\".join(parts).strip()\n                if parts_str in seen:\n                    continue\n                seen.add(parts_str)\n                yield parts_str\n\n            print(len(seen) - 1, \"tests produced\")\n\n        # collect tests into valid/invalid sets, depending on whether they evaluate to valid Python floats or ints\n        valid_ints = set()\n        valid_reals = set()\n        valid_sci_reals = set()\n        invalid_ints = set()\n        invalid_reals = set()\n        invalid_sci_reals = set()\n\n        # check which strings parse as valid floats or ints, and store in related valid or invalid test sets\n        for test_str in make_tests():\n            if \".\" in test_str or \"e\" in test_str.lower():\n                try:\n                    float(test_str)\n                except ValueError:\n                    invalid_sci_reals.add(test_str)\n                    if \"e\" not in test_str.lower():\n                        invalid_reals.add(test_str)\n                else:\n                    valid_sci_reals.add(test_str)\n                    if \"e\" not in test_str.lower():\n                        valid_reals.add(test_str)\n\n            try:\n                int(test_str)\n            except ValueError:\n                invalid_ints.add(test_str)\n            else:\n                valid_ints.add(test_str)\n\n        # now try all the test sets against their respective expressions\n        all_pass = True\n        suppress_results = {\"printResults\": False}\n        for expr, tests, is_fail, fn in zip(\n            [real, sci_real, signed_integer] * 2,\n            [\n                valid_reals,\n                valid_sci_reals,\n                valid_ints,\n                invalid_reals,\n                invalid_sci_reals,\n                invalid_ints,\n            ],\n            [False, False, False, True, True, True],\n            [float, float, int] * 2,\n        ):\n            #\n            # success, test_results = expr.runTests(sorted(tests, key=len), failureTests=is_fail, **suppress_results)\n            # filter_result_fn = (lambda r: isinstance(r, Exception),\n            #                     lambda r: not isinstance(r, Exception))[is_fail]\n            # print(expr, ('FAIL', 'PASS')[success], \"{}valid tests ({})\".format(len(tests),\n            #                                                                       'in' if is_fail else ''))\n            # if not success:\n            #     all_pass = False\n            #     for test_string, result in test_results:\n            #         if filter_result_fn(result):\n            #             try:\n            #                 test_value = fn(test_string)\n            #             except ValueError as ve:\n            #                 test_value = str(ve)\n            #             print(\"{!r}: {} {} {}\".format(test_string, result,\n            #                                                expr.matches(test_string, parseAll=True), test_value))\n\n            success = True\n            for t in tests:\n                if expr.matches(t, parseAll=True):\n                    if is_fail:\n                        print(t, \"should fail but did not\")\n                        success = False\n                else:\n                    if not is_fail:\n                        print(t, \"should not fail but did\")\n                        success = False\n            print(\n                expr,\n                (\"FAIL\", \"PASS\")[success],\n                f\"{'in' if is_fail else ''}valid tests ({len(tests)})\",\n            )\n            all_pass = all_pass and success\n\n        self.assertTrue(all_pass, \"failed one or more numeric tests\")\n\n    def testTokenMap(self):\n        parser = pp.OneOrMore(pp.Word(pp.hexnums)).setParseAction(pp.tokenMap(int, 16))\n        success, report = parser.runTests(\n            \"\"\"\n            00 11 22 aa FF 0a 0d 1a\n            \"\"\"\n        )\n\n        self.assertRunTestResults(\n            (success, report),\n            [([0, 17, 34, 170, 255, 10, 13, 26], \"tokenMap parse action failed\")],\n            msg=\"failed to parse hex integers\",\n        )\n\n    def testParseFile(self):\n        s = \"\"\"\n        123 456 789\n        \"\"\"\n        from pathlib import Path\n\n        integer = ppc.integer\n        test_parser = integer[1, ...]\n\n        input_file_as_stringio = StringIO(s)\n        input_file_as_str = \"tests/parsefiletest_input_file.txt\"\n        input_file_as_path = Path(input_file_as_str)\n\n        expected_list = [int(i) for i in s.split()]\n\n        for input_file in (\n            input_file_as_stringio,\n            input_file_as_str,\n            input_file_as_path,\n        ):\n            with self.subTest(input_file=input_file):\n                print(f\"parse_file() called with {type(input_file).__name__}\")\n                results = test_parser.parseFile(input_file)\n                print(results)\n                self.assertEqual(expected_list, results.as_list())\n\n    def testHTMLStripper(self):\n        sample = \"\"\"\n        <html>\n        Here is some sample <i>HTML</i> text.\n        </html>\n        \"\"\"\n        read_everything = pp.originalTextFor(pp.OneOrMore(pp.Word(pp.printables)))\n        read_everything.addParseAction(ppc.stripHTMLTags)\n\n        result = read_everything.parseString(sample, parseAll=True)\n        self.assertEqual(\"Here is some sample HTML text.\", result[0].strip())\n\n    def testExprSplitter(self):\n        expr = pp.Literal(\";\") + pp.Empty()\n        expr.ignore(pp.quotedString)\n        expr.ignore(pp.pythonStyleComment)\n\n        sample = \"\"\"\n        def main():\n            this_semi_does_nothing();\n            neither_does_this_but_there_are_spaces_afterward();\n            a = \"a;b\"; return a # this is a comment; it has a semicolon!\n\n        def b():\n            if False:\n                z=1000;b(\"; in quotes\");  c=200;return z\n            return ';'\n\n        class Foo(object):\n            def bar(self):\n                '''a docstring; with a semicolon'''\n                a = 10; b = 11; c = 12\n\n                # this comment; has several; semicolons\n                if self.spam:\n                    x = 12; return x # so; does; this; one\n                    x = 15;;; y += x; return y\n\n            def baz(self):\n                return self.bar\n        \"\"\"\n        expected = [\n            [\"            this_semi_does_nothing()\", \"\"],\n            [\"            neither_does_this_but_there_are_spaces_afterward()\", \"\"],\n            [\n                '            a = \"a;b\"',\n                \"return a # this is a comment; it has a semicolon!\",\n            ],\n            [\"                z=1000\", 'b(\"; in quotes\")', \"c=200\", \"return z\"],\n            [\"            return ';'\"],\n            [\"                '''a docstring; with a semicolon'''\"],\n            [\"                a = 10\", \"b = 11\", \"c = 12\"],\n            [\"                # this comment; has several; semicolons\"],\n            [\"                    x = 12\", \"return x # so; does; this; one\"],\n            [\"                    x = 15\", \"\", \"\", \"y += x\", \"return y\"],\n        ]\n\n        exp_iter = iter(expected)\n        for line in filter(lambda ll: \";\" in ll, sample.splitlines()):\n            print(str(list(expr.split(line))) + \",\")\n            self.assertEqual(\n                next(exp_iter), list(expr.split(line)), \"invalid split on expression\"\n            )\n\n        print()\n\n        expected = [\n            [\"            this_semi_does_nothing()\", \";\", \"\"],\n            [\"            neither_does_this_but_there_are_spaces_afterward()\", \";\", \"\"],\n            [\n                '            a = \"a;b\"',\n                \";\",\n                \"return a # this is a comment; it has a semicolon!\",\n            ],\n            [\n                \"                z=1000\",\n                \";\",\n                'b(\"; in quotes\")',\n                \";\",\n                \"c=200\",\n                \";\",\n                \"return z\",\n            ],\n            [\"            return ';'\"],\n            [\"                '''a docstring; with a semicolon'''\"],\n            [\"                a = 10\", \";\", \"b = 11\", \";\", \"c = 12\"],\n            [\"                # this comment; has several; semicolons\"],\n            [\"                    x = 12\", \";\", \"return x # so; does; this; one\"],\n            [\n                \"                    x = 15\",\n                \";\",\n                \"\",\n                \";\",\n                \"\",\n                \";\",\n                \"y += x\",\n                \";\",\n                \"return y\",\n            ],\n        ]\n        exp_iter = iter(expected)\n        for line in filter(lambda ll: \";\" in ll, sample.splitlines()):\n            print(str(list(expr.split(line, includeSeparators=True))) + \",\")\n            self.assertEqual(\n                next(exp_iter),\n                list(expr.split(line, includeSeparators=True)),\n                \"invalid split on expression\",\n            )\n\n        print()\n\n        expected = [\n            [\"            this_semi_does_nothing()\", \"\"],\n            [\"            neither_does_this_but_there_are_spaces_afterward()\", \"\"],\n            [\n                '            a = \"a;b\"',\n                \"return a # this is a comment; it has a semicolon!\",\n            ],\n            [\"                z=1000\", 'b(\"; in quotes\");  c=200;return z'],\n            [\"                a = 10\", \"b = 11; c = 12\"],\n            [\"                    x = 12\", \"return x # so; does; this; one\"],\n            [\"                    x = 15\", \";; y += x; return y\"],\n        ]\n        exp_iter = iter(expected)\n        for line in sample.splitlines():\n            pieces = list(expr.split(line, maxsplit=1))\n            print(str(pieces) + \",\")\n            if len(pieces) == 2:\n                exp = next(exp_iter)\n                self.assertEqual(\n                    exp, pieces, \"invalid split on expression with maxSplits=1\"\n                )\n            elif len(pieces) == 1:\n                self.assertEqual(\n                    0,\n                    len(expr.searchString(line)),\n                    \"invalid split with maxSplits=1 when expr not present\",\n                )\n            else:\n                print(\"\\n>>> \" + line)\n                self.fail(\"invalid split on expression with maxSplits=1, corner case\")\n\n    def testParseFatalException(self):\n        with self.assertRaisesParseException(\n            exc_type=ParseFatalException, msg=\"failed to raise ErrorStop exception\"\n        ):\n            expr = \"ZZZ\" - pp.Word(pp.nums)\n            expr.parseString(\"ZZZ bad\", parseAll=True)\n\n    def testParseFatalException2(self):\n        # Fatal exception raised in MatchFirst should not be superseded later non-fatal exceptions\n        # addresses Issue #251\n\n        def raise_exception(tokens):\n            raise pp.ParseSyntaxException(\"should raise here\")\n\n        test = pp.MatchFirst(\n            (\n                pp.pyparsing_common.integer + pp.pyparsing_common.identifier\n            ).setParseAction(raise_exception)\n            | pp.pyparsing_common.number\n        )\n\n        with self.assertRaisesParseException(pp.ParseFatalException):\n            test.parseString(\"1s\", parseAll=True)\n\n    def testParseFatalException3(self):\n        # Fatal exception raised in MatchFirst should not be superseded later non-fatal exceptions\n        # addresses Issue #251\n\n        test = pp.MatchFirst(\n            (pp.pyparsing_common.integer - pp.pyparsing_common.identifier)\n            | pp.pyparsing_common.integer\n        )\n\n        with self.assertRaisesParseException(pp.ParseFatalException):\n            test.parseString(\"1\", parseAll=True)\n\n    def testInlineLiteralsUsing(self):\n        wd = pp.Word(pp.alphas)\n\n        pp.ParserElement.inlineLiteralsUsing(pp.Suppress)\n        result = (wd + \",\" + wd + pp.oneOf(\"! . ?\")).parseString(\n            \"Hello, World!\", parseAll=True\n        )\n        self.assertEqual(3, len(result), \"inlineLiteralsUsing(Suppress) failed!\")\n\n        pp.ParserElement.inlineLiteralsUsing(pp.Literal)\n        result = (wd + \",\" + wd + pp.oneOf(\"! . ?\")).parseString(\n            \"Hello, World!\", parseAll=True\n        )\n        self.assertEqual(4, len(result), \"inlineLiteralsUsing(Literal) failed!\")\n\n        pp.ParserElement.inlineLiteralsUsing(pp.CaselessKeyword)\n        self.assertParseAndCheckList(\n            \"SELECT\" + wd + \"FROM\" + wd,\n            \"select color from colors\",\n            expected_list=[\"SELECT\", \"color\", \"FROM\", \"colors\"],\n            msg=\"inlineLiteralsUsing(CaselessKeyword) failed!\",\n            verbose=True,\n        )\n\n        pp.ParserElement.inlineLiteralsUsing(pp.CaselessLiteral)\n        self.assertParseAndCheckList(\n            \"SELECT\" + wd + \"FROM\" + wd,\n            \"select color from colors\",\n            expected_list=[\"SELECT\", \"color\", \"FROM\", \"colors\"],\n            msg=\"inlineLiteralsUsing(CaselessLiteral) failed!\",\n            verbose=True,\n        )\n\n        integer = pp.Word(pp.nums)\n        pp.ParserElement.inlineLiteralsUsing(pp.Literal)\n        date_str = integer(\"year\") + \"/\" + integer(\"month\") + \"/\" + integer(\"day\")\n        self.assertParseAndCheckList(\n            date_str,\n            \"1999/12/31\",\n            expected_list=[\"1999\", \"/\", \"12\", \"/\", \"31\"],\n            msg=\"inlineLiteralsUsing(example 1) failed!\",\n            verbose=True,\n        )\n\n        # change to Suppress\n        pp.ParserElement.inlineLiteralsUsing(pp.Suppress)\n        date_str = integer(\"year\") + \"/\" + integer(\"month\") + \"/\" + integer(\"day\")\n\n        self.assertParseAndCheckList(\n            date_str,\n            \"1999/12/31\",\n            expected_list=[\"1999\", \"12\", \"31\"],\n            msg=\"inlineLiteralsUsing(example 2) failed!\",\n            verbose=True,\n        )\n\n    def testCloseMatch(self):\n        searchseq = pp.CloseMatch(\"ATCATCGAATGGA\", 2)\n\n        _, results = searchseq.runTests(\n            \"\"\"\n            ATCATCGAATGGA\n            XTCATCGAATGGX\n            ATCATCGAAXGGA\n            ATCAXXGAATGGA\n            ATCAXXGAATGXA\n            ATCAXXGAATGG\n            \"\"\"\n        )\n        expected = ([], [0, 12], [9], [4, 5], None, None)\n\n        for r, exp in zip(results, expected):\n            if exp is not None:\n                self.assertEqual(\n                    exp,\n                    r[1].mismatches,\n                    f\"fail CloseMatch between {searchseq.match_string!r} and {r[0]!r}\",\n                )\n            print(\n                r[0],\n                (\n                    f\"exc: {r[1]}\"\n                    if exp is None and isinstance(r[1], Exception)\n                    else (\"no match\", \"match\")[r[1].mismatches == exp]\n                ),\n            )\n\n    def testCloseMatchCaseless(self):\n        searchseq = pp.CloseMatch(\"ATCATCGAATGGA\", 2, caseless=True)\n\n        _, results = searchseq.runTests(\n            \"\"\"\n            atcatcgaatgga\n            xtcatcgaatggx\n            atcatcgaaxgga\n            atcaxxgaatgga\n            atcaxxgaatgxa\n            atcaxxgaatgg\n            \"\"\"\n        )\n        expected = ([], [0, 12], [9], [4, 5], None, None)\n\n        for r, exp in zip(results, expected):\n            if exp is not None:\n                self.assertEqual(\n                    exp,\n                    r[1].mismatches,\n                    f\"fail CaselessCloseMatch between {searchseq.match_string!r} and {r[0]!r}\",\n                )\n            print(\n                r[0],\n                (\n                    f\"exc: {r[1]}\"\n                    if exp is None and isinstance(r[1], Exception)\n                    else (\"no match\", \"match\")[r[1].mismatches == exp]\n                ),\n            )\n\n    def testDefaultKeywordChars(self):\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            pp.Keyword(\"start\").parseString(\"start1000\", parseAll=True)\n\n        try:\n            pp.Keyword(\"start\", identChars=pp.alphas).parseString(\n                \"start1000\", parseAll=False\n            )\n        except pp.ParseException:\n            self.fail(\"failed to match keyword using updated keyword chars\")\n\n        with ppt.reset_pyparsing_context():\n            pp.Keyword.setDefaultKeywordChars(pp.alphas)\n            try:\n                pp.Keyword(\"start\").parseString(\"start1000\", parseAll=False)\n            except pp.ParseException:\n                self.fail(\"failed to match keyword using updated keyword chars\")\n\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            pp.CaselessKeyword(\"START\").parseString(\"start1000\", parseAll=False)\n\n        try:\n            pp.CaselessKeyword(\"START\", identChars=pp.alphas).parseString(\n                \"start1000\", parseAll=False\n            )\n        except pp.ParseException:\n            self.fail(\"failed to match keyword using updated keyword chars\")\n\n        with ppt.reset_pyparsing_context():\n            pp.Keyword.setDefaultKeywordChars(pp.alphas)\n            try:\n                pp.CaselessKeyword(\"START\").parseString(\"start1000\", parseAll=False)\n            except pp.ParseException:\n                self.assertTrue(\n                    False, \"failed to match keyword using updated keyword chars\"\n                )\n\n    def testKeywordCopyIdentChars(self):\n        a_keyword = pp.Keyword(\"start\", identChars=\"_\")\n        b_keyword = a_keyword.copy()\n        self.assertEqual(a_keyword.identChars, b_keyword.identChars)\n\n    def testCopyLiteralAttrs(self):\n        lit = pp.Literal(\"foo\").leave_whitespace()\n        lit2 = lit.copy()\n        self.assertFalse(lit2.skipWhitespace)\n        lit3 = lit2.ignore_whitespace().copy()\n        self.assertTrue(lit3.skipWhitespace)\n\n    def testLiteralVsKeyword(self):\n        integer = ppc.integer\n        literal_expr = integer + pp.Literal(\"start\") + integer\n        keyword_expr = integer + pp.Keyword(\"start\") + integer\n        caseless_keyword_expr = integer + pp.CaselessKeyword(\"START\") + integer\n        word_keyword_expr = (\n            integer + pp.Word(pp.alphas, asKeyword=True).setName(\"word\") + integer\n        )\n\n        print()\n        test_string = \"1 start 2\"\n        print(test_string)\n        print(literal_expr, literal_expr.parseString(test_string, parseAll=True))\n        print(keyword_expr, keyword_expr.parseString(test_string, parseAll=True))\n        print(\n            caseless_keyword_expr,\n            caseless_keyword_expr.parseString(test_string, parseAll=True),\n        )\n        print(\n            word_keyword_expr, word_keyword_expr.parseString(test_string, parseAll=True)\n        )\n        print()\n\n        test_string = \"3 start4\"\n        print(test_string)\n        print(literal_expr, literal_expr.parseString(test_string, parseAll=True))\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(keyword_expr.parseString(test_string, parseAll=True))\n\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(caseless_keyword_expr.parseString(test_string, parseAll=True))\n\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(word_keyword_expr.parseString(test_string, parseAll=True))\n        print()\n\n        test_string = \"5start 6\"\n        print(test_string)\n        print(literal_expr.parseString(test_string, parseAll=True))\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(keyword_expr.parseString(test_string, parseAll=True))\n\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(caseless_keyword_expr.parseString(test_string, parseAll=True))\n\n        with self.assertRaisesParseException(\n            msg=\"failed to fail matching keyword using updated keyword chars\"\n        ):\n            print(word_keyword_expr.parseString(test_string, parseAll=True))\n\n    def testCol(self):\n        test = \"*\\n* \\n*   ALF\\n*\\n\"\n        initials = [c for i, c in enumerate(test) if pp.col(i, test) == 1]\n        print(initials)\n        self.assertTrue(\n            len(initials) == 4 and all(c == \"*\" for c in initials), \"fail col test\"\n        )\n\n    def testLiteralException(self):\n        for cls in (\n            pp.Literal,\n            pp.CaselessLiteral,\n            pp.Keyword,\n            pp.CaselessKeyword,\n            pp.Word,\n            pp.Regex,\n        ):\n            expr = cls(\"xyz\")  # .setName('{}_expr'.format(cls.__name__.lower()))\n\n            try:\n                expr.parseString(\" \", parseAll=True)\n            except Exception as e:\n                print(cls.__name__, str(e))\n                self.assertTrue(\n                    isinstance(e, pp.ParseBaseException),\n                    f\"class {cls.__name__} raised wrong exception type {type(e).__name__}\",\n                )\n\n    def testParseActionException(self):\n        import traceback\n\n        number = pp.Word(pp.nums)\n\n        def number_action():\n            raise IndexError  # this is the important line!\n\n        number.setParseAction(number_action)\n        symbol = pp.Word(\"abcd\", max=1)\n        expr = number | symbol\n\n        try:\n            expr.parseString(\"1 + 2\", parseAll=True)\n        except Exception as e:\n            print_traceback = True\n            try:\n                self.assertTrue(\n                    hasattr(e, \"__cause__\"),\n                    \"no __cause__ attribute in the raised exception\",\n                )\n                self.assertTrue(\n                    e.__cause__ is not None,\n                    \"__cause__ not propagated to outer exception\",\n                )\n                self.assertEqual(\n                    IndexError,\n                    type(e.__cause__),\n                    \"__cause__ references wrong exception\",\n                )\n                print_traceback = False\n            finally:\n                if print_traceback:\n                    traceback.print_exc()\n        else:\n            self.fail(\"Expected ParseException not raised\")\n\n    # tests Issue #22\n    def testParseActionNesting(self):\n        vals = pp.OneOrMore(ppc.integer)(\"int_values\")\n\n        def add_total(tokens):\n            tokens[\"total\"] = sum(tokens)\n            return tokens\n\n        vals.addParseAction(add_total)\n        results = vals.parseString(\"244 23 13 2343\", parseAll=True)\n        print(results.dump())\n        self.assertParseResultsEquals(\n            results,\n            expected_dict={\"int_values\": [244, 23, 13, 2343], \"total\": 2623},\n            msg=\"noop parse action changed ParseResults structure\",\n        )\n\n        name = pp.Word(pp.alphas)(\"name\")\n        score = pp.Word(pp.nums + \".\")(\"score\")\n        nameScore = pp.Group(name + score)\n        line1 = nameScore(\"Rider\")\n\n        result1 = line1.parseString(\"Mauney 46.5\", parseAll=True)\n\n        print(\"### before parse action is added ###\")\n        print(\"result1.dump():\\n\" + result1.dump() + \"\\n\")\n        before_pa_dict = result1.asDict()\n\n        line1.setParseAction(lambda t: t)\n\n        result1 = line1.parseString(\"Mauney 46.5\", parseAll=True)\n        after_pa_dict = result1.asDict()\n\n        print(\"### after parse action was added ###\")\n        print(\"result1.dump():\\n\" + result1.dump() + \"\\n\")\n        self.assertEqual(\n            before_pa_dict,\n            after_pa_dict,\n            \"noop parse action changed ParseResults structure\",\n        )\n\n    def testParseActionWithDelimitedList(self):\n        class AnnotatedToken:\n            def __init__(self, kind, elements):\n                self.kind = kind\n                self.elements = elements\n\n            def __str__(self):\n                return f\"AnnotatedToken({self.kind!r}, {self.elements!r})\"\n\n            def __eq__(self, other):\n                return (\n                    type(self) == type(other)\n                    and self.kind == other.kind\n                    and self.elements == other.elements\n                )\n\n            __repr__ = __str__\n\n        def annotate(name):\n            def _(t):\n                return AnnotatedToken(name, t.asList())\n\n            return _\n\n        identifier = pp.Word(pp.srange(\"[a-z0-9]\"))\n        numeral = pp.Word(pp.nums)\n\n        named_number_value = pp.Suppress(\"(\") + numeral + pp.Suppress(\")\")\n        named_number = identifier + named_number_value\n\n        named_number_list = (\n            pp.Suppress(\"{\")\n            + pp.Group(pp.Optional(pp.delimitedList(named_number)))\n            + pp.Suppress(\"}\")\n        )\n\n        # repro but in #345 - delimitedList silently changes contents of named_number\n        named_number_value.setParseAction(annotate(\"val\"))\n\n        test_string = \"{ x1(1), x2(2) }\"\n        expected = [\n            [\"x1\", AnnotatedToken(\"val\", [\"1\"]), \"x2\", AnnotatedToken(\"val\", [\"2\"])]\n        ]\n\n        self.assertParseAndCheckList(named_number_list, test_string, expected)\n\n    def testParseActionRunsInNotAny(self):\n        # see Issue #482\n        data = \"\"\" [gog1] [G1] [gog2] [gog3] [gog4] [G2] [gog5] [G3] [gog6] \"\"\"\n\n        poi_type = pp.Word(pp.alphas).set_results_name(\"type\")\n        poi = pp.Suppress(\"[\") + poi_type + pp.Char(pp.nums) + pp.Suppress(\"]\")\n\n        def cnd_is_type(val):\n            return lambda toks: toks.type == val\n\n        poi_gog = poi(\"gog\").add_condition(cnd_is_type(\"gog\"))\n        poi_g = poi(\"g\").add_condition(cnd_is_type(\"G\"))\n\n        pattern = poi_gog + ~poi_g\n\n        matches = pattern.search_string(data).as_list()\n        self.assertEqual(\n            [[\"gog\", \"2\"], [\"gog\", \"3\"], [\"gog\", \"6\"]],\n            matches,\n            \"failed testing parse actions being run inside a NotAny\",\n        )\n\n    def testParseResultsNameBelowUngroupedName(self):\n        rule_num = pp.Regex(\"[0-9]+\")(\"LIT_NUM*\")\n        list_num = pp.Group(\n            pp.Literal(\"[\")(\"START_LIST\")\n            + pp.delimitedList(rule_num)(\"LIST_VALUES\")\n            + pp.Literal(\"]\")(\"END_LIST\")\n        )(\"LIST\")\n\n        test_string = \"[ 1,2,3,4,5,6 ]\"\n        list_num.runTests(test_string)\n\n        U = list_num.parseString(test_string, parseAll=True)\n        self.assertTrue(\n            \"LIT_NUM\" not in U.LIST.LIST_VALUES,\n            \"results name retained as sub in ungrouped named result\",\n        )\n\n    def testParseResultsNamesInGroupWithDict(self):\n        key = ppc.identifier()\n        value = ppc.integer()\n        lat = ppc.real()\n        long = ppc.real()\n        EQ = pp.Suppress(\"=\")\n\n        data = (\n            lat(\"lat\")\n            + long(\"long\")\n            + pp.Dict(pp.OneOrMore(pp.Group(key + EQ + value)))\n        )\n        site = pp.QuotedString('\"')(\"name\") + pp.Group(data)(\"data\")\n\n        test_string = '\"Golden Gate Bridge\" 37.819722 -122.478611 height=746 span=4200'\n        site.runTests(test_string)\n\n        a, aEnd = pp.makeHTMLTags(\"a\")\n        attrs = a.parseString(\"<a href='blah'>\", parseAll=True)\n        print(attrs.dump())\n        self.assertParseResultsEquals(\n            attrs,\n            expected_dict={\n                \"startA\": {\"href\": \"blah\", \"tag\": \"a\", \"empty\": False},\n                \"href\": \"blah\",\n                \"tag\": \"a\",\n                \"empty\": False,\n            },\n        )\n\n    def testMakeXMLTags(self):\n        \"\"\"test helper function makeXMLTags in simple use case\"\"\"\n\n        body, bodyEnd = pp.makeXMLTags(\"body\")\n        tst = \"<body>Hello</body>\"\n        expr = body + pp.Word(pp.alphas)(\"contents\") + bodyEnd\n        result = expr.parseString(tst, parseAll=True)\n        print(result.dump())\n        self.assertParseResultsEquals(\n            result, [\"body\", False, \"Hello\", \"</body>\"], msg=\"issue using makeXMLTags\"\n        )\n\n    def testFollowedBy(self):\n        expr = pp.Word(pp.alphas)(\"item\") + pp.FollowedBy(ppc.integer(\"qty\"))\n        result = expr.parseString(\"balloon 99\", parseAll=False)\n        print(result.dump())\n        self.assertTrue(\"qty\" in result, \"failed to capture results name in FollowedBy\")\n        self.assertEqual(\n            {\"item\": \"balloon\", \"qty\": 99},\n            result.asDict(),\n            \"invalid results name structure from FollowedBy\",\n        )\n\n    def testSetBreak(self):\n        \"\"\"\n        Test behavior of ParserElement.setBreak(), to invoke the debugger before parsing that element is attempted.\n\n        Temporarily monkeypatches pdb.set_trace.\n        \"\"\"\n        was_called = False\n\n        def mock_set_trace():\n            nonlocal was_called\n            was_called = True\n\n        wd = pp.Word(pp.alphas)\n        wd.setBreak()\n\n        print(\"Before parsing with setBreak:\", was_called)\n        import pdb\n\n        with ppt.reset_pyparsing_context():\n            pdb.set_trace = mock_set_trace\n            wd.parseString(\"ABC\", parseAll=True)\n\n        print(\"After parsing with setBreak:\", was_called)\n        self.assertTrue(was_called, \"set_trace wasn't called by setBreak\")\n\n    def testUnicodeTests(self):\n        import unicodedata\n\n        ppu = pp.pyparsing_unicode\n\n        unicode_version = unicodedata.unidata_version\n        print(f\"Unicode version {unicode_version}\")\n\n        # verify ranges are converted to sets properly\n        for unicode_property, expected_length in [\n            (\"alphas\", 48965),\n            (\"alphanums\", 49430),\n            (\"identchars\", 49013),\n            (\"identbodychars\", 50729),\n            (\"printables\", 65484),\n        ]:\n            charset = getattr(ppu.BMP, unicode_property)\n            charset_len = len(charset)\n\n            # this subtest is sensitive to the Unicode version used in the current\n            # python version\n            if unicode_version == \"14.0.0\":\n                with self.subTest(unicode_property=unicode_property, msg=\"verify len\"):\n                    print(f\"ppu.BMP.{unicode_property:14}: {charset_len:6d}\")\n                    self.assertEqual(\n                        charset_len,\n                        expected_length,\n                        f\"incorrect number of ppu.BMP.{unicode_property},\"\n                        f\" found {charset_len} expected {expected_length}\",\n                    )\n\n            with self.subTest(unicode_property=unicode_property, msg=\"verify unique\"):\n                char_counts = collections.Counter(charset)\n                self.assertTrue(\n                    all(count == 1 for count in char_counts.values()),\n                    f\"duplicate items found in ppu.BMP.{unicode_property}:\"\n                    f\" {[(ord(c), c) for c, count in char_counts.items() if count > 1]}\",\n                )\n\n        # verify proper merging of ranges by addition\n        kanji_printables = ppu.Japanese.Kanji.printables\n        katakana_printables = ppu.Japanese.Katakana.printables\n        hiragana_printables = ppu.Japanese.Hiragana.printables\n        japanese_printables = ppu.Japanese.printables\n        with self.subTest(msg=\"verify constructing ranges by merging types\"):\n            self.assertEqual(\n                set(kanji_printables + katakana_printables + hiragana_printables),\n                set(japanese_printables),\n                \"failed to construct ranges by merging Japanese types\",\n            )\n\n        # verify proper merging of ranges using multiple inheritance\n        cjk_printables = ppu.CJK.printables\n        chinese_printables = ppu.Chinese.printables\n        korean_printables = ppu.Korean.printables\n        with self.subTest(\n            msg=\"verify merging ranges by using multiple inheritance generates unique list of characters\"\n        ):\n            char_counts = collections.Counter(cjk_printables)\n            self.assertTrue(\n                all(count == 1 for count in char_counts.values()),\n                \"duplicate items found in ppu.CJK.printables:\"\n                f\" {[(ord(c), c) for c, count in char_counts.items() if count > 1]}\",\n            )\n\n        with self.subTest(\n            msg=\"verify merging ranges by using multiple inheritance generates sorted list of characters\"\n        ):\n            self.assertEqual(\n                list(cjk_printables),\n                sorted(cjk_printables),\n                \"CJK printables are not sorted\",\n            )\n\n        with self.subTest(\n            msg=\"verify summing chars is equivalent to merging ranges by using multiple inheritance (CJK)\"\n        ):\n            print(\n                len(set(chinese_printables + korean_printables + japanese_printables)),\n                len(cjk_printables),\n            )\n\n            self.assertEqual(\n                set(chinese_printables + korean_printables + japanese_printables),\n                set(cjk_printables),\n                \"failed to construct ranges by merging Chinese, Japanese and Korean\",\n            )\n\n    def testUnicodeTests2(self):\n        ppu = pp.unicode\n\n        alphas = ppu.Greek.alphas\n        greet = pp.Word(alphas) + \",\" + pp.Word(alphas) + \"!\"\n\n        # input string\n        hello = \"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1, \u03ba\u03cc\u03c3\u03bc\u03b5!\"\n        result = greet.parseString(hello, parseAll=True)\n        print(result)\n        self.assertParseResultsEquals(\n            result,\n            expected_list=[\"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1\", \",\", \"\u03ba\u03cc\u03c3\u03bc\u03b5\", \"!\"],\n            msg=\"Failed to parse Greek 'Hello, World!' using \"\n            \"pyparsing_unicode.Greek.alphas\",\n        )\n\n        # define a custom unicode range using multiple inheritance\n        class Turkish_set(ppu.Latin1, ppu.LatinA):\n            pass\n\n        for attrname in \"printables alphas nums identchars identbodychars\".split():\n            with self.subTest(\n                \"verify unicode_set composed using MI\", attrname=attrname\n            ):\n                latin1_value = getattr(ppu.Latin1, attrname)\n                latinA_value = getattr(ppu.LatinA, attrname)\n                turkish_value = getattr(Turkish_set, attrname)\n                self.assertEqual(\n                    set(latin1_value + latinA_value),\n                    set(turkish_value),\n                    f\"failed to construct ranges by merging Latin1 and LatinA ({attrname})\",\n                )\n\n        with self.subTest(\"Test using new Turkish_set for parsing\"):\n            key = pp.Word(Turkish_set.alphas)\n            value = ppc.integer | pp.Word(Turkish_set.alphas, Turkish_set.alphanums)\n            EQ = pp.Suppress(\"=\")\n            key_value = key + EQ + value\n\n            sample = \"\"\"\\\n                \u015fehir=\u0130zmir\n                \u00fclke=T\u00fcrkiye\n                n\u00fcfus=4279677\"\"\"\n            result = pp.Dict(pp.OneOrMore(pp.Group(key_value))).parseString(\n                sample, parseAll=True\n            )\n\n            print(result.dump())\n            self.assertParseResultsEquals(\n                result,\n                expected_dict={\"\u015fehir\": \"\u0130zmir\", \"\u00fclke\": \"T\u00fcrkiye\", \"n\u00fcfus\": 4279677},\n                msg=\"Failed to parse Turkish key-value pairs\",\n            )\n\n        # Basic Multilingual Plane only contains chars up to 65535\n        def filter_16_bit(s):\n            return \"\".join(c for c in s if ord(c) < 2**16)\n\n        with self.subTest():\n            bmp_printables = ppu.BMP.printables\n            sample = (\n                \"\".join(\n                    random.choice(filter_16_bit(unicode_set.printables))\n                    for unicode_set in (\n                        ppu.Japanese,\n                        Turkish_set,\n                        ppu.Greek,\n                        ppu.Hebrew,\n                        ppu.Devanagari,\n                        ppu.Hangul,\n                        ppu.Latin1,\n                        ppu.Chinese,\n                        ppu.Cyrillic,\n                        ppu.Arabic,\n                        ppu.Thai,\n                    )\n                    for _ in range(8)\n                )\n                + \"\\N{REPLACEMENT CHARACTER}\"\n            )\n            print(sample)\n            self.assertParseAndCheckList(pp.Word(bmp_printables), sample, [sample])\n\n    def testUnicodeSetNameEquivalence(self):\n        ppu = pp.unicode\n\n        for ascii_name, unicode_name in [\n            (\"Arabic\", \"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\"),\n            (\"Chinese\", \"\u4e2d\u6587\"),\n            (\"Cyrillic\", \"\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430\"),\n            (\"Greek\", \"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac\"),\n            (\"Hebrew\", \"\u05e2\u05b4\u05d1\u05e8\u05b4\u05d9\u05ea\"),\n            (\"Japanese\", \"\u65e5\u672c\u8a9e\"),\n            (\"Korean\", \"\ud55c\uad6d\uc5b4\"),\n            (\"Thai\", \"\u0e44\u0e17\u0e22\"),\n            (\"Devanagari\", \"\u0926\u0947\u0935\u0928\u093e\u0917\u0930\u0940\"),\n        ]:\n            with self.subTest(ascii_name=ascii_name, unicode_name=unicode_name):\n                self.assertTrue(\n                    eval(f\"ppu.{ascii_name} is ppu.{unicode_name}\", {}, locals())\n                )\n\n    # Make sure example in indentedBlock docstring actually works!\n    def testIndentedBlockExample(self):\n        data = dedent(\n            \"\"\"\n        def A(z):\n          A1\n          B = 100\n          G = A2\n          A2\n          A3\n        B\n        def BB(a,b,c):\n          BB1\n          def BBA():\n            bba1\n            bba2\n            bba3\n        C\n        D\n        def spam(x,y):\n             def eggs(z):\n                 pass\n        \"\"\"\n        )\n\n        indentStack = [1]\n        stmt = pp.Forward()\n\n        identifier = pp.Word(pp.alphas, pp.alphanums)\n        funcDecl = (\n            \"def\"\n            + identifier\n            + pp.Group(\"(\" + pp.Optional(pp.delimitedList(identifier)) + \")\")\n            + \":\"\n        )\n        func_body = pp.indentedBlock(stmt, indentStack)\n        funcDef = pp.Group(funcDecl + func_body)\n\n        rvalue = pp.Forward()\n        funcCall = pp.Group(\n            identifier + \"(\" + pp.Optional(pp.delimitedList(rvalue)) + \")\"\n        )\n        rvalue << (funcCall | identifier | pp.Word(pp.nums))\n        assignment = pp.Group(identifier + \"=\" + rvalue)\n        stmt <<= funcDef | assignment | identifier\n\n        module_body = pp.OneOrMore(stmt)\n\n        self.assertParseAndCheckList(\n            module_body,\n            data,\n            [\n                [\n                    \"def\",\n                    \"A\",\n                    [\"(\", \"z\", \")\"],\n                    \":\",\n                    [[\"A1\"], [[\"B\", \"=\", \"100\"]], [[\"G\", \"=\", \"A2\"]], [\"A2\"], [\"A3\"]],\n                ],\n                \"B\",\n                [\n                    \"def\",\n                    \"BB\",\n                    [\"(\", \"a\", \"b\", \"c\", \")\"],\n                    \":\",\n                    [\n                        [\"BB1\"],\n                        [\n                            [\n                                \"def\",\n                                \"BBA\",\n                                [\"(\", \")\"],\n                                \":\",\n                                [[\"bba1\"], [\"bba2\"], [\"bba3\"]],\n                            ]\n                        ],\n                    ],\n                ],\n                \"C\",\n                \"D\",\n                [\n                    \"def\",\n                    \"spam\",\n                    [\"(\", \"x\", \"y\", \")\"],\n                    \":\",\n                    [[[\"def\", \"eggs\", [\"(\", \"z\", \")\"], \":\", [[\"pass\"]]]]],\n                ],\n            ],\n            \"Failed indentedBlock example\",\n            verbose=True,\n        )\n\n    def testIndentedBlock(self):\n        # parse pseudo-yaml indented text\n\n        EQ = pp.Suppress(\"=\")\n        stack = [1]\n        key = ppc.identifier\n        value = pp.Forward()\n        key_value = key + EQ + value\n        compound_value = pp.Dict(pp.ungroup(pp.indentedBlock(key_value, stack)))\n        value <<= ppc.integer | pp.QuotedString(\"'\") | compound_value\n        parser = pp.Dict(pp.OneOrMore(pp.Group(key_value)))\n\n        text = \"\"\"\n            a = 100\n            b = 101\n            c =\n                c1 = 200\n                c2 =\n                    c21 = 999\n                c3 = 'A horse, a horse, my kingdom for a horse'\n            d = 505\n        \"\"\"\n        text = dedent(text)\n        print(text)\n\n        result = parser.parseString(text, parseAll=True)\n        print(result.dump())\n        self.assertEqual(100, result.a, \"invalid indented block result\")\n        self.assertEqual(200, result.c.c1, \"invalid indented block result\")\n        self.assertEqual(999, result.c.c2.c21, \"invalid indented block result\")\n\n    # exercise indentedBlock with example posted in issue #87\n    def testIndentedBlockTest2(self):\n        indent_stack = [1]\n\n        key = pp.Word(pp.alphas, pp.alphanums) + pp.Suppress(\":\")\n        stmt = pp.Forward()\n\n        suite = pp.indentedBlock(stmt, indent_stack)\n        body = key + suite\n\n        pattern = (\n            pp.Word(pp.alphas)\n            + pp.Suppress(\"(\")\n            + pp.Word(pp.alphas)\n            + pp.Suppress(\")\")\n        )\n        stmt <<= pattern\n\n        def key_parse_action(toks):\n            print(f\"Parsing '{toks[0]}'...\")\n\n        key.setParseAction(key_parse_action)\n        header = pp.Suppress(\"[\") + pp.Literal(\"test\") + pp.Suppress(\"]\")\n        content = header - pp.OneOrMore(pp.indentedBlock(body, indent_stack, False))\n\n        contents = pp.Forward()\n        suites = pp.indentedBlock(content, indent_stack)\n\n        extra = pp.Literal(\"extra\") + pp.Suppress(\":\") - suites\n        contents <<= content | extra\n\n        parser = pp.OneOrMore(contents)\n\n        sample = dedent(\n            \"\"\"\n        extra:\n            [test]\n            one0:\n                two (three)\n            four0:\n                five (seven)\n        extra:\n            [test]\n            one1:\n                two (three)\n            four1:\n                five (seven)\n        \"\"\"\n        )\n\n        success, _ = parser.runTests([sample])\n        self.assertTrue(success, \"Failed indentedBlock test for issue #87\")\n\n        sample2 = dedent(\n            \"\"\"\n        extra:\n            [test]\n            one:\n                two (three)\n            four:\n                five (seven)\n        extra:\n            [test]\n            one:\n                two (three)\n            four:\n                five (seven)\n\n            [test]\n            one:\n                two (three)\n            four:\n                five (seven)\n\n            [test]\n            eight:\n                nine (ten)\n            eleven:\n                twelve (thirteen)\n\n            fourteen:\n                fifteen (sixteen)\n            seventeen:\n                eighteen (nineteen)\n        \"\"\"\n        )\n\n        del indent_stack[1:]\n        success, _ = parser.runTests([sample2])\n        self.assertTrue(success, \"Failed indentedBlock multi-block test for issue #87\")\n\n    def testIndentedBlockScan(self):\n        def get_parser():\n            \"\"\"\n            A valid statement is the word \"block:\", followed by an indent, followed by the letter A only, or another block\n            \"\"\"\n            stack = [1]\n            block = pp.Forward()\n            body = pp.indentedBlock(\n                pp.Literal(\"A\") ^ block, indentStack=stack, indent=True\n            )\n            block <<= pp.Literal(\"block:\") + body\n            return block\n\n        # This input string is a perfect match for the parser, so a single match is found\n        p1 = get_parser()\n        r1 = list(\n            p1.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            A\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(1, len(r1))\n\n        # This input string is a perfect match for the parser, except for the letter B instead of A, so this will fail (and should)\n        p2 = get_parser()\n        r2 = list(\n            p2.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            B\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(0, len(r2))\n\n        # This input string contains both string A and string B, and it finds one match (as it should)\n        p3 = get_parser()\n        r3 = list(\n            p3.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            A\n        block:\n            B\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(1, len(r3))\n\n        # This input string contains both string A and string B, but in a different order.\n        p4 = get_parser()\n        r4 = list(\n            p4.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            B\n        block:\n            A\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(1, len(r4))\n\n        # This is the same as case 3, but with nesting\n        p5 = get_parser()\n        r5 = list(\n            p5.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            block:\n                A\n        block:\n            block:\n                B\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(1, len(r5))\n\n        # This is the same as case 4, but with nesting\n        p6 = get_parser()\n        r6 = list(\n            p6.scanString(\n                dedent(\n                    \"\"\"\\\n        block:\n            block:\n                B\n        block:\n            block:\n                A\n        \"\"\"\n                )\n            )\n        )\n        self.assertEqual(1, len(r6))\n\n    def testIndentedBlockClass(self):\n        data = \"\"\"\\\n            A\n                100\n                101\n\n                102\n            B\n                200\n                201\n\n            C\n                300\n\n        \"\"\"\n\n        integer = ppc.integer\n        group = pp.Group(pp.Char(pp.alphas) + pp.IndentedBlock(integer))\n\n        group[...].parseString(data, parseAll=True).pprint()\n\n        self.assertParseAndCheckList(\n            group[...], data, [[\"A\", [100, 101, 102]], [\"B\", [200, 201]], [\"C\", [300]]]\n        )\n\n    def testIndentedBlockClass2(self):\n        datas = [\n            \"\"\"\\\n             A\n                100\n             B\n                200\n             201\n            \"\"\",\n            \"\"\"\\\n             A\n                100\n             B\n                200\n               201\n            \"\"\",\n            \"\"\"\\\n             A\n                100\n             B\n                200\n                  201\n            \"\"\",\n        ]\n        integer = ppc.integer\n        group = pp.Group(\n            pp.Char(pp.alphas) + pp.IndentedBlock(integer, recursive=False)\n        )\n\n        for data in datas:\n            print()\n            print(ppt.with_line_numbers(data))\n\n            print(group[...].parse_string(data).as_list())\n            self.assertParseAndCheckList(\n                group[...] + integer.suppress(),\n                data,\n                [[\"A\", [100]], [\"B\", [200]]],\n                verbose=False,\n            )\n\n    def testIndentedBlockClassWithRecursion(self):\n        data = \"\"\"\\\n\n            A\n                100\n                101\n\n                102\n            B\n                b\n                    200\n                    201\n\n            C\n                300\n\n        \"\"\"\n\n        integer = ppc.integer\n        group = pp.Forward()\n        group <<= pp.Group(pp.Char(pp.alphas) + pp.IndentedBlock(integer | group))\n\n        print(\"using searchString\")\n        print(group.searchString(data))\n        # print(sum(group.searchString(data)).dump())\n\n        self.assertParseAndCheckList(\n            group[...],\n            data,\n            [[\"A\", [100, 101, 102]], [\"B\", [[\"b\", [200, 201]]]], [\"C\", [300]]],\n        )\n\n        print(\"using parseString\")\n        print(group[...].parseString(data, parseAll=True).dump())\n\n        dotted_int = pp.delimited_list(\n            pp.Word(pp.nums), \".\", allow_trailing_delim=True, combine=True\n        )\n        indented_expr = pp.IndentedBlock(dotted_int, recursive=True, grouped=True)\n        # indented_expr = pp.Forward()\n        # indented_expr <<= pp.IndentedBlock(dotted_int + indented_expr))\n        good_data = \"\"\"\\\n            1.\n                1.1\n                    1.1.1\n                    1.1.2\n            2.\"\"\"\n        bad_data1 = \"\"\"\\\n            1.\n                1.1\n                    1.1.1\n                 1.2\n            2.\"\"\"\n        bad_data2 = \"\"\"\\\n            1.\n                1.1\n                    1.1.1\n               1.2\n            2.\"\"\"\n        print(\"test good indentation\")\n        print(pp.pyparsing_test.with_line_numbers(good_data))\n        print(indented_expr.parseString(good_data, parseAll=True).as_list())\n        print()\n\n        print(\"test bad indentation\")\n        print(pp.pyparsing_test.with_line_numbers(bad_data1))\n        with self.assertRaisesParseException(\n            msg=\"Failed to raise exception with bad indentation 1\"\n        ):\n            indented_expr.parseString(bad_data1, parseAll=True)\n\n        print(pp.pyparsing_test.with_line_numbers(bad_data2))\n        with self.assertRaisesParseException(\n            msg=\"Failed to raise exception with bad indentation 2\"\n        ):\n            indented_expr.parseString(bad_data2, parseAll=True)\n\n    def testInvalidDiagSetting(self):\n        with self.assertRaises(\n            ValueError,\n            msg=\"failed to raise exception when setting non-existent __diag__\",\n        ):\n            pp.__diag__.enable(\"xyzzy\")\n\n        with self.assertWarns(\n            UserWarning, msg=\"failed to warn disabling 'collect_all_And_tokens\"\n        ):\n            pp.__compat__.disable(\"collect_all_And_tokens\")\n\n    def testParseResultsWithNameMatchFirst(self):\n        expr_a = pp.Literal(\"not\") + pp.Literal(\"the\") + pp.Literal(\"bird\")\n        expr_b = pp.Literal(\"the\") + pp.Literal(\"bird\")\n        expr = (expr_a | expr_b)(\"rexp\")\n\n        success, report = expr.runTests(\n            \"\"\"\\\n            not the bird\n            the bird\n        \"\"\"\n        )\n        results = [rpt[1] for rpt in report]\n        self.assertParseResultsEquals(\n            results[0], [\"not\", \"the\", \"bird\"], {\"rexp\": [\"not\", \"the\", \"bird\"]}\n        )\n        self.assertParseResultsEquals(\n            results[1], [\"the\", \"bird\"], {\"rexp\": [\"the\", \"bird\"]}\n        )\n\n        # test compatibility mode, no longer restoring pre-2.3.1 behavior\n        with ppt.reset_pyparsing_context():\n            pp.__compat__.collect_all_And_tokens = False\n            pp.enable_diag(pp.Diagnostics.warn_multiple_tokens_in_named_alternation)\n            expr_a = pp.Literal(\"not\") + pp.Literal(\"the\") + pp.Literal(\"bird\")\n            expr_b = pp.Literal(\"the\") + pp.Literal(\"bird\")\n            with self.assertWarns(\n                UserWarning, msg=\"failed to warn of And within alternation\"\n            ):\n                expr = (expr_a | expr_b)(\"rexp\")\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when And within alternation warning was suppressed\",\n            ):\n                expr = (expr_a | expr_b).suppress_warning(\n                    pp.Diagnostics.warn_multiple_tokens_in_named_alternation\n                )(\"rexp\")\n\n            success, report = expr.runTests(\n                \"\"\"\n                not the bird\n                the bird\n            \"\"\"\n            )\n            results = [rpt[1] for rpt in report]\n            self.assertParseResultsEquals(\n                results[0], [\"not\", \"the\", \"bird\"], {\"rexp\": [\"not\", \"the\", \"bird\"]}\n            )\n            self.assertParseResultsEquals(\n                results[1], [\"the\", \"bird\"], {\"rexp\": [\"the\", \"bird\"]}\n            )\n\n    def testParseResultsWithNameOr(self):\n        expr_a = pp.Literal(\"not\") + pp.Literal(\"the\") + pp.Literal(\"bird\")\n        expr_b = pp.Literal(\"the\") + pp.Literal(\"bird\")\n        expr = (expr_a ^ expr_b)(\"rexp\")\n        expr.runTests(\n            \"\"\"\\\n            not the bird\n            the bird\n        \"\"\"\n        )\n        result = expr.parseString(\"not the bird\", parseAll=True)\n        self.assertParseResultsEquals(\n            result, [\"not\", \"the\", \"bird\"], {\"rexp\": [\"not\", \"the\", \"bird\"]}\n        )\n        result = expr.parseString(\"the bird\", parseAll=True)\n        self.assertParseResultsEquals(\n            result, [\"the\", \"bird\"], {\"rexp\": [\"the\", \"bird\"]}\n        )\n\n        expr = (expr_a | expr_b)(\"rexp\")\n        expr.runTests(\n            \"\"\"\\\n            not the bird\n            the bird\n        \"\"\"\n        )\n        result = expr.parseString(\"not the bird\", parseAll=True)\n        self.assertParseResultsEquals(\n            result, [\"not\", \"the\", \"bird\"], {\"rexp\": [\"not\", \"the\", \"bird\"]}\n        )\n        result = expr.parseString(\"the bird\", parseAll=True)\n        self.assertParseResultsEquals(\n            result, [\"the\", \"bird\"], {\"rexp\": [\"the\", \"bird\"]}\n        )\n\n        # test compatibility mode, no longer restoring pre-2.3.1 behavior\n        with ppt.reset_pyparsing_context():\n            pp.__compat__.collect_all_And_tokens = False\n            pp.enable_diag(pp.Diagnostics.warn_multiple_tokens_in_named_alternation)\n            expr_a = pp.Literal(\"not\") + pp.Literal(\"the\") + pp.Literal(\"bird\")\n            expr_b = pp.Literal(\"the\") + pp.Literal(\"bird\")\n\n            with self.assertWarns(\n                UserWarning, msg=\"failed to warn of And within alternation\"\n            ):\n                expr = (expr_a ^ expr_b)(\"rexp\")\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when And within alternation warning was suppressed\",\n            ):\n                expr = (expr_a ^ expr_b).suppress_warning(\n                    pp.Diagnostics.warn_multiple_tokens_in_named_alternation\n                )(\"rexp\")\n\n            expr.runTests(\n                \"\"\"\\\n                not the bird\n                the bird\n            \"\"\"\n            )\n            self.assertEqual(\n                \"not the bird\".split(),\n                list(expr.parseString(\"not the bird\", parseAll=True)[\"rexp\"]),\n            )\n            self.assertEqual(\n                \"the bird\".split(),\n                list(expr.parseString(\"the bird\", parseAll=True)[\"rexp\"]),\n            )\n\n    def testEmptyDictDoesNotRaiseException(self):\n        key = pp.Word(pp.alphas)\n        value = pp.Word(pp.nums)\n        EQ = pp.Suppress(\"=\")\n        key_value_dict = pp.dictOf(key, EQ + value)\n\n        print(\n            key_value_dict.parseString(\n                \"\"\"\\\n            a = 10\n            b = 20\n            \"\"\",\n                parseAll=True,\n            ).dump()\n        )\n\n        try:\n            print(key_value_dict.parseString(\"\", parseAll=True).dump())\n        except pp.ParseException as pe:\n            print(pp.ParseException.explain(pe))\n        else:\n            self.fail(\"failed to raise exception when matching empty string\")\n\n    def testExplainException(self):\n        expr = pp.Word(pp.nums).setName(\"int\") + pp.Word(pp.alphas).setName(\"word\")\n        try:\n            expr.parseString(\"123 355\", parseAll=True)\n        except pp.ParseException as pe:\n            print(pe.explain(depth=0))\n\n        expr = pp.Word(pp.nums).setName(\"int\") - pp.Word(pp.alphas).setName(\"word\")\n        try:\n            expr.parseString(\"123 355 (test using ErrorStop)\", parseAll=True)\n        except pp.ParseSyntaxException as pe:\n            print(pe.explain())\n\n        integer = pp.Word(pp.nums).setName(\"int\").addParseAction(lambda t: int(t[0]))\n        expr = integer + integer\n\n        def divide_args(t):\n            integer.parseString(\"A\", parseAll=True)\n            return t[0] / t[1]\n\n        expr.addParseAction(divide_args)\n        try:\n            expr.parseString(\"123 0\", parseAll=True)\n        except pp.ParseException as pe:\n            print(pe.explain())\n        except Exception as exc:\n            print(pp.ParseBaseException.explain_exception(exc))\n            raise\n\n    def testExplainExceptionWithMemoizationCheck(self):\n        if pp.ParserElement._left_recursion_enabled or pp.ParserElement._packratEnabled:\n            print(\"test does local memoization enable/disable during test\")\n            return\n\n        pp.ParserElement.disable_memoization()\n\n        integer = pp.Word(pp.nums).setName(\"int\").addParseAction(lambda t: int(t[0]))\n        expr = integer + integer\n\n        def divide_args(t):\n            integer.parseString(\"A\", parseAll=True)\n            return t[0] / t[1]\n\n        expr.addParseAction(divide_args)\n        for memo_kind, enable_memo in [\n            (\"Packrat\", pp.ParserElement.enablePackrat),\n            (\"Left Recursion\", pp.ParserElement.enable_left_recursion),\n        ]:\n            enable_memo(force=True)\n            print(\"Explain for\", memo_kind)\n\n            try:\n                expr.parseString(\"123 0\", parseAll=True)\n            except pp.ParseException as pe:\n                print(pe.explain())\n            except Exception as exc:\n                print(pp.ParseBaseException.explain_exception(exc))\n                raise\n\n        # make sure we leave the state compatible with everything\n        pp.ParserElement.disable_memoization()\n\n    def testCaselessKeywordVsKeywordCaseless(self):\n        frule = pp.Keyword(\"t\", caseless=True) + pp.Keyword(\"yes\", caseless=True)\n        crule = pp.CaselessKeyword(\"t\") + pp.CaselessKeyword(\"yes\")\n\n        flist = frule.searchString(\"not yes\").asList()\n        print(flist)\n        clist = crule.searchString(\"not yes\").asList()\n        print(clist)\n        self.assertEqual(\n            flist,\n            clist,\n            \"CaselessKeyword not working the same as Keyword(caseless=True)\",\n        )\n\n    def testOneOfKeywords(self):\n        literal_expr = pp.oneOf(\"a b c\")\n        success, _ = literal_expr[...].runTests(\n            \"\"\"\n            # literal oneOf tests\n            a b c\n            a a a\n            abc\n        \"\"\"\n        )\n        self.assertTrue(success, \"failed literal oneOf matching\")\n\n        keyword_expr = pp.oneOf(\"a b c\", asKeyword=True)\n        success, _ = keyword_expr[...].runTests(\n            \"\"\"\n            # keyword oneOf tests\n            a b c\n            a a a\n        \"\"\"\n        )\n        self.assertTrue(success, \"failed keyword oneOf matching\")\n\n        success, _ = keyword_expr[...].runTests(\n            \"\"\"\n            # keyword oneOf failure tests\n            abc\n        \"\"\",\n            failureTests=True,\n        )\n        self.assertTrue(success, \"failed keyword oneOf failure tests\")\n\n    def testWarnUngroupedNamedTokens(self):\n        \"\"\"\n        - warn_ungrouped_named_tokens_in_collection - flag to enable warnings when a results\n          name is defined on a containing expression with ungrouped subexpressions that also\n          have results names (default=True)\n        \"\"\"\n        with self.assertDoesNotWarn(\n            msg=f\"raised {pp.Diagnostics.warn_ungrouped_named_tokens_in_collection} warning when not enabled\"\n        ):\n            COMMA = pp.Suppress(\",\").setName(\"comma\")\n            coord = ppc.integer(\"x\") + COMMA + ppc.integer(\"y\")\n            path = coord[...].setResultsName(\"path\")\n\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_ungrouped_named_tokens_in_collection)\n\n            COMMA = pp.Suppress(\",\").setName(\"comma\")\n            coord = ppc.integer(\"x\") + COMMA + ppc.integer(\"y\")\n\n            # this should emit a warning\n            with self.assertWarns(\n                UserWarning,\n                msg=\"failed to warn with named repetition of\"\n                \" ungrouped named expressions\",\n            ):\n                path = coord[...].setResultsName(\"path\")\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when named repetition of\"\n                \" ungrouped named expressions warning was suppressed\",\n            ):\n                path = (\n                    coord[...]\n                    .suppress_warning(\n                        pp.Diagnostics.warn_ungrouped_named_tokens_in_collection\n                    )\n                    .setResultsName(\"path\")\n                )\n\n    def testDontWarnUngroupedNamedTokensIfWarningSuppressed(self):\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_ungrouped_named_tokens_in_collection)\n\n            with self.assertDoesNotWarn(\n                msg=f\"raised {pp.Diagnostics.warn_ungrouped_named_tokens_in_collection}\"\n                f\" warning when warn on ungrouped named tokens was suppressed (original_text_for)\"\n            ):\n                pp.original_text_for(pp.Word(\"ABC\")[...])(\"words\")\n\n    def testWarnNameSetOnEmptyForward(self):\n        \"\"\"\n        - warn_name_set_on_empty_Forward - flag to enable warnings when a Forward is defined\n          with a results name, but has no contents defined (default=False)\n        \"\"\"\n\n        with self.assertDoesNotWarn(\n            msg=f\"raised {pp.Diagnostics.warn_name_set_on_empty_Forward} warning when not enabled\"\n        ):\n            base = pp.Forward()(\"z\")\n\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_name_set_on_empty_Forward)\n\n            base = pp.Forward()\n\n            with self.assertWarns(\n                UserWarning,\n                msg=\"failed to warn when naming an empty Forward expression\",\n            ):\n                base(\"x\")\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when naming an empty Forward expression warning was suppressed\",\n            ):\n                base.suppress_warning(pp.Diagnostics.warn_name_set_on_empty_Forward)(\n                    \"x\"\n                )\n\n    def testWarnParsingEmptyForward(self):\n        \"\"\"\n        - warn_on_parse_using_empty_Forward - flag to enable warnings when a Forward\n          has no contents defined (default=False)\n        \"\"\"\n\n        with self.assertDoesNotWarn(\n            msg=f\"raised {pp.Diagnostics.warn_on_parse_using_empty_Forward} warning when not enabled\"\n        ):\n            base = pp.Forward()\n            try:\n                print(base.parseString(\"x\", parseAll=True))\n            except ParseException as pe:\n                pass\n\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_on_parse_using_empty_Forward)\n\n            base = pp.Forward()\n\n            with self.assertWarns(\n                UserWarning,\n                msg=\"failed to warn when parsing using an empty Forward expression\",\n            ):\n                try:\n                    print(base.parseString(\"x\", parseAll=True))\n                except ParseException as pe:\n                    pass\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when parsing using an empty Forward expression warning was suppressed\",\n            ):\n                base.suppress_warning(pp.Diagnostics.warn_on_parse_using_empty_Forward)\n                try:\n                    print(base.parseString(\"x\", parseAll=True))\n                except ParseException as pe:\n                    pass\n\n    def testWarnIncorrectAssignmentToForward(self):\n        \"\"\"\n        - warn_on_parse_using_empty_Forward - flag to enable warnings when a Forward\n          has no contents defined (default=False)\n        \"\"\"\n        if PYPY_ENV:\n            print(\"warn_on_assignment_to_Forward not supported on PyPy\")\n            return\n\n        def a_method():\n            base = pp.Forward()\n            base = pp.Word(pp.alphas)[...] | \"(\" + base + \")\"\n\n        with self.assertDoesNotWarn(\n            msg=f\"raised {pp.Diagnostics.warn_on_assignment_to_Forward} warning when not enabled\"\n        ):\n            a_method()\n\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_on_assignment_to_Forward)\n\n            with self.assertWarns(\n                UserWarning,\n                msg=\"failed to warn when using '=' to assign expression to a Forward\",\n            ):\n                a_method()\n\n            def a_method():\n                base = pp.Forward().suppress_warning(\n                    pp.Diagnostics.warn_on_assignment_to_Forward\n                )\n                base = pp.Word(pp.alphas)[...] | \"(\" + base + \")\"\n\n            with self.assertDoesNotWarn(\n                UserWarning,\n                msg=\"warned when using '=' to assign expression to a Forward warning was suppressed\",\n            ):\n                a_method()\n\n    def testWarnOnMultipleStringArgsToOneOf(self):\n        \"\"\"\n        - warn_on_multiple_string_args_to_oneof - flag to enable warnings when oneOf is\n          incorrectly called with multiple str arguments (default=True)\n        \"\"\"\n        with self.assertDoesNotWarn(\n            msg=f\"raised {pp.Diagnostics.warn_on_multiple_string_args_to_oneof} warning when not enabled\"\n        ):\n            a = pp.one_of(\"A\", \"B\")\n\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.warn_on_multiple_string_args_to_oneof)\n\n            with self.assertWarns(\n                UserWarning,\n                msg=\"failed to warn when incorrectly calling oneOf(string, string)\",\n            ):\n                a = pp.oneOf(\"A\", \"B\")\n\n    def testAutonameElements(self):\n        with ppt.reset_pyparsing_context():\n            pp.enable_diag(pp.Diagnostics.enable_debug_on_named_expressions)\n\n            a = pp.Literal(\"a\")\n            b = pp.Literal(\"b\").set_name(\"bbb\")\n            z = pp.Literal(\"z\")\n            leading_a = a + pp.FollowedBy(z | a | b)\n\n            grammar = (z | leading_a | b)[...] + \"a\"\n\n            self.assertFalse(a.debug)\n            self.assertFalse(a.customName)\n            pp.autoname_elements()\n            self.assertTrue(a.debug)\n            self.assertEqual(\"a\", a.name)\n            self.assertEqual(\"bbb\", b.name)\n\n    def testDelimitedListName(self):\n        bool_constant = pp.Literal(\"True\") | \"true\" | \"False\" | \"false\"\n        bool_list = pp.delimitedList(bool_constant)\n        print(bool_list)\n        self.assertEqual(\n            \"{'True' | 'true' | 'False' | 'false'} [, {'True' | 'true' | 'False' | 'false'}]...\",\n            str(bool_list),\n        )\n\n        bool_constant.setName(\"bool\")\n        print(bool_constant)\n        print(bool_constant.streamline())\n        bool_list2 = pp.delimitedList(bool_constant)\n        print(bool_constant)\n        print(bool_constant.streamline())\n        print(bool_list2)\n        with self.subTest():\n            self.assertEqual(\"bool [, bool]...\", str(bool_list2))\n\n        with self.subTest():\n            street_address = pp.common.integer.set_name(\"integer\") + pp.Word(pp.alphas)[\n                1, ...\n            ].set_name(\"street_name\")\n            self.assertEqual(\n                \"{integer street_name} [, {integer street_name}]...\",\n                str(pp.delimitedList(street_address)),\n            )\n\n        with self.subTest():\n            operand = pp.Char(pp.alphas).set_name(\"var\")\n            math = pp.infixNotation(\n                operand,\n                [\n                    (pp.one_of(\"+ -\"), 2, pp.opAssoc.LEFT),\n                ],\n            )\n            self.assertEqual(\n                \"Forward: + | - term [, Forward: + | - term]...\",\n                str(pp.delimitedList(math)),\n            )\n\n    def testDelimitedListOfStrLiterals(self):\n        expr = pp.delimitedList(\"ABC\")\n        print(str(expr))\n        source = \"ABC, ABC,ABC\"\n        self.assertParseAndCheckList(\n            expr, source, [s.strip() for s in source.split(\",\")]\n        )\n\n    def testDelimitedListMinMax(self):\n        source = \"ABC, ABC,ABC\"\n        with self.assertRaises(ValueError, msg=\"min must be greater than 0\"):\n            pp.delimited_list(\"ABC\", min=0)\n        with self.assertRaises(\n            ValueError, msg=\"max must be greater than, or equal to min\"\n        ):\n            pp.delimited_list(\"ABC\", min=1, max=0)\n        with self.assertRaises(pp.ParseException):\n            pp.delimited_list(\"ABC\", min=4).parse_string(source)\n\n        source_expr_pairs = [\n            (\"ABC,  ABC\", pp.delimited_list(\"ABC\", max=2)),\n            (source, pp.delimited_list(\"ABC\", min=2, max=4)),\n        ]\n        for source, expr in source_expr_pairs:\n            print(str(expr))\n            self.assertParseAndCheckList(\n                expr, source, [s.strip() for s in source.split(\",\")]\n            )\n\n    def testDelimitedListParseActions1(self):\n        # from issue #408\n        keyword = pp.Keyword(\"foobar\")\n        untyped_identifier = ~keyword + pp.Word(pp.alphas)\n        dotted_vars = pp.delimited_list(untyped_identifier, delim=\".\")\n        lvalue = pp.Opt(dotted_vars)\n\n        # uncomment this line to see the problem\n        stmt = pp.delimited_list(pp.Opt(dotted_vars))\n        # stmt = delimited_list(dotted_vars)\n        # stmt = pp.Opt(dotted_vars)\n\n        def parse_identifier(toks):\n            print(\"YAY!\", toks)\n\n        untyped_identifier.set_parse_action(parse_identifier)\n\n        save_stdout = StringIO()\n        with contextlib.redirect_stdout(save_stdout):\n            dotted_vars.parse_string(\"B.C\")\n\n        self.assertEqual(\n            dedent(\n                \"\"\"\\\n                YAY! ['B']\n                YAY! ['C']\n                \"\"\"\n            ),\n            save_stdout.getvalue(),\n        )\n\n    def testDelimitedListParseActions2(self):\n        # from issue #408\n        keyword = pp.Keyword(\"foobar\")\n        untyped_identifier = ~keyword + pp.Word(pp.alphas)\n        dotted_vars = pp.delimited_list(untyped_identifier, delim=\".\")\n        lvalue = pp.Opt(dotted_vars)\n\n        # uncomment this line to see the problem\n        # stmt = delimited_list(Opt(dotted_vars))\n        stmt = pp.delimited_list(dotted_vars)\n        # stmt = pp.Opt(dotted_vars)\n\n        def parse_identifier(toks):\n            print(\"YAY!\", toks)\n\n        untyped_identifier.set_parse_action(parse_identifier)\n\n        save_stdout = StringIO()\n        with contextlib.redirect_stdout(save_stdout):\n            dotted_vars.parse_string(\"B.C\")\n\n        self.assertEqual(\n            dedent(\n                \"\"\"\\\n                YAY! ['B']\n                YAY! ['C']\n                \"\"\"\n            ),\n            save_stdout.getvalue(),\n        )\n\n    def testDelimitedListParseActions3(self):\n        # from issue #408\n        keyword = pp.Keyword(\"foobar\")\n        untyped_identifier = ~keyword + pp.Word(pp.alphas)\n        dotted_vars = pp.delimited_list(untyped_identifier, delim=\".\")\n        lvalue = pp.Opt(dotted_vars)\n\n        # uncomment this line to see the problem\n        # stmt = delimited_list(Opt(dotted_vars))\n        # stmt = delimited_list(dotted_vars)\n        stmt = pp.Opt(dotted_vars)\n\n        def parse_identifier(toks):\n            print(\"YAY!\", toks)\n\n        untyped_identifier.set_parse_action(parse_identifier)\n\n        save_stdout = StringIO()\n        with contextlib.redirect_stdout(save_stdout):\n            dotted_vars.parse_string(\"B.C\")\n\n        self.assertEqual(\n            dedent(\n                \"\"\"\\\n                YAY! ['B']\n                YAY! ['C']\n                \"\"\"\n            ),\n            save_stdout.getvalue(),\n        )\n\n    def testEnableDebugOnNamedExpressions(self):\n        \"\"\"\n        - enable_debug_on_named_expressions - flag to auto-enable debug on all subsequent\n          calls to ParserElement.setName() (default=False)\n        \"\"\"\n        with ppt.reset_pyparsing_context():\n            test_stdout = StringIO()\n\n            with resetting(sys, \"stdout\", \"stderr\"):\n                sys.stdout = test_stdout\n                sys.stderr = test_stdout\n\n                pp.enable_diag(pp.Diagnostics.enable_debug_on_named_expressions)\n                integer = pp.Word(pp.nums).setName(\"integer\")\n\n                integer[...].parseString(\"1 2 3\", parseAll=True)\n\n            expected_debug_output = dedent(\n                \"\"\"\\\n                Match integer at loc 0(1,1)\n                  1 2 3\n                  ^\n                Matched integer -> ['1']\n                Match integer at loc 2(1,3)\n                  1 2 3\n                    ^\n                Matched integer -> ['2']\n                Match integer at loc 4(1,5)\n                  1 2 3\n                      ^\n                Matched integer -> ['3']\n                Match integer at loc 5(1,6)\n                  1 2 3\n                       ^\n                Match integer failed, ParseException raised: Expected integer, found end of text  (at char 5), (line:1, col:6)\n                \"\"\"\n            )\n            output = test_stdout.getvalue()\n            print(output)\n            self.assertEqual(\n                expected_debug_output,\n                output,\n                \"failed to auto-enable debug on named expressions \"\n                \"using enable_debug_on_named_expressions\",\n            )\n\n    def testEnableDebugOnExpressionWithParseAction(self):\n        test_stdout = StringIO()\n        with resetting(sys, \"stdout\", \"stderr\"):\n            sys.stdout = test_stdout\n            sys.stderr = test_stdout\n\n            parser = (ppc.integer().setDebug() | pp.Word(pp.alphanums).setDebug())[...]\n            parser.setDebug()\n            parser.parseString(\"123 A100\", parseAll=True)\n\n            # now turn off debug - should only get output for components, not overall parser\n            print()\n            parser.setDebug(False)\n            parser.parseString(\"123 A100\", parseAll=True)\n\n        expected_debug_output = dedent(\n            \"\"\"\\\n            Match [{integer | W:(0-9A-Za-z)}]... at loc 0(1,1)\n              123 A100\n              ^\n            Match integer at loc 0(1,1)\n              123 A100\n              ^\n            Matched integer -> [123]\n            Match integer at loc 4(1,5)\n              123 A100\n                  ^\n            Match integer failed, ParseException raised: Expected integer, found 'A100'  (at char 4), (line:1, col:5)\n            Match W:(0-9A-Za-z) at loc 4(1,5)\n              123 A100\n                  ^\n            Matched W:(0-9A-Za-z) -> ['A100']\n            Match integer at loc 8(1,9)\n              123 A100\n                      ^\n            Match integer failed, ParseException raised: Expected integer, found end of text  (at char 8), (line:1, col:9)\n            Match W:(0-9A-Za-z) at loc 8(1,9)\n              123 A100\n                      ^\n            Match W:(0-9A-Za-z) failed, ParseException raised: Expected W:(0-9A-Za-z), found end of text  (at char 8), (line:1, col:9)\n            Matched [{integer | W:(0-9A-Za-z)}]... -> [123, 'A100']\n            \n            Match integer at loc 0(1,1)\n              123 A100\n              ^\n            Matched integer -> [123]\n            Match integer at loc 4(1,5)\n              123 A100\n                  ^\n            Match integer failed, ParseException raised: Expected integer, found 'A100'  (at char 4), (line:1, col:5)\n            Match W:(0-9A-Za-z) at loc 4(1,5)\n              123 A100\n                  ^\n            Matched W:(0-9A-Za-z) -> ['A100']\n            Match integer at loc 8(1,9)\n              123 A100\n                      ^\n            Match integer failed, ParseException raised: Expected integer, found end of text  (at char 8), (line:1, col:9)\n            Match W:(0-9A-Za-z) at loc 8(1,9)\n              123 A100\n                      ^\n            Match W:(0-9A-Za-z) failed, ParseException raised: Expected W:(0-9A-Za-z), found end of text  (at char 8), (line:1, col:9)\n            \"\"\"\n        )\n        output = test_stdout.getvalue()\n        print(output)\n        self.assertEqual(\n            expected_debug_output,\n            output,\n            \"invalid debug output when using parse action\",\n        )\n\n    def testEnableDebugWithCachedExpressionsMarkedWithAsterisk(self):\n        a = pp.Literal(\"a\").setName(\"A\").setDebug()\n        b = pp.Literal(\"b\").setName(\"B\").setDebug()\n        z = pp.Literal(\"z\").setName(\"Z\").setDebug()\n        leading_a = a + pp.FollowedBy(z | a | b)\n        leading_a.setName(\"leading_a\").setDebug()\n\n        grammar = (z | leading_a | b)[...] + \"a\"\n\n        # parse test string and capture debug output\n        test_stdout = StringIO()\n        with resetting(sys, \"stdout\", \"stderr\"):\n            sys.stdout = test_stdout\n            sys.stderr = test_stdout\n            grammar.parseString(\"aba\", parseAll=True)\n\n        expected_debug_output = dedent(\n            \"\"\"\\\n            Match Z at loc 0(1,1)\n              aba\n              ^\n            Match Z failed, ParseException raised: Expected Z, found 'aba'  (at char 0), (line:1, col:1)\n            Match leading_a at loc 0(1,1)\n              aba\n              ^\n            Match A at loc 0(1,1)\n              aba\n              ^\n            Matched A -> ['a']\n            Match Z at loc 1(1,2)\n              aba\n               ^\n            Match Z failed, ParseException raised: Expected Z, found 'ba'  (at char 1), (line:1, col:2)\n            Match A at loc 1(1,2)\n              aba\n               ^\n            Match A failed, ParseException raised: Expected A, found 'ba'  (at char 1), (line:1, col:2)\n            Match B at loc 1(1,2)\n              aba\n               ^\n            Matched B -> ['b']\n            Matched leading_a -> ['a']\n            *Match Z at loc 1(1,2)\n              aba\n               ^\n            *Match Z failed, ParseException raised: Expected Z, found 'ba'  (at char 1), (line:1, col:2)\n            Match leading_a at loc 1(1,2)\n              aba\n               ^\n            Match A at loc 1(1,2)\n              aba\n               ^\n            Match A failed, ParseException raised: Expected A, found 'ba'  (at char 1), (line:1, col:2)\n            Match leading_a failed, ParseException raised: Expected A, found 'ba'  (at char 1), (line:1, col:2)\n            *Match B at loc 1(1,2)\n              aba\n               ^\n            *Matched B -> ['b']\n            Match Z at loc 2(1,3)\n              aba\n                ^\n            Match Z failed, ParseException raised: Expected Z, found 'a'  (at char 2), (line:1, col:3)\n            Match leading_a at loc 2(1,3)\n              aba\n                ^\n            Match A at loc 2(1,3)\n              aba\n                ^\n            Matched A -> ['a']\n            Match Z at loc 3(1,4)\n              aba\n                 ^\n            Match Z failed, ParseException raised: Expected Z, found end of text  (at char 3), (line:1, col:4)\n            Match A at loc 3(1,4)\n              aba\n                 ^\n            Match A failed, ParseException raised: Expected A, found end of text  (at char 3), (line:1, col:4)\n            Match B at loc 3(1,4)\n              aba\n                 ^\n            Match B failed, ParseException raised: Expected B, found end of text  (at char 3), (line:1, col:4)\n            Match leading_a failed, ParseException raised: Expected {Z | A | B}, found end of text  (at char 3), (line:1, col:4)\n            Match B at loc 2(1,3)\n              aba\n                ^\n            Match B failed, ParseException raised: Expected B, found 'a'  (at char 2), (line:1, col:3)\n            \"\"\"\n        )\n        if pp.ParserElement._packratEnabled:\n            packrat_status = \"enabled\"\n        else:\n            # remove '*' cache markers from expected output\n            expected_debug_output = expected_debug_output.replace(\"*\", \"\")\n            packrat_status = \"disabled\"\n        print(\"Packrat status:\", packrat_status)\n\n        output = test_stdout.getvalue()\n        print(output)\n        self.assertEqual(\n            expected_debug_output,\n            output,\n            (\n                f\"invalid debug output showing cached results marked with '*',\"\n                f\" and packrat parsing {packrat_status}\"\n            ),\n        )\n\n    def testSetDebugRecursively(self):\n        expr = pp.Word(pp.alphas)\n        contained = expr + pp.Empty().set_name(\"innermost\")\n        depth = 4\n        for _ in range(depth):\n            contained = pp.Group(contained + pp.Empty())\n        contained.set_debug(recurse=True)\n        self.assertTrue(expr.debug)\n        # contained.parse_string(\"ABC\")\n        test_stdout = StringIO()\n        with resetting(sys, \"stdout\", \"stderr\"):\n            sys.stdout = test_stdout\n            sys.stderr = test_stdout\n            contained.parseString(\"aba\", parseAll=True)\n\n        output = test_stdout.getvalue()\n        print(output)\n        self.assertEqual(depth, output.count(\"Matched Empty -> []\"))\n        self.assertEqual(1, output.count(\"Matched innermost -> []\"))\n\n    def testSetDebugRecursivelyWithForward(self):\n        expr = pp.Word(pp.alphas).set_name(\"innermost\")\n        contained = pp.infix_notation(\n            expr,\n            [\n                (\"NOT\", 1, pp.opAssoc.RIGHT),\n                (\"AND\", 2, pp.opAssoc.LEFT),\n                (\"OR\", 2, pp.opAssoc.LEFT),\n            ],\n        )\n\n        contained.set_debug(recurse=True)\n        self.assertTrue(expr.debug)\n\n        # contained.parse_string(\"ABC\")\n        test_stdout = StringIO()\n        with resetting(sys, \"stdout\", \"stderr\"):\n            sys.stdout = test_stdout\n            sys.stderr = test_stdout\n            contained.parseString(\"aba\", parseAll=True)\n\n        output = test_stdout.getvalue()\n        print(output)\n        # count of matches varies with packrat state, can't match exact count, but at least test if contains\n        # self.assertEqual(4, output.count(\"Matched innermost -> ['aba']\"))\n        self.assertTrue(\"Matched innermost -> ['aba']\" in output)\n\n    def testUndesirableButCommonPractices(self):\n        # While these are valid constructs, and they are not encouraged\n        # there is apparently a lot of code out there using these\n        # coding styles.\n        #\n        # Even though they are not encouraged, we shouldn't break them.\n\n        # Create an And using a list of expressions instead of using '+' operator\n        expr = pp.And([pp.Word(\"abc\"), pp.Word(\"123\")])\n        expr.runTests(\n            \"\"\"\n            aaa 333\n            b 1\n            ababab 32123\n        \"\"\"\n        )\n\n        # Passing a single expression to a ParseExpression, when it really wants a sequence\n        expr = pp.Or(pp.Or(ppc.integer))\n        expr.runTests(\n            \"\"\"\n            123\n            456\n            abc\n        \"\"\"\n        )\n\n    def testEnableWarnDiags(self):\n        import pprint\n\n        def filtered_vars(var_dict):\n            dunders = [nm for nm in var_dict if nm.startswith(\"__\")]\n            return {\n                k: v\n                for k, v in var_dict.items()\n                if isinstance(v, bool) and k not in dunders\n            }\n\n        pprint.pprint(filtered_vars(vars(pp.__diag__)), width=30)\n\n        warn_names = pp.__diag__._warning_names\n        other_names = pp.__diag__._debug_names\n\n        # make sure they are off by default\n        for diag_name in warn_names:\n            self.assertFalse(\n                getattr(pp.__diag__, diag_name),\n                f\"__diag__.{diag_name} not set to True\",\n            )\n\n        with ppt.reset_pyparsing_context():\n            # enable all warn_* diag_names\n            pp.enable_all_warnings()\n            pprint.pprint(filtered_vars(vars(pp.__diag__)), width=30)\n\n            # make sure they are on after being enabled\n            for diag_name in warn_names:\n                self.assertTrue(\n                    getattr(pp.__diag__, diag_name),\n                    f\"__diag__.{diag_name} not set to True\",\n                )\n\n            # non-warn diag_names must be enabled individually\n            for diag_name in other_names:\n                self.assertFalse(\n                    getattr(pp.__diag__, diag_name),\n                    f\"__diag__.{diag_name} not set to True\",\n                )\n\n        # make sure they are off after AutoReset\n        for diag_name in warn_names:\n            self.assertFalse(\n                getattr(pp.__diag__, diag_name),\n                f\"__diag__.{diag_name} not set to True\",\n            )\n\n    def testWordInternalReRangeWithConsecutiveChars(self):\n        self.assertParseAndCheckList(\n            pp.Word(\"ABCDEMNXYZ\"),\n            \"ABCDEMNXYZABCDEMNXYZABCDEMNXYZ\",\n            [\"ABCDEMNXYZABCDEMNXYZABCDEMNXYZ\"],\n        )\n\n    def testWordInternalReRangesKnownSet(self):\n        tests = [\n            (\"ABCDEMNXYZ\", \"[A-EMNX-Z]+\"),\n            (pp.printables, \"[!-~]+\"),\n            (pp.alphanums, \"[0-9A-Za-z]+\"),\n            (pp.pyparsing_unicode.Latin1.printables, \"[!-~\u00a1-\u00ff]+\"),\n            (pp.pyparsing_unicode.Latin1.alphanums, \"[0-9A-Za-z\u00aa\u00b2\u00b3\u00b5\u00b9\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+\"),\n            (pp.alphas8bit, \"[\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+\"),\n        ]\n        failed = []\n        for word_string, expected_re in tests:\n            try:\n                msg = f\"failed to generate correct internal re for {word_string!r}\"\n                resultant_re = pp.Word(word_string).reString\n                self.assertEqual(\n                    expected_re,\n                    resultant_re,\n                    msg + f\"; expected {expected_re!r} got {resultant_re!r}\",\n                )\n            except AssertionError:\n                failed.append(msg)\n\n        if failed:\n            print(\"Errors:\\n{}\".format(\"\\n\".join(failed)))\n            self.fail(\"failed to generate correct internal re's\")\n\n    def testWordInternalReRanges(self):\n        import random\n\n        esc_chars = r\"\\^-][\"\n        esc_chars2 = r\"*+.?\"\n\n        def esc_re_set_char(c):\n            return \"\\\\\" + c if c in esc_chars else c\n\n        def esc_re_set2_char(c):\n            return \"\\\\\" + c if c in esc_chars + esc_chars2 else c\n\n        for esc_char in esc_chars + esc_chars2:\n            # test escape char as first character in range\n            next_char = chr(ord(esc_char) + 1)\n            prev_char = chr(ord(esc_char) - 1)\n            esc_word = pp.Word(esc_char + next_char)\n            expected = rf\"[{esc_re_set_char(esc_char)}{esc_re_set_char(next_char)}]+\"\n            print(\n                f\"Testing escape char: {esc_char} -> {esc_word} re: '{esc_word.reString}')\"\n            )\n            self.assertEqual(\n                expected, esc_word.reString, \"failed to generate correct internal re\"\n            )\n            test_string = \"\".join(\n                random.choice([esc_char, next_char]) for __ in range(16)\n            )\n            print(\n                f\"Match '{test_string}' -> {test_string == esc_word.parseString(test_string, parseAll=True)[0]}\"\n            )\n            self.assertEqual(\n                test_string,\n                esc_word.parseString(test_string, parseAll=True)[0],\n                \"Word using escaped range char failed to parse\",\n            )\n\n            # test escape char as last character in range\n            esc_word = pp.Word(prev_char + esc_char)\n            expected = rf\"[{esc_re_set_char(prev_char)}{esc_re_set_char(esc_char)}]+\"\n            print(\n                f\"Testing escape char: {esc_char} -> {esc_word} re: '{esc_word.reString}')\"\n            )\n            self.assertEqual(\n                expected, esc_word.reString, \"failed to generate correct internal re\"\n            )\n            test_string = \"\".join(\n                random.choice([esc_char, prev_char]) for __ in range(16)\n            )\n            print(\n                f\"Match '{test_string}' -> {test_string == esc_word.parseString(test_string, parseAll=True)[0]}\"\n            )\n            self.assertEqual(\n                test_string,\n                esc_word.parseString(test_string, parseAll=True)[0],\n                \"Word using escaped range char failed to parse\",\n            )\n\n            # test escape char as first character in range\n            next_char = chr(ord(esc_char) + 1)\n            prev_char = chr(ord(esc_char) - 1)\n            esc_word = pp.Word(esc_char + next_char)\n            expected = rf\"[{esc_re_set_char(esc_char)}{esc_re_set_char(next_char)}]+\"\n            print(\n                f\"Testing escape char: {esc_char} -> {esc_word} re: '{esc_word.reString}')\"\n            )\n            self.assertEqual(\n                expected, esc_word.reString, \"failed to generate correct internal re\"\n            )\n            test_string = \"\".join(\n                random.choice([esc_char, next_char]) for __ in range(16)\n            )\n            print(\n                f\"Match '{test_string}' -> {test_string == esc_word.parseString(test_string, parseAll=True)[0]}\"\n            )\n            self.assertEqual(\n                test_string,\n                esc_word.parseString(test_string, parseAll=True)[0],\n                \"Word using escaped range char failed to parse\",\n            )\n\n            # test escape char as only character in range\n            esc_word = pp.Word(esc_char, pp.alphas.upper())\n            expected = rf\"{esc_re_set2_char(esc_char)}[A-Z]*\"\n            print(\n                f\"Testing escape char: {esc_char} -> {esc_word} re: '{esc_word.reString}')\"\n            )\n            self.assertEqual(\n                expected, esc_word.reString, \"failed to generate correct internal re\"\n            )\n            test_string = esc_char + \"\".join(\n                random.choice(pp.alphas.upper()) for __ in range(16)\n            )\n            print(\n                f\"Match '{test_string}' -> {test_string == esc_word.parseString(test_string, parseAll=True)[0]}\"\n            )\n            self.assertEqual(\n                test_string,\n                esc_word.parseString(test_string, parseAll=True)[0],\n                \"Word using escaped range char failed to parse\",\n            )\n\n            # test escape char as only character\n            esc_word = pp.Word(esc_char, pp.alphas.upper())\n            expected = rf\"{re.escape(esc_char)}[A-Z]*\"\n            print(\n                f\"Testing escape char: {esc_char} -> {esc_word} re: '{esc_word.reString}')\"\n            )\n            self.assertEqual(\n                expected, esc_word.reString, \"failed to generate correct internal re\"\n            )\n            test_string = esc_char + \"\".join(\n                random.choice(pp.alphas.upper()) for __ in range(16)\n            )\n            print(\n                f\"Match '{test_string}' -> {test_string == esc_word.parseString(test_string, parseAll=True)[0]}\"\n            )\n            self.assertEqual(\n                test_string,\n                esc_word.parseString(test_string, parseAll=True)[0],\n                \"Word using escaped range char failed to parse\",\n            )\n            print()\n\n    def testWordWithIdentChars(self):\n        ppu = pp.pyparsing_unicode\n\n        latin_identifier = pp.Word(pp.identchars, pp.identbodychars)(\"latin*\")\n        japanese_identifier = ppu.Japanese.identifier(\"japanese*\")\n        cjk_identifier = ppu.CJK.identifier(\"cjk*\")\n        greek_identifier = ppu.Greek.identifier(\"greek*\")\n        cyrillic_identifier = ppu.Cyrillic.identifier(\"cyrillic*\")\n        thai_identifier = ppu.Thai.identifier(\"thai*\")\n        idents = (\n            latin_identifier\n            | japanese_identifier\n            | cjk_identifier  # must follow japanese_identifier, since CJK is superset\n            | thai_identifier\n            | greek_identifier\n            | cyrillic_identifier\n        )\n\n        result = idents[...].parseString(\n            \"abc_100 \u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430x_10 \u65e5\u672c\u8a9ef_300 \u0e44\u0e17\u0e22g_600 def_200 \u6f22\u5b57y_300 \ud55c\uad6d\uc5b4_\u4e2d\u6587c_400 \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03acb_500\",\n            parseAll=True,\n        )\n        self.assertParseResultsEquals(\n            result,\n            [\n                \"abc_100\",\n                \"\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430x_10\",\n                \"\u65e5\u672c\u8a9ef_300\",\n                \"\u0e44\u0e17\u0e22g_600\",\n                \"def_200\",\n                \"\u6f22\u5b57y_300\",\n                \"\ud55c\uad6d\uc5b4_\u4e2d\u6587c_400\",\n                \"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03acb_500\",\n            ],\n            {\n                \"cjk\": [\"\ud55c\uad6d\uc5b4_\u4e2d\u6587c_400\"],\n                \"cyrillic\": [\"\u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430x_10\"],\n                \"greek\": [\"\u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03acb_500\"],\n                \"japanese\": [\"\u65e5\u672c\u8a9ef_300\", \"\u6f22\u5b57y_300\"],\n                \"latin\": [\"abc_100\", \"def_200\"],\n                \"thai\": [\"\u0e44\u0e17\u0e22g_600\"],\n            },\n        )\n\n    def testChainedTernaryOperator(self):\n        # fmt: off\n        TERNARY_INFIX = pp.infixNotation(\n            ppc.integer,\n            [\n                ((\"?\", \":\"), 3, pp.opAssoc.LEFT),\n            ]\n        )\n        self.assertParseAndCheckList(\n            TERNARY_INFIX, \"1?1:0?1:0\", [[1, \"?\", 1, \":\", 0, \"?\", 1, \":\", 0]]\n        )\n\n        TERNARY_INFIX = pp.infixNotation(\n            ppc.integer,\n            [\n                ((\"?\", \":\"), 3, pp.opAssoc.RIGHT),\n            ]\n        )\n        self.assertParseAndCheckList(\n            TERNARY_INFIX, \"1?1:0?1:0\", [[1, \"?\", 1, \":\", [0, \"?\", 1, \":\", 0]]]\n        )\n        # fmt: on\n\n    def testOneOfWithDuplicateSymbols(self):\n        # test making oneOf with duplicate symbols\n        print(\"verify oneOf handles duplicate symbols\")\n        try:\n            test1 = pp.oneOf(\"a b c d a\")\n        except RuntimeError:\n            self.fail(\n                \"still have infinite loop in oneOf with duplicate symbols (string input)\"\n            )\n\n        print(\"verify oneOf handles generator input\")\n        try:\n            test1 = pp.oneOf(c for c in \"a b c d a\" if not c.isspace())\n        except RuntimeError:\n            self.fail(\n                \"still have infinite loop in oneOf with duplicate symbols (generator input)\"\n            )\n\n        print(\"verify oneOf handles list input\")\n        try:\n            test1 = pp.oneOf(\"a b c d a\".split())\n        except RuntimeError:\n            self.fail(\n                \"still have infinite loop in oneOf with duplicate symbols (list input)\"\n            )\n\n        print(\"verify oneOf handles set input\")\n        try:\n            test1 = pp.oneOf(set(\"a b c d a\"))\n        except RuntimeError:\n            self.fail(\n                \"still have infinite loop in oneOf with duplicate symbols (set input)\"\n            )\n\n    def testOneOfWithEmptyList(self):\n        \"\"\"test oneOf helper function with an empty list as input\"\"\"\n\n        tst = []\n        result = pp.oneOf(tst)\n\n        expected = True\n        found = isinstance(result, pp.NoMatch)\n        self.assertEqual(expected, found)\n\n    def testOneOfWithUnexpectedInput(self):\n        \"\"\"test oneOf with an input that isn't a string or iterable\"\"\"\n\n        with self.assertRaises(\n            TypeError, msg=\"failed to warn use of integer for oneOf\"\n        ):\n            expr = pp.oneOf(6)\n\n    def testMatchFirstIteratesOverAllChoices(self):\n        # test MatchFirst bugfix\n        print(\"verify MatchFirst iterates properly\")\n        results = pp.quotedString.parseString(\n            \"'this is a single quoted string'\", parseAll=True\n        )\n        self.assertTrue(\n            len(results) > 0, \"MatchFirst error - not iterating over all choices\"\n        )\n\n    def testStreamlineOfExpressionsAfterSetName(self):\n        bool_constant = pp.Literal(\"True\") | \"true\" | \"False\" | \"false\"\n        self.assertEqual(\n            \"{'True' | 'true' | 'False' | 'false'}\", str(bool_constant.streamline())\n        )\n        bool_constant.setName(\"bool\")\n        self.assertEqual(\"bool\", str(bool_constant.streamline()))\n\n    def testStreamlineOfSubexpressions(self):\n        # verify streamline of subexpressions\n        print(\"verify proper streamline logic\")\n        compound = pp.Literal(\"A\") + \"B\" + \"C\" + \"D\"\n        self.assertEqual(2, len(compound.exprs), \"bad test setup\")\n        print(compound)\n        compound.streamline()\n        print(compound)\n        self.assertEqual(4, len(compound.exprs), \"streamline not working\")\n\n    def testOptionalWithResultsNameAndNoMatch(self):\n        # test for Optional with results name and no match\n        print(\"verify Optional's do not cause match failure if have results name\")\n        testGrammar = pp.Literal(\"A\") + pp.Optional(\"B\")(\"gotB\") + pp.Literal(\"C\")\n        try:\n            testGrammar.parseString(\"ABC\", parseAll=True)\n            testGrammar.parseString(\"AC\", parseAll=True)\n        except pp.ParseException as pe:\n            print(pe.pstr, \"->\", pe)\n            self.fail(f\"error in Optional matching of string {pe.pstr}\")\n\n    def testReturnOfFurthestException(self):\n        # test return of furthest exception\n        testGrammar = (\n            pp.Literal(\"A\") | (pp.Literal(\"B\") + pp.Literal(\"C\")) | pp.Literal(\"E\")\n        )\n        try:\n            testGrammar.parseString(\"BC\", parseAll=True)\n            testGrammar.parseString(\"BD\", parseAll=True)\n        except pp.ParseException as pe:\n            print(pe.pstr, \"->\", pe)\n            self.assertEqual(\"BD\", pe.pstr, \"wrong test string failed to parse\")\n            self.assertEqual(\n                1, pe.loc, \"error in Optional matching, pe.loc=\" + str(pe.loc)\n            )\n            self.assertTrue(\n                \"found 'D'\" in str(pe), \"wrong alternative raised exception\"\n            )\n\n    def testValidateCorrectlyDetectsInvalidLeftRecursion(self):\n        # test validate\n        print(\"verify behavior of validate()\")\n        if IRON_PYTHON_ENV:\n            print(\"disable this test under IronPython\")\n            return\n\n        def testValidation(grmr, gnam, isValid):\n            try:\n                grmr.streamline()\n                with self.assertWarns(\n                    DeprecationWarning, msg=\"failed to warn validate() is deprecated\"\n                ):\n                    grmr.validate()\n                self.assertTrue(isValid, \"validate() accepted invalid grammar \" + gnam)\n            except pp.RecursiveGrammarException as rge:\n                print(grmr)\n                print(rge)\n                self.assertFalse(isValid, \"validate() rejected valid grammar \" + gnam)\n\n        fwd = pp.Forward()\n        g1 = pp.OneOrMore((pp.Literal(\"A\") + \"B\" + \"C\") | fwd)\n        g2 = (\"C\" + g1)[...]\n        fwd <<= pp.Group(g2)\n        testValidation(fwd, \"fwd\", isValid=True)\n\n        fwd2 = pp.Forward()\n        fwd2 <<= pp.Group(\"A\" | fwd2)\n        testValidation(fwd2, \"fwd2\", isValid=False)\n\n        fwd3 = pp.Forward()\n        fwd3 <<= pp.Optional(\"A\") + fwd3\n        testValidation(fwd3, \"fwd3\", isValid=False)\n\n    def testGetNameBehavior(self):\n        # test getName\n        print(\"verify behavior of getName()\")\n        aaa = pp.Group(pp.Word(\"a\")(\"A\"))\n        bbb = pp.Group(pp.Word(\"b\")(\"B\"))\n        ccc = pp.Group(\":\" + pp.Word(\"c\")(\"C\"))\n        g1 = \"XXX\" + (aaa | bbb | ccc)[...]\n        teststring = \"XXX b bb a bbb bbbb aa bbbbb :c bbbbbb aaa\"\n        names = []\n        print(g1.parseString(teststring, parseAll=True).dump())\n        for t in g1.parseString(teststring, parseAll=True):\n            print(t, repr(t))\n            try:\n                names.append(t[0].getName())\n            except Exception:\n                try:\n                    names.append(t.getName())\n                except Exception:\n                    names.append(None)\n        print(teststring)\n        print(names)\n        self.assertEqual(\n            [None, \"B\", \"B\", \"A\", \"B\", \"B\", \"A\", \"B\", None, \"B\", \"A\"],\n            names,\n            \"failure in getting names for tokens\",\n        )\n\n        IF, AND, BUT = map(pp.Keyword, \"if and but\".split())\n        ident = ~(IF | AND | BUT) + pp.Word(pp.alphas)(\"non-key\")\n        scanner = pp.OneOrMore(IF | AND | BUT | ident)\n\n        def getNameTester(s, l, t):\n            print(t, t.getName())\n\n        ident.addParseAction(getNameTester)\n        scanner.parseString(\"lsjd sldkjf IF Saslkj AND lsdjf\", parseAll=True)\n\n        # test ParseResults.get() method\n        print(\"verify behavior of ParseResults.get()\")\n        # use sum() to merge separate groups into single ParseResults\n        res = sum(g1.parseString(teststring, parseAll=True)[1:])\n        print(res.dump())\n        print(res.get(\"A\", \"A not found\"))\n        print(res.get(\"D\", \"!D\"))\n        self.assertEqual(\n            \"aaa\", res.get(\"A\", \"A not found\"), \"get on existing key failed\"\n        )\n        self.assertEqual(\"!D\", res.get(\"D\", \"!D\"), \"get on missing key failed\")\n\n    def testOptionalBeyondEndOfString(self):\n        print(\"verify handling of Optional's beyond the end of string\")\n        testGrammar = \"A\" + pp.Optional(\"B\") + pp.Optional(\"C\") + pp.Optional(\"D\")\n        testGrammar.parseString(\"A\", parseAll=True)\n        testGrammar.parseString(\"AB\", parseAll=True)\n\n    def testCreateLiteralWithEmptyString(self):\n        # test creating Literal with empty string\n        print('verify that Literal(\"\") is optimized to Empty()')\n        e = pp.Literal(\"\")\n        self.assertIsInstance(e, pp.Empty)\n\n    def testLineMethodSpecialCaseAtStart(self):\n        # test line() behavior when starting at 0 and the opening line is an \\n\n        print(\"verify correct line() behavior when first line is empty string\")\n        self.assertEqual(\n            \"\",\n            pp.line(0, \"\\nabc\\ndef\\n\"),\n            \"Error in line() with empty first line in text\",\n        )\n        txt = \"\\nabc\\ndef\\n\"\n        results = [pp.line(i, txt) for i in range(len(txt))]\n        self.assertEqual(\n            [\"\", \"abc\", \"abc\", \"abc\", \"abc\", \"def\", \"def\", \"def\", \"def\"],\n            results,\n            \"Error in line() with empty first line in text\",\n        )\n        txt = \"abc\\ndef\\n\"\n        results = [pp.line(i, txt) for i in range(len(txt))]\n        self.assertEqual(\n            [\"abc\", \"abc\", \"abc\", \"abc\", \"def\", \"def\", \"def\", \"def\"],\n            results,\n            \"Error in line() with non-empty first line in text\",\n        )\n\n    def testRepeatedTokensWhenPackratting(self):\n        # test bugfix with repeated tokens when packrat parsing enabled\n        print(\"verify behavior with repeated tokens when packrat parsing is enabled\")\n        a = pp.Literal(\"a\")\n        b = pp.Literal(\"b\")\n        c = pp.Literal(\"c\")\n\n        abb = a + b + b\n        abc = a + b + c\n        aba = a + b + a\n        grammar = abb | abc | aba\n\n        self.assertEqual(\n            \"aba\",\n            \"\".join(grammar.parseString(\"aba\", parseAll=True)),\n            \"Packrat ABA failure!\",\n        )\n\n    def testSetResultsNameWithOneOrMoreAndZeroOrMore(self):\n        print(\"verify behavior of setResultsName with OneOrMore and ZeroOrMore\")\n        stmt = pp.Keyword(\"test\")\n        print(stmt[...](\"tests\").parseString(\"test test\", parseAll=True).tests)\n        print(stmt[1, ...](\"tests\").parseString(\"test test\", parseAll=True).tests)\n        print(\n            pp.Optional(stmt[1, ...](\"tests\"))\n            .parseString(\"test test\", parseAll=True)\n            .tests\n        )\n        print(\n            pp.Optional(stmt[1, ...])(\"tests\")\n            .parseString(\"test test\", parseAll=True)\n            .tests\n        )\n        print(\n            pp.Optional(pp.delimitedList(stmt))(\"tests\")\n            .parseString(\"test,test\", parseAll=True)\n            .tests\n        )\n        self.assertEqual(\n            2,\n            len(stmt[...](\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"ZeroOrMore failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(stmt[1, ...](\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"OneOrMore failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(\n                pp.Optional(stmt[1, ...](\"tests\"))\n                .parseString(\"test test\", parseAll=True)\n                .tests\n            ),\n            \"OneOrMore failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(\n                pp.Optional(pp.delimitedList(stmt))(\"tests\")\n                .parseString(\"test,test\", parseAll=True)\n                .tests\n            ),\n            \"delimitedList failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len((stmt * 2)(\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"multiplied(1) failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(stmt[..., 2](\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"multiplied(2) failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(stmt[1, ...](\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"multiplied(3) failure with setResultsName\",\n        )\n        self.assertEqual(\n            2,\n            len(stmt[2, ...](\"tests\").parseString(\"test test\", parseAll=True).tests),\n            \"multiplied(3) failure with setResultsName\",\n        )\n\n    def testParseResultsReprWithResultsNames(self):\n        word = pp.Word(pp.printables)(\"word\")\n        res = word[...].parseString(\"test blub\", parseAll=True)\n\n        print(repr(res))\n        print(res[\"word\"])\n        print(res.asDict())\n\n        self.assertEqual(\n            \"ParseResults(['test', 'blub'], {'word': 'blub'})\",\n            repr(res),\n            \"incorrect repr for ParseResults with listAllMatches=False\",\n        )\n\n        word = pp.Word(pp.printables)(\"word*\")\n        res = word[...].parseString(\"test blub\", parseAll=True)\n\n        print(repr(res))\n        print(res[\"word\"])\n        print(res.asDict())\n\n        self.assertEqual(\n            \"ParseResults(['test', 'blub'], {'word': ['test', 'blub']})\",\n            repr(res),\n            \"incorrect repr for ParseResults with listAllMatches=True\",\n        )\n\n    def testWarnUsingLshiftForward(self):\n        print(\n            \"verify that using '<<' operator with a Forward raises a warning if there is a dangling '|' operator\"\n        )\n\n        fwd = pp.Forward()\n        print(\"unsafe << and |, but diag not enabled, should not warn\")\n        fwd << pp.Word(\"a\") | pp.Word(\"b\")\n\n        pp.enable_diag(pp.Diagnostics.warn_on_match_first_with_lshift_operator)\n        with self.assertWarns(\n            UserWarning, msg=\"failed to warn of using << and | operators\"\n        ):\n            fwd = pp.Forward()\n            print(\"unsafe << and |, should warn\")\n            fwd << pp.Word(\"a\") | pp.Word(\"b\")\n\n        with self.assertWarns(\n            UserWarning,\n            msg=\"failed to warn of using << and | operators (within lambda)\",\n        ):\n            fwd = pp.Forward()\n            print(\"unsafe << and |, should warn\")\n            fwd_fn = lambda expr1, expr2: fwd << expr1 | expr2\n            fwd_fn(pp.Word(\"a\"), pp.Word(\"b\"))\n\n        fwd = pp.Forward()\n        print(\"safe <<= and |, should not warn\")\n        fwd <<= pp.Word(\"a\") | pp.Word(\"b\")\n        c = fwd | pp.Word(\"c\")\n\n        print(\"safe << and (|), should not warn\")\n        with self.assertDoesNotWarn(\n            \"warning raised on safe use of << with Forward and MatchFirst\"\n        ):\n            fwd = pp.Forward()\n            fwd << (pp.Word(\"a\") | pp.Word(\"b\"))\n            c = fwd | pp.Word(\"c\")\n\n    def testParseExpressionsWithRegex(self):\n        from itertools import product\n\n        match_empty_regex = pp.Regex(r\"[a-z]*\")\n        match_nonempty_regex = pp.Regex(r\"[a-z]+\")\n\n        parser_classes = pp.ParseExpression.__subclasses__()\n        test_string = \"abc def\"\n        expected = [\"abc\"]\n        for expr, cls in product(\n            (match_nonempty_regex, match_empty_regex), parser_classes\n        ):\n            print(expr, cls)\n            parser = cls([expr])\n            parsed_result = parser.parseString(test_string, parseAll=False)\n            print(parsed_result.dump())\n            self.assertParseResultsEquals(parsed_result, expected)\n\n        for expr, cls in product(\n            (match_nonempty_regex, match_empty_regex), (pp.MatchFirst, pp.Or)\n        ):\n            parser = cls([expr, expr])\n            print(parser)\n            parsed_result = parser.parseString(test_string, parseAll=False)\n            print(parsed_result.dump())\n            self.assertParseResultsEquals(parsed_result, expected)\n\n    def testAssertParseAndCheckDict(self):\n        \"\"\"test assertParseAndCheckDict in test framework\"\"\"\n\n        expr = pp.Word(pp.alphas)(\"item\") + pp.Word(pp.nums)(\"qty\")\n        self.assertParseAndCheckDict(\n            expr, \"balloon 25\", {\"item\": \"balloon\", \"qty\": \"25\"}\n        )\n\n        exprWithInt = pp.Word(pp.alphas)(\"item\") + ppc.integer(\"qty\")\n        self.assertParseAndCheckDict(\n            exprWithInt, \"rucksack 49\", {\"item\": \"rucksack\", \"qty\": 49}\n        )\n\n    def testOnlyOnce(self):\n        \"\"\"test class OnlyOnce and its reset method\"\"\"\n\n        # use a parse action to compute the sum of the parsed integers,\n        # and add it to the end\n        def append_sum(tokens):\n            tokens.append(sum(map(int, tokens)))\n\n        pa = pp.OnlyOnce(append_sum)\n        expr = pp.OneOrMore(pp.Word(pp.nums)).addParseAction(pa)\n\n        result = expr.parseString(\"0 123 321\", parseAll=True)\n        print(result.dump())\n        expected = [\"0\", \"123\", \"321\", 444]\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with OnlyOnce first call\"\n        )\n\n        with self.assertRaisesParseException(\n            msg=\"failed to raise exception calling OnlyOnce more than once\"\n        ):\n            result2 = expr.parseString(\"1 2 3 4 5\", parseAll=True)\n\n        pa.reset()\n        result = expr.parseString(\"100 200 300\")\n        print(result.dump())\n        expected = [\"100\", \"200\", \"300\", 600]\n        self.assertParseResultsEquals(\n            result, expected, msg=\"issue with OnlyOnce after reset\"\n        )\n\n    def testGoToColumn(self):\n        \"\"\"tests for GoToColumn class\"\"\"\n\n        dateExpr = pp.Regex(r\"\\d\\d(\\.\\d\\d){2}\")(\"date\")\n        numExpr = ppc.number(\"num\")\n\n        sample = \"\"\"\\\n            date                Not Important                         value    NotImportant2\n            11.11.13       |    useless . useless,21 useless 2     |  14.21  | asmdakldm\n            21.12.12       |    fmpaosmfpoamsp 4                   |  41     | ajfa9si90\"\"\".splitlines()\n\n        # Column number finds match\n        patt = dateExpr + pp.GoToColumn(70).ignore(\"|\") + numExpr + pp.restOfLine\n\n        infile = iter(sample)\n        next(infile)\n\n        expecteds = [[\"11.11.13\", 14.21], [\"21.12.12\", 41]]\n        for line, expected in zip(infile, expecteds):\n            result = patt.parseString(line, parseAll=True)\n            print(result)\n\n            self.assertEqual(\n                expected, [result.date, result.num], msg=\"issue with GoToColumn\"\n            )\n\n        # Column number does NOT match\n        patt = dateExpr(\"date\") + pp.GoToColumn(30) + numExpr + pp.restOfLine\n\n        infile = iter(sample)\n        next(infile)\n\n        for line in infile:\n            with self.assertRaisesParseException(\n                msg=\"issue with GoToColumn not finding match\"\n            ):\n                result = patt.parseString(line, parseAll=True)\n\n    def testExceptionExplainVariations(self):\n        class Modifier:\n            def modify_upper(self, tokens):\n                tokens[:] = map(str.upper, tokens)\n\n        modder = Modifier()\n\n        # force an exception in the attached parse action\n        # integer has a parse action to convert to an int;\n        # this parse action should fail with a TypeError, since\n        # str.upper expects a str argument, not an int\n        grammar = ppc.integer().addParseAction(modder.modify_upper)\n\n        self_testcase_name = \"tests.test_unit.\" + type(self).__name__\n\n        try:\n            grammar.parseString(\"1000\", parseAll=True)\n        except Exception as e:\n            # extract the exception explanation\n            explain_str = ParseException.explain_exception(e)\n            print(explain_str)\n            explain_str_lines = explain_str.splitlines()\n\n            expected = [\n                self_testcase_name,\n                \"pyparsing.core.Word - integer\",\n                \"tests.test_unit.Modifier\",\n                \"pyparsing.results.ParseResults\",\n            ]\n\n            # verify the list of names shown in the explain \"stack\"\n            self.assertEqual(\n                expected, explain_str_lines[-len(expected) :], msg=\"invalid explain str\"\n            )\n\n            # check type of raised exception matches explain output\n            # (actual exception text varies by Python version, and even\n            # by how the exception is raised, so we can only check the\n            # type name)\n            exception_line = explain_str_lines[-(len(expected) + 1)]\n            self.assertTrue(\n                exception_line.startswith(\"TypeError:\"),\n                msg=f\"unexpected exception line ({exception_line!r})\",\n            )\n\n    def testForwardReferenceException(self):\n        token = pp.Forward()\n        num = pp.Word(pp.nums)\n        num.setName(\"num\")\n        text = pp.Word(pp.alphas)\n        text.setName(\"text\")\n        fail = pp.Regex(r\"\\\\[A-Za-z]*\")(\"name\")\n\n        def parse_fail(s, loc, toks):\n            raise pp.ParseFatalException(s, loc, f\"Unknown symbol: {toks['name']}\")\n\n        fail.set_parse_action(parse_fail)\n        token <<= num | text | fail\n\n        # If no name is given, do not intercept error messages\n        with self.assertRaises(pp.ParseFatalException, msg=\"Unknown symbol: \\\\fail\"):\n            token.parse_string(\"\\\\fail\")\n\n        # If name is given, do intercept error messages\n        token.set_name(\"token\")\n        with self.assertRaises(pp.ParseFatalException, msg=\"Expected token, found.*\"):\n            token.parse_string(\"\\\\fail\")\n\n    def testForwardExceptionText(self):\n        wd = pp.Word(pp.alphas)\n\n        ff = pp.Forward().set_name(\"fffff!\")\n        ff <<= wd + pp.Opt(ff)\n\n        with self.assertRaises(pp.ParseFatalException, msg=\"no numbers!\"):\n            try:\n                ff.parse_string(\"123\")\n            except pp.ParseException as pe:\n                raise pp.ParseSyntaxException(\"no numbers! just alphas!\") from pe\n\n        with self.assertRaises(pp.ParseException, msg=\"Expected W:(A-Za-z)\"):\n            ff2 = pp.Forward()\n            ff2 <<= wd\n            ff2.parse_string(\"123\")\n\n    def testForwardExceptionText2(self):\n        \"\"\"\n        Test various expressions for error messages, under conditions in wrapped ParserElements\n        \"\"\"\n        v = \"(omit closing paren\"\n        w = \"('omit closing quote)\"\n\n        for s, expr, expected in (\n            (v, pp.nested_expr(), \"Expected ')'\"),\n            (v, pp.Combine(pp.nested_expr(), adjacent=False), \"Expected ')'\"),\n            (\n                v,\n                pp.QuotedString(\"(\", endQuoteChar=\")\"),\n                \"Expected quoted string, starting with ( ending with ), found '('\",\n            ),\n            (w, pp.nested_expr(content=pp.sgl_quoted_string), \"Expected ')'\"),\n            (\"\", pp.nested_expr(), \"\"),\n            (\"\", pp.Word(\"A\"), \"\"),\n        ):\n            print(repr(s))\n            print(expr)\n\n            with self.subTest(\"parse expr\", expr=expr, s=s, expected=expected):\n                with self.assertRaisesParseException(expected_msg=expected) as ctx:\n                    expr.parse_string(s, parse_all=True)\n                print(ctx.exception)\n\n            with self.subTest(\"parse expr[1, ...]\", expr=expr, s=s, expected=expected):\n                with self.assertRaisesParseException(expected_msg=expected) as ctx:\n                    expr[1, ...].parse_string(s, parse_all=True)\n                print(ctx.exception)\n\n            with self.subTest(\n                \"parse DelimitedList(expr)\", expr=expr, s=s, expected=expected\n            ):\n                with self.assertRaisesParseException(expected_msg=expected) as ctx:\n                    pp.DelimitedList(expr).parse_string(s, parse_all=True)\n                print(ctx.exception)\n\n            print()\n\n    def testMiscellaneousExceptionBits(self):\n        pp.ParserElement.verbose_stacktrace = True\n\n        self_testcase_name = \"tests.test_unit.\" + type(self).__name__\n\n        # force a parsing exception - match an integer against \"ABC\"\n        try:\n            pp.Word(pp.nums).parseString(\"ABC\", parseAll=True)\n        except pp.ParseException as pe:\n            expected_str = \"Expected W:(0-9), found 'ABC'  (at char 0), (line:1, col:1)\"\n            self.assertEqual(expected_str, str(pe), \"invalid ParseException str\")\n            self.assertEqual(expected_str, repr(pe), \"invalid ParseException repr\")\n\n            self.assertEqual(\n                \">!<ABC\", pe.markInputline(), \"invalid default mark input line\"\n            )\n            self.assertEqual(\n                \"ABC\", pe.markInputline(\"\"), \"invalid mark input line with '' marker\"\n            )\n\n            # test explain using depth=None, 0, 1\n            depth_none_explain_str = pe.explain(depth=None)\n            depth_0_explain_str = pe.explain(depth=0)\n            depth_1_explain_str = pe.explain(depth=1)\n            print(depth_none_explain_str)\n            print()\n            print(depth_0_explain_str)\n            print()\n            print(depth_1_explain_str)\n\n            expr_name = \"pyparsing.core.Word - W:(0-9)\"\n            for expected_function in [self_testcase_name, expr_name]:\n                self.assertTrue(\n                    expected_function in depth_none_explain_str,\n                    f\"{expected_function!r} not found in ParseException.explain()\",\n                )\n                self.assertFalse(\n                    expected_function in depth_0_explain_str,\n                    f\"{expected_function!r} found in ParseException.explain(depth=0)\",\n                )\n\n            self.assertTrue(\n                expr_name in depth_1_explain_str,\n                f\"{expected_function!r} not found in ParseException.explain()\",\n            )\n            self.assertFalse(\n                self_testcase_name in depth_1_explain_str,\n                f\"{expected_function!r} not found in ParseException.explain()\",\n            )\n\n    def testExpressionDefaultStrings(self):\n        expr = pp.Word(pp.nums)\n        print(expr)\n        self.assertEqual(\"W:(0-9)\", repr(expr))\n\n        expr = pp.Word(pp.nums, exact=3)\n        print(expr)\n        self.assertEqual(\"W:(0-9){3}\", repr(expr))\n\n        expr = pp.Word(pp.nums, min=2)\n        print(expr)\n        self.assertEqual(\"W:(0-9){2,...}\", repr(expr))\n\n        expr = pp.Word(pp.nums, max=3)\n        print(expr)\n        self.assertEqual(\"W:(0-9){1,3}\", repr(expr))\n\n        expr = pp.Word(pp.nums, min=2, max=3)\n        print(expr)\n        self.assertEqual(\"W:(0-9){2,3}\", repr(expr))\n\n        expr = pp.Char(pp.nums)\n        print(expr)\n        self.assertEqual(\"(0-9)\", repr(expr))\n\n    def testEmptyExpressionsAreHandledProperly(self):\n        from pyparsing.diagram import to_railroad\n\n        for cls in (pp.And, pp.Or, pp.MatchFirst, pp.Each):\n            print(\"testing empty\", cls.__name__)\n            expr = cls([])\n            expr.streamline()\n            to_railroad(expr)\n\n    def testForwardsDoProperStreamlining(self):\n        wd = pp.Word(pp.alphas)\n        w3 = wd + wd + wd\n        # before streamlining, w3 is {{W:(A-Za-z) W:(A-Za-z)} W:(A-Za-z)}\n        self.assertIsInstance(w3.exprs[0], pp.And)\n        self.assertEqual(len(w3.exprs), 2)\n\n        ff = pp.Forward()\n        ff <<= w3 + pp.Opt(ff)\n        # before streamlining, ff is {{{W:(A-Za-z) W:(A-Za-z)} W:(A-Za-z)} [Forward: None]}\n        self.assertEqual(len(ff.expr.exprs), 2)\n\n        ff.streamline()\n\n        # after streamlining:\n        #   w3 is {W:(A-Za-z) W:(A-Za-z) W:(A-Za-z)}\n        #   ff is {W:(A-Za-z) W:(A-Za-z) W:(A-Za-z) [Forward: None]}\n        self.assertEqual(len(ff.expr.exprs), 4)\n        self.assertEqual(len(w3.exprs), 3)\n\n    test_exception_messages_tests = (\n        (pp.Word(pp.alphas), \"123\", \"Expected W:(A-Za-z), found '123'\"),\n        (pp.Word(pp.alphas).set_name(\"word\"), \"123\", \"Expected word, found '123'\"),\n        (\n            pp.Group(pp.Word(pp.alphas).set_name(\"word\")),\n            \"123\",\n            \"Expected word, found '123'\",\n        ),\n        (\n            pp.OneOrMore(pp.Word(pp.alphas).set_name(\"word\")),\n            \"123\",\n            \"Expected word, found '123'\",\n        ),\n        (\n            pp.DelimitedList(pp.Word(pp.alphas).set_name(\"word\")),\n            \"123\",\n            \"Expected word, found '123'\",\n        ),\n        (\n            pp.Suppress(pp.Word(pp.alphas).set_name(\"word\")),\n            \"123\",\n            \"Expected word, found '123'\",\n        ),\n        (\n            pp.Forward() << pp.Word(pp.alphas).set_name(\"word\"),\n            \"123\",\n            \"Expected word, found '123'\",\n        ),\n    )\n\n    def test_exception_messages(self, tests=test_exception_messages_tests):\n        for expr, input_str, expected_msg in tests:\n            with self.subTest(expr=expr, input_str=input_str):\n                with self.assertRaisesParseException(expected_msg=expected_msg):\n                    expr.parse_string(input_str)\n\n    def test_pep8_synonyms(self):\n        \"\"\"\n        Test that staticmethods wrapped by replaced_by_pep8 wrapper are properly\n        callable as staticmethods.\n        \"\"\"\n\n        def run_subtest(fn_name, expr=None, args=\"\"):\n            bool_expr = pp.one_of(\"true false\", as_keyword=True)\n            if expr is None:\n                expr = \"bool_expr\"\n\n            # try calling a ParserElement staticmethod via a ParserElement instance\n            with self.subTest(fn_name=fn_name):\n                exec(f\"{expr}.{fn_name}({args})\", globals(), locals())\n\n        # access staticmethod synonyms using a ParserElement\n        parser_element_staticmethod_names = \"\"\"\n            enablePackrat disableMemoization enableLeftRecursion resetCache\n        \"\"\".split()\n\n        if not (\n            pp.ParserElement._packratEnabled or pp.ParserElement._left_recursion_enabled\n        ):\n            for name in parser_element_staticmethod_names:\n                run_subtest(name)\n        pp.ParserElement.disable_memoization()\n\n        run_subtest(\"setDefaultWhitespaceChars\", args=\"' '\")\n        run_subtest(\"inlineLiteralsUsing\", args=\"pp.Suppress\")\n\n        run_subtest(\n            \"setDefaultKeywordChars\", expr=\"pp.Keyword('START')\", args=\"'abcde'\"\n        )\n\n\nclass Test03_EnablePackratParsing(TestCase):\n    def runTest(self):\n        Test02_WithoutPackrat.suite_context.restore()\n\n        ParserElement.enablePackrat()\n\n        # SAVE A NEW SUITE CONTEXT\n        Test02_WithoutPackrat.suite_context = ppt.reset_pyparsing_context().save()\n\n\nclass Test04_WithPackrat(Test02_WithoutPackrat):\n    \"\"\"\n    rerun Test2 tests, now that packrat is enabled\n    \"\"\"\n\n    def test000_assert_packrat_status(self):\n        print(\"Packrat enabled:\", ParserElement._packratEnabled)\n        print(\n            \"Packrat cache:\",\n            type(ParserElement.packrat_cache).__name__,\n            getattr(ParserElement.packrat_cache, \"size\", \"- no size attribute -\"),\n        )\n        self.assertTrue(ParserElement._packratEnabled, \"packrat not enabled\")\n        self.assertEqual(\n            \"_FifoCache\",\n            type(ParserElement.packrat_cache).__name__,\n            msg=\"incorrect cache type\",\n        )\n\n\nclass Test05_EnableBoundedPackratParsing(TestCase):\n    def runTest(self):\n        Test02_WithoutPackrat.suite_context = Test02_WithoutPackrat.save_suite_context\n        Test02_WithoutPackrat.suite_context.restore()\n\n        ParserElement.enablePackrat(cache_size_limit=16)\n\n        # SAVE A NEW SUITE CONTEXT\n        Test02_WithoutPackrat.suite_context = ppt.reset_pyparsing_context().save()\n\n\nclass Test06_WithBoundedPackrat(Test02_WithoutPackrat):\n    \"\"\"\n    rerun Test2 tests, now with bounded packrat cache\n    \"\"\"\n\n    def test000_assert_packrat_status(self):\n        print(\"Packrat enabled:\", ParserElement._packratEnabled)\n        print(\n            \"Packrat cache:\",\n            type(ParserElement.packrat_cache).__name__,\n            getattr(ParserElement.packrat_cache, \"size\", \"- no size attribute -\"),\n        )\n        self.assertTrue(ParserElement._packratEnabled, \"packrat not enabled\")\n        self.assertEqual(\n            \"_FifoCache\",\n            type(ParserElement.packrat_cache).__name__,\n            msg=\"incorrect cache type\",\n        )\n\n\nclass Test07_EnableUnboundedPackratParsing(TestCase):\n    def runTest(self):\n        Test02_WithoutPackrat.suite_context = Test02_WithoutPackrat.save_suite_context\n        Test02_WithoutPackrat.suite_context.restore()\n\n        ParserElement.enablePackrat(cache_size_limit=None)\n\n        # SAVE A NEW SUITE CONTEXT\n        Test02_WithoutPackrat.suite_context = ppt.reset_pyparsing_context().save()\n\n\nclass Test08_WithUnboundedPackrat(Test02_WithoutPackrat):\n    \"\"\"\n    rerun Test2 tests, now with unbounded packrat cache\n    \"\"\"\n\n    def test000_assert_packrat_status(self):\n        print(\"Packrat enabled:\", ParserElement._packratEnabled)\n        print(\n            \"Packrat cache:\",\n            type(ParserElement.packrat_cache).__name__,\n            getattr(ParserElement.packrat_cache, \"size\", \"- no size attribute -\"),\n        )\n        self.assertTrue(ParserElement._packratEnabled, \"packrat not enabled\")\n        self.assertEqual(\n            \"_UnboundedCache\",\n            type(ParserElement.packrat_cache).__name__,\n            msg=\"incorrect cache type\",\n        )\n\n\nclass Test09_WithLeftRecursionParsing(Test02_WithoutPackrat):\n    \"\"\"\n    rerun Test2 tests, now with unbounded left recursion cache\n    \"\"\"\n\n    def setUp(self):\n        ParserElement.enable_left_recursion(force=True)\n\n    def tearDown(self):\n        default_suite_context.restore()\n\n    def test000_assert_packrat_status(self):\n        print(\"Left-Recursion enabled:\", ParserElement._left_recursion_enabled)\n        self.assertTrue(\n            ParserElement._left_recursion_enabled, \"left recursion not enabled\"\n        )\n        self.assertIsInstance(ParserElement.recursion_memos, pp.util.UnboundedMemo)\n\n\nclass Test10_WithLeftRecursionParsingBoundedMemo(Test02_WithoutPackrat):\n    \"\"\"\n    rerun Test2 tests, now with bounded left recursion cache\n    \"\"\"\n\n    def setUp(self):\n        ParserElement.enable_left_recursion(cache_size_limit=4, force=True)\n\n    def tearDown(self):\n        default_suite_context.restore()\n\n    def test000_assert_packrat_status(self):\n        print(\"Left-Recursion enabled:\", ParserElement._left_recursion_enabled)\n        self.assertTrue(\n            ParserElement._left_recursion_enabled, \"left recursion not enabled\"\n        )\n        self.assertIsInstance(ParserElement.recursion_memos, pp.util.LRUMemo)\n        # check that the cache matches roughly what we expect\n        # \u2013 it may be larger due to action handling\n        self.assertLessEqual(ParserElement.recursion_memos._capacity, 4)\n        self.assertGreater(ParserElement.recursion_memos._capacity * 3, 4)\n\n\nclass Test11_LR1_Recursion(ppt.TestParseResultsAsserts, TestCase):\n    \"\"\"\n    Tests for recursive parsing\n    \"\"\"\n\n    suite_context = None\n    save_suite_context = None\n\n    def setUp(self):\n        recursion_suite_context.restore()\n\n    def tearDown(self):\n        default_suite_context.restore()\n\n    def test_repeat_as_recurse(self):\n        \"\"\"repetition rules formulated with recursion\"\"\"\n        one_or_more = pp.Forward().setName(\"one_or_more\")\n        one_or_more <<= one_or_more + \"a\" | \"a\"\n        self.assertParseResultsEquals(\n            one_or_more.parseString(\"a\", parseAll=True), expected_list=[\"a\"]\n        )\n        self.assertParseResultsEquals(\n            one_or_more.parseString(\"aaa aa\", parseAll=True),\n            expected_list=[\"a\", \"a\", \"a\", \"a\", \"a\"],\n        )\n        delimited_list = pp.Forward().setName(\"delimited_list\")\n        delimited_list <<= delimited_list + pp.Suppress(\",\") + \"b\" | \"b\"\n        self.assertParseResultsEquals(\n            delimited_list.parseString(\"b\", parseAll=True), expected_list=[\"b\"]\n        )\n        self.assertParseResultsEquals(\n            delimited_list.parseString(\"b,b\", parseAll=True), expected_list=[\"b\", \"b\"]\n        )\n        self.assertParseResultsEquals(\n            delimited_list.parseString(\"b,b , b, b,b\", parseAll=True),\n            expected_list=[\"b\", \"b\", \"b\", \"b\", \"b\"],\n        )\n\n    def test_binary_recursive(self):\n        \"\"\"parsing of single left-recursive binary operator\"\"\"\n        expr = pp.Forward().setName(\"expr\")\n        num = pp.Word(pp.nums)\n        expr <<= expr + \"+\" - num | num\n        self.assertParseResultsEquals(\n            expr.parseString(\"1+2\", parseAll=True), expected_list=[\"1\", \"+\", \"2\"]\n        )\n        self.assertParseResultsEquals(\n            expr.parseString(\"1+2+3+4\", parseAll=True),\n            expected_list=[\"1\", \"+\", \"2\", \"+\", \"3\", \"+\", \"4\"],\n        )\n\n    def test_binary_associative(self):\n        \"\"\"associative is preserved for single left-recursive binary operator\"\"\"\n        expr = pp.Forward().setName(\"expr\")\n        num = pp.Word(pp.nums)\n        expr <<= pp.Group(expr) + \"+\" - num | num\n        self.assertParseResultsEquals(\n            expr.parseString(\"1+2\", parseAll=True), expected_list=[[\"1\"], \"+\", \"2\"]\n        )\n        self.assertParseResultsEquals(\n            expr.parseString(\"1+2+3+4\", parseAll=True),\n            expected_list=[[[[\"1\"], \"+\", \"2\"], \"+\", \"3\"], \"+\", \"4\"],\n        )\n\n    def test_add_sub(self):\n        \"\"\"indirectly left-recursive/associative add/sub calculator\"\"\"\n        expr = pp.Forward().setName(\"expr\")\n        num = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        expr <<= (\n            (expr + \"+\" - num).setParseAction(lambda t: t[0] + t[2])\n            | (expr + \"-\" - num).setParseAction(lambda t: t[0] - t[2])\n            | num\n        )\n        self.assertEqual(expr.parseString(\"1+2\", parseAll=True)[0], 3)\n        self.assertEqual(expr.parseString(\"1+2+3\", parseAll=True)[0], 6)\n        self.assertEqual(expr.parseString(\"1+2-3\", parseAll=True)[0], 0)\n        self.assertEqual(expr.parseString(\"1-2+3\", parseAll=True)[0], 2)\n        self.assertEqual(expr.parseString(\"1-2-3\", parseAll=True)[0], -4)\n\n    def test_math(self):\n        \"\"\"precedence climbing parser for math\"\"\"\n        # named references\n        expr = pp.Forward().setName(\"expr\")\n        add_sub = pp.Forward().setName(\"add_sub\")\n        mul_div = pp.Forward().setName(\"mul_div\")\n        power = pp.Forward().setName(\"power\")\n        terminal = pp.Forward().setName(\"terminal\")\n        # concrete rules\n        number = pp.Word(pp.nums).setParseAction(lambda t: int(t[0]))\n        signed = (\"+\" - expr) | (\"-\" - expr).setParseAction(lambda t: -t[1])\n        group = pp.Suppress(\"(\") - expr - pp.Suppress(\")\")\n        add_sub <<= (\n            (add_sub + \"+\" - mul_div).setParseAction(lambda t: t[0] + t[2])\n            | (add_sub + \"-\" - mul_div).setParseAction(lambda t: t[0] - t[2])\n            | mul_div\n        )\n        mul_div <<= (\n            (mul_div + \"*\" - power).setParseAction(lambda t: t[0] * t[2])\n            | (mul_div + \"/\" - power).setParseAction(lambda t: t[0] / t[2])\n            | power\n        )\n        power <<= (terminal + \"^\" - power).setParseAction(\n            lambda t: t[0] ** t[2]\n        ) | terminal\n        terminal <<= number | signed | group\n        expr <<= add_sub\n        # simple add_sub expressions\n        self.assertEqual(expr.parseString(\"1+2\", parseAll=True)[0], 3)\n        self.assertEqual(expr.parseString(\"1+2+3\", parseAll=True)[0], 6)\n        self.assertEqual(expr.parseString(\"1+2-3\", parseAll=True)[0], 0)\n        self.assertEqual(expr.parseString(\"1-2+3\", parseAll=True)[0], 2)\n        self.assertEqual(expr.parseString(\"1-2-3\", parseAll=True)[0], -4)\n        # precedence overwriting via parentheses\n        self.assertEqual(expr.parseString(\"1+(2+3)\", parseAll=True)[0], 6)\n        self.assertEqual(expr.parseString(\"1+(2-3)\", parseAll=True)[0], 0)\n        self.assertEqual(expr.parseString(\"1-(2+3)\", parseAll=True)[0], -4)\n        self.assertEqual(expr.parseString(\"1-(2-3)\", parseAll=True)[0], 2)\n        # complicated math expressions \u2013 same as Python expressions\n        self.assertEqual(expr.parseString(\"1----3\", parseAll=True)[0], 1 - ---3)\n        self.assertEqual(expr.parseString(\"1+2*3\", parseAll=True)[0], 1 + 2 * 3)\n        self.assertEqual(expr.parseString(\"1*2+3\", parseAll=True)[0], 1 * 2 + 3)\n        self.assertEqual(expr.parseString(\"1*2^3\", parseAll=True)[0], 1 * 2**3)\n        self.assertEqual(expr.parseString(\"4^3^2^1\", parseAll=True)[0], 4**3**2**1)\n\n    def test_terminate_empty(self):\n        \"\"\"Recursion with ``Empty`` terminates\"\"\"\n        empty = pp.Forward().setName(\"e\")\n        empty <<= empty + pp.Empty() | pp.Empty()\n        self.assertParseResultsEquals(\n            empty.parseString(\"\", parseAll=True), expected_list=[]\n        )\n\n    def test_non_peg(self):\n        \"\"\"Recursion works for non-PEG operators\"\"\"\n        expr = pp.Forward().setName(\"expr\")\n        expr <<= expr + \"a\" ^ expr + \"ab\" ^ expr + \"abc\" ^ \".\"\n        self.assertParseResultsEquals(\n            expr.parseString(\".abcabaabc\", parseAll=True),\n            expected_list=[\".\", \"abc\", \"ab\", \"a\", \"abc\"],\n        )\n\n\n# force clear of packrat parsing flags before saving contexts\npp.ParserElement._packratEnabled = False\npp.ParserElement._parse = pp.ParserElement._parseNoCache\n\nTest02_WithoutPackrat.suite_context = ppt.reset_pyparsing_context().save()\nTest02_WithoutPackrat.save_suite_context = ppt.reset_pyparsing_context().save()\n\ndefault_suite_context = ppt.reset_pyparsing_context().save()\npp.ParserElement.enable_left_recursion()\nrecursion_suite_context = ppt.reset_pyparsing_context().save()\ndefault_suite_context.restore()\n", "tests/test_simple_unit.py": "#\n# test_simple_unit.py\n#\n# While these unit tests *do* perform low-level unit testing of the classes in pyparsing,\n# this testing module should also serve an instructional purpose, to clearly show simple passing\n# and failing parse cases of some basic pyparsing expressions.\n#\n# Copyright (c) 2018  Paul T. McGuire\n#\nimport unittest\nimport pyparsing as pp\nfrom collections import namedtuple\nfrom datetime import datetime, timezone\n\nppt = pp.pyparsing_test\nTestParseResultsAsserts = ppt.TestParseResultsAsserts\n\n# Test spec data class for specifying simple pyparsing test cases\nPyparsingTest = namedtuple(\n    \"PyparsingTest\",\n    \"desc expr text parse_fn expected_list expected_dict expected_fail_locn\",\n)\n# fmt: off\nPyparsingTest.__new__.__defaults__ = (\n    \"\", pp.Empty(), \"\", \"parse_string\", None, None, None,\n)\n# fmt: on\n\nNL = \"\\n\"\n\n\nclass PyparsingExpressionTestCase(ppt.TestParseResultsAsserts, unittest.TestCase):\n    \"\"\"\n    Base pyparsing testing class to parse various pyparsing expressions against\n    given text strings. Subclasses must define a class attribute 'tests' which\n    is a list of PyparsingTest instances.\n    \"\"\"\n\n    tests = []\n\n    def runTest(self):\n        if self.__class__ is PyparsingExpressionTestCase:\n            return\n\n        for test_spec in self.tests:\n            # for each spec in the class's tests list, create a subtest\n            # that will either:\n            #  - parse the string with expected success, display the\n            #    results, and validate the returned ParseResults\n            #  - or parse the string with expected failure, display the\n            #    error message and mark the error location, and validate\n            #    the location against an expected value\n            with self.subTest(test_spec=test_spec):\n                test_spec.expr.streamline()\n                print(\n                    f\"{NL}{test_spec.desc} - {type(test_spec.expr).__name__}({test_spec.expr})\"\n                )\n\n                parse_function = getattr(test_spec.expr, test_spec.parse_fn)\n                if test_spec.expected_fail_locn is None:\n                    # expect success\n                    subtest_result = parse_function(test_spec.text)\n                    if test_spec.parse_fn == \"parse_string\":\n                        print(subtest_result.dump())\n                        # compare results against given list and/or dict\n                        self.assertParseResultsEquals(\n                            subtest_result,\n                            expected_list=test_spec.expected_list,\n                            expected_dict=test_spec.expected_dict,\n                        )\n                    elif test_spec.parse_fn == \"transformString\":\n                        print(subtest_result)\n                        # compare results against given list and/or dict\n                        if test_spec.expected_list is not None:\n                            self.assertEqual([subtest_result], test_spec.expected_list)\n                    elif test_spec.parse_fn == \"searchString\":\n                        print(subtest_result)\n                        # compare results against given list and/or dict\n                        if test_spec.expected_list is not None:\n                            self.assertEqual([subtest_result], test_spec.expected_list)\n                else:\n                    # expect fail\n                    with self.assertRaisesParseException():\n                        try:\n                            parse_function(test_spec.text)\n                        except pp.ParseBaseException as exc:\n                            print(pp.ParseException.explain(exc))\n                            self.assertEqual(exc.loc, test_spec.expected_fail_locn)\n                            raise\n\n\n# =========== TEST DEFINITIONS START HERE ==============\n\n\nclass TestLiteral(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Simple match\",\n            expr=pp.Literal(\"xyz\"),\n            text=\"xyz\",\n            expected_list=[\"xyz\"],\n        ),\n        PyparsingTest(\n            desc=\"Simple match after skipping whitespace\",\n            expr=pp.Literal(\"xyz\"),\n            text=\"  xyz\",\n            expected_list=[\"xyz\"],\n        ),\n        PyparsingTest(\n            desc=\"Simple fail - parse an empty string\",\n            expr=pp.Literal(\"xyz\"),\n            text=\"\",\n            expected_fail_locn=0,\n        ),\n        PyparsingTest(\n            desc=\"Simple fail - parse a mismatching string\",\n            expr=pp.Literal(\"xyz\"),\n            text=\"xyu\",\n            expected_fail_locn=0,\n        ),\n        PyparsingTest(\n            desc=\"Simple fail - parse a partially matching string\",\n            expr=pp.Literal(\"xyz\"),\n            text=\"xy\",\n            expected_fail_locn=0,\n        ),\n        PyparsingTest(\n            desc=\"Fail - parse a partially matching string by matching individual letters\",\n            expr=pp.Literal(\"x\") + pp.Literal(\"y\") + pp.Literal(\"z\"),\n            text=\"xy\",\n            expected_fail_locn=2,\n        ),\n    ]\n\n\nclass TestCaselessLiteral(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Match colors, converting to consistent case\",\n            expr=(\n                pp.CaselessLiteral(\"RED\")\n                | pp.CaselessLiteral(\"GREEN\")\n                | pp.CaselessLiteral(\"BLUE\")\n            )[...],\n            text=\"red Green BluE blue GREEN green rEd\",\n            expected_list=[\"RED\", \"GREEN\", \"BLUE\", \"BLUE\", \"GREEN\", \"GREEN\", \"RED\"],\n        ),\n    ]\n\n\nclass TestWord(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Simple Word match\",\n            expr=pp.Word(\"xy\"),\n            text=\"xxyxxyy\",\n            expected_list=[\"xxyxxyy\"],\n        ),\n        PyparsingTest(\n            desc=\"Simple Word match of two separate Words\",\n            expr=pp.Word(\"x\") + pp.Word(\"y\"),\n            text=\"xxxxxyy\",\n            expected_list=[\"xxxxx\", \"yy\"],\n        ),\n        PyparsingTest(\n            desc=\"Simple Word match of two separate Words - implicitly skips whitespace\",\n            expr=pp.Word(\"x\") + pp.Word(\"y\"),\n            text=\"xxxxx yy\",\n            expected_list=[\"xxxxx\", \"yy\"],\n        ),\n    ]\n\n\nclass TestCombine(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Parsing real numbers - fail, parsed numbers are in pieces\",\n            expr=(pp.Word(pp.nums) + \".\" + pp.Word(pp.nums))[...],\n            text=\"1.2 2.3 3.1416 98.6\",\n            # fmt: off\n            expected_list=[\"1\", \".\", \"2\", \"2\", \".\", \"3\", \"3\", \".\", \"1416\", \"98\", \".\", \"6\"],\n            # fmt: on\n        ),\n        PyparsingTest(\n            desc=\"Parsing real numbers - better, use Combine to combine multiple tokens into one\",\n            expr=pp.Combine(pp.Word(pp.nums) + \".\" + pp.Word(pp.nums))[...],\n            text=\"1.2 2.3 3.1416 98.6\",\n            expected_list=[\"1.2\", \"2.3\", \"3.1416\", \"98.6\"],\n        ),\n    ]\n\n\nclass TestRepetition(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Match several words\",\n            expr=(pp.Word(\"x\") | pp.Word(\"y\"))[...],\n            text=\"xxyxxyyxxyxyxxxy\",\n            expected_list=[\"xx\", \"y\", \"xx\", \"yy\", \"xx\", \"y\", \"x\", \"y\", \"xxx\", \"y\"],\n        ),\n        PyparsingTest(\n            desc=\"Match several words, skipping whitespace\",\n            expr=(pp.Word(\"x\") | pp.Word(\"y\"))[...],\n            text=\"x x  y xxy yxx y xyx  xxy\",\n            # fmt: off\n            expected_list=[\"x\", \"x\", \"y\", \"xx\", \"y\", \"y\", \"xx\", \"y\", \"x\", \"y\", \"x\", \"xx\", \"y\"],\n            # fmt: on\n        ),\n        PyparsingTest(\n            desc=\"Match several words, skipping whitespace (old style)\",\n            expr=pp.OneOrMore(pp.Word(\"x\") | pp.Word(\"y\")),\n            text=\"x x  y xxy yxx y xyx  xxy\",\n            # fmt: off\n            expected_list=[\"x\", \"x\", \"y\", \"xx\", \"y\", \"y\", \"xx\", \"y\", \"x\", \"y\", \"x\", \"xx\", \"y\"],\n            # fmt: on\n        ),\n        PyparsingTest(\n            desc=\"Match words and numbers - show use of results names to collect types of tokens\",\n            expr=(pp.Word(pp.alphas)(\"alpha*\") | pp.pyparsing_common.integer(\"int*\"))[\n                ...\n            ],\n            text=\"sdlfj23084ksdfs08234kjsdlfkjd0934\",\n            expected_list=[\"sdlfj\", 23084, \"ksdfs\", 8234, \"kjsdlfkjd\", 934],\n            expected_dict={\n                \"alpha\": [\"sdlfj\", \"ksdfs\", \"kjsdlfkjd\"],\n                \"int\": [23084, 8234, 934],\n            },\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList (comma is the default delimiter)\",\n            expr=pp.DelimitedList(pp.Word(pp.alphas)),\n            text=\"xxyx,xy,y,xxyx,yxx, xy\",\n            expected_list=[\"xxyx\", \"xy\", \"y\", \"xxyx\", \"yxx\", \"xy\"],\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList (comma is the default delimiter) with trailing delimiter\",\n            expr=pp.DelimitedList(pp.Word(pp.alphas), allow_trailing_delim=True),\n            text=\"xxyx,xy,y,xxyx,yxx, xy,\",\n            expected_list=[\"xxyx\", \"xy\", \"y\", \"xxyx\", \"yxx\", \"xy\"],\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList (comma is the default delimiter) with minimum size\",\n            expr=pp.DelimitedList(pp.Word(pp.alphas), min=3),\n            text=\"xxyx,xy\",\n            expected_fail_locn=7,\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList (comma is the default delimiter) with maximum size\",\n            expr=pp.DelimitedList(pp.Word(pp.alphas), max=3),\n            text=\"xxyx,xy,y,xxyx,yxx, xy,\",\n            expected_list=[\"xxyx\", \"xy\", \"y\"],\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList, with ':' delimiter\",\n            expr=pp.DelimitedList(\n                pp.Word(pp.hexnums, exact=2), delim=\":\", combine=True\n            ),\n            text=\"0A:4B:73:21:FE:76\",\n            expected_list=[\"0A:4B:73:21:FE:76\"],\n        ),\n        PyparsingTest(\n            desc=\"Using DelimitedList, with ':' delimiter\",\n            expr=pp.DelimitedList(\n                pp.Word(pp.hexnums, exact=2),\n                delim=\":\",\n                combine=True,\n                allow_trailing_delim=True,\n            ),\n            text=\"0A:4B:73:21:FE:76:\",\n            expected_list=[\"0A:4B:73:21:FE:76:\"],\n        ),\n    ]\n\n\nclass TestResultsName(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Match with results name\",\n            expr=pp.Literal(\"xyz\").set_results_name(\"value\"),\n            text=\"xyz\",\n            expected_dict={\"value\": \"xyz\"},\n            expected_list=[\"xyz\"],\n        ),\n        PyparsingTest(\n            desc=\"Match with results name - using naming short-cut\",\n            expr=pp.Literal(\"xyz\")(\"value\"),\n            text=\"xyz\",\n            expected_dict={\"value\": \"xyz\"},\n            expected_list=[\"xyz\"],\n        ),\n        PyparsingTest(\n            desc=\"Define multiple results names\",\n            expr=pp.Word(pp.alphas, pp.alphanums)(\"key\")\n            + \"=\"\n            + pp.pyparsing_common.integer(\"value\"),\n            text=\"range=5280\",\n            expected_dict={\"key\": \"range\", \"value\": 5280},\n            expected_list=[\"range\", \"=\", 5280],\n        ),\n    ]\n\n\nclass TestGroups(PyparsingExpressionTestCase):\n    EQ = pp.Suppress(\"=\")\n    tests = [\n        PyparsingTest(\n            desc=\"Define multiple results names in groups\",\n            expr=pp.Group(\n                pp.Word(pp.alphas)(\"key\") + EQ + pp.pyparsing_common.number(\"value\")\n            )[...],\n            text=\"range=5280 long=-138.52 lat=46.91\",\n            expected_list=[[\"range\", 5280], [\"long\", -138.52], [\"lat\", 46.91]],\n        ),\n        PyparsingTest(\n            desc=(\n                \"Define multiple results names in groups\"\n                \" - use Dict to define results names using parsed keys\"\n            ),\n            expr=pp.Dict(\n                pp.Group(pp.Word(pp.alphas) + EQ + pp.pyparsing_common.number)[...]\n            ),\n            text=\"range=5280 long=-138.52 lat=46.91\",\n            expected_list=[[\"range\", 5280], [\"long\", -138.52], [\"lat\", 46.91]],\n            expected_dict={\"lat\": 46.91, \"long\": -138.52, \"range\": 5280},\n        ),\n        PyparsingTest(\n            desc=\"Define multiple value types\",\n            expr=pp.Dict(\n                pp.Group(\n                    pp.Word(pp.alphas)\n                    + EQ\n                    + (\n                        pp.pyparsing_common.number\n                        | pp.oneOf(\"True False\")\n                        | pp.QuotedString(\"'\")\n                    )\n                )[...]\n            ),\n            text=\"long=-122.47 lat=37.82 public=True name='Golden Gate Bridge'\",\n            expected_list=[\n                [\"long\", -122.47],\n                [\"lat\", 37.82],\n                [\"public\", \"True\"],\n                [\"name\", \"Golden Gate Bridge\"],\n            ],\n            expected_dict={\n                \"long\": -122.47,\n                \"lat\": 37.82,\n                \"public\": \"True\",\n                \"name\": \"Golden Gate Bridge\",\n            },\n        ),\n    ]\n\n\nclass TestParseAction(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Parsing real numbers - use parse action to convert to float at parse time\",\n            expr=pp.Combine(pp.Word(pp.nums) + \".\" + pp.Word(pp.nums)).add_parse_action(\n                lambda t: float(t[0])\n            )[...],\n            text=\"1.2 2.3 3.1416 98.6\",\n            # note, these are now floats, not strs\n            expected_list=[1.2, 2.3, 3.1416, 98.6],\n        ),\n        PyparsingTest(\n            desc=\"Match with numeric string converted to int\",\n            expr=pp.Word(\"0123456789\").addParseAction(lambda t: int(t[0])),\n            text=\"12345\",\n            expected_list=[12345],  # note - result is type int, not str\n        ),\n        PyparsingTest(\n            desc=\"Use two parse actions to convert numeric string, then convert to datetime\",\n            expr=pp.Word(pp.nums).add_parse_action(\n                lambda t: int(t[0]),\n                lambda t: datetime.fromtimestamp(t[0], timezone.utc),\n            ),\n            text=\"1537415628\",\n            expected_list=[datetime(2018, 9, 20, 3, 53, 48, tzinfo=timezone.utc)],\n        ),\n        PyparsingTest(\n            desc=\"Use tokenMap for parse actions that operate on a single-length token\",\n            expr=pp.Word(pp.nums).add_parse_action(\n                pp.token_map(int),\n                pp.token_map(lambda t: datetime.fromtimestamp(t, timezone.utc)),\n            ),\n            text=\"1537415628\",\n            expected_list=[datetime(2018, 9, 20, 3, 53, 48, tzinfo=timezone.utc)],\n        ),\n        PyparsingTest(\n            desc=\"Using a built-in function that takes a sequence of strs as a parse action\",\n            expr=pp.Word(pp.hexnums, exact=2)[...].add_parse_action(\":\".join),\n            text=\"0A4B7321FE76\",\n            expected_list=[\"0A:4B:73:21:FE:76\"],\n        ),\n        PyparsingTest(\n            desc=\"Using a built-in function that takes a sequence of strs as a parse action\",\n            expr=pp.Word(pp.hexnums, exact=2)[...].add_parse_action(sorted),\n            text=\"0A4B7321FE76\",\n            expected_list=[\"0A\", \"21\", \"4B\", \"73\", \"76\", \"FE\"],\n        ),\n    ]\n\n\nclass TestResultsModifyingParseAction(PyparsingExpressionTestCase):\n    # do not make staticmethod\n    # @staticmethod\n    def compute_stats_parse_action(t):\n        # by the time this parse action is called, parsed numeric words\n        # have been converted to ints by a previous parse action, so\n        # they can be treated as ints\n        t[\"sum\"] = sum(t)\n        t[\"ave\"] = sum(t) / len(t)\n        t[\"min\"] = min(t)\n        t[\"max\"] = max(t)\n\n    tests = [\n        PyparsingTest(\n            desc=\"A parse action that adds new key-values\",\n            expr=pp.pyparsing_common.integer[...].addParseAction(\n                compute_stats_parse_action\n            ),\n            text=\"27 1 14 22 89\",\n            expected_list=[27, 1, 14, 22, 89],\n            expected_dict={\"ave\": 30.6, \"max\": 89, \"min\": 1, \"sum\": 153},\n        ),\n    ]\n\n\nclass TestRegex(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Parsing real numbers - using Regex instead of Combine\",\n            expr=pp.Regex(r\"\\d+\\.\\d+\").add_parse_action(lambda t: float(t[0]))[...],\n            text=\"1.2 2.3 3.1416 98.6\",\n            # note, these are now floats, not strs\n            expected_list=[1.2, 2.3, 3.1416, 98.6],\n        ),\n    ]\n\n\nclass TestParseCondition(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"Define a condition to only match numeric values that are multiples of 7\",\n            expr=pp.Word(pp.nums).addCondition(lambda t: int(t[0]) % 7 == 0)[...],\n            text=\"14 35 77 12 28\",\n            expected_list=[\"14\", \"35\", \"77\"],\n        ),\n        PyparsingTest(\n            desc=\"Separate conversion to int and condition into separate parse action/conditions\",\n            expr=pp.Word(pp.nums)\n            .add_parse_action(lambda t: int(t[0]))\n            .add_condition(lambda t: t[0] % 7 == 0)[...],\n            text=\"14 35 77 12 28\",\n            expected_list=[14, 35, 77],\n        ),\n    ]\n\n\nclass TestTransformStringUsingParseActions(PyparsingExpressionTestCase):\n    markup_convert_map = {\n        \"*\": \"B\",\n        \"_\": \"U\",\n        \"/\": \"I\",\n    }\n\n    # do not make staticmethod\n    # @staticmethod\n    def markup_convert(t):\n        htmltag = TestTransformStringUsingParseActions.markup_convert_map[\n            t.markup_symbol\n        ]\n        return f\"<{htmltag}>{t.body}</{htmltag}>\"\n\n    tests = [\n        PyparsingTest(\n            desc=\"Use transformString to convert simple markup to HTML\",\n            expr=(\n                pp.one_of(markup_convert_map)(\"markup_symbol\")\n                + \"(\"\n                + pp.CharsNotIn(\")\")(\"body\")\n                + \")\"\n            ).add_parse_action(markup_convert),\n            text=\"Show in *(bold), _(underscore), or /(italic) type\",\n            expected_list=[\n                \"Show in <B>bold</B>, <U>underscore</U>, or <I>italic</I> type\"\n            ],\n            parse_fn=\"transformString\",\n        ),\n    ]\n\n\nclass TestCommonHelperExpressions(PyparsingExpressionTestCase):\n    tests = [\n        PyparsingTest(\n            desc=\"A comma-delimited list of words\",\n            expr=pp.DelimitedList(pp.Word(pp.alphas)),\n            text=\"this, that, blah,foo,   bar\",\n            expected_list=[\"this\", \"that\", \"blah\", \"foo\", \"bar\"],\n        ),\n        PyparsingTest(\n            desc=\"A counted array of words\",\n            expr=pp.Group(pp.counted_array(pp.Word(\"ab\")))[...],\n            text=\"2 aaa bbb 0 3 abab bbaa abbab\",\n            expected_list=[[\"aaa\", \"bbb\"], [], [\"abab\", \"bbaa\", \"abbab\"]],\n        ),\n        PyparsingTest(\n            desc=\"skipping comments with ignore\",\n            expr=(\n                pp.pyparsing_common.identifier(\"lhs\")\n                + \"=\"\n                + pp.pyparsing_common.fnumber(\"rhs\")\n            ).ignore(pp.cpp_style_comment),\n            text=\"abc_100 = /* value to be tested */ 3.1416\",\n            expected_list=[\"abc_100\", \"=\", 3.1416],\n            expected_dict={\"lhs\": \"abc_100\", \"rhs\": 3.1416},\n        ),\n        PyparsingTest(\n            desc=(\n                \"some pre-defined expressions in pyparsing_common, and\"\n                \" building a dotted identifier with DelimitedList\"\n            ),\n            expr=(\n                pp.pyparsing_common.number(\"id_num\")\n                + pp.DelimitedList(pp.pyparsing_common.identifier, \".\", combine=True)(\n                    \"name\"\n                )\n                + pp.pyparsing_common.ipv4_address(\"ip_address\")\n            ),\n            text=\"1001 www.google.com 192.168.10.199\",\n            expected_list=[1001, \"www.google.com\", \"192.168.10.199\"],\n            expected_dict={\n                \"id_num\": 1001,\n                \"name\": \"www.google.com\",\n                \"ip_address\": \"192.168.10.199\",\n            },\n        ),\n        PyparsingTest(\n            desc=\"using one_of (shortcut for Literal('a') | Literal('b') | Literal('c'))\",\n            expr=pp.one_of(\"a b c\")[...],\n            text=\"a b a b b a c c a b b\",\n            expected_list=[\"a\", \"b\", \"a\", \"b\", \"b\", \"a\", \"c\", \"c\", \"a\", \"b\", \"b\"],\n        ),\n        PyparsingTest(\n            desc=\"parsing nested parentheses\",\n            expr=pp.nested_expr(),\n            text=\"(a b (c) d (e f g ()))\",\n            expected_list=[[\"a\", \"b\", [\"c\"], \"d\", [\"e\", \"f\", \"g\", []]]],\n        ),\n        PyparsingTest(\n            desc=\"parsing nested braces\",\n            expr=(\n                pp.Keyword(\"if\")\n                + pp.nested_expr()(\"condition\")\n                + pp.nested_expr(\"{\", \"}\")(\"body\")\n            ),\n            text='if ((x == y) || !z) {printf(\"{}\");}',\n            expected_list=[\n                \"if\",\n                [[\"x\", \"==\", \"y\"], \"||\", \"!z\"],\n                [\"printf(\", '\"{}\"', \");\"],\n            ],\n            expected_dict={\n                \"condition\": [[[\"x\", \"==\", \"y\"], \"||\", \"!z\"]],\n                \"body\": [[\"printf(\", '\"{}\"', \");\"]],\n            },\n        ),\n    ]\n\n\nclass TestWhitespaceMethods(PyparsingExpressionTestCase):\n    tests = [\n        # These test the single-element versions\n        PyparsingTest(\n            desc=\"The word foo\",\n            expr=pp.Literal(\"foo\").ignore_whitespace(),\n            text=\"      foo        \",\n            expected_list=[\"foo\"],\n        ),\n        PyparsingTest(\n            desc=\"The word foo\",\n            expr=pp.Literal(\"foo\").leave_whitespace(),\n            text=\"      foo        \",\n            expected_fail_locn=0,\n        ),\n        PyparsingTest(\n            desc=\"The word foo\",\n            expr=pp.Literal(\"foo\").ignore_whitespace(),\n            text=\"foo\",\n            expected_list=[\"foo\"],\n        ),\n        PyparsingTest(\n            desc=\"The word foo\",\n            expr=pp.Literal(\"foo\").leave_whitespace(),\n            text=\"foo\",\n            expected_list=[\"foo\"],\n        ),\n        # These test the composite elements\n        PyparsingTest(\n            desc=(\n                \"If we recursively leave whitespace on the parent, this\"\n                \" whitespace-dependent grammar will succeed, even if the\"\n                \" children themselves skip whitespace\"\n            ),\n            expr=pp.And(\n                [\n                    pp.Literal(\" foo\").ignore_whitespace(),\n                    pp.Literal(\" bar\").ignore_whitespace(),\n                ]\n            ).leave_whitespace(recursive=True),\n            text=\" foo bar\",\n            expected_list=[\" foo\", \" bar\"],\n        ),\n        #\n        PyparsingTest(\n            desc=(\n                \"If we recursively ignore whitespace in our parsing, this\"\n                \" whitespace-dependent grammar will fail, even if the children\"\n                \" themselves keep whitespace\"\n            ),\n            expr=pp.And(\n                [\n                    pp.Literal(\" foo\").leave_whitespace(),\n                    pp.Literal(\" bar\").leave_whitespace(),\n                ]\n            ).ignore_whitespace(recursive=True),\n            text=\" foo bar\",\n            expected_fail_locn=1,\n        ),\n        PyparsingTest(\n            desc=(\n                \"If we leave whitespace on the parent, but it isn't recursive,\"\n                \" this whitespace-dependent grammar will fail\"\n            ),\n            expr=pp.And(\n                [\n                    pp.Literal(\" foo\").ignore_whitespace(),\n                    pp.Literal(\" bar\").ignore_whitespace(),\n                ]\n            ).leave_whitespace(recursive=False),\n            text=\" foo bar\",\n            expected_fail_locn=5,\n        ),\n        # These test the Enhance classes\n        PyparsingTest(\n            desc=(\n                \"If we recursively leave whitespace on the parent,\"\n                \" this whitespace-dependent grammar will succeed, even\"\n                \" if the children themselves skip whitespace\"\n            ),\n            expr=pp.Optional(pp.Literal(\" foo\").ignore_whitespace()).leave_whitespace(\n                recursive=True\n            ),\n            text=\" foo\",\n            expected_list=[\" foo\"],\n        ),\n        #\n        PyparsingTest(\n            desc=(\n                \"If we ignore whitespace on the parent, but it isn't recursive,\"\n                \" parsing will fail because we skip to the first character\"\n                \" 'f' before the internal expr can see it\"\n            ),\n            expr=pp.Optional(pp.Literal(\" foo\").leave_whitespace()).ignore_whitespace(\n                recursive=True\n            ),\n            text=\" foo\",\n            expected_list=[],\n        ),\n        # PyparsingTest(\n        #     desc=(\n        #         \"If we leave whitespace on the parent, this whitespace-dependent\"\n        #         \" grammar will succeed, even if the children themselves skip whitespace\"\n        #     ),\n        #     expr=pp.Optional(pp.Literal(\" foo\").ignoreWhitespace()).leaveWhitespace(\n        #         recursive=False\n        #     ),\n        #     text=\" foo\",\n        #     expected_list=[]\n        # ),\n    ]\n\n\ndef _get_decl_line_no(cls):\n    import inspect\n\n    return inspect.getsourcelines(cls)[1]\n\n\n# get all test case classes defined in this module and sort them by decl line no\ntest_case_classes = list(PyparsingExpressionTestCase.__subclasses__())\ntest_case_classes.sort(key=_get_decl_line_no)\n\n# make into a suite and run it - this will run the tests in the same order\n# they are declared in this module\n#\n# runnable from setup.py using \"python setup.py test -s simple_unit_tests.suite\"\n#\nsuite = unittest.TestSuite(cls() for cls in test_case_classes)\n\n\n# ============ MAIN ================\n\nif __name__ == \"__main__\":\n\n    result = unittest.TextTestRunner().run(suite)\n\n    exit(0 if result.wasSuccessful() else 1)\n", "tests/json_parser_tests.py": "# jsonParser.py\n#\n# Copyright (c) 2006, Paul McGuire\n#\n\ntest1 = \"\"\"\n{\n    \"glossary\": {\n        \"title\": \"example glossary\",\n        \"GlossDiv\": {\n            \"title\": \"S\",\n            \"GlossList\": [\n                {\n                    \"ID\": \"SGML\",\n                    \"SortAs\": \"SGML\",\n                    \"GlossDef\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n                    \"GlossSeeAlso\": [\"GML\", \"XML\", \"markup\"],\n                    \"GlossTerm\": \"Standard Generalized Markup Language\",\n                    \"Acronym\": \"SGML\",\n                    \"LargestPrimeLessThan100\": 97,\n                    \"AvogadroNumber\": 6.02E23,\n                    \"EvenPrimesGreaterThan2\": [],\n                    \"PrimesLessThan10\" : [2,3,5,7],\n                    \"FermatTheoremInMargin\" : false,\n                    \"MapRequiringFiveColors\" : null,\n                    \"Abbrev\": \"ISO 8879:1986\",\n                    \"EmptyDict\" : {},\n                    \"EmptyList\" : []\n                }\n            ]\n        }\n    }\n}\n\"\"\"\n\ntest2 = \"\"\"\n{\"menu\": {\n  \"id\": \"file\",\n  \"value\": \"File:\",\n  \"popup\": {\n    \"menuitem\": [\n      {\"value\": \"New\", \"onclick\": \"CreateNewDoc()\"},\n      {\"value\": \"Open\", \"onclick\": \"OpenDoc()\"},\n      {\"value\": \"Close\", \"onclick\": \"CloseDoc()\"}\n    ]\n  }\n}}\n\"\"\"\n\ntest3 = \"\"\"\n{\"widget\": {\n    \"debug\": \"on\",\n    \"window\": {\n        \"title\": \"Sample Konfabulator Widget\",        \"name\": \"main_window\",        \"width\": 500,        \"height\": 500\n    },    \"image\": {\n        \"src\": \"Images/Sun.png\",\n        \"name\": \"sun1\",        \"hOffset\": 250,        \"vOffset\": 250,        \"alignment\": \"center\"\n    },    \"text\": {\n        \"data\": \"Click Here\",\n        \"size\": 36,\n        \"style\": \"bold\",        \"name\": \"text1\",        \"hOffset\": 250,        \"vOffset\": 100,        \"alignment\": \"center\",\n        \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\"\n    }\n}}\n\"\"\"\ntest4 = \"\"\"\n{\"web-app\": {\n  \"servlet\": [    // Defines the CDSServlet\n    {\n      \"servlet-name\": \"cofaxCDS\",\n      \"servlet-class\": \"org.cofax.cds.CDSServlet\",\n        /*\n            Defines glossary variables that template designers\n            can use across the site.  You can add new\n            variables to this set by creating a new init-param, with\n            the param-name prefixed with \"configGlossary:\".\n        */\n      \"init-param\": {\n        \"configGlossary:installationAt\": \"Philadelphia, PA\",\n        \"configGlossary:adminEmail\": \"ksm@pobox.com\",\n        \"configGlossary:poweredBy\": \"Cofax\",\n        \"configGlossary:poweredByIcon\": \"/images/cofax.gif\",\n        \"configGlossary:staticPath\": \"/content/static\",\n        /*\n            Defines the template loader and template processor\n            classes.  These are implementations of org.cofax.TemplateProcessor\n            and org.cofax.TemplateLoader respectively.  Simply create new\n            implementation of these classes and set them here if the default\n            implementations do not suit your needs.  Leave these alone\n            for the defaults.\n        */\n        \"templateProcessorClass\": \"org.cofax.WysiwygTemplate\",\n        \"templateLoaderClass\": \"org.cofax.FilesTemplateLoader\",\n        \"templatePath\": \"templates\",\n        \"templateOverridePath\": \"\",\n        /*\n            Defines the names of the default templates to look for\n            when acquiring WYSIWYG templates.  Leave these at their\n            defaults for most usage.\n        */\n        \"defaultListTemplate\": \"listTemplate.htm\",\n        \"defaultFileTemplate\": \"articleTemplate.htm\",\n        /*\n            New! useJSP switches on JSP template processing.\n            jspListTemplate and jspFileTemplate are the names\n            of the default templates to look for when acquiring JSP\n            templates.  Cofax currently in production at KR has useJSP\n            set to false, since our sites currently use WYSIWYG\n            templating exclusively.\n        */\n        \"useJSP\": false,\n        \"jspListTemplate\": \"listTemplate.jsp\",\n        \"jspFileTemplate\": \"articleTemplate.jsp\",\n        /*\n            Defines the packageTag cache.  This cache keeps\n            Cofax from needing to interact with the database\n            to look up packageTag commands.\n        */\n        \"cachePackageTagsTrack\": 200,\n        \"cachePackageTagsStore\": 200,\n        \"cachePackageTagsRefresh\": 60,\n        /*\n            Defines the template cache.  Keeps Cofax from needing\n            to go to the file system to load a raw template from\n            the file system.\n        */\n        \"cacheTemplatesTrack\": 100,\n        \"cacheTemplatesStore\": 50,\n        \"cacheTemplatesRefresh\": 15,\n        /*\n            Defines the page cache.  Keeps Cofax from processing\n            templates to deliver to users.\n        */\n        \"cachePagesTrack\": 200,\n        \"cachePagesStore\": 100,\n        \"cachePagesRefresh\": 10,\n        \"cachePagesDirtyRead\": 10,\n        /*\n            Defines the templates Cofax will use when\n            being browsed by a search engine identified in\n            searchEngineRobotsDb\n        */\n        \"searchEngineListTemplate\": \"forSearchEnginesList.htm\",\n        \"searchEngineFileTemplate\": \"forSearchEngines.htm\",\n        \"searchEngineRobotsDb\": \"WEB-INF/robots.db\",\n        /*\n            New!  useDataStore enables/disables the Cofax database pool\n        */\n        \"useDataStore\": true,\n        /*\n            Defines the implementation of org.cofax.DataStore that Cofax\n            will use.  If this DataStore class does not suit your needs\n            simply implement a new DataStore class and set here.\n        */\n        \"dataStoreClass\": \"org.cofax.SqlDataStore\",\n        /*\n            Defines the implementation of org.cofax.Redirection that\n            Cofax will use.  If this Redirection class does not suit\n            your needs simply implenet a new Redirection class\n            and set here.\n        */\n        \"redirectionClass\": \"org.cofax.SqlRedirection\",\n        /*\n            Defines the data store name.   Keep this at the default\n        */\n        \"dataStoreName\": \"cofax\",\n        /*\n            Defines the JDBC driver that Cofax's database pool will use\n        */\n        \"dataStoreDriver\": \"com.microsoft.jdbc.sqlserver.SQLServerDriver\",\n        /*\n            Defines the JDBC connection URL to connect to the database\n        */\n        \"dataStoreUrl\": \"jdbc:microsoft:sqlserver://LOCALHOST:1433;DatabaseName=goon\",\n        /*\n            Defines the user name to connect to the database\n        */\n        \"dataStoreUser\": \"sa\",\n        /*\n            Defines the password to connect to the database\n        */\n        \"dataStorePassword\": \"dataStoreTestQuery\",\n        /*\n            A query that will run to test the validity of the\n            connection in the pool.\n        */\n        \"dataStoreTestQuery\": \"SET NOCOUNT ON;select test='test';\",\n        /*\n            A log file to print out database information\n        */\n        \"dataStoreLogFile\": \"/usr/local/tomcat/logs/datastore.log\",\n        /*\n            The number of connection to initialize on startup\n        */\n        \"dataStoreInitConns\": 10,\n        /*\n            The maximum number of connection to use in the pool\n        */\n        \"dataStoreMaxConns\": 100,\n        /*\n            The number of times a connection will be utilized from the\n            pool before disconnect\n        */\n        \"dataStoreConnUsageLimit\": 100,\n        /*\n            The level of information to print to the log\n        */\n        \"dataStoreLogLevel\": \"debug\",\n        /*\n            The maximum URL length allowable by the CDS Servlet\n            Helps to prevent hacking\n        */\n        \"maxUrlLength\": 500}},\n        /*\n            Defines the Email Servlet\n        */\n    {\n      \"servlet-name\": \"cofaxEmail\",\n      \"servlet-class\": \"org.cofax.cds.EmailServlet\",\n      \"init-param\": {\n        /*\n            The mail host to be used by the mail servlet\n        */\n        \"mailHost\": \"mail1\",\n        /*\n            An override\n        */\n        \"mailHostOverride\": \"mail2\"}},\n        /*\n            Defines the Admin Servlet - used to refresh cache on\n            demand and see statistics\n        */\n    {\n      \"servlet-name\": \"cofaxAdmin\",\n      \"servlet-class\": \"org.cofax.cds.AdminServlet\"},\n        /*\n            Defines the File Servlet - used to display files like Apache\n        */\n    {\n      \"servlet-name\": \"fileServlet\",\n      \"servlet-class\": \"org.cofax.cds.FileServlet\"},\n    {\n      \"servlet-name\": \"cofaxTools\",\n      \"servlet-class\": \"org.cofax.cms.CofaxToolsServlet\",\n      \"init-param\": {\n        /*\n            Path to the template folder relative to the tools tomcat installation.\n        */\n        \"templatePath\": \"toolstemplates/\",\n        /*\n            Logging boolean 1 = on, 0 = off\n        */\n        \"log\": 1,\n        /*\n            Location of log. If empty, log will be written System.out\n        */\n        \"logLocation\": \"/usr/local/tomcat/logs/CofaxTools.log\",\n        /*\n            Max size of log in BITS. If size is empty, no limit to log.\n            If size is defined, log will be overwritten upon reaching defined size.\n        */\n        \"logMaxSize\": \"\",\n        /*\n            DataStore logging boolean 1 = on, 0 = off\n        */\n        \"dataLog\": 1,\n        /*\n            DataStore location of log. If empty, log will be written System.out\n        */\n        \"dataLogLocation\": \"/usr/local/tomcat/logs/dataLog.log\",\n        /*\n            Max size of log in BITS. If size is empty, no limit to log.\n            If size is defined, log will be overwritten upon reaching defined size.\n        */\n        \"dataLogMaxSize\": \"\",\n        /*\n            Http string relative to server root to call for page cache\n            removal to Cofax Servlet.\n        */\n        \"removePageCache\": \"/content/admin/remove?cache=pages&id=\",\n        /*\n            Http string relative to server root to call for template\n            cache removal to Cofax Servlet.\n        */\n        \"removeTemplateCache\": \"/content/admin/remove?cache=templates&id=\",\n        /*\n            Location of folder from root of drive that will be used for\n            ftp transfer from beta server or user hard drive to live servers.\n            Note that Edit Article will not function without this variable\n            set correctly. MultiPart request relies upon access to this folder.\n        */\n        \"fileTransferFolder\": \"/usr/local/tomcat/webapps/content/fileTransferFolder\",\n        /*\n            Defines whether the Server should look in another path for\n            config files or variables.\n        */\n        \"lookInContext\": 1,\n        /*\n            Number of the ID of the top level administration group in tblPermGroups.\n        */\n        \"adminGroupID\": 4,\n        /*\n            Is the tools app running on  the 'beta server'.\n        */\n        \"betaServer\": true}}],\n  \"servlet-mapping\": {\n    /*\n        URL mapping for the CDS Servlet\n    */\n     \"cofaxCDS\": \"/\",\n    /*\n        URL mapping for the Email Servlet\n    */\n     \"cofaxEmail\": \"/cofaxutil/aemail/*\",\n    /*\n        URL mapping for the Admin servlet\n    */\n     \"cofaxAdmin\": \"/admin/*\",\n    /*\n        URL mapping for the Files servlet\n    */\n     \"fileServlet\": \"/static/*\",\n     \"cofaxTools\": \"/tools/*\"},\n    /*\n        New! The cofax taglib descriptor file\n    */\n  \"taglib\": {\n    \"taglib-uri\": \"cofax.tld\",\n    \"taglib-location\": \"/WEB-INF/tlds/cofax.tld\"}}}\n\n\"\"\"\n\ntest5 = \"\"\"\n{\"menu\": {\n    \"header\": \"SVG Viewer\",\n    \"items\": [\n        {\"id\": \"Open\"},\n        {\"id\": \"OpenNew\", \"label\": \"Open New\"},\n        null,\n        {\"id\": \"ZoomIn\", \"label\": \"Zoom In\"},\n        {\"id\": \"ZoomOut\", \"label\": \"Zoom Out\"},\n        {\"id\": \"OriginalView\", \"label\": \"Original View\"},\n        null,\n        {\"id\": \"Quality\"},\n        {\"id\": \"Pause\"},\n        {\"id\": \"Mute\"},\n        null,\n        {\"id\": \"Find\", \"label\": \"Find...\"},\n        {\"id\": \"FindAgain\", \"label\": \"Find Again\"},\n        {\"id\": \"Copy\"},\n        {\"id\": \"CopyAgain\", \"label\": \"Copy Again\"},\n        {\"id\": \"CopySVG\", \"label\": \"Copy SVG\"},\n        {\"id\": \"ViewSVG\", \"label\": \"View SVG\"},\n        {\"id\": \"ViewSource\", \"label\": \"View Source\"},\n        {\"id\": \"SaveAs\", \"label\": \"Save As\"},\n        null,\n        {\"id\": \"Help\"},\n        {\"id\": \"About\", \"label\": \"About Adobe CVG Viewer...\"}\n    ]\n}}\n\"\"\"\n", "tests/test_examples.py": "#\n# test_examples.py\n#\nfrom importlib import import_module\nimport unittest\n\nfrom pyparsing import testing as ppt\n\n\nclass TestExamples(unittest.TestCase):\n    def _run(self, name):\n        mod = import_module(\"examples.\" + name)\n\n        # use pyparsing context to reset each test to clean\n        # pyparsing settings\n        with ppt.reset_pyparsing_context():\n            getattr(mod, \"main\", lambda *args, **kwargs: None)()\n\n    def test_numerics(self):\n        self._run(\"numerics\")\n\n    def test_tap(self):\n        self._run(\"TAP\")\n\n    def test_roman_numerals(self):\n        self._run(\"roman_numerals\")\n\n    def test_sexp_parser(self):\n        self._run(\"sexpParser\")\n\n    def test_oc(self):\n        self._run(\"oc\")\n\n    def test_delta_time(self):\n        self._run(\"delta_time\")\n\n    def test_eval_arith(self):\n        self._run(\"eval_arith\")\n\n    def test_select_parser(self):\n        self._run(\"select_parser\")\n\n    def test_booleansearchparser(self):\n        self._run(\"booleansearchparser\")\n\n    def test_rosettacode(self):\n        self._run(\"rosettacode\")\n\n    def test_excelExpr(self):\n        self._run(\"excel_expr\")\n\n    def test_lucene_grammar(self):\n        self._run(\"lucene_grammar\")\n\n    def test_range_check(self):\n        self._run(\"range_check\")\n\n    def test_stackish(self):\n        self._run(\"stackish\")\n\n    def test_email_parser(self):\n        self._run(\"email_address_parser\")\n", "tests/test_diagram.py": "import unittest\nfrom io import StringIO\nfrom pathlib import Path\nfrom typing import List\n\nfrom examples.jsonParser import jsonObject\nfrom examples.simpleBool import boolExpr\nfrom examples.simpleSQL import simpleSQL\nfrom examples.mozillaCalendarParser import calendars\nfrom pyparsing.diagram import to_railroad, railroad_to_html, NamedDiagram, AnnotatedItem\nimport pyparsing as pp\nimport railroad\nimport tempfile\nimport os\nimport sys\n\n\nprint(f\"Running {__file__}\")\nprint(sys.version_info)\n\ncurdir = Path(__file__).parent\n\n\ndef is_run_with_coverage():\n    \"\"\"Check whether test is run with coverage.\n    From https://stackoverflow.com/a/69812849/165216\n    \"\"\"\n    gettrace = getattr(sys, \"gettrace\", None)\n\n    if gettrace is None:\n        return False\n    else:\n        gettrace_result = gettrace()\n\n    try:\n        from coverage.pytracer import PyTracer\n        from coverage.tracer import CTracer\n\n        if isinstance(gettrace_result, (CTracer, PyTracer)):\n            return True\n    except ImportError:\n        pass\n\n    return False\n\n\ndef running_in_debug() -> bool:\n    \"\"\"\n    Returns True if we're in debug mode (determined by either setting\n    environment var, or running in a debugger which sets sys.settrace)\n    \"\"\"\n    return (\n        os.environ.get(\"RAILROAD_DEBUG\", False)\n        or sys.gettrace()\n        and not is_run_with_coverage()\n    )\n\n\nclass TestRailroadDiagrams(unittest.TestCase):\n    def get_temp(self):\n        \"\"\"\n        Returns an appropriate temporary file for writing a railroad diagram\n        \"\"\"\n        delete_on_close = not running_in_debug()\n        return tempfile.NamedTemporaryFile(\n            dir=\".\",\n            delete=delete_on_close,\n            mode=\"w\",\n            encoding=\"utf-8\",\n            suffix=\".html\",\n        )\n\n    def generate_railroad(\n        self, expr: pp.ParserElement, label: str, show_results_names: bool = False\n    ) -> List[NamedDiagram]:\n        \"\"\"\n        Generate an intermediate list of NamedDiagrams from a pyparsing expression.\n        \"\"\"\n        with self.get_temp() as temp:\n            railroad = to_railroad(expr, show_results_names=show_results_names)\n            temp.write(railroad_to_html(railroad))\n\n        if running_in_debug():\n            print(f\"{label}: {temp.name}\")\n\n        return railroad\n\n    def test_example_rr_diags(self):\n        subtests = [\n            (\"jsonObject\", jsonObject, 8),\n            (\"boolExpr\", boolExpr, 7),\n            (\"simpleSQL\", simpleSQL, 22),\n            (\"calendars\", calendars, 13),\n        ]\n        for label, example_expr, expected_rr_len in subtests:\n            with self.subTest(f\"{label}: test rr diag without results names\"):\n                railroad = self.generate_railroad(example_expr, example_expr)\n                if len(railroad) != expected_rr_len:\n                    diag_html = railroad_to_html(railroad)\n                    for line in diag_html.splitlines():\n                        if 'h1 class=\"railroad-heading\"' in line:\n                            print(line)\n                assert (\n                    len(railroad) == expected_rr_len\n                ), f\"expected {expected_rr_len}, got {len(railroad)}\"\n\n            with self.subTest(f\"{label}: test rr diag with results names\"):\n                railroad = self.generate_railroad(\n                    example_expr, example_expr, show_results_names=True\n                )\n                if len(railroad) != expected_rr_len:\n                    print(railroad_to_html(railroad))\n                assert (\n                    len(railroad) == expected_rr_len\n                ), f\"expected {expected_rr_len}, got {len(railroad)}\"\n\n    def test_nested_forward_with_inner_and_outer_names(self):\n        outer = pp.Forward().setName(\"outer\")\n        inner = pp.Word(pp.alphas)[...].setName(\"inner\")\n        outer <<= inner\n\n        railroad = self.generate_railroad(outer, \"inner_outer_names\")\n        assert len(railroad) == 2\n        railroad = self.generate_railroad(\n            outer, \"inner_outer_names\", show_results_names=True\n        )\n        assert len(railroad) == 2\n\n    def test_nested_forward_with_inner_name_only(self):\n        outer = pp.Forward()\n        inner = pp.Word(pp.alphas)[...].setName(\"inner\")\n        outer <<= inner\n\n        railroad = self.generate_railroad(outer, \"inner_only\")\n        assert len(railroad) == 2\n        railroad = self.generate_railroad(outer, \"inner_only\", show_results_names=True)\n        assert len(railroad) == 2\n\n    def test_each_grammar(self):\n\n        grammar = pp.Each(\n            [\n                pp.Word(pp.nums),\n                pp.Word(pp.alphas),\n                pp.pyparsing_common.uuid,\n            ]\n        ).setName(\"int-word-uuid in any order\")\n        railroad = self.generate_railroad(grammar, \"each_expression\")\n        assert len(railroad) == 2\n        railroad = self.generate_railroad(\n            grammar, \"each_expression\", show_results_names=True\n        )\n        assert len(railroad) == 2\n\n    def test_none_name(self):\n        grammar = pp.Or([\"foo\", \"bar\"])\n        railroad = to_railroad(grammar)\n        assert len(railroad) == 1\n        assert railroad[0].name is not None\n\n    def test_none_name2(self):\n        grammar = pp.Or([\"foo\", \"bar\"]) + pp.Word(pp.nums).setName(\"integer\")\n        railroad = to_railroad(grammar)\n        assert len(railroad) == 2\n        assert railroad[0].name is not None\n        railroad = to_railroad(grammar, show_results_names=True)\n        assert len(railroad) == 2\n\n    def test_complete_combine_element(self):\n        ints = pp.Word(pp.nums)\n        grammar = pp.Combine(\n            ints(\"hours\") + \":\" + ints(\"minutes\") + \":\" + ints(\"seconds\")\n        )\n        railroad = to_railroad(grammar)\n        assert len(railroad) == 1\n        railroad = to_railroad(grammar, show_results_names=True)\n        assert len(railroad) == 1\n\n    def test_create_diagram(self):\n        ints = pp.Word(pp.nums)\n        grammar = pp.Combine(\n            ints(\"hours\") + \":\" + ints(\"minutes\") + \":\" + ints(\"seconds\")\n        )\n\n        diag_strio = StringIO()\n        grammar.create_diagram(output_html=diag_strio)\n        diag_str = diag_strio.getvalue().lower()\n        tags = \"<html> </html> <head> </head> <body> </body>\".split()\n        assert all(tag in diag_str for tag in tags)\n\n    def test_create_diagram_embed(self):\n        ints = pp.Word(pp.nums)\n        grammar = pp.Combine(\n            ints(\"hours\") + \":\" + ints(\"minutes\") + \":\" + ints(\"seconds\")\n        )\n\n        diag_strio = StringIO()\n        grammar.create_diagram(output_html=diag_strio, embed=True)\n        diag_str = diag_strio.getvalue().lower()\n        tags = \"<html> </html> <head> </head> <body> </body>\".split()\n        assert not any(tag in diag_str for tag in tags)\n\n    def test_create_diagram_for_oneormore_with_stopon(self):\n        wd = pp.Word(pp.alphas)\n        grammar = \"start\" + wd[1, ...:\"end\"] + \"end\"\n\n        pp.autoname_elements()\n        railroad_diag = to_railroad(grammar)\n        assert len(railroad_diag) == 3\n        assert isinstance(railroad_diag[1][1].items[1].item, railroad.Sequence)\n        assert isinstance(railroad_diag[1][1].items[1].item.items[0], AnnotatedItem)\n        assert isinstance(\n            railroad_diag[1][1].items[1].item.items[1], railroad.NonTerminal\n        )\n\n    def test_kwargs_pass_thru_create_diagram(self):\n        from io import StringIO\n\n        # Creates a simple diagram with a blue body and\n        # various other railroad features colored with\n        # a complete disregard for taste\n\n        # Very simple grammar for demo purposes\n        salutation = pp.Word(pp.alphas).set_name(\"salutation\")\n        subject = pp.rest_of_line.set_name(\"subject\")\n        parse_grammar = salutation + subject\n\n        # This is used to turn off the railroads\n        # definition of DEFAULT_STYLE.\n        # If this is set to 'None' the default style\n        # will be written as part of each diagram\n        # and will you will not be able to set the\n        # css style globally and the string 'expStyle'\n        # will have no effect.\n        # There is probably a PR to railroad_diagram to\n        # remove some cruft left in the SVG.\n        DEFAULT_STYLE = \"\"\n\n        # CSS Code to be placed into head of the html file\n        expStyle = \"\"\"\n        <style type=\"text/css\">\n\n        body {\n            background-color: blue;\n        }\n\n        .railroad-heading {\n            font-family: monospace;\n            color: bisque;\n        }\n\n        svg.railroad-diagram {\n            background-color: hsl(264,45%,85%);\n        }\n        svg.railroad-diagram path {\n            stroke-width: 3;\n            stroke: green;\n            fill: rgba(0,0,0,0);\n        }\n        svg.railroad-diagram text {\n            font: bold 14px monospace;\n            text-anchor: middle;\n            white-space: pre;\n        }\n        svg.railroad-diagram text.diagram-text {\n            font-size: 12px;\n        }\n        svg.railroad-diagram text.diagram-arrow {\n            font-size: 16px;\n        }\n        svg.railroad-diagram text.label {\n            text-anchor: start;\n        }\n        svg.railroad-diagram text.comment {\n            font: italic 12px monospace;\n        }\n        svg.railroad-diagram g.non-terminal text {\n            /*font-style: italic;*/\n        }\n        svg.railroad-diagram rect {\n            stroke-width: 3;\n            stroke: black;\n            fill: hsl(55, 72%, 69%);\n        }\n        svg.railroad-diagram rect.group-box {\n            stroke: rgb(33, 8, 225);\n            stroke-dasharray: 10 5;\n            fill: none;\n        }\n        svg.railroad-diagram path.diagram-text {\n            stroke-width: 3;\n            stroke: black;\n            fill: white;\n            cursor: help;\n        }\n        svg.railroad-diagram g.diagram-text:hover path.diagram-text {\n            fill: #eee;\n        }\n        </style>\n        \"\"\"\n\n        # the 'css=DEFAULT_STYLE' or 'css=\"\"' is needed to turn off railroad_diagrams styling\n        diag_html_capture = StringIO()\n        parse_grammar.create_diagram(\n            diag_html_capture,\n            vertical=6,\n            show_results_names=True,\n            css=DEFAULT_STYLE,\n            head=expStyle,\n        )\n\n        self.assertIn(expStyle, diag_html_capture.getvalue())\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "tests/__init__.py": "", "tests/mypy-ignore-cases/forward_methods.py": "import pyparsing as pp\n\n# first, some basic validation: forward is a ParserElement, so is Literal\n# MatchFirst([Forward(), Literal(...)]) should also be okay\ne: pp.ParserElement = pp.Forward()\ne = pp.Literal()\ne = pp.MatchFirst([pp.Forward(), pp.Literal(\"hi there\")])\n# confirm that it isn't returning Any because it cannot be assigned to a str\nx: str = pp.Forward() | pp.Literal(\"oops\")  # type: ignore[assignment]\n\n# confirm that `Forward.__or__` has the right behavior\ne = pp.Forward() | pp.Literal(\"nice to meet you\")\n# and that it isn't returning Any because it cannot be assigned to an int\ny: int = pp.Forward() | pp.Literal(\"oops\")  # type: ignore[assignment]\n", "pyparsing/common.py": "# common.py\nfrom .core import *\nfrom .helpers import DelimitedList, any_open_tag, any_close_tag\nfrom datetime import datetime\n\n\n# some other useful expressions - using lower-case class name since we are really using this as a namespace\nclass pyparsing_common:\n    \"\"\"Here are some common low-level expressions that may be useful in\n    jump-starting parser development:\n\n    - numeric forms (:class:`integers<integer>`, :class:`reals<real>`,\n      :class:`scientific notation<sci_real>`)\n    - common :class:`programming identifiers<identifier>`\n    - network addresses (:class:`MAC<mac_address>`,\n      :class:`IPv4<ipv4_address>`, :class:`IPv6<ipv6_address>`)\n    - ISO8601 :class:`dates<iso8601_date>` and\n      :class:`datetime<iso8601_datetime>`\n    - :class:`UUID<uuid>`\n    - :class:`comma-separated list<comma_separated_list>`\n    - :class:`url`\n\n    Parse actions:\n\n    - :class:`convert_to_integer`\n    - :class:`convert_to_float`\n    - :class:`convert_to_date`\n    - :class:`convert_to_datetime`\n    - :class:`strip_html_tags`\n    - :class:`upcase_tokens`\n    - :class:`downcase_tokens`\n\n    Example::\n\n        pyparsing_common.number.run_tests('''\n            # any int or real number, returned as the appropriate type\n            100\n            -100\n            +100\n            3.14159\n            6.02e23\n            1e-12\n            ''')\n\n        pyparsing_common.fnumber.run_tests('''\n            # any int or real number, returned as float\n            100\n            -100\n            +100\n            3.14159\n            6.02e23\n            1e-12\n            ''')\n\n        pyparsing_common.hex_integer.run_tests('''\n            # hex numbers\n            100\n            FF\n            ''')\n\n        pyparsing_common.fraction.run_tests('''\n            # fractions\n            1/2\n            -3/4\n            ''')\n\n        pyparsing_common.mixed_integer.run_tests('''\n            # mixed fractions\n            1\n            1/2\n            -3/4\n            1-3/4\n            ''')\n\n        import uuid\n        pyparsing_common.uuid.set_parse_action(token_map(uuid.UUID))\n        pyparsing_common.uuid.run_tests('''\n            # uuid\n            12345678-1234-5678-1234-567812345678\n            ''')\n\n    prints::\n\n        # any int or real number, returned as the appropriate type\n        100\n        [100]\n\n        -100\n        [-100]\n\n        +100\n        [100]\n\n        3.14159\n        [3.14159]\n\n        6.02e23\n        [6.02e+23]\n\n        1e-12\n        [1e-12]\n\n        # any int or real number, returned as float\n        100\n        [100.0]\n\n        -100\n        [-100.0]\n\n        +100\n        [100.0]\n\n        3.14159\n        [3.14159]\n\n        6.02e23\n        [6.02e+23]\n\n        1e-12\n        [1e-12]\n\n        # hex numbers\n        100\n        [256]\n\n        FF\n        [255]\n\n        # fractions\n        1/2\n        [0.5]\n\n        -3/4\n        [-0.75]\n\n        # mixed fractions\n        1\n        [1]\n\n        1/2\n        [0.5]\n\n        -3/4\n        [-0.75]\n\n        1-3/4\n        [1.75]\n\n        # uuid\n        12345678-1234-5678-1234-567812345678\n        [UUID('12345678-1234-5678-1234-567812345678')]\n    \"\"\"\n\n    convert_to_integer = token_map(int)\n    \"\"\"\n    Parse action for converting parsed integers to Python int\n    \"\"\"\n\n    convert_to_float = token_map(float)\n    \"\"\"\n    Parse action for converting parsed numbers to Python float\n    \"\"\"\n\n    integer = Word(nums).set_name(\"integer\").set_parse_action(convert_to_integer)\n    \"\"\"expression that parses an unsigned integer, returns an int\"\"\"\n\n    hex_integer = (\n        Word(hexnums).set_name(\"hex integer\").set_parse_action(token_map(int, 16))\n    )\n    \"\"\"expression that parses a hexadecimal integer, returns an int\"\"\"\n\n    signed_integer = (\n        Regex(r\"[+-]?\\d+\")\n        .set_name(\"signed integer\")\n        .set_parse_action(convert_to_integer)\n    )\n    \"\"\"expression that parses an integer with optional leading sign, returns an int\"\"\"\n\n    fraction = (\n        signed_integer().set_parse_action(convert_to_float)\n        + \"/\"\n        + signed_integer().set_parse_action(convert_to_float)\n    ).set_name(\"fraction\")\n    \"\"\"fractional expression of an integer divided by an integer, returns a float\"\"\"\n    fraction.add_parse_action(lambda tt: tt[0] / tt[-1])\n\n    mixed_integer = (\n        fraction | signed_integer + Opt(Opt(\"-\").suppress() + fraction)\n    ).set_name(\"fraction or mixed integer-fraction\")\n    \"\"\"mixed integer of the form 'integer - fraction', with optional leading integer, returns float\"\"\"\n    mixed_integer.add_parse_action(sum)\n\n    real = (\n        Regex(r\"[+-]?(?:\\d+\\.\\d*|\\.\\d+)\")\n        .set_name(\"real number\")\n        .set_parse_action(convert_to_float)\n    )\n    \"\"\"expression that parses a floating point number and returns a float\"\"\"\n\n    sci_real = (\n        Regex(r\"[+-]?(?:\\d+(?:[eE][+-]?\\d+)|(?:\\d+\\.\\d*|\\.\\d+)(?:[eE][+-]?\\d+)?)\")\n        .set_name(\"real number with scientific notation\")\n        .set_parse_action(convert_to_float)\n    )\n    \"\"\"expression that parses a floating point number with optional\n    scientific notation and returns a float\"\"\"\n\n    # streamlining this expression makes the docs nicer-looking\n    number = (sci_real | real | signed_integer).set_name(\"number\").streamline()\n    \"\"\"any numeric expression, returns the corresponding Python type\"\"\"\n\n    fnumber = (\n        Regex(r\"[+-]?\\d+\\.?\\d*([eE][+-]?\\d+)?\")\n        .set_name(\"fnumber\")\n        .set_parse_action(convert_to_float)\n    )\n    \"\"\"any int or real number, returned as float\"\"\"\n\n    ieee_float = (\n        Regex(r\"(?i)[+-]?((\\d+\\.?\\d*(e[+-]?\\d+)?)|nan|inf(inity)?)\")\n        .set_name(\"ieee_float\")\n        .set_parse_action(convert_to_float)\n    )\n    \"\"\"any floating-point literal (int, real number, infinity, or NaN), returned as float\"\"\"\n\n    identifier = Word(identchars, identbodychars).set_name(\"identifier\")\n    \"\"\"typical code identifier (leading alpha or '_', followed by 0 or more alphas, nums, or '_')\"\"\"\n\n    ipv4_address = Regex(\n        r\"(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})(\\.(25[0-5]|2[0-4][0-9]|1?[0-9]{1,2})){3}\"\n    ).set_name(\"IPv4 address\")\n    \"IPv4 address (``0.0.0.0 - 255.255.255.255``)\"\n\n    _ipv6_part = Regex(r\"[0-9a-fA-F]{1,4}\").set_name(\"hex_integer\")\n    _full_ipv6_address = (_ipv6_part + (\":\" + _ipv6_part) * 7).set_name(\n        \"full IPv6 address\"\n    )\n    _short_ipv6_address = (\n        Opt(_ipv6_part + (\":\" + _ipv6_part) * (0, 6))\n        + \"::\"\n        + Opt(_ipv6_part + (\":\" + _ipv6_part) * (0, 6))\n    ).set_name(\"short IPv6 address\")\n    _short_ipv6_address.add_condition(\n        lambda t: sum(1 for tt in t if pyparsing_common._ipv6_part.matches(tt)) < 8\n    )\n    _mixed_ipv6_address = (\"::ffff:\" + ipv4_address).set_name(\"mixed IPv6 address\")\n    ipv6_address = Combine(\n        (_full_ipv6_address | _mixed_ipv6_address | _short_ipv6_address).set_name(\n            \"IPv6 address\"\n        )\n    ).set_name(\"IPv6 address\")\n    \"IPv6 address (long, short, or mixed form)\"\n\n    mac_address = Regex(\n        r\"[0-9a-fA-F]{2}([:.-])[0-9a-fA-F]{2}(?:\\1[0-9a-fA-F]{2}){4}\"\n    ).set_name(\"MAC address\")\n    \"MAC address xx:xx:xx:xx:xx (may also have '-' or '.' delimiters)\"\n\n    @staticmethod\n    def convert_to_date(fmt: str = \"%Y-%m-%d\"):\n        \"\"\"\n        Helper to create a parse action for converting parsed date string to Python datetime.date\n\n        Params -\n        - fmt - format to be passed to datetime.strptime (default= ``\"%Y-%m-%d\"``)\n\n        Example::\n\n            date_expr = pyparsing_common.iso8601_date.copy()\n            date_expr.set_parse_action(pyparsing_common.convert_to_date())\n            print(date_expr.parse_string(\"1999-12-31\"))\n\n        prints::\n\n            [datetime.date(1999, 12, 31)]\n        \"\"\"\n\n        def cvt_fn(ss, ll, tt):\n            try:\n                return datetime.strptime(tt[0], fmt).date()\n            except ValueError as ve:\n                raise ParseException(ss, ll, str(ve))\n\n        return cvt_fn\n\n    @staticmethod\n    def convert_to_datetime(fmt: str = \"%Y-%m-%dT%H:%M:%S.%f\"):\n        \"\"\"Helper to create a parse action for converting parsed\n        datetime string to Python datetime.datetime\n\n        Params -\n        - fmt - format to be passed to datetime.strptime (default= ``\"%Y-%m-%dT%H:%M:%S.%f\"``)\n\n        Example::\n\n            dt_expr = pyparsing_common.iso8601_datetime.copy()\n            dt_expr.set_parse_action(pyparsing_common.convert_to_datetime())\n            print(dt_expr.parse_string(\"1999-12-31T23:59:59.999\"))\n\n        prints::\n\n            [datetime.datetime(1999, 12, 31, 23, 59, 59, 999000)]\n        \"\"\"\n\n        def cvt_fn(s, l, t):\n            try:\n                return datetime.strptime(t[0], fmt)\n            except ValueError as ve:\n                raise ParseException(s, l, str(ve))\n\n        return cvt_fn\n\n    iso8601_date = Regex(\n        r\"(?P<year>\\d{4})(?:-(?P<month>\\d\\d)(?:-(?P<day>\\d\\d))?)?\"\n    ).set_name(\"ISO8601 date\")\n    \"ISO8601 date (``yyyy-mm-dd``)\"\n\n    iso8601_datetime = Regex(\n        r\"(?P<year>\\d{4})-(?P<month>\\d\\d)-(?P<day>\\d\\d)[T ](?P<hour>\\d\\d):(?P<minute>\\d\\d)(:(?P<second>\\d\\d(\\.\\d*)?)?)?(?P<tz>Z|[+-]\\d\\d:?\\d\\d)?\"\n    ).set_name(\"ISO8601 datetime\")\n    \"ISO8601 datetime (``yyyy-mm-ddThh:mm:ss.s(Z|+-00:00)``) - trailing seconds, milliseconds, and timezone optional; accepts separating ``'T'`` or ``' '``\"\n\n    uuid = Regex(r\"[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}\").set_name(\"UUID\")\n    \"UUID (``xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx``)\"\n\n    _html_stripper = any_open_tag.suppress() | any_close_tag.suppress()\n\n    @staticmethod\n    def strip_html_tags(s: str, l: int, tokens: ParseResults):\n        \"\"\"Parse action to remove HTML tags from web page HTML source\n\n        Example::\n\n            # strip HTML links from normal text\n            text = '<td>More info at the <a href=\"https://github.com/pyparsing/pyparsing/wiki\">pyparsing</a> wiki page</td>'\n            td, td_end = make_html_tags(\"TD\")\n            table_text = td + SkipTo(td_end).set_parse_action(pyparsing_common.strip_html_tags)(\"body\") + td_end\n            print(table_text.parse_string(text).body)\n\n        Prints::\n\n            More info at the pyparsing wiki page\n        \"\"\"\n        return pyparsing_common._html_stripper.transform_string(tokens[0])\n\n    _commasepitem = (\n        Combine(\n            OneOrMore(\n                ~Literal(\",\")\n                + ~LineEnd()\n                + Word(printables, exclude_chars=\",\")\n                + Opt(White(\" \\t\") + ~FollowedBy(LineEnd() | \",\"))\n            )\n        )\n        .streamline()\n        .set_name(\"commaItem\")\n    )\n    comma_separated_list = DelimitedList(\n        Opt(quoted_string.copy() | _commasepitem, default=\"\")\n    ).set_name(\"comma separated list\")\n    \"\"\"Predefined expression of 1 or more printable words or quoted strings, separated by commas.\"\"\"\n\n    upcase_tokens = staticmethod(token_map(lambda t: t.upper()))\n    \"\"\"Parse action to convert tokens to upper case.\"\"\"\n\n    downcase_tokens = staticmethod(token_map(lambda t: t.lower()))\n    \"\"\"Parse action to convert tokens to lower case.\"\"\"\n\n    # fmt: off\n    url = Regex(\n        # https://mathiasbynens.be/demo/url-regex\n        # https://gist.github.com/dperini/729294\n        r\"(?P<url>\" +\n        # protocol identifier (optional)\n        # short syntax // still required\n        r\"(?:(?:(?P<scheme>https?|ftp):)?\\/\\/)\" +\n        # user:pass BasicAuth (optional)\n        r\"(?:(?P<auth>\\S+(?::\\S*)?)@)?\" +\n        r\"(?P<host>\" +\n        # IP address exclusion\n        # private & local networks\n        r\"(?!(?:10|127)(?:\\.\\d{1,3}){3})\" +\n        r\"(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})\" +\n        r\"(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})\" +\n        # IP address dotted notation octets\n        # excludes loopback network 0.0.0.0\n        # excludes reserved space >= 224.0.0.0\n        # excludes network & broadcast addresses\n        # (first & last IP address of each class)\n        r\"(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])\" +\n        r\"(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}\" +\n        r\"(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))\" +\n        r\"|\" +\n        # host & domain names, may end with dot\n        # can be replaced by a shortest alternative\n        # (?![-_])(?:[-\\w\\u00a1-\\uffff]{0,63}[^-_]\\.)+\n        r\"(?:\" +\n        r\"(?:\" +\n        r\"[a-z0-9\\u00a1-\\uffff]\" +\n        r\"[a-z0-9\\u00a1-\\uffff_-]{0,62}\" +\n        r\")?\" +\n        r\"[a-z0-9\\u00a1-\\uffff]\\.\" +\n        r\")+\" +\n        # TLD identifier name, may end with dot\n        r\"(?:[a-z\\u00a1-\\uffff]{2,}\\.?)\" +\n        r\")\" +\n        # port number (optional)\n        r\"(:(?P<port>\\d{2,5}))?\" +\n        # resource path (optional)\n        r\"(?P<path>\\/[^?# ]*)?\" +\n        # query string (optional)\n        r\"(\\?(?P<query>[^#]*))?\" +\n        # fragment (optional)\n        r\"(#(?P<fragment>\\S*))?\" +\n        r\")\"\n    ).set_name(\"url\")\n    \"\"\"URL (http/https/ftp scheme)\"\"\"\n    # fmt: on\n\n    # pre-PEP8 compatibility names\n    # fmt: off\n    convertToInteger = staticmethod(replaced_by_pep8(\"convertToInteger\", convert_to_integer))\n    convertToFloat = staticmethod(replaced_by_pep8(\"convertToFloat\", convert_to_float))\n    convertToDate = staticmethod(replaced_by_pep8(\"convertToDate\", convert_to_date))\n    convertToDatetime = staticmethod(replaced_by_pep8(\"convertToDatetime\", convert_to_datetime))\n    stripHTMLTags = staticmethod(replaced_by_pep8(\"stripHTMLTags\", strip_html_tags))\n    upcaseTokens = staticmethod(replaced_by_pep8(\"upcaseTokens\", upcase_tokens))\n    downcaseTokens = staticmethod(replaced_by_pep8(\"downcaseTokens\", downcase_tokens))\n    # fmt: on\n\n\n_builtin_exprs = [\n    v for v in vars(pyparsing_common).values() if isinstance(v, ParserElement)\n]\n", "pyparsing/actions.py": "# actions.py\n\nfrom .exceptions import ParseException\nfrom .util import col, replaced_by_pep8\n\n\nclass OnlyOnce:\n    \"\"\"\n    Wrapper for parse actions, to ensure they are only called once.\n    \"\"\"\n\n    def __init__(self, method_call):\n        from .core import _trim_arity\n\n        self.callable = _trim_arity(method_call)\n        self.called = False\n\n    def __call__(self, s, l, t):\n        if not self.called:\n            results = self.callable(s, l, t)\n            self.called = True\n            return results\n        raise ParseException(s, l, \"OnlyOnce obj called multiple times w/out reset\")\n\n    def reset(self):\n        \"\"\"\n        Allow the associated parse action to be called once more.\n        \"\"\"\n\n        self.called = False\n\n\ndef match_only_at_col(n):\n    \"\"\"\n    Helper method for defining parse actions that require matching at\n    a specific column in the input text.\n    \"\"\"\n\n    def verify_col(strg, locn, toks):\n        if col(locn, strg) != n:\n            raise ParseException(strg, locn, f\"matched token not at column {n}\")\n\n    return verify_col\n\n\ndef replace_with(repl_str):\n    \"\"\"\n    Helper method for common parse actions that simply return\n    a literal value.  Especially useful when used with\n    :class:`transform_string<ParserElement.transform_string>` ().\n\n    Example::\n\n        num = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n        na = one_of(\"N/A NA\").set_parse_action(replace_with(math.nan))\n        term = na | num\n\n        term[1, ...].parse_string(\"324 234 N/A 234\") # -> [324, 234, nan, 234]\n    \"\"\"\n    return lambda s, l, t: [repl_str]\n\n\ndef remove_quotes(s, l, t):\n    \"\"\"\n    Helper parse action for removing quotation marks from parsed\n    quoted strings.\n\n    Example::\n\n        # by default, quotation marks are included in parsed results\n        quoted_string.parse_string(\"'Now is the Winter of our Discontent'\") # -> [\"'Now is the Winter of our Discontent'\"]\n\n        # use remove_quotes to strip quotation marks from parsed results\n        quoted_string.set_parse_action(remove_quotes)\n        quoted_string.parse_string(\"'Now is the Winter of our Discontent'\") # -> [\"Now is the Winter of our Discontent\"]\n    \"\"\"\n    return t[0][1:-1]\n\n\ndef with_attribute(*args, **attr_dict):\n    \"\"\"\n    Helper to create a validating parse action to be used with start\n    tags created with :class:`make_xml_tags` or\n    :class:`make_html_tags`. Use ``with_attribute`` to qualify\n    a starting tag with a required attribute value, to avoid false\n    matches on common tags such as ``<TD>`` or ``<DIV>``.\n\n    Call ``with_attribute`` with a series of attribute names and\n    values. Specify the list of filter attributes names and values as:\n\n    - keyword arguments, as in ``(align=\"right\")``, or\n    - as an explicit dict with ``**`` operator, when an attribute\n      name is also a Python reserved word, as in ``**{\"class\":\"Customer\", \"align\":\"right\"}``\n    - a list of name-value tuples, as in ``((\"ns1:class\", \"Customer\"), (\"ns2:align\", \"right\"))``\n\n    For attribute names with a namespace prefix, you must use the second\n    form.  Attribute names are matched insensitive to upper/lower case.\n\n    If just testing for ``class`` (with or without a namespace), use\n    :class:`with_class`.\n\n    To verify that the attribute exists, but without specifying a value,\n    pass ``with_attribute.ANY_VALUE`` as the value.\n\n    Example::\n\n        html = '''\n            <div>\n            Some text\n            <div type=\"grid\">1 4 0 1 0</div>\n            <div type=\"graph\">1,3 2,3 1,1</div>\n            <div>this has no type</div>\n            </div>\n        '''\n        div,div_end = make_html_tags(\"div\")\n\n        # only match div tag having a type attribute with value \"grid\"\n        div_grid = div().set_parse_action(with_attribute(type=\"grid\"))\n        grid_expr = div_grid + SkipTo(div | div_end)(\"body\")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        # construct a match with any div tag having a type attribute, regardless of the value\n        div_any_type = div().set_parse_action(with_attribute(type=with_attribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)(\"body\")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    \"\"\"\n    if args:\n        attrs = args[:]\n    else:\n        attrs = attr_dict.items()\n    attrs = [(k, v) for k, v in attrs]\n\n    def pa(s, l, tokens):\n        for attrName, attrValue in attrs:\n            if attrName not in tokens:\n                raise ParseException(s, l, \"no matching attribute \" + attrName)\n            if attrValue != with_attribute.ANY_VALUE and tokens[attrName] != attrValue:\n                raise ParseException(\n                    s,\n                    l,\n                    f\"attribute {attrName!r} has value {tokens[attrName]!r}, must be {attrValue!r}\",\n                )\n\n    return pa\n\n\nwith_attribute.ANY_VALUE = object()  # type: ignore [attr-defined]\n\n\ndef with_class(classname, namespace=\"\"):\n    \"\"\"\n    Simplified version of :class:`with_attribute` when\n    matching on a div class - made difficult because ``class`` is\n    a reserved word in Python.\n\n    Example::\n\n        html = '''\n            <div>\n            Some text\n            <div class=\"grid\">1 4 0 1 0</div>\n            <div class=\"graph\">1,3 2,3 1,1</div>\n            <div>this &lt;div&gt; has no class</div>\n            </div>\n\n        '''\n        div,div_end = make_html_tags(\"div\")\n        div_grid = div().set_parse_action(with_class(\"grid\"))\n\n        grid_expr = div_grid + SkipTo(div | div_end)(\"body\")\n        for grid_header in grid_expr.search_string(html):\n            print(grid_header.body)\n\n        div_any_type = div().set_parse_action(with_class(withAttribute.ANY_VALUE))\n        div_expr = div_any_type + SkipTo(div | div_end)(\"body\")\n        for div_header in div_expr.search_string(html):\n            print(div_header.body)\n\n    prints::\n\n        1 4 0 1 0\n\n        1 4 0 1 0\n        1,3 2,3 1,1\n    \"\"\"\n    classattr = f\"{namespace}:class\" if namespace else \"class\"\n    return with_attribute(**{classattr: classname})\n\n\n# Compatibility synonyms\n# fmt: off\nreplaceWith = replaced_by_pep8(\"replaceWith\", replace_with)\nremoveQuotes = replaced_by_pep8(\"removeQuotes\", remove_quotes)\nwithAttribute = replaced_by_pep8(\"withAttribute\", with_attribute)\nwithClass = replaced_by_pep8(\"withClass\", with_class)\nmatchOnlyAtCol = replaced_by_pep8(\"matchOnlyAtCol\", match_only_at_col)\n# fmt: on\n", "pyparsing/core.py": "#\n# core.py\n#\n\nfrom collections import deque\nimport os\nimport typing\nfrom typing import (\n    Any,\n    Callable,\n    Generator,\n    List,\n    NamedTuple,\n    Sequence,\n    Set,\n    TextIO,\n    Tuple,\n    Union,\n    cast,\n)\nfrom abc import ABC, abstractmethod\nfrom enum import Enum\nimport string\nimport copy\nimport warnings\nimport re\nimport sys\nfrom collections.abc import Iterable\nimport traceback\nimport types\nfrom operator import itemgetter\nfrom functools import wraps\nfrom threading import RLock\nfrom pathlib import Path\n\nfrom .util import (\n    _FifoCache,\n    _UnboundedCache,\n    __config_flags,\n    _collapse_string_to_ranges,\n    _escape_regex_range_chars,\n    _bslash,\n    _flatten,\n    LRUMemo as _LRUMemo,\n    UnboundedMemo as _UnboundedMemo,\n    replaced_by_pep8,\n)\nfrom .exceptions import *\nfrom .actions import *\nfrom .results import ParseResults, _ParseResultsWithOffset\nfrom .unicode import pyparsing_unicode\n\n_MAX_INT = sys.maxsize\nstr_type: Tuple[type, ...] = (str, bytes)\n\n#\n# Copyright (c) 2003-2022  Paul T. McGuire\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n\nif sys.version_info >= (3, 8):\n    from functools import cached_property\nelse:\n\n    class cached_property:\n        def __init__(self, func):\n            self._func = func\n\n        def __get__(self, instance, owner=None):\n            ret = instance.__dict__[self._func.__name__] = self._func(instance)\n            return ret\n\n\nclass __compat__(__config_flags):\n    \"\"\"\n    A cross-version compatibility configuration for pyparsing features that will be\n    released in a future version. By setting values in this configuration to True,\n    those features can be enabled in prior versions for compatibility development\n    and testing.\n\n    - ``collect_all_And_tokens`` - flag to enable fix for Issue #63 that fixes erroneous grouping\n      of results names when an :class:`And` expression is nested within an :class:`Or` or :class:`MatchFirst`;\n      maintained for compatibility, but setting to ``False`` no longer restores pre-2.3.1\n      behavior\n    \"\"\"\n\n    _type_desc = \"compatibility\"\n\n    collect_all_And_tokens = True\n\n    _all_names = [__ for __ in locals() if not __.startswith(\"_\")]\n    _fixed_names = \"\"\"\n        collect_all_And_tokens\n        \"\"\".split()\n\n\nclass __diag__(__config_flags):\n    _type_desc = \"diagnostic\"\n\n    warn_multiple_tokens_in_named_alternation = False\n    warn_ungrouped_named_tokens_in_collection = False\n    warn_name_set_on_empty_Forward = False\n    warn_on_parse_using_empty_Forward = False\n    warn_on_assignment_to_Forward = False\n    warn_on_multiple_string_args_to_oneof = False\n    warn_on_match_first_with_lshift_operator = False\n    enable_debug_on_named_expressions = False\n\n    _all_names = [__ for __ in locals() if not __.startswith(\"_\")]\n    _warning_names = [name for name in _all_names if name.startswith(\"warn\")]\n    _debug_names = [name for name in _all_names if name.startswith(\"enable_debug\")]\n\n    @classmethod\n    def enable_all_warnings(cls) -> None:\n        for name in cls._warning_names:\n            cls.enable(name)\n\n\nclass Diagnostics(Enum):\n    \"\"\"\n    Diagnostic configuration (all default to disabled)\n\n    - ``warn_multiple_tokens_in_named_alternation`` - flag to enable warnings when a results\n      name is defined on a :class:`MatchFirst` or :class:`Or` expression with one or more :class:`And` subexpressions\n    - ``warn_ungrouped_named_tokens_in_collection`` - flag to enable warnings when a results\n      name is defined on a containing expression with ungrouped subexpressions that also\n      have results names\n    - ``warn_name_set_on_empty_Forward`` - flag to enable warnings when a :class:`Forward` is defined\n      with a results name, but has no contents defined\n    - ``warn_on_parse_using_empty_Forward`` - flag to enable warnings when a :class:`Forward` is\n      defined in a grammar but has never had an expression attached to it\n    - ``warn_on_assignment_to_Forward`` - flag to enable warnings when a :class:`Forward` is defined\n      but is overwritten by assigning using ``'='`` instead of ``'<<='`` or ``'<<'``\n    - ``warn_on_multiple_string_args_to_oneof`` - flag to enable warnings when :class:`one_of` is\n      incorrectly called with multiple str arguments\n    - ``enable_debug_on_named_expressions`` - flag to auto-enable debug on all subsequent\n      calls to :class:`ParserElement.set_name`\n\n    Diagnostics are enabled/disabled by calling :class:`enable_diag` and :class:`disable_diag`.\n    All warnings can be enabled by calling :class:`enable_all_warnings`.\n    \"\"\"\n\n    warn_multiple_tokens_in_named_alternation = 0\n    warn_ungrouped_named_tokens_in_collection = 1\n    warn_name_set_on_empty_Forward = 2\n    warn_on_parse_using_empty_Forward = 3\n    warn_on_assignment_to_Forward = 4\n    warn_on_multiple_string_args_to_oneof = 5\n    warn_on_match_first_with_lshift_operator = 6\n    enable_debug_on_named_expressions = 7\n\n\ndef enable_diag(diag_enum: Diagnostics) -> None:\n    \"\"\"\n    Enable a global pyparsing diagnostic flag (see :class:`Diagnostics`).\n    \"\"\"\n    __diag__.enable(diag_enum.name)\n\n\ndef disable_diag(diag_enum: Diagnostics) -> None:\n    \"\"\"\n    Disable a global pyparsing diagnostic flag (see :class:`Diagnostics`).\n    \"\"\"\n    __diag__.disable(diag_enum.name)\n\n\ndef enable_all_warnings() -> None:\n    \"\"\"\n    Enable all global pyparsing diagnostic warnings (see :class:`Diagnostics`).\n    \"\"\"\n    __diag__.enable_all_warnings()\n\n\n# hide abstract class\ndel __config_flags\n\n\ndef _should_enable_warnings(\n    cmd_line_warn_options: typing.Iterable[str], warn_env_var: typing.Optional[str]\n) -> bool:\n    enable = bool(warn_env_var)\n    for warn_opt in cmd_line_warn_options:\n        w_action, w_message, w_category, w_module, w_line = (warn_opt + \"::::\").split(\n            \":\"\n        )[:5]\n        if not w_action.lower().startswith(\"i\") and (\n            not (w_message or w_category or w_module) or w_module == \"pyparsing\"\n        ):\n            enable = True\n        elif w_action.lower().startswith(\"i\") and w_module in (\"pyparsing\", \"\"):\n            enable = False\n    return enable\n\n\nif _should_enable_warnings(\n    sys.warnoptions, os.environ.get(\"PYPARSINGENABLEALLWARNINGS\")\n):\n    enable_all_warnings()\n\n\n# build list of single arg builtins, that can be used as parse actions\n# fmt: off\n_single_arg_builtins = {\n    sum, len, sorted, reversed, list, tuple, set, any, all, min, max\n}\n# fmt: on\n\n_generatorType = types.GeneratorType\nParseImplReturnType = Tuple[int, Any]\nPostParseReturnType = Union[ParseResults, Sequence[ParseResults]]\nParseAction = Union[\n    Callable[[], Any],\n    Callable[[ParseResults], Any],\n    Callable[[int, ParseResults], Any],\n    Callable[[str, int, ParseResults], Any],\n]\nParseCondition = Union[\n    Callable[[], bool],\n    Callable[[ParseResults], bool],\n    Callable[[int, ParseResults], bool],\n    Callable[[str, int, ParseResults], bool],\n]\nParseFailAction = Callable[[str, int, \"ParserElement\", Exception], None]\nDebugStartAction = Callable[[str, int, \"ParserElement\", bool], None]\nDebugSuccessAction = Callable[\n    [str, int, int, \"ParserElement\", ParseResults, bool], None\n]\nDebugExceptionAction = Callable[[str, int, \"ParserElement\", Exception, bool], None]\n\n\nalphas: str = string.ascii_uppercase + string.ascii_lowercase\nidentchars: str = pyparsing_unicode.Latin1.identchars\nidentbodychars: str = pyparsing_unicode.Latin1.identbodychars\nnums: str = \"0123456789\"\nhexnums: str = nums + \"ABCDEFabcdef\"\nalphanums: str = alphas + nums\nprintables: str = \"\".join([c for c in string.printable if c not in string.whitespace])\n\n_trim_arity_call_line: traceback.StackSummary = None  # type: ignore[assignment]\n\n\ndef _trim_arity(func, max_limit=3):\n    \"\"\"decorator to trim function calls to match the arity of the target\"\"\"\n    global _trim_arity_call_line\n\n    if func in _single_arg_builtins:\n        return lambda s, l, t: func(t)\n\n    limit = 0\n    found_arity = False\n\n    # synthesize what would be returned by traceback.extract_stack at the call to\n    # user's parse action 'func', so that we don't incur call penalty at parse time\n\n    # fmt: off\n    LINE_DIFF = 9\n    # IF ANY CODE CHANGES, EVEN JUST COMMENTS OR BLANK LINES, BETWEEN THE NEXT LINE AND\n    # THE CALL TO FUNC INSIDE WRAPPER, LINE_DIFF MUST BE MODIFIED!!!!\n    _trim_arity_call_line = (_trim_arity_call_line or traceback.extract_stack(limit=2)[-1])\n    pa_call_line_synth = (_trim_arity_call_line[0], _trim_arity_call_line[1] + LINE_DIFF)\n\n    def wrapper(*args):\n        nonlocal found_arity, limit\n        if found_arity:\n            return func(*args[limit:])\n        while 1:\n            try:\n                ret = func(*args[limit:])\n                found_arity = True\n                return ret\n            except TypeError as te:\n                # re-raise TypeErrors if they did not come from our arity testing\n                if found_arity:\n                    raise\n                else:\n                    tb = te.__traceback__\n                    frames = traceback.extract_tb(tb, limit=2)\n                    frame_summary = frames[-1]\n                    trim_arity_type_error = (\n                        [frame_summary[:2]][-1][:2] == pa_call_line_synth\n                    )\n                    del tb\n\n                    if trim_arity_type_error:\n                        if limit < max_limit:\n                            limit += 1\n                            continue\n\n                    raise\n    # fmt: on\n\n    # copy func name to wrapper for sensible debug output\n    # (can't use functools.wraps, since that messes with function signature)\n    func_name = getattr(func, \"__name__\", getattr(func, \"__class__\").__name__)\n    wrapper.__name__ = func_name\n    wrapper.__doc__ = func.__doc__\n\n    return wrapper\n\n\ndef condition_as_parse_action(\n    fn: ParseCondition, message: typing.Optional[str] = None, fatal: bool = False\n) -> ParseAction:\n    \"\"\"\n    Function to convert a simple predicate function that returns ``True`` or ``False``\n    into a parse action. Can be used in places when a parse action is required\n    and :class:`ParserElement.add_condition` cannot be used (such as when adding a condition\n    to an operator level in :class:`infix_notation`).\n\n    Optional keyword arguments:\n\n    - ``message`` - define a custom message to be used in the raised exception\n    - ``fatal`` - if True, will raise :class:`ParseFatalException` to stop parsing immediately;\n      otherwise will raise :class:`ParseException`\n\n    \"\"\"\n    msg = message if message is not None else \"failed user-defined condition\"\n    exc_type = ParseFatalException if fatal else ParseException\n    fn = _trim_arity(fn)\n\n    @wraps(fn)\n    def pa(s, l, t):\n        if not bool(fn(s, l, t)):\n            raise exc_type(s, l, msg)\n\n    return pa\n\n\ndef _default_start_debug_action(\n    instring: str, loc: int, expr: \"ParserElement\", cache_hit: bool = False\n):\n    cache_hit_str = \"*\" if cache_hit else \"\"\n    print(\n        (\n            f\"{cache_hit_str}Match {expr} at loc {loc}({lineno(loc, instring)},{col(loc, instring)})\\n\"\n            f\"  {line(loc, instring)}\\n\"\n            f\"  {' ' * (col(loc, instring) - 1)}^\"\n        )\n    )\n\n\ndef _default_success_debug_action(\n    instring: str,\n    startloc: int,\n    endloc: int,\n    expr: \"ParserElement\",\n    toks: ParseResults,\n    cache_hit: bool = False,\n):\n    cache_hit_str = \"*\" if cache_hit else \"\"\n    print(f\"{cache_hit_str}Matched {expr} -> {toks.as_list()}\")\n\n\ndef _default_exception_debug_action(\n    instring: str,\n    loc: int,\n    expr: \"ParserElement\",\n    exc: Exception,\n    cache_hit: bool = False,\n):\n    cache_hit_str = \"*\" if cache_hit else \"\"\n    print(f\"{cache_hit_str}Match {expr} failed, {type(exc).__name__} raised: {exc}\")\n\n\ndef null_debug_action(*args):\n    \"\"\"'Do-nothing' debug action, to suppress debugging output during parsing.\"\"\"\n\n\nclass ParserElement(ABC):\n    \"\"\"Abstract base level parser element class.\"\"\"\n\n    DEFAULT_WHITE_CHARS: str = \" \\n\\t\\r\"\n    verbose_stacktrace: bool = False\n    _literalStringClass: type = None  # type: ignore[assignment]\n\n    @staticmethod\n    def set_default_whitespace_chars(chars: str) -> None:\n        r\"\"\"\n        Overrides the default whitespace chars\n\n        Example::\n\n            # default whitespace chars are space, <TAB> and newline\n            Word(alphas)[1, ...].parse_string(\"abc def\\nghi jkl\")  # -> ['abc', 'def', 'ghi', 'jkl']\n\n            # change to just treat newline as significant\n            ParserElement.set_default_whitespace_chars(\" \\t\")\n            Word(alphas)[1, ...].parse_string(\"abc def\\nghi jkl\")  # -> ['abc', 'def']\n        \"\"\"\n        ParserElement.DEFAULT_WHITE_CHARS = chars\n\n        # update whitespace all parse expressions defined in this module\n        for expr in _builtin_exprs:\n            if expr.copyDefaultWhiteChars:\n                expr.whiteChars = set(chars)\n\n    @staticmethod\n    def inline_literals_using(cls: type) -> None:\n        \"\"\"\n        Set class to be used for inclusion of string literals into a parser.\n\n        Example::\n\n            # default literal class used is Literal\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            date_str.parse_string(\"1999/12/31\")  # -> ['1999', '/', '12', '/', '31']\n\n\n            # change to Suppress\n            ParserElement.inline_literals_using(Suppress)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            date_str.parse_string(\"1999/12/31\")  # -> ['1999', '12', '31']\n        \"\"\"\n        ParserElement._literalStringClass = cls\n\n    @classmethod\n    def using_each(cls, seq, **class_kwargs):\n        \"\"\"\n        Yields a sequence of class(obj, **class_kwargs) for obj in seq.\n\n        Example::\n\n            LPAR, RPAR, LBRACE, RBRACE, SEMI = Suppress.using_each(\"(){};\")\n\n        \"\"\"\n        yield from (cls(obj, **class_kwargs) for obj in seq)\n\n    class DebugActions(NamedTuple):\n        debug_try: typing.Optional[DebugStartAction]\n        debug_match: typing.Optional[DebugSuccessAction]\n        debug_fail: typing.Optional[DebugExceptionAction]\n\n    def __init__(self, savelist: bool = False):\n        self.parseAction: List[ParseAction] = list()\n        self.failAction: typing.Optional[ParseFailAction] = None\n        self.customName: str = None  # type: ignore[assignment]\n        self._defaultName: typing.Optional[str] = None\n        self.resultsName: str = None  # type: ignore[assignment]\n        self.saveAsList = savelist\n        self.skipWhitespace = True\n        self.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)\n        self.copyDefaultWhiteChars = True\n        # used when checking for left-recursion\n        self.mayReturnEmpty = False\n        self.keepTabs = False\n        self.ignoreExprs: List[\"ParserElement\"] = list()\n        self.debug = False\n        self.streamlined = False\n        # optimize exception handling for subclasses that don't advance parse index\n        self.mayIndexError = True\n        self.errmsg = \"\"\n        # mark results names as modal (report only last) or cumulative (list all)\n        self.modalResults = True\n        # custom debug actions\n        self.debugActions = self.DebugActions(None, None, None)\n        # avoid redundant calls to preParse\n        self.callPreparse = True\n        self.callDuringTry = False\n        self.suppress_warnings_: List[Diagnostics] = []\n\n    def suppress_warning(self, warning_type: Diagnostics) -> \"ParserElement\":\n        \"\"\"\n        Suppress warnings emitted for a particular diagnostic on this expression.\n\n        Example::\n\n            base = pp.Forward()\n            base.suppress_warning(Diagnostics.warn_on_parse_using_empty_Forward)\n\n            # statement would normally raise a warning, but is now suppressed\n            print(base.parse_string(\"x\"))\n\n        \"\"\"\n        self.suppress_warnings_.append(warning_type)\n        return self\n\n    def visit_all(self):\n        \"\"\"General-purpose method to yield all expressions and sub-expressions\n        in a grammar. Typically just for internal use.\n        \"\"\"\n        to_visit = deque([self])\n        seen = set()\n        while to_visit:\n            cur = to_visit.popleft()\n\n            # guard against looping forever through recursive grammars\n            if cur in seen:\n                continue\n            seen.add(cur)\n\n            to_visit.extend(cur.recurse())\n            yield cur\n\n    def copy(self) -> \"ParserElement\":\n        \"\"\"\n        Make a copy of this :class:`ParserElement`.  Useful for defining\n        different parse actions for the same parsing pattern, using copies of\n        the original parse element.\n\n        Example::\n\n            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n            integerK = integer.copy().add_parse_action(lambda toks: toks[0] * 1024) + Suppress(\"K\")\n            integerM = integer.copy().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(\"M\")\n\n            print((integerK | integerM | integer)[1, ...].parse_string(\"5K 100 640K 256M\"))\n\n        prints::\n\n            [5120, 100, 655360, 268435456]\n\n        Equivalent form of ``expr.copy()`` is just ``expr()``::\n\n            integerM = integer().add_parse_action(lambda toks: toks[0] * 1024 * 1024) + Suppress(\"M\")\n        \"\"\"\n        cpy = copy.copy(self)\n        cpy.parseAction = self.parseAction[:]\n        cpy.ignoreExprs = self.ignoreExprs[:]\n        if self.copyDefaultWhiteChars:\n            cpy.whiteChars = set(ParserElement.DEFAULT_WHITE_CHARS)\n        return cpy\n\n    def set_results_name(\n        self, name: str, list_all_matches: bool = False, *, listAllMatches: bool = False\n    ) -> \"ParserElement\":\n        \"\"\"\n        Define name for referencing matching tokens as a nested attribute\n        of the returned parse results.\n\n        Normally, results names are assigned as you would assign keys in a dict:\n        any existing value is overwritten by later values. If it is necessary to\n        keep all values captured for a particular results name, call ``set_results_name``\n        with ``list_all_matches`` = True.\n\n        NOTE: ``set_results_name`` returns a *copy* of the original :class:`ParserElement` object;\n        this is so that the client can define a basic element, such as an\n        integer, and reference it in multiple places with different names.\n\n        You can also set results names using the abbreviated syntax,\n        ``expr(\"name\")`` in place of ``expr.set_results_name(\"name\")``\n        - see :class:`__call__`. If ``list_all_matches`` is required, use\n        ``expr(\"name*\")``.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = (integer.set_results_name(\"year\") + '/'\n                        + integer.set_results_name(\"month\") + '/'\n                        + integer.set_results_name(\"day\"))\n\n            # equivalent form:\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n        \"\"\"\n        listAllMatches = listAllMatches or list_all_matches\n        return self._setResultsName(name, listAllMatches)\n\n    def _setResultsName(self, name, listAllMatches=False):\n        if name is None:\n            return self\n        newself = self.copy()\n        if name.endswith(\"*\"):\n            name = name[:-1]\n            listAllMatches = True\n        newself.resultsName = name\n        newself.modalResults = not listAllMatches\n        return newself\n\n    def set_break(self, break_flag: bool = True) -> \"ParserElement\":\n        \"\"\"\n        Method to invoke the Python pdb debugger when this element is\n        about to be parsed. Set ``break_flag`` to ``True`` to enable, ``False`` to\n        disable.\n        \"\"\"\n        if break_flag:\n            _parseMethod = self._parse\n\n            def breaker(instring, loc, doActions=True, callPreParse=True):\n                import pdb\n\n                # this call to pdb.set_trace() is intentional, not a checkin error\n                pdb.set_trace()\n                return _parseMethod(instring, loc, doActions, callPreParse)\n\n            breaker._originalParseMethod = _parseMethod  # type: ignore [attr-defined]\n            self._parse = breaker  # type: ignore [assignment]\n        elif hasattr(self._parse, \"_originalParseMethod\"):\n            self._parse = self._parse._originalParseMethod  # type: ignore [attr-defined, assignment]\n        return self\n\n    def set_parse_action(self, *fns: ParseAction, **kwargs: Any) -> \"ParserElement\":\n        \"\"\"\n        Define one or more actions to perform when successfully matching parse element definition.\n\n        Parse actions can be called to perform data conversions, do extra validation,\n        update external data structures, or enhance or replace the parsed tokens.\n        Each parse action ``fn`` is a callable method with 0-3 arguments, called as\n        ``fn(s, loc, toks)`` , ``fn(loc, toks)`` , ``fn(toks)`` , or just ``fn()`` , where:\n\n        - ``s``    = the original string being parsed (see note below)\n        - ``loc``  = the location of the matching substring\n        - ``toks`` = a list of the matched tokens, packaged as a :class:`ParseResults` object\n\n        The parsed tokens are passed to the parse action as ParseResults. They can be\n        modified in place using list-style append, extend, and pop operations to update\n        the parsed list elements; and with dictionary-style item set and del operations\n        to add, update, or remove any named results. If the tokens are modified in place,\n        it is not necessary to return them with a return statement.\n\n        Parse actions can also completely replace the given tokens, with another ``ParseResults``\n        object, or with some entirely different object (common for parse actions that perform data\n        conversions). A convenient way to build a new parse result is to define the values\n        using a dict, and then create the return value using :class:`ParseResults.from_dict`.\n\n        If None is passed as the ``fn`` parse action, all previously added parse actions for this\n        expression are cleared.\n\n        Optional keyword arguments:\n\n        - ``call_during_try`` = (default= ``False``) indicate if parse action should be run during\n          lookaheads and alternate testing. For parse actions that have side effects, it is\n          important to only call the parse action once it is determined that it is being\n          called as part of a successful parse. For parse actions that perform additional\n          validation, then call_during_try should be passed as True, so that the validation\n          code is included in the preliminary \"try\" parses.\n\n        Note: the default parsing behavior is to expand tabs in the input string\n        before starting the parsing process.  See :class:`parse_string` for more\n        information on parsing strings containing ``<TAB>`` s, and suggested\n        methods to maintain a consistent view of the parsed string, the parse\n        location, and line and column positions within the parsed string.\n\n        Example::\n\n            # parse dates in the form YYYY/MM/DD\n\n            # use parse action to convert toks from str to int at parse time\n            def convert_to_int(toks):\n                return int(toks[0])\n\n            # use a parse action to verify that the date is a valid date\n            def is_valid_date(instring, loc, toks):\n                from datetime import date\n                year, month, day = toks[::2]\n                try:\n                    date(year, month, day)\n                except ValueError:\n                    raise ParseException(instring, loc, \"invalid date given\")\n\n            integer = Word(nums)\n            date_str = integer + '/' + integer + '/' + integer\n\n            # add parse actions\n            integer.set_parse_action(convert_to_int)\n            date_str.set_parse_action(is_valid_date)\n\n            # note that integer fields are now ints, not strings\n            date_str.run_tests('''\n                # successful parse - note that integer fields were converted to ints\n                1999/12/31\n\n                # fail - invalid date\n                1999/13/31\n                ''')\n        \"\"\"\n        if list(fns) == [None]:\n            self.parseAction = []\n            return self\n\n        if not all(callable(fn) for fn in fns):\n            raise TypeError(\"parse actions must be callable\")\n        self.parseAction = [_trim_arity(fn) for fn in fns]\n        self.callDuringTry = kwargs.get(\n            \"call_during_try\", kwargs.get(\"callDuringTry\", False)\n        )\n\n        return self\n\n    def add_parse_action(self, *fns: ParseAction, **kwargs: Any) -> \"ParserElement\":\n        \"\"\"\n        Add one or more parse actions to expression's list of parse actions. See :class:`set_parse_action`.\n\n        See examples in :class:`copy`.\n        \"\"\"\n        self.parseAction += [_trim_arity(fn) for fn in fns]\n        self.callDuringTry = self.callDuringTry or kwargs.get(\n            \"call_during_try\", kwargs.get(\"callDuringTry\", False)\n        )\n        return self\n\n    def add_condition(self, *fns: ParseCondition, **kwargs: Any) -> \"ParserElement\":\n        \"\"\"Add a boolean predicate function to expression's list of parse actions. See\n        :class:`set_parse_action` for function call signatures. Unlike ``set_parse_action``,\n        functions passed to ``add_condition`` need to return boolean success/fail of the condition.\n\n        Optional keyword arguments:\n\n        - ``message`` = define a custom message to be used in the raised exception\n        - ``fatal`` = if True, will raise ParseFatalException to stop parsing immediately; otherwise will raise\n          ParseException\n        - ``call_during_try`` = boolean to indicate if this method should be called during internal tryParse calls,\n          default=False\n\n        Example::\n\n            integer = Word(nums).set_parse_action(lambda toks: int(toks[0]))\n            year_int = integer.copy()\n            year_int.add_condition(lambda toks: toks[0] >= 2000, message=\"Only support years 2000 and later\")\n            date_str = year_int + '/' + integer + '/' + integer\n\n            result = date_str.parse_string(\"1999/12/31\")  # -> Exception: Only support years 2000 and later (at char 0),\n                                                                         (line:1, col:1)\n        \"\"\"\n        for fn in fns:\n            self.parseAction.append(\n                condition_as_parse_action(\n                    fn,\n                    message=str(kwargs.get(\"message\")),\n                    fatal=bool(kwargs.get(\"fatal\", False)),\n                )\n            )\n\n        self.callDuringTry = self.callDuringTry or kwargs.get(\n            \"call_during_try\", kwargs.get(\"callDuringTry\", False)\n        )\n        return self\n\n    def set_fail_action(self, fn: ParseFailAction) -> \"ParserElement\":\n        \"\"\"\n        Define action to perform if parsing fails at this expression.\n        Fail acton fn is a callable function that takes the arguments\n        ``fn(s, loc, expr, err)`` where:\n\n        - ``s`` = string being parsed\n        - ``loc`` = location where expression match was attempted and failed\n        - ``expr`` = the parse expression that failed\n        - ``err`` = the exception thrown\n\n        The function returns no value.  It may throw :class:`ParseFatalException`\n        if it is desired to stop parsing immediately.\"\"\"\n        self.failAction = fn\n        return self\n\n    def _skipIgnorables(self, instring: str, loc: int) -> int:\n        if not self.ignoreExprs:\n            return loc\n        exprsFound = True\n        ignore_expr_fns = [e._parse for e in self.ignoreExprs]\n        last_loc = loc\n        while exprsFound:\n            exprsFound = False\n            for ignore_fn in ignore_expr_fns:\n                try:\n                    while 1:\n                        loc, dummy = ignore_fn(instring, loc)\n                        exprsFound = True\n                except ParseException:\n                    pass\n            # check if all ignore exprs matched but didn't actually advance the parse location\n            if loc == last_loc:\n                break\n            last_loc = loc\n        return loc\n\n    def preParse(self, instring: str, loc: int) -> int:\n        if self.ignoreExprs:\n            loc = self._skipIgnorables(instring, loc)\n\n        if self.skipWhitespace:\n            instrlen = len(instring)\n            white_chars = self.whiteChars\n            while loc < instrlen and instring[loc] in white_chars:\n                loc += 1\n\n        return loc\n\n    def parseImpl(self, instring, loc, doActions=True):\n        return loc, []\n\n    def postParse(self, instring, loc, tokenlist):\n        return tokenlist\n\n    # @profile\n    def _parseNoCache(\n        self, instring, loc, doActions=True, callPreParse=True\n    ) -> Tuple[int, ParseResults]:\n        TRY, MATCH, FAIL = 0, 1, 2\n        debugging = self.debug  # and doActions)\n        len_instring = len(instring)\n\n        if debugging or self.failAction:\n            # print(\"Match {} at loc {}({}, {})\".format(self, loc, lineno(loc, instring), col(loc, instring)))\n            try:\n                if callPreParse and self.callPreparse:\n                    pre_loc = self.preParse(instring, loc)\n                else:\n                    pre_loc = loc\n                tokens_start = pre_loc\n                if self.debugActions.debug_try:\n                    self.debugActions.debug_try(instring, tokens_start, self, False)\n                if self.mayIndexError or pre_loc >= len_instring:\n                    try:\n                        loc, tokens = self.parseImpl(instring, pre_loc, doActions)\n                    except IndexError:\n                        raise ParseException(instring, len_instring, self.errmsg, self)\n                else:\n                    loc, tokens = self.parseImpl(instring, pre_loc, doActions)\n            except Exception as err:\n                # print(\"Exception raised:\", err)\n                if self.debugActions.debug_fail:\n                    self.debugActions.debug_fail(\n                        instring, tokens_start, self, err, False\n                    )\n                if self.failAction:\n                    self.failAction(instring, tokens_start, self, err)\n                raise\n        else:\n            if callPreParse and self.callPreparse:\n                pre_loc = self.preParse(instring, loc)\n            else:\n                pre_loc = loc\n            tokens_start = pre_loc\n            if self.mayIndexError or pre_loc >= len_instring:\n                try:\n                    loc, tokens = self.parseImpl(instring, pre_loc, doActions)\n                except IndexError:\n                    raise ParseException(instring, len_instring, self.errmsg, self)\n            else:\n                loc, tokens = self.parseImpl(instring, pre_loc, doActions)\n\n        tokens = self.postParse(instring, loc, tokens)\n\n        ret_tokens = ParseResults(\n            tokens, self.resultsName, asList=self.saveAsList, modal=self.modalResults\n        )\n        if self.parseAction and (doActions or self.callDuringTry):\n            if debugging:\n                try:\n                    for fn in self.parseAction:\n                        try:\n                            tokens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]\n                        except IndexError as parse_action_exc:\n                            exc = ParseException(\"exception raised in parse action\")\n                            raise exc from parse_action_exc\n\n                        if tokens is not None and tokens is not ret_tokens:\n                            ret_tokens = ParseResults(\n                                tokens,\n                                self.resultsName,\n                                asList=self.saveAsList\n                                and isinstance(tokens, (ParseResults, list)),\n                                modal=self.modalResults,\n                            )\n                except Exception as err:\n                    # print \"Exception raised in user parse action:\", err\n                    if self.debugActions.debug_fail:\n                        self.debugActions.debug_fail(\n                            instring, tokens_start, self, err, False\n                        )\n                    raise\n            else:\n                for fn in self.parseAction:\n                    try:\n                        tokens = fn(instring, tokens_start, ret_tokens)  # type: ignore [call-arg, arg-type]\n                    except IndexError as parse_action_exc:\n                        exc = ParseException(\"exception raised in parse action\")\n                        raise exc from parse_action_exc\n\n                    if tokens is not None and tokens is not ret_tokens:\n                        ret_tokens = ParseResults(\n                            tokens,\n                            self.resultsName,\n                            asList=self.saveAsList\n                            and isinstance(tokens, (ParseResults, list)),\n                            modal=self.modalResults,\n                        )\n        if debugging:\n            # print(\"Matched\", self, \"->\", ret_tokens.as_list())\n            if self.debugActions.debug_match:\n                self.debugActions.debug_match(\n                    instring, tokens_start, loc, self, ret_tokens, False\n                )\n\n        return loc, ret_tokens\n\n    def try_parse(\n        self,\n        instring: str,\n        loc: int,\n        *,\n        raise_fatal: bool = False,\n        do_actions: bool = False,\n    ) -> int:\n        try:\n            return self._parse(instring, loc, doActions=do_actions)[0]\n        except ParseFatalException:\n            if raise_fatal:\n                raise\n            raise ParseException(instring, loc, self.errmsg, self)\n\n    def can_parse_next(self, instring: str, loc: int, do_actions: bool = False) -> bool:\n        try:\n            self.try_parse(instring, loc, do_actions=do_actions)\n        except (ParseException, IndexError):\n            return False\n        else:\n            return True\n\n    # cache for left-recursion in Forward references\n    recursion_lock = RLock()\n    recursion_memos: typing.Dict[\n        Tuple[int, \"Forward\", bool], Tuple[int, Union[ParseResults, Exception]]\n    ] = {}\n\n    class _CacheType(dict):\n        \"\"\"\n        class to help type checking\n        \"\"\"\n\n        not_in_cache: bool\n\n        def get(self, *args): ...\n\n        def set(self, *args): ...\n\n    # argument cache for optimizing repeated calls when backtracking through recursive expressions\n    packrat_cache = (\n        _CacheType()\n    )  # set later by enable_packrat(); this is here so that reset_cache() doesn't fail\n    packrat_cache_lock = RLock()\n    packrat_cache_stats = [0, 0]\n\n    # this method gets repeatedly called during backtracking with the same arguments -\n    # we can cache these arguments and save ourselves the trouble of re-parsing the contained expression\n    def _parseCache(\n        self, instring, loc, doActions=True, callPreParse=True\n    ) -> Tuple[int, ParseResults]:\n        HIT, MISS = 0, 1\n        TRY, MATCH, FAIL = 0, 1, 2\n        lookup = (self, instring, loc, callPreParse, doActions)\n        with ParserElement.packrat_cache_lock:\n            cache = ParserElement.packrat_cache\n            value = cache.get(lookup)\n            if value is cache.not_in_cache:\n                ParserElement.packrat_cache_stats[MISS] += 1\n                try:\n                    value = self._parseNoCache(instring, loc, doActions, callPreParse)\n                except ParseBaseException as pe:\n                    # cache a copy of the exception, without the traceback\n                    cache.set(lookup, pe.__class__(*pe.args))\n                    raise\n                else:\n                    cache.set(lookup, (value[0], value[1].copy(), loc))\n                    return value\n            else:\n                ParserElement.packrat_cache_stats[HIT] += 1\n                if self.debug and self.debugActions.debug_try:\n                    try:\n                        self.debugActions.debug_try(instring, loc, self, cache_hit=True)  # type: ignore [call-arg]\n                    except TypeError:\n                        pass\n                if isinstance(value, Exception):\n                    if self.debug and self.debugActions.debug_fail:\n                        try:\n                            self.debugActions.debug_fail(\n                                instring, loc, self, value, cache_hit=True  # type: ignore [call-arg]\n                            )\n                        except TypeError:\n                            pass\n                    raise value\n\n                value = cast(Tuple[int, ParseResults, int], value)\n                loc_, result, endloc = value[0], value[1].copy(), value[2]\n                if self.debug and self.debugActions.debug_match:\n                    try:\n                        self.debugActions.debug_match(\n                            instring, loc_, endloc, self, result, cache_hit=True  # type: ignore [call-arg]\n                        )\n                    except TypeError:\n                        pass\n\n                return loc_, result\n\n    _parse = _parseNoCache\n\n    @staticmethod\n    def reset_cache() -> None:\n        ParserElement.packrat_cache.clear()\n        ParserElement.packrat_cache_stats[:] = [0] * len(\n            ParserElement.packrat_cache_stats\n        )\n        ParserElement.recursion_memos.clear()\n\n    _packratEnabled = False\n    _left_recursion_enabled = False\n\n    @staticmethod\n    def disable_memoization() -> None:\n        \"\"\"\n        Disables active Packrat or Left Recursion parsing and their memoization\n\n        This method also works if neither Packrat nor Left Recursion are enabled.\n        This makes it safe to call before activating Packrat nor Left Recursion\n        to clear any previous settings.\n        \"\"\"\n        ParserElement.reset_cache()\n        ParserElement._left_recursion_enabled = False\n        ParserElement._packratEnabled = False\n        ParserElement._parse = ParserElement._parseNoCache\n\n    @staticmethod\n    def enable_left_recursion(\n        cache_size_limit: typing.Optional[int] = None, *, force=False\n    ) -> None:\n        \"\"\"\n        Enables \"bounded recursion\" parsing, which allows for both direct and indirect\n        left-recursion. During parsing, left-recursive :class:`Forward` elements are\n        repeatedly matched with a fixed recursion depth that is gradually increased\n        until finding the longest match.\n\n        Example::\n\n            import pyparsing as pp\n            pp.ParserElement.enable_left_recursion()\n\n            E = pp.Forward(\"E\")\n            num = pp.Word(pp.nums)\n            # match `num`, or `num '+' num`, or `num '+' num '+' num`, ...\n            E <<= E + '+' - num | num\n\n            print(E.parse_string(\"1+2+3\"))\n\n        Recursion search naturally memoizes matches of ``Forward`` elements and may\n        thus skip reevaluation of parse actions during backtracking. This may break\n        programs with parse actions which rely on strict ordering of side-effects.\n\n        Parameters:\n\n        - ``cache_size_limit`` - (default=``None``) - memoize at most this many\n          ``Forward`` elements during matching; if ``None`` (the default),\n          memoize all ``Forward`` elements.\n\n        Bounded Recursion parsing works similar but not identical to Packrat parsing,\n        thus the two cannot be used together. Use ``force=True`` to disable any\n        previous, conflicting settings.\n        \"\"\"\n        if force:\n            ParserElement.disable_memoization()\n        elif ParserElement._packratEnabled:\n            raise RuntimeError(\"Packrat and Bounded Recursion are not compatible\")\n        if cache_size_limit is None:\n            ParserElement.recursion_memos = _UnboundedMemo()  # type: ignore[assignment]\n        elif cache_size_limit > 0:\n            ParserElement.recursion_memos = _LRUMemo(capacity=cache_size_limit)  # type: ignore[assignment]\n        else:\n            raise NotImplementedError(f\"Memo size of {cache_size_limit}\")\n        ParserElement._left_recursion_enabled = True\n\n    @staticmethod\n    def enable_packrat(\n        cache_size_limit: Union[int, None] = 128, *, force: bool = False\n    ) -> None:\n        \"\"\"\n        Enables \"packrat\" parsing, which adds memoizing to the parsing logic.\n        Repeated parse attempts at the same string location (which happens\n        often in many complex grammars) can immediately return a cached value,\n        instead of re-executing parsing/validating code.  Memoizing is done of\n        both valid results and parsing exceptions.\n\n        Parameters:\n\n        - ``cache_size_limit`` - (default= ``128``) - if an integer value is provided\n          will limit the size of the packrat cache; if None is passed, then\n          the cache size will be unbounded; if 0 is passed, the cache will\n          be effectively disabled.\n\n        This speedup may break existing programs that use parse actions that\n        have side-effects.  For this reason, packrat parsing is disabled when\n        you first import pyparsing.  To activate the packrat feature, your\n        program must call the class method :class:`ParserElement.enable_packrat`.\n        For best results, call ``enable_packrat()`` immediately after\n        importing pyparsing.\n\n        Example::\n\n            import pyparsing\n            pyparsing.ParserElement.enable_packrat()\n\n        Packrat parsing works similar but not identical to Bounded Recursion parsing,\n        thus the two cannot be used together. Use ``force=True`` to disable any\n        previous, conflicting settings.\n        \"\"\"\n        if force:\n            ParserElement.disable_memoization()\n        elif ParserElement._left_recursion_enabled:\n            raise RuntimeError(\"Packrat and Bounded Recursion are not compatible\")\n\n        if ParserElement._packratEnabled:\n            return\n\n        ParserElement._packratEnabled = True\n        if cache_size_limit is None:\n            ParserElement.packrat_cache = _UnboundedCache()\n        else:\n            ParserElement.packrat_cache = _FifoCache(cache_size_limit)  # type: ignore[assignment]\n        ParserElement._parse = ParserElement._parseCache\n\n    def parse_string(\n        self, instring: str, parse_all: bool = False, *, parseAll: bool = False\n    ) -> ParseResults:\n        \"\"\"\n        Parse a string with respect to the parser definition. This function is intended as the primary interface to the\n        client code.\n\n        :param instring: The input string to be parsed.\n        :param parse_all: If set, the entire input string must match the grammar.\n        :param parseAll: retained for pre-PEP8 compatibility, will be removed in a future release.\n        :raises ParseException: Raised if ``parse_all`` is set and the input string does not match the whole grammar.\n        :returns: the parsed data as a :class:`ParseResults` object, which may be accessed as a `list`, a `dict`, or\n          an object with attributes if the given parser includes results names.\n\n        If the input string is required to match the entire grammar, ``parse_all`` flag must be set to ``True``. This\n        is also equivalent to ending the grammar with :class:`StringEnd`\\\\ ().\n\n        To report proper column numbers, ``parse_string`` operates on a copy of the input string where all tabs are\n        converted to spaces (8 spaces per tab, as per the default in ``string.expandtabs``). If the input string\n        contains tabs and the grammar uses parse actions that use the ``loc`` argument to index into the string\n        being parsed, one can ensure a consistent view of the input string by doing one of the following:\n\n        - calling ``parse_with_tabs`` on your grammar before calling ``parse_string`` (see :class:`parse_with_tabs`),\n        - define your parse action using the full ``(s,loc,toks)`` signature, and reference the input string using the\n          parse action's ``s`` argument, or\n        - explicitly expand the tabs in your input string before calling ``parse_string``.\n\n        Examples:\n\n        By default, partial matches are OK.\n\n        >>> res = Word('a').parse_string('aaaaabaaa')\n        >>> print(res)\n        ['aaaaa']\n\n        The parsing behavior varies by the inheriting class of this abstract class. Please refer to the children\n        directly to see more examples.\n\n        It raises an exception if parse_all flag is set and instring does not match the whole grammar.\n\n        >>> res = Word('a').parse_string('aaaaabaaa', parse_all=True)\n        Traceback (most recent call last):\n        ...\n        pyparsing.ParseException: Expected end of text, found 'b'  (at char 5), (line:1, col:6)\n        \"\"\"\n        parseAll = parse_all or parseAll\n\n        ParserElement.reset_cache()\n        if not self.streamlined:\n            self.streamline()\n        for e in self.ignoreExprs:\n            e.streamline()\n        if not self.keepTabs:\n            instring = instring.expandtabs()\n        try:\n            loc, tokens = self._parse(instring, 0)\n            if parseAll:\n                loc = self.preParse(instring, loc)\n                se = Empty() + StringEnd()\n                se._parse(instring, loc)\n        except ParseBaseException as exc:\n            if ParserElement.verbose_stacktrace:\n                raise\n            else:\n                # catch and re-raise exception from here, clearing out pyparsing internal stack trace\n                raise exc.with_traceback(None)\n        else:\n            return tokens\n\n    def scan_string(\n        self,\n        instring: str,\n        max_matches: int = _MAX_INT,\n        overlap: bool = False,\n        *,\n        debug: bool = False,\n        maxMatches: int = _MAX_INT,\n    ) -> Generator[Tuple[ParseResults, int, int], None, None]:\n        \"\"\"\n        Scan the input string for expression matches.  Each match will return the\n        matching tokens, start location, and end location.  May be called with optional\n        ``max_matches`` argument, to clip scanning after 'n' matches are found.  If\n        ``overlap`` is specified, then overlapping matches will be reported.\n\n        Note that the start and end locations are reported relative to the string\n        being parsed.  See :class:`parse_string` for more information on parsing\n        strings with embedded tabs.\n\n        Example::\n\n            source = \"sldjf123lsdjjkf345sldkjf879lkjsfd987\"\n            print(source)\n            for tokens, start, end in Word(alphas).scan_string(source):\n                print(' '*start + '^'*(end-start))\n                print(' '*start + tokens[0])\n\n        prints::\n\n            sldjf123lsdjjkf345sldkjf879lkjsfd987\n            ^^^^^\n            sldjf\n                    ^^^^^^^\n                    lsdjjkf\n                              ^^^^^^\n                              sldkjf\n                                       ^^^^^^\n                                       lkjsfd\n        \"\"\"\n        maxMatches = min(maxMatches, max_matches)\n        if not self.streamlined:\n            self.streamline()\n        for e in self.ignoreExprs:\n            e.streamline()\n\n        if not self.keepTabs:\n            instring = str(instring).expandtabs()\n        instrlen = len(instring)\n        loc = 0\n        preparseFn = self.preParse\n        parseFn = self._parse\n        ParserElement.resetCache()\n        matches = 0\n        try:\n            while loc <= instrlen and matches < maxMatches:\n                try:\n                    preloc: int = preparseFn(instring, loc)\n                    nextLoc: int\n                    tokens: ParseResults\n                    nextLoc, tokens = parseFn(instring, preloc, callPreParse=False)\n                except ParseException:\n                    loc = preloc + 1\n                else:\n                    if nextLoc > loc:\n                        matches += 1\n                        if debug:\n                            print(\n                                {\n                                    \"tokens\": tokens.asList(),\n                                    \"start\": preloc,\n                                    \"end\": nextLoc,\n                                }\n                            )\n                        yield tokens, preloc, nextLoc\n                        if overlap:\n                            nextloc = preparseFn(instring, loc)\n                            if nextloc > loc:\n                                loc = nextLoc\n                            else:\n                                loc += 1\n                        else:\n                            loc = nextLoc\n                    else:\n                        loc = preloc + 1\n        except ParseBaseException as exc:\n            if ParserElement.verbose_stacktrace:\n                raise\n\n            # catch and re-raise exception from here, clears out pyparsing internal stack trace\n            raise exc.with_traceback(None)\n\n    def transform_string(self, instring: str, *, debug: bool = False) -> str:\n        \"\"\"\n        Extension to :class:`scan_string`, to modify matching text with modified tokens that may\n        be returned from a parse action.  To use ``transform_string``, define a grammar and\n        attach a parse action to it that modifies the returned token list.\n        Invoking ``transform_string()`` on a target string will then scan for matches,\n        and replace the matched text patterns according to the logic in the parse\n        action.  ``transform_string()`` returns the resulting transformed string.\n\n        Example::\n\n            wd = Word(alphas)\n            wd.set_parse_action(lambda toks: toks[0].title())\n\n            print(wd.transform_string(\"now is the winter of our discontent made glorious summer by this sun of york.\"))\n\n        prints::\n\n            Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York.\n        \"\"\"\n        out: List[str] = []\n        lastE = 0\n        # force preservation of <TAB>s, to minimize unwanted transformation of string, and to\n        # keep string locs straight between transform_string and scan_string\n        self.keepTabs = True\n        try:\n            for t, s, e in self.scan_string(instring, debug=debug):\n                out.append(instring[lastE:s])\n                lastE = e\n\n                if not t:\n                    continue\n\n                if isinstance(t, ParseResults):\n                    out += t.as_list()\n                elif isinstance(t, Iterable) and not isinstance(t, str_type):\n                    out.extend(t)\n                else:\n                    out.append(t)\n\n            out.append(instring[lastE:])\n            out = [o for o in out if o]\n            return \"\".join([str(s) for s in _flatten(out)])\n        except ParseBaseException as exc:\n            if ParserElement.verbose_stacktrace:\n                raise\n\n            # catch and re-raise exception from here, clears out pyparsing internal stack trace\n            raise exc.with_traceback(None)\n\n    def search_string(\n        self,\n        instring: str,\n        max_matches: int = _MAX_INT,\n        *,\n        debug: bool = False,\n        maxMatches: int = _MAX_INT,\n    ) -> ParseResults:\n        \"\"\"\n        Another extension to :class:`scan_string`, simplifying the access to the tokens found\n        to match the given parse expression.  May be called with optional\n        ``max_matches`` argument, to clip searching after 'n' matches are found.\n\n        Example::\n\n            # a capitalized word starts with an uppercase letter, followed by zero or more lowercase letters\n            cap_word = Word(alphas.upper(), alphas.lower())\n\n            print(cap_word.search_string(\"More than Iron, more than Lead, more than Gold I need Electricity\"))\n\n            # the sum() builtin can be used to merge results into a single ParseResults object\n            print(sum(cap_word.search_string(\"More than Iron, more than Lead, more than Gold I need Electricity\")))\n\n        prints::\n\n            [['More'], ['Iron'], ['Lead'], ['Gold'], ['I'], ['Electricity']]\n            ['More', 'Iron', 'Lead', 'Gold', 'I', 'Electricity']\n        \"\"\"\n        maxMatches = min(maxMatches, max_matches)\n        try:\n            return ParseResults(\n                [t for t, s, e in self.scan_string(instring, maxMatches, debug=debug)]\n            )\n        except ParseBaseException as exc:\n            if ParserElement.verbose_stacktrace:\n                raise\n\n            # catch and re-raise exception from here, clears out pyparsing internal stack trace\n            raise exc.with_traceback(None)\n\n    def split(\n        self,\n        instring: str,\n        maxsplit: int = _MAX_INT,\n        include_separators: bool = False,\n        *,\n        includeSeparators=False,\n    ) -> Generator[str, None, None]:\n        \"\"\"\n        Generator method to split a string using the given expression as a separator.\n        May be called with optional ``maxsplit`` argument, to limit the number of splits;\n        and the optional ``include_separators`` argument (default= ``False``), if the separating\n        matching text should be included in the split results.\n\n        Example::\n\n            punc = one_of(list(\".,;:/-!?\"))\n            print(list(punc.split(\"This, this?, this sentence, is badly punctuated!\")))\n\n        prints::\n\n            ['This', ' this', '', ' this sentence', ' is badly punctuated', '']\n        \"\"\"\n        includeSeparators = includeSeparators or include_separators\n        last = 0\n        for t, s, e in self.scan_string(instring, max_matches=maxsplit):\n            yield instring[last:s]\n            if includeSeparators:\n                yield t[0]\n            last = e\n        yield instring[last:]\n\n    def __add__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``+`` operator - returns :class:`And`. Adding strings to a :class:`ParserElement`\n        converts them to :class:`Literal`\\\\ s by default.\n\n        Example::\n\n            greet = Word(alphas) + \",\" + Word(alphas) + \"!\"\n            hello = \"Hello, World!\"\n            print(hello, \"->\", greet.parse_string(hello))\n\n        prints::\n\n            Hello, World! -> ['Hello', ',', 'World', '!']\n\n        ``...`` may be used as a parse expression as a short form of :class:`SkipTo`::\n\n            Literal('start') + ... + Literal('end')\n\n        is equivalent to::\n\n            Literal('start') + SkipTo('end')(\"_skipped*\") + Literal('end')\n\n        Note that the skipped text is returned with '_skipped' as a results name,\n        and to support having multiple skips in the same parser, the value returned is\n        a list of all skipped text.\n        \"\"\"\n        if other is Ellipsis:\n            return _PendingSkip(self)\n\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return And([self, other])\n\n    def __radd__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``+`` operator when left operand is not a :class:`ParserElement`\n        \"\"\"\n        if other is Ellipsis:\n            return SkipTo(self)(\"_skipped*\") + self\n\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return other + self\n\n    def __sub__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``-`` operator, returns :class:`And` with error stop\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return self + And._ErrorStop() + other\n\n    def __rsub__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``-`` operator when left operand is not a :class:`ParserElement`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return other - self\n\n    def __mul__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``*`` operator, allows use of ``expr * 3`` in place of\n        ``expr + expr + expr``.  Expressions may also be multiplied by a 2-integer\n        tuple, similar to ``{min, max}`` multipliers in regular expressions.  Tuples\n        may also include ``None`` as in:\n\n        - ``expr*(n, None)`` or ``expr*(n, )`` is equivalent\n          to ``expr*n + ZeroOrMore(expr)``\n          (read as \"at least n instances of ``expr``\")\n        - ``expr*(None, n)`` is equivalent to ``expr*(0, n)``\n          (read as \"0 to n instances of ``expr``\")\n        - ``expr*(None, None)`` is equivalent to ``ZeroOrMore(expr)``\n        - ``expr*(1, None)`` is equivalent to ``OneOrMore(expr)``\n\n        Note that ``expr*(None, n)`` does not raise an exception if\n        more than n exprs exist in the input stream; that is,\n        ``expr*(None, n)`` does not enforce a maximum number of expr\n        occurrences.  If this behavior is desired, then write\n        ``expr*(None, n) + ~expr``\n        \"\"\"\n        if other is Ellipsis:\n            other = (0, None)\n        elif isinstance(other, tuple) and other[:1] == (Ellipsis,):\n            other = ((0,) + other[1:] + (None,))[:2]\n\n        if not isinstance(other, (int, tuple)):\n            return NotImplemented\n\n        if isinstance(other, int):\n            minElements, optElements = other, 0\n        else:\n            other = tuple(o if o is not Ellipsis else None for o in other)\n            other = (other + (None, None))[:2]\n            if other[0] is None:\n                other = (0, other[1])\n            if isinstance(other[0], int) and other[1] is None:\n                if other[0] == 0:\n                    return ZeroOrMore(self)\n                if other[0] == 1:\n                    return OneOrMore(self)\n                else:\n                    return self * other[0] + ZeroOrMore(self)\n            elif isinstance(other[0], int) and isinstance(other[1], int):\n                minElements, optElements = other\n                optElements -= minElements\n            else:\n                return NotImplemented\n\n        if minElements < 0:\n            raise ValueError(\"cannot multiply ParserElement by negative value\")\n        if optElements < 0:\n            raise ValueError(\n                \"second tuple value must be greater or equal to first tuple value\"\n            )\n        if minElements == optElements == 0:\n            return And([])\n\n        if optElements:\n\n            def makeOptionalList(n):\n                if n > 1:\n                    return Opt(self + makeOptionalList(n - 1))\n                else:\n                    return Opt(self)\n\n            if minElements:\n                if minElements == 1:\n                    ret = self + makeOptionalList(optElements)\n                else:\n                    ret = And([self] * minElements) + makeOptionalList(optElements)\n            else:\n                ret = makeOptionalList(optElements)\n        else:\n            if minElements == 1:\n                ret = self\n            else:\n                ret = And([self] * minElements)\n        return ret\n\n    def __rmul__(self, other) -> \"ParserElement\":\n        return self.__mul__(other)\n\n    def __or__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``|`` operator - returns :class:`MatchFirst`\n        \"\"\"\n        if other is Ellipsis:\n            return _PendingSkip(self, must_skip=True)\n\n        if isinstance(other, str_type):\n            # `expr | \"\"` is equivalent to `Opt(expr)`\n            if other == \"\":\n                return Opt(self)\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return MatchFirst([self, other])\n\n    def __ror__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``|`` operator when left operand is not a :class:`ParserElement`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return other | self\n\n    def __xor__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``^`` operator - returns :class:`Or`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return Or([self, other])\n\n    def __rxor__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``^`` operator when left operand is not a :class:`ParserElement`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return other ^ self\n\n    def __and__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``&`` operator - returns :class:`Each`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return Each([self, other])\n\n    def __rand__(self, other) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``&`` operator when left operand is not a :class:`ParserElement`\n        \"\"\"\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return other & self\n\n    def __invert__(self) -> \"ParserElement\":\n        \"\"\"\n        Implementation of ``~`` operator - returns :class:`NotAny`\n        \"\"\"\n        return NotAny(self)\n\n    # disable __iter__ to override legacy use of sequential access to __getitem__ to\n    # iterate over a sequence\n    __iter__ = None\n\n    def __getitem__(self, key):\n        \"\"\"\n        use ``[]`` indexing notation as a short form for expression repetition:\n\n        - ``expr[n]`` is equivalent to ``expr*n``\n        - ``expr[m, n]`` is equivalent to ``expr*(m, n)``\n        - ``expr[n, ...]`` or ``expr[n,]`` is equivalent\n             to ``expr*n + ZeroOrMore(expr)``\n             (read as \"at least n instances of ``expr``\")\n        - ``expr[..., n]`` is equivalent to ``expr*(0, n)``\n             (read as \"0 to n instances of ``expr``\")\n        - ``expr[...]`` and ``expr[0, ...]`` are equivalent to ``ZeroOrMore(expr)``\n        - ``expr[1, ...]`` is equivalent to ``OneOrMore(expr)``\n\n        ``None`` may be used in place of ``...``.\n\n        Note that ``expr[..., n]`` and ``expr[m, n]`` do not raise an exception\n        if more than ``n`` ``expr``\\\\ s exist in the input stream.  If this behavior is\n        desired, then write ``expr[..., n] + ~expr``.\n\n        For repetition with a stop_on expression, use slice notation:\n\n        - ``expr[...: end_expr]`` and ``expr[0, ...: end_expr]`` are equivalent to ``ZeroOrMore(expr, stop_on=end_expr)``\n        - ``expr[1, ...: end_expr]`` is equivalent to ``OneOrMore(expr, stop_on=end_expr)``\n\n        \"\"\"\n\n        stop_on_defined = False\n        stop_on = NoMatch()\n        if isinstance(key, slice):\n            key, stop_on = key.start, key.stop\n            if key is None:\n                key = ...\n            stop_on_defined = True\n        elif isinstance(key, tuple) and isinstance(key[-1], slice):\n            key, stop_on = (key[0], key[1].start), key[1].stop\n            stop_on_defined = True\n\n        # convert single arg keys to tuples\n        if isinstance(key, str_type):\n            key = (key,)\n        try:\n            iter(key)\n        except TypeError:\n            key = (key, key)\n\n        if len(key) > 2:\n            raise TypeError(\n                f\"only 1 or 2 index arguments supported ({key[:5]}{f'... [{len(key)}]' if len(key) > 5 else ''})\"\n            )\n\n        # clip to 2 elements\n        ret = self * tuple(key[:2])\n        ret = typing.cast(_MultipleMatch, ret)\n\n        if stop_on_defined:\n            ret.stopOn(stop_on)\n\n        return ret\n\n    def __call__(self, name: typing.Optional[str] = None) -> \"ParserElement\":\n        \"\"\"\n        Shortcut for :class:`set_results_name`, with ``list_all_matches=False``.\n\n        If ``name`` is given with a trailing ``'*'`` character, then ``list_all_matches`` will be\n        passed as ``True``.\n\n        If ``name`` is omitted, same as calling :class:`copy`.\n\n        Example::\n\n            # these are equivalent\n            userdata = Word(alphas).set_results_name(\"name\") + Word(nums + \"-\").set_results_name(\"socsecno\")\n            userdata = Word(alphas)(\"name\") + Word(nums + \"-\")(\"socsecno\")\n        \"\"\"\n        if name is not None:\n            return self._setResultsName(name)\n\n        return self.copy()\n\n    def suppress(self) -> \"ParserElement\":\n        \"\"\"\n        Suppresses the output of this :class:`ParserElement`; useful to keep punctuation from\n        cluttering up returned output.\n        \"\"\"\n        return Suppress(self)\n\n    def ignore_whitespace(self, recursive: bool = True) -> \"ParserElement\":\n        \"\"\"\n        Enables the skipping of whitespace before matching the characters in the\n        :class:`ParserElement`'s defined pattern.\n\n        :param recursive: If ``True`` (the default), also enable whitespace skipping in child elements (if any)\n        \"\"\"\n        self.skipWhitespace = True\n        return self\n\n    def leave_whitespace(self, recursive: bool = True) -> \"ParserElement\":\n        \"\"\"\n        Disables the skipping of whitespace before matching the characters in the\n        :class:`ParserElement`'s defined pattern.  This is normally only used internally by\n        the pyparsing module, but may be needed in some whitespace-sensitive grammars.\n\n        :param recursive: If true (the default), also disable whitespace skipping in child elements (if any)\n        \"\"\"\n        self.skipWhitespace = False\n        return self\n\n    def set_whitespace_chars(\n        self, chars: Union[Set[str], str], copy_defaults: bool = False\n    ) -> \"ParserElement\":\n        \"\"\"\n        Overrides the default whitespace chars\n        \"\"\"\n        self.skipWhitespace = True\n        self.whiteChars = set(chars)\n        self.copyDefaultWhiteChars = copy_defaults\n        return self\n\n    def parse_with_tabs(self) -> \"ParserElement\":\n        \"\"\"\n        Overrides default behavior to expand ``<TAB>`` s to spaces before parsing the input string.\n        Must be called before ``parse_string`` when the input grammar contains elements that\n        match ``<TAB>`` characters.\n        \"\"\"\n        self.keepTabs = True\n        return self\n\n    def ignore(self, other: \"ParserElement\") -> \"ParserElement\":\n        \"\"\"\n        Define expression to be ignored (e.g., comments) while doing pattern\n        matching; may be called repeatedly, to define multiple comment or other\n        ignorable patterns.\n\n        Example::\n\n            patt = Word(alphas)[...]\n            patt.parse_string('ablaj /* comment */ lskjd')\n            # -> ['ablaj']\n\n            patt.ignore(c_style_comment)\n            patt.parse_string('ablaj /* comment */ lskjd')\n            # -> ['ablaj', 'lskjd']\n        \"\"\"\n        if isinstance(other, str_type):\n            other = Suppress(other)\n\n        if isinstance(other, Suppress):\n            if other not in self.ignoreExprs:\n                self.ignoreExprs.append(other)\n        else:\n            self.ignoreExprs.append(Suppress(other.copy()))\n        return self\n\n    def set_debug_actions(\n        self,\n        start_action: DebugStartAction,\n        success_action: DebugSuccessAction,\n        exception_action: DebugExceptionAction,\n    ) -> \"ParserElement\":\n        \"\"\"\n        Customize display of debugging messages while doing pattern matching:\n\n        - ``start_action`` - method to be called when an expression is about to be parsed;\n          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, cache_hit: bool)``\n\n        - ``success_action`` - method to be called when an expression has successfully parsed;\n          should have the signature ``fn(input_string: str, start_location: int, end_location: int, expression: ParserELement, parsed_tokens: ParseResults, cache_hit: bool)``\n\n        - ``exception_action`` - method to be called when expression fails to parse;\n          should have the signature ``fn(input_string: str, location: int, expression: ParserElement, exception: Exception, cache_hit: bool)``\n        \"\"\"\n        self.debugActions = self.DebugActions(\n            start_action or _default_start_debug_action,  # type: ignore[truthy-function]\n            success_action or _default_success_debug_action,  # type: ignore[truthy-function]\n            exception_action or _default_exception_debug_action,  # type: ignore[truthy-function]\n        )\n        self.debug = True\n        return self\n\n    def set_debug(self, flag: bool = True, recurse: bool = False) -> \"ParserElement\":\n        \"\"\"\n        Enable display of debugging messages while doing pattern matching.\n        Set ``flag`` to ``True`` to enable, ``False`` to disable.\n        Set ``recurse`` to ``True`` to set the debug flag on this expression and all sub-expressions.\n\n        Example::\n\n            wd = Word(alphas).set_name(\"alphaword\")\n            integer = Word(nums).set_name(\"numword\")\n            term = wd | integer\n\n            # turn on debugging for wd\n            wd.set_debug()\n\n            term[1, ...].parse_string(\"abc 123 xyz 890\")\n\n        prints::\n\n            Match alphaword at loc 0(1,1)\n            Matched alphaword -> ['abc']\n            Match alphaword at loc 3(1,4)\n            Exception raised:Expected alphaword (at char 4), (line:1, col:5)\n            Match alphaword at loc 7(1,8)\n            Matched alphaword -> ['xyz']\n            Match alphaword at loc 11(1,12)\n            Exception raised:Expected alphaword (at char 12), (line:1, col:13)\n            Match alphaword at loc 15(1,16)\n            Exception raised:Expected alphaword (at char 15), (line:1, col:16)\n\n        The output shown is that produced by the default debug actions - custom debug actions can be\n        specified using :class:`set_debug_actions`. Prior to attempting\n        to match the ``wd`` expression, the debugging message ``\"Match <exprname> at loc <n>(<line>,<col>)\"``\n        is shown. Then if the parse succeeds, a ``\"Matched\"`` message is shown, or an ``\"Exception raised\"``\n        message is shown. Also note the use of :class:`set_name` to assign a human-readable name to the expression,\n        which makes debugging and exception messages easier to understand - for instance, the default\n        name created for the :class:`Word` expression without calling ``set_name`` is ``\"W:(A-Za-z)\"``.\n        \"\"\"\n        if recurse:\n            for expr in self.visit_all():\n                expr.set_debug(flag, recurse=False)\n            return self\n\n        if flag:\n            self.set_debug_actions(\n                _default_start_debug_action,\n                _default_success_debug_action,\n                _default_exception_debug_action,\n            )\n        else:\n            self.debug = False\n        return self\n\n    @property\n    def default_name(self) -> str:\n        if self._defaultName is None:\n            self._defaultName = self._generateDefaultName()\n        return self._defaultName\n\n    @abstractmethod\n    def _generateDefaultName(self) -> str:\n        \"\"\"\n        Child classes must define this method, which defines how the ``default_name`` is set.\n        \"\"\"\n\n    def set_name(self, name: str) -> \"ParserElement\":\n        \"\"\"\n        Define name for this expression, makes debugging and exception messages clearer.\n\n        Example::\n\n            integer = Word(nums)\n            integer.parse_string(\"ABC\")  # -> Exception: Expected W:(0-9) (at char 0), (line:1, col:1)\n\n            integer.set_name(\"integer\")\n            integer.parse_string(\"ABC\")  # -> Exception: Expected integer (at char 0), (line:1, col:1)\n        \"\"\"\n        self.customName = name\n        self.errmsg = f\"Expected {self.name}\"\n        if __diag__.enable_debug_on_named_expressions:\n            self.set_debug()\n        return self\n\n    @property\n    def name(self) -> str:\n        # This will use a user-defined name if available, but otherwise defaults back to the auto-generated name\n        return self.customName if self.customName is not None else self.default_name\n\n    def __str__(self) -> str:\n        return self.name\n\n    def __repr__(self) -> str:\n        return str(self)\n\n    def streamline(self) -> \"ParserElement\":\n        self.streamlined = True\n        self._defaultName = None\n        return self\n\n    def recurse(self) -> List[\"ParserElement\"]:\n        return []\n\n    def _checkRecursion(self, parseElementList):\n        subRecCheckList = parseElementList[:] + [self]\n        for e in self.recurse():\n            e._checkRecursion(subRecCheckList)\n\n    def validate(self, validateTrace=None) -> None:\n        \"\"\"\n        Check defined expressions for valid structure, check for infinite recursive definitions.\n        \"\"\"\n        warnings.warn(\n            \"ParserElement.validate() is deprecated, and should not be used to check for left recursion\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        self._checkRecursion([])\n\n    def parse_file(\n        self,\n        file_or_filename: Union[str, Path, TextIO],\n        encoding: str = \"utf-8\",\n        parse_all: bool = False,\n        *,\n        parseAll: bool = False,\n    ) -> ParseResults:\n        \"\"\"\n        Execute the parse expression on the given file or filename.\n        If a filename is specified (instead of a file object),\n        the entire file is opened, read, and closed before parsing.\n        \"\"\"\n        parseAll = parseAll or parse_all\n        try:\n            file_or_filename = typing.cast(TextIO, file_or_filename)\n            file_contents = file_or_filename.read()\n        except AttributeError:\n            file_or_filename = typing.cast(str, file_or_filename)\n            with open(file_or_filename, \"r\", encoding=encoding) as f:\n                file_contents = f.read()\n        try:\n            return self.parse_string(file_contents, parseAll)\n        except ParseBaseException as exc:\n            if ParserElement.verbose_stacktrace:\n                raise\n\n            # catch and re-raise exception from here, clears out pyparsing internal stack trace\n            raise exc.with_traceback(None)\n\n    def __eq__(self, other):\n        if self is other:\n            return True\n        elif isinstance(other, str_type):\n            return self.matches(other, parse_all=True)\n        elif isinstance(other, ParserElement):\n            return vars(self) == vars(other)\n        return False\n\n    def __hash__(self):\n        return id(self)\n\n    def matches(\n        self, test_string: str, parse_all: bool = True, *, parseAll: bool = True\n    ) -> bool:\n        \"\"\"\n        Method for quick testing of a parser against a test string. Good for simple\n        inline microtests of sub expressions while building up larger parser.\n\n        Parameters:\n\n        - ``test_string`` - to test against this expression for a match\n        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests\n\n        Example::\n\n            expr = Word(nums)\n            assert expr.matches(\"100\")\n        \"\"\"\n        parseAll = parseAll and parse_all\n        try:\n            self.parse_string(str(test_string), parse_all=parseAll)\n            return True\n        except ParseBaseException:\n            return False\n\n    def run_tests(\n        self,\n        tests: Union[str, List[str]],\n        parse_all: bool = True,\n        comment: typing.Optional[Union[\"ParserElement\", str]] = \"#\",\n        full_dump: bool = True,\n        print_results: bool = True,\n        failure_tests: bool = False,\n        post_parse: typing.Optional[\n            Callable[[str, ParseResults], typing.Optional[str]]\n        ] = None,\n        file: typing.Optional[TextIO] = None,\n        with_line_numbers: bool = False,\n        *,\n        parseAll: bool = True,\n        fullDump: bool = True,\n        printResults: bool = True,\n        failureTests: bool = False,\n        postParse: typing.Optional[\n            Callable[[str, ParseResults], typing.Optional[str]]\n        ] = None,\n    ) -> Tuple[bool, List[Tuple[str, Union[ParseResults, Exception]]]]:\n        \"\"\"\n        Execute the parse expression on a series of test strings, showing each\n        test, the parsed results or where the parse failed. Quick and easy way to\n        run a parse expression against a list of sample strings.\n\n        Parameters:\n\n        - ``tests`` - a list of separate test strings, or a multiline string of test strings\n        - ``parse_all`` - (default= ``True``) - flag to pass to :class:`parse_string` when running tests\n        - ``comment`` - (default= ``'#'``) - expression for indicating embedded comments in the test\n          string; pass None to disable comment filtering\n        - ``full_dump`` - (default= ``True``) - dump results as list followed by results names in nested outline;\n          if False, only dump nested list\n        - ``print_results`` - (default= ``True``) prints test output to stdout\n        - ``failure_tests`` - (default= ``False``) indicates if these tests are expected to fail parsing\n        - ``post_parse`` - (default= ``None``) optional callback for successful parse results; called as\n          `fn(test_string, parse_results)` and returns a string to be added to the test output\n        - ``file`` - (default= ``None``) optional file-like object to which test output will be written;\n          if None, will default to ``sys.stdout``\n        - ``with_line_numbers`` - default= ``False``) show test strings with line and column numbers\n\n        Returns: a (success, results) tuple, where success indicates that all tests succeeded\n        (or failed if ``failure_tests`` is True), and the results contain a list of lines of each\n        test's output\n\n        Example::\n\n            number_expr = pyparsing_common.number.copy()\n\n            result = number_expr.run_tests('''\n                # unsigned integer\n                100\n                # negative integer\n                -100\n                # float with scientific notation\n                6.02e23\n                # integer with scientific notation\n                1e-12\n                ''')\n            print(\"Success\" if result[0] else \"Failed!\")\n\n            result = number_expr.run_tests('''\n                # stray character\n                100Z\n                # missing leading digit before '.'\n                -.100\n                # too many '.'\n                3.14.159\n                ''', failure_tests=True)\n            print(\"Success\" if result[0] else \"Failed!\")\n\n        prints::\n\n            # unsigned integer\n            100\n            [100]\n\n            # negative integer\n            -100\n            [-100]\n\n            # float with scientific notation\n            6.02e23\n            [6.02e+23]\n\n            # integer with scientific notation\n            1e-12\n            [1e-12]\n\n            Success\n\n            # stray character\n            100Z\n               ^\n            FAIL: Expected end of text (at char 3), (line:1, col:4)\n\n            # missing leading digit before '.'\n            -.100\n            ^\n            FAIL: Expected {real number with scientific notation | real number | signed integer} (at char 0), (line:1, col:1)\n\n            # too many '.'\n            3.14.159\n                ^\n            FAIL: Expected end of text (at char 4), (line:1, col:5)\n\n            Success\n\n        Each test string must be on a single line. If you want to test a string that spans multiple\n        lines, create a test like this::\n\n            expr.run_tests(r\"this is a test\\\\n of strings that spans \\\\n 3 lines\")\n\n        (Note that this is a raw string literal, you must include the leading ``'r'``.)\n        \"\"\"\n        from .testing import pyparsing_test\n\n        parseAll = parseAll and parse_all\n        fullDump = fullDump and full_dump\n        printResults = printResults and print_results\n        failureTests = failureTests or failure_tests\n        postParse = postParse or post_parse\n        if isinstance(tests, str_type):\n            tests = typing.cast(str, tests)\n            line_strip = type(tests).strip\n            tests = [line_strip(test_line) for test_line in tests.rstrip().splitlines()]\n        comment_specified = comment is not None\n        if comment_specified:\n            if isinstance(comment, str_type):\n                comment = typing.cast(str, comment)\n                comment = Literal(comment)\n        comment = typing.cast(ParserElement, comment)\n        if file is None:\n            file = sys.stdout\n        print_ = file.write\n\n        result: Union[ParseResults, Exception]\n        allResults: List[Tuple[str, Union[ParseResults, Exception]]] = []\n        comments: List[str] = []\n        success = True\n        NL = Literal(r\"\\n\").add_parse_action(replace_with(\"\\n\")).ignore(quoted_string)\n        BOM = \"\\ufeff\"\n        nlstr = \"\\n\"\n        for t in tests:\n            if comment_specified and comment.matches(t, False) or comments and not t:\n                comments.append(\n                    pyparsing_test.with_line_numbers(t) if with_line_numbers else t\n                )\n                continue\n            if not t:\n                continue\n            out = [\n                f\"{nlstr}{nlstr.join(comments) if comments else ''}\",\n                pyparsing_test.with_line_numbers(t) if with_line_numbers else t,\n            ]\n            comments = []\n            try:\n                # convert newline marks to actual newlines, and strip leading BOM if present\n                t = NL.transform_string(t.lstrip(BOM))\n                result = self.parse_string(t, parse_all=parseAll)\n            except ParseBaseException as pe:\n                fatal = \"(FATAL) \" if isinstance(pe, ParseFatalException) else \"\"\n                out.append(pe.explain())\n                out.append(f\"FAIL: {fatal}{pe}\")\n                if ParserElement.verbose_stacktrace:\n                    out.extend(traceback.format_tb(pe.__traceback__))\n                success = success and failureTests\n                result = pe\n            except Exception as exc:\n                out.append(f\"FAIL-EXCEPTION: {type(exc).__name__}: {exc}\")\n                if ParserElement.verbose_stacktrace:\n                    out.extend(traceback.format_tb(exc.__traceback__))\n                success = success and failureTests\n                result = exc\n            else:\n                success = success and not failureTests\n                if postParse is not None:\n                    try:\n                        pp_value = postParse(t, result)\n                        if pp_value is not None:\n                            if isinstance(pp_value, ParseResults):\n                                out.append(pp_value.dump())\n                            else:\n                                out.append(str(pp_value))\n                        else:\n                            out.append(result.dump())\n                    except Exception as e:\n                        out.append(result.dump(full=fullDump))\n                        out.append(\n                            f\"{postParse.__name__} failed: {type(e).__name__}: {e}\"\n                        )\n                else:\n                    out.append(result.dump(full=fullDump))\n            out.append(\"\")\n\n            if printResults:\n                print_(\"\\n\".join(out))\n\n            allResults.append((t, result))\n\n        return success, allResults\n\n    def create_diagram(\n        self,\n        output_html: Union[TextIO, Path, str],\n        vertical: int = 3,\n        show_results_names: bool = False,\n        show_groups: bool = False,\n        embed: bool = False,\n        **kwargs,\n    ) -> None:\n        \"\"\"\n        Create a railroad diagram for the parser.\n\n        Parameters:\n\n        - ``output_html`` (str or file-like object) - output target for generated\n          diagram HTML\n        - ``vertical`` (int) - threshold for formatting multiple alternatives vertically\n          instead of horizontally (default=3)\n        - ``show_results_names`` - bool flag whether diagram should show annotations for\n          defined results names\n        - ``show_groups`` - bool flag whether groups should be highlighted with an unlabeled surrounding box\n        - ``embed`` - bool flag whether generated HTML should omit <HEAD>, <BODY>, and <DOCTYPE> tags to embed\n          the resulting HTML in an enclosing HTML source\n        - ``head`` - str containing additional HTML to insert into the <HEAD> section of the generated code;\n          can be used to insert custom CSS styling\n        - ``body`` - str containing additional HTML to insert at the beginning of the <BODY> section of the\n          generated code\n\n        Additional diagram-formatting keyword arguments can also be included;\n        see railroad.Diagram class.\n        \"\"\"\n\n        try:\n            from .diagram import to_railroad, railroad_to_html\n        except ImportError as ie:\n            raise Exception(\n                \"must ``pip install pyparsing[diagrams]`` to generate parser railroad diagrams\"\n            ) from ie\n\n        self.streamline()\n\n        railroad = to_railroad(\n            self,\n            vertical=vertical,\n            show_results_names=show_results_names,\n            show_groups=show_groups,\n            diagram_kwargs=kwargs,\n        )\n        if not isinstance(output_html, (str, Path)):\n            # we were passed a file-like object, just write to it\n            output_html.write(railroad_to_html(railroad, embed=embed, **kwargs))\n            return\n\n        with open(output_html, \"w\", encoding=\"utf-8\") as diag_file:\n            diag_file.write(railroad_to_html(railroad, embed=embed, **kwargs))\n\n    # Compatibility synonyms\n    # fmt: off\n    inlineLiteralsUsing = staticmethod(replaced_by_pep8(\"inlineLiteralsUsing\", inline_literals_using))\n    setDefaultWhitespaceChars = staticmethod(replaced_by_pep8(\n        \"setDefaultWhitespaceChars\", set_default_whitespace_chars\n    ))\n    disableMemoization = staticmethod(replaced_by_pep8(\"disableMemoization\", disable_memoization))\n    enableLeftRecursion = staticmethod(replaced_by_pep8(\"enableLeftRecursion\", enable_left_recursion))\n    enablePackrat = staticmethod(replaced_by_pep8(\"enablePackrat\", enable_packrat))\n    resetCache = staticmethod(replaced_by_pep8(\"resetCache\", reset_cache))\n\n    setResultsName = replaced_by_pep8(\"setResultsName\", set_results_name)\n    setBreak = replaced_by_pep8(\"setBreak\", set_break)\n    setParseAction = replaced_by_pep8(\"setParseAction\", set_parse_action)\n    addParseAction = replaced_by_pep8(\"addParseAction\", add_parse_action)\n    addCondition = replaced_by_pep8(\"addCondition\", add_condition)\n    setFailAction = replaced_by_pep8(\"setFailAction\", set_fail_action)\n    tryParse = replaced_by_pep8(\"tryParse\", try_parse)\n    parseString = replaced_by_pep8(\"parseString\", parse_string)\n    scanString = replaced_by_pep8(\"scanString\", scan_string)\n    transformString = replaced_by_pep8(\"transformString\", transform_string)\n    searchString = replaced_by_pep8(\"searchString\", search_string)\n    ignoreWhitespace = replaced_by_pep8(\"ignoreWhitespace\", ignore_whitespace)\n    leaveWhitespace = replaced_by_pep8(\"leaveWhitespace\", leave_whitespace)\n    setWhitespaceChars = replaced_by_pep8(\"setWhitespaceChars\", set_whitespace_chars)\n    parseWithTabs = replaced_by_pep8(\"parseWithTabs\", parse_with_tabs)\n    setDebugActions = replaced_by_pep8(\"setDebugActions\", set_debug_actions)\n    setDebug = replaced_by_pep8(\"setDebug\", set_debug)\n    setName = replaced_by_pep8(\"setName\", set_name)\n    parseFile = replaced_by_pep8(\"parseFile\", parse_file)\n    runTests = replaced_by_pep8(\"runTests\", run_tests)\n    canParseNext = replaced_by_pep8(\"canParseNext\", can_parse_next)\n    defaultName = default_name\n    # fmt: on\n\n\nclass _PendingSkip(ParserElement):\n    # internal placeholder class to hold a place were '...' is added to a parser element,\n    # once another ParserElement is added, this placeholder will be replaced with a SkipTo\n    def __init__(self, expr: ParserElement, must_skip: bool = False):\n        super().__init__()\n        self.anchor = expr\n        self.must_skip = must_skip\n\n    def _generateDefaultName(self) -> str:\n        return str(self.anchor + Empty()).replace(\"Empty\", \"...\")\n\n    def __add__(self, other) -> \"ParserElement\":\n        skipper = SkipTo(other).set_name(\"...\")(\"_skipped*\")\n        if self.must_skip:\n\n            def must_skip(t):\n                if not t._skipped or t._skipped.as_list() == [\"\"]:\n                    del t[0]\n                    t.pop(\"_skipped\", None)\n\n            def show_skip(t):\n                if t._skipped.as_list()[-1:] == [\"\"]:\n                    t.pop(\"_skipped\")\n                    t[\"_skipped\"] = f\"missing <{self.anchor!r}>\"\n\n            return (\n                self.anchor + skipper().add_parse_action(must_skip)\n                | skipper().add_parse_action(show_skip)\n            ) + other\n\n        return self.anchor + skipper + other\n\n    def __repr__(self):\n        return self.defaultName\n\n    def parseImpl(self, *args):\n        raise Exception(\n            \"use of `...` expression without following SkipTo target expression\"\n        )\n\n\nclass Token(ParserElement):\n    \"\"\"Abstract :class:`ParserElement` subclass, for defining atomic\n    matching patterns.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__(savelist=False)\n\n    def _generateDefaultName(self) -> str:\n        return type(self).__name__\n\n\nclass NoMatch(Token):\n    \"\"\"\n    A token that will never match.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.mayReturnEmpty = True\n        self.mayIndexError = False\n        self.errmsg = \"Unmatchable token\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass Literal(Token):\n    \"\"\"\n    Token to exactly match a specified string.\n\n    Example::\n\n        Literal('abc').parse_string('abc')  # -> ['abc']\n        Literal('abc').parse_string('abcdef')  # -> ['abc']\n        Literal('abc').parse_string('ab')  # -> Exception: Expected \"abc\"\n\n    For case-insensitive matching, use :class:`CaselessLiteral`.\n\n    For keyword matching (force word break before and after the matched string),\n    use :class:`Keyword` or :class:`CaselessKeyword`.\n    \"\"\"\n\n    def __new__(cls, match_string: str = \"\", *, matchString: str = \"\"):\n        # Performance tuning: select a subclass with optimized parseImpl\n        if cls is Literal:\n            match_string = matchString or match_string\n            if not match_string:\n                return super().__new__(Empty)\n            if len(match_string) == 1:\n                return super().__new__(_SingleCharLiteral)\n\n        # Default behavior\n        return super().__new__(cls)\n\n    # Needed to make copy.copy() work correctly if we customize __new__\n    def __getnewargs__(self):\n        return (self.match,)\n\n    def __init__(self, match_string: str = \"\", *, matchString: str = \"\"):\n        super().__init__()\n        match_string = matchString or match_string\n        self.match = match_string\n        self.matchLen = len(match_string)\n        self.firstMatchChar = match_string[:1]\n        self.errmsg = f\"Expected {self.name}\"\n        self.mayReturnEmpty = False\n        self.mayIndexError = False\n\n    def _generateDefaultName(self) -> str:\n        return repr(self.match)\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if instring[loc] == self.firstMatchChar and instring.startswith(\n            self.match, loc\n        ):\n            return loc + self.matchLen, self.match\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass Empty(Literal):\n    \"\"\"\n    An empty token, will always match.\n    \"\"\"\n\n    def __init__(self, match_string=\"\", *, matchString=\"\"):\n        super().__init__(\"\")\n        self.mayReturnEmpty = True\n        self.mayIndexError = False\n\n    def _generateDefaultName(self) -> str:\n        return \"Empty\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        return loc, []\n\n\nclass _SingleCharLiteral(Literal):\n    def parseImpl(self, instring, loc, doActions=True):\n        if instring[loc] == self.firstMatchChar:\n            return loc + 1, self.match\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nParserElement._literalStringClass = Literal\n\n\nclass Keyword(Token):\n    \"\"\"\n    Token to exactly match a specified string as a keyword, that is,\n    it must be immediately preceded and followed by whitespace or\n    non-keyword characters. Compare with :class:`Literal`:\n\n    - ``Literal(\"if\")`` will match the leading ``'if'`` in\n      ``'ifAndOnlyIf'``.\n    - ``Keyword(\"if\")`` will not; it will only match the leading\n      ``'if'`` in ``'if x=1'``, or ``'if(y==2)'``\n\n    Accepts two optional constructor arguments in addition to the\n    keyword string:\n\n    - ``ident_chars`` is a string of characters that would be valid\n      identifier characters, defaulting to all alphanumerics + \"_\" and\n      \"$\"\n    - ``caseless`` allows case-insensitive matching, default is ``False``.\n\n    Example::\n\n        Keyword(\"start\").parse_string(\"start\")  # -> ['start']\n        Keyword(\"start\").parse_string(\"starting\")  # -> Exception\n\n    For case-insensitive matching, use :class:`CaselessKeyword`.\n    \"\"\"\n\n    DEFAULT_KEYWORD_CHARS = alphanums + \"_$\"\n\n    def __init__(\n        self,\n        match_string: str = \"\",\n        ident_chars: typing.Optional[str] = None,\n        caseless: bool = False,\n        *,\n        matchString: str = \"\",\n        identChars: typing.Optional[str] = None,\n    ):\n        super().__init__()\n        identChars = identChars or ident_chars\n        if identChars is None:\n            identChars = Keyword.DEFAULT_KEYWORD_CHARS\n        match_string = matchString or match_string\n        self.match = match_string\n        self.matchLen = len(match_string)\n        try:\n            self.firstMatchChar = match_string[0]\n        except IndexError:\n            raise ValueError(\"null string passed to Keyword; use Empty() instead\")\n        self.errmsg = f\"Expected {type(self).__name__} {self.name}\"\n        self.mayReturnEmpty = False\n        self.mayIndexError = False\n        self.caseless = caseless\n        if caseless:\n            self.caselessmatch = match_string.upper()\n            identChars = identChars.upper()\n        self.identChars = set(identChars)\n\n    def _generateDefaultName(self) -> str:\n        return repr(self.match)\n\n    def parseImpl(self, instring, loc, doActions=True):\n        errmsg = self.errmsg\n        errloc = loc\n        if self.caseless:\n            if instring[loc : loc + self.matchLen].upper() == self.caselessmatch:\n                if loc == 0 or instring[loc - 1].upper() not in self.identChars:\n                    if (\n                        loc >= len(instring) - self.matchLen\n                        or instring[loc + self.matchLen].upper() not in self.identChars\n                    ):\n                        return loc + self.matchLen, self.match\n\n                    # followed by keyword char\n                    errmsg += \", was immediately followed by keyword character\"\n                    errloc = loc + self.matchLen\n                else:\n                    # preceded by keyword char\n                    errmsg += \", keyword was immediately preceded by keyword character\"\n                    errloc = loc - 1\n            # else no match just raise plain exception\n\n        elif (\n            instring[loc] == self.firstMatchChar\n            and self.matchLen == 1\n            or instring.startswith(self.match, loc)\n        ):\n            if loc == 0 or instring[loc - 1] not in self.identChars:\n                if (\n                    loc >= len(instring) - self.matchLen\n                    or instring[loc + self.matchLen] not in self.identChars\n                ):\n                    return loc + self.matchLen, self.match\n\n                # followed by keyword char\n                errmsg += \", keyword was immediately followed by keyword character\"\n                errloc = loc + self.matchLen\n            else:\n                # preceded by keyword char\n                errmsg += \", keyword was immediately preceded by keyword character\"\n                errloc = loc - 1\n        # else no match just raise plain exception\n\n        raise ParseException(instring, errloc, errmsg, self)\n\n    @staticmethod\n    def set_default_keyword_chars(chars) -> None:\n        \"\"\"\n        Overrides the default characters used by :class:`Keyword` expressions.\n        \"\"\"\n        Keyword.DEFAULT_KEYWORD_CHARS = chars\n\n    # Compatibility synonyms\n    setDefaultKeywordChars = staticmethod(\n        replaced_by_pep8(\"setDefaultKeywordChars\", set_default_keyword_chars)\n    )\n\n\nclass CaselessLiteral(Literal):\n    \"\"\"\n    Token to match a specified string, ignoring case of letters.\n    Note: the matched results will always be in the case of the given\n    match string, NOT the case of the input text.\n\n    Example::\n\n        CaselessLiteral(\"CMD\")[1, ...].parse_string(\"cmd CMD Cmd10\")\n        # -> ['CMD', 'CMD', 'CMD']\n\n    (Contrast with example for :class:`CaselessKeyword`.)\n    \"\"\"\n\n    def __init__(self, match_string: str = \"\", *, matchString: str = \"\"):\n        match_string = matchString or match_string\n        super().__init__(match_string.upper())\n        # Preserve the defining literal.\n        self.returnString = match_string\n        self.errmsg = f\"Expected {self.name}\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if instring[loc : loc + self.matchLen].upper() == self.match:\n            return loc + self.matchLen, self.returnString\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass CaselessKeyword(Keyword):\n    \"\"\"\n    Caseless version of :class:`Keyword`.\n\n    Example::\n\n        CaselessKeyword(\"CMD\")[1, ...].parse_string(\"cmd CMD Cmd10\")\n        # -> ['CMD', 'CMD']\n\n    (Contrast with example for :class:`CaselessLiteral`.)\n    \"\"\"\n\n    def __init__(\n        self,\n        match_string: str = \"\",\n        ident_chars: typing.Optional[str] = None,\n        *,\n        matchString: str = \"\",\n        identChars: typing.Optional[str] = None,\n    ):\n        identChars = identChars or ident_chars\n        match_string = matchString or match_string\n        super().__init__(match_string, identChars, caseless=True)\n\n\nclass CloseMatch(Token):\n    \"\"\"A variation on :class:`Literal` which matches \"close\" matches,\n    that is, strings with at most 'n' mismatching characters.\n    :class:`CloseMatch` takes parameters:\n\n    - ``match_string`` - string to be matched\n    - ``caseless`` - a boolean indicating whether to ignore casing when comparing characters\n    - ``max_mismatches`` - (``default=1``) maximum number of\n      mismatches allowed to count as a match\n\n    The results from a successful parse will contain the matched text\n    from the input string and the following named results:\n\n    - ``mismatches`` - a list of the positions within the\n      match_string where mismatches were found\n    - ``original`` - the original match_string used to compare\n      against the input string\n\n    If ``mismatches`` is an empty list, then the match was an exact\n    match.\n\n    Example::\n\n        patt = CloseMatch(\"ATCATCGAATGGA\")\n        patt.parse_string(\"ATCATCGAAXGGA\") # -> (['ATCATCGAAXGGA'], {'mismatches': [[9]], 'original': ['ATCATCGAATGGA']})\n        patt.parse_string(\"ATCAXCGAAXGGA\") # -> Exception: Expected 'ATCATCGAATGGA' (with up to 1 mismatches) (at char 0), (line:1, col:1)\n\n        # exact match\n        patt.parse_string(\"ATCATCGAATGGA\") # -> (['ATCATCGAATGGA'], {'mismatches': [[]], 'original': ['ATCATCGAATGGA']})\n\n        # close match allowing up to 2 mismatches\n        patt = CloseMatch(\"ATCATCGAATGGA\", max_mismatches=2)\n        patt.parse_string(\"ATCAXCGAAXGGA\") # -> (['ATCAXCGAAXGGA'], {'mismatches': [[4, 9]], 'original': ['ATCATCGAATGGA']})\n    \"\"\"\n\n    def __init__(\n        self,\n        match_string: str,\n        max_mismatches: typing.Optional[int] = None,\n        *,\n        maxMismatches: int = 1,\n        caseless=False,\n    ):\n        maxMismatches = max_mismatches if max_mismatches is not None else maxMismatches\n        super().__init__()\n        self.match_string = match_string\n        self.maxMismatches = maxMismatches\n        self.errmsg = f\"Expected {self.match_string!r} (with up to {self.maxMismatches} mismatches)\"\n        self.caseless = caseless\n        self.mayIndexError = False\n        self.mayReturnEmpty = False\n\n    def _generateDefaultName(self) -> str:\n        return f\"{type(self).__name__}:{self.match_string!r}\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        start = loc\n        instrlen = len(instring)\n        maxloc = start + len(self.match_string)\n\n        if maxloc <= instrlen:\n            match_string = self.match_string\n            match_stringloc = 0\n            mismatches = []\n            maxMismatches = self.maxMismatches\n\n            for match_stringloc, s_m in enumerate(\n                zip(instring[loc:maxloc], match_string)\n            ):\n                src, mat = s_m\n                if self.caseless:\n                    src, mat = src.lower(), mat.lower()\n\n                if src != mat:\n                    mismatches.append(match_stringloc)\n                    if len(mismatches) > maxMismatches:\n                        break\n            else:\n                loc = start + match_stringloc + 1\n                results = ParseResults([instring[start:loc]])\n                results[\"original\"] = match_string\n                results[\"mismatches\"] = mismatches\n                return loc, results\n\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass Word(Token):\n    \"\"\"Token for matching words composed of allowed character sets.\n\n    Parameters:\n\n    - ``init_chars`` - string of all characters that should be used to\n      match as a word; \"ABC\" will match \"AAA\", \"ABAB\", \"CBAC\", etc.;\n      if ``body_chars`` is also specified, then this is the string of\n      initial characters\n    - ``body_chars`` - string of characters that\n      can be used for matching after a matched initial character as\n      given in ``init_chars``; if omitted, same as the initial characters\n      (default=``None``)\n    - ``min`` - minimum number of characters to match (default=1)\n    - ``max`` - maximum number of characters to match (default=0)\n    - ``exact`` - exact number of characters to match (default=0)\n    - ``as_keyword`` - match as a keyword (default=``False``)\n    - ``exclude_chars`` - characters that might be\n      found in the input ``body_chars`` string but which should not be\n      accepted for matching ;useful to define a word of all\n      printables except for one or two characters, for instance\n      (default=``None``)\n\n    :class:`srange` is useful for defining custom character set strings\n    for defining :class:`Word` expressions, using range notation from\n    regular expression character sets.\n\n    A common mistake is to use :class:`Word` to match a specific literal\n    string, as in ``Word(\"Address\")``. Remember that :class:`Word`\n    uses the string argument to define *sets* of matchable characters.\n    This expression would match \"Add\", \"AAA\", \"dAred\", or any other word\n    made up of the characters 'A', 'd', 'r', 'e', and 's'. To match an\n    exact literal string, use :class:`Literal` or :class:`Keyword`.\n\n    pyparsing includes helper strings for building Words:\n\n    - :class:`alphas`\n    - :class:`nums`\n    - :class:`alphanums`\n    - :class:`hexnums`\n    - :class:`alphas8bit` (alphabetic characters in ASCII range 128-255\n      - accented, tilded, umlauted, etc.)\n    - :class:`punc8bit` (non-alphabetic characters in ASCII range\n      128-255 - currency, symbols, superscripts, diacriticals, etc.)\n    - :class:`printables` (any non-whitespace character)\n\n    ``alphas``, ``nums``, and ``printables`` are also defined in several\n    Unicode sets - see :class:`pyparsing_unicode``.\n\n    Example::\n\n        # a word composed of digits\n        integer = Word(nums) # equivalent to Word(\"0123456789\") or Word(srange(\"0-9\"))\n\n        # a word with a leading capital, and zero or more lowercase\n        capitalized_word = Word(alphas.upper(), alphas.lower())\n\n        # hostnames are alphanumeric, with leading alpha, and '-'\n        hostname = Word(alphas, alphanums + '-')\n\n        # roman numeral (not a strict parser, accepts invalid mix of characters)\n        roman = Word(\"IVXLCDM\")\n\n        # any string of non-whitespace characters, except for ','\n        csv_value = Word(printables, exclude_chars=\",\")\n    \"\"\"\n\n    def __init__(\n        self,\n        init_chars: str = \"\",\n        body_chars: typing.Optional[str] = None,\n        min: int = 1,\n        max: int = 0,\n        exact: int = 0,\n        as_keyword: bool = False,\n        exclude_chars: typing.Optional[str] = None,\n        *,\n        initChars: typing.Optional[str] = None,\n        bodyChars: typing.Optional[str] = None,\n        asKeyword: bool = False,\n        excludeChars: typing.Optional[str] = None,\n    ):\n        initChars = initChars or init_chars\n        bodyChars = bodyChars or body_chars\n        asKeyword = asKeyword or as_keyword\n        excludeChars = excludeChars or exclude_chars\n        super().__init__()\n        if not initChars:\n            raise ValueError(\n                f\"invalid {type(self).__name__}, initChars cannot be empty string\"\n            )\n\n        initChars_set = set(initChars)\n        if excludeChars:\n            excludeChars_set = set(excludeChars)\n            initChars_set -= excludeChars_set\n            if bodyChars:\n                bodyChars = \"\".join(set(bodyChars) - excludeChars_set)\n        self.initChars = initChars_set\n        self.initCharsOrig = \"\".join(sorted(initChars_set))\n\n        if bodyChars:\n            self.bodyChars = set(bodyChars)\n            self.bodyCharsOrig = \"\".join(sorted(bodyChars))\n        else:\n            self.bodyChars = initChars_set\n            self.bodyCharsOrig = self.initCharsOrig\n\n        self.maxSpecified = max > 0\n\n        if min < 1:\n            raise ValueError(\n                \"cannot specify a minimum length < 1; use Opt(Word()) if zero-length word is permitted\"\n            )\n\n        if self.maxSpecified and min > max:\n            raise ValueError(\n                f\"invalid args, if min and max both specified min must be <= max (min={min}, max={max})\"\n            )\n\n        self.minLen = min\n\n        if max > 0:\n            self.maxLen = max\n        else:\n            self.maxLen = _MAX_INT\n\n        if exact > 0:\n            min = max = exact\n            self.maxLen = exact\n            self.minLen = exact\n\n        self.errmsg = f\"Expected {self.name}\"\n        self.mayIndexError = False\n        self.asKeyword = asKeyword\n        if self.asKeyword:\n            self.errmsg += \" as a keyword\"\n\n        # see if we can make a regex for this Word\n        if \" \" not in (self.initChars | self.bodyChars):\n            if len(self.initChars) == 1:\n                re_leading_fragment = re.escape(self.initCharsOrig)\n            else:\n                re_leading_fragment = f\"[{_collapse_string_to_ranges(self.initChars)}]\"\n\n            if self.bodyChars == self.initChars:\n                if max == 0 and self.minLen == 1:\n                    repeat = \"+\"\n                elif max == 1:\n                    repeat = \"\"\n                else:\n                    if self.minLen != self.maxLen:\n                        repeat = f\"{{{self.minLen},{'' if self.maxLen == _MAX_INT else self.maxLen}}}\"\n                    else:\n                        repeat = f\"{{{self.minLen}}}\"\n                self.reString = f\"{re_leading_fragment}{repeat}\"\n            else:\n                if max == 1:\n                    re_body_fragment = \"\"\n                    repeat = \"\"\n                else:\n                    re_body_fragment = f\"[{_collapse_string_to_ranges(self.bodyChars)}]\"\n                    if max == 0 and self.minLen == 1:\n                        repeat = \"*\"\n                    elif max == 2:\n                        repeat = \"?\" if min <= 1 else \"\"\n                    else:\n                        if min != max:\n                            repeat = f\"{{{min - 1 if min > 0 else ''},{max - 1 if max > 0 else ''}}}\"\n                        else:\n                            repeat = f\"{{{min - 1 if min > 0 else ''}}}\"\n\n                self.reString = f\"{re_leading_fragment}{re_body_fragment}{repeat}\"\n\n            if self.asKeyword:\n                self.reString = rf\"\\b{self.reString}\\b\"\n\n            try:\n                self.re = re.compile(self.reString)\n            except re.error:\n                self.re = None  # type: ignore[assignment]\n            else:\n                self.re_match = self.re.match\n                self.parseImpl = self.parseImpl_regex  # type: ignore[assignment]\n\n    def _generateDefaultName(self) -> str:\n        def charsAsStr(s):\n            max_repr_len = 16\n            s = _collapse_string_to_ranges(s, re_escape=False)\n\n            if len(s) > max_repr_len:\n                return s[: max_repr_len - 3] + \"...\"\n\n            return s\n\n        if self.initChars != self.bodyChars:\n            base = f\"W:({charsAsStr(self.initChars)}, {charsAsStr(self.bodyChars)})\"\n        else:\n            base = f\"W:({charsAsStr(self.initChars)})\"\n\n        # add length specification\n        if self.minLen > 1 or self.maxLen != _MAX_INT:\n            if self.minLen == self.maxLen:\n                if self.minLen == 1:\n                    return base[2:]\n                else:\n                    return base + f\"{{{self.minLen}}}\"\n            elif self.maxLen == _MAX_INT:\n                return base + f\"{{{self.minLen},...}}\"\n            else:\n                return base + f\"{{{self.minLen},{self.maxLen}}}\"\n        return base\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if instring[loc] not in self.initChars:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        start = loc\n        loc += 1\n        instrlen = len(instring)\n        bodychars = self.bodyChars\n        maxloc = start + self.maxLen\n        maxloc = min(maxloc, instrlen)\n        while loc < maxloc and instring[loc] in bodychars:\n            loc += 1\n\n        throwException = False\n        if loc - start < self.minLen:\n            throwException = True\n        elif self.maxSpecified and loc < instrlen and instring[loc] in bodychars:\n            throwException = True\n        elif self.asKeyword and (\n            (start > 0 and instring[start - 1] in bodychars)\n            or (loc < instrlen and instring[loc] in bodychars)\n        ):\n            throwException = True\n\n        if throwException:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        return loc, instring[start:loc]\n\n    def parseImpl_regex(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        return loc, result.group()\n\n\nclass Char(Word):\n    \"\"\"A short-cut class for defining :class:`Word` ``(characters, exact=1)``,\n    when defining a match of any single character in a string of\n    characters.\n    \"\"\"\n\n    def __init__(\n        self,\n        charset: str,\n        as_keyword: bool = False,\n        exclude_chars: typing.Optional[str] = None,\n        *,\n        asKeyword: bool = False,\n        excludeChars: typing.Optional[str] = None,\n    ):\n        asKeyword = asKeyword or as_keyword\n        excludeChars = excludeChars or exclude_chars\n        super().__init__(\n            charset, exact=1, as_keyword=asKeyword, exclude_chars=excludeChars\n        )\n\n\nclass Regex(Token):\n    r\"\"\"Token for matching strings that match a given regular\n    expression. Defined with string specifying the regular expression in\n    a form recognized by the stdlib Python  `re module <https://docs.python.org/3/library/re.html>`_.\n    If the given regex contains named groups (defined using ``(?P<name>...)``),\n    these will be preserved as named :class:`ParseResults`.\n\n    If instead of the Python stdlib ``re`` module you wish to use a different RE module\n    (such as the ``regex`` module), you can do so by building your ``Regex`` object with\n    a compiled RE that was compiled using ``regex``.\n\n    Example::\n\n        realnum = Regex(r\"[+-]?\\d+\\.\\d*\")\n        # ref: https://stackoverflow.com/questions/267399/how-do-you-match-only-valid-roman-numerals-with-a-regular-expression\n        roman = Regex(r\"M{0,4}(CM|CD|D?{0,3})(XC|XL|L?X{0,3})(IX|IV|V?I{0,3})\")\n\n        # named fields in a regex will be returned as named results\n        date = Regex(r'(?P<year>\\d{4})-(?P<month>\\d\\d?)-(?P<day>\\d\\d?)')\n\n        # the Regex class will accept re's compiled using the regex module\n        import regex\n        parser = pp.Regex(regex.compile(r'[0-9]'))\n    \"\"\"\n\n    def __init__(\n        self,\n        pattern: Any,\n        flags: Union[re.RegexFlag, int] = 0,\n        as_group_list: bool = False,\n        as_match: bool = False,\n        *,\n        asGroupList: bool = False,\n        asMatch: bool = False,\n    ):\n        \"\"\"The parameters ``pattern`` and ``flags`` are passed\n        to the ``re.compile()`` function as-is. See the Python\n        `re module <https://docs.python.org/3/library/re.html>`_ module for an\n        explanation of the acceptable patterns and flags.\n        \"\"\"\n        super().__init__()\n        asGroupList = asGroupList or as_group_list\n        asMatch = asMatch or as_match\n\n        if isinstance(pattern, str_type):\n            if not pattern:\n                raise ValueError(\"null string passed to Regex; use Empty() instead\")\n\n            self._re = None\n            self.reString = self.pattern = pattern\n            self.flags = flags\n\n        elif hasattr(pattern, \"pattern\") and hasattr(pattern, \"match\"):\n            self._re = pattern\n            self.pattern = self.reString = pattern.pattern\n            self.flags = flags\n\n        else:\n            raise TypeError(\n                \"Regex may only be constructed with a string or a compiled RE object\"\n            )\n\n        self.errmsg = f\"Expected {self.name}\"\n        self.mayIndexError = False\n        self.asGroupList = asGroupList\n        self.asMatch = asMatch\n        if self.asGroupList:\n            self.parseImpl = self.parseImplAsGroupList  # type: ignore [assignment]\n        if self.asMatch:\n            self.parseImpl = self.parseImplAsMatch  # type: ignore [assignment]\n\n    @cached_property\n    def re(self):\n        if self._re:\n            return self._re\n\n        try:\n            return re.compile(self.pattern, self.flags)\n        except re.error:\n            raise ValueError(f\"invalid pattern ({self.pattern!r}) passed to Regex\")\n\n    @cached_property\n    def re_match(self):\n        return self.re.match\n\n    @cached_property\n    def mayReturnEmpty(self):\n        return self.re_match(\"\") is not None\n\n    def _generateDefaultName(self) -> str:\n        return \"Re:({})\".format(repr(self.pattern).replace(\"\\\\\\\\\", \"\\\\\"))\n\n    def parseImpl(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = ParseResults(result.group())\n        d = result.groupdict()\n\n        for k, v in d.items():\n            ret[k] = v\n\n        return loc, ret\n\n    def parseImplAsGroupList(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = result.groups()\n        return loc, ret\n\n    def parseImplAsMatch(self, instring, loc, doActions=True):\n        result = self.re_match(instring, loc)\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        loc = result.end()\n        ret = result\n        return loc, ret\n\n    def sub(self, repl: str) -> ParserElement:\n        r\"\"\"\n        Return :class:`Regex` with an attached parse action to transform the parsed\n        result as if called using `re.sub(expr, repl, string) <https://docs.python.org/3/library/re.html#re.sub>`_.\n\n        Example::\n\n            make_html = Regex(r\"(\\w+):(.*?):\").sub(r\"<\\1>\\2</\\1>\")\n            print(make_html.transform_string(\"h1:main title:\"))\n            # prints \"<h1>main title</h1>\"\n        \"\"\"\n        if self.asGroupList:\n            raise TypeError(\"cannot use sub() with Regex(as_group_list=True)\")\n\n        if self.asMatch and callable(repl):\n            raise TypeError(\n                \"cannot use sub() with a callable with Regex(as_match=True)\"\n            )\n\n        if self.asMatch:\n\n            def pa(tokens):\n                return tokens[0].expand(repl)\n\n        else:\n\n            def pa(tokens):\n                return self.re.sub(repl, tokens[0])\n\n        return self.add_parse_action(pa)\n\n\nclass QuotedString(Token):\n    r\"\"\"\n    Token for matching strings that are delimited by quoting characters.\n\n    Defined with the following parameters:\n\n    - ``quote_char`` - string of one or more characters defining the\n      quote delimiting string\n    - ``esc_char`` - character to re_escape quotes, typically backslash\n      (default= ``None``)\n    - ``esc_quote`` - special quote sequence to re_escape an embedded quote\n      string (such as SQL's ``\"\"`` to re_escape an embedded ``\"``)\n      (default= ``None``)\n    - ``multiline`` - boolean indicating whether quotes can span\n      multiple lines (default= ``False``)\n    - ``unquote_results`` - boolean indicating whether the matched text\n      should be unquoted (default= ``True``)\n    - ``end_quote_char`` - string of one or more characters defining the\n      end of the quote delimited string (default= ``None``  => same as\n      quote_char)\n    - ``convert_whitespace_escapes`` - convert escaped whitespace\n      (``'\\t'``, ``'\\n'``, etc.) to actual whitespace\n      (default= ``True``)\n\n    Example::\n\n        qs = QuotedString('\"')\n        print(qs.search_string('lsjdf \"This is the quote\" sldjf'))\n        complex_qs = QuotedString('{{', end_quote_char='}}')\n        print(complex_qs.search_string('lsjdf {{This is the \"quote\"}} sldjf'))\n        sql_qs = QuotedString('\"', esc_quote='\"\"')\n        print(sql_qs.search_string('lsjdf \"This is the quote with \"\"embedded\"\" quotes\" sldjf'))\n\n    prints::\n\n        [['This is the quote']]\n        [['This is the \"quote\"']]\n        [['This is the quote with \"embedded\" quotes']]\n    \"\"\"\n\n    ws_map = dict(((r\"\\t\", \"\\t\"), (r\"\\n\", \"\\n\"), (r\"\\f\", \"\\f\"), (r\"\\r\", \"\\r\")))\n\n    def __init__(\n        self,\n        quote_char: str = \"\",\n        esc_char: typing.Optional[str] = None,\n        esc_quote: typing.Optional[str] = None,\n        multiline: bool = False,\n        unquote_results: bool = True,\n        end_quote_char: typing.Optional[str] = None,\n        convert_whitespace_escapes: bool = True,\n        *,\n        quoteChar: str = \"\",\n        escChar: typing.Optional[str] = None,\n        escQuote: typing.Optional[str] = None,\n        unquoteResults: bool = True,\n        endQuoteChar: typing.Optional[str] = None,\n        convertWhitespaceEscapes: bool = True,\n    ):\n        super().__init__()\n        esc_char = escChar or esc_char\n        esc_quote = escQuote or esc_quote\n        unquote_results = unquoteResults and unquote_results\n        end_quote_char = endQuoteChar or end_quote_char\n        convert_whitespace_escapes = (\n            convertWhitespaceEscapes and convert_whitespace_escapes\n        )\n        quote_char = quoteChar or quote_char\n\n        # remove white space from quote chars\n        quote_char = quote_char.strip()\n        if not quote_char:\n            raise ValueError(\"quote_char cannot be the empty string\")\n\n        if end_quote_char is None:\n            end_quote_char = quote_char\n        else:\n            end_quote_char = end_quote_char.strip()\n            if not end_quote_char:\n                raise ValueError(\"end_quote_char cannot be the empty string\")\n\n        self.quote_char: str = quote_char\n        self.quote_char_len: int = len(quote_char)\n        self.first_quote_char: str = quote_char[0]\n        self.end_quote_char: str = end_quote_char\n        self.end_quote_char_len: int = len(end_quote_char)\n        self.esc_char: str = esc_char or \"\"\n        self.has_esc_char: bool = esc_char is not None\n        self.esc_quote: str = esc_quote or \"\"\n        self.unquote_results: bool = unquote_results\n        self.convert_whitespace_escapes: bool = convert_whitespace_escapes\n        self.multiline = multiline\n        self.re_flags = re.RegexFlag(0)\n\n        # fmt: off\n        # build up re pattern for the content between the quote delimiters\n        inner_pattern = []\n\n        if esc_quote:\n            inner_pattern.append(rf\"(?:{re.escape(esc_quote)})\")\n\n        if esc_char:\n            inner_pattern.append(rf\"(?:{re.escape(esc_char)}.)\")\n\n        if len(self.end_quote_char) > 1:\n            inner_pattern.append(\n                \"(?:\"\n                + \"|\".join(\n                    f\"(?:{re.escape(self.end_quote_char[:i])}(?!{re.escape(self.end_quote_char[i:])}))\"\n                    for i in range(len(self.end_quote_char) - 1, 0, -1)\n                )\n                + \")\"\n            )\n\n        if self.multiline:\n            self.re_flags |= re.MULTILINE | re.DOTALL\n            inner_pattern.append(\n                rf\"(?:[^{_escape_regex_range_chars(self.end_quote_char[0])}\"\n                rf\"{(_escape_regex_range_chars(esc_char) if self.has_esc_char else '')}])\"\n            )\n        else:\n            inner_pattern.append(\n                rf\"(?:[^{_escape_regex_range_chars(self.end_quote_char[0])}\\n\\r\"\n                rf\"{(_escape_regex_range_chars(esc_char) if self.has_esc_char else '')}])\"\n            )\n\n        self.pattern = \"\".join(\n            [\n                re.escape(self.quote_char),\n                \"(?:\",\n                '|'.join(inner_pattern),\n                \")*\",\n                re.escape(self.end_quote_char),\n            ]\n        )\n\n        if self.unquote_results:\n            if self.convert_whitespace_escapes:\n                self.unquote_scan_re = re.compile(\n                    rf\"({'|'.join(re.escape(k) for k in self.ws_map)})\"\n                    rf\"|({re.escape(self.esc_char)}.)\"\n                    rf\"|(\\n|.)\",\n                    flags=self.re_flags,\n                )\n            else:\n                self.unquote_scan_re = re.compile(\n                    rf\"({re.escape(self.esc_char)}.)\"\n                    rf\"|(\\n|.)\",\n                    flags=self.re_flags\n                )\n        # fmt: on\n\n        try:\n            self.re = re.compile(self.pattern, self.re_flags)\n            self.reString = self.pattern\n            self.re_match = self.re.match\n        except re.error:\n            raise ValueError(f\"invalid pattern {self.pattern!r} passed to Regex\")\n\n        self.errmsg = f\"Expected {self.name}\"\n        self.mayIndexError = False\n        self.mayReturnEmpty = True\n\n    def _generateDefaultName(self) -> str:\n        if self.quote_char == self.end_quote_char and isinstance(\n            self.quote_char, str_type\n        ):\n            return f\"string enclosed in {self.quote_char!r}\"\n\n        return f\"quoted string, starting with {self.quote_char} ending with {self.end_quote_char}\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        # check first character of opening quote to see if that is a match\n        # before doing the more complicated regex match\n        result = (\n            instring[loc] == self.first_quote_char\n            and self.re_match(instring, loc)\n            or None\n        )\n        if not result:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        # get ending loc and matched string from regex matching result\n        loc = result.end()\n        ret = result.group()\n\n        if self.unquote_results:\n            # strip off quotes\n            ret = ret[self.quote_char_len : -self.end_quote_char_len]\n\n            if isinstance(ret, str_type):\n                # fmt: off\n                if self.convert_whitespace_escapes:\n                    # as we iterate over matches in the input string,\n                    # collect from whichever match group of the unquote_scan_re\n                    # regex matches (only 1 group will match at any given time)\n                    ret = \"\".join(\n                        # match group 1 matches \\t, \\n, etc.\n                        self.ws_map[match.group(1)] if match.group(1)\n                        # match group 2 matches escaped characters\n                        else match.group(2)[-1] if match.group(2)\n                        # match group 3 matches any character\n                        else match.group(3)\n                        for match in self.unquote_scan_re.finditer(ret)\n                    )\n                else:\n                    ret = \"\".join(\n                        # match group 1 matches escaped characters\n                        match.group(1)[-1] if match.group(1)\n                        # match group 2 matches any character\n                        else match.group(2)\n                        for match in self.unquote_scan_re.finditer(ret)\n                    )\n                # fmt: on\n\n                # replace escaped quotes\n                if self.esc_quote:\n                    ret = ret.replace(self.esc_quote, self.end_quote_char)\n\n        return loc, ret\n\n\nclass CharsNotIn(Token):\n    \"\"\"Token for matching words composed of characters *not* in a given\n    set (will include whitespace in matched characters if not listed in\n    the provided exclusion set - see example). Defined with string\n    containing all disallowed characters, and an optional minimum,\n    maximum, and/or exact length.  The default value for ``min`` is\n    1 (a minimum value < 1 is not valid); the default values for\n    ``max`` and ``exact`` are 0, meaning no maximum or exact\n    length restriction.\n\n    Example::\n\n        # define a comma-separated-value as anything that is not a ','\n        csv_value = CharsNotIn(',')\n        print(DelimitedList(csv_value).parse_string(\"dkls,lsdkjf,s12 34,@!#,213\"))\n\n    prints::\n\n        ['dkls', 'lsdkjf', 's12 34', '@!#', '213']\n    \"\"\"\n\n    def __init__(\n        self,\n        not_chars: str = \"\",\n        min: int = 1,\n        max: int = 0,\n        exact: int = 0,\n        *,\n        notChars: str = \"\",\n    ):\n        super().__init__()\n        self.skipWhitespace = False\n        self.notChars = not_chars or notChars\n        self.notCharsSet = set(self.notChars)\n\n        if min < 1:\n            raise ValueError(\n                \"cannot specify a minimum length < 1; use\"\n                \" Opt(CharsNotIn()) if zero-length char group is permitted\"\n            )\n\n        self.minLen = min\n\n        if max > 0:\n            self.maxLen = max\n        else:\n            self.maxLen = _MAX_INT\n\n        if exact > 0:\n            self.maxLen = exact\n            self.minLen = exact\n\n        self.errmsg = f\"Expected {self.name}\"\n        self.mayReturnEmpty = self.minLen == 0\n        self.mayIndexError = False\n\n    def _generateDefaultName(self) -> str:\n        not_chars_str = _collapse_string_to_ranges(self.notChars)\n        if len(not_chars_str) > 16:\n            return f\"!W:({self.notChars[: 16 - 3]}...)\"\n        else:\n            return f\"!W:({self.notChars})\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        notchars = self.notCharsSet\n        if instring[loc] in notchars:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        start = loc\n        loc += 1\n        maxlen = min(start + self.maxLen, len(instring))\n        while loc < maxlen and instring[loc] not in notchars:\n            loc += 1\n\n        if loc - start < self.minLen:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        return loc, instring[start:loc]\n\n\nclass White(Token):\n    \"\"\"Special matching class for matching whitespace.  Normally,\n    whitespace is ignored by pyparsing grammars.  This class is included\n    when some whitespace structures are significant.  Define with\n    a string containing the whitespace characters to be matched; default\n    is ``\" \\\\t\\\\r\\\\n\"``.  Also takes optional ``min``,\n    ``max``, and ``exact`` arguments, as defined for the\n    :class:`Word` class.\n    \"\"\"\n\n    whiteStrs = {\n        \" \": \"<SP>\",\n        \"\\t\": \"<TAB>\",\n        \"\\n\": \"<LF>\",\n        \"\\r\": \"<CR>\",\n        \"\\f\": \"<FF>\",\n        \"\\u00A0\": \"<NBSP>\",\n        \"\\u1680\": \"<OGHAM_SPACE_MARK>\",\n        \"\\u180E\": \"<MONGOLIAN_VOWEL_SEPARATOR>\",\n        \"\\u2000\": \"<EN_QUAD>\",\n        \"\\u2001\": \"<EM_QUAD>\",\n        \"\\u2002\": \"<EN_SPACE>\",\n        \"\\u2003\": \"<EM_SPACE>\",\n        \"\\u2004\": \"<THREE-PER-EM_SPACE>\",\n        \"\\u2005\": \"<FOUR-PER-EM_SPACE>\",\n        \"\\u2006\": \"<SIX-PER-EM_SPACE>\",\n        \"\\u2007\": \"<FIGURE_SPACE>\",\n        \"\\u2008\": \"<PUNCTUATION_SPACE>\",\n        \"\\u2009\": \"<THIN_SPACE>\",\n        \"\\u200A\": \"<HAIR_SPACE>\",\n        \"\\u200B\": \"<ZERO_WIDTH_SPACE>\",\n        \"\\u202F\": \"<NNBSP>\",\n        \"\\u205F\": \"<MMSP>\",\n        \"\\u3000\": \"<IDEOGRAPHIC_SPACE>\",\n    }\n\n    def __init__(self, ws: str = \" \\t\\r\\n\", min: int = 1, max: int = 0, exact: int = 0):\n        super().__init__()\n        self.matchWhite = ws\n        self.set_whitespace_chars(\n            \"\".join(c for c in self.whiteStrs if c not in self.matchWhite),\n            copy_defaults=True,\n        )\n        # self.leave_whitespace()\n        self.mayReturnEmpty = True\n        self.errmsg = f\"Expected {self.name}\"\n\n        self.minLen = min\n\n        if max > 0:\n            self.maxLen = max\n        else:\n            self.maxLen = _MAX_INT\n\n        if exact > 0:\n            self.maxLen = exact\n            self.minLen = exact\n\n    def _generateDefaultName(self) -> str:\n        return \"\".join(White.whiteStrs[c] for c in self.matchWhite)\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if instring[loc] not in self.matchWhite:\n            raise ParseException(instring, loc, self.errmsg, self)\n        start = loc\n        loc += 1\n        maxloc = start + self.maxLen\n        maxloc = min(maxloc, len(instring))\n        while loc < maxloc and instring[loc] in self.matchWhite:\n            loc += 1\n\n        if loc - start < self.minLen:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        return loc, instring[start:loc]\n\n\nclass PositionToken(Token):\n    def __init__(self):\n        super().__init__()\n        self.mayReturnEmpty = True\n        self.mayIndexError = False\n\n\nclass GoToColumn(PositionToken):\n    \"\"\"Token to advance to a specific column of input text; useful for\n    tabular report scraping.\n    \"\"\"\n\n    def __init__(self, colno: int):\n        super().__init__()\n        self.col = colno\n\n    def preParse(self, instring: str, loc: int) -> int:\n        if col(loc, instring) == self.col:\n            return loc\n\n        instrlen = len(instring)\n        if self.ignoreExprs:\n            loc = self._skipIgnorables(instring, loc)\n        while (\n            loc < instrlen\n            and instring[loc].isspace()\n            and col(loc, instring) != self.col\n        ):\n            loc += 1\n\n        return loc\n\n    def parseImpl(self, instring, loc, doActions=True):\n        thiscol = col(loc, instring)\n        if thiscol > self.col:\n            raise ParseException(instring, loc, \"Text not in expected column\", self)\n        newloc = loc + self.col - thiscol\n        ret = instring[loc:newloc]\n        return newloc, ret\n\n\nclass LineStart(PositionToken):\n    r\"\"\"Matches if current position is at the beginning of a line within\n    the parse string\n\n    Example::\n\n        test = '''\\\n        AAA this line\n        AAA and this line\n          AAA but not this one\n        B AAA and definitely not this one\n        '''\n\n        for t in (LineStart() + 'AAA' + rest_of_line).search_string(test):\n            print(t)\n\n    prints::\n\n        ['AAA', ' this line']\n        ['AAA', ' and this line']\n\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.leave_whitespace()\n        self.orig_whiteChars = set() | self.whiteChars\n        self.whiteChars.discard(\"\\n\")\n        self.skipper = Empty().set_whitespace_chars(self.whiteChars)\n        self.errmsg = \"Expected start of line\"\n\n    def preParse(self, instring: str, loc: int) -> int:\n        if loc == 0:\n            return loc\n\n        ret = self.skipper.preParse(instring, loc)\n\n        if \"\\n\" in self.orig_whiteChars:\n            while instring[ret : ret + 1] == \"\\n\":\n                ret = self.skipper.preParse(instring, ret + 1)\n\n        return ret\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if col(loc, instring) == 1:\n            return loc, []\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass LineEnd(PositionToken):\n    \"\"\"Matches if current position is at the end of a line within the\n    parse string\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.whiteChars.discard(\"\\n\")\n        self.set_whitespace_chars(self.whiteChars, copy_defaults=False)\n        self.errmsg = \"Expected end of line\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if loc < len(instring):\n            if instring[loc] == \"\\n\":\n                return loc + 1, \"\\n\"\n            else:\n                raise ParseException(instring, loc, self.errmsg, self)\n        elif loc == len(instring):\n            return loc + 1, []\n        else:\n            raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass StringStart(PositionToken):\n    \"\"\"Matches if current position is at the beginning of the parse\n    string\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.errmsg = \"Expected start of text\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        # see if entire string up to here is just whitespace and ignoreables\n        if loc != 0 and loc != self.preParse(instring, 0):\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        return loc, []\n\n\nclass StringEnd(PositionToken):\n    \"\"\"\n    Matches if current position is at the end of the parse string\n    \"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self.errmsg = \"Expected end of text\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if loc < len(instring):\n            raise ParseException(instring, loc, self.errmsg, self)\n        if loc == len(instring):\n            return loc + 1, []\n        if loc > len(instring):\n            return loc, []\n\n        raise ParseException(instring, loc, self.errmsg, self)\n\n\nclass WordStart(PositionToken):\n    \"\"\"Matches if the current position is at the beginning of a\n    :class:`Word`, and is not preceded by any character in a given\n    set of ``word_chars`` (default= ``printables``). To emulate the\n    ``\\b`` behavior of regular expressions, use\n    ``WordStart(alphanums)``. ``WordStart`` will also match at\n    the beginning of the string being parsed, or at the beginning of\n    a line.\n    \"\"\"\n\n    def __init__(self, word_chars: str = printables, *, wordChars: str = printables):\n        wordChars = word_chars if wordChars == printables else wordChars\n        super().__init__()\n        self.wordChars = set(wordChars)\n        self.errmsg = \"Not at the start of a word\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if loc != 0:\n            if (\n                instring[loc - 1] in self.wordChars\n                or instring[loc] not in self.wordChars\n            ):\n                raise ParseException(instring, loc, self.errmsg, self)\n        return loc, []\n\n\nclass WordEnd(PositionToken):\n    \"\"\"Matches if the current position is at the end of a :class:`Word`,\n    and is not followed by any character in a given set of ``word_chars``\n    (default= ``printables``). To emulate the ``\\b`` behavior of\n    regular expressions, use ``WordEnd(alphanums)``. ``WordEnd``\n    will also match at the end of the string being parsed, or at the end\n    of a line.\n    \"\"\"\n\n    def __init__(self, word_chars: str = printables, *, wordChars: str = printables):\n        wordChars = word_chars if wordChars == printables else wordChars\n        super().__init__()\n        self.wordChars = set(wordChars)\n        self.skipWhitespace = False\n        self.errmsg = \"Not at the end of a word\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        instrlen = len(instring)\n        if instrlen > 0 and loc < instrlen:\n            if (\n                instring[loc] in self.wordChars\n                or instring[loc - 1] not in self.wordChars\n            ):\n                raise ParseException(instring, loc, self.errmsg, self)\n        return loc, []\n\n\nclass ParseExpression(ParserElement):\n    \"\"\"Abstract subclass of ParserElement, for combining and\n    post-processing parsed tokens.\n    \"\"\"\n\n    def __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):\n        super().__init__(savelist)\n        self.exprs: List[ParserElement]\n        if isinstance(exprs, _generatorType):\n            exprs = list(exprs)\n\n        if isinstance(exprs, str_type):\n            self.exprs = [self._literalStringClass(exprs)]\n        elif isinstance(exprs, ParserElement):\n            self.exprs = [exprs]\n        elif isinstance(exprs, Iterable):\n            exprs = list(exprs)\n            # if sequence of strings provided, wrap with Literal\n            if any(isinstance(expr, str_type) for expr in exprs):\n                exprs = (\n                    self._literalStringClass(e) if isinstance(e, str_type) else e\n                    for e in exprs\n                )\n            self.exprs = list(exprs)\n        else:\n            try:\n                self.exprs = list(exprs)\n            except TypeError:\n                self.exprs = [exprs]\n        self.callPreparse = False\n\n    def recurse(self) -> List[ParserElement]:\n        return self.exprs[:]\n\n    def append(self, other) -> ParserElement:\n        self.exprs.append(other)\n        self._defaultName = None\n        return self\n\n    def leave_whitespace(self, recursive: bool = True) -> ParserElement:\n        \"\"\"\n        Extends ``leave_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on\n           all contained expressions.\n        \"\"\"\n        super().leave_whitespace(recursive)\n\n        if recursive:\n            self.exprs = [e.copy() for e in self.exprs]\n            for e in self.exprs:\n                e.leave_whitespace(recursive)\n        return self\n\n    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:\n        \"\"\"\n        Extends ``ignore_whitespace`` defined in base class, and also invokes ``leave_whitespace`` on\n           all contained expressions.\n        \"\"\"\n        super().ignore_whitespace(recursive)\n        if recursive:\n            self.exprs = [e.copy() for e in self.exprs]\n            for e in self.exprs:\n                e.ignore_whitespace(recursive)\n        return self\n\n    def ignore(self, other) -> ParserElement:\n        if isinstance(other, Suppress):\n            if other not in self.ignoreExprs:\n                super().ignore(other)\n                for e in self.exprs:\n                    e.ignore(self.ignoreExprs[-1])\n        else:\n            super().ignore(other)\n            for e in self.exprs:\n                e.ignore(self.ignoreExprs[-1])\n        return self\n\n    def _generateDefaultName(self) -> str:\n        return f\"{type(self).__name__}:({self.exprs})\"\n\n    def streamline(self) -> ParserElement:\n        if self.streamlined:\n            return self\n\n        super().streamline()\n\n        for e in self.exprs:\n            e.streamline()\n\n        # collapse nested :class:`And`'s of the form ``And(And(And(a, b), c), d)`` to ``And(a, b, c, d)``\n        # but only if there are no parse actions or resultsNames on the nested And's\n        # (likewise for :class:`Or`'s and :class:`MatchFirst`'s)\n        if len(self.exprs) == 2:\n            other = self.exprs[0]\n            if (\n                isinstance(other, self.__class__)\n                and not other.parseAction\n                and other.resultsName is None\n                and not other.debug\n            ):\n                self.exprs = other.exprs[:] + [self.exprs[1]]\n                self._defaultName = None\n                self.mayReturnEmpty |= other.mayReturnEmpty\n                self.mayIndexError |= other.mayIndexError\n\n            other = self.exprs[-1]\n            if (\n                isinstance(other, self.__class__)\n                and not other.parseAction\n                and other.resultsName is None\n                and not other.debug\n            ):\n                self.exprs = self.exprs[:-1] + other.exprs[:]\n                self._defaultName = None\n                self.mayReturnEmpty |= other.mayReturnEmpty\n                self.mayIndexError |= other.mayIndexError\n\n        self.errmsg = f\"Expected {self}\"\n\n        return self\n\n    def validate(self, validateTrace=None) -> None:\n        warnings.warn(\n            \"ParserElement.validate() is deprecated, and should not be used to check for left recursion\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        tmp = (validateTrace if validateTrace is not None else [])[:] + [self]\n        for e in self.exprs:\n            e.validate(tmp)\n        self._checkRecursion([])\n\n    def copy(self) -> ParserElement:\n        ret = super().copy()\n        ret = typing.cast(ParseExpression, ret)\n        ret.exprs = [e.copy() for e in self.exprs]\n        return ret\n\n    def _setResultsName(self, name, listAllMatches=False):\n        if not (\n            __diag__.warn_ungrouped_named_tokens_in_collection\n            and Diagnostics.warn_ungrouped_named_tokens_in_collection\n            not in self.suppress_warnings_\n        ):\n            return super()._setResultsName(name, listAllMatches)\n\n        for e in self.exprs:\n            if (\n                isinstance(e, ParserElement)\n                and e.resultsName\n                and (\n                    Diagnostics.warn_ungrouped_named_tokens_in_collection\n                    not in e.suppress_warnings_\n                )\n            ):\n                warning = (\n                    \"warn_ungrouped_named_tokens_in_collection:\"\n                    f\" setting results name {name!r} on {type(self).__name__} expression\"\n                    f\" collides with {e.resultsName!r} on contained expression\"\n                )\n                warnings.warn(warning, stacklevel=3)\n                break\n\n        return super()._setResultsName(name, listAllMatches)\n\n    # Compatibility synonyms\n    # fmt: off\n    leaveWhitespace = replaced_by_pep8(\"leaveWhitespace\", leave_whitespace)\n    ignoreWhitespace = replaced_by_pep8(\"ignoreWhitespace\", ignore_whitespace)\n    # fmt: on\n\n\nclass And(ParseExpression):\n    \"\"\"\n    Requires all given :class:`ParseExpression` s to be found in the given order.\n    Expressions may be separated by whitespace.\n    May be constructed using the ``'+'`` operator.\n    May also be constructed using the ``'-'`` operator, which will\n    suppress backtracking.\n\n    Example::\n\n        integer = Word(nums)\n        name_expr = Word(alphas)[1, ...]\n\n        expr = And([integer(\"id\"), name_expr(\"name\"), integer(\"age\")])\n        # more easily written as:\n        expr = integer(\"id\") + name_expr(\"name\") + integer(\"age\")\n    \"\"\"\n\n    class _ErrorStop(Empty):\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            self.leave_whitespace()\n\n        def _generateDefaultName(self) -> str:\n            return \"-\"\n\n    def __init__(\n        self, exprs_arg: typing.Iterable[ParserElement], savelist: bool = True\n    ):\n        exprs: List[ParserElement] = list(exprs_arg)\n        if exprs and Ellipsis in exprs:\n            tmp = []\n            for i, expr in enumerate(exprs):\n                if expr is not Ellipsis:\n                    tmp.append(expr)\n                    continue\n\n                if i < len(exprs) - 1:\n                    skipto_arg: ParserElement = typing.cast(\n                        ParseExpression, (Empty() + exprs[i + 1])\n                    ).exprs[-1]\n                    tmp.append(SkipTo(skipto_arg)(\"_skipped*\"))\n                    continue\n\n                raise Exception(\"cannot construct And with sequence ending in ...\")\n            exprs[:] = tmp\n        super().__init__(exprs, savelist)\n        if self.exprs:\n            self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)\n            if not isinstance(self.exprs[0], White):\n                self.set_whitespace_chars(\n                    self.exprs[0].whiteChars,\n                    copy_defaults=self.exprs[0].copyDefaultWhiteChars,\n                )\n                self.skipWhitespace = self.exprs[0].skipWhitespace\n            else:\n                self.skipWhitespace = False\n        else:\n            self.mayReturnEmpty = True\n        self.callPreparse = True\n\n    def streamline(self) -> ParserElement:\n        # collapse any _PendingSkip's\n        if self.exprs and any(\n            isinstance(e, ParseExpression)\n            and e.exprs\n            and isinstance(e.exprs[-1], _PendingSkip)\n            for e in self.exprs[:-1]\n        ):\n            deleted_expr_marker = NoMatch()\n            for i, e in enumerate(self.exprs[:-1]):\n                if e is deleted_expr_marker:\n                    continue\n                if (\n                    isinstance(e, ParseExpression)\n                    and e.exprs\n                    and isinstance(e.exprs[-1], _PendingSkip)\n                ):\n                    e.exprs[-1] = e.exprs[-1] + self.exprs[i + 1]\n                    self.exprs[i + 1] = deleted_expr_marker\n            self.exprs = [e for e in self.exprs if e is not deleted_expr_marker]\n\n        super().streamline()\n\n        # link any IndentedBlocks to the prior expression\n        prev: ParserElement\n        cur: ParserElement\n        for prev, cur in zip(self.exprs, self.exprs[1:]):\n            # traverse cur or any first embedded expr of cur looking for an IndentedBlock\n            # (but watch out for recursive grammar)\n            seen = set()\n            while True:\n                if id(cur) in seen:\n                    break\n                seen.add(id(cur))\n                if isinstance(cur, IndentedBlock):\n                    prev.add_parse_action(\n                        lambda s, l, t, cur_=cur: setattr(\n                            cur_, \"parent_anchor\", col(l, s)\n                        )\n                    )\n                    break\n                subs = cur.recurse()\n                next_first = next(iter(subs), None)\n                if next_first is None:\n                    break\n                cur = typing.cast(ParserElement, next_first)\n\n        self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)\n        return self\n\n    def parseImpl(self, instring, loc, doActions=True):\n        # pass False as callPreParse arg to _parse for first element, since we already\n        # pre-parsed the string as part of our And pre-parsing\n        loc, resultlist = self.exprs[0]._parse(\n            instring, loc, doActions, callPreParse=False\n        )\n        errorStop = False\n        for e in self.exprs[1:]:\n            # if isinstance(e, And._ErrorStop):\n            if type(e) is And._ErrorStop:\n                errorStop = True\n                continue\n            if errorStop:\n                try:\n                    loc, exprtokens = e._parse(instring, loc, doActions)\n                except ParseSyntaxException:\n                    raise\n                except ParseBaseException as pe:\n                    pe.__traceback__ = None\n                    raise ParseSyntaxException._from_exception(pe)\n                except IndexError:\n                    raise ParseSyntaxException(\n                        instring, len(instring), self.errmsg, self\n                    )\n            else:\n                loc, exprtokens = e._parse(instring, loc, doActions)\n            resultlist += exprtokens\n        return loc, resultlist\n\n    def __iadd__(self, other):\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return self.append(other)  # And([self, other])\n\n    def _checkRecursion(self, parseElementList):\n        subRecCheckList = parseElementList[:] + [self]\n        for e in self.exprs:\n            e._checkRecursion(subRecCheckList)\n            if not e.mayReturnEmpty:\n                break\n\n    def _generateDefaultName(self) -> str:\n        inner = \" \".join(str(e) for e in self.exprs)\n        # strip off redundant inner {}'s\n        while len(inner) > 1 and inner[0 :: len(inner) - 1] == \"{}\":\n            inner = inner[1:-1]\n        return f\"{{{inner}}}\"\n\n\nclass Or(ParseExpression):\n    \"\"\"Requires that at least one :class:`ParseExpression` is found. If\n    two expressions match, the expression that matches the longest\n    string will be used. May be constructed using the ``'^'``\n    operator.\n\n    Example::\n\n        # construct Or using '^' operator\n\n        number = Word(nums) ^ Combine(Word(nums) + '.' + Word(nums))\n        print(number.search_string(\"123 3.1416 789\"))\n\n    prints::\n\n        [['123'], ['3.1416'], ['789']]\n    \"\"\"\n\n    def __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):\n        super().__init__(exprs, savelist)\n        if self.exprs:\n            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)\n            self.skipWhitespace = all(e.skipWhitespace for e in self.exprs)\n        else:\n            self.mayReturnEmpty = True\n\n    def streamline(self) -> ParserElement:\n        super().streamline()\n        if self.exprs:\n            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)\n            self.saveAsList = any(e.saveAsList for e in self.exprs)\n            self.skipWhitespace = all(\n                e.skipWhitespace and not isinstance(e, White) for e in self.exprs\n            )\n        else:\n            self.saveAsList = False\n        return self\n\n    def parseImpl(self, instring, loc, doActions=True):\n        maxExcLoc = -1\n        maxException = None\n        matches = []\n        fatals = []\n        if all(e.callPreparse for e in self.exprs):\n            loc = self.preParse(instring, loc)\n        for e in self.exprs:\n            try:\n                loc2 = e.try_parse(instring, loc, raise_fatal=True)\n            except ParseFatalException as pfe:\n                pfe.__traceback__ = None\n                pfe.parser_element = e\n                fatals.append(pfe)\n                maxException = None\n                maxExcLoc = -1\n            except ParseException as err:\n                if not fatals:\n                    err.__traceback__ = None\n                    if err.loc > maxExcLoc:\n                        maxException = err\n                        maxExcLoc = err.loc\n            except IndexError:\n                if len(instring) > maxExcLoc:\n                    maxException = ParseException(\n                        instring, len(instring), e.errmsg, self\n                    )\n                    maxExcLoc = len(instring)\n            else:\n                # save match among all matches, to retry longest to shortest\n                matches.append((loc2, e))\n\n        if matches:\n            # re-evaluate all matches in descending order of length of match, in case attached actions\n            # might change whether or how much they match of the input.\n            matches.sort(key=itemgetter(0), reverse=True)\n\n            if not doActions:\n                # no further conditions or parse actions to change the selection of\n                # alternative, so the first match will be the best match\n                best_expr = matches[0][1]\n                return best_expr._parse(instring, loc, doActions)\n\n            longest = -1, None\n            for loc1, expr1 in matches:\n                if loc1 <= longest[0]:\n                    # already have a longer match than this one will deliver, we are done\n                    return longest\n\n                try:\n                    loc2, toks = expr1._parse(instring, loc, doActions)\n                except ParseException as err:\n                    err.__traceback__ = None\n                    if err.loc > maxExcLoc:\n                        maxException = err\n                        maxExcLoc = err.loc\n                else:\n                    if loc2 >= loc1:\n                        return loc2, toks\n                    # didn't match as much as before\n                    elif loc2 > longest[0]:\n                        longest = loc2, toks\n\n            if longest != (-1, None):\n                return longest\n\n        if fatals:\n            if len(fatals) > 1:\n                fatals.sort(key=lambda e: -e.loc)\n                if fatals[0].loc == fatals[1].loc:\n                    fatals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))\n            max_fatal = fatals[0]\n            raise max_fatal\n\n        if maxException is not None:\n            # infer from this check that all alternatives failed at the current position\n            # so emit this collective error message instead of any single error message\n            if maxExcLoc == loc:\n                maxException.msg = self.errmsg\n            raise maxException\n\n        raise ParseException(instring, loc, \"no defined alternatives to match\", self)\n\n    def __ixor__(self, other):\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return self.append(other)  # Or([self, other])\n\n    def _generateDefaultName(self) -> str:\n        return f\"{{{' ^ '.join(str(e) for e in self.exprs)}}}\"\n\n    def _setResultsName(self, name, listAllMatches=False):\n        if (\n            __diag__.warn_multiple_tokens_in_named_alternation\n            and Diagnostics.warn_multiple_tokens_in_named_alternation\n            not in self.suppress_warnings_\n        ):\n            if any(\n                isinstance(e, And)\n                and Diagnostics.warn_multiple_tokens_in_named_alternation\n                not in e.suppress_warnings_\n                for e in self.exprs\n            ):\n                warning = (\n                    \"warn_multiple_tokens_in_named_alternation:\"\n                    f\" setting results name {name!r} on {type(self).__name__} expression\"\n                    \" will return a list of all parsed tokens in an And alternative,\"\n                    \" in prior versions only the first token was returned; enclose\"\n                    \" contained argument in Group\"\n                )\n                warnings.warn(warning, stacklevel=3)\n\n        return super()._setResultsName(name, listAllMatches)\n\n\nclass MatchFirst(ParseExpression):\n    \"\"\"Requires that at least one :class:`ParseExpression` is found. If\n    more than one expression matches, the first one listed is the one that will\n    match. May be constructed using the ``'|'`` operator.\n\n    Example::\n\n        # construct MatchFirst using '|' operator\n\n        # watch the order of expressions to match\n        number = Word(nums) | Combine(Word(nums) + '.' + Word(nums))\n        print(number.search_string(\"123 3.1416 789\")) #  Fail! -> [['123'], ['3'], ['1416'], ['789']]\n\n        # put more selective expression first\n        number = Combine(Word(nums) + '.' + Word(nums)) | Word(nums)\n        print(number.search_string(\"123 3.1416 789\")) #  Better -> [['123'], ['3.1416'], ['789']]\n    \"\"\"\n\n    def __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = False):\n        super().__init__(exprs, savelist)\n        if self.exprs:\n            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)\n            self.skipWhitespace = all(e.skipWhitespace for e in self.exprs)\n        else:\n            self.mayReturnEmpty = True\n\n    def streamline(self) -> ParserElement:\n        if self.streamlined:\n            return self\n\n        super().streamline()\n        if self.exprs:\n            self.saveAsList = any(e.saveAsList for e in self.exprs)\n            self.mayReturnEmpty = any(e.mayReturnEmpty for e in self.exprs)\n            self.skipWhitespace = all(\n                e.skipWhitespace and not isinstance(e, White) for e in self.exprs\n            )\n        else:\n            self.saveAsList = False\n            self.mayReturnEmpty = True\n        return self\n\n    def parseImpl(self, instring, loc, doActions=True):\n        maxExcLoc = -1\n        maxException = None\n\n        for e in self.exprs:\n            try:\n                return e._parse(instring, loc, doActions)\n            except ParseFatalException as pfe:\n                pfe.__traceback__ = None\n                pfe.parser_element = e\n                raise\n            except ParseException as err:\n                if err.loc > maxExcLoc:\n                    maxException = err\n                    maxExcLoc = err.loc\n            except IndexError:\n                if len(instring) > maxExcLoc:\n                    maxException = ParseException(\n                        instring, len(instring), e.errmsg, self\n                    )\n                    maxExcLoc = len(instring)\n\n        if maxException is not None:\n            # infer from this check that all alternatives failed at the current position\n            # so emit this collective error message instead of any individual error message\n            if maxExcLoc == loc:\n                maxException.msg = self.errmsg\n            raise maxException\n\n        raise ParseException(instring, loc, \"no defined alternatives to match\", self)\n\n    def __ior__(self, other):\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return self.append(other)  # MatchFirst([self, other])\n\n    def _generateDefaultName(self) -> str:\n        return f\"{{{' | '.join(str(e) for e in self.exprs)}}}\"\n\n    def _setResultsName(self, name, listAllMatches=False):\n        if (\n            __diag__.warn_multiple_tokens_in_named_alternation\n            and Diagnostics.warn_multiple_tokens_in_named_alternation\n            not in self.suppress_warnings_\n        ):\n            if any(\n                isinstance(e, And)\n                and Diagnostics.warn_multiple_tokens_in_named_alternation\n                not in e.suppress_warnings_\n                for e in self.exprs\n            ):\n                warning = (\n                    \"warn_multiple_tokens_in_named_alternation:\"\n                    f\" setting results name {name!r} on {type(self).__name__} expression\"\n                    \" will return a list of all parsed tokens in an And alternative,\"\n                    \" in prior versions only the first token was returned; enclose\"\n                    \" contained argument in Group\"\n                )\n                warnings.warn(warning, stacklevel=3)\n\n        return super()._setResultsName(name, listAllMatches)\n\n\nclass Each(ParseExpression):\n    \"\"\"Requires all given :class:`ParseExpression` s to be found, but in\n    any order. Expressions may be separated by whitespace.\n\n    May be constructed using the ``'&'`` operator.\n\n    Example::\n\n        color = one_of(\"RED ORANGE YELLOW GREEN BLUE PURPLE BLACK WHITE BROWN\")\n        shape_type = one_of(\"SQUARE CIRCLE TRIANGLE STAR HEXAGON OCTAGON\")\n        integer = Word(nums)\n        shape_attr = \"shape:\" + shape_type(\"shape\")\n        posn_attr = \"posn:\" + Group(integer(\"x\") + ',' + integer(\"y\"))(\"posn\")\n        color_attr = \"color:\" + color(\"color\")\n        size_attr = \"size:\" + integer(\"size\")\n\n        # use Each (using operator '&') to accept attributes in any order\n        # (shape and posn are required, color and size are optional)\n        shape_spec = shape_attr & posn_attr & Opt(color_attr) & Opt(size_attr)\n\n        shape_spec.run_tests('''\n            shape: SQUARE color: BLACK posn: 100, 120\n            shape: CIRCLE size: 50 color: BLUE posn: 50,80\n            color:GREEN size:20 shape:TRIANGLE posn:20,40\n            '''\n            )\n\n    prints::\n\n        shape: SQUARE color: BLACK posn: 100, 120\n        ['shape:', 'SQUARE', 'color:', 'BLACK', 'posn:', ['100', ',', '120']]\n        - color: BLACK\n        - posn: ['100', ',', '120']\n          - x: 100\n          - y: 120\n        - shape: SQUARE\n\n\n        shape: CIRCLE size: 50 color: BLUE posn: 50,80\n        ['shape:', 'CIRCLE', 'size:', '50', 'color:', 'BLUE', 'posn:', ['50', ',', '80']]\n        - color: BLUE\n        - posn: ['50', ',', '80']\n          - x: 50\n          - y: 80\n        - shape: CIRCLE\n        - size: 50\n\n\n        color: GREEN size: 20 shape: TRIANGLE posn: 20,40\n        ['color:', 'GREEN', 'size:', '20', 'shape:', 'TRIANGLE', 'posn:', ['20', ',', '40']]\n        - color: GREEN\n        - posn: ['20', ',', '40']\n          - x: 20\n          - y: 40\n        - shape: TRIANGLE\n        - size: 20\n    \"\"\"\n\n    def __init__(self, exprs: typing.Iterable[ParserElement], savelist: bool = True):\n        super().__init__(exprs, savelist)\n        if self.exprs:\n            self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)\n        else:\n            self.mayReturnEmpty = True\n        self.skipWhitespace = True\n        self.initExprGroups = True\n        self.saveAsList = True\n\n    def __iand__(self, other):\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n        return self.append(other)  # Each([self, other])\n\n    def streamline(self) -> ParserElement:\n        super().streamline()\n        if self.exprs:\n            self.mayReturnEmpty = all(e.mayReturnEmpty for e in self.exprs)\n        else:\n            self.mayReturnEmpty = True\n        return self\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if self.initExprGroups:\n            self.opt1map = dict(\n                (id(e.expr), e) for e in self.exprs if isinstance(e, Opt)\n            )\n            opt1 = [e.expr for e in self.exprs if isinstance(e, Opt)]\n            opt2 = [\n                e\n                for e in self.exprs\n                if e.mayReturnEmpty and not isinstance(e, (Opt, Regex, ZeroOrMore))\n            ]\n            self.optionals = opt1 + opt2\n            self.multioptionals = [\n                e.expr.set_results_name(e.resultsName, list_all_matches=True)\n                for e in self.exprs\n                if isinstance(e, _MultipleMatch)\n            ]\n            self.multirequired = [\n                e.expr.set_results_name(e.resultsName, list_all_matches=True)\n                for e in self.exprs\n                if isinstance(e, OneOrMore)\n            ]\n            self.required = [\n                e for e in self.exprs if not isinstance(e, (Opt, ZeroOrMore, OneOrMore))\n            ]\n            self.required += self.multirequired\n            self.initExprGroups = False\n\n        tmpLoc = loc\n        tmpReqd = self.required[:]\n        tmpOpt = self.optionals[:]\n        multis = self.multioptionals[:]\n        matchOrder = []\n\n        keepMatching = True\n        failed = []\n        fatals = []\n        while keepMatching:\n            tmpExprs = tmpReqd + tmpOpt + multis\n            failed.clear()\n            fatals.clear()\n            for e in tmpExprs:\n                try:\n                    tmpLoc = e.try_parse(instring, tmpLoc, raise_fatal=True)\n                except ParseFatalException as pfe:\n                    pfe.__traceback__ = None\n                    pfe.parser_element = e\n                    fatals.append(pfe)\n                    failed.append(e)\n                except ParseException:\n                    failed.append(e)\n                else:\n                    matchOrder.append(self.opt1map.get(id(e), e))\n                    if e in tmpReqd:\n                        tmpReqd.remove(e)\n                    elif e in tmpOpt:\n                        tmpOpt.remove(e)\n            if len(failed) == len(tmpExprs):\n                keepMatching = False\n\n        # look for any ParseFatalExceptions\n        if fatals:\n            if len(fatals) > 1:\n                fatals.sort(key=lambda e: -e.loc)\n                if fatals[0].loc == fatals[1].loc:\n                    fatals.sort(key=lambda e: (-e.loc, -len(str(e.parser_element))))\n            max_fatal = fatals[0]\n            raise max_fatal\n\n        if tmpReqd:\n            missing = \", \".join([str(e) for e in tmpReqd])\n            raise ParseException(\n                instring,\n                loc,\n                f\"Missing one or more required elements ({missing})\",\n            )\n\n        # add any unmatched Opts, in case they have default values defined\n        matchOrder += [e for e in self.exprs if isinstance(e, Opt) and e.expr in tmpOpt]\n\n        total_results = ParseResults([])\n        for e in matchOrder:\n            loc, results = e._parse(instring, loc, doActions)\n            total_results += results\n\n        return loc, total_results\n\n    def _generateDefaultName(self) -> str:\n        return f\"{{{' & '.join(str(e) for e in self.exprs)}}}\"\n\n\nclass ParseElementEnhance(ParserElement):\n    \"\"\"Abstract subclass of :class:`ParserElement`, for combining and\n    post-processing parsed tokens.\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str], savelist: bool = False):\n        super().__init__(savelist)\n        if isinstance(expr, str_type):\n            expr_str = typing.cast(str, expr)\n            if issubclass(self._literalStringClass, Token):\n                expr = self._literalStringClass(expr_str)  # type: ignore[call-arg]\n            elif issubclass(type(self), self._literalStringClass):\n                expr = Literal(expr_str)\n            else:\n                expr = self._literalStringClass(Literal(expr_str))  # type: ignore[assignment, call-arg]\n        expr = typing.cast(ParserElement, expr)\n        self.expr = expr\n        if expr is not None:\n            self.mayIndexError = expr.mayIndexError\n            self.mayReturnEmpty = expr.mayReturnEmpty\n            self.set_whitespace_chars(\n                expr.whiteChars, copy_defaults=expr.copyDefaultWhiteChars\n            )\n            self.skipWhitespace = expr.skipWhitespace\n            self.saveAsList = expr.saveAsList\n            self.callPreparse = expr.callPreparse\n            self.ignoreExprs.extend(expr.ignoreExprs)\n\n    def recurse(self) -> List[ParserElement]:\n        return [self.expr] if self.expr is not None else []\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if self.expr is None:\n            raise ParseException(instring, loc, \"No expression defined\", self)\n\n        try:\n            return self.expr._parse(instring, loc, doActions, callPreParse=False)\n        except ParseBaseException as pbe:\n            if not isinstance(self, Forward) or self.customName is not None:\n                if self.errmsg:\n                    pbe.msg = self.errmsg\n            raise\n\n    def leave_whitespace(self, recursive: bool = True) -> ParserElement:\n        super().leave_whitespace(recursive)\n\n        if recursive:\n            if self.expr is not None:\n                self.expr = self.expr.copy()\n                self.expr.leave_whitespace(recursive)\n        return self\n\n    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:\n        super().ignore_whitespace(recursive)\n\n        if recursive:\n            if self.expr is not None:\n                self.expr = self.expr.copy()\n                self.expr.ignore_whitespace(recursive)\n        return self\n\n    def ignore(self, other) -> ParserElement:\n        if not isinstance(other, Suppress) or other not in self.ignoreExprs:\n            super().ignore(other)\n            if self.expr is not None:\n                self.expr.ignore(self.ignoreExprs[-1])\n\n        return self\n\n    def streamline(self) -> ParserElement:\n        super().streamline()\n        if self.expr is not None:\n            self.expr.streamline()\n        return self\n\n    def _checkRecursion(self, parseElementList):\n        if self in parseElementList:\n            raise RecursiveGrammarException(parseElementList + [self])\n        subRecCheckList = parseElementList[:] + [self]\n        if self.expr is not None:\n            self.expr._checkRecursion(subRecCheckList)\n\n    def validate(self, validateTrace=None) -> None:\n        warnings.warn(\n            \"ParserElement.validate() is deprecated, and should not be used to check for left recursion\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        if validateTrace is None:\n            validateTrace = []\n        tmp = validateTrace[:] + [self]\n        if self.expr is not None:\n            self.expr.validate(tmp)\n        self._checkRecursion([])\n\n    def _generateDefaultName(self) -> str:\n        return f\"{type(self).__name__}:({self.expr})\"\n\n    # Compatibility synonyms\n    # fmt: off\n    leaveWhitespace = replaced_by_pep8(\"leaveWhitespace\", leave_whitespace)\n    ignoreWhitespace = replaced_by_pep8(\"ignoreWhitespace\", ignore_whitespace)\n    # fmt: on\n\n\nclass IndentedBlock(ParseElementEnhance):\n    \"\"\"\n    Expression to match one or more expressions at a given indentation level.\n    Useful for parsing text where structure is implied by indentation (like Python source code).\n    \"\"\"\n\n    class _Indent(Empty):\n        def __init__(self, ref_col: int):\n            super().__init__()\n            self.errmsg = f\"expected indent at column {ref_col}\"\n            self.add_condition(lambda s, l, t: col(l, s) == ref_col)\n\n    class _IndentGreater(Empty):\n        def __init__(self, ref_col: int):\n            super().__init__()\n            self.errmsg = f\"expected indent at column greater than {ref_col}\"\n            self.add_condition(lambda s, l, t: col(l, s) > ref_col)\n\n    def __init__(\n        self, expr: ParserElement, *, recursive: bool = False, grouped: bool = True\n    ):\n        super().__init__(expr, savelist=True)\n        # if recursive:\n        #     raise NotImplementedError(\"IndentedBlock with recursive is not implemented\")\n        self._recursive = recursive\n        self._grouped = grouped\n        self.parent_anchor = 1\n\n    def parseImpl(self, instring, loc, doActions=True):\n        # advance parse position to non-whitespace by using an Empty()\n        # this should be the column to be used for all subsequent indented lines\n        anchor_loc = Empty().preParse(instring, loc)\n\n        # see if self.expr matches at the current location - if not it will raise an exception\n        # and no further work is necessary\n        self.expr.try_parse(instring, anchor_loc, do_actions=doActions)\n\n        indent_col = col(anchor_loc, instring)\n        peer_detect_expr = self._Indent(indent_col)\n\n        inner_expr = Empty() + peer_detect_expr + self.expr\n        if self._recursive:\n            sub_indent = self._IndentGreater(indent_col)\n            nested_block = IndentedBlock(\n                self.expr, recursive=self._recursive, grouped=self._grouped\n            )\n            nested_block.set_debug(self.debug)\n            nested_block.parent_anchor = indent_col\n            inner_expr += Opt(sub_indent + nested_block)\n\n        inner_expr.set_name(f\"inner {hex(id(inner_expr))[-4:].upper()}@{indent_col}\")\n        block = OneOrMore(inner_expr)\n\n        trailing_undent = self._Indent(self.parent_anchor) | StringEnd()\n\n        if self._grouped:\n            wrapper = Group\n        else:\n            wrapper = lambda expr: expr\n        return (wrapper(block) + Optional(trailing_undent)).parseImpl(\n            instring, anchor_loc, doActions\n        )\n\n\nclass AtStringStart(ParseElementEnhance):\n    \"\"\"Matches if expression matches at the beginning of the parse\n    string::\n\n        AtStringStart(Word(nums)).parse_string(\"123\")\n        # prints [\"123\"]\n\n        AtStringStart(Word(nums)).parse_string(\"    123\")\n        # raises ParseException\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str]):\n        super().__init__(expr)\n        self.callPreparse = False\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if loc != 0:\n            raise ParseException(instring, loc, \"not found at string start\")\n        return super().parseImpl(instring, loc, doActions)\n\n\nclass AtLineStart(ParseElementEnhance):\n    r\"\"\"Matches if an expression matches at the beginning of a line within\n    the parse string\n\n    Example::\n\n        test = '''\\\n        AAA this line\n        AAA and this line\n          AAA but not this one\n        B AAA and definitely not this one\n        '''\n\n        for t in (AtLineStart('AAA') + rest_of_line).search_string(test):\n            print(t)\n\n    prints::\n\n        ['AAA', ' this line']\n        ['AAA', ' and this line']\n\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str]):\n        super().__init__(expr)\n        self.callPreparse = False\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if col(loc, instring) != 1:\n            raise ParseException(instring, loc, \"not found at line start\")\n        return super().parseImpl(instring, loc, doActions)\n\n\nclass FollowedBy(ParseElementEnhance):\n    \"\"\"Lookahead matching of the given parse expression.\n    ``FollowedBy`` does *not* advance the parsing position within\n    the input string, it only verifies that the specified parse\n    expression matches at the current position.  ``FollowedBy``\n    always returns a null token list. If any results names are defined\n    in the lookahead expression, those *will* be returned for access by\n    name.\n\n    Example::\n\n        # use FollowedBy to match a label only if it is followed by a ':'\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(':')\n        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))\n\n        attr_expr[1, ...].parse_string(\"shape: SQUARE color: BLACK posn: upper left\").pprint()\n\n    prints::\n\n        [['shape', 'SQUARE'], ['color', 'BLACK'], ['posn', 'upper left']]\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str]):\n        super().__init__(expr)\n        self.mayReturnEmpty = True\n\n    def parseImpl(self, instring, loc, doActions=True):\n        # by using self._expr.parse and deleting the contents of the returned ParseResults list\n        # we keep any named results that were defined in the FollowedBy expression\n        _, ret = self.expr._parse(instring, loc, doActions=doActions)\n        del ret[:]\n\n        return loc, ret\n\n\nclass PrecededBy(ParseElementEnhance):\n    \"\"\"Lookbehind matching of the given parse expression.\n    ``PrecededBy`` does not advance the parsing position within the\n    input string, it only verifies that the specified parse expression\n    matches prior to the current position.  ``PrecededBy`` always\n    returns a null token list, but if a results name is defined on the\n    given expression, it is returned.\n\n    Parameters:\n\n    - ``expr`` - expression that must match prior to the current parse\n      location\n    - ``retreat`` - (default= ``None``) - (int) maximum number of characters\n      to lookbehind prior to the current parse location\n\n    If the lookbehind expression is a string, :class:`Literal`,\n    :class:`Keyword`, or a :class:`Word` or :class:`CharsNotIn`\n    with a specified exact or maximum length, then the retreat\n    parameter is not required. Otherwise, retreat must be specified to\n    give a maximum number of characters to look back from\n    the current parse position for a lookbehind match.\n\n    Example::\n\n        # VB-style variable names with type prefixes\n        int_var = PrecededBy(\"#\") + pyparsing_common.identifier\n        str_var = PrecededBy(\"$\") + pyparsing_common.identifier\n\n    \"\"\"\n\n    def __init__(\n        self, expr: Union[ParserElement, str], retreat: typing.Optional[int] = None\n    ):\n        super().__init__(expr)\n        self.expr = self.expr().leave_whitespace()\n        self.mayReturnEmpty = True\n        self.mayIndexError = False\n        self.exact = False\n        if isinstance(expr, str_type):\n            expr = typing.cast(str, expr)\n            retreat = len(expr)\n            self.exact = True\n        elif isinstance(expr, (Literal, Keyword)):\n            retreat = expr.matchLen\n            self.exact = True\n        elif isinstance(expr, (Word, CharsNotIn)) and expr.maxLen != _MAX_INT:\n            retreat = expr.maxLen\n            self.exact = True\n        elif isinstance(expr, PositionToken):\n            retreat = 0\n            self.exact = True\n        self.retreat = retreat\n        self.errmsg = f\"not preceded by {expr}\"\n        self.skipWhitespace = False\n        self.parseAction.append(lambda s, l, t: t.__delitem__(slice(None, None)))\n\n    def parseImpl(self, instring, loc=0, doActions=True):\n        if self.exact:\n            if loc < self.retreat:\n                raise ParseException(instring, loc, self.errmsg)\n            start = loc - self.retreat\n            _, ret = self.expr._parse(instring, start)\n            return loc, ret\n\n        # retreat specified a maximum lookbehind window, iterate\n        test_expr = self.expr + StringEnd()\n        instring_slice = instring[max(0, loc - self.retreat) : loc]\n        last_expr = ParseException(instring, loc, self.errmsg)\n\n        for offset in range(1, min(loc, self.retreat + 1) + 1):\n            try:\n                # print('trying', offset, instring_slice, repr(instring_slice[loc - offset:]))\n                _, ret = test_expr._parse(instring_slice, len(instring_slice) - offset)\n            except ParseBaseException as pbe:\n                last_expr = pbe\n            else:\n                break\n        else:\n            raise last_expr\n\n        return loc, ret\n\n\nclass Located(ParseElementEnhance):\n    \"\"\"\n    Decorates a returned token with its starting and ending\n    locations in the input string.\n\n    This helper adds the following results names:\n\n    - ``locn_start`` - location where matched expression begins\n    - ``locn_end`` - location where matched expression ends\n    - ``value`` - the actual parsed results\n\n    Be careful if the input text contains ``<TAB>`` characters, you\n    may want to call :class:`ParserElement.parse_with_tabs`\n\n    Example::\n\n        wd = Word(alphas)\n        for match in Located(wd).search_string(\"ljsdf123lksdjjf123lkkjj1222\"):\n            print(match)\n\n    prints::\n\n        [0, ['ljsdf'], 5]\n        [8, ['lksdjjf'], 15]\n        [18, ['lkkjj'], 23]\n\n    \"\"\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        start = loc\n        loc, tokens = self.expr._parse(instring, start, doActions, callPreParse=False)\n        ret_tokens = ParseResults([start, tokens, loc])\n        ret_tokens[\"locn_start\"] = start\n        ret_tokens[\"value\"] = tokens\n        ret_tokens[\"locn_end\"] = loc\n        if self.resultsName:\n            # must return as a list, so that the name will be attached to the complete group\n            return loc, [ret_tokens]\n        else:\n            return loc, ret_tokens\n\n\nclass NotAny(ParseElementEnhance):\n    \"\"\"\n    Lookahead to disallow matching with the given parse expression.\n    ``NotAny`` does *not* advance the parsing position within the\n    input string, it only verifies that the specified parse expression\n    does *not* match at the current position.  Also, ``NotAny`` does\n    *not* skip over leading whitespace. ``NotAny`` always returns\n    a null token list.  May be constructed using the ``'~'`` operator.\n\n    Example::\n\n        AND, OR, NOT = map(CaselessKeyword, \"AND OR NOT\".split())\n\n        # take care not to mistake keywords for identifiers\n        ident = ~(AND | OR | NOT) + Word(alphas)\n        boolean_term = Opt(NOT) + ident\n\n        # very crude boolean expression - to support parenthesis groups and\n        # operation hierarchy, use infix_notation\n        boolean_expr = boolean_term + ((AND | OR) + boolean_term)[...]\n\n        # integers that are followed by \".\" are actually floats\n        integer = Word(nums) + ~Char(\".\")\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str]):\n        super().__init__(expr)\n        # do NOT use self.leave_whitespace(), don't want to propagate to exprs\n        # self.leave_whitespace()\n        self.skipWhitespace = False\n\n        self.mayReturnEmpty = True\n        self.errmsg = f\"Found unwanted token, {self.expr}\"\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if self.expr.can_parse_next(instring, loc, do_actions=doActions):\n            raise ParseException(instring, loc, self.errmsg, self)\n        return loc, []\n\n    def _generateDefaultName(self) -> str:\n        return f\"~{{{self.expr}}}\"\n\n\nclass _MultipleMatch(ParseElementEnhance):\n    def __init__(\n        self,\n        expr: Union[str, ParserElement],\n        stop_on: typing.Optional[Union[ParserElement, str]] = None,\n        *,\n        stopOn: typing.Optional[Union[ParserElement, str]] = None,\n    ):\n        super().__init__(expr)\n        stopOn = stopOn or stop_on\n        self.saveAsList = True\n        ender = stopOn\n        if isinstance(ender, str_type):\n            ender = self._literalStringClass(ender)\n        self.stopOn(ender)\n\n    def stopOn(self, ender) -> ParserElement:\n        if isinstance(ender, str_type):\n            ender = self._literalStringClass(ender)\n        self.not_ender = ~ender if ender is not None else None\n        return self\n\n    def parseImpl(self, instring, loc, doActions=True):\n        self_expr_parse = self.expr._parse\n        self_skip_ignorables = self._skipIgnorables\n        check_ender = self.not_ender is not None\n        if check_ender:\n            try_not_ender = self.not_ender.try_parse\n\n        # must be at least one (but first see if we are the stopOn sentinel;\n        # if so, fail)\n        if check_ender:\n            try_not_ender(instring, loc)\n        loc, tokens = self_expr_parse(instring, loc, doActions)\n        try:\n            hasIgnoreExprs = not not self.ignoreExprs\n            while 1:\n                if check_ender:\n                    try_not_ender(instring, loc)\n                if hasIgnoreExprs:\n                    preloc = self_skip_ignorables(instring, loc)\n                else:\n                    preloc = loc\n                loc, tmptokens = self_expr_parse(instring, preloc, doActions)\n                tokens += tmptokens\n        except (ParseException, IndexError):\n            pass\n\n        return loc, tokens\n\n    def _setResultsName(self, name, listAllMatches=False):\n        if (\n            __diag__.warn_ungrouped_named_tokens_in_collection\n            and Diagnostics.warn_ungrouped_named_tokens_in_collection\n            not in self.suppress_warnings_\n        ):\n            for e in [self.expr] + self.expr.recurse():\n                if (\n                    isinstance(e, ParserElement)\n                    and e.resultsName\n                    and (\n                        Diagnostics.warn_ungrouped_named_tokens_in_collection\n                        not in e.suppress_warnings_\n                    )\n                ):\n                    warning = (\n                        \"warn_ungrouped_named_tokens_in_collection:\"\n                        f\" setting results name {name!r} on {type(self).__name__} expression\"\n                        f\" collides with {e.resultsName!r} on contained expression\"\n                    )\n                    warnings.warn(warning, stacklevel=3)\n                    break\n\n        return super()._setResultsName(name, listAllMatches)\n\n\nclass OneOrMore(_MultipleMatch):\n    \"\"\"\n    Repetition of one or more of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match one or more times\n    - ``stop_on`` - (default= ``None``) - expression for a terminating sentinel\n      (only required if the sentinel would ordinarily match the repetition\n      expression)\n\n    Example::\n\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(':')\n        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word).set_parse_action(' '.join))\n\n        text = \"shape: SQUARE posn: upper left color: BLACK\"\n        attr_expr[1, ...].parse_string(text).pprint()  # Fail! read 'color' as data instead of next label -> [['shape', 'SQUARE color']]\n\n        # use stop_on attribute for OneOrMore to avoid reading label string as part of the data\n        attr_expr = Group(label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))\n        OneOrMore(attr_expr).parse_string(text).pprint() # Better -> [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'BLACK']]\n\n        # could also be written as\n        (attr_expr * (1,)).parse_string(text).pprint()\n    \"\"\"\n\n    def _generateDefaultName(self) -> str:\n        return f\"{{{self.expr}}}...\"\n\n\nclass ZeroOrMore(_MultipleMatch):\n    \"\"\"\n    Optional repetition of zero or more of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match zero or more times\n    - ``stop_on`` - expression for a terminating sentinel\n      (only required if the sentinel would ordinarily match the repetition\n      expression) - (default= ``None``)\n\n    Example: similar to :class:`OneOrMore`\n    \"\"\"\n\n    def __init__(\n        self,\n        expr: Union[str, ParserElement],\n        stop_on: typing.Optional[Union[ParserElement, str]] = None,\n        *,\n        stopOn: typing.Optional[Union[ParserElement, str]] = None,\n    ):\n        super().__init__(expr, stopOn=stopOn or stop_on)\n        self.mayReturnEmpty = True\n\n    def parseImpl(self, instring, loc, doActions=True):\n        try:\n            return super().parseImpl(instring, loc, doActions)\n        except (ParseException, IndexError):\n            return loc, ParseResults([], name=self.resultsName)\n\n    def _generateDefaultName(self) -> str:\n        return f\"[{self.expr}]...\"\n\n\nclass DelimitedList(ParseElementEnhance):\n    def __init__(\n        self,\n        expr: Union[str, ParserElement],\n        delim: Union[str, ParserElement] = \",\",\n        combine: bool = False,\n        min: typing.Optional[int] = None,\n        max: typing.Optional[int] = None,\n        *,\n        allow_trailing_delim: bool = False,\n    ):\n        \"\"\"Helper to define a delimited list of expressions - the delimiter\n        defaults to ','. By default, the list elements and delimiters can\n        have intervening whitespace, and comments, but this can be\n        overridden by passing ``combine=True`` in the constructor. If\n        ``combine`` is set to ``True``, the matching tokens are\n        returned as a single token string, with the delimiters included;\n        otherwise, the matching tokens are returned as a list of tokens,\n        with the delimiters suppressed.\n\n        If ``allow_trailing_delim`` is set to True, then the list may end with\n        a delimiter.\n\n        Example::\n\n            DelimitedList(Word(alphas)).parse_string(\"aa,bb,cc\") # -> ['aa', 'bb', 'cc']\n            DelimitedList(Word(hexnums), delim=':', combine=True).parse_string(\"AA:BB:CC:DD:EE\") # -> ['AA:BB:CC:DD:EE']\n        \"\"\"\n        if isinstance(expr, str_type):\n            expr = ParserElement._literalStringClass(expr)\n        expr = typing.cast(ParserElement, expr)\n\n        if min is not None and min < 1:\n            raise ValueError(\"min must be greater than 0\")\n\n        if max is not None and min is not None and max < min:\n            raise ValueError(\"max must be greater than, or equal to min\")\n\n        self.content = expr\n        self.raw_delim = str(delim)\n        self.delim = delim\n        self.combine = combine\n        if not combine:\n            self.delim = Suppress(delim)\n        self.min = min or 1\n        self.max = max\n        self.allow_trailing_delim = allow_trailing_delim\n\n        delim_list_expr = self.content + (self.delim + self.content) * (\n            self.min - 1,\n            None if self.max is None else self.max - 1,\n        )\n        if self.allow_trailing_delim:\n            delim_list_expr += Opt(self.delim)\n\n        if self.combine:\n            delim_list_expr = Combine(delim_list_expr)\n\n        super().__init__(delim_list_expr, savelist=True)\n\n    def _generateDefaultName(self) -> str:\n        content_expr = self.content.streamline()\n        return f\"{content_expr} [{self.raw_delim} {content_expr}]...\"\n\n\nclass _NullToken:\n    def __bool__(self):\n        return False\n\n    def __str__(self):\n        return \"\"\n\n\nclass Opt(ParseElementEnhance):\n    \"\"\"\n    Optional matching of the given expression.\n\n    Parameters:\n\n    - ``expr`` - expression that must match zero or more times\n    - ``default`` (optional) - value to be returned if the optional expression is not found.\n\n    Example::\n\n        # US postal code can be a 5-digit zip, plus optional 4-digit qualifier\n        zip = Combine(Word(nums, exact=5) + Opt('-' + Word(nums, exact=4)))\n        zip.run_tests('''\n            # traditional ZIP code\n            12345\n\n            # ZIP+4 form\n            12101-0001\n\n            # invalid ZIP\n            98765-\n            ''')\n\n    prints::\n\n        # traditional ZIP code\n        12345\n        ['12345']\n\n        # ZIP+4 form\n        12101-0001\n        ['12101-0001']\n\n        # invalid ZIP\n        98765-\n             ^\n        FAIL: Expected end of text (at char 5), (line:1, col:6)\n    \"\"\"\n\n    __optionalNotMatched = _NullToken()\n\n    def __init__(\n        self, expr: Union[ParserElement, str], default: Any = __optionalNotMatched\n    ):\n        super().__init__(expr, savelist=False)\n        self.saveAsList = self.expr.saveAsList\n        self.defaultValue = default\n        self.mayReturnEmpty = True\n\n    def parseImpl(self, instring, loc, doActions=True):\n        self_expr = self.expr\n        try:\n            loc, tokens = self_expr._parse(instring, loc, doActions, callPreParse=False)\n        except (ParseException, IndexError):\n            default_value = self.defaultValue\n            if default_value is not self.__optionalNotMatched:\n                if self_expr.resultsName:\n                    tokens = ParseResults([default_value])\n                    tokens[self_expr.resultsName] = default_value\n                else:\n                    tokens = [default_value]\n            else:\n                tokens = []\n        return loc, tokens\n\n    def _generateDefaultName(self) -> str:\n        inner = str(self.expr)\n        # strip off redundant inner {}'s\n        while len(inner) > 1 and inner[0 :: len(inner) - 1] == \"{}\":\n            inner = inner[1:-1]\n        return f\"[{inner}]\"\n\n\nOptional = Opt\n\n\nclass SkipTo(ParseElementEnhance):\n    \"\"\"\n    Token for skipping over all undefined text until the matched\n    expression is found.\n\n    Parameters:\n\n    - ``expr`` - target expression marking the end of the data to be skipped\n    - ``include`` - if ``True``, the target expression is also parsed\n      (the skipped text and target expression are returned as a 2-element\n      list) (default= ``False``).\n    - ``ignore`` - (default= ``None``) used to define grammars (typically quoted strings and\n      comments) that might contain false matches to the target expression\n    - ``fail_on`` - (default= ``None``) define expressions that are not allowed to be\n      included in the skipped test; if found before the target expression is found,\n      the :class:`SkipTo` is not a match\n\n    Example::\n\n        report = '''\n            Outstanding Issues Report - 1 Jan 2000\n\n               # | Severity | Description                               |  Days Open\n            -----+----------+-------------------------------------------+-----------\n             101 | Critical | Intermittent system crash                 |          6\n              94 | Cosmetic | Spelling error on Login ('log|n')         |         14\n              79 | Minor    | System slow when running too many reports |         47\n            '''\n        integer = Word(nums)\n        SEP = Suppress('|')\n        # use SkipTo to simply match everything up until the next SEP\n        # - ignore quoted strings, so that a '|' character inside a quoted string does not match\n        # - parse action will call token.strip() for each matched token, i.e., the description body\n        string_data = SkipTo(SEP, ignore=quoted_string)\n        string_data.set_parse_action(token_map(str.strip))\n        ticket_expr = (integer(\"issue_num\") + SEP\n                      + string_data(\"sev\") + SEP\n                      + string_data(\"desc\") + SEP\n                      + integer(\"days_open\"))\n\n        for tkt in ticket_expr.search_string(report):\n            print tkt.dump()\n\n    prints::\n\n        ['101', 'Critical', 'Intermittent system crash', '6']\n        - days_open: '6'\n        - desc: 'Intermittent system crash'\n        - issue_num: '101'\n        - sev: 'Critical'\n        ['94', 'Cosmetic', \"Spelling error on Login ('log|n')\", '14']\n        - days_open: '14'\n        - desc: \"Spelling error on Login ('log|n')\"\n        - issue_num: '94'\n        - sev: 'Cosmetic'\n        ['79', 'Minor', 'System slow when running too many reports', '47']\n        - days_open: '47'\n        - desc: 'System slow when running too many reports'\n        - issue_num: '79'\n        - sev: 'Minor'\n    \"\"\"\n\n    def __init__(\n        self,\n        other: Union[ParserElement, str],\n        include: bool = False,\n        ignore: typing.Optional[Union[ParserElement, str]] = None,\n        fail_on: typing.Optional[Union[ParserElement, str]] = None,\n        *,\n        failOn: typing.Optional[Union[ParserElement, str]] = None,\n    ):\n        super().__init__(other)\n        failOn = failOn or fail_on\n        self.ignoreExpr = ignore\n        self.mayReturnEmpty = True\n        self.mayIndexError = False\n        self.includeMatch = include\n        self.saveAsList = False\n        if isinstance(failOn, str_type):\n            self.failOn = self._literalStringClass(failOn)\n        else:\n            self.failOn = failOn\n        self.errmsg = \"No match found for \" + str(self.expr)\n        self.ignorer = Empty().leave_whitespace()\n        self._update_ignorer()\n\n    def _update_ignorer(self):\n        # rebuild internal ignore expr from current ignore exprs and assigned ignoreExpr\n        self.ignorer.ignoreExprs.clear()\n        for e in self.expr.ignoreExprs:\n            self.ignorer.ignore(e)\n        if self.ignoreExpr:\n            self.ignorer.ignore(self.ignoreExpr)\n\n    def ignore(self, expr):\n        super().ignore(expr)\n        self._update_ignorer()\n\n    def parseImpl(self, instring, loc, doActions=True):\n        startloc = loc\n        instrlen = len(instring)\n        self_expr_parse = self.expr._parse\n        self_failOn_canParseNext = (\n            self.failOn.canParseNext if self.failOn is not None else None\n        )\n        ignorer_try_parse = self.ignorer.try_parse if self.ignorer.ignoreExprs else None\n\n        tmploc = loc\n        while tmploc <= instrlen:\n            if self_failOn_canParseNext is not None:\n                # break if failOn expression matches\n                if self_failOn_canParseNext(instring, tmploc):\n                    break\n\n            if ignorer_try_parse is not None:\n                # advance past ignore expressions\n                prev_tmploc = tmploc\n                while 1:\n                    try:\n                        tmploc = ignorer_try_parse(instring, tmploc)\n                    except ParseBaseException:\n                        break\n                    # see if all ignorers matched, but didn't actually ignore anything\n                    if tmploc == prev_tmploc:\n                        break\n                    prev_tmploc = tmploc\n\n            try:\n                self_expr_parse(instring, tmploc, doActions=False, callPreParse=False)\n            except (ParseException, IndexError):\n                # no match, advance loc in string\n                tmploc += 1\n            else:\n                # matched skipto expr, done\n                break\n\n        else:\n            # ran off the end of the input string without matching skipto expr, fail\n            raise ParseException(instring, loc, self.errmsg, self)\n\n        # build up return values\n        loc = tmploc\n        skiptext = instring[startloc:loc]\n        skipresult = ParseResults(skiptext)\n\n        if self.includeMatch:\n            loc, mat = self_expr_parse(instring, loc, doActions, callPreParse=False)\n            skipresult += mat\n\n        return loc, skipresult\n\n\nclass Forward(ParseElementEnhance):\n    \"\"\"\n    Forward declaration of an expression to be defined later -\n    used for recursive grammars, such as algebraic infix notation.\n    When the expression is known, it is assigned to the ``Forward``\n    variable using the ``'<<'`` operator.\n\n    Note: take care when assigning to ``Forward`` not to overlook\n    precedence of operators.\n\n    Specifically, ``'|'`` has a lower precedence than ``'<<'``, so that::\n\n        fwd_expr << a | b | c\n\n    will actually be evaluated as::\n\n        (fwd_expr << a) | b | c\n\n    thereby leaving b and c out as parseable alternatives.  It is recommended that you\n    explicitly group the values inserted into the ``Forward``::\n\n        fwd_expr << (a | b | c)\n\n    Converting to use the ``'<<='`` operator instead will avoid this problem.\n\n    See :class:`ParseResults.pprint` for an example of a recursive\n    parser created using ``Forward``.\n    \"\"\"\n\n    def __init__(self, other: typing.Optional[Union[ParserElement, str]] = None):\n        self.caller_frame = traceback.extract_stack(limit=2)[0]\n        super().__init__(other, savelist=False)  # type: ignore[arg-type]\n        self.lshift_line = None\n\n    def __lshift__(self, other) -> \"Forward\":\n        if hasattr(self, \"caller_frame\"):\n            del self.caller_frame\n        if isinstance(other, str_type):\n            other = self._literalStringClass(other)\n\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n\n        self.expr = other\n        self.streamlined = other.streamlined\n        self.mayIndexError = self.expr.mayIndexError\n        self.mayReturnEmpty = self.expr.mayReturnEmpty\n        self.set_whitespace_chars(\n            self.expr.whiteChars, copy_defaults=self.expr.copyDefaultWhiteChars\n        )\n        self.skipWhitespace = self.expr.skipWhitespace\n        self.saveAsList = self.expr.saveAsList\n        self.ignoreExprs.extend(self.expr.ignoreExprs)\n        self.lshift_line = traceback.extract_stack(limit=2)[-2]  # type: ignore[assignment]\n        return self\n\n    def __ilshift__(self, other) -> \"Forward\":\n        if not isinstance(other, ParserElement):\n            return NotImplemented\n\n        return self << other\n\n    def __or__(self, other) -> \"ParserElement\":\n        caller_line = traceback.extract_stack(limit=2)[-2]\n        if (\n            __diag__.warn_on_match_first_with_lshift_operator\n            and caller_line == self.lshift_line\n            and Diagnostics.warn_on_match_first_with_lshift_operator\n            not in self.suppress_warnings_\n        ):\n            warnings.warn(\n                \"using '<<' operator with '|' is probably an error, use '<<='\",\n                stacklevel=2,\n            )\n        ret = super().__or__(other)\n        return ret\n\n    def __del__(self):\n        # see if we are getting dropped because of '=' reassignment of var instead of '<<=' or '<<'\n        if (\n            self.expr is None\n            and __diag__.warn_on_assignment_to_Forward\n            and Diagnostics.warn_on_assignment_to_Forward not in self.suppress_warnings_\n        ):\n            warnings.warn_explicit(\n                \"Forward defined here but no expression attached later using '<<=' or '<<'\",\n                UserWarning,\n                filename=self.caller_frame.filename,\n                lineno=self.caller_frame.lineno,\n            )\n\n    def parseImpl(self, instring, loc, doActions=True):\n        if (\n            self.expr is None\n            and __diag__.warn_on_parse_using_empty_Forward\n            and Diagnostics.warn_on_parse_using_empty_Forward\n            not in self.suppress_warnings_\n        ):\n            # walk stack until parse_string, scan_string, search_string, or transform_string is found\n            parse_fns = (\n                \"parse_string\",\n                \"scan_string\",\n                \"search_string\",\n                \"transform_string\",\n            )\n            tb = traceback.extract_stack(limit=200)\n            for i, frm in enumerate(reversed(tb), start=1):\n                if frm.name in parse_fns:\n                    stacklevel = i + 1\n                    break\n            else:\n                stacklevel = 2\n            warnings.warn(\n                \"Forward expression was never assigned a value, will not parse any input\",\n                stacklevel=stacklevel,\n            )\n        if not ParserElement._left_recursion_enabled:\n            return super().parseImpl(instring, loc, doActions)\n        # ## Bounded Recursion algorithm ##\n        # Recursion only needs to be processed at ``Forward`` elements, since they are\n        # the only ones that can actually refer to themselves. The general idea is\n        # to handle recursion stepwise: We start at no recursion, then recurse once,\n        # recurse twice, ..., until more recursion offers no benefit (we hit the bound).\n        #\n        # The \"trick\" here is that each ``Forward`` gets evaluated in two contexts\n        # - to *match* a specific recursion level, and\n        # - to *search* the bounded recursion level\n        # and the two run concurrently. The *search* must *match* each recursion level\n        # to find the best possible match. This is handled by a memo table, which\n        # provides the previous match to the next level match attempt.\n        #\n        # See also \"Left Recursion in Parsing Expression Grammars\", Medeiros et al.\n        #\n        # There is a complication since we not only *parse* but also *transform* via\n        # actions: We do not want to run the actions too often while expanding. Thus,\n        # we expand using `doActions=False` and only run `doActions=True` if the next\n        # recursion level is acceptable.\n        with ParserElement.recursion_lock:\n            memo = ParserElement.recursion_memos\n            try:\n                # we are parsing at a specific recursion expansion - use it as-is\n                prev_loc, prev_result = memo[loc, self, doActions]\n                if isinstance(prev_result, Exception):\n                    raise prev_result\n                return prev_loc, prev_result.copy()\n            except KeyError:\n                act_key = (loc, self, True)\n                peek_key = (loc, self, False)\n                # we are searching for the best recursion expansion - keep on improving\n                # both `doActions` cases must be tracked separately here!\n                prev_loc, prev_peek = memo[peek_key] = (\n                    loc - 1,\n                    ParseException(\n                        instring, loc, \"Forward recursion without base case\", self\n                    ),\n                )\n                if doActions:\n                    memo[act_key] = memo[peek_key]\n                while True:\n                    try:\n                        new_loc, new_peek = super().parseImpl(instring, loc, False)\n                    except ParseException:\n                        # we failed before getting any match \u2013 do not hide the error\n                        if isinstance(prev_peek, Exception):\n                            raise\n                        new_loc, new_peek = prev_loc, prev_peek\n                    # the match did not get better: we are done\n                    if new_loc <= prev_loc:\n                        if doActions:\n                            # replace the match for doActions=False as well,\n                            # in case the action did backtrack\n                            prev_loc, prev_result = memo[peek_key] = memo[act_key]\n                            del memo[peek_key], memo[act_key]\n                            return prev_loc, prev_result.copy()\n                        del memo[peek_key]\n                        return prev_loc, prev_peek.copy()\n                    # the match did get better: see if we can improve further\n                    if doActions:\n                        try:\n                            memo[act_key] = super().parseImpl(instring, loc, True)\n                        except ParseException as e:\n                            memo[peek_key] = memo[act_key] = (new_loc, e)\n                            raise\n                    prev_loc, prev_peek = memo[peek_key] = new_loc, new_peek\n\n    def leave_whitespace(self, recursive: bool = True) -> ParserElement:\n        self.skipWhitespace = False\n        return self\n\n    def ignore_whitespace(self, recursive: bool = True) -> ParserElement:\n        self.skipWhitespace = True\n        return self\n\n    def streamline(self) -> ParserElement:\n        if not self.streamlined:\n            self.streamlined = True\n            if self.expr is not None:\n                self.expr.streamline()\n        return self\n\n    def validate(self, validateTrace=None) -> None:\n        warnings.warn(\n            \"ParserElement.validate() is deprecated, and should not be used to check for left recursion\",\n            DeprecationWarning,\n            stacklevel=2,\n        )\n        if validateTrace is None:\n            validateTrace = []\n\n        if self not in validateTrace:\n            tmp = validateTrace[:] + [self]\n            if self.expr is not None:\n                self.expr.validate(tmp)\n        self._checkRecursion([])\n\n    def _generateDefaultName(self) -> str:\n        # Avoid infinite recursion by setting a temporary _defaultName\n        self._defaultName = \": ...\"\n\n        # Use the string representation of main expression.\n        retString = \"...\"\n        try:\n            if self.expr is not None:\n                retString = str(self.expr)[:1000]\n            else:\n                retString = \"None\"\n        finally:\n            return f\"{type(self).__name__}: {retString}\"\n\n    def copy(self) -> ParserElement:\n        if self.expr is not None:\n            return super().copy()\n        else:\n            ret = Forward()\n            ret <<= self\n            return ret\n\n    def _setResultsName(self, name, list_all_matches=False):\n        # fmt: off\n        if (\n            __diag__.warn_name_set_on_empty_Forward\n            and Diagnostics.warn_name_set_on_empty_Forward not in self.suppress_warnings_\n            and self.expr is None\n        ):\n            warning = (\n                \"warn_name_set_on_empty_Forward:\"\n                f\" setting results name {name!r} on {type(self).__name__} expression\"\n                \" that has no contained expression\"\n            )\n            warnings.warn(warning, stacklevel=3)\n        # fmt: on\n\n        return super()._setResultsName(name, list_all_matches)\n\n    # Compatibility synonyms\n    # fmt: off\n    leaveWhitespace = replaced_by_pep8(\"leaveWhitespace\", leave_whitespace)\n    ignoreWhitespace = replaced_by_pep8(\"ignoreWhitespace\", ignore_whitespace)\n    # fmt: on\n\n\nclass TokenConverter(ParseElementEnhance):\n    \"\"\"\n    Abstract subclass of :class:`ParseExpression`, for converting parsed results.\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str], savelist=False):\n        super().__init__(expr)  # , savelist)\n        self.saveAsList = False\n\n\nclass Combine(TokenConverter):\n    \"\"\"Converter to concatenate all matching tokens to a single string.\n    By default, the matching patterns must also be contiguous in the\n    input string; this can be disabled by specifying\n    ``'adjacent=False'`` in the constructor.\n\n    Example::\n\n        real = Word(nums) + '.' + Word(nums)\n        print(real.parse_string('3.1416')) # -> ['3', '.', '1416']\n        # will also erroneously match the following\n        print(real.parse_string('3. 1416')) # -> ['3', '.', '1416']\n\n        real = Combine(Word(nums) + '.' + Word(nums))\n        print(real.parse_string('3.1416')) # -> ['3.1416']\n        # no match when there are internal spaces\n        print(real.parse_string('3. 1416')) # -> Exception: Expected W:(0123...)\n    \"\"\"\n\n    def __init__(\n        self,\n        expr: ParserElement,\n        join_string: str = \"\",\n        adjacent: bool = True,\n        *,\n        joinString: typing.Optional[str] = None,\n    ):\n        super().__init__(expr)\n        joinString = joinString if joinString is not None else join_string\n        # suppress whitespace-stripping in contained parse expressions, but re-enable it on the Combine itself\n        if adjacent:\n            self.leave_whitespace()\n        self.adjacent = adjacent\n        self.skipWhitespace = True\n        self.joinString = joinString\n        self.callPreparse = True\n\n    def ignore(self, other) -> ParserElement:\n        if self.adjacent:\n            ParserElement.ignore(self, other)\n        else:\n            super().ignore(other)\n        return self\n\n    def postParse(self, instring, loc, tokenlist):\n        retToks = tokenlist.copy()\n        del retToks[:]\n        retToks += ParseResults(\n            [\"\".join(tokenlist._asStringList(self.joinString))], modal=self.modalResults\n        )\n\n        if self.resultsName and retToks.haskeys():\n            return [retToks]\n        else:\n            return retToks\n\n\nclass Group(TokenConverter):\n    \"\"\"Converter to return the matched tokens as a list - useful for\n    returning tokens of :class:`ZeroOrMore` and :class:`OneOrMore` expressions.\n\n    The optional ``aslist`` argument when set to True will return the\n    parsed tokens as a Python list instead of a pyparsing ParseResults.\n\n    Example::\n\n        ident = Word(alphas)\n        num = Word(nums)\n        term = ident | num\n        func = ident + Opt(DelimitedList(term))\n        print(func.parse_string(\"fn a, b, 100\"))\n        # -> ['fn', 'a', 'b', '100']\n\n        func = ident + Group(Opt(DelimitedList(term)))\n        print(func.parse_string(\"fn a, b, 100\"))\n        # -> ['fn', ['a', 'b', '100']]\n    \"\"\"\n\n    def __init__(self, expr: ParserElement, aslist: bool = False):\n        super().__init__(expr)\n        self.saveAsList = True\n        self._asPythonList = aslist\n\n    def postParse(self, instring, loc, tokenlist):\n        if self._asPythonList:\n            return ParseResults.List(\n                tokenlist.asList()\n                if isinstance(tokenlist, ParseResults)\n                else list(tokenlist)\n            )\n\n        return [tokenlist]\n\n\nclass Dict(TokenConverter):\n    \"\"\"Converter to return a repetitive expression as a list, but also\n    as a dictionary. Each element can also be referenced using the first\n    token in the expression as its key. Useful for tabular report\n    scraping when the first column can be used as a item key.\n\n    The optional ``asdict`` argument when set to True will return the\n    parsed tokens as a Python dict instead of a pyparsing ParseResults.\n\n    Example::\n\n        data_word = Word(alphas)\n        label = data_word + FollowedBy(':')\n\n        text = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\n        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))\n\n        # print attributes as plain groups\n        print(attr_expr[1, ...].parse_string(text).dump())\n\n        # instead of OneOrMore(expr), parse using Dict(Group(expr)[1, ...]) - Dict will auto-assign names\n        result = Dict(Group(attr_expr)[1, ...]).parse_string(text)\n        print(result.dump())\n\n        # access named fields as dict entries, or output as dict\n        print(result['shape'])\n        print(result.as_dict())\n\n    prints::\n\n        ['shape', 'SQUARE', 'posn', 'upper left', 'color', 'light blue', 'texture', 'burlap']\n        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]\n        - color: 'light blue'\n        - posn: 'upper left'\n        - shape: 'SQUARE'\n        - texture: 'burlap'\n        SQUARE\n        {'color': 'light blue', 'posn': 'upper left', 'texture': 'burlap', 'shape': 'SQUARE'}\n\n    See more examples at :class:`ParseResults` of accessing fields by results name.\n    \"\"\"\n\n    def __init__(self, expr: ParserElement, asdict: bool = False):\n        super().__init__(expr)\n        self.saveAsList = True\n        self._asPythonDict = asdict\n\n    def postParse(self, instring, loc, tokenlist):\n        for i, tok in enumerate(tokenlist):\n            if len(tok) == 0:\n                continue\n\n            ikey = tok[0]\n            if isinstance(ikey, int):\n                ikey = str(ikey).strip()\n\n            if len(tok) == 1:\n                tokenlist[ikey] = _ParseResultsWithOffset(\"\", i)\n\n            elif len(tok) == 2 and not isinstance(tok[1], ParseResults):\n                tokenlist[ikey] = _ParseResultsWithOffset(tok[1], i)\n\n            else:\n                try:\n                    dictvalue = tok.copy()  # ParseResults(i)\n                except Exception:\n                    exc = TypeError(\n                        \"could not extract dict values from parsed results\"\n                        \" - Dict expression must contain Grouped expressions\"\n                    )\n                    raise exc from None\n\n                del dictvalue[0]\n\n                if len(dictvalue) != 1 or (\n                    isinstance(dictvalue, ParseResults) and dictvalue.haskeys()\n                ):\n                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue, i)\n                else:\n                    tokenlist[ikey] = _ParseResultsWithOffset(dictvalue[0], i)\n\n        if self._asPythonDict:\n            return [tokenlist.as_dict()] if self.resultsName else tokenlist.as_dict()\n\n        return [tokenlist] if self.resultsName else tokenlist\n\n\nclass Suppress(TokenConverter):\n    \"\"\"Converter for ignoring the results of a parsed expression.\n\n    Example::\n\n        source = \"a, b, c,d\"\n        wd = Word(alphas)\n        wd_list1 = wd + (',' + wd)[...]\n        print(wd_list1.parse_string(source))\n\n        # often, delimiters that are useful during parsing are just in the\n        # way afterward - use Suppress to keep them out of the parsed output\n        wd_list2 = wd + (Suppress(',') + wd)[...]\n        print(wd_list2.parse_string(source))\n\n        # Skipped text (using '...') can be suppressed as well\n        source = \"lead in START relevant text END trailing text\"\n        start_marker = Keyword(\"START\")\n        end_marker = Keyword(\"END\")\n        find_body = Suppress(...) + start_marker + ... + end_marker\n        print(find_body.parse_string(source)\n\n    prints::\n\n        ['a', ',', 'b', ',', 'c', ',', 'd']\n        ['a', 'b', 'c', 'd']\n        ['START', 'relevant text ', 'END']\n\n    (See also :class:`DelimitedList`.)\n    \"\"\"\n\n    def __init__(self, expr: Union[ParserElement, str], savelist: bool = False):\n        if expr is ...:\n            expr = _PendingSkip(NoMatch())\n        super().__init__(expr)\n\n    def __add__(self, other) -> \"ParserElement\":\n        if isinstance(self.expr, _PendingSkip):\n            return Suppress(SkipTo(other)) + other\n\n        return super().__add__(other)\n\n    def __sub__(self, other) -> \"ParserElement\":\n        if isinstance(self.expr, _PendingSkip):\n            return Suppress(SkipTo(other)) - other\n\n        return super().__sub__(other)\n\n    def postParse(self, instring, loc, tokenlist):\n        return []\n\n    def suppress(self) -> ParserElement:\n        return self\n\n\ndef trace_parse_action(f: ParseAction) -> ParseAction:\n    \"\"\"Decorator for debugging parse actions.\n\n    When the parse action is called, this decorator will print\n    ``\">> entering method-name(line:<current_source_line>, <parse_location>, <matched_tokens>)\"``.\n    When the parse action completes, the decorator will print\n    ``\"<<\"`` followed by the returned value, or any exception that the parse action raised.\n\n    Example::\n\n        wd = Word(alphas)\n\n        @trace_parse_action\n        def remove_duplicate_chars(tokens):\n            return ''.join(sorted(set(''.join(tokens))))\n\n        wds = wd[1, ...].set_parse_action(remove_duplicate_chars)\n        print(wds.parse_string(\"slkdjs sld sldd sdlf sdljf\"))\n\n    prints::\n\n        >>entering remove_duplicate_chars(line: 'slkdjs sld sldd sdlf sdljf', 0, (['slkdjs', 'sld', 'sldd', 'sdlf', 'sdljf'], {}))\n        <<leaving remove_duplicate_chars (ret: 'dfjkls')\n        ['dfjkls']\n    \"\"\"\n    f = _trim_arity(f)\n\n    def z(*paArgs):\n        thisFunc = f.__name__\n        s, l, t = paArgs[-3:]\n        if len(paArgs) > 3:\n            thisFunc = f\"{type(paArgs[0]).__name__}.{thisFunc}\"\n        sys.stderr.write(f\">>entering {thisFunc}(line: {line(l, s)!r}, {l}, {t!r})\\n\")\n        try:\n            ret = f(*paArgs)\n        except Exception as exc:\n            sys.stderr.write(\n                f\"<<leaving {thisFunc} (exception: {type(exc).__name__}: {exc})\\n\"\n            )\n            raise\n        sys.stderr.write(f\"<<leaving {thisFunc} (ret: {ret!r})\\n\")\n        return ret\n\n    z.__name__ = f.__name__\n    return z\n\n\n# convenience constants for positional expressions\nempty = Empty().set_name(\"empty\")\nline_start = LineStart().set_name(\"line_start\")\nline_end = LineEnd().set_name(\"line_end\")\nstring_start = StringStart().set_name(\"string_start\")\nstring_end = StringEnd().set_name(\"string_end\")\n\n_escapedPunc = Regex(r\"\\\\[\\\\[\\]\\/\\-\\*\\.\\$\\+\\^\\?()~ ]\").set_parse_action(\n    lambda s, l, t: t[0][1]\n)\n_escapedHexChar = Regex(r\"\\\\0?[xX][0-9a-fA-F]+\").set_parse_action(\n    lambda s, l, t: chr(int(t[0].lstrip(r\"\\0x\"), 16))\n)\n_escapedOctChar = Regex(r\"\\\\0[0-7]+\").set_parse_action(\n    lambda s, l, t: chr(int(t[0][1:], 8))\n)\n_singleChar = (\n    _escapedPunc | _escapedHexChar | _escapedOctChar | CharsNotIn(r\"\\]\", exact=1)\n)\n_charRange = Group(_singleChar + Suppress(\"-\") + _singleChar)\n_reBracketExpr = (\n    Literal(\"[\")\n    + Opt(\"^\").set_results_name(\"negate\")\n    + Group(OneOrMore(_charRange | _singleChar)).set_results_name(\"body\")\n    + Literal(\"]\")\n)\n\n\ndef srange(s: str) -> str:\n    r\"\"\"Helper to easily define string ranges for use in :class:`Word`\n    construction. Borrows syntax from regexp ``'[]'`` string range\n    definitions::\n\n        srange(\"[0-9]\")   -> \"0123456789\"\n        srange(\"[a-z]\")   -> \"abcdefghijklmnopqrstuvwxyz\"\n        srange(\"[a-z$_]\") -> \"abcdefghijklmnopqrstuvwxyz$_\"\n\n    The input string must be enclosed in []'s, and the returned string\n    is the expanded character set joined into a single string. The\n    values enclosed in the []'s may be:\n\n    - a single character\n    - an escaped character with a leading backslash (such as ``\\-``\n      or ``\\]``)\n    - an escaped hex character with a leading ``'\\x'``\n      (``\\x21``, which is a ``'!'`` character) (``\\0x##``\n      is also supported for backwards compatibility)\n    - an escaped octal character with a leading ``'\\0'``\n      (``\\041``, which is a ``'!'`` character)\n    - a range of any of the above, separated by a dash (``'a-z'``,\n      etc.)\n    - any combination of the above (``'aeiouy'``,\n      ``'a-zA-Z0-9_$'``, etc.)\n    \"\"\"\n    _expanded = lambda p: (\n        p\n        if not isinstance(p, ParseResults)\n        else \"\".join(chr(c) for c in range(ord(p[0]), ord(p[1]) + 1))\n    )\n    try:\n        return \"\".join(_expanded(part) for part in _reBracketExpr.parse_string(s).body)\n    except Exception as e:\n        return \"\"\n\n\ndef token_map(func, *args) -> ParseAction:\n    \"\"\"Helper to define a parse action by mapping a function to all\n    elements of a :class:`ParseResults` list. If any additional args are passed,\n    they are forwarded to the given function as additional arguments\n    after the token, as in\n    ``hex_integer = Word(hexnums).set_parse_action(token_map(int, 16))``,\n    which will convert the parsed data to an integer using base 16.\n\n    Example (compare the last to example in :class:`ParserElement.transform_string`::\n\n        hex_ints = Word(hexnums)[1, ...].set_parse_action(token_map(int, 16))\n        hex_ints.run_tests('''\n            00 11 22 aa FF 0a 0d 1a\n            ''')\n\n        upperword = Word(alphas).set_parse_action(token_map(str.upper))\n        upperword[1, ...].run_tests('''\n            my kingdom for a horse\n            ''')\n\n        wd = Word(alphas).set_parse_action(token_map(str.title))\n        wd[1, ...].set_parse_action(' '.join).run_tests('''\n            now is the winter of our discontent made glorious summer by this sun of york\n            ''')\n\n    prints::\n\n        00 11 22 aa FF 0a 0d 1a\n        [0, 17, 34, 170, 255, 10, 13, 26]\n\n        my kingdom for a horse\n        ['MY', 'KINGDOM', 'FOR', 'A', 'HORSE']\n\n        now is the winter of our discontent made glorious summer by this sun of york\n        ['Now Is The Winter Of Our Discontent Made Glorious Summer By This Sun Of York']\n    \"\"\"\n\n    def pa(s, l, t):\n        return [func(tokn, *args) for tokn in t]\n\n    func_name = getattr(func, \"__name__\", getattr(func, \"__class__\").__name__)\n    pa.__name__ = func_name\n\n    return pa\n\n\ndef autoname_elements() -> None:\n    \"\"\"\n    Utility to simplify mass-naming of parser elements, for\n    generating railroad diagram with named subdiagrams.\n    \"\"\"\n    calling_frame = sys._getframe().f_back\n    if calling_frame is None:\n        return\n    calling_frame = typing.cast(types.FrameType, calling_frame)\n    for name, var in calling_frame.f_locals.items():\n        if isinstance(var, ParserElement) and not var.customName:\n            var.set_name(name)\n\n\ndbl_quoted_string = Combine(\n    Regex(r'\"(?:[^\"\\n\\r\\\\]|(?:\"\")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*') + '\"'\n).set_name(\"string enclosed in double quotes\")\n\nsgl_quoted_string = Combine(\n    Regex(r\"'(?:[^'\\n\\r\\\\]|(?:'')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*\") + \"'\"\n).set_name(\"string enclosed in single quotes\")\n\nquoted_string = Combine(\n    (Regex(r'\"(?:[^\"\\n\\r\\\\]|(?:\"\")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*') + '\"').set_name(\n        \"double quoted string\"\n    )\n    | (Regex(r\"'(?:[^'\\n\\r\\\\]|(?:'')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*\") + \"'\").set_name(\n        \"single quoted string\"\n    )\n).set_name(\"quoted string using single or double quotes\")\n\npython_quoted_string = Combine(\n    (Regex(r'\"\"\"(?:[^\"\\\\]|\"\"(?!\")|\"(?!\"\")|\\\\.)*', flags=re.MULTILINE) + '\"\"\"').set_name(\n        \"multiline double quoted string\"\n    )\n    ^ (\n        Regex(r\"'''(?:[^'\\\\]|''(?!')|'(?!'')|\\\\.)*\", flags=re.MULTILINE) + \"'''\"\n    ).set_name(\"multiline single quoted string\")\n    ^ (Regex(r'\"(?:[^\"\\n\\r\\\\]|(?:\\\\\")|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*') + '\"').set_name(\n        \"double quoted string\"\n    )\n    ^ (Regex(r\"'(?:[^'\\n\\r\\\\]|(?:\\\\')|(?:\\\\(?:[^x]|x[0-9a-fA-F]+)))*\") + \"'\").set_name(\n        \"single quoted string\"\n    )\n).set_name(\"Python quoted string\")\n\nunicode_string = Combine(\"u\" + quoted_string.copy()).set_name(\"unicode string literal\")\n\n\nalphas8bit = srange(r\"[\\0xc0-\\0xd6\\0xd8-\\0xf6\\0xf8-\\0xff]\")\npunc8bit = srange(r\"[\\0xa1-\\0xbf\\0xd7\\0xf7]\")\n\n# build list of built-in expressions, for future reference if a global default value\n# gets updated\n_builtin_exprs: List[ParserElement] = [\n    v for v in vars().values() if isinstance(v, ParserElement)\n]\n\n# Compatibility synonyms\n# fmt: off\nsglQuotedString = sgl_quoted_string\ndblQuotedString = dbl_quoted_string\nquotedString = quoted_string\nunicodeString = unicode_string\nlineStart = line_start\nlineEnd = line_end\nstringStart = string_start\nstringEnd = string_end\nnullDebugAction = replaced_by_pep8(\"nullDebugAction\", null_debug_action)\ntraceParseAction = replaced_by_pep8(\"traceParseAction\", trace_parse_action)\nconditionAsParseAction = replaced_by_pep8(\"conditionAsParseAction\", condition_as_parse_action)\ntokenMap = replaced_by_pep8(\"tokenMap\", token_map)\n# fmt: on\n", "pyparsing/exceptions.py": "# exceptions.py\n\nimport re\nimport sys\nimport typing\n\nfrom .util import (\n    col,\n    line,\n    lineno,\n    _collapse_string_to_ranges,\n    replaced_by_pep8,\n)\nfrom .unicode import pyparsing_unicode as ppu\n\n\nclass _ExceptionWordUnicodeSet(\n    ppu.Latin1, ppu.LatinA, ppu.LatinB, ppu.Greek, ppu.Cyrillic\n):\n    pass\n\n\n_extract_alphanums = _collapse_string_to_ranges(_ExceptionWordUnicodeSet.alphanums)\n_exception_word_extractor = re.compile(\"([\" + _extract_alphanums + \"]{1,16})|.\")\n\n\nclass ParseBaseException(Exception):\n    \"\"\"base exception class for all parsing runtime exceptions\"\"\"\n\n    loc: int\n    msg: str\n    pstr: str\n    parser_element: typing.Any  # \"ParserElement\"\n    args: typing.Tuple[str, int, typing.Optional[str]]\n\n    __slots__ = (\n        \"loc\",\n        \"msg\",\n        \"pstr\",\n        \"parser_element\",\n        \"args\",\n    )\n\n    # Performance tuning: we construct a *lot* of these, so keep this\n    # constructor as small and fast as possible\n    def __init__(\n        self,\n        pstr: str,\n        loc: int = 0,\n        msg: typing.Optional[str] = None,\n        elem=None,\n    ):\n        self.loc = loc\n        if msg is None:\n            self.msg = pstr\n            self.pstr = \"\"\n        else:\n            self.msg = msg\n            self.pstr = pstr\n        self.parser_element = elem\n        self.args = (pstr, loc, msg)\n\n    @staticmethod\n    def explain_exception(exc, depth=16):\n        \"\"\"\n        Method to take an exception and translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - exc - exception raised during parsing (need not be a ParseException, in support\n          of Python exceptions that might be raised in a parse action)\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception's stack trace.\n        \"\"\"\n        import inspect\n        from .core import ParserElement\n\n        if depth is None:\n            depth = sys.getrecursionlimit()\n        ret = []\n        if isinstance(exc, ParseBaseException):\n            ret.append(exc.line)\n            ret.append(f\"{' ' * (exc.column - 1)}^\")\n        ret.append(f\"{type(exc).__name__}: {exc}\")\n\n        if depth <= 0:\n            return \"\\n\".join(ret)\n\n        callers = inspect.getinnerframes(exc.__traceback__, context=depth)\n        seen = set()\n        for ff in callers[-depth:]:\n            frm = ff[0]\n\n            f_self = frm.f_locals.get(\"self\", None)\n            if isinstance(f_self, ParserElement):\n                if not frm.f_code.co_name.startswith((\"parseImpl\", \"_parseNoCache\")):\n                    continue\n                if id(f_self) in seen:\n                    continue\n                seen.add(id(f_self))\n\n                self_type = type(f_self)\n                ret.append(f\"{self_type.__module__}.{self_type.__name__} - {f_self}\")\n\n            elif f_self is not None:\n                self_type = type(f_self)\n                ret.append(f\"{self_type.__module__}.{self_type.__name__}\")\n\n            else:\n                code = frm.f_code\n                if code.co_name in (\"wrapper\", \"<module>\"):\n                    continue\n\n                ret.append(code.co_name)\n\n            depth -= 1\n            if not depth:\n                break\n\n        return \"\\n\".join(ret)\n\n    @classmethod\n    def _from_exception(cls, pe):\n        \"\"\"\n        internal factory method to simplify creating one type of ParseException\n        from another - avoids having __init__ signature conflicts among subclasses\n        \"\"\"\n        return cls(pe.pstr, pe.loc, pe.msg, pe.parser_element)\n\n    @property\n    def line(self) -> str:\n        \"\"\"\n        Return the line of text where the exception occurred.\n        \"\"\"\n        return line(self.loc, self.pstr)\n\n    @property\n    def lineno(self) -> int:\n        \"\"\"\n        Return the 1-based line number of text where the exception occurred.\n        \"\"\"\n        return lineno(self.loc, self.pstr)\n\n    @property\n    def col(self) -> int:\n        \"\"\"\n        Return the 1-based column on the line of text where the exception occurred.\n        \"\"\"\n        return col(self.loc, self.pstr)\n\n    @property\n    def column(self) -> int:\n        \"\"\"\n        Return the 1-based column on the line of text where the exception occurred.\n        \"\"\"\n        return col(self.loc, self.pstr)\n\n    # pre-PEP8 compatibility\n    @property\n    def parserElement(self):\n        return self.parser_element\n\n    @parserElement.setter\n    def parserElement(self, elem):\n        self.parser_element = elem\n\n    def __str__(self) -> str:\n        if self.pstr:\n            if self.loc >= len(self.pstr):\n                foundstr = \", found end of text\"\n            else:\n                # pull out next word at error location\n                found_match = _exception_word_extractor.match(self.pstr, self.loc)\n                if found_match is not None:\n                    found = found_match.group(0)\n                else:\n                    found = self.pstr[self.loc : self.loc + 1]\n                foundstr = (\", found %r\" % found).replace(r\"\\\\\", \"\\\\\")\n        else:\n            foundstr = \"\"\n        return f\"{self.msg}{foundstr}  (at char {self.loc}), (line:{self.lineno}, col:{self.column})\"\n\n    def __repr__(self):\n        return str(self)\n\n    def mark_input_line(\n        self, marker_string: typing.Optional[str] = None, *, markerString: str = \">!<\"\n    ) -> str:\n        \"\"\"\n        Extracts the exception line from the input string, and marks\n        the location of the exception with a special symbol.\n        \"\"\"\n        markerString = marker_string if marker_string is not None else markerString\n        line_str = self.line\n        line_column = self.column - 1\n        if markerString:\n            line_str = \"\".join(\n                (line_str[:line_column], markerString, line_str[line_column:])\n            )\n        return line_str.strip()\n\n    def explain(self, depth=16) -> str:\n        \"\"\"\n        Method to translate the Python internal traceback into a list\n        of the pyparsing expressions that caused the exception to be raised.\n\n        Parameters:\n\n        - depth (default=16) - number of levels back in the stack trace to list expression\n          and function names; if None, the full stack trace names will be listed; if 0, only\n          the failing input line, marker, and exception string will be shown\n\n        Returns a multi-line string listing the ParserElements and/or function names in the\n        exception's stack trace.\n\n        Example::\n\n            # an expression to parse 3 integers\n            expr = pp.Word(pp.nums) * 3\n            try:\n                # a failing parse - the third integer is prefixed with \"A\"\n                expr.parse_string(\"123 456 A789\")\n            except pp.ParseException as pe:\n                print(pe.explain(depth=0))\n\n        prints::\n\n            123 456 A789\n                    ^\n            ParseException: Expected W:(0-9), found 'A'  (at char 8), (line:1, col:9)\n\n        Note: the diagnostic output will include string representations of the expressions\n        that failed to parse. These representations will be more helpful if you use `set_name` to\n        give identifiable names to your expressions. Otherwise they will use the default string\n        forms, which may be cryptic to read.\n\n        Note: pyparsing's default truncation of exception tracebacks may also truncate the\n        stack of expressions that are displayed in the ``explain`` output. To get the full listing\n        of parser expressions, you may have to set ``ParserElement.verbose_stacktrace = True``\n        \"\"\"\n        return self.explain_exception(self, depth)\n\n    # Compatibility synonyms\n    # fmt: off\n    markInputline = replaced_by_pep8(\"markInputline\", mark_input_line)\n    # fmt: on\n\n\nclass ParseException(ParseBaseException):\n    \"\"\"\n    Exception thrown when a parse expression doesn't match the input string\n\n    Example::\n\n        integer = Word(nums).set_name(\"integer\")\n        try:\n            integer.parse_string(\"ABC\")\n        except ParseException as pe:\n            print(pe)\n            print(f\"column: {pe.column}\")\n\n    prints::\n\n       Expected integer (at char 0), (line:1, col:1) column: 1\n\n    \"\"\"\n\n\nclass ParseFatalException(ParseBaseException):\n    \"\"\"\n    User-throwable exception thrown when inconsistent parse content\n    is found; stops all parsing immediately\n    \"\"\"\n\n\nclass ParseSyntaxException(ParseFatalException):\n    \"\"\"\n    Just like :class:`ParseFatalException`, but thrown internally\n    when an :class:`ErrorStop<And._ErrorStop>` ('-' operator) indicates\n    that parsing is to stop immediately because an unbacktrackable\n    syntax error has been found.\n    \"\"\"\n\n\nclass RecursiveGrammarException(Exception):\n    \"\"\"\n    Exception thrown by :class:`ParserElement.validate` if the\n    grammar could be left-recursive; parser may need to enable\n    left recursion using :class:`ParserElement.enable_left_recursion<ParserElement.enable_left_recursion>`\n    \"\"\"\n\n    def __init__(self, parseElementList):\n        self.parseElementTrace = parseElementList\n\n    def __str__(self) -> str:\n        return f\"RecursiveGrammarException: {self.parseElementTrace}\"\n", "pyparsing/util.py": "# util.py\nimport inspect\nimport warnings\nimport types\nimport collections\nimport itertools\nfrom functools import lru_cache, wraps\nfrom typing import Callable, List, Union, Iterable, TypeVar, cast\n\n_bslash = chr(92)\nC = TypeVar(\"C\", bound=Callable)\n\n\nclass __config_flags:\n    \"\"\"Internal class for defining compatibility and debugging flags\"\"\"\n\n    _all_names: List[str] = []\n    _fixed_names: List[str] = []\n    _type_desc = \"configuration\"\n\n    @classmethod\n    def _set(cls, dname, value):\n        if dname in cls._fixed_names:\n            warnings.warn(\n                f\"{cls.__name__}.{dname} {cls._type_desc} is {str(getattr(cls, dname)).upper()}\"\n                f\" and cannot be overridden\",\n                stacklevel=3,\n            )\n            return\n        if dname in cls._all_names:\n            setattr(cls, dname, value)\n        else:\n            raise ValueError(f\"no such {cls._type_desc} {dname!r}\")\n\n    enable = classmethod(lambda cls, name: cls._set(name, True))\n    disable = classmethod(lambda cls, name: cls._set(name, False))\n\n\n@lru_cache(maxsize=128)\ndef col(loc: int, strg: str) -> int:\n    \"\"\"\n    Returns current column within a string, counting newlines as line separators.\n    The first column is number 1.\n\n    Note: the default parsing behavior is to expand tabs in the input string\n    before starting the parsing process.  See\n    :class:`ParserElement.parse_string` for more\n    information on parsing strings containing ``<TAB>`` s, and suggested\n    methods to maintain a consistent view of the parsed string, the parse\n    location, and line and column positions within the parsed string.\n    \"\"\"\n    s = strg\n    return 1 if 0 < loc < len(s) and s[loc - 1] == \"\\n\" else loc - s.rfind(\"\\n\", 0, loc)\n\n\n@lru_cache(maxsize=128)\ndef lineno(loc: int, strg: str) -> int:\n    \"\"\"Returns current line number within a string, counting newlines as line separators.\n    The first line is number 1.\n\n    Note - the default parsing behavior is to expand tabs in the input string\n    before starting the parsing process.  See :class:`ParserElement.parse_string`\n    for more information on parsing strings containing ``<TAB>`` s, and\n    suggested methods to maintain a consistent view of the parsed string, the\n    parse location, and line and column positions within the parsed string.\n    \"\"\"\n    return strg.count(\"\\n\", 0, loc) + 1\n\n\n@lru_cache(maxsize=128)\ndef line(loc: int, strg: str) -> str:\n    \"\"\"\n    Returns the line of text containing loc within a string, counting newlines as line separators.\n    \"\"\"\n    last_cr = strg.rfind(\"\\n\", 0, loc)\n    next_cr = strg.find(\"\\n\", loc)\n    return strg[last_cr + 1 : next_cr] if next_cr >= 0 else strg[last_cr + 1 :]\n\n\nclass _UnboundedCache:\n    def __init__(self):\n        cache = {}\n        cache_get = cache.get\n        self.not_in_cache = not_in_cache = object()\n\n        def get(_, key):\n            return cache_get(key, not_in_cache)\n\n        def set_(_, key, value):\n            cache[key] = value\n\n        def clear(_):\n            cache.clear()\n\n        self.size = None\n        self.get = types.MethodType(get, self)\n        self.set = types.MethodType(set_, self)\n        self.clear = types.MethodType(clear, self)\n\n\nclass _FifoCache:\n    def __init__(self, size):\n        self.not_in_cache = not_in_cache = object()\n        cache = {}\n        keyring = [object()] * size\n        cache_get = cache.get\n        cache_pop = cache.pop\n        keyiter = itertools.cycle(range(size))\n\n        def get(_, key):\n            return cache_get(key, not_in_cache)\n\n        def set_(_, key, value):\n            cache[key] = value\n            i = next(keyiter)\n            cache_pop(keyring[i], None)\n            keyring[i] = key\n\n        def clear(_):\n            cache.clear()\n            keyring[:] = [object()] * size\n\n        self.size = size\n        self.get = types.MethodType(get, self)\n        self.set = types.MethodType(set_, self)\n        self.clear = types.MethodType(clear, self)\n\n\nclass LRUMemo:\n    \"\"\"\n    A memoizing mapping that retains `capacity` deleted items\n\n    The memo tracks retained items by their access order; once `capacity` items\n    are retained, the least recently used item is discarded.\n    \"\"\"\n\n    def __init__(self, capacity):\n        self._capacity = capacity\n        self._active = {}\n        self._memory = collections.OrderedDict()\n\n    def __getitem__(self, key):\n        try:\n            return self._active[key]\n        except KeyError:\n            self._memory.move_to_end(key)\n            return self._memory[key]\n\n    def __setitem__(self, key, value):\n        self._memory.pop(key, None)\n        self._active[key] = value\n\n    def __delitem__(self, key):\n        try:\n            value = self._active.pop(key)\n        except KeyError:\n            pass\n        else:\n            while len(self._memory) >= self._capacity:\n                self._memory.popitem(last=False)\n            self._memory[key] = value\n\n    def clear(self):\n        self._active.clear()\n        self._memory.clear()\n\n\nclass UnboundedMemo(dict):\n    \"\"\"\n    A memoizing mapping that retains all deleted items\n    \"\"\"\n\n    def __delitem__(self, key):\n        pass\n\n\ndef _escape_regex_range_chars(s: str) -> str:\n    # escape these chars: ^-[]\n    for c in r\"\\^-[]\":\n        s = s.replace(c, _bslash + c)\n    s = s.replace(\"\\n\", r\"\\n\")\n    s = s.replace(\"\\t\", r\"\\t\")\n    return str(s)\n\n\ndef _collapse_string_to_ranges(\n    s: Union[str, Iterable[str]], re_escape: bool = True\n) -> str:\n    def is_consecutive(c):\n        c_int = ord(c)\n        is_consecutive.prev, prev = c_int, is_consecutive.prev\n        if c_int - prev > 1:\n            is_consecutive.value = next(is_consecutive.counter)\n        return is_consecutive.value\n\n    is_consecutive.prev = 0  # type: ignore [attr-defined]\n    is_consecutive.counter = itertools.count()  # type: ignore [attr-defined]\n    is_consecutive.value = -1  # type: ignore [attr-defined]\n\n    def escape_re_range_char(c):\n        return \"\\\\\" + c if c in r\"\\^-][\" else c\n\n    def no_escape_re_range_char(c):\n        return c\n\n    if not re_escape:\n        escape_re_range_char = no_escape_re_range_char\n\n    ret = []\n    s = \"\".join(sorted(set(s)))\n    if len(s) > 3:\n        for _, chars in itertools.groupby(s, key=is_consecutive):\n            first = last = next(chars)\n            last = collections.deque(\n                itertools.chain(iter([last]), chars), maxlen=1\n            ).pop()\n            if first == last:\n                ret.append(escape_re_range_char(first))\n            else:\n                sep = \"\" if ord(last) == ord(first) + 1 else \"-\"\n                ret.append(\n                    f\"{escape_re_range_char(first)}{sep}{escape_re_range_char(last)}\"\n                )\n    else:\n        ret = [escape_re_range_char(c) for c in s]\n\n    return \"\".join(ret)\n\n\ndef _flatten(ll: list) -> list:\n    ret = []\n    for i in ll:\n        if isinstance(i, list):\n            ret.extend(_flatten(i))\n        else:\n            ret.append(i)\n    return ret\n\n\ndef replaced_by_pep8(compat_name: str, fn: C) -> C:\n    # In a future version, uncomment the code in the internal _inner() functions\n    # to begin emitting DeprecationWarnings.\n\n    # Unwrap staticmethod/classmethod\n    fn = getattr(fn, \"__func__\", fn)\n\n    # (Presence of 'self' arg in signature is used by explain_exception() methods, so we take\n    # some extra steps to add it if present in decorated function.)\n    if [\"self\"] == list(inspect.signature(fn).parameters)[:1]:\n\n        @wraps(fn)\n        def _inner(self, *args, **kwargs):\n            # warnings.warn(\n            #     f\"Deprecated - use {fn.__name__}\", DeprecationWarning, stacklevel=2\n            # )\n            return fn(self, *args, **kwargs)\n\n    else:\n\n        @wraps(fn)\n        def _inner(*args, **kwargs):\n            # warnings.warn(\n            #     f\"Deprecated - use {fn.__name__}\", DeprecationWarning, stacklevel=2\n            # )\n            return fn(*args, **kwargs)\n\n    _inner.__doc__ = f\"\"\"Deprecated - use :class:`{fn.__name__}`\"\"\"\n    _inner.__name__ = compat_name\n    _inner.__annotations__ = fn.__annotations__\n    if isinstance(fn, types.FunctionType):\n        _inner.__kwdefaults__ = fn.__kwdefaults__\n    elif isinstance(fn, type) and hasattr(fn, \"__init__\"):\n        _inner.__kwdefaults__ = fn.__init__.__kwdefaults__\n    else:\n        _inner.__kwdefaults__ = None\n    _inner.__qualname__ = fn.__qualname__\n    return cast(C, _inner)\n", "pyparsing/helpers.py": "# helpers.py\nimport html.entities\nimport re\nimport sys\nimport typing\n\nfrom . import __diag__\nfrom .core import *\nfrom .util import (\n    _bslash,\n    _flatten,\n    _escape_regex_range_chars,\n    replaced_by_pep8,\n)\n\n\n#\n# global helpers\n#\ndef counted_array(\n    expr: ParserElement,\n    int_expr: typing.Optional[ParserElement] = None,\n    *,\n    intExpr: typing.Optional[ParserElement] = None,\n) -> ParserElement:\n    \"\"\"Helper to define a counted list of expressions.\n\n    This helper defines a pattern of the form::\n\n        integer expr expr expr...\n\n    where the leading integer tells how many expr expressions follow.\n    The matched tokens returns the array of expr tokens as a list - the\n    leading count token is suppressed.\n\n    If ``int_expr`` is specified, it should be a pyparsing expression\n    that produces an integer value.\n\n    Example::\n\n        counted_array(Word(alphas)).parse_string('2 ab cd ef')  # -> ['ab', 'cd']\n\n        # in this parser, the leading integer value is given in binary,\n        # '10' indicating that 2 values are in the array\n        binary_constant = Word('01').set_parse_action(lambda t: int(t[0], 2))\n        counted_array(Word(alphas), int_expr=binary_constant).parse_string('10 ab cd ef')  # -> ['ab', 'cd']\n\n        # if other fields must be parsed after the count but before the\n        # list items, give the fields results names and they will\n        # be preserved in the returned ParseResults:\n        count_with_metadata = integer + Word(alphas)(\"type\")\n        typed_array = counted_array(Word(alphanums), int_expr=count_with_metadata)(\"items\")\n        result = typed_array.parse_string(\"3 bool True True False\")\n        print(result.dump())\n\n        # prints\n        # ['True', 'True', 'False']\n        # - items: ['True', 'True', 'False']\n        # - type: 'bool'\n    \"\"\"\n    intExpr = intExpr or int_expr\n    array_expr = Forward()\n\n    def count_field_parse_action(s, l, t):\n        nonlocal array_expr\n        n = t[0]\n        array_expr <<= (expr * n) if n else Empty()\n        # clear list contents, but keep any named results\n        del t[:]\n\n    if intExpr is None:\n        intExpr = Word(nums).set_parse_action(lambda t: int(t[0]))\n    else:\n        intExpr = intExpr.copy()\n    intExpr.set_name(\"arrayLen\")\n    intExpr.add_parse_action(count_field_parse_action, call_during_try=True)\n    return (intExpr + array_expr).set_name(f\"(len) {expr}...\")\n\n\ndef match_previous_literal(expr: ParserElement) -> ParserElement:\n    \"\"\"Helper to define an expression that is indirectly defined from\n    the tokens matched in a previous expression, that is, it looks for\n    a 'repeat' of a previous expression.  For example::\n\n        first = Word(nums)\n        second = match_previous_literal(first)\n        match_expr = first + \":\" + second\n\n    will match ``\"1:1\"``, but not ``\"1:2\"``.  Because this\n    matches a previous literal, will also match the leading\n    ``\"1:1\"`` in ``\"1:10\"``. If this is not desired, use\n    :class:`match_previous_expr`. Do *not* use with packrat parsing\n    enabled.\n    \"\"\"\n    rep = Forward()\n\n    def copy_token_to_repeater(s, l, t):\n        if not t:\n            rep << Empty()\n            return\n\n        if len(t) == 1:\n            rep << t[0]\n            return\n\n        # flatten t tokens\n        tflat = _flatten(t.as_list())\n        rep << And(Literal(tt) for tt in tflat)\n\n    expr.add_parse_action(copy_token_to_repeater, callDuringTry=True)\n    rep.set_name(\"(prev) \" + str(expr))\n    return rep\n\n\ndef match_previous_expr(expr: ParserElement) -> ParserElement:\n    \"\"\"Helper to define an expression that is indirectly defined from\n    the tokens matched in a previous expression, that is, it looks for\n    a 'repeat' of a previous expression.  For example::\n\n        first = Word(nums)\n        second = match_previous_expr(first)\n        match_expr = first + \":\" + second\n\n    will match ``\"1:1\"``, but not ``\"1:2\"``.  Because this\n    matches by expressions, will *not* match the leading ``\"1:1\"``\n    in ``\"1:10\"``; the expressions are evaluated first, and then\n    compared, so ``\"1\"`` is compared with ``\"10\"``. Do *not* use\n    with packrat parsing enabled.\n    \"\"\"\n    rep = Forward()\n    e2 = expr.copy()\n    rep <<= e2\n\n    def copy_token_to_repeater(s, l, t):\n        matchTokens = _flatten(t.as_list())\n\n        def must_match_these_tokens(s, l, t):\n            theseTokens = _flatten(t.as_list())\n            if theseTokens != matchTokens:\n                raise ParseException(\n                    s, l, f\"Expected {matchTokens}, found{theseTokens}\"\n                )\n\n        rep.set_parse_action(must_match_these_tokens, callDuringTry=True)\n\n    expr.add_parse_action(copy_token_to_repeater, callDuringTry=True)\n    rep.set_name(\"(prev) \" + str(expr))\n    return rep\n\n\ndef one_of(\n    strs: Union[typing.Iterable[str], str],\n    caseless: bool = False,\n    use_regex: bool = True,\n    as_keyword: bool = False,\n    *,\n    useRegex: bool = True,\n    asKeyword: bool = False,\n) -> ParserElement:\n    \"\"\"Helper to quickly define a set of alternative :class:`Literal` s,\n    and makes sure to do longest-first testing when there is a conflict,\n    regardless of the input order, but returns\n    a :class:`MatchFirst` for best performance.\n\n    Parameters:\n\n    - ``strs`` - a string of space-delimited literals, or a collection of\n      string literals\n    - ``caseless`` - treat all literals as caseless - (default= ``False``)\n    - ``use_regex`` - as an optimization, will\n      generate a :class:`Regex` object; otherwise, will generate\n      a :class:`MatchFirst` object (if ``caseless=True`` or ``as_keyword=True``, or if\n      creating a :class:`Regex` raises an exception) - (default= ``True``)\n    - ``as_keyword`` - enforce :class:`Keyword`-style matching on the\n      generated expressions - (default= ``False``)\n    - ``asKeyword`` and ``useRegex`` are retained for pre-PEP8 compatibility,\n      but will be removed in a future release\n\n    Example::\n\n        comp_oper = one_of(\"< = > <= >= !=\")\n        var = Word(alphas)\n        number = Word(nums)\n        term = var | number\n        comparison_expr = term + comp_oper + term\n        print(comparison_expr.search_string(\"B = 12  AA=23 B<=AA AA>12\"))\n\n    prints::\n\n        [['B', '=', '12'], ['AA', '=', '23'], ['B', '<=', 'AA'], ['AA', '>', '12']]\n    \"\"\"\n    asKeyword = asKeyword or as_keyword\n    useRegex = useRegex and use_regex\n\n    if (\n        isinstance(caseless, str_type)\n        and __diag__.warn_on_multiple_string_args_to_oneof\n    ):\n        warnings.warn(\n            \"More than one string argument passed to one_of, pass\"\n            \" choices as a list or space-delimited string\",\n            stacklevel=2,\n        )\n\n    if caseless:\n        isequal = lambda a, b: a.upper() == b.upper()\n        masks = lambda a, b: b.upper().startswith(a.upper())\n        parseElementClass = CaselessKeyword if asKeyword else CaselessLiteral\n    else:\n        isequal = lambda a, b: a == b\n        masks = lambda a, b: b.startswith(a)\n        parseElementClass = Keyword if asKeyword else Literal\n\n    symbols: List[str] = []\n    if isinstance(strs, str_type):\n        strs = typing.cast(str, strs)\n        symbols = strs.split()\n    elif isinstance(strs, Iterable):\n        symbols = list(strs)\n    else:\n        raise TypeError(\"Invalid argument to one_of, expected string or iterable\")\n    if not symbols:\n        return NoMatch()\n\n    # reorder given symbols to take care to avoid masking longer choices with shorter ones\n    # (but only if the given symbols are not just single characters)\n    if any(len(sym) > 1 for sym in symbols):\n        i = 0\n        while i < len(symbols) - 1:\n            cur = symbols[i]\n            for j, other in enumerate(symbols[i + 1 :]):\n                if isequal(other, cur):\n                    del symbols[i + j + 1]\n                    break\n                if masks(cur, other):\n                    del symbols[i + j + 1]\n                    symbols.insert(i, other)\n                    break\n            else:\n                i += 1\n\n    if useRegex:\n        re_flags: int = re.IGNORECASE if caseless else 0\n\n        try:\n            if all(len(sym) == 1 for sym in symbols):\n                # symbols are just single characters, create range regex pattern\n                patt = f\"[{''.join(_escape_regex_range_chars(sym) for sym in symbols)}]\"\n            else:\n                patt = \"|\".join(re.escape(sym) for sym in symbols)\n\n            # wrap with \\b word break markers if defining as keywords\n            if asKeyword:\n                patt = rf\"\\b(?:{patt})\\b\"\n\n            ret = Regex(patt, flags=re_flags).set_name(\" | \".join(symbols))\n\n            if caseless:\n                # add parse action to return symbols as specified, not in random\n                # casing as found in input string\n                symbol_map = {sym.lower(): sym for sym in symbols}\n                ret.add_parse_action(lambda s, l, t: symbol_map[t[0].lower()])\n\n            return ret\n\n        except re.error:\n            warnings.warn(\n                \"Exception creating Regex for one_of, building MatchFirst\", stacklevel=2\n            )\n\n    # last resort, just use MatchFirst\n    return MatchFirst(parseElementClass(sym) for sym in symbols).set_name(\n        \" | \".join(symbols)\n    )\n\n\ndef dict_of(key: ParserElement, value: ParserElement) -> ParserElement:\n    \"\"\"Helper to easily and clearly define a dictionary by specifying\n    the respective patterns for the key and value.  Takes care of\n    defining the :class:`Dict`, :class:`ZeroOrMore`, and\n    :class:`Group` tokens in the proper order.  The key pattern\n    can include delimiting markers or punctuation, as long as they are\n    suppressed, thereby leaving the significant key text.  The value\n    pattern can include named results, so that the :class:`Dict` results\n    can include named token fields.\n\n    Example::\n\n        text = \"shape: SQUARE posn: upper left color: light blue texture: burlap\"\n        attr_expr = (label + Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join))\n        print(attr_expr[1, ...].parse_string(text).dump())\n\n        attr_label = label\n        attr_value = Suppress(':') + OneOrMore(data_word, stop_on=label).set_parse_action(' '.join)\n\n        # similar to Dict, but simpler call format\n        result = dict_of(attr_label, attr_value).parse_string(text)\n        print(result.dump())\n        print(result['shape'])\n        print(result.shape)  # object attribute access works too\n        print(result.as_dict())\n\n    prints::\n\n        [['shape', 'SQUARE'], ['posn', 'upper left'], ['color', 'light blue'], ['texture', 'burlap']]\n        - color: 'light blue'\n        - posn: 'upper left'\n        - shape: 'SQUARE'\n        - texture: 'burlap'\n        SQUARE\n        SQUARE\n        {'color': 'light blue', 'shape': 'SQUARE', 'posn': 'upper left', 'texture': 'burlap'}\n    \"\"\"\n    return Dict(OneOrMore(Group(key + value)))\n\n\ndef original_text_for(\n    expr: ParserElement, as_string: bool = True, *, asString: bool = True\n) -> ParserElement:\n    \"\"\"Helper to return the original, untokenized text for a given\n    expression.  Useful to restore the parsed fields of an HTML start\n    tag into the raw tag text itself, or to revert separate tokens with\n    intervening whitespace back to the original matching input text. By\n    default, returns a string containing the original parsed text.\n\n    If the optional ``as_string`` argument is passed as\n    ``False``, then the return value is\n    a :class:`ParseResults` containing any results names that\n    were originally matched, and a single token containing the original\n    matched text from the input string.  So if the expression passed to\n    :class:`original_text_for` contains expressions with defined\n    results names, you must set ``as_string`` to ``False`` if you\n    want to preserve those results name values.\n\n    The ``asString`` pre-PEP8 argument is retained for compatibility,\n    but will be removed in a future release.\n\n    Example::\n\n        src = \"this is test <b> bold <i>text</i> </b> normal text \"\n        for tag in (\"b\", \"i\"):\n            opener, closer = make_html_tags(tag)\n            patt = original_text_for(opener + ... + closer)\n            print(patt.search_string(src)[0])\n\n    prints::\n\n        ['<b> bold <i>text</i> </b>']\n        ['<i>text</i>']\n    \"\"\"\n    asString = asString and as_string\n\n    locMarker = Empty().set_parse_action(lambda s, loc, t: loc)\n    endlocMarker = locMarker.copy()\n    endlocMarker.callPreparse = False\n    matchExpr = locMarker(\"_original_start\") + expr + endlocMarker(\"_original_end\")\n    if asString:\n        extractText = lambda s, l, t: s[t._original_start : t._original_end]\n    else:\n\n        def extractText(s, l, t):\n            t[:] = [s[t.pop(\"_original_start\") : t.pop(\"_original_end\")]]\n\n    matchExpr.set_parse_action(extractText)\n    matchExpr.ignoreExprs = expr.ignoreExprs\n    matchExpr.suppress_warning(Diagnostics.warn_ungrouped_named_tokens_in_collection)\n    return matchExpr\n\n\ndef ungroup(expr: ParserElement) -> ParserElement:\n    \"\"\"Helper to undo pyparsing's default grouping of And expressions,\n    even if all but one are non-empty.\n    \"\"\"\n    return TokenConverter(expr).add_parse_action(lambda t: t[0])\n\n\ndef locatedExpr(expr: ParserElement) -> ParserElement:\n    \"\"\"\n    (DEPRECATED - future code should use the :class:`Located` class)\n    Helper to decorate a returned token with its starting and ending\n    locations in the input string.\n\n    This helper adds the following results names:\n\n    - ``locn_start`` - location where matched expression begins\n    - ``locn_end`` - location where matched expression ends\n    - ``value`` - the actual parsed results\n\n    Be careful if the input text contains ``<TAB>`` characters, you\n    may want to call :class:`ParserElement.parse_with_tabs`\n\n    Example::\n\n        wd = Word(alphas)\n        for match in locatedExpr(wd).search_string(\"ljsdf123lksdjjf123lkkjj1222\"):\n            print(match)\n\n    prints::\n\n        [[0, 'ljsdf', 5]]\n        [[8, 'lksdjjf', 15]]\n        [[18, 'lkkjj', 23]]\n    \"\"\"\n    locator = Empty().set_parse_action(lambda ss, ll, tt: ll)\n    return Group(\n        locator(\"locn_start\")\n        + expr(\"value\")\n        + locator.copy().leaveWhitespace()(\"locn_end\")\n    )\n\n\ndef nested_expr(\n    opener: Union[str, ParserElement] = \"(\",\n    closer: Union[str, ParserElement] = \")\",\n    content: typing.Optional[ParserElement] = None,\n    ignore_expr: ParserElement = quoted_string(),\n    *,\n    ignoreExpr: ParserElement = quoted_string(),\n) -> ParserElement:\n    \"\"\"Helper method for defining nested lists enclosed in opening and\n    closing delimiters (``\"(\"`` and ``\")\"`` are the default).\n\n    Parameters:\n\n    - ``opener`` - opening character for a nested list\n      (default= ``\"(\"``); can also be a pyparsing expression\n    - ``closer`` - closing character for a nested list\n      (default= ``\")\"``); can also be a pyparsing expression\n    - ``content`` - expression for items within the nested lists\n      (default= ``None``)\n    - ``ignore_expr`` - expression for ignoring opening and closing delimiters\n      (default= :class:`quoted_string`)\n    - ``ignoreExpr`` - this pre-PEP8 argument is retained for compatibility\n      but will be removed in a future release\n\n    If an expression is not provided for the content argument, the\n    nested expression will capture all whitespace-delimited content\n    between delimiters as a list of separate values.\n\n    Use the ``ignore_expr`` argument to define expressions that may\n    contain opening or closing characters that should not be treated as\n    opening or closing characters for nesting, such as quoted_string or\n    a comment expression.  Specify multiple expressions using an\n    :class:`Or` or :class:`MatchFirst`. The default is\n    :class:`quoted_string`, but if no expressions are to be ignored, then\n    pass ``None`` for this argument.\n\n    Example::\n\n        data_type = one_of(\"void int short long char float double\")\n        decl_data_type = Combine(data_type + Opt(Word('*')))\n        ident = Word(alphas+'_', alphanums+'_')\n        number = pyparsing_common.number\n        arg = Group(decl_data_type + ident)\n        LPAR, RPAR = map(Suppress, \"()\")\n\n        code_body = nested_expr('{', '}', ignore_expr=(quoted_string | c_style_comment))\n\n        c_function = (decl_data_type(\"type\")\n                      + ident(\"name\")\n                      + LPAR + Opt(DelimitedList(arg), [])(\"args\") + RPAR\n                      + code_body(\"body\"))\n        c_function.ignore(c_style_comment)\n\n        source_code = '''\n            int is_odd(int x) {\n                return (x%2);\n            }\n\n            int dec_to_hex(char hchar) {\n                if (hchar >= '0' && hchar <= '9') {\n                    return (ord(hchar)-ord('0'));\n                } else {\n                    return (10+ord(hchar)-ord('A'));\n                }\n            }\n        '''\n        for func in c_function.search_string(source_code):\n            print(\"%(name)s (%(type)s) args: %(args)s\" % func)\n\n\n    prints::\n\n        is_odd (int) args: [['int', 'x']]\n        dec_to_hex (int) args: [['char', 'hchar']]\n    \"\"\"\n    if ignoreExpr != ignore_expr:\n        ignoreExpr = ignore_expr if ignoreExpr == quoted_string() else ignoreExpr\n    if opener == closer:\n        raise ValueError(\"opening and closing strings cannot be the same\")\n    if content is None:\n        if isinstance(opener, str_type) and isinstance(closer, str_type):\n            opener = typing.cast(str, opener)\n            closer = typing.cast(str, closer)\n            if len(opener) == 1 and len(closer) == 1:\n                if ignoreExpr is not None:\n                    content = Combine(\n                        OneOrMore(\n                            ~ignoreExpr\n                            + CharsNotIn(\n                                opener + closer + ParserElement.DEFAULT_WHITE_CHARS,\n                                exact=1,\n                            )\n                        )\n                    ).set_parse_action(lambda t: t[0].strip())\n                else:\n                    content = empty.copy() + CharsNotIn(\n                        opener + closer + ParserElement.DEFAULT_WHITE_CHARS\n                    ).set_parse_action(lambda t: t[0].strip())\n            else:\n                if ignoreExpr is not None:\n                    content = Combine(\n                        OneOrMore(\n                            ~ignoreExpr\n                            + ~Literal(opener)\n                            + ~Literal(closer)\n                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)\n                        )\n                    ).set_parse_action(lambda t: t[0].strip())\n                else:\n                    content = Combine(\n                        OneOrMore(\n                            ~Literal(opener)\n                            + ~Literal(closer)\n                            + CharsNotIn(ParserElement.DEFAULT_WHITE_CHARS, exact=1)\n                        )\n                    ).set_parse_action(lambda t: t[0].strip())\n        else:\n            raise ValueError(\n                \"opening and closing arguments must be strings if no content expression is given\"\n            )\n    ret = Forward()\n    if ignoreExpr is not None:\n        ret <<= Group(\n            Suppress(opener) + ZeroOrMore(ignoreExpr | ret | content) + Suppress(closer)\n        )\n    else:\n        ret <<= Group(Suppress(opener) + ZeroOrMore(ret | content) + Suppress(closer))\n    ret.set_name(f\"nested {opener}{closer} expression\")\n    # don't override error message from content expressions\n    ret.errmsg = None\n    return ret\n\n\ndef _makeTags(tagStr, xml, suppress_LT=Suppress(\"<\"), suppress_GT=Suppress(\">\")):\n    \"\"\"Internal helper to construct opening and closing tag expressions, given a tag name\"\"\"\n    if isinstance(tagStr, str_type):\n        resname = tagStr\n        tagStr = Keyword(tagStr, caseless=not xml)\n    else:\n        resname = tagStr.name\n\n    tagAttrName = Word(alphas, alphanums + \"_-:\")\n    if xml:\n        tagAttrValue = dbl_quoted_string.copy().set_parse_action(remove_quotes)\n        openTag = (\n            suppress_LT\n            + tagStr(\"tag\")\n            + Dict(ZeroOrMore(Group(tagAttrName + Suppress(\"=\") + tagAttrValue)))\n            + Opt(\"/\", default=[False])(\"empty\").set_parse_action(\n                lambda s, l, t: t[0] == \"/\"\n            )\n            + suppress_GT\n        )\n    else:\n        tagAttrValue = quoted_string.copy().set_parse_action(remove_quotes) | Word(\n            printables, exclude_chars=\">\"\n        )\n        openTag = (\n            suppress_LT\n            + tagStr(\"tag\")\n            + Dict(\n                ZeroOrMore(\n                    Group(\n                        tagAttrName.set_parse_action(lambda t: t[0].lower())\n                        + Opt(Suppress(\"=\") + tagAttrValue)\n                    )\n                )\n            )\n            + Opt(\"/\", default=[False])(\"empty\").set_parse_action(\n                lambda s, l, t: t[0] == \"/\"\n            )\n            + suppress_GT\n        )\n    closeTag = Combine(Literal(\"</\") + tagStr + \">\", adjacent=False)\n\n    openTag.set_name(f\"<{resname}>\")\n    # add start<tagname> results name in parse action now that ungrouped names are not reported at two levels\n    openTag.add_parse_action(\n        lambda t: t.__setitem__(\n            \"start\" + \"\".join(resname.replace(\":\", \" \").title().split()), t.copy()\n        )\n    )\n    closeTag = closeTag(\n        \"end\" + \"\".join(resname.replace(\":\", \" \").title().split())\n    ).set_name(f\"</{resname}>\")\n    openTag.tag = resname\n    closeTag.tag = resname\n    openTag.tag_body = SkipTo(closeTag())\n    return openTag, closeTag\n\n\ndef make_html_tags(\n    tag_str: Union[str, ParserElement]\n) -> Tuple[ParserElement, ParserElement]:\n    \"\"\"Helper to construct opening and closing tag expressions for HTML,\n    given a tag name. Matches tags in either upper or lower case,\n    attributes with namespaces and with quoted or unquoted values.\n\n    Example::\n\n        text = '<td>More info at the <a href=\"https://github.com/pyparsing/pyparsing/wiki\">pyparsing</a> wiki page</td>'\n        # make_html_tags returns pyparsing expressions for the opening and\n        # closing tags as a 2-tuple\n        a, a_end = make_html_tags(\"A\")\n        link_expr = a + SkipTo(a_end)(\"link_text\") + a_end\n\n        for link in link_expr.search_string(text):\n            # attributes in the <A> tag (like \"href\" shown here) are\n            # also accessible as named results\n            print(link.link_text, '->', link.href)\n\n    prints::\n\n        pyparsing -> https://github.com/pyparsing/pyparsing/wiki\n    \"\"\"\n    return _makeTags(tag_str, False)\n\n\ndef make_xml_tags(\n    tag_str: Union[str, ParserElement]\n) -> Tuple[ParserElement, ParserElement]:\n    \"\"\"Helper to construct opening and closing tag expressions for XML,\n    given a tag name. Matches tags only in the given upper/lower case.\n\n    Example: similar to :class:`make_html_tags`\n    \"\"\"\n    return _makeTags(tag_str, True)\n\n\nany_open_tag: ParserElement\nany_close_tag: ParserElement\nany_open_tag, any_close_tag = make_html_tags(\n    Word(alphas, alphanums + \"_:\").set_name(\"any tag\")\n)\n\n_htmlEntityMap = {k.rstrip(\";\"): v for k, v in html.entities.html5.items()}\ncommon_html_entity = Regex(\"&(?P<entity>\" + \"|\".join(_htmlEntityMap) + \");\").set_name(\n    \"common HTML entity\"\n)\n\n\ndef replace_html_entity(s, l, t):\n    \"\"\"Helper parser action to replace common HTML entities with their special characters\"\"\"\n    return _htmlEntityMap.get(t.entity)\n\n\nclass OpAssoc(Enum):\n    \"\"\"Enumeration of operator associativity\n    - used in constructing InfixNotationOperatorSpec for :class:`infix_notation`\"\"\"\n\n    LEFT = 1\n    RIGHT = 2\n\n\nInfixNotationOperatorArgType = Union[\n    ParserElement, str, Tuple[Union[ParserElement, str], Union[ParserElement, str]]\n]\nInfixNotationOperatorSpec = Union[\n    Tuple[\n        InfixNotationOperatorArgType,\n        int,\n        OpAssoc,\n        typing.Optional[ParseAction],\n    ],\n    Tuple[\n        InfixNotationOperatorArgType,\n        int,\n        OpAssoc,\n    ],\n]\n\n\ndef infix_notation(\n    base_expr: ParserElement,\n    op_list: List[InfixNotationOperatorSpec],\n    lpar: Union[str, ParserElement] = Suppress(\"(\"),\n    rpar: Union[str, ParserElement] = Suppress(\")\"),\n) -> ParserElement:\n    \"\"\"Helper method for constructing grammars of expressions made up of\n    operators working in a precedence hierarchy.  Operators may be unary\n    or binary, left- or right-associative.  Parse actions can also be\n    attached to operator expressions. The generated parser will also\n    recognize the use of parentheses to override operator precedences\n    (see example below).\n\n    Note: if you define a deep operator list, you may see performance\n    issues when using infix_notation. See\n    :class:`ParserElement.enable_packrat` for a mechanism to potentially\n    improve your parser performance.\n\n    Parameters:\n\n    - ``base_expr`` - expression representing the most basic operand to\n      be used in the expression\n    - ``op_list`` - list of tuples, one for each operator precedence level\n      in the expression grammar; each tuple is of the form ``(op_expr,\n      num_operands, right_left_assoc, (optional)parse_action)``, where:\n\n      - ``op_expr`` is the pyparsing expression for the operator; may also\n        be a string, which will be converted to a Literal; if ``num_operands``\n        is 3, ``op_expr`` is a tuple of two expressions, for the two\n        operators separating the 3 terms\n      - ``num_operands`` is the number of terms for this operator (must be 1,\n        2, or 3)\n      - ``right_left_assoc`` is the indicator whether the operator is right\n        or left associative, using the pyparsing-defined constants\n        ``OpAssoc.RIGHT`` and ``OpAssoc.LEFT``.\n      - ``parse_action`` is the parse action to be associated with\n        expressions matching this operator expression (the parse action\n        tuple member may be omitted); if the parse action is passed\n        a tuple or list of functions, this is equivalent to calling\n        ``set_parse_action(*fn)``\n        (:class:`ParserElement.set_parse_action`)\n    - ``lpar`` - expression for matching left-parentheses; if passed as a\n      str, then will be parsed as ``Suppress(lpar)``. If lpar is passed as\n      an expression (such as ``Literal('(')``), then it will be kept in\n      the parsed results, and grouped with them. (default= ``Suppress('(')``)\n    - ``rpar`` - expression for matching right-parentheses; if passed as a\n      str, then will be parsed as ``Suppress(rpar)``. If rpar is passed as\n      an expression (such as ``Literal(')')``), then it will be kept in\n      the parsed results, and grouped with them. (default= ``Suppress(')')``)\n\n    Example::\n\n        # simple example of four-function arithmetic with ints and\n        # variable names\n        integer = pyparsing_common.signed_integer\n        varname = pyparsing_common.identifier\n\n        arith_expr = infix_notation(integer | varname,\n            [\n            ('-', 1, OpAssoc.RIGHT),\n            (one_of('* /'), 2, OpAssoc.LEFT),\n            (one_of('+ -'), 2, OpAssoc.LEFT),\n            ])\n\n        arith_expr.run_tests('''\n            5+3*6\n            (5+3)*6\n            -2--11\n            ''', full_dump=False)\n\n    prints::\n\n        5+3*6\n        [[5, '+', [3, '*', 6]]]\n\n        (5+3)*6\n        [[[5, '+', 3], '*', 6]]\n\n        (5+x)*y\n        [[[5, '+', 'x'], '*', 'y']]\n\n        -2--11\n        [[['-', 2], '-', ['-', 11]]]\n    \"\"\"\n\n    # captive version of FollowedBy that does not do parse actions or capture results names\n    class _FB(FollowedBy):\n        def parseImpl(self, instring, loc, doActions=True):\n            self.expr.try_parse(instring, loc)\n            return loc, []\n\n    _FB.__name__ = \"FollowedBy>\"\n\n    ret = Forward()\n    if isinstance(lpar, str):\n        lpar = Suppress(lpar)\n    if isinstance(rpar, str):\n        rpar = Suppress(rpar)\n\n    # if lpar and rpar are not suppressed, wrap in group\n    if not (isinstance(lpar, Suppress) and isinstance(rpar, Suppress)):\n        lastExpr = base_expr | Group(lpar + ret + rpar).set_name(\n            f\"nested_{base_expr.name}\"\n        )\n    else:\n        lastExpr = base_expr | (lpar + ret + rpar).set_name(f\"nested_{base_expr.name}\")\n    root_expr = lastExpr\n\n    arity: int\n    rightLeftAssoc: opAssoc\n    pa: typing.Optional[ParseAction]\n    opExpr1: ParserElement\n    opExpr2: ParserElement\n    for operDef in op_list:\n        opExpr, arity, rightLeftAssoc, pa = (operDef + (None,))[:4]  # type: ignore[assignment]\n        if isinstance(opExpr, str_type):\n            opExpr = ParserElement._literalStringClass(opExpr)\n        opExpr = typing.cast(ParserElement, opExpr)\n        if arity == 3:\n            if not isinstance(opExpr, (tuple, list)) or len(opExpr) != 2:\n                raise ValueError(\n                    \"if numterms=3, opExpr must be a tuple or list of two expressions\"\n                )\n            opExpr1, opExpr2 = opExpr\n            term_name = f\"{opExpr1}{opExpr2} term\"\n        else:\n            term_name = f\"{opExpr} term\"\n\n        if not 1 <= arity <= 3:\n            raise ValueError(\"operator must be unary (1), binary (2), or ternary (3)\")\n\n        if rightLeftAssoc not in (OpAssoc.LEFT, OpAssoc.RIGHT):\n            raise ValueError(\"operator must indicate right or left associativity\")\n\n        thisExpr: ParserElement = Forward().set_name(term_name)\n        thisExpr = typing.cast(Forward, thisExpr)\n        if rightLeftAssoc is OpAssoc.LEFT:\n            if arity == 1:\n                matchExpr = _FB(lastExpr + opExpr) + Group(lastExpr + opExpr[1, ...])\n            elif arity == 2:\n                if opExpr is not None:\n                    matchExpr = _FB(lastExpr + opExpr + lastExpr) + Group(\n                        lastExpr + (opExpr + lastExpr)[1, ...]\n                    )\n                else:\n                    matchExpr = _FB(lastExpr + lastExpr) + Group(lastExpr[2, ...])\n            elif arity == 3:\n                matchExpr = _FB(\n                    lastExpr + opExpr1 + lastExpr + opExpr2 + lastExpr\n                ) + Group(lastExpr + OneOrMore(opExpr1 + lastExpr + opExpr2 + lastExpr))\n        elif rightLeftAssoc is OpAssoc.RIGHT:\n            if arity == 1:\n                # try to avoid LR with this extra test\n                if not isinstance(opExpr, Opt):\n                    opExpr = Opt(opExpr)\n                matchExpr = _FB(opExpr.expr + thisExpr) + Group(opExpr + thisExpr)\n            elif arity == 2:\n                if opExpr is not None:\n                    matchExpr = _FB(lastExpr + opExpr + thisExpr) + Group(\n                        lastExpr + (opExpr + thisExpr)[1, ...]\n                    )\n                else:\n                    matchExpr = _FB(lastExpr + thisExpr) + Group(\n                        lastExpr + thisExpr[1, ...]\n                    )\n            elif arity == 3:\n                matchExpr = _FB(\n                    lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr\n                ) + Group(lastExpr + opExpr1 + thisExpr + opExpr2 + thisExpr)\n        if pa:\n            if isinstance(pa, (tuple, list)):\n                matchExpr.set_parse_action(*pa)\n            else:\n                matchExpr.set_parse_action(pa)\n        thisExpr <<= (matchExpr | lastExpr).setName(term_name)\n        lastExpr = thisExpr\n    ret <<= lastExpr\n    root_expr.set_name(\"base_expr\")\n    return ret\n\n\ndef indentedBlock(blockStatementExpr, indentStack, indent=True, backup_stacks=[]):\n    \"\"\"\n    (DEPRECATED - use :class:`IndentedBlock` class instead)\n    Helper method for defining space-delimited indentation blocks,\n    such as those used to define block statements in Python source code.\n\n    Parameters:\n\n    - ``blockStatementExpr`` - expression defining syntax of statement that\n      is repeated within the indented block\n    - ``indentStack`` - list created by caller to manage indentation stack\n      (multiple ``statementWithIndentedBlock`` expressions within a single\n      grammar should share a common ``indentStack``)\n    - ``indent`` - boolean indicating whether block must be indented beyond\n      the current level; set to ``False`` for block of left-most statements\n      (default= ``True``)\n\n    A valid block must contain at least one ``blockStatement``.\n\n    (Note that indentedBlock uses internal parse actions which make it\n    incompatible with packrat parsing.)\n\n    Example::\n\n        data = '''\n        def A(z):\n          A1\n          B = 100\n          G = A2\n          A2\n          A3\n        B\n        def BB(a,b,c):\n          BB1\n          def BBA():\n            bba1\n            bba2\n            bba3\n        C\n        D\n        def spam(x,y):\n             def eggs(z):\n                 pass\n        '''\n\n\n        indentStack = [1]\n        stmt = Forward()\n\n        identifier = Word(alphas, alphanums)\n        funcDecl = (\"def\" + identifier + Group(\"(\" + Opt(delimitedList(identifier)) + \")\") + \":\")\n        func_body = indentedBlock(stmt, indentStack)\n        funcDef = Group(funcDecl + func_body)\n\n        rvalue = Forward()\n        funcCall = Group(identifier + \"(\" + Opt(delimitedList(rvalue)) + \")\")\n        rvalue << (funcCall | identifier | Word(nums))\n        assignment = Group(identifier + \"=\" + rvalue)\n        stmt << (funcDef | assignment | identifier)\n\n        module_body = stmt[1, ...]\n\n        parseTree = module_body.parseString(data)\n        parseTree.pprint()\n\n    prints::\n\n        [['def',\n          'A',\n          ['(', 'z', ')'],\n          ':',\n          [['A1'], [['B', '=', '100']], [['G', '=', 'A2']], ['A2'], ['A3']]],\n         'B',\n         ['def',\n          'BB',\n          ['(', 'a', 'b', 'c', ')'],\n          ':',\n          [['BB1'], [['def', 'BBA', ['(', ')'], ':', [['bba1'], ['bba2'], ['bba3']]]]]],\n         'C',\n         'D',\n         ['def',\n          'spam',\n          ['(', 'x', 'y', ')'],\n          ':',\n          [[['def', 'eggs', ['(', 'z', ')'], ':', [['pass']]]]]]]\n    \"\"\"\n    backup_stacks.append(indentStack[:])\n\n    def reset_stack():\n        indentStack[:] = backup_stacks[-1]\n\n    def checkPeerIndent(s, l, t):\n        if l >= len(s):\n            return\n        curCol = col(l, s)\n        if curCol != indentStack[-1]:\n            if curCol > indentStack[-1]:\n                raise ParseException(s, l, \"illegal nesting\")\n            raise ParseException(s, l, \"not a peer entry\")\n\n    def checkSubIndent(s, l, t):\n        curCol = col(l, s)\n        if curCol > indentStack[-1]:\n            indentStack.append(curCol)\n        else:\n            raise ParseException(s, l, \"not a subentry\")\n\n    def checkUnindent(s, l, t):\n        if l >= len(s):\n            return\n        curCol = col(l, s)\n        if not (indentStack and curCol in indentStack):\n            raise ParseException(s, l, \"not an unindent\")\n        if curCol < indentStack[-1]:\n            indentStack.pop()\n\n    NL = OneOrMore(LineEnd().set_whitespace_chars(\"\\t \").suppress())\n    INDENT = (Empty() + Empty().set_parse_action(checkSubIndent)).set_name(\"INDENT\")\n    PEER = Empty().set_parse_action(checkPeerIndent).set_name(\"\")\n    UNDENT = Empty().set_parse_action(checkUnindent).set_name(\"UNINDENT\")\n    if indent:\n        smExpr = Group(\n            Opt(NL)\n            + INDENT\n            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))\n            + UNDENT\n        )\n    else:\n        smExpr = Group(\n            Opt(NL)\n            + OneOrMore(PEER + Group(blockStatementExpr) + Opt(NL))\n            + Opt(UNDENT)\n        )\n\n    # add a parse action to remove backup_stack from list of backups\n    smExpr.add_parse_action(\n        lambda: backup_stacks.pop(-1) and None if backup_stacks else None\n    )\n    smExpr.set_fail_action(lambda a, b, c, d: reset_stack())\n    blockStatementExpr.ignore(_bslash + LineEnd())\n    return smExpr.set_name(\"indented block\")\n\n\n# it's easy to get these comment structures wrong - they're very common, so may as well make them available\nc_style_comment = Combine(Regex(r\"/\\*(?:[^*]|\\*(?!/))*\") + \"*/\").set_name(\n    \"C style comment\"\n)\n\"Comment of the form ``/* ... */``\"\n\nhtml_comment = Regex(r\"<!--[\\s\\S]*?-->\").set_name(\"HTML comment\")\n\"Comment of the form ``<!-- ... -->``\"\n\nrest_of_line = Regex(r\".*\").leave_whitespace().set_name(\"rest of line\")\ndbl_slash_comment = Regex(r\"//(?:\\\\\\n|[^\\n])*\").set_name(\"// comment\")\n\"Comment of the form ``// ... (to end of line)``\"\n\ncpp_style_comment = Combine(\n    Regex(r\"/\\*(?:[^*]|\\*(?!/))*\") + \"*/\" | dbl_slash_comment\n).set_name(\"C++ style comment\")\n\"Comment of either form :class:`c_style_comment` or :class:`dbl_slash_comment`\"\n\njava_style_comment = cpp_style_comment\n\"Same as :class:`cpp_style_comment`\"\n\npython_style_comment = Regex(r\"#.*\").set_name(\"Python style comment\")\n\"Comment of the form ``# ... (to end of line)``\"\n\n\n# build list of built-in expressions, for future reference if a global default value\n# gets updated\n_builtin_exprs: List[ParserElement] = [\n    v for v in vars().values() if isinstance(v, ParserElement)\n]\n\n\n# compatibility function, superseded by DelimitedList class\ndef delimited_list(\n    expr: Union[str, ParserElement],\n    delim: Union[str, ParserElement] = \",\",\n    combine: bool = False,\n    min: typing.Optional[int] = None,\n    max: typing.Optional[int] = None,\n    *,\n    allow_trailing_delim: bool = False,\n) -> ParserElement:\n    \"\"\"(DEPRECATED - use :class:`DelimitedList` class)\"\"\"\n    return DelimitedList(\n        expr, delim, combine, min, max, allow_trailing_delim=allow_trailing_delim\n    )\n\n\n# Compatibility synonyms\n# fmt: off\nopAssoc = OpAssoc\nanyOpenTag = any_open_tag\nanyCloseTag = any_close_tag\ncommonHTMLEntity = common_html_entity\ncStyleComment = c_style_comment\nhtmlComment = html_comment\nrestOfLine = rest_of_line\ndblSlashComment = dbl_slash_comment\ncppStyleComment = cpp_style_comment\njavaStyleComment = java_style_comment\npythonStyleComment = python_style_comment\ndelimitedList = replaced_by_pep8(\"delimitedList\", DelimitedList)\ndelimited_list = replaced_by_pep8(\"delimited_list\", DelimitedList)\ncountedArray = replaced_by_pep8(\"countedArray\", counted_array)\nmatchPreviousLiteral = replaced_by_pep8(\"matchPreviousLiteral\", match_previous_literal)\nmatchPreviousExpr = replaced_by_pep8(\"matchPreviousExpr\", match_previous_expr)\noneOf = replaced_by_pep8(\"oneOf\", one_of)\ndictOf = replaced_by_pep8(\"dictOf\", dict_of)\noriginalTextFor = replaced_by_pep8(\"originalTextFor\", original_text_for)\nnestedExpr = replaced_by_pep8(\"nestedExpr\", nested_expr)\nmakeHTMLTags = replaced_by_pep8(\"makeHTMLTags\", make_html_tags)\nmakeXMLTags = replaced_by_pep8(\"makeXMLTags\", make_xml_tags)\nreplaceHTMLEntity = replaced_by_pep8(\"replaceHTMLEntity\", replace_html_entity)\ninfixNotation = replaced_by_pep8(\"infixNotation\", infix_notation)\n# fmt: on\n", "pyparsing/results.py": "# results.py\nfrom collections.abc import (\n    MutableMapping,\n    Mapping,\n    MutableSequence,\n    Iterator,\n    Sequence,\n    Container,\n)\nimport pprint\nfrom typing import Tuple, Any, Dict, Set, List\n\nfrom .util import replaced_by_pep8\n\n\nstr_type: Tuple[type, ...] = (str, bytes)\n_generator_type = type((_ for _ in ()))\n\n\nclass _ParseResultsWithOffset:\n    tup: Tuple[\"ParseResults\", int]\n    __slots__ = [\"tup\"]\n\n    def __init__(self, p1: \"ParseResults\", p2: int):\n        self.tup: Tuple[ParseResults, int] = (p1, p2)\n\n    def __getitem__(self, i):\n        return self.tup[i]\n\n    def __getstate__(self):\n        return self.tup\n\n    def __setstate__(self, *args):\n        self.tup = args[0]\n\n\nclass ParseResults:\n    \"\"\"Structured parse results, to provide multiple means of access to\n    the parsed data:\n\n    - as a list (``len(results)``)\n    - by list index (``results[0], results[1]``, etc.)\n    - by attribute (``results.<results_name>`` - see :class:`ParserElement.set_results_name`)\n\n    Example::\n\n        integer = Word(nums)\n        date_str = (integer.set_results_name(\"year\") + '/'\n                    + integer.set_results_name(\"month\") + '/'\n                    + integer.set_results_name(\"day\"))\n        # equivalent form:\n        # date_str = (integer(\"year\") + '/'\n        #             + integer(\"month\") + '/'\n        #             + integer(\"day\"))\n\n        # parse_string returns a ParseResults object\n        result = date_str.parse_string(\"1999/12/31\")\n\n        def test(s, fn=repr):\n            print(f\"{s} -> {fn(eval(s))}\")\n        test(\"list(result)\")\n        test(\"result[0]\")\n        test(\"result['month']\")\n        test(\"result.day\")\n        test(\"'month' in result\")\n        test(\"'minutes' in result\")\n        test(\"result.dump()\", str)\n\n    prints::\n\n        list(result) -> ['1999', '/', '12', '/', '31']\n        result[0] -> '1999'\n        result['month'] -> '12'\n        result.day -> '31'\n        'month' in result -> True\n        'minutes' in result -> False\n        result.dump() -> ['1999', '/', '12', '/', '31']\n        - day: '31'\n        - month: '12'\n        - year: '1999'\n    \"\"\"\n\n    _null_values: Tuple[Any, ...] = (None, [], ())\n\n    _name: str\n    _parent: \"ParseResults\"\n    _all_names: Set[str]\n    _modal: bool\n    _toklist: List[Any]\n    _tokdict: Dict[str, Any]\n\n    __slots__ = (\n        \"_name\",\n        \"_parent\",\n        \"_all_names\",\n        \"_modal\",\n        \"_toklist\",\n        \"_tokdict\",\n    )\n\n    class List(list):\n        \"\"\"\n        Simple wrapper class to distinguish parsed list results that should be preserved\n        as actual Python lists, instead of being converted to :class:`ParseResults`::\n\n            LBRACK, RBRACK = map(pp.Suppress, \"[]\")\n            element = pp.Forward()\n            item = ppc.integer\n            element_list = LBRACK + pp.DelimitedList(element) + RBRACK\n\n            # add parse actions to convert from ParseResults to actual Python collection types\n            def as_python_list(t):\n                return pp.ParseResults.List(t.as_list())\n            element_list.add_parse_action(as_python_list)\n\n            element <<= item | element_list\n\n            element.run_tests('''\n                100\n                [2,3,4]\n                [[2, 1],3,4]\n                [(2, 1),3,4]\n                (2,3,4)\n                ''', post_parse=lambda s, r: (r[0], type(r[0])))\n\n        prints::\n\n            100\n            (100, <class 'int'>)\n\n            [2,3,4]\n            ([2, 3, 4], <class 'list'>)\n\n            [[2, 1],3,4]\n            ([[2, 1], 3, 4], <class 'list'>)\n\n        (Used internally by :class:`Group` when `aslist=True`.)\n        \"\"\"\n\n        def __new__(cls, contained=None):\n            if contained is None:\n                contained = []\n\n            if not isinstance(contained, list):\n                raise TypeError(\n                    f\"{cls.__name__} may only be constructed with a list, not {type(contained).__name__}\"\n                )\n\n            return list.__new__(cls)\n\n    def __new__(cls, toklist=None, name=None, **kwargs):\n        if isinstance(toklist, ParseResults):\n            return toklist\n        self = object.__new__(cls)\n        self._name = None\n        self._parent = None\n        self._all_names = set()\n\n        if toklist is None:\n            self._toklist = []\n        elif isinstance(toklist, (list, _generator_type)):\n            self._toklist = (\n                [toklist[:]]\n                if isinstance(toklist, ParseResults.List)\n                else list(toklist)\n            )\n        else:\n            self._toklist = [toklist]\n        self._tokdict = dict()\n        return self\n\n    # Performance tuning: we construct a *lot* of these, so keep this\n    # constructor as small and fast as possible\n    def __init__(\n        self, toklist=None, name=None, asList=True, modal=True, isinstance=isinstance\n    ):\n        self._tokdict: Dict[str, _ParseResultsWithOffset]\n        self._modal = modal\n\n        if name is None or name == \"\":\n            return\n\n        if isinstance(name, int):\n            name = str(name)\n\n        if not modal:\n            self._all_names = {name}\n\n        self._name = name\n\n        if toklist in self._null_values:\n            return\n\n        if isinstance(toklist, (str_type, type)):\n            toklist = [toklist]\n\n        if asList:\n            if isinstance(toklist, ParseResults):\n                self[name] = _ParseResultsWithOffset(ParseResults(toklist._toklist), 0)\n            else:\n                self[name] = _ParseResultsWithOffset(ParseResults(toklist[0]), 0)\n            self[name]._name = name\n            return\n\n        try:\n            self[name] = toklist[0]\n        except (KeyError, TypeError, IndexError):\n            if toklist is not self:\n                self[name] = toklist\n            else:\n                self._name = name\n\n    def __getitem__(self, i):\n        if isinstance(i, (int, slice)):\n            return self._toklist[i]\n\n        if i not in self._all_names:\n            return self._tokdict[i][-1][0]\n\n        return ParseResults([v[0] for v in self._tokdict[i]])\n\n    def __setitem__(self, k, v, isinstance=isinstance):\n        if isinstance(v, _ParseResultsWithOffset):\n            self._tokdict[k] = self._tokdict.get(k, list()) + [v]\n            sub = v[0]\n        elif isinstance(k, (int, slice)):\n            self._toklist[k] = v\n            sub = v\n        else:\n            self._tokdict[k] = self._tokdict.get(k, list()) + [\n                _ParseResultsWithOffset(v, 0)\n            ]\n            sub = v\n        if isinstance(sub, ParseResults):\n            sub._parent = self\n\n    def __delitem__(self, i):\n        if not isinstance(i, (int, slice)):\n            del self._tokdict[i]\n            return\n\n        mylen = len(self._toklist)\n        del self._toklist[i]\n\n        # convert int to slice\n        if isinstance(i, int):\n            if i < 0:\n                i += mylen\n            i = slice(i, i + 1)\n        # get removed indices\n        removed = list(range(*i.indices(mylen)))\n        removed.reverse()\n        # fixup indices in token dictionary\n        for occurrences in self._tokdict.values():\n            for j in removed:\n                for k, (value, position) in enumerate(occurrences):\n                    occurrences[k] = _ParseResultsWithOffset(\n                        value, position - (position > j)\n                    )\n\n    def __contains__(self, k) -> bool:\n        return k in self._tokdict\n\n    def __len__(self) -> int:\n        return len(self._toklist)\n\n    def __bool__(self) -> bool:\n        return not not (self._toklist or self._tokdict)\n\n    def __iter__(self) -> Iterator:\n        return iter(self._toklist)\n\n    def __reversed__(self) -> Iterator:\n        return iter(self._toklist[::-1])\n\n    def keys(self):\n        return iter(self._tokdict)\n\n    def values(self):\n        return (self[k] for k in self.keys())\n\n    def items(self):\n        return ((k, self[k]) for k in self.keys())\n\n    def haskeys(self) -> bool:\n        \"\"\"\n        Since ``keys()`` returns an iterator, this method is helpful in bypassing\n        code that looks for the existence of any defined results names.\"\"\"\n        return not not self._tokdict\n\n    def pop(self, *args, **kwargs):\n        \"\"\"\n        Removes and returns item at specified index (default= ``last``).\n        Supports both ``list`` and ``dict`` semantics for ``pop()``. If\n        passed no argument or an integer argument, it will use ``list``\n        semantics and pop tokens from the list of parsed tokens. If passed\n        a non-integer argument (most likely a string), it will use ``dict``\n        semantics and pop the corresponding value from any defined results\n        names. A second default return value argument is supported, just as in\n        ``dict.pop()``.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            def remove_first(tokens):\n                tokens.pop(0)\n            numlist.add_parse_action(remove_first)\n            print(numlist.parse_string(\"0 123 321\")) # -> ['123', '321']\n\n            label = Word(alphas)\n            patt = label(\"LABEL\") + Word(nums)[1, ...]\n            print(patt.parse_string(\"AAB 123 321\").dump())\n\n            # Use pop() in a parse action to remove named result (note that corresponding value is not\n            # removed from list form of results)\n            def remove_LABEL(tokens):\n                tokens.pop(\"LABEL\")\n                return tokens\n            patt.add_parse_action(remove_LABEL)\n            print(patt.parse_string(\"AAB 123 321\").dump())\n\n        prints::\n\n            ['AAB', '123', '321']\n            - LABEL: 'AAB'\n\n            ['AAB', '123', '321']\n        \"\"\"\n        if not args:\n            args = [-1]\n        for k, v in kwargs.items():\n            if k == \"default\":\n                args = (args[0], v)\n            else:\n                raise TypeError(f\"pop() got an unexpected keyword argument {k!r}\")\n        if isinstance(args[0], int) or len(args) == 1 or args[0] in self:\n            index = args[0]\n            ret = self[index]\n            del self[index]\n            return ret\n        else:\n            defaultvalue = args[1]\n            return defaultvalue\n\n    def get(self, key, default_value=None):\n        \"\"\"\n        Returns named result matching the given key, or if there is no\n        such name, then returns the given ``default_value`` or ``None`` if no\n        ``default_value`` is specified.\n\n        Similar to ``dict.get()``.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string(\"1999/12/31\")\n            print(result.get(\"year\")) # -> '1999'\n            print(result.get(\"hour\", \"not specified\")) # -> 'not specified'\n            print(result.get(\"hour\")) # -> None\n        \"\"\"\n        if key in self:\n            return self[key]\n        else:\n            return default_value\n\n    def insert(self, index, ins_string):\n        \"\"\"\n        Inserts new element at location index in the list of parsed tokens.\n\n        Similar to ``list.insert()``.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            # use a parse action to insert the parse location in the front of the parsed results\n            def insert_locn(locn, tokens):\n                tokens.insert(0, locn)\n            numlist.add_parse_action(insert_locn)\n            print(numlist.parse_string(\"0 123 321\")) # -> [0, '0', '123', '321']\n        \"\"\"\n        self._toklist.insert(index, ins_string)\n        # fixup indices in token dictionary\n        for occurrences in self._tokdict.values():\n            for k, (value, position) in enumerate(occurrences):\n                occurrences[k] = _ParseResultsWithOffset(\n                    value, position + (position > index)\n                )\n\n    def append(self, item):\n        \"\"\"\n        Add single element to end of ``ParseResults`` list of elements.\n\n        Example::\n\n            numlist = Word(nums)[...]\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321']\n\n            # use a parse action to compute the sum of the parsed integers, and add it to the end\n            def append_sum(tokens):\n                tokens.append(sum(map(int, tokens)))\n            numlist.add_parse_action(append_sum)\n            print(numlist.parse_string(\"0 123 321\")) # -> ['0', '123', '321', 444]\n        \"\"\"\n        self._toklist.append(item)\n\n    def extend(self, itemseq):\n        \"\"\"\n        Add sequence of elements to end of ``ParseResults`` list of elements.\n\n        Example::\n\n            patt = Word(alphas)[1, ...]\n\n            # use a parse action to append the reverse of the matched strings, to make a palindrome\n            def make_palindrome(tokens):\n                tokens.extend(reversed([t[::-1] for t in tokens]))\n                return ''.join(tokens)\n            patt.add_parse_action(make_palindrome)\n            print(patt.parse_string(\"lskdj sdlkjf lksd\")) # -> 'lskdjsdlkjflksddsklfjkldsjdksl'\n        \"\"\"\n        if isinstance(itemseq, ParseResults):\n            self.__iadd__(itemseq)\n        else:\n            self._toklist.extend(itemseq)\n\n    def clear(self):\n        \"\"\"\n        Clear all elements and results names.\n        \"\"\"\n        del self._toklist[:]\n        self._tokdict.clear()\n\n    def __getattr__(self, name):\n        try:\n            return self[name]\n        except KeyError:\n            if name.startswith(\"__\"):\n                raise AttributeError(name)\n            return \"\"\n\n    def __add__(self, other: \"ParseResults\") -> \"ParseResults\":\n        ret = self.copy()\n        ret += other\n        return ret\n\n    def __iadd__(self, other: \"ParseResults\") -> \"ParseResults\":\n        if not other:\n            return self\n\n        if other._tokdict:\n            offset = len(self._toklist)\n            addoffset = lambda a: offset if a < 0 else a + offset\n            otheritems = other._tokdict.items()\n            otherdictitems = [\n                (k, _ParseResultsWithOffset(v[0], addoffset(v[1])))\n                for k, vlist in otheritems\n                for v in vlist\n            ]\n            for k, v in otherdictitems:\n                self[k] = v\n                if isinstance(v[0], ParseResults):\n                    v[0]._parent = self\n\n        self._toklist += other._toklist\n        self._all_names |= other._all_names\n        return self\n\n    def __radd__(self, other) -> \"ParseResults\":\n        if isinstance(other, int) and other == 0:\n            # useful for merging many ParseResults using sum() builtin\n            return self.copy()\n        else:\n            # this may raise a TypeError - so be it\n            return other + self\n\n    def __repr__(self) -> str:\n        return f\"{type(self).__name__}({self._toklist!r}, {self.as_dict()})\"\n\n    def __str__(self) -> str:\n        return (\n            \"[\"\n            + \", \".join(\n                [\n                    str(i) if isinstance(i, ParseResults) else repr(i)\n                    for i in self._toklist\n                ]\n            )\n            + \"]\"\n        )\n\n    def _asStringList(self, sep=\"\"):\n        out = []\n        for item in self._toklist:\n            if out and sep:\n                out.append(sep)\n            if isinstance(item, ParseResults):\n                out += item._asStringList()\n            else:\n                out.append(str(item))\n        return out\n\n    def as_list(self) -> list:\n        \"\"\"\n        Returns the parse results as a nested list of matching tokens, all converted to strings.\n\n        Example::\n\n            patt = Word(alphas)[1, ...]\n            result = patt.parse_string(\"sldkj lsdkj sldkj\")\n            # even though the result prints in string-like form, it is actually a pyparsing ParseResults\n            print(type(result), result) # -> <class 'pyparsing.ParseResults'> ['sldkj', 'lsdkj', 'sldkj']\n\n            # Use as_list() to create an actual list\n            result_list = result.as_list()\n            print(type(result_list), result_list) # -> <class 'list'> ['sldkj', 'lsdkj', 'sldkj']\n        \"\"\"\n        return [\n            res.as_list() if isinstance(res, ParseResults) else res\n            for res in self._toklist\n        ]\n\n    def as_dict(self) -> dict:\n        \"\"\"\n        Returns the named parse results as a nested dictionary.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string('12/31/1999')\n            print(type(result), repr(result)) # -> <class 'pyparsing.ParseResults'> (['12', '/', '31', '/', '1999'], {'day': [('1999', 4)], 'year': [('12', 0)], 'month': [('31', 2)]})\n\n            result_dict = result.as_dict()\n            print(type(result_dict), repr(result_dict)) # -> <class 'dict'> {'day': '1999', 'year': '12', 'month': '31'}\n\n            # even though a ParseResults supports dict-like access, sometime you just need to have a dict\n            import json\n            print(json.dumps(result)) # -> Exception: TypeError: ... is not JSON serializable\n            print(json.dumps(result.as_dict())) # -> {\"month\": \"31\", \"day\": \"1999\", \"year\": \"12\"}\n        \"\"\"\n\n        def to_item(obj):\n            if isinstance(obj, ParseResults):\n                return obj.as_dict() if obj.haskeys() else [to_item(v) for v in obj]\n            else:\n                return obj\n\n        return dict((k, to_item(v)) for k, v in self.items())\n\n    def copy(self) -> \"ParseResults\":\n        \"\"\"\n        Returns a new shallow copy of a :class:`ParseResults` object. `ParseResults`\n        items contained within the source are shared with the copy. Use\n        :class:`ParseResults.deepcopy()` to create a copy with its own separate\n        content values.\n        \"\"\"\n        ret = ParseResults(self._toklist)\n        ret._tokdict = self._tokdict.copy()\n        ret._parent = self._parent\n        ret._all_names |= self._all_names\n        ret._name = self._name\n        return ret\n\n    def deepcopy(self) -> \"ParseResults\":\n        \"\"\"\n        Returns a new deep copy of a :class:`ParseResults` object.\n        \"\"\"\n        ret = self.copy()\n        # replace values with copies if they are of known mutable types\n        for i, obj in enumerate(self._toklist):\n            if isinstance(obj, ParseResults):\n                self._toklist[i] = obj.deepcopy()\n            elif isinstance(obj, (str, bytes)):\n                pass\n            elif isinstance(obj, MutableMapping):\n                self._toklist[i] = dest = type(obj)()\n                for k, v in obj.items():\n                    dest[k] = v.deepcopy() if isinstance(v, ParseResults) else v\n            elif isinstance(obj, Container):\n                self._toklist[i] = type(obj)(\n                    v.deepcopy() if isinstance(v, ParseResults) else v for v in obj\n                )\n        return ret\n\n    def get_name(self):\n        r\"\"\"\n        Returns the results name for this token expression. Useful when several\n        different expressions might match at a particular location.\n\n        Example::\n\n            integer = Word(nums)\n            ssn_expr = Regex(r\"\\d\\d\\d-\\d\\d-\\d\\d\\d\\d\")\n            house_number_expr = Suppress('#') + Word(nums, alphanums)\n            user_data = (Group(house_number_expr)(\"house_number\")\n                        | Group(ssn_expr)(\"ssn\")\n                        | Group(integer)(\"age\"))\n            user_info = user_data[1, ...]\n\n            result = user_info.parse_string(\"22 111-22-3333 #221B\")\n            for item in result:\n                print(item.get_name(), ':', item[0])\n\n        prints::\n\n            age : 22\n            ssn : 111-22-3333\n            house_number : 221B\n        \"\"\"\n        if self._name:\n            return self._name\n        elif self._parent:\n            par: \"ParseResults\" = self._parent\n            parent_tokdict_items = par._tokdict.items()\n            return next(\n                (\n                    k\n                    for k, vlist in parent_tokdict_items\n                    for v, loc in vlist\n                    if v is self\n                ),\n                None,\n            )\n        elif (\n            len(self) == 1\n            and len(self._tokdict) == 1\n            and next(iter(self._tokdict.values()))[0][1] in (0, -1)\n        ):\n            return next(iter(self._tokdict.keys()))\n        else:\n            return None\n\n    def dump(self, indent=\"\", full=True, include_list=True, _depth=0) -> str:\n        \"\"\"\n        Diagnostic method for listing out the contents of\n        a :class:`ParseResults`. Accepts an optional ``indent`` argument so\n        that this string can be embedded in a nested display of other data.\n\n        Example::\n\n            integer = Word(nums)\n            date_str = integer(\"year\") + '/' + integer(\"month\") + '/' + integer(\"day\")\n\n            result = date_str.parse_string('1999/12/31')\n            print(result.dump())\n\n        prints::\n\n            ['1999', '/', '12', '/', '31']\n            - day: '31'\n            - month: '12'\n            - year: '1999'\n        \"\"\"\n        out = []\n        NL = \"\\n\"\n        out.append(indent + str(self.as_list()) if include_list else \"\")\n\n        if not full:\n            return \"\".join(out)\n\n        if self.haskeys():\n            items = sorted((str(k), v) for k, v in self.items())\n            for k, v in items:\n                if out:\n                    out.append(NL)\n                out.append(f\"{indent}{('  ' * _depth)}- {k}: \")\n                if not isinstance(v, ParseResults):\n                    out.append(repr(v))\n                    continue\n\n                if not v:\n                    out.append(str(v))\n                    continue\n\n                out.append(\n                    v.dump(\n                        indent=indent,\n                        full=full,\n                        include_list=include_list,\n                        _depth=_depth + 1,\n                    )\n                )\n        if not any(isinstance(vv, ParseResults) for vv in self):\n            return \"\".join(out)\n\n        v = self\n        incr = \"  \"\n        nl = \"\\n\"\n        for i, vv in enumerate(v):\n            if isinstance(vv, ParseResults):\n                vv_dump = vv.dump(\n                    indent=indent,\n                    full=full,\n                    include_list=include_list,\n                    _depth=_depth + 1,\n                )\n                out.append(\n                    f\"{nl}{indent}{incr * _depth}[{i}]:{nl}{indent}{incr * (_depth + 1)}{vv_dump}\"\n                )\n            else:\n                out.append(\n                    f\"{nl}{indent}{incr * _depth}[{i}]:{nl}{indent}{incr * (_depth + 1)}{vv}\"\n                )\n\n        return \"\".join(out)\n\n    def pprint(self, *args, **kwargs):\n        \"\"\"\n        Pretty-printer for parsed results as a list, using the\n        `pprint <https://docs.python.org/3/library/pprint.html>`_ module.\n        Accepts additional positional or keyword args as defined for\n        `pprint.pprint <https://docs.python.org/3/library/pprint.html#pprint.pprint>`_ .\n\n        Example::\n\n            ident = Word(alphas, alphanums)\n            num = Word(nums)\n            func = Forward()\n            term = ident | num | Group('(' + func + ')')\n            func <<= ident + Group(Optional(DelimitedList(term)))\n            result = func.parse_string(\"fna a,b,(fnb c,d,200),100\")\n            result.pprint(width=40)\n\n        prints::\n\n            ['fna',\n             ['a',\n              'b',\n              ['(', 'fnb', ['c', 'd', '200'], ')'],\n              '100']]\n        \"\"\"\n        pprint.pprint(self.as_list(), *args, **kwargs)\n\n    # add support for pickle protocol\n    def __getstate__(self):\n        return (\n            self._toklist,\n            (\n                self._tokdict.copy(),\n                None,\n                self._all_names,\n                self._name,\n            ),\n        )\n\n    def __setstate__(self, state):\n        self._toklist, (self._tokdict, par, inAccumNames, self._name) = state\n        self._all_names = set(inAccumNames)\n        self._parent = None\n\n    def __getnewargs__(self):\n        return self._toklist, self._name\n\n    def __dir__(self):\n        return dir(type(self)) + list(self.keys())\n\n    @classmethod\n    def from_dict(cls, other, name=None) -> \"ParseResults\":\n        \"\"\"\n        Helper classmethod to construct a ``ParseResults`` from a ``dict``, preserving the\n        name-value relations as results names. If an optional ``name`` argument is\n        given, a nested ``ParseResults`` will be returned.\n        \"\"\"\n\n        def is_iterable(obj):\n            try:\n                iter(obj)\n            except Exception:\n                return False\n            # str's are iterable, but in pyparsing, we don't want to iterate over them\n            else:\n                return not isinstance(obj, str_type)\n\n        ret = cls([])\n        for k, v in other.items():\n            if isinstance(v, Mapping):\n                ret += cls.from_dict(v, name=k)\n            else:\n                ret += cls([v], name=k, asList=is_iterable(v))\n        if name is not None:\n            ret = cls([ret], name=name)\n        return ret\n\n    asList = as_list\n    \"\"\"Deprecated - use :class:`as_list`\"\"\"\n    asDict = as_dict\n    \"\"\"Deprecated - use :class:`as_dict`\"\"\"\n    getName = get_name\n    \"\"\"Deprecated - use :class:`get_name`\"\"\"\n\n\nMutableMapping.register(ParseResults)\nMutableSequence.register(ParseResults)\n", "pyparsing/testing.py": "# testing.py\n\nfrom contextlib import contextmanager\nimport re\nimport typing\n\n\nfrom .core import (\n    ParserElement,\n    ParseException,\n    Keyword,\n    __diag__,\n    __compat__,\n)\n\n\nclass pyparsing_test:\n    \"\"\"\n    namespace class for classes useful in writing unit tests\n    \"\"\"\n\n    class reset_pyparsing_context:\n        \"\"\"\n        Context manager to be used when writing unit tests that modify pyparsing config values:\n        - packrat parsing\n        - bounded recursion parsing\n        - default whitespace characters.\n        - default keyword characters\n        - literal string auto-conversion class\n        - __diag__ settings\n\n        Example::\n\n            with reset_pyparsing_context():\n                # test that literals used to construct a grammar are automatically suppressed\n                ParserElement.inlineLiteralsUsing(Suppress)\n\n                term = Word(alphas) | Word(nums)\n                group = Group('(' + term[...] + ')')\n\n                # assert that the '()' characters are not included in the parsed tokens\n                self.assertParseAndCheckList(group, \"(abc 123 def)\", ['abc', '123', 'def'])\n\n            # after exiting context manager, literals are converted to Literal expressions again\n        \"\"\"\n\n        def __init__(self):\n            self._save_context = {}\n\n        def save(self):\n            self._save_context[\"default_whitespace\"] = ParserElement.DEFAULT_WHITE_CHARS\n            self._save_context[\"default_keyword_chars\"] = Keyword.DEFAULT_KEYWORD_CHARS\n\n            self._save_context[\"literal_string_class\"] = (\n                ParserElement._literalStringClass\n            )\n\n            self._save_context[\"verbose_stacktrace\"] = ParserElement.verbose_stacktrace\n\n            self._save_context[\"packrat_enabled\"] = ParserElement._packratEnabled\n            if ParserElement._packratEnabled:\n                self._save_context[\"packrat_cache_size\"] = (\n                    ParserElement.packrat_cache.size\n                )\n            else:\n                self._save_context[\"packrat_cache_size\"] = None\n            self._save_context[\"packrat_parse\"] = ParserElement._parse\n            self._save_context[\"recursion_enabled\"] = (\n                ParserElement._left_recursion_enabled\n            )\n\n            self._save_context[\"__diag__\"] = {\n                name: getattr(__diag__, name) for name in __diag__._all_names\n            }\n\n            self._save_context[\"__compat__\"] = {\n                \"collect_all_And_tokens\": __compat__.collect_all_And_tokens\n            }\n\n            return self\n\n        def restore(self):\n            # reset pyparsing global state\n            if (\n                ParserElement.DEFAULT_WHITE_CHARS\n                != self._save_context[\"default_whitespace\"]\n            ):\n                ParserElement.set_default_whitespace_chars(\n                    self._save_context[\"default_whitespace\"]\n                )\n\n            ParserElement.verbose_stacktrace = self._save_context[\"verbose_stacktrace\"]\n\n            Keyword.DEFAULT_KEYWORD_CHARS = self._save_context[\"default_keyword_chars\"]\n            ParserElement.inlineLiteralsUsing(\n                self._save_context[\"literal_string_class\"]\n            )\n\n            for name, value in self._save_context[\"__diag__\"].items():\n                (__diag__.enable if value else __diag__.disable)(name)\n\n            ParserElement._packratEnabled = False\n            if self._save_context[\"packrat_enabled\"]:\n                ParserElement.enable_packrat(self._save_context[\"packrat_cache_size\"])\n            else:\n                ParserElement._parse = self._save_context[\"packrat_parse\"]\n            ParserElement._left_recursion_enabled = self._save_context[\n                \"recursion_enabled\"\n            ]\n\n            __compat__.collect_all_And_tokens = self._save_context[\"__compat__\"]\n\n            return self\n\n        def copy(self):\n            ret = type(self)()\n            ret._save_context.update(self._save_context)\n            return ret\n\n        def __enter__(self):\n            return self.save()\n\n        def __exit__(self, *args):\n            self.restore()\n\n    class TestParseResultsAsserts:\n        \"\"\"\n        A mixin class to add parse results assertion methods to normal unittest.TestCase classes.\n        \"\"\"\n\n        def assertParseResultsEquals(\n            self, result, expected_list=None, expected_dict=None, msg=None\n        ):\n            \"\"\"\n            Unit test assertion to compare a :class:`ParseResults` object with an optional ``expected_list``,\n            and compare any defined results names with an optional ``expected_dict``.\n            \"\"\"\n            if expected_list is not None:\n                self.assertEqual(expected_list, result.as_list(), msg=msg)\n            if expected_dict is not None:\n                self.assertEqual(expected_dict, result.as_dict(), msg=msg)\n\n        def assertParseAndCheckList(\n            self, expr, test_string, expected_list, msg=None, verbose=True\n        ):\n            \"\"\"\n            Convenience wrapper assert to test a parser element and input string, and assert that\n            the resulting ``ParseResults.asList()`` is equal to the ``expected_list``.\n            \"\"\"\n            result = expr.parse_string(test_string, parse_all=True)\n            if verbose:\n                print(result.dump())\n            else:\n                print(result.as_list())\n            self.assertParseResultsEquals(result, expected_list=expected_list, msg=msg)\n\n        def assertParseAndCheckDict(\n            self, expr, test_string, expected_dict, msg=None, verbose=True\n        ):\n            \"\"\"\n            Convenience wrapper assert to test a parser element and input string, and assert that\n            the resulting ``ParseResults.asDict()`` is equal to the ``expected_dict``.\n            \"\"\"\n            result = expr.parse_string(test_string, parseAll=True)\n            if verbose:\n                print(result.dump())\n            else:\n                print(result.as_list())\n            self.assertParseResultsEquals(result, expected_dict=expected_dict, msg=msg)\n\n        def assertRunTestResults(\n            self, run_tests_report, expected_parse_results=None, msg=None\n        ):\n            \"\"\"\n            Unit test assertion to evaluate output of ``ParserElement.runTests()``. If a list of\n            list-dict tuples is given as the ``expected_parse_results`` argument, then these are zipped\n            with the report tuples returned by ``runTests`` and evaluated using ``assertParseResultsEquals``.\n            Finally, asserts that the overall ``runTests()`` success value is ``True``.\n\n            :param run_tests_report: tuple(bool, [tuple(str, ParseResults or Exception)]) returned from runTests\n            :param expected_parse_results (optional): [tuple(str, list, dict, Exception)]\n            \"\"\"\n            run_test_success, run_test_results = run_tests_report\n\n            if expected_parse_results is None:\n                self.assertTrue(\n                    run_test_success, msg=msg if msg is not None else \"failed runTests\"\n                )\n                return\n\n            merged = [\n                (*rpt, expected)\n                for rpt, expected in zip(run_test_results, expected_parse_results)\n            ]\n            for test_string, result, expected in merged:\n                # expected should be a tuple containing a list and/or a dict or an exception,\n                # and optional failure message string\n                # an empty tuple will skip any result validation\n                fail_msg = next((exp for exp in expected if isinstance(exp, str)), None)\n                expected_exception = next(\n                    (\n                        exp\n                        for exp in expected\n                        if isinstance(exp, type) and issubclass(exp, Exception)\n                    ),\n                    None,\n                )\n                if expected_exception is not None:\n                    with self.assertRaises(\n                        expected_exception=expected_exception, msg=fail_msg or msg\n                    ):\n                        if isinstance(result, Exception):\n                            raise result\n                else:\n                    expected_list = next(\n                        (exp for exp in expected if isinstance(exp, list)), None\n                    )\n                    expected_dict = next(\n                        (exp for exp in expected if isinstance(exp, dict)), None\n                    )\n                    if (expected_list, expected_dict) != (None, None):\n                        self.assertParseResultsEquals(\n                            result,\n                            expected_list=expected_list,\n                            expected_dict=expected_dict,\n                            msg=fail_msg or msg,\n                        )\n                    else:\n                        # warning here maybe?\n                        print(f\"no validation for {test_string!r}\")\n\n            # do this last, in case some specific test results can be reported instead\n            self.assertTrue(\n                run_test_success, msg=msg if msg is not None else \"failed runTests\"\n            )\n\n        @contextmanager\n        def assertRaisesParseException(\n            self, exc_type=ParseException, expected_msg=None, msg=None\n        ):\n            if expected_msg is not None:\n                if isinstance(expected_msg, str):\n                    expected_msg = re.escape(expected_msg)\n                with self.assertRaisesRegex(exc_type, expected_msg, msg=msg) as ctx:\n                    yield ctx\n\n            else:\n                with self.assertRaises(exc_type, msg=msg) as ctx:\n                    yield ctx\n\n    @staticmethod\n    def with_line_numbers(\n        s: str,\n        start_line: typing.Optional[int] = None,\n        end_line: typing.Optional[int] = None,\n        expand_tabs: bool = True,\n        eol_mark: str = \"|\",\n        mark_spaces: typing.Optional[str] = None,\n        mark_control: typing.Optional[str] = None,\n    ) -> str:\n        \"\"\"\n        Helpful method for debugging a parser - prints a string with line and column numbers.\n        (Line and column numbers are 1-based.)\n\n        :param s: tuple(bool, str - string to be printed with line and column numbers\n        :param start_line: int - (optional) starting line number in s to print (default=1)\n        :param end_line: int - (optional) ending line number in s to print (default=len(s))\n        :param expand_tabs: bool - (optional) expand tabs to spaces, to match the pyparsing default\n        :param eol_mark: str - (optional) string to mark the end of lines, helps visualize trailing spaces (default=\"|\")\n        :param mark_spaces: str - (optional) special character to display in place of spaces\n        :param mark_control: str - (optional) convert non-printing control characters to a placeholding\n                                 character; valid values:\n                                 - \"unicode\" - replaces control chars with Unicode symbols, such as \"\u240d\" and \"\u240a\"\n                                 - any single character string - replace control characters with given string\n                                 - None (default) - string is displayed as-is\n\n        :return: str - input string with leading line numbers and column number headers\n        \"\"\"\n        if expand_tabs:\n            s = s.expandtabs()\n        if mark_control is not None:\n            mark_control = typing.cast(str, mark_control)\n            if mark_control == \"unicode\":\n                transtable_map = {\n                    c: u for c, u in zip(range(0, 33), range(0x2400, 0x2433))\n                }\n                transtable_map[127] = 0x2421\n                tbl = str.maketrans(transtable_map)\n                eol_mark = \"\"\n            else:\n                ord_mark_control = ord(mark_control)\n                tbl = str.maketrans(\n                    {c: ord_mark_control for c in list(range(0, 32)) + [127]}\n                )\n            s = s.translate(tbl)\n        if mark_spaces is not None and mark_spaces != \" \":\n            if mark_spaces == \"unicode\":\n                tbl = str.maketrans({9: 0x2409, 32: 0x2423})\n                s = s.translate(tbl)\n            else:\n                s = s.replace(\" \", mark_spaces)\n        if start_line is None:\n            start_line = 1\n        if end_line is None:\n            end_line = len(s)\n        end_line = min(end_line, len(s))\n        start_line = min(max(1, start_line), end_line)\n\n        if mark_control != \"unicode\":\n            s_lines = s.splitlines()[start_line - 1 : end_line]\n        else:\n            s_lines = [line + \"\u240a\" for line in s.split(\"\u240a\")[start_line - 1 : end_line]]\n        if not s_lines:\n            return \"\"\n\n        lineno_width = len(str(end_line))\n        max_line_len = max(len(line) for line in s_lines)\n        lead = \" \" * (lineno_width + 1)\n        if max_line_len >= 99:\n            header0 = (\n                lead\n                + \"\".join(\n                    f\"{' ' * 99}{(i + 1) % 100}\"\n                    for i in range(max(max_line_len // 100, 1))\n                )\n                + \"\\n\"\n            )\n        else:\n            header0 = \"\"\n        header1 = (\n            header0\n            + lead\n            + \"\".join(f\"         {(i + 1) % 10}\" for i in range(-(-max_line_len // 10)))\n            + \"\\n\"\n        )\n        header2 = lead + \"1234567890\" * (-(-max_line_len // 10)) + \"\\n\"\n        return (\n            header1\n            + header2\n            + \"\\n\".join(\n                f\"{i:{lineno_width}d}:{line}{eol_mark}\"\n                for i, line in enumerate(s_lines, start=start_line)\n            )\n            + \"\\n\"\n        )\n", "pyparsing/unicode.py": "# unicode.py\n\nimport sys\nfrom itertools import filterfalse\nfrom typing import List, Tuple, Union\n\n\nclass _lazyclassproperty:\n    def __init__(self, fn):\n        self.fn = fn\n        self.__doc__ = fn.__doc__\n        self.__name__ = fn.__name__\n\n    def __get__(self, obj, cls):\n        if cls is None:\n            cls = type(obj)\n        if not hasattr(cls, \"_intern\") or any(\n            cls._intern is getattr(superclass, \"_intern\", [])\n            for superclass in cls.__mro__[1:]\n        ):\n            cls._intern = {}\n        attrname = self.fn.__name__\n        if attrname not in cls._intern:\n            cls._intern[attrname] = self.fn(cls)\n        return cls._intern[attrname]\n\n\nUnicodeRangeList = List[Union[Tuple[int, int], Tuple[int]]]\n\n\nclass unicode_set:\n    \"\"\"\n    A set of Unicode characters, for language-specific strings for\n    ``alphas``, ``nums``, ``alphanums``, and ``printables``.\n    A unicode_set is defined by a list of ranges in the Unicode character\n    set, in a class attribute ``_ranges``. Ranges can be specified using\n    2-tuples or a 1-tuple, such as::\n\n        _ranges = [\n            (0x0020, 0x007e),\n            (0x00a0, 0x00ff),\n            (0x0100,),\n            ]\n\n    Ranges are left- and right-inclusive. A 1-tuple of (x,) is treated as (x, x).\n\n    A unicode set can also be defined using multiple inheritance of other unicode sets::\n\n        class CJK(Chinese, Japanese, Korean):\n            pass\n    \"\"\"\n\n    _ranges: UnicodeRangeList = []\n\n    @_lazyclassproperty\n    def _chars_for_ranges(cls) -> List[str]:\n        ret = []\n        for cc in cls.__mro__:\n            if cc is unicode_set:\n                break\n            for rr in getattr(cc, \"_ranges\", ()):\n                ret.extend(range(rr[0], rr[-1] + 1))\n        return sorted(chr(c) for c in set(ret))\n\n    @_lazyclassproperty\n    def printables(cls) -> str:\n        \"\"\"all non-whitespace characters in this range\"\"\"\n        return \"\".join(filterfalse(str.isspace, cls._chars_for_ranges))\n\n    @_lazyclassproperty\n    def alphas(cls) -> str:\n        \"\"\"all alphabetic characters in this range\"\"\"\n        return \"\".join(filter(str.isalpha, cls._chars_for_ranges))\n\n    @_lazyclassproperty\n    def nums(cls) -> str:\n        \"\"\"all numeric digit characters in this range\"\"\"\n        return \"\".join(filter(str.isdigit, cls._chars_for_ranges))\n\n    @_lazyclassproperty\n    def alphanums(cls) -> str:\n        \"\"\"all alphanumeric characters in this range\"\"\"\n        return cls.alphas + cls.nums\n\n    @_lazyclassproperty\n    def identchars(cls) -> str:\n        \"\"\"all characters in this range that are valid identifier characters, plus underscore '_'\"\"\"\n        return \"\".join(\n            sorted(\n                set(filter(str.isidentifier, cls._chars_for_ranges))\n                | set(\n                    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u00aa\u00b5\u00ba\"\n                    \"\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd\u00de\u00df\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00fe\u00ff\"\n                    \"_\"\n                )\n            )\n        )\n\n    @_lazyclassproperty\n    def identbodychars(cls) -> str:\n        \"\"\"\n        all characters in this range that are valid identifier body characters,\n        plus the digits 0-9, and \u00b7 (Unicode MIDDLE DOT)\n        \"\"\"\n        identifier_chars = set(\n            c for c in cls._chars_for_ranges if (\"_\" + c).isidentifier()\n        )\n        return \"\".join(\n            sorted(identifier_chars | set(cls.identchars) | set(\"0123456789\u00b7\"))\n        )\n\n    @_lazyclassproperty\n    def identifier(cls):\n        \"\"\"\n        a pyparsing Word expression for an identifier using this range's definitions for\n        identchars and identbodychars\n        \"\"\"\n        from pyparsing import Word\n\n        return Word(cls.identchars, cls.identbodychars)\n\n\nclass pyparsing_unicode(unicode_set):\n    \"\"\"\n    A namespace class for defining common language unicode_sets.\n    \"\"\"\n\n    # fmt: off\n\n    # define ranges in language character sets\n    _ranges: UnicodeRangeList = [\n        (0x0020, sys.maxunicode),\n    ]\n\n    class BasicMultilingualPlane(unicode_set):\n        \"\"\"Unicode set for the Basic Multilingual Plane\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0020, 0xFFFF),\n        ]\n\n    class Latin1(unicode_set):\n        \"\"\"Unicode set for Latin-1 Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0020, 0x007E),\n            (0x00A0, 0x00FF),\n        ]\n\n    class LatinA(unicode_set):\n        \"\"\"Unicode set for Latin-A Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0100, 0x017F),\n        ]\n\n    class LatinB(unicode_set):\n        \"\"\"Unicode set for Latin-B Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0180, 0x024F),\n        ]\n\n    class Greek(unicode_set):\n        \"\"\"Unicode set for Greek Unicode Character Ranges\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0342, 0x0345),\n            (0x0370, 0x0377),\n            (0x037A, 0x037F),\n            (0x0384, 0x038A),\n            (0x038C,),\n            (0x038E, 0x03A1),\n            (0x03A3, 0x03E1),\n            (0x03F0, 0x03FF),\n            (0x1D26, 0x1D2A),\n            (0x1D5E,),\n            (0x1D60,),\n            (0x1D66, 0x1D6A),\n            (0x1F00, 0x1F15),\n            (0x1F18, 0x1F1D),\n            (0x1F20, 0x1F45),\n            (0x1F48, 0x1F4D),\n            (0x1F50, 0x1F57),\n            (0x1F59,),\n            (0x1F5B,),\n            (0x1F5D,),\n            (0x1F5F, 0x1F7D),\n            (0x1F80, 0x1FB4),\n            (0x1FB6, 0x1FC4),\n            (0x1FC6, 0x1FD3),\n            (0x1FD6, 0x1FDB),\n            (0x1FDD, 0x1FEF),\n            (0x1FF2, 0x1FF4),\n            (0x1FF6, 0x1FFE),\n            (0x2129,),\n            (0x2719, 0x271A),\n            (0xAB65,),\n            (0x10140, 0x1018D),\n            (0x101A0,),\n            (0x1D200, 0x1D245),\n            (0x1F7A1, 0x1F7A7),\n        ]\n\n    class Cyrillic(unicode_set):\n        \"\"\"Unicode set for Cyrillic Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0400, 0x052F),\n            (0x1C80, 0x1C88),\n            (0x1D2B,),\n            (0x1D78,),\n            (0x2DE0, 0x2DFF),\n            (0xA640, 0xA672),\n            (0xA674, 0xA69F),\n            (0xFE2E, 0xFE2F),\n        ]\n\n    class Chinese(unicode_set):\n        \"\"\"Unicode set for Chinese Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x2E80, 0x2E99),\n            (0x2E9B, 0x2EF3),\n            (0x31C0, 0x31E3),\n            (0x3400, 0x4DB5),\n            (0x4E00, 0x9FEF),\n            (0xA700, 0xA707),\n            (0xF900, 0xFA6D),\n            (0xFA70, 0xFAD9),\n            (0x16FE2, 0x16FE3),\n            (0x1F210, 0x1F212),\n            (0x1F214, 0x1F23B),\n            (0x1F240, 0x1F248),\n            (0x20000, 0x2A6D6),\n            (0x2A700, 0x2B734),\n            (0x2B740, 0x2B81D),\n            (0x2B820, 0x2CEA1),\n            (0x2CEB0, 0x2EBE0),\n            (0x2F800, 0x2FA1D),\n        ]\n\n    class Japanese(unicode_set):\n        \"\"\"Unicode set for Japanese Unicode Character Range, combining Kanji, Hiragana, and Katakana ranges\"\"\"\n\n        class Kanji(unicode_set):\n            \"Unicode set for Kanji Unicode Character Range\"\n            _ranges: UnicodeRangeList = [\n                (0x4E00, 0x9FBF),\n                (0x3000, 0x303F),\n            ]\n\n        class Hiragana(unicode_set):\n            \"\"\"Unicode set for Hiragana Unicode Character Range\"\"\"\n            _ranges: UnicodeRangeList = [\n                (0x3041, 0x3096),\n                (0x3099, 0x30A0),\n                (0x30FC,),\n                (0xFF70,),\n                (0x1B001,),\n                (0x1B150, 0x1B152),\n                (0x1F200,),\n            ]\n\n        class Katakana(unicode_set):\n            \"\"\"Unicode set for Katakana  Unicode Character Range\"\"\"\n            _ranges: UnicodeRangeList = [\n                (0x3099, 0x309C),\n                (0x30A0, 0x30FF),\n                (0x31F0, 0x31FF),\n                (0x32D0, 0x32FE),\n                (0xFF65, 0xFF9F),\n                (0x1B000,),\n                (0x1B164, 0x1B167),\n                (0x1F201, 0x1F202),\n                (0x1F213,),\n            ]\n\n        \u6f22\u5b57 = Kanji\n        \u30ab\u30bf\u30ab\u30ca = Katakana\n        \u3072\u3089\u304c\u306a = Hiragana\n\n        _ranges = (\n            Kanji._ranges\n            + Hiragana._ranges\n            + Katakana._ranges\n        )\n\n    class Hangul(unicode_set):\n        \"\"\"Unicode set for Hangul (Korean) Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x1100, 0x11FF),\n            (0x302E, 0x302F),\n            (0x3131, 0x318E),\n            (0x3200, 0x321C),\n            (0x3260, 0x327B),\n            (0x327E,),\n            (0xA960, 0xA97C),\n            (0xAC00, 0xD7A3),\n            (0xD7B0, 0xD7C6),\n            (0xD7CB, 0xD7FB),\n            (0xFFA0, 0xFFBE),\n            (0xFFC2, 0xFFC7),\n            (0xFFCA, 0xFFCF),\n            (0xFFD2, 0xFFD7),\n            (0xFFDA, 0xFFDC),\n        ]\n\n    Korean = Hangul\n\n    class CJK(Chinese, Japanese, Hangul):\n        \"\"\"Unicode set for combined Chinese, Japanese, and Korean (CJK) Unicode Character Range\"\"\"\n\n    class Thai(unicode_set):\n        \"\"\"Unicode set for Thai Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0E01, 0x0E3A),\n            (0x0E3F, 0x0E5B)\n        ]\n\n    class Arabic(unicode_set):\n        \"\"\"Unicode set for Arabic Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0600, 0x061B),\n            (0x061E, 0x06FF),\n            (0x0700, 0x077F),\n        ]\n\n    class Hebrew(unicode_set):\n        \"\"\"Unicode set for Hebrew Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0591, 0x05C7),\n            (0x05D0, 0x05EA),\n            (0x05EF, 0x05F4),\n            (0xFB1D, 0xFB36),\n            (0xFB38, 0xFB3C),\n            (0xFB3E,),\n            (0xFB40, 0xFB41),\n            (0xFB43, 0xFB44),\n            (0xFB46, 0xFB4F),\n        ]\n\n    class Devanagari(unicode_set):\n        \"\"\"Unicode set for Devanagari Unicode Character Range\"\"\"\n        _ranges: UnicodeRangeList = [\n            (0x0900, 0x097F),\n            (0xA8E0, 0xA8FF)\n        ]\n\n    BMP = BasicMultilingualPlane\n\n    # add language identifiers using language Unicode\n    \u0627\u0644\u0639\u0631\u0628\u064a\u0629 = Arabic\n    \u4e2d\u6587 = Chinese\n    \u043a\u0438\u0440\u0438\u043b\u043b\u0438\u0446\u0430 = Cyrillic\n    \u0395\u03bb\u03bb\u03b7\u03bd\u03b9\u03ba\u03ac = Greek\n    \u05e2\u05b4\u05d1\u05e8\u05b4\u05d9\u05ea = Hebrew\n    \u65e5\u672c\u8a9e = Japanese\n    \ud55c\uad6d\uc5b4 = Korean\n    \u0e44\u0e17\u0e22 = Thai\n    \u0926\u0947\u0935\u0928\u093e\u0917\u0930\u0940 = Devanagari\n\n    # fmt: on\n", "pyparsing/__init__.py": "# module pyparsing.py\n#\n# Copyright (c) 2003-2022  Paul T. McGuire\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n# IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#\n\n__doc__ = \"\"\"\npyparsing module - Classes and methods to define and execute parsing grammars\n=============================================================================\n\nThe pyparsing module is an alternative approach to creating and\nexecuting simple grammars, vs. the traditional lex/yacc approach, or the\nuse of regular expressions.  With pyparsing, you don't need to learn\na new syntax for defining grammars or matching expressions - the parsing\nmodule provides a library of classes that you use to construct the\ngrammar directly in Python.\n\nHere is a program to parse \"Hello, World!\" (or any greeting of the form\n``\"<salutation>, <addressee>!\"``), built up using :class:`Word`,\n:class:`Literal`, and :class:`And` elements\n(the :meth:`'+'<ParserElement.__add__>` operators create :class:`And` expressions,\nand the strings are auto-converted to :class:`Literal` expressions)::\n\n    from pyparsing import Word, alphas\n\n    # define grammar of a greeting\n    greet = Word(alphas) + \",\" + Word(alphas) + \"!\"\n\n    hello = \"Hello, World!\"\n    print(hello, \"->\", greet.parse_string(hello))\n\nThe program outputs the following::\n\n    Hello, World! -> ['Hello', ',', 'World', '!']\n\nThe Python representation of the grammar is quite readable, owing to the\nself-explanatory class names, and the use of :class:`'+'<And>`,\n:class:`'|'<MatchFirst>`, :class:`'^'<Or>` and :class:`'&'<Each>` operators.\n\nThe :class:`ParseResults` object returned from\n:class:`ParserElement.parse_string` can be\naccessed as a nested list, a dictionary, or an object with named\nattributes.\n\nThe pyparsing module handles some of the problems that are typically\nvexing when writing text parsers:\n\n  - extra or missing whitespace (the above program will also handle\n    \"Hello,World!\", \"Hello  ,  World  !\", etc.)\n  - quoted strings\n  - embedded comments\n\n\nGetting Started -\n-----------------\nVisit the classes :class:`ParserElement` and :class:`ParseResults` to\nsee the base classes that most other pyparsing\nclasses inherit from. Use the docstrings for examples of how to:\n\n - construct literal match expressions from :class:`Literal` and\n   :class:`CaselessLiteral` classes\n - construct character word-group expressions using the :class:`Word`\n   class\n - see how to create repetitive expressions using :class:`ZeroOrMore`\n   and :class:`OneOrMore` classes\n - use :class:`'+'<And>`, :class:`'|'<MatchFirst>`, :class:`'^'<Or>`,\n   and :class:`'&'<Each>` operators to combine simple expressions into\n   more complex ones\n - associate names with your parsed results using\n   :class:`ParserElement.set_results_name`\n - access the parsed data, which is returned as a :class:`ParseResults`\n   object\n - find some helpful expression short-cuts like :class:`DelimitedList`\n   and :class:`one_of`\n - find more useful common expressions in the :class:`pyparsing_common`\n   namespace class\n\"\"\"\nfrom typing import NamedTuple\n\n\nclass version_info(NamedTuple):\n    major: int\n    minor: int\n    micro: int\n    releaselevel: str\n    serial: int\n\n    @property\n    def __version__(self):\n        return (\n            f\"{self.major}.{self.minor}.{self.micro}\"\n            + (\n                f\"{'r' if self.releaselevel[0] == 'c' else ''}{self.releaselevel[0]}{self.serial}\",\n                \"\",\n            )[self.releaselevel == \"final\"]\n        )\n\n    def __str__(self):\n        return f\"{__name__} {self.__version__} / {__version_time__}\"\n\n    def __repr__(self):\n        return f\"{__name__}.{type(self).__name__}({', '.join('{}={!r}'.format(*nv) for nv in zip(self._fields, self))})\"\n\n\n__version_info__ = version_info(3, 1, 3, \"final\", 1)\n__version_time__ = \"09 Mar 2024 15:40 UTC\"\n__version__ = __version_info__.__version__\n__versionTime__ = __version_time__\n__author__ = \"Paul McGuire <ptmcg.gm+pyparsing@gmail.com>\"\n\nfrom .util import *\nfrom .exceptions import *\nfrom .actions import *\nfrom .core import __diag__, __compat__\nfrom .results import *\nfrom .core import *  # type: ignore[misc, assignment]\nfrom .core import _builtin_exprs as core_builtin_exprs\nfrom .helpers import *  # type: ignore[misc, assignment]\nfrom .helpers import _builtin_exprs as helper_builtin_exprs\n\nfrom .unicode import unicode_set, UnicodeRangeList, pyparsing_unicode as unicode\nfrom .testing import pyparsing_test as testing\nfrom .common import (\n    pyparsing_common as common,\n    _builtin_exprs as common_builtin_exprs,\n)\n\n# Compatibility synonyms\nif \"pyparsing_unicode\" not in globals():\n    pyparsing_unicode = unicode  # type: ignore[misc]\nif \"pyparsing_common\" not in globals():\n    pyparsing_common = common  # type: ignore[misc]\nif \"pyparsing_test\" not in globals():\n    pyparsing_test = testing  # type: ignore[misc]\n\ncore_builtin_exprs += common_builtin_exprs + helper_builtin_exprs\n\n\n__all__ = [\n    \"__version__\",\n    \"__version_time__\",\n    \"__author__\",\n    \"__compat__\",\n    \"__diag__\",\n    \"And\",\n    \"AtLineStart\",\n    \"AtStringStart\",\n    \"CaselessKeyword\",\n    \"CaselessLiteral\",\n    \"CharsNotIn\",\n    \"CloseMatch\",\n    \"Combine\",\n    \"DelimitedList\",\n    \"Dict\",\n    \"Each\",\n    \"Empty\",\n    \"FollowedBy\",\n    \"Forward\",\n    \"GoToColumn\",\n    \"Group\",\n    \"IndentedBlock\",\n    \"Keyword\",\n    \"LineEnd\",\n    \"LineStart\",\n    \"Literal\",\n    \"Located\",\n    \"PrecededBy\",\n    \"MatchFirst\",\n    \"NoMatch\",\n    \"NotAny\",\n    \"OneOrMore\",\n    \"OnlyOnce\",\n    \"OpAssoc\",\n    \"Opt\",\n    \"Optional\",\n    \"Or\",\n    \"ParseBaseException\",\n    \"ParseElementEnhance\",\n    \"ParseException\",\n    \"ParseExpression\",\n    \"ParseFatalException\",\n    \"ParseResults\",\n    \"ParseSyntaxException\",\n    \"ParserElement\",\n    \"PositionToken\",\n    \"QuotedString\",\n    \"RecursiveGrammarException\",\n    \"Regex\",\n    \"SkipTo\",\n    \"StringEnd\",\n    \"StringStart\",\n    \"Suppress\",\n    \"Token\",\n    \"TokenConverter\",\n    \"White\",\n    \"Word\",\n    \"WordEnd\",\n    \"WordStart\",\n    \"ZeroOrMore\",\n    \"Char\",\n    \"alphanums\",\n    \"alphas\",\n    \"alphas8bit\",\n    \"any_close_tag\",\n    \"any_open_tag\",\n    \"autoname_elements\",\n    \"c_style_comment\",\n    \"col\",\n    \"common_html_entity\",\n    \"condition_as_parse_action\",\n    \"counted_array\",\n    \"cpp_style_comment\",\n    \"dbl_quoted_string\",\n    \"dbl_slash_comment\",\n    \"delimited_list\",\n    \"dict_of\",\n    \"empty\",\n    \"hexnums\",\n    \"html_comment\",\n    \"identchars\",\n    \"identbodychars\",\n    \"infix_notation\",\n    \"java_style_comment\",\n    \"line\",\n    \"line_end\",\n    \"line_start\",\n    \"lineno\",\n    \"make_html_tags\",\n    \"make_xml_tags\",\n    \"match_only_at_col\",\n    \"match_previous_expr\",\n    \"match_previous_literal\",\n    \"nested_expr\",\n    \"null_debug_action\",\n    \"nums\",\n    \"one_of\",\n    \"original_text_for\",\n    \"printables\",\n    \"punc8bit\",\n    \"pyparsing_common\",\n    \"pyparsing_test\",\n    \"pyparsing_unicode\",\n    \"python_style_comment\",\n    \"quoted_string\",\n    \"remove_quotes\",\n    \"replace_with\",\n    \"replace_html_entity\",\n    \"rest_of_line\",\n    \"sgl_quoted_string\",\n    \"srange\",\n    \"string_end\",\n    \"string_start\",\n    \"token_map\",\n    \"trace_parse_action\",\n    \"ungroup\",\n    \"unicode_set\",\n    \"unicode_string\",\n    \"with_attribute\",\n    \"with_class\",\n    # pre-PEP8 compatibility names\n    \"__versionTime__\",\n    \"anyCloseTag\",\n    \"anyOpenTag\",\n    \"cStyleComment\",\n    \"commonHTMLEntity\",\n    \"conditionAsParseAction\",\n    \"countedArray\",\n    \"cppStyleComment\",\n    \"dblQuotedString\",\n    \"dblSlashComment\",\n    \"delimitedList\",\n    \"dictOf\",\n    \"htmlComment\",\n    \"indentedBlock\",\n    \"infixNotation\",\n    \"javaStyleComment\",\n    \"lineEnd\",\n    \"lineStart\",\n    \"locatedExpr\",\n    \"makeHTMLTags\",\n    \"makeXMLTags\",\n    \"matchOnlyAtCol\",\n    \"matchPreviousExpr\",\n    \"matchPreviousLiteral\",\n    \"nestedExpr\",\n    \"nullDebugAction\",\n    \"oneOf\",\n    \"opAssoc\",\n    \"originalTextFor\",\n    \"pythonStyleComment\",\n    \"quotedString\",\n    \"removeQuotes\",\n    \"replaceHTMLEntity\",\n    \"replaceWith\",\n    \"restOfLine\",\n    \"sglQuotedString\",\n    \"stringEnd\",\n    \"stringStart\",\n    \"tokenMap\",\n    \"traceParseAction\",\n    \"unicodeString\",\n    \"withAttribute\",\n    \"withClass\",\n    \"common\",\n    \"unicode\",\n    \"testing\",\n]\n", "pyparsing/diagram/__init__.py": "# mypy: ignore-errors\nimport railroad\nimport pyparsing\nimport typing\nfrom typing import (\n    List,\n    NamedTuple,\n    Generic,\n    TypeVar,\n    Dict,\n    Callable,\n    Set,\n    Iterable,\n)\nfrom jinja2 import Template\nfrom io import StringIO\nimport inspect\n\n\njinja2_template_source = \"\"\"\\\n{% if not embed %}\n<!DOCTYPE html>\n<html>\n<head>\n{% endif %}\n    {% if not head %}\n        <style>\n            .railroad-heading {\n                font-family: monospace;\n            }\n        </style>\n    {% else %}\n        {{ head | safe }}\n    {% endif %}\n{% if not embed %}\n</head>\n<body>\n{% endif %}\n{{ body | safe }}\n{% for diagram in diagrams %}\n    <div class=\"railroad-group\">\n        <h1 class=\"railroad-heading\">{{ diagram.title }}</h1>\n        <div class=\"railroad-description\">{{ diagram.text }}</div>\n        <div class=\"railroad-svg\">\n            {{ diagram.svg }}\n        </div>\n    </div>\n{% endfor %}\n{% if not embed %}\n</body>\n</html>\n{% endif %}\n\"\"\"\n\ntemplate = Template(jinja2_template_source)\n\n# Note: ideally this would be a dataclass, but we're supporting Python 3.5+ so we can't do this yet\nNamedDiagram = NamedTuple(\n    \"NamedDiagram\",\n    [(\"name\", str), (\"diagram\", typing.Optional[railroad.DiagramItem]), (\"index\", int)],\n)\n\"\"\"\nA simple structure for associating a name with a railroad diagram\n\"\"\"\n\nT = TypeVar(\"T\")\n\n\nclass EachItem(railroad.Group):\n    \"\"\"\n    Custom railroad item to compose a:\n    - Group containing a\n      - OneOrMore containing a\n        - Choice of the elements in the Each\n    with the group label indicating that all must be matched\n    \"\"\"\n\n    all_label = \"[ALL]\"\n\n    def __init__(self, *items):\n        choice_item = railroad.Choice(len(items) - 1, *items)\n        one_or_more_item = railroad.OneOrMore(item=choice_item)\n        super().__init__(one_or_more_item, label=self.all_label)\n\n\nclass AnnotatedItem(railroad.Group):\n    \"\"\"\n    Simple subclass of Group that creates an annotation label\n    \"\"\"\n\n    def __init__(self, label: str, item):\n        super().__init__(item=item, label=\"[{}]\".format(label) if label else label)\n\n\nclass EditablePartial(Generic[T]):\n    \"\"\"\n    Acts like a functools.partial, but can be edited. In other words, it represents a type that hasn't yet been\n    constructed.\n    \"\"\"\n\n    # We need this here because the railroad constructors actually transform the data, so can't be called until the\n    # entire tree is assembled\n\n    def __init__(self, func: Callable[..., T], args: list, kwargs: dict):\n        self.func = func\n        self.args = args\n        self.kwargs = kwargs\n\n    @classmethod\n    def from_call(cls, func: Callable[..., T], *args, **kwargs) -> \"EditablePartial[T]\":\n        \"\"\"\n        If you call this function in the same way that you would call the constructor, it will store the arguments\n        as you expect. For example EditablePartial.from_call(Fraction, 1, 3)() == Fraction(1, 3)\n        \"\"\"\n        return EditablePartial(func=func, args=list(args), kwargs=kwargs)\n\n    @property\n    def name(self):\n        return self.kwargs[\"name\"]\n\n    def __call__(self) -> T:\n        \"\"\"\n        Evaluate the partial and return the result\n        \"\"\"\n        args = self.args.copy()\n        kwargs = self.kwargs.copy()\n\n        # This is a helpful hack to allow you to specify varargs parameters (e.g. *args) as keyword args (e.g.\n        # args=['list', 'of', 'things'])\n        arg_spec = inspect.getfullargspec(self.func)\n        if arg_spec.varargs in self.kwargs:\n            args += kwargs.pop(arg_spec.varargs)\n\n        return self.func(*args, **kwargs)\n\n\ndef railroad_to_html(diagrams: List[NamedDiagram], embed=False, **kwargs) -> str:\n    \"\"\"\n    Given a list of NamedDiagram, produce a single HTML string that visualises those diagrams\n    :params kwargs: kwargs to be passed in to the template\n    \"\"\"\n    data = []\n    for diagram in diagrams:\n        if diagram.diagram is None:\n            continue\n        io = StringIO()\n        try:\n            css = kwargs.get('css')\n            diagram.diagram.writeStandalone(io.write, css=css)\n        except AttributeError:\n            diagram.diagram.writeSvg(io.write)\n        title = diagram.name\n        if diagram.index == 0:\n            title += \" (root)\"\n        data.append({\"title\": title, \"text\": \"\", \"svg\": io.getvalue()})\n\n    return template.render(diagrams=data, embed=embed, **kwargs)\n\n\ndef resolve_partial(partial: \"EditablePartial[T]\") -> T:\n    \"\"\"\n    Recursively resolves a collection of Partials into whatever type they are\n    \"\"\"\n    if isinstance(partial, EditablePartial):\n        partial.args = resolve_partial(partial.args)\n        partial.kwargs = resolve_partial(partial.kwargs)\n        return partial()\n    elif isinstance(partial, list):\n        return [resolve_partial(x) for x in partial]\n    elif isinstance(partial, dict):\n        return {key: resolve_partial(x) for key, x in partial.items()}\n    else:\n        return partial\n\n\ndef to_railroad(\n    element: pyparsing.ParserElement,\n    diagram_kwargs: typing.Optional[dict] = None,\n    vertical: int = 3,\n    show_results_names: bool = False,\n    show_groups: bool = False,\n) -> List[NamedDiagram]:\n    \"\"\"\n    Convert a pyparsing element tree into a list of diagrams. This is the recommended entrypoint to diagram\n    creation if you want to access the Railroad tree before it is converted to HTML\n    :param element: base element of the parser being diagrammed\n    :param diagram_kwargs: kwargs to pass to the Diagram() constructor\n    :param vertical: (optional) - int - limit at which number of alternatives should be\n       shown vertically instead of horizontally\n    :param show_results_names - bool to indicate whether results name annotations should be\n       included in the diagram\n    :param show_groups - bool to indicate whether groups should be highlighted with an unlabeled\n       surrounding box\n    \"\"\"\n    # Convert the whole tree underneath the root\n    lookup = ConverterState(diagram_kwargs=diagram_kwargs or {})\n    _to_diagram_element(\n        element,\n        lookup=lookup,\n        parent=None,\n        vertical=vertical,\n        show_results_names=show_results_names,\n        show_groups=show_groups,\n    )\n\n    root_id = id(element)\n    # Convert the root if it hasn't been already\n    if root_id in lookup:\n        if not element.customName:\n            lookup[root_id].name = \"\"\n        lookup[root_id].mark_for_extraction(root_id, lookup, force=True)\n\n    # Now that we're finished, we can convert from intermediate structures into Railroad elements\n    diags = list(lookup.diagrams.values())\n    if len(diags) > 1:\n        # collapse out duplicate diags with the same name\n        seen = set()\n        deduped_diags = []\n        for d in diags:\n            # don't extract SkipTo elements, they are uninformative as subdiagrams\n            if d.name == \"...\":\n                continue\n            if d.name is not None and d.name not in seen:\n                seen.add(d.name)\n                deduped_diags.append(d)\n        resolved = [resolve_partial(partial) for partial in deduped_diags]\n    else:\n        # special case - if just one diagram, always display it, even if\n        # it has no name\n        resolved = [resolve_partial(partial) for partial in diags]\n    return sorted(resolved, key=lambda diag: diag.index)\n\n\ndef _should_vertical(\n    specification: int, exprs: Iterable[pyparsing.ParserElement]\n) -> bool:\n    \"\"\"\n    Returns true if we should return a vertical list of elements\n    \"\"\"\n    if specification is None:\n        return False\n    else:\n        return len(_visible_exprs(exprs)) >= specification\n\n\nclass ElementState:\n    \"\"\"\n    State recorded for an individual pyparsing Element\n    \"\"\"\n\n    # Note: this should be a dataclass, but we have to support Python 3.5\n    def __init__(\n        self,\n        element: pyparsing.ParserElement,\n        converted: EditablePartial,\n        parent: EditablePartial,\n        number: int,\n        name: str = None,\n        parent_index: typing.Optional[int] = None,\n    ):\n        #: The pyparsing element that this represents\n        self.element: pyparsing.ParserElement = element\n        #: The name of the element\n        self.name: typing.Optional[str] = name\n        #: The output Railroad element in an unconverted state\n        self.converted: EditablePartial = converted\n        #: The parent Railroad element, which we store so that we can extract this if it's duplicated\n        self.parent: EditablePartial = parent\n        #: The order in which we found this element, used for sorting diagrams if this is extracted into a diagram\n        self.number: int = number\n        #: The index of this inside its parent\n        self.parent_index: typing.Optional[int] = parent_index\n        #: If true, we should extract this out into a subdiagram\n        self.extract: bool = False\n        #: If true, all of this element's children have been filled out\n        self.complete: bool = False\n\n    def mark_for_extraction(\n        self, el_id: int, state: \"ConverterState\", name: str = None, force: bool = False\n    ):\n        \"\"\"\n        Called when this instance has been seen twice, and thus should eventually be extracted into a sub-diagram\n        :param el_id: id of the element\n        :param state: element/diagram state tracker\n        :param name: name to use for this element's text\n        :param force: If true, force extraction now, regardless of the state of this. Only useful for extracting the\n        root element when we know we're finished\n        \"\"\"\n        self.extract = True\n\n        # Set the name\n        if not self.name:\n            if name:\n                # Allow forcing a custom name\n                self.name = name\n            elif self.element.customName:\n                self.name = self.element.customName\n            else:\n                self.name = \"\"\n\n        # Just because this is marked for extraction doesn't mean we can do it yet. We may have to wait for children\n        # to be added\n        # Also, if this is just a string literal etc, don't bother extracting it\n        if force or (self.complete and _worth_extracting(self.element)):\n            state.extract_into_diagram(el_id)\n\n\nclass ConverterState:\n    \"\"\"\n    Stores some state that persists between recursions into the element tree\n    \"\"\"\n\n    def __init__(self, diagram_kwargs: typing.Optional[dict] = None):\n        #: A dictionary mapping ParserElements to state relating to them\n        self._element_diagram_states: Dict[int, ElementState] = {}\n        #: A dictionary mapping ParserElement IDs to subdiagrams generated from them\n        self.diagrams: Dict[int, EditablePartial[NamedDiagram]] = {}\n        #: The index of the next unnamed element\n        self.unnamed_index: int = 1\n        #: The index of the next element. This is used for sorting\n        self.index: int = 0\n        #: Shared kwargs that are used to customize the construction of diagrams\n        self.diagram_kwargs: dict = diagram_kwargs or {}\n        self.extracted_diagram_names: Set[str] = set()\n\n    def __setitem__(self, key: int, value: ElementState):\n        self._element_diagram_states[key] = value\n\n    def __getitem__(self, key: int) -> ElementState:\n        return self._element_diagram_states[key]\n\n    def __delitem__(self, key: int):\n        del self._element_diagram_states[key]\n\n    def __contains__(self, key: int):\n        return key in self._element_diagram_states\n\n    def generate_unnamed(self) -> int:\n        \"\"\"\n        Generate a number used in the name of an otherwise unnamed diagram\n        \"\"\"\n        self.unnamed_index += 1\n        return self.unnamed_index\n\n    def generate_index(self) -> int:\n        \"\"\"\n        Generate a number used to index a diagram\n        \"\"\"\n        self.index += 1\n        return self.index\n\n    def extract_into_diagram(self, el_id: int):\n        \"\"\"\n        Used when we encounter the same token twice in the same tree. When this\n        happens, we replace all instances of that token with a terminal, and\n        create a new subdiagram for the token\n        \"\"\"\n        position = self[el_id]\n\n        # Replace the original definition of this element with a regular block\n        if position.parent:\n            ret = EditablePartial.from_call(railroad.NonTerminal, text=position.name)\n            if \"item\" in position.parent.kwargs:\n                position.parent.kwargs[\"item\"] = ret\n            elif \"items\" in position.parent.kwargs:\n                position.parent.kwargs[\"items\"][position.parent_index] = ret\n\n        # If the element we're extracting is a group, skip to its content but keep the title\n        if position.converted.func == railroad.Group:\n            content = position.converted.kwargs[\"item\"]\n        else:\n            content = position.converted\n\n        self.diagrams[el_id] = EditablePartial.from_call(\n            NamedDiagram,\n            name=position.name,\n            diagram=EditablePartial.from_call(\n                railroad.Diagram, content, **self.diagram_kwargs\n            ),\n            index=position.number,\n        )\n\n        del self[el_id]\n\n\ndef _worth_extracting(element: pyparsing.ParserElement) -> bool:\n    \"\"\"\n    Returns true if this element is worth having its own sub-diagram. Simply, if any of its children\n    themselves have children, then its complex enough to extract\n    \"\"\"\n    children = element.recurse()\n    return any(child.recurse() for child in children)\n\n\ndef _apply_diagram_item_enhancements(fn):\n    \"\"\"\n    decorator to ensure enhancements to a diagram item (such as results name annotations)\n    get applied on return from _to_diagram_element (we do this since there are several\n    returns in _to_diagram_element)\n    \"\"\"\n\n    def _inner(\n        element: pyparsing.ParserElement,\n        parent: typing.Optional[EditablePartial],\n        lookup: ConverterState = None,\n        vertical: int = None,\n        index: int = 0,\n        name_hint: str = None,\n        show_results_names: bool = False,\n        show_groups: bool = False,\n    ) -> typing.Optional[EditablePartial]:\n        ret = fn(\n            element,\n            parent,\n            lookup,\n            vertical,\n            index,\n            name_hint,\n            show_results_names,\n            show_groups,\n        )\n\n        # apply annotation for results name, if present\n        if show_results_names and ret is not None:\n            element_results_name = element.resultsName\n            if element_results_name:\n                # add \"*\" to indicate if this is a \"list all results\" name\n                element_results_name += \"\" if element.modalResults else \"*\"\n                ret = EditablePartial.from_call(\n                    railroad.Group, item=ret, label=element_results_name\n                )\n\n        return ret\n\n    return _inner\n\n\ndef _visible_exprs(exprs: Iterable[pyparsing.ParserElement]):\n    non_diagramming_exprs = (\n        pyparsing.ParseElementEnhance,\n        pyparsing.PositionToken,\n        pyparsing.And._ErrorStop,\n    )\n    return [\n        e\n        for e in exprs\n        if not (e.customName or e.resultsName or isinstance(e, non_diagramming_exprs))\n    ]\n\n\n@_apply_diagram_item_enhancements\ndef _to_diagram_element(\n    element: pyparsing.ParserElement,\n    parent: typing.Optional[EditablePartial],\n    lookup: ConverterState = None,\n    vertical: int = None,\n    index: int = 0,\n    name_hint: str = None,\n    show_results_names: bool = False,\n    show_groups: bool = False,\n) -> typing.Optional[EditablePartial]:\n    \"\"\"\n    Recursively converts a PyParsing Element to a railroad Element\n    :param lookup: The shared converter state that keeps track of useful things\n    :param index: The index of this element within the parent\n    :param parent: The parent of this element in the output tree\n    :param vertical: Controls at what point we make a list of elements vertical. If this is an integer (the default),\n    it sets the threshold of the number of items before we go vertical. If True, always go vertical, if False, never\n    do so\n    :param name_hint: If provided, this will override the generated name\n    :param show_results_names: bool flag indicating whether to add annotations for results names\n    :returns: The converted version of the input element, but as a Partial that hasn't yet been constructed\n    :param show_groups: bool flag indicating whether to show groups using bounding box\n    \"\"\"\n    exprs = element.recurse()\n    name = name_hint or element.customName or type(element).__name__\n\n    # Python's id() is used to provide a unique identifier for elements\n    el_id = id(element)\n\n    element_results_name = element.resultsName\n\n    # Here we basically bypass processing certain wrapper elements if they contribute nothing to the diagram\n    if not element.customName:\n        if isinstance(\n            element,\n            (\n                # pyparsing.TokenConverter,\n                # pyparsing.Forward,\n                pyparsing.Located,\n            ),\n        ):\n            # However, if this element has a useful custom name, and its child does not, we can pass it on to the child\n            if exprs:\n                if not exprs[0].customName:\n                    propagated_name = name\n                else:\n                    propagated_name = None\n\n                return _to_diagram_element(\n                    element.expr,\n                    parent=parent,\n                    lookup=lookup,\n                    vertical=vertical,\n                    index=index,\n                    name_hint=propagated_name,\n                    show_results_names=show_results_names,\n                    show_groups=show_groups,\n                )\n\n    # If the element isn't worth extracting, we always treat it as the first time we say it\n    if _worth_extracting(element):\n        if el_id in lookup:\n            # If we've seen this element exactly once before, we are only just now finding out that it's a duplicate,\n            # so we have to extract it into a new diagram.\n            looked_up = lookup[el_id]\n            looked_up.mark_for_extraction(el_id, lookup, name=name_hint)\n            ret = EditablePartial.from_call(railroad.NonTerminal, text=looked_up.name)\n            return ret\n\n        elif el_id in lookup.diagrams:\n            # If we have seen the element at least twice before, and have already extracted it into a subdiagram, we\n            # just put in a marker element that refers to the sub-diagram\n            ret = EditablePartial.from_call(\n                railroad.NonTerminal, text=lookup.diagrams[el_id].kwargs[\"name\"]\n            )\n            return ret\n\n    # Recursively convert child elements\n    # Here we find the most relevant Railroad element for matching pyparsing Element\n    # We use ``items=[]`` here to hold the place for where the child elements will go once created\n    if isinstance(element, pyparsing.And):\n        # detect And's created with ``expr*N`` notation - for these use a OneOrMore with a repeat\n        # (all will have the same name, and resultsName)\n        if not exprs:\n            return None\n        if len(set((e.name, e.resultsName) for e in exprs)) == 1:\n            ret = EditablePartial.from_call(\n                railroad.OneOrMore, item=\"\", repeat=str(len(exprs))\n            )\n        elif _should_vertical(vertical, exprs):\n            ret = EditablePartial.from_call(railroad.Stack, items=[])\n        else:\n            ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    elif isinstance(element, (pyparsing.Or, pyparsing.MatchFirst)):\n        if not exprs:\n            return None\n        if _should_vertical(vertical, exprs):\n            ret = EditablePartial.from_call(railroad.Choice, 0, items=[])\n        else:\n            ret = EditablePartial.from_call(railroad.HorizontalChoice, items=[])\n    elif isinstance(element, pyparsing.Each):\n        if not exprs:\n            return None\n        ret = EditablePartial.from_call(EachItem, items=[])\n    elif isinstance(element, pyparsing.NotAny):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"NOT\", item=\"\")\n    elif isinstance(element, pyparsing.FollowedBy):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"LOOKAHEAD\", item=\"\")\n    elif isinstance(element, pyparsing.PrecededBy):\n        ret = EditablePartial.from_call(AnnotatedItem, label=\"LOOKBEHIND\", item=\"\")\n    elif isinstance(element, pyparsing.Group):\n        if show_groups:\n            ret = EditablePartial.from_call(AnnotatedItem, label=\"\", item=\"\")\n        else:\n            ret = EditablePartial.from_call(railroad.Group, label=\"\", item=\"\")\n    elif isinstance(element, pyparsing.TokenConverter):\n        label = type(element).__name__.lower()\n        if label == \"tokenconverter\":\n            ret = EditablePartial.from_call(railroad.Sequence, items=[])\n        else:\n            ret = EditablePartial.from_call(AnnotatedItem, label=label, item=\"\")\n    elif isinstance(element, pyparsing.Opt):\n        ret = EditablePartial.from_call(railroad.Optional, item=\"\")\n    elif isinstance(element, pyparsing.OneOrMore):\n        if element.not_ender is not None:\n            args = [\n                parent,\n                lookup,\n                vertical,\n                index,\n                name_hint,\n                show_results_names,\n                show_groups,\n            ]\n            return _to_diagram_element(\n                (~element.not_ender.expr\n                 + element.expr)[1, ...].set_name(element.name),\n                *args,\n            )\n        ret = EditablePartial.from_call(railroad.OneOrMore, item=None)\n    elif isinstance(element, pyparsing.ZeroOrMore):\n        if element.not_ender is not None:\n            args = [\n                parent,\n                lookup,\n                vertical,\n                index,\n                name_hint,\n                show_results_names,\n                show_groups,\n            ]\n            return _to_diagram_element(\n                (~element.not_ender.expr\n                 + element.expr)[...].set_name(element.name),\n                *args\n            )\n        ret = EditablePartial.from_call(railroad.ZeroOrMore, item=\"\")\n    elif isinstance(element, pyparsing.Group):\n        ret = EditablePartial.from_call(\n            railroad.Group, item=None, label=element_results_name\n        )\n    elif isinstance(element, pyparsing.Empty) and not element.customName:\n        # Skip unnamed \"Empty\" elements\n        ret = None\n    elif isinstance(element, pyparsing.ParseElementEnhance):\n        ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    elif len(exprs) > 0 and not element_results_name:\n        ret = EditablePartial.from_call(railroad.Group, item=\"\", label=name)\n    elif len(exprs) > 0:\n        ret = EditablePartial.from_call(railroad.Sequence, items=[])\n    else:\n        terminal = EditablePartial.from_call(railroad.Terminal, element.defaultName)\n        ret = terminal\n\n    if ret is None:\n        return\n\n    # Indicate this element's position in the tree so we can extract it if necessary\n    lookup[el_id] = ElementState(\n        element=element,\n        converted=ret,\n        parent=parent,\n        parent_index=index,\n        number=lookup.generate_index(),\n    )\n    if element.customName:\n        lookup[el_id].mark_for_extraction(el_id, lookup, element.customName)\n\n    i = 0\n    for expr in exprs:\n        # Add a placeholder index in case we have to extract the child before we even add it to the parent\n        if \"items\" in ret.kwargs:\n            ret.kwargs[\"items\"].insert(i, None)\n\n        item = _to_diagram_element(\n            expr,\n            parent=ret,\n            lookup=lookup,\n            vertical=vertical,\n            index=i,\n            show_results_names=show_results_names,\n            show_groups=show_groups,\n        )\n\n        # Some elements don't need to be shown in the diagram\n        if item is not None:\n            if \"item\" in ret.kwargs:\n                ret.kwargs[\"item\"] = item\n            elif \"items\" in ret.kwargs:\n                # If we've already extracted the child, don't touch this index, since it's occupied by a nonterminal\n                ret.kwargs[\"items\"][i] = item\n                i += 1\n        elif \"items\" in ret.kwargs:\n            # If we're supposed to skip this element, remove it from the parent\n            del ret.kwargs[\"items\"][i]\n\n    # If all this items children are none, skip this item\n    if ret and (\n        (\"items\" in ret.kwargs and len(ret.kwargs[\"items\"]) == 0)\n        or (\"item\" in ret.kwargs and ret.kwargs[\"item\"] is None)\n    ):\n        ret = EditablePartial.from_call(railroad.Terminal, name)\n\n    # Mark this element as \"complete\", ie it has all of its children\n    if el_id in lookup:\n        lookup[el_id].complete = True\n\n    if el_id in lookup and lookup[el_id].extract and lookup[el_id].complete:\n        lookup.extract_into_diagram(el_id)\n        if ret is not None:\n            ret = EditablePartial.from_call(\n                railroad.NonTerminal, text=lookup.diagrams[el_id].kwargs[\"name\"]\n            )\n\n    return ret\n", "examples/simpleWiki.py": "from pyparsing import *\n\nwikiInput = \"\"\"\nHere is a simple Wiki input:\n  *This is in italics.*\n  **This is in bold!**\n  ***This is in bold italics!***\n  Here's a URL to {{Pyparsing's Wiki Page->https://site-closed.wikispaces.com}}\n\"\"\"\n\n\ndef convertToHTML(opening, closing):\n    def conversionParseAction(s, l, t):\n        return opening + t[0] + closing\n\n    return conversionParseAction\n\n\nitalicized = QuotedString(\"*\").setParseAction(convertToHTML(\"<I>\", \"</I>\"))\nbolded = QuotedString(\"**\").setParseAction(convertToHTML(\"<B>\", \"</B>\"))\nboldItalicized = QuotedString(\"***\").setParseAction(convertToHTML(\"<B><I>\", \"</I></B>\"))\n\n\ndef convertToHTML_A(s, l, t):\n    try:\n        text, url = t[0].split(\"->\")\n    except ValueError:\n        raise ParseFatalException(s, l, \"invalid URL link reference: \" + t[0])\n    return '<A href=\"{}\">{}</A>'.format(url, text)\n\n\nurlRef = QuotedString(\"{{\", endQuoteChar=\"}}\").setParseAction(convertToHTML_A)\n\nwikiMarkup = urlRef | boldItalicized | bolded | italicized\n\nprint(wikiInput)\nprint()\nprint(wikiMarkup.transformString(wikiInput))\n", "examples/configParse.py": "#\n# configparse.py\n#\n# an example of using the parsing module to be able to process a .INI configuration file\n#\n# Copyright (c) 2003, Paul McGuire\n#\n\nfrom pyparsing import (\n    Literal,\n    Word,\n    ZeroOrMore,\n    Group,\n    Dict,\n    Optional,\n    printables,\n    ParseException,\n    restOfLine,\n    empty,\n)\nimport pprint\n\n\ninibnf = None\n\n\ndef inifile_BNF():\n    global inibnf\n\n    if not inibnf:\n\n        # punctuation\n        lbrack = Literal(\"[\").suppress()\n        rbrack = Literal(\"]\").suppress()\n        equals = Literal(\"=\").suppress()\n        semi = Literal(\";\")\n\n        comment = semi + Optional(restOfLine)\n\n        nonrbrack = \"\".join([c for c in printables if c != \"]\"]) + \" \\t\"\n        nonequals = \"\".join([c for c in printables if c != \"=\"]) + \" \\t\"\n\n        sectionDef = lbrack + Word(nonrbrack) + rbrack\n        keyDef = ~lbrack + Word(nonequals) + equals + empty + restOfLine\n        # strip any leading or trailing blanks from key\n        def stripKey(tokens):\n            tokens[0] = tokens[0].strip()\n\n        keyDef.setParseAction(stripKey)\n\n        # using Dict will allow retrieval of named data fields as attributes of the parsed results\n        inibnf = Dict(ZeroOrMore(Group(sectionDef + Dict(ZeroOrMore(Group(keyDef))))))\n\n        inibnf.ignore(comment)\n\n    return inibnf\n\n\npp = pprint.PrettyPrinter(2)\n\n\ndef test(strng):\n    print(strng)\n    try:\n        iniFile = open(strng)\n        iniData = \"\".join(iniFile.readlines())\n        bnf = inifile_BNF()\n        tokens = bnf.parseString(iniData)\n        pp.pprint(tokens.asList())\n\n    except ParseException as err:\n        print(err.line)\n        print(\" \" * (err.column - 1) + \"^\")\n        print(err)\n\n    iniFile.close()\n    print()\n    return tokens\n\n\nif __name__ == \"__main__\":\n    ini = test(\"setup.ini\")\n    print(\"ini['Startup']['modemid'] =\", ini[\"Startup\"][\"modemid\"])\n    print(\"ini.Startup =\", ini.Startup)\n    print(\"ini.Startup.modemid =\", ini.Startup.modemid)\n", "examples/delta_time.py": "# delta_time.py\n#\n# Parser to convert a conversational time reference such as \"in a minute\" or\n# \"noon tomorrow\" and convert it to a Python datetime. The returned\n# ParseResults object contains\n#   - original - the original time expression string\n#   - computed_dt - the Python datetime representing the computed time\n#   - relative_to - the reference \"now\" time\n#   - time_offset - the difference between the reference time and the computed time\n#\n# BNF:\n#     time_and_day ::= time_reference [day_reference] | day_reference 'at' absolute_time_of_day\n#     day_reference ::= absolute_day_reference | relative_day_reference\n#     absolute_day_reference ::= 'today' | 'tomorrow' | 'yesterday' | ['next' | 'last'] weekday_name\n#        (if weekday_name is given and is the same as the reference weekday:\n#            if 'next' is given, use 7 days after the reference time\n#            else if 'last' is given, use 7 days before the reference time\n#            else, use the reference time)\n#\n#     relative_day_reference ::= 'in' qty day_units\n#                                | qty day_units 'ago'\n#                                | 'qty day_units ('from' | 'before' | 'after') absolute_day_reference\n#     day_units ::= 'days' | 'weeks'\n#\n#     time_reference ::= absolute_time_of_day | relative_time_reference\n#     relative_time_reference ::= qty time_units ('from' | 'before' | 'after') absolute_time_of_day\n#                                 | qty time_units 'ago'\n#                                 | 'in' qty time_units\n#     time_units ::= 'hours' | 'minutes' | 'seconds'\n#     absolute_time_of_day ::= 'noon' | 'midnight' | 'now' | absolute_time\n#     absolute_time ::=  24hour_time | hour (\"o'clock\" | ':' minute) ('AM'|'PM')\n#\n#     qty ::= integer | integer_words | 'a couple of' | 'a' | 'the'\n#     weekday_name ::= 'Monday' | ... | 'Sunday'\n#\n# Copyright 2010, 2019 by Paul McGuire\n#\n\nimport calendar\nfrom datetime import datetime, time as datetime_time, timedelta\n\nimport pyparsing as pp\n\n__all__ = [\"time_expression\"]\n\n\n_WEEKDAY_NAMES = list(calendar.day_name)\n_DAY_NUM_BY_NAME = {d: i for i, d in enumerate(_WEEKDAY_NAMES)}\n\n\n# basic grammar definitions\ndef _make_integer_word_expr(int_name: str, int_value: int) -> pp.CaselessKeyword:\n    return pp.CaselessKeyword(\n        int_name, ident_chars=pp.srange(\"[A-Za-z-]\")\n    ).add_parse_action(pp.replace_with(int_value))\n\n\ninteger_word = pp.MatchFirst(\n    _make_integer_word_expr(int_str, int_value)\n    for int_value, int_str in enumerate(\n        \"one two three four five six seven eight nine ten\"\n        \" eleven twelve thirteen fourteen fifteen sixteen\"\n        \" seventeen eighteen nineteen twenty twenty-one\"\n        \" twenty-two twenty-three twenty-four\".split(),\n        start=1,\n    )\n).set_name(\"integer_word\")\n\ninteger = pp.pyparsing_common.integer | integer_word\ninteger.set_name(\"numeric\")\n\nCK = pp.CaselessKeyword\nCL = pp.CaselessLiteral\ntoday, tomorrow, yesterday, noon, midnight, now = CK.using_each(\n    \"today tomorrow yesterday noon midnight now\".split()\n)\n\n\ndef _now():\n    return datetime.now().replace(microsecond=0)\n\n\ndef _singular_or_plural(s: str) -> pp.ParserElement:\n    return CK(s) | CK(s + \"s\").add_parse_action(pp.replace_with(s))\n\n\nweek, day, hour, minute, second = map(\n    _singular_or_plural, \"week day hour minute second\".split()\n)\ntime_units = hour | minute | second\nany_time_units = (week | day | time_units).set_name(\"any_time_units\")\n\nam = CL(\"am\")\npm = CL(\"pm\")\nCOLON = pp.Suppress(\":\")\n\nin_ = CK(\"in\").set_parse_action(pp.replace_with(1))\nfrom_ = CK(\"from\").set_parse_action(pp.replace_with(1))\nbefore = CK(\"before\").set_parse_action(pp.replace_with(-1))\nafter = CK(\"after\").set_parse_action(pp.replace_with(1))\nago = CK(\"ago\").set_parse_action(pp.replace_with(-1))\nnext_ = CK(\"next\").set_parse_action(\n    pp.replace_with(1), lambda t: t.__setitem__(\"next_present\", True)\n)\nlast_ = CK(\"last\").set_parse_action(pp.replace_with(-1))\nat_ = CK(\"at\")\non_ = CK(\"on\")\na_ = CK(\"a\")\nan_ = CK(\"an\")\nof_ = CK(\"of\")\nthe_ = CK(\"the\")\nadverb_ = pp.MatchFirst(CK.using_each(\"just only exactly\".split())).suppress()\n\ncouple = (\n    (pp.Opt(CK(\"a\")) + CK(\"couple\") + pp.Opt(CK(\"of\")))\n    .set_parse_action(pp.replace_with(2))\n    .set_name(\"couple\")\n)\n\na_qty = (a_ | an_).set_parse_action(pp.replace_with(1))\nthe_qty = the_.set_parse_action(pp.replace_with(1))\nqty = pp.ungroup(\n    (pp.Opt(adverb_) + (integer | couple | a_qty | the_qty)).set_name(\"qty_expression\")\n).set_name(\"qty\")\ntime_ref_present = pp.Empty().add_parse_action(pp.replace_with(True))(\n    \"time_ref_present\"\n)\n\n# get weekday names from the calendar module\nweekday_names = list(calendar.day_name)\nweekday_name = pp.MatchFirst(CK.using_each(weekday_names)).set_name(\"weekday_name\")\n\n# expressions for military 2400 time\n_24hour_time = ~(pp.Word(pp.nums) + any_time_units).set_name(\n    \"numbered_time_units\"\n) + pp.Word(pp.nums, exact=4, as_keyword=True).set_name(\"HHMM\").add_parse_action(\n    lambda t: [int(t[0][:2]), int(t[0][2:])]\n)\n_24hour_time.set_name(\"0000 time\")\n\n@_24hour_time.add_parse_action\ndef _fill_24hr_time_fields(t: pp.ParseResults) -> None:\n    t[\"HH\"] = t[0]\n    t[\"MM\"] = t[1]\n    t[\"SS\"] = 0\n    t[\"ampm\"] = \"am\" if t.HH < 12 else \"pm\"\n\nampm = am | pm\no_clock = CK(\"o'clock\", ident_chars=pp.srange(\"[A-Za-z']\"))\ntimespec = (\n    integer(\"HH\")\n    + pp.Opt(o_clock | COLON + integer(\"MM\") + pp.Opt(COLON + integer(\"SS\")))\n    + (am | pm)(\"ampm\")\n)\n\n@timespec.add_parse_action\ndef _fill_default_time_fields(t: pp.ParseResults) -> None:\n    for fld in \"HH MM SS\".split():\n        if fld not in t:\n            t[fld] = 0\n\n\nabsolute_time = _24hour_time | timespec\nabsolute_time.set_name(\"absolute time\")\n\nabsolute_time_of_day = noon | midnight | now | absolute_time\nabsolute_time_of_day.set_name(\"time of day\")\n\n@absolute_time_of_day.add_parse_action\ndef _add_computed_time(t: pp.ParseResults) -> None:\n    initial_word = t[0]\n    if initial_word in \"now noon midnight\".split():\n        t[\"computed_time\"] = {\n            \"now\": _now().time(),\n            \"noon\": datetime_time(hour=12),\n            \"midnight\": datetime_time(hour=0),\n        }[initial_word]\n    else:\n        t[\"HH\"] = {\"am\": int(t[\"HH\"]) % 12, \"pm\": int(t[\"HH\"]) % 12 + 12}[t.ampm]\n        t[\"computed_time\"] = datetime_time(hour=t.HH, minute=t.MM, second=t.SS)\n\n\n#     relative_time_reference ::= qty time_units ('ago' | ('from' | 'before' | 'after') absolute_time_of_day)\n#                                 | 'in' qty time_units\ntime_units = (hour | minute | second).set_name(\"time unit\")\nrelative_time_reference = (\n    (\n        qty(\"qty\")\n        + time_units(\"units\")\n        + (\n            ago(\"dir\")\n            | (from_ | before | after)(\"dir\")\n            + pp.Group(absolute_time_of_day)(\"ref_time\")\n        )\n    )\n    | in_(\"dir\") + qty(\"qty\") + time_units(\"units\")\n).set_name(\"relative time\")\n\n@relative_time_reference.add_parse_action\ndef _compute_relative_time(t: pp.ParseResults) -> None:\n    if \"ref_time\" not in t:\n        t[\"ref_time\"] = _now().time().replace(microsecond=0)\n    else:\n        t[\"ref_time\"] = t.ref_time.computed_time\n    delta_seconds = {\"hour\": 3600, \"minute\": 60, \"second\": 1}[t.units] * t.qty\n    t[\"time_delta\"] = timedelta(seconds=t.dir * delta_seconds)\n\n\ntime_reference = absolute_time_of_day | relative_time_reference\ntime_reference.set_name(\"time reference\")\n\n@time_reference.add_parse_action\ndef _add_default_time_ref_fields(t: pp.ParseResults) -> None:\n    if \"time_delta\" not in t:\n        t[\"time_delta\"] = timedelta()\n\n\n#     absolute_day_reference ::= 'today' | 'tomorrow' | 'yesterday' | ('next' | 'last') weekday_name\n#     day_units ::= 'days' | 'weeks'\n\nday_units = day | week\nweekday_reference = pp.Opt(next_ | last_, 1)(\"dir\") + weekday_name(\"day_name\")\n\n\nabsolute_day_reference = (\n    today | tomorrow | yesterday | (now + time_ref_present) | weekday_reference\n)\nabsolute_day_reference.set_name(\"absolute day\")\n\n@absolute_day_reference.add_parse_action\ndef _convert_abs_day_reference_to_date(t: pp.ParseResults) -> None:\n    now_ref = _now().replace(microsecond=0)\n\n    # handle day reference by weekday name\n    if \"day_name\" in t:\n        today_num = now_ref.weekday()\n        day_names = [n.lower() for n in weekday_names]\n        named_day_num = day_names.index(t.day_name.lower())\n        # compute difference in days - if current weekday name is referenced, then\n        # computed 0 offset is changed to 7\n        if t.dir > 0:\n            if today_num != named_day_num or t.next_present:\n                day_diff = (named_day_num + 7 - today_num) % 7 or 7\n            else:\n                day_diff = 0\n        else:\n            day_diff = -((today_num + 7 - named_day_num) % 7 or 7)\n        t[\"abs_date\"] = datetime(now_ref.year, now_ref.month, now_ref.day) + timedelta(\n            days=day_diff\n        )\n    else:\n        name = t[0]\n        t[\"abs_date\"] = {\n            \"now\": now_ref,\n            \"today\": datetime(now_ref.year, now_ref.month, now_ref.day),\n            \"yesterday\": datetime(now_ref.year, now_ref.month, now_ref.day)\n            + timedelta(days=-1),\n            \"tomorrow\": datetime(now_ref.year, now_ref.month, now_ref.day)\n            + timedelta(days=+1),\n        }[name]\n\n\n#     relative_day_reference ::=  'in' qty day_units\n#                                   | qty day_units\n#                                     ('ago'\n#                                      | ('from' | 'before' | 'after') absolute_day_reference)\nrelative_day_reference = in_(\"dir\") + qty(\"qty\") + day_units(\"units\") | qty(\n    \"qty\"\n) + day_units(\"units\") + (\n    ago(\"dir\") | ((from_ | before | after)(\"dir\") + absolute_day_reference(\"ref_day\"))\n)\nrelative_day_reference.set_name(\"relative day\")\n\n@relative_day_reference.add_parse_action\ndef _compute_relative_date(t: pp.ParseResults) -> None:\n    now = _now().replace(microsecond=0)\n    if \"ref_day\" in t:\n        t[\"computed_date\"] = t.ref_day\n    else:\n        t[\"computed_date\"] = now.date()\n    day_diff = t.dir * t.qty * {\"week\": 7, \"day\": 1}[t.units]\n    t[\"date_delta\"] = timedelta(days=day_diff)\n\n\n# combine expressions for absolute and relative day references\nday_reference = relative_day_reference | absolute_day_reference\nday_reference.set_name(\"day reference\")\n\n@day_reference.add_parse_action\ndef _add_default_date_fields(t: pp.ParseResults) -> None:\n    if \"date_delta\" not in t:\n        t[\"date_delta\"] = timedelta()\n\n\n# combine date and time expressions into single overall parser\ntime_and_day = time_reference + time_ref_present + pp.Opt(\n    pp.Opt(on_) + day_reference\n) | day_reference + pp.Opt(pp.Opt(at_) + absolute_time_of_day + time_ref_present)\ntime_and_day.set_name(\"time and day\")\n\n\n# parse actions for total time_and_day expression\n@time_and_day.add_parse_action\ndef _save_original_string(s: str, _: int, t: pp.ParseResults) -> None:\n    # save original input string and reference time\n    t[\"original\"] = \" \".join(s.strip().split())\n    t[\"relative_to\"] = _now().replace(microsecond=0)\n\n\n@time_and_day.add_parse_action\ndef _compute_timestamp(t: pp.ParseResults) -> None:\n    # accumulate values from parsed time and day subexpressions - fill in defaults for omitted parts\n    now = _now().replace(microsecond=0)\n    if \"computed_time\" not in t:\n        t[\"computed_time\"] = t.ref_time or now.time()\n    if \"abs_date\" not in t:\n        t[\"abs_date\"] = now\n\n    # roll up all fields and apply any time or day deltas\n    t[\"computed_dt\"] = (\n        t.abs_date.replace(\n            hour=t.computed_time.hour,\n            minute=t.computed_time.minute,\n            second=t.computed_time.second,\n        )\n        + (t.time_delta or timedelta(0))\n        + (t.date_delta or timedelta(0))\n    )\n\n    # if time just given in terms of day expressions, zero out time fields\n    if not t.time_ref_present:\n        t[\"computed_dt\"] = t.computed_dt.replace(hour=0, minute=0, second=0)\n\n    # add results name compatible with previous version\n    t[\"calculatedTime\"] = t.computed_dt\n\n    # add time_offset fields\n    t[\"time_offset\"] = t.computed_dt - t.relative_to\n\n\n@time_and_day.add_parse_action\ndef _remove_temp_keys(t: pp.ParseResults) -> None:\n    # strip out keys that are just used internally\n    all_keys = list(t.keys())\n    for k in all_keys:\n        if k not in (\n            \"computed_dt\",\n            \"original\",\n            \"relative_to\",\n            \"time_offset\",\n            \"calculatedTime\",\n        ):\n            del t[k]\n\n    # delete list elements - just return keys\n    del t[:]\n\n\ntime_expression = time_and_day\n\n_GENERATE_DIAGRAM = False\nif _GENERATE_DIAGRAM:\n    pp.autoname_elements()\n    time_expression.create_diagram(\"delta_time.html\")\n\n\ndef demo():\n    \"\"\"\n    Demonstrate using the time_expression parser, and accessing\n    the parsed results.\n\n    - parse a complex time expression\n    - show all fields that are accessible in the results\n    - show an example of using one of the results fields in Python\n    \"\"\"\n\n    # - parse a complex time expression\n    example_expr = \"10 seconds before noon tomorrow\"\n    result = time_expression.parse_string(example_expr)\n\n    # - show all fields that are accessible in the results\n    print(f\"\\nDemo: Results of parsing {example_expr!r}\", end=\"\")\n    print(result.dump(include_list=False))\n\n    # - show an example of using one of the results fields in Python\n    print(\"Computed time:\", result.computed_dt)\n\n\ndef run_all_tests() -> bool:\n    import itertools\n    from typing import Dict\n\n    def make_weekday_time_references() -> Dict[str, timedelta]:\n        def offset_weekday(\n            day_name: str, offset_dir: int, next_present: bool = False\n        ) -> timedelta:\n            \"\"\"\n            Compute a timedelta for a reference to a weekday by name, relative to\n            the current weekday.\n\n            If the current day is Monday:\n               \"next Monday\" will be one week in the future\n               \"last Monday\" will be one week in the past\n               \"Monday\" will be the current day\n               \"next Tuesday\" and \"Tuesday\" will be one day in the future\n               \"last Tuesday\" will be 6 days in the past\n               ... and similar for all other weekdays\n            \"\"\"\n            to_day_num = _DAY_NUM_BY_NAME[day_name]\n            from_day_num = current_time.weekday()\n\n            if to_day_num != from_day_num:\n                if offset_dir == 1:\n                    return timedelta(days=(to_day_num + 7 - from_day_num) % 7)\n                else:\n                    return timedelta(days=-((from_day_num + 7 - to_day_num) % 7))\n            else:\n                if offset_dir == 1:\n                    if next_present:\n                        return timedelta(days=7)\n                    else:\n                        return timedelta()\n                else:\n                    return timedelta(days=-7)\n\n        def next_weekday_by_name(\n            day_name: str, *, next_present: bool = False\n        ) -> timedelta:\n            return offset_weekday(day_name, 1, next_present)\n\n        def prev_weekday_by_name(day_name: str, **_) -> timedelta:\n            return offset_weekday(day_name, -1)\n\n        # add test_time_exprs for various times, forward and backward to a weekday by name\n        # define lists of expression terms to generate permutations of times, weekdays,\n        # and next/last\n        times = [(\"noon\", 12), (\"2am\", 2), (\"2pm\", 14), (\"1500\", 15)]\n        rels = [\"\", \"next\", \"last\"]\n        weekday_rel_func = {\n            \"\": next_weekday_by_name,\n            \"next\": next_weekday_by_name,\n            \"last\": prev_weekday_by_name,\n        }\n\n        weekday_test_cases = {}\n        for (timestr, timehours), rel, dayname in itertools.product(\n            times, rels, _WEEKDAY_NAMES\n        ):\n            next_or_prev_weekday_func = weekday_rel_func[rel]\n            expected_offset = (\n                timedelta(hours=timehours) - time_of_day\n            ) + next_or_prev_weekday_func(dayname, next_present=rel == \"next\")\n\n            # times such as \"noon last Friday\" or just \"noon Friday\"\n            weekday_test_cases[f\"{timestr} {rel} {dayname}\"] = expected_offset\n            # times such as \"next Tuesday at 4pm\" or just \"Tuesday at 4pm\"\n            weekday_test_cases[f\"{rel} {dayname} at {timestr}\"] = expected_offset\n            # times such as \"next Tuesday 4pm\" or just \"Tuesday 4pm\"\n            weekday_test_cases[f\"{rel} {dayname} {timestr}\"] = expected_offset\n\n        return weekday_test_cases\n\n    # get the current time as a timedelta, to compare with parsed times\n    current_time = _now()\n    time_of_day = timedelta(\n        hours=current_time.hour,\n        minutes=current_time.minute,\n        seconds=current_time.second,\n    )\n\n    # generate a dict of time expressions and correspdoning offset from\n    # the current time\n    # fmt: off\n    test_time_exprs = {\n        \"now\": timedelta(0),\n        \"midnight\": -time_of_day,\n        \"noon\": timedelta(hours=12) - time_of_day,\n        \"today\": -time_of_day,\n        \"tomorrow\": timedelta(days=1) - time_of_day,\n        \"yesterday\": timedelta(days=-1) - time_of_day,\n        \"10 seconds ago\": timedelta(seconds=-10),\n        \"100 seconds ago\": timedelta(seconds=-100),\n        \"1000 seconds ago\": timedelta(seconds=-1000),\n        \"10000 seconds ago\": timedelta(seconds=-10000),\n        \"10 minutes ago\": timedelta(minutes=-10),\n        \"10 minutes from now\": timedelta(minutes=10),\n        \"in 10 minutes\": timedelta(minutes=10),\n        \"in a minute\": timedelta(minutes=1),\n        \"in a couple of minutes\": timedelta(minutes=2),\n        \"20 seconds ago\": timedelta(seconds=-20),\n        \"in 30 seconds\": timedelta(seconds=30),\n        \"in an hour\": timedelta(hours=1),\n        \"in a couple hours\": timedelta(hours=2),\n        \"a week from now\": timedelta(days=7),\n        \"3 days from now\": timedelta(days=3),\n        \"a couple of days from now\": timedelta(days=2),\n        \"an hour ago\": timedelta(hours=-1),\n        \"in a couple days\": timedelta(days=2) - time_of_day,\n        \"a week from today\": timedelta(days=7) - time_of_day,\n        \"three weeks ago\": timedelta(days=-21) - time_of_day,\n        \"a day ago\": timedelta(days=-1) - time_of_day,\n        \"in a couple of days\": timedelta(days=2) - time_of_day,\n        \"a couple of days from today\": timedelta(days=2) - time_of_day,\n        \"2 weeks after today\": timedelta(days=14) - time_of_day,\n        \"in 2 weeks\": timedelta(days=14) - time_of_day,\n        \"the day after tomorrow\": timedelta(days=2) - time_of_day,\n        \"the day before yesterday\": timedelta(days=-2) - time_of_day,\n        \"8am the day after tomorrow\": timedelta(days=+2) - time_of_day + timedelta(hours=8),\n        \"in a day\": timedelta(days=1) - time_of_day,\n        \"3 days ago\": timedelta(days=-3) - time_of_day,\n        \"noon tomorrow\": timedelta(days=1) - time_of_day + timedelta(hours=12),\n        \"6am tomorrow\": timedelta(days=1) - time_of_day + timedelta(hours=6),\n        \"0800 yesterday\": timedelta(days=-1) - time_of_day + timedelta(hours=8),\n        \"1700 tomorrow\": timedelta(days=1) - time_of_day + timedelta(hours=17),\n        \"12:15 AM today\": -time_of_day + timedelta(minutes=15),\n        \"3pm 2 days from today\": timedelta(days=2) - time_of_day + timedelta(hours=15),\n        \"ten seconds before noon tomorrow\": (\n                timedelta(days=1)\n                - time_of_day\n                + timedelta(hours=12)\n                + timedelta(seconds=-10)\n        ),\n        \"20 seconds before noon\": -time_of_day + timedelta(hours=12) + timedelta(seconds=-20),\n        \"in 3 days at 5pm\": timedelta(days=3) - time_of_day + timedelta(hours=17),\n        \"20 hours from now\": timedelta(hours=20),\n        \"twenty hours from now\": timedelta(hours=20),\n        \"twenty-four hours from now\": timedelta(days=1),\n        \"Twenty-four hours from now\": timedelta(days=1),\n        \"just twenty-four hours from now\": timedelta(days=1),\n        \"in just 10 seconds\": timedelta(seconds=10),\n        \"in just a couple of hours\": timedelta(hours=2),\n        \"in exactly 1 hour\": timedelta(hours=1),\n        \"only one hour from now\": timedelta(hours=1),\n        \"only a couple of days ago\": timedelta(days=-2) - time_of_day,\n    }\n    # fmt: on\n\n    # add expressions using weekday names\n    test_time_exprs.update(make_weekday_time_references())\n\n    def verify_offset(test_time_str: str, parsed: pp.ParseResults) -> None:\n        \"\"\"\n        Function to compare computed offset time with expected offset as defined\n        in times dict.\n        \"\"\"\n        # allow up to a 1-second time discrepancy due to test processing time\n        time_epsilon = timedelta(seconds=1)\n        expected_offset = test_time_exprs[test_time_str]\n        offset_error = parsed.time_offset - expected_offset\n\n        # add helpful test results in case of a test failure\n        parsed[\"_testing_expected_offset\"] = expected_offset\n        parsed[\"_testing_observed_offset\"] = parsed.time_offset\n        parsed[\"_testing_offset_error\"] = offset_error\n        parsed[\"_testing_abs_offset_error\"] = abs(offset_error)\n\n        if abs(offset_error) <= time_epsilon:\n            parsed[\"_testing_verify_offset\"] = \"PASS\"\n        else:\n            parsed[\"_testing_verify_offset\"] = \"FAIL\"\n\n    # run all test cases\n    print(f\"(relative to {_now()})\")\n    success, report = time_expression.run_tests(\n        list(test_time_exprs), post_parse=verify_offset\n    )\n    assert success\n\n    # collect all tests that failed to compute the expected time (relative to\n    # the current time)\n    fails = []\n    for test, rpt in report:\n        if rpt._testing_verify_offset != \"PASS\":\n            fails.append((test, rpt))\n\n    if fails:\n        print(f\"\\nFAILED ({len(fails)}/{len(test_time_exprs)} tests)\")\n        print(\"\\n\".join(f\"- {test}\" for test, _ in fails))\n    else:\n        print(f\"\\nPASSED ({len(test_time_exprs)} tests)\")\n\n    return not fails\n\n\ndef main() -> int:\n    tests_pass = run_all_tests()\n    demo()\n    return 0 if tests_pass else 1\n\n\nif __name__ == \"__main__\":\n    exit(main())\n", "examples/gen_ctypes.py": "#\n# gen_ctypes.py\n#\n# Parse a .h header file to generate ctypes argtype and return type definitions\n#\n# Copyright 2004-2016, by Paul McGuire\n#\nfrom pyparsing import *\n\ntypemap = {\n    \"byte\": \"c_byte\",\n    \"char\": \"c_char\",\n    \"char *\": \"c_char_p\",\n    \"double\": \"c_double\",\n    \"float\": \"c_float\",\n    \"int\": \"c_int\",\n    \"int16\": \"c_int16\",\n    \"int32\": \"c_int32\",\n    \"int64\": \"c_int64\",\n    \"int8\": \"c_int8\",\n    \"long\": \"c_long\",\n    \"longlong\": \"c_longlong\",\n    \"short\": \"c_short\",\n    \"size_t\": \"c_size_t\",\n    \"ubyte\": \"c_ubyte\",\n    \"uchar\": \"c_ubyte\",\n    \"u_char\": \"c_ubyte\",\n    \"uint\": \"c_uint\",\n    \"u_int\": \"c_uint\",\n    \"uint16\": \"c_uint16\",\n    \"uint32\": \"c_uint32\",\n    \"uint64\": \"c_uint64\",\n    \"uint8\": \"c_uint8\",\n    \"u_long\": \"c_ulong\",\n    \"ulong\": \"c_ulong\",\n    \"ulonglong\": \"c_ulonglong\",\n    \"ushort\": \"c_ushort\",\n    \"u_short\": \"c_ushort\",\n    \"void *\": \"c_void_p\",\n    \"voidp\": \"c_voidp\",\n    \"wchar\": \"c_wchar\",\n    \"wchar *\": \"c_wchar_p\",\n    \"Bool\": \"c_bool\",\n    \"void\": \"None\",\n}\n\nLPAR, RPAR, LBRACE, RBRACE, COMMA, SEMI = Suppress.using_each(\"(){},;\")\nident = pyparsing_common.identifier\ninteger = Regex(r\"[+-]?\\d+\")\nhexinteger = Regex(r\"0x[0-9a-fA-F]+\")\n\nconst = Suppress(\"const\")\nprimitiveType = one_of(t for t in typemap if not t.endswith(\"*\"))\nstructType = Suppress(\"struct\") + ident\nvartype = (\n    Opt(const) + (primitiveType | structType | ident) + Opt(Word(\"*\")(\"ptr\"))\n)\n\n\ndef normalizetype(t):\n    if isinstance(t, ParseResults):\n        return \" \".join(t)\n        # ~ ret = ParseResults([' '.join(t)])\n        # ~ return ret\n\n\nvartype.set_parse_action(normalizetype)\n\narg = Group(vartype(\"argtype\") + Opt(ident(\"argname\")))\nfunc_def = (\n    vartype(\"fn_type\")\n    + ident(\"fn_name\")\n    + LPAR\n    + Opt(DelimitedList(arg | \"...\"))(\"fn_args\")\n    + RPAR\n    + SEMI\n)\n\n\ndef derivefields(t):\n    if t.fn_args and t.fn_args[-1] == \"...\":\n        t[\"varargs\"] = True\n\n\nfunc_def.set_parse_action(derivefields)\n\nfn_typedef = \"typedef\" + func_def\nvar_typedef = \"typedef\" + primitiveType(\"primType\") + ident(\"name\") + SEMI\n\nenum_def = (\n    Keyword(\"enum\")\n    + LBRACE\n    + DelimitedList(Group(ident(\"name\") + \"=\" + (hexinteger | integer)(\"value\")))(\n        \"evalues\"\n    )\n    + Opt(COMMA)\n    + RBRACE\n)\n\nc_header = open(\"snmp_api.h\").read()\n\n\nmodule = \"pynetsnmp\"\n\nuser_defined_types = set()\ntypedefs = []\nfn_typedefs = []\nfunctions = []\nenum_constants = []\n\n# add structures commonly included from std lib headers\ndef addStdType(t, namespace=\"\"):\n    fullname = namespace + \"_\" + t if namespace else t\n    typemap[t] = fullname\n    user_defined_types.add(t)\n\n\naddStdType(\"fd_set\", \"sys_select\")\naddStdType(\"timeval\", \"sys_time\")\n\n\ndef getUDType(typestr):\n    key = typestr.rstrip(\" *\")\n    if key not in typemap:\n        user_defined_types.add(key)\n        typemap[key] = \"{}_{}\".format(module, key)\n\n\ndef typeAsCtypes(typestr):\n    if typestr in typemap:\n        return typemap[typestr]\n    if typestr.endswith(\"*\"):\n        return f\"POINTER({typeAsCtypes(typestr.rstrip(' *'))})\"\n    return typestr\n\n\n# scan input header text for primitive typedefs\nfor td, _, _ in var_typedef.scan_string(c_header):\n    typedefs.append((td.name, td.primType))\n    # add typedef type to typemap to map to itself\n    typemap[td.name] = td.name\n\n# scan input header text for function typedefs\nfn_typedefs = fn_typedef.search_string(c_header)\n# add each function typedef to typemap to map to itself\nfor fntd in fn_typedefs:\n    typemap[fntd.fn_name] = fntd.fn_name\n\n# scan input header text, and keep running list of user-defined types\nfor fn, _, _ in (\n    cStyleComment.suppress() | fn_typedef.suppress() | func_def\n).scan_string(c_header):\n    if not fn:\n        continue\n    getUDType(fn.fn_type)\n    for arg in fn.fn_args:\n        if arg != \"...\":\n            if arg.argtype not in typemap:\n                getUDType(arg.argtype)\n    functions.append(fn)\n\n# scan input header text for enums\nenum_def.ignore(cpp_style_comment)\nfor en_, _, _ in enum_def.scan_string(c_header):\n    for ev in en_.evalues:\n        enum_constants.append((ev.name, ev.value))\n\nprint(\"from ctypes import *\")\nprint(\"{} = CDLL('{}.dll')\".format(module, module))\nprint()\nprint(\"# user defined types\")\nfor tdname, tdtyp in typedefs:\n    print(\"{} = {}\".format(tdname, typemap[tdtyp]))\nfor fntd in fn_typedefs:\n    print(\n        \"{} = CFUNCTYPE({})\".format(\n            fntd.fn_name, \",\\n    \".join(typeAsCtypes(a.argtype) for a in fntd.fn_args)\n        )\n    )\nfor udtype in user_defined_types:\n    print(f\"class {typemap[udtype]}(Structure): pass\")\n\nprint()\nprint(\"# constant definitions\")\nfor en, ev in enum_constants:\n    print(\"{} = {}\".format(en, ev))\n\nprint()\nprint(\"# functions\")\nfor fn in functions:\n    prefix = \"{}.{}\".format(module, fn.fn_name)\n\n    print(\"{}.restype = {}\".format(prefix, typeAsCtypes(fn.fn_type)))\n    if fn.varargs:\n        print(f\"# warning - {prefix} takes variable argument list\")\n        del fn.fn_args[-1]\n\n    if fn.fn_args.asList() != [[\"void\"]]:\n        print(\n            \"{}.argtypes = ({},)\".format(\n                prefix, \",\".join(typeAsCtypes(a.argtype) for a in fn.fn_args)\n            )\n        )\n    else:\n        print(f\"{prefix}.argtypes = ()\")\n", "examples/listAllMatches.py": "# listAllMatches.py\n#\n# Sample program showing how/when to use listAllMatches to get all matching tokens in a results name.\n#\n# copyright 2006, Paul McGuire\n#\n\nfrom pyparsing import oneOf, OneOrMore, printables, StringEnd\n\ntest = \"The quick brown fox named 'Aloysius' lives at 123 Main Street (and jumps over lazy dogs in his spare time).\"\nnonAlphas = [c for c in printables if not c.isalpha()]\n\nprint(\"Extract vowels, consonants, and special characters from this test string:\")\nprint(\"'\" + test + \"'\")\nprint(\"\")\n\nprint(\"Define grammar using normal results names\")\nprint(\"(only last matching symbol is saved)\")\nvowels = oneOf(list(\"aeiouy\"), caseless=True)(\"vowels\")\ncons = oneOf(list(\"bcdfghjklmnpqrstvwxz\"), caseless=True)(\"cons\")\nother = oneOf(nonAlphas)(\"others\")\nletters = OneOrMore(cons | vowels | other) + StringEnd()\n\nresults = letters.parseString(test)\nprint(results)\nprint(results.vowels)\nprint(results.cons)\nprint(results.others)\nprint(\"\")\n\n\nprint(\"Define grammar using results names, with listAllMatches=True\")\nprint(\"(all matching symbols are saved)\")\nvowels = oneOf(list(\"aeiouy\"), caseless=True)(\"vowels*\")\ncons = oneOf(list(\"bcdfghjklmnpqrstvwxz\"), caseless=True)(\"cons*\")\nother = oneOf(nonAlphas)(\"others*\")\n\nletters = OneOrMore(cons | vowels | other)\n\nresults = letters.parseString(test, parseAll=True)\nprint(results)\nprint(sorted(set(results)))\nprint(\"\")\nprint(results.vowels)\nprint(sorted(set(results.vowels)))\nprint(\"\")\nprint(results.cons)\nprint(sorted(set(results.cons)))\nprint(\"\")\nprint(results.others)\nprint(sorted(set(results.others)))\n", "examples/indented_block_example.py": "#\n# indented_block_example.py\n#\n\nimport pyparsing as pp\n\nppc = pp.pyparsing_common\n\ndata = \"\"\"\\\n\n    A\n        100\n        101\n\n        102\n    B\n        200\n        201\n    \n    C\n        300\n\n\"\"\"\n\ninteger = ppc.integer\ngroup = pp.Group(pp.Char(pp.alphas) + pp.Group(pp.IndentedBlock(integer)))\n\nprint(group[...].parseString(data).dump())\n\n# example of a recursive IndentedBlock\n\ndata = \"\"\"\\\n\n    A\n        100\n        101\n\n        102\n    B\n        200\n        b\n            210\n            211\n        202\n    C\n        300\n\n\"\"\"\n\ngroup = pp.Forward()\ngroup <<= pp.Group(pp.Char(pp.alphas) + pp.Group(pp.IndentedBlock(integer | group)))\n\nprint(\"using searchString\")\nprint(sum(group.searchString(data)).dump())\n", "examples/removeLineBreaks.py": "# removeLineBreaks.py\n#\n# Demonstration of the pyparsing module, converting text files\n# with hard line-breaks to text files with line breaks only\n# between paragraphs.  (Helps when converting downloads from Project\n# Gutenberg - https://www.gutenberg.org/ - to import to word processing apps\n# that can reformat paragraphs once hard line-breaks are removed.)\n#\n# Uses parse actions and transformString to remove unwanted line breaks,\n# and to double up line breaks between paragraphs.\n#\n# Copyright 2006, by Paul McGuire\n#\nimport pyparsing as pp\n\nline_end = pp.LineEnd()\n\n# define an expression for the body of a line of text - use a predicate condition to\n# accept only lines with some content.\ndef mustBeNonBlank(t):\n    return t[0] != \"\"\n    # could also be written as\n    # return bool(t[0])\n\n\nlineBody = pp.SkipTo(line_end).addCondition(\n    mustBeNonBlank, message=\"line body can't be empty\"\n)\n\n# now define a line with a trailing lineEnd, to be replaced with a space character\ntextLine = lineBody + line_end().setParseAction(pp.replaceWith(\" \"))\n\n# define a paragraph, with a separating lineEnd, to be replaced with a double newline\npara = pp.OneOrMore(textLine) + line_end().setParseAction(pp.replaceWith(\"\\n\\n\"))\n\n# run a test\ntest = \"\"\"\n    Now is the\n    time for\n    all\n    good men\n    to come to\n\n    the aid of their\n    country.\n\"\"\"\nprint(para.transformString(test))\n\n# process an entire file\n#   Project Gutenberg EBook of Successful Methods of Public Speaking, by Grenville Kleiser\n#   Download from http://www.gutenberg.org/cache/epub/18095/pg18095.txt\n#\nwith open(\"18095-8.txt\") as source_file:\n    original = source_file.read()\n\n# use transformString to convert line breaks\ntransformed = para.transformString(original)\n\nwith open(\"18095-8_reformatted.txt\", \"w\") as transformed_file:\n    transformed_file.write(transformed)\n", "examples/readJson.py": "# ~ url = \"http://cmsdoc.cern.ch/cms/test/aprom/phedex/dev/gowri/datasvc/tbedi/requestDetails\"\n# ~ params = {'format':'json'}\n# ~ import urllib\n# ~ eparams = urllib.urlencode(params)\n# ~ import urllib2\n# ~ request = urllib2.Request(url,eparams)\n# ~ response = urllib2.urlopen(request)\n# ~ s = response.read()\n# ~ response.close()\n\n# ~ print s\n\ns = \"\"\"\n{\"phedex\":{\"request\":[{\"last_update\":\"1188037561\", \"numofapproved\":\"1\",\n\"id\":\"7425\"}, {\"last_update\":\"1188751826\", \"numofapproved\":\"1\",\n\"id\":\"8041\"}, {\"last_update\":\"1190116795\", \"numofapproved\":\"1\",\n\"id\":\"9281\"}, {\"last_update\":\"1190248781\", \"numofapproved\":\"1\",\n\"id\":\"9521\"}, {\"last_update\":\"1192615612\", \"numofapproved\":\"1\",\n\"id\":\"12821\"}, {\"last_update\":\"1192729887\", \"numofapproved\":\"1\",\n\"id\":\"13121\"}, {\"last_update\":\"1193152971\", \"numofapproved\":\"1\",\n\"id\":\"13501\"}, {\"last_update\":\"1194022054\", \"numofapproved\":\"1\",\n\"id\":\"14782\"}, {\"last_update\":\"1194429365\", \"numofapproved\":\"1\",\n\"id\":\"15081\"}, {\"last_update\":\"1195069848\", \"numofapproved\":\"1\",\n\"id\":\"16661\"}, {\"last_update\":\"1178403225\", \"numofapproved\":\"1\",\n\"id\":\"1281\"}, {\"last_update\":\"1179239056\", \"numofapproved\":\"1\",\n\"id\":\"1387\"}, {\"last_update\":\"1179842205\", \"numofapproved\":\"1\",\n\"id\":\"1665\"}, {\"last_update\":\"1179842040\", \"numofapproved\":\"1\",\n\"id\":\"1661\"}, {\"last_update\":\"1179935333\", \"numofapproved\":\"1\",\n\"id\":\"1741\"}, {\"last_update\":\"1183151195\", \"numofapproved\":\"1\",\n\"id\":\"3841\"}, {\"last_update\":\"1187031531\", \"numofapproved\":\"1\",\n\"id\":\"6601\"}, {\"last_update\":\"1188820478\", \"numofapproved\":\"1\",\n\"id\":\"8121\"}, {\"last_update\":\"1190652719\", \"numofapproved\":\"1\",\n\"id\":\"9983\"}, {\"last_update\":\"1192628950\", \"numofapproved\":\"1\",\n\"id\":\"12841\"}, {\"last_update\":\"1193075426\", \"numofapproved\":\"1\",\n\"id\":\"13341\"}, {\"last_update\":\"1194214609\", \"numofapproved\":\"1\",\n\"id\":\"14882\"}, {\"last_update\":\"1194387864\", \"numofapproved\":\"1\",\n\"id\":\"15062\"}, {\"last_update\":\"1195134504\", \"numofapproved\":\"1\",\n\"id\":\"16741\"}, {\"last_update\":\"1182431453\", \"numofapproved\":\"1\",\n\"id\":\"3421\"}, {\"last_update\":\"1183448188\", \"numofapproved\":\"1\",\n\"id\":\"4061\"}, {\"last_update\":\"1184588081\", \"numofapproved\":\"1\",\n\"id\":\"4908\"}, {\"last_update\":\"1184681258\", \"numofapproved\":\"1\",\n\"id\":\"4913\"}, {\"last_update\":\"1188039048\", \"numofapproved\":\"1\",\n\"id\":\"7426\"}, {\"last_update\":\"1192699041\", \"numofapproved\":\"1\",\n\"id\":\"12982\"}, {\"last_update\":\"1193219685\", \"numofapproved\":\"1\",\n\"id\":\"13529\"}, {\"last_update\":\"1193401408\", \"numofapproved\":\"1\",\n\"id\":\"14081\"}, {\"last_update\":\"1194454724\", \"numofapproved\":\"1\",\n\"id\":\"15201\"}, {\"last_update\":\"1194937690\", \"numofapproved\":\"1\",\n\"id\":\"16044\"}, {\"last_update\":\"1194947125\", \"numofapproved\":\"1\",\n\"id\":\"16103\"}, {\"last_update\":\"1195134890\", \"numofapproved\":\"1\",\n\"id\":\"16761\"}, {\"last_update\":\"1195486898\", \"numofapproved\":\"1\",\n\"id\":\"17301\"}, {\"last_update\":\"1195497774\", \"numofapproved\":\"1\",\n\"id\":\"17341\"}, {\"last_update\":\"1184744080\", \"numofapproved\":\"1\",\n\"id\":\"4941\"}, {\"last_update\":\"1186558911\", \"numofapproved\":\"1\",\n\"id\":\"6321\"}, {\"last_update\":\"1189524520\", \"numofapproved\":\"1\",\n\"id\":\"8802\"}, {\"last_update\":\"1192683178\", \"numofapproved\":\"1\",\n\"id\":\"12921\"}, {\"last_update\":\"1193260655\", \"numofapproved\":\"1\",\n\"id\":\"13530\"}, {\"last_update\":\"1194280038\", \"numofapproved\":\"1\",\n\"id\":\"15002\"}, {\"last_update\":\"1182077478\", \"numofapproved\":\"1\",\n\"id\":\"3162\"}, {\"last_update\":\"1183386650\", \"numofapproved\":\"1\",\n\"id\":\"3961\"}, {\"last_update\":\"1192063369\", \"numofapproved\":\"1\",\n\"id\":\"12182\"}, {\"last_update\":\"1181931262\", \"numofapproved\":\"1\",\n\"id\":\"3101\"}, {\"last_update\":\"1178648271\", \"numofapproved\":\"1\",\n\"id\":\"1308\"}, {\"last_update\":\"1179239923\", \"numofapproved\":\"1\",\n\"id\":\"1405\"}, {\"last_update\":\"1184370745\", \"numofapproved\":\"1\",\n\"id\":\"4861\"}, {\"last_update\":\"1185280568\", \"numofapproved\":\"1\",\n\"id\":\"5302\"}, {\"last_update\":\"1187875115\", \"numofapproved\":\"1\",\n\"id\":\"7344\"}, {\"last_update\":\"1189140441\", \"numofapproved\":\"1\",\n\"id\":\"8541\"}, {\"last_update\":\"1189180903\", \"numofapproved\":\"1\",\n\"id\":\"8661\"}, {\"last_update\":\"1189767643\", \"numofapproved\":\"1\",\n\"id\":\"9001\"}, {\"last_update\":\"1190726167\", \"numofapproved\":\"1\",\n\"id\":\"10101\"}, {\"last_update\":\"1190972990\", \"numofapproved\":\"1\",\n\"id\":\"10661\"}, {\"last_update\":\"1190990720\", \"numofapproved\":\"1\",\n\"id\":\"10712\"}, {\"last_update\":\"1192004838\", \"numofapproved\":\"1\",\n\"id\":\"12021\"}, {\"last_update\":\"1192612211\", \"numofapproved\":\"1\",\n\"id\":\"12803\"}, {\"last_update\":\"1194441407\", \"numofapproved\":\"1\",\n\"id\":\"15103\"}, {\"last_update\":\"1194792356\", \"numofapproved\":\"1\",\n\"id\":\"15681\"}, {\"last_update\":\"1194860650\", \"numofapproved\":\"1\",\n\"id\":\"15801\"}, {\"last_update\":\"1194877395\", \"numofapproved\":\"1\",\n\"id\":\"15881\"}, {\"last_update\":\"1194950552\", \"numofapproved\":\"1\",\n\"id\":\"16124\"}, {\"last_update\":\"1194992714\", \"numofapproved\":\"1\",\n\"id\":\"16421\"}, {\"last_update\":\"1195054500\", \"numofapproved\":\"1\",\n\"id\":\"16581\"}, {\"last_update\":\"1195228524\", \"numofapproved\":\"1\",\n\"id\":\"17001\"}, {\"last_update\":\"1195469382\", \"numofapproved\":\"1\",\n\"id\":\"17161\"}, {\"last_update\":\"1178035947\", \"numofapproved\":\"1\",\n\"id\":\"1202\"}, {\"last_update\":\"1178869668\", \"numofapproved\":\"1\",\n\"id\":\"1356\"}, {\"last_update\":\"1183563268\", \"numofapproved\":\"1\",\n\"id\":\"4201\"}, {\"last_update\":\"1185314677\", \"numofapproved\":\"1\",\n\"id\":\"5361\"}, {\"last_update\":\"1188467567\", \"numofapproved\":\"1\",\n\"id\":\"7781\"}, {\"last_update\":\"1190011821\", \"numofapproved\":\"1\",\n\"id\":\"9202\"}, {\"last_update\":\"1190206214\", \"numofapproved\":\"1\",\n\"id\":\"9481\"}, {\"last_update\":\"1190973037\", \"numofapproved\":\"1\",\n\"id\":\"10663\"}, {\"last_update\":\"1190819127\", \"numofapproved\":\"1\",\n\"id\":\"10342\"}, {\"last_update\":\"1192154959\", \"numofapproved\":\"1\",\n\"id\":\"12381\"}, {\"last_update\":\"1192634509\", \"numofapproved\":\"1\",\n\"id\":\"12862\"}, {\"last_update\":\"1194004677\", \"numofapproved\":\"1\",\n\"id\":\"14722\"}, {\"last_update\":\"1195548191\", \"numofapproved\":\"1\",\n\"id\":\"17501\"}, {\"last_update\":\"1195548953\", \"numofapproved\":\"1\",\n\"id\":\"17502\"}, {\"last_update\":\"1195559809\", \"numofapproved\":\"1\",\n\"id\":\"17541\"}, {\"last_update\":\"1177589103\", \"numofapproved\":\"1\",\n\"id\":\"1044\"}, {\"last_update\":\"1183416879\", \"numofapproved\":\"1\",\n\"id\":\"4041\"}, {\"last_update\":\"1186646977\", \"numofapproved\":\"1\",\n\"id\":\"6342\"}, {\"last_update\":\"1189656586\", \"numofapproved\":\"1\",\n\"id\":\"8902\"}, {\"last_update\":\"1190150645\", \"numofapproved\":\"1\",\n\"id\":\"9421\"}, {\"last_update\":\"1190409040\", \"numofapproved\":\"1\",\n\"id\":\"9741\"}, {\"last_update\":\"1190973011\", \"numofapproved\":\"1\",\n\"id\":\"10662\"}, {\"last_update\":\"1190993896\", \"numofapproved\":\"1\",\n\"id\":\"10761\"}, {\"last_update\":\"1193973610\", \"numofapproved\":\"1\",\n\"id\":\"14661\"}, {\"last_update\":\"1193973848\", \"numofapproved\":\"1\",\n\"id\":\"14664\"}, {\"last_update\":\"1194539978\", \"numofapproved\":\"1\",\n\"id\":\"15381\"}, {\"last_update\":\"1194947356\", \"numofapproved\":\"1\",\n\"id\":\"16105\"}, {\"last_update\":\"1195399589\", \"numofapproved\":\"1\",\n\"id\":\"17101\"}, {\"last_update\":\"1195464953\", \"numofapproved\":\"1\",\n\"id\":\"17141\"}, {\"last_update\":\"1171962221\", \"numofapproved\":\"1\",\n\"id\":\"109\"}, {\"last_update\":\"1173113812\", \"numofapproved\":\"1\",\n\"id\":\"247\"}, {\"last_update\":\"1173975435\", \"numofapproved\":\"1\",\n\"id\":\"343\"}, {\"last_update\":\"1174050971\", \"numofapproved\":\"1\",\n\"id\":\"353\"}, {\"last_update\":\"1174301484\", \"numofapproved\":\"1\",\n\"id\":\"393\"}, {\"last_update\":\"1172565853\", \"numofapproved\":\"1\",\n\"id\":\"208\"}, {\"last_update\":\"1172593328\", \"numofapproved\":\"1\",\n\"id\":\"215\"}, {\"last_update\":\"1175267391\", \"numofapproved\":\"1\",\n\"id\":\"565\"}, {\"last_update\":\"1171379845\", \"numofapproved\":\"1\",\n\"id\":\"25\"}, {\"last_update\":\"1171477466\", \"numofapproved\":\"1\",\n\"id\":\"53\"}, {\"last_update\":\"1171799296\", \"numofapproved\":\"1\",\n\"id\":\"77\"}, {\"last_update\":\"1172671474\", \"numofapproved\":\"1\",\n\"id\":\"223\"}, {\"last_update\":\"1174301354\", \"numofapproved\":\"1\",\n\"id\":\"388\"}, {\"last_update\":\"1174899552\", \"numofapproved\":\"1\",\n\"id\":\"511\"}, {\"last_update\":\"1174899458\", \"numofapproved\":\"1\",\n\"id\":\"505\"}, {\"last_update\":\"1175502936\", \"numofapproved\":\"1\",\n\"id\":\"604\"}, {\"last_update\":\"1175613825\", \"numofapproved\":\"1\",\n\"id\":\"665\"}, {\"last_update\":\"1175776232\", \"numofapproved\":\"1\",\n\"id\":\"673\"}, {\"last_update\":\"1171621302\", \"numofapproved\":\"1\",\n\"id\":\"68\"}, {\"last_update\":\"1171904738\", \"numofapproved\":\"1\",\n\"id\":\"98\"}, {\"last_update\":\"1171968012\", \"numofapproved\":\"1\",\n\"id\":\"115\"}, {\"last_update\":\"1172145037\", \"numofapproved\":\"1\",\n\"id\":\"168\"}, {\"last_update\":\"1172246599\", \"numofapproved\":\"1\",\n\"id\":\"185\"}, {\"last_update\":\"1173886280\", \"numofapproved\":\"1\",\n\"id\":\"318\"}, {\"last_update\":\"1174562010\", \"numofapproved\":\"1\",\n\"id\":\"423\"}, {\"last_update\":\"1176308974\", \"numofapproved\":\"1\",\n\"id\":\"884\"}, {\"last_update\":\"1176482150\", \"numofapproved\":\"1\",\n\"id\":\"943\"}, {\"last_update\":\"1176702424\", \"numofapproved\":\"1\",\n\"id\":\"1001\"}, {\"last_update\":\"1176748776\", \"numofapproved\":\"1\",\n\"id\":\"984\"}, {\"last_update\":\"1172669745\", \"numofapproved\":\"1\",\n\"id\":\"222\"}, {\"last_update\":\"1174899538\", \"numofapproved\":\"1\",\n\"id\":\"510\"}, {\"last_update\":\"1174899143\", \"numofapproved\":\"1\",\n\"id\":\"493\"}, {\"last_update\":\"1174899043\", \"numofapproved\":\"1\",\n\"id\":\"488\"}, {\"last_update\":\"1175711780\", \"numofapproved\":\"1\",\n\"id\":\"667\"}, {\"last_update\":\"1175712851\", \"numofapproved\":\"1\",\n\"id\":\"705\"}, {\"last_update\":\"1176296548\", \"numofapproved\":\"1\",\n\"id\":\"841\"}, {\"last_update\":\"1175862269\", \"numofapproved\":\"1\",\n\"id\":\"781\"}, {\"last_update\":\"1171483107\", \"numofapproved\":\"1\",\n\"id\":\"54\"}, {\"last_update\":\"1171645737\", \"numofapproved\":\"1\",\n\"id\":\"71\"}, {\"last_update\":\"1172253423\", \"numofapproved\":\"1\",\n\"id\":\"188\"}, {\"last_update\":\"1173888726\", \"numofapproved\":\"1\",\n\"id\":\"321\"}, {\"last_update\":\"1173975649\", \"numofapproved\":\"1\",\n\"id\":\"346\"}, {\"last_update\":\"1174299379\", \"numofapproved\":\"1\",\n\"id\":\"363\"}, {\"last_update\":\"1174301359\", \"numofapproved\":\"1\",\n\"id\":\"389\"}, {\"last_update\":\"1174301073\", \"numofapproved\":\"1\",\n\"id\":\"379\"}, {\"last_update\":\"1174300650\", \"numofapproved\":\"1\",\n\"id\":\"371\"}, {\"last_update\":\"1171485069\", \"numofapproved\":\"1\",\n\"id\":\"55\"}, {\"last_update\":\"1171799178\", \"numofapproved\":\"1\",\n\"id\":\"73\"}, {\"last_update\":\"1171896809\", \"numofapproved\":\"1\",\n\"id\":\"95\"}, {\"last_update\":\"1172672959\", \"numofapproved\":\"1\",\n\"id\":\"224\"}, {\"last_update\":\"1172693619\", \"numofapproved\":\"1\",\n\"id\":\"230\"}, {\"last_update\":\"1173207656\", \"numofapproved\":\"1\",\n\"id\":\"253\"}, {\"last_update\":\"1174059533\", \"numofapproved\":\"1\",\n\"id\":\"356\"}, {\"last_update\":\"1174300538\", \"numofapproved\":\"1\",\n\"id\":\"368\"}, {\"last_update\":\"1176137457\", \"numofapproved\":\"1\",\n\"id\":\"807\"}, {\"last_update\":\"1173728124\", \"numofapproved\":\"1\",\n\"id\":\"305\"}, {\"last_update\":\"1172507633\", \"numofapproved\":\"1\",\n\"id\":\"198\"}, {\"last_update\":\"1174301173\", \"numofapproved\":\"1\",\n\"id\":\"383\"}, {\"last_update\":\"1174899102\", \"numofapproved\":\"1\",\n\"id\":\"491\"}, {\"last_update\":\"1174301362\", \"numofapproved\":\"1\",\n\"id\":\"390\"}, {\"last_update\":\"1175254095\", \"numofapproved\":\"1\",\n\"id\":\"561\"}, {\"last_update\":\"1174037250\", \"numofapproved\":\"1\",\n\"id\":\"348\"}, {\"last_update\":\"1175865081\", \"numofapproved\":\"1\",\n\"id\":\"782\"}, {\"last_update\":\"1177591942\", \"numofapproved\":\"1\",\n\"id\":\"1046\"}, {\"last_update\":\"1177989191\", \"numofapproved\":\"1\",\n\"id\":\"1201\"}, {\"last_update\":\"1178743279\", \"numofapproved\":\"1\",\n\"id\":\"1323\"}, {\"last_update\":\"1178876587\", \"numofapproved\":\"1\",\n\"id\":\"1357\"}, {\"last_update\":\"1179239620\", \"numofapproved\":\"1\",\n\"id\":\"1401\"}, {\"last_update\":\"1180725458\", \"numofapproved\":\"1\",\n\"id\":\"2141\"}, {\"last_update\":\"1181205209\", \"numofapproved\":\"1\",\n\"id\":\"2421\"}, {\"last_update\":\"1181575615\", \"numofapproved\":\"1\",\n\"id\":\"2761\"}, {\"last_update\":\"1182184775\", \"numofapproved\":\"1\",\n\"id\":\"3201\"}, {\"last_update\":\"1182963728\", \"numofapproved\":\"1\",\n\"id\":\"3661\"}, {\"last_update\":\"1178727735\", \"numofapproved\":\"1\",\n\"id\":\"1349\"}, {\"last_update\":\"1182497720\", \"numofapproved\":\"1\",\n\"id\":\"3441\"}, {\"last_update\":\"1184381847\", \"numofapproved\":\"1\",\n\"id\":\"4881\"}, {\"last_update\":\"1184568423\", \"numofapproved\":\"1\",\n\"id\":\"4904\"}, {\"last_update\":\"1185364813\", \"numofapproved\":\"1\",\n\"id\":\"5421\"}, {\"last_update\":\"1188043594\", \"numofapproved\":\"1\",\n\"id\":\"7441\"}, {\"last_update\":\"1188675287\", \"numofapproved\":\"1\",\n\"id\":\"7981\"}, {\"last_update\":\"1188741594\", \"numofapproved\":\"1\",\n\"id\":\"8021\"}, {\"last_update\":\"1189144234\", \"numofapproved\":\"1\",\n\"id\":\"8561\"}, {\"last_update\":\"1189170150\", \"numofapproved\":\"1\",\n\"id\":\"8641\"}, {\"last_update\":\"1189501508\", \"numofapproved\":\"1\",\n\"id\":\"8761\"}, {\"last_update\":\"1189811918\", \"numofapproved\":\"1\",\n\"id\":\"9041\"}, {\"last_update\":\"1189812095\", \"numofapproved\":\"1\",\n\"id\":\"9042\"}, {\"last_update\":\"1177591716\", \"numofapproved\":\"1\",\n\"id\":\"1045\"}, {\"last_update\":\"1178040595\", \"numofapproved\":\"1\",\n\"id\":\"1203\"}, {\"last_update\":\"1182437936\", \"numofapproved\":\"1\",\n\"id\":\"3423\"}, {\"last_update\":\"1190480042\", \"numofapproved\":\"1\",\n\"id\":\"9781\"}, {\"last_update\":\"1190821494\", \"numofapproved\":\"1\",\n\"id\":\"10361\"}, {\"last_update\":\"1190959672\", \"numofapproved\":\"1\",\n\"id\":\"10602\"}, {\"last_update\":\"1190964023\", \"numofapproved\":\"1\",\n\"id\":\"10621\"}, {\"last_update\":\"1190991147\", \"numofapproved\":\"1\",\n\"id\":\"10721\"}, {\"last_update\":\"1190992132\", \"numofapproved\":\"1\",\n\"id\":\"10741\"}, {\"last_update\":\"1190990410\", \"numofapproved\":\"1\",\n\"id\":\"10706\"}, {\"last_update\":\"1181667132\", \"numofapproved\":\"1\",\n\"id\":\"2861\"}, {\"last_update\":\"1183746653\", \"numofapproved\":\"1\",\n\"id\":\"4321\"}, {\"last_update\":\"1191184539\", \"numofapproved\":\"1\",\n\"id\":\"10861\"}, {\"last_update\":\"1191490599\", \"numofapproved\":\"1\",\n\"id\":\"11261\"}, {\"last_update\":\"1191834884\", \"numofapproved\":\"1\",\n\"id\":\"11801\"}, {\"last_update\":\"1191834899\", \"numofapproved\":\"1\",\n\"id\":\"11802\"}, {\"last_update\":\"1191940759\", \"numofapproved\":\"1\",\n\"id\":\"11961\"}, {\"last_update\":\"1179971250\", \"numofapproved\":\"1\",\n\"id\":\"1643\"}, {\"last_update\":\"1181663618\", \"numofapproved\":\"1\",\n\"id\":\"2841\"}, {\"last_update\":\"1181932994\", \"numofapproved\":\"1\",\n\"id\":\"3102\"}, {\"last_update\":\"1182420732\", \"numofapproved\":\"1\",\n\"id\":\"3382\"}, {\"last_update\":\"1192118127\", \"numofapproved\":\"1\",\n\"id\":\"12281\"}, {\"last_update\":\"1192222036\", \"numofapproved\":\"1\",\n\"id\":\"12481\"}, {\"last_update\":\"1192155814\", \"numofapproved\":\"1\",\n\"id\":\"12364\"}, {\"last_update\":\"1192563924\", \"numofapproved\":\"1\",\n\"id\":\"12761\"}, {\"last_update\":\"1193124530\", \"numofapproved\":\"1\",\n\"id\":\"13441\"}, {\"last_update\":\"1193345545\", \"numofapproved\":\"1\",\n\"id\":\"13921\"}, {\"last_update\":\"1193396927\", \"numofapproved\":\"1\",\n\"id\":\"14041\"}, {\"last_update\":\"1180015411\", \"numofapproved\":\"1\",\n\"id\":\"1651\"}, {\"last_update\":\"1180107815\", \"numofapproved\":\"1\",\n\"id\":\"1658\"}, {\"last_update\":\"1186050394\", \"numofapproved\":\"1\",\n\"id\":\"6021\"}, {\"last_update\":\"1188519417\", \"numofapproved\":\"1\",\n\"id\":\"7841\"}, {\"last_update\":\"1193222002\", \"numofapproved\":\"1\",\n\"id\":\"13541\"}, {\"last_update\":\"1193965081\", \"numofapproved\":\"1\",\n\"id\":\"14641\"}, {\"last_update\":\"1193660582\", \"numofapproved\":\"1\",\n\"id\":\"14381\"}, {\"last_update\":\"1194088240\", \"numofapproved\":\"1\",\n\"id\":\"14821\"}, {\"last_update\":\"1194110475\", \"numofapproved\":\"1\",\n\"id\":\"14841\"}, {\"last_update\":\"1194246367\", \"numofapproved\":\"1\",\n\"id\":\"14902\"}, {\"last_update\":\"1194464283\", \"numofapproved\":\"1\",\n\"id\":\"15221\"}, {\"last_update\":\"1194622250\", \"numofapproved\":\"1\",\n\"id\":\"15461\"}, {\"last_update\":\"1194635632\", \"numofapproved\":\"1\",\n\"id\":\"15601\"}, {\"last_update\":\"1179147506\", \"numofapproved\":\"1\",\n\"id\":\"1382\"}, {\"last_update\":\"1179240025\", \"numofapproved\":\"1\",\n\"id\":\"1388\"}, {\"last_update\":\"1179748089\", \"numofapproved\":\"1\",\n\"id\":\"1561\"}, {\"last_update\":\"1179868997\", \"numofapproved\":\"1\",\n\"id\":\"1681\"}, {\"last_update\":\"1183019667\", \"numofapproved\":\"1\",\n\"id\":\"3702\"}, {\"last_update\":\"1184531598\", \"numofapproved\":\"1\",\n\"id\":\"4902\"}, {\"last_update\":\"1187294472\", \"numofapproved\":\"1\",\n\"id\":\"6841\"}, {\"last_update\":\"1189521494\", \"numofapproved\":\"1\",\n\"id\":\"8801\"}, {\"last_update\":\"1192726867\", \"numofapproved\":\"1\",\n\"id\":\"13081\"}, {\"last_update\":\"1193049178\", \"numofapproved\":\"1\",\n\"id\":\"13301\"}, {\"last_update\":\"1193387050\", \"numofapproved\":\"1\",\n\"id\":\"13947\"}, {\"last_update\":\"1194277280\", \"numofapproved\":\"1\",\n\"id\":\"14981\"}, {\"last_update\":\"1179150720\", \"numofapproved\":\"1\",\n\"id\":\"1383\"}, {\"last_update\":\"1179842104\", \"numofapproved\":\"1\",\n\"id\":\"1663\"}, {\"last_update\":\"1183766887\", \"numofapproved\":\"1\",\n\"id\":\"4341\"}, {\"last_update\":\"1185542132\", \"numofapproved\":\"1\",\n\"id\":\"5682\"}, {\"last_update\":\"1186737114\", \"numofapproved\":\"1\",\n\"id\":\"6382\"}, {\"last_update\":\"1187015679\", \"numofapproved\":\"1\",\n\"id\":\"6521\"}, {\"last_update\":\"1190326980\", \"numofapproved\":\"1\",\n\"id\":\"9641\"}, {\"last_update\":\"1191595711\", \"numofapproved\":\"1\",\n\"id\":\"11622\"}, {\"last_update\":\"1192106288\", \"numofapproved\":\"1\",\n\"id\":\"12221\"}, {\"last_update\":\"1192454432\", \"numofapproved\":\"1\",\n\"id\":\"12622\"}, {\"last_update\":\"1194339640\", \"numofapproved\":\"1\",\n\"id\":\"15021\"}, {\"last_update\":\"1177758209\", \"numofapproved\":\"1\",\n\"id\":\"1181\"}, {\"last_update\":\"1179842392\", \"numofapproved\":\"1\",\n\"id\":\"1669\"}, {\"last_update\":\"1179872870\", \"numofapproved\":\"1\",\n\"id\":\"1682\"}, {\"last_update\":\"1181233887\", \"numofapproved\":\"1\",\n\"id\":\"2541\"}, {\"last_update\":\"1182349297\", \"numofapproved\":\"1\",\n\"id\":\"3342\"}, {\"last_update\":\"1182375421\", \"numofapproved\":\"1\",\n\"id\":\"3350\"}, {\"last_update\":\"1183485259\", \"numofapproved\":\"1\",\n\"id\":\"4081\"}, {\"last_update\":\"1184319308\", \"numofapproved\":\"1\",\n\"id\":\"4821\"}, {\"last_update\":\"1187626648\", \"numofapproved\":\"1\",\n\"id\":\"6981\"}, {\"last_update\":\"1193153090\", \"numofapproved\":\"1\",\n\"id\":\"13502\"}, {\"last_update\":\"1194366368\", \"numofapproved\":\"1\",\n\"id\":\"15041\"}, {\"last_update\":\"1194617018\", \"numofapproved\":\"1\",\n\"id\":\"15421\"}, {\"last_update\":\"1195230640\", \"numofapproved\":\"1\",\n\"id\":\"17021\"}, {\"last_update\":\"1179908379\", \"numofapproved\":\"1\",\n\"id\":\"1701\"}, {\"last_update\":\"1188049228\", \"numofapproved\":\"1\",\n\"id\":\"7427\"}, {\"last_update\":\"1177581166\", \"numofapproved\":\"1\",\n\"id\":\"1061\"}, {\"last_update\":\"1187160654\", \"numofapproved\":\"1\",\n\"id\":\"6661\"}, {\"last_update\":\"1192983992\", \"numofapproved\":\"1\",\n\"id\":\"13222\"}, {\"last_update\":\"1193388978\", \"numofapproved\":\"1\",\n\"id\":\"13954\"}, {\"last_update\":\"1194617112\", \"numofapproved\":\"1\",\n\"id\":\"15422\"}, {\"last_update\":\"1195398876\", \"numofapproved\":\"1\",\n\"id\":\"17081\"}, {\"last_update\":\"1184262511\", \"numofapproved\":\"1\",\n\"id\":\"4801\"}, {\"last_update\":\"1192112284\", \"numofapproved\":\"1\",\n\"id\":\"12241\"}, {\"last_update\":\"1193082767\", \"numofapproved\":\"1\",\n\"id\":\"13401\"}, {\"last_update\":\"1193179243\", \"numofapproved\":\"1\",\n\"id\":\"13526\"}, {\"last_update\":\"1178142915\", \"numofapproved\":\"1\",\n\"id\":\"1206\"}, {\"last_update\":\"1178648333\", \"numofapproved\":\"1\",\n\"id\":\"1310\"}, {\"last_update\":\"1179279626\", \"numofapproved\":\"1\",\n\"id\":\"1391\"}, {\"last_update\":\"1182882268\", \"numofapproved\":\"1\",\n\"id\":\"3584\"}, {\"last_update\":\"1183128448\", \"numofapproved\":\"1\",\n\"id\":\"3823\"}, {\"last_update\":\"1183377394\", \"numofapproved\":\"1\",\n\"id\":\"3941\"}, {\"last_update\":\"1188582729\", \"numofapproved\":\"1\",\n\"id\":\"7902\"}, {\"last_update\":\"1189695063\", \"numofapproved\":\"1\",\n\"id\":\"8962\"}, {\"last_update\":\"1192001165\", \"numofapproved\":\"1\",\n\"id\":\"12001\"}, {\"last_update\":\"1192155647\", \"numofapproved\":\"1\",\n\"id\":\"12363\"}, {\"last_update\":\"1193418304\", \"numofapproved\":\"1\",\n\"id\":\"14202\"}, {\"last_update\":\"1193632105\", \"numofapproved\":\"1\",\n\"id\":\"14341\"}, {\"last_update\":\"1194011106\", \"numofapproved\":\"1\",\n\"id\":\"14741\"}, {\"last_update\":\"1194818628\", \"numofapproved\":\"1\",\n\"id\":\"15701\"}, {\"last_update\":\"1194875153\", \"numofapproved\":\"1\",\n\"id\":\"15861\"}, {\"last_update\":\"1194727029\", \"numofapproved\":\"1\",\n\"id\":\"15665\"}, {\"last_update\":\"1194950210\", \"numofapproved\":\"1\",\n\"id\":\"16122\"}, {\"last_update\":\"1194976681\", \"numofapproved\":\"1\",\n\"id\":\"16241\"}, {\"last_update\":\"1194979189\", \"numofapproved\":\"1\",\n\"id\":\"16281\"}, {\"last_update\":\"1194962224\", \"numofapproved\":\"1\",\n\"id\":\"16201\"}, {\"last_update\":\"1195046085\", \"numofapproved\":\"1\",\n\"id\":\"16481\"}, {\"last_update\":\"1195399919\", \"numofapproved\":\"1\",\n\"id\":\"17102\"}, {\"last_update\":\"1183113736\", \"numofapproved\":\"1\",\n\"id\":\"3782\"}, {\"last_update\":\"1183114202\", \"numofapproved\":\"1\",\n\"id\":\"3783\"}, {\"last_update\":\"1189017904\", \"numofapproved\":\"1\",\n\"id\":\"8441\"}, {\"last_update\":\"1189694944\", \"numofapproved\":\"1\",\n\"id\":\"8961\"}, {\"last_update\":\"1190766842\", \"numofapproved\":\"1\",\n\"id\":\"10181\"}, {\"last_update\":\"1190973066\", \"numofapproved\":\"1\",\n\"id\":\"10665\"}, {\"last_update\":\"1190990264\", \"numofapproved\":\"1\",\n\"id\":\"10702\"}, {\"last_update\":\"1193043204\", \"numofapproved\":\"1\",\n\"id\":\"13281\"}, {\"last_update\":\"1194627082\", \"numofapproved\":\"1\",\n\"id\":\"15561\"}, {\"last_update\":\"1194894589\", \"numofapproved\":\"1\",\n\"id\":\"15941\"}, {\"last_update\":\"1195485915\", \"numofapproved\":\"1\",\n\"id\":\"17281\"}, {\"last_update\":\"1195485806\", \"numofapproved\":\"1\",\n\"id\":\"17261\"}, {\"last_update\":\"1195498836\", \"numofapproved\":\"1\",\n\"id\":\"17361\"}, {\"last_update\":\"1195514951\", \"numofapproved\":\"1\",\n\"id\":\"17421\"}, {\"last_update\":\"1183722351\", \"numofapproved\":\"1\",\n\"id\":\"4261\"}, {\"last_update\":\"1184218083\", \"numofapproved\":\"1\",\n\"id\":\"4682\"}, {\"last_update\":\"1186848968\", \"numofapproved\":\"1\",\n\"id\":\"6441\"}, {\"last_update\":\"1187023846\", \"numofapproved\":\"1\",\n\"id\":\"6561\"}, {\"last_update\":\"1187870812\", \"numofapproved\":\"1\",\n\"id\":\"7342\"}, {\"last_update\":\"1188657717\", \"numofapproved\":\"1\",\n\"id\":\"7961\"}, {\"last_update\":\"1190541897\", \"numofapproved\":\"1\",\n\"id\":\"9841\"}, {\"last_update\":\"1190629135\", \"numofapproved\":\"1\",\n\"id\":\"9922\"}, {\"last_update\":\"1191226530\", \"numofapproved\":\"1\",\n\"id\":\"10922\"}, {\"last_update\":\"1191505214\", \"numofapproved\":\"1\",\n\"id\":\"11321\"}, {\"last_update\":\"1192304524\", \"numofapproved\":\"1\",\n\"id\":\"12541\"}, {\"last_update\":\"1193948730\", \"numofapproved\":\"1\",\n\"id\":\"14601\"}, {\"last_update\":\"1194073812\", \"numofapproved\":\"1\",\n\"id\":\"14801\"}, {\"last_update\":\"1194387224\", \"numofapproved\":\"1\",\n\"id\":\"14892\"}, {\"last_update\":\"1194464384\", \"numofapproved\":\"1\",\n\"id\":\"15223\"}, {\"last_update\":\"1194726799\", \"numofapproved\":\"1\",\n\"id\":\"15663\"}, {\"last_update\":\"1171969969\", \"numofapproved\":\"1\",\n\"id\":\"119\"}, {\"last_update\":\"1174444717\", \"numofapproved\":\"1\",\n\"id\":\"405\"}, {\"last_update\":\"1174899431\", \"numofapproved\":\"1\",\n\"id\":\"504\"}, {\"last_update\":\"1174899204\", \"numofapproved\":\"1\",\n\"id\":\"496\"}, {\"last_update\":\"1174925591\", \"numofapproved\":\"1\",\n\"id\":\"530\"}, {\"last_update\":\"1176902523\", \"numofapproved\":\"1\",\n\"id\":\"1008\"}, {\"last_update\":\"1172765523\", \"numofapproved\":\"1\",\n\"id\":\"232\"}, {\"last_update\":\"1173315950\", \"numofapproved\":\"1\",\n\"id\":\"260\"}, {\"last_update\":\"1174899524\", \"numofapproved\":\"1\",\n\"id\":\"509\"}, {\"last_update\":\"1174300691\", \"numofapproved\":\"1\",\n\"id\":\"373\"}, {\"last_update\":\"1175502917\", \"numofapproved\":\"1\",\n\"id\":\"625\"}, {\"last_update\":\"1175601578\", \"numofapproved\":\"1\",\n\"id\":\"662\"}, {\"last_update\":\"1175608600\", \"numofapproved\":\"1\",\n\"id\":\"684\"}, {\"last_update\":\"1176755309\", \"numofapproved\":\"1\",\n\"id\":\"985\"}, {\"last_update\":\"1171386411\", \"numofapproved\":\"1\",\n\"id\":\"45\"}, {\"last_update\":\"1171800366\", \"numofapproved\":\"1\",\n\"id\":\"81\"}, {\"last_update\":\"1172847417\", \"numofapproved\":\"1\",\n\"id\":\"241\"}, {\"last_update\":\"1174734904\", \"numofapproved\":\"1\",\n\"id\":\"462\"}, {\"last_update\":\"1174735234\", \"numofapproved\":\"1\",\n\"id\":\"469\"}, {\"last_update\":\"1174735074\", \"numofapproved\":\"1\",\n\"id\":\"465\"}, {\"last_update\":\"1175267646\", \"numofapproved\":\"1\",\n\"id\":\"566\"}, {\"last_update\":\"1176331857\", \"numofapproved\":\"1\",\n\"id\":\"888\"}, {\"last_update\":\"1176387926\", \"numofapproved\":\"1\",\n\"id\":\"890\"}, {\"last_update\":\"1176458401\", \"numofapproved\":\"1\",\n\"id\":\"904\"}, {\"last_update\":\"1173088626\", \"numofapproved\":\"1\",\n\"id\":\"244\"}, {\"last_update\":\"1173109009\", \"numofapproved\":\"1\",\n\"id\":\"246\"}, {\"last_update\":\"1173671557\", \"numofapproved\":\"1\",\n\"id\":\"284\"}, {\"last_update\":\"1174927658\", \"numofapproved\":\"1\",\n\"id\":\"532\"}, {\"last_update\":\"1175592399\", \"numofapproved\":\"1\",\n\"id\":\"661\"}, {\"last_update\":\"1176480402\", \"numofapproved\":\"1\",\n\"id\":\"941\"}, {\"last_update\":\"1176561564\", \"numofapproved\":\"1\",\n\"id\":\"945\"}, {\"last_update\":\"1172218707\", \"numofapproved\":\"1\",\n\"id\":\"180\"}, {\"last_update\":\"1172771475\", \"numofapproved\":\"1\",\n\"id\":\"233\"}, {\"last_update\":\"1173267863\", \"numofapproved\":\"1\",\n\"id\":\"257\"}, {\"last_update\":\"1176493803\", \"numofapproved\":\"1\",\n\"id\":\"963\"}, {\"last_update\":\"1171449646\", \"numofapproved\":\"1\",\n\"id\":\"49\"}, {\"last_update\":\"1171471549\", \"numofapproved\":\"1\",\n\"id\":\"51\"}, {\"last_update\":\"1171800487\", \"numofapproved\":\"1\",\n\"id\":\"88\"}, {\"last_update\":\"1171800431\", \"numofapproved\":\"1\",\n\"id\":\"85\"}, {\"last_update\":\"1175502995\", \"numofapproved\":\"1\",\n\"id\":\"627\"}, {\"last_update\":\"1175712797\", \"numofapproved\":\"1\",\n\"id\":\"704\"}, {\"last_update\":\"1171122384\", \"numofapproved\":\"1\",\n\"id\":\"3\"}, {\"last_update\":\"1171380774\", \"numofapproved\":\"1\", \"id\":\"26\"},\n{\"last_update\":\"1171904757\", \"numofapproved\":\"1\", \"id\":\"99\"},\n{\"last_update\":\"1174300705\", \"numofapproved\":\"1\", \"id\":\"374\"},\n{\"last_update\":\"1174924802\", \"numofapproved\":\"1\", \"id\":\"526\"},\n{\"last_update\":\"1175935441\", \"numofapproved\":\"1\", \"id\":\"801\"},\n{\"last_update\":\"1175610915\", \"numofapproved\":\"1\", \"id\":\"686\"},\n{\"last_update\":\"1171977081\", \"numofapproved\":\"1\", \"id\":\"125\"},\n{\"last_update\":\"1173165324\", \"numofapproved\":\"1\", \"id\":\"249\"},\n{\"last_update\":\"1173888337\", \"numofapproved\":\"1\", \"id\":\"319\"},\n{\"last_update\":\"1173889473\", \"numofapproved\":\"1\", \"id\":\"331\"},\n{\"last_update\":\"1172180902\", \"numofapproved\":\"1\", \"id\":\"175\"},\n{\"last_update\":\"1174058063\", \"numofapproved\":\"1\", \"id\":\"354\"},\n{\"last_update\":\"1174300674\", \"numofapproved\":\"1\", \"id\":\"372\"},\n{\"last_update\":\"1171886332\", \"numofapproved\":\"1\", \"id\":\"93\"},\n{\"last_update\":\"1176731068\", \"numofapproved\":\"1\", \"id\":\"1003\"},\n{\"last_update\":\"1178645848\", \"numofapproved\":\"1\", \"id\":\"1306\"},\n{\"last_update\":\"1178706683\", \"numofapproved\":\"1\", \"id\":\"1321\"},\n{\"last_update\":\"1179240076\", \"numofapproved\":\"1\", \"id\":\"1406\"},\n{\"last_update\":\"1180380411\", \"numofapproved\":\"1\", \"id\":\"1862\"},\n{\"last_update\":\"1180683561\", \"numofapproved\":\"1\", \"id\":\"2041\"},\n{\"last_update\":\"1181229731\", \"numofapproved\":\"1\", \"id\":\"2521\"},\n{\"last_update\":\"1182210982\", \"numofapproved\":\"1\", \"id\":\"3203\"},\n{\"last_update\":\"1182421105\", \"numofapproved\":\"1\", \"id\":\"3401\"},\n{\"last_update\":\"1182199404\", \"numofapproved\":\"1\", \"id\":\"3202\"},\n{\"last_update\":\"1182258596\", \"numofapproved\":\"1\", \"id\":\"3241\"},\n{\"last_update\":\"1183556842\", \"numofapproved\":\"1\", \"id\":\"4161\"},\n{\"last_update\":\"1184146825\", \"numofapproved\":\"1\", \"id\":\"4601\"},\n{\"last_update\":\"1184771229\", \"numofapproved\":\"1\", \"id\":\"4981\"},\n{\"last_update\":\"1185355415\", \"numofapproved\":\"1\", \"id\":\"5401\"},\n{\"last_update\":\"1185377130\", \"numofapproved\":\"1\", \"id\":\"5481\"},\n{\"last_update\":\"1185483994\", \"numofapproved\":\"1\", \"id\":\"5621\"},\n{\"last_update\":\"1186496707\", \"numofapproved\":\"1\", \"id\":\"6261\"},\n{\"last_update\":\"1187704347\", \"numofapproved\":\"1\", \"id\":\"7001\"},\n{\"last_update\":\"1187758331\", \"numofapproved\":\"1\", \"id\":\"7101\"},\n{\"last_update\":\"1187765716\", \"numofapproved\":\"1\", \"id\":\"7161\"},\n{\"last_update\":\"1188284185\", \"numofapproved\":\"1\", \"id\":\"7581\"},\n{\"last_update\":\"1188463286\", \"numofapproved\":\"1\", \"id\":\"7761\"},\n{\"last_update\":\"1189012058\", \"numofapproved\":\"1\", \"id\":\"8421\"},\n{\"last_update\":\"1189814265\", \"numofapproved\":\"1\", \"id\":\"9061\"},\n{\"last_update\":\"1180880867\", \"numofapproved\":\"1\", \"id\":\"2161\"},\n{\"last_update\":\"1181218244\", \"numofapproved\":\"1\", \"id\":\"2463\"},\n{\"last_update\":\"1183515137\", \"numofapproved\":\"1\", \"id\":\"4141\"},\n{\"last_update\":\"1183515248\", \"numofapproved\":\"1\", \"id\":\"4142\"},\n{\"last_update\":\"1188311100\", \"numofapproved\":\"1\", \"id\":\"7641\"},\n{\"last_update\":\"1190011501\", \"numofapproved\":\"1\", \"id\":\"9201\"},\n{\"last_update\":\"1190012299\", \"numofapproved\":\"1\", \"id\":\"9221\"},\n{\"last_update\":\"1190149196\", \"numofapproved\":\"1\", \"id\":\"9382\"},\n{\"last_update\":\"1190202046\", \"numofapproved\":\"1\", \"id\":\"9461\"},\n{\"last_update\":\"1190626607\", \"numofapproved\":\"1\", \"id\":\"9881\"},\n{\"last_update\":\"1190632230\", \"numofapproved\":\"1\", \"id\":\"9941\"},\n{\"last_update\":\"1190660429\", \"numofapproved\":\"1\", \"id\":\"10002\"},\n{\"last_update\":\"1190819102\", \"numofapproved\":\"1\", \"id\":\"10341\"},\n{\"last_update\":\"1190824319\", \"numofapproved\":\"1\", \"id\":\"10382\"},\n{\"last_update\":\"1190825791\", \"numofapproved\":\"1\", \"id\":\"10402\"},\n{\"last_update\":\"1190847397\", \"numofapproved\":\"1\", \"id\":\"10421\"},\n{\"last_update\":\"1190876679\", \"numofapproved\":\"1\", \"id\":\"10441\"},\n{\"last_update\":\"1190918894\", \"numofapproved\":\"1\", \"id\":\"10541\"},\n{\"last_update\":\"1190924961\", \"numofapproved\":\"1\", \"id\":\"10582\"},\n{\"last_update\":\"1190991179\", \"numofapproved\":\"1\", \"id\":\"10723\"},\n{\"last_update\":\"1190663960\", \"numofapproved\":\"1\", \"id\":\"10042\"},\n{\"last_update\":\"1191222270\", \"numofapproved\":\"1\", \"id\":\"10881\"},\n{\"last_update\":\"1178869580\", \"numofapproved\":\"1\", \"id\":\"1355\"},\n{\"last_update\":\"1180054057\", \"numofapproved\":\"1\", \"id\":\"1655\"},\n{\"last_update\":\"1180428815\", \"numofapproved\":\"1\", \"id\":\"1881\"},\n{\"last_update\":\"1183369278\", \"numofapproved\":\"1\", \"id\":\"3901\"},\n{\"last_update\":\"1185018445\", \"numofapproved\":\"1\", \"id\":\"5163\"},\n{\"last_update\":\"1185201628\", \"numofapproved\":\"1\", \"id\":\"5221\"},\n{\"last_update\":\"1189345395\", \"numofapproved\":\"1\", \"id\":\"8741\"},\n{\"last_update\":\"1191406141\", \"numofapproved\":\"1\", \"id\":\"11041\"},\n{\"last_update\":\"1191410914\", \"numofapproved\":\"1\", \"id\":\"11067\"},\n{\"last_update\":\"1191558362\", \"numofapproved\":\"1\", \"id\":\"11461\"},\n{\"last_update\":\"1191584539\", \"numofapproved\":\"1\", \"id\":\"11541\"},\n{\"last_update\":\"1191584660\", \"numofapproved\":\"1\", \"id\":\"11542\"},\n{\"last_update\":\"1191599491\", \"numofapproved\":\"1\", \"id\":\"11661\"},\n{\"last_update\":\"1191813292\", \"numofapproved\":\"1\", \"id\":\"11781\"},\n{\"last_update\":\"1191856553\", \"numofapproved\":\"1\", \"id\":\"11842\"},\n{\"last_update\":\"1191861142\", \"numofapproved\":\"1\", \"id\":\"11862\"},\n{\"last_update\":\"1177509523\", \"numofapproved\":\"1\", \"id\":\"1041\"},\n{\"last_update\":\"1190627650\", \"numofapproved\":\"1\", \"id\":\"9901\"},\n{\"last_update\":\"1192034749\", \"numofapproved\":\"1\", \"id\":\"12141\"},\n{\"last_update\":\"1192165574\", \"numofapproved\":\"1\", \"id\":\"12401\"},\n{\"last_update\":\"1192431750\", \"numofapproved\":\"1\", \"id\":\"12581\"},\n{\"last_update\":\"1192536591\", \"numofapproved\":\"1\", \"id\":\"12721\"},\n{\"last_update\":\"1193035428\", \"numofapproved\":\"1\", \"id\":\"13261\"},\n{\"last_update\":\"1193239266\", \"numofapproved\":\"1\", \"id\":\"13581\"},\n{\"last_update\":\"1193314455\", \"numofapproved\":\"1\", \"id\":\"13841\"},\n{\"last_update\":\"1193333733\", \"numofapproved\":\"1\", \"id\":\"13901\"},\n{\"last_update\":\"1193389116\", \"numofapproved\":\"1\", \"id\":\"14001\"},\n{\"last_update\":\"1184970339\", \"numofapproved\":\"1\", \"id\":\"5121\"},\n{\"last_update\":\"1190892760\", \"numofapproved\":\"1\", \"id\":\"10481\"},\n{\"last_update\":\"1192823398\", \"numofapproved\":\"1\", \"id\":\"13182\"},\n{\"last_update\":\"1193911671\", \"numofapproved\":\"1\", \"id\":\"14541\"},\n{\"last_update\":\"1193916761\", \"numofapproved\":\"1\", \"id\":\"14543\"},\n{\"last_update\":\"1194212665\", \"numofapproved\":\"1\", \"id\":\"14881\"},\n{\"last_update\":\"1194248205\", \"numofapproved\":\"1\", \"id\":\"14921\"},\n{\"last_update\":\"1194513600\", \"numofapproved\":\"1\", \"id\":\"15110\"},\n{\"last_update\":\"1194539704\", \"numofapproved\":\"1\", \"id\":\"15361\"},\n{\"last_update\":\"1194569643\", \"numofapproved\":\"1\", \"id\":\"15112\"},\n{\"last_update\":\"1194619794\", \"numofapproved\":\"1\", \"id\":\"15441\"},\n{\"last_update\":\"1194623621\", \"numofapproved\":\"1\", \"id\":\"15501\"},\n{\"last_update\":\"1194624477\", \"numofapproved\":\"1\", \"id\":\"15521\"},\n{\"last_update\":\"1194635685\", \"numofapproved\":\"1\", \"id\":\"15602\"},\n{\"last_update\":\"1179311539\", \"numofapproved\":\"1\", \"id\":\"1393\"},\n{\"last_update\":\"1179672561\", \"numofapproved\":\"1\", \"id\":\"1521\"},\n{\"last_update\":\"1180712413\", \"numofapproved\":\"1\", \"id\":\"2101\"},\n{\"last_update\":\"1181646264\", \"numofapproved\":\"1\", \"id\":\"2821\"},\n{\"last_update\":\"1181807696\", \"numofapproved\":\"1\", \"id\":\"2921\"},\n{\"last_update\":\"1181824523\", \"numofapproved\":\"1\", \"id\":\"2942\"},\n{\"last_update\":\"1181835089\", \"numofapproved\":\"1\", \"id\":\"2981\"},\n{\"last_update\":\"1182000147\", \"numofapproved\":\"1\", \"id\":\"3141\"},\n{\"last_update\":\"1182952133\", \"numofapproved\":\"1\", \"id\":\"3641\"},\n{\"last_update\":\"1188811518\", \"numofapproved\":\"1\", \"id\":\"8101\"},\n{\"last_update\":\"1188975549\", \"numofapproved\":\"1\", \"id\":\"8321\"},\n{\"last_update\":\"1190122760\", \"numofapproved\":\"1\", \"id\":\"9301\"},\n{\"last_update\":\"1190124712\", \"numofapproved\":\"1\", \"id\":\"9321\"},\n{\"last_update\":\"1194526560\", \"numofapproved\":\"1\", \"id\":\"15281\"},\n{\"last_update\":\"1195149112\", \"numofapproved\":\"1\", \"id\":\"16821\"},\n{\"last_update\":\"1179823256\", \"numofapproved\":\"1\", \"id\":\"1602\"},\n{\"last_update\":\"1186332011\", \"numofapproved\":\"1\", \"id\":\"6165\"},\n{\"last_update\":\"1187263451\", \"numofapproved\":\"1\", \"id\":\"6781\"},\n{\"last_update\":\"1190312346\", \"numofapproved\":\"1\", \"id\":\"9621\"},\n{\"last_update\":\"1193178728\", \"numofapproved\":\"1\", \"id\":\"13525\"},\n{\"last_update\":\"1193908534\", \"numofapproved\":\"1\", \"id\":\"14524\"},\n{\"last_update\":\"1194279992\", \"numofapproved\":\"1\", \"id\":\"15001\"},\n{\"last_update\":\"1194947169\", \"numofapproved\":\"1\", \"id\":\"16104\"},\n{\"last_update\":\"1195139978\", \"numofapproved\":\"1\", \"id\":\"16801\"},\n{\"last_update\":\"1195152323\", \"numofapproved\":\"1\", \"id\":\"16841\"},\n{\"last_update\":\"1188086146\", \"numofapproved\":\"1\", \"id\":\"7428\"},\n{\"last_update\":\"1192143475\", \"numofapproved\":\"1\", \"id\":\"12341\"},\n{\"last_update\":\"1192529949\", \"numofapproved\":\"1\", \"id\":\"12664\"},\n{\"last_update\":\"1192721072\", \"numofapproved\":\"1\", \"id\":\"13041\"},\n{\"last_update\":\"1193844156\", \"numofapproved\":\"1\", \"id\":\"14501\"},\n{\"last_update\":\"1177597683\", \"numofapproved\":\"1\", \"id\":\"1063\"},\n{\"last_update\":\"1180975406\", \"numofapproved\":\"1\", \"id\":\"2184\"},\n{\"last_update\":\"1184681435\", \"numofapproved\":\"1\", \"id\":\"4914\"},\n{\"last_update\":\"1187596457\", \"numofapproved\":\"1\", \"id\":\"6922\"},\n{\"last_update\":\"1190661113\", \"numofapproved\":\"1\", \"id\":\"10003\"},\n{\"last_update\":\"1192721357\", \"numofapproved\":\"1\", \"id\":\"13042\"},\n{\"last_update\":\"1193130120\", \"numofapproved\":\"1\", \"id\":\"13461\"},\n{\"last_update\":\"1193388868\", \"numofapproved\":\"1\", \"id\":\"13953\"},\n{\"last_update\":\"1194861534\", \"numofapproved\":\"1\", \"id\":\"15821\"},\n{\"last_update\":\"1182357592\", \"numofapproved\":\"1\", \"id\":\"3345\"},\n{\"last_update\":\"1183722862\", \"numofapproved\":\"1\", \"id\":\"4262\"},\n{\"last_update\":\"1186066354\", \"numofapproved\":\"1\", \"id\":\"6041\"},\n{\"last_update\":\"1192698982\", \"numofapproved\":\"1\", \"id\":\"12981\"},\n{\"last_update\":\"1181237191\", \"numofapproved\":\"1\", \"id\":\"2561\"},\n{\"last_update\":\"1184569090\", \"numofapproved\":\"1\", \"id\":\"4906\"},\n{\"last_update\":\"1185397555\", \"numofapproved\":\"1\", \"id\":\"5501\"},\n{\"last_update\":\"1185541935\", \"numofapproved\":\"1\", \"id\":\"5681\"},\n{\"last_update\":\"1193385832\", \"numofapproved\":\"1\", \"id\":\"13941\"},\n{\"last_update\":\"1185482424\", \"numofapproved\":\"1\", \"id\":\"5581\"},\n{\"last_update\":\"1195508796\", \"numofapproved\":\"1\", \"id\":\"17401\"},\n{\"last_update\":\"1178718386\", \"numofapproved\":\"1\", \"id\":\"1347\"},\n{\"last_update\":\"1178788813\", \"numofapproved\":\"1\", \"id\":\"1351\"},\n{\"last_update\":\"1178877332\", \"numofapproved\":\"1\", \"id\":\"1358\"},\n{\"last_update\":\"1183208679\", \"numofapproved\":\"1\", \"id\":\"3861\"},\n{\"last_update\":\"1187885439\", \"numofapproved\":\"1\", \"id\":\"7347\"},\n{\"last_update\":\"1188985190\", \"numofapproved\":\"1\", \"id\":\"8341\"},\n{\"last_update\":\"1189687132\", \"numofapproved\":\"1\", \"id\":\"8941\"},\n{\"last_update\":\"1189864330\", \"numofapproved\":\"1\", \"id\":\"9121\"},\n{\"last_update\":\"1190990605\", \"numofapproved\":\"1\", \"id\":\"10709\"},\n{\"last_update\":\"1192634449\", \"numofapproved\":\"1\", \"id\":\"12861\"},\n{\"last_update\":\"1194723756\", \"numofapproved\":\"1\", \"id\":\"15641\"},\n{\"last_update\":\"1194792428\", \"numofapproved\":\"1\", \"id\":\"15682\"},\n{\"last_update\":\"1194725734\", \"numofapproved\":\"1\", \"id\":\"15661\"},\n{\"last_update\":\"1194945618\", \"numofapproved\":\"1\", \"id\":\"16061\"},\n{\"last_update\":\"1194946006\", \"numofapproved\":\"1\", \"id\":\"16081\"},\n{\"last_update\":\"1194949774\", \"numofapproved\":\"1\", \"id\":\"16121\"},\n{\"last_update\":\"1194950925\", \"numofapproved\":\"1\", \"id\":\"16126\"},\n{\"last_update\":\"1194979238\", \"numofapproved\":\"1\", \"id\":\"16282\"},\n{\"last_update\":\"1195051013\", \"numofapproved\":\"1\", \"id\":\"16543\"},\n{\"last_update\":\"1195050956\", \"numofapproved\":\"1\", \"id\":\"16542\"},\n{\"last_update\":\"1195047036\", \"numofapproved\":\"1\", \"id\":\"16501\"},\n{\"last_update\":\"1195221919\", \"numofapproved\":\"1\", \"id\":\"16942\"},\n{\"last_update\":\"1178035892\", \"numofapproved\":\"1\", \"id\":\"1221\"},\n{\"last_update\":\"1178570265\", \"numofapproved\":\"1\", \"id\":\"1302\"},\n{\"last_update\":\"1178811921\", \"numofapproved\":\"1\", \"id\":\"1354\"},\n{\"last_update\":\"1182344326\", \"numofapproved\":\"1\", \"id\":\"3321\"},\n{\"last_update\":\"1184999048\", \"numofapproved\":\"1\", \"id\":\"5141\"},\n{\"last_update\":\"1188994511\", \"numofapproved\":\"1\", \"id\":\"8361\"},\n{\"last_update\":\"1189161726\", \"numofapproved\":\"1\", \"id\":\"8601\"},\n{\"last_update\":\"1190500875\", \"numofapproved\":\"1\", \"id\":\"9803\"},\n{\"last_update\":\"1190817424\", \"numofapproved\":\"1\", \"id\":\"10321\"},\n{\"last_update\":\"1191327796\", \"numofapproved\":\"1\", \"id\":\"11001\"},\n{\"last_update\":\"1191410544\", \"numofapproved\":\"1\", \"id\":\"11062\"},\n{\"last_update\":\"1192009739\", \"numofapproved\":\"1\", \"id\":\"12062\"},\n{\"last_update\":\"1193973669\", \"numofapproved\":\"1\", \"id\":\"14662\"},\n{\"last_update\":\"1194035149\", \"numofapproved\":\"1\", \"id\":\"14783\"},\n{\"last_update\":\"1194465519\", \"numofapproved\":\"1\", \"id\":\"15106\"},\n{\"last_update\":\"1194464336\", \"numofapproved\":\"1\", \"id\":\"15222\"},\n{\"last_update\":\"1194861398\", \"numofapproved\":\"1\", \"id\":\"15802\"},\n{\"last_update\":\"1194950791\", \"numofapproved\":\"1\", \"id\":\"16125\"},\n{\"last_update\":\"1195501394\", \"numofapproved\":\"1\", \"id\":\"17381\"},\n{\"last_update\":\"1195546583\", \"numofapproved\":\"1\", \"id\":\"17461\"},\n{\"last_update\":\"1177607652\", \"numofapproved\":\"1\", \"id\":\"1048\"},\n{\"last_update\":\"1182349136\", \"numofapproved\":\"1\", \"id\":\"3322\"},\n{\"last_update\":\"1184217665\", \"numofapproved\":\"1\", \"id\":\"4681\"},\n{\"last_update\":\"1185510733\", \"numofapproved\":\"1\", \"id\":\"5641\"},\n{\"last_update\":\"1187875988\", \"numofapproved\":\"1\", \"id\":\"7345\"},\n{\"last_update\":\"1188384227\", \"numofapproved\":\"1\", \"id\":\"7701\"},\n{\"last_update\":\"1188935650\", \"numofapproved\":\"1\", \"id\":\"8261\"},\n{\"last_update\":\"1188951982\", \"numofapproved\":\"1\", \"id\":\"8301\"},\n{\"last_update\":\"1190391010\", \"numofapproved\":\"1\", \"id\":\"9701\"},\n{\"last_update\":\"1191169581\", \"numofapproved\":\"1\", \"id\":\"10841\"},\n{\"last_update\":\"1194435269\", \"numofapproved\":\"1\", \"id\":\"15101\"},\n{\"last_update\":\"1171800457\", \"numofapproved\":\"1\", \"id\":\"86\"},\n{\"last_update\":\"1171968036\", \"numofapproved\":\"1\", \"id\":\"116\"},\n{\"last_update\":\"1171984640\", \"numofapproved\":\"1\", \"id\":\"129\"},\n{\"last_update\":\"1171987101\", \"numofapproved\":\"1\", \"id\":\"130\"},\n{\"last_update\":\"1172588327\", \"numofapproved\":\"1\", \"id\":\"213\"},\n{\"last_update\":\"1173736730\", \"numofapproved\":\"1\", \"id\":\"306\"},\n{\"last_update\":\"1174735009\", \"numofapproved\":\"1\", \"id\":\"463\"},\n{\"last_update\":\"1172314484\", \"numofapproved\":\"1\", \"id\":\"192\"},\n{\"last_update\":\"1172580739\", \"numofapproved\":\"1\", \"id\":\"212\"},\n{\"last_update\":\"1173889335\", \"numofapproved\":\"1\", \"id\":\"328\"},\n{\"last_update\":\"1171799339\", \"numofapproved\":\"1\", \"id\":\"79\"},\n{\"last_update\":\"1171882669\", \"numofapproved\":\"1\", \"id\":\"91\"},\n{\"last_update\":\"1172561300\", \"numofapproved\":\"1\", \"id\":\"207\"},\n{\"last_update\":\"1172565919\", \"numofapproved\":\"1\", \"id\":\"209\"},\n{\"last_update\":\"1172600401\", \"numofapproved\":\"1\", \"id\":\"217\"},\n{\"last_update\":\"1174040553\", \"numofapproved\":\"1\", \"id\":\"350\"},\n{\"last_update\":\"1174300376\", \"numofapproved\":\"1\", \"id\":\"365\"},\n{\"last_update\":\"1171800419\", \"numofapproved\":\"1\", \"id\":\"84\"},\n{\"last_update\":\"1171800471\", \"numofapproved\":\"1\", \"id\":\"87\"},\n{\"last_update\":\"1171904826\", \"numofapproved\":\"1\", \"id\":\"102\"},\n{\"last_update\":\"1171962248\", \"numofapproved\":\"1\", \"id\":\"110\"},\n{\"last_update\":\"1171968056\", \"numofapproved\":\"1\", \"id\":\"117\"},\n{\"last_update\":\"1172180757\", \"numofapproved\":\"1\", \"id\":\"174\"},\n{\"last_update\":\"1172249286\", \"numofapproved\":\"1\", \"id\":\"186\"},\n{\"last_update\":\"1172331355\", \"numofapproved\":\"1\", \"id\":\"194\"},\n{\"last_update\":\"1172838799\", \"numofapproved\":\"1\", \"id\":\"235\"},\n{\"last_update\":\"1173839361\", \"numofapproved\":\"1\", \"id\":\"316\"},\n{\"last_update\":\"1176141087\", \"numofapproved\":\"1\", \"id\":\"809\"},\n{\"last_update\":\"1176293168\", \"numofapproved\":\"1\", \"id\":\"827\"},\n{\"last_update\":\"1176314927\", \"numofapproved\":\"1\", \"id\":\"887\"},\n{\"last_update\":\"1172147490\", \"numofapproved\":\"1\", \"id\":\"169\"},\n{\"last_update\":\"1172673371\", \"numofapproved\":\"1\", \"id\":\"225\"},\n{\"last_update\":\"1175021309\", \"numofapproved\":\"1\", \"id\":\"539\"},\n{\"last_update\":\"1175719394\", \"numofapproved\":\"1\", \"id\":\"708\"},\n{\"last_update\":\"1175797177\", \"numofapproved\":\"1\", \"id\":\"741\"},\n{\"last_update\":\"1175797204\", \"numofapproved\":\"1\", \"id\":\"761\"},\n{\"last_update\":\"1173888948\", \"numofapproved\":\"1\", \"id\":\"323\"},\n{\"last_update\":\"1171050355\", \"numofapproved\":\"1\", \"id\":\"1\"},\n{\"last_update\":\"1171904868\", \"numofapproved\":\"1\", \"id\":\"104\"},\n{\"last_update\":\"1174301476\", \"numofapproved\":\"1\", \"id\":\"392\"},\n{\"last_update\":\"1174396679\", \"numofapproved\":\"1\", \"id\":\"401\"},\n{\"last_update\":\"1174735025\", \"numofapproved\":\"1\", \"id\":\"464\"},\n{\"last_update\":\"1171894147\", \"numofapproved\":\"1\", \"id\":\"94\"},\n{\"last_update\":\"1172226240\", \"numofapproved\":\"1\", \"id\":\"181\"},\n{\"last_update\":\"1172442130\", \"numofapproved\":\"1\", \"id\":\"195\"},\n{\"last_update\":\"1174300588\", \"numofapproved\":\"1\", \"id\":\"370\"},\n{\"last_update\":\"1174899082\", \"numofapproved\":\"1\", \"id\":\"490\"},\n{\"last_update\":\"1174899309\", \"numofapproved\":\"1\", \"id\":\"501\"},\n{\"last_update\":\"1173724444\", \"numofapproved\":\"1\", \"id\":\"304\"},\n{\"last_update\":\"1176314883\", \"numofapproved\":\"1\", \"id\":\"886\"},\n{\"last_update\":\"1173284377\", \"numofapproved\":\"1\", \"id\":\"259\"},\n{\"last_update\":\"1172244974\", \"numofapproved\":\"1\", \"id\":\"184\"},\n{\"last_update\":\"1173825356\", \"numofapproved\":\"1\", \"id\":\"315\"},\n{\"last_update\":\"1174898980\", \"numofapproved\":\"1\", \"id\":\"485\"},\n{\"last_update\":\"1175713133\", \"numofapproved\":\"1\", \"id\":\"706\"},\n{\"last_update\":\"1175872869\", \"numofapproved\":\"1\", \"id\":\"784\"},\n{\"last_update\":\"1174301161\", \"numofapproved\":\"1\", \"id\":\"380\"},\n{\"last_update\":\"1176710519\", \"numofapproved\":\"1\", \"id\":\"1002\"},\n{\"last_update\":\"1176776871\", \"numofapproved\":\"1\", \"id\":\"1006\"},\n{\"last_update\":\"1176383102\", \"numofapproved\":\"1\", \"id\":\"901\"},\n{\"last_update\":\"1176391153\", \"numofapproved\":\"1\", \"id\":\"902\"},\n{\"last_update\":\"1176562039\", \"numofapproved\":\"1\", \"id\":\"946\"},\n{\"last_update\":\"1175713172\", \"numofapproved\":\"1\", \"id\":\"668\"},\n{\"last_update\":\"1178045208\", \"numofapproved\":\"1\", \"id\":\"1204\"},\n{\"last_update\":\"1178648231\", \"numofapproved\":\"1\", \"id\":\"1307\"},\n{\"last_update\":\"1178876638\", \"numofapproved\":\"1\", \"id\":\"1362\"},\n{\"last_update\":\"1181120419\", \"numofapproved\":\"1\", \"id\":\"2341\"},\n{\"last_update\":\"1181217997\", \"numofapproved\":\"1\", \"id\":\"2462\"},\n{\"last_update\":\"1181292688\", \"numofapproved\":\"1\", \"id\":\"2622\"},\n{\"last_update\":\"1182246090\", \"numofapproved\":\"1\", \"id\":\"3205\"},\n{\"last_update\":\"1182982710\", \"numofapproved\":\"1\", \"id\":\"3681\"},\n{\"last_update\":\"1177496084\", \"numofapproved\":\"1\", \"id\":\"1021\"},\n{\"last_update\":\"1177496190\", \"numofapproved\":\"1\", \"id\":\"1022\"},\n{\"last_update\":\"1178310654\", \"numofapproved\":\"1\", \"id\":\"1261\"},\n{\"last_update\":\"1182861963\", \"numofapproved\":\"1\", \"id\":\"3582\"},\n{\"last_update\":\"1183392466\", \"numofapproved\":\"1\", \"id\":\"3981\"},\n{\"last_update\":\"1183971409\", \"numofapproved\":\"1\", \"id\":\"4404\"},\n{\"last_update\":\"1183984082\", \"numofapproved\":\"1\", \"id\":\"4421\"},\n{\"last_update\":\"1184101764\", \"numofapproved\":\"1\", \"id\":\"4581\"},\n{\"last_update\":\"1185805036\", \"numofapproved\":\"1\", \"id\":\"5821\"},\n{\"last_update\":\"1186071563\", \"numofapproved\":\"1\", \"id\":\"6061\"},\n{\"last_update\":\"1186331614\", \"numofapproved\":\"1\", \"id\":\"6221\"},\n{\"last_update\":\"1187103429\", \"numofapproved\":\"1\", \"id\":\"6623\"},\n{\"last_update\":\"1187359405\", \"numofapproved\":\"1\", \"id\":\"6901\"},\n{\"last_update\":\"1187764462\", \"numofapproved\":\"1\", \"id\":\"7121\"},\n{\"last_update\":\"1187765742\", \"numofapproved\":\"1\", \"id\":\"7181\"},\n{\"last_update\":\"1187821663\", \"numofapproved\":\"1\", \"id\":\"7281\"},\n{\"last_update\":\"1187851593\", \"numofapproved\":\"1\", \"id\":\"7301\"},\n{\"last_update\":\"1188829369\", \"numofapproved\":\"1\", \"id\":\"8141\"},\n{\"last_update\":\"1189006834\", \"numofapproved\":\"1\", \"id\":\"8401\"},\n{\"last_update\":\"1189656411\", \"numofapproved\":\"1\", \"id\":\"8901\"},\n{\"last_update\":\"1181824325\", \"numofapproved\":\"1\", \"id\":\"2961\"},\n{\"last_update\":\"1184699326\", \"numofapproved\":\"1\", \"id\":\"4922\"},\n{\"last_update\":\"1185981618\", \"numofapproved\":\"1\", \"id\":\"5981\"},\n{\"last_update\":\"1186476979\", \"numofapproved\":\"1\", \"id\":\"6169\"},\n{\"last_update\":\"1186501212\", \"numofapproved\":\"1\", \"id\":\"6301\"},\n{\"last_update\":\"1187111728\", \"numofapproved\":\"1\", \"id\":\"6624\"},\n{\"last_update\":\"1187275194\", \"numofapproved\":\"1\", \"id\":\"6821\"},\n{\"last_update\":\"1190232587\", \"numofapproved\":\"1\", \"id\":\"9501\"},\n{\"last_update\":\"1190379779\", \"numofapproved\":\"1\", \"id\":\"9661\"},\n{\"last_update\":\"1190500551\", \"numofapproved\":\"1\", \"id\":\"9801\"},\n{\"last_update\":\"1190555711\", \"numofapproved\":\"1\", \"id\":\"9861\"},\n{\"last_update\":\"1190664200\", \"numofapproved\":\"1\", \"id\":\"10061\"},\n{\"last_update\":\"1190662067\", \"numofapproved\":\"1\", \"id\":\"10021\"},\n{\"last_update\":\"1190887692\", \"numofapproved\":\"1\", \"id\":\"10461\"},\n{\"last_update\":\"1190887880\", \"numofapproved\":\"1\", \"id\":\"10462\"},\n{\"last_update\":\"1190924576\", \"numofapproved\":\"1\", \"id\":\"10581\"},\n{\"last_update\":\"1190990748\", \"numofapproved\":\"1\", \"id\":\"10713\"},\n{\"last_update\":\"1190990297\", \"numofapproved\":\"1\", \"id\":\"10703\"},\n{\"last_update\":\"1182792178\", \"numofapproved\":\"1\", \"id\":\"3541\"},\n{\"last_update\":\"1189505682\", \"numofapproved\":\"1\", \"id\":\"8781\"},\n{\"last_update\":\"1191410630\", \"numofapproved\":\"1\", \"id\":\"11081\"},\n{\"last_update\":\"1191431148\", \"numofapproved\":\"1\", \"id\":\"11141\"},\n{\"last_update\":\"1191446393\", \"numofapproved\":\"1\", \"id\":\"11181\"},\n{\"last_update\":\"1191559326\", \"numofapproved\":\"1\", \"id\":\"11481\"},\n{\"last_update\":\"1191860159\", \"numofapproved\":\"1\", \"id\":\"11861\"},\n{\"last_update\":\"1191933842\", \"numofapproved\":\"1\", \"id\":\"11901\"},\n{\"last_update\":\"1181765760\", \"numofapproved\":\"1\", \"id\":\"2901\"},\n{\"last_update\":\"1187098770\", \"numofapproved\":\"1\", \"id\":\"6622\"},\n{\"last_update\":\"1192155125\", \"numofapproved\":\"1\", \"id\":\"12382\"},\n{\"last_update\":\"1192449036\", \"numofapproved\":\"1\", \"id\":\"12601\"},\n{\"last_update\":\"1192604489\", \"numofapproved\":\"1\", \"id\":\"12781\"},\n{\"last_update\":\"1193265229\", \"numofapproved\":\"1\", \"id\":\"13681\"},\n{\"last_update\":\"1193304550\", \"numofapproved\":\"1\", \"id\":\"13781\"},\n{\"last_update\":\"1193401945\", \"numofapproved\":\"1\", \"id\":\"14101\"},\n{\"last_update\":\"1193305327\", \"numofapproved\":\"1\", \"id\":\"13801\"},\n{\"last_update\":\"1179912412\", \"numofapproved\":\"1\", \"id\":\"1722\"},\n{\"last_update\":\"1188295203\", \"numofapproved\":\"1\", \"id\":\"7621\"},\n{\"last_update\":\"1188580008\", \"numofapproved\":\"1\", \"id\":\"7881\"},\n{\"last_update\":\"1189115708\", \"numofapproved\":\"1\", \"id\":\"8521\"},\n{\"last_update\":\"1193864375\", \"numofapproved\":\"1\", \"id\":\"14522\"},\n{\"last_update\":\"1193973963\", \"numofapproved\":\"1\", \"id\":\"14666\"},\n{\"last_update\":\"1194003054\", \"numofapproved\":\"1\", \"id\":\"14701\"},\n{\"last_update\":\"1194262755\", \"numofapproved\":\"1\", \"id\":\"14885\"},\n{\"last_update\":\"1194262860\", \"numofapproved\":\"1\", \"id\":\"14886\"},\n{\"last_update\":\"1194366475\", \"numofapproved\":\"1\", \"id\":\"15042\"},\n{\"last_update\":\"1194505568\", \"numofapproved\":\"1\", \"id\":\"15108\"},\n{\"last_update\":\"1194507434\", \"numofapproved\":\"1\", \"id\":\"15109\"},\n{\"last_update\":\"1194625505\", \"numofapproved\":\"1\", \"id\":\"15542\"},\n{\"last_update\":\"1194635569\", \"numofapproved\":\"1\", \"id\":\"15583\"},\n{\"last_update\":\"1179319405\", \"numofapproved\":\"1\", \"id\":\"1394\"},\n{\"last_update\":\"1179409867\", \"numofapproved\":\"1\", \"id\":\"1441\"},\n{\"last_update\":\"1179431647\", \"numofapproved\":\"1\", \"id\":\"1481\"},\n{\"last_update\":\"1179842302\", \"numofapproved\":\"1\", \"id\":\"1667\"},\n{\"last_update\":\"1180710254\", \"numofapproved\":\"1\", \"id\":\"2081\"},\n{\"last_update\":\"1181855583\", \"numofapproved\":\"1\", \"id\":\"3041\"},\n{\"last_update\":\"1182100211\", \"numofapproved\":\"1\", \"id\":\"3182\"},\n{\"last_update\":\"1183377220\", \"numofapproved\":\"1\", \"id\":\"3921\"},\n{\"last_update\":\"1184677615\", \"numofapproved\":\"1\", \"id\":\"4910\"},\n{\"last_update\":\"1184679060\", \"numofapproved\":\"1\", \"id\":\"4911\"},\n{\"last_update\":\"1184679348\", \"numofapproved\":\"1\", \"id\":\"4912\"},\n{\"last_update\":\"1184749371\", \"numofapproved\":\"1\", \"id\":\"4943\"},\n{\"last_update\":\"1186734180\", \"numofapproved\":\"1\", \"id\":\"6381\"},\n{\"last_update\":\"1187012463\", \"numofapproved\":\"1\", \"id\":\"6501\"},\n{\"last_update\":\"1187209404\", \"numofapproved\":\"1\", \"id\":\"6741\"},\n{\"last_update\":\"1192687257\", \"numofapproved\":\"1\", \"id\":\"12941\"},\n{\"last_update\":\"1193385868\", \"numofapproved\":\"1\", \"id\":\"13942\"},\n{\"last_update\":\"1193386346\", \"numofapproved\":\"1\", \"id\":\"13943\"},\n{\"last_update\":\"1194937571\", \"numofapproved\":\"1\", \"id\":\"16042\"},\n{\"last_update\":\"1194855975\", \"numofapproved\":\"1\", \"id\":\"15761\"},\n{\"last_update\":\"1194960221\", \"numofapproved\":\"1\", \"id\":\"16161\"},\n{\"last_update\":\"1184058679\", \"numofapproved\":\"1\", \"id\":\"4541\"},\n{\"last_update\":\"1185865315\", \"numofapproved\":\"1\", \"id\":\"5842\"},\n{\"last_update\":\"1187178780\", \"numofapproved\":\"1\", \"id\":\"6681\"},\n{\"last_update\":\"1194884625\", \"numofapproved\":\"1\", \"id\":\"15921\"},\n{\"last_update\":\"1195134032\", \"numofapproved\":\"1\", \"id\":\"16721\"},\n{\"last_update\":\"1195164570\", \"numofapproved\":\"1\", \"id\":\"16901\"},\n{\"last_update\":\"1182336429\", \"numofapproved\":\"1\", \"id\":\"3301\"},\n{\"last_update\":\"1182415670\", \"numofapproved\":\"1\", \"id\":\"3353\"},\n{\"last_update\":\"1184575801\", \"numofapproved\":\"1\", \"id\":\"4907\"},\n{\"last_update\":\"1185483718\", \"numofapproved\":\"1\", \"id\":\"5601\"},\n{\"last_update\":\"1186402874\", \"numofapproved\":\"1\", \"id\":\"6166\"},\n{\"last_update\":\"1186750969\", \"numofapproved\":\"1\", \"id\":\"6383\"},\n{\"last_update\":\"1192725360\", \"numofapproved\":\"1\", \"id\":\"13061\"},\n{\"last_update\":\"1193314911\", \"numofapproved\":\"1\", \"id\":\"13822\"},\n{\"last_update\":\"1183448275\", \"numofapproved\":\"1\", \"id\":\"4062\"},\n{\"last_update\":\"1187321039\", \"numofapproved\":\"1\", \"id\":\"6861\"},\n{\"last_update\":\"1188287578\", \"numofapproved\":\"1\", \"id\":\"7601\"},\n{\"last_update\":\"1194464420\", \"numofapproved\":\"1\", \"id\":\"15224\"},\n{\"last_update\":\"1195139641\", \"numofapproved\":\"1\", \"id\":\"16781\"},\n{\"last_update\":\"1186147124\", \"numofapproved\":\"1\", \"id\":\"6107\"},\n{\"last_update\":\"1188821750\", \"numofapproved\":\"1\", \"id\":\"8122\"},\n{\"last_update\":\"1192531864\", \"numofapproved\":\"1\", \"id\":\"12665\"},\n{\"last_update\":\"1192984220\", \"numofapproved\":\"1\", \"id\":\"13223\"},\n{\"last_update\":\"1195225246\", \"numofapproved\":\"1\", \"id\":\"16982\"},\n{\"last_update\":\"1182410787\", \"numofapproved\":\"1\", \"id\":\"3351\"},\n{\"last_update\":\"1184531419\", \"numofapproved\":\"1\", \"id\":\"4901\"},\n{\"last_update\":\"1188801472\", \"numofapproved\":\"1\", \"id\":\"8081\"},\n{\"last_update\":\"1192524288\", \"numofapproved\":\"1\", \"id\":\"12661\"},\n{\"last_update\":\"1180950691\", \"numofapproved\":\"1\", \"id\":\"2181\"},\n{\"last_update\":\"1184016732\", \"numofapproved\":\"1\", \"id\":\"4501\"},\n{\"last_update\":\"1186074085\", \"numofapproved\":\"1\", \"id\":\"6081\"},\n{\"last_update\":\"1194937650\", \"numofapproved\":\"1\", \"id\":\"16043\"},\n{\"last_update\":\"1182937178\", \"numofapproved\":\"1\", \"id\":\"3623\"},\n{\"last_update\":\"1191419601\", \"numofapproved\":\"1\", \"id\":\"11101\"},\n{\"last_update\":\"1191856562\", \"numofapproved\":\"1\", \"id\":\"11843\"},\n{\"last_update\":\"1192525042\", \"numofapproved\":\"1\", \"id\":\"12681\"},\n{\"last_update\":\"1194625494\", \"numofapproved\":\"1\", \"id\":\"15541\"},\n{\"last_update\":\"1194982850\", \"numofapproved\":\"1\", \"id\":\"16361\"},\n{\"last_update\":\"1194989219\", \"numofapproved\":\"1\", \"id\":\"16401\"},\n{\"last_update\":\"1195066723\", \"numofapproved\":\"1\", \"id\":\"16641\"},\n{\"last_update\":\"1183971226\", \"numofapproved\":\"1\", \"id\":\"4403\"},\n{\"last_update\":\"1185526866\", \"numofapproved\":\"1\", \"id\":\"5661\"},\n{\"last_update\":\"1185741495\", \"numofapproved\":\"1\", \"id\":\"5741\"},\n{\"last_update\":\"1185905429\", \"numofapproved\":\"1\", \"id\":\"5881\"},\n{\"last_update\":\"1186137969\", \"numofapproved\":\"1\", \"id\":\"6104\"},\n{\"last_update\":\"1189267536\", \"numofapproved\":\"1\", \"id\":\"8701\"},\n{\"last_update\":\"1190115042\", \"numofapproved\":\"1\", \"id\":\"9261\"},\n{\"last_update\":\"1190664258\", \"numofapproved\":\"1\", \"id\":\"10062\"},\n{\"last_update\":\"1190774949\", \"numofapproved\":\"1\", \"id\":\"10201\"},\n{\"last_update\":\"1190965042\", \"numofapproved\":\"1\", \"id\":\"10641\"},\n{\"last_update\":\"1191493379\", \"numofapproved\":\"1\", \"id\":\"11301\"},\n{\"last_update\":\"1191578051\", \"numofapproved\":\"1\", \"id\":\"11501\"},\n{\"last_update\":\"1192188840\", \"numofapproved\":\"1\", \"id\":\"12421\"},\n{\"last_update\":\"1194000252\", \"numofapproved\":\"1\", \"id\":\"14682\"},\n{\"last_update\":\"1194622556\", \"numofapproved\":\"1\", \"id\":\"15462\"},\n{\"last_update\":\"1194981068\", \"numofapproved\":\"1\", \"id\":\"16341\"},\n{\"last_update\":\"1185795733\", \"numofapproved\":\"1\", \"id\":\"5782\"},\n{\"last_update\":\"1186646854\", \"numofapproved\":\"1\", \"id\":\"6341\"},\n{\"last_update\":\"1187087291\", \"numofapproved\":\"1\", \"id\":\"6621\"},\n{\"last_update\":\"1187951800\", \"numofapproved\":\"1\", \"id\":\"7401\"},\n{\"last_update\":\"1189170373\", \"numofapproved\":\"1\", \"id\":\"8642\"},\n{\"last_update\":\"1191007934\", \"numofapproved\":\"1\", \"id\":\"10781\"},\n{\"last_update\":\"1190985695\", \"numofapproved\":\"1\", \"id\":\"10681\"},\n{\"last_update\":\"1192009758\", \"numofapproved\":\"1\", \"id\":\"12063\"},\n{\"last_update\":\"1193062543\", \"numofapproved\":\"1\", \"id\":\"13321\"},\n{\"last_update\":\"1194950304\", \"numofapproved\":\"1\", \"id\":\"16123\"},\n{\"last_update\":\"1171882085\", \"numofapproved\":\"1\", \"id\":\"90\"},\n{\"last_update\":\"1171962264\", \"numofapproved\":\"1\", \"id\":\"111\"},\n{\"last_update\":\"1172646556\", \"numofapproved\":\"1\", \"id\":\"219\"},\n{\"last_update\":\"1174040139\", \"numofapproved\":\"1\", \"id\":\"349\"},\n{\"last_update\":\"1174059263\", \"numofapproved\":\"1\", \"id\":\"355\"},\n{\"last_update\":\"1174899063\", \"numofapproved\":\"1\", \"id\":\"489\"},\n{\"last_update\":\"1173797557\", \"numofapproved\":\"1\", \"id\":\"310\"},\n{\"last_update\":\"1174735191\", \"numofapproved\":\"1\", \"id\":\"468\"},\n{\"last_update\":\"1174899259\", \"numofapproved\":\"1\", \"id\":\"499\"},\n{\"last_update\":\"1174899354\", \"numofapproved\":\"1\", \"id\":\"502\"},\n{\"last_update\":\"1175254120\", \"numofapproved\":\"1\", \"id\":\"562\"},\n{\"last_update\":\"1171126391\", \"numofapproved\":\"1\", \"id\":\"4\"},\n{\"last_update\":\"1171800381\", \"numofapproved\":\"1\", \"id\":\"82\"},\n{\"last_update\":\"1171799224\", \"numofapproved\":\"1\", \"id\":\"75\"},\n{\"last_update\":\"1171972550\", \"numofapproved\":\"1\", \"id\":\"123\"},\n{\"last_update\":\"1174301165\", \"numofapproved\":\"1\", \"id\":\"381\"},\n{\"last_update\":\"1171904847\", \"numofapproved\":\"1\", \"id\":\"103\"},\n{\"last_update\":\"1172260956\", \"numofapproved\":\"1\", \"id\":\"190\"},\n{\"last_update\":\"1172803368\", \"numofapproved\":\"1\", \"id\":\"234\"},\n{\"last_update\":\"1173199576\", \"numofapproved\":\"1\", \"id\":\"250\"},\n{\"last_update\":\"1173206201\", \"numofapproved\":\"1\", \"id\":\"252\"},\n{\"last_update\":\"1175258941\", \"numofapproved\":\"1\", \"id\":\"563\"},\n{\"last_update\":\"1176232231\", \"numofapproved\":\"1\", \"id\":\"825\"},\n{\"last_update\":\"1176475088\", \"numofapproved\":\"1\", \"id\":\"921\"},\n{\"last_update\":\"1172082181\", \"numofapproved\":\"1\", \"id\":\"166\"},\n{\"last_update\":\"1172595205\", \"numofapproved\":\"1\", \"id\":\"216\"},\n{\"last_update\":\"1174898892\", \"numofapproved\":\"1\", \"id\":\"481\"},\n{\"last_update\":\"1174899696\", \"numofapproved\":\"1\", \"id\":\"518\"},\n{\"last_update\":\"1174924777\", \"numofapproved\":\"1\", \"id\":\"525\"},\n{\"last_update\":\"1175598588\", \"numofapproved\":\"1\", \"id\":\"682\"},\n{\"last_update\":\"1175602572\", \"numofapproved\":\"1\", \"id\":\"683\"},\n{\"last_update\":\"1175707879\", \"numofapproved\":\"1\", \"id\":\"666\"},\n{\"last_update\":\"1175710528\", \"numofapproved\":\"1\", \"id\":\"703\"},\n{\"last_update\":\"1175715728\", \"numofapproved\":\"1\", \"id\":\"707\"},\n{\"last_update\":\"1176137267\", \"numofapproved\":\"1\", \"id\":\"806\"},\n{\"last_update\":\"1176306491\", \"numofapproved\":\"1\", \"id\":\"883\"},\n{\"last_update\":\"1172069972\", \"numofapproved\":\"1\", \"id\":\"134\"},\n{\"last_update\":\"1173889144\", \"numofapproved\":\"1\", \"id\":\"324\"},\n{\"last_update\":\"1175502804\", \"numofapproved\":\"1\", \"id\":\"623\"},\n{\"last_update\":\"1175772530\", \"numofapproved\":\"1\", \"id\":\"711\"},\n{\"last_update\":\"1176297526\", \"numofapproved\":\"1\", \"id\":\"861\"},\n{\"last_update\":\"1171445818\", \"numofapproved\":\"1\", \"id\":\"47\"},\n{\"last_update\":\"1171884505\", \"numofapproved\":\"1\", \"id\":\"92\"},\n{\"last_update\":\"1172250708\", \"numofapproved\":\"1\", \"id\":\"187\"},\n{\"last_update\":\"1173749631\", \"numofapproved\":\"1\", \"id\":\"307\"},\n{\"last_update\":\"1173889164\", \"numofapproved\":\"1\", \"id\":\"325\"},\n{\"last_update\":\"1174301168\", \"numofapproved\":\"1\", \"id\":\"382\"},\n{\"last_update\":\"1171904807\", \"numofapproved\":\"1\", \"id\":\"101\"},\n{\"last_update\":\"1171970405\", \"numofapproved\":\"1\", \"id\":\"120\"},\n{\"last_update\":\"1172218677\", \"numofapproved\":\"1\", \"id\":\"179\"},\n{\"last_update\":\"1173125028\", \"numofapproved\":\"1\", \"id\":\"248\"},\n{\"last_update\":\"1171978122\", \"numofapproved\":\"1\", \"id\":\"126\"},\n{\"last_update\":\"1172676736\", \"numofapproved\":\"1\", \"id\":\"226\"},\n{\"last_update\":\"1173975473\", \"numofapproved\":\"1\", \"id\":\"344\"},\n{\"last_update\":\"1172072582\", \"numofapproved\":\"1\", \"id\":\"165\"},\n{\"last_update\":\"1173888774\", \"numofapproved\":\"1\", \"id\":\"322\"},\n{\"last_update\":\"1174560347\", \"numofapproved\":\"1\", \"id\":\"422\"},\n{\"last_update\":\"1174899242\", \"numofapproved\":\"1\", \"id\":\"498\"},\n{\"last_update\":\"1174735110\", \"numofapproved\":\"1\", \"id\":\"466\"},\n{\"last_update\":\"1176735630\", \"numofapproved\":\"1\", \"id\":\"1004\"},\n{\"last_update\":\"1175725931\", \"numofapproved\":\"1\", \"id\":\"670\"},\n{\"last_update\":\"1176498072\", \"numofapproved\":\"1\", \"id\":\"944\"},\n{\"last_update\":\"1178264233\", \"numofapproved\":\"1\", \"id\":\"1241\"},\n{\"last_update\":\"1178746727\", \"numofapproved\":\"1\", \"id\":\"1350\"},\n{\"last_update\":\"1178798992\", \"numofapproved\":\"1\", \"id\":\"1352\"},\n{\"last_update\":\"1180011647\", \"numofapproved\":\"1\", \"id\":\"1649\"},\n{\"last_update\":\"1180430823\", \"numofapproved\":\"1\", \"id\":\"1901\"},\n{\"last_update\":\"1180649952\", \"numofapproved\":\"1\", \"id\":\"2021\"},\n{\"last_update\":\"1180966506\", \"numofapproved\":\"1\", \"id\":\"2183\"},\n{\"last_update\":\"1180987142\", \"numofapproved\":\"1\", \"id\":\"2241\"},\n{\"last_update\":\"1181127788\", \"numofapproved\":\"1\", \"id\":\"2322\"},\n{\"last_update\":\"1181217668\", \"numofapproved\":\"1\", \"id\":\"2461\"},\n{\"last_update\":\"1182789542\", \"numofapproved\":\"1\", \"id\":\"3522\"},\n{\"last_update\":\"1182851714\", \"numofapproved\":\"1\", \"id\":\"3581\"},\n{\"last_update\":\"1179268837\", \"numofapproved\":\"1\", \"id\":\"1407\"},\n{\"last_update\":\"1179999486\", \"numofapproved\":\"1\", \"id\":\"1645\"},\n{\"last_update\":\"1180019568\", \"numofapproved\":\"1\", \"id\":\"1653\"},\n{\"last_update\":\"1180082061\", \"numofapproved\":\"1\", \"id\":\"1821\"},\n{\"last_update\":\"1184181871\", \"numofapproved\":\"1\", \"id\":\"4642\"},\n{\"last_update\":\"1184251955\", \"numofapproved\":\"1\", \"id\":\"4741\"},\n{\"last_update\":\"1184346893\", \"numofapproved\":\"1\", \"id\":\"4841\"},\n{\"last_update\":\"1184773981\", \"numofapproved\":\"1\", \"id\":\"5001\"},\n{\"last_update\":\"1185272905\", \"numofapproved\":\"1\", \"id\":\"5281\"},\n{\"last_update\":\"1185484083\", \"numofapproved\":\"1\", \"id\":\"5622\"},\n{\"last_update\":\"1185897961\", \"numofapproved\":\"1\", \"id\":\"5861\"},\n{\"last_update\":\"1186951708\", \"numofapproved\":\"1\", \"id\":\"6462\"},\n{\"last_update\":\"1187596311\", \"numofapproved\":\"1\", \"id\":\"6941\"},\n{\"last_update\":\"1187766852\", \"numofapproved\":\"1\", \"id\":\"7201\"},\n{\"last_update\":\"1188158133\", \"numofapproved\":\"1\", \"id\":\"7481\"},\n{\"last_update\":\"1188233835\", \"numofapproved\":\"1\", \"id\":\"7501\"},\n{\"last_update\":\"1188269273\", \"numofapproved\":\"1\", \"id\":\"7561\"},\n{\"last_update\":\"1177672684\", \"numofapproved\":\"1\", \"id\":\"1141\"},\n{\"last_update\":\"1178042016\", \"numofapproved\":\"1\", \"id\":\"1222\"},\n{\"last_update\":\"1181646022\", \"numofapproved\":\"1\", \"id\":\"2801\"},\n{\"last_update\":\"1181853920\", \"numofapproved\":\"1\", \"id\":\"3021\"},\n{\"last_update\":\"1183715836\", \"numofapproved\":\"1\", \"id\":\"4241\"},\n{\"last_update\":\"1183726859\", \"numofapproved\":\"1\", \"id\":\"4281\"},\n{\"last_update\":\"1189860355\", \"numofapproved\":\"1\", \"id\":\"9101\"},\n{\"last_update\":\"1189871747\", \"numofapproved\":\"1\", \"id\":\"9141\"},\n{\"last_update\":\"1190380660\", \"numofapproved\":\"1\", \"id\":\"9681\"},\n{\"last_update\":\"1190510808\", \"numofapproved\":\"1\", \"id\":\"9821\"},\n{\"last_update\":\"1190542013\", \"numofapproved\":\"1\", \"id\":\"9843\"},\n{\"last_update\":\"1190665412\", \"numofapproved\":\"1\", \"id\":\"10081\"},\n{\"last_update\":\"1190299519\", \"numofapproved\":\"1\", \"id\":\"9601\"},\n{\"last_update\":\"1191410594\", \"numofapproved\":\"1\", \"id\":\"11063\"},\n{\"last_update\":\"1191505786\", \"numofapproved\":\"1\", \"id\":\"11341\"},\n{\"last_update\":\"1191583652\", \"numofapproved\":\"1\", \"id\":\"11522\"},\n{\"last_update\":\"1191599712\", \"numofapproved\":\"1\", \"id\":\"11681\"},\n{\"last_update\":\"1191602931\", \"numofapproved\":\"1\", \"id\":\"11721\"},\n{\"last_update\":\"1191762572\", \"numofapproved\":\"1\", \"id\":\"11761\"},\n{\"last_update\":\"1191856256\", \"numofapproved\":\"1\", \"id\":\"11841\"},\n{\"last_update\":\"1191937041\", \"numofapproved\":\"1\", \"id\":\"11921\"},\n{\"last_update\":\"1179325639\", \"numofapproved\":\"1\", \"id\":\"1409\"},\n{\"last_update\":\"1179912165\", \"numofapproved\":\"1\", \"id\":\"1721\"},\n{\"last_update\":\"1181119430\", \"numofapproved\":\"1\", \"id\":\"2321\"},\n{\"last_update\":\"1184696743\", \"numofapproved\":\"1\", \"id\":\"4921\"},\n{\"last_update\":\"1192154847\", \"numofapproved\":\"1\", \"id\":\"12361\"},\n{\"last_update\":\"1192237071\", \"numofapproved\":\"1\", \"id\":\"12501\"},\n{\"last_update\":\"1178637394\", \"numofapproved\":\"1\", \"id\":\"1304\"},\n{\"last_update\":\"1178716778\", \"numofapproved\":\"1\", \"id\":\"1344\"},\n{\"last_update\":\"1182937057\", \"numofapproved\":\"1\", \"id\":\"3622\"},\n{\"last_update\":\"1183113642\", \"numofapproved\":\"1\", \"id\":\"3781\"},\n{\"last_update\":\"1183995467\", \"numofapproved\":\"1\", \"id\":\"4461\"},\n{\"last_update\":\"1184223331\", \"numofapproved\":\"1\", \"id\":\"4721\"},\n{\"last_update\":\"1190990692\", \"numofapproved\":\"1\", \"id\":\"10711\"},\n{\"last_update\":\"1193269310\", \"numofapproved\":\"1\", \"id\":\"13761\"},\n{\"last_update\":\"1193735756\", \"numofapproved\":\"1\", \"id\":\"14441\"},\n{\"last_update\":\"1194635738\", \"numofapproved\":\"1\", \"id\":\"15603\"},\n{\"last_update\":\"1194901721\", \"numofapproved\":\"1\", \"id\":\"15961\"},\n{\"last_update\":\"1194949951\", \"numofapproved\":\"1\", \"id\":\"16141\"},\n{\"last_update\":\"1194960695\", \"numofapproved\":\"1\", \"id\":\"16182\"},\n{\"last_update\":\"1194973974\", \"numofapproved\":\"1\", \"id\":\"16221\"},\n{\"last_update\":\"1194946810\", \"numofapproved\":\"1\", \"id\":\"16102\"},\n{\"last_update\":\"1194977452\", \"numofapproved\":\"1\", \"id\":\"16261\"},\n{\"last_update\":\"1195040385\", \"numofapproved\":\"1\", \"id\":\"16461\"},\n{\"last_update\":\"1195053483\", \"numofapproved\":\"1\", \"id\":\"16561\"},\n{\"last_update\":\"1195053518\", \"numofapproved\":\"1\", \"id\":\"16562\"},\n{\"last_update\":\"1195218698\", \"numofapproved\":\"1\", \"id\":\"16921\"},\n{\"last_update\":\"1195225049\", \"numofapproved\":\"1\", \"id\":\"16961\"},\n{\"last_update\":\"1195164270\", \"numofapproved\":\"1\", \"id\":\"16881\"},\n{\"last_update\":\"1195080947\", \"numofapproved\":\"1\", \"id\":\"16681\"},\n{\"last_update\":\"1195469884\", \"numofapproved\":\"1\", \"id\":\"17181\"},\n{\"last_update\":\"1185314804\", \"numofapproved\":\"1\", \"id\":\"5381\"},\n{\"last_update\":\"1188401767\", \"numofapproved\":\"1\", \"id\":\"7721\"},\n{\"last_update\":\"1190286841\", \"numofapproved\":\"1\", \"id\":\"9582\"},\n{\"last_update\":\"1190733096\", \"numofapproved\":\"1\", \"id\":\"10141\"},\n{\"last_update\":\"1190847451\", \"numofapproved\":\"1\", \"id\":\"10422\"},\n{\"last_update\":\"1190990526\", \"numofapproved\":\"1\", \"id\":\"10707\"},\n{\"last_update\":\"1192009711\", \"numofapproved\":\"1\", \"id\":\"12061\"},\n{\"last_update\":\"1192155478\", \"numofapproved\":\"1\", \"id\":\"12362\"},\n{\"last_update\":\"1192468382\", \"numofapproved\":\"1\", \"id\":\"12641\"},\n{\"last_update\":\"1193332032\", \"numofapproved\":\"1\", \"id\":\"13881\"},\n{\"last_update\":\"1195497290\", \"numofapproved\":\"1\", \"id\":\"17321\"},\n{\"last_update\":\"1195519935\", \"numofapproved\":\"1\", \"id\":\"17441\"},\n{\"last_update\":\"1195549826\", \"numofapproved\":\"1\", \"id\":\"17521\"},\n{\"last_update\":\"1177668131\", \"numofapproved\":\"1\", \"id\":\"1101\"},\n{\"last_update\":\"1186835348\", \"numofapproved\":\"1\", \"id\":\"6421\"},\n{\"last_update\":\"1191057903\", \"numofapproved\":\"1\", \"id\":\"10802\"},\n{\"last_update\":\"1193973906\", \"numofapproved\":\"1\", \"id\":\"14665\"},\n{\"last_update\":\"1171904780\", \"numofapproved\":\"1\", \"id\":\"100\"},\n{\"last_update\":\"1172677750\", \"numofapproved\":\"1\", \"id\":\"227\"},\n{\"last_update\":\"1172686704\", \"numofapproved\":\"1\", \"id\":\"229\"},\n{\"last_update\":\"1173101684\", \"numofapproved\":\"1\", \"id\":\"245\"},\n{\"last_update\":\"1173466151\", \"numofapproved\":\"1\", \"id\":\"282\"},\n{\"last_update\":\"1174301263\", \"numofapproved\":\"1\", \"id\":\"386\"},\n{\"last_update\":\"1174302366\", \"numofapproved\":\"1\", \"id\":\"399\"},\n{\"last_update\":\"1174501294\", \"numofapproved\":\"1\", \"id\":\"421\"},\n{\"last_update\":\"1174899635\", \"numofapproved\":\"1\", \"id\":\"515\"},\n{\"last_update\":\"1174924556\", \"numofapproved\":\"1\", \"id\":\"523\"},\n{\"last_update\":\"1175141200\", \"numofapproved\":\"1\", \"id\":\"541\"},\n{\"last_update\":\"1171799271\", \"numofapproved\":\"1\", \"id\":\"76\"},\n{\"last_update\":\"1171900163\", \"numofapproved\":\"1\", \"id\":\"97\"},\n{\"last_update\":\"1174301267\", \"numofapproved\":\"1\", \"id\":\"387\"},\n{\"last_update\":\"1174735156\", \"numofapproved\":\"1\", \"id\":\"467\"},\n{\"last_update\":\"1174899569\", \"numofapproved\":\"1\", \"id\":\"512\"},\n{\"last_update\":\"1174926970\", \"numofapproved\":\"1\", \"id\":\"531\"},\n{\"last_update\":\"1175502757\", \"numofapproved\":\"1\", \"id\":\"602\"},\n{\"last_update\":\"1175603425\", \"numofapproved\":\"1\", \"id\":\"663\"},\n{\"last_update\":\"1176194967\", \"numofapproved\":\"1\", \"id\":\"822\"},\n{\"last_update\":\"1171800398\", \"numofapproved\":\"1\", \"id\":\"83\"},\n{\"last_update\":\"1171968376\", \"numofapproved\":\"1\", \"id\":\"118\"},\n{\"last_update\":\"1172070063\", \"numofapproved\":\"1\", \"id\":\"135\"},\n{\"last_update\":\"1173821159\", \"numofapproved\":\"1\", \"id\":\"314\"},\n{\"last_update\":\"1176559052\", \"numofapproved\":\"1\", \"id\":\"964\"},\n{\"last_update\":\"1171299245\", \"numofapproved\":\"1\", \"id\":\"23\"},\n{\"last_update\":\"1171535160\", \"numofapproved\":\"1\", \"id\":\"57\"},\n{\"last_update\":\"1171564542\", \"numofapproved\":\"1\", \"id\":\"65\"},\n{\"last_update\":\"1172646592\", \"numofapproved\":\"1\", \"id\":\"220\"},\n{\"last_update\":\"1174899489\", \"numofapproved\":\"1\", \"id\":\"507\"},\n{\"last_update\":\"1174924890\", \"numofapproved\":\"1\", \"id\":\"528\"},\n{\"last_update\":\"1175687005\", \"numofapproved\":\"1\", \"id\":\"701\"},\n{\"last_update\":\"1176132888\", \"numofapproved\":\"1\", \"id\":\"805\"},\n{\"last_update\":\"1171286610\", \"numofapproved\":\"1\", \"id\":\"21\"},\n{\"last_update\":\"1172184441\", \"numofapproved\":\"1\", \"id\":\"176\"},\n{\"last_update\":\"1172187221\", \"numofapproved\":\"1\", \"id\":\"178\"},\n{\"last_update\":\"1173386668\", \"numofapproved\":\"1\", \"id\":\"261\"},\n{\"last_update\":\"1173809115\", \"numofapproved\":\"1\", \"id\":\"312\"},\n{\"last_update\":\"1175609126\", \"numofapproved\":\"1\", \"id\":\"685\"},\n{\"last_update\":\"1175791369\", \"numofapproved\":\"1\", \"id\":\"712\"},\n{\"last_update\":\"1176480434\", \"numofapproved\":\"1\", \"id\":\"942\"},\n{\"last_update\":\"1171503567\", \"numofapproved\":\"1\", \"id\":\"56\"},\n{\"last_update\":\"1171799204\", \"numofapproved\":\"1\", \"id\":\"74\"},\n{\"last_update\":\"1172236765\", \"numofapproved\":\"1\", \"id\":\"183\"},\n{\"last_update\":\"1175598013\", \"numofapproved\":\"1\", \"id\":\"681\"},\n{\"last_update\":\"1175610956\", \"numofapproved\":\"1\", \"id\":\"687\"},\n{\"last_update\":\"1175725436\", \"numofapproved\":\"1\", \"id\":\"710\"},\n{\"last_update\":\"1171905052\", \"numofapproved\":\"1\", \"id\":\"105\"},\n{\"last_update\":\"1172268920\", \"numofapproved\":\"1\", \"id\":\"191\"},\n{\"last_update\":\"1173264110\", \"numofapproved\":\"1\", \"id\":\"256\"},\n{\"last_update\":\"1173889179\", \"numofapproved\":\"1\", \"id\":\"326\"},\n{\"last_update\":\"1174301066\", \"numofapproved\":\"1\", \"id\":\"378\"},\n{\"last_update\":\"1174300399\", \"numofapproved\":\"1\", \"id\":\"366\"},\n{\"last_update\":\"1174387980\", \"numofapproved\":\"1\", \"id\":\"400\"},\n{\"last_update\":\"1176823766\", \"numofapproved\":\"1\", \"id\":\"1007\"},\n{\"last_update\":\"1171970585\", \"numofapproved\":\"1\", \"id\":\"122\"},\n{\"last_update\":\"1172071500\", \"numofapproved\":\"1\", \"id\":\"145\"},\n{\"last_update\":\"1172580279\", \"numofapproved\":\"1\", \"id\":\"211\"},\n{\"last_update\":\"1172658493\", \"numofapproved\":\"1\", \"id\":\"221\"},\n{\"last_update\":\"1174301611\", \"numofapproved\":\"1\", \"id\":\"397\"},\n{\"last_update\":\"1176900132\", \"numofapproved\":\"1\", \"id\":\"989\"},\n{\"last_update\":\"1171965754\", \"numofapproved\":\"1\", \"id\":\"114\"},\n{\"last_update\":\"1173797482\", \"numofapproved\":\"1\", \"id\":\"309\"},\n{\"last_update\":\"1174300513\", \"numofapproved\":\"1\", \"id\":\"367\"},\n{\"last_update\":\"1174301493\", \"numofapproved\":\"1\", \"id\":\"395\"},\n{\"last_update\":\"1174899124\", \"numofapproved\":\"1\", \"id\":\"492\"},\n{\"last_update\":\"1174899677\", \"numofapproved\":\"1\", \"id\":\"517\"},\n{\"last_update\":\"1174924235\", \"numofapproved\":\"1\", \"id\":\"522\"},\n{\"last_update\":\"1174925568\", \"numofapproved\":\"1\", \"id\":\"529\"},\n{\"last_update\":\"1174933088\", \"numofapproved\":\"1\", \"id\":\"533\"},\n{\"last_update\":\"1174933338\", \"numofapproved\":\"1\", \"id\":\"538\"},\n{\"last_update\":\"1174044629\", \"numofapproved\":\"1\", \"id\":\"352\"},\n{\"last_update\":\"1175713207\", \"numofapproved\":\"1\", \"id\":\"669\"},\n{\"last_update\":\"1178339569\", \"numofapproved\":\"1\", \"id\":\"1262\"},\n{\"last_update\":\"1178611427\", \"numofapproved\":\"1\", \"id\":\"1303\"},\n{\"last_update\":\"1178707269\", \"numofapproved\":\"1\", \"id\":\"1341\"},\n{\"last_update\":\"1179411388\", \"numofapproved\":\"1\", \"id\":\"1461\"},\n{\"last_update\":\"1180000879\", \"numofapproved\":\"1\", \"id\":\"1648\"},\n{\"last_update\":\"1180097993\", \"numofapproved\":\"1\", \"id\":\"1657\"},\n{\"last_update\":\"1180107947\", \"numofapproved\":\"1\", \"id\":\"1659\"},\n{\"last_update\":\"1180515935\", \"numofapproved\":\"1\", \"id\":\"1922\"},\n{\"last_update\":\"1180712418\", \"numofapproved\":\"1\", \"id\":\"2102\"},\n{\"last_update\":\"1180731895\", \"numofapproved\":\"1\", \"id\":\"2063\"},\n{\"last_update\":\"1180731763\", \"numofapproved\":\"1\", \"id\":\"2143\"},\n{\"last_update\":\"1180951519\", \"numofapproved\":\"1\", \"id\":\"2201\"},\n{\"last_update\":\"1180954763\", \"numofapproved\":\"1\", \"id\":\"2182\"},\n{\"last_update\":\"1181134185\", \"numofapproved\":\"1\", \"id\":\"2361\"},\n{\"last_update\":\"1181206368\", \"numofapproved\":\"1\", \"id\":\"2441\"},\n{\"last_update\":\"1181207556\", \"numofapproved\":\"1\", \"id\":\"2442\"},\n{\"last_update\":\"1183065868\", \"numofapproved\":\"1\", \"id\":\"3741\"},\n{\"last_update\":\"1183124436\", \"numofapproved\":\"1\", \"id\":\"3822\"},\n{\"last_update\":\"1183118631\", \"numofapproved\":\"1\", \"id\":\"3802\"},\n{\"last_update\":\"1183515629\", \"numofapproved\":\"1\", \"id\":\"4144\"},\n{\"last_update\":\"1184169495\", \"numofapproved\":\"1\", \"id\":\"4621\"},\n{\"last_update\":\"1184777700\", \"numofapproved\":\"1\", \"id\":\"5021\"},\n{\"last_update\":\"1185371099\", \"numofapproved\":\"1\", \"id\":\"5441\"},\n{\"last_update\":\"1185460060\", \"numofapproved\":\"1\", \"id\":\"5521\"},\n{\"last_update\":\"1185462514\", \"numofapproved\":\"1\", \"id\":\"5541\"},\n{\"last_update\":\"1185573050\", \"numofapproved\":\"1\", \"id\":\"5721\"},\n{\"last_update\":\"1185795586\", \"numofapproved\":\"1\", \"id\":\"5781\"},\n{\"last_update\":\"1185962181\", \"numofapproved\":\"1\", \"id\":\"5901\"},\n{\"last_update\":\"1185987024\", \"numofapproved\":\"1\", \"id\":\"6001\"},\n{\"last_update\":\"1186138150\", \"numofapproved\":\"1\", \"id\":\"6105\"},\n{\"last_update\":\"1186500528\", \"numofapproved\":\"1\", \"id\":\"6281\"},\n{\"last_update\":\"1187765075\", \"numofapproved\":\"1\", \"id\":\"7141\"},\n{\"last_update\":\"1188158263\", \"numofapproved\":\"1\", \"id\":\"7482\"},\n{\"last_update\":\"1189094579\", \"numofapproved\":\"1\", \"id\":\"8461\"},\n{\"last_update\":\"1189327635\", \"numofapproved\":\"1\", \"id\":\"8721\"},\n{\"last_update\":\"1182356521\", \"numofapproved\":\"1\", \"id\":\"3344\"},\n{\"last_update\":\"1185017921\", \"numofapproved\":\"1\", \"id\":\"5161\"},\n{\"last_update\":\"1185271167\", \"numofapproved\":\"1\", \"id\":\"5261\"},\n{\"last_update\":\"1190663796\", \"numofapproved\":\"1\", \"id\":\"10041\"},\n{\"last_update\":\"1190726728\", \"numofapproved\":\"1\", \"id\":\"10121\"},\n{\"last_update\":\"1190801144\", \"numofapproved\":\"1\", \"id\":\"10241\"},\n{\"last_update\":\"1190894441\", \"numofapproved\":\"1\", \"id\":\"10502\"},\n{\"last_update\":\"1190973098\", \"numofapproved\":\"1\", \"id\":\"10667\"},\n{\"last_update\":\"1190925124\", \"numofapproved\":\"1\", \"id\":\"10584\"},\n{\"last_update\":\"1191249884\", \"numofapproved\":\"1\", \"id\":\"10961\"},\n{\"last_update\":\"1187732431\", \"numofapproved\":\"1\", \"id\":\"7081\"},\n{\"last_update\":\"1189259179\", \"numofapproved\":\"1\", \"id\":\"8681\"},\n{\"last_update\":\"1191446517\", \"numofapproved\":\"1\", \"id\":\"11183\"},\n{\"last_update\":\"1191510643\", \"numofapproved\":\"1\", \"id\":\"11381\"},\n{\"last_update\":\"1191529640\", \"numofapproved\":\"1\", \"id\":\"11421\"},\n{\"last_update\":\"1191588726\", \"numofapproved\":\"1\", \"id\":\"11602\"},\n{\"last_update\":\"1191903050\", \"numofapproved\":\"1\", \"id\":\"11881\"},\n{\"last_update\":\"1181218459\", \"numofapproved\":\"1\", \"id\":\"2464\"},\n{\"last_update\":\"1187024536\", \"numofapproved\":\"1\", \"id\":\"6581\"},\n{\"last_update\":\"1192009094\", \"numofapproved\":\"1\", \"id\":\"12041\"},\n{\"last_update\":\"1192064048\", \"numofapproved\":\"1\", \"id\":\"12183\"},\n{\"last_update\":\"1192061973\", \"numofapproved\":\"1\", \"id\":\"12181\"},\n{\"last_update\":\"1193026780\", \"numofapproved\":\"1\", \"id\":\"13241\"},\n{\"last_update\":\"1193416409\", \"numofapproved\":\"1\", \"id\":\"14161\"},\n{\"last_update\":\"1186992495\", \"numofapproved\":\"1\", \"id\":\"6481\"},\n{\"last_update\":\"1191410811\", \"numofapproved\":\"1\", \"id\":\"11066\"},\n{\"last_update\":\"1193440748\", \"numofapproved\":\"1\", \"id\":\"14241\"},\n{\"last_update\":\"1194252005\", \"numofapproved\":\"1\", \"id\":\"14884\"},\n{\"last_update\":\"1194362364\", \"numofapproved\":\"1\", \"id\":\"14889\"},\n{\"last_update\":\"1179240103\", \"numofapproved\":\"1\", \"id\":\"1389\"},\n{\"last_update\":\"1181812262\", \"numofapproved\":\"1\", \"id\":\"2922\"},\n{\"last_update\":\"1182093916\", \"numofapproved\":\"1\", \"id\":\"3181\"},\n{\"last_update\":\"1182767688\", \"numofapproved\":\"1\", \"id\":\"3501\"},\n{\"last_update\":\"1184181747\", \"numofapproved\":\"1\", \"id\":\"4661\"},\n{\"last_update\":\"1186505570\", \"numofapproved\":\"1\", \"id\":\"6170\"},\n{\"last_update\":\"1186751068\", \"numofapproved\":\"1\", \"id\":\"6384\"},\n{\"last_update\":\"1187558925\", \"numofapproved\":\"1\", \"id\":\"6921\"},\n{\"last_update\":\"1188037477\", \"numofapproved\":\"1\", \"id\":\"7424\"},\n{\"last_update\":\"1194937530\", \"numofapproved\":\"1\", \"id\":\"16041\"},\n{\"last_update\":\"1179754250\", \"numofapproved\":\"1\", \"id\":\"1562\"},\n{\"last_update\":\"1183416194\", \"numofapproved\":\"1\", \"id\":\"4021\"},\n{\"last_update\":\"1185835616\", \"numofapproved\":\"1\", \"id\":\"5841\"},\n{\"last_update\":\"1192731190\", \"numofapproved\":\"1\", \"id\":\"13141\"},\n{\"last_update\":\"1193178120\", \"numofapproved\":\"1\", \"id\":\"13523\"},\n{\"last_update\":\"1193844805\", \"numofapproved\":\"1\", \"id\":\"14503\"},\n{\"last_update\":\"1193909242\", \"numofapproved\":\"1\", \"id\":\"14525\"},\n{\"last_update\":\"1195474767\", \"numofapproved\":\"1\", \"id\":\"17221\"},\n{\"last_update\":\"1177690781\", \"numofapproved\":\"1\", \"id\":\"1142\"},\n{\"last_update\":\"1185373614\", \"numofapproved\":\"1\", \"id\":\"5461\"},\n{\"last_update\":\"1192520088\", \"numofapproved\":\"1\", \"id\":\"12624\"},\n{\"last_update\":\"1193194444\", \"numofapproved\":\"1\", \"id\":\"13527\"},\n{\"last_update\":\"1193387684\", \"numofapproved\":\"1\", \"id\":\"13950\"},\n{\"last_update\":\"1193388786\", \"numofapproved\":\"1\", \"id\":\"13952\"},\n{\"last_update\":\"1194616895\", \"numofapproved\":\"1\", \"id\":\"15401\"},\n{\"last_update\":\"1195034817\", \"numofapproved\":\"1\", \"id\":\"16441\"},\n{\"last_update\":\"1183107374\", \"numofapproved\":\"1\", \"id\":\"3761\"},\n{\"last_update\":\"1183515040\", \"numofapproved\":\"1\", \"id\":\"4121\"},\n{\"last_update\":\"1184744160\", \"numofapproved\":\"1\", \"id\":\"4942\"},\n{\"last_update\":\"1192094830\", \"numofapproved\":\"1\", \"id\":\"12201\"},\n{\"last_update\":\"1193314411\", \"numofapproved\":\"1\", \"id\":\"13821\"},\n{\"last_update\":\"1193391901\", \"numofapproved\":\"1\", \"id\":\"13957\"},\n{\"last_update\":\"1193399824\", \"numofapproved\":\"1\", \"id\":\"14043\"},\n{\"last_update\":\"1194450353\", \"numofapproved\":\"1\", \"id\":\"15181\"},\n{\"last_update\":\"1194474719\", \"numofapproved\":\"1\", \"id\":\"15241\"},\n{\"last_update\":\"1194622799\", \"numofapproved\":\"1\", \"id\":\"15481\"},\n{\"last_update\":\"1194880827\", \"numofapproved\":\"1\", \"id\":\"15901\"},\n{\"last_update\":\"1182363929\", \"numofapproved\":\"1\", \"id\":\"3347\"},\n{\"last_update\":\"1182952243\", \"numofapproved\":\"1\", \"id\":\"3642\"},\n{\"last_update\":\"1183386876\", \"numofapproved\":\"1\", \"id\":\"3962\"},\n{\"last_update\":\"1193178314\", \"numofapproved\":\"1\", \"id\":\"13524\"},\n{\"last_update\":\"1195376577\", \"numofapproved\":\"1\", \"id\":\"17061\"},\n{\"last_update\":\"1179832847\", \"numofapproved\":\"1\", \"id\":\"1621\"},\n{\"last_update\":\"1184053269\", \"numofapproved\":\"1\", \"id\":\"4521\"},\n{\"last_update\":\"1185024744\", \"numofapproved\":\"1\", \"id\":\"5181\"},\n{\"last_update\":\"1186130324\", \"numofapproved\":\"1\", \"id\":\"6101\"},\n{\"last_update\":\"1192529640\", \"numofapproved\":\"1\", \"id\":\"12662\"},\n{\"last_update\":\"1193158482\", \"numofapproved\":\"1\", \"id\":\"13521\"},\n{\"last_update\":\"1194247788\", \"numofapproved\":\"1\", \"id\":\"14883\"},\n{\"last_update\":\"1182363717\", \"numofapproved\":\"1\", \"id\":\"3346\"},\n{\"last_update\":\"1193386824\", \"numofapproved\":\"1\", \"id\":\"13944\"},\n{\"last_update\":\"1193844655\", \"numofapproved\":\"1\", \"id\":\"14502\"},\n{\"last_update\":\"1180732326\", \"numofapproved\":\"1\", \"id\":\"2064\"},\n{\"last_update\":\"1182247493\", \"numofapproved\":\"1\", \"id\":\"3222\"},\n{\"last_update\":\"1183515318\", \"numofapproved\":\"1\", \"id\":\"4143\"},\n{\"last_update\":\"1184840285\", \"numofapproved\":\"1\", \"id\":\"5061\"},\n{\"last_update\":\"1188458821\", \"numofapproved\":\"1\", \"id\":\"7741\"},\n{\"last_update\":\"1188919582\", \"numofapproved\":\"1\", \"id\":\"8241\"},\n{\"last_update\":\"1190990231\", \"numofapproved\":\"1\", \"id\":\"10701\"},\n{\"last_update\":\"1190990557\", \"numofapproved\":\"1\", \"id\":\"10708\"},\n{\"last_update\":\"1191583611\", \"numofapproved\":\"1\", \"id\":\"11521\"},\n{\"last_update\":\"1192031263\", \"numofapproved\":\"1\", \"id\":\"12102\"},\n{\"last_update\":\"1192431349\", \"numofapproved\":\"1\", \"id\":\"12563\"},\n{\"last_update\":\"1192608972\", \"numofapproved\":\"1\", \"id\":\"12801\"},\n{\"last_update\":\"1193244196\", \"numofapproved\":\"1\", \"id\":\"13641\"},\n{\"last_update\":\"1193733530\", \"numofapproved\":\"1\", \"id\":\"14422\"},\n{\"last_update\":\"1194988770\", \"numofapproved\":\"1\", \"id\":\"16381\"},\n{\"last_update\":\"1195050890\", \"numofapproved\":\"1\", \"id\":\"16541\"},\n{\"last_update\":\"1195047262\", \"numofapproved\":\"1\", \"id\":\"16502\"},\n{\"last_update\":\"1195221672\", \"numofapproved\":\"1\", \"id\":\"16941\"},\n{\"last_update\":\"1195400016\", \"numofapproved\":\"1\", \"id\":\"17103\"},\n{\"last_update\":\"1178716622\", \"numofapproved\":\"1\", \"id\":\"1343\"},\n{\"last_update\":\"1183563126\", \"numofapproved\":\"1\", \"id\":\"4181\"},\n{\"last_update\":\"1183970953\", \"numofapproved\":\"1\", \"id\":\"4402\"},\n{\"last_update\":\"1190149151\", \"numofapproved\":\"1\", \"id\":\"9381\"},\n{\"last_update\":\"1190628937\", \"numofapproved\":\"1\", \"id\":\"9921\"},\n{\"last_update\":\"1190908511\", \"numofapproved\":\"1\", \"id\":\"10521\"},\n{\"last_update\":\"1191365468\", \"numofapproved\":\"1\", \"id\":\"11021\"},\n{\"last_update\":\"1192431054\", \"numofapproved\":\"1\", \"id\":\"12561\"},\n{\"last_update\":\"1188938163\", \"numofapproved\":\"1\", \"id\":\"8281\"},\n{\"last_update\":\"1192155298\", \"numofapproved\":\"1\", \"id\":\"12383\"},\n{\"last_update\":\"1193223714\", \"numofapproved\":\"1\", \"id\":\"13561\"},\n{\"last_update\":\"1171799359\", \"numofapproved\":\"1\", \"id\":\"80\"},\n{\"last_update\":\"1171962550\", \"numofapproved\":\"1\", \"id\":\"112\"},\n{\"last_update\":\"1171965210\", \"numofapproved\":\"1\", \"id\":\"113\"},\n{\"last_update\":\"1171980888\", \"numofapproved\":\"1\", \"id\":\"128\"},\n{\"last_update\":\"1174299174\", \"numofapproved\":\"1\", \"id\":\"361\"},\n{\"last_update\":\"1174301053\", \"numofapproved\":\"1\", \"id\":\"376\"},\n{\"last_update\":\"1174899661\", \"numofapproved\":\"1\", \"id\":\"516\"},\n{\"last_update\":\"1172646493\", \"numofapproved\":\"1\", \"id\":\"218\"},\n{\"last_update\":\"1174899018\", \"numofapproved\":\"1\", \"id\":\"487\"},\n{\"last_update\":\"1175091201\", \"numofapproved\":\"1\", \"id\":\"540\"},\n{\"last_update\":\"1175267243\", \"numofapproved\":\"1\", \"id\":\"564\"},\n{\"last_update\":\"1176293117\", \"numofapproved\":\"1\", \"id\":\"826\"},\n{\"last_update\":\"1171602873\", \"numofapproved\":\"1\", \"id\":\"67\"},\n{\"last_update\":\"1172568714\", \"numofapproved\":\"1\", \"id\":\"210\"},\n{\"last_update\":\"1174300556\", \"numofapproved\":\"1\", \"id\":\"369\"},\n{\"last_update\":\"1174301614\", \"numofapproved\":\"1\", \"id\":\"398\"},\n{\"last_update\":\"1174429050\", \"numofapproved\":\"1\", \"id\":\"404\"},\n{\"last_update\":\"1175547821\", \"numofapproved\":\"1\", \"id\":\"641\"},\n{\"last_update\":\"1175696551\", \"numofapproved\":\"1\", \"id\":\"702\"},\n{\"last_update\":\"1176223342\", \"numofapproved\":\"1\", \"id\":\"823\"},\n{\"last_update\":\"1176459077\", \"numofapproved\":\"1\", \"id\":\"905\"},\n{\"last_update\":\"1172169117\", \"numofapproved\":\"1\", \"id\":\"172\"},\n{\"last_update\":\"1172259821\", \"numofapproved\":\"1\", \"id\":\"189\"},\n{\"last_update\":\"1172847347\", \"numofapproved\":\"1\", \"id\":\"237\"},\n{\"last_update\":\"1176485274\", \"numofapproved\":\"1\", \"id\":\"961\"},\n{\"last_update\":\"1176739199\", \"numofapproved\":\"1\", \"id\":\"983\"},\n{\"last_update\":\"1171710108\", \"numofapproved\":\"1\", \"id\":\"72\"},\n{\"last_update\":\"1172147854\", \"numofapproved\":\"1\", \"id\":\"170\"},\n{\"last_update\":\"1172178657\", \"numofapproved\":\"1\", \"id\":\"173\"},\n{\"last_update\":\"1174933210\", \"numofapproved\":\"1\", \"id\":\"535\"},\n{\"last_update\":\"1175502973\", \"numofapproved\":\"1\", \"id\":\"626\"},\n{\"last_update\":\"1172071610\", \"numofapproved\":\"1\", \"id\":\"146\"},\n{\"last_update\":\"1172847402\", \"numofapproved\":\"1\", \"id\":\"240\"},\n{\"last_update\":\"1173282970\", \"numofapproved\":\"1\", \"id\":\"258\"},\n{\"last_update\":\"1175502729\", \"numofapproved\":\"1\", \"id\":\"621\"},\n{\"last_update\":\"1173889203\", \"numofapproved\":\"1\", \"id\":\"327\"},\n{\"last_update\":\"1174301604\", \"numofapproved\":\"1\", \"id\":\"396\"},\n{\"last_update\":\"1176738556\", \"numofapproved\":\"1\", \"id\":\"1005\"},\n{\"last_update\":\"1171287066\", \"numofapproved\":\"1\", \"id\":\"22\"},\n{\"last_update\":\"1171388951\", \"numofapproved\":\"1\", \"id\":\"46\"},\n{\"last_update\":\"1171645099\", \"numofapproved\":\"1\", \"id\":\"70\"},\n{\"last_update\":\"1174301489\", \"numofapproved\":\"1\", \"id\":\"394\"},\n{\"last_update\":\"1176109438\", \"numofapproved\":\"1\", \"id\":\"804\"},\n{\"last_update\":\"1173203622\", \"numofapproved\":\"1\", \"id\":\"251\"},\n{\"last_update\":\"1174300337\", \"numofapproved\":\"1\", \"id\":\"364\"},\n{\"last_update\":\"1174898999\", \"numofapproved\":\"1\", \"id\":\"486\"},\n{\"last_update\":\"1174899221\", \"numofapproved\":\"1\", \"id\":\"497\"},\n{\"last_update\":\"1174899505\", \"numofapproved\":\"1\", \"id\":\"508\"},\n{\"last_update\":\"1171905996\", \"numofapproved\":\"1\", \"id\":\"106\"},\n{\"last_update\":\"1172003938\", \"numofapproved\":\"1\", \"id\":\"131\"},\n{\"last_update\":\"1172134183\", \"numofapproved\":\"1\", \"id\":\"167\"},\n{\"last_update\":\"1178550080\", \"numofapproved\":\"1\", \"id\":\"1301\"},\n{\"last_update\":\"1178718229\", \"numofapproved\":\"1\", \"id\":\"1346\"},\n{\"last_update\":\"1178725187\", \"numofapproved\":\"1\", \"id\":\"1322\"},\n{\"last_update\":\"1179302219\", \"numofapproved\":\"1\", \"id\":\"1392\"},\n{\"last_update\":\"1180015260\", \"numofapproved\":\"1\", \"id\":\"1650\"},\n{\"last_update\":\"1180088452\", \"numofapproved\":\"1\", \"id\":\"1656\"},\n{\"last_update\":\"1180719498\", \"numofapproved\":\"1\", \"id\":\"2121\"},\n{\"last_update\":\"1180731930\", \"numofapproved\":\"1\", \"id\":\"2145\"},\n{\"last_update\":\"1180731601\", \"numofapproved\":\"1\", \"id\":\"2142\"},\n{\"last_update\":\"1181034337\", \"numofapproved\":\"1\", \"id\":\"2281\"},\n{\"last_update\":\"1181222113\", \"numofapproved\":\"1\", \"id\":\"2501\"},\n{\"last_update\":\"1181254636\", \"numofapproved\":\"1\", \"id\":\"2601\"},\n{\"last_update\":\"1181578682\", \"numofapproved\":\"1\", \"id\":\"2762\"},\n{\"last_update\":\"1181731051\", \"numofapproved\":\"1\", \"id\":\"2881\"},\n{\"last_update\":\"1177673345\", \"numofapproved\":\"1\", \"id\":\"1162\"},\n{\"last_update\":\"1183741680\", \"numofapproved\":\"1\", \"id\":\"4301\"},\n{\"last_update\":\"1183988623\", \"numofapproved\":\"1\", \"id\":\"4441\"},\n{\"last_update\":\"1184217947\", \"numofapproved\":\"1\", \"id\":\"4701\"},\n{\"last_update\":\"1186260146\", \"numofapproved\":\"1\", \"id\":\"6181\"},\n{\"last_update\":\"1186289860\", \"numofapproved\":\"1\", \"id\":\"6163\"},\n{\"last_update\":\"1186235477\", \"numofapproved\":\"1\", \"id\":\"6161\"},\n{\"last_update\":\"1186508996\", \"numofapproved\":\"1\", \"id\":\"6171\"},\n{\"last_update\":\"1187626570\", \"numofapproved\":\"1\", \"id\":\"6961\"},\n{\"last_update\":\"1187713755\", \"numofapproved\":\"1\", \"id\":\"7041\"},\n{\"last_update\":\"1187769208\", \"numofapproved\":\"1\", \"id\":\"7222\"},\n{\"last_update\":\"1187856827\", \"numofapproved\":\"1\", \"id\":\"7341\"},\n{\"last_update\":\"1188053850\", \"numofapproved\":\"1\", \"id\":\"7461\"},\n{\"last_update\":\"1188264856\", \"numofapproved\":\"1\", \"id\":\"7541\"},\n{\"last_update\":\"1188319841\", \"numofapproved\":\"1\", \"id\":\"7681\"},\n{\"last_update\":\"1188582632\", \"numofapproved\":\"1\", \"id\":\"7901\"},\n{\"last_update\":\"1188734330\", \"numofapproved\":\"1\", \"id\":\"8001\"},\n{\"last_update\":\"1189003562\", \"numofapproved\":\"1\", \"id\":\"8381\"},\n{\"last_update\":\"1179787121\", \"numofapproved\":\"1\", \"id\":\"1581\"},\n{\"last_update\":\"1181998896\", \"numofapproved\":\"1\", \"id\":\"3121\"},\n{\"last_update\":\"1182274782\", \"numofapproved\":\"1\", \"id\":\"3261\"},\n{\"last_update\":\"1186350397\", \"numofapproved\":\"1\", \"id\":\"6241\"},\n{\"last_update\":\"1187354512\", \"numofapproved\":\"1\", \"id\":\"6881\"},\n{\"last_update\":\"1188918086\", \"numofapproved\":\"1\", \"id\":\"8221\"},\n{\"last_update\":\"1190392989\", \"numofapproved\":\"1\", \"id\":\"9721\"},\n{\"last_update\":\"1190925022\", \"numofapproved\":\"1\", \"id\":\"10583\"},\n{\"last_update\":\"1190959571\", \"numofapproved\":\"1\", \"id\":\"10601\"},\n{\"last_update\":\"1190990357\", \"numofapproved\":\"1\", \"id\":\"10705\"},\n{\"last_update\":\"1190990656\", \"numofapproved\":\"1\", \"id\":\"10710\"},\n{\"last_update\":\"1191226364\", \"numofapproved\":\"1\", \"id\":\"10921\"},\n{\"last_update\":\"1180011741\", \"numofapproved\":\"1\", \"id\":\"1761\"},\n{\"last_update\":\"1180533694\", \"numofapproved\":\"1\", \"id\":\"1961\"},\n{\"last_update\":\"1180731839\", \"numofapproved\":\"1\", \"id\":\"2144\"},\n{\"last_update\":\"1181461876\", \"numofapproved\":\"1\", \"id\":\"2681\"},\n{\"last_update\":\"1181855690\", \"numofapproved\":\"1\", \"id\":\"3061\"},\n{\"last_update\":\"1189537687\", \"numofapproved\":\"1\", \"id\":\"8821\"},\n{\"last_update\":\"1189937430\", \"numofapproved\":\"1\", \"id\":\"9161\"},\n{\"last_update\":\"1190803903\", \"numofapproved\":\"1\", \"id\":\"10261\"},\n{\"last_update\":\"1190973051\", \"numofapproved\":\"1\", \"id\":\"10664\"},\n{\"last_update\":\"1191410739\", \"numofapproved\":\"1\", \"id\":\"11064\"},\n{\"last_update\":\"1191426697\", \"numofapproved\":\"1\", \"id\":\"11121\"},\n{\"last_update\":\"1191446459\", \"numofapproved\":\"1\", \"id\":\"11182\"},\n{\"last_update\":\"1191450891\", \"numofapproved\":\"1\", \"id\":\"11201\"},\n{\"last_update\":\"1191550000\", \"numofapproved\":\"1\", \"id\":\"11441\"},\n{\"last_update\":\"1191588714\", \"numofapproved\":\"1\", \"id\":\"11601\"},\n{\"last_update\":\"1191596815\", \"numofapproved\":\"1\", \"id\":\"11641\"},\n{\"last_update\":\"1191647971\", \"numofapproved\":\"1\", \"id\":\"11741\"},\n{\"last_update\":\"1191949660\", \"numofapproved\":\"1\", \"id\":\"11981\"},\n{\"last_update\":\"1180641844\", \"numofapproved\":\"1\", \"id\":\"2001\"},\n{\"last_update\":\"1188319710\", \"numofapproved\":\"1\", \"id\":\"7661\"},\n{\"last_update\":\"1189169640\", \"numofapproved\":\"1\", \"id\":\"8621\"},\n{\"last_update\":\"1192028009\", \"numofapproved\":\"1\", \"id\":\"12081\"},\n{\"last_update\":\"1192116783\", \"numofapproved\":\"1\", \"id\":\"12261\"},\n{\"last_update\":\"1192558715\", \"numofapproved\":\"1\", \"id\":\"12741\"},\n{\"last_update\":\"1192727702\", \"numofapproved\":\"1\", \"id\":\"13101\"},\n{\"last_update\":\"1193035517\", \"numofapproved\":\"1\", \"id\":\"13262\"},\n{\"last_update\":\"1193080239\", \"numofapproved\":\"1\", \"id\":\"13381\"},\n{\"last_update\":\"1193268912\", \"numofapproved\":\"1\", \"id\":\"13722\"},\n{\"last_update\":\"1193386894\", \"numofapproved\":\"1\", \"id\":\"13946\"},\n{\"last_update\":\"1193388087\", \"numofapproved\":\"1\", \"id\":\"13982\"},\n{\"last_update\":\"1179841973\", \"numofapproved\":\"1\", \"id\":\"1642\"},\n{\"last_update\":\"1179842066\", \"numofapproved\":\"1\", \"id\":\"1662\"},\n{\"last_update\":\"1185971695\", \"numofapproved\":\"1\", \"id\":\"5941\"},\n{\"last_update\":\"1186137440\", \"numofapproved\":\"1\", \"id\":\"6103\"},\n{\"last_update\":\"1192823224\", \"numofapproved\":\"1\", \"id\":\"13181\"},\n{\"last_update\":\"1193921116\", \"numofapproved\":\"1\", \"id\":\"14581\"},\n{\"last_update\":\"1193918035\", \"numofapproved\":\"1\", \"id\":\"14544\"},\n{\"last_update\":\"1193973759\", \"numofapproved\":\"1\", \"id\":\"14663\"},\n{\"last_update\":\"1194004166\", \"numofapproved\":\"1\", \"id\":\"14721\"},\n{\"last_update\":\"1194020795\", \"numofapproved\":\"1\", \"id\":\"14761\"},\n{\"last_update\":\"1194021069\", \"numofapproved\":\"1\", \"id\":\"14781\"},\n{\"last_update\":\"1194283444\", \"numofapproved\":\"1\", \"id\":\"14887\"},\n{\"last_update\":\"1194436909\", \"numofapproved\":\"1\", \"id\":\"15141\"},\n{\"last_update\":\"1194538247\", \"numofapproved\":\"1\", \"id\":\"15341\"},\n{\"last_update\":\"1180031440\", \"numofapproved\":\"1\", \"id\":\"1801\"},\n{\"last_update\":\"1181823965\", \"numofapproved\":\"1\", \"id\":\"2941\"},\n{\"last_update\":\"1182846565\", \"numofapproved\":\"1\", \"id\":\"3561\"},\n{\"last_update\":\"1185872587\", \"numofapproved\":\"1\", \"id\":\"5843\"},\n{\"last_update\":\"1186472951\", \"numofapproved\":\"1\", \"id\":\"6168\"},\n{\"last_update\":\"1189937606\", \"numofapproved\":\"1\", \"id\":\"9181\"},\n{\"last_update\":\"1193389026\", \"numofapproved\":\"1\", \"id\":\"13955\"},\n{\"last_update\":\"1192130592\", \"numofapproved\":\"1\", \"id\":\"12321\"},\n{\"last_update\":\"1194387386\", \"numofapproved\":\"1\", \"id\":\"15061\"},\n{\"last_update\":\"1179336536\", \"numofapproved\":\"1\", \"id\":\"1396\"},\n{\"last_update\":\"1182280246\", \"numofapproved\":\"1\", \"id\":\"3281\"},\n{\"last_update\":\"1183394591\", \"numofapproved\":\"1\", \"id\":\"4001\"},\n{\"last_update\":\"1184677502\", \"numofapproved\":\"1\", \"id\":\"4909\"},\n{\"last_update\":\"1186144184\", \"numofapproved\":\"1\", \"id\":\"6106\"},\n{\"last_update\":\"1187191683\", \"numofapproved\":\"1\", \"id\":\"6701\"},\n{\"last_update\":\"1193909594\", \"numofapproved\":\"1\", \"id\":\"14527\"},\n{\"last_update\":\"1194435747\", \"numofapproved\":\"1\", \"id\":\"15121\"},\n{\"last_update\":\"1184252278\", \"numofapproved\":\"1\", \"id\":\"4761\"},\n{\"last_update\":\"1194854996\", \"numofapproved\":\"1\", \"id\":\"15721\"},\n{\"last_update\":\"1194937730\", \"numofapproved\":\"1\", \"id\":\"16045\"},\n{\"last_update\":\"1193076864\", \"numofapproved\":\"1\", \"id\":\"13361\"},\n{\"last_update\":\"1194904087\", \"numofapproved\":\"1\", \"id\":\"15981\"},\n{\"last_update\":\"1181853751\", \"numofapproved\":\"1\", \"id\":\"3001\"},\n{\"last_update\":\"1182075529\", \"numofapproved\":\"1\", \"id\":\"3161\"},\n{\"last_update\":\"1184883226\", \"numofapproved\":\"1\", \"id\":\"5081\"},\n{\"last_update\":\"1186136013\", \"numofapproved\":\"1\", \"id\":\"6102\"},\n{\"last_update\":\"1193147983\", \"numofapproved\":\"1\", \"id\":\"13481\"},\n{\"last_update\":\"1194532658\", \"numofapproved\":\"1\", \"id\":\"15301\"},\n{\"last_update\":\"1194937763\", \"numofapproved\":\"1\", \"id\":\"16046\"},\n{\"last_update\":\"1195225183\", \"numofapproved\":\"1\", \"id\":\"16981\"},\n{\"last_update\":\"1180616624\", \"numofapproved\":\"1\", \"id\":\"1981\"},\n{\"last_update\":\"1183019269\", \"numofapproved\":\"1\", \"id\":\"3701\"},\n{\"last_update\":\"1188656338\", \"numofapproved\":\"1\", \"id\":\"7941\"},\n{\"last_update\":\"1178799062\", \"numofapproved\":\"1\", \"id\":\"1353\"},\n{\"last_update\":\"1178905809\", \"numofapproved\":\"1\", \"id\":\"1360\"},\n{\"last_update\":\"1179311575\", \"numofapproved\":\"1\", \"id\":\"1408\"},\n{\"last_update\":\"1182507595\", \"numofapproved\":\"1\", \"id\":\"3461\"},\n{\"last_update\":\"1184254004\", \"numofapproved\":\"1\", \"id\":\"4781\"},\n{\"last_update\":\"1187938257\", \"numofapproved\":\"1\", \"id\":\"7381\"},\n{\"last_update\":\"1188473327\", \"numofapproved\":\"1\", \"id\":\"7801\"},\n{\"last_update\":\"1189102174\", \"numofapproved\":\"1\", \"id\":\"8481\"},\n{\"last_update\":\"1191419747\", \"numofapproved\":\"1\", \"id\":\"11102\"},\n{\"last_update\":\"1193389169\", \"numofapproved\":\"1\", \"id\":\"14002\"},\n{\"last_update\":\"1194440930\", \"numofapproved\":\"1\", \"id\":\"15102\"},\n{\"last_update\":\"1194855848\", \"numofapproved\":\"1\", \"id\":\"15741\"},\n{\"last_update\":\"1194862162\", \"numofapproved\":\"1\", \"id\":\"15841\"},\n{\"last_update\":\"1194923605\", \"numofapproved\":\"1\", \"id\":\"16021\"},\n{\"last_update\":\"1194950051\", \"numofapproved\":\"1\", \"id\":\"16142\"},\n{\"last_update\":\"1194960554\", \"numofapproved\":\"1\", \"id\":\"16181\"},\n{\"last_update\":\"1194988868\", \"numofapproved\":\"1\", \"id\":\"16382\"},\n{\"last_update\":\"1195058276\", \"numofapproved\":\"1\", \"id\":\"16601\"},\n{\"last_update\":\"1195469960\", \"numofapproved\":\"1\", \"id\":\"17201\"},\n{\"last_update\":\"1178648361\", \"numofapproved\":\"1\", \"id\":\"1311\"},\n{\"last_update\":\"1183970840\", \"numofapproved\":\"1\", \"id\":\"4401\"},\n{\"last_update\":\"1184838534\", \"numofapproved\":\"1\", \"id\":\"5041\"},\n{\"last_update\":\"1190745858\", \"numofapproved\":\"1\", \"id\":\"10161\"},\n{\"last_update\":\"1191587968\", \"numofapproved\":\"1\", \"id\":\"11581\"},\n{\"last_update\":\"1189773687\", \"numofapproved\":\"1\", \"id\":\"9021\"},\n{\"last_update\":\"1192612866\", \"numofapproved\":\"1\", \"id\":\"12804\"},\n{\"last_update\":\"1193746024\", \"numofapproved\":\"1\", \"id\":\"14461\"},\n{\"last_update\":\"1193918117\", \"numofapproved\":\"1\", \"id\":\"14561\"},\n{\"last_update\":\"1194981013\", \"numofapproved\":\"1\", \"id\":\"16321\"},\n{\"last_update\":\"1195546695\", \"numofapproved\":\"1\", \"id\":\"17481\"},\n{\"last_update\":\"1177592107\", \"numofapproved\":\"1\", \"id\":\"1047\"},\n{\"last_update\":\"1183569612\", \"numofapproved\":\"1\", \"id\":\"4221\"},\n{\"last_update\":\"1186770649\", \"numofapproved\":\"1\", \"id\":\"6401\"},\n{\"last_update\":\"1187707518\", \"numofapproved\":\"1\", \"id\":\"7021\"},\n{\"last_update\":\"1187769297\", \"numofapproved\":\"1\", \"id\":\"7223\"},\n{\"last_update\":\"1187798945\", \"numofapproved\":\"1\", \"id\":\"7241\"},\n{\"last_update\":\"1187820883\", \"numofapproved\":\"1\", \"id\":\"7261\"},\n{\"last_update\":\"1190286816\", \"numofapproved\":\"1\", \"id\":\"9581\"},\n{\"last_update\":\"1190541964\", \"numofapproved\":\"1\", \"id\":\"9842\"},\n{\"last_update\":\"1190500569\", \"numofapproved\":\"1\", \"id\":\"9802\"},\n{\"last_update\":\"1190800190\", \"numofapproved\":\"1\", \"id\":\"10222\"},\n{\"last_update\":\"1190965460\", \"numofapproved\":\"1\", \"id\":\"10642\"},\n{\"last_update\":\"1192120899\", \"numofapproved\":\"1\", \"id\":\"12301\"},\n{\"last_update\":\"1193265675\", \"numofapproved\":\"1\", \"id\":\"13701\"},\n{\"last_update\":\"1194508196\", \"numofapproved\":\"1\", \"id\":\"15261\"},\n{\"last_update\":\"1172503197\", \"numofapproved\":\"1\", \"id\":\"196\"},\n{\"last_update\":\"1172847366\", \"numofapproved\":\"1\", \"id\":\"238\"},\n{\"last_update\":\"1173975764\", \"numofapproved\":\"1\", \"id\":\"347\"},\n{\"last_update\":\"1174301010\", \"numofapproved\":\"1\", \"id\":\"375\"},\n{\"last_update\":\"1174899614\", \"numofapproved\":\"1\", \"id\":\"514\"},\n{\"last_update\":\"1174924853\", \"numofapproved\":\"1\", \"id\":\"527\"},\n{\"last_update\":\"1175270318\", \"numofapproved\":\"1\", \"id\":\"567\"},\n{\"last_update\":\"1174933246\", \"numofapproved\":\"1\", \"id\":\"536\"},\n{\"last_update\":\"1176369900\", \"numofapproved\":\"1\", \"id\":\"889\"},\n{\"last_update\":\"1171102836\", \"numofapproved\":\"1\", \"id\":\"2\"},\n{\"last_update\":\"1171970451\", \"numofapproved\":\"1\", \"id\":\"121\"},\n{\"last_update\":\"1174898953\", \"numofapproved\":\"1\", \"id\":\"484\"},\n{\"last_update\":\"1175610845\", \"numofapproved\":\"1\", \"id\":\"664\"},\n{\"last_update\":\"1176313569\", \"numofapproved\":\"1\", \"id\":\"885\"},\n{\"last_update\":\"1171878648\", \"numofapproved\":\"1\", \"id\":\"89\"},\n{\"last_update\":\"1171897268\", \"numofapproved\":\"1\", \"id\":\"96\"},\n{\"last_update\":\"1172326187\", \"numofapproved\":\"1\", \"id\":\"193\"},\n{\"last_update\":\"1176106905\", \"numofapproved\":\"1\", \"id\":\"802\"},\n{\"last_update\":\"1176389540\", \"numofapproved\":\"1\", \"id\":\"891\"},\n{\"last_update\":\"1171318806\", \"numofapproved\":\"1\", \"id\":\"24\"},\n{\"last_update\":\"1171601548\", \"numofapproved\":\"1\", \"id\":\"66\"},\n{\"last_update\":\"1172148331\", \"numofapproved\":\"1\", \"id\":\"171\"},\n{\"last_update\":\"1172686680\", \"numofapproved\":\"1\", \"id\":\"228\"},\n{\"last_update\":\"1173793572\", \"numofapproved\":\"1\", \"id\":\"308\"},\n{\"last_update\":\"1174899594\", \"numofapproved\":\"1\", \"id\":\"513\"},\n{\"last_update\":\"1174898936\", \"numofapproved\":\"1\", \"id\":\"483\"},\n{\"last_update\":\"1175502773\", \"numofapproved\":\"1\", \"id\":\"622\"},\n{\"last_update\":\"1175722537\", \"numofapproved\":\"1\", \"id\":\"709\"},\n{\"last_update\":\"1175764633\", \"numofapproved\":\"1\", \"id\":\"672\"},\n{\"last_update\":\"1175797156\", \"numofapproved\":\"1\", \"id\":\"721\"},\n{\"last_update\":\"1175899070\", \"numofapproved\":\"1\", \"id\":\"785\"},\n{\"last_update\":\"1176106959\", \"numofapproved\":\"1\", \"id\":\"803\"},\n{\"last_update\":\"1176228460\", \"numofapproved\":\"1\", \"id\":\"824\"},\n{\"last_update\":\"1176488163\", \"numofapproved\":\"1\", \"id\":\"962\"},\n{\"last_update\":\"1172068869\", \"numofapproved\":\"1\", \"id\":\"133\"},\n{\"last_update\":\"1172847381\", \"numofapproved\":\"1\", \"id\":\"239\"},\n{\"last_update\":\"1173888657\", \"numofapproved\":\"1\", \"id\":\"320\"},\n{\"last_update\":\"1171449446\", \"numofapproved\":\"1\", \"id\":\"48\"},\n{\"last_update\":\"1175287424\", \"numofapproved\":\"1\", \"id\":\"581\"},\n{\"last_update\":\"1175502897\", \"numofapproved\":\"1\", \"id\":\"624\"},\n{\"last_update\":\"1175503020\", \"numofapproved\":\"1\", \"id\":\"605\"},\n{\"last_update\":\"1172848367\", \"numofapproved\":\"1\", \"id\":\"243\"},\n{\"last_update\":\"1174301060\", \"numofapproved\":\"1\", \"id\":\"377\"},\n{\"last_update\":\"1176824481\", \"numofapproved\":\"1\", \"id\":\"986\"},\n{\"last_update\":\"1171275893\", \"numofapproved\":\"1\", \"id\":\"6\"},\n{\"last_update\":\"1172546216\", \"numofapproved\":\"1\", \"id\":\"206\"},\n{\"last_update\":\"1175502705\", \"numofapproved\":\"1\", \"id\":\"601\"},\n{\"last_update\":\"1173962671\", \"numofapproved\":\"1\", \"id\":\"341\"},\n{\"last_update\":\"1173975403\", \"numofapproved\":\"1\", \"id\":\"342\"},\n{\"last_update\":\"1173816295\", \"numofapproved\":\"1\", \"id\":\"313\"},\n{\"last_update\":\"1174301256\", \"numofapproved\":\"1\", \"id\":\"384\"},\n{\"last_update\":\"1174933293\", \"numofapproved\":\"1\", \"id\":\"537\"},\n{\"last_update\":\"1176899419\", \"numofapproved\":\"1\", \"id\":\"988\"},\n{\"last_update\":\"1173975599\", \"numofapproved\":\"1\", \"id\":\"345\"},\n{\"last_update\":\"1174041960\", \"numofapproved\":\"1\", \"id\":\"351\"},\n{\"last_update\":\"1175759476\", \"numofapproved\":\"1\", \"id\":\"671\"},\n{\"last_update\":\"1178195644\", \"numofapproved\":\"1\", \"id\":\"1207\"},\n{\"last_update\":\"1178725318\", \"numofapproved\":\"1\", \"id\":\"1348\"},\n{\"last_update\":\"1179333492\", \"numofapproved\":\"1\", \"id\":\"1421\"},\n{\"last_update\":\"1179999737\", \"numofapproved\":\"1\", \"id\":\"1646\"},\n{\"last_update\":\"1180710770\", \"numofapproved\":\"1\", \"id\":\"2062\"},\n{\"last_update\":\"1182868347\", \"numofapproved\":\"1\", \"id\":\"3601\"},\n{\"last_update\":\"1182932927\", \"numofapproved\":\"1\", \"id\":\"3621\"},\n{\"last_update\":\"1183115054\", \"numofapproved\":\"1\", \"id\":\"3784\"},\n{\"last_update\":\"1180000741\", \"numofapproved\":\"1\", \"id\":\"1647\"},\n{\"last_update\":\"1181292582\", \"numofapproved\":\"1\", \"id\":\"2621\"},\n{\"last_update\":\"1184181581\", \"numofapproved\":\"1\", \"id\":\"4641\"},\n{\"last_update\":\"1185280501\", \"numofapproved\":\"1\", \"id\":\"5301\"},\n{\"last_update\":\"1185471699\", \"numofapproved\":\"1\", \"id\":\"5561\"},\n{\"last_update\":\"1185542771\", \"numofapproved\":\"1\", \"id\":\"5701\"},\n{\"last_update\":\"1186650650\", \"numofapproved\":\"1\", \"id\":\"6361\"},\n{\"last_update\":\"1186951065\", \"numofapproved\":\"1\", \"id\":\"6461\"},\n{\"last_update\":\"1187769080\", \"numofapproved\":\"1\", \"id\":\"7221\"},\n{\"last_update\":\"1187887905\", \"numofapproved\":\"1\", \"id\":\"7348\"},\n{\"last_update\":\"1188001607\", \"numofapproved\":\"1\", \"id\":\"7423\"},\n{\"last_update\":\"1188463414\", \"numofapproved\":\"1\", \"id\":\"7762\"},\n{\"last_update\":\"1188555813\", \"numofapproved\":\"1\", \"id\":\"7861\"},\n{\"last_update\":\"1188634622\", \"numofapproved\":\"1\", \"id\":\"7921\"},\n{\"last_update\":\"1189543954\", \"numofapproved\":\"1\", \"id\":\"8841\"},\n{\"last_update\":\"1177511009\", \"numofapproved\":\"1\", \"id\":\"1043\"},\n{\"last_update\":\"1181898808\", \"numofapproved\":\"1\", \"id\":\"3081\"},\n{\"last_update\":\"1182247483\", \"numofapproved\":\"1\", \"id\":\"3221\"},\n{\"last_update\":\"1187024005\", \"numofapproved\":\"1\", \"id\":\"6562\"},\n{\"last_update\":\"1189839471\", \"numofapproved\":\"1\", \"id\":\"9081\"},\n{\"last_update\":\"1190018380\", \"numofapproved\":\"1\", \"id\":\"9241\"},\n{\"last_update\":\"1190149586\", \"numofapproved\":\"1\", \"id\":\"9401\"},\n{\"last_update\":\"1190652684\", \"numofapproved\":\"1\", \"id\":\"9981\"},\n{\"last_update\":\"1190662296\", \"numofapproved\":\"1\", \"id\":\"10022\"},\n{\"last_update\":\"1190813509\", \"numofapproved\":\"1\", \"id\":\"10281\"},\n{\"last_update\":\"1190826005\", \"numofapproved\":\"1\", \"id\":\"10403\"},\n{\"last_update\":\"1190991166\", \"numofapproved\":\"1\", \"id\":\"10722\"},\n{\"last_update\":\"1191057700\", \"numofapproved\":\"1\", \"id\":\"10801\"},\n{\"last_update\":\"1191161241\", \"numofapproved\":\"1\", \"id\":\"10821\"},\n{\"last_update\":\"1191227885\", \"numofapproved\":\"1\", \"id\":\"10941\"},\n{\"last_update\":\"1182537005\", \"numofapproved\":\"1\", \"id\":\"3481\"},\n{\"last_update\":\"1185018401\", \"numofapproved\":\"1\", \"id\":\"5162\"},\n{\"last_update\":\"1186752963\", \"numofapproved\":\"1\", \"id\":\"6386\"},\n{\"last_update\":\"1190660077\", \"numofapproved\":\"1\", \"id\":\"10001\"},\n{\"last_update\":\"1191319062\", \"numofapproved\":\"1\", \"id\":\"10981\"},\n{\"last_update\":\"1191446097\", \"numofapproved\":\"1\", \"id\":\"11161\"},\n{\"last_update\":\"1191446587\", \"numofapproved\":\"1\", \"id\":\"11184\"},\n{\"last_update\":\"1191470824\", \"numofapproved\":\"1\", \"id\":\"11221\"},\n{\"last_update\":\"1191526821\", \"numofapproved\":\"1\", \"id\":\"11401\"},\n{\"last_update\":\"1191585471\", \"numofapproved\":\"1\", \"id\":\"11561\"},\n{\"last_update\":\"1191602213\", \"numofapproved\":\"1\", \"id\":\"11701\"},\n{\"last_update\":\"1191845720\", \"numofapproved\":\"1\", \"id\":\"11821\"},\n{\"last_update\":\"1191933874\", \"numofapproved\":\"1\", \"id\":\"11902\"},\n{\"last_update\":\"1191933897\", \"numofapproved\":\"1\", \"id\":\"11903\"},\n{\"last_update\":\"1177673238\", \"numofapproved\":\"1\", \"id\":\"1161\"},\n{\"last_update\":\"1181601542\", \"numofapproved\":\"1\", \"id\":\"2781\"},\n{\"last_update\":\"1182869532\", \"numofapproved\":\"1\", \"id\":\"3583\"},\n{\"last_update\":\"1183315879\", \"numofapproved\":\"1\", \"id\":\"3881\"},\n{\"last_update\":\"1187097870\", \"numofapproved\":\"1\", \"id\":\"6641\"},\n{\"last_update\":\"1190148660\", \"numofapproved\":\"1\", \"id\":\"9361\"},\n{\"last_update\":\"1192248648\", \"numofapproved\":\"1\", \"id\":\"12521\"},\n{\"last_update\":\"1192702958\", \"numofapproved\":\"1\", \"id\":\"13001\"},\n{\"last_update\":\"1193387721\", \"numofapproved\":\"1\", \"id\":\"13981\"},\n{\"last_update\":\"1193391276\", \"numofapproved\":\"1\", \"id\":\"14021\"},\n{\"last_update\":\"1193397051\", \"numofapproved\":\"1\", \"id\":\"14061\"},\n{\"last_update\":\"1193592081\", \"numofapproved\":\"1\", \"id\":\"14321\"},\n{\"last_update\":\"1188474438\", \"numofapproved\":\"1\", \"id\":\"7821\"},\n{\"last_update\":\"1190158372\", \"numofapproved\":\"1\", \"id\":\"9441\"},\n{\"last_update\":\"1193648459\", \"numofapproved\":\"1\", \"id\":\"14361\"},\n{\"last_update\":\"1193999834\", \"numofapproved\":\"1\", \"id\":\"14681\"},\n{\"last_update\":\"1194200119\", \"numofapproved\":\"1\", \"id\":\"14861\"},\n{\"last_update\":\"1194528747\", \"numofapproved\":\"1\", \"id\":\"15111\"},\n{\"last_update\":\"1179150787\", \"numofapproved\":\"1\", \"id\":\"1384\"},\n{\"last_update\":\"1179266496\", \"numofapproved\":\"1\", \"id\":\"1390\"},\n{\"last_update\":\"1179508139\", \"numofapproved\":\"1\", \"id\":\"1501\"},\n{\"last_update\":\"1179842157\", \"numofapproved\":\"1\", \"id\":\"1664\"},\n{\"last_update\":\"1179842347\", \"numofapproved\":\"1\", \"id\":\"1668\"},\n{\"last_update\":\"1181245388\", \"numofapproved\":\"1\", \"id\":\"2562\"},\n{\"last_update\":\"1181311044\", \"numofapproved\":\"1\", \"id\":\"2661\"},\n{\"last_update\":\"1181545818\", \"numofapproved\":\"1\", \"id\":\"2701\"},\n{\"last_update\":\"1181934881\", \"numofapproved\":\"1\", \"id\":\"3103\"},\n{\"last_update\":\"1187020798\", \"numofapproved\":\"1\", \"id\":\"6541\"},\n{\"last_update\":\"1187271377\", \"numofapproved\":\"1\", \"id\":\"6801\"},\n{\"last_update\":\"1196086904\", \"numofapproved\":\"1\", \"id\":\"17545\"},\n{\"last_update\":\"1196266437\", \"numofapproved\":\"2\", \"id\":\"17662\"},\n{\"last_update\":\"1196266638\", \"numofapproved\":\"2\", \"id\":\"17663\"},\n{\"last_update\":\"1197533251\", \"numofapproved\":\"1\", \"id\":\"17901\"},\n{\"last_update\":\"1197533384\", \"numofapproved\":\"1\", \"id\":\"17923\"},\n{\"last_update\":\"1197556776\", \"numofapproved\":\"2\", \"id\":\"17941\"},\n{\"last_update\":\"1200059354\", \"numofapproved\":\"1\", \"id\":\"17981\"},\n{\"last_update\":\"1200576144\", \"numofapproved\":\"1\", \"id\":\"18001\"},\n{\"last_update\":\"1200576230\", \"numofapproved\":\"1\", \"id\":\"18002\"},\n{\"last_update\":\"1200657266\", \"numofapproved\":\"1\", \"id\":\"18041\"},\n{\"last_update\":\"1201510556\", \"numofapproved\":\"1\", \"id\":\"18061\"},\n{\"last_update\":\"1196087136\", \"numofapproved\":\"1\", \"id\":\"17546\"},\n{\"last_update\":\"1196087269\", \"numofapproved\":\"1\", \"id\":\"17547\"},\n{\"last_update\":\"1196087335\", \"numofapproved\":\"1\", \"id\":\"17548\"},\n{\"last_update\":\"1196087379\", \"numofapproved\":\"1\", \"id\":\"17549\"},\n{\"last_update\":\"1196087427\", \"numofapproved\":\"1\", \"id\":\"17550\"},\n{\"last_update\":\"1196096347\", \"numofapproved\":\"1\", \"id\":\"17581\"},\n{\"last_update\":\"1196265997\", \"numofapproved\":\"2\", \"id\":\"17661\"},\n{\"last_update\":\"1196266785\", \"numofapproved\":\"1\", \"id\":\"17664\"},\n{\"last_update\":\"1196270058\", \"numofapproved\":\"1\", \"id\":\"17701\"},\n{\"last_update\":\"1196431875\", \"numofapproved\":\"1\", \"id\":\"17804\"},\n{\"last_update\":\"1197635044\", \"numofapproved\":\"1\", \"id\":\"17961\"},\n{\"last_update\":\"1202720206\", \"numofapproved\":\"2\", \"id\":\"18084\"},\n{\"last_update\":\"1196267153\", \"numofapproved\":\"1\", \"id\":\"17681\"},\n{\"last_update\":\"1196090749\", \"numofapproved\":\"1\", \"id\":\"17569\"},\n{\"last_update\":\"1196162163\", \"numofapproved\":\"2\", \"id\":\"17641\"},\n{\"last_update\":\"1196345846\", \"numofapproved\":\"1\", \"id\":\"17721\"},\n{\"last_update\":\"1196088254\", \"numofapproved\":\"1\", \"id\":\"17552\"},\n{\"last_update\":\"1196088437\", \"numofapproved\":\"1\", \"id\":\"17564\"},\n{\"last_update\":\"1196088477\", \"numofapproved\":\"1\", \"id\":\"17565\"},\n{\"last_update\":\"1196088537\", \"numofapproved\":\"1\", \"id\":\"17566\"},\n{\"last_update\":\"1196088894\", \"numofapproved\":\"1\", \"id\":\"17567\"},\n{\"last_update\":\"1196090414\", \"numofapproved\":\"1\", \"id\":\"17554\"},\n{\"last_update\":\"1196097621\", \"numofapproved\":\"1\", \"id\":\"17601\"},\n{\"last_update\":\"1196097710\", \"numofapproved\":\"1\", \"id\":\"17602\"},\n{\"last_update\":\"1196098047\", \"numofapproved\":\"1\", \"id\":\"17603\"},\n{\"last_update\":\"1196358376\", \"numofapproved\":\"2\", \"id\":\"17761\"},\n{\"last_update\":\"1196358647\", \"numofapproved\":\"1\", \"id\":\"17762\"},\n{\"last_update\":\"1196427604\", \"numofapproved\":\"1\", \"id\":\"17781\"},\n{\"last_update\":\"1196429856\", \"numofapproved\":\"1\", \"id\":\"17782\"},\n{\"last_update\":\"1196431068\", \"numofapproved\":\"2\", \"id\":\"17783\"},\n{\"last_update\":\"1196435953\", \"numofapproved\":\"2\", \"id\":\"17821\"},\n{\"last_update\":\"1204027277\", \"numofapproved\":\"1\", \"id\":\"18104\"},\n{\"last_update\":\"1196090201\", \"numofapproved\":\"1\", \"id\":\"17553\"},\n{\"last_update\":\"1196097095\", \"numofapproved\":\"1\", \"id\":\"17582\"},\n{\"last_update\":\"1196097215\", \"numofapproved\":\"1\", \"id\":\"17583\"},\n{\"last_update\":\"1196430140\", \"numofapproved\":\"2\", \"id\":\"17803\"},\n{\"last_update\":\"1196436411\", \"numofapproved\":\"2\", \"id\":\"17841\"},\n{\"last_update\":\"1196692298\", \"numofapproved\":\"1\", \"id\":\"17861\"},\n{\"last_update\":\"1196692342\", \"numofapproved\":\"2\", \"id\":\"17862\"},\n{\"last_update\":\"1196695231\", \"numofapproved\":\"2\", \"id\":\"17865\"},\n{\"last_update\":\"1197533316\", \"numofapproved\":\"1\", \"id\":\"17921\"},\n{\"last_update\":\"1201512744\", \"numofapproved\":\"1\", \"id\":\"18082\"},\n{\"last_update\":\"1201513438\", \"numofapproved\":\"2\", \"id\":\"18083\"},\n{\"last_update\":\"1196087540\", \"numofapproved\":\"1\", \"id\":\"17551\"},\n{\"last_update\":\"1196156416\", \"numofapproved\":\"2\", \"id\":\"17621\"},\n{\"last_update\":\"1196356717\", \"numofapproved\":\"1\", \"id\":\"17741\"},\n{\"last_update\":\"1196428544\", \"numofapproved\":\"2\", \"id\":\"17801\"},\n{\"last_update\":\"1196429000\", \"numofapproved\":\"2\", \"id\":\"17802\"},\n{\"last_update\":\"1196692578\", \"numofapproved\":\"1\", \"id\":\"17863\"},\n{\"last_update\":\"1196693445\", \"numofapproved\":\"2\", \"id\":\"17881\"},\n{\"last_update\":\"1196693804\", \"numofapproved\":\"2\", \"id\":\"17864\"},\n{\"last_update\":\"1197533347\", \"numofapproved\":\"1\", \"id\":\"17922\"},\n{\"last_update\":\"1200591782\", \"numofapproved\":\"1\", \"id\":\"18021\"},\n{\"last_update\":\"1201510930\", \"numofapproved\":\"1\", \"id\":\"18081\"},\n{\"last_update\":\"1192432005\", \"numofapproved\":\"1\", \"id\":\"12582\"},\n{\"last_update\":\"1192614291\", \"numofapproved\":\"1\", \"id\":\"12805\"},\n{\"last_update\":\"1192624421\", \"numofapproved\":\"1\", \"id\":\"12806\"},\n{\"last_update\":\"1192983623\", \"numofapproved\":\"1\", \"id\":\"13221\"},\n{\"last_update\":\"1193043248\", \"numofapproved\":\"1\", \"id\":\"13282\"},\n{\"last_update\":\"1193223892\", \"numofapproved\":\"1\", \"id\":\"13562\"},\n{\"last_update\":\"1193239943\", \"numofapproved\":\"1\", \"id\":\"13601\"},\n{\"last_update\":\"1193385960\", \"numofapproved\":\"1\", \"id\":\"13961\"},\n{\"last_update\":\"1193386863\", \"numofapproved\":\"1\", \"id\":\"13945\"},\n{\"last_update\":\"1193399770\", \"numofapproved\":\"1\", \"id\":\"14042\"},\n{\"last_update\":\"1193417684\", \"numofapproved\":\"1\", \"id\":\"14181\"},\n{\"last_update\":\"1193458402\", \"numofapproved\":\"1\", \"id\":\"14261\"},\n{\"last_update\":\"1193555071\", \"numofapproved\":\"1\", \"id\":\"14301\"},\n{\"last_update\":\"1185285506\", \"numofapproved\":\"1\", \"id\":\"5321\"},\n{\"last_update\":\"1188250869\", \"numofapproved\":\"1\", \"id\":\"7521\"},\n{\"last_update\":\"1191410480\", \"numofapproved\":\"1\", \"id\":\"11061\"},\n{\"last_update\":\"1193763056\", \"numofapproved\":\"1\", \"id\":\"14482\"},\n{\"last_update\":\"1193913886\", \"numofapproved\":\"1\", \"id\":\"14542\"},\n{\"last_update\":\"1194366001\", \"numofapproved\":\"1\", \"id\":\"14890\"},\n{\"last_update\":\"1194454607\", \"numofapproved\":\"1\", \"id\":\"15105\"},\n{\"last_update\":\"1194255904\", \"numofapproved\":\"1\", \"id\":\"14941\"},\n{\"last_update\":\"1179328986\", \"numofapproved\":\"1\", \"id\":\"1395\"},\n{\"last_update\":\"1180377628\", \"numofapproved\":\"1\", \"id\":\"1861\"},\n{\"last_update\":\"1181250011\", \"numofapproved\":\"1\", \"id\":\"2563\"},\n{\"last_update\":\"1181572386\", \"numofapproved\":\"1\", \"id\":\"2741\"},\n{\"last_update\":\"1183967114\", \"numofapproved\":\"1\", \"id\":\"4381\"},\n{\"last_update\":\"1192512712\", \"numofapproved\":\"1\", \"id\":\"12623\"},\n{\"last_update\":\"1193172621\", \"numofapproved\":\"1\", \"id\":\"13522\"},\n{\"last_update\":\"1193868932\", \"numofapproved\":\"1\", \"id\":\"14523\"},\n{\"last_update\":\"1194980345\", \"numofapproved\":\"1\", \"id\":\"16301\"},\n{\"last_update\":\"1182280312\", \"numofapproved\":\"1\", \"id\":\"3282\"},\n{\"last_update\":\"1184058726\", \"numofapproved\":\"1\", \"id\":\"4542\"},\n{\"last_update\":\"1188829875\", \"numofapproved\":\"1\", \"id\":\"8161\"},\n{\"last_update\":\"1190129857\", \"numofapproved\":\"1\", \"id\":\"9341\"},\n{\"last_update\":\"1190652687\", \"numofapproved\":\"1\", \"id\":\"9982\"},\n{\"last_update\":\"1193389082\", \"numofapproved\":\"1\", \"id\":\"13956\"},\n{\"last_update\":\"1195400591\", \"numofapproved\":\"1\", \"id\":\"17121\"},\n{\"last_update\":\"1184420846\", \"numofapproved\":\"1\", \"id\":\"4882\"},\n{\"last_update\":\"1184532219\", \"numofapproved\":\"1\", \"id\":\"4903\"},\n{\"last_update\":\"1192030476\", \"numofapproved\":\"1\", \"id\":\"12101\"},\n{\"last_update\":\"1192202239\", \"numofapproved\":\"1\", \"id\":\"12461\"},\n{\"last_update\":\"1192688302\", \"numofapproved\":\"1\", \"id\":\"12961\"},\n{\"last_update\":\"1192703266\", \"numofapproved\":\"1\", \"id\":\"13021\"},\n{\"last_update\":\"1193387096\", \"numofapproved\":\"1\", \"id\":\"13948\"},\n{\"last_update\":\"1193387200\", \"numofapproved\":\"1\", \"id\":\"13949\"},\n{\"last_update\":\"1193909837\", \"numofapproved\":\"1\", \"id\":\"14528\"},\n{\"last_update\":\"1181062093\", \"numofapproved\":\"1\", \"id\":\"2301\"},\n{\"last_update\":\"1182364431\", \"numofapproved\":\"1\", \"id\":\"3348\"},\n{\"last_update\":\"1182364589\", \"numofapproved\":\"1\", \"id\":\"3349\"},\n{\"last_update\":\"1184942429\", \"numofapproved\":\"1\", \"id\":\"5101\"},\n{\"last_update\":\"1192682522\", \"numofapproved\":\"1\", \"id\":\"12901\"},\n{\"last_update\":\"1184756287\", \"numofapproved\":\"1\", \"id\":\"4944\"},\n{\"last_update\":\"1190274411\", \"numofapproved\":\"1\", \"id\":\"9541\"},\n{\"last_update\":\"1193324229\", \"numofapproved\":\"1\", \"id\":\"13861\"},\n{\"last_update\":\"1195163999\", \"numofapproved\":\"1\", \"id\":\"16861\"},\n{\"last_update\":\"1181553321\", \"numofapproved\":\"1\", \"id\":\"2721\"},\n{\"last_update\":\"1178869453\", \"numofapproved\":\"1\", \"id\":\"1361\"},\n{\"last_update\":\"1181219788\", \"numofapproved\":\"1\", \"id\":\"2481\"},\n{\"last_update\":\"1178140002\", \"numofapproved\":\"1\", \"id\":\"1205\"},\n{\"last_update\":\"1178716891\", \"numofapproved\":\"1\", \"id\":\"1345\"},\n{\"last_update\":\"1180691957\", \"numofapproved\":\"1\", \"id\":\"2061\"},\n{\"last_update\":\"1182246242\", \"numofapproved\":\"1\", \"id\":\"3206\"},\n{\"last_update\":\"1182882314\", \"numofapproved\":\"1\", \"id\":\"3585\"},\n{\"last_update\":\"1183124192\", \"numofapproved\":\"1\", \"id\":\"3821\"},\n{\"last_update\":\"1183905634\", \"numofapproved\":\"1\", \"id\":\"4361\"},\n{\"last_update\":\"1191225755\", \"numofapproved\":\"1\", \"id\":\"10901\"},\n{\"last_update\":\"1192635977\", \"numofapproved\":\"1\", \"id\":\"12881\"},\n{\"last_update\":\"1193268752\", \"numofapproved\":\"1\", \"id\":\"13721\"},\n{\"last_update\":\"1193242245\", \"numofapproved\":\"1\", \"id\":\"13621\"},\n{\"last_update\":\"1193949751\", \"numofapproved\":\"1\", \"id\":\"14621\"},\n{\"last_update\":\"1194635892\", \"numofapproved\":\"1\", \"id\":\"15621\"},\n{\"last_update\":\"1194726918\", \"numofapproved\":\"1\", \"id\":\"15664\"},\n{\"last_update\":\"1194726371\", \"numofapproved\":\"1\", \"id\":\"15662\"},\n{\"last_update\":\"1194858043\", \"numofapproved\":\"1\", \"id\":\"15781\"},\n{\"last_update\":\"1194946522\", \"numofapproved\":\"1\", \"id\":\"16101\"},\n{\"last_update\":\"1195047359\", \"numofapproved\":\"1\", \"id\":\"16521\"},\n{\"last_update\":\"1195050812\", \"numofapproved\":\"1\", \"id\":\"16503\"},\n{\"last_update\":\"1195058811\", \"numofapproved\":\"1\", \"id\":\"16621\"},\n{\"last_update\":\"1195476161\", \"numofapproved\":\"1\", \"id\":\"17241\"},\n{\"last_update\":\"1178645683\", \"numofapproved\":\"1\", \"id\":\"1305\"},\n{\"last_update\":\"1183118619\", \"numofapproved\":\"1\", \"id\":\"3801\"},\n{\"last_update\":\"1186150376\", \"numofapproved\":\"1\", \"id\":\"6121\"},\n{\"last_update\":\"1189114226\", \"numofapproved\":\"1\", \"id\":\"8501\"},\n{\"last_update\":\"1190973079\", \"numofapproved\":\"1\", \"id\":\"10666\"},\n{\"last_update\":\"1190990329\", \"numofapproved\":\"1\", \"id\":\"10704\"},\n{\"last_update\":\"1191508485\", \"numofapproved\":\"1\", \"id\":\"11361\"},\n{\"last_update\":\"1183054560\", \"numofapproved\":\"1\", \"id\":\"3721\"},\n{\"last_update\":\"1185263889\", \"numofapproved\":\"1\", \"id\":\"5241\"},\n{\"last_update\":\"1187876083\", \"numofapproved\":\"1\", \"id\":\"7346\"},\n{\"last_update\":\"1189550218\", \"numofapproved\":\"1\", \"id\":\"8861\"},\n{\"last_update\":\"1190800088\", \"numofapproved\":\"1\", \"id\":\"10221\"},\n{\"last_update\":\"1193260528\", \"numofapproved\":\"1\", \"id\":\"13661\"},\n{\"last_update\":\"1172509002\", \"numofapproved\":\"1\", \"id\":\"199\"},\n{\"last_update\":\"1172509846\", \"numofapproved\":\"1\", \"id\":\"200\"},\n{\"last_update\":\"1172589855\", \"numofapproved\":\"1\", \"id\":\"214\"},\n{\"last_update\":\"1172847322\", \"numofapproved\":\"1\", \"id\":\"236\"},\n{\"last_update\":\"1172847433\", \"numofapproved\":\"1\", \"id\":\"242\"},\n{\"last_update\":\"1173607050\", \"numofapproved\":\"1\", \"id\":\"283\"},\n{\"last_update\":\"1173703535\", \"numofapproved\":\"1\", \"id\":\"301\"},\n{\"last_update\":\"1173719825\", \"numofapproved\":\"1\", \"id\":\"302\"},\n{\"last_update\":\"1174414845\", \"numofapproved\":\"1\", \"id\":\"403\"},\n{\"last_update\":\"1174650542\", \"numofapproved\":\"1\", \"id\":\"441\"},\n{\"last_update\":\"1171475944\", \"numofapproved\":\"1\", \"id\":\"52\"},\n{\"last_update\":\"1172746278\", \"numofapproved\":\"1\", \"id\":\"231\"},\n{\"last_update\":\"1173251095\", \"numofapproved\":\"1\", \"id\":\"254\"},\n{\"last_update\":\"1173259501\", \"numofapproved\":\"1\", \"id\":\"255\"},\n{\"last_update\":\"1174899183\", \"numofapproved\":\"1\", \"id\":\"495\"},\n{\"last_update\":\"1174924714\", \"numofapproved\":\"1\", \"id\":\"524\"},\n{\"last_update\":\"1171962179\", \"numofapproved\":\"1\", \"id\":\"108\"},\n{\"last_update\":\"1172522401\", \"numofapproved\":\"1\", \"id\":\"205\"},\n{\"last_update\":\"1174299349\", \"numofapproved\":\"1\", \"id\":\"362\"},\n{\"last_update\":\"1174899291\", \"numofapproved\":\"1\", \"id\":\"500\"},\n{\"last_update\":\"1175617661\", \"numofapproved\":\"1\", \"id\":\"688\"},\n{\"last_update\":\"1176302948\", \"numofapproved\":\"1\", \"id\":\"881\"},\n{\"last_update\":\"1176467393\", \"numofapproved\":\"1\", \"id\":\"893\"},\n{\"last_update\":\"1176737599\", \"numofapproved\":\"1\", \"id\":\"982\"},\n{\"last_update\":\"1171465517\", \"numofapproved\":\"1\", \"id\":\"50\"},\n{\"last_update\":\"1171924670\", \"numofapproved\":\"1\", \"id\":\"107\"},\n{\"last_update\":\"1173880505\", \"numofapproved\":\"1\", \"id\":\"317\"},\n{\"last_update\":\"1173889350\", \"numofapproved\":\"1\", \"id\":\"329\"},\n{\"last_update\":\"1173889557\", \"numofapproved\":\"1\", \"id\":\"332\"},\n{\"last_update\":\"1176391285\", \"numofapproved\":\"1\", \"id\":\"892\"},\n{\"last_update\":\"1176673529\", \"numofapproved\":\"1\", \"id\":\"981\"},\n{\"last_update\":\"1171643442\", \"numofapproved\":\"1\", \"id\":\"69\"},\n{\"last_update\":\"1172226841\", \"numofapproved\":\"1\", \"id\":\"182\"},\n{\"last_update\":\"1174899475\", \"numofapproved\":\"1\", \"id\":\"506\"},\n{\"last_update\":\"1174915327\", \"numofapproved\":\"1\", \"id\":\"521\"},\n{\"last_update\":\"1176194461\", \"numofapproved\":\"1\", \"id\":\"821\"},\n{\"last_update\":\"1172013837\", \"numofapproved\":\"1\", \"id\":\"132\"},\n{\"last_update\":\"1172184974\", \"numofapproved\":\"1\", \"id\":\"177\"},\n{\"last_update\":\"1175777908\", \"numofapproved\":\"1\", \"id\":\"674\"},\n{\"last_update\":\"1173460745\", \"numofapproved\":\"1\", \"id\":\"281\"},\n{\"last_update\":\"1174401746\", \"numofapproved\":\"1\", \"id\":\"402\"},\n{\"last_update\":\"1171274691\", \"numofapproved\":\"1\", \"id\":\"5\"},\n{\"last_update\":\"1171799314\", \"numofapproved\":\"1\", \"id\":\"78\"},\n{\"last_update\":\"1171979089\", \"numofapproved\":\"1\", \"id\":\"127\"},\n{\"last_update\":\"1172503571\", \"numofapproved\":\"1\", \"id\":\"197\"},\n{\"last_update\":\"1174301365\", \"numofapproved\":\"1\", \"id\":\"391\"},\n{\"last_update\":\"1174301259\", \"numofapproved\":\"1\", \"id\":\"385\"},\n{\"last_update\":\"1174899163\", \"numofapproved\":\"1\", \"id\":\"494\"},\n{\"last_update\":\"1174933167\", \"numofapproved\":\"1\", \"id\":\"534\"},\n{\"last_update\":\"1176139704\", \"numofapproved\":\"1\", \"id\":\"808\"},\n{\"last_update\":\"1175502855\", \"numofapproved\":\"1\", \"id\":\"603\"},\n{\"last_update\":\"1173721122\", \"numofapproved\":\"1\", \"id\":\"303\"},\n{\"last_update\":\"1173809079\", \"numofapproved\":\"1\", \"id\":\"311\"},\n{\"last_update\":\"1174734352\", \"numofapproved\":\"1\", \"id\":\"461\"},\n{\"last_update\":\"1174898917\", \"numofapproved\":\"1\", \"id\":\"482\"},\n{\"last_update\":\"1174899374\", \"numofapproved\":\"1\", \"id\":\"503\"},\n{\"last_update\":\"1176392495\", \"numofapproved\":\"1\", \"id\":\"903\"},\n{\"last_update\":\"1176829535\", \"numofapproved\":\"1\", \"id\":\"987\"},\n{\"last_update\":\"1173889385\", \"numofapproved\":\"1\", \"id\":\"330\"},\n{\"last_update\":\"1175869070\", \"numofapproved\":\"1\", \"id\":\"783\"},\n{\"last_update\":\"1177510634\", \"numofapproved\":\"1\", \"id\":\"1042\"},\n{\"last_update\":\"1177585810\", \"numofapproved\":\"1\", \"id\":\"1062\"},\n{\"last_update\":\"1178648303\", \"numofapproved\":\"1\", \"id\":\"1309\"},\n{\"last_update\":\"1178883682\", \"numofapproved\":\"1\", \"id\":\"1363\"},\n{\"last_update\":\"1179239792\", \"numofapproved\":\"1\", \"id\":\"1402\"},\n{\"last_update\":\"1179997715\", \"numofapproved\":\"1\", \"id\":\"1644\"},\n{\"last_update\":\"1180031289\", \"numofapproved\":\"1\", \"id\":\"1654\"},\n{\"last_update\":\"1180440758\", \"numofapproved\":\"1\", \"id\":\"1921\"},\n{\"last_update\":\"1180972413\", \"numofapproved\":\"1\", \"id\":\"2221\"},\n{\"last_update\":\"1181032741\", \"numofapproved\":\"1\", \"id\":\"2261\"},\n{\"last_update\":\"1181198104\", \"numofapproved\":\"1\", \"id\":\"2401\"},\n{\"last_update\":\"1181237541\", \"numofapproved\":\"1\", \"id\":\"2581\"},\n{\"last_update\":\"1181293731\", \"numofapproved\":\"1\", \"id\":\"2641\"},\n{\"last_update\":\"1182231158\", \"numofapproved\":\"1\", \"id\":\"3204\"},\n{\"last_update\":\"1177668412\", \"numofapproved\":\"1\", \"id\":\"1121\"},\n{\"last_update\":\"1178713554\", \"numofapproved\":\"1\", \"id\":\"1342\"},\n{\"last_update\":\"1179239886\", \"numofapproved\":\"1\", \"id\":\"1404\"},\n{\"last_update\":\"1184766561\", \"numofapproved\":\"1\", \"id\":\"4961\"},\n{\"last_update\":\"1185293883\", \"numofapproved\":\"1\", \"id\":\"5341\"},\n{\"last_update\":\"1185781181\", \"numofapproved\":\"1\", \"id\":\"5761\"},\n{\"last_update\":\"1185898126\", \"numofapproved\":\"1\", \"id\":\"5862\"},\n{\"last_update\":\"1186290486\", \"numofapproved\":\"1\", \"id\":\"6164\"},\n{\"last_update\":\"1186260193\", \"numofapproved\":\"1\", \"id\":\"6162\"},\n{\"last_update\":\"1186305362\", \"numofapproved\":\"1\", \"id\":\"6201\"},\n{\"last_update\":\"1187024035\", \"numofapproved\":\"1\", \"id\":\"6563\"},\n{\"last_update\":\"1187245873\", \"numofapproved\":\"1\", \"id\":\"6761\"},\n{\"last_update\":\"1187765176\", \"numofapproved\":\"1\", \"id\":\"7142\"},\n{\"last_update\":\"1187872548\", \"numofapproved\":\"1\", \"id\":\"7343\"},\n{\"last_update\":\"1188774634\", \"numofapproved\":\"1\", \"id\":\"8061\"},\n{\"last_update\":\"1188838929\", \"numofapproved\":\"1\", \"id\":\"8181\"},\n{\"last_update\":\"1189608461\", \"numofapproved\":\"1\", \"id\":\"8881\"},\n{\"last_update\":\"1189667694\", \"numofapproved\":\"1\", \"id\":\"8921\"},\n{\"last_update\":\"1179747423\", \"numofapproved\":\"1\", \"id\":\"1541\"},\n{\"last_update\":\"1181142187\", \"numofapproved\":\"1\", \"id\":\"2381\"},\n{\"last_update\":\"1185965227\", \"numofapproved\":\"1\", \"id\":\"5921\"},\n{\"last_update\":\"1190476977\", \"numofapproved\":\"1\", \"id\":\"9761\"},\n{\"last_update\":\"1190648889\", \"numofapproved\":\"1\", \"id\":\"9961\"},\n{\"last_update\":\"1190824195\", \"numofapproved\":\"1\", \"id\":\"10381\"},\n{\"last_update\":\"1190825530\", \"numofapproved\":\"1\", \"id\":\"10401\"},\n{\"last_update\":\"1190894398\", \"numofapproved\":\"1\", \"id\":\"10501\"},\n{\"last_update\":\"1178271031\", \"numofapproved\":\"1\", \"id\":\"1242\"},\n{\"last_update\":\"1178878052\", \"numofapproved\":\"1\", \"id\":\"1359\"},\n{\"last_update\":\"1178967516\", \"numofapproved\":\"1\", \"id\":\"1364\"},\n{\"last_update\":\"1180018261\", \"numofapproved\":\"1\", \"id\":\"1652\"},\n{\"last_update\":\"1180107922\", \"numofapproved\":\"1\", \"id\":\"1841\"},\n{\"last_update\":\"1180514196\", \"numofapproved\":\"1\", \"id\":\"1941\"},\n{\"last_update\":\"1181901023\", \"numofapproved\":\"1\", \"id\":\"3082\"},\n{\"last_update\":\"1182417878\", \"numofapproved\":\"1\", \"id\":\"3361\"},\n{\"last_update\":\"1182785340\", \"numofapproved\":\"1\", \"id\":\"3521\"},\n{\"last_update\":\"1183485766\", \"numofapproved\":\"1\", \"id\":\"4101\"},\n{\"last_update\":\"1189526136\", \"numofapproved\":\"1\", \"id\":\"8803\"},\n{\"last_update\":\"1191446636\", \"numofapproved\":\"1\", \"id\":\"11185\"},\n{\"last_update\":\"1191489743\", \"numofapproved\":\"1\", \"id\":\"11241\"},\n{\"last_update\":\"1191903141\", \"numofapproved\":\"1\", \"id\":\"11882\"},\n{\"last_update\":\"1191940049\", \"numofapproved\":\"1\", \"id\":\"11941\"},\n{\"last_update\":\"1179239857\", \"numofapproved\":\"1\", \"id\":\"1403\"},\n{\"last_update\":\"1185799202\", \"numofapproved\":\"1\", \"id\":\"5801\"},\n{\"last_update\":\"1190924823\", \"numofapproved\":\"1\", \"id\":\"10562\"},\n{\"last_update\":\"1191410783\", \"numofapproved\":\"1\", \"id\":\"11065\"},\n{\"last_update\":\"1192031578\", \"numofapproved\":\"1\", \"id\":\"12121\"},\n{\"last_update\":\"1192431234\", \"numofapproved\":\"1\", \"id\":\"12562\"},\n{\"last_update\":\"1192609228\", \"numofapproved\":\"1\", \"id\":\"12802\"},\n{\"last_update\":\"1192742243\", \"numofapproved\":\"1\", \"id\":\"13161\"},\n{\"last_update\":\"1192942532\", \"numofapproved\":\"1\", \"id\":\"13201\"},\n{\"last_update\":\"1193386303\", \"numofapproved\":\"1\", \"id\":\"13962\"},\n{\"last_update\":\"1193406158\", \"numofapproved\":\"1\", \"id\":\"14121\"},\n{\"last_update\":\"1193418273\", \"numofapproved\":\"1\", \"id\":\"14201\"},\n{\"last_update\":\"1193519213\", \"numofapproved\":\"1\", \"id\":\"14281\"},\n{\"last_update\":\"1193666593\", \"numofapproved\":\"1\", \"id\":\"14401\"},\n{\"last_update\":\"1193733296\", \"numofapproved\":\"1\", \"id\":\"14421\"},\n{\"last_update\":\"1193760981\", \"numofapproved\":\"1\", \"id\":\"14481\"},\n{\"last_update\":\"1182436569\", \"numofapproved\":\"1\", \"id\":\"3422\"},\n{\"last_update\":\"1184012598\", \"numofapproved\":\"1\", \"id\":\"4481\"},\n{\"last_update\":\"1189715279\", \"numofapproved\":\"1\", \"id\":\"8981\"},\n{\"last_update\":\"1192528903\", \"numofapproved\":\"1\", \"id\":\"12701\"},\n{\"last_update\":\"1194246273\", \"numofapproved\":\"1\", \"id\":\"14901\"},\n{\"last_update\":\"1194354217\", \"numofapproved\":\"1\", \"id\":\"14888\"},\n{\"last_update\":\"1194366787\", \"numofapproved\":\"1\", \"id\":\"14891\"},\n{\"last_update\":\"1194445768\", \"numofapproved\":\"1\", \"id\":\"15104\"},\n{\"last_update\":\"1194467580\", \"numofapproved\":\"1\", \"id\":\"15107\"},\n{\"last_update\":\"1194508237\", \"numofapproved\":\"1\", \"id\":\"15262\"},\n{\"last_update\":\"1194635341\", \"numofapproved\":\"1\", \"id\":\"15581\"},\n{\"last_update\":\"1194635508\", \"numofapproved\":\"1\", \"id\":\"15582\"},\n{\"last_update\":\"1179214538\", \"numofapproved\":\"1\", \"id\":\"1386\"},\n{\"last_update\":\"1186433530\", \"numofapproved\":\"1\", \"id\":\"6167\"},\n{\"last_update\":\"1187853435\", \"numofapproved\":\"1\", \"id\":\"7321\"},\n{\"last_update\":\"1187972012\", \"numofapproved\":\"1\", \"id\":\"7421\"},\n{\"last_update\":\"1188895906\", \"numofapproved\":\"1\", \"id\":\"8201\"},\n{\"last_update\":\"1190284020\", \"numofapproved\":\"1\", \"id\":\"9561\"},\n{\"last_update\":\"1190924163\", \"numofapproved\":\"1\", \"id\":\"10561\"},\n{\"last_update\":\"1192529770\", \"numofapproved\":\"1\", \"id\":\"12663\"},\n{\"last_update\":\"1192536538\", \"numofapproved\":\"1\", \"id\":\"12666\"},\n{\"last_update\":\"1193269090\", \"numofapproved\":\"1\", \"id\":\"13741\"},\n{\"last_update\":\"1193428819\", \"numofapproved\":\"1\", \"id\":\"14221\"},\n{\"last_update\":\"1193860091\", \"numofapproved\":\"1\", \"id\":\"14521\"},\n{\"last_update\":\"1193909426\", \"numofapproved\":\"1\", \"id\":\"14526\"},\n{\"last_update\":\"1194533708\", \"numofapproved\":\"1\", \"id\":\"15321\"},\n{\"last_update\":\"1179822723\", \"numofapproved\":\"1\", \"id\":\"1601\"},\n{\"last_update\":\"1179842248\", \"numofapproved\":\"1\", \"id\":\"1666\"},\n{\"last_update\":\"1182412362\", \"numofapproved\":\"1\", \"id\":\"3352\"},\n{\"last_update\":\"1185980065\", \"numofapproved\":\"1\", \"id\":\"5961\"},\n{\"last_update\":\"1186751100\", \"numofapproved\":\"1\", \"id\":\"6385\"},\n{\"last_update\":\"1187202714\", \"numofapproved\":\"1\", \"id\":\"6721\"},\n{\"last_update\":\"1187601864\", \"numofapproved\":\"1\", \"id\":\"6923\"},\n{\"last_update\":\"1191490727\", \"numofapproved\":\"1\", \"id\":\"11281\"},\n{\"last_update\":\"1194449840\", \"numofapproved\":\"1\", \"id\":\"15161\"},\n{\"last_update\":\"1180028166\", \"numofapproved\":\"1\", \"id\":\"1781\"},\n{\"last_update\":\"1185025939\", \"numofapproved\":\"1\", \"id\":\"5201\"},\n{\"last_update\":\"1192454400\", \"numofapproved\":\"1\", \"id\":\"12621\"},\n{\"last_update\":\"1193414234\", \"numofapproved\":\"1\", \"id\":\"14141\"},\n{\"last_update\":\"1194270682\", \"numofapproved\":\"1\", \"id\":\"14961\"},\n{\"last_update\":\"1184061669\", \"numofapproved\":\"1\", \"id\":\"4561\"},\n{\"last_update\":\"1186161284\", \"numofapproved\":\"1\", \"id\":\"6141\"},\n{\"last_update\":\"1187714492\", \"numofapproved\":\"1\", \"id\":\"7061\"},\n{\"last_update\":\"1187893562\", \"numofapproved\":\"1\", \"id\":\"7361\"},\n{\"last_update\":\"1190815311\", \"numofapproved\":\"1\", \"id\":\"10301\"},\n{\"last_update\":\"1193388120\", \"numofapproved\":\"1\", \"id\":\"13951\"},\n{\"last_update\":\"1195239956\", \"numofapproved\":\"1\", \"id\":\"17041\"},\n{\"last_update\":\"1179147467\", \"numofapproved\":\"1\", \"id\":\"1381\"},\n{\"last_update\":\"1182346611\", \"numofapproved\":\"1\", \"id\":\"3341\"},\n{\"last_update\":\"1184267506\", \"numofapproved\":\"1\", \"id\":\"4802\"},\n{\"last_update\":\"1192047087\", \"numofapproved\":\"1\", \"id\":\"12161\"},\n{\"last_update\":\"1192198948\", \"numofapproved\":\"1\", \"id\":\"12441\"},\n{\"last_update\":\"1193208717\", \"numofapproved\":\"1\", \"id\":\"13528\"},\n{\"last_update\":\"1194907182\", \"numofapproved\":\"1\", \"id\":\"16001\"},\n{\"last_update\":\"1179153020\", \"numofapproved\":\"1\", \"id\":\"1385\"},\n{\"last_update\":\"1179835655\", \"numofapproved\":\"1\", \"id\":\"1641\"},\n{\"last_update\":\"1181234739\", \"numofapproved\":\"1\", \"id\":\"2542\"},\n{\"last_update\":\"1182356477\", \"numofapproved\":\"1\", \"id\":\"3343\"},\n{\"last_update\":\"1182418583\", \"numofapproved\":\"1\", \"id\":\"3381\"},\n{\"last_update\":\"1184568502\", \"numofapproved\":\"1\", \"id\":\"4905\"},\n{\"last_update\":\"1189151603\", \"numofapproved\":\"1\", \"id\":\"8581\"},\n{\"last_update\":\"1191595695\", \"numofapproved\":\"1\", \"id\":\"11621\"},\n{\"last_update\":\"1193105000\", \"numofapproved\":\"1\", \"id\":\"13421\"},\n{\"last_update\":\"1195104657\", \"numofapproved\":\"1\", \"id\":\"16701\"}],\n\"request_timestamp\":1206363392.08521,\n\"request_call\":\"requestDetails\",\n\"instance\":\"tbedi\",\n\"call_time\":\"0.10059\",\n\"request_date\":\"2008-03-2412:56:32 UTC\",\n\"request_url\":\"http://cmsdoc.cern.ch/cms/test/aprom/phedex/dev/gowri/datasvc/tbedi/requestDetails?format=json\"}}\n\"\"\"\n\nfrom jsonParser import jsonObject\n\ndata = jsonObject.parseString(s)[0]\n\n# from pprint import pprint\n# pprint(data)\n# print()\nprint(data[\"phedex\"][\"call_time\"])\nprint(data[\"phedex\"][\"instance\"])\nprint(data[\"phedex\"][\"request_call\"])\nprint(len(data[\"phedex\"][\"request\"]))\nfor req in data[\"phedex\"][\"request\"][:10]:\n    print(\"-\", req[\"id\"], req[\"last_update\"])\n", "examples/dictExample2.py": "#\n# dictExample2.py\n#\n#  Illustration of using pyparsing's Dict class to process tabular data\n#  Enhanced Dict example, courtesy of Mike Kelly\n#\n# Copyright (c) 2004, Paul McGuire\n#\nfrom pyparsing import (\n    Literal,\n    Word,\n    Group,\n    Dict,\n    ZeroOrMore,\n    alphas,\n    nums,\n    delimitedList,\n    pyparsing_common as ppc,\n)\n\ntestData = \"\"\"\n+-------+------+------+------+------+------+------+------+------+\n|       |  A1  |  B1  |  C1  |  D1  |  A2  |  B2  |  C2  |  D2  |\n+=======+======+======+======+======+======+======+======+======+\n| min   |   7  |  43  |   7  |  15  |  82  |  98  |   1  |  37  |\n| max   |  11  |  52  |  10  |  17  |  85  | 112  |   4  |  39  |\n| ave   |   9  |  47  |   8  |  16  |  84  | 106  |   3  |  38  |\n| sdev  |   1  |   3  |   1  |   1  |   1  |   3  |   1  |   1  |\n+-------+------+------+------+------+------+------+------+------+\n\"\"\"\n\n# define grammar for datatable\nunderline = Word(\"-=\")\nnumber = ppc.integer\n\nvert = Literal(\"|\").suppress()\n\nrowDelim = (\"+\" + ZeroOrMore(underline + \"+\")).suppress()\ncolumnHeader = Group(vert + vert + delimitedList(Word(alphas + nums), \"|\") + vert)\n\nheading = rowDelim + columnHeader(\"columns\") + rowDelim\nrowData = Group(vert + Word(alphas) + vert + delimitedList(number, \"|\") + vert)\ntrailing = rowDelim\n\ndatatable = heading + Dict(ZeroOrMore(rowData)) + trailing\n\n# now parse data and print results\ndata = datatable.parseString(testData)\nprint(data.dump())\nprint(\"data keys=\", list(data.keys()))\nprint(\"data['min']=\", data[\"min\"])\nprint(\"sum(data['min']) =\", sum(data[\"min\"]))\nprint(\"data.max =\", data.max)\nprint(\"sum(data.max) =\", sum(data.max))\n\n# now print transpose of data table, using column labels read from table header and\n# values from data lists\nprint()\nprint(\" \" * 5, end=\" \")\nfor i in range(1, len(data)):\n    print(\"|%5s\" % data[i][0], end=\" \")\nprint()\nprint((\"-\" * 6) + (\"+------\" * (len(data) - 1)))\nfor i in range(len(data.columns)):\n    print(\"%5s\" % data.columns[i], end=\" \")\n    for j in range(len(data) - 1):\n        print(\"|%5s\" % data[j + 1][i + 1], end=\" \")\n    print()\n", "examples/nested_markup.py": "#\n# nested_markup.py\n#\n# Example markup parser to recursively transform nested markup directives.\n#\n# Copyright 2019, Paul McGuire\n#\nimport pyparsing as pp\n\nwiki_markup = pp.Forward()\n\n# a method that will construct and return a parse action that will\n# do the proper wrapping in opening and closing HTML, and recursively call\n# wiki_markup.transformString on the markup body text\ndef convert_markup_to_html(opening, closing):\n    def conversionParseAction(s, l, t):\n        return opening + wiki_markup.transformString(t[1][1:-1]) + closing\n\n    return conversionParseAction\n\n\n# use a nestedExpr with originalTextFor to parse nested braces, but return the\n# parsed text as a single string containing the outermost nested braces instead\n# of a nested list of parsed tokens\nmarkup_body = pp.originalTextFor(pp.nestedExpr(\"{\", \"}\"))\nitalicized = (\"ital\" + markup_body).setParseAction(\n    convert_markup_to_html(\"<I>\", \"</I>\")\n)\nbolded = (\"bold\" + markup_body).setParseAction(convert_markup_to_html(\"<B>\", \"</B>\"))\n\n# another markup and parse action to parse links - again using transform string\n# to recursively parse any markup in the link text\ndef convert_link_to_html(s, l, t):\n    link_text, url = t._skipped\n    t[\"link_text\"] = wiki_markup.transformString(link_text)\n    t[\"url\"] = url\n    return '<A href=\"{url}\">{link_text}</A>'.format_map(t)\n\n\nurlRef = (pp.Keyword(\"link\") + \"{\" + ... + \"->\" + ... + \"}\").setParseAction(\n    convert_link_to_html\n)\n\n# now inject all the markup bits as possible markup expressions\nwiki_markup <<= urlRef | italicized | bolded\n\n# try it out!\nwiki_input = \"\"\"\nHere is a simple Wiki input:\n\n  ital{This is in italics}.\n  bold{This is in bold}!\n  bold{This is in ital{bold italics}! But this is just bold.}\n  Here's a URL to link{Pyparsing's bold{Wiki Page}!->https://github.com/pyparsing/pyparsing/wiki}\n\"\"\"\nprint(wiki_markup.transformString(wiki_input))\n", "examples/pythonGrammarParser.py": "# pythonGrammarParser.py\n#\n# Copyright, 2006, by Paul McGuire\n#\n\nfrom pyparsing import *\n\n# should probably read this from the Grammar file provided with the Python source, but\n# this just skips that step and inlines the bnf text directly - this grammar was taken from\n# Python 2.4.1\n#\ngrammar = r\"\"\"\n# Grammar for Python\n\n# Note:  Changing the grammar specified in this file will most likely\n#        require corresponding changes in the parser module\n#        (../Modules/parsermodule.c).  If you can't make the changes to\n#        that module yourself, please coordinate the required changes\n#        with someone who can; ask around on python-dev for help.  Fred\n#        Drake <fdrake@acm.org> will probably be listening there.\n\n# Commands for Kees Blom's railroad program\n#diagram:token NAME\n#diagram:token NUMBER\n#diagram:token STRING\n#diagram:token NEWLINE\n#diagram:token ENDMARKER\n#diagram:token INDENT\n#diagram:output\\input python.bla\n#diagram:token DEDENT\n#diagram:output\\textwidth 20.04cm\\oddsidemargin  0.0cm\\evensidemargin 0.0cm\n#diagram:rules\n\n# Start symbols for the grammar:\n#\tsingle_input is a single interactive statement;\n#\tfile_input is a module or sequence of commands read from an input file;\n#\teval_input is the input for the eval() and input() functions.\n# NB: compound_stmt in single_input is followed by extra NEWLINE!\nsingle_input: NEWLINE | simple_stmt | compound_stmt NEWLINE\nfile_input: (NEWLINE | stmt)* ENDMARKER\neval_input: testlist NEWLINE* ENDMARKER\n\ndecorator: '@' dotted_name [ '(' [arglist] ')' ] NEWLINE\ndecorators: decorator+\nfuncdef: [decorators] 'def' NAME parameters ':' suite\nparameters: '(' [varargslist] ')'\nvarargslist: (fpdef ['=' test] ',')* ('*' NAME [',' '**' NAME] | '**' NAME) | fpdef ['=' test] (',' fpdef ['=' test])* [',']\nfpdef: NAME | '(' fplist ')'\nfplist: fpdef (',' fpdef)* [',']\n\nstmt: simple_stmt | compound_stmt\nsimple_stmt: small_stmt (';' small_stmt)* [';'] NEWLINE\nsmall_stmt: expr_stmt | print_stmt  | del_stmt | pass_stmt | flow_stmt | import_stmt | global_stmt | exec_stmt | assert_stmt\nexpr_stmt: testlist (augassign testlist | ('=' testlist)*)\naugassign: '+=' | '-=' | '*=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='\n# For normal assignments, additional restrictions enforced by the interpreter\nprint_stmt: 'print' ( [ test (',' test)* [','] ] | '>>' test [ (',' test)+ [','] ] )\ndel_stmt: 'del' exprlist\npass_stmt: 'pass'\nflow_stmt: break_stmt | continue_stmt | return_stmt | raise_stmt | yield_stmt\nbreak_stmt: 'break'\ncontinue_stmt: 'continue'\nreturn_stmt: 'return' [testlist]\nyield_stmt: 'yield' testlist\nraise_stmt: 'raise' [test [',' test [',' test]]]\nimport_stmt: import_name | import_from\nimport_name: 'import' dotted_as_names\nimport_from: 'from' dotted_name 'import' ('*' | '(' import_as_names ')' | import_as_names)\nimport_as_name: NAME [NAME NAME]\ndotted_as_name: dotted_name [NAME NAME]\nimport_as_names: import_as_name (',' import_as_name)* [',']\ndotted_as_names: dotted_as_name (',' dotted_as_name)*\ndotted_name: NAME ('.' NAME)*\nglobal_stmt: 'global' NAME (',' NAME)*\nexec_stmt: 'exec' expr ['in' test [',' test]]\nassert_stmt: 'assert' test [',' test]\n#35\ncompound_stmt: if_stmt | while_stmt | for_stmt | try_stmt | funcdef | classdef\nif_stmt: 'if' test ':' suite ('elif' test ':' suite)* ['else' ':' suite]\nwhile_stmt: 'while' test ':' suite ['else' ':' suite]\nfor_stmt: 'for' exprlist 'in' testlist ':' suite ['else' ':' suite]\ntry_stmt: ('try' ':' suite (except_clause ':' suite)+ #diagram:break\n           ['else' ':' suite] | 'try' ':' suite 'finally' ':' suite)\n# NB compile.c makes sure that the default except clause is last\nexcept_clause: 'except' [test [',' test]]\nsuite: simple_stmt | NEWLINE INDENT stmt+ DEDENT\n\ntest: and_test ('or' and_test)* | lambdef\nand_test: not_test ('and' not_test)*\nnot_test: 'not' not_test | comparison\ncomparison: expr (comp_op expr)*\ncomp_op: '<'|'>'|'=='|'>='|'<='|'<>'|'!='|'in'|'not' 'in'|'is'|'is' 'not'\nexpr: xor_expr ('|' xor_expr)*\nxor_expr: and_expr ('^' and_expr)*\nand_expr: shift_expr ('&' shift_expr)*\nshift_expr: arith_expr (('<<'|'>>') arith_expr)*\narith_expr: term (('+'|'-') term)*\nterm: factor (('*'|'/'|'%'|'//') factor)*\nfactor: ('+'|'-'|'~') factor | power\npower: atom trailer* ['**' factor]\natom: '(' [testlist_gexp] ')' | '[' [listmaker] ']' | '{' [dictmaker] '}' | '`' testlist1 '`' | NAME | NUMBER | STRING+\nlistmaker: test ( list_for | (',' test)* [','] )\ntestlist_gexp: test ( gen_for | (',' test)* [','] )\nlambdef: 'lambda' [varargslist] ':' test\ntrailer: '(' [arglist] ')' | '[' subscriptlist ']' | '.' NAME\nsubscriptlist: subscript (',' subscript)* [',']\nsubscript: '.' '.' '.' | test | [test] ':' [test] [sliceop]\nsliceop: ':' [test]\nexprlist: expr (',' expr)* [',']\ntestlist: test (',' test)* [',']\ntestlist_safe: test [(',' test)+ [',']]\ndictmaker: test ':' test (',' test ':' test)* [',']\n\nclassdef: 'class' NAME ['(' testlist ')'] ':' suite\n\narglist: (argument ',')* (argument [',']| '*' test [',' '**' test] | '**' test)\nargument: [test '='] test [gen_for] # Really [keyword '='] test\n\nlist_iter: list_for | list_if\nlist_for: 'for' exprlist 'in' testlist_safe [list_iter]\nlist_if: 'if' test [list_iter]\n\ngen_iter: gen_for | gen_if\ngen_for: 'for' exprlist 'in' test [gen_iter]\ngen_if: 'if' test [gen_iter]\n\ntestlist1: test (',' test)*\n\n# not used in grammar, but may appear in \"node\" passed from Parser to Compiler\nencoding_decl: NAME\n\"\"\"\n\n\nclass SemanticGroup:\n    def __init__(self, contents):\n        self.contents = contents\n        while self.contents[-1].__class__ == self.__class__:\n            self.contents = self.contents[:-1] + self.contents[-1].contents\n\n    def __str__(self):\n        return \"{}({})\".format(\n            self.label,\n            \" \".join([isinstance(c, str) and c or str(c) for c in self.contents]),\n        )\n\n\nclass OrList(SemanticGroup):\n    label = \"OR\"\n    pass\n\n\nclass AndList(SemanticGroup):\n    label = \"AND\"\n    pass\n\n\nclass OptionalGroup(SemanticGroup):\n    label = \"OPT\"\n    pass\n\n\nclass Atom(SemanticGroup):\n    def __init__(self, contents):\n        if len(contents) > 1:\n            self.rep = contents[1]\n        else:\n            self.rep = \"\"\n        if isinstance(contents, str):\n            self.contents = contents\n        else:\n            self.contents = contents[0]\n\n    def __str__(self):\n        return \"{}{}\".format(self.rep, self.contents)\n\n\ndef makeGroupObject(cls):\n    def groupAction(s, l, t):\n        try:\n            return cls(t[0].asList())\n        except Exception:\n            return cls(t)\n\n    return groupAction\n\n\n# bnf punctuation\nLPAREN = Suppress(\"(\")\nRPAREN = Suppress(\")\")\nLBRACK = Suppress(\"[\")\nRBRACK = Suppress(\"]\")\nCOLON = Suppress(\":\")\nALT_OP = Suppress(\"|\")\n\n# bnf grammar\nident = Word(alphanums + \"_\")\nbnfToken = Word(alphanums + \"_\") + ~FollowedBy(\":\")\nrepSymbol = oneOf(\"* +\")\nbnfExpr = Forward()\noptionalTerm = Group(LBRACK + bnfExpr + RBRACK).setParseAction(\n    makeGroupObject(OptionalGroup)\n)\nbnfTerm = (\n    (bnfToken | quotedString | optionalTerm | (LPAREN + bnfExpr + RPAREN))\n    + Optional(repSymbol)\n).setParseAction(makeGroupObject(Atom))\nandList = Group(bnfTerm + OneOrMore(bnfTerm)).setParseAction(makeGroupObject(AndList))\nbnfFactor = andList | bnfTerm\norList = Group(bnfFactor + OneOrMore(ALT_OP + bnfFactor)).setParseAction(\n    makeGroupObject(OrList)\n)\nbnfExpr << (orList | bnfFactor)\nbnfLine = ident + COLON + bnfExpr\n\nbnfComment = \"#\" + restOfLine\n\n# build return tokens as a dictionary\nbnf = Dict(OneOrMore(Group(bnfLine)))\nbnf.ignore(bnfComment)\n\n# bnf is defined, parse the grammar text\nbnfDefs = bnf.parseString(grammar)\n\n# correct answer is 78\nexpected = 78\nassert len(bnfDefs) == expected, \"Error, found %d BNF defns, expected %d\" % (\n    len(bnfDefs),\n    expected,\n)\n\n# list out defns in order they were parsed (to verify accuracy of parsing)\nfor k, v in bnfDefs:\n    print(k, \"=\", v)\nprint()\n\n# list out parsed grammar defns (demonstrates dictionary access to parsed tokens)\nfor k in list(bnfDefs.keys()):\n    print(k, \"=\", bnfDefs[k])\n", "examples/fourFn.py": "# fourFn.py\n#\n# Demonstration of the pyparsing module, implementing a simple 4-function expression parser,\n# with support for scientific notation, and symbols for e and pi.\n# Extended to add exponentiation and simple built-in functions.\n# Extended test cases, simplified pushFirst method.\n# Removed unnecessary expr.suppress() call (thanks Nathaniel Peterson!), and added Group\n# Changed fnumber to use a Regex, which is now the preferred method\n# Reformatted to latest pyparsing features, support multiple and variable args to functions\n#\n# Copyright 2003-2019 by Paul McGuire\n#\nfrom pyparsing import (\n    Literal,\n    Word,\n    Group,\n    Forward,\n    alphas,\n    alphanums,\n    Regex,\n    ParseException,\n    CaselessKeyword,\n    Suppress,\n    delimitedList,\n)\nimport math\nimport operator\n\nexprStack = []\n\n\ndef push_first(toks):\n    exprStack.append(toks[0])\n\n\ndef push_unary_minus(toks):\n    for t in toks:\n        if t == \"-\":\n            exprStack.append(\"unary -\")\n        else:\n            break\n\n\nbnf = None\n\n\ndef BNF():\n    \"\"\"\n    expop   :: '^'\n    multop  :: '*' | '/'\n    addop   :: '+' | '-'\n    integer :: ['+' | '-'] '0'..'9'+\n    atom    :: PI | E | real | fn '(' expr ')' | '(' expr ')'\n    factor  :: atom [ expop factor ]*\n    term    :: factor [ multop factor ]*\n    expr    :: term [ addop term ]*\n    \"\"\"\n    global bnf\n    if not bnf:\n        # use CaselessKeyword for e and pi, to avoid accidentally matching\n        # functions that start with 'e' or 'pi' (such as 'exp'); Keyword\n        # and CaselessKeyword only match whole words\n        e = CaselessKeyword(\"E\")\n        pi = CaselessKeyword(\"PI\")\n        # fnumber = Combine(Word(\"+-\"+nums, nums) +\n        #                    Optional(\".\" + Optional(Word(nums))) +\n        #                    Optional(e + Word(\"+-\"+nums, nums)))\n        # or use provided pyparsing_common.number, but convert back to str:\n        # fnumber = ppc.number().addParseAction(lambda t: str(t[0]))\n        fnumber = Regex(r\"[+-]?\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?\")\n        ident = Word(alphas, alphanums + \"_$\")\n\n        plus, minus, mult, div = map(Literal, \"+-*/\")\n        lpar, rpar = map(Suppress, \"()\")\n        addop = plus | minus\n        multop = mult | div\n        expop = Literal(\"^\")\n\n        expr = Forward()\n        expr_list = delimitedList(Group(expr))\n        # add parse action that replaces the function identifier with a (name, number of args) tuple\n        def insert_fn_argcount_tuple(t):\n            fn = t.pop(0)\n            num_args = len(t[0])\n            t.insert(0, (fn, num_args))\n\n        fn_call = (ident + lpar - Group(expr_list) + rpar).setParseAction(\n            insert_fn_argcount_tuple\n        )\n        atom = (\n            addop[...]\n            + (\n                (fn_call | pi | e | fnumber | ident).setParseAction(push_first)\n                | Group(lpar + expr + rpar)\n            )\n        ).setParseAction(push_unary_minus)\n\n        # by defining exponentiation as \"atom [ ^ factor ]...\" instead of \"atom [ ^ atom ]...\", we get right-to-left\n        # exponents, instead of left-to-right that is, 2^3^2 = 2^(3^2), not (2^3)^2.\n        factor = Forward()\n        factor <<= atom + (expop + factor).setParseAction(push_first)[...]\n        term = factor + (multop + factor).setParseAction(push_first)[...]\n        expr <<= term + (addop + term).setParseAction(push_first)[...]\n        bnf = expr\n    return bnf\n\n\n# map operator symbols to corresponding arithmetic operations\nepsilon = 1e-12\nopn = {\n    \"+\": operator.add,\n    \"-\": operator.sub,\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n    \"^\": operator.pow,\n}\n\nfn = {\n    \"sin\": math.sin,\n    \"cos\": math.cos,\n    \"tan\": math.tan,\n    \"exp\": math.exp,\n    \"abs\": abs,\n    \"trunc\": int,\n    \"round\": round,\n    \"sgn\": lambda a: -1 if a < -epsilon else 1 if a > epsilon else 0,\n    # functionsl with multiple arguments\n    \"multiply\": lambda a, b: a * b,\n    \"hypot\": math.hypot,\n    # functions with a variable number of arguments\n    \"all\": lambda *a: all(a),\n}\n\n\ndef evaluate_stack(s):\n    op, num_args = s.pop(), 0\n    if isinstance(op, tuple):\n        op, num_args = op\n    if op == \"unary -\":\n        return -evaluate_stack(s)\n    if op in \"+-*/^\":\n        # note: operands are pushed onto the stack in reverse order\n        op2 = evaluate_stack(s)\n        op1 = evaluate_stack(s)\n        return opn[op](op1, op2)\n    elif op == \"PI\":\n        return math.pi  # 3.1415926535\n    elif op == \"E\":\n        return math.e  # 2.718281828\n    elif op in fn:\n        # note: args are pushed onto the stack in reverse order\n        args = reversed([evaluate_stack(s) for _ in range(num_args)])\n        return fn[op](*args)\n    elif op[0].isalpha():\n        raise Exception(\"invalid identifier '%s'\" % op)\n    else:\n        # try to evaluate as int first, then as float if int fails\n        try:\n            return int(op)\n        except ValueError:\n            return float(op)\n\n\nif __name__ == \"__main__\":\n\n    def test(s, expected):\n        exprStack[:] = []\n        try:\n            results = BNF().parseString(s, parseAll=True)\n            val = evaluate_stack(exprStack[:])\n        except ParseException as pe:\n            print(s, \"failed parse:\", str(pe))\n        except Exception as e:\n            print(s, \"failed eval:\", str(e), exprStack)\n        else:\n            if val == expected:\n                print(s, \"=\", val, results, \"=>\", exprStack)\n            else:\n                print(s + \"!!!\", val, \"!=\", expected, results, \"=>\", exprStack)\n\n    test(\"9\", 9)\n    test(\"-9\", -9)\n    test(\"--9\", 9)\n    test(\"-E\", -math.e)\n    test(\"9 + 3 + 6\", 9 + 3 + 6)\n    test(\"9 + 3 / 11\", 9 + 3.0 / 11)\n    test(\"(9 + 3)\", (9 + 3))\n    test(\"(9+3) / 11\", (9 + 3.0) / 11)\n    test(\"9 - 12 - 6\", 9 - 12 - 6)\n    test(\"9 - (12 - 6)\", 9 - (12 - 6))\n    test(\"2*3.14159\", 2 * 3.14159)\n    test(\"3.1415926535*3.1415926535 / 10\", 3.1415926535 * 3.1415926535 / 10)\n    test(\"PI * PI / 10\", math.pi * math.pi / 10)\n    test(\"PI*PI/10\", math.pi * math.pi / 10)\n    test(\"PI^2\", math.pi ** 2)\n    test(\"round(PI^2)\", round(math.pi ** 2))\n    test(\"6.02E23 * 8.048\", 6.02e23 * 8.048)\n    test(\"e / 3\", math.e / 3)\n    test(\"sin(PI/2)\", math.sin(math.pi / 2))\n    test(\"10+sin(PI/4)^2\", 10 + math.sin(math.pi / 4) ** 2)\n    test(\"trunc(E)\", int(math.e))\n    test(\"trunc(-E)\", int(-math.e))\n    test(\"round(E)\", round(math.e))\n    test(\"round(-E)\", round(-math.e))\n    test(\"E^PI\", math.e ** math.pi)\n    test(\"exp(0)\", 1)\n    test(\"exp(1)\", math.e)\n    test(\"2^3^2\", 2 ** 3 ** 2)\n    test(\"(2^3)^2\", (2 ** 3) ** 2)\n    test(\"2^3+2\", 2 ** 3 + 2)\n    test(\"2^3+5\", 2 ** 3 + 5)\n    test(\"2^9\", 2 ** 9)\n    test(\"sgn(-2)\", -1)\n    test(\"sgn(0)\", 0)\n    test(\"sgn(0.1)\", 1)\n    test(\"foo(0.1)\", None)\n    test(\"round(E, 3)\", round(math.e, 3))\n    test(\"round(PI^2, 3)\", round(math.pi ** 2, 3))\n    test(\"sgn(cos(PI/4))\", 1)\n    test(\"sgn(cos(PI/2))\", 0)\n    test(\"sgn(cos(PI*3/4))\", -1)\n    test(\"+(sgn(cos(PI/4)))\", 1)\n    test(\"-(sgn(cos(PI/4)))\", -1)\n    test(\"hypot(3, 4)\", 5)\n    test(\"multiply(3, 7)\", 21)\n    test(\"all(1,1,1)\", True)\n    test(\"all(1,1,1,1,1,0)\", False)\n\n\n\"\"\"\nTest output:\n>python fourFn.py\n9 = 9 ['9'] => ['9']\n-9 = -9 ['-', '9'] => ['9', 'unary -']\n--9 = 9 ['-', '-', '9'] => ['9', 'unary -', 'unary -']\n-E = -2.718281828459045 ['-', 'E'] => ['E', 'unary -']\n9 + 3 + 6 = 18 ['9', '+', '3', '+', '6'] => ['9', '3', '+', '6', '+']\n9 + 3 / 11 = 9.272727272727273 ['9', '+', '3', '/', '11'] => ['9', '3', '11', '/', '+']\n(9 + 3) = 12 [['9', '+', '3']] => ['9', '3', '+']\n(9+3) / 11 = 1.0909090909090908 [['9', '+', '3'], '/', '11'] => ['9', '3', '+', '11', '/']\n9 - 12 - 6 = -9 ['9', '-', '12', '-', '6'] => ['9', '12', '-', '6', '-']\n9 - (12 - 6) = 3 ['9', '-', ['12', '-', '6']] => ['9', '12', '6', '-', '-']\n2*3.14159 = 6.28318 ['2', '*', '3.14159'] => ['2', '3.14159', '*']\n3.1415926535*3.1415926535 / 10 = 0.9869604400525172 ['3.1415926535', '*', '3.1415926535', '/', '10'] => ['3.1415926535', '3.1415926535', '*', '10', '/']\nPI * PI / 10 = 0.9869604401089358 ['PI', '*', 'PI', '/', '10'] => ['PI', 'PI', '*', '10', '/']\nPI*PI/10 = 0.9869604401089358 ['PI', '*', 'PI', '/', '10'] => ['PI', 'PI', '*', '10', '/']\nPI^2 = 9.869604401089358 ['PI', '^', '2'] => ['PI', '2', '^']\nround(PI^2) = 10 [('round', 1), [['PI', '^', '2']]] => ['PI', '2', '^', ('round', 1)]\n6.02E23 * 8.048 = 4.844896e+24 ['6.02E23', '*', '8.048'] => ['6.02E23', '8.048', '*']\ne / 3 = 0.9060939428196817 ['E', '/', '3'] => ['E', '3', '/']\nsin(PI/2) = 1.0 [('sin', 1), [['PI', '/', '2']]] => ['PI', '2', '/', ('sin', 1)]\n10+sin(PI/4)^2 = 10.5 ['10', '+', ('sin', 1), [['PI', '/', '4']], '^', '2'] => ['10', 'PI', '4', '/', ('sin', 1), '2', '^', '+']\ntrunc(E) = 2 [('trunc', 1), [['E']]] => ['E', ('trunc', 1)]\ntrunc(-E) = -2 [('trunc', 1), [['-', 'E']]] => ['E', 'unary -', ('trunc', 1)]\nround(E) = 3 [('round', 1), [['E']]] => ['E', ('round', 1)]\nround(-E) = -3 [('round', 1), [['-', 'E']]] => ['E', 'unary -', ('round', 1)]\nE^PI = 23.140692632779263 ['E', '^', 'PI'] => ['E', 'PI', '^']\nexp(0) = 1.0 [('exp', 1), [['0']]] => ['0', ('exp', 1)]\nexp(1) = 2.718281828459045 [('exp', 1), [['1']]] => ['1', ('exp', 1)]\n2^3^2 = 512 ['2', '^', '3', '^', '2'] => ['2', '3', '2', '^', '^']\n(2^3)^2 = 64 [['2', '^', '3'], '^', '2'] => ['2', '3', '^', '2', '^']\n2^3+2 = 10 ['2', '^', '3', '+', '2'] => ['2', '3', '^', '2', '+']\n2^3+5 = 13 ['2', '^', '3', '+', '5'] => ['2', '3', '^', '5', '+']\n2^9 = 512 ['2', '^', '9'] => ['2', '9', '^']\nsgn(-2) = -1 [('sgn', 1), [['-', '2']]] => ['2', 'unary -', ('sgn', 1)]\nsgn(0) = 0 [('sgn', 1), [['0']]] => ['0', ('sgn', 1)]\nsgn(0.1) = 1 [('sgn', 1), [['0.1']]] => ['0.1', ('sgn', 1)]\nfoo(0.1) failed eval: invalid identifier 'foo' ['0.1', ('foo', 1)]\nround(E, 3) = 2.718 [('round', 2), [['E'], ['3']]] => ['E', '3', ('round', 2)]\nround(PI^2, 3) = 9.87 [('round', 2), [['PI', '^', '2'], ['3']]] => ['PI', '2', '^', '3', ('round', 2)]\nsgn(cos(PI/4)) = 1 [('sgn', 1), [[('cos', 1), [['PI', '/', '4']]]]] => ['PI', '4', '/', ('cos', 1), ('sgn', 1)]\nsgn(cos(PI/2)) = 0 [('sgn', 1), [[('cos', 1), [['PI', '/', '2']]]]] => ['PI', '2', '/', ('cos', 1), ('sgn', 1)]\nsgn(cos(PI*3/4)) = -1 [('sgn', 1), [[('cos', 1), [['PI', '*', '3', '/', '4']]]]] => ['PI', '3', '*', '4', '/', ('cos', 1), ('sgn', 1)]\n+(sgn(cos(PI/4))) = 1 ['+', [('sgn', 1), [[('cos', 1), [['PI', '/', '4']]]]]] => ['PI', '4', '/', ('cos', 1), ('sgn', 1)]\n-(sgn(cos(PI/4))) = -1 ['-', [('sgn', 1), [[('cos', 1), [['PI', '/', '4']]]]]] => ['PI', '4', '/', ('cos', 1), ('sgn', 1), 'unary -']\n\"\"\"\n", "examples/getNTPserversNew.py": "# getNTPserversNew.py\n#\n# Demonstration of the parsing module, implementing a HTML page scanner,\n# to extract a list of NTP time servers from the NIST web site.\n#\n# Copyright 2004-2010, by Paul McGuire\n# September, 2010 - updated to more current use of setResultsName, new NIST URL\n#\nimport pyparsing as pp\n\nppc = pp.pyparsing_common\nfrom urllib.request import urlopen\n\ninteger = pp.Word(pp.nums)\nipAddress = ppc.ipv4_address()\nhostname = pp.DelimitedList(pp.Word(pp.alphas, pp.alphanums + \"-_\"), \".\", combine=True)\ntdStart, tdEnd = pp.make_html_tags(\"td\")\ntimeServerPattern = (\n    tdStart\n    + hostname(\"hostname\")\n    + tdEnd\n    + tdStart\n    + ipAddress(\"ipAddr\")\n    + tdEnd\n    + tdStart\n    + tdStart.tag_body(\"loc\")\n    + tdEnd\n)\n\n# get list of time servers\nnistTimeServerURL = \"https://tf.nist.gov/tf-cgi/servers.cgi#\"\nwith urlopen(nistTimeServerURL) as serverListPage:\n    serverListHTML = serverListPage.read().decode(\"UTF-8\")\n\naddrs = {}\nfor srvr, startloc, endloc in timeServerPattern.scan_string(serverListHTML):\n    print(f\"{srvr.ipAddr} ({srvr.hostname.strip()}) - {srvr.loc.strip()}\")\n    addrs[srvr.ipAddr] = srvr.loc\n", "examples/rosettacode.py": "#\n# rosettacode.py\n#\n# parser for language used by rosettacode.org (http://rosettacode.org/wiki/Compiler/syntax_analyzer)\n#\n# Copyright Paul McGuire, 2019\n#\nBNF = \"\"\"\n    stmt_list           =   {stmt} ;\n\n    stmt                =   ';'\n                          | Identifier '=' expr ';'\n                          | 'while' paren_expr stmt\n                          | 'if' paren_expr stmt ['else' stmt]\n                          | 'print' '(' prt_list ')' ';'\n                          | 'putc' paren_expr ';'\n                          | '{' stmt_list '}'\n                          ;\n\n    paren_expr          =   '(' expr ')' ;\n\n    prt_list            =   string | expr {',' String | expr} ;\n\n    expr                =   and_expr            {'||' and_expr} ;\n    and_expr            =   equality_expr       {'&&' equality_expr} ;\n    equality_expr       =   relational_expr     [('==' | '!=') relational_expr] ;\n    relational_expr     =   addition_expr       [('<' | '<=' | '>' | '>=') addition_expr] ;\n    addition_expr       =   multiplication_expr {('+' | '-') multiplication_expr} ;\n    multiplication_expr =   primary             {('*' | '/' | '%') primary } ;\n    primary             =   Identifier\n                          | Integer\n                          | '(' expr ')'\n                          | ('+' | '-' | '!') primary\n                          ;\n\"\"\"\n\nimport pyparsing as pp\n\npp.ParserElement.enablePackrat()\n\nLBRACE, RBRACE, LPAR, RPAR, SEMI = map(pp.Suppress, \"{}();\")\nEQ = pp.Literal(\"=\")\n\nkeywords = (WHILE, IF, PRINT, PUTC, ELSE) = map(\n    pp.Keyword, \"while if print putc else\".split()\n)\nany_keyword = pp.MatchFirst(keywords)\nidentifier = ~any_keyword + pp.pyparsing_common.identifier\ninteger = pp.pyparsing_common.integer\nstring = pp.QuotedString('\"', convertWhitespaceEscapes=False).setName(\"quoted string\")\nchar = pp.Regex(r\"'\\\\?.'\")\n\n# fmt: off\nexpr = pp.infixNotation(\n    identifier | integer | char,\n    [\n        (pp.oneOf(\"+ - !\"), 1, pp.opAssoc.RIGHT,),\n        (pp.oneOf(\"* / %\"), 2, pp.opAssoc.LEFT, ),\n        (pp.oneOf(\"+ -\"), 2, pp.opAssoc.LEFT, ),\n        (pp.oneOf(\"< <= > >=\"), 2, pp.opAssoc.LEFT, ),\n        (pp.oneOf(\"== !=\"), 2, pp.opAssoc.LEFT, ),\n        (pp.oneOf(\"&&\"), 2, pp.opAssoc.LEFT, ),\n        (pp.oneOf(\"||\"), 2, pp.opAssoc.LEFT, ),\n    ],\n)\n# fmt: on\n\nprt_list = pp.Group(pp.delimitedList(string | expr))\nparen_expr = pp.Group(LPAR + expr + RPAR)\n\nstmt = pp.Forward()\nassignment_stmt = pp.Group(identifier + EQ + expr + SEMI)\nwhile_stmt = pp.Group(WHILE - paren_expr + stmt)\nif_stmt = pp.Group(IF - paren_expr + stmt + pp.Optional(ELSE + stmt))\nprint_stmt = pp.Group(PRINT - pp.Group(LPAR + prt_list + RPAR) + SEMI)\nputc_stmt = pp.Group(PUTC - paren_expr + SEMI)\nstmt_list = pp.Group(LBRACE + stmt[...] + RBRACE)\nstmt <<= (\n    pp.Group(SEMI)\n    | assignment_stmt\n    | while_stmt\n    | if_stmt\n    | print_stmt\n    | putc_stmt\n    | stmt_list\n).setName(\"statement\")\n\ncode = stmt[...]\ncode.ignore(pp.cppStyleComment)\n\n\ntests = [\n    r\"\"\"\n        count = 1;\n        while (count < 10) {\n            print(\"count is: \", count, \"\\n\");\n            count = count + 1;\n        }\n    \"\"\",\n    r\"\"\"\n        /*\n         Simple prime number generator\n         */\n        count = 1;\n        n = 1;\n        limit = 100;\n        while (n < limit) {\n            k=3;\n            p=1;\n            n=n+2;\n            while ((k*k<=n) && (p)) {\n                p=n/k*k!=n;\n                k=k+2;\n            }\n            if (p) {\n                print(n, \" is prime\\n\");\n                count = count + 1;\n            }\n        }\n        print(\"Total primes found: \", count, \"\\n\");\n    \"\"\",\n    r\"\"\"\n        /*\n          Hello world\n         */\n        print(\"Hello, World!\\n\");\n    \"\"\",\n    r\"\"\"\n        /*\n          Show Ident and Integers\n         */\n        phoenix_number = 142857;\n        print(phoenix_number, \"\\n\");\n    \"\"\",\n    r\"\"\"\n        /*** test printing, embedded \\n and comments with lots of '*' ***/\n        print(42);\n        print(\"\\nHello World\\nGood Bye\\nok\\n\");\n        print(\"Print a slash n - \\\\n.\\n\");\n    \"\"\",\n    r\"\"\"\n        /* 100 Doors */\n        i = 1;\n        while (i * i <= 100) {\n            print(\"door \", i * i, \" is open\\n\");\n            i = i + 1;\n        }\n    \"\"\",\n    r\"\"\"\n        a = (-1 * ((-1 * (5 * 15)) / 10));\n        print(a, \"\\n\");\n        b = -a;\n        print(b, \"\\n\");\n        print(-b, \"\\n\");\n        print(-(1), \"\\n\");\n    \"\"\",\n    r\"\"\"\n        print(---------------------------------+++5, \"\\n\");\n        print(((((((((3 + 2) * ((((((2))))))))))))), \"\\n\");\n\n        if (1) { if (1) { if (1) { if (1) { if (1) { print(15, \"\\n\"); } } } } }\n    \"\"\",\n    r\"\"\"\n        /* Compute the gcd of 1071, 1029:  21 */\n\n        a = 1071;\n        b = 1029;\n\n        while (b != 0) {\n            new_a = b;\n            b     = a % b;\n            a     = new_a;\n        }\n        print(a);\n    \"\"\",\n    r\"\"\"\n        /* 12 factorial is 479001600 */\n\n        n = 12;\n        result = 1;\n        i = 1;\n        while (i <= n) {\n            result = result * i;\n            i = i + 1;\n        }\n        print(result);\n    \"\"\",\n    r\"\"\"\n        /* fibonacci of 44 is 701408733 */\n\n        n = 44;\n        i = 1;\n        a = 0;\n        b = 1;\n        while (i < n) {\n            w = a + b;\n            a = b;\n            b = w;\n            i = i + 1;\n        }\n        print(w, \"\\n\");\n    \"\"\",\n    r\"\"\"\n        /* FizzBuzz */\n        i = 1;\n        while (i <= 100) {\n            if (!(i % 15))\n                print(\"FizzBuzz\");\n            else if (!(i % 3))\n                print(\"Fizz\");\n            else if (!(i % 5))\n                print(\"Buzz\");\n            else\n                print(i);\n\n            print(\"\\n\");\n            i = i + 1;\n        }\n    \"\"\",\n    r\"\"\"\n        /* 99 bottles */\n        bottles = 99;\n        while (bottles > 0) {\n            print(bottles, \" bottles of beer on the wall\\n\");\n            print(bottles, \" bottles of beer\\n\");\n            print(\"Take one down, pass it around\\n\");\n            bottles = bottles - 1;\n            print(bottles, \" bottles of beer on the wall\\n\\n\");\n        }\n    \"\"\",\n    r\"\"\"\n         {\n        /*\n         This is an integer ascii Mandelbrot generator\n         */\n            left_edge   = -420;\n            right_edge  =  300;\n            top_edge    =  300;\n            bottom_edge = -300;\n            x_step      =    7;\n            y_step      =   15;\n\n            max_iter    =  200;\n\n            y0 = top_edge;\n            while (y0 > bottom_edge) {\n                x0 = left_edge;\n                while (x0 < right_edge) {\n                    y = 0;\n                    x = 0;\n                    the_char = ' ';\n                    i = 0;\n                    while (i < max_iter) {\n                        x_x = (x * x) / 200;\n                        y_y = (y * y) / 200;\n                        if (x_x + y_y > 800 ) {\n                            the_char = '0' + i;\n                            if (i > 9) {\n                                the_char = '@';\n                            }\n                            i = max_iter;\n                        }\n                        y = x * y / 100 + y0;\n                        x = x_x - y_y + x0;\n                        i = i + 1;\n                    }\n                    putc(the_char);\n                    x0 = x0 + x_step;\n                }\n                putc('\\n');\n                y0 = y0 - y_step;\n            }\n        }\n    \"\"\",\n]\n\n\ndef main():\n    import sys\n    sys.setrecursionlimit(2000)\n\n    success, report = code.run_tests(tests)\n    assert success\n\n\nif __name__ == '__main__':\n    main()", "examples/cuneiform_python.py": "#\n# cuneiform_python.py\n#\n# Example showing how to create a custom Unicode set for parsing\n#\n# Copyright Paul McGuire, 2021\n#\nfrom typing import List, Tuple\nimport pyparsing as pp\n\n\nclass Cuneiform(pp.unicode_set):\n    \"\"\"Unicode set for Cuneiform Character Range\"\"\"\n\n    _ranges: List[Tuple[int, ...]] = [\n        (0x10380, 0x103d5),\n        (0x12000, 0x123FF),\n        (0x12400, 0x1247F),\n    ]\n\n\n# list out all valid identifier characters\n# print(Cuneiform.identchars)\n\n\n\"\"\"\nSimple Cuneiform Python language transformer\n\nDefine Cuneiform \"words\"\n    print: \ud808\udd11\ud808\ude7f\ud808\udd54\ud808\udeeb\n    hello: \ud808\udc04\ud808\udc96\ud808\uddb7\ud808\udc4e\n    world: \ud808\udf5f\ud808\udc4e\ud808\ude7f\ud808\uddb7\ud808\udc33\n    def: \ud808\udc74\ud808\ude2b\n\"\"\"\n\n# uncomment to show parse-time debugging\n# pp.enable_diag(pp.Diagnostics.enable_debug_on_named_expressions)\n\n# define a MINIMAL Python parser\nLPAR, RPAR, COLON, EQ = map(pp.Suppress, \"():=\")\ndef_ = pp.Keyword(\"\ud808\udc74\ud808\ude2b\", ident_chars=Cuneiform.identbodychars).set_name(\"def\")\nany_keyword = def_\nident = (~any_keyword) + pp.Word(\n    Cuneiform.identchars, Cuneiform.identbodychars, asKeyword=True\n)\nstr_expr = pp.infix_notation(\n    pp.QuotedString('\"') | pp.common.integer,\n    [\n        (\"*\", 2, pp.OpAssoc.LEFT),\n        (\"+\", 2, pp.OpAssoc.LEFT),\n    ],\n)\n\nrvalue = pp.Forward()\nfn_call = (ident + pp.Group(LPAR + pp.Optional(rvalue) + RPAR)).set_name(\"fn_call\")\n\nrvalue <<= fn_call | ident | str_expr | pp.common.number\nassignment_stmt = ident + EQ + rvalue\n\nstmt = pp.Group(fn_call | assignment_stmt).set_name(\"stmt\")\n\nfn_def = pp.Group(\n    def_ + ident + pp.Group(LPAR + pp.Optional(rvalue) + RPAR) + COLON\n).set_name(\"fn_def\")\nfn_body = pp.IndentedBlock(stmt).set_name(\"fn_body\")\nfn_expr = pp.Group(fn_def + pp.Group(fn_body))\n\nscript = fn_expr[...] + stmt[...]\n\n\n# parse some Python written in Cuneiform\ncuneiform_hello_world = r\"\"\"\n\ud808\udc74\ud808\ude2b \ud808\udc04\ud808\udc96\ud808\uddb7\ud808\udc4e():\n    \ud808\udc01 = \"\ud808\udc04\ud808\udc96\ud808\uddb7\ud808\udc4e, \ud808\udf5f\ud808\udc4e\ud808\ude7f\ud808\uddb7\ud808\udc33!\\n\" * 3\n    \ud808\udd11\ud808\ude7f\ud808\udd54\ud808\udeeb(\ud808\udc01)\n\n\ud808\udc04\ud808\udc96\ud808\uddb7\ud808\udc4e()\"\"\"\nscript.parseString(cuneiform_hello_world).pprint(width=40)\n\n\n# use transform_string to convert keywords and builtins to runnable Python\nnames_map = {\n    \"\ud808\udd11\ud808\ude7f\ud808\udd54\ud808\udeeb\": \"print\",\n}\nident.add_parse_action(lambda t: names_map.get(t[0], t[0]))\ndef_.add_parse_action(lambda: \"def\")\n\nprint(\"\\nconvert Cuneiform Python to executable Python\")\ntransformed = (\n    # always put ident last\n    (def_ | ident)\n    .ignore(pp.quoted_string)\n    .transform_string(cuneiform_hello_world)\n    .strip()\n)\nprint(\n    \"=================\\n\"\n    + cuneiform_hello_world.strip()\n    + \"\\n=================\\n\"\n    + transformed\n    + \"\\n=================\\n\"\n)\nprint(\"# run transformed Python\")\nexec(transformed)\n", "examples/dfmparse.py": "\"\"\"\nThis module can parse a Delphi Form (dfm) file.\n\nThe main is used in experimenting (to find which files fail\nto parse, and where), but isn't useful for anything else.\n\"\"\"\n__version__ = \"1.0\"\n__author__ = \"Daniel 'Dang' Griffith <pythondev - dang at lazytwinacres . net>\"\n\n\nfrom pyparsing import (\n    Literal,\n    CaselessLiteral,\n    Word,\n    delimitedList,\n    Optional,\n    Combine,\n    Group,\n    alphas,\n    nums,\n    alphanums,\n    Forward,\n    oneOf,\n    OneOrMore,\n    ZeroOrMore,\n    CharsNotIn,\n)\n\n\n# This converts DFM character constants into Python string (unicode) values.\ndef to_chr(x):\n    \"\"\"chr(x) if 0 < x < 128 ; unicode(x) if x > 127.\"\"\"\n    return 0 < x < 128 and chr(x) or eval(\"u'\\\\u%d'\" % x)\n\n\n#################\n# BEGIN GRAMMAR\n#################\n\nCOLON = Literal(\":\").suppress()\nCONCAT = Literal(\"+\").suppress()\nEQUALS = Literal(\"=\").suppress()\nLANGLE = Literal(\"<\").suppress()\nLBRACE = Literal(\"[\").suppress()\nLPAREN = Literal(\"(\").suppress()\nPERIOD = Literal(\".\").suppress()\nRANGLE = Literal(\">\").suppress()\nRBRACE = Literal(\"]\").suppress()\nRPAREN = Literal(\")\").suppress()\n\nCATEGORIES = CaselessLiteral(\"categories\").suppress()\nEND = CaselessLiteral(\"end\").suppress()\nFONT = CaselessLiteral(\"font\").suppress()\nHINT = CaselessLiteral(\"hint\").suppress()\nITEM = CaselessLiteral(\"item\").suppress()\nOBJECT = CaselessLiteral(\"object\").suppress()\n\nattribute_value_pair = Forward()  # this is recursed in item_list_entry\n\nsimple_identifier = Word(alphas, alphanums + \"_\")\nidentifier = Combine(simple_identifier + ZeroOrMore(Literal(\".\") + simple_identifier))\nobject_name = identifier\nobject_type = identifier\n\n# Integer and floating point values are converted to Python longs and floats, respectively.\nint_value = Combine(Optional(\"-\") + Word(nums)).setParseAction(\n    lambda s, l, t: [int(t[0])]\n)\nfloat_value = Combine(\n    Optional(\"-\") + Optional(Word(nums)) + \".\" + Word(nums)\n).setParseAction(lambda s, l, t: [float(t[0])])\nnumber_value = float_value | int_value\n\n# Base16 constants are left in string form, including the surrounding braces.\nbase16_value = Combine(\n    Literal(\"{\") + OneOrMore(Word(\"0123456789ABCDEFabcdef\")) + Literal(\"}\"),\n    adjacent=False,\n)\n\n# This is the first part of a hack to convert the various delphi partial sglQuotedStrings\n#     into a single sglQuotedString equivalent.  The gist of it is to combine\n#     all sglQuotedStrings (with their surrounding quotes removed (suppressed))\n#     with sequences of #xyz character constants, with \"strings\" concatenated\n#     with a '+' sign.\nunquoted_sglQuotedString = Combine(\n    Literal(\"'\").suppress() + ZeroOrMore(CharsNotIn(\"'\\n\\r\")) + Literal(\"'\").suppress()\n)\n\n# The parse action on this production converts repetitions of constants into a single string.\npound_char = Combine(\n    OneOrMore(\n        (Literal(\"#\").suppress() + Word(nums)).setParseAction(\n            lambda s, l, t: to_chr(int(t[0]))\n        )\n    )\n)\n\n# This is the second part of the hack.  It combines the various \"unquoted\"\n#     partial strings into a single one.  Then, the parse action puts\n#     a single matched pair of quotes around it.\ndelphi_string = Combine(\n    OneOrMore(CONCAT | pound_char | unquoted_sglQuotedString), adjacent=False\n).setParseAction(lambda s, l, t: f\"'{t[0]}'\")\n\nstring_value = delphi_string | base16_value\n\nlist_value = (\n    LBRACE\n    + Optional(Group(delimitedList(identifier | number_value | string_value)))\n    + RBRACE\n)\nparen_list_value = (\n    LPAREN + ZeroOrMore(identifier | number_value | string_value) + RPAREN\n)\n\nitem_list_entry = ITEM + ZeroOrMore(attribute_value_pair) + END\nitem_list = LANGLE + ZeroOrMore(item_list_entry) + RANGLE\n\ngeneric_value = identifier\nvalue = (\n    item_list\n    | number_value\n    | string_value\n    | list_value\n    | paren_list_value\n    | generic_value\n)\n\ncategory_attribute = CATEGORIES + PERIOD + oneOf(\"strings itemsvisibles visibles\", True)\nevent_attribute = oneOf(\n    \"onactivate onclosequery onclose oncreate ondeactivate onhide onshow\", True\n)\nfont_attribute = FONT + PERIOD + oneOf(\"charset color height name style\", True)\nhint_attribute = HINT\nlayout_attribute = oneOf(\"left top width height\", True)\ngeneric_attribute = identifier\nattribute = (\n    category_attribute\n    | event_attribute\n    | font_attribute\n    | hint_attribute\n    | layout_attribute\n    | generic_attribute\n)\n\ncategory_attribute_value_pair = category_attribute + EQUALS + paren_list_value\nevent_attribute_value_pair = event_attribute + EQUALS + value\nfont_attribute_value_pair = font_attribute + EQUALS + value\nhint_attribute_value_pair = hint_attribute + EQUALS + value\nlayout_attribute_value_pair = layout_attribute + EQUALS + value\ngeneric_attribute_value_pair = attribute + EQUALS + value\nattribute_value_pair << Group(\n    category_attribute_value_pair\n    | event_attribute_value_pair\n    | font_attribute_value_pair\n    | hint_attribute_value_pair\n    | layout_attribute_value_pair\n    | generic_attribute_value_pair\n)\n\nobject_declaration = Group(OBJECT + object_name + COLON + object_type)\nobject_attributes = Group(ZeroOrMore(attribute_value_pair))\n\nnested_object = Forward()\nobject_definition = (\n    object_declaration + object_attributes + ZeroOrMore(nested_object) + END\n)\nnested_object << Group(object_definition)\n\n#################\n# END GRAMMAR\n#################\n\n\ndef printer(s, loc, tok):\n    print(tok, end=\" \")\n    return tok\n\n\ndef get_filename_list(tf):\n    import sys, glob\n\n    if tf == None:\n        if len(sys.argv) > 1:\n            tf = sys.argv[1:]\n        else:\n            tf = glob.glob(\"*.dfm\")\n    elif type(tf) == str:\n        tf = [tf]\n    testfiles = []\n    for arg in tf:\n        testfiles.extend(glob.glob(arg))\n    return testfiles\n\n\ndef main(testfiles=None, action=printer):\n    \"\"\"testfiles can be None, in which case the command line arguments are used as filenames.\n    testfiles can be a string, in which case that file is parsed.\n    testfiles can be a list.\n    In all cases, the filenames will be globbed.\n    If more than one file is parsed successfully, a dictionary of ParseResults is returned.\n    Otherwise, a simple ParseResults is returned.\n    \"\"\"\n    testfiles = get_filename_list(testfiles)\n    print(testfiles)\n\n    if action:\n        for i in (simple_identifier, value, item_list):\n            i.setParseAction(action)\n\n    success = 0\n    failures = []\n\n    retval = {}\n    for f in testfiles:\n        try:\n            retval[f] = object_definition.parseFile(f)\n            success += 1\n        except Exception:\n            failures.append(f)\n\n    nl = \"\\n\"\n    if failures:\n        print(f\"{nl}failed while processing {', '.join(failures)}\")\n    print(f\"{nl}succeeded on {success} of {len(testfiles)} files\")\n\n    if len(retval) == 1 and len(testfiles) == 1:\n        # if only one file is parsed, return the parseResults directly\n        return retval[list(retval.keys())[0]]\n\n    # else, return a dictionary of parseResults\n    return retval\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/lua_parser.py": "#\n# lua_parser.py\n#\n# A simple parser for the Lua language.\n#\n# Copyright 2020, Paul McGuire\n#\n\n\"\"\"\nfrom https://www.lua.org/manual/5.1/manual.html#8\n\n    chunk ::= {stat [';']} [laststat [';']]\n\n    block ::= chunk\n\n    stat ::=  varlist '=' explist |\n         functioncall |\n         do block end |\n         while exp do block end |\n         repeat block until exp |\n         if exp then block {elseif exp then block} [else block] end |\n         for Name '=' exp ',' exp [',' exp] do block end |\n         for namelist in explist do block end |\n         function funcname funcbody |\n         local function Name funcbody |\n         local namelist ['=' explist]\n\n    laststat ::= return [explist] | break\n\n    funcname ::= Name {'.' Name} [':' Name]\n\n    varlist ::= var {',' var}\n\n    var ::=  Name | prefixexp '[' exp ']' | prefixexp '.' Name\n\n    namelist ::= Name {',' Name}\n\n    explist ::= {exp ','} exp\n\n    exp ::=  nil | false | true | Number | String | '...' | function |\n         prefixexp | tableconstructor | exp binop exp | unop exp\n\n    prefixexp ::= var | functioncall | '(' exp ')'\n\n    functioncall ::=  prefixexp args | prefixexp ':' Name args\n\n    args ::=  '(' [explist] ')' | tableconstructor | String\n\n    function ::= function funcbody\n\n    funcbody ::= '(' [parlist] ')' block end\n\n    parlist ::= namelist [',' '...'] | '...'\n\n    tableconstructor ::= '{' [fieldlist] '}'\n\n    fieldlist ::= field {fieldsep field} [fieldsep]\n\n    field ::= '[' exp ']' '=' exp | Name '=' exp | exp\n\n    fieldsep ::= ',' | ';'\n\n    binop ::= '+' | '-' | '*' | '/' | '^' | '%' | '..' |\n         '<' | '<=' | '>' | '>=' | '==' | '~=' |\n         and | or\n\n    unop ::= '-' | not | '#'\n\noperator precedence:\n\n     or\n     and\n     <     >     <=    >=    ~=    ==\n     |\n     ~\n     &\n     <<    >>\n     ..\n     +     -\n     *     /     //    %\n     unary operators (not   #     -     ~)\n     ^\n\n\"\"\"\nimport pyparsing as pp\n\nppc = pp.pyparsing_common\npp.ParserElement.enable_packrat()\n\nLBRACK, RBRACK, LBRACE, RBRACE, LPAR, RPAR = pp.Suppress.using_each(\"[]{}()\")\nCOMMA, SEMI, COLON = pp.Suppress.using_each(\",;:\")\nOPT_SEMI = pp.Optional(SEMI).suppress()\nELLIPSIS = pp.Literal(\"...\")\nEQ = pp.Literal(\"=\")\n\nkeywords = {\n    k.upper(): pp.Keyword(k)\n    for k in \"\"\"\\\n    return break do end while if then elseif else for in function\n    local repeat until nil false true and or not\n    \"\"\".split()\n}\nvars().update(keywords)\nany_keyword = pp.MatchFirst(keywords.values()).set_name(\"keyword\")\n\ncomment_intro = pp.Literal(\"--\")\nshort_comment = comment_intro + pp.rest_of_line\nlong_comment = comment_intro + LBRACK + ... + RBRACK\nlua_comment = long_comment | short_comment\n\n# must use negative lookahead to ensure we don't parse a keyword as an identifier\nident = ~any_keyword + ppc.identifier\n\nname = pp.DelimitedList(ident, delim=\".\", combine=True)\n\nnamelist = pp.DelimitedList(name)\nnumber = ppc.number\n\n# does not parse levels\nmultiline_string = pp.QuotedString(\"[[\", endQuoteChar=\"]]\", multiline=True)\nstring = pp.QuotedString(\"'\") | pp.QuotedString('\"') | multiline_string\n\nexp = pp.Forward()\n\n#     explist1 ::= {exp ','} exp\nexplist1 = pp.DelimitedList(exp)\n\n# set up for recursive definition of 'stmt' (since some statements are\n# composed of nested statements)\nstat = pp.Forward().set_name(\"stat\")\n\n#    laststat ::= return [explist1]  |  break\nlaststat = pp.Group(RETURN + explist1) | BREAK\n\n#    block ::= {stat [';']} [laststat[';']]\nblock = pp.Group((stat + OPT_SEMI)[1, ...] + pp.Optional(laststat + OPT_SEMI))\n\n#    field ::= '[' exp ']' '=' exp  |  Name '=' exp  |  exp\nfield = pp.Group(\n    LBRACK + exp + RBRACK + EQ + pp.Group(exp) | name + EQ + pp.Group(exp) | exp\n)\n\n#    fieldsep ::= ','  |  ';'\nfieldsep = COMMA | SEMI\n\n#    fieldlist ::= field {fieldsep field} [fieldsep]\nfield_list = pp.DelimitedList(field, delim=fieldsep, allow_trailing_delim=True)\n\n#    tableconstructor ::= '{' [fieldlist] '}'\ntableconstructor = pp.Group(LBRACE + pp.Optional(field_list) + RBRACE)\n\n#    parlist1 ::= namelist [',' '...']  |  '...'\nparlist = namelist + pp.Optional(COMMA + ELLIPSIS) | ELLIPSIS\n\n#    funcname ::= Name {'.' Name} [':' Name]\nfuncname = pp.Group(name + COLON + name) | name\n\n#    function ::= function funcbody\n#    funcbody ::= '(' [parlist1] ')' block end\nfuncbody = pp.Group(LPAR + parlist + RPAR) + block + END\nfunction = FUNCTION + funcbody\n\n#    args ::=  '(' [explist1] ')'  |  tableconstructor  |  String\nargs = LPAR + pp.Optional(explist1) + RPAR | tableconstructor | string\n\n# this portion of the spec is left-recursive, must break LR loop\n#    varlist1 ::= var {',' var}\n#    var ::=  Name  |  prefixexp '[' exp ']'  |  prefixexp '.' Name\n#    prefixexp ::= var  |  functioncall  |  '(' exp ')'\n#    functioncall ::=  prefixexp args  |  prefixexp ':' Name args\n\nexp_group = pp.Group(LPAR + exp + RPAR)\nprefixexp = name | exp_group\nfunctioncall = pp.Group(prefixexp + pp.Optional(COLON + name) + pp.Group(args))\nvar = pp.Forward()\nvar_atom = functioncall | name | exp_group\nindex_ref = pp.Group(LBRACK + exp + RBRACK)\nvar_part = pp.Group(var_atom + index_ref) | var_atom\nvar <<= pp.DelimitedList(var_part, delim=\".\")\n\nvarlist1 = pp.DelimitedList(var)\n\n# exp ::=  nil  |  false  |  true  |  Number  |  String  |  '...'  |\n#              function  |  prefixexp  |  tableconstructor\nexp_atom = (\n    NIL\n    | FALSE\n    | TRUE\n    | number\n    | string\n    | ELLIPSIS\n    | functioncall\n    | var  # prefixexp\n    | tableconstructor\n).set_name(\"exp_atom\")\n\n# precedence of operations from https://www.lua.org/manual/5.3/manual.html#3.4.8\nexp <<= pp.infix_notation(\n    exp_atom,\n    [\n        (\"^\", 2, pp.opAssoc.LEFT),\n        ((NOT | pp.oneOf(\"# - ~\")).set_name(\"not op\"), 1, pp.opAssoc.RIGHT),\n        (pp.oneOf(\"* / // %\"), 2, pp.opAssoc.LEFT),\n        (pp.oneOf(\"+ -\"), 2, pp.opAssoc.LEFT),\n        (\"..\", 2, pp.opAssoc.LEFT),\n        (pp.oneOf(\"<< >>\"), 2, pp.opAssoc.LEFT),\n        (\"&\", 2, pp.opAssoc.LEFT),\n        (\"~\", 2, pp.opAssoc.LEFT),\n        (\"|\", 2, pp.opAssoc.LEFT),\n        (pp.oneOf(\"< > <= >= ~= ==\"), 2, pp.opAssoc.LEFT),\n        (AND, 2, pp.opAssoc.LEFT),\n        (OR, 2, pp.opAssoc.LEFT),\n    ],\n).set_name(\"exp\")\n\nassignment_stat = pp.Optional(LOCAL) + varlist1 + EQ + explist1\nfunc_call_stat = pp.Optional(LOCAL) + functioncall\ndo_stat = DO + block + END\nwhile_stat = WHILE + exp + block + END\nrepeat_stat = REPEAT + block + UNTIL + exp\nfor_loop_stat = (\n    FOR + name + EQ + exp + COMMA + exp + pp.Optional(COMMA + exp) + DO + block + END\n)\nfor_seq_stat = FOR + namelist + IN + explist1 + DO + block + END\nif_stat = (\n    IF\n    + exp\n    + THEN\n    + block\n    + pp.Group(ELSEIF + exp + THEN + block)[...]\n    + pp.Optional(pp.Group(ELSE + block))\n    + END\n)\nfunction_def = pp.Optional(LOCAL) + FUNCTION + funcname + funcbody\n\npp.autoname_elements()\n\n#    stat ::=  varlist1 '=' explist1  |\n#              functioncall  |\n#              do block end  |\n#              while exp do block end  |\n#              repeat block until exp  |\n#              if exp then block {elseif exp then block} [else block] end  |\n#              for Name '=' exp ',' exp [',' exp] do block end  |\n#              for namelist in explist1 do block end  |\n#              function funcname funcbody  |\n#              local function Name funcbody  |\n#              local namelist ['=' explist1]\nstat <<= pp.Group(\n    assignment_stat\n    | do_stat\n    | while_stat\n    | repeat_stat\n    | for_loop_stat\n    | for_seq_stat\n    | func_call_stat\n    | if_stat\n    | function_def\n)\n\nlua_script = stat[...].set_name(\"script\")\n\n# ignore comments\nlua_script.ignore(lua_comment)\n\nif __name__ == \"__main__\":\n    sample = r\"\"\"\n    function test(x)\n        local t = {foo=1, bar=2, arg=x}\n        n = 0\n        if t['foo'] then\n            n = n + 1\n        end\n        if 10 > 8 then\n            n = n + 2\n        end\n        if (10 > 8) then\n            n = n + 2\n        end\n        for var in vars do\n            print(var, '=', var)\n        end\n    end\n    \"\"\"\n\n    try:\n        result = lua_script.parseString(sample)\n        result.pprint()\n    except pp.ParseException as pe:\n        print(pe.explain())\n        raise\n", "examples/LAparser.py": "\"\"\"\nPurpose:   Linear Algebra Parser\nBased on:  SimpleCalc.py example (author Paul McGuire) in pyparsing-1.3.3\nAuthor:    Mike Ellis\nCopyright: Ellis & Grant, Inc. 2005\nLicense:   You may freely use, modify, and distribute this software.\nWarranty:  THIS SOFTWARE HAS NO WARRANTY WHATSOEVER. USE AT YOUR OWN RISK.\nNotes: Parses infix linear algebra (LA) notation for vectors, matrices, and scalars.\n       Output is C code function calls.  The parser can be run as an interactive\n       interpreter or included as module to use for in-place substitution into C files\n       containing LA equations.\n\n       Supported operations are:\n       OPERATION:              INPUT                    OUTPUT\n       Scalar addition:        \"a = b+c\"                \"a=(b+c)\"\n       Scalar subtraction:     \"a = b-c\"                \"a=(b-c)\"\n       Scalar multiplication:  \"a = b*c\"                \"a=b*c\"\n       Scalar division:        \"a = b/c\"                \"a=b/c\"\n       Scalar exponentiation:  \"a = b^c\"                \"a=pow(b,c)\"\n       Vector scaling:         \"V3_a = V3_b * c\"        \"vCopy(a,vScale(b,c))\"\n       Vector addition:        \"V3_a = V3_b + V3_c\"     \"vCopy(a,vAdd(b,c))\"\n       Vector subtraction:     \"V3_a = V3_b - V3_c\"     \"vCopy(a,vSubtract(b,c))\"\n       Vector dot product:     \"a = V3_b * V3_c\"        \"a=vDot(b,c)\"\n       Vector outer product:   \"M3_a = V3_b @ V3_c\"     \"a=vOuterProduct(b,c)\"\n       Vector magn. squared:   \"a = V3_b^Mag2\"          \"a=vMagnitude2(b)\"\n       Vector magnitude:       \"a = V3_b^Mag\"           \"a=sqrt(vMagnitude2(b))\"\n       Matrix scaling:         \"M3_a = M3_b * c\"        \"mCopy(a,mScale(b,c))\"\n       Matrix addition:        \"M3_a = M3_b + M3_c\"     \"mCopy(a,mAdd(b,c))\"\n       Matrix subtraction:     \"M3_a = M3_b - M3_c\"     \"mCopy(a,mSubtract(b,c))\"\n       Matrix multiplication:  \"M3_a = M3_b * M3_c\"     \"mCopy(a,mMultiply(b,c))\"\n       Matrix by vector mult.: \"V3_a = M3_b * V3_c\"     \"vCopy(a,mvMultiply(b,c))\"\n       Matrix inversion:       \"M3_a = M3_b^-1\"         \"mCopy(a,mInverse(b))\"\n       Matrix transpose:       \"M3_a = M3_b^T\"          \"mCopy(a,mTranspose(b))\"\n       Matrix determinant:     \"a = M3_b^Det\"           \"a=mDeterminant(b)\"\n\n       The parser requires the expression to be an equation.  Each non-scalar variable\n       must be prefixed with a type tag, 'M3_' for 3x3 matrices and 'V3_' for 3-vectors.\n       For proper compilation of the C code, the variables need to be declared without\n       the prefix as float[3] for vectors and float[3][3] for matrices. The operations do\n       not modify any variables on the right-hand side of the equation.\n\n       Equations may include nested expressions within parentheses. The allowed binary\n       operators are '+-*/^' for scalars, and '+-*^@' for vectors and matrices with the\n       meanings defined in the table above.\n\n       Specifying an improper combination of operands, e.g. adding a vector to a matrix,\n       is detected by the parser and results in a Python TypeError Exception. The usual cause\n       of this is omitting one or more tag prefixes. The parser knows nothing about a\n       a variable's C declaration and relies entirely on the type tags. Errors in C\n       declarations are not caught until compile time.\n\nUsage: To process LA equations embedded in source files, import this module and\n       pass input and output file objects to the fprocess() function.  You can\n       can also invoke the parser from the command line, e.g. 'python LAparser.py',\n       to run a small test suite and enter an interactive loop where you can enter\n       LA equations and see the resulting C code.\n\n\"\"\"\n\nimport re, sys\nfrom pyparsing import (\n    Word,\n    alphas,\n    ParseException,\n    Literal,\n    CaselessLiteral,\n    Combine,\n    Optional,\n    nums,\n    Forward,\n    ZeroOrMore,\n    StringEnd,\n    alphanums,\n)\n\n# Debugging flag can be set to either \"debug_flag=True\" or \"debug_flag=False\"\ndebug_flag = False\n\n# ----------------------------------------------------------------------------\n# Variables that hold intermediate parsing results and a couple of\n# helper functions.\nexprStack = []  # Holds operators and operands parsed from input.\ntargetvar = None  # Holds variable name to left of '=' sign in LA equation.\n\n\ndef _pushFirst(str, loc, toks):\n    if debug_flag:\n        print(\"pushing \", toks[0], \"str is \", str)\n    exprStack.append(toks[0])\n\n\ndef _assignVar(str, loc, toks):\n    global targetvar\n    targetvar = toks[0]\n\n\n# -----------------------------------------------------------------------------\n# The following statements define the grammar for the parser.\n\npoint = Literal(\".\")\ne = CaselessLiteral(\"E\")\nplusorminus = Literal(\"+\") | Literal(\"-\")\nnumber = Word(nums)\ninteger = Combine(Optional(plusorminus) + number)\nfloatnumber = Combine(\n    integer + Optional(point + Optional(number)) + Optional(e + integer)\n)\n\nlbracket = Literal(\"[\")\nrbracket = Literal(\"]\")\nident = Forward()\n## The definition below treats array accesses as identifiers. This means your expressions\n## can include references to array elements, rows and columns, e.g., a = b[i] + 5.\n## Expressions within []'s are not presently supported, so a = b[i+1] will raise\n## a ParseException.\nident = Combine(\n    Word(alphas + \"-\", alphanums + \"_\")\n    + ZeroOrMore(lbracket + (Word(alphas + \"-\", alphanums + \"_\") | integer) + rbracket)\n)\n\nplus = Literal(\"+\")\nminus = Literal(\"-\")\nmult = Literal(\"*\")\ndiv = Literal(\"/\")\nouter = Literal(\"@\")\nlpar = Literal(\"(\").suppress()\nrpar = Literal(\")\").suppress()\naddop = plus | minus\nmultop = mult | div | outer\nexpop = Literal(\"^\")\nassignop = Literal(\"=\")\n\nexpr = Forward()\natom = (e | floatnumber | integer | ident).setParseAction(_pushFirst) | (\n    lpar + expr.suppress() + rpar\n)\nfactor = Forward()\nfactor << atom + ZeroOrMore((expop + factor).setParseAction(_pushFirst))\n\nterm = factor + ZeroOrMore((multop + factor).setParseAction(_pushFirst))\nexpr << term + ZeroOrMore((addop + term).setParseAction(_pushFirst))\nequation = (ident + assignop).setParseAction(_assignVar) + expr + StringEnd()\n\n# End of grammar definition\n# -----------------------------------------------------------------------------\n## The following are helper variables and functions used by the Binary Infix Operator\n## Functions described below.\n\nvprefix = \"V3_\"\nvplen = len(vprefix)\nmprefix = \"M3_\"\nmplen = len(mprefix)\n\n## We don't support unary negation for vectors and matrices\nclass UnaryUnsupportedError(Exception):\n    pass\n\n\ndef _isvec(ident):\n    if ident[0] == \"-\" and ident[1 : vplen + 1] == vprefix:\n        raise UnaryUnsupportedError\n    else:\n        return ident[0:vplen] == vprefix\n\n\ndef _ismat(ident):\n    if ident[0] == \"-\" and ident[1 : mplen + 1] == mprefix:\n        raise UnaryUnsupportedError\n    else:\n        return ident[0:mplen] == mprefix\n\n\ndef _isscalar(ident):\n    return not (_isvec(ident) or _ismat(ident))\n\n\n## Binary infix operator (BIO) functions.  These are called when the stack evaluator\n## pops a binary operator like '+' or '*\".  The stack evaluator pops the two operand, a and b,\n## and calls the function that is mapped to the operator with a and b as arguments.  Thus,\n## 'x + y' yields a call to addfunc(x,y). Each of the BIO functions checks the prefixes of its\n## arguments to determine whether the operand is scalar, vector, or matrix.  This information\n## is used to generate appropriate C code.  For scalars, this is essentially the input string, e.g.\n## 'a + b*5' as input yields 'a + b*5' as output.  For vectors and matrices, the input is translated to\n## nested function calls, e.g. \"V3_a + V3_b*5\"  yields \"V3_vAdd(a,vScale(b,5)\".  Note that prefixes are\n## stripped from operands and function names within the argument list to the outer function and\n## the appropriate prefix is placed on the outer function for removal later as the stack evaluation\n## recurses toward the final assignment statement.\n\n\ndef _addfunc(a, b):\n    if _isscalar(a) and _isscalar(b):\n        return \"(%s+%s)\" % (a, b)\n    if _isvec(a) and _isvec(b):\n        return \"%svAdd(%s,%s)\" % (vprefix, a[vplen:], b[vplen:])\n    if _ismat(a) and _ismat(b):\n        return \"%smAdd(%s,%s)\" % (mprefix, a[mplen:], b[mplen:])\n    else:\n        raise TypeError\n\n\ndef _subfunc(a, b):\n    if _isscalar(a) and _isscalar(b):\n        return \"(%s-%s)\" % (a, b)\n    if _isvec(a) and _isvec(b):\n        return \"%svSubtract(%s,%s)\" % (vprefix, a[vplen:], b[vplen:])\n    if _ismat(a) and _ismat(b):\n        return \"%smSubtract(%s,%s)\" % (mprefix, a[mplen:], b[mplen:])\n    else:\n        raise TypeError\n\n\ndef _mulfunc(a, b):\n    if _isscalar(a) and _isscalar(b):\n        return \"%s*%s\" % (a, b)\n    if _isvec(a) and _isvec(b):\n        return \"vDot(%s,%s)\" % (a[vplen:], b[vplen:])\n    if _ismat(a) and _ismat(b):\n        return \"%smMultiply(%s,%s)\" % (mprefix, a[mplen:], b[mplen:])\n    if _ismat(a) and _isvec(b):\n        return \"%smvMultiply(%s,%s)\" % (vprefix, a[mplen:], b[vplen:])\n    if _ismat(a) and _isscalar(b):\n        return \"%smScale(%s,%s)\" % (mprefix, a[mplen:], b)\n    if _isvec(a) and _isscalar(b):\n        return \"%svScale(%s,%s)\" % (vprefix, a[mplen:], b)\n    else:\n        raise TypeError\n\n\ndef _outermulfunc(a, b):\n    ## The '@' operator is used for the vector outer product.\n    if _isvec(a) and _isvec(b):\n        return \"%svOuterProduct(%s,%s)\" % (mprefix, a[vplen:], b[vplen:])\n    else:\n        raise TypeError\n\n\ndef _divfunc(a, b):\n    ## The '/' operator is used only for scalar division\n    if _isscalar(a) and _isscalar(b):\n        return \"%s/%s\" % (a, b)\n    else:\n        raise TypeError\n\n\ndef _expfunc(a, b):\n    ## The '^' operator is used for exponentiation on scalars and\n    ## as a marker for unary operations on vectors and matrices.\n    if _isscalar(a) and _isscalar(b):\n        return \"pow(%s,%s)\" % (str(a), str(b))\n    if _ismat(a) and b == \"-1\":\n        return \"%smInverse(%s)\" % (mprefix, a[mplen:])\n    if _ismat(a) and b == \"T\":\n        return \"%smTranspose(%s)\" % (mprefix, a[mplen:])\n    if _ismat(a) and b == \"Det\":\n        return \"mDeterminant(%s)\" % (a[mplen:])\n    if _isvec(a) and b == \"Mag\":\n        return \"sqrt(vMagnitude2(%s))\" % (a[vplen:])\n    if _isvec(a) and b == \"Mag2\":\n        return \"vMagnitude2(%s)\" % (a[vplen:])\n    else:\n        raise TypeError\n\n\ndef _assignfunc(a, b):\n    ## The '=' operator is used for assignment\n    if _isscalar(a) and _isscalar(b):\n        return \"%s=%s\" % (a, b)\n    if _isvec(a) and _isvec(b):\n        return \"vCopy(%s,%s)\" % (a[vplen:], b[vplen:])\n    if _ismat(a) and _ismat(b):\n        return \"mCopy(%s,%s)\" % (a[mplen:], b[mplen:])\n    else:\n        raise TypeError\n\n\n## End of BIO func definitions\n##----------------------------------------------------------------------------\n\n# Map  operator symbols to corresponding BIO funcs\nopn = {\n    \"+\": (_addfunc),\n    \"-\": (_subfunc),\n    \"*\": (_mulfunc),\n    \"@\": (_outermulfunc),\n    \"/\": (_divfunc),\n    \"^\": (_expfunc),\n}\n\n\n##----------------------------------------------------------------------------\n# Recursive function that evaluates the expression stack\ndef _evaluateStack(s):\n    op = s.pop()\n    if op in \"+-*/@^\":\n        op2 = _evaluateStack(s)\n        op1 = _evaluateStack(s)\n        result = opn[op](op1, op2)\n        if debug_flag:\n            print(result)\n        return result\n    else:\n        return op\n\n\n##----------------------------------------------------------------------------\n# The parse function that invokes all of the above.\ndef parse(input_string):\n    \"\"\"\n    Accepts an input string containing an LA equation, e.g.,\n    \"M3_mymatrix = M3_anothermatrix^-1\" returns C code function\n    calls that implement the expression.\n    \"\"\"\n\n    global exprStack\n    global targetvar\n\n    # Start with a blank exprStack and a blank targetvar\n    exprStack = []\n    targetvar = None\n\n    if input_string != \"\":\n        # try parsing the input string\n        try:\n            L = equation.parseString(input_string)\n        except ParseException as err:\n            print(\"Parse Failure\", file=sys.stderr)\n            print(err.line, file=sys.stderr)\n            print(\" \" * (err.column - 1) + \"^\", file=sys.stderr)\n            print(err, file=sys.stderr)\n            raise\n\n        # show result of parsing the input string\n        if debug_flag:\n            print(input_string, \"->\", L)\n            print(\"exprStack=\", exprStack)\n\n        # Evaluate the stack of parsed operands, emitting C code.\n        try:\n            result = _evaluateStack(exprStack)\n        except TypeError:\n            print(\n                \"Unsupported operation on right side of '%s'.\\nCheck for missing or incorrect tags on non-scalar operands.\"\n                % input_string,\n                file=sys.stderr,\n            )\n            raise\n        except UnaryUnsupportedError:\n            print(\n                \"Unary negation is not supported for vectors and matrices: '%s'\"\n                % input_string,\n                file=sys.stderr,\n            )\n            raise\n\n        # Create final assignment and print it.\n        if debug_flag:\n            print(\"var=\", targetvar)\n        if targetvar != None:\n            try:\n                result = _assignfunc(targetvar, result)\n            except TypeError:\n                print(\n                    \"Left side tag does not match right side of '%s'\" % input_string,\n                    file=sys.stderr,\n                )\n                raise\n            except UnaryUnsupportedError:\n                print(\n                    \"Unary negation is not supported for vectors and matrices: '%s'\"\n                    % input_string,\n                    file=sys.stderr,\n                )\n                raise\n\n            return result\n        else:\n            print(\"Empty left side in '%s'\" % input_string, file=sys.stderr)\n            raise TypeError\n\n\n##-----------------------------------------------------------------------------------\ndef fprocess(infilep, outfilep):\n    \"\"\"\n    Scans an input file for LA equations between double square brackets,\n    e.g. [[ M3_mymatrix = M3_anothermatrix^-1 ]], and replaces the expression\n    with a comment containing the equation followed by nested function calls\n    that implement the equation as C code. A trailing semi-colon is appended.\n    The equation within [[ ]] should NOT end with a semicolon as that will raise\n    a ParseException. However, it is ok to have a semicolon after the right brackets.\n\n    Other text in the file is unaltered.\n\n    The arguments are file objects (NOT file names) opened for reading and\n    writing, respectively.\n    \"\"\"\n    pattern = r\"\\[\\[\\s*(.*?)\\s*\\]\\]\"\n    eqn = re.compile(pattern, re.DOTALL)\n    s = infilep.read()\n\n    def parser(mo):\n        ccode = parse(mo.group(1))\n        return \"/* %s */\\n%s;\\nLAParserBufferReset();\\n\" % (mo.group(1), ccode)\n\n    content = eqn.sub(parser, s)\n    outfilep.write(content)\n\n\n##-----------------------------------------------------------------------------------\ndef test():\n    \"\"\"\n    Tests the parsing of various supported expressions. Raises\n    an AssertError if the output is not what is expected. Prints the\n    input, expected output, and actual output for all tests.\n    \"\"\"\n    print(\"Testing LAParser\")\n    testcases = [\n        (\"Scalar addition\", \"a = b+c\", \"a=(b+c)\"),\n        (\"Vector addition\", \"V3_a = V3_b + V3_c\", \"vCopy(a,vAdd(b,c))\"),\n        (\"Vector addition\", \"V3_a=V3_b+V3_c\", \"vCopy(a,vAdd(b,c))\"),\n        (\"Matrix addition\", \"M3_a = M3_b + M3_c\", \"mCopy(a,mAdd(b,c))\"),\n        (\"Matrix addition\", \"M3_a=M3_b+M3_c\", \"mCopy(a,mAdd(b,c))\"),\n        (\"Scalar subtraction\", \"a = b-c\", \"a=(b-c)\"),\n        (\"Vector subtraction\", \"V3_a = V3_b - V3_c\", \"vCopy(a,vSubtract(b,c))\"),\n        (\"Matrix subtraction\", \"M3_a = M3_b - M3_c\", \"mCopy(a,mSubtract(b,c))\"),\n        (\"Scalar multiplication\", \"a = b*c\", \"a=b*c\"),\n        (\"Scalar division\", \"a = b/c\", \"a=b/c\"),\n        (\"Vector multiplication (dot product)\", \"a = V3_b * V3_c\", \"a=vDot(b,c)\"),\n        (\n            \"Vector multiplication (outer product)\",\n            \"M3_a = V3_b @ V3_c\",\n            \"mCopy(a,vOuterProduct(b,c))\",\n        ),\n        (\"Matrix multiplication\", \"M3_a = M3_b * M3_c\", \"mCopy(a,mMultiply(b,c))\"),\n        (\"Vector scaling\", \"V3_a = V3_b * c\", \"vCopy(a,vScale(b,c))\"),\n        (\"Matrix scaling\", \"M3_a = M3_b * c\", \"mCopy(a,mScale(b,c))\"),\n        (\n            \"Matrix by vector multiplication\",\n            \"V3_a = M3_b * V3_c\",\n            \"vCopy(a,mvMultiply(b,c))\",\n        ),\n        (\"Scalar exponentiation\", \"a = b^c\", \"a=pow(b,c)\"),\n        (\"Matrix inversion\", \"M3_a = M3_b^-1\", \"mCopy(a,mInverse(b))\"),\n        (\"Matrix transpose\", \"M3_a = M3_b^T\", \"mCopy(a,mTranspose(b))\"),\n        (\"Matrix determinant\", \"a = M3_b^Det\", \"a=mDeterminant(b)\"),\n        (\"Vector magnitude squared\", \"a = V3_b^Mag2\", \"a=vMagnitude2(b)\"),\n        (\"Vector magnitude\", \"a = V3_b^Mag\", \"a=sqrt(vMagnitude2(b))\"),\n        (\n            \"Complicated expression\",\n            \"myscalar = (M3_amatrix * V3_bvector)^Mag + 5*(-xyz[i] + 2.03^2)\",\n            \"myscalar=(sqrt(vMagnitude2(mvMultiply(amatrix,bvector)))+5*(-xyz[i]+pow(2.03,2)))\",\n        ),\n        (\n            \"Complicated Multiline\",\n            \"myscalar = \\n(M3_amatrix * V3_bvector)^Mag +\\n 5*(xyz + 2.03^2)\",\n            \"myscalar=(sqrt(vMagnitude2(mvMultiply(amatrix,bvector)))+5*(xyz+pow(2.03,2)))\",\n        ),\n    ]\n\n    all_passed = [True]\n\n    def post_test(test, parsed):\n\n        # copy exprStack to evaluate and clear before running next test\n        parsed_stack = exprStack[:]\n        exprStack.clear()\n\n        name, testcase, expected = next(tc for tc in testcases if tc[1] == test)\n\n        this_test_passed = False\n        try:\n            try:\n                result = _evaluateStack(parsed_stack)\n            except TypeError:\n                print(\n                    \"Unsupported operation on right side of '%s'.\\nCheck for missing or incorrect tags on non-scalar operands.\"\n                    % input_string,\n                    file=sys.stderr,\n                )\n                raise\n            except UnaryUnsupportedError:\n                print(\n                    \"Unary negation is not supported for vectors and matrices: '%s'\"\n                    % input_string,\n                    file=sys.stderr,\n                )\n                raise\n\n            # Create final assignment and print it.\n            if debug_flag:\n                print(\"var=\", targetvar)\n            if targetvar != None:\n                try:\n                    result = _assignfunc(targetvar, result)\n                except TypeError:\n                    print(\n                        \"Left side tag does not match right side of '%s'\"\n                        % input_string,\n                        file=sys.stderr,\n                    )\n                    raise\n                except UnaryUnsupportedError:\n                    print(\n                        \"Unary negation is not supported for vectors and matrices: '%s'\"\n                        % input_string,\n                        file=sys.stderr,\n                    )\n                    raise\n\n            else:\n                print(\"Empty left side in '%s'\" % input_string, file=sys.stderr)\n                raise TypeError\n\n            parsed[\"result\"] = result\n            parsed[\"passed\"] = this_test_passed = result == expected\n\n        finally:\n            all_passed[0] = all_passed[0] and this_test_passed\n            print(\"\\n\" + name)\n\n    equation.runTests((t[1] for t in testcases), postParse=post_test)\n\n    ##TODO: Write testcases with invalid expressions and test that the expected\n    ## exceptions are raised.\n\n    print(\"Tests completed!\")\n    print(\"PASSED\" if all_passed[0] else \"FAILED\")\n    assert all_passed[0]\n\n\n##----------------------------------------------------------------------------\n## The following is executed only when this module is executed as\n## command line script.  It runs a small test suite (see above)\n## and then enters an interactive loop where you\n## can enter expressions and see the resulting C code as output.\n\nif __name__ == \"__main__\":\n\n    import sys\n\n    if not sys.flags.interactive:\n        # run testcases\n        test()\n        sys.exit(0)\n\n    # input_string\n    input_string = \"\"\n\n    # Display instructions on how to use the program interactively\n    interactiveusage = \"\"\"\n  Entering interactive mode:\n  Type in an equation to be parsed or 'quit' to exit the program.\n  Type 'debug on' to print parsing details as each string is processed.\n  Type 'debug off' to stop printing parsing details\n  \"\"\"\n    print(interactiveusage)\n    input_string = input(\"> \")\n\n    while input_string != \"quit\":\n        if input_string == \"debug on\":\n            debug_flag = True\n        elif input_string == \"debug off\":\n            debug_flag = False\n        else:\n            try:\n                print(parse(input_string))\n            except Exception:\n                pass\n\n        # obtain new input string\n        input_string = input(\"> \")\n\n    # if user types 'quit' then say goodbye\n    print(\"Good bye!\")\n    import os\n\n    os._exit(0)\n", "examples/protobuf_parser.py": "# protobuf_parser.py\n#\n#  simple parser for parsing protobuf .proto files\n#\n#  Copyright 2010, Paul McGuire\n#\n\nfrom pyparsing import (\n    Word,\n    alphas,\n    alphanums,\n    Regex,\n    Suppress,\n    Forward,\n    Group,\n    one_of,\n    Opt,\n    DelimitedList,\n    rest_of_line,\n    quotedString,\n    Dict,\n    Keyword,\n)\n\nident = Word(alphas + \"_\", alphanums + \"_\").set_name(\"identifier\")\ninteger = Regex(r\"[+-]?\\d+\")\n\nLBRACE, RBRACE, LBRACK, RBRACK, LPAR, RPAR, EQ, SEMI = Suppress.using_each(\"{}[]()=;\")\n\nkwds = \"\"\"message required optional repeated enum extensions extends extend\n          to package service rpc returns true false option import syntax\"\"\"\nfor kw in kwds.split():\n    exec(\"{}_ = Keyword('{}')\".format(kw.upper(), kw))\n\nmessageBody = Forward()\n\nmessageDefn = MESSAGE_ - ident(\"messageId\") + LBRACE + messageBody(\"body\") + RBRACE\n\ntypespec = (\n    one_of(\n        \"double float int32 int64 uint32 uint64 sint32 sint64\"\n        \" fixed32 fixed64 sfixed32 sfixed64 bool string bytes\"\n    )\n    | ident\n)\nrvalue = integer | TRUE_ | FALSE_ | ident\nfieldDirective = LBRACK + Group(ident + EQ + rvalue) + RBRACK\nfieldDefnPrefix = REQUIRED_ | OPTIONAL_ | REPEATED_\nfieldDefn = (\n    Opt(fieldDefnPrefix)\n    + typespec(\"typespec\")\n    + ident(\"ident\")\n    + EQ\n    + integer(\"fieldint\")\n    + fieldDirective[...]\n    + SEMI\n)\n\n# enumDefn ::= 'enum' ident '{' { ident '=' integer ';' }* '}'\nenumDefn = (\n    ENUM_(\"typespec\")\n    - ident(\"name\")\n    + LBRACE\n    + Dict((Group(ident + EQ + integer + SEMI))[...])(\"values\")\n    + RBRACE\n)\n\n# extensionsDefn ::= 'extensions' integer 'to' integer ';'\nextensionsDefn = EXTENSIONS_ - integer + TO_ + integer + SEMI\n\n# messageExtension ::= 'extend' ident '{' messageBody '}'\nmessageExtension = EXTEND_ - ident + LBRACE + messageBody + RBRACE\n\n# messageBody ::= { fieldDefn | enumDefn | messageDefn | extensionsDefn | messageExtension }*\nmessageBody <<= Group(\n    Group(\n        fieldDefn | enumDefn | messageDefn | extensionsDefn | messageExtension\n    )[...]\n)\n\n# methodDefn ::= 'rpc' ident '(' [ ident ] ')' 'returns' '(' [ ident ] ')' ';'\nmethodDefn = (\n    RPC_\n    - ident(\"methodName\")\n    + LPAR\n    + Opt(ident(\"methodParam\"))\n    + RPAR\n    + RETURNS_\n    + LPAR\n    + Opt(ident(\"methodReturn\"))\n    + RPAR\n)\n\n# serviceDefn ::= 'service' ident '{' methodDefn* '}'\nserviceDefn = (\n    SERVICE_ - ident(\"serviceName\") + LBRACE + Group(methodDefn)[...] + RBRACE\n)\n\nsyntaxDefn = SYNTAX_ + EQ - quotedString(\"syntaxString\") + SEMI\n\n# packageDirective ::= 'package' ident [ '.' ident]* ';'\npackageDirective = Group(PACKAGE_ - DelimitedList(ident, \".\", combine=True) + SEMI)\n\ncomment = \"//\" + rest_of_line\n\nimportDirective = IMPORT_ - quotedString(\"importFileSpec\") + SEMI\n\noptionDirective = (\n    OPTION_ - ident(\"optionName\") + EQ + quotedString(\"optionValue\") + SEMI\n)\n\ntopLevelStatement = Group(\n    messageDefn\n    | messageExtension\n    | enumDefn\n    | serviceDefn\n    | importDirective\n    | optionDirective\n    | syntaxDefn\n)\n\nparser = Opt(packageDirective) + topLevelStatement[...]\n\nparser.ignore(comment)\n\n\nif __name__ == \"__main__\":\n\n    test1 = \"\"\"message Person {\n      required int32 id = 1;\n      required string name = 2;\n      optional string email = 3;\n    }\"\"\"\n\n    test2 = \"\"\"package tutorial;\n    \n    message Person {\n      required string name = 1;\n      required int32 id = 2;\n      optional string email = 3;\n    \n      enum PhoneType {\n        MOBILE = 0;\n        HOME = 1;\n        WORK = 2;\n      }\n    \n      message PhoneNumber {\n        required string number = 1;\n        optional PhoneType type = 2 [default = HOME];\n      }\n    \n      repeated PhoneNumber phone = 4;\n    }\n    \n    message AddressBook {\n      repeated Person person = 1;\n    }\"\"\"\n\n    test3 = \"\"\"syntax = \"proto3\";\n    \n    import \"test.proto\";\n    \n    message SearchRequest {\n      string query = 1;\n      int32 page_number = 2;\n      int32 result_per_page = 3;\n    }\n    \"\"\"\n\n    parser.run_tests([test1, test2, test3])\n", "examples/datetime_parse_actions.py": "# parseActions.py\n#\n#   A sample parser to match a date string of the form \"YYYY/MM/DD\",\n# and return it as a datetime, or raise an exception if not a valid date.\n#\n# Copyright 2012, Paul T. McGuire\n#\nfrom datetime import datetime\nimport pyparsing as pp\nfrom pyparsing import pyparsing_common as ppc\n\n# define an integer string, and a parse action to convert it\n# to an integer at parse time\ninteger = pp.Word(pp.nums).set_name(\"integer\")\n\n\ndef convert_to_int(tokens):\n    # no need to test for validity - we can't get here\n    # unless tokens[0] contains all numeric digits\n    return int(tokens[0])\n\n\ninteger.set_parse_action(convert_to_int)\n# or can be written as one line as\n# integer = Word(nums).set_parse_action(lambda t: int(t[0]))\n\n# define a pattern for a year/month/day date\ndate_expr = integer(\"year\") + \"/\" + integer(\"month\") + \"/\" + integer(\"day\")\ndate_expr.ignore(pp.python_style_comment)\n\n\ndef convert_to_datetime(s, loc, tokens):\n    try:\n        # note that the year, month, and day fields were already\n        # converted to ints from strings by the parse action defined\n        # on the integer expression above\n        return datetime(tokens.year, tokens.month, tokens.day).date()\n    except Exception as ve:\n        errmsg = f\"'{tokens.year}/{tokens.month}/{tokens.day}' is not a valid date, {ve}\"\n        raise pp.ParseException(s, loc, errmsg)\n\n\ndate_expr.set_parse_action(convert_to_datetime)\n\n\ndate_expr.run_tests(\n    \"\"\"\\\n    2000/1/1\n\n    # invalid month\n    2000/13/1\n\n    # 1900 was not a leap year\n    1900/2/29\n\n    # but 2000 was\n    2000/2/29\n    \"\"\"\n)\n\n\n# if dates conform to ISO8601, use definitions in pyparsing_common\ndate_expr = ppc.iso8601_date.set_parse_action(ppc.convert_to_date())\ndate_expr.ignore(pp.python_style_comment)\n\ndate_expr.run_tests(\n    \"\"\"\\\n    2000-01-01\n\n    # invalid month\n    2000-13-01\n\n    # 1900 was not a leap year\n    1900-02-29\n\n    # but 2000 was\n    2000-02-29\n    \"\"\"\n)\n", "examples/withAttribute.py": "#\n#  withAttribute.py\n#  Copyright, 2007 - Paul McGuire\n#\n#  Simple example of using withAttribute parse action helper\n#  to define\n#\nimport pyparsing as pp\n\ndata = \"\"\"\\\n    <td align=right width=80><font size=2 face=\"New Times Roman,Times,Serif\">&nbsp;49.950&nbsp;</font></td>\n    <td align=left width=80><font size=2 face=\"New Times Roman,Times,Serif\">&nbsp;50.950&nbsp;</font></td>\n    <td align=right width=80><font size=2 face=\"New Times Roman,Times,Serif\">&nbsp;51.950&nbsp;</font></td>\n    \"\"\"\n\ntd, tdEnd = pp.makeHTMLTags(\"TD\")\nfont, fontEnd = pp.makeHTMLTags(\"FONT\")\nrealNum = pp.pyparsing_common.real\nNBSP = pp.Literal(\"&nbsp;\")\npatt = td + font + NBSP + realNum(\"value\") + NBSP + fontEnd + tdEnd\n\n# always use addParseAction when adding withAttribute as a parse action to a start tag\ntd.addParseAction(pp.withAttribute(align=\"right\", width=\"80\"))\n\nfor s in patt.searchString(data):\n    print(s.value)\n", "examples/greetingInGreek.py": "#\n# greetingInGreek.py\n#\n# Demonstration of the parsing module, on the prototypical \"Hello, World!\" example\n#\n# Copyright 2004-2016, by Paul McGuire\n#\nfrom pyparsing import Word, pyparsing_unicode as ppu\n\n# define grammar\nalphas = ppu.Greek.alphas\ngreet = Word(alphas) + \",\" + Word(alphas) + \"!\"\n\n# input string\nhello = \"\u039a\u03b1\u03bb\u03b7\u03bc\u03ad\u03c1\u03b1, \u03ba\u03cc\u03c3\u03bc\u03b5!\"\n\n# parse input string\nprint(greet.parse_string(hello))\n", "examples/mozillaCalendarParser.py": "from pyparsing import (\n    Optional,\n    oneOf,\n    Literal,\n    Word,\n    printables,\n    Group,\n    OneOrMore,\n    ZeroOrMore,\n)\n\n\"\"\"\nA simple parser for calendar (*.ics) files,\nas exported by the Mozilla calendar.\n\nAny suggestions and comments welcome.\n\nVersion:   0.1\nCopyright: Petri Savolainen <firstname.lastname@iki.fi>\nLicense:   Free for any use\n\"\"\"\n\n\n# TERMINALS\n\nBEGIN = Literal(\"BEGIN:\").suppress()\nEND = Literal(\"END:\").suppress()\nvalstr = printables + \"\\xe4\\xf6\\xe5\\xd6\\xc4\\xc5 \"\n\nEQ = Literal(\"=\").suppress()\nSEMI = Literal(\";\").suppress()\nCOLON = Literal(\":\").suppress()\n\nEVENT = Literal(\"VEVENT\").suppress()\nCALENDAR = Literal(\"VCALENDAR\").suppress()\nALARM = Literal(\"VALARM\").suppress()\n\n# TOKENS\n\nCALPROP = oneOf(\"VERSION PRODID METHOD\", asKeyword=True)\nALMPROP = oneOf(\"TRIGGER\", asKeyword=True)\nEVTPROP = oneOf(\n    \"\"\"X-MOZILLA-RECUR-DEFAULT-INTERVAL\n       X-MOZILLA-RECUR-DEFAULT-UNITS\n       UID DTSTAMP LAST-MODIFIED X RRULE EXDATE\"\"\", asKeyword=True\n)\n\nvaluestr = Word(valstr).setName(\"valuestr\")\npropval = valuestr\ntypeval = valuestr\ntypename = oneOf(\"VALUE MEMBER FREQ UNTIL INTERVAL\", asKeyword=True)\n\nproptype = Group(SEMI + typename + EQ + typeval).setName(\"proptype\").suppress()\n\ncalprop = Group(CALPROP + ZeroOrMore(proptype) + COLON + propval)\nalmprop = Group(ALMPROP + ZeroOrMore(proptype) + COLON + propval)\nevtprop = (\n    Group(EVTPROP + ZeroOrMore(proptype) + COLON + propval).suppress()\n    | \"CATEGORIES\" + COLON + propval.setResultsName(\"categories\")\n    | \"CLASS\" + COLON + propval.setResultsName(\"class\")\n    | \"DESCRIPTION\" + COLON + propval.setResultsName(\"description\")\n    | \"DTSTART\" + proptype + COLON + propval.setResultsName(\"begin\")\n    | \"DTEND\" + proptype + COLON + propval.setResultsName(\"end\")\n    | \"LOCATION\" + COLON + propval.setResultsName(\"location\")\n    | \"PRIORITY\" + COLON + propval.setResultsName(\"priority\")\n    | \"STATUS\" + COLON + propval.setResultsName(\"status\")\n    | \"SUMMARY\" + COLON + propval.setResultsName(\"summary\")\n    | \"URL\" + COLON + propval.setResultsName(\"url\")\n).setName(\"evtprop\")\ncalprops = Group(OneOrMore(calprop)).setName(\"calprops\").suppress()\nevtprops = Group(OneOrMore(evtprop))\nalmprops = Group(OneOrMore(almprop)).setName(\"almprops\").suppress()\n\nalarm = (BEGIN + ALARM + almprops + END + ALARM).setName(\"alarm\")\nevent = (BEGIN + EVENT + evtprops + Optional(alarm) + END + EVENT).setName(\"event\")\nevents = Group(OneOrMore(event))\ncalendar = (BEGIN + CALENDAR + calprops + ZeroOrMore(event) + END + CALENDAR).setName(\"calendar\")\ncalendars = OneOrMore(calendar)\n\n\n# PARSE ACTIONS\n\n\ndef gotEvent(s, loc, toks):\n    for event in toks:\n        print(event.dump())\n\n\nevent.setParseAction(gotEvent)\n\n\n# MAIN PROGRAM\n\nif __name__ == \"__main__\":\n\n    calendars.parseFile(\"mozilla.ics\")\n", "examples/indentedGrammarExample.py": "# indentedGrammarExample.py\n#\n# Copyright (c) 2006,2016  Paul McGuire\n#\n# A sample of a pyparsing grammar using indentation for\n# grouping (like Python does).\n#\n# Updated to use indentedBlock helper method.\n#\n\nfrom pyparsing import *\n\n\ndata = \"\"\"\\\ndef A(z):\n  A1\n  B = 100\n  G = A2\n  A2\n  A3\nB\ndef BB(a,b,c):\n  BB1\n  def BBA():\n    bba1\n    bba2\n    bba3\nC\nD\ndef spam(x,y):\n     def eggs(z):\n         pass\n\"\"\"\n\n\nstmt = Forward()\nsuite = IndentedBlock(stmt)\n\nidentifier = Word(alphas, alphanums)\nfuncDecl = (\n    \"def\" + identifier + Group(\"(\" + Optional(delimitedList(identifier)) + \")\") + \":\"\n)\nfuncDef = Group(funcDecl + suite)\n\nrvalue = Forward()\nfuncCall = Group(identifier + \"(\" + Optional(delimitedList(rvalue)) + \")\")\nrvalue << (funcCall | identifier | Word(nums))\nassignment = Group(identifier + \"=\" + rvalue)\nstmt << (funcDef | assignment | identifier)\n\nmodule_body = OneOrMore(stmt)\n\nprint(data)\nparseTree = module_body.parseString(data)\nparseTree.pprint()\n", "examples/lineno_example.py": "#\n# lineno_example.py\n#\n# an example of using the location value returned by pyparsing to\n# extract the line and column number of the location of the matched text,\n# or to extract the entire line of text.\n#\n# Copyright (c) 2006, Paul McGuire\n#\nimport pyparsing as pp\n\ndata = \"\"\"Now is the time\nfor all good men\nto come to the aid\nof their country.\"\"\"\n\n\n# demonstrate use of lineno, line, and col in a parse action\ndef report_long_words(st, locn, toks):\n    word = toks[0]\n    if len(word) > 3:\n        print(\n            f\"Found {word!r} on line {pp.lineno(locn, st)} at column {pp.col(locn, st)}\"\n        )\n        print(\"The full line of text was:\")\n        print(f\"{pp.line(locn, st)!r}\")\n        print(f\" {'^':>{pp.col(locn, st)}}\")\n        print()\n\n\nwd = pp.Word(pp.alphas).set_parse_action(report_long_words)\nwd[1, ...].parse_string(data)\n\n\n# demonstrate returning an object from a parse action, containing more information\n# than just the matching token text\nclass Token:\n    def __init__(self, st, locn, tok_string):\n        self.token_string = tok_string\n        self.locn = locn\n        self.source_line = pp.line(locn, st)\n        self.line_no = pp.lineno(locn, st)\n        self.col = pp.col(locn, st)\n\n    def __str__(self):\n        return f\"{self.token_string!r} (line: {self.line_no}, col: {self.col})\"\n\n\ndef create_token_object(st, locn, toks):\n    return Token(st, locn, toks[0])\n\n\nwd = pp.Word(pp.alphas).set_parse_action(create_token_object)\n\nfor token_obj in wd[1, ...].parse_string(data):\n    print(token_obj)\n", "examples/searchparser.py": "\"\"\"Search query parser\n\nversion 2006-03-09\n\nThis search query parser uses the excellent Pyparsing module\n(http://pyparsing.sourceforge.net/) to parse search queries by users.\nIt handles:\n\n* 'and', 'or' and implicit 'and' operators;\n* parentheses;\n* quoted strings;\n* wildcards at the end of a search term (help*);\n\nRequirements:\n* Python\n* Pyparsing\n\nIf you run this script, it will perform a number of tests. To use is as a\nmodule, you should use inheritance on the SearchQueryParser class and overwrite\nthe Get... methods. The ParserTest class gives a very simple example of how this\ncould work.\n\n-------------------------------------------------------------------------------\nCopyright (c) 2006, Estrate, the Netherlands\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n* Neither the name of Estrate nor the names of its contributors may be used\n  to endorse or promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nCONTRIBUTORS:\n- Steven Mooij\n- Rudolph Froger\n- Paul McGuire\n\nTODO:\n- add more docs\n- ask someone to check my English texts\n- add more kinds of wildcards ('*' at the beginning and '*' inside a word)?\n\"\"\"\nfrom pyparsing import (\n    Word,\n    alphanums,\n    Keyword,\n    Group,\n    Combine,\n    Forward,\n    Suppress,\n    OneOrMore,\n    oneOf,\n)\n\n\nclass SearchQueryParser:\n    def __init__(self):\n        self._methods = {\n            \"and\": self.evaluateAnd,\n            \"or\": self.evaluateOr,\n            \"not\": self.evaluateNot,\n            \"parenthesis\": self.evaluateParenthesis,\n            \"quotes\": self.evaluateQuotes,\n            \"word\": self.evaluateWord,\n            \"wordwildcard\": self.evaluateWordWildcard,\n        }\n        self._parser = self.parser()\n\n    def parser(self):\n        \"\"\"\n        This function returns a parser.\n        The grammar should be like most full text search engines (Google, Tsearch, Lucene).\n\n        Grammar:\n        - a query consists of alphanumeric words, with an optional '*' wildcard\n          at the end of a word\n        - a sequence of words between quotes is a literal string\n        - words can be used together by using operators ('and' or 'or')\n        - words with operators can be grouped with parenthesis\n        - a word or group of words can be preceded by a 'not' operator\n        - the 'and' operator precedes an 'or' operator\n        - if an operator is missing, use an 'and' operator\n        \"\"\"\n        operatorOr = Forward()\n\n        operatorWord = Group(Combine(Word(alphanums) + Suppress(\"*\"))).setResultsName(\n            \"wordwildcard\"\n        ) | Group(Word(alphanums)).setResultsName(\"word\")\n\n        operatorQuotesContent = Forward()\n        operatorQuotesContent << ((operatorWord + operatorQuotesContent) | operatorWord)\n\n        operatorQuotes = (\n            Group(Suppress('\"') + operatorQuotesContent + Suppress('\"')).setResultsName(\n                \"quotes\"\n            )\n            | operatorWord\n        )\n\n        operatorParenthesis = (\n            Group(Suppress(\"(\") + operatorOr + Suppress(\")\")).setResultsName(\n                \"parenthesis\"\n            )\n            | operatorQuotes\n        )\n\n        operatorNot = Forward()\n        operatorNot << (\n            Group(Suppress(Keyword(\"not\", caseless=True)) + operatorNot).setResultsName(\n                \"not\"\n            )\n            | operatorParenthesis\n        )\n\n        operatorAnd = Forward()\n        operatorAnd << (\n            Group(\n                operatorNot + Suppress(Keyword(\"and\", caseless=True)) + operatorAnd\n            ).setResultsName(\"and\")\n            | Group(\n                operatorNot + OneOrMore(~oneOf(\"and or\") + operatorAnd)\n            ).setResultsName(\"and\")\n            | operatorNot\n        )\n\n        operatorOr << (\n            Group(\n                operatorAnd + Suppress(Keyword(\"or\", caseless=True)) + operatorOr\n            ).setResultsName(\"or\")\n            | operatorAnd\n        )\n\n        return operatorOr.parseString\n\n    def evaluateAnd(self, argument):\n        return self.evaluate(argument[0]).intersection(self.evaluate(argument[1]))\n\n    def evaluateOr(self, argument):\n        return self.evaluate(argument[0]).union(self.evaluate(argument[1]))\n\n    def evaluateNot(self, argument):\n        return self.GetNot(self.evaluate(argument[0]))\n\n    def evaluateParenthesis(self, argument):\n        return self.evaluate(argument[0])\n\n    def evaluateQuotes(self, argument):\n        \"\"\"Evaluate quoted strings\n\n        First is does an 'and' on the indidual search terms, then it asks the\n        function GetQuoted to only return the subset of ID's that contain the\n        literal string.\n        \"\"\"\n        r = set()\n        search_terms = []\n        for item in argument:\n            search_terms.append(item[0])\n            if len(r) == 0:\n                r = self.evaluate(item)\n            else:\n                r = r.intersection(self.evaluate(item))\n        return self.GetQuotes(\" \".join(search_terms), r)\n\n    def evaluateWord(self, argument):\n        return self.GetWord(argument[0])\n\n    def evaluateWordWildcard(self, argument):\n        return self.GetWordWildcard(argument[0])\n\n    def evaluate(self, argument):\n        return self._methods[argument.getName()](argument)\n\n    def Parse(self, query):\n        # print self._parser(query)[0]\n        return self.evaluate(self._parser(query)[0])\n\n    def GetWord(self, word):\n        return set()\n\n    def GetWordWildcard(self, word):\n        return set()\n\n    def GetQuotes(self, search_string, tmp_result):\n        return set()\n\n    def GetNot(self, not_set):\n        return set().difference(not_set)\n\n\nclass ParserTest(SearchQueryParser):\n    \"\"\"Tests the parser with some search queries\n    tests contains a dictionary with tests and expected results.\n    \"\"\"\n\n    tests = {\n        \"help\": {1, 2, 4, 5},\n        \"help or hulp\": {1, 2, 3, 4, 5},\n        \"help and hulp\": {2},\n        \"help hulp\": {2},\n        \"help and hulp or hilp\": {2, 3, 4},\n        \"help or hulp and hilp\": {1, 2, 3, 4, 5},\n        \"help or hulp or hilp or halp\": {1, 2, 3, 4, 5, 6},\n        \"(help or hulp) and (hilp or halp)\": {3, 4, 5},\n        \"help and (hilp or halp)\": {4, 5},\n        \"(help and (hilp or halp)) or hulp\": {2, 3, 4, 5},\n        \"not help\": {3, 6, 7, 8},\n        \"not hulp and halp\": {5, 6},\n        \"not (help and halp)\": {1, 2, 3, 4, 6, 7, 8},\n        '\"help me please\"': {2},\n        '\"help me please\" or hulp': {2, 3},\n        '\"help me please\" or (hulp and halp)': {2},\n        \"help*\": {1, 2, 4, 5, 8},\n        \"help or hulp*\": {1, 2, 3, 4, 5},\n        \"help* and hulp\": {2},\n        \"help and hulp* or hilp\": {2, 3, 4},\n        \"help* or hulp or hilp or halp\": {1, 2, 3, 4, 5, 6, 8},\n        \"(help or hulp*) and (hilp* or halp)\": {3, 4, 5},\n        \"help* and (hilp* or halp*)\": {4, 5},\n        \"(help and (hilp* or halp)) or hulp*\": {2, 3, 4, 5},\n        \"not help* and halp\": {6},\n        \"not (help* and helpe*)\": {1, 2, 3, 4, 5, 6, 7},\n        '\"help* me please\"': {2},\n        '\"help* me* please\" or hulp*': {2, 3},\n        '\"help me please*\" or (hulp and halp)': {2},\n        '\"help me please\" not (hulp and halp)': {2},\n        '\"help me please\" hulp': {2},\n        \"help and hilp and not holp\": {4},\n        \"help hilp not holp\": {4},\n        \"help hilp and not holp\": {4},\n    }\n\n    docs = {\n        1: \"help\",\n        2: \"help me please hulp\",\n        3: \"hulp hilp\",\n        4: \"help hilp\",\n        5: \"halp thinks he needs help\",\n        6: \"he needs halp\",\n        7: \"nothing\",\n        8: \"helper\",\n    }\n\n    index = {\n        \"help\": {1, 2, 4, 5},\n        \"me\": {2},\n        \"please\": {2},\n        \"hulp\": {2, 3},\n        \"hilp\": {3, 4},\n        \"halp\": {5, 6},\n        \"thinks\": {5},\n        \"he\": {5, 6},\n        \"needs\": {5, 6},\n        \"nothing\": {7},\n        \"helper\": {8},\n    }\n\n    def GetWord(self, word):\n        if word in self.index:\n            return self.index[word]\n        else:\n            return set()\n\n    def GetWordWildcard(self, word):\n        result = set()\n        for item in list(self.index.keys()):\n            if word == item[0 : len(word)]:\n                result = result.union(self.index[item])\n        return result\n\n    def GetQuotes(self, search_string, tmp_result):\n        result = set()\n        for item in tmp_result:\n            if self.docs[item].count(search_string):\n                result.add(item)\n        return result\n\n    def GetNot(self, not_set):\n        all = set(list(self.docs.keys()))\n        return all.difference(not_set)\n\n    def Test(self):\n        all_ok = True\n        for item in list(self.tests.keys()):\n            print(item)\n            r = self.Parse(item)\n            e = self.tests[item]\n            print(f\"Result: {r}\")\n            print(f\"Expect: {e}\")\n            if e == r:\n                print(\"Test OK\")\n            else:\n                all_ok = False\n                print(\">>>>>>>>>>>>>>>>>>>>>>Test ERROR<<<<<<<<<<<<<<<<<<<<<\")\n            print(\"\")\n        return all_ok\n\n\nif __name__ == \"__main__\":\n    if ParserTest().Test():\n        print(\"All tests OK\")\n    else:\n        print(\"One or more tests FAILED\")\n", "examples/email_address_parser.py": "#\n# email_address_parser.py\n#\n# email address parser based on RFC 5322 BNF segments\n# - see https://datatracker.ietf.org/doc/html/rfc5322#section-3.4.\n#\n# The returned parse results include named fields 'account' and 'domain'\n# for emails of the form `account@domain`.\n#\n# Copyright 2024, by Paul McGuire\n#\nfrom pyparsing import Regex\n\nemail_address = Regex(\n    # RFC5322 email address\n    r\"\"\"(?P<account>(?:(?:\\\"[\\w\\s()<>[\\].,;:@\"]+\\\")|[!#-'*+\\-/-9=?A-Z\\^-~.]+))\"\"\"\n    \"@\"\n    r\"\"\"(?P<domain>(?:(?:(?!-)[!#-'*+\\-/-9=?A-Z\\^-~]{1,63}(?<!-)\\.)+[A-Za-z0-9]{2,6})|(?:\\[[!-Z^-~]+\\]))(?:\\b|$)\"\"\"\n).set_name(\"email address\")\n\n\ndef main():\n    success, _ = email_address.run_tests(\n        \"\"\"\\\n        email@example.com\n        firstname.lastname@example.com\n        email@subdomain.example.com\n        firstname+lastname@example.com\n        email@123.123.123.123\n        email@[123.123.123.123]\n        \"email\"@example.com\n        1234567890@example.com\n        email@example-one.com\n        _______@example.com\n        email@example.name\n        email@example.museum\n        email@example.co.jp\n        firstname-lastname@example.com\n        \"\"\"\n    )\n\n    assert success\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/test_bibparse.py": "\"\"\" Test for bibparse grammar \"\"\"\n\nimport unittest\nfrom pyparsing import ParseException\nfrom .btpyparse import Macro\nfrom . import btpyparse as bp\n\n\nclass TestBibparse(unittest.TestCase):\n    def test_names(self):\n        # check various types of names\n        # All names can contains alphas, but not some special chars\n        bad_chars = \"\\\"#%'(),={}\"\n        for name_type, dig1f in (\n            (bp.macro_def, False),\n            (bp.field_name, False),\n            (bp.entry_type, False),\n            (bp.cite_key, True),\n        ):\n            if dig1f:  # can start with digit\n                self.assertEqual(\"2t\", name_type.parseString(\"2t\")[0])\n            else:\n                self.assertRaises(ParseException, name_type.parseString, \"2t\")\n            # All of the names cannot contain some characters\n            for char in bad_chars:\n                self.assertRaises(ParseException, name_type.parseString, char)\n            # standard strings all OK\n            self.assertEqual(\"simple_test\", name_type.parseString(\"simple_test\")[0])\n        # Test macro ref\n        mr = bp.macro_ref\n        # can't start with digit\n        self.assertRaises(ParseException, mr.parseString, \"2t\")\n        for char in bad_chars:\n            self.assertRaises(ParseException, mr.parseString, char)\n        self.assertEqual(\"simple_test\", mr.parseString(\"simple_test\")[0].name)\n\n    def test_numbers(self):\n        self.assertEqual(\"1066\", bp.number.parseString(\"1066\")[0])\n        self.assertEqual(\"0\", bp.number.parseString(\"0\")[0])\n        self.assertRaises(ParseException, bp.number.parseString, \"-4\")\n        self.assertRaises(ParseException, bp.number.parseString, \"+4\")\n        self.assertRaises(ParseException, bp.number.parseString, \".4\")\n        # something point something leaves a trailing .4 unmatched\n        self.assertEqual(\"0\", bp.number.parseString(\"0.4\")[0])\n\n    def test_parse_string(self):\n        # test string building blocks\n        self.assertEqual(bp.chars_no_quotecurly.parseString(\"x\")[0], \"x\")\n        self.assertEqual(bp.chars_no_quotecurly.parseString(\"a string\")[0], \"a string\")\n        self.assertEqual(bp.chars_no_quotecurly.parseString('a \"string')[0], \"a \")\n        self.assertEqual(bp.chars_no_curly.parseString(\"x\")[0], \"x\")\n        self.assertEqual(bp.chars_no_curly.parseString(\"a string\")[0], \"a string\")\n        self.assertEqual(bp.chars_no_curly.parseString(\"a {string\")[0], \"a \")\n        self.assertEqual(bp.chars_no_curly.parseString(\"a }string\")[0], \"a \")\n        # test more general strings together\n        for obj in (bp.curly_string, bp.string, bp.field_value):\n            self.assertEqual(obj.parseString(\"{}\").asList(), [])\n            self.assertEqual(obj.parseString('{a \"string}')[0], 'a \"string')\n            self.assertEqual(\n                [\"a \", [\"nested\"], \" string\"],\n                obj.parseString(\"{a {nested} string}\").asList(),\n            )\n            self.assertEqual(\n                [\"a \", [\"double \", [\"nested\"]], \" string\"],\n                obj.parseString(\"{a {double {nested}} string}\").asList(),\n            )\n        for obj in (bp.quoted_string, bp.string, bp.field_value):\n            self.assertEqual([], obj.parseString('\"\"').asList())\n            self.assertEqual(\"a string\", obj.parseString('\"a string\"')[0])\n            self.assertEqual(\n                [\"a \", [\"nested\"], \" string\"],\n                obj.parseString('\"a {nested} string\"').asList(),\n            )\n            self.assertEqual(\n                [\"a \", [\"double \", [\"nested\"]], \" string\"],\n                obj.parseString('\"a {double {nested}} string\"').asList(),\n            )\n\n        # check macro def in string\n        self.assertEqual(Macro(\"someascii\"), bp.string.parseString(\"someascii\")[0])\n        self.assertRaises(ParseException, bp.string.parseString, \"%#= validstring\")\n        # check number in string\n        self.assertEqual(bp.string.parseString(\"1994\")[0], \"1994\")\n\n    def test_parse_field(self):\n        # test field value - hashes included\n        fv = bp.field_value\n        # Macro\n        self.assertEqual(Macro(\"aname\"), fv.parseString(\"aname\")[0])\n        self.assertEqual(Macro(\"aname\"), fv.parseString(\"ANAME\")[0])\n        # String and macro\n        self.assertEqual(\n            [Macro(\"aname\"), \"some string\"],\n            fv.parseString('aname # \"some string\"').asList(),\n        )\n        # Nested string\n        self.assertEqual(\n            [Macro(\"aname\"), \"some \", [\"string\"]],\n            fv.parseString(\"aname # {some {string}}\").asList(),\n        )\n        # String and number\n        self.assertEqual(\n            [\"a string\", \"1994\"], fv.parseString('\"a string\" # 1994').asList()\n        )\n        # String and number and macro\n        self.assertEqual(\n            [\"a string\", \"1994\", Macro(\"a_macro\")],\n            fv.parseString('\"a string\" # 1994 # a_macro').asList(),\n        )\n\n    def test_comments(self):\n        res = bp.comment.parseString(\"@Comment{about something}\")\n        self.assertEqual(res.asList(), [\"comment\", \"{about something}\"])\n        self.assertEqual(\n            [\"comment\", \"{about something\"],\n            bp.comment.parseString(\"@COMMENT{about something\").asList(),\n        )\n        self.assertEqual(\n            [\"comment\", \"(about something\"],\n            bp.comment.parseString(\"@comment(about something\").asList(),\n        )\n        self.assertEqual(\n            [\"comment\", \" about something\"],\n            bp.comment.parseString(\"@COMment about something\").asList(),\n        )\n        self.assertRaises(\n            ParseException, bp.comment.parseString, \"@commentabout something\"\n        )\n        self.assertRaises(\n            ParseException, bp.comment.parseString, \"@comment+about something\"\n        )\n        self.assertRaises(\n            ParseException, bp.comment.parseString, '@comment\"about something'\n        )\n\n    def test_preamble(self):\n        res = bp.preamble.parseString('@preamble{\"about something\"}')\n        self.assertEqual(res.asList(), [\"preamble\", \"about something\"])\n        self.assertEqual(\n            [\"preamble\", \"about something\"],\n            bp.preamble.parseString(\"@PREamble{{about something}}\").asList(),\n        )\n        self.assertEqual(\n            [\"preamble\", \"about something\"],\n            bp.preamble.parseString(\n                \"\"\"@PREamble{\n            {about something}\n        }\"\"\"\n            ).asList(),\n        )\n\n    def test_macro(self):\n        res = bp.macro.parseString('@string{ANAME = \"about something\"}')\n        self.assertEqual(res.asList(), [\"string\", \"aname\", \"about something\"])\n        self.assertEqual(\n            [\"string\", \"aname\", \"about something\"],\n            bp.macro.parseString(\"@string{aname = {about something}}\").asList(),\n        )\n\n    def test_entry(self):\n        txt = \"\"\"@some_entry{akey, aname = \"about something\",\n        another={something else}}\"\"\"\n        res = bp.entry.parseString(txt)\n        self.assertEqual(\n            [\n                \"some_entry\",\n                \"akey\",\n                [\"aname\", \"about something\"],\n                [\"another\", \"something else\"],\n            ],\n            res.asList(),\n        )\n        # Case conversion\n        txt = \"\"\"@SOME_ENTRY{akey, ANAME = \"about something\",\n        another={something else}}\"\"\"\n        res = bp.entry.parseString(txt)\n        self.assertEqual(\n            [\n                \"some_entry\",\n                \"akey\",\n                [\"aname\", \"about something\"],\n                [\"another\", \"something else\"],\n            ],\n            res.asList(),\n        )\n\n    def test_bibfile(self):\n        txt = \"\"\"@some_entry{akey, aname = \"about something\",\n        another={something else}}\"\"\"\n        res = bp.bibfile.parseString(txt)\n        self.assertEqual(\n            [\n                [\n                    \"some_entry\",\n                    \"akey\",\n                    [\"aname\", \"about something\"],\n                    [\"another\", \"something else\"],\n                ]\n            ],\n            res.asList(),\n        )\n\n    def test_bib1(self):\n        # First pass whole bib-like tests\n        txt = \"\"\"\n    Some introductory text\n    (implicit comment)\n\n        @ARTICLE{Brett2002marsbar,\n      author = {Matthew Brett and Jean-Luc Anton and Romain Valabregue and Jean-Baptise\n                Poline},\n      title = {{Region of interest analysis using an SPM toolbox}},\n      journal = {Neuroimage},\n      year = {2002},\n      volume = {16},\n      pages = {1140--1141},\n      number = {2}\n    }\n\n    @some_entry{akey, aname = \"about something\",\n    another={something else}}\n    \"\"\"\n        res = bp.bibfile.parseString(txt)\n        self.assertEqual(len(res), 3)\n        res2 = bp.parse_str(txt)\n        self.assertEqual(res.asList(), res2.asList())\n        res3 = [r.asList()[0] for r, start, end in bp.definitions.scanString(txt)]\n        self.assertEqual(res.asList(), res3)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "examples/decaf_parser.py": "#\n# decaf_parser.py\n#\n# Rudimentary parser for decaf language, used in Stanford University CS143\n# (https://web.stanford.edu/class/archive/cs/cs143/cs143.1128/handouts/030%20Decaf%20Specification.pdf)\n#\n# To convert this parser into one that gives more of an AST, change all the Group wrappers to add parse\n# actions that will result in ASTNode classes, or statement-specific subclasses.\n#\n# Copyright 2018, Paul McGuire\n#\n# fmt: off\n\"\"\"\n    Program ::= Decl+\n    Decl ::= VariableDecl | FunctionDecl  | ClassDecl | InterfaceDecl\n    VariableDecl ::= Variable ;\n    Variable ::= Type ident\n    Type ::= int | double | bool | string | ident | Type []\n    FunctionDecl ::= Type ident ( Formals ) StmtBlock | void ident ( Formals ) StmtBlock\n    Formals ::= Variable+, |  e\n    ClassDecl ::= class ident <extends ident>  <implements ident + ,>  { Field* }\n    Field ::= VariableDecl | FunctionDecl\n    InterfaceDecl ::= interface ident { Prototype* }\n    Prototype ::= Type ident ( Formals ) ; | void ident ( Formals ) ;\n    StmtBlock ::= { VariableDecl*  Stmt* }\n    Stmt ::=  <Expr> ; | IfStmt  | WhileStmt |  ForStmt | BreakStmt   | ReturnStmt  | PrintStmt  | StmtBlock\n    IfStmt ::= if ( Expr ) Stmt <else Stmt>\n    WhileStmt ::= while ( Expr ) Stmt\n    ForStmt ::= for ( <Expr> ; Expr ; <Expr> ) Stmt\n    ReturnStmt ::= return <Expr> ;\n    BreakStmt ::= break ;\n    PrintStmt ::= Print ( Expr+, ) ;\n    Expr ::= LValue = Expr | Constant | LValue | this | Call\n            | ( Expr )\n            | Expr + Expr | Expr - Expr | Expr * Expr | Expr / Expr |  Expr % Expr | - Expr\n            | Expr < Expr | Expr <= Expr | Expr > Expr | Expr >= Expr | Expr == Expr | Expr != Expr\n            | Expr && Expr | Expr || Expr | ! Expr\n            | ReadInteger ( ) | ReadLine ( ) | new ident | NewArray ( Expr , Typev)\n    LValue ::= ident |  Expr  . ident | Expr [ Expr ]\n    Call ::= ident  ( Actuals ) |  Expr  .  ident  ( Actuals )\n    Actuals ::=  Expr+, | e\n    Constant ::= intConstant | doubleConstant | boolConstant |  stringConstant | null\n\"\"\"\nimport pyparsing as pp\nfrom pyparsing import pyparsing_common as ppc\n\npp.ParserElement.enable_packrat()\n\n# keywords\n_keywords = (\n    VOID, INT, DOUBLE, BOOL, STRING, CLASS, INTERFACE, NULL, THIS, EXTENDS,\n    IMPLEMENTS, FOR, WHILE, IF, ELSE, RETURN, BREAK, NEW, NEWARRAY,\n    PRINT, READINTEGER, READLINE, TRUE, FALSE,\n) = pp.Keyword.using_each(\n    \"\"\"\n    void int double bool string class interface null this extends implements or while\n    if else return break new NewArray Print ReadInteger ReadLine true false\n    \"\"\".split(),\n)\nkeywords = pp.MatchFirst(_keywords)\n\n(\n    LPAR, RPAR, LBRACE, RBRACE, LBRACK, RBRACK, DOT, EQ, COMMA, SEMI\n) = pp.Suppress.using_each(\"(){}[].=,;\")\n\nhex_constant = pp.Regex(r\"0[xX][0-9a-fA-F]+\").add_parse_action(\n    lambda t: int(t[0][2:], 16)\n)\nint_constant = hex_constant | ppc.integer\ndouble_constant = ppc.real\nbool_constant = TRUE | FALSE\nstring_constant = pp.dbl_quoted_string\nnull = NULL\nconstant = double_constant | bool_constant | int_constant | string_constant | null\nident = ~keywords + ppc.identifier\ntype_ = pp.Group((INT | DOUBLE | BOOL | STRING | ident) + pp.Literal(\"[]\")[...])\n\nvariable = type_ + ident\nvariable_decl = variable + SEMI\n\nexpr = pp.Forward()\nexpr_parens = pp.Group(LPAR + expr + RPAR)\nactuals = pp.DelimitedList(expr) | \"\"\ncall = pp.Group(\n    ident(\"call_ident\") + LPAR + actuals(\"call_args\") + RPAR\n    | (expr_parens + (DOT + ident)[...])(\"call_ident_expr\")\n    + LPAR\n    + actuals(\"call_args\")\n    + RPAR\n)\nlvalue = (\n    (ident | expr_parens)\n    + (DOT + (ident | expr_parens))[...]\n    + (LBRACK + expr + RBRACK)[...]\n)\nassignment = pp.Group(lvalue(\"lhs\") + EQ + expr(\"rhs\"))\nread_integer = pp.Group(READINTEGER + LPAR + RPAR)\nread_line = pp.Group(READLINE + LPAR + RPAR)\nnew_statement = pp.Group(NEW + ident)\nnew_array = pp.Group(NEWARRAY + LPAR + expr + COMMA + type_ + RPAR)\nrvalue = constant | call | read_integer | read_line | new_statement | new_array | ident\narith_expr = pp.infix_notation(\n    rvalue,\n    [\n        (\"-\", 1, pp.OpAssoc.RIGHT,),\n        (pp.one_of(\"* / %\"), 2, pp.OpAssoc.LEFT,),\n        (pp.one_of(\"+ -\"), 2, pp.OpAssoc.LEFT,),\n    ],\n)\ncomparison_expr = pp.infix_notation(\n    arith_expr,\n    [\n        (\"!\", 1, pp.OpAssoc.RIGHT,),\n        (pp.one_of(\"< > <= >=\"), 2, pp.OpAssoc.LEFT,),\n        (pp.one_of(\"== !=\"), 2, pp.OpAssoc.LEFT,),\n        (pp.one_of(\"&&\"), 2, pp.OpAssoc.LEFT,),\n        (pp.one_of(\"||\"), 2, pp.OpAssoc.LEFT,),\n    ],\n)\nexpr <<= (\n    assignment\n    | call\n    | THIS\n    | comparison_expr\n    | arith_expr\n    | lvalue\n    | constant\n    | read_integer\n    | read_line\n    | new_statement\n    | new_array\n)\n\nstmt = pp.Forward()\nprint_stmt = pp.Group(\n    PRINT(\"statement\")\n    + LPAR\n    + pp.Group(pp.DelimitedList(expr) | \"\")(\"args\")\n    + RPAR\n    + SEMI\n)\nbreak_stmt = pp.Group(BREAK(\"statement\") + SEMI)\nreturn_stmt = pp.Group(RETURN(\"statement\") + expr + SEMI)\nfor_stmt = pp.Group(\n    FOR(\"statement\")\n    + LPAR\n    + (expr | \"\")\n    + SEMI\n    + expr\n    + SEMI\n    + (expr | \"\")\n    + RPAR\n    + stmt\n)\nwhile_stmt = pp.Group(WHILE(\"statement\") + LPAR + expr + RPAR + stmt)\nif_stmt = pp.Group(\n    IF(\"statement\")\n    + LPAR\n    + pp.Group(expr)(\"condition\")\n    + RPAR\n    + pp.Group(stmt)(\"then_statement\")\n    + pp.Group((ELSE + stmt | \"\"))(\"else_statement\")\n)\nstmt_block = pp.Group(\n    LBRACE + variable_decl[...] + stmt[...] + RBRACE\n)\nstmt <<= (\n    if_stmt\n    | while_stmt\n    | for_stmt\n    | break_stmt\n    | return_stmt\n    | print_stmt\n    | stmt_block\n    | pp.Group(expr + SEMI)\n)\n\nformals = pp.DelimitedList(variable) | \"\"\nprototype = pp.Group(\n    (type_ | VOID)(\"return_type\")\n    + ident(\"function_name\")\n    + LPAR\n    + formals(\"args\")\n    + RPAR\n    + SEMI\n)(\"prototype\")\nfunction_decl = pp.Group(\n    (type_ | VOID)(\"return_type\")\n    + ident(\"function_name\")\n    + LPAR\n    + formals(\"args\")\n    + RPAR\n    + stmt_block(\"body\")\n)(\"function_decl\")\n\ninterface_decl = pp.Group(\n    INTERFACE\n    + ident(\"interface_name\")\n    + LBRACE\n    + prototype[...](\"prototypes\")\n    + RBRACE\n)(\"interface\")\nfield = variable_decl | function_decl\nclass_decl = pp.Group(\n    CLASS\n    + ident(\"class_name\")\n    + (EXTENDS + ident | \"\")(\"extends\")\n    + (IMPLEMENTS + pp.DelimitedList(ident) | \"\")(\"implements\")\n    + LBRACE\n    + field[...](\"fields\")\n    + RBRACE\n)(\"class_decl\")\n\ndecl = variable_decl | function_decl | class_decl | interface_decl | prototype\nprogram = pp.Group(decl)[1, ...]\ndecaf_parser = program\n\nstmt.runTests(\"\"\"\\\n    sin(30);\n    a = 1;\n    b = 1 + 1;\n    b = 1 != 2 && false;\n    print(\"A\");\n    a.b = 100;\n    a.b = 100.0;\n    a[100] = b;\n    a[0][0] = 2;\n    a = 0x1234;\n\"\"\"\n)\n\ntest_program = \"\"\"\n    void getenv(string var);\n    int main(string[] args) {\n        if (a > 100) {\n            Print(a, \" is too big\");\n        } else if (a < 100) {\n            Print(a, \" is too small\");\n        } else {\n            Print(a, \"just right!\");\n        }\n    }\n\"\"\"\n\nprint(decaf_parser.parse_string(test_program).dump())\n", "examples/html_table_parser.py": "#\n# htmlTableParser.py\n#\n# Example of parsing a simple HTML table into a list of rows, and optionally into a little database\n#\n# Copyright 2019, Paul McGuire\n#\n\nimport pyparsing as pp\nimport urllib.request\n\n\n# define basic HTML tags, and compose into a Table\ntable, table_end = pp.make_html_tags(\"table\")\nthead, thead_end = pp.make_html_tags(\"thead\")\ntbody, tbody_end = pp.make_html_tags(\"tbody\")\ntr, tr_end = pp.make_html_tags(\"tr\")\nth, th_end = pp.make_html_tags(\"th\")\ntd, td_end = pp.make_html_tags(\"td\")\na, a_end = pp.make_html_tags(\"a\")\n\n# method to strip HTML tags from a string - will be used to clean up content of table cells\nstrip_html = (pp.any_open_tag | pp.any_close_tag).suppress().transform_string\n\n# expression for parsing <a href=\"url\">text</a> links, returning a (text, url) tuple\nlink = pp.Group(a + a.tag_body(\"text\") + a_end.suppress())\n\n\ndef extract_text_and_url(t):\n    return (t[0].text, t[0].href)\n\n\nlink.addParseAction(extract_text_and_url)\n\n\n# method to create table rows of header and data tags\ndef table_row(start_tag, end_tag):\n    body = start_tag.tag_body\n    body.add_parse_action(pp.token_map(str.strip), pp.token_map(strip_html))\n    row = pp.Group(\n        tr.suppress()\n        + (start_tag.suppress() + body + end_tag.suppress())[...]\n        + tr_end.suppress()\n    )\n    return row\n\n\nth_row = table_row(th, th_end)\ntd_row = table_row(td, td_end)\n\n# define expression for overall table - may vary slightly for different pages\nhtml_table = (\n    table\n    + tbody\n    + th_row[...](\"headers\")\n    + td_row[...](\"rows\")\n    + tbody_end\n    + table_end\n)\n\n\n# read in a web page containing an interesting HTML table\nwith urllib.request.urlopen(\n    \"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\"\n) as page:\n    page_html = page.read().decode()\n\ntz_table = html_table.searchString(page_html)[0]\n\n# convert rows to dicts\nrows = [dict(zip(tz_table.headers[0], row)) for row in tz_table.rows]\n\n# make a dict keyed by TZ database identifier\n# (get identifier key from second column header)\nidentifier_key = tz_table.headers[0][1]\ntz_db = {row[identifier_key]: row for row in rows}\n\nfrom pprint import pprint\n\npprint(tz_db[\"America/Chicago\"])\npprint(tz_db[\"Zulu\"])\n", "examples/urlExtractor.py": "# URL extractor\n# Copyright 2004, Paul McGuire\nfrom pyparsing import makeHTMLTags, pyparsing_common as ppc\nfrom urllib.request import urlopen\nimport pprint\n\nlinkOpenTag, linkCloseTag = makeHTMLTags(\"a\")\n\nlinkBody = linkOpenTag.tag_body\nlinkBody.setParseAction(ppc.stripHTMLTags)\nlinkBody.addParseAction(lambda toks: \" \".join(toks[0].strip().split()))\n\nlink = linkOpenTag + linkBody(\"body\") + linkCloseTag.suppress()\n\n# Go get some HTML with some links in it.\nwith urlopen(\"https://www.cnn.com/\") as serverListPage:\n    htmlText = serverListPage.read().decode(\"UTF-8\")\n\n# scanString is a generator that loops through the input htmlText, and for each\n# match yields the tokens and start and end locations (for this application, we are\n# not interested in the start and end values).\nfor toks, strt, end in link.scanString(htmlText):\n    print(toks.asList())\n\n# Create dictionary from list comprehension, assembled from each pair of tokens returned\n# from a matched URL.\npprint.pprint({toks.body: toks.href for toks, strt, end in link.scanString(htmlText)})\n", "examples/left_recursion.py": "#\n# left_recursion.py\n#\n# Example code illustrating use of left-recursion in Pyparsing.\n#\nimport pyparsing as pp\n\n# comment out this line to see the effects without LR parsing enabled\npp.ParserElement.enableLeftRecursion()\n\nitem_list = pp.Forward()\n\n# a common left-recursion definition\n# define a list of items as 'list + item | item'\n# BNF:\n#   item_list := item_list item | item\n#   item := word of alphas\nitem = pp.Word(pp.alphas)\nitem_list <<= item_list + item | item\n\nitem_list.runTests(\n    \"\"\"\\\n    To parse or not to parse that is the question\n    \"\"\"\n)\n\n# Define a parser for an expression that can be an identifier, a quoted string, or a\n# function call that starts with an expression\n# BNF:\n#   expr := function_call | name | string | '(' expr ')'\n#   function_call := expr '(' expr,... ')'\n#   name := Python identifier\n#   string := a quoted string\n# from https://stackoverflow.com/questions/32809389/parse-python-code-using-pyparsing/32822575#32822575\n\nLPAR, RPAR = map(pp.Suppress, \"()\")\nexpr = pp.Forward()\nstring = pp.quotedString\nfunction_call = expr + pp.Group(LPAR + pp.Optional(pp.delimitedList(expr)) + RPAR)\nname = pp.Word(pp.alphas + \"_\", pp.alphanums + \"_\")\n# left recursion - call starts with an expr\nexpr <<= function_call | string | name | pp.Group(LPAR + expr + RPAR)\n\nexpr.runTests(\n    \"\"\"\\\n    print(\"Hello, World!\")\n    (lookup_function(\"fprintf\"))(stderr, \"Hello, World!\")\n    \"\"\",\n    fullDump=False,\n)\n", "examples/cLibHeader.py": "#\n# cLibHeader.py\n#\n# A simple parser to extract API doc info from a C header file\n#\n# Copyright, 2012 - Paul McGuire\n#\n\nfrom pyparsing import (\n    Word,\n    alphas,\n    alphanums,\n    Combine,\n    oneOf,\n    Optional,\n    delimitedList,\n    Group,\n    Keyword,\n)\n\ntestdata = \"\"\"\n  int func1(float *vec, int len, double arg1);\n  int func2(float **arr, float *vec, int len, double arg1, double arg2);\n  \"\"\"\n\nident = Word(alphas, alphanums + \"_\")\nvartype = Combine(oneOf(\"float double int char\") + Optional(Word(\"*\")), adjacent=False)\narglist = delimitedList(Group(vartype(\"type\") + ident(\"name\")))\n\nfunctionCall = Keyword(\"int\") + ident(\"name\") + \"(\" + arglist(\"args\") + \")\" + \";\"\n\nfor fn, s, e in functionCall.scanString(testdata):\n    print(fn.name)\n    for a in fn.args:\n        print(\" - %(name)s (%(type)s)\" % a)\n", "examples/position.py": "from pyparsing import *\n\ntext = \"\"\"Lorem ipsum dolor sit amet, consectetur adipisicing\nelit, sed do eiusmod tempor incididunt ut labore et dolore magna\naliqua. Ut enim ad minim veniam, quis nostrud exercitation\nullamco laboris nisi ut aliquip ex ea commodo consequat. Duis\naute irure dolor in reprehenderit in voluptate velit esse cillum\ndolore eu fugiat nulla pariatur. Excepteur sint occaecat\ncupidatat non proident, sunt in culpa qui officia deserunt\nmollit anim id est laborum\"\"\"\n\n# find all words beginning with a vowel\nvowels = \"aeiouAEIOU\"\ninitialVowelWord = Word(vowels, alphas)\n\n# Unfortunately, searchString will advance character by character through\n# the input text, so it will detect that the initial \"Lorem\" is not an\n# initialVowelWord, but then it will test \"orem\" and think that it is. So\n# we need to add a do-nothing term that will match the words that start with\n# consonants, but we will just throw them away when we match them. The key is\n# that, in having been matched, the parser will skip over them entirely when\n# looking for initialVowelWords.\nconsonants = \"\".join(c for c in alphas if c not in vowels)\ninitialConsWord = Word(consonants, alphas).suppress()\n\n# using scanString to locate where tokens are matched\nfor t, start, end in (initialConsWord | initialVowelWord).scanString(text):\n    if t:\n        print(start, \":\", t[0])\n\n# add parse action to annotate the parsed tokens with their location in the\n# input string\ndef addLocnToTokens(s, l, t):\n    t[\"locn\"] = l\n    t[\"word\"] = t[0]\n\n\ninitialVowelWord.setParseAction(addLocnToTokens)\n\nfor ivowelInfo in (initialConsWord | initialVowelWord).searchString(text):\n    if not ivowelInfo:\n        continue\n    print(ivowelInfo.locn, \":\", ivowelInfo.word)\n\n\n# alternative - add an Empty that will save the current location\ndef location(name):\n    return Empty().setParseAction(lambda s, l, t: t.__setitem__(name, l))\n\n\nlocateInitialVowels = location(\"locn\") + initialVowelWord(\"word\")\n\n# search through the input text\nfor ivowelInfo in (initialConsWord | locateInitialVowels).searchString(text):\n    if not ivowelInfo:\n        continue\n    print(ivowelInfo.locn, \":\", ivowelInfo.word)\n", "examples/urlExtractorNew.py": "# URL extractor\n# Copyright 2004, Paul McGuire\nfrom collections import Counter\nimport pprint\nfrom urllib.request import urlopen\n\nfrom pyparsing import makeHTMLTags, pyparsing_common as ppc, FollowedBy, trace_parse_action\n\n# Define the pyparsing grammar for a URL, that is:\n#    URLlink ::= <a href= URL>linkText</a>\n#    URL ::= doubleQuotedString | alphanumericWordPath\n# Note that whitespace may appear just about anywhere in the link.  Note also\n# that it is not necessary to explicitly show this in the pyparsing grammar; by default,\n# pyparsing skips over whitespace between tokens.\nlinkOpenTag, linkCloseTag = makeHTMLTags(\"a\")\nlink = linkOpenTag + linkOpenTag.tag_body(\"body\") + linkCloseTag.suppress()\n\n\n# Add a parse action to expand relative URLs\ndef expand_relative_url(t):\n    url = t.href\n    if url.startswith(\"//\"):\n        url = \"https:\" + url\n    elif url.startswith((\"/\", \"?\", \"#\")):\n        url = \"https://www.cnn.com\" + url\n\n    # Put modified URL back into input tokens\n    t[\"href\"] = url\n\n\nlink.add_parse_action(expand_relative_url)\n\n# Go get some HTML with some links in it.\nwith urlopen(\"https://www.cnn.com/\") as serverListPage:\n    htmlText = serverListPage.read().decode()\n\n# scanString is a generator that loops through the input htmlText, and for each\n# match yields the tokens and start and end locations (for this application, we are\n# not interested in the start and end values).\nfor toks, strt, end in link.scanString(htmlText):\n    print(toks.startA.href, \"->\", toks.body)\n\n# Create dictionary with a dict comprehension, assembled from each pair of tokens returned\n# from a matched URL.\nlinks = {toks.body: toks.href for toks, _, _ in link.scanString(htmlText)}\npprint.pprint(links)\n\n# Parse the urls in the links using pyparsing_common.url, and tally up all\n# the different domains in a Counter.\ndomains = Counter()\nfor url in links.values():\n\n    print(url)\n    parsed = ppc.url.parseString(url)\n\n    # print parsed fields for each new url\n    if parsed.host not in domains:\n        print(parsed.dump())\n        print()\n\n    # update domain counter\n    domains[parsed.host] += 1\n\n\n# Print out a little table of all the domains in the urls\nmax_domain_len = max(len(d) for d in domains)\nprint()\nprint(\"{:{}s}  {}\".format(\"Domain\", max_domain_len, \"Count\"))\nprint(\"{:=<{}}  {:=<5}\".format(\"\", max_domain_len, \"\"))\n\nfor domain, count in domains.most_common():\n    print(\"{:{}s}  {:5d}\".format(domain, max_domain_len, count))\n", "examples/stackish.py": "# stackish.py\n#\n# Stackish is a data representation syntax, similar to JSON or YAML.  For more info on\n# stackish, see http://www.savingtheinternetwithhate.com/stackish.html\n#\n# Copyright 2008, Paul McGuire\n#\n\n\"\"\"\nNUMBER A simple integer type that's just any series of digits.\nFLOAT A simple floating point type.\nSTRING A string is double quotes with anything inside that's not a \" or\n    newline character. You can include \\n and \\\" to include these\n    characters.\nMARK Marks a point in the stack that demarcates the boundary for a nested\n    group.\nWORD Marks the root node of a group, with the other end being the nearest\n    MARK.\nGROUP Acts as the root node of an anonymous group.\nATTRIBUTE Assigns an attribute name to the previously processed node.\n    This means that just about anything can be an attribute, unlike in XML.\nBLOB A BLOB is unique to Stackish and allows you to record any content\n    (even binary content) inside the structure. This is done by pre-\n    sizing the data with the NUMBER similar to Dan Bernstein's netstrings\n    setup.\nSPACE White space is basically ignored. This is interesting because since\n    Stackish is serialized consistently this means you can use \\n as the\n    separation character and perform reasonable diffs on two structures.\n\"\"\"\n\nimport pyparsing as pp\nppc = pp.common\n\nMARK, UNMARK, AT, COLON, QUOTE = pp.Suppress.using_each(\"[]@:'\")\n\nNUMBER = ppc.integer()\nFLOAT = ppc.real()\nSTRING = pp.QuotedString('\"', multiline=True) | pp.QuotedString(\"'\", multiline=True)\nWORD = pp.DelimitedList(pp.Word(pp.alphas, pp.alphanums + \"_\"), delim=\":\", combine=True)\nATTRIBUTE = pp.Combine(AT + WORD)\n\nstr_body = pp.Forward()\n\n\ndef set_body_length(tokens):\n    str_body << pp.Word(pp.srange(r\"[\\0x00-\\0xffff]\"), exact=int(tokens[0]))\n    return \"\"\n\n\nBLOB = pp.Combine(\n    QUOTE + pp.Word(pp.nums).set_parse_action(set_body_length) + COLON + str_body + QUOTE\n)\n\n\ndef assign_using(s):\n    def assign_pa(tokens):\n        if s in tokens:\n            tokens[tokens[s]] = tokens[0]\n            del tokens[s]\n\n    return assign_pa\n\n\nitem = pp.Forward()\n\nGROUP = (\n    MARK\n    + pp.Group(\n        (item + ATTRIBUTE[0, 1](\"attr\")).set_parse_action(assign_using(\"attr\"))[...]\n    )\n    + (WORD(\"name\") | UNMARK)\n).set_parse_action(assign_using(\"name\"))\nitem <<= FLOAT | NUMBER | STRING | BLOB | GROUP\n\nif __name__ == '__main__':\n\n    success, _ = item.run_tests(\n        \"\"\"\\\n        [ '10:1234567890' @name 25 @age +0.45 @percentage person:zed\n        [ [ \"hello\" 1 child root\n        [ \"child\" [ 200 '4:like' \"I\" \"hello\" things root\n        [ [ \"data\" [ 2 1 ] @numbers child root\n        [ [ 1 2 3 ] @test 4 5 6 root\n        \"\"\"\n    )\n\n    assert success\n", "examples/ebnftest.py": "#\n# ebnftest.py\n#\n# Test script for ebnf.py\n#\n# Submitted 2004 by Seo Sanghyeon\n#\nprint(\"Importing pyparsing...\")\nfrom pyparsing import *\n\nprint(\"Constructing EBNF parser with pyparsing...\")\nimport ebnf\n\n\ngrammar = \"\"\"\nsyntax = (syntax_rule), {(syntax_rule)};\nsyntax_rule = meta_identifier, '=', definitions_list, ';';\ndefinitions_list = single_definition, {'|', single_definition};\nsingle_definition = syntactic_term, {',', syntactic_term};\nsyntactic_term = syntactic_factor,['-', syntactic_factor];\nsyntactic_factor = [integer, '*'], syntactic_primary;\nsyntactic_primary = optional_sequence | repeated_sequence |\n  grouped_sequence | meta_identifier | terminal_string;\noptional_sequence = '[', definitions_list, ']';\nrepeated_sequence = '{', definitions_list, '}';\ngrouped_sequence = '(', definitions_list, ')';\n(*\nterminal_string = \"'\", character - \"'\", {character - \"'\"}, \"'\" |\n  '\"', character - '\"', {character - '\"'}, '\"';\n meta_identifier = letter, {letter | digit};\ninteger = digit, {digit};\n*)\n\"\"\"\n\ntable = {}\n# ~ table['character'] = Word(printables, exact=1)\n# ~ table['letter'] = Word(alphas + '_', exact=1)\n# ~ table['digit'] = Word(nums, exact=1)\ntable[\"terminal_string\"] = sglQuotedString\ntable[\"meta_identifier\"] = Word(alphas + \"_\", alphas + \"_\" + nums)\ntable[\"integer\"] = Word(nums)\n\nprint(\"Parsing EBNF grammar with EBNF parser...\")\nparsers = ebnf.parse(grammar, table)\nebnf_parser = parsers[\"syntax\"]\n\ncommentcharcount = 0\ncommentlocs = set()\n\n\ndef tallyCommentChars(s, l, t):\n    global commentcharcount, commentlocs\n    # only count this comment if we haven't seen it before\n    if l not in commentlocs:\n        charCount = len(t[0]) - len(list(filter(str.isspace, t[0])))\n        commentcharcount += charCount\n        commentlocs.add(l)\n    return l, t\n\n\n# ordinarily, these lines wouldn't be necessary, but we are doing extra stuff with the comment expression\nebnf.ebnfComment.setParseAction(tallyCommentChars)\nebnf_parser.ignore(ebnf.ebnfComment)\n\nprint(\"Parsing EBNF grammar with generated EBNF parser...\\n\")\nparsed_chars = ebnf_parser.parseString(grammar)\nparsed_char_len = len(parsed_chars)\n\nprint(\"],\\n\".join(str(parsed_chars.asList()).split(\"],\")))\n\n# ~ grammar_length = len(grammar) - len(filter(str.isspace, grammar))-commentcharcount\n\n# ~ assert parsed_char_len == grammar_length\n\nprint(\"Ok!\")\n", "examples/numerics.py": "#\n# numerics.py\n#\n# Examples of parsing real and integers using various grouping and\n# decimal point characters, varying by locale.\n#\n# Copyright 2016, Paul McGuire\n#\n# Format samples from https://docs.oracle.com/cd/E19455-01/806-0169/overview-9/index.html\n#\ntests = \"\"\"\\\n# Canadian (English and French)\n4 294 967 295,000\n\n# Danish\n4 294 967 295,000\n\n# Finnish\n4 294 967 295,000\n\n# French\n4 294 967 295,000\n\n# German\n4 294 967 295,000\n\n# Italian\n4.294.967.295,000\n\n# Norwegian\n4.294.967.295,000\n\n# Spanish\n4.294.967.295,000\n\n# Swedish\n4 294 967 295,000\n\n# GB-English\n4,294,967,295.000\n\n# US-English\n4,294,967,295.000\n\n# Thai\n4,294,967,295.000\n\"\"\"\n\nfrom pyparsing import Regex\n\ncomma_decimal = Regex(r\"\\d{1,2}(([ .])\\d\\d\\d(\\2\\d\\d\\d)*)?,\\d*\")\ncomma_decimal.add_parse_action(\n    lambda t: float(t[0].replace(\" \", \"\").replace(\".\", \"\").replace(\",\", \".\"))\n)\n\ndot_decimal = Regex(r\"\\d{1,2}(([ ,])\\d\\d\\d(\\2\\d\\d\\d)*)?\\.\\d*\")\ndot_decimal.add_parse_action(lambda t: float(t[0].replace(\" \", \"\").replace(\",\", \"\")))\n\ndecimal = comma_decimal ^ dot_decimal\ndecimal.run_tests(tests, parse_all=True)\n\ngrouped_integer = Regex(r\"\\d{1,2}(([ .,])\\d\\d\\d(\\2\\d\\d\\d)*)?\")\ngrouped_integer.add_parse_action(\n    lambda t: int(t[0].replace(\" \", \"\").replace(\",\", \"\").replace(\".\", \"\"))\n)\ngrouped_integer.run_tests(tests, parse_all=False)\n", "examples/macro_expander.py": "# macro_expander.py\n#\n# Example pyparsing program for performing macro expansion, similar to\n# the C pre-processor.  This program is not as fully-featured, simply\n# processing macros of the form:\n#     #def xxx yyyyy\n# and replacing xxx with yyyyy in the rest of the input string.  Macros\n# can also be composed using other macros, such as\n#     #def zzz xxx+1\n# Since xxx was previously defined as yyyyy, then zzz will be replaced\n# with yyyyy+1.\n#\n# Copyright 2007, 2023 by Paul McGuire\n#\nimport pyparsing as pp\n\n# define the structure of a macro definition (the empty term is used\n# to advance to the next non-whitespace character)\nidentifier = pp.common.identifier\nmacro_def = \"#def\" + identifier(\"macro\") + pp.empty + pp.restOfLine(\"value\")\n\n# define a placeholder for defined macros - initially nothing\nmacro_expr = pp.Forward()\nmacro_expr << pp.NoMatch()\n\n# global dictionary for macro definitions\nmacros = {}\n\n\n# parse action for macro definitions\ndef process_macro_defn(t):\n    macro_val = macro_expander.transform_string(t.value)\n    macros[t.macro] = macro_val\n    macro_expr << pp.MatchFirst(map(pp.Keyword, macros))\n    return f\"#def {t.macro} {macro_val}\"\n\n\n# parse action to replace macro references with their respective definition\ndef process_macro_ref(t):\n    return macros[t[0]]\n\n\n# attach parse actions to expressions\nmacro_expr.set_parse_action(process_macro_ref)\nmacro_def.set_parse_action(process_macro_defn)\n\n# define pattern for scanning through the input string\nmacro_expander = macro_expr | macro_def\n\n\n# test macro substitution using transformString\ntest_string = \"\"\"\n    #def A 100\n    #def ALEN A+1\n\n    char Astring[ALEN];\n    char AA[A];\n    typedef char[ALEN] Acharbuf;\n    \"\"\"\n\nprint(test_string)\nprint(\"-\" * 40)\nprint(macro_expander.transform_string(test_string))\nprint(macros)\n", "examples/sexpParser.py": "# sexpParser.py\n#\n# Demonstration of the pyparsing module, implementing a simple S-expression\n# parser.\n#\n# Updates:\n#  November, 2011 - fixed errors in precedence of alternatives in simpleString;\n#      fixed exception raised in verifyLen to properly signal the input string\n#      and exception location so that markInputline works correctly; fixed\n#      definition of decimal to accept a single '0' and optional leading '-'\n#      sign; updated tests to improve parser coverage\n#\n# Copyright 2007-2011, by Paul McGuire\n#\n\"\"\"\nBNF reference: http://theory.lcs.mit.edu/~rivest/sexp.txt\n\n<sexp>    \t:: <string> | <list>\n<string>   \t:: <display>? <simple-string> ;\n<simple-string>\t:: <raw> | <token> | <base-64> | <hexadecimal> |\n                   <quoted-string> ;\n<display>  \t:: \"[\" <simple-string> \"]\" ;\n<raw>      \t:: <decimal> \":\" <bytes> ;\n<decimal>  \t:: <decimal-digit>+ ;\n        -- decimal numbers should have no unnecessary leading zeros\n<bytes>     -- any string of bytes, of the indicated length\n<token>    \t:: <tokenchar>+ ;\n<base-64>  \t:: <decimal>? \"|\" ( <base-64-char> | <whitespace> )* \"|\" ;\n<hexadecimal>   :: \"#\" ( <hex-digit> | <white-space> )* \"#\" ;\n<quoted-string> :: <decimal>? <quoted-string-body>\n<quoted-string-body> :: \"\\\"\" <bytes> \"\\\"\"\n<list>     \t:: \"(\" ( <sexp> | <whitespace> )* \")\" ;\n<whitespace> \t:: <whitespace-char>* ;\n<token-char>  \t:: <alpha> | <decimal-digit> | <simple-punc> ;\n<alpha>       \t:: <upper-case> | <lower-case> | <digit> ;\n<lower-case>  \t:: \"a\" | ... | \"z\" ;\n<upper-case>  \t:: \"A\" | ... | \"Z\" ;\n<decimal-digit> :: \"0\" | ... | \"9\" ;\n<hex-digit>     :: <decimal-digit> | \"A\" | ... | \"F\" | \"a\" | ... | \"f\" ;\n<simple-punc> \t:: \"-\" | \".\" | \"/\" | \"_\" | \":\" | \"*\" | \"+\" | \"=\" ;\n<whitespace-char> :: \" \" | \"\\t\" | \"\\r\" | \"\\n\" ;\n<base-64-char> \t:: <alpha> | <decimal-digit> | \"+\" | \"/\" | \"=\" ;\n<null>        \t:: \"\" ;\n\"\"\"\n\nimport pyparsing as pp\nfrom base64 import b64decode\n\n\ndef verify_length(s, l, t):\n    t = t[0]\n    if t.len is not None:\n        t1len = len(t[1])\n        if t1len != t.len:\n            raise pp.ParseFatalException(\n                s, l, \"invalid data of length {}, expected {}\".format(t1len, t.len)\n            )\n    return t[1]\n\n\n# define punctuation literals\nLPAR, RPAR, LBRK, RBRK, LBRC, RBRC, VBAR, COLON = (\n    pp.Suppress(c).setName(c) for c in \"()[]{}|:\"\n)\n\ndecimal = pp.Regex(r\"-?0|[1-9]\\d*\").setParseAction(lambda t: int(t[0]))\nhexadecimal = (\"#\" + pp.Word(pp.hexnums)[1, ...] + \"#\").setParseAction(\n    lambda t: int(\"\".join(t[1:-1]), 16)\n)\nbytes = pp.Word(pp.printables)\nraw = pp.Group(decimal(\"len\") + COLON + bytes).setParseAction(verify_length)\nbase64_ = pp.Group(\n    pp.Optional(decimal | hexadecimal, default=None)(\"len\")\n    + VBAR\n    + pp.Word(pp.alphanums + \"+/=\")[1, ...].setParseAction(\n        lambda t: b64decode(\"\".join(t))\n    )\n    + VBAR\n).setParseAction(verify_length)\n\nreal = pp.Regex(r\"[+-]?\\d+\\.\\d*([eE][+-]?\\d+)?\").setParseAction(\n    lambda tokens: float(tokens[0])\n)\ntoken = pp.Word(pp.alphanums + \"-./_:*+=!<>\")\nqString = pp.Group(\n    pp.Optional(decimal, default=None)(\"len\")\n    + pp.dblQuotedString.setParseAction(pp.removeQuotes)\n).setParseAction(verify_length)\n\nsimpleString = real | base64_ | raw | decimal | token | hexadecimal | qString\n\ndisplay = LBRK + simpleString + RBRK\nstring_ = pp.Optional(display) + simpleString\n\nsexp = pp.Forward()\nsexpList = pp.Group(LPAR + sexp[...] + RPAR)\nsexp <<= string_ | sexpList\n\n\ndef main():\n    #  Test data\n\n    test00 = \"\"\"(snicker \"abc\" (#03# |YWJj|))\"\"\"\n    test01 = \"\"\"(certificate\n     (issuer\n      (name\n       (public-key\n        rsa-with-md5\n        (e 15 |NFGq/E3wh9f4rJIQVXhS|)\n        (n |d738/4ghP9rFZ0gAIYZ5q9y6iskDJwASi5rEQpEQq8ZyMZeIZzIAR2I5iGE=|))\n       aid-committee))\n     (subject\n      (ref\n       (public-key\n        rsa-with-md5\n        (e |NFGq/E3wh9f4rJIQVXhS|)\n        (n |d738/4ghP9rFZ0gAIYZ5q9y6iskDJwASi5rEQpEQq8ZyMZeIZzIAR2I5iGE=|))\n       tom\n       mother))\n     (not-before \"1997-01-01_09:00:00\")\n     (not-after \"1998-01-01_09:00:00\")\n     (tag\n      (spend (account \"12345678\") (* numeric range \"1\" \"1000\"))))\n    \"\"\"\n    test02 = \"\"\"(lambda (x) (* x x))\"\"\"\n    test03 = \"\"\"(def length\n       (lambda (x)\n          (cond\n             ((not x) 0)\n             (   t   (+ 1 (length (cdr x))))\n          )\n       )\n    )\n    \"\"\"\n    test04 = \"\"\"(2:XX \"abc\" (#03# |YWJj|))\"\"\"\n    test05 = \"\"\"(if (is (window_name) \"XMMS\") (set_workspace 2))\"\"\"\n    test06 = \"\"\"(if\n      (and\n        (is (application_name) \"Firefox\")\n        (or\n          (contains (window_name) \"Enter name of file to save to\")\n          (contains (window_name) \"Save As\")\n          (contains (window_name) \"Save Image\")\n          ()\n        )\n      )\n      (geometry \"+140+122\")\n    )\n    \"\"\"\n    test07 = \"\"\"(defun factorial (x)\n       (if (zerop x) 1\n           (* x (factorial (- x 1)))))\n           \"\"\"\n    test51 = \"\"\"(2:XX \"abc\" (#03# |YWJj|))\"\"\"\n    test51error = \"\"\"(3:XX \"abc\" (#03# |YWJj|))\"\"\"\n\n    test52 = \"\"\"\n        (and\n          (or (> uid 1000)\n              (!= gid 20)\n          )\n          (> quota 5.0e+03)\n        )\n        \"\"\"\n\n    # Run tests\n    local_vars = sorted(locals().items())\n    alltests = [\n        test_fn for testname, test_fn in local_vars if testname.startswith(\"test\")\n    ]\n\n    sexp.runTests(alltests, fullDump=False)\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/dhcpd_leases_parser.py": "#\n# dhcpd_leases_parser.py\n#\n# Copyright 2008, Paul McGuire\n#\n# Sample parser to parse a dhcpd.leases file to extract leases\n# and lease attributes\n#\n# format ref: http://www.linuxmanpages.com/man5/dhcpd.leases.5.php\n#\n\nsample = r\"\"\"\\\n# All times in this file are in UTC (GMT), not your local timezone.   This is\n# not a bug, so please don't ask about it.   There is no portable way to\n# store leases in the local timezone, so please don't request this as a\n# feature.   If this is inconvenient or confusing to you, we sincerely\n# apologize.   Seriously, though - don't ask.\n# The format of this file is documented in the dhcpd.leases(5) manual page.\n# This lease file was written by isc-dhcp-V3.0.4\n\nlease 192.168.0.250 {\n  starts 3 2008/01/23 17:16:41;\n  ends 6 2008/02/02 17:16:41;\n  tstp 6 2008/02/02 17:16:41;\n  binding state free;\n  hardware ethernet 00:17:f2:9b:d8:19;\n  uid \"\\001\\000\\027\\362\\233\\330\\031\";\n}\nlease 192.168.0.198 {\n  starts 1 2008/02/04 13:46:55;\n  ends never;\n  tstp 1 2008/02/04 17:04:14;\n  binding state free;\n  hardware ethernet 00:13:72:d3:3b:98;\n  uid \"\\001\\000\\023r\\323;\\230\";\n}\nlease 192.168.0.239 {\n  starts 3 2008/02/06 12:12:03;\n  ends 4 2008/02/07 12:12:03;\n  tstp 4 2008/02/07 12:12:03;\n  binding state free;\n  hardware ethernet 00:1d:09:65:93:26;\n}\n\"\"\"\n\nfrom pyparsing import *\nimport datetime, time\n\nLBRACE, RBRACE, SEMI, QUOTE = map(Suppress, '{};\"')\nipAddress = Combine(Word(nums) + (\".\" + Word(nums)) * 3)\nhexint = Word(hexnums, exact=2)\nmacAddress = Combine(hexint + (\":\" + hexint) * 5)\nhdwType = Word(alphanums)\n\nyyyymmdd = Combine(\n    (Word(nums, exact=4) | Word(nums, exact=2)) + (\"/\" + Word(nums, exact=2)) * 2\n)\nhhmmss = Combine(Word(nums, exact=2) + (\":\" + Word(nums, exact=2)) * 2)\ndateRef = oneOf(list(\"0123456\"))(\"weekday\") + yyyymmdd(\"date\") + hhmmss(\"time\")\n\n\ndef utcToLocalTime(tokens):\n    utctime = datetime.datetime.strptime(\n        \"%(date)s %(time)s\" % tokens, \"%Y/%m/%d %H:%M:%S\"\n    )\n    localtime = utctime - datetime.timedelta(0, time.timezone, 0)\n    tokens[\"utcdate\"], tokens[\"utctime\"] = tokens[\"date\"], tokens[\"time\"]\n    tokens[\"localdate\"], tokens[\"localtime\"] = str(localtime).split()\n    del tokens[\"date\"]\n    del tokens[\"time\"]\n\n\ndateRef.setParseAction(utcToLocalTime)\n\nstartsStmt = \"starts\" + dateRef + SEMI\nendsStmt = \"ends\" + (dateRef | \"never\") + SEMI\ntstpStmt = \"tstp\" + dateRef + SEMI\ntsfpStmt = \"tsfp\" + dateRef + SEMI\nhdwStmt = \"hardware\" + hdwType(\"type\") + macAddress(\"mac\") + SEMI\nuidStmt = \"uid\" + QuotedString('\"')(\"uid\") + SEMI\nbindingStmt = \"binding\" + Word(alphanums) + Word(alphanums) + SEMI\n\nleaseStatement = (\n    startsStmt | endsStmt | tstpStmt | tsfpStmt | hdwStmt | uidStmt | bindingStmt\n)\nleaseDef = (\n    \"lease\"\n    + ipAddress(\"ipaddress\")\n    + LBRACE\n    + Dict(ZeroOrMore(Group(leaseStatement)))\n    + RBRACE\n)\n\nfor lease in leaseDef.searchString(sample):\n    print(lease.dump())\n    print(lease.ipaddress, \"->\", lease.hardware.mac)\n    print()\n", "examples/partial_gene_match.py": "# partial_gene_match.py\n#\n#  Example showing how to use the CloseMatch class, to find strings in a gene with up to 'n' mismatches\n#\nimport pyparsing as pp\n\nfrom urllib.request import urlopen\n\n# read in a bunch of genomic data\ndata_url = \"http://toxodb.org/common/downloads/release-6.0/Tgondii/TgondiiApicoplastORFsNAs_ToxoDB-6.0.fasta\"\nwith urlopen(data_url) as datafile:\n    fastasrc = datafile.read().decode()\n\n# define parser to extract gene definitions\n\"\"\"\nSample header:\n>NC_001799-6-2978-2778 | organism=Toxoplasma_gondii_RH | location=NC_001799:2778-2978(-) | length=201\n\"\"\"\ninteger = pp.pyparsing_common.integer\ngenebit = pp.Group(\n    \">\"\n    + pp.Word(pp.alphanums.upper() + \"-_\")(\"gene_id\")\n    + \"|\"\n    + pp.Word(pp.printables)(\"organism\")\n    + \"|\"\n    + pp.Word(pp.printables)(\"location\")\n    + \"|\"\n    + \"length=\"\n    + integer(\"gene_len\")\n    + pp.LineEnd()\n    + pp.Word(\"ACGTN\")[1, ...].addParseAction(\"\".join)(\"gene\")\n)\n\n# read gene data from .fasta file - takes just a few seconds\n# An important aspect of this parsing process is the reassembly of all the separate lines of the\n# gene into a single scannable string. Just searching the raw .fasta file could overlook matches\n# if the match is broken up across separate lines. The parse action in the genebit parser does\n# this reassembly work.\ngenedata = genebit[1, ...].parseString(fastasrc)\n\n# using the genedata extracted above, look for close matches of a gene sequence\nsearchseq = pp.CloseMatch(\"TTAAATCTAGAAGAT\", 3)\n\nfor g in genedata:\n    show_header = True\n    # scan for close matches, list out found strings, and mark mismatch locations\n    for t, startLoc, endLoc in searchseq.scanString(g.gene, overlap=True):\n        if show_header:\n            # only need to show the header once\n            print(f\"{g.gene_id}/{g.organism}/{g.location} ({g.gene_len})\")\n            print(\"-\" * 24)\n            show_header = False\n\n        matched = t[0]\n        mismatches = t[\"mismatches\"]\n        print(\"MATCH:\", searchseq.match_string)\n        print(\"FOUND:\", matched)\n        if mismatches:\n            print(\n                \"      \",\n                \"\".join(\n                    \"*\" if i in mismatches else \" \"\n                    for i, c in enumerate(searchseq.match_string)\n                ),\n            )\n        else:\n            print(\"<exact match>\")\n        print(\"at location\", startLoc)\n        print()\n", "examples/nested.py": "#\n#  nested.py\n#  Copyright, 2007 - Paul McGuire\n#\n#  Simple example of using nestedExpr to define expressions using\n#  paired delimiters for grouping lists and sublists\n#\n\nfrom pyparsing import *\n\ndata = \"\"\"\n{\n     { item1 \"item with } in it\" }\n     {\n      {item2a item2b }\n      {item3}\n     }\n\n}\n\"\"\"\n\n# use {}'s for nested lists\nnestedItems = nestedExpr(\"{\", \"}\")\nprint((nestedItems + stringEnd).parseString(data).asList())\n\n# use default delimiters of ()'s\nmathExpr = nestedExpr()\nprint(mathExpr.parseString(\"((( ax + by)*C) *(Z | (E^F) & D))\"))\n", "examples/simpleSQL.py": "# simpleSQL.py\n#\n# simple demo of using the parsing library to do simple-minded SQL parsing\n# could be extended to include where clauses etc.\n#\n# Copyright (c) 2003,2016, Paul McGuire\n#\nfrom pyparsing import (\n    Word,\n    delimitedList,\n    Optional,\n    Group,\n    alphas,\n    alphanums,\n    Forward,\n    oneOf,\n    quotedString,\n    infixNotation,\n    opAssoc,\n    restOfLine,\n    CaselessKeyword,\n    ParserElement,\n    pyparsing_common as ppc,\n)\n\nParserElement.enablePackrat()\n\n# define SQL tokens\nselectStmt = Forward()\nSELECT, FROM, WHERE, AND, OR, IN, IS, NOT, NULL = map(\n    CaselessKeyword, \"select from where and or in is not null\".split()\n)\nNOT_NULL = NOT + NULL\n\nident = Word(alphas, alphanums + \"_$\").setName(\"identifier\")\ncolumnName = delimitedList(ident, \".\", combine=True).setName(\"column name\")\ncolumnName.addParseAction(ppc.upcaseTokens)\ncolumnNameList = Group(delimitedList(columnName).setName(\"column_list\"))\ntableName = delimitedList(ident, \".\", combine=True).setName(\"table name\")\ntableName.addParseAction(ppc.upcaseTokens)\ntableNameList = Group(delimitedList(tableName).setName(\"table_list\"))\n\nbinop = oneOf(\"= != < > >= <= eq ne lt le gt ge\", caseless=True).setName(\"binop\")\nrealNum = ppc.real().setName(\"real number\")\nintNum = ppc.signed_integer()\n\ncolumnRval = (\n    realNum | intNum | quotedString | columnName\n).setName(\"column_rvalue\")  # need to add support for alg expressions\nwhereCondition = Group(\n    (columnName + binop + columnRval)\n    | (columnName + IN + Group(\"(\" + delimitedList(columnRval).setName(\"in_values_list\") + \")\"))\n    | (columnName + IN + Group(\"(\" + selectStmt + \")\"))\n    | (columnName + IS + (NULL | NOT_NULL))\n).setName(\"where_condition\")\n\nwhereExpression = infixNotation(\n    whereCondition,\n    [\n        (NOT, 1, opAssoc.RIGHT),\n        (AND, 2, opAssoc.LEFT),\n        (OR, 2, opAssoc.LEFT),\n    ],\n).setName(\"where_expression\")\n\n# define the grammar\nselectStmt <<= (\n    SELECT\n    + (\"*\" | columnNameList)(\"columns\")\n    + FROM\n    + tableNameList(\"tables\")\n    + Optional(Group(WHERE + whereExpression), \"\")(\"where\")\n).setName(\"select_statement\")\n\nsimpleSQL = selectStmt\n\n# define Oracle comment format, and ignore them\noracleSqlComment = \"--\" + restOfLine\nsimpleSQL.ignore(oracleSqlComment)\n\nif __name__ == \"__main__\":\n    simpleSQL.runTests(\n        \"\"\"\\\n\n        # multiple tables\n        SELECT * from XYZZY, ABC\n\n        # dotted table name\n        select * from SYS.XYZZY\n\n        Select A from Sys.dual\n\n        Select A,B,C from Sys.dual\n\n        Select A, B, C from Sys.dual, Table2\n\n        # FAIL - invalid SELECT keyword\n        Xelect A, B, C from Sys.dual\n\n        # FAIL - invalid FROM keyword\n        Select A, B, C frox Sys.dual\n\n        # FAIL - incomplete statement\n        Select\n\n        # FAIL - incomplete statement\n        Select * from\n\n        # FAIL - invalid column\n        Select &&& frox Sys.dual\n\n        # where clause\n        Select A from Sys.dual where a in ('RED','GREEN','BLUE')\n\n        # compound where clause\n        Select A from Sys.dual where a in ('RED','GREEN','BLUE') and b in (10,20,30)\n\n        # where clause with comparison operator\n        Select A,b from table1,table2 where table1.id eq table2.id\n        \"\"\"\n    )\n", "examples/simpleArith.py": "#\n# simpleArith.py\n#\n# Example of defining an arithmetic expression parser using\n# the infixNotation helper method in pyparsing.\n#\n# Copyright 2006, by Paul McGuire\n#\nimport sys\nfrom pyparsing import *\n\nppc = pyparsing_common\n\nParserElement.enablePackrat()\nsys.setrecursionlimit(3000)\n\ninteger = ppc.integer\nvariable = Word(alphas, exact=1)\noperand = integer | variable\n\nexpop = Literal(\"^\")\nsignop = oneOf(\"+ -\")\nmultop = oneOf(\"* /\")\nplusop = oneOf(\"+ -\")\nfactop = Literal(\"!\")\n\n# To use the infixNotation helper:\n#   1.  Define the \"atom\" operand term of the grammar.\n#       For this simple grammar, the smallest operand is either\n#       and integer or a variable.  This will be the first argument\n#       to the infixNotation method.\n#   2.  Define a list of tuples for each level of operator\n#       precedence.  Each tuple is of the form\n#       (opExpr, numTerms, rightLeftAssoc, parseAction), where\n#       - opExpr is the pyparsing expression for the operator;\n#          may also be a string, which will be converted to a Literal\n#       - numTerms is the number of terms for this operator (must\n#          be 1 or 2)\n#       - rightLeftAssoc is the indicator whether the operator is\n#          right or left associative, using the pyparsing-defined\n#          constants opAssoc.RIGHT and opAssoc.LEFT.\n#       - parseAction is the parse action to be associated with\n#          expressions matching this operator expression (the\n#          parse action tuple member may be omitted)\n#   3.  Call infixNotation passing the operand expression and\n#       the operator precedence list, and save the returned value\n#       as the generated pyparsing expression.  You can then use\n#       this expression to parse input strings, or incorporate it\n#       into a larger, more complex grammar.\n#\nexpr = infixNotation(\n    operand,\n    [\n        (\"!\", 1, opAssoc.LEFT),\n        (\"^\", 2, opAssoc.RIGHT),\n        (signop, 1, opAssoc.RIGHT),\n        (multop, 2, opAssoc.LEFT),\n        (plusop, 2, opAssoc.LEFT),\n    ],\n)\n\ntest = [\n    \"9 + 2 + 3\",\n    \"9 + 2 * 3\",\n    \"(9 + 2) * 3\",\n    \"(9 + -2) * 3\",\n    \"(9 + -2) * 3^2^2\",\n    \"(9! + -2) * 3^2^2\",\n    \"M*X + B\",\n    \"M*(X + B)\",\n    \"1+2*-3^4*5+-+-6\",\n    \"(a + b)\",\n    \"((a + b))\",\n    \"(((a + b)))\",\n    \"((((a + b))))\",\n    \"((((((((((((((a + b))))))))))))))\",\n]\nfor t in test:\n    print(t)\n    print(expr.parseString(t))\n    print(\"\")\n", "examples/builtin_parse_action_demo.py": "#\n#  builtin_parse_action_demo.py\n#  Copyright, 2012 - Paul McGuire\n#\n#  Simple example of using builtin functions as parse actions.\n#\n\nimport pyparsing as pp\nppc = pp.common\n\n# make an expression that will match a list of ints (which\n# will be converted to actual ints by the parse action attached\n# to integer)\nnums = ppc.integer[...]\n\n\ntest = \"2 54 34 2 211 66 43 2 0\"\nprint(test)\n\n# try each of these builtins as parse actions\nfor fn in (sum, max, min, len, sorted, reversed, list, tuple, set, any, all):\n    if fn is reversed:\n        # reversed returns an iterator, we really want to show the list of items\n        fn = lambda x: list(reversed(x))\n\n    # show how each builtin works as a free-standing parse action\n    print(fn.__name__, nums.set_parse_action(fn).parse_string(test))\n", "examples/matchPreviousDemo.py": "#\n# matchPreviousDemo.py\n#\n\nfrom pyparsing import *\n\nsrc = \"\"\"\nclass a\n...\nend a;\n\nclass b\n...\nend b;\n\nclass c\n...\nend d;\"\"\"\n\n\nidentifier = Word(alphas)\n\nclassIdent = identifier(\"classname\")  # note that this also makes a copy of identifier\nclassHead = \"class\" + classIdent\nclassBody = \"...\"\nclassEnd = \"end\" + matchPreviousLiteral(classIdent) + \";\"\nclassDefn = classHead + classBody + classEnd\n\n# use this form to catch syntax error\n# classDefn = classHead + classBody - classEnd\n\nfor tokens in classDefn.searchString(src):\n    print(tokens.classname)\n", "examples/bf.py": "# bf.py\n#\n# Brainf*ck interpreter demo\n#\n# BF instructions (symbols):\n#   + - increment value at the current pointer\n#   - - decrement value at the current pointer\n#   > - increment pointer\n#   < - decrement pointer\n#   , - input new byte value, store at the current pointer\n#   . - output the byte at the current pointer\n#   [] - evaluate value at current pointer, if nonzero, execute all statements in []'s and repeat\n#\nimport pyparsing as pp\n\n# define the basic parser\n\n# define Literals for each symbol in the BF langauge\nPLUS, MINUS, GT, LT, INP, OUT, LBRACK, RBRACK = pp.Literal.using_each(\"+-<>,.[]\")\n\n# use a pyparsing Forward for the recursive definition of an instruction that can\n# itself contain instructions\ninstruction_expr = pp.Forward().set_name(\"instruction\")\n\n# define a LOOP expression for the instructions enclosed in brackets; use a\n# pyparsing Group to wrap the instructions in a sub-list\nLOOP = pp.Group(LBRACK + instruction_expr[...] + RBRACK)\n\n# use '<<=' operator to insert expression definition into existing Forward\ninstruction_expr <<= PLUS | MINUS | GT | LT | INP | OUT | LOOP\n\nprogram_expr = instruction_expr[...].set_name(\"program\")\n\n# ignore everything that is not a BF symbol\nignore_chars = pp.Word(pp.printables, exclude_chars=\"+-<>,.[]\")\nprogram_expr.ignore(ignore_chars)\n\n\nclass BFEngine:\n    \"\"\"\n    Brainf*ck execution environment, with a memory array and pointer.\n    \"\"\"\n    def __init__(self, memory_size: int = 1024):\n        self._ptr = 0\n        self._memory_size = memory_size\n        self._memory = [0] * self._memory_size\n\n    @property\n    def ptr(self):\n        return self._ptr\n\n    @ptr.setter\n    def ptr(self, value):\n        self._ptr = value % self._memory_size\n\n    @property\n    def at_ptr(self):\n        return self._memory[self._ptr]\n\n    @at_ptr.setter\n    def at_ptr(self, value):\n        self._memory[self._ptr] = value % 256\n\n    def output_value_at_ptr(self):\n        print(chr(self.at_ptr), end=\"\")\n\n    def input_value(self):\n        input_char = input() or \"\\0\"\n        self.at_ptr = ord(input_char[0])\n\n    def reset(self):\n        self._ptr = 0\n        self._memory[:] = [0] * self._memory_size\n\n    def dump_state(self):\n        for i in range(30):\n            print(f\"{self._memory[i]:3d} \", end=\"\")\n        print()\n\n        if self.ptr < 30:\n            print(f\" {'    ' * self.ptr}^\")\n\n\n# define executable classes for each instruction\n\nclass Instruction:\n    \"\"\"Abstract class for all instruction classes to implement.\"\"\"\n    def __init__(self, tokens):\n        self.tokens = tokens\n\n    def execute(self, bf_engine: BFEngine):\n        raise NotImplementedError()\n\n\nclass IncrPtr(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.ptr += 1\n\n\nclass DecrPtr(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.ptr -= 1\n\n\nclass IncrPtrValue(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.at_ptr += 1\n\n\nclass DecrPtrValue(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.at_ptr -= 1\n\n\nclass OutputPtrValue(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.output_value_at_ptr()\n\n\nclass InputPtrValue(Instruction):\n    def execute(self, bf_engine: BFEngine):\n        bf_engine.input_value()\n\n\nclass RunInstructionLoop(Instruction):\n    def __init__(self, tokens):\n        super().__init__(tokens)\n        self.instructions = self.tokens[0][1:-1]\n\n    def execute(self, bf_engine: BFEngine):\n        while bf_engine.at_ptr:\n            for i in self.instructions:\n                i.execute(bf_engine)\n\n\n# add parse actions to all BF instruction expressions\nPLUS.add_parse_action(IncrPtrValue)\nMINUS.add_parse_action(DecrPtrValue)\nGT.add_parse_action(IncrPtr)\nLT.add_parse_action(DecrPtr)\nOUT.add_parse_action(OutputPtrValue)\nINP.add_parse_action(InputPtrValue)\nLOOP.add_parse_action(RunInstructionLoop)\n\n\n@program_expr.add_parse_action\ndef run_program(tokens):\n    bf = BFEngine()\n    for t in tokens:\n        t.execute(bf)\n    print()\n\n\n# generate railroad diagram\nprogram_expr.create_diagram(\"bf.html\")\n\n# execute an example BF program\nhw = \"+[-->-[>>+>-----<<]<--<---]>-.>>>+.>>..+++[.>]<<<<.+++.------.<<-.>>>>+.\"\nprogram_expr.parse_string(hw)\n", "examples/hola_mundo.py": "# escrito por Marco Alfonso, 2004 Noviembre\n\n# importamos los s\u00edmbolos requeridos desde el m\u00f3dulo\nfrom pyparsing import (\n    Word,\n    one_of,\n    nums,\n    Group,\n    OneOrMore,\n    Opt,\n    pyparsing_unicode as ppu,\n)\n\n# usamos las letras en latin1, que incluye las como '\u00f1', '\u00e1', '\u00e9', etc.\nalphas = ppu.Latin1.alphas\n\n# Aqui decimos que la gramatica \"saludo\" DEBE contener\n# una palabra compuesta de caracteres alfanumericos\n# (Word(alphas)) mas una ',' mas otra palabra alfanumerica,\n# mas '!' y esos seian nuestros tokens\nsaludo = Word(alphas) + \",\" + Word(alphas) + one_of(\"! . ?\")\ntokens = saludo.parse_string(\"Hola, Mundo !\")\n\n# Ahora parseamos una cadena, \"Hola, Mundo!\",\n# el metodo parseString, nos devuelve una lista con los tokens\n# encontrados, en caso de no haber errores...\nfor i, token in enumerate(tokens):\n    print(f\"Token {i} -> {token}\")\n\n# imprimimos cada uno de los tokens Y listooo!!, he aqu\u00ed a salida\n# Token 0 -> Hola\n# Token 1 -> ,\n# Token 2-> Mundo\n# Token 3 -> !\n\n# ahora cambia el parseador, aceptando saludos con mas que una sola palabra antes que ','\nsaludo = Group(OneOrMore(Word(alphas))) + \",\" + Word(alphas) + one_of(\"! . ?\")\ntokens = saludo.parse_string(\"Hasta ma\u00f1ana, Mundo !\")\n\nfor i, token in enumerate(tokens):\n    print(f\"Token {i} -> {token}\")\n\n# Ahora parseamos algunas cadenas, usando el metodo runTests\nsaludo.run_tests(\"\"\"\\\n        Hola, Mundo!\n        Hasta ma\u00f1ana, Mundo !\n    \"\"\",\n    fullDump=False,\n)\n\n# Por supuesto, se pueden \"reutilizar\" gram\u00e1ticas, por ejemplo:\nnumimag = Word(nums) + \"i\"\nnumreal = Word(nums)\nnumcomplex = numimag | numreal + Opt(\"+\" + numimag)\n\n# Funcion para cambiar a complejo numero durante parsear:\ndef hace_python_complejo(t):\n    valid_python = \"\".join(t).replace(\"i\", \"j\")\n    for tipo in (int, complex):\n        try:\n            return tipo(valid_python)\n        except ValueError:\n            pass\n\n\nnumcomplex.set_parse_action(hace_python_complejo)\nnumcomplex.run_tests(\"\"\"\\\n    3\n    5i\n    3+5i   \n\"\"\")\n\n# Excelente!!, bueno, los dejo, me voy a seguir tirando c\u00f3digo...\n", "examples/one_to_ninety_nine.py": "#\n# one_to_ninety_nine.py\n#\n# Copyright 2021, Paul McGuire\n#\n# Parser/evaluator for expressions of numbers as written out in words:\n#  - one\n#  - seven\n#  - twelve\n#  - twenty six\n#  - forty-two\n#\n#  BNF:\n#     units ::= one | two | three | ... | nine\n#     teens ::= ten | eleven | twelve | ... | nineteen\n#     tens ::= twenty | thirty | ... | ninety\n#     one_to_99 ::= units | teens | (tens [[\"-\"] units])\n#\nimport pyparsing as pp\n\n\ndef define_numeric_word_range(\n    names: str, from_: int, to_: int, step: int = 1\n) -> pp.MatchFirst:\n    \"\"\"\n    Compose a MatchFirst of CaselessKeywords, given their names and values,\n    which when parsed, are converted to their value\n    \"\"\"\n\n    def define_numeric_word(nm: str, val: int):\n        return pp.CaselessKeyword(nm).add_parse_action(lambda: val)\n\n    names = names.split()\n    values = range(from_, to_ + 1, step)\n    return pp.MatchFirst(\n        define_numeric_word(name, value) for name, value in zip(names, values)\n    )\n\n\nunits = define_numeric_word_range(\n    \"one two three four five six seven eight nine\", 1, 9\n).set_name(\"units\")\nteens = define_numeric_word_range(\n    \"ten eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen\",\n    10,\n    19,\n).set_name(\"teens\")\ntens = define_numeric_word_range(\n    \"twenty thirty forty fifty sixty seventy eighty ninety\", 20, 90, step=10\n).set_name(\"tens\")\n\nopt_dash = pp.Opt(pp.Suppress(\"-\"))\ntwenty_to_99 = tens + pp.Opt(opt_dash + units)\n\none_to_99 = (units | teens | twenty_to_99).set_name(\"1-99\")\n\n# for expressions that parse multiple values, add them up\none_to_99.add_parse_action(sum)\n\nnumeric_expression = one_to_99\n\nif __name__ == \"__main__\":\n    numeric_expression.run_tests(\n        \"\"\"\n        one\n        seven\n        twelve\n        twenty six\n        forty-two\n        \"\"\"\n    )\n\n    # create railroad diagram\n    numeric_expression.create_diagram(\"one_to_99_diagram.html\", vertical=5)\n", "examples/sql2dot.py": "#!/usr/bin/python\n\n# sql2dot.py\n#\n#  Creates table graphics by parsing SQL table DML commands and\n#  generating DOT language output.\n#\n#  Adapted from a post at https://energyblog.blogspot.com/2006/04/blog-post_20.html.\n#\nsampleSQL = \"\"\"\ncreate table students\n(\nstudent_id integer primary key,\nfirstname varchar(20),\nlastname varchar(40),\naddress1 varchar(80),\naddress2 varchar(80),\ncity varchar(30),\nstate varchar(2),\nzipcode varchar(10),\ndob date\n);\n\ncreate table classes\n(\nclass_id integer primary key,\nid varchar(8),\nmaxsize integer,\ninstructor varchar(40)\n);\n\ncreate table student_registrations\n(\nreg_id integer primary key,\nstudent_id integer,\nclass_id integer\n);\n\nalter table only student_registrations\n    add constraint students_link\n    foreign key\n    (student_id) references students(student_id);\n\nalter table only student_registrations\n    add constraint classes_link\n    foreign key\n    (class_id) references classes(class_id);\n\"\"\".upper()\n\nfrom pyparsing import (\n    Literal,\n    Word,\n    delimitedList,\n    alphas,\n    alphanums,\n    OneOrMore,\n    ZeroOrMore,\n    CharsNotIn,\n    replaceWith,\n)\n\nskobki = \"(\" + ZeroOrMore(CharsNotIn(\")\")) + \")\"\nfield_def = OneOrMore(Word(alphas, alphanums + \"_\\\"':-\") | skobki)\n\n\ndef field_act(s, loc, tok):\n    return (\"<\" + tok[0] + \"> \" + \" \".join(tok)).replace('\"', '\\\\\"')\n\n\nfield_def.setParseAction(field_act)\n\nfield_list_def = delimitedList(field_def)\n\n\ndef field_list_act(toks):\n    return \" | \".join(toks)\n\n\nfield_list_def.setParseAction(field_list_act)\n\ncreate_table_def = (\n    Literal(\"CREATE\")\n    + \"TABLE\"\n    + Word(alphas, alphanums + \"_\").setResultsName(\"tablename\")\n    + \"(\"\n    + field_list_def.setResultsName(\"columns\")\n    + \")\"\n    + \";\"\n)\n\n\ndef create_table_act(toks):\n    return (\n        \"\"\"\"%(tablename)s\" [\\n\\t label=\"<%(tablename)s> %(tablename)s | %(columns)s\"\\n\\t shape=\"record\"\\n];\"\"\"\n        % toks\n    )\n\n\ncreate_table_def.setParseAction(create_table_act)\n\nadd_fkey_def = (\n    Literal(\"ALTER\")\n    + \"TABLE\"\n    + \"ONLY\"\n    + Word(alphanums + \"_\").setResultsName(\"fromtable\")\n    + \"ADD\"\n    + \"CONSTRAINT\"\n    + Word(alphanums + \"_\")\n    + \"FOREIGN\"\n    + \"KEY\"\n    + \"(\"\n    + Word(alphanums + \"_\").setResultsName(\"fromcolumn\")\n    + \")\"\n    + \"REFERENCES\"\n    + Word(alphanums + \"_\").setResultsName(\"totable\")\n    + \"(\"\n    + Word(alphanums + \"_\").setResultsName(\"tocolumn\")\n    + \")\"\n    + \";\"\n)\n\n\ndef add_fkey_act(toks):\n    return \"\"\" \"%(fromtable)s\":%(fromcolumn)s -> \"%(totable)s\":%(tocolumn)s \"\"\" % toks\n\n\nadd_fkey_def.setParseAction(add_fkey_act)\n\nother_statement_def = OneOrMore(CharsNotIn(\";\")) + \";\"\nother_statement_def.setParseAction(replaceWith(\"\"))\ncomment_def = \"--\" + ZeroOrMore(CharsNotIn(\"\\n\"))\ncomment_def.setParseAction(replaceWith(\"\"))\n\nstatement_def = comment_def | create_table_def | add_fkey_def | other_statement_def\ndefs = OneOrMore(statement_def)\n\nprint(\"\"\"digraph g { graph [ rankdir = \"LR\" ]; \"\"\")\nfor i in defs.parseString(sampleSQL):\n    if i != \"\":\n        print(i)\nprint(\"}\")\n", "examples/inv_regex.py": "#\n# original file: https://raw.githubusercontent.com/pyparsing/pyparsing/pyparsing_3.0.9/examples/invRegex.py\n#\n# Copyright 2008, Paul McGuire\n#\n# pyparsing script to expand a regular expression into all possible matching strings\n# Supports:\n# - {n} and {m,n} repetition, but not unbounded + or * repetition\n# - ? optional elements\n# - [] character ranges\n# - () grouping\n# - | alternation\n#\n__all__ = [\"count\", \"invert\"]\n\nfrom pyparsing import (\n    Literal,\n    one_of,\n    Empty,\n    printables,\n    ParserElement,\n    Combine,\n    SkipTo,\n    infix_notation,\n    ParseFatalException,\n    Word,\n    nums,\n    OpAssoc,\n    Suppress,\n    ParseResults,\n    srange,\n)\n\nParserElement.enablePackrat()\n\n\nclass CharacterRangeEmitter:\n    def __init__(self, chars):\n        # remove duplicate chars in character range, but preserve original order\n        seen = set()\n        self.charset = \"\".join(seen.add(c) or c for c in chars if c not in seen)\n\n    def __str__(self):\n        return \"[\" + self.charset + \"]\"\n\n    def __repr__(self):\n        return \"[\" + self.charset + \"]\"\n\n    def make_generator(self):\n        def gen_chars():\n            yield from self.charset\n\n        return gen_chars\n\n\nclass OptionalEmitter:\n    def __init__(self, expr):\n        self.expr = expr\n\n    def make_generator(self):\n        def optional_gen():\n            yield \"\"\n            yield from self.expr.make_generator()()\n\n        return optional_gen\n\n\nclass DotEmitter:\n    def make_generator(self):\n        def dot_gen():\n            yield from printables\n\n        return dot_gen\n\n\nclass GroupEmitter:\n    def __init__(self, exprs):\n        self.exprs = ParseResults(exprs)\n\n    def make_generator(self):\n        def group_gen():\n            def recurse_list(elist):\n                if len(elist) == 1:\n                    yield from elist[0].make_generator()()\n                else:\n                    for s in elist[0].make_generator()():\n                        for s2 in recurse_list(elist[1:]):\n                            yield s + s2\n\n            if self.exprs:\n                yield from recurse_list(self.exprs)\n\n        return group_gen\n\n\nclass AlternativeEmitter:\n    def __init__(self, exprs):\n        self.exprs = exprs\n\n    def make_generator(self):\n        def alt_gen():\n            for e in self.exprs:\n                yield from e.make_generator()()\n\n        return alt_gen\n\n\nclass LiteralEmitter:\n    def __init__(self, lit):\n        self.lit = lit\n\n    def __str__(self):\n        return \"Lit:\" + self.lit\n\n    def __repr__(self):\n        return \"Lit:\" + self.lit\n\n    def make_generator(self):\n        def lit_gen():\n            yield self.lit\n\n        return lit_gen\n\n\ndef handle_range(toks):\n    return CharacterRangeEmitter(srange(toks[0]))\n\n\ndef handle_repetition(toks):\n    toks = toks[0]\n    if toks[1] in \"*+\":\n        raise ParseFatalException(\"\", 0, \"unbounded repetition operators not supported\")\n    if toks[1] == \"?\":\n        return OptionalEmitter(toks[0])\n    if \"count\" in toks:\n        return GroupEmitter([toks[0]] * int(toks.count))\n    if \"minCount\" in toks:\n        mincount = int(toks.minCount)\n        maxcount = int(toks.maxCount)\n        optcount = maxcount - mincount\n        if optcount:\n            opt = OptionalEmitter(toks[0])\n            for i in range(1, optcount):\n                opt = OptionalEmitter(GroupEmitter([toks[0], opt]))\n            return GroupEmitter([toks[0]] * mincount + [opt])\n        else:\n            return [toks[0]] * mincount\n\n\ndef handle_literal(toks):\n    lit = \"\"\n    for t in toks:\n        if t[0] == \"\\\\\":\n            if t[1] == \"t\":\n                lit += \"\\t\"\n            else:\n                lit += t[1]\n        else:\n            lit += t\n    return LiteralEmitter(lit)\n\n\ndef handle_macro(toks):\n    macro_char = toks[0][1]\n    if macro_char == \"d\":\n        return CharacterRangeEmitter(\"0123456789\")\n    elif macro_char == \"w\":\n        return CharacterRangeEmitter(srange(\"[A-Za-z0-9_]\"))\n    elif macro_char == \"s\":\n        return LiteralEmitter(\" \")\n    else:\n        raise ParseFatalException(\n            \"\", 0, \"unsupported macro character (\" + macro_char + \")\"\n        )\n\n\ndef handle_sequence(toks):\n    return GroupEmitter(toks[0])\n\n\ndef handle_dot():\n    return CharacterRangeEmitter(printables)\n\n\ndef handle_alternative(toks):\n    return AlternativeEmitter(toks[0])\n\n\n_parser = None\n\n\ndef parser():\n    global _parser\n    if _parser is None:\n        ParserElement.set_default_whitespace_chars(\"\")\n        lbrack, rbrack, lbrace, rbrace, lparen, rparen, colon, qmark = Literal.using_each(\n            \"[]{}():?\"\n        )\n\n        re_macro = Combine(\"\\\\\" + one_of(\"d w s\"))\n        escaped_char = ~re_macro + Combine(\"\\\\\" + one_of(list(printables)))\n        re_literal_char = (\n            \"\".join(c for c in printables if c not in r\"\\[]{}().*?+|\") + \" \\t\"\n        )\n\n        re_range = Combine(lbrack + SkipTo(rbrack, ignore=escaped_char) + rbrack) # type: ignore \n        re_literal = escaped_char | one_of(list(re_literal_char))\n        re_non_capture_group = Suppress(\"?:\")\n        re_dot = Literal(\".\")\n        repetition = (\n            (lbrace + Word(nums)(\"count\") + rbrace)\n            | (lbrace + Word(nums)(\"minCount\") + \",\" + Word(nums)(\"maxCount\") + rbrace)\n            | one_of(list(\"*+?\"))\n        )\n\n        re_range.add_parse_action(handle_range)\n        re_literal.add_parse_action(handle_literal)\n        re_macro.add_parse_action(handle_macro)\n        re_dot.add_parse_action(handle_dot)\n\n        re_term = re_literal | re_range | re_macro | re_dot | re_non_capture_group\n        re_expr = infix_notation(\n            re_term,\n            [\n                (repetition, 1, OpAssoc.LEFT, handle_repetition),\n                (Empty(), 2, OpAssoc.LEFT, handle_sequence),\n                (Suppress(\"|\"), 2, OpAssoc.LEFT, handle_alternative),\n            ],\n        )\n        _parser = re_expr\n\n    return _parser\n\n\ndef count(gen):\n    \"\"\"Simple function to count the number of elements returned by a generator.\"\"\"\n    return sum(1 for _ in gen)\n\n\ndef invert(regex):\n    r\"\"\"\n    Call this routine as a generator to return all the strings that\n    match the input regular expression.\n        for s in invert(r\"[A-Z]{3}\\d{3}\"):\n            print s\n    \"\"\"\n    invre = GroupEmitter(parser().parseString(regex)).make_generator()\n    return invre()\n\n\ndef main():\n    tests = r\"\"\"\n    [A-EA]\n    [A-D]*\n    [A-D]{3}\n    X[A-C]{3}Y\n    X[A-C]{3}\\(\n    X\\d\n    foobar\\d\\d\n    foobar{2}\n    foobar{2,9}\n    fooba[rz]{2}\n    (foobar){2}\n    ([01]\\d)|(2[0-5])\n    (?:[01]\\d)|(2[0-5])\n    ([01]\\d\\d)|(2[0-4]\\d)|(25[0-5])\n    [A-C]{1,2}\n    [A-C]{0,3}\n    [A-C]\\s[A-C]\\s[A-C]\n    [A-C]\\s?[A-C][A-C]\n    [A-C]\\s([A-C][A-C])\n    [A-C]\\s([A-C][A-C])?\n    [A-C]{2}\\d{2}\n    @|TH[12]\n    @(@|TH[12])?\n    @(@|TH[12]|AL[12]|SP[123]|TB(1[0-9]?|20?|[3-9]))?\n    @(@|TH[12]|AL[12]|SP[123]|TB(1[0-9]?|20?|[3-9])|OH(1[0-9]?|2[0-9]?|30?|[4-9]))?\n    (([ECMP]|HA|AK)[SD]|HS)T\n    [A-CV]{2}\n    A[cglmrstu]|B[aehikr]?|C[adeflmorsu]?|D[bsy]|E[rsu]|F[emr]?|G[ade]|H[efgos]?|I[nr]?|Kr?|L[airu]|M[dgnot]|N[abdeiop]?|Os?|P[abdmortu]?|R[abefghnu]|S[bcegimnr]?|T[abcehilm]|Uu[bhopqst]|U|V|W|Xe|Yb?|Z[nr]\n    (a|b)|(x|y)\n    (a|b) (x|y)\n    [ABCDEFG](?:#|##|b|bb)?(?:maj|min|m|sus|aug|dim)?[0-9]?(?:/[ABCDEFG](?:#|##|b|bb)?)?\n    (Fri|Mon|S(atur|un)|T(hur|ue)s|Wednes)day\n    A(pril|ugust)|((Dec|Nov|Sept)em|Octo)ber|(Febr|Jan)uary|Ju(ly|ne)|Ma(rch|y)\n    \"\"\".splitlines()\n\n    for t in tests:\n        t = t.strip()\n        if not t:\n            continue\n        print(\"-\" * 50)\n        print(t)\n        try:\n            num = count(invert(t))\n            print(num)\n            maxprint = 30\n            for s in invert(t):\n                print(s)\n                maxprint -= 1\n                if not maxprint:\n                    break\n        except ParseFatalException as pfe:\n            print(pfe.msg)\n            print(\"\")\n            continue\n        print(\"\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/verilog_parse.py": "#\n# verilogParse.py\n#\n# an example of using the pyparsing module to be able to process Verilog files\n# uses BNF defined at http://www.verilog.com/VerilogBNF.html\n#\n#    Copyright (c) 2004-2011 Paul T. McGuire.  All rights reserved.\n#\n# Permission is hereby granted, free of charge, to any person obtaining\n# a copy of this software and associated documentation files (the\n# \"Software\"), to deal in the Software without restriction, including\n# without limitation the rights to use, copy, modify, merge, publish,\n# distribute, sublicense, and/or sell copies of the Software, and to\n# permit persons to whom the Software is furnished to do so, subject to\n# the following conditions:\n#\n# The above copyright notice and this permission notice shall be\n# included in all copies or substantial portions of the Software.\n#\n# If you find this software to be useful, please make a donation to one\n# of the following charities:\n# - the Red Cross (https://www.redcross.org/)\n# - Hospice Austin (https://www.hospiceaustin.org/)\n#\n#    DISCLAIMER:\n#    THIS SOFTWARE IS PROVIDED BY PAUL T. McGUIRE ``AS IS'' AND ANY EXPRESS OR\n#    IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n#    MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n#    EVENT SHALL PAUL T. McGUIRE OR CO-CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n#    INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n#    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OFUSE,\n#    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n#    OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n#    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n#    EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n#\n#    For questions or inquiries regarding this license, or commercial use of\n#    this software, contact the author via e-mail: ptmcg@users.sourceforge.net\n#\n# Todo:\n#  - add pre-process pass to implement compilerDirectives (ifdef, include, etc.)\n#\n# Revision History:\n#\n#   1.0   - Initial release\n#   1.0.1 - Fixed grammar errors:\n#           . real declaration was incorrect\n#           . tolerant of '=>' for '*>' operator\n#           . tolerant of '?' as hex character\n#           . proper handling of mintypmax_expr within path delays\n#   1.0.2 - Performance tuning (requires pyparsing 1.3)\n#   1.0.3 - Performance updates, using Regex (requires pyparsing 1.4)\n#   1.0.4 - Performance updates, enable packrat parsing (requires pyparsing 1.4.2)\n#   1.0.5 - Converted keyword Literals to Keywords, added more use of Group to\n#           group parsed results tokens\n#   1.0.6 - Added support for module header with no ports list (thanks, Thomas Dejanovic!)\n#   1.0.7 - Fixed erroneous '<<' Forward definition in timCheckCond, omitting ()'s\n#   1.0.8 - Re-released under MIT license\n#   1.0.9 - Enhanced udpInstance to handle identifiers with leading '\\' and subscripting\n#   1.0.10 - Fixed change added in 1.0.9 to work for all identifiers, not just those used\n#           for udpInstance.\n#   1.0.11 - Fixed bug in inst_args, content alternatives were reversed\n#   1.1.0 - Some performance fixes, convert most literal strs to Keywords\n#\nfrom pathlib import Path\nimport pprint\nimport time\n\n__version__ = \"1.1.0\"\n\n__all__ = [\"__version__\", \"verilogbnf\"]\n\nfrom pyparsing import (\n    Literal,\n    Keyword,\n    Word,\n    Forward,\n    DelimitedList,\n    Group,\n    Optional,\n    Combine,\n    alphas,\n    nums,\n    restOfLine,\n    alphanums,\n    dbl_quoted_string,\n    empty,\n    ParseException,\n    one_of,\n    StringEnd,\n    FollowedBy,\n    ParserElement,\n    Regex,\n    cppStyleComment,\n)\nimport pyparsing\n\nusePackrat = True\n\npackratOn = False\nif usePackrat:\n    try:\n        ParserElement.enable_packrat()\n    except Exception:\n        pass\n    else:\n        packratOn = True\n\n\nverilogbnf = None\n\n\ndef make_verilog_bnf():\n    global verilogbnf\n\n    if verilogbnf is None:\n\n        # compiler directives\n        compilerDirective = Combine(\n            \"`\"\n            + one_of(\n                \"define undef ifdef else endif default_nettype\"\n                \" include resetall timescale unconnected_drive\"\n                \" nounconnected_drive celldefine endcelldefine\",\n                as_keyword=True,\n            )\n            + restOfLine\n        ).set_name(\"compilerDirective\")\n\n        # primitives\n        (\n            SEMI,\n            COLON,\n            LPAR,\n            RPAR,\n            LBRACE,\n            RBRACE,\n            LBRACK,\n            RBRACK,\n            DOT,\n            COMMA,\n            EQ,\n        ) = Literal.using_each(\";:(){}[].,=\")\n\n        identLead = alphas + \"$_\"\n        identBody = alphanums + \"$_\"\n        identifier1 = Regex(\n            rf\"\\.?[{identLead}][{identBody}]*(\\.[{identLead}][{identBody}]*)*\"\n        ).set_name(\"baseIdent\")\n        identifier2 = (\n            Regex(r\"\\\\\\S+\").setParseAction(lambda t: t[0][1:]).set_name(\"escapedIdent\")\n        )  # .setDebug()\n        identifier = identifier1 | identifier2\n        assert identifier2 == r\"\\abc\"\n\n        hexnums = nums + \"abcdefABCDEF\" + \"_?\"\n        base = Regex(\"'[bBoOdDhH]\").set_name(\"base\")\n        basedNumber = Combine(\n            (Word(nums + \"_\") | \"\") + base + Word(hexnums + \"xXzZ\"),\n            joinString=\" \",\n            adjacent=False,\n        ).set_name(\"basedNumber\")\n        # number = ( basedNumber | Combine( Word( \"+-\"+spacedNums, spacedNums ) +\n        # Optional( DOT + Optional( Word( spacedNums ) ) ) +\n        # Optional( e + Word( \"+-\"+spacedNums, spacedNums ) ) ).set_name(\"numeric\") )\n        number = (\n            basedNumber | Regex(r\"[+-]?[0-9_]+(\\.[0-9_]*)?([Ee][+-]?[0-9_]+)?\")\n        ).set_name(\"numeric\")\n\n        expr = Forward().set_name(\"expr\")\n        concat = Group(LBRACE + DelimitedList(expr) + RBRACE)\n        multiConcat = Group(\"{\" + expr + concat + \"}\").set_name(\"multiConcat\")\n        funcCall = Group(\n            identifier + LPAR + (DelimitedList(expr) | \"\") + RPAR\n        ).set_name(\"funcCall\")\n\n        subscrRef = Group(LBRACK + DelimitedList(expr, COLON) + RBRACK)\n        subscrIdentifier = Group(identifier + (subscrRef | \"\"))\n        # scalarConst = \"0\" | (( FollowedBy('1') + one_of(\"1'b0 1'b1 1'bx 1'bX 1'B0 1'B1 1'Bx 1'BX 1\") ))\n        scalarConst = Regex(\"0|1('[Bb][01xX])?\")\n        mintypmaxExpr = Group(expr + COLON + expr + COLON + expr).set_name(\"mintypmax\")\n        primary = (\n            number\n            | (LPAR + mintypmaxExpr + RPAR)\n            | (LPAR + Group(expr) + RPAR).set_name(\"nestedExpr\")\n            | multiConcat\n            | concat\n            | dbl_quoted_string\n            | funcCall\n            | subscrIdentifier\n        )\n\n        unop = one_of(\"+  -  !  ~  &  ~&  |  ^|  ^  ~^\").set_name(\"unop\")\n        binop = one_of(\n            \"+  -  *  /  %  ==  !=  ===  !==  &&  \"\n            \"||  <  <=  >  >=  &  |  ^  ^~  >>  << ** <<< >>>\"\n        ).set_name(\"binop\")\n\n        expr <<= (\n            (unop + expr)\n            | (primary + \"?\" + expr + COLON + expr)  # must be first!\n            | (primary + ((binop + expr) | \"\"))\n        )\n\n        lvalue = subscrIdentifier | concat\n\n        # keywords\n        reg = Keyword(\"reg\")\n        trireg = Keyword(\"trireg\")\n        signed = Keyword(\"signed\")\n        parameter = Keyword(\"parameter\")\n        input_, output, inout = Keyword.using_each(\"input output inout\".split())\n        time = Keyword(\"time\")\n        integer = Keyword(\"integer\")\n        real = Keyword(\"real\")\n        event = Keyword(\"event\")\n        scalared = Keyword(\"scalared\")\n        vectored = Keyword(\"vectored\")\n        if_ = Keyword(\"if\")\n        else_ = Keyword(\"else\")\n        always = Keyword(\"always\")\n        initial = Keyword(\"initial\")\n        small, medium, large = Keyword.using_each(\"small medium large\".split())\n        edge = Keyword(\"edge\")\n        posedge = Keyword(\"posedge\")\n        negedge = Keyword(\"negedge\")\n        specify, endspecify = Keyword.using_each(\"specify endspecify\".split())\n        primitive, endprimitive = Keyword.using_each(\"primitive endprimitive\".split())\n        fork = Keyword(\"fork\")\n        join = Keyword(\"join\")\n        begin = Keyword(\"begin\")\n        end = Keyword(\"end\")\n        default = Keyword(\"default\")\n        forever = Keyword(\"forever\")\n        repeat = Keyword(\"repeat\")\n        while_ = Keyword(\"while\")\n        for_ = Keyword(\"for\")\n        case = one_of(\"case casez casex\", as_keyword=True)\n        endcase = Keyword(\"endcase\")\n        wait = Keyword(\"wait\")\n        disable = Keyword(\"disable\")\n        deassign = Keyword(\"deassign\")\n        force = Keyword(\"force\")\n        release = Keyword(\"release\")\n        assign = Keyword(\"assign\")\n        table, endtable = Keyword.using_each(\"table endtable\".split())\n        function, endfunction = Keyword.using_each(\"function endfunction\".split())\n        task, endtask = Keyword.using_each(\"task endtask\".split())\n        module, macromodule, endmodule = Keyword.using_each(\n            \"module macromodule endmodule\".split()\n        )\n\n        eventExpr = Forward()\n        eventTerm = (\n            (posedge + expr) | (negedge + expr) | expr | (LPAR + eventExpr + RPAR)\n        )\n        eventExpr <<= Group(DelimitedList(eventTerm, Keyword(\"or\")))\n        eventControl = Group(\n            \"@\" + ((LPAR + eventExpr + RPAR) | identifier | \"*\")\n        ).set_name(\"eventCtrl\")\n\n        delayArg = (\n            number\n            | Word(alphanums + \"$_\")\n            | (LPAR + Group(DelimitedList(mintypmaxExpr | expr)) + RPAR)  # identifier |\n        ).set_name(\n            \"delayArg\"\n        )  # .setDebug()\n        delay = Group(\"#\" + delayArg).set_name(\"delay\")  # .setDebug()\n        delayOrEventControl = delay | eventControl\n\n        assgnmt = Group(lvalue + EQ + (delayOrEventControl | \"\") + expr).set_name(\n            \"assgnmt\"\n        )\n        nbAssgnmt = Group(\n            (lvalue + \"<=\" + (delay | \"\") + expr)\n            | (lvalue + \"<=\" + (eventControl | \"\") + expr)\n        ).set_name(\"nbassgnmt\")\n\n        range_ = LBRACK + expr + COLON + expr + RBRACK\n\n        paramAssgnmt = Group(identifier + EQ + expr).set_name(\"paramAssgnmt\")\n        parameterDecl = Group(\n            parameter + (range_ | \"\") + DelimitedList(paramAssgnmt) + SEMI\n        ).set_name(\"paramDecl\")\n\n        inputDecl = Group(input_ + (range_ | \"\") + DelimitedList(identifier) + SEMI)\n        outputDecl = Group(output + (range_ | \"\") + DelimitedList(identifier) + SEMI)\n        inoutDecl = Group(inout + (range_ | \"\") + DelimitedList(identifier) + SEMI)\n\n        regIdentifier = Group(identifier + (LBRACK + expr + COLON + expr + RBRACK | \"\"))\n        regDecl = Group(\n            reg + (signed | \"\") + (range_ | \"\") + DelimitedList(regIdentifier) + SEMI\n        ).set_name(\"regDecl\")\n        timeDecl = Group(time + DelimitedList(regIdentifier) + SEMI)\n        integerDecl = Group(integer + DelimitedList(regIdentifier) + SEMI)\n\n        strength0 = one_of(\"supply0  strong0  pull0  weak0  highz0\", as_keyword=True)\n        strength1 = one_of(\"supply1  strong1  pull1  weak1  highz1\", as_keyword=True)\n        driveStrength = Group(\n            LPAR\n            + ((strength0 + COMMA + strength1) | (strength1 + COMMA + strength0))\n            + RPAR\n        ).set_name(\"driveStrength\")\n        nettype = one_of(\n            \"wire  tri  tri1  supply0  wand  triand  tri0  supply1  wor  trior  trireg\",\n            as_keyword=True,\n        )\n        expandRange = (scalared | vectored | \"\") + range_\n        realDecl = Group(real + DelimitedList(identifier) + SEMI)\n\n        eventDecl = Group(event + DelimitedList(identifier) + SEMI)\n\n        blockDecl = (\n            parameterDecl | regDecl | integerDecl | realDecl | timeDecl | eventDecl\n        )\n\n        stmt = Forward().set_name(\"stmt\")  # .setDebug()\n        stmtOrNull = stmt | SEMI\n        caseItem = (DelimitedList(expr) + COLON + stmtOrNull) | (\n            default + Optional(\":\") + stmtOrNull\n        )\n        stmt <<= Group(\n            (begin + Group(stmt[...:end]) + end).set_name(\"begin-end\")\n            | (\n                if_ + Group(LPAR + expr + RPAR) + stmtOrNull + (else_ + stmtOrNull | \"\")\n            ).set_name(\"if\")\n            | (delayOrEventControl + stmtOrNull)\n            | (case + LPAR + expr + RPAR + caseItem[1, ...] + endcase)\n            | (forever + stmt)\n            | (repeat + LPAR + expr + RPAR + stmt)\n            | (while_ + LPAR + expr + RPAR + stmt)\n            | (\n                for_\n                + LPAR\n                + assgnmt\n                + SEMI\n                + Group(expr)\n                + SEMI\n                + assgnmt\n                + RPAR\n                + stmt\n            )\n            | (fork + stmt[...] + join)\n            | (fork + COLON + identifier + blockDecl[...] + stmt[...] + end)\n            | (wait + LPAR + expr + RPAR + stmtOrNull)\n            | (\"->\" + identifier + SEMI)\n            | (disable + identifier + SEMI)\n            | (assign + assgnmt + SEMI)\n            | (deassign + lvalue + SEMI)\n            | (force + assgnmt + SEMI)\n            | (release + lvalue + SEMI)\n            | (begin + COLON + identifier + blockDecl[...] + stmt[...] + end).set_name(\n                \"begin:label-end\"\n            )\n            |\n            # these  *have* to go at the end of the list!!!\n            (assgnmt + SEMI)\n            | (nbAssgnmt + SEMI)\n            | (\n                Combine(Optional(\"$\") + identifier)\n                + (LPAR + DelimitedList(expr | empty) + RPAR | \"\")\n                + SEMI\n            )\n        ).set_name(\"stmtBody\")\n        \"\"\"\n        x::=<blocking_assignment> ;\n        x||= <non_blocking_assignment> ;\n        x||= if ( <expression> ) <statement_or_null>\n        x||= if ( <expression> ) <statement_or_null> else <statement_or_null>\n        x||= case ( <expression> ) <case_item>+ endcase\n        x||= casez ( <expression> ) <case_item>+ endcase\n        x||= casex ( <expression> ) <case_item>+ endcase\n        x||= forever <statement>\n        x||= repeat ( <expression> ) <statement>\n        x||= while ( <expression> ) <statement>\n        x||= for ( <assignment> ; <expression> ; <assignment> ) <statement>\n        x||= <delay_or_event_control> <statement_or_null>\n        x||= wait ( <expression> ) <statement_or_null>\n        x||= -> <name_of_event> ;\n        x||= <seq_block>\n        x||= <par_block>\n        x||= <task_enable>\n        x||= <system_task_enable>\n        x||= disable <name_of_task> ;\n        x||= disable <name_of_block> ;\n        x||= assign <assignment> ;\n        x||= deassign <lvalue> ;\n        x||= force <assignment> ;\n        x||= release <lvalue> ;\n        \"\"\"\n        alwaysStmt = Group(always + (eventControl | \"\") + stmt).set_name(\"alwaysStmt\")\n        initialStmt = Group(initial + stmt).set_name(\"initialStmt\")\n\n        chargeStrength = Group(LPAR + (small | medium | large) + RPAR).set_name(\n            \"chargeStrength\"\n        )\n\n        continuousAssign = Group(\n            assign + (driveStrength | \"\") + (delay | \"\") + DelimitedList(assgnmt) + SEMI\n        ).set_name(\"continuousAssign\")\n\n        tfDecl = (\n            parameterDecl\n            | inputDecl\n            | outputDecl\n            | inoutDecl\n            | regDecl\n            | timeDecl\n            | integerDecl\n            | realDecl\n        )\n\n        functionDecl = Group(\n            function\n            + (range_ | \"integer\" | \"real\" | \"\")\n            + identifier\n            + SEMI\n            + Group(tfDecl[1, ...])\n            + Group(stmt[...])\n            + endfunction\n        )\n\n        inputOutput = input_ | output\n        netDecl1Arg = (\n            nettype\n            + (expandRange | \"\")\n            + (delay | \"\")\n            + Group(DelimitedList(~inputOutput + identifier))\n        )\n        netDecl2Arg = (\n            trireg\n            + (chargeStrength | \"\")\n            + (expandRange | \"\")\n            + (delay | \"\")\n            + Group(DelimitedList(~inputOutput + identifier))\n        )\n        netDecl3Arg = (\n            nettype\n            + (driveStrength | \"\")\n            + (expandRange | \"\")\n            + (delay | \"\")\n            + Group(DelimitedList(assgnmt))\n        )\n        netDecl1 = Group(netDecl1Arg + SEMI).set_name(\"netDecl1\")\n        netDecl2 = Group(netDecl2Arg + SEMI).set_name(\"netDecl2\")\n        netDecl3 = Group(netDecl3Arg + SEMI).set_name(\"netDecl3\")\n\n        gateType = one_of(\n            \"and  nand  or  nor xor  xnor buf  bufif0 bufif1 \"\n            \"not  notif0 notif1  pulldown pullup nmos  rnmos \"\n            \"pmos rpmos cmos rcmos   tran rtran  tranif0  \"\n            \"rtranif0  tranif1 rtranif1\",\n            as_keyword=True,\n        )\n        gateInstance = (\n            (Group(identifier + (range_ | \"\")) | \"\")\n            + LPAR\n            + Group(DelimitedList(expr))\n            + RPAR\n        )\n        gateDecl = Group(\n            gateType\n            + (driveStrength | \"\")\n            + (delay | \"\")\n            + DelimitedList(gateInstance)\n            + SEMI\n        )\n\n        udpInstance = Group(\n            Group(identifier + (range_ | subscrRef | \"\"))\n            + LPAR\n            + Group(DelimitedList(expr))\n            + RPAR\n        )\n        udpInstantiation = Group(\n            identifier\n            - (driveStrength | \"\")\n            + (delay | \"\")\n            + DelimitedList(udpInstance)\n            + SEMI\n        ).set_name(\"udpInstantiation\")\n\n        parameterValueAssignment = Group(\n            Literal(\"#\") + LPAR + Group(DelimitedList(expr)) + RPAR\n        )\n        namedPortConnection = Group(DOT + identifier + LPAR + expr + RPAR).set_name(\n            \"namedPortConnection\"\n        )  # .setDebug()\n        # assert r\".\\abc (abc )\" == namedPortConnection\n        modulePortConnection = expr | empty\n        inst_args = Group(\n            LPAR\n            + (DelimitedList(namedPortConnection) | DelimitedList(modulePortConnection))\n            + RPAR\n        ).set_name(\"inst_args\")\n        moduleInstance = Group(Group(identifier + (range_ | \"\")) + inst_args).set_name(\n            \"moduleInstance\"\n        )  # .setDebug()\n\n        moduleInstantiation = Group(\n            identifier\n            + (parameterValueAssignment | \"\")\n            + DelimitedList(moduleInstance).set_name(\"moduleInstanceList\")\n            + SEMI\n        ).set_name(\"moduleInstantiation\")\n\n        parameterOverride = Group(\"defparam\" + DelimitedList(paramAssgnmt) + SEMI)\n        task = Group(task + identifier + SEMI + tfDecl[...] + stmtOrNull + endtask)\n\n        specparamDecl = Group(\"specparam\" + DelimitedList(paramAssgnmt) + SEMI)\n\n        pathDescr1 = Group(LPAR + subscrIdentifier + \"=>\" + subscrIdentifier + RPAR)\n        pathDescr2 = Group(\n            LPAR\n            + Group(DelimitedList(subscrIdentifier))\n            + \"*>\"\n            + Group(DelimitedList(subscrIdentifier))\n            + RPAR\n        )\n        pathDescr3 = Group(\n            LPAR\n            + Group(DelimitedList(subscrIdentifier))\n            + \"=>\"\n            + Group(DelimitedList(subscrIdentifier))\n            + RPAR\n        )\n        pathDelayValue = Group(\n            (LPAR + Group(DelimitedList(mintypmaxExpr | expr)) + RPAR)\n            | mintypmaxExpr\n            | expr\n        )\n        pathDecl = Group(\n            (pathDescr1 | pathDescr2 | pathDescr3) + EQ + pathDelayValue + SEMI\n        ).set_name(\"pathDecl\")\n\n        portConditionExpr = Forward()\n        portConditionTerm = (unop | \"\") + subscrIdentifier\n        portConditionExpr <<= portConditionTerm + (binop + portConditionExpr | \"\")\n        polarityOp = one_of(\"+ -\")\n        levelSensitivePathDecl1 = Group(\n            if_\n            + Group(LPAR + portConditionExpr + RPAR)\n            + subscrIdentifier\n            + (polarityOp | \"\")\n            + \"=>\"\n            + subscrIdentifier\n            + EQ\n            + pathDelayValue\n            + SEMI\n        )\n        levelSensitivePathDecl2 = Group(\n            if_\n            + Group(LPAR + portConditionExpr + RPAR)\n            + LPAR\n            + Group(DelimitedList(subscrIdentifier))\n            + (polarityOp | \"\")\n            + \"*>\"\n            + Group(DelimitedList(subscrIdentifier))\n            + RPAR\n            + EQ\n            + pathDelayValue\n            + SEMI\n        )\n        levelSensitivePathDecl = levelSensitivePathDecl1 | levelSensitivePathDecl2\n\n        edgeIdentifier = posedge | negedge\n        edgeSensitivePathDecl1 = Group(\n            (if_ + Group(LPAR + expr + RPAR) | \"\")\n            + LPAR\n            + (edgeIdentifier | \"\")\n            + subscrIdentifier\n            + \"=>\"\n            + LPAR\n            + subscrIdentifier\n            + (polarityOp | \"\")\n            + COLON\n            + expr\n            + RPAR\n            + RPAR\n            + EQ\n            + pathDelayValue\n            + SEMI\n        )\n        edgeSensitivePathDecl2 = Group(\n            (if_ + Group(LPAR + expr + RPAR) | \"\")\n            + LPAR\n            + (edgeIdentifier | \"\")\n            + subscrIdentifier\n            + \"*>\"\n            + LPAR\n            + DelimitedList(subscrIdentifier)\n            + (polarityOp | \"\")\n            + COLON\n            + expr\n            + RPAR\n            + RPAR\n            + EQ\n            + pathDelayValue\n            + SEMI\n        )\n        edgeSensitivePathDecl = edgeSensitivePathDecl1 | edgeSensitivePathDecl2\n\n        edgeDescr = one_of(\"01 10 0x x1 1x x0\").set_name(\"edgeDescr\")\n\n        timCheckEventControl = Group(\n            posedge | negedge | (edge + LBRACK + DelimitedList(edgeDescr) + RBRACK)\n        )\n        timCheckCond = Forward()\n        timCondBinop = one_of(\"== === != !==\")\n        timCheckCondTerm = (expr + timCondBinop + scalarConst) | (Optional(\"~\") + expr)\n        timCheckCond <<= (LPAR + timCheckCond + RPAR) | timCheckCondTerm\n        timCheckEvent = Group(\n            (timCheckEventControl | \"\") + subscrIdentifier + (\"&&&\" + timCheckCond | \"\")\n        )\n        timCheckLimit = expr\n        controlledTimingCheckEvent = Group(\n            timCheckEventControl + subscrIdentifier + (\"&&&\" + timCheckCond | \"\")\n        )\n        notifyRegister = identifier\n\n        systemTimingCheck1 = Group(\n            \"$setup\"\n            + LPAR\n            + timCheckEvent\n            + COMMA\n            + timCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck2 = Group(\n            \"$hold\"\n            + LPAR\n            + timCheckEvent\n            + COMMA\n            + timCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck3 = Group(\n            \"$period\"\n            + LPAR\n            + controlledTimingCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck4 = Group(\n            \"$width\"\n            + LPAR\n            + controlledTimingCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + expr + COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck5 = Group(\n            \"$skew\"\n            + LPAR\n            + timCheckEvent\n            + COMMA\n            + timCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck6 = Group(\n            \"$recovery\"\n            + LPAR\n            + controlledTimingCheckEvent\n            + COMMA\n            + timCheckEvent\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck7 = Group(\n            \"$setuphold\"\n            + LPAR\n            + timCheckEvent\n            + COMMA\n            + timCheckEvent\n            + COMMA\n            + timCheckLimit\n            + COMMA\n            + timCheckLimit\n            + (COMMA + notifyRegister | \"\")\n            + RPAR\n            + SEMI\n        )\n        systemTimingCheck = (\n            FollowedBy(\"$\")\n            + (\n                systemTimingCheck1\n                | systemTimingCheck2\n                | systemTimingCheck3\n                | systemTimingCheck4\n                | systemTimingCheck5\n                | systemTimingCheck6\n                | systemTimingCheck7\n            )\n        ).set_name(\"systemTimingCheck\")\n        sdpd = (\n            if_\n            + Group(LPAR + expr + RPAR)\n            + (pathDescr1 | pathDescr2)\n            + EQ\n            + pathDelayValue\n            + SEMI\n        )\n\n        specifyItem = (\n            specparamDecl\n            | pathDecl\n            | levelSensitivePathDecl\n            | edgeSensitivePathDecl\n            | systemTimingCheck\n            | sdpd\n        )\n        \"\"\"\n        x::= <specparam_declaration>\n        x||= <path_declaration>\n        x||= <level_sensitive_path_declaration>\n        x||= <edge_sensitive_path_declaration>\n        x||= <system_timing_check>\n        x||= <sdpd>\n        \"\"\"\n        specifyBlock = Group(\n            specify + specifyItem[...:endspecify] + endspecify\n        ).set_name(\"specifyBlock\")\n\n        moduleItem = (\n            parameterDecl\n            | inputDecl\n            | outputDecl\n            | inoutDecl\n            | regDecl\n            | netDecl3\n            | netDecl1\n            | netDecl2\n            | timeDecl\n            | integerDecl\n            | realDecl\n            | eventDecl\n            | gateDecl\n            | parameterOverride\n            | continuousAssign\n            | specifyBlock\n            | initialStmt\n            | alwaysStmt\n            | task\n            | functionDecl\n            # these have to be at the end - they start with identifiers\n            | moduleInstantiation\n            | udpInstantiation\n        )\n        \"\"\"  All possible moduleItems, from Verilog grammar spec\n        x::= <parameter_declaration>\n        x||= <input_declaration>\n        x||= <output_declaration>\n        x||= <inout_declaration>\n        ?||= <net_declaration>  (spec does not seem consistent for this item)\n        x||= <reg_declaration>\n        x||= <time_declaration>\n        x||= <integer_declaration>\n        x||= <real_declaration>\n        x||= <event_declaration>\n        x||= <gate_declaration>\n        x||= <UDP_instantiation>\n        x||= <module_instantiation>\n        x||= <parameter_override>\n        x||= <continuous_assign>\n        x||= <specify_block>\n        x||= <initial_statement>\n        x||= <always_statement>\n        x||= <task>\n        x||= <function>\n        \"\"\"\n        portRef = subscrIdentifier\n        portExpr = portRef | Group(LBRACE + DelimitedList(portRef) + RBRACE)\n        port = portExpr | Group(DOT + identifier + LPAR + portExpr + RPAR)\n\n        moduleHdr = Group(\n            (module | macromodule)\n            + identifier\n            + (\n                LPAR\n                + Group(\n                    (\n                        DelimitedList(\n                            Group(\n                                (input_ | output)\n                                + (netDecl1Arg | netDecl2Arg | netDecl3Arg)\n                            )\n                            | port\n                        )\n                        | \"\"\n                    )\n                )\n                + RPAR\n                | \"\"\n            )\n            + SEMI\n        ).set_name(\"moduleHdr\")\n\n        module_expr = Group(\n            moduleHdr + Group(moduleItem[...:endmodule]) + endmodule\n        ).set_name(\n            \"module\"\n        )  # .setDebug()\n\n        udpDecl = outputDecl | inputDecl | regDecl\n        # udpInitVal = one_of(\"1'b0 1'b1 1'bx 1'bX 1'B0 1'B1 1'Bx 1'BX 1 0 x X\")\n        udpInitVal = (Regex(\"1'[bB][01xX]|[01xX]\")).set_name(\"udpInitVal\")\n        udpInitialStmt = Group(\n            \"initial\" + identifier + EQ + udpInitVal + SEMI\n        ).set_name(\"udpInitialStmt\")\n\n        levelSymbol = one_of(\"0   1   x   X   ?   b   B\")\n        levelInputList = Group(levelSymbol[1, ...].set_name(\"levelInpList\"))\n\n        outputSymbol = one_of(\"0   1   x   X\")\n        combEntry = Group(levelInputList + COLON + outputSymbol + SEMI)\n        edgeSymbol = one_of(\"r   R   f   F   p   P   n   N   *\")\n        edge = Group(LPAR + levelSymbol + levelSymbol + RPAR) | Group(edgeSymbol)\n        edgeInputList = Group(levelSymbol[...] + edge + levelSymbol[...])\n        inputList = levelInputList | edgeInputList\n        seqEntry = Group(\n            inputList + COLON + levelSymbol + COLON + (outputSymbol | \"-\") + SEMI\n        ).set_name(\"seqEntry\")\n        udpTableDefn = Group(\n            table + (combEntry | seqEntry)[1, ...] + endtable\n        ).set_name(\"table\")\n\n        \"\"\"\n        <UDP>\n        ::= primitive <name_of_UDP> ( <name_of_variable> <,<name_of_variable>>* ) ;\n                <UDP_declaration>+\n                <UDP_initial_statement>?\n                <table_definition>\n                endprimitive\n        \"\"\"\n        udp = Group(\n            primitive\n            + identifier\n            + LPAR\n            + Group(DelimitedList(identifier))\n            + RPAR\n            + SEMI\n            + udpDecl[1, ...]\n            + (udpInitialStmt | \"\")\n            + udpTableDefn\n            + endprimitive\n        )\n\n        verilogbnf = (module_expr | udp)[1, ...] + StringEnd()\n\n        verilogbnf.ignore(cppStyleComment)\n        verilogbnf.ignore(compilerDirective)\n\n    return verilogbnf\n\n\ndef test(strng):\n    tokens = []\n    try:\n        tokens = make_verilog_bnf().parse_string(strng)\n    except ParseException as err:\n        print(err.explain())\n    return tokens\n\n\nif __name__ == \"__main__\":\n\n    def main():\n        import sys\n\n        sys.setrecursionlimit(5000)\n        print(f\"Verilog parser test (V {__version__})\")\n        print(f\" - using pyparsing version {pyparsing.__version__}\")\n        print(f\" - using Python version {sys.version}\")\n        if packratOn:\n            print(\" - using packrat parsing\")\n        print()\n\n        import gc\n\n        failCount = 0\n        make_verilog_bnf()\n        numlines = 0\n        fileDir = \"verilog\"\n        fileDir = \"scratch/verilog\"\n        # fileDir = \"scratch/verilog/new3\"\n        fileDir = Path(fileDir)\n        allFiles = [f for f in fileDir.glob(\"*.v\")]\n\n        pretty = pprint.PrettyPrinter(indent=2)\n        totalTime = 0\n        for vfile in allFiles:\n            gc.collect()\n            gc.collect()\n            filelines = vfile.read_text().splitlines()\n            print(vfile.name, len(filelines), end=\" \")\n            numlines += len(filelines)\n            teststr = \"\\n\".join(filelines)\n            time1 = time.perf_counter()\n            tokens = test(teststr)\n            time2 = time.perf_counter()\n            elapsed = time2 - time1\n            totalTime += elapsed\n            if len(tokens):\n                print(f\"OK {elapsed}\")\n\n                (fileDir / \"parseOutput\").mkdir(exist_ok=True)\n                outfile = fileDir / \"parseOutput\" / (vfile.name + \".parsed.txt\")\n                outfile.write_text(f\"{teststr}\\n\\n{pretty.pformat(tokens.as_list())}\\n\")\n            else:\n                print(f\"failed {elapsed}\")\n                failCount += 1\n                for i, line in enumerate(filelines, 1):\n                    print(f\"{i:4d}: {line.rstrip()}\")\n\n        print(f\"Total parse time: {totalTime}\")\n        print(f\"Total source lines: {numlines}\")\n        print(f\"Average lines/sec: {numlines / (totalTime + 0.05):.1f}\")\n        if failCount:\n            print(f\"FAIL - {failCount} files failed to parse\")\n        else:\n            print(\"SUCCESS - all files parsed\")\n\n        return 0\n\n    main()\n", "examples/greeting.py": "# greeting.py\n#\n# Demonstration of the pyparsing module, on the prototypical \"Hello, World!\"\n# example\n#\n# Copyright 2003, 2019 by Paul McGuire\n#\nimport pyparsing as pp\n\n# define grammar\ngreet = pp.Word(pp.alphas) + \",\" + pp.Word(pp.alphas) + pp.one_of(\"! ? .\")\n\n# input string\nhello = \"Hello, World!\"\n\n# parse input string\nprint(hello, \"->\", greet.parse_string(hello))\n\n# parse a bunch of input strings\ngreet.run_tests(\n    \"\"\"\\\n    Hello, World!\n    Ahoy, Matey!\n    Howdy, Pardner!\n    Morning, Neighbor!\n    \"\"\"\n)\n", "examples/scanExamples.py": "#\n# scanExamples.py\n#\n#  Illustration of using pyparsing's scanString,transformString, and searchString methods\n#\n# Copyright (c) 2004, 2006 Paul McGuire\n#\nfrom pyparsing import (\n    Word,\n    alphas,\n    alphanums,\n    Literal,\n    restOfLine,\n    OneOrMore,\n    empty,\n    Suppress,\n    replaceWith,\n)\n\n# simulate some C++ code\ntestData = \"\"\"\n#define MAX_LOCS=100\n#define USERNAME = \"floyd\"\n#define PASSWORD = \"swordfish\"\n\na = MAX_LOCS;\nCORBA::initORB(\"xyzzy\", USERNAME, PASSWORD );\n\n\"\"\"\n\n#################\nprint(\"Example of an extractor\")\nprint(\"----------------------\")\n\n# simple grammar to match #define's\nident = Word(alphas, alphanums + \"_\")\nmacroDef = (\n    Literal(\"#define\")\n    + ident.setResultsName(\"name\")\n    + \"=\"\n    + restOfLine.setResultsName(\"value\")\n)\nfor t, s, e in macroDef.scanString(testData):\n    print(t.name, \":\", t.value)\n\n# or a quick way to make a dictionary of the names and values\n# (return only key and value tokens, and construct dict from key-value pairs)\n# - empty ahead of restOfLine advances past leading whitespace, does implicit lstrip during parsing\nmacroDef = Suppress(\"#define\") + ident + Suppress(\"=\") + empty + restOfLine\nmacros = dict(list(macroDef.searchString(testData)))\nprint(\"macros =\", macros)\nprint()\n\n\n#################\nprint(\"Examples of a transformer\")\nprint(\"----------------------\")\n\n# convert C++ namespaces to mangled C-compatible names\nscopedIdent = ident + OneOrMore(Literal(\"::\").suppress() + ident)\nscopedIdent.setParseAction(lambda t: \"_\".join(t))\n\nprint(\"(replace namespace-scoped names with C-compatible names)\")\nprint(scopedIdent.transformString(testData))\n\n\n# or a crude pre-processor (use parse actions to replace matching text)\ndef substituteMacro(s, l, t):\n    if t[0] in macros:\n        return macros[t[0]]\n\n\nident.setParseAction(substituteMacro)\nident.ignore(macroDef)\n\nprint(\"(simulate #define pre-processor)\")\nprint(ident.transformString(testData))\n\n\n#################\nprint(\"Example of a stripper\")\nprint(\"----------------------\")\n\nfrom pyparsing import dblQuotedString, LineStart\n\n# remove all string macro definitions (after extracting to a string resource table?)\nstringMacroDef = Literal(\"#define\") + ident + \"=\" + dblQuotedString + LineStart()\nstringMacroDef.setParseAction(replaceWith(\"\"))\n\nprint(stringMacroDef.transformString(testData))\n", "examples/railroad_diagram_demo.py": "import pyparsing as pp\n\nppc = pp.pyparsing_common\n\n# fmt: off\nword = pp.Word(pp.alphas).setName(\"word\")\ninteger = pp.Word(pp.nums).setName(\"integer\")\nplus_minus = pp.Char(\"+-\").set_name(\"add_sub\")\nmult_div = pp.Char(\"*/\").set_name(\"mult_div\")\nstreet_address = pp.Group(integer(\"house_number\")\n                          + word[1, ...](\"street_name\")\n                          ).setName(\"street_address\")\ntime = pp.Regex(r\"\\d\\d:\\d\\d\")\n\ngrammar = (pp.Group(integer[1, ...])\n           + (ppc.ipv4_address\n              & word(\"header_word\")\n              & pp.Optional(time)\n              ).setName(\"header with various elements\")(\"header\")\n           + street_address(\"address\")\n           + pp.Group(pp.counted_array(word))\n           + pp.Group(integer * 8)(\"data\")\n           + pp.Group(pp.Word(\"abc\") + pp.Word(\"def\")*3)\n           + pp.infix_notation(integer,\n                               [\n                                   (plus_minus().setName(\"pos_neg\"), 1, pp.opAssoc.RIGHT),\n                                   (mult_div, 2, pp.opAssoc.LEFT),\n                                   (plus_minus, 2, pp.opAssoc.LEFT),\n                               ]).setName(\"simple_arithmetic\")\n           + ...\n           + pp.Group(ppc.ipv4_address)(\"ip_address\")\n           ).setName(\"grammar\")\n\n\ngrammar.create_diagram(\"railroad_diagram_demo.html\", vertical=6, show_results_names=True)\n\ntest = \"\"\"\\\n    1 2 3 \n    ABC 1.2.3.4 12:45\n    123 Main St \n    4\n    abc def ghi jkl \n    5 5 5 5 5 5 5 5 \n    a d d d \n    2+2 \n    alice bob charlie dave 5.6.7.8\"\"\"\nresult = grammar.runTests([test])\n", "examples/TAP.py": "#\n# TAP.py - TAP parser\n#\n# A pyparsing parser to process the output of the Perl\n#   \"Test Anything Protocol\"\n#   (https://metacpan.org/pod/release/PETDANCE/TAP-1.00/TAP.pm)\n#\n# TAP output lines are preceded or followed by a test number range:\n#   1..n\n# with 'n' TAP output lines.\n#\n# The general format of a TAP output line is:\n#   ok/not ok (required)\n#   Test number (recommended)\n#   Description (recommended)\n#   Directive (only when necessary)\n#\n# A TAP output line may also indicate abort of the test suit with the line:\n#   Bail out!\n# optionally followed by a reason for bailing\n#\n# Copyright 2008, by Paul McGuire\n#\n\nfrom pyparsing import (\n    ParserElement,\n    LineEnd,\n    Optional,\n    Word,\n    nums,\n    Regex,\n    Literal,\n    CaselessLiteral,\n    Group,\n    OneOrMore,\n    Suppress,\n    restOfLine,\n    FollowedBy,\n    empty,\n)\n\n__all__ = [\"tapOutputParser\", \"TAPTest\", \"TAPSummary\"]\n\n# newlines are significant whitespace, so set default skippable\n# whitespace to just spaces and tabs\nParserElement.setDefaultWhitespaceChars(\" \\t\")\nNL = LineEnd().suppress()\n\ninteger = Word(nums)\nplan = \"1..\" + integer(\"ubound\")\n\nOK, NOT_OK = map(Literal, [\"ok\", \"not ok\"])\ntestStatus = OK | NOT_OK\n\ndescription = Regex(\"[^#\\n]+\")\ndescription.setParseAction(lambda t: t[0].lstrip(\"- \"))\n\nTODO, SKIP = map(CaselessLiteral, \"TODO SKIP\".split())\ndirective = Group(\n    Suppress(\"#\")\n    + (\n        TODO + restOfLine\n        | FollowedBy(SKIP) + restOfLine.copy().setParseAction(lambda t: [\"SKIP\", t[0]])\n    )\n)\n\ncommentLine = Suppress(\"#\") + empty + restOfLine\n\ntestLine = Group(\n    Optional(OneOrMore(commentLine + NL))(\"comments\")\n    + testStatus(\"passed\")\n    + Optional(integer)(\"testNumber\")\n    + Optional(description)(\"description\")\n    + Optional(directive)(\"directive\")\n)\nbailLine = Group(Literal(\"Bail out!\")(\"BAIL\") + empty + Optional(restOfLine)(\"reason\"))\n\ntapOutputParser = Optional(Group(plan)(\"plan\") + NL) & Group(\n    OneOrMore((testLine | bailLine) + NL)\n)(\"tests\")\n\n\nclass TAPTest:\n    def __init__(self, results):\n        self.num = results.testNumber\n        self.passed = results.passed == \"ok\"\n        self.skipped = self.todo = False\n        if results.directive:\n            self.skipped = results.directive[0][0] == \"SKIP\"\n            self.todo = results.directive[0][0] == \"TODO\"\n\n    @classmethod\n    def bailedTest(cls, num):\n        ret = TAPTest(empty.parseString(\"\"))\n        ret.num = num\n        ret.skipped = True\n        return ret\n\n\nclass TAPSummary:\n    def __init__(self, results):\n        self.passedTests = []\n        self.failedTests = []\n        self.skippedTests = []\n        self.todoTests = []\n        self.bonusTests = []\n        self.bail = False\n        if results.plan:\n            expected = list(range(1, int(results.plan.ubound) + 1))\n        else:\n            expected = list(range(1, len(results.tests) + 1))\n\n        for i, res in enumerate(results.tests):\n            # test for bail out\n            if res.BAIL:\n                # ~ print \"Test suite aborted: \" + res.reason\n                # ~ self.failedTests += expected[i:]\n                self.bail = True\n                self.skippedTests += [TAPTest.bailedTest(ii) for ii in expected[i:]]\n                self.bailReason = res.reason\n                break\n\n            # ~ print res.dump()\n            testnum = i + 1\n            if res.testNumber != \"\":\n                if testnum != int(res.testNumber):\n                    print(\"ERROR! test %(testNumber)s out of sequence\" % res)\n                testnum = int(res.testNumber)\n            res[\"testNumber\"] = testnum\n\n            test = TAPTest(res)\n            if test.passed:\n                self.passedTests.append(test)\n            else:\n                self.failedTests.append(test)\n            if test.skipped:\n                self.skippedTests.append(test)\n            if test.todo:\n                self.todoTests.append(test)\n            if test.todo and test.passed:\n                self.bonusTests.append(test)\n\n        self.passedSuite = not self.bail and (\n            set(self.failedTests) - set(self.todoTests) == set()\n        )\n\n    def summary(self, showPassed=False, showAll=False):\n        testListStr = lambda tl: \"[\" + \",\".join(str(t.num) for t in tl) + \"]\"\n        summaryText = []\n        if showPassed or showAll:\n            summaryText.append(f\"PASSED: {testListStr(self.passedTests)}\")\n        if self.failedTests or showAll:\n            summaryText.append(f\"FAILED: {testListStr(self.failedTests)}\")\n        if self.skippedTests or showAll:\n            summaryText.append(f\"SKIPPED: {testListStr(self.skippedTests)}\")\n        if self.todoTests or showAll:\n            summaryText.append(f\"TODO: {testListStr(self.todoTests)}\")\n        if self.bonusTests or showAll:\n            summaryText.append(f\"BONUS: {testListStr(self.bonusTests)}\")\n        if self.passedSuite:\n            summaryText.append(\"PASSED\")\n        else:\n            summaryText.append(\"FAILED\")\n        return \"\\n\".join(summaryText)\n\n\n# create TAPSummary objects from tapOutput parsed results, by setting\n# class as parse action\ntapOutputParser.setParseAction(TAPSummary)\n\n\ndef main():\n    test1 = \"\"\"\\\n        1..4\n        ok 1 - Input file opened\n        not ok 2 - First line of the input valid\n        ok 3 - Read the rest of the file\n        not ok 4 - Summarized correctly # TODO Not written yet\n        \"\"\"\n    test2 = \"\"\"\\\n        ok 1\n        not ok 2 some description # TODO with a directive\n        ok 3 a description only, no directive\n        ok 4 # TODO directive only\n        ok a description only, no directive\n        ok # Skipped only a directive, no description\n        ok\n        \"\"\"\n    test3 = \"\"\"\\\n        ok - created Board\n        ok\n        ok\n        not ok\n        ok\n        ok\n        ok\n        ok\n        # +------+------+------+------+\n        # |      |16G   |      |05C   |\n        # |      |G N C |      |C C G |\n        # |      |  G   |      |  C  +|\n        # +------+------+------+------+\n        # |10C   |01G   |      |03C   |\n        # |R N G |G A G |      |C C C |\n        # |  R   |  G   |      |  C  +|\n        # +------+------+------+------+\n        # |      |01G   |17C   |00C   |\n        # |      |G A G |G N R |R N R |\n        # |      |  G   |  R   |  G   |\n        # +------+------+------+------+\n        ok - board has 7 tiles + starter tile\n        1..9\n        \"\"\"\n    test4 = \"\"\"\\\n        1..4\n        ok 1 - Creating test program\n        ok 2 - Test program runs, no error\n        not ok 3 - infinite loop # TODO halting problem unsolved\n        not ok 4 - infinite loop 2 # TODO halting problem unsolved\n        \"\"\"\n    test5 = \"\"\"\\\n        1..20\n        ok - database handle\n        not ok - failed database login\n        Bail out! Couldn't connect to database.\n        \"\"\"\n    test6 = \"\"\"\\\n        ok 1 - retrieving servers from the database\n        # need to ping 6 servers\n        ok 2 - pinged diamond\n        ok 3 - pinged ruby\n        not ok 4 - pinged sapphire\n        ok 5 - pinged onyx\n        not ok 6 - pinged quartz\n        ok 7 - pinged gold\n        1..7\n        \"\"\"\n\n    for test in (test1, test2, test3, test4, test5, test6):\n        print(test)\n        tapResult = tapOutputParser.parseString(test)[0]\n        print(tapResult.summary(showAll=True))\n        print()\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/adventureEngine.py": "# adventureEngine.py\n# Copyright 2005-2006, Paul McGuire\n#\n# Updated 2012 - latest pyparsing API\n# Updated 2023 - using PEP8 API names\n#\n\nimport pyparsing as pp\nimport random\nimport string\n\n\ndef a_or_an(item):\n    if item.desc.startswith(tuple(\"aeiou\")):\n        return \"an \" + item.desc\n    else:\n        return \"a \" + item.desc\n\ndef enumerate_items(items_list):\n    if not items_list:\n        return \"nothing\"\n    *all_but_last, last = items_list\n    out = []\n    if all_but_last:\n        out.append(\", \".join(a_or_an(item) for item in all_but_last))\n        if len(all_but_last) > 1:\n            out[-1] += ','\n        out.append(\"and\")\n    out.append(a_or_an(last))\n    return \" \".join(out)\n\ndef enumerate_doors(doors_list):\n    if not doors_list:\n        return \"\"\n    *all_but_last, last = doors_list\n    out = []\n    if all_but_last:\n        out.append(\", \".join(all_but_last))\n        if len(all_but_last) > 1:\n            out[-1] += ','\n        out.append(\"and\")\n    out.append(last)\n    return \" \".join(out)\n\n\nclass Room:\n    def __init__(self, desc):\n        self.desc = desc\n        self.inv = []\n        self.gameOver = False\n        self.doors = [None, None, None, None]\n\n    def __getattr__(self, attr):\n        return {\n            \"n\": self.doors[0],\n            \"s\": self.doors[1],\n            \"e\": self.doors[2],\n            \"w\": self.doors[3],\n        }[attr]\n\n    def enter(self, player):\n        if self.gameOver:\n            player.gameOver = True\n\n    def add_item(self, it):\n        self.inv.append(it)\n\n    def remove_item(self, it):\n        self.inv.remove(it)\n\n    def describe(self):\n        print(self.desc)\n        visibleItems = [it for it in self.inv if it.isVisible]\n        if random.random() > 0.5:\n            if len(visibleItems) > 1:\n                is_form = \"are\"\n            else:\n                is_form = \"is\"\n            print(f\"There {is_form} {enumerate_items(visibleItems)} here.\")\n        else:\n            print(f\"You see {enumerate_items(visibleItems)}.\")\n\n\nclass Exit(Room):\n    def __init__(self):\n        super().__init__(\"\")\n\n    def enter(self, player):\n        player.gameOver = True\n\n\nclass Item:\n    items = {}\n\n    def __init__(self, desc):\n        self.desc = desc\n        self.isDeadly = False\n        self.isFragile = False\n        self.isBroken = False\n        self.isTakeable = True\n        self.isVisible = True\n        self.isOpenable = False\n        self.useAction = None\n        self.usableConditionTest = None\n        self.cantTakeMessage = \"You can't take that!\"\n        Item.items[desc] = self\n\n    def __str__(self):\n        return self.desc\n\n    def breakItem(self):\n        if not self.isBroken:\n            print(\"<Crash!>\")\n            self.desc = \"broken \" + self.desc\n            self.isBroken = True\n\n    def isUsable(self, player, target):\n        if self.usableConditionTest:\n            return self.usableConditionTest(player, target)\n        else:\n            return False\n\n    def useItem(self, player, target):\n        if self.useAction:\n            self.useAction(player, self, target)\n\n\nclass OpenableItem(Item):\n    def __init__(self, desc, contents=None):\n        super().__init__(desc)\n        self.isOpenable = True\n        self.isOpened = False\n        if contents is not None:\n            if isinstance(contents, Item):\n                self.contents = [\n                    contents,\n                ]\n            else:\n                self.contents = contents\n        else:\n            self.contents = []\n\n    def open_item(self, player):\n        if not self.isOpened:\n            self.isOpened = not self.isOpened\n            if self.contents is not None:\n                for item in self.contents:\n                    player.room.add_item(item)\n                self.contents = []\n            self.desc = \"open \" + self.desc\n\n    def close_item(self, player):\n        if self.isOpened:\n            self.isOpened = not self.isOpened\n            if self.desc.startswith(\"open \"):\n                self.desc = self.desc[5:]\n\n\nclass Command:\n    \"Base class for commands\"\n\n    def __init__(self, verb, verbProg):\n        self.verb = verb\n        self.verbProg = verbProg\n\n    @staticmethod\n    def help_description():\n        return \"\"\n\n    def _do_command(self, player):\n        pass\n\n    def __call__(self, player):\n        print(self.verbProg.capitalize() + \"...\")\n        self._do_command(player)\n\n\nclass MoveCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"MOVE\", \"moving\")\n        self.direction = quals.direction[0]\n\n    @staticmethod\n    def help_description():\n        return \"\"\"MOVE or GO - go NORTH, SOUTH, EAST, or WEST\n          (can abbreviate as 'GO N' and 'GO W', or even just 'E' and 'S')\"\"\"\n\n    def _do_command(self, player):\n        rm = player.room\n        nextRoom = rm.doors[\n            {\n                \"N\": 0,\n                \"S\": 1,\n                \"E\": 2,\n                \"W\": 3,\n            }[self.direction]\n        ]\n        if nextRoom:\n            player.moveTo(nextRoom)\n        else:\n            print(\"Can't go that way.\")\n\n\nclass TakeCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"TAKE\", \"taking\")\n        self.subject = quals.item\n\n    @staticmethod\n    def help_description():\n        return \"TAKE or PICKUP or PICK UP - pick up an object (but some are deadly)\"\n\n    def _do_command(self, player):\n        rm = player.room\n        subj = Item.items[self.subject]\n        if subj in rm.inv and subj.isVisible:\n            if subj.isTakeable:\n                rm.remove_item(subj)\n                player.take(subj)\n            else:\n                print(subj.cantTakeMessage)\n        else:\n            print(f\"There is no {subj} here.\")\n\n\nclass DropCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"DROP\", \"dropping\")\n        self.subject = quals.item\n\n    @staticmethod\n    def help_description():\n        return \"DROP or LEAVE - drop an object (but fragile items may break)\"\n\n    def _do_command(self, player):\n        rm = player.room\n        subj = Item.items[self.subject]\n        if subj in player.inv:\n            rm.add_item(subj)\n            player.drop(subj)\n        else:\n            print(f\"You don't have {a_or_an(subj)}.\")\n\n\nclass InventoryCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"INV\", \"taking inventory\")\n\n    @staticmethod\n    def help_description():\n        return \"INVENTORY or INV or I - lists what items you have\"\n\n    def _do_command(self, player):\n        print(f\"You have {enumerate_items(player.inv)}.\")\n\n\nclass LookCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"LOOK\", \"looking\")\n\n    @staticmethod\n    def help_description():\n        return \"LOOK or L - describes the current room and any objects in it\"\n\n    def _do_command(self, player):\n        player.room.describe()\n\n\nclass ExamineCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"EXAMINE\", \"examining\")\n        self.subject = Item.items[quals.item]\n\n    @staticmethod\n    def help_description():\n        return \"EXAMINE or EX or X - look closely at an object\"\n\n    def _do_command(self, player):\n        msg = random.choice(\n            [\n                \"It's {}.\",\n                \"It's just {}.\",\n                \"It's a beautiful {1}.\",\n                \"It's a rare and beautiful {1}.\",\n                \"It's a rare {1}.\",\n                \"Just {}, nothing special...\",\n                \"{0}, just {0}.\"\n            ]\n        )\n        print(msg.format(a_or_an(self.subject), self.subject).capitalize())\n\n\nclass DoorsCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"DOORS\", \"looking for doors\")\n\n    @staticmethod\n    def help_description():\n        return \"DOORS - display what doors are visible from this room\"\n\n    def _do_command(self, player):\n        rm = player.room\n        numDoors = sum(1 for r in rm.doors if r is not None)\n        if numDoors == 0:\n            reply = \"There are no doors in any direction.\"\n        else:\n            if numDoors == 1:\n                reply = \"There is a door to the \"\n            else:\n                reply = \"There are doors to the \"\n            doorNames = [\n                {0: \"north\", 1: \"south\", 2: \"east\", 3: \"west\"}[i]\n                for i, d in enumerate(rm.doors)\n                if d is not None\n            ]\n            reply += enumerate_doors(doorNames)\n            reply += \".\"\n            print(reply)\n\n\nclass UseCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"USE\", \"using\")\n        self.subject = Item.items[quals.usedObj]\n        if quals.targetObj:\n            self.target = Item.items[quals.targetObj]\n        else:\n            self.target = None\n\n    @staticmethod\n    def help_description():\n        return \"USE or U - use an object, optionally IN or ON another object\"\n\n    def _do_command(self, player):\n        rm = player.room\n        availItems = rm.inv + player.inv\n        if self.subject in availItems:\n            if self.subject.isUsable(player, self.target):\n                self.subject.useItem(player, self.target)\n            else:\n                print(\"You can't use that here.\")\n        else:\n            print(f\"There is no {self.subject} here to use.\")\n\n\nclass OpenCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"OPEN\", \"opening\")\n        self.subject = Item.items[quals.item]\n\n    @staticmethod\n    def help_description():\n        return \"OPEN or O - open an object\"\n\n    def _do_command(self, player):\n        rm = player.room\n        availItems = rm.inv + player.inv\n        if self.subject in availItems:\n            if self.subject.isOpenable:\n                if not self.subject.isOpened:\n                    self.subject.open_item(player)\n                else:\n                    print(\"It's already open.\")\n            else:\n                print(\"You can't open that.\")\n        else:\n            print(f\"There is no {self.subject} here to open.\")\n\n\nclass CloseCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"CLOSE\", \"closing\")\n        self.subject = Item.items[quals.item]\n\n    @staticmethod\n    def help_description():\n        return \"CLOSE or CL - close an object\"\n\n    def _do_command(self, player):\n        rm = player.room\n        availItems = rm.inv + player.inv\n        if self.subject in availItems:\n            if self.subject.isOpenable:\n                if self.subject.isOpened:\n                    self.subject.close_item(player)\n                else:\n                    print(\"You can't close that, it's not open.\")\n            else:\n                print(\"You can't close that.\")\n        else:\n            print(f\"There is no {self.subject} here to close.\")\n\n\nclass QuitCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"QUIT\", \"quitting\")\n\n    @staticmethod\n    def help_description():\n        return \"QUIT or Q - ends the game\"\n\n    def _do_command(self, player):\n        print(\"Ok....\")\n        player.gameOver = True\n\n\nclass HelpCommand(Command):\n    def __init__(self, quals):\n        super().__init__(\"HELP\", \"helping\")\n\n    @staticmethod\n    def help_description():\n        return \"HELP or H or ? - displays this help message\"\n\n    def _do_command(self, player):\n        print(\"Enter any of the following commands (not case sensitive):\")\n        for cmd in [\n            InventoryCommand,\n            DropCommand,\n            TakeCommand,\n            UseCommand,\n            OpenCommand,\n            CloseCommand,\n            MoveCommand,\n            LookCommand,\n            ExamineCommand,\n            DoorsCommand,\n            QuitCommand,\n            HelpCommand,\n        ]:\n            print(f\"  - {cmd.help_description()}\")\n        print()\n\n\nclass AppParseException(pp.ParseException):\n    pass\n\n\nclass Parser:\n    def __init__(self):\n        self.bnf = self.make_bnf()\n\n    def make_bnf(self):\n        invVerb = pp.one_of(\"INV INVENTORY I\", caseless=True)\n        dropVerb = pp.one_of(\"DROP LEAVE\", caseless=True)\n        takeVerb = pp.one_of(\"TAKE PICKUP\", caseless=True) | (\n            pp.CaselessLiteral(\"PICK\") + pp.CaselessLiteral(\"UP\")\n        )\n        moveVerb = pp.one_of(\"MOVE GO\", caseless=True) | pp.Empty()\n        useVerb = pp.one_of(\"USE U\", caseless=True)\n        openVerb = pp.one_of(\"OPEN O\", caseless=True)\n        closeVerb = pp.one_of(\"CLOSE CL\", caseless=True)\n        quitVerb = pp.one_of(\"QUIT Q\", caseless=True)\n        lookVerb = pp.one_of(\"LOOK L\", caseless=True)\n        doorsVerb = pp.CaselessLiteral(\"DOORS\")\n        helpVerb = pp.one_of(\"H HELP ?\", caseless=True)\n\n        itemRef = pp.OneOrMore(pp.Word(pp.alphas)).set_parse_action(self.validate_item_name).setName(\"item_ref\")\n        nDir = pp.one_of(\"N NORTH\", caseless=True).set_parse_action(pp.replace_with(\"N\"))\n        sDir = pp.one_of(\"S SOUTH\", caseless=True).set_parse_action(pp.replace_with(\"S\"))\n        eDir = pp.one_of(\"E EAST\", caseless=True).set_parse_action(pp.replace_with(\"E\"))\n        wDir = pp.one_of(\"W WEST\", caseless=True).set_parse_action(pp.replace_with(\"W\"))\n        moveDirection = nDir | sDir | eDir | wDir\n\n        invCommand = invVerb\n        dropCommand = dropVerb + itemRef(\"item\")\n        takeCommand = takeVerb + itemRef(\"item\")\n        useCommand = (\n            useVerb\n            + itemRef(\"usedObj\")\n            + pp.Opt(pp.one_of(\"IN ON\", caseless=True))\n            + pp.Opt(itemRef, default=None)(\"targetObj\")\n        )\n        openCommand = openVerb + itemRef(\"item\")\n        closeCommand = closeVerb + itemRef(\"item\")\n        moveCommand = (moveVerb | \"\") + moveDirection(\"direction\")\n        quitCommand = quitVerb\n        lookCommand = lookVerb\n        examineCommand = pp.one_of(\"EXAMINE EX X\", caseless=True) + itemRef(\"item\")\n        doorsCommand = doorsVerb.setName(\"DOORS\")\n        helpCommand = helpVerb\n\n        # attach command classes to expressions\n        invCommand.set_parse_action(InventoryCommand)\n        dropCommand.set_parse_action(DropCommand)\n        takeCommand.set_parse_action(TakeCommand)\n        useCommand.set_parse_action(UseCommand)\n        openCommand.set_parse_action(OpenCommand)\n        closeCommand.set_parse_action(CloseCommand)\n        moveCommand.set_parse_action(MoveCommand)\n        quitCommand.set_parse_action(QuitCommand)\n        lookCommand.set_parse_action(LookCommand)\n        examineCommand.set_parse_action(ExamineCommand)\n        doorsCommand.set_parse_action(DoorsCommand)\n        helpCommand.set_parse_action(HelpCommand)\n\n        # define parser using all command expressions\n        parser = pp.ungroup(\n            invCommand\n            | useCommand\n            | openCommand\n            | closeCommand\n            | dropCommand\n            | takeCommand\n            | moveCommand\n            | lookCommand\n            | examineCommand\n            | doorsCommand\n            | helpCommand\n            | quitCommand\n        )(\"command\")\n\n        return parser\n\n    def validate_item_name(self, s, l, t):\n        iname = \" \".join(t)\n        if iname not in Item.items:\n            raise AppParseException(s, l, f\"No such item '{iname}'.\")\n        return iname\n\n    def parse_cmd(self, cmdstr):\n        try:\n            ret = self.bnf.parse_string(cmdstr)\n            return ret\n        except AppParseException as pe:\n            print(pe.msg)\n        except pp.ParseException as pe:\n            print(\n                random.choice(\n                    [\n                        \"Sorry, I don't understand that.\",\n                        \"Huh?\",\n                        \"Excuse me?\",\n                        \"???\",\n                        \"What?\",\n                    ]\n                )\n            )\n\n\nclass Player:\n    def __init__(self, name):\n        self.name = name\n        self.gameOver = False\n        self.inv = []\n\n    def moveTo(self, rm):\n        self.room = rm\n        rm.enter(self)\n        if self.gameOver:\n            if rm.desc:\n                rm.describe()\n            print(\"Game over!\")\n        else:\n            rm.describe()\n\n    def take(self, it):\n        if it.isDeadly:\n            print(f\"Aaaagh!...., the {it} killed me!\")\n            self.gameOver = True\n        else:\n            self.inv.append(it)\n\n    def drop(self, it):\n        self.inv.remove(it)\n        if it.isFragile:\n            it.breakItem()\n\n\ndef createRooms(rm):\n    \"\"\"\n    create rooms, using multiline string showing map layout\n    string contains symbols for the following:\n     A-Z, a-z indicate rooms, and rooms will be stored in a dictionary by\n               reference letter\n     -, | symbols indicate connection between rooms\n     <, >, ^, . symbols indicate one-way connection between rooms\n    \"\"\"\n    # start with empty dictionary of rooms\n    ret = {}\n\n    # look for room symbols, and initialize dictionary\n    # - exit room is always marked 'Z'\n    for c in rm:\n        if c in string.ascii_letters:\n            if c != \"Z\":\n                ret[c] = Room(c)\n            else:\n                ret[c] = Exit()\n\n    # scan through input string looking for connections between rooms\n    rows = rm.split(\"\\n\")\n    for row, line in enumerate(rows):\n        for col, c in enumerate(line):\n            if c in string.ascii_letters:\n                room = ret[c]\n                n = None\n                s = None\n                e = None\n                w = None\n\n                # look in neighboring cells for connection symbols (must take\n                # care to guard that neighboring cells exist before testing\n                # contents)\n                if col > 0 and line[col - 1] in \"<-\":\n                    other = line[col - 2]\n                    w = ret[other]\n                if col < len(line) - 1 and line[col + 1] in \"->\":\n                    other = line[col + 2]\n                    e = ret[other]\n                if row > 1 and col < len(rows[row - 1]) and rows[row - 1][col] in \"|^\":\n                    other = rows[row - 2][col]\n                    n = ret[other]\n                if (\n                    row < len(rows) - 1\n                    and col < len(rows[row + 1])\n                    and rows[row + 1][col] in \"|.\"\n                ):\n                    other = rows[row + 2][col]\n                    s = ret[other]\n\n                # set connections to neighboring rooms\n                room.doors = [n, s, e, w]\n\n    return ret\n\n\n# put items in rooms\ndef putItemInRoom(i, r):\n    if isinstance(r, str):\n        r = rooms[r]\n    r.add_item(Item.items[i])\n\n\ndef playGame(p, startRoom):\n    # create parser\n    parser = Parser()\n    p.moveTo(startRoom)\n    while not p.gameOver:\n        cmdstr = input(\">> \")\n        cmd = parser.parse_cmd(cmdstr)\n        if cmd is not None:\n            cmd.command(p)\n    print()\n    print(\"You ended the game with:\")\n    for i in p.inv:\n        print(\" -\", a_or_an(i))\n\n\nif __name__ == '__main__':\n    # start game definition\n    roomMap = \"\"\"\n         d-Z\n         |\n       f-c-e\n       . |\n       q<b\n         |\n         A\n    \"\"\"\n    rooms = createRooms(roomMap)\n    rooms[\"A\"].desc = \"You are standing on the front porch of a wooden shack.\"\n    rooms[\"b\"].desc = \"You are in a garden.\"\n    rooms[\"c\"].desc = \"You are in a kitchen.\"\n    rooms[\"d\"].desc = \"You are on the back porch.\"\n    rooms[\"e\"].desc = \"You are in a library.\"\n    rooms[\"f\"].desc = \"You are on the patio.\"\n    rooms[\"q\"].desc = \"You are sinking in quicksand.  You're dead...\"\n    rooms[\"q\"].gameOver = True\n\n    # define global variables for referencing rooms\n    frontPorch = rooms[\"A\"]\n    garden = rooms[\"b\"]\n    kitchen = rooms[\"c\"]\n    backPorch = rooms[\"d\"]\n    library = rooms[\"e\"]\n    patio = rooms[\"f\"]\n\n    # create items\n    itemNames = (\n        \"\"\"sword.diamond.apple.flower.coin.shovel.book.mirror.telescope.gold bar\"\"\".split(\n            \".\"\n        )\n    )\n    for itemName in itemNames:\n        Item(itemName)\n    Item.items[\"apple\"].isDeadly = True\n    Item.items[\"mirror\"].isFragile = True\n    Item.items[\"coin\"].isVisible = False\n    Item.items[\"shovel\"].usableConditionTest = lambda p, t: p.room is garden\n\n\n    def use_shovel(p, subj, target):\n        coin = Item.items[\"coin\"]\n        if not coin.isVisible and coin in p.room.inv:\n            coin.isVisible = True\n\n\n    Item.items[\"shovel\"].useAction = use_shovel\n\n    Item.items[\"telescope\"].isTakeable = False\n\n\n    def use_telescope(p, subj, target):\n        print(\"You don't see anything.\")\n\n\n    Item.items[\"telescope\"].useAction = use_telescope\n\n    OpenableItem(\"treasure chest\", Item.items[\"gold bar\"])\n    Item.items[\"chest\"] = Item.items[\"treasure chest\"]\n    Item.items[\"chest\"].isTakeable = False\n    Item.items[\"chest\"].cantTakeMessage = \"It's too heavy!\"\n\n    OpenableItem(\"mailbox\")\n    Item.items[\"mailbox\"].isTakeable = False\n    Item.items[\"mailbox\"].cantTakeMessage = \"It's nailed to the wall!\"\n\n    putItemInRoom(\"mailbox\", frontPorch)\n    putItemInRoom(\"shovel\", frontPorch)\n    putItemInRoom(\"coin\", garden)\n    putItemInRoom(\"flower\", garden)\n    putItemInRoom(\"apple\", library)\n    putItemInRoom(\"mirror\", library)\n    putItemInRoom(\"telescope\", library)\n    putItemInRoom(\"book\", kitchen)\n    putItemInRoom(\"diamond\", backPorch)\n    putItemInRoom(\"treasure chest\", patio)\n\n    # create player\n    plyr = Player(\"Bob\")\n    plyr.take(Item.items[\"sword\"])\n\n    # start game\n    playGame(plyr, frontPorch)\n", "examples/groupUsingListAllMatches.py": "#\n# A simple example showing the use of the implied listAllMatches=True for\n# results names with a trailing '*' character.\n#\n# This example performs work similar to itertools.groupby, but without\n# having to sort the input first.\n#\n# Copyright 2004-2016, by Paul McGuire\n#\nfrom pyparsing import Word, ZeroOrMore, nums\n\naExpr = Word(\"A\", nums)\nbExpr = Word(\"B\", nums)\ncExpr = Word(\"C\", nums)\ngrammar = ZeroOrMore(aExpr(\"A*\") | bExpr(\"B*\") | cExpr(\"C*\"))\n\ngrammar.runTests(\"A1 B1 A2 C1 B2 A3\")\n", "examples/greetingInKorean.py": "#\n# greetingInKorean.py\n#\n# Demonstration of the parsing module, on the prototypical \"Hello, World!\" example\n#\n# Copyright 2004-2016, by Paul McGuire\n#\nfrom pyparsing import Word, pyparsing_unicode as ppu\n\nkorean_chars = ppu.\ud55c\uad6d\uc5b4.alphas\nkorean_word = Word(korean_chars, min=2)\n\n# define grammar\ngreet = korean_word + \",\" + korean_word + \"!\"\n\n# input string\nhello = \"\uc548\ub155, \uc5ec\ub7ec\ubd84!\"  # \"Hello, World!\" in Korean\n\n# parse input string\nprint(greet.parse_string(hello))\n", "examples/apicheck.py": "# apicheck.py\n#   A simple source code scanner for finding patterns of the form\n#       [ procname1 $arg1 $arg2 ]\n#  and verifying the number of arguments\n#\n# Copyright (c) 2004-2016, Paul McGuire\n#\n\nfrom pyparsing import *\n\n# define punctuation and simple tokens for locating API calls\nLBRACK, RBRACK, LBRACE, RBRACE = map(Suppress, \"[]{}\")\nident = Word(alphas, alphanums + \"_\") | QuotedString(\"{\", endQuoteChar=\"}\")\narg = \"$\" + ident\n\n# define an API call with a specific number of arguments - using '-'\n# will ensure that after matching procname, an incorrect number of args will\n# raise a ParseSyntaxException, which will interrupt the scanString\ndef apiProc(name, numargs):\n    return LBRACK + Keyword(name)(\"procname\") - arg * numargs + RBRACK\n\n\n# create an apiReference, listing all API functions to be scanned for,  and\n# their respective number of arguments.  Beginning the overall expression\n# with FollowedBy allows us to quickly rule out non-api calls while scanning,\n# since all of the api calls begin with a \"[\"\napiRef = FollowedBy(\"[\") + MatchFirst(\n    [\n        apiProc(\"procname1\", 2),\n        apiProc(\"procname2\", 1),\n        apiProc(\"procname3\", 2),\n    ]\n)\n\ntest = \"\"\"[ procname1  $par1 $par2 ]\n          other code here\n          [ procname1 $par1 $par2 $par3 ]\n          more code here\n          [ procname1 $par1 ]\n          [ procname3  ${arg with spaces} $par2 ]\"\"\"\n\n\n# now explicitly iterate through the scanner using next(), so that\n# we can trap ParseSyntaxException's that would be raised due to\n# an incorrect number of arguments. If an exception does occur,\n# then see how we reset the input text and scanner to advance to the\n# next line of source code\napi_scanner = apiRef.scanString(test)\nwhile 1:\n    try:\n        t, s, e = next(api_scanner)\n        print(f\"found {t.procname} on line {lineno(s, test)}\")\n    except ParseSyntaxException as pe:\n        print(f\"invalid arg count on line {pe.lineno}\")\n        print(f\"{pe.lineno} : {pe.line}\")\n        # reset api scanner to start after this exception location\n        test = \"\\n\" * (pe.lineno - 1) + test[pe.loc + 1:]\n        api_scanner = apiRef.scanString(test)\n    except StopIteration:\n        break\n", "examples/html_stripper.py": "#\n# html_stripper.py\n#\n#  Sample code for stripping HTML markup tags and scripts from\n#  HTML source files.\n#\n# Copyright (c) 2006, 2016, 2023, Paul McGuire\n#\nfrom urllib.request import urlopen\nfrom pyparsing import (\n    LineEnd,\n    quoted_string,\n    make_html_tags,\n    common_html_entity,\n    replace_html_entity,\n    html_comment,\n    any_open_tag,\n    any_close_tag,\n    replace_with,\n)\n\n# if <script> tags found, remove script content also\nscript_open, script_close = make_html_tags(\"script\")\nscript_body = script_open + ... + script_close\n\n# translate HTML entities\ncommon_html_entity.set_parse_action(replace_html_entity)\n\nstripper = (\n        # parse quoted strings first, if they enclose HTML tags - keep these\n        quoted_string\n        # parse and translate HTML entities (&amp;, &lt;, &gt;, etc.)\n        | common_html_entity\n        # expressions to be stripped - suppress() will remove them when transforming\n        | (\n            html_comment | script_body | any_open_tag | any_close_tag\n          ).suppress()\n)\n\nrepeated_newlines = LineEnd()[2, ...]\nrepeated_newlines.set_parse_action(replace_with(\"\\n\\n\"))\n\n\nif __name__ == '__main__':\n    # get some HTML\n    target_url = \"https://wiki.python.org/moin/PythonDecoratorLibrary\"\n    with urlopen(target_url) as targetPage:\n        target_html = targetPage.read().decode(\"UTF-8\")\n\n    # first pass, strip out tags and translate entities\n    # (use transform_string() instead of parse_string - will do\n    # suppressions and parse actions)\n    first_pass = stripper.transform_string(target_html)\n\n    # first pass leaves many blank lines, collapse these down\n    second_pass = repeated_newlines.transform_string(first_pass)\n\n    print(second_pass)\n", "examples/SimpleCalc.py": "# SimpleCalc.py\n#\n# Demonstration of the parsing module,\n# Sample usage\n#\n#     $ python SimpleCalc.py\n#     Type in the string to be parse or 'quit' to exit the program\n#     > g=67.89 + 7/5\n#     69.29\n#     > g\n#     69.29\n#     > h=(6*g+8.8)-g\n#     355.25\n#     > h + 1\n#     356.25\n#     > 87.89 + 7/5\n#     89.29\n#     > ans+10\n#     99.29\n#     > quit\n#     Good bye!\n#\n#\n\n\n# Uncomment the line below for readline support on interactive terminal\n# import readline\nfrom pyparsing import ParseException, Word, alphas, alphanums\n\n# Debugging flag can be set to either \"debug_flag=True\" or \"debug_flag=False\"\ndebug_flag = False\n\nvariables = {}\n\nfrom fourFn import BNF, exprStack, evaluate_stack\n\n# from fourFn import BNF, exprStack, fn, opn\n# def evaluateStack( s ):\n#     op = s.pop()\n#     if op == 'unary -':\n#         return -evaluateStack( s )\n#     if op in \"+-*/^\":\n#         op2 = evaluateStack( s )\n#         op1 = evaluateStack( s )\n#         return opn[op]( op1, op2 )\n#     elif op == \"PI\":\n#         return math.pi # 3.1415926535\n#     elif op == \"E\":\n#         return math.e  # 2.718281828\n#     elif op in fn:\n#         return fn[op]( evaluateStack( s ) )\n#     elif op[0].isalpha():\n#         if op in variables:\n#             return variables[op]\n#         raise Exception(f\"invalid identifier {op!r}\")\n#     else:\n#         return float( op )\n\narithExpr = BNF()\nident = Word(alphas, alphanums).setName(\"identifier\")\nassignment = ident(\"varname\") + \"=\" + arithExpr\npattern = assignment | arithExpr\n\nif __name__ == \"__main__\":\n    # input_string\n    input_string = \"\"\n\n    # Display instructions on how to quit the program\n    print(\"Type in the string to be parsed or 'quit' to exit the program\")\n    input_string = input(\"> \")\n\n    while input_string.strip().lower() != \"quit\":\n        if input_string.strip().lower() == \"debug\":\n            debug_flag = True\n            input_string = input(\"> \")\n            continue\n\n        # Reset to an empty exprStack\n        del exprStack[:]\n\n        if input_string != \"\":\n            # try parsing the input string\n            try:\n                L = pattern.parseString(input_string, parseAll=True)\n            except ParseException as err:\n                L = [\"Parse Failure\", input_string, (str(err), err.line, err.column)]\n\n            # show result of parsing the input string\n            if debug_flag:\n                print(input_string, \"->\", L)\n            if len(L) == 0 or L[0] != \"Parse Failure\":\n                if debug_flag:\n                    print(\"exprStack=\", exprStack)\n\n                for i, ob in enumerate(exprStack):\n                    if isinstance(ob, str) and ob in variables:\n                        exprStack[i] = str(variables[ob])\n\n                # calculate result , store a copy in ans , display the result to user\n                try:\n                    result = evaluate_stack(exprStack)\n                except Exception as e:\n                    print(str(e))\n                else:\n                    variables[\"ans\"] = result\n                    print(result)\n\n                    # Assign result to a variable if required\n                    if L.varname:\n                        variables[L.varname] = result\n                    if debug_flag:\n                        print(\"variables=\", variables)\n            else:\n                print(\"Parse Failure\")\n                err_str, err_line, err_col = L[-1]\n                print(err_line)\n                print(\" \" * (err_col - 1) + \"^\")\n                print(err_str)\n\n        # obtain new input string\n        input_string = input(\"> \")\n\n    # if user type 'quit' then say goodbye\n    print(\"Good bye!\")\n", "examples/select_parser.py": "# select_parser.py\n# Copyright 2010,2019 Paul McGuire\n#\n# a simple SELECT statement parser, taken from SQLite's SELECT statement\n# definition at https://www.sqlite.org/lang_select.html\n#\n# fmt: off\nfrom pyparsing import (\n    pyparsing_common, ParserElement, OpAssoc,\n    CaselessKeyword, Combine, Forward, Group, Literal, MatchFirst, Optional, QuotedString, Regex, Suppress, Word,\n    alphanums, alphas, DelimitedList, infix_notation, nums, one_of, rest_of_line\n)\n# fmt: on\n\nParserElement.enable_packrat()\n\nLPAR, RPAR, COMMA = map(Suppress, \"(),\")\nDOT, STAR = map(Literal, \".*\")\nselect_stmt = Forward().set_name(\"select statement\")\n\n# keywords\nkeywords = {\n    k: CaselessKeyword(k)\n    for k in \"\"\"\\\n    UNION ALL AND INTERSECT EXCEPT COLLATE ASC DESC ON USING NATURAL INNER CROSS LEFT OUTER JOIN AS INDEXED NOT\n    SELECT DISTINCT FROM WHERE GROUP BY HAVING ORDER LIMIT OFFSET OR CAST ISNULL NOTNULL NULL IS BETWEEN ELSE END\n    CASE WHEN THEN EXISTS IN LIKE GLOB REGEXP MATCH ESCAPE CURRENT_TIME CURRENT_DATE CURRENT_TIMESTAMP TRUE FALSE\n    \"\"\".split()\n}\nvars().update(keywords)\n\nany_keyword = MatchFirst(keywords.values())\n\nquoted_identifier = QuotedString('\"', esc_quote='\"\"')\nidentifier = (~any_keyword + Word(alphas, alphanums + \"_\")).set_parse_action(\n    pyparsing_common.downcase_tokens\n) | quoted_identifier\ncollation_name = identifier.copy()\ncolumn_name = identifier.copy()\ncolumn_alias = identifier.copy()\ntable_name = identifier.copy()\ntable_alias = identifier.copy()\nindex_name = identifier.copy()\nfunction_name = identifier.copy()\nparameter_name = identifier.copy()\ndatabase_name = identifier.copy()\n\ncomment = \"--\" + rest_of_line\n\n# expression\nexpr = Forward().set_name(\"expression\")\n\nnumeric_literal = pyparsing_common.number\nstring_literal = QuotedString(\"'\", esc_quote=\"''\")\nblob_literal = Regex(r\"[xX]'[0-9A-Fa-f]+'\")\nliteral_value = (\n    numeric_literal\n    | string_literal\n    | blob_literal\n    | TRUE\n    | FALSE\n    | NULL\n    | CURRENT_TIME\n    | CURRENT_DATE\n    | CURRENT_TIMESTAMP\n)\nbind_parameter = Word(\"?\", nums) | Combine(one_of(\": @ $\") + parameter_name)\ntype_name = one_of(\"TEXT REAL INTEGER BLOB NULL\")\n\nexpr_term = (\n    CAST + LPAR + expr + AS + type_name + RPAR\n    | EXISTS + LPAR + select_stmt + RPAR\n    | function_name.set_name(\"function_name\")\n    + LPAR\n    + Optional(STAR | DelimitedList(expr))\n    + RPAR\n    | literal_value\n    | bind_parameter\n    | Group(\n        identifier(\"col_db\") + DOT + identifier(\"col_tab\") + DOT + identifier(\"col\")\n    )\n    | Group(identifier(\"col_tab\") + DOT + identifier(\"col\"))\n    | Group(identifier(\"col\"))\n)\n\nNOT_NULL = Group(NOT + NULL)\nNOT_BETWEEN = Group(NOT + BETWEEN)\nNOT_IN = Group(NOT + IN)\nNOT_LIKE = Group(NOT + LIKE)\nNOT_MATCH = Group(NOT + MATCH)\nNOT_GLOB = Group(NOT + GLOB)\nNOT_REGEXP = Group(NOT + REGEXP)\n\nUNARY, BINARY, TERNARY = 1, 2, 3\nexpr <<= infix_notation(\n    expr_term,\n    [\n        (one_of(\"- + ~\") | NOT, UNARY, OpAssoc.RIGHT),\n        (ISNULL | NOTNULL | NOT_NULL, UNARY, OpAssoc.LEFT),\n        (\"||\", BINARY, OpAssoc.LEFT),\n        (one_of(\"* / %\"), BINARY, OpAssoc.LEFT),\n        (one_of(\"+ -\"), BINARY, OpAssoc.LEFT),\n        (one_of(\"<< >> & |\"), BINARY, OpAssoc.LEFT),\n        (one_of(\"< <= > >=\"), BINARY, OpAssoc.LEFT),\n        (\n            one_of(\"= == != <>\")\n            | IS\n            | IN\n            | LIKE\n            | GLOB\n            | MATCH\n            | REGEXP\n            | NOT_IN\n            | NOT_LIKE\n            | NOT_GLOB\n            | NOT_MATCH\n            | NOT_REGEXP,\n            BINARY,\n            OpAssoc.LEFT,\n        ),\n        ((BETWEEN | NOT_BETWEEN, AND), TERNARY, OpAssoc.LEFT),\n        (\n            (IN | NOT_IN) + LPAR + Group(select_stmt | DelimitedList(expr)) + RPAR,\n            UNARY,\n            OpAssoc.LEFT,\n        ),\n        (AND, BINARY, OpAssoc.LEFT),\n        (OR, BINARY, OpAssoc.LEFT),\n    ],\n)\n\ncompound_operator = UNION + Optional(ALL) | INTERSECT | EXCEPT\n\nordering_term = Group(\n    expr(\"order_key\")\n    + Optional(COLLATE + collation_name(\"collate\"))\n    + Optional(ASC | DESC)(\"direction\")\n)\n\njoin_constraint = Group(\n    Optional(ON + expr | USING + LPAR + Group(DelimitedList(column_name)) + RPAR)\n)\n\njoin_op = COMMA | Group(\n    Optional(NATURAL) + Optional(INNER | CROSS | LEFT + OUTER | LEFT | OUTER) + JOIN\n)\n\njoin_source = Forward()\nsingle_source = (\n    Group(database_name(\"database\") + DOT + table_name(\"table*\") | table_name(\"table*\"))\n    + Optional(Optional(AS) + table_alias(\"table_alias*\"))\n    + Optional(INDEXED + BY + index_name(\"name\") | NOT + INDEXED)(\"index\")\n    | (LPAR + select_stmt + RPAR + Optional(Optional(AS) + table_alias))\n    | (LPAR + join_source + RPAR)\n)\n\njoin_source <<= (\n    Group(single_source + (join_op + single_source + join_constraint)[1, ...])\n    | single_source\n)\n\n# result_column = \"*\" | table_name + \".\" + \"*\" | Group(expr + Optional(Optional(AS) + column_alias))\nresult_column = Group(\n    STAR(\"col\")\n    | table_name(\"col_table\") + DOT + STAR(\"col\")\n    | expr(\"col\") + Optional(Optional(AS) + column_alias(\"alias\"))\n)\n\nselect_core = Group(\n    SELECT\n    + Optional(DISTINCT | ALL)\n    + Group(DelimitedList(result_column))(\"columns\")\n    + Optional(FROM + join_source(\"from*\"))\n    + Optional(WHERE + expr(\"where_expr\"))\n    + Optional(\n        GROUP\n        + BY\n        + Group(DelimitedList(ordering_term))(\"group_by_terms\")\n        + Optional(HAVING + expr(\"having_expr\"))\n    )\n)\n\nselect_stmt <<= (\n    Group(select_core + (compound_operator + select_core)[...])(\"select_terms\")\n    + Optional(ORDER + BY + Group(DelimitedList(ordering_term))(\"order_by_terms\"))\n    + Optional(\n        LIMIT\n        + (Group(expr + OFFSET + expr) | Group(expr + COMMA + expr) | expr)(\"limit\")\n    )\n)\n\nselect_stmt.ignore(comment)\n\n\ndef main():\n    tests = \"\"\"\\\n        select * from xyzzy where z > 100\n        select * from xyzzy where z > 100 order by zz\n        select * from xyzzy\n        select z.* from xyzzy\n        select a, b from test_table where 1=1 and b='yes'\n        select a, b from test_table where 1=1 and b in (select bb from foo)\n        select z.a, b from test_table where 1=1 and b in (select bb from foo)\n        select z.a, b from test_table where 1=1 and b in (select bb from foo) order by b,c desc,d\n        select z.a, b from test_table left join test2_table where 1=1 and b in (select bb from foo)\n        select a, db.table.b as BBB from db.table where 1=1 and BBB='yes'\n        select a, db.table.b as BBB from test_table,db.table where 1=1 and BBB='yes'\n        select a, db.table.b as BBB from test_table,db.table where 1=1 and BBB='yes' limit 50\n        select a, b from test_table where (1=1 or 2=3) and b='yes' group by zx having b=2 order by 1\n        SELECT emp.ename as e FROM scott.employee as emp\n        SELECT ename as e, fname as f FROM scott.employee as emp\n        SELECT emp.eid, fname,lname FROM scott.employee as emp\n        SELECT ename, lname, emp.eid FROM scott.employee as emp\n        select emp.salary * (1.0 + emp.bonus) as salary_plus_bonus from scott.employee as emp\n        SELECT * FROM abcd WHERE (ST_Overlaps(\"GEOM\", 'POINT(0 0)'))\n        SELECT * FROM abcd WHERE CAST(foo AS REAL) > -999.123\n        SELECT * FROM abcd WHERE bar BETWEEN +180 AND +10E9\n        SELECT * FROM abcd WHERE CAST(foo AS REAL) < (4 + -9.876E-4)\n        SELECT SomeFunc(99)\n        SELECT * FROM abcd WHERE ST_X(ST_Centroid(geom)) BETWEEN (-180*2) AND (180*2)\n        SELECT * FROM abcd WHERE a\n        SELECT * FROM abcd WHERE snowy_things REGEXP '[\u26c4\ufe0f\u2603\ufe0f\u2603\ud83c\udfbf\ud83c\udfc2\ud83c\udf28\u2744\ufe0f\u26f7\ud83c\udfd4\ud83d\uddfb\u2744\ufe0e\u2746\u2745]'\n        SELECT * FROM abcd WHERE a.\"b\" IN 4\n        SELECT * FROM abcd WHERE a.\"b\" In ('4')\n        SELECT * FROM \"a\".b AS \"E\" WHERE \"E\".\"C\" >= CURRENT_Time\n        SELECT * FROM abcd WHERE \"dave\" != \"Dave\" -- names & things \u2603\ufe0f\n        SELECT * FROM a WHERE a.dave is not null\n        SELECT * FROM abcd WHERE pete == FALSE or peter is true\n        SELECT * FROM abcd WHERE a >= 10 * (2 + 3)\n        SELECT * FROM abcd WHERE frank = 'is ''scary'''\n        SELECT * FROM abcd WHERE \"identifier with \"\"quotes\"\" and a trailing space \" IS NOT FALSE\n        SELECT * FROM abcd WHERE blobby == x'C0FFEE'  -- hex\n        SELECT * FROM abcd WHERE ff NOT IN (1,2,4,5)\n        SELECT * FROM abcd WHERE ff not between 3 and 9\n        SELECT * FROM abcd WHERE ff not like 'bob%'\n    \"\"\"\n\n    success, _ = select_stmt.run_tests(tests)\n    print(\"\\n{}\".format(\"OK\" if success else \"FAIL\"))\n    return 0 if success else 1\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/directx_x_file_parser.py": "#\n# directx_x_file_parser.py\n#\n# Parses .x files used for DirectX.\n# Based on format documentation at http://paulbourke.net/dataformats/directx/\n#\n# Copyright 2024, Paul McGuire\n#\nimport pyparsing as pp\n\n\nLBRACE, RBRACE, LBRACK, RBRACK, SEMI = pp.Suppress.using_each(\"{}[];\")\n\nident = pp.Word(pp.alphas, pp.alphanums + \"_\").set_name(\"identifier\")\ninteger = pp.Word(\"123456789\", pp.nums).add_parse_action(lambda t: int(t[0]))\n\n# scalar_type = pp.one_of(\n#     \"WORD DWORD FLOAT DOUBLE CHAR UCHAR BYTE STRING CSTRING UNICODE\", as_keyword=True\n# ).set_name(\"base_type\")\nscalar_type = pp.MatchFirst(\n    pp.Keyword.using_each(\n        \"WORD DWORD FLOAT DOUBLE CHAR UCHAR BYTE STRING CSTRING UNICODE\".split()\n    )\n).set_name(\"scalar_type\")\ntype_ref = scalar_type | ident\n\nARRAY = pp.Keyword(\"array\")\narray_type_ref = pp.Group(ARRAY + type_ref(\"element_type\"))\narray_dim = LBRACK + (integer | ident) + RBRACK\nmember_defn = pp.Group(\n    (\n        array_type_ref(\"type\") + ident(\"name\") + array_dim[...](\"dims\")\n        | type_ref(\"type\") + ident(\"name\")\n    )\n    + SEMI\n)\n\nTEMPLATE = pp.Keyword(\"template\")\nuuid = pp.Regex(\n    r\"<[0-9a-fA-F]{8}(-[0-9a-fA-F]{4}){3}-[0-9a-fA-F]{12}>\"\n).set_parse_action(lambda t: t[0][1:-1])\nopen_template_indicator = pp.Combine(LBRACK + \"...\" + RBRACK, adjacent=False)\nrestriction = pp.Group(type_ref(\"type\") + pp.Optional(uuid)(\"uuid\"))\ntemplate_restrictions = LBRACK + pp.DelimitedList(restriction) + RBRACK\ndirectx_template_defn = (\n    TEMPLATE\n    + ident(\"name\")\n    + LBRACE\n    + pp.Optional(uuid)(\"uuid\")\n    + member_defn[...](\"members\")\n    + pp.Optional(\n        open_template_indicator.set_parse_action(lambda: True), default=False\n    )(\"open_template\")\n    + pp.Optional(template_restrictions)(\"restrictions\")\n    + RBRACE\n).set_name(\"template_defn\")\ndirectx_template_defn.add_parse_action(\n    lambda t: t.__setitem__(\"closed\", not (t.open_template or t.restrictions))\n)\n\ndirectx_template_defn.ignore(pp.cpp_style_comment)\n\n\ndef make_template_parser(template_defn: pp.ParseResults) -> pp.ParserElement:\n    \"\"\"\n    Create a pyparsing parser from a DirectX template definition.\n    (Limited to templates containing scalar types, or arrays of scalars.)\n    \"\"\"\n    float_ = pp.common.real\n    type_map = {\n        \"WORD\": integer,\n        \"DWORD\": integer,\n        \"FLOAT\": float_,\n        \"DOUBLE\": float_,\n        \"CHAR\": integer,\n        \"UCHAR\": integer,\n        \"BYTE\": integer,\n        \"STRING\": pp.QuotedString('\"'),\n        \"CSTRING\": pp.QuotedString('\"'),\n        \"UNICODE\": pp.QuotedString('\"'),\n    }\n    member_parsers = []\n    for member in template_defn.members:\n        if member.type in type_map:\n            expr = pp.ungroup(type_map[member.type] + SEMI)\n        elif member.dims:\n            expr = type_map[member.type.element_type]\n            for dim in member.dims:\n                expr = pp.Group(pp.DelimitedList(expr, max=dim) + SEMI)\n        member_parsers.append(expr(member.name))\n\n    return (\n        pp.Keyword(template_defn.name)(\"type\")\n        + ident(\"name\")\n        + LBRACE\n        + pp.Group(pp.And(member_parsers))(\"fields\")\n        + RBRACE\n    )\n\n\nif __name__ == \"__main__\":\n\n    sample = \"\"\"\n    some stuff...\n\n    template Mesh {\n    <3D82AB44-62DA-11cf-AB39-0020AF71E433>\n    DWORD nVertices;\n    array Vector vertices[nVertices];\n    DWORD nFaces;\n    array MeshFace faces[nFaces];\n     [ ... ]                // An open template\n    }\n    \n    template PolyArray {\n    <3D82AB44-62DA-11cf-AB39-0020AF71E433>\n    DWORD nPolys;\n    array FLOAT polys[nPolys][3];\n    }\n\n    template Vector {\n    <3D82AB5E-62DA-11cf-AB39-0020AF71E434>\n    FLOAT x;\n    FLOAT y;\n    FLOAT z;\n    }                        // A closed template\n\n    template FileSystem {\n    <3D82AB5E-62DA-11cf-AB39-0020AF71E435>\n    STRING name;\n    [ Directory <3D82AB5E-62DA-11cf-AB39-0020AF71E436>, File <3D82AB5E-62DA-11cf-AB39-0020AF71E437> ]    // A restricted template\n    }\n\n    more stuff...\n\n    template mytemp {\n    DWORD myvar;\n    DWORD myvar2;\n    }\n\n    template container {\n    DWORD count;\n    array mytemp tempArray[count];\n    }\n    \"\"\"\n\n    for template in directx_template_defn.search_string(sample):\n        # print(template.dump())\n        print(\n            f\"Name: {template.name!r}\"\n            f\" UUID: {template.uuid}\"\n            f\" Open: {template.open_template!r}\"\n            f\" Closed: {template.closed!r}\"\n            f\" Restricted: {bool(template.restrictions)}\"\n        )\n        # print()\n\n    # create railroad diagram\n    pp.autoname_elements()\n    directx_template_defn.create_diagram(\n        \"directx_x_file_parser.html\", show_results_names=True, show_groups=False\n    )\n\n    vector_template = directx_template_defn.parse_string(\n        \"\"\"\\\n    template Vector {\n        <3D82AB5E-62DA-11cf-AB39-0020AF71E434>\n        STRING label;\n        FLOAT x;\n        FLOAT y;\n        FLOAT z;\n    }  \n    \"\"\"\n    )\n    vector_parser = make_template_parser(vector_template)\n    vector_parser.create_diagram(\n        \"directx_x_vector_parser.html\", show_results_names=True, show_groups=False\n    )\n    v = vector_parser.parse_string('Vector p1 {\"datum_A\"; 1.0; 3.0; 5.0;}')\n    print(v.dump())\n\n    vector_template = directx_template_defn.parse_string(\n        \"\"\"\\\n    template Vector {\n        <3D82AB5E-62DA-11cf-AB39-0020AF71E434>\n        STRING label;\n        array FLOAT coords[3];\n    }  \n    \"\"\"\n    )\n    vector_parser = make_template_parser(vector_template)\n    vector_parser.create_diagram(\n        \"directx_x_vector_parser.html\", show_results_names=True, show_groups=False\n    )\n    v = vector_parser.parse_string('Vector p1 {\"datum_A\"; 1.0, 3.0, 5.0;}')\n    print(v.dump())\n", "examples/booleansearchparser.py": "\"\"\"\nBoolean Search query parser (Based on searchparser: https://github.com/pyparsing/pyparsing/blob/master/examples/searchparser.py)\n\nversion 2018-07-22\n\nThis search query parser uses the excellent Pyparsing module\n(http://pyparsing.sourceforge.net/) to parse search queries by users.\nIt handles:\n\n* 'and', 'or' and implicit 'and' operators;\n* parentheses;\n* quoted strings;\n* wildcards at the end of a search term (help*);\n* wildcards at the beginning of a search term (*lp);\n* non-western languages\n\nRequirements:\n* Python\n* Pyparsing\n\nSAMPLE USAGE:\nfrom booleansearchparser import BooleanSearchParser\nfrom __future__ import print_function\nbsp = BooleanSearchParser()\ntext = u\"wildcards at the beginning of a search term \"\nexprs= [\n    u\"*cards and term\", #True\n    u\"wild* and term\",  #True\n    u\"not terms\",       #True\n    u\"terms or begin\",  #False\n]\nfor expr in exprs:\n    print (bsp.match(text,expr))\n\n#non-western samples\ntext = u\"\uc548\ub155\ud558\uc138\uc694, \ub2f9\uc2e0\uc740 \uc5b4\ub5a0\uc138\uc694?\"\nexprs= [\n    u\"*\uc2e0\uc740 and \uc5b4\ub5a0\uc138\uc694\", #True\n    u\"not \ub2f9\uc2e0\uc740\",       #False\n    u\"\ub2f9\uc2e0 or \ub2f9\",  #False\n]\nfor expr in exprs:\n    print (bsp.match(text,expr))\n-------------------------------------------------------------------------------\nCopyright (c) 2006, Estrate, the Netherlands\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above copyright notice, this\n  list of conditions and the following disclaimer.\n* Redistributions in binary form must reproduce the above copyright notice,\n  this list of conditions and the following disclaimer in the documentation\n  and/or other materials provided with the distribution.\n* Neither the name of Estrate nor the names of its contributors may be used\n  to endorse or promote products derived from this software without specific\n  prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\nCONTRIBUTORS:\n- Steven Mooij\n- Rudolph Froger\n- Paul McGuire\n- Guiem Bosch\n- Francesc Garcia\n\nTODO:\n- add more docs\n- ask someone to check my English texts\n- add more kinds of wildcards ('*' at the beginning and '*' inside a word)?\n\n\"\"\"\nfrom pyparsing import (\n    Word,\n    alphanums,\n    CaselessKeyword,\n    Group,\n    Forward,\n    Suppress,\n    OneOrMore,\n    one_of,\n    ParserElement,\n)\nimport re\n\nParserElement.enablePackrat()\n\n# Updated on 02 Dec 2021 according to ftp://ftp.unicode.org/Public/UNIDATA/Blocks.txt\n# (includes characters not found in the BasicMultilingualPlane)\nalphabet_ranges = [\n    # CYRILIC: https://en.wikipedia.org/wiki/Cyrillic_(Unicode_block)\n    [int(\"0400\", 16), int(\"04FF\", 16)],\n    # ARABIC: https://en.wikipedia.org/wiki/Arabic_(Unicode_block) (Arabic (0600\u201306FF)+ Syriac (0700\u2013074F)+ Arabic Supplement (0750\u2013077F))\n    [int(\"0600\", 16), int(\"07FF\", 16)],\n    # THAI: https://en.wikipedia.org/wiki/Thai_(Unicode_block)\n    [int(\"0E00\", 16), int(\"0E7F\", 16)],\n    # JAPANESE : https://en.wikipedia.org/wiki/Japanese_writing_system (Hiragana (3040\u2013309F) + Katakana (30A0\u201330FF))\n    [int(\"3040\", 16), int(\"30FF\", 16)],\n    # Enclosed CJK Letters and Months\n    [int(\"3200\", 16), int(\"32FF\", 16)],\n    # CHINESE: https://en.wikipedia.org/wiki/CJK_Unified_Ideographs_(Unicode_block)\n    [int(\"4E00\", 16), int(\"9FFF\", 16)],\n    # KOREAN : https://en.wikipedia.org/wiki/Hangul\n    [int(\"1100\", 16), int(\"11FF\", 16)],\n    [int(\"3130\", 16), int(\"318F\", 16)],\n    [int(\"A960\", 16), int(\"A97F\", 16)],\n    [int(\"AC00\", 16), int(\"D7AF\", 16)],\n    [int(\"D7B0\", 16), int(\"D7FF\", 16)],\n    # Halfwidth and Fullwidth Forms\n    [int(\"FF00\", 16), int(\"FFEF\", 16)],\n]\n\n\nclass BooleanSearchParser:\n    def __init__(self, only_parse=False):\n        self._methods = {\n            \"and\": self.evaluateAnd,\n            \"or\": self.evaluateOr,\n            \"not\": self.evaluateNot,\n            \"parenthesis\": self.evaluateParenthesis,\n            \"quotes\": self.evaluateQuotes,\n            \"word\": self.evaluateWord,\n            \"wordwildcardprefix\": self.evaluateWordWildcardPrefix,\n            \"wordwildcardsufix\": self.evaluateWordWildcardSufix,\n        }\n        self._parser = self.parser()\n        self.text = \"\"\n        self.words = []\n\n    def parser(self):\n        \"\"\"\n        This function returns a parser.\n        The grammar should be like most full text search engines (Google, Tsearch, Lucene).\n\n        Grammar:\n        - a query consists of alphanumeric words, with an optional '*'\n          wildcard at the end or the beginning of a word\n        - a sequence of words between quotes is a literal string\n        - words can be used together by using operators ('and' or 'or')\n        - words with operators can be grouped with parenthesis\n        - a word or group of words can be preceded by a 'not' operator\n        - the 'and' operator precedes an 'or' operator\n        - if an operator is missing, use an 'and' operator\n        \"\"\"\n        operatorOr = Forward()\n\n        alphabet = alphanums\n\n        # support for non-western alphabets\n        for lo, hi in alphabet_ranges:\n            alphabet += \"\".join(chr(c) for c in range(lo, hi + 1) if not chr(c).isspace())\n\n        operatorWord = Group(Word(alphabet + \"*\")).set_results_name(\"word*\")\n\n        operatorQuotesContent = Forward()\n        operatorQuotesContent << ((operatorWord + operatorQuotesContent) | operatorWord)\n\n        operatorQuotes = (\n            Group(Suppress('\"') + operatorQuotesContent + Suppress('\"')).set_results_name(\n                \"quotes\"\n            )\n            | operatorWord\n        )\n\n        operatorParenthesis = (\n            Group(Suppress(\"(\") + operatorOr + Suppress(\")\")).set_results_name(\n                \"parenthesis\"\n            )\n            | operatorQuotes\n        )\n\n        operatorNot = Forward()\n        operatorNot << (\n            Group(Suppress(CaselessKeyword(\"not\")) + operatorNot).set_results_name(\n                \"not\"\n            )\n            | operatorParenthesis\n        )\n\n        operatorAnd = Forward()\n        operatorAnd << (\n            Group(\n                operatorNot + Suppress(CaselessKeyword(\"and\")) + operatorAnd\n            ).set_results_name(\"and\")\n            | Group(\n                operatorNot + OneOrMore(~one_of(\"and or\") + operatorAnd)\n            ).set_results_name(\"and\")\n            | operatorNot\n        )\n\n        operatorOr << (\n            Group(\n                operatorAnd + Suppress(CaselessKeyword(\"or\")) + operatorOr\n            ).set_results_name(\"or\")\n            | operatorAnd\n        )\n\n        return operatorOr.parse_string\n\n    def evaluateAnd(self, argument):\n        return all(self.evaluate(arg) for arg in argument)\n\n    def evaluateOr(self, argument):\n        return any(self.evaluate(arg) for arg in argument)\n\n    def evaluateNot(self, argument):\n        return self.GetNot(self.evaluate(argument[0]))\n\n    def evaluateParenthesis(self, argument):\n        return self.evaluate(argument[0])\n\n    def evaluateQuotes(self, argument):\n        \"\"\"Evaluate quoted strings\n\n        First is does an 'and' on the individual search terms, then it asks the\n        function GetQuoted to only return the subset of ID's that contain the\n        literal string.\n        \"\"\"\n        # r = set()\n        r = False\n        search_terms = []\n        for item in argument:\n            search_terms.append(item[0])\n            r = r and self.evaluate(item)\n        return self.GetQuotes(\" \".join(search_terms), r)\n\n    def evaluateWord(self, argument):\n        wildcard_count = argument[0].count(\"*\")\n        if wildcard_count > 0:\n            if wildcard_count == 1 and argument[0].startswith(\"*\"):\n                return self.GetWordWildcard(argument[0][1:], method=\"endswith\")\n            if wildcard_count == 1 and argument[0].endswith(\"*\"):\n                return self.GetWordWildcard(argument[0][:-1], method=\"startswith\")\n            else:\n                _regex = argument[0].replace(\"*\", \".+\")\n                matched = False\n                for w in self.words:\n                    matched = bool(re.search(_regex, w))\n                    if matched:\n                        break\n                return matched\n\n        return self.GetWord(argument[0])\n\n    def evaluateWordWildcardPrefix(self, argument):\n        return self.GetWordWildcard(argument[0], method=\"endswith\")\n\n    def evaluateWordWildcardSufix(self, argument):\n        return self.GetWordWildcard(argument[0], method=\"startswith\")\n\n    def evaluate(self, argument):\n        return self._methods[argument.getName()](argument)\n\n    def Parse(self, query):\n        return self.evaluate(self._parser(query)[0])\n\n    def GetWord(self, word):\n        return word in self.words\n\n    def GetWordWildcard(self, word, method=\"startswith\"):\n        matched = False\n        for w in self.words:\n            matched = getattr(w, method)(word)\n            if matched:\n                break\n        return matched\n\n    \"\"\"\n    def GetKeyword(self, name, value):\n        return set()\n\n    def GetBetween(self, min, max):\n        print (min,max)\n        return set()\n    \"\"\"\n\n    def GetQuotes(self, search_string, tmp_result):\n        return search_string in self.text\n\n    def GetNot(self, not_set):\n        return not not_set\n\n    def _split_words(self, text):\n        words = []\n        \"\"\"\n        >>> import string\n        >>> string.punctuation\n        '!\"#$%&\\'()*+,-./:;<=>?@[\\\\]^_`{|}~'\n        \"\"\"\n        # it will keep @, # and\n        # usernames and hashtags can contain dots, so a double check is done\n        r = re.compile(r\"[\\s{}]+\".format(re.escape(\"!\\\"$%&'()*+,-/:;<=>?[\\\\]^`{|}~\")))\n        _words = r.split(text)\n        for _w in _words:\n            if \".\" in _w and not _w.startswith(\"#\") and not _w.startswith(\"@\"):\n                for __w in _w.split(\".\"):\n                    words.append(__w)\n                continue\n\n            words.append(_w)\n\n        return words\n\n    def match(self, text, expr):\n        self.text = text\n        self.words = self._split_words(text)\n\n        return self.Parse(expr)\n\n\nclass ParserTest(BooleanSearchParser):\n    \"\"\"Tests the parser with some search queries\n    tests contains a dictionary with tests and expected results.\n    \"\"\"\n\n    def Test(self):\n        # fmt: off\n        exprs = {\n            \"0\": \"help\",\n            \"1\": \"help or hulp\",\n            \"2\": \"help and hulp\",\n            \"3\": \"help hulp\",\n            \"4\": \"help and hulp or hilp\",\n            \"5\": \"help or hulp and hilp\",\n            \"6\": \"help or hulp or hilp or halp\",\n            \"7\": \"(help or hulp) and (hilp or halp)\",\n            \"8\": \"help and (hilp or halp)\",\n            \"9\": \"(help and (hilp or halp)) or hulp\",\n            \"10\": \"not help\",\n            \"11\": \"not hulp and halp\",\n            \"12\": \"not (help and halp)\",\n            \"13\": '\"help me please\"',\n            \"14\": '\"help me please\" or hulp',\n            \"15\": '\"help me please\" or (hulp and halp)',\n            \"16\": \"help*\",\n            \"17\": \"help or hulp*\",\n            \"18\": \"help* and hulp\",\n            \"19\": \"help and hulp* or hilp\",\n            \"20\": \"help* or hulp or hilp or halp\",\n            \"21\": \"(help or hulp*) and (hilp* or halp)\",\n            \"22\": \"help* and (hilp* or halp*)\",\n            \"23\": \"(help and (hilp* or halp)) or hulp*\",\n            \"24\": \"not help* and halp\",\n            \"25\": \"not (help* and helpe*)\",\n            \"26\": '\"help* me please\"',\n            \"27\": '\"help* me* please\" or hulp*',\n            \"28\": '\"help me please*\" or (hulp and halp)',\n            \"29\": '\"help me please\" not (hulp and halp)',\n            \"30\": '\"help me please\" hulp',\n            \"31\": \"help and hilp and not holp\",\n            \"32\": \"help hilp not holp\",\n            \"33\": \"help hilp and not holp\",\n            \"34\": \"*lp and halp\",\n            \"35\": \"*\uc2e0\uc740 and \uc5b4\ub5a0\uc138\uc694\",\n        }\n\n        texts_matcheswith = {\n            \"halp thinks he needs help\": [\n                \"25\", \"22\", \"20\", \"21\", \"11\", \"17\", \"16\", \"23\", \"34\", \"1\",\n                \"0\", \"5\", \"7\", \"6\", \"9\", \"8\",\n            ],\n            \"he needs halp\": [\"24\", \"25\", \"20\", \"11\", \"10\", \"12\", \"34\", \"6\"],\n            \"help\": [\"25\", \"20\", \"12\", \"17\", \"16\", \"1\", \"0\", \"5\", \"6\"],\n            \"help hilp\": [\n                \"25\", \"22\", \"20\", \"32\", \"21\", \"12\", \"17\", \"16\", \"19\", \"31\",\n                \"23\", \"1\", \"0\", \"5\", \"4\", \"7\", \"6\", \"9\", \"8\", \"33\",\n            ],\n            \"help me please hulp\": [\n                \"30\", \"25\", \"27\", \"20\", \"13\", \"12\", \"15\", \"14\", \"17\", \"16\",\n                \"19\", \"18\", \"23\", \"29\", \"1\", \"0\", \"3\", \"2\", \"5\", \"4\", \"6\", \"9\",\n            ],\n            \"helper\": [\"20\", \"10\", \"12\", \"16\"],\n            \"hulp hilp\": [\n                \"25\", \"27\", \"20\", \"21\", \"10\", \"12\", \"14\", \"17\", \"19\", \"23\",\n                \"1\", \"5\", \"4\", \"7\", \"6\", \"9\",\n            ],\n            \"nothing\": [\"25\", \"10\", \"12\"],\n            \"\uc548\ub155\ud558\uc138\uc694, \ub2f9\uc2e0\uc740 \uc5b4\ub5a0\uc138\uc694?\": [\"10\", \"12\", \"25\", \"35\"],\n        }\n        # fmt: on\n\n        all_ok = True\n        for text, matches in texts_matcheswith.items():\n            _matches = []\n            for _id, expr in exprs.items():\n                if self.match(text, expr):\n                    _matches.append(_id)\n\n            test_passed = sorted(matches) == sorted(_matches)\n            if test_passed:\n                print(\"Passed\", repr(text))\n            else:\n                print(\"Failed\", repr(text), \"expected\", matches, \"matched\", _matches)\n\n            all_ok = all_ok and test_passed\n\n        # Tests for non western characters, should fail with\n        # pyparsing.exceptions.ParseException under the previous\n        # configuration\n        non_western_exprs = {\n            \"0\": \"*\",\n            \"1\": \"\u30ff\",  # Edge character\n            \"2\": \"\u4e80\",  # Character in CJK block\n            \"3\": \"\u30ff or \u4e80\",\n            \"4\": \"\u30ff and \u4e80\",\n            \"5\": \"not \u30ff\"\n        }\n\n        non_western_texts_matcheswith = {\n            \"\uc548\ub155\ud558\uc138\uc694, \ub2f9\uc2e0\uc740 \uc5b4\ub5a0\uc138\uc694?\": [\"0\", \"5\"],\n            \"\u30ff\": [\"0\", \"1\", \"3\"],\n            \"\u4e80\": [\"0\", \"2\", \"3\", \"5\"],\n            \"\u4e80 \u30ff\": [\"0\", \"1\", \"2\", \"3\", \"4\"],\n        }\n\n        for text, matches in non_western_texts_matcheswith.items():\n            _matches = []\n            for _id, expr in non_western_exprs.items():\n                if self.match(text, expr):\n                    _matches.append(_id)\n\n            test_passed = sorted(matches) == sorted(_matches)\n            if test_passed:\n                print(\"Passed\", repr(text))\n            else:\n                print(\"Failed\", repr(text), \"expected\", matches, \"matched\", _matches)\n\n            all_ok = all_ok and test_passed\n\n        return all_ok\n\n\ndef main():\n    if ParserTest().Test():\n        print(\"All tests OK\")\n    else:\n        print(\"One or more tests FAILED\")\n        raise Exception(\"One or more tests FAILED\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/simpleBool.py": "#\n# simpleBool.py\n#\n# Example of defining a boolean logic parser using\n# the operatorGrammar helper method in pyparsing.\n#\n# In this example, parse actions associated with each\n# operator expression will \"compile\" the expression\n# into BoolXXX class instances, which can then\n# later be evaluated for their boolean value.\n#\n# Copyright 2006, by Paul McGuire\n# Updated 2013-Sep-14 - improved Python 2/3 cross-compatibility\n# Updated 2021-Sep-27 - removed Py2 compat; added type annotations\n#\nfrom typing import Callable, Iterable\n\nfrom pyparsing import infixNotation, opAssoc, Keyword, Word, alphas, ParserElement\n\nParserElement.enablePackrat()\n\n\n# define classes to be built at parse time, as each matching\n# expression type is parsed\nclass BoolOperand:\n    def __init__(self, t):\n        self.label = t[0]\n        self.value = eval(t[0])\n\n    def __bool__(self) -> bool:\n        return self.value\n\n    def __str__(self) -> str:\n        return self.label\n\n    __repr__ = __str__\n\n\nclass BoolNot:\n    def __init__(self, t):\n        self.arg = t[0][1]\n\n    def __bool__(self) -> bool:\n        v = bool(self.arg)\n        return not v\n\n    def __str__(self) -> str:\n        return \"~\" + str(self.arg)\n\n    __repr__ = __str__\n\n\nclass BoolBinOp:\n    repr_symbol: str = \"\"\n    eval_fn: Callable[\n        [Iterable[bool]], bool\n    ] = lambda _: False\n\n    def __init__(self, t):\n        self.args = t[0][0::2]\n\n    def __str__(self) -> str:\n        sep = f\" {self.repr_symbol} \"\n        return f\"({sep.join(map(str, self.args))})\"\n\n    def __bool__(self) -> bool:\n        return self.eval_fn(bool(a) for a in self.args)\n\n\nclass BoolAnd(BoolBinOp):\n    repr_symbol = \"&\"\n    eval_fn = all\n\n\nclass BoolOr(BoolBinOp):\n    repr_symbol = \"|\"\n    eval_fn = any\n\n\n# define keywords and simple infix notation grammar for boolean\n# expressions\nTRUE = Keyword(\"True\")\nFALSE = Keyword(\"False\")\nNOT = Keyword(\"not\")\nAND = Keyword(\"and\")\nOR = Keyword(\"or\")\nboolOperand = TRUE | FALSE | Word(alphas, max=1)\nboolOperand.setParseAction(BoolOperand).setName(\"bool_operand\")\n\n# define expression, based on expression operand and\n# list of operations in precedence order\nboolExpr = infixNotation(\n    boolOperand,\n    [\n        (NOT, 1, opAssoc.RIGHT, BoolNot),\n        (AND, 2, opAssoc.LEFT, BoolAnd),\n        (OR, 2, opAssoc.LEFT, BoolOr),\n    ],\n).setName(\"boolean_expression\")\n\n\nif __name__ == \"__main__\":\n    p = True\n    q = False\n    r = True\n    tests = [\n        (\"p\", True),\n        (\"q\", False),\n        (\"p and q\", False),\n        (\"p and not q\", True),\n        (\"not not p\", True),\n        (\"not(p and q)\", True),\n        (\"q or not p and r\", False),\n        (\"q or not p or not r\", False),\n        (\"q or not (p and r)\", False),\n        (\"p or q or r\", True),\n        (\"p or q or r and False\", True),\n        (\"(p or q or r) and False\", False),\n    ]\n\n    print(\"p =\", p)\n    print(\"q =\", q)\n    print(\"r =\", r)\n    print()\n    for test_string, expected in tests:\n        res = boolExpr.parseString(test_string)[0]\n        success = \"PASS\" if bool(res) == expected else \"FAIL\"\n        print(test_string, \"\\n\", res, \"=\", bool(res), \"\\n\", success, \"\\n\")\n", "examples/range_check.py": "# rangeCheck.py\n#\n#   A sample program showing how parse actions can convert parsed\n# strings into a data type or object, and to validate the parsed value.\n#\n# Updated to use new addCondition method and expr() copy.\n#\n# Copyright 2011,2015 Paul T. McGuire\n#\n\nimport pyparsing as pp\nfrom datetime import date\nfrom typing import Any\n\n\ndef ranged_value(\n        expr: pp.ParserElement,\n        min_val: Any = None,\n        max_val: Any = None,\n        label: str = \"\"\n) -> pp.ParserElement:\n\n    # have to specify at least one range boundary\n    if (min_val, max_val) == (None, None):\n        raise ValueError(\"min_val or max_val must be specified\")\n\n    expr_label = label or \"value\"\n\n    # set range testing function and error message depending on\n    # whether either or both min and max values are given\n    in_range_condition = {\n        (False, True): lambda s, l, t: t[0] <= max_val,\n        (True, False): lambda s, l, t: min_val <= t[0],\n        (True, True): lambda s, l, t: min_val <= t[0] <= max_val,\n    }[min_val is not None, max_val is not None]\n\n    out_of_range_message = {\n        (False, True): f\"{expr_label} is greater than {max_val}\",\n        (True, False): f\"{expr_label} is less than {min_val}\",\n        (True, True): f\"{expr_label} is not in the range ({min_val} to {max_val})\",\n    }[min_val is not None, max_val is not None]\n\n    ret = expr().add_condition(in_range_condition, message=out_of_range_message)\n\n    if label:\n        ret.set_name(label)\n\n    return ret\n\n\n# define the expressions for a date of the form YYYY/MM/DD or YYYY/MM (assumes YYYY/MM/01)\ninteger = pp.Word(pp.nums).set_name(\"integer\")\ninteger.set_parse_action(lambda t: int(t[0]))\n\nmonth = ranged_value(integer, 1, 12, \"month\")\nday = ranged_value(integer, 1, 31, \"day\")\nyear = ranged_value(integer, 2000, None, \"year\")\n\nSLASH = pp.Suppress(\"/\")\ndateExpr = year(\"year\") + SLASH + month(\"month\") + pp.Opt(SLASH + day(\"day\"))\ndateExpr.set_name(\"date\")\n\n# convert date fields to datetime (also validates dates as truly valid dates)\ndateExpr.set_parse_action(lambda t: date(t.year, t.month, t.day or 1))\n\n# add range checking on dates\nmin_date = date(2002, 1, 1)\nmax_date = date.today()\ndate_expr = ranged_value(dateExpr, min_date, max_date, \"date\")\n\ndate_expr.create_diagram(\"range_check.html\")\n\n# tests of valid dates\nsuccess_valid_tests, _ = date_expr.run_tests(\n    \"\"\"\n    # valid date\n    2011/5/8\n    \n    # leap day\n    2004/2/29\n\n    # default day of month to 1\n    2004/2\n    \"\"\"\n)\n\n# tests of invalid dates\nsuccess_invalid_tests, _ = date_expr.run_tests(\n    \"\"\"\n    # all values are in range, but date is too early\n    2001/1/1\n\n    # not a leap day\n    2005/2/29\n\n    # year number is < 2000\n    1999/12/31\n\n    # bad year field\n    XXXX/1/1\n\n    # bad month field\n    2010/XX/1\n\n    # bad day field\n    2010/11/XX\n    \"\"\",\n    failure_tests=True\n)\n\nassert (success_valid_tests and success_invalid_tests)\n", "examples/btpyparse.py": "\"\"\" Pyparsing parser for BibTeX files\n\nA standalone parser using pyparsing.\n\npyparsing has a simple and expressive syntax so the grammar is easy to read and\nwrite.\n\nSubmitted by Matthew Brett, 2010\n\nSimplified BSD license\n\"\"\"\n\nfrom pyparsing import (\n    Regex,\n    Suppress,\n    ZeroOrMore,\n    Group,\n    Optional,\n    Forward,\n    SkipTo,\n    CaselessLiteral,\n    Dict,\n)\n\n\nclass Macro:\n    \"\"\"Class to encapsulate undefined macro references\"\"\"\n\n    def __init__(self, name):\n        self.name = name\n\n    def __repr__(self):\n        return f'Macro(\"{self.name}\")'\n\n    def __eq__(self, other):\n        return self.name == other.name\n\n\n# Character literals\nLCURLY, RCURLY, LPAREN, RPAREN, QUOTE, COMMA, AT, EQUALS, HASH = map(\n    Suppress, '{}()\",@=#'\n)\n\n\ndef bracketed(expr):\n    \"\"\"Return matcher for `expr` between curly brackets or parentheses\"\"\"\n    return (LPAREN + expr + RPAREN) | (LCURLY + expr + RCURLY)\n\n\n# Define parser components for strings (the hard bit)\nchars_no_curly = Regex(r\"[^{}]+\")\nchars_no_curly.leaveWhitespace()\nchars_no_quotecurly = Regex(r'[^\"{}]+')\nchars_no_quotecurly.leaveWhitespace()\n# Curly string is some stuff without curlies, or nested curly sequences\ncurly_string = Forward()\ncurly_item = Group(curly_string) | chars_no_curly\ncurly_string << LCURLY + ZeroOrMore(curly_item) + RCURLY\n# quoted string is either just stuff within quotes, or stuff within quotes, within\n# which there is nested curliness\nquoted_item = Group(curly_string) | chars_no_quotecurly\nquoted_string = QUOTE + ZeroOrMore(quoted_item) + QUOTE\n\n# Numbers can just be numbers. Only integers though.\nnumber = Regex(\"[0-9]+\")\n\n# Basis characters (by exclusion) for variable / field names.  The following\n# list of characters is from the btparse documentation\nany_name = Regex(\"[^\\\\s\\\"#%'(),={}]+\")\n\n# btparse says, and the test bibs show by experiment, that macro and field names\n# cannot start with a digit.  In fact entry type names cannot start with a digit\n# either (see tests/bibs). Cite keys can start with a digit\nnot_digname = Regex(\"[^\\\\d\\\\s\\\"#%'(),={}][^\\\\s\\\"#%'(),={}]*\")\n\n# Comment comments out to end of line\ncomment = AT + CaselessLiteral(\"comment\") + Regex(r\"[\\s{(].*\").leaveWhitespace()\n\n# The name types with their digiteyness\nnot_dig_lower = not_digname.copy().setParseAction(lambda t: t[0].lower())\nmacro_def = not_dig_lower.copy()\nmacro_ref = not_dig_lower.copy().setParseAction(lambda t: Macro(t[0].lower()))\nfield_name = not_dig_lower.copy()\n# Spaces in names mean they cannot clash with field names\nentry_type = not_dig_lower(\"entry_type\")\ncite_key = any_name(\"cite_key\")\n# Number has to be before macro name\nstring = number | macro_ref | quoted_string | curly_string\n\n# There can be hash concatenation\nfield_value = string + ZeroOrMore(HASH + string)\nfield_def = Group(field_name + EQUALS + field_value)\nentry_contents = Dict(ZeroOrMore(field_def + COMMA) + Optional(field_def))\n\n# Entry is surrounded either by parentheses or curlies\nentry = AT + entry_type + bracketed(cite_key + COMMA + entry_contents)\n\n# Preamble is a macro-like thing with no name\npreamble = AT + CaselessLiteral(\"preamble\") + bracketed(field_value)\n\n# Macros (aka strings)\nmacro_contents = macro_def + EQUALS + field_value\nmacro = AT + CaselessLiteral(\"string\") + bracketed(macro_contents)\n\n# Implicit comments\nicomment = SkipTo(\"@\").setParseAction(lambda t: t.insert(0, \"icomment\"))\n\n# entries are last in the list (other than the fallback) because they have\n# arbitrary start patterns that would match comments, preamble or macro\ndefinitions = Group(comment | preamble | macro | entry | icomment)\n\n# Start symbol\nbibfile = ZeroOrMore(definitions)\n\n\ndef parse_str(str):\n    return bibfile.parseString(str)\n\n\nif __name__ == \"__main__\":\n    # Run basic test\n    txt = \"\"\"\nSome introductory text\n(implicit comment)\n\n@ARTICLE{Authors2011,\n  author = {First Author and Second Author and Third Author},\n  title = {An article about {S}omething},\n  journal = \"Journal of Articles\",\n  year = {2011},\n  volume = {16},\n  pages = {1140--1141},\n  number = {2}\n}\n\"\"\"\n    print(\"\\n\\n\".join(defn.dump() for defn in parse_str(txt)))\n", "examples/shapes.py": "# shapes.py\n#\n#   A sample program showing how parse actions can convert parsed\n# strings into a data type or object.\n#\n# Copyright 2012, 2019 Paul T. McGuire\n#\n\n# define class hierarchy of Shape classes, with polymorphic area method\nclass Shape:\n    def __init__(self, tokens):\n        self.__dict__.update(tokens.asDict())\n\n    def area(self):\n        raise NotImplemented()\n\n    def __str__(self):\n        return \"<{}>: {}\".format(self.__class__.__name__, vars(self))\n\n\nclass Square(Shape):\n    def area(self):\n        return self.side ** 2\n\n\nclass Rectangle(Shape):\n    def area(self):\n        return self.width * self.height\n\n\nclass Circle(Shape):\n    def area(self):\n        return 3.14159 * self.radius ** 2\n\n\nimport pyparsing as pp\n\nppc = pp.pyparsing_common\n\n# use pyparsing-defined numeric expression that converts all parsed\n# numeric values as floats\nnumber = ppc.fnumber()\n\n# Shape expressions:\n#   square : S <centerx> <centery> <side>\n#   rectangle: R <centerx> <centery> <width> <height>\n#   circle : C <centerx> <centery> <diameter>\n\nsquareDefn = \"S\" + number(\"centerx\") + number(\"centery\") + number(\"side\")\nrectDefn = (\n    \"R\" + number(\"centerx\") + number(\"centery\") + number(\"width\") + number(\"height\")\n)\ncircleDefn = \"C\" + number(\"centerx\") + number(\"centery\") + number(\"diameter\")\n\nsquareDefn.setParseAction(Square)\nrectDefn.setParseAction(Rectangle)\n\n\ndef computeRadius(tokens):\n    tokens[\"radius\"] = tokens.diameter / 2.0\n\n\ncircleDefn.setParseAction(computeRadius, Circle)\n\nshapeExpr = squareDefn | rectDefn | circleDefn\n\ntests = \"\"\"\\\nC 0 0 100\nR 10 10 20 50\nS -1 5 10\"\"\".splitlines()\n\nfor t in tests:\n    shape = shapeExpr.parseString(t)[0]\n    print(shape)\n    print(\"Area:\", shape.area())\n    print()\n", "examples/jsonParser.py": "# jsonParser.py\n#\n# Implementation of a simple JSON parser, returning a hierarchical\n# ParseResults object support both list- and dict-style data access.\n#\n# Copyright 2006, by Paul McGuire\n#\n# Updated 8 Jan 2007 - fixed dict grouping bug, and made elements and\n#   members optional in array and object collections\n#\n# Updated 9 Aug 2016 - use more current pyparsing constructs/idioms\n#\njson_bnf = \"\"\"\nobject\n    { members }\n    {}\nmembers\n    string : value\n    members , string : value\narray\n    [ elements ]\n    []\nelements\n    value\n    elements , value\nvalue\n    string\n    number\n    object\n    array\n    true\n    false\n    null\n\"\"\"\n\nimport pyparsing as pp\nfrom pyparsing import pyparsing_common as ppc\n\n\ndef make_keyword(kwd_str, kwd_value):\n    return pp.Keyword(kwd_str).setParseAction(pp.replaceWith(kwd_value))\n\n\n# set to False to return ParseResults\nRETURN_PYTHON_COLLECTIONS = True\n\nTRUE = make_keyword(\"true\", True)\nFALSE = make_keyword(\"false\", False)\nNULL = make_keyword(\"null\", None)\n\nLBRACK, RBRACK, LBRACE, RBRACE, COLON = map(pp.Suppress, \"[]{}:\")\n\njsonString = pp.dblQuotedString().setParseAction(pp.removeQuotes)\njsonNumber = ppc.number().setName(\"jsonNumber\")\n\njsonObject = pp.Forward().setName(\"jsonObject\")\njsonValue = pp.Forward().setName(\"jsonValue\")\n\njsonElements = pp.delimitedList(jsonValue).setName(None)\n# jsonArray = pp.Group(LBRACK + pp.Optional(jsonElements, []) + RBRACK)\n# jsonValue << (\n#     jsonString | jsonNumber | pp.Group(jsonObject) | jsonArray | TRUE | FALSE | NULL\n# )\n# memberDef = pp.Group(jsonString + COLON + jsonValue).setName(\"jsonMember\")\n\njsonArray = pp.Group(\n    LBRACK + pp.Optional(jsonElements) + RBRACK, aslist=RETURN_PYTHON_COLLECTIONS\n).setName(\"jsonArray\")\n\njsonValue << (jsonString | jsonNumber | jsonObject | jsonArray | TRUE | FALSE | NULL)\n\nmemberDef = pp.Group(\n    jsonString + COLON + jsonValue, aslist=RETURN_PYTHON_COLLECTIONS\n).setName(\"jsonMember\")\n\njsonMembers = pp.delimitedList(memberDef).setName(None)\n# jsonObject << pp.Dict(LBRACE + pp.Optional(jsonMembers) + RBRACE)\njsonObject << pp.Dict(\n    LBRACE + pp.Optional(jsonMembers) + RBRACE, asdict=RETURN_PYTHON_COLLECTIONS\n)\n\njsonComment = pp.cppStyleComment\njsonObject.ignore(jsonComment)\n\n\nif __name__ == \"__main__\":\n    testdata = \"\"\"\n    {\n        \"glossary\": {\n            \"title\": \"example glossary\",\n            \"GlossDiv\": {\n                \"title\": \"S\",\n                \"GlossList\": [\n                    {\n                    \"ID\": \"SGML\",\n                    \"SortAs\": \"SGML\",\n                    \"GlossTerm\": \"Standard Generalized Markup Language\",\n                    \"TrueValue\": true,\n                    \"FalseValue\": false,\n                    \"Gravity\": -9.8,\n                    \"LargestPrimeLessThan100\": 97,\n                    \"AvogadroNumber\": 6.02E23,\n                    \"EvenPrimesGreaterThan2\": null,\n                    \"PrimesLessThan10\" : [2,3,5,7],\n                    \"Acronym\": \"SGML\",\n                    \"Abbrev\": \"ISO 8879:1986\",\n                    \"GlossDef\": \"A meta-markup language, used to create markup languages such as DocBook.\",\n                    \"GlossSeeAlso\": [\"GML\", \"XML\", \"markup\"],\n                    \"EmptyDict\" : {},\n                    \"EmptyList\" : []\n                    }\n                ]\n            }\n        }\n    }\n    \"\"\"\n\n    results = jsonObject.parseString(testdata)\n\n    results.pprint()\n    if RETURN_PYTHON_COLLECTIONS:\n        from pprint import pprint\n\n        pprint(results)\n    else:\n        results.pprint()\n    print()\n\n    def testPrint(x):\n        print(type(x), repr(x))\n\n    if RETURN_PYTHON_COLLECTIONS:\n        results = results[0]\n        print(list(results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0].keys()))\n        testPrint(results[\"glossary\"][\"title\"])\n        testPrint(results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0][\"ID\"])\n        testPrint(results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0][\"FalseValue\"])\n        testPrint(results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0][\"Acronym\"])\n        testPrint(\n            results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0][\"EvenPrimesGreaterThan2\"]\n        )\n        testPrint(results[\"glossary\"][\"GlossDiv\"][\"GlossList\"][0][\"PrimesLessThan10\"])\n    else:\n        print(list(results.glossary.GlossDiv.GlossList.keys()))\n        testPrint(results.glossary.title)\n        testPrint(results.glossary.GlossDiv.GlossList.ID)\n        testPrint(results.glossary.GlossDiv.GlossList.FalseValue)\n        testPrint(results.glossary.GlossDiv.GlossList.Acronym)\n        testPrint(results.glossary.GlossDiv.GlossList.EvenPrimesGreaterThan2)\n        testPrint(results.glossary.GlossDiv.GlossList.PrimesLessThan10)\n", "examples/cpp_enum_parser.py": "#\n# cpp_enum_parser.py\n#\n# Posted by Mark Tolonen on comp.lang.python in August, 2009,\n# Used with permission.\n#\n# Parser that scans through C or C++ code for enum definitions, and\n# generates corresponding Python constant definitions.\n#\n#\n\nimport pyparsing as pp\n\n# sample string with enums and other stuff\nsample = \"\"\"\n    stuff before\n    enum hello {\n        Zero,\n        One,\n        Two,\n        Three,\n        Five=5,\n        Six,\n        Ten=10\n        };\n    in the middle\n    enum blah\n        {\n        alpha,\n        beta,\n        gamma = 10 ,\n        zeta = 50\n        };\n    at the end\n    \"\"\"\n\n# syntax we don't want to see in the final parse tree\nLBRACE, RBRACE, EQ, COMMA = pp.Suppress.using_each(\"{}=,\")\n_enum = pp.Suppress(\"enum\")\nidentifier = pp.Word(pp.alphas + \"_\", pp.alphanums + \"_\")\ninteger = pp.Word(pp.nums)\nenumValue = pp.Group(identifier(\"name\") + pp.Optional(EQ + integer(\"value\")))\nenumList = pp.Group(enumValue + (COMMA + enumValue)[...])\nenum = _enum + identifier(\"enum\") + LBRACE + enumList(\"names\") + RBRACE\n\n# find instances of enums ignoring other syntax\nfor item, start, stop in enum.scan_string(sample):\n    idx = 0\n    for entry in item.names:\n        if entry.value != \"\":\n            idx = int(entry.value)\n        print(f\"{item.enum.upper()}_{entry.name.upper()} = {idx}\")\n        idx += 1\n", "examples/roman_numerals.py": "# romanNumerals.py\n#\n# Copyright (c) 2006, 2019, Paul McGuire\n#\n\nimport pyparsing as pp\n\n\ndef roman_numeral_literal(numeral_string, value):\n    return (\n        pp.Literal(numeral_string)\n        .set_parse_action(pp.replace_with(value))\n        .leave_whitespace()\n    )\n\n\none = roman_numeral_literal(\"I\", 1)\nfour = roman_numeral_literal(\"IV\", 4)\nfive = roman_numeral_literal(\"V\", 5)\nnine = roman_numeral_literal(\"IX\", 9)\nten = roman_numeral_literal(\"X\", 10)\nforty = roman_numeral_literal(\"XL\", 40)\nfifty = roman_numeral_literal(\"L\", 50)\nninety = roman_numeral_literal(\"XC\", 90)\nonehundred = roman_numeral_literal(\"C\", 100)\nfourhundred = roman_numeral_literal(\"CD\", 400)\nfivehundred = roman_numeral_literal(\"D\", 500)\nninehundred = roman_numeral_literal(\"CM\", 900)\nonethousand = roman_numeral_literal(\"M\", 1000)\n\n# lenient parser - passes all legal Roman numerals but does not detect illegal\n# numeral = (\n#     onethousand\n#     | ninehundred\n#     | fivehundred\n#     | fourhundred\n#     | onehundred\n#     | ninety\n#     | fifty\n#     | forty\n#     | ten\n#     | nine\n#     | five\n#     | four\n#     | one\n# )\n#\n# roman_numeral = numeral[1, ...].set_parse_action(sum)\n\n# strict parser - rejects illegal Roman numerals\nroman_numeral = (\n    onethousand[...]\n    + (ninehundred | fourhundred | fivehundred[0, 1] + onehundred[0, 3])[0, 1]\n    + (ninety | forty | fifty[0, 1] + ten[0, 3])[0, 1]\n    + (nine | four | five[0, 1] + one[0, 3])[0, 1]\n).set_parse_action(sum)\npp.autoname_elements()\n\n# uncomment to generate railroad diagram\n# roman_numeral.create_diagram(\"romanNumerals.html\")\n\n\n# unit tests\ndef make_roman_numeral(n):\n    def add_digits(n, limit, c, s):\n        while n >= limit:\n            n -= limit\n            s += c\n        return n, s\n\n    ret = \"\"\n    n, ret = add_digits(n, 1000, \"M\", ret)\n    n, ret = add_digits(n, 900, \"CM\", ret)\n    n, ret = add_digits(n, 500, \"D\", ret)\n    n, ret = add_digits(n, 400, \"CD\", ret)\n    n, ret = add_digits(n, 100, \"C\", ret)\n    n, ret = add_digits(n, 90, \"XC\", ret)\n    n, ret = add_digits(n, 50, \"L\", ret)\n    n, ret = add_digits(n, 40, \"XL\", ret)\n    n, ret = add_digits(n, 10, \"X\", ret)\n    n, ret = add_digits(n, 9, \"IX\", ret)\n    n, ret = add_digits(n, 5, \"V\", ret)\n    n, ret = add_digits(n, 4, \"IV\", ret)\n    n, ret = add_digits(n, 1, \"I\", ret)\n    return ret\n\n\ndef main():\n    # make a string of all roman numerals from I to MMMMM\n    tests = \" \".join(make_roman_numeral(i) for i in range(1, 5000 + 1))\n\n    # parse each roman numeral, and populate map for validation below\n    roman_int_map = {}\n    for expected, (t, s, e) in enumerate(roman_numeral.scan_string(tests), start=1):\n        orig = tests[s:e]\n        assert t[0] == expected, f\"==> Incorrect result for {orig}: {t}\"\n        roman_int_map[orig] = t[0]\n\n    def verify_value(s, tokens):\n        expected_value = roman_int_map[s]\n        if tokens[0] != expected_value:\n            raise Exception(\n                f\"incorrect value for {s} ({tokens[0]}), expected {expected_value}\"\n            )\n\n    success1, _ = roman_numeral.runTests(\n        \"\"\"\\\n        XVI\n        XXXIX\n        XIV\n        XIX\n        MCMLXXX\n        MMVI\n        MMMMM\n        \"\"\",\n        parse_all=True,\n        post_parse=verify_value,\n    )\n\n    assert success1, \"failed to parse one or more legal Roman numerals\"\n\n    print(\"\\nRun failure tests\")\n    success2, _ = roman_numeral.runTests(\n        \"\"\"\\\n        # too many X's\n        XXXX\n\n        # X after XL\n        XLX\n        \"\"\",\n        parse_all=True,\n        failure_tests=True,\n    )\n\n    assert success2, \"parsed one or more illegal Roman numerals\"\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/excel_expr.py": "# excelExpr.py\n#\n# Copyright 2010, Paul McGuire\n#\n# A partial implementation of a parser of Excel formula expressions.\n#\nimport pyparsing as pp\nppc = pp.common\n\npp.ParserElement.enable_packrat()\n\nEQ, LPAR, RPAR, COLON, COMMA = pp.Suppress.using_each(\"=():,\")\nEXCL, DOLLAR = pp.Literal.using_each(\"!$\")\nsheet_ref = pp.Word(pp.alphas, pp.alphanums) | pp.QuotedString(\"'\", escQuote=\"''\")\ncol_ref = pp.Opt(DOLLAR) + pp.Word(pp.alphas, max=2)\nrow_ref = pp.Opt(DOLLAR) + pp.Word(pp.nums)\ncell_ref = pp.Combine(\n    pp.Group(pp.Opt(sheet_ref + EXCL)(\"sheet\") + col_ref(\"col\") + row_ref(\"row\"))\n)\n\ncell_range = (\n        pp.Group(cell_ref(\"start\") + COLON + cell_ref(\"end\"))(\"range\")\n        | cell_ref\n        | pp.Word(pp.alphas, pp.alphanums)\n)\n\nexpr = pp.Forward()\n\nCOMPARISON_OP = pp.one_of(\"< = > >= <= != <>\")\ncond_expr = expr + COMPARISON_OP + expr\n\nif_func = (\n    pp.CaselessKeyword(\"if\")\n    - LPAR\n    + pp.Group(cond_expr)(\"condition\")\n    + COMMA\n    + pp.Group(expr)(\"if_true\")\n    + COMMA\n    + pp.Group(expr)(\"if_false\")\n    + RPAR\n)\n\n\ndef stat_function(name):\n    return pp.Group(pp.CaselessKeyword(name) + pp.Group(LPAR + pp.DelimitedList(expr) + RPAR))\n\n\nsum_func = stat_function(\"sum\")\nmin_func = stat_function(\"min\")\nmax_func = stat_function(\"max\")\nave_func = stat_function(\"ave\")\nfunc_call = if_func | sum_func | min_func | max_func | ave_func\n\nmult_op = pp.one_of(\"* /\")\nadd_op = pp.one_of(\"+ -\")\nnumeric_literal = ppc.number\noperand = numeric_literal | func_call | cell_range | cell_ref\narith_expr = pp.infix_notation(\n    operand,\n    [\n        (mult_op, 2, pp.OpAssoc.LEFT),\n        (add_op, 2, pp.OpAssoc.LEFT),\n    ],\n)\n\ntext_operand = pp.dbl_quoted_string | cell_ref\ntext_expr = pp.infix_notation(\n    text_operand,\n    [\n        (\"&\", 2, pp.OpAssoc.LEFT),\n    ],\n)\n\nexpr <<= arith_expr | text_expr\n\n\ndef main():\n    success, report = (EQ + expr).run_tests(\n        \"\"\"\\\n        =3*A7+5\n        =3*Sheet1!$A$7+5\n        =3*'Sheet 1'!$A$7+5\n        =3*'O''Reilly''s sheet'!$A$7+5\n        =if(Sum(A1:A25)>42,Min(B1:B25),if(Sum(C1:C25)>3.14, (Min(C1:C25)+3)*18,Max(B1:B25)))\n        =sum(a1:a25,10,min(b1,c2,d3))\n        =if(\"T\"&a2=\"TTime\", \"Ready\", \"Not ready\")\n    \"\"\"\n    )\n    assert success\n\n\nif __name__ == '__main__':\n    main()\n", "examples/include_preprocessor.py": "#\n# include_preprocessor.py\n#\n# Short pyparsing script to perform #include inclusions similar to the C preprocessor\n#\n# Copyright 2019, Paul McGuire\n#\nimport pyparsing as pp\nfrom pathlib import Path\n\n# parser elements to be used to assemble into #include parser\nSEMI = pp.Suppress(\";\")\nINCLUDE = pp.Keyword(\"#include\")\nquoted_string = pp.quotedString.addParseAction(pp.removeQuotes)\nfile_ref = quoted_string | pp.Word(pp.printables, excludeChars=\";\")\n\n# parser for parsing \"#include xyz.dat;\" directives\ninclude_directive = INCLUDE + file_ref(\"include_file_name\") + SEMI\n\n# add parse action that will recursively pull in included files - when\n# using transformString, the value returned from the parse action will replace\n# the text matched by the attached expression\nseen = set()\n\n\ndef read_include_contents(s, l, t):\n    include_file_ref = t.include_file_name\n    include_echo = \"/* {} */\".format(pp.line(l, s).strip())\n\n    # guard against recursive includes\n    if include_file_ref not in seen:\n        seen.add(include_file_ref)\n        included_file_contents = Path(include_file_ref).read_text()\n        return (\n            include_echo\n            + \"\\n\"\n            + include_directive.transformString(included_file_contents)\n        )\n    else:\n        lead = \" \" * (pp.col(l, s) - 1)\n        return \"/* recursive include! */\\n{}{}\".format(lead, include_echo)\n\n\n# attach include processing method as parse action (parse-time callback)\n# to include_directive expression\ninclude_directive.addParseAction(read_include_contents)\n\n\nif __name__ == \"__main__\":\n\n    # demo\n\n    # create test files:\n    # - a.txt includes b.txt\n    # - b.txt includes c.txt\n    # - c.txt includes b.txt (must catch infinite recursion)\n    Path(\"a.txt\").write_text(\n        \"\"\"\\\n        /* a.txt */\n        int i;\n\n        /* sometimes included files aren't in quotes */\n        #include b.txt;\n        \"\"\"\n    )\n\n    Path(\"b.txt\").write_text(\n        \"\"\"\\\n        i = 100;\n        #include 'c.txt';\n        \"\"\"\n    )\n\n    Path(\"c.txt\").write_text(\n        \"\"\"\\\n        i += 1;\n\n        /* watch out! this might be recursive if this file included by b.txt */\n        #include b.txt;\n        \"\"\"\n    )\n\n    # use include_directive.transformString to perform includes\n\n    # read contents of original file\n    initial_file = Path(\"a.txt\").read_text()\n\n    # print original file\n    print(initial_file)\n    print(\"-----------------\")\n\n    # expand includes in source file (and any included files) and print the result\n    expanded_source = include_directive.transformString(initial_file)\n    print(expanded_source)\n\n    # clean up\n    for fname in \"a.txt b.txt c.txt\".split():\n        Path(fname).unlink()\n", "examples/__init__.py": "", "examples/lucene_grammar.py": "#\n# lucene_grammar.py\n#\n# Copyright 2011, Paul McGuire\n# Updated 2023\n#\n# implementation of Lucene grammar, as described\n# at https://lucene.apache.org/core/2_9_4/queryparsersyntax.html\n#\n\nimport pyparsing as pp\nfrom pyparsing import pyparsing_common as ppc\n\npp.ParserElement.enable_packrat()\n\nCOLON, LBRACK, RBRACK, LBRACE, RBRACE, TILDE, CARAT = pp.Literal.using_each(\":[]{}~^\")\nLPAR, RPAR = pp.Suppress.using_each(\"()\")\nand_, or_, not_, to_ = pp.CaselessKeyword.using_each(\"AND OR NOT TO\".split())\nkeyword = and_ | or_ | not_ | to_\n\nexpression = pp.Forward()\n\nvalid_word = pp.Regex(\n    r'([a-zA-Z0-9_.-]|\\\\\\\\|\\\\([+\\-!(){}\\[\\]^\"~*?:]|\\|\\||&&))'\n    r'([a-zA-Z0-9*_+.-]|\\\\\\\\|\\\\([+\\-!(){}\\[\\]^\"~*?:]|\\|\\||&&)|\\*|\\?)*'\n).setName(\"word\")\nvalid_word.set_parse_action(\n    lambda t: t[0].replace(\"\\\\\\\\\", chr(127)).replace(\"\\\\\", \"\").replace(chr(127), \"\\\\\")\n)\n\nstring = pp.QuotedString('\"')\n\nrequired_modifier = pp.Literal(\"+\")(\"required\")\nprohibit_modifier = pp.Literal(\"-\")(\"prohibit\")\ninteger = ppc.integer()\nproximity_modifier = pp.Group(TILDE + integer(\"proximity\"))\nnumber = ppc.fnumber()\nfuzzy_modifier = TILDE + pp.Opt(number, default=0.5)(\"fuzzy\")\n\nterm = pp.Forward().set_name(\"field\")\nfield_name = valid_word().set_name(\"fieldname\")\nincl_range_search = pp.Group(LBRACK - term(\"lower\") + to_ + term(\"upper\") + RBRACK)\nexcl_range_search = pp.Group(LBRACE - term(\"lower\") + to_ + term(\"upper\") + RBRACE)\nrange_search = incl_range_search(\"incl_range\") | excl_range_search(\"excl_range\")\nboost = CARAT - number(\"boost\")\n\nstring_expr = pp.Group(string + proximity_modifier) | string\nword_expr = pp.Group(valid_word + fuzzy_modifier) | valid_word\nterm <<= (\n    ~keyword\n    + pp.Opt(field_name(\"field\") + COLON)\n    + (word_expr | string_expr | range_search | pp.Group(LPAR + expression + RPAR))\n    + pp.Opt(boost)\n)\nterm.set_parse_action(lambda t: [t] if \"field\" in t or \"boost\" in t else None)\n\nexpression <<= pp.infixNotation(\n    term,\n    [\n        (required_modifier | prohibit_modifier, 1, pp.OpAssoc.RIGHT),\n        ((not_ | \"!\").set_parse_action(lambda: \"NOT\"), 1, pp.OpAssoc.RIGHT),\n        ((and_ | \"&&\").set_parse_action(lambda: \"AND\"), 2, pp.OpAssoc.LEFT),\n        (\n            pp.Opt(or_ | \"||\").setName(\"or\").set_parse_action(lambda: \"OR\"),\n            2,\n            pp.OpAssoc.LEFT,\n        ),\n    ],\n).set_name(\"query expression\")\n\n\nif __name__ == \"__main__\":\n\n    # test strings taken from grammar description doc, and TestQueryParser.java\n    tests = r\"\"\"\n        # Success tests\n        a and b\n        a and not b\n        a and !b\n        a && !b\n        a&&!b\n        name:a\n        name:a and not title:b\n        (a^100 c d f) and !z\n        name:\"blah de blah\"\n        title:(+return +\"pink panther\")\n        title:\"The Right Way\" AND text:go\n        title:\"Do it right\" AND right\n        title:Do it right\n        te?t\n        test*\n        te*t\n        roam~\n        roam~0.8\n        \"jakarta apache\"~10\n        mod_date:[20020101 TO 20030101]\n        title:{Aida TO Carmen}\n        jakarta apache\n        jakarta^4 apache\n        \"jakarta apache\"^4 \"Apache Lucene\"\n        \"jakarta apache\" jakarta\n        \"jakarta apache\" OR jakarta\n        \"jakarta apache\" AND \"Apache Lucene\"\n        +jakarta lucene\n        \"jakarta apache\" NOT \"Apache Lucene\"\n        \"jakarta apache\" -\"Apache Lucene\"\n        (jakarta OR apache) AND website\n        title:(+return +\"pink panther\")\n        \\(1+1\\)\\:2\n        c\\:\\\\windows\n        (fieldX:xxxxx OR fieldy:xxxxxxxx)^2 AND (fieldx:the OR fieldy:foo)\n        (fieldX:xxxxx fieldy:xxxxxxxx)^2 AND (fieldx:the fieldy:foo)\n        (fieldX:xxxxx~0.5 fieldy:xxxxxxxx)^2 AND (fieldx:the fieldy:foo)\n        +term -term term\n        foo:term AND field:anotherTerm\n        germ term^2.0\n        (term)^2.0\n        (foo OR bar) AND (baz OR boo)\n        +(apple \\\"steve jobs\\\") -(foo bar baz)\n        +title:(dog OR cat) -author:\\\"bob dole\\\"\n        a AND b\n        +a +b\n        (a AND b)\n        c OR (a AND b)\n        c (+a +b)\n        a AND NOT b\n        +a -b\n        a AND -b\n        a AND !b\n        a && b\n        a && ! b\n        a OR b\n        a b\n        a || b\n        a OR !b\n        a -b\n        a OR ! b\n        a OR -b\n        a - b\n        a + b\n        a ! b\n        +foo:term +anotherterm\n        hello\n        term^2.0\n        (germ term)^2.0\n        term^2\n        +(foo bar) +(baz boo)\n        ((a OR b) AND NOT c) OR d\n        (+(a b) -c) d\n        field\n        a&&b\n        .NET\n        term\n        germ\n        3\n        term 1.0 1 2\n        term term1 term2\n        term term term\n        term*\n        term*^2\n        term*^2.0\n        term~\n        term~2.0\n        term~0.7\n        term~^3\n        term~2.0^3.0\n        term*germ\n        term*germ^3\n        term*germ^3.0\n        term~1.1\n        [A TO C]\n        t*erm*\n        term term^3.0 term\n        term stop^3.0 term\n        term +stop term\n        term -stop term\n        drop AND (stop) AND roll\n        +drop +roll\n        term +(stop) term\n        term -(stop) term\n        drop AND stop AND roll\n        term phrase term\n        term (phrase1 phrase2) term\n        term AND NOT phrase term\n        +term -(phrase1 phrase2) term\n        stop^3\n        stop\n        (stop)^3\n        ((stop))^3\n        (stop^3)\n        ((stop)^3)\n        (stop)\n        ((stop))\n        term +stop\n        [ a TO z]\n        [a TO z]\n        [ a TO z ]\n        { a TO z}\n        {a TO z}\n        { a TO z }\n        { a TO z }^2.0\n        {a TO z}^2.0\n        [ a TO z] OR bar\n        [a TO z] bar\n        [ a TO z] AND bar\n        +[a TO z] +bar\n        ( bar blar { a TO z})\n        bar blar {a TO z}\n        gack ( bar blar { a TO z})\n        gack (bar blar {a TO z})\n        [\\* TO \\*]\n        \\!blah\n        \\:blah\n        blah\n        \\~blah\n        \\*blah\n        a\n        a-b:c\n        a+b:c\n        a\\:b:c\n        a\\\\b:c\n        a:b-c\n        a:b+c\n        a:b\\:c\n        a:b\\\\c\n        a:b-c*\n        a:b+c*\n        a:b\\:c*\n        a:b\\\\c*\n        a:b-c~2.0\n        a:b+c~2.0\n        a:b\\:c~\n        a:b\\\\c~\n        [a- TO a+]\n        [ a\\\\ TO a\\* ]\n        c\\:\\\\temp\\\\\\~foo.txt\n        abc\n        XYZ\n        (item:\\\\ item:ABCD\\\\)\n        \\*\n        blah*blah\n        blah?blah\n        \\\\\n        \\||\n        \\&&\n        a\\:b\\:c\n        a\\\\b\\:c\n        a\\:b\\\\c\n        a\\:b\\:c\\*\n        a\\:b\\\\\\\\c\\*\n        a:b-c~\n        a:b+c~\n        a\\:b\\:c\\~\n        a\\:b\\\\c\\~\n        +weltbank +worlbank\n        +term +term +term\n        term +term term\n        term term +term\n        term +term +term\n        -term term term\n        -term +term +term\n        on\n        on^1.0\n        hello^2.0\n        the^3\n        the\n        some phrase\n        xunit~\n        one two three\n        A AND B OR C AND D\n        +A +B +C +D\n        foo:zoo*\n        foo:zoo*^2\n        zoo\n        a:the OR a:foo\n        a:woo OR a:the\n        \"the wizard of ozzy\"\n        \"\"\"\n\n    failtests = r\"\"\"\n        # Failure tests\n\n        # multiple ':'s in term\n        field:term:with:colon some more terms\n\n        # multiple '^'s in term\n        (sub query)^5.0^2.0 plus more\n        \n        # cannot start with * or ?\n        *term1 AND term2 \n        ?term3 OR term4\n        *\n\n        # unbounded '*' range terms\n        [* TO Z]\n        [* TO z]\n        [A TO *]\n        [a TO *]\n        [* TO *]\n\n        # unbounded field values\n        foo:*\n        foo:*^2\n        *:foo\n        *:*\n        (*:*)\n        +*:* -*:*        \n\n        a:b:c\n        a:b:c~\n        a:b:c*\n        a:b:c~2.0\n        \"\"\"\n    # strings with backslashes still to be tested\n    z = r\"\"\"\n        \\+blah\n        \\-blah\n        foo \\|| bar\n        foo \\AND bar\n        \\a\n        a\\-b:c\n        a\\+b:c\n        a\\b:c\n        a:b\\-c\n        a:b\\+c\n        a\\-b\\:c\n        a\\+b\\:c\n        a:b\\c*\n        a:b\\-c~\n        a:b\\+c~\n        a:b\\c\n        a:b\\-c*\n        a:b\\+c*\n        [ a\\- TO a\\+ ]\n        [a\\ TO a*]\n        a\\\\\\+b\n        a\\+b\n        c:\\temp\\~foo.txt\n        XY\\\n        a\\u0062c\n        a:b\\c~2.0\n        XY\\u005a\n        XY\\u005A\n        item:\\ item:ABCD\\\n        \\\n        a\\ or b\n        a\\:b\\-c\n        a\\:b\\+c\n        a\\:b\\-c\\*\n        a\\:b\\+c\\*\n        a\\:b\\-c\\~\n        a\\:b\\+c\\~\n        a:b\\c~\n        [ a\\ TO a* ]\n        \"\"\"\n\n    success1, _ = expression.runTests(tests)\n    success2, _ = expression.runTests(failtests, failureTests=True)\n\n    print(\"\\n\")\n    print(f\"Success tests: {'OK' if success1 else 'FAIL'}\")\n    print(f\"Fail tests:    {'OK' if success2 else 'FAIL'}\")\n    print(f\"All tests:     {'OK' if (success1 and success2) else 'FAIL'}\")\n\n    if not (success1 and success2):\n        import sys\n\n        sys.exit(1)\n", "examples/antlr_grammar.py": "\"\"\"\nantlr_grammar.py\n\nCreated on 4 sept. 2010\n\n@author: luca\n\nSubmitted by Luca DallOlio, September, 2010\n(Minor updates by Paul McGuire, June, 2012)\n(Code idiom updates by Paul McGuire, April, 2019)\n\"\"\"\nfrom pyparsing import (\n    Word,\n    ZeroOrMore,\n    printables,\n    Suppress,\n    OneOrMore,\n    Group,\n    LineEnd,\n    Optional,\n    White,\n    originalTextFor,\n    hexnums,\n    nums,\n    Combine,\n    Literal,\n    Keyword,\n    cStyleComment,\n    Regex,\n    Forward,\n    MatchFirst,\n    And,\n    oneOf,\n    alphas,\n    alphanums,\n    delimitedList,\n    Char,\n)\n\n# http://www.antlr.org/grammar/ANTLR/ANTLRv3.g\n\n(\n    QUOTE,\n    APOS,\n    EQ,\n    LBRACK,\n    RBRACK,\n    LBRACE,\n    RBRACE,\n    LPAR,\n    RPAR,\n    ROOT,\n    BANG,\n    AT,\n    TIL,\n    SEMI,\n    COLON,\n    VERT,\n) = map(Suppress, \"\\\"'=[]{}()^!@~;:|\")\nBSLASH = Literal(\"\\\\\")\nkeywords = (\n    SRC_,\n    SCOPE_,\n    OPTIONS_,\n    TOKENS_,\n    FRAGMENT,\n    ID,\n    LEXER,\n    PARSER,\n    GRAMMAR,\n    TREE,\n    CATCH,\n    FINALLY,\n    THROWS,\n    PROTECTED,\n    PUBLIC,\n    PRIVATE,\n) = map(\n    Keyword,\n    \"\"\"src scope options tokens fragment id lexer parser grammar tree catch finally throws protected\n       public private \"\"\".split(),\n)\nKEYWORD = MatchFirst(keywords)\n\n# Tokens\nEOL = Suppress(LineEnd())  # $\nSGL_PRINTABLE = Char(printables)\nsingleTextString = originalTextFor(\n    ZeroOrMore(~EOL + (White(\" \\t\") | Word(printables)))\n).leaveWhitespace()\nXDIGIT = hexnums\nINT = Word(nums)\nESC = BSLASH + (\n    oneOf(list(r\"nrtbf\\\">\" + \"'\")) | (\"u\" + Word(hexnums, exact=4)) | SGL_PRINTABLE\n)\nLITERAL_CHAR = ESC | ~(APOS | BSLASH) + SGL_PRINTABLE\nCHAR_LITERAL = APOS + LITERAL_CHAR + APOS\nSTRING_LITERAL = APOS + Combine(OneOrMore(LITERAL_CHAR)) + APOS\nDOUBLE_QUOTE_STRING_LITERAL = '\"' + ZeroOrMore(LITERAL_CHAR) + '\"'\nDOUBLE_ANGLE_STRING_LITERAL = \"<<\" + ZeroOrMore(SGL_PRINTABLE) + \">>\"\nTOKEN_REF = Word(alphas.upper(), alphanums + \"_\")\nRULE_REF = Word(alphas.lower(), alphanums + \"_\")\nACTION_ESC = (\n    BSLASH.suppress() + APOS\n    | BSLASH.suppress()\n    | BSLASH.suppress() + (~(APOS | QUOTE) + SGL_PRINTABLE)\n)\nACTION_CHAR_LITERAL = APOS + (ACTION_ESC | ~(BSLASH | APOS) + SGL_PRINTABLE) + APOS\nACTION_STRING_LITERAL = (\n    QUOTE + ZeroOrMore(ACTION_ESC | ~(BSLASH | QUOTE) + SGL_PRINTABLE) + QUOTE\n)\n\nSRC = SRC_.suppress() + ACTION_STRING_LITERAL(\"file\") + INT(\"line\")\nid = TOKEN_REF | RULE_REF\nSL_COMMENT = (\n    Suppress(\"//\") + Suppress(\"$ANTLR\") + SRC\n    | ZeroOrMore(~EOL + Word(printables)) + EOL\n)\nML_COMMENT = cStyleComment\nWS = OneOrMore(\n    Suppress(\" \") | Suppress(\"\\t\") | (Optional(Suppress(\"\\r\")) + Literal(\"\\n\"))\n)\nWS_LOOP = ZeroOrMore(SL_COMMENT | ML_COMMENT)\nNESTED_ARG_ACTION = Forward()\nNESTED_ARG_ACTION << (\n    LBRACK\n    + ZeroOrMore(NESTED_ARG_ACTION | ACTION_STRING_LITERAL | ACTION_CHAR_LITERAL)\n    + RBRACK\n)\nARG_ACTION = NESTED_ARG_ACTION\nNESTED_ACTION = Forward()\nNESTED_ACTION << (\n    LBRACE\n    + ZeroOrMore(\n        NESTED_ACTION\n        | SL_COMMENT\n        | ML_COMMENT\n        | ACTION_STRING_LITERAL\n        | ACTION_CHAR_LITERAL\n    )\n    + RBRACE\n)\nACTION = NESTED_ACTION + Optional(\"?\")\nSCOPE = SCOPE_.suppress()\nOPTIONS = OPTIONS_.suppress() + LBRACE  # + WS_LOOP + Suppress('{')\nTOKENS = TOKENS_.suppress() + LBRACE  # + WS_LOOP + Suppress('{')\nTREE_BEGIN = ROOT + LPAR\nRANGE = Suppress(\"..\")\nREWRITE = Suppress(\"->\")\n\n# General Parser Definitions\n\n# Grammar heading\noptionValue = id | STRING_LITERAL | CHAR_LITERAL | INT | Literal(\"*\").setName(\"s\")\n\noption = Group(id(\"id\") + EQ + optionValue(\"value\"))(\"option\")\noptionsSpec = OPTIONS + Group(OneOrMore(option + SEMI))(\"options\") + RBRACE\ntokenSpec = (\n    Group(TOKEN_REF(\"token_ref\") + (EQ + (STRING_LITERAL | CHAR_LITERAL)(\"lit\")))(\n        \"token\"\n    )\n    + SEMI\n)\ntokensSpec = TOKENS + Group(OneOrMore(tokenSpec))(\"tokens\") + RBRACE\nattrScope = SCOPE_.suppress() + id + ACTION\ngrammarType = LEXER + PARSER + TREE\nactionScopeName = id | LEXER(\"l\") | PARSER(\"p\")\naction = AT + Optional(actionScopeName + Suppress(\"::\")) + id + ACTION\n\ngrammarHeading = (\n    Optional(ML_COMMENT(\"ML_COMMENT\"))\n    + Optional(grammarType)\n    + GRAMMAR\n    + id(\"grammarName\")\n    + SEMI\n    + Optional(optionsSpec)\n    + Optional(tokensSpec)\n    + ZeroOrMore(attrScope)\n    + ZeroOrMore(action)\n)\n\nmodifier = PROTECTED | PUBLIC | PRIVATE | FRAGMENT\nruleAction = AT + id + ACTION\nthrowsSpec = THROWS.suppress() + delimitedList(id)\nruleScopeSpec = (\n    (SCOPE_.suppress() + ACTION)\n    | (SCOPE_.suppress() + delimitedList(id) + SEMI)\n    | (SCOPE_.suppress() + ACTION + SCOPE_.suppress() + delimitedList(id) + SEMI)\n)\nunary_op = oneOf(\"^ !\")\nnotTerminal = CHAR_LITERAL | TOKEN_REF | STRING_LITERAL\nterminal = (\n    CHAR_LITERAL | TOKEN_REF + Optional(ARG_ACTION) | STRING_LITERAL | \".\"\n) + Optional(unary_op)\nblock = Forward()\nnotSet = TIL + (notTerminal | block)\nrangeNotPython = CHAR_LITERAL(\"c1\") + RANGE + CHAR_LITERAL(\"c2\")\natom = Group(\n    (rangeNotPython + Optional(unary_op)(\"op\"))\n    | terminal\n    | (notSet + Optional(unary_op)(\"op\"))\n    | (RULE_REF + Optional(ARG_ACTION(\"arg\")) + Optional(unary_op)(\"op\"))\n)\nelement = Forward()\ntreeSpec = ROOT + LPAR + element * (2,) + RPAR\nebnfSuffix = oneOf(\"? * +\")\nebnf = block + Optional(ebnfSuffix(\"op\") | \"=>\")\nelementNoOptionSpec = (\n    (id(\"result_name\") + oneOf(\"= +=\")(\"labelOp\") + atom(\"atom\") + Optional(ebnfSuffix))\n    | (id(\"result_name\") + oneOf(\"= +=\")(\"labelOp\") + block + Optional(ebnfSuffix))\n    | atom(\"atom\") + Optional(ebnfSuffix)\n    | ebnf\n    | ACTION\n    | (treeSpec + Optional(ebnfSuffix))\n)  # |   SEMPRED ( '=>' -> GATED_SEMPRED | -> SEMPRED )\nelement <<= Group(elementNoOptionSpec)(\"element\")\n# Do not ask me why group is needed twice... seems like the xml that you see is not always the real structure?\nalternative = Group(Group(OneOrMore(element))(\"elements\"))\nrewrite = Optional(Literal(\"TODO REWRITE RULES TODO\"))\nblock <<= (\n    LPAR\n    + Optional(Optional(optionsSpec(\"opts\")) + COLON)\n    + Group(\n        alternative(\"a1\")\n        + rewrite\n        + Group(ZeroOrMore(VERT + alternative(\"a2\") + rewrite))(\"alternatives\")\n    )(\"block\")\n    + RPAR\n)\naltList = (\n    alternative(\"a1\")\n    + rewrite\n    + Group(ZeroOrMore(VERT + alternative(\"a2\") + rewrite))(\"alternatives\")\n)\nexceptionHandler = CATCH.suppress() + ARG_ACTION + ACTION\nfinallyClause = FINALLY.suppress() + ACTION\nexceptionGroup = (OneOrMore(exceptionHandler) + Optional(finallyClause)) | finallyClause\n\nruleHeading = (\n    Optional(ML_COMMENT)(\"ruleComment\")\n    + Optional(modifier)(\"modifier\")\n    + id(\"ruleName\")\n    + Optional(\"!\")\n    + Optional(ARG_ACTION(\"arg\"))\n    + Optional(Suppress(\"returns\") + ARG_ACTION(\"rt\"))\n    + Optional(throwsSpec)\n    + Optional(optionsSpec)\n    + Optional(ruleScopeSpec)\n    + ZeroOrMore(ruleAction)\n)\nrule = Group(ruleHeading + COLON + altList + SEMI + Optional(exceptionGroup))(\"rule\")\n\ngrammarDef = grammarHeading + Group(OneOrMore(rule))(\"rules\")\n\n\ndef grammar():\n    return grammarDef\n\n\ndef __antlrAlternativesConverter(pyparsingRules, antlrBlock):\n    rule = None\n    if (\n        hasattr(antlrBlock, \"alternatives\")\n        and antlrBlock.alternatives != \"\"\n        and len(antlrBlock.alternatives) > 0\n    ):\n        alternatives = []\n        alternatives.append(__antlrAlternativeConverter(pyparsingRules, antlrBlock.a1))\n        for alternative in antlrBlock.alternatives:\n            alternatives.append(\n                __antlrAlternativeConverter(pyparsingRules, alternative)\n            )\n        rule = MatchFirst(alternatives)(\"anonymous_or\")\n    elif hasattr(antlrBlock, \"a1\") and antlrBlock.a1 != \"\":\n        rule = __antlrAlternativeConverter(pyparsingRules, antlrBlock.a1)\n    else:\n        raise Exception(\"Not yet implemented\")\n    assert rule != None\n    return rule\n\n\ndef __antlrAlternativeConverter(pyparsingRules, antlrAlternative):\n    elementList = []\n    for element in antlrAlternative.elements:\n        rule = None\n        if hasattr(element.atom, \"c1\") and element.atom.c1 != \"\":\n            regex = r\"[\" + str(element.atom.c1[0]) + \"-\" + str(element.atom.c2[0] + \"]\")\n            rule = Regex(regex)(\"anonymous_regex\")\n        elif hasattr(element, \"block\") and element.block != \"\":\n            rule = __antlrAlternativesConverter(pyparsingRules, element.block)\n        else:\n            ruleRef = element.atom[0]\n            assert ruleRef in pyparsingRules\n            rule = pyparsingRules[ruleRef](ruleRef)\n        if hasattr(element, \"op\") and element.op != \"\":\n            if element.op == \"+\":\n                rule = Group(OneOrMore(rule))(\"anonymous_one_or_more\")\n            elif element.op == \"*\":\n                rule = Group(ZeroOrMore(rule))(\"anonymous_zero_or_more\")\n            elif element.op == \"?\":\n                rule = Optional(rule)\n            else:\n                raise Exception(\"rule operator not yet implemented : \" + element.op)\n        rule = rule\n        elementList.append(rule)\n    if len(elementList) > 1:\n        rule = Group(And(elementList))(\"anonymous_and\")\n    else:\n        rule = elementList[0]\n    assert rule is not None\n    return rule\n\n\ndef __antlrRuleConverter(pyparsingRules, antlrRule):\n    rule = None\n    rule = __antlrAlternativesConverter(pyparsingRules, antlrRule)\n    assert rule != None\n    rule(antlrRule.ruleName)\n    return rule\n\n\ndef antlrConverter(antlrGrammarTree):\n    pyparsingRules = {}\n\n    antlrTokens = {}\n    for antlrToken in antlrGrammarTree.tokens:\n        antlrTokens[antlrToken.token_ref] = antlrToken.lit\n    for antlrTokenName, antlrToken in list(antlrTokens.items()):\n        pyparsingRules[antlrTokenName] = Literal(antlrToken)\n\n    antlrRules = {}\n    for antlrRule in antlrGrammarTree.rules:\n        antlrRules[antlrRule.ruleName] = antlrRule\n        pyparsingRules[antlrRule.ruleName] = Forward()  # antlr is a top down grammar\n    for antlrRuleName, antlrRule in list(antlrRules.items()):\n        pyparsingRule = __antlrRuleConverter(pyparsingRules, antlrRule)\n        assert pyparsingRule != None\n        pyparsingRules[antlrRuleName] <<= pyparsingRule\n\n    return pyparsingRules\n\n\nif __name__ == \"__main__\":\n\n    text = \"\"\"\\\ngrammar SimpleCalc;\n\noptions {\n    language = Python;\n}\n\ntokens {\n    PLUS     = '+' ;\n    MINUS    = '-' ;\n    MULT    = '*' ;\n    DIV    = '/' ;\n}\n\n/*------------------------------------------------------------------\n * PARSER RULES\n *------------------------------------------------------------------*/\n\nexpr    : term ( ( PLUS | MINUS )  term )* ;\n\nterm    : factor ( ( MULT | DIV ) factor )* ;\n\nfactor    : NUMBER ;\n\n\n/*------------------------------------------------------------------\n * LEXER RULES\n *------------------------------------------------------------------*/\n\nNUMBER    : (DIGIT)+ ;\n\n/* WHITESPACE : ( '\\t' | ' ' | '\\r' | '\\n'| '\\u000C' )+     { $channel = HIDDEN; } ; */\n\nfragment DIGIT    : '0'..'9' ;\n\n\"\"\"\n\n    grammar().validate()\n    antlrGrammarTree = grammar().parseString(text)\n    print(antlrGrammarTree.dump())\n    pyparsingRules = antlrConverter(antlrGrammarTree)\n    pyparsingRule = pyparsingRules[\"expr\"]\n    pyparsingTree = pyparsingRule.parseString(\"2 - 5 * 42 + 7 / 25\")\n    print(pyparsingTree.dump())\n", "examples/idlParse.py": "#\n# idlparse.py\n#\n# an example of using the parsing module to be able to process a subset of the CORBA IDL grammar\n#\n# Copyright (c) 2003, Paul McGuire\n#\n\nfrom pyparsing import (\n    Literal,\n    Word,\n    OneOrMore,\n    ZeroOrMore,\n    Forward,\n    delimitedList,\n    Group,\n    Optional,\n    alphas,\n    restOfLine,\n    cStyleComment,\n    alphanums,\n    quotedString,\n    ParseException,\n    Keyword,\n    Regex,\n)\nimport pprint\n\n# ~ import tree2image\n\nbnf = None\n\n\ndef CORBA_IDL_BNF():\n    global bnf\n\n    if not bnf:\n\n        # punctuation\n        (\n            colon,\n            lbrace,\n            rbrace,\n            lbrack,\n            rbrack,\n            lparen,\n            rparen,\n            equals,\n            comma,\n            dot,\n            slash,\n            bslash,\n            star,\n            semi,\n            langle,\n            rangle,\n        ) = map(Literal, r\":{}[]()=,./\\*;<>\")\n\n        # keywords\n        (\n            any_,\n            attribute_,\n            boolean_,\n            case_,\n            char_,\n            const_,\n            context_,\n            default_,\n            double_,\n            enum_,\n            exception_,\n            FALSE_,\n            fixed_,\n            float_,\n            inout_,\n            interface_,\n            in_,\n            long_,\n            module_,\n            Object_,\n            octet_,\n            oneway_,\n            out_,\n            raises_,\n            readonly_,\n            sequence_,\n            short_,\n            string_,\n            struct_,\n            switch_,\n            TRUE_,\n            typedef_,\n            unsigned_,\n            union_,\n            void_,\n            wchar_,\n            wstring_,\n        ) = map(\n            Keyword,\n            \"\"\"any attribute boolean case char const context\n            default double enum exception FALSE fixed float inout interface in long module\n            Object octet oneway out raises readonly sequence short string struct switch\n            TRUE typedef unsigned union void wchar wstring\"\"\".split(),\n        )\n\n        identifier = Word(alphas, alphanums + \"_\").setName(\"identifier\")\n\n        real = Regex(r\"[+-]?\\d+\\.\\d*([Ee][+-]?\\d+)?\").setName(\"real\")\n        integer = Regex(r\"0x[0-9a-fA-F]+|[+-]?\\d+\").setName(\"int\")\n\n        udTypeName = delimitedList(identifier, \"::\", combine=True).setName(\"udType\")\n        typeName = (\n            any_\n            | boolean_\n            | char_\n            | double_\n            | fixed_\n            | float_\n            | long_\n            | octet_\n            | short_\n            | string_\n            | wchar_\n            | wstring_\n            | udTypeName\n        ).setName(\"type\")\n        sequenceDef = Forward().setName(\"seq\")\n        sequenceDef << Group(sequence_ + langle + (sequenceDef | typeName) + rangle)\n        typeDef = sequenceDef | (typeName + Optional(lbrack + integer + rbrack))\n        typedefDef = Group(typedef_ + typeDef + identifier + semi).setName(\"typedef\")\n\n        moduleDef = Forward().setName(\"moduleDef\")\n        constDef = Group(\n            const_\n            + typeDef\n            + identifier\n            + equals\n            + (real | integer | quotedString)\n            + semi\n        ).setName(\n            \"constDef\"\n        )  # | quotedString )\n        exceptionItem = Group(typeDef + identifier + semi)\n        exceptionDef = (\n            exception_ + identifier + lbrace + ZeroOrMore(exceptionItem) + rbrace + semi\n        ).setName(\"exceptionDef\")\n        attributeDef = Optional(readonly_) + attribute_ + typeDef + identifier + semi\n        paramlist = delimitedList(\n            Group((inout_ | in_ | out_) + typeName + identifier)\n        ).setName(\"paramlist\")\n        operationDef = (\n            (void_ ^ typeDef)\n            + identifier\n            + lparen\n            + Optional(paramlist)\n            + rparen\n            + Optional(raises_ + lparen + Group(delimitedList(typeName)) + rparen)\n            + semi\n        ).setName(\"operationDef\")\n        interfaceItem = constDef | exceptionDef | attributeDef | operationDef\n        interfaceDef = Group(\n            interface_\n            + identifier\n            + Optional(colon + delimitedList(typeName))\n            + lbrace\n            + ZeroOrMore(interfaceItem)\n            + rbrace\n            + semi\n        ).setName(\"interfaceDef\")\n        moduleItem = (\n            interfaceDef | exceptionDef | constDef | typedefDef | moduleDef\n        ).setName(\"moduleItem\")\n        (\n            moduleDef\n            << module_ + identifier + lbrace + ZeroOrMore(moduleItem) + rbrace + semi\n        )\n\n        bnf = moduleDef | OneOrMore(moduleItem)\n\n        singleLineComment = \"//\" + restOfLine\n        bnf.ignore(singleLineComment)\n        bnf.ignore(cStyleComment)\n\n    return bnf\n\n\nif __name__ == \"__main__\":\n\n    testnum = 1\n\n    def test(strng):\n        global testnum\n        print(strng)\n        try:\n            bnf = CORBA_IDL_BNF()\n            tokens = bnf.parseString(strng)\n            print(\"tokens = \")\n            pprint.pprint(tokens.asList())\n            imgname = \"idlParse%02d.bmp\" % testnum\n            testnum += 1\n            # ~ tree2image.str2image( str(tokens.asList()), imgname )\n        except ParseException as err:\n            print(err.line)\n            print(\" \" * (err.column - 1) + \"^\")\n            print(err)\n        print()\n\n    test(\n        \"\"\"\n        /*\n         * a block comment *\n         */\n        typedef string[10] tenStrings;\n        typedef sequence<string> stringSeq;\n        typedef sequence< sequence<string> > stringSeqSeq;\n\n        interface QoSAdmin {\n            stringSeq method1( in string arg1, inout long arg2 );\n            stringSeqSeq method2( in string arg1, inout long arg2, inout long arg3);\n            string method3();\n          };\n        \"\"\"\n    )\n    test(\n        \"\"\"\n        /*\n         * a block comment *\n         */\n        typedef string[10] tenStrings;\n        typedef\n            /** ** *** **** *\n             * a block comment *\n             */\n            sequence<string> /*comment inside an And */ stringSeq;\n        /* */  /**/ /***/ /****/\n        typedef sequence< sequence<string> > stringSeqSeq;\n\n        interface QoSAdmin {\n            stringSeq method1( in string arg1, inout long arg2 );\n            stringSeqSeq method2( in string arg1, inout long arg2, inout long arg3);\n            string method3();\n          };\n        \"\"\"\n    )\n    test(\n        r\"\"\"\n          const string test=\"Test String\\n\";\n          const long  a = 0;\n          const long  b = -100;\n          const float c = 3.14159;\n          const long  d = 0x007f7f7f;\n          exception TestException\n            {\n            string msg;\n            sequence<string> dataStrings;\n            };\n\n          interface TestInterface\n            {\n            void method1( in string arg1, inout long arg2 );\n            };\n        \"\"\"\n    )\n    test(\n        \"\"\"\n        module Test1\n          {\n          exception TestException\n            {\n            string msg;\n            ];\n\n          interface TestInterface\n            {\n            void method1( in string arg1, inout long arg2 )\n              raises ( TestException );\n            };\n          };\n        \"\"\"\n    )\n    test(\n        \"\"\"\n        module Test1\n          {\n          exception TestException\n            {\n            string msg;\n            };\n\n          };\n        \"\"\"\n    )\n", "examples/antlr_grammar_tests.py": "\"\"\"\nCreated on 4 sept. 2010\n\n@author: luca\n\nSubmitted by Luca DallOlio, September, 2010\n\"\"\"\nimport unittest\nfrom . import antlr_grammar\n\n\nclass Test(unittest.TestCase):\n    def testOptionsSpec(self):\n        text = \"\"\"options {\n                            language = Python;\n                        }\"\"\"\n        antlr_grammar.optionsSpec.parseString(text)  # @UndefinedVariable\n\n    def testTokensSpec(self):\n        text = \"\"\"tokens {\n                            PLUS     = '+' ;\n                            MINUS    = '-' ;\n                            MULT    = '*' ;\n                            DIV    = '/' ;\n                        }\"\"\"\n        antlr_grammar.tokensSpec.parseString(text)  # @UndefinedVariable\n\n    def testBlock(self):\n        text = \"\"\"( PLUS | MINUS )\"\"\"\n        antlr_grammar.block.parseString(text)  # @UndefinedVariable\n\n    def testRule(self):\n        text = \"\"\"expr    : term ( ( PLUS | MINUS )  term )* ;\"\"\"\n        antlr_grammar.rule.parseString(text)  # @UndefinedVariable\n\n    def testLexerRule(self):\n        text = \"\"\"fragment DIGIT    : '0'..'9' ;\"\"\"\n        antlr_grammar.rule.parseString(text)  # @UndefinedVariable\n\n    def testLexerRule2(self):\n        text = \"\"\"WHITESPACE : ( '\\t' | ' ' | '\\r' | '\\n'| '\\u000C' )+     { $channel = HIDDEN; } ;\"\"\"\n        # antlr_grammar.rule.parseString(text) #@UndefinedVariable\n\n    def testGrammar(self):\n        text = \"\"\"grammar SimpleCalc;\n\noptions {\n    language = Python;\n}\n\ntokens {\n    PLUS     = '+' ;\n    MINUS    = '-' ;\n    MULT    = '*' ;\n    DIV    = '/' ;\n}\n\n/*------------------------------------------------------------------\n * PARSER RULES\n *------------------------------------------------------------------*/\n\nexpr    : term ( ( PLUS | MINUS )  term )* ;\n\nterm    : factor ( ( MULT | DIV ) factor )* ;\n\nfactor    : NUMBER ;\n\n\n/*------------------------------------------------------------------\n * LEXER RULES\n *------------------------------------------------------------------*/\n\nNUMBER    : (DIGIT)+ ;\n\n/* WHITESPACE : ( '\\t' | ' ' | '\\r' | '\\n'| '\\u000C' )+     { $channel = HIDDEN; } ; */\n\nfragment DIGIT    : '0'..'9' ;\"\"\"\n        antlrGrammarTree = antlr_grammar.grammarDef.parseString(\n            text\n        )  # @UndefinedVariable\n        pyparsingRules = antlr_grammar.antlrConverter(antlrGrammarTree)\n        pyparsingRule = pyparsingRules[\"expr\"]\n        pyparsingTree = pyparsingRule.parseString(\"2 - 5 * 42 + 7 / 25\")\n        pyparsingTreeList = pyparsingTree.asList()\n        print(pyparsingTreeList)\n        self.assertEqual(\n            pyparsingTreeList,\n            [\n                [\n                    [[\"2\"], []],\n                    [\n                        [\"-\", [[\"5\"], [[\"*\", [\"4\", \"2\"]]]]],\n                        [\"+\", [[\"7\"], [[\"/\", [\"2\", \"5\"]]]]],\n                    ],\n                ]\n            ],\n        )\n\n\nif __name__ == \"__main__\":\n    # import sys;sys.argv = ['', 'Test.testOptionsSpec']\n    unittest.main()\n", "examples/ebnf.py": "# This module tries to implement ISO 14977 standard with pyparsing.\n# pyparsing version 1.1 or greater is required.\n\n# ISO 14977 standardize The Extended Backus-Naur Form(EBNF) syntax.\n# You can read a final draft version here:\n# https://www.cl.cam.ac.uk/~mgk25/iso-ebnf.html\n#\n# Submitted 2004 by Seo Sanghyeon\n#\n\nfrom pyparsing import *\n\n\nall_names = \"\"\"\ninteger\nmeta_identifier\nterminal_string\noptional_sequence\nrepeated_sequence\ngrouped_sequence\nsyntactic_primary\nsyntactic_factor\nsyntactic_term\nsingle_definition\ndefinitions_list\nsyntax_rule\nsyntax\n\"\"\".split()\n\n\ninteger = Word(nums)\nmeta_identifier = Word(alphas, alphanums + \"_\")\nterminal_string = Suppress(\"'\") + CharsNotIn(\"'\") + Suppress(\"'\") ^ Suppress(\n    '\"'\n) + CharsNotIn('\"') + Suppress('\"')\ndefinitions_list = Forward()\noptional_sequence = Suppress(\"[\") + definitions_list + Suppress(\"]\")\nrepeated_sequence = Suppress(\"{\") + definitions_list + Suppress(\"}\")\ngrouped_sequence = Suppress(\"(\") + definitions_list + Suppress(\")\")\nsyntactic_primary = (\n    optional_sequence\n    ^ repeated_sequence\n    ^ grouped_sequence\n    ^ meta_identifier\n    ^ terminal_string\n)\nsyntactic_factor = Optional(integer + Suppress(\"*\")) + syntactic_primary\nsyntactic_term = syntactic_factor + Optional(Suppress(\"-\") + syntactic_factor)\nsingle_definition = delimitedList(syntactic_term, \",\")\ndefinitions_list << delimitedList(single_definition, \"|\")\nsyntax_rule = meta_identifier + Suppress(\"=\") + definitions_list + Suppress(\";\")\n\nebnfComment = (\n    (\"(*\" + ZeroOrMore(CharsNotIn(\"*\") | (\"*\" + ~Literal(\")\"))) + \"*)\")\n    .streamline()\n    .setName(\"ebnfComment\")\n)\n\nsyntax = OneOrMore(syntax_rule)\nsyntax.ignore(ebnfComment)\n\n\ndef do_integer(str, loc, toks):\n    return int(toks[0])\n\n\ndef do_meta_identifier(str, loc, toks):\n    if toks[0] in symbol_table:\n        return symbol_table[toks[0]]\n    else:\n        forward_count.value += 1\n        symbol_table[toks[0]] = Forward()\n        return symbol_table[toks[0]]\n\n\ndef do_terminal_string(str, loc, toks):\n    return Literal(toks[0])\n\n\ndef do_optional_sequence(str, loc, toks):\n    return Optional(toks[0])\n\n\ndef do_repeated_sequence(str, loc, toks):\n    return ZeroOrMore(toks[0])\n\n\ndef do_grouped_sequence(str, loc, toks):\n    return Group(toks[0])\n\n\ndef do_syntactic_primary(str, loc, toks):\n    return toks[0]\n\n\ndef do_syntactic_factor(str, loc, toks):\n    if len(toks) == 2:\n        # integer * syntactic_primary\n        return And([toks[1]] * toks[0])\n    else:\n        # syntactic_primary\n        return [toks[0]]\n\n\ndef do_syntactic_term(str, loc, toks):\n    if len(toks) == 2:\n        # syntactic_factor - syntactic_factor\n        return NotAny(toks[1]) + toks[0]\n    else:\n        # syntactic_factor\n        return [toks[0]]\n\n\ndef do_single_definition(str, loc, toks):\n    toks = toks.asList()\n    if len(toks) > 1:\n        # syntactic_term , syntactic_term , ...\n        return And(toks)\n    else:\n        # syntactic_term\n        return [toks[0]]\n\n\ndef do_definitions_list(str, loc, toks):\n    toks = toks.asList()\n    if len(toks) > 1:\n        # single_definition | single_definition | ...\n        return Or(toks)\n    else:\n        # single_definition\n        return [toks[0]]\n\n\ndef do_syntax_rule(str, loc, toks):\n    # meta_identifier = definitions_list ;\n    assert toks[0].expr is None, \"Duplicate definition\"\n    forward_count.value -= 1\n    toks[0] << toks[1]\n    return [toks[0]]\n\n\ndef do_syntax(str, loc, toks):\n    # syntax_rule syntax_rule ...\n    return symbol_table\n\n\nsymbol_table = {}\n\n\nclass forward_count:\n    pass\n\n\nforward_count.value = 0\nfor name in all_names:\n    expr = vars()[name]\n    action = vars()[\"do_\" + name]\n    expr.setName(name)\n    expr.setParseAction(action)\n    # ~ expr.setDebug()\n\n\ndef parse(ebnf, given_table={}):\n    symbol_table.clear()\n    symbol_table.update(given_table)\n    forward_count.value = 0\n    table = syntax.parseString(ebnf)[0]\n    assert forward_count.value == 0, \"Missing definition\"\n    for name in table:\n        expr = table[name]\n        expr.setName(name)\n        # ~ expr.setDebug()\n    return table\n", "examples/wordsToNum.py": "# wordsToNum.py\n# Copyright 2006, Paul McGuire\n#\n# Sample parser grammar to read a number given in words, and return the numeric value.\n#\nimport pyparsing as pp\nfrom operator import mul\nfrom functools import reduce\n\n\ndef makeLit(s, val):\n    ret = pp.CaselessLiteral(s)\n    return ret.setParseAction(pp.replaceWith(val))\n\n\nunitDefinitions = [\n    (\"zero\", 0),\n    (\"oh\", 0),\n    (\"zip\", 0),\n    (\"zilch\", 0),\n    (\"nada\", 0),\n    (\"bupkis\", 0),\n    (\"one\", 1),\n    (\"two\", 2),\n    (\"three\", 3),\n    (\"four\", 4),\n    (\"five\", 5),\n    (\"six\", 6),\n    (\"seven\", 7),\n    (\"eight\", 8),\n    (\"nine\", 9),\n    (\"ten\", 10),\n    (\"eleven\", 11),\n    (\"twelve\", 12),\n    (\"thirteen\", 13),\n    (\"fourteen\", 14),\n    (\"fifteen\", 15),\n    (\"sixteen\", 16),\n    (\"seventeen\", 17),\n    (\"eighteen\", 18),\n    (\"nineteen\", 19),\n]\nunits = pp.MatchFirst(\n    makeLit(s, v) for s, v in sorted(unitDefinitions, key=lambda d: -len(d[0]))\n)\n\ntensDefinitions = [\n    (\"ten\", 10),\n    (\"twenty\", 20),\n    (\"thirty\", 30),\n    (\"forty\", 40),\n    (\"fourty\", 40),  # for the spelling-challenged...\n    (\"fifty\", 50),\n    (\"sixty\", 60),\n    (\"seventy\", 70),\n    (\"eighty\", 80),\n    (\"ninety\", 90),\n]\ntens = pp.MatchFirst(makeLit(s, v) for s, v in tensDefinitions)\n\nhundreds = makeLit(\"hundred\", 100)\n\nmajorDefinitions = [\n    (\"thousand\", int(1e3)),\n    (\"million\", int(1e6)),\n    (\"billion\", int(1e9)),\n    (\"trillion\", int(1e12)),\n    (\"quadrillion\", int(1e15)),\n    (\"quintillion\", int(1e18)),\n]\nmag = pp.MatchFirst(makeLit(s, v) for s, v in majorDefinitions)\n\nwordprod = lambda t: reduce(mul, t)\nnumPart = (\n    (\n        (\n            (units + pp.Optional(hundreds)).setParseAction(wordprod) + pp.Optional(tens)\n        ).setParseAction(sum)\n        ^ tens\n    )\n    + pp.Optional(units)\n).setParseAction(sum)\nnumWords = (\n    (numPart + pp.Optional(mag)).setParseAction(wordprod)[1, ...]\n).setParseAction(sum)\nnumWords.setName(\"num word parser\")\n\nnumWords.ignore(pp.Literal(\"-\"))\nnumWords.ignore(pp.CaselessLiteral(\"and\"))\n\ntests = \"\"\"\n    one hundred twenty hundred, None\n    one hundred and twennty, None\n    one hundred and twenty, 120\n    one hundred and three, 103\n    one hundred twenty-three, 123\n    one hundred and twenty three, 123\n    one hundred twenty three million, 123000000\n    one hundred and twenty three million, 123000000\n    one hundred twenty three million and three, 123000003\n    fifteen hundred and sixty five, 1565\n    seventy-seven thousand eight hundred and nineteen, 77819\n    seven hundred seventy-seven thousand seven hundred and seventy-seven, 777777\n    zero, 0\n    forty two, 42\n    fourty two, 42\n\"\"\"\n\n# use '| ...' to indicate \"if omitted, skip to next\" logic\ntest_expr = (\n    (numWords(\"result\") | ...)\n    + \",\"\n    + (pp.pyparsing_common.integer(\"expected\") | \"None\")\n)\n\n\ndef verify_result(t):\n    if \"_skipped\" in t:\n        t[\"pass\"] = False\n    elif \"expected\" in t:\n        t[\"pass\"] = t.result == t.expected\n\n\ntest_expr.addParseAction(verify_result)\n\ntest_expr.runTests(tests)\n", "examples/parse_python_value.py": "# parsePythonValue.py\n#\n# Copyright, 2006, by Paul McGuire\n#\nimport pyparsing as pp\n\n\ncvtBool = lambda t: t[0] == \"True\"\ncvtInt = lambda toks: int(toks[0])\ncvtReal = lambda toks: float(toks[0])\ncvtTuple = lambda toks: tuple(toks.as_list())\ncvtSet = lambda toks: set(toks.as_list())\ncvtDict = lambda toks: dict(toks.as_list())\ncvtList = lambda toks: [toks.as_list()]\n\n# define punctuation as suppressed literals\nlparen, rparen, lbrack, rbrack, lbrace, rbrace, colon, comma = pp.Suppress.using_each(\"()[]{}:,\")\n\ninteger = pp.Regex(r\"[+-]?\\d+\").set_name(\"integer\").add_parse_action(cvtInt)\nreal = pp.Regex(r\"[+-]?\\d+\\.\\d*([Ee][+-]?\\d+)?\").set_name(\"real\").add_parse_action(cvtReal)\ntuple_str = pp.Forward().set_name(\"tuple_expr\")\nlist_str = pp.Forward().set_name(\"list_expr\")\nset_str = pp.Forward().set_name(\"set_expr\")\ndict_str = pp.Forward().set_name(\"dict_expr\")\n\nunistr = pp.unicodeString().add_parse_action(lambda t: t[0][2:-1])\nquoted_str = pp.quotedString().add_parse_action(lambda t: t[0][1:-1])\nbool_literal = pp.oneOf(\"True False\", as_keyword=True).add_parse_action(cvtBool)\nnone_literal = pp.Keyword(\"None\").add_parse_action(pp.replace_with(None))\n\nlist_item = (\n    real\n    | integer\n    | quoted_str\n    | unistr\n    | bool_literal\n    | none_literal\n    | pp.Group(list_str)\n    | tuple_str\n    | set_str\n    | dict_str\n).set_name(\"list_item\")\n\ntuple_str <<= (\n    lparen + pp.Opt(pp.DelimitedList(list_item, allow_trailing_delim=True)) + rparen\n)\ntuple_str.add_parse_action(cvtTuple)\n\nset_str <<= (\n    lbrace + pp.DelimitedList(list_item, allow_trailing_delim=True) + rbrace\n)\nset_str.add_parse_action(cvtSet)\n\nlist_str <<= (\n    lbrack + pp.Opt(pp.DelimitedList(list_item, allow_trailing_delim=True)) + rbrack\n)\nlist_str.add_parse_action(cvtList, lambda t: t[0])\n\ndict_entry = pp.Group(list_item + colon + list_item).set_name(\"dict_entry\")\ndict_str <<= (\n    lbrace + pp.Opt(pp.DelimitedList(dict_entry, allow_trailing_delim=True)) + rbrace\n)\ndict_str.add_parse_action(cvtDict)\n\nif __name__ == \"__main__\":\n\n    tests = \"\"\"['a', 100, ('A', [101,102]), 3.14, [ +2.718, 'xyzzy', -1.414] ]\n               [{0: [2], 1: []}, {0: [], 1: [], 2: []}, {0: [1, 2]}]\n               { 'A':1, 'B':2, 'C': {'a': 1.2, 'b': 3.4} }\n               { 1, 2, 11, \"blah\" }\n               { 'A':1, 'B':2, 'C': {'a', 1.2, 'b', 3.4} }\n               3.14159\n               42\n               6.02E23\n               6.02e+023\n               1.0e-7\n               'a quoted string'\"\"\"\n\n    list_item.run_tests(tests)\n    list_item.create_diagram(\"parse_python_value.html\")\n", "examples/searchParserAppDemo.py": "from searchparser import SearchQueryParser\n\nproducts = [\n    \"grape juice\",\n    \"grape jelly\",\n    \"orange juice\",\n    \"orange jujubees\",\n    \"strawberry jam\",\n    \"prune juice\",\n    \"prune butter\",\n    \"orange marmalade\",\n    \"grapefruit juice\",\n]\n\n\nclass FruitSearchParser(SearchQueryParser):\n    def GetWord(self, word):\n        return {p for p in products if p.startswith(word + \" \")}\n\n    def GetWordWildcard(self, word):\n        return {p for p in products if p.startswith(word[:-1])}\n\n    def GetQuotes(self, search_string, tmp_result):\n        result = set()\n        # I have no idea how to use this feature...\n        return result\n\n    def GetNot(self, not_set):\n        return set(products) - not_set\n\n\nparser = FruitSearchParser()\n\ntests = \"\"\"\\\n    grape or orange\n    grape*\n    not(grape*)\n    prune and grape\"\"\".splitlines()\n\nfor t in tests:\n    print(t.strip())\n    print(parser.Parse(t))\n    print(\"\")\n", "examples/commasep.py": "# commasep.py\n#\n# comma-separated list example, to illustrate the advantages of using\n# the pyparsing comma_separated_list as opposed to string.split(\",\"):\n# - leading and trailing whitespace is implicitly trimmed from list elements\n# - list elements can be quoted strings, which can safely contain commas without breaking\n#    into separate elements\n#\n# Copyright (c) 2004-2016, Paul McGuire\n#\n\nimport pyparsing as pp\n\nppc = pp.pyparsing_common\n\ntestData = [\n    \"a,b,c,100.2,,3\",\n    \"d, e, j k , m  \",\n    \"'Hello, World', f, g , , 5.1,x\",\n    \"John Doe, 123 Main St., Cleveland, Ohio\",\n    \"Jane Doe, 456 St. James St., Los Angeles , California \",\n    \"\",\n]\n\nppc.comma_separated_list.runTests(testData)\n", "examples/parse_results_sum_example.py": "#\n# parseResultsSumExample.py\n#\n# Sample script showing the value in merging ParseResults retrieved by searchString,\n# using Python's builtin sum() method\n#\nsamplestr1 = \"garbage;DOB 10-10-2010;more garbage\\nID PARI12345678;more garbage\"\nsamplestr2 = \"garbage;ID PARI12345678;more garbage\\nDOB 10-10-2010;more garbage\"\nsamplestr3 = \"garbage;DOB 10-10-2010\"\nsamplestr4 = \"garbage;ID PARI12345678;more garbage- I am cool\"\n\nfrom pyparsing import Regex, Word, alphanums, rest_of_line\n\ndob_ref = \"DOB\" + Regex(r\"\\d{2}-\\d{2}-\\d{4}\")(\"dob\")\nid_ref = \"ID\" + Word(alphanums, exact=12)(\"id\")\ninfo_ref = \"-\" + rest_of_line(\"info\")\n\nperson_data = dob_ref | id_ref | info_ref\n\nfor test in (\n    samplestr1,\n    samplestr2,\n    samplestr3,\n    samplestr4,\n):\n    person = sum(person_data.search_string(test))\n    print(person.id)\n    print(person.dump())\n    print()\n", "examples/chemical_formulas.py": "#\n# chemicalFormulas.py\n#\n# Copyright (c) 2003,2019 Paul McGuire\n#\n\nimport pyparsing as pp\n\natomic_weight = {\n    \"O\": 15.9994,\n    \"H\": 1.00794,\n    \"Na\": 22.9897,\n    \"Cl\": 35.4527,\n    \"C\": 12.0107,\n}\n\ndigits = \"0123456789\"\n\n# Version 1\nelement = pp.Word(pp.alphas.upper(), pp.alphas.lower(), max=2).set_name(\"element\")\n# for stricter matching, use this Regex instead\n# element = Regex(\"A[cglmrstu]|B[aehikr]?|C[adeflmorsu]?|D[bsy]|\"\n#                 \"E[rsu]|F[emr]?|G[ade]|H[efgos]?|I[nr]?|Kr?|L[airu]|\"\n#                 \"M[dgnot]|N[abdeiop]?|Os?|P[abdmortu]?|R[abefghnu]|\"\n#                 \"S[bcegimnr]?|T[abcehilm]|U(u[bhopqst])?|V|W|Xe|Yb?|Z[nr]\")\nelement_ref = pp.Group(element + pp.Opt(pp.Word(digits), default=\"1\"))\nformula = element_ref[...]\n\n\ndef sum_atomic_weights(element_list):\n    return sum(atomic_weight[elem] * int(qty) for elem, qty in element_list)\n\n\nformula.run_tests(\n    \"\"\"\\\n    H2O\n    C6H5OH\n    NaCl\n    \"\"\",\n    full_dump=False,\n    post_parse=lambda _, tokens: f\"Molecular weight: {sum_atomic_weights(tokens)}\",\n)\nprint()\n\n\n# Version 2 - access parsed items by results name\nelement_ref = pp.Group(\n    element(\"symbol\") + pp.Opt(pp.Word(digits), default=\"1\")(\"qty\")\n)\nformula = element_ref[...]\n\n\ndef sum_atomic_weights_by_results_name(element_list):\n    return sum(atomic_weight[elem.symbol] * int(elem.qty) for elem in element_list)\n\n\nformula.run_tests(\n    \"\"\"\\\n    H2O\n    C6H5OH\n    NaCl\n    \"\"\",\n    full_dump=False,\n    post_parse=lambda _, tokens:\n        f\"Molecular weight: {sum_atomic_weights_by_results_name(tokens)}\",\n)\nprint()\n\n# Version 3 - convert integers during parsing process\ninteger = pp.Word(digits).set_name(\"integer\")\ninteger.add_parse_action(lambda t: int(t[0]))\nelement_ref = pp.Group(element(\"symbol\") + pp.Opt(integer, default=1)(\"qty\"))\nformula = element_ref[...].set_name(\"chemical_formula\")\n\n\ndef sum_atomic_weights_by_results_name_with_converted_ints(element_list):\n    return sum(atomic_weight[elem.symbol] * int(elem.qty) for elem in element_list)\n\n\nformula.run_tests(\n    \"\"\"\\\n    H2O\n    C6H5OH\n    NaCl\n    \"\"\",\n    full_dump=False,\n    post_parse=lambda _, tokens:\n        f\"Molecular weight: {sum_atomic_weights_by_results_name_with_converted_ints(tokens)}\",\n)\nprint()\n\n# Version 4 - parse and convert integers as subscript digits\nsubscript_digits = \"\u2080\u2081\u2082\u2083\u2084\u2085\u2086\u2087\u2088\u2089\"\nsubscript_int_map = {e[1]: e[0] for e in enumerate(subscript_digits)}\n\n\ndef cvt_subscript_int(s):\n    ret = 0\n    for c in s[0]:\n        ret = ret * 10 + subscript_int_map[c]\n    return ret\n\n\nsubscript_int = pp.Word(subscript_digits).set_name(\"subscript\")\nsubscript_int.add_parse_action(cvt_subscript_int)\n\nelement_ref = pp.Group(element(\"symbol\") + pp.Opt(subscript_int, default=1)(\"qty\"))\nformula = element_ref[1, ...].set_name(\"chemical_formula\")\nformula.run_tests(\n    \"\"\"\\\n    H\u2082O\n    C\u2086H\u2085OH\n    NaCl\n    \"\"\",\n    full_dump=False,\n    post_parse=lambda _, tokens:\n        f\"Molecular weight: {sum_atomic_weights_by_results_name_with_converted_ints(tokens)}\",\n)\nprint()\n", "examples/pgn.py": "# pgn.py rel. 1.1 17-sep-2004\n#\n# Demonstration of the parsing module, implementing a pgn parser.\n#\n# The aim of this parser is not to support database application,\n# but to create automagically a pgn annotated reading the log console file\n# of a lecture of ICC (Internet Chess Club), saved by Blitzin.\n# Of course you can modify the Abstract Syntax Tree to your purpose.\n#\n# Copyright 2004, by Alberto Santini http://www.albertosantini.it/chess/\n#\nfrom pyparsing import alphanums, nums, quotedString\nfrom pyparsing import (\n    Combine,\n    Forward,\n    Group,\n    Literal,\n    one_of,\n    Opt,\n    Suppress,\n    Word,\n)\nfrom pyparsing import ParseException\n\n#\n# define pgn grammar\n#\n\ntag = Suppress(\"[\") + Word(alphanums) + quotedString + Suppress(\"]\")\ncomment = Suppress(\"{\") + Word(alphanums + \" \") + Suppress(\"}\")\n\ndot = Literal(\".\")\npiece = one_of(\"K Q B N R\")\nfile_coord = one_of(\"a b c d e f g h\")\nrank_coord = one_of(\"1 2 3 4 5 6 7 8\")\ncapture = one_of(\"x :\")\npromote = Literal(\"=\")\ncastle_queenside = one_of(\"O-O-O 0-0-0 o-o-o\")\ncastle_kingside = one_of(\"O-O 0-0 o-o\")\n\nmove_number = Opt(comment) + Word(nums) + dot\nm1 = file_coord + rank_coord  # pawn move e.g. d4\nm2 = file_coord + capture + file_coord + rank_coord  # pawn capture move e.g. dxe5\nm3 = file_coord + \"8\" + promote + piece  # pawn promotion e.g. e8=Q\nm4 = piece + file_coord + rank_coord  # piece move e.g. Be6\nm5 = piece + file_coord + file_coord + rank_coord  # piece move e.g. Nbd2\nm6 = piece + rank_coord + file_coord + rank_coord  # piece move e.g. R4a7\nm7 = piece + capture + file_coord + rank_coord  # piece capture move e.g. Bxh7\nm8 = castle_queenside | castle_kingside  # castling e.g. o-o\n\ncheck = one_of(\"+ ++\")\nmate = Literal(\"#\")\nannotation = Word(\"!?\", max=2)\nnag = \" $\" + Word(nums)\ndecoration = check | mate | annotation | nag\n\nvariant = Forward()\nhalf_move = (\n    Combine((m3 | m1 | m2 | m4 | m5 | m6 | m7 | m8) + Opt(decoration))\n    + Opt(comment)\n    + Opt(variant)\n)\nmove = Suppress(move_number) + half_move + Opt(half_move)\nvariant << \"(\" + move[1, ...] + \")\"\n# grouping the plies (half-moves) for each move: useful to group annotations, variants...\n# suggested by Paul McGuire :)\nmove = Group(Suppress(move_number) + half_move + Opt(half_move))\nvariant << Group(\"(\" + move[1, ...] + \")\")\ngame_terminator = one_of(\"1-0 0-1 1/2-1/2 *\")\n\npgnGrammar = (\n    Suppress(tag[...]) + move[...] + Opt(Suppress(game_terminator))\n)\n\n\ndef parsePGN(pgn, bnf=pgnGrammar, fn=None):\n    try:\n        return bnf.parse_string(pgn, parse_all=True)\n    except ParseException as err:\n        print(err.explain())\n\n\nif __name__ == \"__main__\":\n    # input string\n    pgn = \"\"\"\n[Event \"ICC 5 0 u\"]\n[Site \"Internet Chess Club\"]\n[Date \"2004.01.25\"]\n[Round \"-\"]\n[White \"guest920\"]\n[Black \"IceBox\"]\n[Result \"0-1\"]\n[ICCResult \"White checkmated\"]\n[BlackElo \"1498\"]\n[Opening \"French defense\"]\n[ECO \"C00\"]\n[NIC \"FR.01\"]\n[Time \"04:44:56\"]\n[TimeControl \"300+0\"]\n\n1. e4 e6 2. Nf3 d5 $2 3. exd5 (3. e5 g6 4. h4) exd5 4. Qe2+ Qe7 5. Qxe7+ Bxe7 6. d3 Nf6 7. Be3\nBg4 8. Nbd2 c5 9. h3 Be6 10. O-O-O Nc6 11. g4 Bd6 12. g5 Nd7 13. Rg1 d4 14.\ng6 fxg6 15. Bg5 Rf8 16. a3 Bd5 17. Re1+ Nde5 18. Nxe5 Nxe5 19. Bf4 Rf5 20.\nBxe5 Rxe5 21. Rg5 Rxe1# {Black wins} 0-1\n\"\"\"\n    # parse input string\n    tokens = parsePGN(pgn, pgnGrammar)\n    print(tokens.dump())\n", "examples/dictExample.py": "#\n# dictExample.py\n#\n#  Illustration of using pyparsing's Dict class to process tabular data\n#\n# Copyright (c) 2003, Paul McGuire\n#\nimport pyparsing as pp\n\ntestData = \"\"\"\n+-------+------+------+------+------+------+------+------+------+\n|       |  A1  |  B1  |  C1  |  D1  |  A2  |  B2  |  C2  |  D2  |\n+=======+======+======+======+======+======+======+======+======+\n| min   |   7  |  43  |   7  |  15  |  82  |  98  |   1  |  37  |\n| max   |  11  |  52  |  10  |  17  |  85  | 112  |   4  |  39  |\n| ave   |   9  |  47  |   8  |  16  |  84  | 106  |   3  |  38  |\n| sdev  |   1  |   3  |   1  |   1  |   1  |   3  |   1  |   1  |\n+-------+------+------+------+------+------+------+------+------+\n\"\"\"\n\n# define grammar for datatable\nheading = (\n    pp.Literal(\"+-------+------+------+------+------+------+------+------+------+\")\n    + \"|       |  A1  |  B1  |  C1  |  D1  |  A2  |  B2  |  C2  |  D2  |\"\n    + \"+=======+======+======+======+======+======+======+======+======+\"\n).suppress()\nvert = pp.Literal(\"|\").suppress()\nnumber = pp.Word(pp.nums)\nrowData = pp.Group(\n    vert + pp.Word(pp.alphas) + vert + pp.delimitedList(number, \"|\") + vert\n)\ntrailing = pp.Literal(\n    \"+-------+------+------+------+------+------+------+------+------+\"\n).suppress()\n\ndatatable = heading + pp.Dict(pp.ZeroOrMore(rowData)) + trailing\n\n# now parse data and print results\ndata = datatable.parseString(testData)\nprint(data)\n\n# shortcut for import pprint; pprint.pprint(data.asList())\ndata.pprint()\n\n# access all data keys\nprint(\"data keys=\", list(data.keys()))\n\n# use dict-style access to values\nprint(\"data['min']=\", data[\"min\"])\n\n# use attribute-style access to values (if key is a valid Python identifier)\nprint(\"data.max\", data.max)\n", "examples/make_diagram.py": "#\n# make_diagram.py\n#\n# Sample railroad diagrams of selected pyparsing examples.\n#\n# Copyright 2021, Paul McGuire\n\n# Uncomment the related import statement and rerun to construct railroad diagram\n\nfrom examples.delta_time import time_expression as imported_expr\n\n# from examples.sexpParser import sexp as imported_expr\n# from examples.ebnftest import ebnf_parser as imported_expr\n# from examples.jsonParser import jsonObject as imported_expr\n# from examples.lucene_grammar import expression as imported_expr\n# from examples.invRegex import parser; imported_expr = parser()\n# from examples.oc import program as imported_expr\n# from examples.mozillaCalendarParser import calendars as imported_expr\n# from examples.pgn import pgnGrammar as imported_expr\n# from examples.idlParse import CORBA_IDL_BNF; imported_expr = CORBA_IDL_BNF()\n# from examples.chemical_formulas import formula as imported_expr\n# from examples.roman_numerals import roman_numeral as imported_expr\n# from examples.protobuf_parser import parser as imported_expr\n# from examples.parsePythonValue import listItem as imported_expr\n# from examples.one_to_ninety_nine import one_to_99 as imported_expr\n# from examples.simpleSQL import simpleSQL as imported_expr\n# from examples.simpleBool import boolExpr as imported_expr\n# from examples.adventureEngine import Parser; imported_expr = Parser().bnf\n# from examples.lua_parser import lua_script as imported_expr\n\n\ngrammar = imported_expr\n\n# or define a custom grammar here\n# import pyparsing as pp\n# grammar = pp.Or([\"foo\", \"bar\"]) + pp.Word(pp.nums) + pp.pyparsing_common.uuid\n\ngrammar.create_diagram(output_html=\"output.html\", show_results_names=True)\n", "examples/bigquery_view_parser.py": "# bigquery_view_parser.py\n#\n# A parser to extract table names from BigQuery view definitions.\n# This is based on the `select_parser.py` sample in pyparsing:\n# https://github.com/pyparsing/pyparsing/blob/master/examples/select_parser.py\n#\n# Michael Smedberg\n#\nimport sys\nimport textwrap\n\nfrom pyparsing import ParserElement, Suppress, Forward, CaselessKeyword\nfrom pyparsing import MatchFirst, alphas, alphanums, Combine, Word\nfrom pyparsing import QuotedString, CharsNotIn, Optional, Group\nfrom pyparsing import oneOf, delimitedList, restOfLine, cStyleComment\nfrom pyparsing import infixNotation, opAssoc, Regex, nums\n\nsys.setrecursionlimit(3000)\n\nParserElement.enablePackrat()\n\n\nclass BigQueryViewParser:\n    \"\"\"Parser to extract table info from BigQuery view definitions\n\n    Based on the BNF and examples posted at\n    https://cloud.google.com/bigquery/docs/reference/legacy-sql\n    \"\"\"\n\n    _parser = None\n    _table_identifiers = set()\n    _with_aliases = set()\n\n    def get_table_names(self, sql_stmt):\n        table_identifiers, with_aliases = self._parse(sql_stmt)\n\n        # Table names and alias names might differ by case, but that's not\n        # relevant- aliases are not case sensitive\n        lower_aliases = BigQueryViewParser.lowercase_set_of_tuples(with_aliases)\n        tables = {\n            x\n            for x in table_identifiers\n            if not BigQueryViewParser.lowercase_of_tuple(x) in lower_aliases\n        }\n\n        # Table names ARE case sensitive as described at\n        # https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#case_sensitivity\n        return tables\n\n    def _parse(self, sql_stmt):\n        BigQueryViewParser._table_identifiers.clear()\n        BigQueryViewParser._with_aliases.clear()\n        BigQueryViewParser._get_parser().parseString(sql_stmt, parseAll=True)\n\n        return BigQueryViewParser._table_identifiers, BigQueryViewParser._with_aliases\n\n    @classmethod\n    def lowercase_of_tuple(cls, tuple_to_lowercase):\n        return tuple(x.lower() if x else None for x in tuple_to_lowercase)\n\n    @classmethod\n    def lowercase_set_of_tuples(cls, set_of_tuples):\n        return {BigQueryViewParser.lowercase_of_tuple(x) for x in set_of_tuples}\n\n    @classmethod\n    def _get_parser(cls):\n        if cls._parser is not None:\n            return cls._parser\n\n        ParserElement.enablePackrat()\n\n        LPAR, RPAR, COMMA, LBRACKET, RBRACKET, LT, GT = map(Suppress, \"(),[]<>\")\n        QUOT, APOS, ACC, DOT, SEMI = map(Suppress, \"\\\"'`.;\")\n        ungrouped_select_stmt = Forward().setName(\"select statement\")\n\n        QUOTED_QUOT = QuotedString('\"')\n        QUOTED_APOS = QuotedString(\"'\")\n        QUOTED_ACC = QuotedString(\"`\")\n        QUOTED_BRACKETS = QuotedString(\"[\", endQuoteChar=\"]\")\n\n        # fmt: off\n        # keywords\n        (\n            UNION, ALL, AND, INTERSECT, EXCEPT, COLLATE, ASC, DESC, ON, USING, NATURAL,\n            INNER, CROSS, LEFT, RIGHT, OUTER, FULL, JOIN, AS, INDEXED, NOT, SELECT,\n            DISTINCT, FROM, WHERE, GROUP, BY, HAVING, ORDER, BY, LIMIT, OFFSET, OR,\n            CAST, ISNULL, NOTNULL, NULL, IS, BETWEEN, ELSE, END, CASE, WHEN, THEN,\n            EXISTS, COLLATE, IN, LIKE, GLOB, REGEXP, MATCH, ESCAPE, CURRENT_TIME,\n            CURRENT_DATE, CURRENT_TIMESTAMP, WITH, EXTRACT, PARTITION, ROWS, RANGE,\n            UNBOUNDED, PRECEDING, CURRENT, ROW, FOLLOWING, OVER, INTERVAL, DATE_ADD,\n            DATE_SUB, ADDDATE, SUBDATE, REGEXP_EXTRACT, SPLIT, ORDINAL, FIRST_VALUE,\n            LAST_VALUE, NTH_VALUE, LEAD, LAG, PERCENTILE_CONT, PRECENTILE_DISC, RANK,\n            DENSE_RANK, PERCENT_RANK, CUME_DIST, NTILE, ROW_NUMBER, DATE, TIME, DATETIME,\n            TIMESTAMP, UNNEST, INT64, NUMERIC, FLOAT64, BOOL, BYTES, GEOGRAPHY, ARRAY,\n            STRUCT, SAFE_CAST, ANY_VALUE, ARRAY_AGG, ARRAY_CONCAT_AGG, AVG, BIT_AND,\n            BIT_OR, BIT_XOR, COUNT, COUNTIF, LOGICAL_AND, LOGICAL_OR, MAX, MIN,\n            STRING_AGG, SUM, CORR, COVAR_POP, COVAR_SAMP, STDDEV_POP, STDDEV_SAMP,\n            STDDEV, VAR_POP, VAR_SAMP, VARIANCE, TIMESTAMP_ADD, TIMESTAMP_SUB,\n            GENERATE_ARRAY, GENERATE_DATE_ARRAY, GENERATE_TIMESTAMP_ARRAY, FOR,\n            SYSTEM_TIME, OF, WINDOW, RESPECT, IGNORE, NULLS, IF, CONTAINS,\n        ) = map(\n            CaselessKeyword,\n            \"\"\"\n            UNION, ALL, AND, INTERSECT, EXCEPT, COLLATE, ASC, DESC, ON, USING, NATURAL,\n            INNER, CROSS, LEFT, RIGHT, OUTER, FULL, JOIN, AS, INDEXED, NOT, SELECT,\n            DISTINCT, FROM, WHERE, GROUP, BY, HAVING, ORDER, BY, LIMIT, OFFSET, OR,\n            CAST, ISNULL, NOTNULL, NULL, IS, BETWEEN, ELSE, END, CASE, WHEN, THEN,\n            EXISTS, COLLATE, IN, LIKE, GLOB, REGEXP, MATCH, ESCAPE, CURRENT_TIME,\n            CURRENT_DATE, CURRENT_TIMESTAMP, WITH, EXTRACT, PARTITION, ROWS, RANGE,\n            UNBOUNDED, PRECEDING, CURRENT, ROW, FOLLOWING, OVER, INTERVAL, DATE_ADD,\n            DATE_SUB, ADDDATE, SUBDATE, REGEXP_EXTRACT, SPLIT, ORDINAL, FIRST_VALUE,\n            LAST_VALUE, NTH_VALUE, LEAD, LAG, PERCENTILE_CONT, PRECENTILE_DISC, RANK,\n            DENSE_RANK, PERCENT_RANK, CUME_DIST, NTILE, ROW_NUMBER, DATE, TIME, DATETIME,\n            TIMESTAMP, UNNEST, INT64, NUMERIC, FLOAT64, BOOL, BYTES, GEOGRAPHY, ARRAY,\n            STRUCT, SAFE_CAST, ANY_VALUE, ARRAY_AGG, ARRAY_CONCAT_AGG, AVG, BIT_AND,\n            BIT_OR, BIT_XOR, COUNT, COUNTIF, LOGICAL_AND, LOGICAL_OR, MAX, MIN,\n            STRING_AGG, SUM, CORR, COVAR_POP, COVAR_SAMP, STDDEV_POP, STDDEV_SAMP,\n            STDDEV, VAR_POP, VAR_SAMP, VARIANCE, TIMESTAMP_ADD, TIMESTAMP_SUB,\n            GENERATE_ARRAY, GENERATE_DATE_ARRAY, GENERATE_TIMESTAMP_ARRAY, FOR,\n            SYSTEM_TIME, OF, WINDOW, RESPECT, IGNORE, NULLS, IF, CONTAINS,\n            \"\"\".replace(\",\", \"\").split(),\n        )\n\n        keyword_nonfunctions = MatchFirst(\n            (UNION, ALL, INTERSECT, EXCEPT, COLLATE, ASC, DESC, ON, USING,\n             NATURAL, INNER, CROSS, LEFT, RIGHT, OUTER, FULL, JOIN, AS, INDEXED,\n             NOT, SELECT, DISTINCT, FROM, WHERE, GROUP, BY, HAVING, ORDER, BY,\n             LIMIT, OFFSET, CAST, ISNULL, NOTNULL, NULL, IS, BETWEEN, ELSE, END,\n             CASE, WHEN, THEN, EXISTS, COLLATE, IN, LIKE, GLOB, REGEXP, MATCH,\n             STRUCT, WINDOW, SYSTEM_TIME, IF, FOR,\n             )\n        )\n\n        keyword = keyword_nonfunctions | MatchFirst(\n            (ESCAPE, CURRENT_TIME, CURRENT_DATE, CURRENT_TIMESTAMP, DATE_ADD,\n             DATE_SUB, ADDDATE, SUBDATE, INTERVAL, STRING_AGG, REGEXP_EXTRACT,\n             SPLIT, ORDINAL, UNNEST, SAFE_CAST, PARTITION, TIMESTAMP_ADD,\n             TIMESTAMP_SUB, ARRAY, GENERATE_ARRAY, GENERATE_DATE_ARRAY,\n             GENERATE_TIMESTAMP_ARRAY, SYSTEM_TIME, CONTAINS,\n             )\n        )\n\n        # fmt: on\n\n        identifier_word = Word(alphas + \"_@#\", alphanums + \"@$#_\")\n        identifier = ~keyword + identifier_word.copy()\n        collation_name = identifier.copy()\n        # NOTE: Column names can be keywords.  Doc says they cannot, but in practice it seems to work.\n        column_name = identifier_word.copy()\n        qualified_column_name = Combine(\n            column_name + (\".\" + column_name)[..., 6], adjacent=False\n        )\n        # NOTE: As with column names, column aliases can be keywords, e.g. functions like `current_time`.  Other\n        # keywords, e.g. `from` make parsing pretty difficult (e.g. \"SELECT a from from b\" is confusing.)\n        column_alias = ~keyword_nonfunctions + column_name.copy()\n        table_name = identifier.copy()\n        table_alias = identifier.copy()\n        index_name = identifier.copy()\n        function_name = identifier.copy()\n        parameter_name = identifier.copy()\n        # NOTE: The expression in a CASE statement can be an integer.  E.g. this is valid SQL:\n        # select CASE 1 WHEN 1 THEN -1 ELSE -2 END from test_table\n        unquoted_case_identifier = ~keyword + Word(alphanums + \"$_\")\n        quoted_case_identifier = QUOTED_QUOT | QUOTED_ACC\n        case_identifier = quoted_case_identifier | unquoted_case_identifier\n        case_expr = (\n            Optional(case_identifier + DOT)\n            + Optional(case_identifier + DOT)\n            + case_identifier\n        )\n\n        # expression\n        expr = Forward().setName(\"expression\")\n\n        integer = Regex(r\"[+-]?\\d+\")\n        numeric_literal = Regex(r\"[+-]?\\d*\\.?\\d+([eE][+-]?\\d+)?\")\n        string_literal = QUOTED_APOS | QUOTED_QUOT | QUOTED_ACC\n        regex_literal = \"r\" + string_literal\n        blob_literal = Regex(r\"[xX]'[0-9A-Fa-f]+'\")\n        date_or_time_literal = (DATE | TIME | DATETIME | TIMESTAMP) + string_literal\n        literal_value = (\n            numeric_literal\n            | string_literal\n            | regex_literal\n            | blob_literal\n            | date_or_time_literal\n            | NULL\n            | CURRENT_TIME + Optional(LPAR + Optional(string_literal) + RPAR)\n            | CURRENT_DATE + Optional(LPAR + Optional(string_literal) + RPAR)\n            | CURRENT_TIMESTAMP + Optional(LPAR + Optional(string_literal) + RPAR)\n        )\n        bind_parameter = Word(\"?\", nums) | Combine(oneOf(\": @ $\") + parameter_name)\n        type_name = oneOf(\n            \"\"\"TEXT REAL INTEGER BLOB NULL TIMESTAMP STRING DATE\n            INT64 NUMERIC FLOAT64 BOOL BYTES DATETIME GEOGRAPHY TIME ARRAY\n            STRUCT\"\"\",\n            caseless=True,\n        )\n        date_part = oneOf(\n            \"\"\"DAY DAY_HOUR DAY_MICROSECOND DAY_MINUTE DAY_SECOND\n            HOUR HOUR_MICROSECOND HOUR_MINUTE HOUR_SECOND MICROSECOND MINUTE\n            MINUTE_MICROSECOND MINUTE_SECOND MONTH QUARTER SECOND\n            SECOND_MICROSECOND WEEK YEAR YEAR_MONTH\"\"\",\n            caseless=True,\n            as_keyword=True,\n        )\n        datetime_operators = (\n            DATE_ADD | DATE_SUB | ADDDATE | SUBDATE | TIMESTAMP_ADD | TIMESTAMP_SUB\n        )\n\n        grouping_term = expr.copy()\n        ordering_term = Group(\n            expr(\"order_key\")\n            + Optional(COLLATE + collation_name(\"collate\"))\n            + Optional(ASC | DESC)(\"direction\")\n        )(\"ordering_term\")\n\n        function_arg = expr.copy()(\"function_arg\")\n        function_args = Optional(\n            \"*\"\n            | Optional(DISTINCT)\n            + delimitedList(function_arg)\n            + Optional((RESPECT | IGNORE) + NULLS)\n        )(\"function_args\")\n        function_call = (\n            (function_name | keyword)(\"function_name\")\n            + LPAR\n            + Group(function_args)(\"function_args_group\")\n            + RPAR\n        )\n\n        navigation_function_name = (\n            FIRST_VALUE\n            | LAST_VALUE\n            | NTH_VALUE\n            | LEAD\n            | LAG\n            | PERCENTILE_CONT\n            | PRECENTILE_DISC\n        )\n        aggregate_function_name = (\n            ANY_VALUE\n            | ARRAY_AGG\n            | ARRAY_CONCAT_AGG\n            | AVG\n            | BIT_AND\n            | BIT_OR\n            | BIT_XOR\n            | COUNT\n            | COUNTIF\n            | LOGICAL_AND\n            | LOGICAL_OR\n            | MAX\n            | MIN\n            | STRING_AGG\n            | SUM\n        )\n        statistical_aggregate_function_name = (\n            CORR\n            | COVAR_POP\n            | COVAR_SAMP\n            | STDDEV_POP\n            | STDDEV_SAMP\n            | STDDEV\n            | VAR_POP\n            | VAR_SAMP\n            | VARIANCE\n        )\n        numbering_function_name = (\n            RANK | DENSE_RANK | PERCENT_RANK | CUME_DIST | NTILE | ROW_NUMBER\n        )\n        analytic_function_name = (\n            navigation_function_name\n            | aggregate_function_name\n            | statistical_aggregate_function_name\n            | numbering_function_name\n        )(\"analytic_function_name\")\n        partition_expression_list = delimitedList(grouping_term)(\n            \"partition_expression_list\"\n        )\n        window_frame_boundary_start = (\n            UNBOUNDED + PRECEDING\n            | numeric_literal + (PRECEDING | FOLLOWING)\n            | CURRENT + ROW\n        )\n        window_frame_boundary_end = (\n            UNBOUNDED + FOLLOWING\n            | numeric_literal + (PRECEDING | FOLLOWING)\n            | CURRENT + ROW\n        )\n        window_frame_clause = (ROWS | RANGE) + (\n            ((UNBOUNDED + PRECEDING) | (numeric_literal + PRECEDING) | (CURRENT + ROW))\n            | (BETWEEN + window_frame_boundary_start + AND + window_frame_boundary_end)\n        )\n        window_name = identifier.copy()(\"window_name\")\n        window_specification = (\n            Optional(window_name)\n            + Optional(PARTITION + BY + partition_expression_list)\n            + Optional(ORDER + BY + delimitedList(ordering_term))\n            + Optional(window_frame_clause)(\"window_specification\")\n        )\n        analytic_function = (\n            analytic_function_name\n            + LPAR\n            + function_args\n            + RPAR\n            + OVER\n            + (window_name | LPAR + Optional(window_specification) + RPAR)\n        )(\"analytic_function\")\n\n        string_agg_term = (\n            STRING_AGG\n            + LPAR\n            + Optional(DISTINCT)\n            + expr\n            + Optional(COMMA + string_literal)\n            + Optional(\n                ORDER + BY + expr + Optional(ASC | DESC) + Optional(LIMIT + integer)\n            )\n            + RPAR\n        )(\"string_agg\")\n        array_literal = (\n            Optional(ARRAY + Optional(LT + delimitedList(type_name) + GT))\n            + LBRACKET\n            + delimitedList(expr)\n            + RBRACKET\n        )\n        interval = INTERVAL + expr + date_part\n        array_generator = (\n            GENERATE_ARRAY\n            + LPAR\n            + numeric_literal\n            + COMMA\n            + numeric_literal\n            + COMMA\n            + numeric_literal\n            + RPAR\n        )\n        date_array_generator = (\n            (GENERATE_DATE_ARRAY | GENERATE_TIMESTAMP_ARRAY)\n            + LPAR\n            + expr(\"start_date\")\n            + COMMA\n            + expr(\"end_date\")\n            + Optional(COMMA + interval)\n            + RPAR\n        )\n\n        explicit_struct = (\n            STRUCT\n            + Optional(LT + delimitedList(type_name) + GT)\n            + LPAR\n            + Optional(delimitedList(expr + Optional(AS + identifier)))\n            + RPAR\n        )\n\n        case_when = WHEN + expr.copy()(\"when\")\n        case_then = THEN + expr.copy()(\"then\")\n        case_clauses = Group((case_when + case_then)[...])\n        case_else = ELSE + expr.copy()(\"else\")\n        case_stmt = (\n            CASE\n            + Optional(case_expr.copy())\n            + case_clauses(\"case_clauses\")\n            + Optional(case_else)\n            + END\n        )(\"case\")\n\n        expr_term = (\n            (analytic_function)(\"analytic_function\")\n            | (CAST + LPAR + expr + AS + type_name + RPAR)(\"cast\")\n            | (SAFE_CAST + LPAR + expr + AS + type_name + RPAR)(\"safe_cast\")\n            | (Optional(EXISTS) + LPAR + ungrouped_select_stmt + RPAR)(\"subselect\")\n            | (literal_value)(\"literal\")\n            | (bind_parameter)(\"bind_parameter\")\n            | (EXTRACT + LPAR + expr + FROM + expr + RPAR)(\"extract\")\n            | case_stmt\n            | (datetime_operators + LPAR + expr + COMMA + interval + RPAR)(\n                \"date_operation\"\n            )\n            | string_agg_term(\"string_agg_term\")\n            | array_literal(\"array_literal\")\n            | array_generator(\"array_generator\")\n            | date_array_generator(\"date_array_generator\")\n            | explicit_struct(\"explicit_struct\")\n            | function_call(\"function_call\")\n            | qualified_column_name(\"column\")\n        ) + Optional(LBRACKET + (OFFSET | ORDINAL) + LPAR + expr + RPAR + RBRACKET)(\n            \"offset_ordinal\"\n        )\n\n        struct_term = LPAR + delimitedList(expr_term) + RPAR\n\n        UNARY, BINARY, TERNARY = 1, 2, 3\n        expr <<= infixNotation(\n            (expr_term | struct_term),\n            [\n                (oneOf(\"- + ~\") | NOT, UNARY, opAssoc.RIGHT),\n                (ISNULL | NOTNULL | NOT + NULL, UNARY, opAssoc.LEFT),\n                (\"||\", BINARY, opAssoc.LEFT),\n                (oneOf(\"* / %\"), BINARY, opAssoc.LEFT),\n                (oneOf(\"+ -\"), BINARY, opAssoc.LEFT),\n                (oneOf(\"<< >> & |\"), BINARY, opAssoc.LEFT),\n                (oneOf(\"= > < >= <= <> != !< !> ==\"), BINARY, opAssoc.LEFT),\n                (\n                    IS + Optional(NOT)\n                    | Optional(NOT) + IN\n                    | Optional(NOT) + LIKE\n                    | GLOB\n                    | MATCH\n                    | REGEXP\n                    | CONTAINS,\n                    BINARY,\n                    opAssoc.LEFT,\n                ),\n                ((BETWEEN, AND), TERNARY, opAssoc.LEFT),\n                (\n                    Optional(NOT)\n                    + IN\n                    + LPAR\n                    + Group(ungrouped_select_stmt | delimitedList(expr))\n                    + RPAR,\n                    UNARY,\n                    opAssoc.LEFT,\n                ),\n                (AND, BINARY, opAssoc.LEFT),\n                (OR, BINARY, opAssoc.LEFT),\n            ],\n        )\n        quoted_expr = (\n            expr | QUOT + expr + QUOT | APOS + expr + APOS | ACC + expr + ACC\n        )(\"quoted_expr\")\n\n        compound_operator = (\n            UNION + Optional(ALL | DISTINCT)\n            | INTERSECT + DISTINCT\n            | EXCEPT + DISTINCT\n            | INTERSECT\n            | EXCEPT\n        )(\"compound_operator\")\n\n        join_constraint = Group(\n            Optional(\n                ON + expr\n                | USING + LPAR + Group(delimitedList(qualified_column_name)) + RPAR\n            )\n        )(\"join_constraint\")\n\n        join_op = (\n            COMMA\n            | Group(\n                Optional(NATURAL)\n                + Optional(\n                    INNER\n                    | CROSS\n                    | LEFT + OUTER\n                    | LEFT\n                    | RIGHT + OUTER\n                    | RIGHT\n                    | FULL + OUTER\n                    | OUTER\n                    | FULL\n                )\n                + JOIN\n            )\n        )(\"join_op\")\n\n        join_source = Forward()\n\n        # We support three kinds of table identifiers.\n        #\n        # First, dot delimited info like project.dataset.table, where\n        # each component follows the rules described in the BigQuery\n        # docs, namely:\n        #  Contain letters (upper or lower case), numbers, and underscores\n        #\n        # Second, a dot delimited quoted string.  Since it's quoted, we'll be\n        # liberal w.r.t. what characters we allow.  E.g.:\n        #  `project.dataset.name-with-dashes`\n        #\n        # Third, a series of quoted strings, delimited by dots, e.g.:\n        #  `project`.`dataset`.`name-with-dashes`\n        #\n        # We also support combinations, like:\n        #  project.dataset.`name-with-dashes`\n        #  `project`.`dataset.name-with-dashes`\n\n        def record_table_identifier(t):\n            identifier_list = t.asList()\n            padded_list = [None] * (3 - len(identifier_list)) + identifier_list\n            cls._table_identifiers.add(tuple(padded_list))\n\n        standard_table_part = ~keyword + Word(alphanums + \"_\")\n        quoted_project_part = QUOTED_QUOT | QUOTED_APOS | QUOTED_ACC\n        quoted_table_part = (\n            QUOT + CharsNotIn('\".') + QUOT\n            | APOS + CharsNotIn(\"'.\") + APOS\n            | ACC + CharsNotIn(\"`.\") + ACC\n        )\n        quoted_table_parts_identifier = (\n            Optional(\n                (quoted_project_part(\"project\") | standard_table_part(\"project\")) + DOT\n            )\n            + Optional(\n                (quoted_table_part(\"dataset\") | standard_table_part(\"dataset\")) + DOT\n            )\n            + (quoted_table_part(\"table\") | standard_table_part(\"table\"))\n        ).setParseAction(record_table_identifier)\n\n        def record_quoted_table_identifier(t):\n            identifier_list = t[0].split(\".\")\n            *first, second, third = identifier_list\n            first = \".\".join(first) or None\n            identifier_list = [first, second, third]\n            padded_list = [None] * (3 - len(identifier_list)) + identifier_list\n            cls._table_identifiers.add(tuple(padded_list))\n\n        quotable_table_parts_identifier = (\n            QUOTED_QUOT | QUOTED_APOS | QUOTED_ACC | QUOTED_BRACKETS\n        ).setParseAction(record_quoted_table_identifier)\n\n        table_identifier = (\n            quoted_table_parts_identifier | quotable_table_parts_identifier\n        ).setName(\"table_identifier\")\n        single_source = (\n            (\n                table_identifier\n                + Optional(Optional(AS) + table_alias(\"table_alias*\"))\n                + Optional(FOR - SYSTEM_TIME + AS + OF + expr)\n                + Optional(INDEXED + BY + index_name(\"name\") | NOT + INDEXED)\n            )(\"index\")\n            | (LPAR + ungrouped_select_stmt + RPAR)\n            | (LPAR + join_source + RPAR)\n            | (UNNEST + LPAR + expr + RPAR)\n        ) + Optional(Optional(AS) + table_alias)\n\n        join_source <<= single_source + (join_op + single_source + join_constraint)[...]\n\n        over_partition = (PARTITION + BY + delimitedList(partition_expression_list))(\n            \"over_partition\"\n        )\n        over_order = ORDER + BY + delimitedList(ordering_term)\n        over_unsigned_value_specification = expr\n        over_window_frame_preceding = (\n            UNBOUNDED + PRECEDING\n            | over_unsigned_value_specification + PRECEDING\n            | CURRENT + ROW\n        )\n        over_window_frame_following = (\n            UNBOUNDED + FOLLOWING\n            | over_unsigned_value_specification + FOLLOWING\n            | CURRENT + ROW\n        )\n        over_window_frame_bound = (\n            over_window_frame_preceding | over_window_frame_following\n        )\n        over_window_frame_between = (\n            BETWEEN + over_window_frame_bound + AND + over_window_frame_bound\n        )\n        over_window_frame_extent = (\n            over_window_frame_preceding | over_window_frame_between\n        )\n        over_row_or_range = (ROWS | RANGE) + over_window_frame_extent\n        over = (\n            OVER\n            + LPAR\n            + Optional(over_partition)\n            + Optional(over_order)\n            + Optional(over_row_or_range)\n            + RPAR\n        )(\"over\")\n        if_term = IF - LPAR + expr + COMMA + expr + COMMA + expr + RPAR\n\n        result_column = Optional(table_name + \".\") + \"*\" + Optional(\n            EXCEPT + LPAR + delimitedList(column_name) + RPAR\n        ) | Group(quoted_expr + Optional(over))\n\n        window_select_clause = (\n            WINDOW + identifier + AS + LPAR + window_specification + RPAR\n        )\n\n        with_stmt = Forward().setName(\"with statement\")\n        ungrouped_select_no_with = (\n            SELECT\n            + Optional(DISTINCT | ALL)\n            + Group(\n                delimitedList(\n                    (~FROM + ~IF + result_column | if_term)\n                    + Optional(Optional(AS) + column_alias),\n                    allow_trailing_delim=True,\n                )\n            )(\"columns\")\n            + Optional(FROM + join_source(\"from*\"))\n            + Optional(WHERE + expr)\n            + Optional(\n                GROUP + BY + Group(delimitedList(grouping_term))(\"group_by_terms\")\n            )\n            + Optional(HAVING + expr(\"having_expr\"))\n            + Optional(\n                ORDER + BY + Group(delimitedList(ordering_term))(\"order_by_terms\")\n            )\n            + Optional(delimitedList(window_select_clause))\n        )\n        select_no_with = ungrouped_select_no_with | (\n            LPAR + ungrouped_select_no_with + RPAR\n        )\n        select_core = Optional(with_stmt) + select_no_with\n        grouped_select_core = select_core | (LPAR + select_core + RPAR)\n\n        ungrouped_select_stmt <<= (\n            grouped_select_core\n            + (compound_operator + grouped_select_core)[...]\n            + Optional(\n                LIMIT\n                + (Group(expr + OFFSET + expr) | Group(expr + COMMA + expr) | expr)(\n                    \"limit\"\n                )\n            )\n        )(\"select\")\n        select_stmt = (\n            ungrouped_select_stmt | (LPAR + ungrouped_select_stmt + RPAR)\n        ) + Optional(SEMI)\n\n        # define comment format, and ignore them\n        sql_comment = oneOf(\"-- #\") + restOfLine | cStyleComment\n        select_stmt.ignore(sql_comment)\n\n        def record_with_alias(t):\n            identifier_list = t.asList()\n            padded_list = [None] * (3 - len(identifier_list)) + identifier_list\n            cls._with_aliases.add(tuple(padded_list))\n\n        with_clause = Group(\n            identifier.setParseAction(record_with_alias)\n            + AS\n            + LPAR\n            + select_stmt\n            + RPAR\n        )\n        with_stmt <<= WITH + delimitedList(with_clause)\n        with_stmt.ignore(sql_comment)\n\n        cls._parser = select_stmt\n        return cls._parser\n\n    def test(self, sql_stmt, expected_tables, verbose=False):\n        def print_(*args):\n            if verbose:\n                print(*args)\n\n        print_(textwrap.dedent(sql_stmt.strip()))\n        found_tables = self.get_table_names(sql_stmt)\n        print_(found_tables)\n        expected_tables_set = set(expected_tables)\n\n        if expected_tables_set != found_tables:\n            raise Exception(\n                f\"Test {test_index} failed- expected {expected_tables_set} but got {found_tables}\"\n            )\n        print_()\n\n\nif __name__ == \"__main__\":\n    # fmt: off\n    TEST_CASES = [\n        [\n            \"\"\"\\\n            SELECT x FROM y.a, b\n            \"\"\",\n            [\n                (None, \"y\", \"a\"),\n                (None, None, \"b\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT x FROM y.a JOIN b\n            \"\"\",\n            [\n                (None, \"y\", \"a\"),\n                (None, None, \"b\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select * from xyzzy where z > 100\n            \"\"\",\n            [\n                (None, None, \"xyzzy\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select * from xyzzy where z > 100 order by zz\n            \"\"\",\n            [\n                (None, None, \"xyzzy\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select * from xyzzy\n            \"\"\",\n            [\n                (None, None, \"xyzzy\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select z.* from xyzzy\n            \"\"\",\n            [\n                (None, None, \"xyzzy\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, b from test_table where 1=1 and b='yes'\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, b from test_table where 1=1 and b in (select bb from foo)\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, None, \"foo\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select z.a, b from test_table where 1=1 and b in (select bb from foo)\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, None, \"foo\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select z.a, b from test_table where 1=1 and b in (select bb from foo) order by b,c desc,d\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, None, \"foo\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select z.a, b from test_table left join test2_table where 1=1 and b in (select bb from foo)\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, None, \"test2_table\"),\n                (None, None, \"foo\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, db.table.b as BBB from db.table where 1=1 and BBB='yes'\n            \"\"\",\n            [\n                (None, \"db\", \"table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, db.table.b as BBB from test_table,db.table where 1=1 and BBB='yes'\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, \"db\", \"table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, db.table.b as BBB from test_table,db.table where 1=1 and BBB='yes' limit 50\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n                (None, \"db\", \"table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select a, b from test_table where (1=1 or 2=3) and b='yes' group by zx having b=2 order by 1\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select\n                a,\n                b\n                # this is a comment\n            from\n                test_table\n                # another comment\n            where (1=1 or 2=3) and b='yes'\n            #yup, a comment\n            group by zx having b=2 order by 1\n            \"\"\",\n            [\n                (None, None, \"test_table\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT COUNT(DISTINCT foo) FROM bar JOIN baz ON bar.baz_id = baz.id\n            \"\"\",\n            [\n                (None, None, \"bar\"),\n                (None, None, \"baz\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT COUNT(DISTINCT foo) FROM bar, baz WHERE bar.baz_id = baz.id\n            \"\"\",\n            [\n                (None, None, \"bar\"),\n                (None, None, \"baz\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH one AS (SELECT id FROM foo) SELECT one.id\n            \"\"\",\n            [\n                (None, None, \"foo\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH one AS (SELECT id FROM foo), two AS (select id FROM bar) SELECT one.id, two.id\n            \"\"\",\n            [\n                (None, None, \"foo\"),\n                (None, None, \"bar\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT x,\n              RANK() OVER (ORDER BY x ASC) AS rank,\n              DENSE_RANK() OVER (ORDER BY x ASC) AS dense_rank,\n              ROW_NUMBER() OVER (PARTITION BY x ORDER BY y) AS row_num\n            FROM a\n            \"\"\",\n            [\n                (None, None, \"a\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT x, COUNT(*) OVER ( ORDER BY x\n              RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING ) AS count_x\n            FROM T\n            \"\"\",\n            [\n                (None, None, \"T\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT firstname, department, startdate,\n              RANK() OVER ( PARTITION BY department ORDER BY startdate ) AS rank\n            FROM Employees\n            \"\"\",\n            [\n                (None, None, \"Employees\"),\n            ],\n        ],\n        # A fragment from https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34'\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            WITH finishers AS\n             (SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n            SELECT name,\n              FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,\n              division,\n              FORMAT_TIMESTAMP('%X', fastest_time) AS fastest_time,\n              TIMESTAMP_DIFF(finish_time, fastest_time, SECOND) AS delta_in_seconds\n            FROM (\n              SELECT name,\n              finish_time,\n              division,\n              FIRST_VALUE(finish_time)\n                OVER (PARTITION BY division ORDER BY finish_time ASC\n                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS fastest_time\n              FROM finishers)\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n                WITH finishers AS\n                 (SELECT 'Sophia Liu' as name,\n                  TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n                  'F30-34' as division\n                  UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n                  UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n                  UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n                  UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n                  UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n                  UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n                  UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n                  UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n                  UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n                SELECT name,\n                  FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,\n                  division,\n                  FORMAT_TIMESTAMP('%X', slowest_time) AS slowest_time,\n                  TIMESTAMP_DIFF(slowest_time, finish_time, SECOND) AS delta_in_seconds\n                FROM (\n                  SELECT name,\n                  finish_time,\n                  division,\n                  LAST_VALUE(finish_time)\n                    OVER (PARTITION BY division ORDER BY finish_time ASC\n                    ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS slowest_time\n                  FROM finishers)\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            WITH finishers AS\n             (SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n            SELECT name,\n              FORMAT_TIMESTAMP('%X', finish_time) AS finish_time,\n              division,\n              FORMAT_TIMESTAMP('%X', fastest_time) AS fastest_time,\n              FORMAT_TIMESTAMP('%X', second_fastest) AS second_fastest\n            FROM (\n              SELECT name,\n              finish_time,\n              division,finishers,\n              FIRST_VALUE(finish_time)\n                OVER w1 AS fastest_time,\n              NTH_VALUE(finish_time, 2)\n                OVER w1 as second_fastest\n              FROM finishers\n              WINDOW w1 AS (\n                PARTITION BY division ORDER BY finish_time ASC\n                ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING))\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            WITH finishers AS\n             (SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n            SELECT name,\n              finish_time,\n              division,\n              LEAD(name)\n                OVER (PARTITION BY division ORDER BY finish_time ASC) AS followed_by\n            FROM finishers\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            WITH finishers AS\n             (SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n            SELECT name,\n              finish_time,\n              division,\n              LEAD(name, 2)\n                OVER (PARTITION BY division ORDER BY finish_time ASC) AS two_runners_back\n            FROM finishers\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            WITH finishers AS\n             (SELECT 'Sophia Liu' as name,\n              TIMESTAMP '2016-10-18 2:51:45' as finish_time,\n              'F30-34' as division\n              UNION ALL SELECT 'Lisa Stelzner', TIMESTAMP '2016-10-18 2:54:11', 'F35-39'\n              UNION ALL SELECT 'Nikki Leith', TIMESTAMP '2016-10-18 2:59:01', 'F30-34'\n              UNION ALL SELECT 'Lauren Matthews', TIMESTAMP '2016-10-18 3:01:17', 'F35-39'\n              UNION ALL SELECT 'Desiree Berry', TIMESTAMP '2016-10-18 3:05:42', 'F35-39'\n              UNION ALL SELECT 'Suzy Slane', TIMESTAMP '2016-10-18 3:06:24', 'F35-39'\n              UNION ALL SELECT 'Jen Edwards', TIMESTAMP '2016-10-18 3:06:36', 'F30-34'\n              UNION ALL SELECT 'Meghan Lederer', TIMESTAMP '2016-10-18 3:07:41', 'F30-34'\n              UNION ALL SELECT 'Carly Forte', TIMESTAMP '2016-10-18 3:08:58', 'F25-29'\n              UNION ALL SELECT 'Lauren Reasoner', TIMESTAMP '2016-10-18 3:10:14', 'F30-34')\n            SELECT name,\n              finish_time,\n              division,\n              LAG(name)\n                OVER (PARTITION BY division ORDER BY finish_time ASC) AS preceding_runner\n            FROM finishers\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            SELECT\n              PERCENTILE_CONT(x, 0) OVER() AS min,\n              PERCENTILE_CONT(x, 0.01) OVER() AS percentile1,\n              PERCENTILE_CONT(x, 0.5) OVER() AS median,\n              PERCENTILE_CONT(x, 0.9) OVER() AS percentile90,\n              PERCENTILE_CONT(x, 1) OVER() AS max\n            FROM UNNEST([0, 3, NULL, 1, 2]) AS x LIMIT 1\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/navigation_functions\n        [\n            \"\"\"\\\n            SELECT\n              x,\n              PERCENTILE_DISC(x, 0) OVER() AS min,\n              PERCENTILE_DISC(x, 0.5) OVER() AS median,\n              PERCENTILE_DISC(x, 1) OVER() AS max\n            FROM UNNEST(['c', NULL, 'b', 'a']) AS x\n            \"\"\",\n            [],\n        ],\n        # From https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions\n        [\n            \"\"\"\\\n            SELECT\n              TIMESTAMP \"2008-12-25 15:30:00 UTC\" as original,\n              TIMESTAMP_ADD(TIMESTAMP \"2008-12-25 15:30:00 UTC\", INTERVAL 10 MINUTE) AS later\n            \"\"\",\n            [],\n        ],\n        # Previously hosted on https://cloud.google.com/bigquery/docs/reference/standard-sql/timestamp_functions, but\n        # appears to no longer be there\n        [\n            \"\"\"\\\n            WITH date_hour_slots AS (\n             SELECT\n               [\n                    STRUCT(\n                        \" 00:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 01:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 02:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 03:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 04:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 05:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 06:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 07:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 08:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY ) as dt_range),\n                    STRUCT(\n                        \" 09:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01', current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 10:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 11:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 12:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 13:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 14:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 15:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 16:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 17:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 18:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 19:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 20:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 21:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 22:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range),\n                    STRUCT(\n                        \" 23:00:00 UTC\" as hrs,\n                        GENERATE_DATE_ARRAY('2016-01-01',current_date(), INTERVAL 1 DAY) as dt_range)\n                ]\n                AS full_timestamps)\n                SELECT\n              dt AS dates, hrs, CAST(CONCAT( CAST(dt as STRING), CAST(hrs as STRING)) as TIMESTAMP) as timestamp_value\n              FROM `date_hour_slots`, date_hour_slots.full_timestamps LEFT JOIN full_timestamps.dt_range as dt\n            \"\"\",\n            [\n                (None, \"date_hour_slots\", \"full_timestamps\"),\n                (None, \"full_timestamps\", \"dt_range\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                [foo],\n                ARRAY[foo],\n                ARRAY<int64, STRING>[foo, bar],\n                STRUCT(1, 3),\n                STRUCT<int64, STRING>(2, 'foo'),\n                current_date(),\n                GENERATE_ARRAY(5, NULL, 1),\n                GENERATE_DATE_ARRAY('2016-10-05', '2016-10-01', INTERVAL 1 DAY),\n                GENERATE_DATE_ARRAY('2016-10-05', NULL),\n                GENERATE_DATE_ARRAY('2016-01-01', '2016-12-31', INTERVAL 2 MONTH),\n                GENERATE_DATE_ARRAY('2000-02-01',current_date(), INTERVAL 1 DAY),\n                GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-05 00:00:02', INTERVAL 1 SECOND)\n            FROM\n                bar\n            \"\"\",\n            [\n                (None, None, \"bar\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT GENERATE_ARRAY(start, 5) AS example_array\n            FROM UNNEST([3, 4, 5]) AS start\n            \"\"\",\n            [],\n        ],\n        [\n            \"\"\"\\\n            WITH StartsAndEnds AS (\n              SELECT DATE '2016-01-01' AS date_start, DATE '2016-01-31' AS date_end\n              UNION ALL SELECT DATE \"2016-04-01\", DATE \"2016-04-30\"\n              UNION ALL SELECT DATE \"2016-07-01\", DATE \"2016-07-31\"\n              UNION ALL SELECT DATE \"2016-10-01\", DATE \"2016-10-31\"\n            )\n            SELECT GENERATE_DATE_ARRAY(date_start, date_end, INTERVAL 1 WEEK) AS date_range\n            FROM StartsAndEnds\n            \"\"\",\n            [],\n        ],\n        [\n            \"\"\"\\\n            SELECT GENERATE_TIMESTAMP_ARRAY(start_timestamp, end_timestamp, INTERVAL 1 HOUR)\n              AS timestamp_array\n            FROM\n              (SELECT\n                TIMESTAMP '2016-10-05 00:00:00' AS start_timestamp,\n                TIMESTAMP '2016-10-05 02:00:00' AS end_timestamp\n               UNION ALL\n               SELECT\n                TIMESTAMP '2016-10-05 12:00:00' AS start_timestamp,\n                TIMESTAMP '2016-10-05 14:00:00' AS end_timestamp\n               UNION ALL\n               SELECT\n                TIMESTAMP '2016-10-05 23:59:00' AS start_timestamp,\n                TIMESTAMP '2016-10-06 01:59:00' AS end_timestamp)\n            \"\"\",\n            [],\n        ],\n        [\n            \"\"\"\\\n            SELECT DATE_SUB(current_date(\"-08:00\"), INTERVAL 2 DAY)\n            \"\"\",\n            [],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                case when (a) then b else c end\n            FROM d\n            \"\"\",\n            [\n                (None, None, \"d\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                e,\n                case when (f) then g else h end\n            FROM i\n            \"\"\",\n            [\n                (None, None, \"i\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                case when j then k else l end\n            FROM m\n            \"\"\",\n            [\n                (None, None, \"m\",),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                n,\n                case when o then p else q end\n            FROM r\n            \"\"\",\n            [\n                (None, None, \"r\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                case s when (t) then u else v end\n            FROM w\n            \"\"\",\n            [\n                (None, None, \"w\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                x,\n                case y when (z) then aa else ab end\n            FROM ac\n            \"\"\",\n            [\n                (None, None, \"ac\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                case ad when ae then af else ag end\n            FROM ah\n            \"\"\",\n            [\n                (None, None, \"ah\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                ai,\n                case aj when ak then al else am end\n            FROM an\n            \"\"\",\n            [\n                (None, None, \"an\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH\n                ONE AS (SELECT x FROM y),\n                TWO AS (select a FROM b)\n            SELECT y FROM onE JOIN TWo\n            \"\"\",\n            [\n                (None, None, \"y\"),\n                (None, None, \"b\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n                a,\n                (SELECT b FROM oNE)\n            FROM OnE\n            \"\"\",\n            [\n                (None, None, \"oNE\"),\n                (None, None, \"OnE\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM `a.b.c`\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM `b.c`\n            \"\"\",\n            [\n                (None, \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM `c`\n            \"\"\",\n            [\n                (None, None, \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM a.b.c\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM \"a\".\"b\".\"c\"\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM 'a'.'b'.'c'\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM `a`.`b`.`c`\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM \"a.b.c\"\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM 'a.b.c'\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM `a.b.c`\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT t2.a\n                FROM t2 FOR SYSTEM_TIME AS OF t1.timestamp_column\n            \"\"\",\n            [\n                (None, None, \"t2\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT *\n            FROM t1\n            WHERE t1.a IN (SELECT t2.a\n                           FROM t2 FOR SYSTEM_TIME AS OF t1.timestamp_column)\n            \"\"\",\n            [\n                (None, None, \"t1\"),\n                (None, None, \"t2\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH a AS (SELECT b FROM c)\n            SELECT d FROM A JOIN e ON f = g JOIN E ON h = i\n            \"\"\",\n            [\n                (None, None, \"c\"),\n                (None, None, \"e\"),\n                (None, None, \"E\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            with\n            a as (\n                (\n                    select b from\n                    (\n                        select c from d\n                    )\n                    Union all\n                    (\n                        select e from f\n                    )\n                )\n            )\n\n            select g from h\n            \"\"\",\n            [\n                (None, None, \"d\"),\n                (None, None, \"f\"),\n                (None, None, \"h\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            select\n                a AS ESCAPE,\n                b AS CURRENT_TIME,\n                c AS CURRENT_DATE,\n                d AS CURRENT_TIMESTAMP,\n                e AS DATE_ADD\n            FROM x\n            \"\"\",\n            [\n                (None, None, \"x\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH x AS (\n                SELECT a\n                FROM b\n                WINDOW w as (PARTITION BY a)\n            )\n            SELECT y FROM z\n            \"\"\",\n            [\n                (None, None, \"b\"),\n                (None, None, \"z\")\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT DISTINCT\n                FIRST_VALUE(x IGNORE NULLS) OVER (PARTITION BY y)\n            FROM z\n            \"\"\",\n            [\n                (None, None, \"z\")\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT a . b .   c\n            FROM d\n            \"\"\",\n            [\n                (None, None, \"d\")\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH a AS (\n                SELECT b FROM c\n                UNION ALL\n                (\n                    WITH d AS (\n                        SELECT e FROM f\n                    )\n                    SELECT g FROM d\n                )\n            )\n            SELECT h FROM a\n            \"\"\",\n            [\n                (None, None, \"c\"),\n                (None, None, \"f\")\n            ],\n        ],\n        [\n            \"\"\"\\\n            WITH a AS (\n                SELECT b FROM c\n                UNION ALL\n                (\n                    WITH d AS (\n                        SELECT e FROM f\n                    )\n                    SELECT g FROM d\n                )\n            )\n            (SELECT h FROM a)\n            \"\"\",\n            [\n                (None, None, \"c\"),\n                (None, None, \"f\")\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM a.b.`c`\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT * FROM 'a'.b.`c`\n            \"\"\",\n            [\n                (\"a\", \"b\", \"c\"),\n            ],\n        ],\n        # from https://cloud.google.com/bigquery/docs/reference/legacy-sql\n        [\n            \"\"\"\\\n            SELECT\n                           word,\n                           word_count,\n                           RANK() OVER (PARTITION BY corpus ORDER BY word_count DESC) rank,\n                        FROM\n                           [bigquery-public-data:samples.shakespeare]\n                        WHERE\n                           corpus='othello' and length(word) > 10\n                        LIMIT 5\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'shakespeare'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n               word,\n               word_count,\n               RATIO_TO_REPORT(word_count) OVER (PARTITION BY corpus ORDER BY word_count DESC) r_to_r,\n            FROM\n               [bigquery-public-data:samples.shakespeare]\n            WHERE\n               corpus='othello' and length(word) > 10\n            LIMIT 5\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'shakespeare'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n               word,\n               word_count,\n               ROW_NUMBER() OVER (PARTITION BY corpus ORDER BY word_count DESC) row_num,\n            FROM\n               [bigquery-public-data:samples.shakespeare]\n            WHERE\n               corpus='othello' and length(word) > 10\n            LIMIT 5\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'shakespeare'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n              TO_BASE64(SHA1(title))\n            FROM\n              [bigquery-public-data:samples.wikipedia]\n            LIMIT\n              100;\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'wikipedia'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n              CASE\n                WHEN state IN ('WA', 'OR', 'CA', 'AK', 'HI', 'ID',\n                               'MT', 'WY', 'NV', 'UT', 'CO', 'AZ', 'NM')\n                  THEN 'West'\n                WHEN state IN ('OK', 'TX', 'AR', 'LA', 'TN', 'MS', 'AL',\n                               'KY', 'GA', 'FL', 'SC', 'NC', 'VA', 'WV',\n                               'MD', 'DC', 'DE')\n                  THEN 'South'\n                WHEN state IN ('ND', 'SD', 'NE', 'KS', 'MN', 'IA',\n                               'MO', 'WI', 'IL', 'IN', 'MI', 'OH')\n                  THEN 'Midwest'\n                WHEN state IN ('NY', 'PA', 'NJ', 'CT',\n                               'RI', 'MA', 'VT', 'NH', 'ME')\n                  THEN 'Northeast'\n                ELSE 'None'\n              END as region,\n              average_mother_age,\n              average_father_age,\n              state, year\n            FROM\n              (SELECT\n                 year, state,\n                 SUM(mother_age)/COUNT(mother_age) as average_mother_age,\n                 SUM(father_age)/COUNT(father_age) as average_father_age\n               FROM\n                 [bigquery-public-data:samples.natality]\n               WHERE\n                 father_age < 99\n               GROUP BY\n                 year, state)\n            ORDER BY\n              year\n            LIMIT 5;\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'natality'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n              /* Replace white spaces in the title with underscores. */\n              REGEXP_REPLACE(title, r'\\s+', '_') AS regexp_title, revisions\n            FROM\n              (SELECT title, COUNT(revision_id) as revisions\n              FROM\n                [bigquery-public-data:samples.wikipedia]\n              WHERE\n                wp_namespace=0\n                /* Match titles that start with 'G', end with\n                 * 'e', and contain at least two 'o's.\n                 */\n                AND REGEXP_MATCH(title, r'^G.*o.*o.*e$')\n              GROUP BY\n                title\n              ORDER BY\n                revisions DESC\n              LIMIT 100);\"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'wikipedia'),\n            ],\n        ],\n        [\n            \"\"\"\\\n            SELECT\n              page_title,\n              /* Populate these columns as True or False, */\n              /*  depending on the condition */\n              IF (page_title CONTAINS 'search',\n                  INTEGER(total), 0) AS search,\n              IF (page_title CONTAINS 'Earth' OR\n                  page_title CONTAINS 'Maps', INTEGER(total), 0) AS geo,\n            FROM\n              /* Subselect to return top revised Wikipedia articles */\n              /* containing 'Google', followed by additional text. */\n              (SELECT\n                TOP (title, 5) as page_title,\n                COUNT (*) as total\n               FROM\n                 [bigquery-public-data:samples.wikipedia]\n               WHERE\n                 REGEXP_MATCH (title, r'^Google.+') AND wp_namespace = 0\n              );\n              \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'wikipedia'),\n            ]\n        ],\n        [\n            \"\"\"\\\n            SELECT\n              title,\n              HASH(title) AS hash_value,\n              IF(ABS(HASH(title)) % 2 == 1, 'True', 'False')\n                AS included_in_sample\n            FROM\n              [bigquery-public-data:samples.wikipedia]\n            WHERE\n              wp_namespace = 0\n            LIMIT 5;\n            \"\"\",\n            [\n                (None, 'bigquery-public-data:samples', 'wikipedia'),\n            ]\n        ],\n        [\n            \"\"\"\\\n            with t as (select CASE when EXTRACT(dayofweek FROM CURRENT_DATETIME()) == 1 then \"S\" end) select * from t\n            \"\"\",\n            [],\n        ],\n    ]\n    # fmt: on\n\n    parser = BigQueryViewParser()\n    for test_index, test_case in enumerate(TEST_CASES):\n        sql, expected = test_case\n        parser.test(sql_stmt=sql, expected_tables=expected, verbose=True)\n", "examples/httpServerLogParser.py": "# httpServerLogParser.py\n#\n# Copyright (c) 2016, Paul McGuire\n#\n\"\"\"\nParser for HTTP server log output, of the form:\n\n195.146.134.15 - - [20/Jan/2003:08:55:36 -0800]\n\"GET /path/to/page.html HTTP/1.0\" 200 4649 \"http://www.somedomain.com/020602/page.html\"\n\"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n127.0.0.1 - u.surname@domain.com [12/Sep/2006:14:13:53 +0300]\n\"GET /skins/monobook/external.png HTTP/1.0\" 304 - \"http://wiki.mysite.com/skins/monobook/main.css\"\n\"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6\"\n\nYou can then break it up as follows:\nIP ADDRESS - -\nServer Date / Time [SPACE]\n\"GET /path/to/page\nHTTP/Type Request\"\nSuccess Code\nBytes Sent To Client\nReferer\nClient Software\n\"\"\"\n\nfrom pyparsing import (\n    alphas,\n    nums,\n    dblQuotedString,\n    Combine,\n    Word,\n    Group,\n    delimitedList,\n    Suppress,\n    removeQuotes,\n)\nimport string\n\n\ndef getCmdFields(s, l, t):\n    t[\"method\"], t[\"requestURI\"], t[\"protocolVersion\"] = t[0].strip('\"').split()\n\n\nlogLineBNF = None\n\n\ndef getLogLineBNF():\n    global logLineBNF\n\n    if logLineBNF is None:\n        integer = Word(nums)\n        ipAddress = delimitedList(integer, \".\", combine=True)\n\n        timeZoneOffset = Word(\"+-\", nums)\n        month = Word(string.ascii_uppercase, string.ascii_lowercase, exact=3)\n        serverDateTime = Group(\n            Suppress(\"[\")\n            + Combine(\n                integer\n                + \"/\"\n                + month\n                + \"/\"\n                + integer\n                + \":\"\n                + integer\n                + \":\"\n                + integer\n                + \":\"\n                + integer\n            )\n            + timeZoneOffset\n            + Suppress(\"]\")\n        )\n\n        logLineBNF = (\n            ipAddress.setResultsName(\"ipAddr\")\n            + Suppress(\"-\")\n            + (\"-\" | Word(alphas + nums + \"@._\")).setResultsName(\"auth\")\n            + serverDateTime.setResultsName(\"timestamp\")\n            + dblQuotedString.setResultsName(\"cmd\").setParseAction(getCmdFields)\n            + (integer | \"-\").setResultsName(\"statusCode\")\n            + (integer | \"-\").setResultsName(\"numBytesSent\")\n            + dblQuotedString.setResultsName(\"referrer\").setParseAction(removeQuotes)\n            + dblQuotedString.setResultsName(\"clientSfw\").setParseAction(removeQuotes)\n        )\n    return logLineBNF\n\n\ntestdata = \"\"\"\n195.146.134.15 - - [20/Jan/2003:08:55:36 -0800] \"GET /path/to/page.html HTTP/1.0\" 200 4649 \"http://www.somedomain.com/020602/page.html\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n111.111.111.11 - - [16/Feb/2004:04:09:49 -0800] \"GET /ads/redirectads/336x280redirect.htm HTTP/1.1\" 304 - \"http://www.foobarp.org/theme_detail.php?type=vs&cat=0&mid=27512\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)\"\n11.111.11.111 - - [16/Feb/2004:10:35:12 -0800] \"GET /ads/redirectads/468x60redirect.htm HTTP/1.1\" 200 541 \"http://11.11.111.11/adframe.php?n=ad1f311a&what=zone:56\" \"Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1) Opera 7.20  [ru\\\"]\"\n127.0.0.1 - u.surname@domain.com [12/Sep/2006:14:13:53 +0300] \"GET /skins/monobook/external.png HTTP/1.0\" 304 - \"http://wiki.mysite.com/skins/monobook/main.css\" \"Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.0.6) Gecko/20060728 Firefox/1.5.0.6\"\n\"\"\"\nfor line in testdata.split(\"\\n\"):\n    if not line:\n        continue\n    fields = getLogLineBNF().parseString(line)\n    print(fields.dump())\n    # ~ print repr(fields)\n    # ~ for k in fields.keys():\n    # ~ print \"fields.\" + k + \" =\", fields[k]\n    print()\n", "examples/unicode_denormalizer.py": "# unicode_denormalizer.py\n#\n# Demonstration of the pyparsing's transform_string() method, to\n# convert identifiers in Python source code to equivalent Unicode\n# characters. Python's compiler automatically normalizes Unicode\n# characters back to their ASCII equivalents, so that identifiers may\n# be rewritten using other Unicode characters, and normalize back to\n# the same identifier. For instance, Python treats \"print\" and \"\ud835\udd61\ud835\udcfb\u1d62\ud835\udcc3\ud835\ude01\"\n# and \"\ud835\udd95\ud835\udc93\ud835\uddc2\ud835\udc5b\u1d57\" all as the same identifier.\n#\n# The converter must take care to *only* transform identifiers -\n# Python keywords must always be represented in base ASCII form. To\n# skip over keywords, they are added to the parser/transformer, but\n# contain no transforming parse action.\n#\n# The converter also detects identifiers in placeholders within f-strings.\n#\n# Copyright 2022, by Paul McGuire\n#\nimport keyword\nimport random\nimport unicodedata\n\nimport pyparsing as pp\nppu = pp.pyparsing_unicode\n\n_\u00b7 = \"_\u00b7\"\nident_chars = (\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n    + \"0123456789\" + _\u00b7\n)\n\n# build map of each ASCII character to a string of\n# all the characters in the Basic Multilingual Plane\n# that NFKC normalizes back to that ASCII character\nident_char_map = {c: [] for c in ident_chars}\nfor ch in ppu.BMP.identbodychars:\n    normal = unicodedata.normalize(\"NFKC\", ch)\n    if normal in ident_char_map:\n        ident_char_map[normal].append(ch)\n\n# ligatures will also normalize back to ASCII\n# (doubled elements have higher chance of being chosen by random.choice)\nligature_map = {\n    'IJ': ('\u0132', '\u0132', 'IJ'),\n    'LJ': ('\u01c7', '\u01c7', 'LJ'),\n    'NJ': ('\u01ca', '\u01ca', 'NJ'),\n    'DZ': ('\u01f1', '\u01f1', 'DZ'),\n    'II': ('\u2161', '\u2161', 'II'),\n    'IV': ('\u2163', '\u2163', 'IV'),\n    'VI': ('\u2165', '\u2165', 'VI'),\n    'IX': ('\u2168', '\u2168', 'IX'),\n    'XI': ('\u216a', '\u216a', 'XI'),\n    'ffl': ('\ufb04', '\ufb04', '\ufb00l', 'f\ufb02', 'ffl'),\n    'ffi': ('\ufb03', '\ufb03', '\ufb00i', 'f\ufb01', 'ffi'),\n    'ff': ('\ufb00', '\ufb00', 'ff'),\n    'fi': ('\ufb01', '\ufb01', 'fi'),\n    'fl': ('\ufb02', '\ufb02', 'fl'),\n    'ij': ('\u0133', '\u0133', 'ij'),\n    'lj': ('\u01c9', '\u01c9', 'lj'),\n    'nj': ('\u01cc', '\u01cc', 'nj'),\n    'dz': ('\u01f3', '\u01f3', 'dz'),\n    'ii': ('\u2171', '\u2171', 'ii'),\n    'iv': ('\u2173', '\u2173', 'iv'),\n    'vi': ('\u2175', '\u2175', 'vi'),\n    'ix': ('\u2178', '\u2178', 'ix'),\n    'xi': ('\u217a', '\u217a', 'xi'),\n}\n\nligature_transformer = pp.one_of(ligature_map).add_parse_action(\n    lambda t: random.choice(ligature_map[t[0]])\n)\n\n\ndef make_mixed_font(t):\n    # extract leading character and remainder to process separately\n    t_first, t_rest = t[0][0], t[0][1:]\n\n    # a leading '_' must be written using the ASCII character '_'\n    ret = ['_' if t_first == '_'\n           else random.choice(ident_char_map.get(t_first, t_first))]\n    t_rest = ligature_transformer.transform_string(t_rest)\n    ret.extend(random.choice(ident_char_map.get(c, c)) for c in t_rest)\n    return ''.join(ret)\n\n\n# define a pyparsing expression to match any identifier; add a parse\n# action to convert to mixed Unicode characters\nidentifier = pp.pyparsing_common.identifier\nidentifier.add_parse_action(make_mixed_font)\n\n# match quoted strings (which may be f-strings)\npython_quoted_string = pp.Opt(pp.Char(\"fF\")(\"f_string_prefix\")) + (\n        pp.python_quoted_string\n)(\"quoted_string_body\")\n\n\ndef mix_fstring_expressions(t):\n    if not t.f_string_prefix:\n        return\n\n    # define an expression and transformer to handle embedded\n    # f-string field expressions\n    fstring_arg = pp.QuotedString(\"{\", end_quote_char=\"}\")\n    fstring_arg.add_parse_action(\n        lambda tt: \"{\" + transformer.transform_string(tt[0]) + \"}\"\n    )\n\n    return (\n        t.f_string_prefix\n        + fstring_arg.transform_string(t.quoted_string_body)\n    )\n\n# add parse action to transform identifiers in f-strings\npython_quoted_string.add_parse_action(mix_fstring_expressions)\n\n# match keywords separately from identifiers - keywords must be kept in their\n# original ASCII\nany_keyword = pp.one_of(\n    list(keyword.kwlist) + getattr(keyword, \"softkwlist\", []),\n    as_keyword=True\n)\n\n# quoted strings and keywords will be parsed, but left untransformed\ntransformer = python_quoted_string | any_keyword | identifier\n\n\ndef demo():\n    import textwrap\n    hello_source = textwrap.dedent(\"\"\"\n    def hello():\n        try:\n            hello_ = \"Hello\"\n            world_ = \"World\"\n            print(f\"{hello_}, {world_}!\")\n        except TypeError as exc:\n            print(\"failed: {}\".format(exc))\n    \n    if __name__ == \"__main__\":\n        hello()\n    \"\"\")\n\n    # use transformer to generate code with denormalized identifiers\n    transformed = transformer.transform_string(hello_source)\n    print(transformed)\n\n    # does it really work? compile the transformed code and run it!\n    code = compile(transformed, \"inline source\", mode=\"exec\")\n    exec(code)\n\n    if 1:\n        # pick some code from the stdlib\n        import unittest.util as lib_module\n        import inspect\n        source = inspect.getsource(lib_module)\n        transformed = transformer.transform_string(source)\n        print()\n        print(transformed)\n\nif __name__ == '__main__':\n    demo()\n", "examples/tag_emitter.py": "#\n# tag_emitter.py\n#\n# Example showing how to inject tags into the parsed results by adding\n# an Empty() with a parse action to return the desired added data.\n#\n# Copyright 2023, Paul McGuire\n#\nimport pyparsing as pp\n\n# define expressions to parse different forms of integer constants\n# add parse actions that will evaluate the integer correctly\nbinary_int = (\"0b\" + pp.Word(\"01\")).add_parse_action(lambda t: int(t[1], base=2))\nhex_int = (\"0x\" + pp.Word(pp.hexnums)).add_parse_action(lambda t: int(t[1], base=16))\ndec_int = pp.Word(pp.nums).add_parse_action(lambda t: int(t[0]))\n\n\n# define function to inject an expression that will add an extra tag in the\n# parsed output, to indicate what the original input format was\ndef emit_tag(s):\n    return pp.Empty().add_parse_action(pp.replace_with(s))\n\n\n# define a parser that includes the tag emitter for each integer format type\nint_parser = (binary_int(\"value\") + emit_tag(\"binary\")(\"original_format\")\n              | hex_int(\"value\") + emit_tag(\"hex\")(\"original_format\")\n              | dec_int(\"value\") + emit_tag(\"decimal\")(\"original_format\")\n              )\n\n# parse some integers\nint_parser.run_tests(\"\"\"\\\n    0b11011000001\n    0x6c1\n    1729\"\"\")\n", "examples/number_words.py": "# number_words.py\n#\n# Copyright 2020, Paul McGuire\n#\n# Parser/evaluator for expressions of numbers as written out in words:\n#  - one\n#  - seven\n#  - twelve\n#  - twenty six\n#  - forty-two\n#  - one hundred and seven\n#\n#\n#  BNF:\n\"\"\"\n    optional_and ::= [\"and\" | \"-\"]\n    optional_dash ::= [\"-\"]\n    units ::= one | two | three | ... | nine\n    teens ::= ten | teens_only\n    tens ::= twenty | thirty | ... | ninety\n    one_to_99 ::= units | teens | (tens [optional_dash units])\n    teens_only ::= eleven | twelve | ... | nineteen\n    hundreds ::= (units | teens_only | tens optional_dash units) \"hundred\"\n    thousands ::= one_to_99 \"thousand\"\n\n    # number from 1-999,999\n    number ::= [thousands [optional_and]] [hundreds[optional_and]] one_to_99\n               | [thousands [optional_and]] hundreds\n               | thousands\n\"\"\"\nimport pyparsing as pp\nfrom operator import mul\n\n\ndef define_numeric_word_range(\n    names: str, from_: int, to_: int = None, step: int = 1\n) -> pp.MatchFirst:\n    \"\"\"\n    Compose a MatchFirst of CaselessKeywords, given their names and values,\n    which when parsed, are converted to their value\n    \"\"\"\n\n    def define_numeric_word(nm: str, val: int):\n        return pp.CaselessKeyword(nm).add_parse_action(lambda: val)\n\n    names = names.split()\n    if to_ is None:\n        to_ = from_\n    values = range(from_, to_ + 1, step)\n    ret = pp.MatchFirst(\n        define_numeric_word(name, value) for name, value in zip(names, values)\n    )\n\n    if len(names) == 1:\n        ret.set_name(names[0])\n    else:\n        ret.set_name(f\"{names[0]}-{names[-1]}\")\n\n    return ret\n\n\ndef multiply(t):\n    \"\"\"\n    Parse action for hundreds and thousands.\n    \"\"\"\n    return mul(*t)\n\n\nopt_dash = pp.Opt(pp.Suppress(\"-\")).set_name(\"'-'\")\nopt_and = pp.Opt((pp.CaselessKeyword(\"and\") | \"-\").suppress()).set_name(\"'and/-'\")\n\nunits = define_numeric_word_range(\"one two three four five six seven eight nine\", 1, 9)\nteens_only = define_numeric_word_range(\n    \"eleven twelve thirteen fourteen fifteen sixteen seventeen eighteen nineteen\",\n    11,\n    19,\n)\nten = define_numeric_word_range(\"ten\", 10)\nteens = ten | teens_only\n\ntens = define_numeric_word_range(\n    \"twenty thirty forty fifty sixty seventy eighty ninety\", 20, 90, 10\n)\none_to_99 = (units | teens | (tens + pp.Opt(opt_dash + units))).set_name(\"1-99\")\none_to_99.add_parse_action(sum)\n\nhundred = define_numeric_word_range(\"hundred\", 100)\nthousand = define_numeric_word_range(\"thousand\", 1000)\n\nhundreds = (units | teens_only | (tens + opt_dash + units)) + hundred\nhundreds.set_name(\"100s\")\n\none_to_999 = (\n    (pp.Opt(hundreds + opt_and) + one_to_99 | hundreds).add_parse_action(sum)\n).set_name(\"1-999\")\n\nthousands = one_to_999 + thousand\nthousands.set_name(\"1000s\")\n\n# for hundreds and thousands, must scale up (multiply) accordingly\nhundreds.add_parse_action(multiply)\nthousands.add_parse_action(multiply)\n\nnumeric_expression = (\n    pp.Opt(thousands + opt_and) + pp.Opt(hundreds + opt_and) + one_to_99\n    | pp.Opt(thousands + opt_and) + hundreds\n    | thousands\n).set_name(\"numeric_words\")\n\n# sum all sub-results into total\nnumeric_expression.add_parse_action(sum)\n\n\nif __name__ == \"__main__\":\n    numeric_expression.run_tests(\n        \"\"\"\n        one\n        seven\n        twelve\n        twenty six\n        forty-two\n        two hundred\n        twelve hundred\n        one hundred and eleven\n        ninety nine thousand nine hundred and ninety nine\n        nine hundred thousand nine hundred and ninety nine\n        nine hundred and ninety nine thousand nine hundred and ninety nine\n        nineteen hundred thousand nineteen hundred and ninety nine\n        \n        # invalid\n        twenty hundred\n        \"\"\",\n        postParse=lambda _, s: \"{:,}\".format(s[0]),\n    )\n\n    # create railroad diagram\n    numeric_expression.create_diagram(\"numeric_words_diagram.html\", vertical=5)\n", "examples/parseTabularData.py": "#\n# parseTabularData.py\n#\n# Example of parsing data that is formatted in a tabular listing, with\n# potential for missing values. Uses new addCondition method on\n# ParserElements.\n#\n# Copyright 2015, Paul McGuire\n#\nfrom pyparsing import col, Word, Optional, alphas, nums\n\ntable = \"\"\"\\\n         1         2\n12345678901234567890\nCOLOR      S   M   L\nRED       10   2   2\nBLUE           5  10\nGREEN      3       5\nPURPLE     8\"\"\"\n\n# function to create column-specific parse conditions\ndef mustMatchCols(startloc, endloc):\n    return lambda s, l, t: startloc <= col(l, s) <= endloc\n\n\n# helper to define values in a space-delimited table\n# (change empty_cell_is_zero to True if a value of 0 is desired for empty cells)\ndef tableValue(expr, colstart, colend):\n    empty_cell_is_zero = False\n    if empty_cell_is_zero:\n        return Optional(\n            expr.copy().addCondition(\n                mustMatchCols(colstart, colend), message=\"text not in expected columns\"\n            ),\n            default=0,\n        )\n    else:\n        return Optional(\n            expr.copy().addCondition(\n                mustMatchCols(colstart, colend), message=\"text not in expected columns\"\n            )\n        )\n\n\n# define the grammar for this simple table\ncolorname = Word(alphas)\ninteger = Word(nums).setParseAction(lambda t: int(t[0])).setName(\"integer\")\nrow = (\n    colorname(\"name\")\n    + tableValue(integer, 11, 12)(\"S\")\n    + tableValue(integer, 15, 16)(\"M\")\n    + tableValue(integer, 19, 20)(\"L\")\n)\n\n# parse the sample text - skip over the header and counter lines\nfor line in table.splitlines()[3:]:\n    print(line)\n    print(row.parseString(line).dump())\n    print(\"\")\n", "examples/oc.py": "# oc.py\n#\n#   A subset-C parser, (BNF taken from 1996 International Obfuscated C Code Contest)\n#\n#   Copyright, 2010, Paul McGuire\n#\n\"\"\"\nhttps://www.ioccc.org/1996/august.hint\n\nThe following is a description of the OC grammar:\n\n    OC grammar\n    ==========\n    Terminals are in quotes, () is used for bracketing.\n\n    program:\tdecl*\n\n    decl:\t\tvardecl\n            fundecl\n\n    vardecl:\ttype NAME ;\n            type NAME \"[\" INT \"]\" ;\n\n    fundecl:\ttype NAME \"(\" args \")\" \"{\" body \"}\"\n\n    args:\t\t/*empty*/\n            ( arg \",\" )* arg\n\n    arg:\t\ttype NAME\n\n    body:\t\tvardecl* stmt*\n\n    stmt:\t\tifstmt\n            whilestmt\n            dowhilestmt\n            \"return\" expr \";\"\n            expr \";\"\n            \"{\" stmt* \"}\"\n            \";\"\n\n    ifstmt:\t\t\"if\" \"(\" expr \")\" stmt\n            \"if\" \"(\" expr \")\" stmt \"else\" stmt\n\n    whilestmt:\t\"while\" \"(\" expr \")\" stmt\n\n    dowhilestmt:\t\"do\" stmt \"while\" \"(\" expr \")\" \";\"\n\n    expr:\t\texpr binop expr\n            unop expr\n            expr \"[\" expr \"]\"\n            \"(\" expr \")\"\n            expr \"(\" exprs \")\"\n            NAME\n            INT\n            CHAR\n            STRING\n\n    exprs:\t\t/*empty*/\n            (expr \",\")* expr\n\n    binop:\t\t\"+\" | \"-\" | \"*\" | \"/\" | \"%\" |\n            \"=\" |\n            \"<\" | \"==\" | \"!=\"\n\n    unop:\t\t\"!\" | \"-\" | \"*\"\n\n    type:\t\t\"int\" stars\n            \"char\" stars\n\n    stars:\t\t\"*\"*\n\"\"\"\n\nfrom pyparsing import *\n\nParserElement.enablePackrat()\n\nLPAR, RPAR, LBRACK, RBRACK, LBRACE, RBRACE, SEMI, COMMA = map(Suppress, \"()[]{};,\")\nINT, CHAR, WHILE, DO, IF, ELSE, RETURN = map(\n    Keyword, \"int char while do if else return\".split()\n)\n\nNAME = Word(alphas + \"_\", alphanums + \"_\")\ninteger = Regex(r\"[+-]?\\d+\")\nchar = Regex(r\"'.'\")\nstring_ = dblQuotedString\n\nTYPE = Group((INT | CHAR) + ZeroOrMore(\"*\"))\nexpr = Forward()\nfunc_call = Group(NAME + LPAR + Group(Optional(delimitedList(expr))) + RPAR)\noperand = func_call | NAME | integer | char | string_\nexpr <<= infixNotation(\n    operand,\n    [\n        (oneOf(\"! - *\"), 1, opAssoc.RIGHT),\n        (oneOf(\"++ --\"), 1, opAssoc.RIGHT),\n        (oneOf(\"++ --\"), 1, opAssoc.LEFT),\n        (oneOf(\"* / %\"), 2, opAssoc.LEFT),\n        (oneOf(\"+ -\"), 2, opAssoc.LEFT),\n        (oneOf(\"< == > <= >= !=\"), 2, opAssoc.LEFT),\n        (Regex(r\"(?<!=)=(?!=)\"), 2, opAssoc.LEFT),\n    ],\n) + Optional(\n    LBRACK + expr + RBRACK | LPAR + Group(Optional(delimitedList(expr))) + RPAR\n)\n\nstmt = Forward()\n\nifstmt = IF - LPAR + expr + RPAR + stmt + Optional(ELSE + stmt)\nwhilestmt = WHILE - LPAR + expr + RPAR + stmt\ndowhilestmt = DO - stmt + WHILE + LPAR + expr + RPAR + SEMI\nreturnstmt = RETURN - expr + SEMI\n\nstmt << Group(\n    ifstmt\n    | whilestmt\n    | dowhilestmt\n    | returnstmt\n    | expr + SEMI\n    | LBRACE + ZeroOrMore(stmt) + RBRACE\n    | SEMI\n)\n\nvardecl = Group(TYPE + NAME + Optional(LBRACK + integer + RBRACK)) + SEMI\n\narg = Group(TYPE + NAME)\nbody = ZeroOrMore(vardecl) + ZeroOrMore(stmt)\nfundecl = Group(\n    TYPE\n    + NAME\n    + LPAR\n    + Optional(Group(delimitedList(arg)))\n    + RPAR\n    + LBRACE\n    + Group(body)\n    + RBRACE\n)\ndecl = fundecl | vardecl\nprogram = ZeroOrMore(decl)\n\nprogram.ignore(cStyleComment)\n\n# set parser element names\nfor vname in (\n    \"ifstmt whilestmt dowhilestmt returnstmt TYPE \"\n    \"NAME fundecl vardecl program arg body stmt\".split()\n):\n    v = vars()[vname]\n    v.setName(vname)\n\n# ~ for vname in \"fundecl stmt\".split():\n# ~ v = vars()[vname]\n# ~ v.setDebug()\n\n\ndef main():\n    test = r\"\"\"\n    /* A factorial program */\n    int\n    putstr(char *s)\n    {\n        while(*s)\n            putchar(*s++);\n    }\n    \n    int\n    fac(int n)\n    {\n        if (n == 0)\n            return 1;\n        else\n            return n*fac(n-1);\n    }\n    \n    int\n    putn(int n)\n    {\n        if (9 < n)\n            putn(n / 10);\n        putchar((n%10) + '0');\n    }\n    \n    int\n    facpr(int n)\n    {\n        putstr(\"factorial \");\n        putn(n);\n        putstr(\" = \");\n        putn(fac(n));\n        putstr(\"\\n\");\n    }\n    \n    int\n    main()\n    {\n        int i;\n        i = 0;\n        if(a() == 1){}\n        while(i < 10)\n            facpr(i++);\n        return 0;\n    }\n    \"\"\"\n\n    ast = program.parseString(test, parseAll=True)\n    ast.pprint()\n\n\nif __name__ == \"__main__\":\n    main()\n", "examples/eval_arith.py": "# eval_arith.py\n#\n# Copyright 2009, 2011 Paul McGuire\n#\n# Expansion on the pyparsing example simpleArith.py, to include evaluation\n# of the parsed tokens.\n#\n# Added support for exponentiation, using right-to-left evaluation of\n# operands\n#\nfrom pyparsing import (\n    Word,\n    nums,\n    alphas,\n    Combine,\n    one_of,\n    OpAssoc,\n    infix_notation,\n    Literal,\n    ParserElement,\n)\n\nParserElement.enablePackrat()\n\n\nclass EvalConstant:\n    \"Class to evaluate a parsed constant or variable\"\n    vars_ = {}\n\n    def __init__(self, tokens):\n        self.value = tokens[0]\n\n    def eval(self):\n        if self.value in EvalConstant.vars_:\n            return EvalConstant.vars_[self.value]\n        else:\n            return float(self.value)\n\n\nclass EvalSignOp:\n    \"Class to evaluate expressions with a leading + or - sign\"\n\n    def __init__(self, tokens):\n        self.sign, self.value = tokens[0]\n\n    def eval(self):\n        mult = {\"+\": 1, \"-\": -1}[self.sign]\n        return mult * self.value.eval()\n\n\ndef operatorOperands(tokenlist):\n    \"generator to extract operators and operands in pairs\"\n    it = iter(tokenlist)\n    while 1:\n        try:\n            yield (next(it), next(it))\n        except StopIteration:\n            break\n\n\nclass EvalPowerOp:\n    \"Class to evaluate power expressions\"\n\n    def __init__(self, tokens):\n        self.value = tokens[0]\n\n    def eval(self):\n        res = self.value[-1].eval()\n        for val in self.value[-3::-2]:\n            res = val.eval() ** res\n        return res\n\n\nclass EvalMultOp:\n    \"Class to evaluate multiplication and division expressions\"\n\n    def __init__(self, tokens):\n        self.value = tokens[0]\n\n    def eval(self):\n        prod = self.value[0].eval()\n        for op, val in operatorOperands(self.value[1:]):\n            if op == \"*\":\n                prod *= val.eval()\n            if op == \"/\":\n                prod /= val.eval()\n        return prod\n\n\nclass EvalAddOp:\n    \"Class to evaluate addition and subtraction expressions\"\n\n    def __init__(self, tokens):\n        self.value = tokens[0]\n\n    def eval(self):\n        sum = self.value[0].eval()\n        for op, val in operatorOperands(self.value[1:]):\n            if op == \"+\":\n                sum += val.eval()\n            if op == \"-\":\n                sum -= val.eval()\n        return sum\n\n\nclass EvalComparisonOp:\n    \"Class to evaluate comparison expressions\"\n    opMap = {\n        \"<\": lambda a, b: a < b,\n        \"<=\": lambda a, b: a <= b,\n        \">\": lambda a, b: a > b,\n        \">=\": lambda a, b: a >= b,\n        \"!=\": lambda a, b: a != b,\n        \"=\": lambda a, b: a == b,\n        \"LT\": lambda a, b: a < b,\n        \"LE\": lambda a, b: a <= b,\n        \"GT\": lambda a, b: a > b,\n        \"GE\": lambda a, b: a >= b,\n        \"NE\": lambda a, b: a != b,\n        \"EQ\": lambda a, b: a == b,\n        \"<>\": lambda a, b: a != b,\n    }\n\n    def __init__(self, tokens):\n        self.value = tokens[0]\n\n    def eval(self):\n        val1 = self.value[0].eval()\n        for op, val in operatorOperands(self.value[1:]):\n            fn = EvalComparisonOp.opMap[op]\n            val2 = val.eval()\n            if not fn(val1, val2):\n                break\n            val1 = val2\n        else:\n            return True\n        return False\n\n\n# define the parser\ninteger = Word(nums)\nreal = Combine(Word(nums) + \".\" + Word(nums))\nvariable = Word(alphas, exact=1)\noperand = real | integer | variable\n\nsignop = one_of(\"+ -\")\nmultop = one_of(\"* /\")\nplusop = one_of(\"+ -\")\nexpop = Literal(\"**\")\n\n# use parse actions to attach EvalXXX constructors to sub-expressions\noperand.setParseAction(EvalConstant)\narith_expr = infix_notation(\n    operand,\n    [\n        (signop, 1, OpAssoc.RIGHT, EvalSignOp),\n        (expop, 2, OpAssoc.LEFT, EvalPowerOp),\n        (multop, 2, OpAssoc.LEFT, EvalMultOp),\n        (plusop, 2, OpAssoc.LEFT, EvalAddOp),\n    ],\n)\n\ncomparisonop = one_of(\"< <= > >= != = <> LT GT LE GE EQ NE\")\ncomp_expr = infix_notation(\n    arith_expr,\n    [\n        (comparisonop, 2, OpAssoc.LEFT, EvalComparisonOp),\n    ],\n)\n\n\n# sample expressions posted on comp.lang.python, asking for advice\n# in safely evaluating them\nrules = [\n    \"( A - B ) = 0\",\n    \"( B - C + B ) = 0\",\n    \"(A + B + C + D + E + F + G + H + I) = J\",\n    \"(A + B + C + D + E + F + G + H) = I\",\n    \"(A + B + C + D + E + F) = G\",\n    \"(A + B + C + D + E) = (F + G + H + I + J)\",\n    \"(A + B + C + D + E) = (F + G + H + I)\",\n    \"(A + B + C + D + E) = F\",\n    \"(A + B + C + D) = (E + F + G + H)\",\n    \"(A + B + C) = D\",\n    \"(A + B + C) = (D + E + F)\",\n    \"(A + B) = (C + D + E + F)\",\n    \"(A + B) = (C + D)\",\n    \"(A + B) = (C - D + E - F - G + H + I + J)\",\n    \"(A + B) = C\",\n    \"(A + B) = 0\",\n    \"(A+B+C+D+E) = (F+G+H+I+J)\",\n    \"(A+B+C+D) = (E+F+G+H)\",\n    \"(A+B+C+D)=(E+F+G+H)\",\n    \"(A+B+C)=(D+E+F)\",\n    \"(A+B)=(C+D)\",\n    \"(A+B)=C\",\n    \"(A-B)=C\",\n    \"(A/(B+C))\",\n    \"(B/(C+D))\",\n    \"(G + H) = I\",\n    \"-0.99 LE ((A+B+C)-(D+E+F+G)) LE 0.99\",\n    \"-0.99 LE (A-(B+C)) LE 0.99\",\n    \"-1000.00 LE A LE 0.00\",\n    \"-5000.00 LE A LE 0.00\",\n    \"A < B\",\n    \"A < 7000\",\n    \"A = -(B)\",\n    \"A = C\",\n    \"A = 0\",\n    \"A GT 0\",\n    \"A GT 0.00\",\n    \"A GT 7.00\",\n    \"A LE B\",\n    \"A LT -1000.00\",\n    \"A LT -5000\",\n    \"A LT 0\",\n    \"G=(B+C+D)\",\n    \"A=B\",\n    \"I = (G + H)\",\n    \"0.00 LE A LE 4.00\",\n    \"4.00 LT A LE 7.00\",\n    \"0.00 LE A LE 4.00 LE E > D\",\n    \"2**2**(A+3)\",\n]\nvars_ = {\n    \"A\": 0,\n    \"B\": 1.1,\n    \"C\": 2.2,\n    \"D\": 3.3,\n    \"E\": 4.4,\n    \"F\": 5.5,\n    \"G\": 6.6,\n    \"H\": 7.7,\n    \"I\": 8.8,\n    \"J\": 9.9,\n}\n\n# define tests from given rules\ntests = []\nfor t in rules:\n    t_orig = t\n    t = t.replace(\"=\", \"==\")\n    t = t.replace(\"EQ\", \"==\")\n    t = t.replace(\"LE\", \"<=\")\n    t = t.replace(\"GT\", \">\")\n    t = t.replace(\"LT\", \"<\")\n    t = t.replace(\"GE\", \">=\")\n    t = t.replace(\"LE\", \"<=\")\n    t = t.replace(\"NE\", \"!=\")\n    t = t.replace(\"<>\", \"!=\")\n    tests.append((t_orig, eval(t, vars_)))\n\n# copy vars_ to EvalConstant lookup dict\nEvalConstant.vars_ = vars_\nfailed = 0\nfor test, expected in tests:\n    ret = comp_expr.parseString(test)[0]\n    parsedvalue = ret.eval()\n    print(test, expected, parsedvalue)\n    if abs(parsedvalue - expected) > 1e-6:\n        print(\"<<< FAIL\")\n        failed += 1\n    else:\n        print(\"\")\n\nprint(\"\")\nif failed:\n    raise Exception(\"could not parse\")\n", "examples/statemachine/statemachine.py": "# stateMachine.py\n#\n# module to define .pystate import handler\n#\n# import imputil\nimport keyword\nimport sys\nimport os\nimport types\nimport importlib\nimport importlib.machinery\nfrom urllib.parse import urlparse\n\n\nDEBUG = False\n\n\nimport pyparsing as pp\n\n# define basic exception for invalid state transitions - state machine classes will subclass to\n# define their own specific exception type\nclass InvalidTransitionException(Exception):\n    pass\n\n\nident = pp.Word(pp.alphas + \"_\", pp.alphanums + \"_$\")\n\n# add parse-time condition to make sure we do not allow any Python keywords to be used as\n# statemachine identifiers\ndef no_keywords_allowed(s, l, t):\n    wd = t[0]\n    return not keyword.iskeyword(wd)\n\n\nident.addCondition(\n    no_keywords_allowed,\n    message=\"cannot use a Python keyword for state or transition identifier\",\n)\n\nstateTransition = ident(\"from_state\") + \"->\" + ident(\"to_state\")\nstateMachine = (\n    pp.Keyword(\"statemachine\")\n    + ident(\"name\")\n    + \":\"\n    + pp.OneOrMore(pp.Group(stateTransition))(\"transitions\")\n)\n\nnamedStateTransition = (\n    ident(\"from_state\") + \"-(\" + ident(\"transition\") + \")->\" + ident(\"to_state\")\n)\nnamedStateMachine = (\n    pp.Keyword(\"statemachine\")\n    + ident(\"name\")\n    + \":\"\n    + pp.OneOrMore(pp.Group(namedStateTransition))(\"transitions\")\n)\n\n\ndef expand_state_definition(source, loc, tokens):\n    \"\"\"\n    Parse action to convert statemachine to corresponding Python classes and methods\n    \"\"\"\n    indent = \" \" * (pp.col(loc, source) - 1)\n    statedef = []\n\n    # build list of states\n    states = set()\n    fromTo = {}\n    for tn in tokens.transitions:\n        states.add(tn.from_state)\n        states.add(tn.to_state)\n        fromTo[tn.from_state] = tn.to_state\n\n    # define base class for state classes\n    baseStateClass = tokens.name\n    statedef.extend(\n        [\n            f\"class {baseStateClass}(object):\",\n            \"    def __str__(self):\",\n            \"        return self.__class__.__name__\",\n            \"    @classmethod\",\n            \"    def states(cls):\",\n            \"        return list(cls.__subclasses__())\",\n            \"    def next_state(self):\",\n            \"        return self._next_state_class()\",\n        ]\n    )\n\n    # define all state classes\n    statedef.extend(\"class {}({}): pass\".format(s, baseStateClass) for s in states)\n\n    # define state->state transitions\n    statedef.extend(\n        \"{}._next_state_class = {}\".format(s, fromTo[s]) for s in states if s in fromTo\n    )\n\n    statedef.extend(\n        [\n            \"class {baseStateClass}Mixin:\".format(baseStateClass=baseStateClass),\n            \"    def __init__(self):\",\n            \"        self._state = None\",\n            \"    def initialize_state(self, init_state):\",\n            \"        if issubclass(init_state, {baseStateClass}):\".format(\n                baseStateClass=baseStateClass\n            ),\n            \"            init_state = init_state()\",\n            \"        self._state = init_state\",\n            \"    @property\",\n            \"    def state(self):\",\n            \"        return self._state\",\n            \"    # get behavior/properties from current state\",\n            \"    def __getattr__(self, attrname):\",\n            \"        attr = getattr(self._state, attrname)\",\n            \"        return attr\",\n            \"    def __str__(self):\",\n            \"       return '{0}: {1}'.format(self.__class__.__name__, self._state)\",\n        ]\n    )\n\n    return (\"\\n\" + indent).join(statedef) + \"\\n\"\n\n\nstateMachine.setParseAction(expand_state_definition)\n\n\ndef expand_named_state_definition(source, loc, tokens):\n    \"\"\"\n    Parse action to convert statemachine with named transitions to corresponding Python\n    classes and methods\n    \"\"\"\n    indent = \" \" * (pp.col(loc, source) - 1)\n    statedef = []\n    # build list of states and transitions\n    states = set()\n    transitions = set()\n\n    baseStateClass = tokens.name\n\n    fromTo = {}\n    for tn in tokens.transitions:\n        states.add(tn.from_state)\n        states.add(tn.to_state)\n        transitions.add(tn.transition)\n        if tn.from_state in fromTo:\n            fromTo[tn.from_state][tn.transition] = tn.to_state\n        else:\n            fromTo[tn.from_state] = {tn.transition: tn.to_state}\n\n    # add entries for terminal states\n    for s in states:\n        if s not in fromTo:\n            fromTo[s] = {}\n\n    # define state transition class\n    statedef.extend(\n        [\n            \"class {baseStateClass}Transition:\".format(baseStateClass=baseStateClass),\n            \"    def __str__(self):\",\n            \"        return self.transitionName\",\n        ]\n    )\n    statedef.extend(\n        \"{tn_name} = {baseStateClass}Transition()\".format(\n            tn_name=tn, baseStateClass=baseStateClass\n        )\n        for tn in transitions\n    )\n    statedef.extend(\n        \"{tn_name}.transitionName = '{tn_name}'\".format(tn_name=tn)\n        for tn in transitions\n    )\n\n    # define base class for state classes\n    statedef.extend(\n        [\n            f\"class {baseStateClass}(object):\",\n            \"    from statemachine import InvalidTransitionException as BaseTransitionException\",\n            \"    class InvalidTransitionException(BaseTransitionException): pass\",\n            \"    def __str__(self):\",\n            \"        return self.__class__.__name__\",\n            \"    @classmethod\",\n            \"    def states(cls):\",\n            \"        return list(cls.__subclasses__())\",\n            \"    @classmethod\",\n            \"    def next_state(cls, name):\",\n            \"        try:\",\n            \"            return cls.tnmap[name]()\",\n            \"        except KeyError:\",\n            \"            raise cls.InvalidTransitionException(f'{cls.__name__} does not support transition {name!r}'\",\n            \"    def __bad_tn(name):\",\n            \"        def _fn(cls):\",\n            \"            raise cls.InvalidTransitionException(f'{cls.__name__} does not support transition {name!r}'\",\n            \"        _fn.__name__ = name\",\n            \"        return _fn\",\n        ]\n    )\n\n    # define default 'invalid transition' methods in base class, valid transitions will be implemented in subclasses\n    statedef.extend(\n        \"    {tn_name} = classmethod(__bad_tn({tn_name!r}))\".format(tn_name=tn)\n        for tn in transitions\n    )\n\n    # define all state classes\n    statedef.extend(\"class {}({}): pass\".format(s, baseStateClass) for s in states)\n\n    # define state transition methods for valid transitions from each state\n    for s in states:\n        trns = list(fromTo[s].items())\n        # statedef.append(f\"{s}.tnmap = {{{', '.join('%s:%s' % tn for tn in trns)}}}\")\n        statedef.extend(\n            f\"{s}.{tn_} = classmethod(lambda cls: {to_}())\"\n            for tn_, to_ in trns\n        )\n\n    statedef.extend(\n        [\n            \"{baseStateClass}.transitions = classmethod(lambda cls: [{transition_class_list}])\".format(\n                baseStateClass=baseStateClass,\n                transition_class_list=\", \".join(\n                    \"cls.{}\".format(tn) for tn in transitions\n                ),\n            ),\n            \"{baseStateClass}.transition_names = [tn.__name__ for tn in {baseStateClass}.transitions()]\".format(\n                baseStateClass=baseStateClass\n            ),\n        ]\n    )\n\n    # define <state>Mixin class for application classes that delegate to the state\n    statedef.extend(\n        [\n            \"class {baseStateClass}Mixin:\".format(baseStateClass=baseStateClass),\n            \"    def __init__(self):\",\n            \"        self._state = None\",\n            \"    def initialize_state(self, init_state):\",\n            \"        if issubclass(init_state, {baseStateClass}):\".format(\n                baseStateClass=baseStateClass\n            ),\n            \"            init_state = init_state()\",\n            \"        self._state = init_state\",\n            \"    @property\",\n            \"    def state(self):\",\n            \"        return self._state\",\n            \"    # get behavior/properties from current state\",\n            \"    def __getattr__(self, attrname):\",\n            \"        attr = getattr(self._state, attrname)\",\n            \"        return attr\",\n            \"    def __str__(self):\",\n            \"       return '{0}: {1}'.format(self.__class__.__name__, self._state)\",\n        ]\n    )\n\n    # define transition methods to be delegated to the _state instance variable\n    statedef.extend(\n        \"    def {tn_name}(self): self._state = self._state.{tn_name}()\".format(\n            tn_name=tn\n        )\n        for tn in transitions\n    )\n    return (\"\\n\" + indent).join(statedef) + \"\\n\"\n\n\nnamedStateMachine.setParseAction(expand_named_state_definition)\n\n\n# ======================================================================\n# NEW STUFF - Matt Anderson, 2009-11-26\n# ======================================================================\nclass SuffixImporter:\n    \"\"\"An importer designed using the mechanism defined in :pep:`302`. I read\n    the PEP, and also used Doug Hellmann's PyMOTW article `Modules and\n    Imports`_, as a pattern.\n\n    .. _`Modules and Imports`: http://www.doughellmann.com/PyMOTW/sys/imports.html\n\n    Define a subclass that specifies a :attr:`suffix` attribute, and\n    implements a :meth:`process_filedata` method. Then call the classmethod\n    :meth:`register` on your class to actually install it in the appropriate\n    places in :mod:`sys`.\"\"\"\n\n    scheme = \"suffix\"\n    suffix = None\n    path_entry = None\n\n    @classmethod\n    def trigger_url(cls):\n        if cls.suffix is None:\n            raise ValueError(f\"{cls.__name__}.suffix is not set\")\n        return f\"suffix:{cls.suffix}\"\n\n    @classmethod\n    def register(cls):\n        sys.path_hooks.append(cls)\n        sys.path.append(cls.trigger_url())\n\n    def __init__(self, path_entry):\n        pr = urlparse(str(path_entry))\n        if pr.scheme != self.scheme or pr.path != self.suffix:\n            raise ImportError()\n        self.path_entry = path_entry\n        self._found = {}\n\n    def checkpath_iter(self, fullname):\n        for dirpath in sys.path:\n            # if the value in sys.path_importer_cache is None, then this\n            # path *should* be imported by the builtin mechanism, and the\n            # entry is thus a path to a directory on the filesystem;\n            # if it's not None, then some other importer is in charge, and\n            # it probably isn't even a filesystem path\n            finder = sys.path_importer_cache.get(dirpath)\n            if isinstance(finder, (type(None), importlib.machinery.FileFinder)):\n                checkpath = os.path.join(dirpath, \"{}.{}\".format(fullname, self.suffix))\n                yield checkpath\n\n    def find_module(self, fullname, path=None):\n        for checkpath in self.checkpath_iter(fullname):\n            if os.path.isfile(checkpath):\n                self._found[fullname] = checkpath\n                return self\n        return None\n\n    def load_module(self, fullname):\n        assert fullname in self._found\n        if fullname in sys.modules:\n            module = sys.modules[fullname]\n        else:\n            sys.modules[fullname] = module = types.ModuleType(fullname)\n        data = None\n        with open(self._found[fullname]) as f:\n            data = f.read()\n\n        module.__dict__.clear()\n        module.__file__ = self._found[fullname]\n        module.__name__ = fullname\n        module.__loader__ = self\n        self.process_filedata(module, data)\n        return module\n\n    def process_filedata(self, module, data):\n        pass\n\n\nclass PystateImporter(SuffixImporter):\n    suffix = \"pystate\"\n\n    def process_filedata(self, module, data):\n        # MATT-NOTE: re-worked :func:`get_state_machine`\n\n        # convert any statemachine expressions\n        stateMachineExpr = (stateMachine | namedStateMachine).ignore(\n            pp.pythonStyleComment\n        )\n        generated_code = stateMachineExpr.transformString(data)\n\n        if DEBUG:\n            print(generated_code)\n\n        # compile code object from generated code\n        # (strip trailing spaces and tabs, compile doesn't like\n        # dangling whitespace)\n        COMPILE_MODE = \"exec\"\n\n        codeobj = compile(generated_code.rstrip(\" \\t\"), module.__file__, COMPILE_MODE)\n\n        exec(codeobj, module.__dict__)\n\n\nPystateImporter.register()\n\nif DEBUG:\n    print(\"registered {!r} importer\".format(PystateImporter.suffix))\n", "examples/statemachine/vending_machine.py": "#\n# vending_machine.py\n#\n# Example of using the statemachine parser without importing a .pystate module.\n#\n# A vending machine that dispenses candy and chips in a 4x4 grid, A1 thru D4.\n# To dispense a product, you must press an alpha button, then a digit button.\n#\n\nimport statemachine\n\n# Vending machine buttons:\n#    A, B, C, D\n#    1, 2, 3, 4\n#\nvending_machine_state_description = \"\"\"\\\nstatemachine VendingMachineState:\n    Idle-(press_alpha_button)->WaitingOnDigit\n    WaitingOnDigit-(press_alpha_button)->WaitingOnDigit\n    WaitingOnDigit-(press_digit_button)->DispenseProduct\n    DispenseProduct-(dispense)->Idle\n\"\"\"\n\n# convert state machine text to state classes\ngenerated = statemachine.namedStateMachine.transformString(\n    vending_machine_state_description\n)\n# print(generated)\n# exec generated code to define state classes and state mixin\nexec(generated)\n\n\nclass VendingMachine(VendingMachineStateMixin):\n    def __init__(self):\n        self.initialize_state(Idle)\n        self._pressed = None\n        self._alpha_pressed = None\n        self._digit_pressed = None\n\n    def press_button(self, button):\n        if button in \"ABCD\":\n            self._pressed = button\n            self.press_alpha_button()\n        elif button in \"1234\":\n            self._pressed = button\n            self.press_digit_button()\n        else:\n            print(\"Did not recognize button {!r}\".format(str(button)))\n\n    def press_alpha_button(self):\n        try:\n            super().press_alpha_button()\n        except VendingMachineState.InvalidTransitionException as ite:\n            print(ite)\n        else:\n            self._alpha_pressed = self._pressed\n\n    def press_digit_button(self):\n        try:\n            super().press_digit_button()\n        except VendingMachineState.InvalidTransitionException as ite:\n            print(ite)\n        else:\n            self._digit_pressed = self._pressed\n            self.dispense()\n\n    def dispense(self):\n        try:\n            super().dispense()\n        except VendingMachineState.InvalidTransitionException as ite:\n            print(ite)\n        else:\n            print(\"Dispensing at {}{}\".format(self._alpha_pressed, self._digit_pressed))\n            self._alpha_pressed = self._digit_pressed = None\n\n\nvm = VendingMachine()\nfor button in \"1 A B 1\".split():\n    print(\">> pressing {!r}\".format(button))\n    vm.press_button(button)\n    print(\"Vending machine is now in {} state\".format(vm.state))\n", "examples/statemachine/documentSignoffDemo.py": "#\n# documentSignoffDemo.py\n#\n# Example of a state machine modeling the state of a document in a document\n# control system, using named state transitions\n#\nimport statemachine\nimport documentsignoffstate\n\nprint(\n    \"\\n\".join(\n        t.__name__ for t in documentsignoffstate.DocumentRevisionState.transitions()\n    )\n)\n\n\nclass Document(documentsignoffstate.DocumentRevisionStateMixin):\n    def __init__(self):\n        self.initialize_state(documentsignoffstate.New)\n\n\ndef run_demo():\n    import random\n\n    doc = Document()\n    print(doc)\n\n    # begin editing document\n    doc.create()\n    print(doc)\n    print(doc.state.description)\n\n    while not isinstance(doc._state, documentsignoffstate.Approved):\n\n        print(\"...submit\")\n        doc.submit()\n        print(doc)\n        print(doc.state.description)\n\n        if random.randint(1, 10) > 3:\n            print(\"...reject\")\n            doc.reject()\n        else:\n            print(\"...approve\")\n            doc.approve()\n\n        print(doc)\n        print(doc.state.description)\n\n    doc.activate()\n    print(doc)\n    print(doc.state.description)\n\n\nif __name__ == \"__main__\":\n    run_demo()\n", "examples/statemachine/libraryBookDemo.py": "#\n# libraryBookDemo.py\n#\n# Simple statemachine demo, based on the state transitions given in librarybookstate.pystate\n#\n\nimport statemachine\nimport librarybookstate\n\n\nclass Book(librarybookstate.BookStateMixin):\n    def __init__(self):\n        self.initialize_state(librarybookstate.New)\n\n\nclass RestrictedBook(Book):\n    def __init__(self):\n        super().__init__()\n        self._authorized_users = []\n\n    def authorize(self, name):\n        self._authorized_users.append(name)\n\n    # specialized checkout to check permission of user first\n    def checkout(self, user=None):\n        if user in self._authorized_users:\n            super().checkout()\n        else:\n            raise Exception(\n                \"{} could not check out restricted book\".format(\n                    user if user is not None else \"anonymous\"\n                )\n            )\n\n\ndef run_demo():\n    book = Book()\n    book.shelve()\n    print(book)\n    book.checkout()\n    print(book)\n    book.checkin()\n    print(book)\n    book.reserve()\n    print(book)\n    try:\n        book.checkout()\n    except librarybookstate.BookState.InvalidTransitionException as e:\n        print(e)\n        print(\"..cannot check out reserved book\")\n    book.release()\n    print(book)\n    book.checkout()\n    print(book)\n    print()\n\n    restricted_book = RestrictedBook()\n    restricted_book.authorize(\"BOB\")\n    restricted_book.restrict()\n    print(restricted_book)\n    for name in [None, \"BILL\", \"BOB\"]:\n        try:\n            restricted_book.checkout(name)\n        except Exception as e:\n            print(\"..\" + str(e))\n        else:\n            print(\"checkout to\", name)\n    print(restricted_book)\n    restricted_book.checkin()\n    print(restricted_book)\n\n\nif __name__ == \"__main__\":\n    run_demo()\n", "examples/statemachine/video_demo.py": "#\n# video_demo.py\n#\n# Simple statemachine demo, based on the state transitions given in videostate.pystate\n#\n\nimport statemachine\nimport videostate\n\n\nclass Video(videostate.VideoStateMixin):\n    def __init__(self, title):\n        self.initialize_state(videostate.Stopped)\n        self.title = title\n\n\n# ==== main loop - a REPL ====\n\nv = Video(\"Die Hard.mp4\")\n\nwhile True:\n    print(v.state)\n    cmd = (\n        input(\"Command ({})> \".format(\"/\".join(videostate.VideoState.transition_names)))\n        .lower()\n        .strip()\n    )\n    if not cmd:\n        continue\n\n    if cmd in (\"?\", \"h\", \"help\"):\n        print(\"enter a transition {!r}\".format(videostate.VideoState.transition_names))\n        print(\" q - quit\")\n        print(\" ?, h, help - this message\")\n        continue\n\n    # quitting out\n    if cmd.startswith(\"q\"):\n        break\n\n    # get transition function for given command\n    state_transition_fn = getattr(v, cmd, None)\n\n    if state_transition_fn is None:\n        print(\"???\")\n        continue\n\n    # invoke the input transition, handle invalid commands\n    try:\n        state_transition_fn()\n    except videostate.VideoState.InvalidTransitionException as e:\n        print(e)\n", "examples/statemachine/trafficLightDemo.py": "#\n# trafficLightDemo.py\n#\n# Example of a simple state machine modeling the state of a traffic light\n#\n\nimport statemachine\nimport trafficlightstate\n\n\nclass TrafficLight(trafficlightstate.TrafficLightStateMixin):\n    def __init__(self):\n        self.initialize_state(trafficlightstate.Red)\n\n    def change(self):\n        self._state = self._state.next_state()\n\n\nlight = TrafficLight()\nfor i in range(10):\n    print(\"{} {}\".format(light, (\"STOP\", \"GO\")[light.cars_can_go]))\n    light.crossing_signal()\n    light.delay()\n    print()\n\n    light.change()\n"}