{"generate_self_schema.py": "\"\"\"\nThis script generates the schema for the schema - e.g.\na definition of what inputs can be provided to `SchemaValidator()`.\n\nThe schema is generated from `python/pydantic_core/core_schema.py`.\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport decimal\nimport importlib.util\nimport re\nimport sys\nfrom collections.abc import Callable\nfrom datetime import date, datetime, time, timedelta\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Dict, ForwardRef, List, Pattern, Set, Type, Union\n\nfrom typing_extensions import TypedDict, get_args, get_origin, is_typeddict\n\nTypingUnionType = Type[Union[str, int]]\n\ntry:\n    from types import UnionType as TypesUnionType\n\n    UnionType = Union[TypingUnionType, TypesUnionType]\n\nexcept ImportError:\n    TypesUnionType = TypingUnionType\n    UnionType = TypingUnionType\n\n\nTHIS_DIR = Path(__file__).parent\nSAVE_PATH = THIS_DIR / 'src' / 'self_schema.py'\n\nif TYPE_CHECKING:\n    from pydantic_core import core_schema\nelse:\n    # can't import core_schema.py directly as pydantic-core might not be installed\n    core_schema_spec = importlib.util.spec_from_file_location(\n        '_typing', str(THIS_DIR / 'python' / 'pydantic_core' / 'core_schema.py')\n    )\n    core_schema = importlib.util.module_from_spec(core_schema_spec)\n    core_schema_spec.loader.exec_module(core_schema)\n\n# the validator for referencing schema (Schema is used recursively, so has to use a reference)\nschema_ref_validator = {'type': 'definition-ref', 'schema_ref': 'root-schema'}\n\n\ndef get_schema(obj: Any, definitions: dict[str, core_schema.CoreSchema]) -> core_schema.CoreSchema:  # noqa: C901\n    if isinstance(obj, str):\n        return {'type': obj}\n    elif obj in (datetime, timedelta, date, time, bool, int, float, str, decimal.Decimal):\n        return {'type': obj.__name__.lower()}\n    elif is_typeddict(obj):\n        return type_dict_schema(obj, definitions)\n    elif obj == Any or obj == type:\n        return {'type': 'any'}\n    if isinstance(obj, type) and issubclass(obj, core_schema.Protocol):\n        return {'type': 'callable'}\n\n    origin = get_origin(obj)\n    assert origin is not None, f'origin cannot be None, obj={obj}, you probably need to fix generate_self_schema.py'\n    if origin is Union or origin is TypesUnionType:\n        return union_schema(obj, definitions)\n    elif obj is Callable or origin is Callable:\n        return {'type': 'callable'}\n    elif origin is core_schema.Literal:\n        expected = all_literal_values(obj)\n        assert expected, f'literal \"expected\" cannot be empty, obj={obj}'\n        return {'type': 'literal', 'expected': expected}\n    elif issubclass(origin, List):\n        return {'type': 'list', 'items_schema': get_schema(obj.__args__[0], definitions)}\n    elif issubclass(origin, Set):\n        return {'type': 'set', 'items_schema': get_schema(obj.__args__[0], definitions)}\n    elif issubclass(origin, Dict):\n        return {\n            'type': 'dict',\n            'keys_schema': get_schema(obj.__args__[0], definitions),\n            'values_schema': get_schema(obj.__args__[1], definitions),\n        }\n    elif issubclass(origin, Type):\n        # can't really use 'is-instance' since this is used for the class_ parameter of 'is-instance' validators\n        return {'type': 'any'}\n    elif origin in (Pattern, re.Pattern):\n        # can't really use 'is-instance' easily with Pattern, so we use `any` as a placeholder for now\n        return {'type': 'any'}\n    else:\n        # debug(obj)\n        raise TypeError(f'Unknown type: {obj!r}')\n\n\ndef tagged_union(std_union_schema: Dict[str, Any], discriminator_key: str, ref: str | None = None) -> Dict[str, Any]:\n    \"\"\"\n    Build a tagged union schema from a standard union schema.\n    \"\"\"\n    tagged_choices = {}\n    for choice in std_union_schema['choices']:\n        literal = choice['fields'][discriminator_key]['schema']['expected']\n        assert isinstance(literal, list), 'literal expected must be a list'\n        assert all(isinstance(arg, str) for arg in literal), 'literal expected must be a list of strings'\n        first, *rest = literal\n        tagged_choices[first] = choice\n        for arg in rest:\n            tagged_choices[arg] = choice\n    s = {'type': 'tagged-union', 'discriminator': discriminator_key, 'choices': tagged_choices}\n    if ref is not None:\n        s['ref'] = ref\n    return s\n\n\ndefined_ser_schema = False\n\n\ndef type_dict_schema(  # noqa: C901\n    typed_dict: type[TypedDict], definitions: dict[str, core_schema.CoreSchema]\n) -> dict[str, Any]:\n    global defined_ser_schema\n\n    required_keys = getattr(typed_dict, '__required_keys__', set())\n    fields = {}\n\n    for field_name, field_type in typed_dict.__annotations__.items():\n        required = field_name in required_keys\n        schema = None\n        fr_arg = None\n        if type(field_type) == ForwardRef:\n            fr_arg = field_type.__forward_arg__\n\n            fr_arg, matched = re.subn(r'Required\\[(.+)]', r'\\1', fr_arg)\n            if matched:\n                required = True\n\n            if 'CoreSchema' == fr_arg or re.search('[^a-zA-Z]CoreSchema', fr_arg):\n                if fr_arg == 'CoreSchema':\n                    schema = schema_ref_validator\n                elif fr_arg == 'List[CoreSchema]':\n                    schema = {'type': 'list', 'items_schema': schema_ref_validator}\n                elif fr_arg == 'Dict[str, CoreSchema]':\n                    schema = {'type': 'dict', 'keys_schema': {'type': 'str'}, 'values_schema': schema_ref_validator}\n                elif fr_arg == 'Dict[Hashable, CoreSchema]':\n                    schema = {'type': 'dict', 'keys_schema': {'type': 'any'}, 'values_schema': schema_ref_validator}\n                elif fr_arg == 'List[Union[CoreSchema, Tuple[CoreSchema, str]]]':\n                    schema = {\n                        'type': 'list',\n                        'items_schema': {\n                            'type': 'union',\n                            'choices': [\n                                schema_ref_validator,\n                                {'type': 'tuple', 'items_schema': [schema_ref_validator, {'type': 'str'}]},\n                            ],\n                        },\n                    }\n                else:\n                    raise ValueError(f'Unknown Schema forward ref: {fr_arg}')\n            else:\n                field_type = eval_forward_ref(field_type)\n\n        if schema is None:\n            if get_origin(field_type) == core_schema.Required:\n                required = True\n                field_type = field_type.__args__[0]\n\n            schema = get_schema(field_type, definitions)\n            if fr_arg == 'SerSchema':\n                if defined_ser_schema:\n                    schema = {'type': 'definition-ref', 'schema_ref': 'ser-schema'}\n                else:\n                    defined_ser_schema = True\n                    definitions['ser-schema'] = tagged_union(schema, 'type', 'ser-schema')\n                    schema = {'type': 'definition-ref', 'schema_ref': 'ser-schema'}\n            elif fr_arg.endswith('SerSchema'):\n                schema = tagged_union(schema, 'type')\n\n        # now_utc_offset is an int that must be in the range -24 hours to +24 hours, we manually add a constraint here\n        if field_name == 'now_utc_offset':\n            schema.update(gt=-86_400, lt=86_400)\n        fields[field_name] = {'schema': schema, 'required': required}\n\n    return {'type': 'typed-dict', 'fields': fields, 'extra_behavior': 'forbid'}\n\n\ndef union_schema(union_type: UnionType, definitions) -> core_schema.UnionSchema | core_schema.DefinitionReferenceSchema:\n    return {'type': 'union', 'choices': [get_schema(arg, definitions) for arg in union_type.__args__]}\n\n\ndef all_literal_values(type_: type[core_schema.Literal]) -> list[any]:\n    if get_origin(type_) is core_schema.Literal:\n        values = get_args(type_)\n        return [x for value in values for x in all_literal_values(value)]\n    else:\n        return [type_]\n\n\ndef eval_forward_ref(type_: Any) -> Any:\n    if sys.version_info < (3, 9):\n        return type_._evaluate(core_schema.__dict__, None)\n    elif sys.version_info < (3, 12, 4):\n        return type_._evaluate(core_schema.__dict__, None, recursive_guard=set())\n    else:\n        return type_._evaluate(core_schema.__dict__, None, type_params=set(), recursive_guard=set())\n\n\ndef main() -> None:\n    schema_union = core_schema.CoreSchema\n    assert get_origin(schema_union) is Union, 'expected core_schema.CoreSchema to be a Union'\n\n    definitions: dict[str, core_schema.CoreSchema] = {}\n\n    choices = {}\n    for s in schema_union.__args__:\n        type_ = s.__annotations__['type']\n        m = re.search(r\"Literal\\['(.+?)']\", type_.__forward_arg__)\n        assert m, f'Unknown schema type: {type_}'\n        key = m.group(1)\n        value = get_schema(s, definitions)\n        choices[key] = value\n\n    schema = core_schema.definitions_schema(\n        schema=core_schema.definition_reference_schema(schema_ref='root-schema'),\n        definitions=[\n            core_schema.tagged_union_schema(choices, discriminator='type', ref='root-schema'),\n            *definitions.values(),\n        ],\n    )\n    python_code = (\n        f'# this file is auto-generated by generate_self_schema.py, DO NOT edit manually\\nself_schema = {schema}\\n'\n    )\n    try:\n        from black import Mode, TargetVersion, format_file_contents\n    except ImportError:\n        pass\n    else:\n        mode = Mode(\n            line_length=120,\n            string_normalization=False,\n            magic_trailing_comma=False,\n            target_versions={TargetVersion.PY37, TargetVersion.PY38, TargetVersion.PY39, TargetVersion.PY310},\n        )\n        python_code = format_file_contents(python_code, fast=False, mode=mode)\n    SAVE_PATH.write_text(python_code)\n    print(f'Self schema definition written to {SAVE_PATH}')\n\n\nif __name__ == '__main__':\n    main()\n", "python/pydantic_core/core_schema.py": "\"\"\"\nThis module contains definitions to build schemas which `pydantic_core` can\nvalidate and serialize.\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport sys\nimport warnings\nfrom collections.abc import Mapping\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, Hashable, List, Pattern, Set, Tuple, Type, Union\n\nfrom typing_extensions import deprecated\n\nif sys.version_info < (3, 12):\n    from typing_extensions import TypedDict\nelse:\n    from typing import TypedDict\n\nif sys.version_info < (3, 11):\n    from typing_extensions import Protocol, Required, TypeAlias\nelse:\n    from typing import Protocol, Required, TypeAlias\n\nif sys.version_info < (3, 9):\n    from typing_extensions import Literal\nelse:\n    from typing import Literal\n\nif TYPE_CHECKING:\n    from pydantic_core import PydanticUndefined\nelse:\n    # The initial build of pydantic_core requires PydanticUndefined to generate\n    # the core schema; so we need to conditionally skip it. mypy doesn't like\n    # this at all, hence the TYPE_CHECKING branch above.\n    try:\n        from pydantic_core import PydanticUndefined\n    except ImportError:\n        PydanticUndefined = object()\n\n\nExtraBehavior = Literal['allow', 'forbid', 'ignore']\n\n\nclass CoreConfig(TypedDict, total=False):\n    \"\"\"\n    Base class for schema configuration options.\n\n    Attributes:\n        title: The name of the configuration.\n        strict: Whether the configuration should strictly adhere to specified rules.\n        extra_fields_behavior: The behavior for handling extra fields.\n        typed_dict_total: Whether the TypedDict should be considered total. Default is `True`.\n        from_attributes: Whether to use attributes for models, dataclasses, and tagged union keys.\n        loc_by_alias: Whether to use the used alias (or first alias for \"field required\" errors) instead of\n            `field_names` to construct error `loc`s. Default is `True`.\n        revalidate_instances: Whether instances of models and dataclasses should re-validate. Default is 'never'.\n        validate_default: Whether to validate default values during validation. Default is `False`.\n        populate_by_name: Whether an aliased field may be populated by its name as given by the model attribute,\n            as well as the alias. (Replaces 'allow_population_by_field_name' in Pydantic v1.) Default is `False`.\n        str_max_length: The maximum length for string fields.\n        str_min_length: The minimum length for string fields.\n        str_strip_whitespace: Whether to strip whitespace from string fields.\n        str_to_lower: Whether to convert string fields to lowercase.\n        str_to_upper: Whether to convert string fields to uppercase.\n        allow_inf_nan: Whether to allow infinity and NaN values for float fields. Default is `True`.\n        ser_json_timedelta: The serialization option for `timedelta` values. Default is 'iso8601'.\n        ser_json_bytes: The serialization option for `bytes` values. Default is 'utf8'.\n        ser_json_inf_nan: The serialization option for infinity and NaN values\n            in float fields. Default is 'null'.\n        hide_input_in_errors: Whether to hide input data from `ValidationError` representation.\n        validation_error_cause: Whether to add user-python excs to the __cause__ of a ValidationError.\n            Requires exceptiongroup backport pre Python 3.11.\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n        regex_engine: The regex engine to use for regex pattern validation. Default is 'rust-regex'. See `StringSchema`.\n        cache_strings: Whether to cache strings. Default is `True`, `True` or `'all'` is required to cache strings\n            during general validation since validators don't know if they're in a key or a value.\n    \"\"\"\n\n    title: str\n    strict: bool\n    # settings related to typed dicts, model fields, dataclass fields\n    extra_fields_behavior: ExtraBehavior\n    typed_dict_total: bool  # default: True\n    # used for models, dataclasses, and tagged union keys\n    from_attributes: bool\n    # whether to use the used alias (or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default True\n    loc_by_alias: bool\n    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    # used on typed-dicts and arguments\n    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1\n    # fields related to string fields only\n    str_max_length: int\n    str_min_length: int\n    str_strip_whitespace: bool\n    str_to_lower: bool\n    str_to_upper: bool\n    # fields related to float fields only\n    allow_inf_nan: bool  # default: True\n    # the config options are used to customise serialization to JSON\n    ser_json_timedelta: Literal['iso8601', 'float']  # default: 'iso8601'\n    ser_json_bytes: Literal['utf8', 'base64', 'hex']  # default: 'utf8'\n    ser_json_inf_nan: Literal['null', 'constants', 'strings']  # default: 'null'\n    # used to hide input data from ValidationError repr\n    hide_input_in_errors: bool\n    validation_error_cause: bool  # default: False\n    coerce_numbers_to_str: bool  # default: False\n    regex_engine: Literal['rust-regex', 'python-re']  # default: 'rust-regex'\n    cache_strings: Union[bool, Literal['all', 'keys', 'none']]  # default: 'True'\n\n\nIncExCall: TypeAlias = 'set[int | str] | dict[int | str, IncExCall] | None'\n\n\nclass SerializationInfo(Protocol):\n    @property\n    def include(self) -> IncExCall: ...\n\n    @property\n    def exclude(self) -> IncExCall: ...\n\n    @property\n    def context(self) -> Any | None:\n        \"\"\"Current serialization context.\"\"\"\n\n    @property\n    def mode(self) -> str: ...\n\n    @property\n    def by_alias(self) -> bool: ...\n\n    @property\n    def exclude_unset(self) -> bool: ...\n\n    @property\n    def exclude_defaults(self) -> bool: ...\n\n    @property\n    def exclude_none(self) -> bool: ...\n\n    @property\n    def serialize_as_any(self) -> bool: ...\n\n    def round_trip(self) -> bool: ...\n\n    def mode_is_json(self) -> bool: ...\n\n    def __str__(self) -> str: ...\n\n    def __repr__(self) -> str: ...\n\n\nclass FieldSerializationInfo(SerializationInfo, Protocol):\n    @property\n    def field_name(self) -> str: ...\n\n\nclass ValidationInfo(Protocol):\n    \"\"\"\n    Argument passed to validation functions.\n    \"\"\"\n\n    @property\n    def context(self) -> Any | None:\n        \"\"\"Current validation context.\"\"\"\n        ...\n\n    @property\n    def config(self) -> CoreConfig | None:\n        \"\"\"The CoreConfig that applies to this validation.\"\"\"\n        ...\n\n    @property\n    def mode(self) -> Literal['python', 'json']:\n        \"\"\"The type of input data we are currently validating\"\"\"\n        ...\n\n    @property\n    def data(self) -> Dict[str, Any]:\n        \"\"\"The data being validated for this model.\"\"\"\n        ...\n\n    @property\n    def field_name(self) -> str | None:\n        \"\"\"\n        The name of the current field being validated if this validator is\n        attached to a model field.\n        \"\"\"\n        ...\n\n\nExpectedSerializationTypes = Literal[\n    'none',\n    'int',\n    'bool',\n    'float',\n    'str',\n    'bytes',\n    'bytearray',\n    'list',\n    'tuple',\n    'set',\n    'frozenset',\n    'generator',\n    'dict',\n    'datetime',\n    'date',\n    'time',\n    'timedelta',\n    'url',\n    'multi-host-url',\n    'json',\n    'uuid',\n]\n\n\nclass SimpleSerSchema(TypedDict, total=False):\n    type: Required[ExpectedSerializationTypes]\n\n\ndef simple_ser_schema(type: ExpectedSerializationTypes) -> SimpleSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a custom type.\n\n    Args:\n        type: The type to use for serialization\n    \"\"\"\n    return SimpleSerSchema(type=type)\n\n\n# (input_value: Any, /) -> Any\nGeneralPlainNoInfoSerializerFunction = Callable[[Any], Any]\n# (input_value: Any, info: FieldSerializationInfo, /) -> Any\nGeneralPlainInfoSerializerFunction = Callable[[Any, SerializationInfo], Any]\n# (model: Any, input_value: Any, /) -> Any\nFieldPlainNoInfoSerializerFunction = Callable[[Any, Any], Any]\n# (model: Any, input_value: Any, info: FieldSerializationInfo, /) -> Any\nFieldPlainInfoSerializerFunction = Callable[[Any, Any, FieldSerializationInfo], Any]\nSerializerFunction = Union[\n    GeneralPlainNoInfoSerializerFunction,\n    GeneralPlainInfoSerializerFunction,\n    FieldPlainNoInfoSerializerFunction,\n    FieldPlainInfoSerializerFunction,\n]\n\nWhenUsed = Literal['always', 'unless-none', 'json', 'json-unless-none']\n\"\"\"\nValues have the following meanings:\n\n* `'always'` means always use\n* `'unless-none'` means use unless the value is `None`\n* `'json'` means use when serializing to JSON\n* `'json-unless-none'` means use when serializing to JSON and the value is not `None`\n\"\"\"\n\n\nclass PlainSerializerFunctionSerSchema(TypedDict, total=False):\n    type: Required[Literal['function-plain']]\n    function: Required[SerializerFunction]\n    is_field_serializer: bool  # default False\n    info_arg: bool  # default False\n    return_schema: CoreSchema  # if omitted, AnySchema is used\n    when_used: WhenUsed  # default: 'always'\n\n\ndef plain_serializer_function_ser_schema(\n    function: SerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = 'always',\n) -> PlainSerializerFunctionSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a function, can be either a \"general\" or \"field\" function.\n\n    Args:\n        function: The function to use for serialization\n        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,\n            and `info` includes `field_name`\n        info_arg: Whether the function takes an `info` argument\n        return_schema: Schema to use for serializing return value\n        when_used: When the function should be called\n    \"\"\"\n    if when_used == 'always':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(\n        type='function-plain',\n        function=function,\n        is_field_serializer=is_field_serializer,\n        info_arg=info_arg,\n        return_schema=return_schema,\n        when_used=when_used,\n    )\n\n\nclass SerializerFunctionWrapHandler(Protocol):  # pragma: no cover\n    def __call__(self, input_value: Any, index_key: int | str | None = None, /) -> Any: ...\n\n\n# (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any\nGeneralWrapNoInfoSerializerFunction = Callable[[Any, SerializerFunctionWrapHandler], Any]\n# (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -> Any\nGeneralWrapInfoSerializerFunction = Callable[[Any, SerializerFunctionWrapHandler, SerializationInfo], Any]\n# (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any\nFieldWrapNoInfoSerializerFunction = Callable[[Any, Any, SerializerFunctionWrapHandler], Any]\n# (model: Any, input_value: Any, serializer: SerializerFunctionWrapHandler, info: FieldSerializationInfo, /) -> Any\nFieldWrapInfoSerializerFunction = Callable[[Any, Any, SerializerFunctionWrapHandler, FieldSerializationInfo], Any]\nWrapSerializerFunction = Union[\n    GeneralWrapNoInfoSerializerFunction,\n    GeneralWrapInfoSerializerFunction,\n    FieldWrapNoInfoSerializerFunction,\n    FieldWrapInfoSerializerFunction,\n]\n\n\nclass WrapSerializerFunctionSerSchema(TypedDict, total=False):\n    type: Required[Literal['function-wrap']]\n    function: Required[WrapSerializerFunction]\n    is_field_serializer: bool  # default False\n    info_arg: bool  # default False\n    schema: CoreSchema  # if omitted, the schema on which this serializer is defined is used\n    return_schema: CoreSchema  # if omitted, AnySchema is used\n    when_used: WhenUsed  # default: 'always'\n\n\ndef wrap_serializer_function_ser_schema(\n    function: WrapSerializerFunction,\n    *,\n    is_field_serializer: bool | None = None,\n    info_arg: bool | None = None,\n    schema: CoreSchema | None = None,\n    return_schema: CoreSchema | None = None,\n    when_used: WhenUsed = 'always',\n) -> WrapSerializerFunctionSerSchema:\n    \"\"\"\n    Returns a schema for serialization with a wrap function, can be either a \"general\" or \"field\" function.\n\n    Args:\n        function: The function to use for serialization\n        is_field_serializer: Whether the serializer is for a field, e.g. takes `model` as the first argument,\n            and `info` includes `field_name`\n        info_arg: Whether the function takes an `info` argument\n        schema: The schema to use for the inner serialization\n        return_schema: Schema to use for serializing return value\n        when_used: When the function should be called\n    \"\"\"\n    if when_used == 'always':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(\n        type='function-wrap',\n        function=function,\n        is_field_serializer=is_field_serializer,\n        info_arg=info_arg,\n        schema=schema,\n        return_schema=return_schema,\n        when_used=when_used,\n    )\n\n\nclass FormatSerSchema(TypedDict, total=False):\n    type: Required[Literal['format']]\n    formatting_string: Required[str]\n    when_used: WhenUsed  # default: 'json-unless-none'\n\n\ndef format_ser_schema(formatting_string: str, *, when_used: WhenUsed = 'json-unless-none') -> FormatSerSchema:\n    \"\"\"\n    Returns a schema for serialization using python's `format` method.\n\n    Args:\n        formatting_string: String defining the format to use\n        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default\n    \"\"\"\n    if when_used == 'json-unless-none':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        when_used = None  # type: ignore\n    return _dict_not_none(type='format', formatting_string=formatting_string, when_used=when_used)\n\n\nclass ToStringSerSchema(TypedDict, total=False):\n    type: Required[Literal['to-string']]\n    when_used: WhenUsed  # default: 'json-unless-none'\n\n\ndef to_string_ser_schema(*, when_used: WhenUsed = 'json-unless-none') -> ToStringSerSchema:\n    \"\"\"\n    Returns a schema for serialization using python's `str()` / `__str__` method.\n\n    Args:\n        when_used: Same meaning as for [general_function_plain_ser_schema], but with a different default\n    \"\"\"\n    s = dict(type='to-string')\n    if when_used != 'json-unless-none':\n        # just to avoid extra elements in schema, and to use the actual default defined in rust\n        s['when_used'] = when_used\n    return s  # type: ignore\n\n\nclass ModelSerSchema(TypedDict, total=False):\n    type: Required[Literal['model']]\n    cls: Required[Type[Any]]\n    schema: Required[CoreSchema]\n\n\ndef model_ser_schema(cls: Type[Any], schema: CoreSchema) -> ModelSerSchema:\n    \"\"\"\n    Returns a schema for serialization using a model.\n\n    Args:\n        cls: The expected class type, used to generate warnings if the wrong type is passed\n        schema: Internal schema to use to serialize the model dict\n    \"\"\"\n    return ModelSerSchema(type='model', cls=cls, schema=schema)\n\n\nSerSchema = Union[\n    SimpleSerSchema,\n    PlainSerializerFunctionSerSchema,\n    WrapSerializerFunctionSerSchema,\n    FormatSerSchema,\n    ToStringSerSchema,\n    ModelSerSchema,\n]\n\n\nclass ComputedField(TypedDict, total=False):\n    type: Required[Literal['computed-field']]\n    property_name: Required[str]\n    return_schema: Required[CoreSchema]\n    alias: str\n    metadata: Any\n\n\ndef computed_field(\n    property_name: str, return_schema: CoreSchema, *, alias: str | None = None, metadata: Any = None\n) -> ComputedField:\n    \"\"\"\n    ComputedFields are properties of a model or dataclass that are included in serialization.\n\n    Args:\n        property_name: The name of the property on the model or dataclass\n        return_schema: The schema used for the type returned by the computed field\n        alias: The name to use in the serialized output\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='computed-field', property_name=property_name, return_schema=return_schema, alias=alias, metadata=metadata\n    )\n\n\nclass AnySchema(TypedDict, total=False):\n    type: Required[Literal['any']]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef any_schema(*, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None) -> AnySchema:\n    \"\"\"\n    Returns a schema that matches any value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.any_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python(1) == 1\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='any', ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass NoneSchema(TypedDict, total=False):\n    type: Required[Literal['none']]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef none_schema(*, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None) -> NoneSchema:\n    \"\"\"\n    Returns a schema that matches a None value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.none_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python(None) is None\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='none', ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass BoolSchema(TypedDict, total=False):\n    type: Required[Literal['bool']]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef bool_schema(\n    strict: bool | None = None, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None\n) -> BoolSchema:\n    \"\"\"\n    Returns a schema that matches a bool value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.bool_schema()\n    v = SchemaValidator(schema)\n    assert v.validate_python('True') is True\n    ```\n\n    Args:\n        strict: Whether the value should be a bool or a value that can be converted to a bool\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='bool', strict=strict, ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass IntSchema(TypedDict, total=False):\n    type: Required[Literal['int']]\n    multiple_of: int\n    le: int\n    ge: int\n    lt: int\n    gt: int\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef int_schema(\n    *,\n    multiple_of: int | None = None,\n    le: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    gt: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> IntSchema:\n    \"\"\"\n    Returns a schema that matches a int value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.int_schema(multiple_of=2, le=6, ge=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('4') == 4\n    ```\n\n    Args:\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        strict: Whether the value should be a int or a value that can be converted to a int\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='int',\n        multiple_of=multiple_of,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass FloatSchema(TypedDict, total=False):\n    type: Required[Literal['float']]\n    allow_inf_nan: bool  # whether 'NaN', '+inf', '-inf' should be forbidden. default: True\n    multiple_of: float\n    le: float\n    ge: float\n    lt: float\n    gt: float\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef float_schema(\n    *,\n    allow_inf_nan: bool | None = None,\n    multiple_of: float | None = None,\n    le: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    gt: float | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> FloatSchema:\n    \"\"\"\n    Returns a schema that matches a float value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.float_schema(le=0.8, ge=0.2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('0.5') == 0.5\n    ```\n\n    Args:\n        allow_inf_nan: Whether to allow inf and nan values\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        strict: Whether the value should be a float or a value that can be converted to a float\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='float',\n        allow_inf_nan=allow_inf_nan,\n        multiple_of=multiple_of,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass DecimalSchema(TypedDict, total=False):\n    type: Required[Literal['decimal']]\n    allow_inf_nan: bool  # whether 'NaN', '+inf', '-inf' should be forbidden. default: False\n    multiple_of: Decimal\n    le: Decimal\n    ge: Decimal\n    lt: Decimal\n    gt: Decimal\n    max_digits: int\n    decimal_places: int\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef decimal_schema(\n    *,\n    allow_inf_nan: bool = None,\n    multiple_of: Decimal | None = None,\n    le: Decimal | None = None,\n    ge: Decimal | None = None,\n    lt: Decimal | None = None,\n    gt: Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> DecimalSchema:\n    \"\"\"\n    Returns a schema that matches a decimal value, e.g.:\n\n    ```py\n    from decimal import Decimal\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.decimal_schema(le=0.8, ge=0.2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('0.5') == Decimal('0.5')\n    ```\n\n    Args:\n        allow_inf_nan: Whether to allow inf and nan values\n        multiple_of: The value must be a multiple of this number\n        le: The value must be less than or equal to this number\n        ge: The value must be greater than or equal to this number\n        lt: The value must be strictly less than this number\n        gt: The value must be strictly greater than this number\n        max_digits: The maximum number of decimal digits allowed\n        decimal_places: The maximum number of decimal places allowed\n        strict: Whether the value should be a float or a value that can be converted to a float\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='decimal',\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass StringSchema(TypedDict, total=False):\n    type: Required[Literal['str']]\n    pattern: Union[str, Pattern[str]]\n    max_length: int\n    min_length: int\n    strip_whitespace: bool\n    to_lower: bool\n    to_upper: bool\n    regex_engine: Literal['rust-regex', 'python-re']  # default: 'rust-regex'\n    strict: bool\n    coerce_numbers_to_str: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef str_schema(\n    *,\n    pattern: str | Pattern[str] | None = None,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strip_whitespace: bool | None = None,\n    to_lower: bool | None = None,\n    to_upper: bool | None = None,\n    regex_engine: Literal['rust-regex', 'python-re'] | None = None,\n    strict: bool | None = None,\n    coerce_numbers_to_str: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> StringSchema:\n    \"\"\"\n    Returns a schema that matches a string value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.str_schema(max_length=10, min_length=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    ```\n\n    Args:\n        pattern: A regex pattern that the value must match\n        max_length: The value must be at most this length\n        min_length: The value must be at least this length\n        strip_whitespace: Whether to strip whitespace from the value\n        to_lower: Whether to convert the value to lowercase\n        to_upper: Whether to convert the value to uppercase\n        regex_engine: The regex engine to use for pattern validation. Default is 'rust-regex'.\n            - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust\n              crate, which is non-backtracking and therefore more DDoS\n              resistant, but does not support all regex features.\n            - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,\n              which supports all regex features, but may be slower.\n        strict: Whether the value should be a string or a value that can be converted to a string\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='str',\n        pattern=pattern,\n        max_length=max_length,\n        min_length=min_length,\n        strip_whitespace=strip_whitespace,\n        to_lower=to_lower,\n        to_upper=to_upper,\n        regex_engine=regex_engine,\n        strict=strict,\n        coerce_numbers_to_str=coerce_numbers_to_str,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass BytesSchema(TypedDict, total=False):\n    type: Required[Literal['bytes']]\n    max_length: int\n    min_length: int\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef bytes_schema(\n    *,\n    max_length: int | None = None,\n    min_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> BytesSchema:\n    \"\"\"\n    Returns a schema that matches a bytes value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.bytes_schema(max_length=10, min_length=2)\n    v = SchemaValidator(schema)\n    assert v.validate_python(b'hello') == b'hello'\n    ```\n\n    Args:\n        max_length: The value must be at most this length\n        min_length: The value must be at least this length\n        strict: Whether the value should be a bytes or a value that can be converted to a bytes\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='bytes',\n        max_length=max_length,\n        min_length=min_length,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass DateSchema(TypedDict, total=False):\n    type: Required[Literal['date']]\n    strict: bool\n    le: date\n    ge: date\n    lt: date\n    gt: date\n    now_op: Literal['past', 'future']\n    # defaults to current local utc offset from `time.localtime().tm_gmtoff`\n    # value is restricted to -86_400 < offset < 86_400 by bounds in generate_self_schema.py\n    now_utc_offset: int\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef date_schema(\n    *,\n    strict: bool | None = None,\n    le: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    gt: date | None = None,\n    now_op: Literal['past', 'future'] | None = None,\n    now_utc_offset: int | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> DateSchema:\n    \"\"\"\n    Returns a schema that matches a date value, e.g.:\n\n    ```py\n    from datetime import date\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.date_schema(le=date(2020, 1, 1), ge=date(2019, 1, 1))\n    v = SchemaValidator(schema)\n    assert v.validate_python(date(2019, 6, 1)) == date(2019, 6, 1)\n    ```\n\n    Args:\n        strict: Whether the value should be a date or a value that can be converted to a date\n        le: The value must be less than or equal to this date\n        ge: The value must be greater than or equal to this date\n        lt: The value must be strictly less than this date\n        gt: The value must be strictly greater than this date\n        now_op: The value must be in the past or future relative to the current date\n        now_utc_offset: The value must be in the past or future relative to the current date with this utc offset\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='date',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        now_op=now_op,\n        now_utc_offset=now_utc_offset,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass TimeSchema(TypedDict, total=False):\n    type: Required[Literal['time']]\n    strict: bool\n    le: time\n    ge: time\n    lt: time\n    gt: time\n    tz_constraint: Union[Literal['aware', 'naive'], int]\n    microseconds_precision: Literal['truncate', 'error']\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef time_schema(\n    *,\n    strict: bool | None = None,\n    le: time | None = None,\n    ge: time | None = None,\n    lt: time | None = None,\n    gt: time | None = None,\n    tz_constraint: Literal['aware', 'naive'] | int | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> TimeSchema:\n    \"\"\"\n    Returns a schema that matches a time value, e.g.:\n\n    ```py\n    from datetime import time\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.time_schema(le=time(12, 0, 0), ge=time(6, 0, 0))\n    v = SchemaValidator(schema)\n    assert v.validate_python(time(9, 0, 0)) == time(9, 0, 0)\n    ```\n\n    Args:\n        strict: Whether the value should be a time or a value that can be converted to a time\n        le: The value must be less than or equal to this time\n        ge: The value must be greater than or equal to this time\n        lt: The value must be strictly less than this time\n        gt: The value must be strictly greater than this time\n        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='time',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        tz_constraint=tz_constraint,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass DatetimeSchema(TypedDict, total=False):\n    type: Required[Literal['datetime']]\n    strict: bool\n    le: datetime\n    ge: datetime\n    lt: datetime\n    gt: datetime\n    now_op: Literal['past', 'future']\n    tz_constraint: Union[Literal['aware', 'naive'], int]\n    # defaults to current local utc offset from `time.localtime().tm_gmtoff`\n    # value is restricted to -86_400 < offset < 86_400 by bounds in generate_self_schema.py\n    now_utc_offset: int\n    microseconds_precision: Literal['truncate', 'error']  # default: 'truncate'\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef datetime_schema(\n    *,\n    strict: bool | None = None,\n    le: datetime | None = None,\n    ge: datetime | None = None,\n    lt: datetime | None = None,\n    gt: datetime | None = None,\n    now_op: Literal['past', 'future'] | None = None,\n    tz_constraint: Literal['aware', 'naive'] | int | None = None,\n    now_utc_offset: int | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> DatetimeSchema:\n    \"\"\"\n    Returns a schema that matches a datetime value, e.g.:\n\n    ```py\n    from datetime import datetime\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.datetime_schema()\n    v = SchemaValidator(schema)\n    now = datetime.now()\n    assert v.validate_python(str(now)) == now\n    ```\n\n    Args:\n        strict: Whether the value should be a datetime or a value that can be converted to a datetime\n        le: The value must be less than or equal to this datetime\n        ge: The value must be greater than or equal to this datetime\n        lt: The value must be strictly less than this datetime\n        gt: The value must be strictly greater than this datetime\n        now_op: The value must be in the past or future relative to the current datetime\n        tz_constraint: The value must be timezone aware or naive, or an int to indicate required tz offset\n            TODO: use of a tzinfo where offset changes based on the datetime is not yet supported\n        now_utc_offset: The value must be in the past or future relative to the current datetime with this utc offset\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='datetime',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        now_op=now_op,\n        tz_constraint=tz_constraint,\n        now_utc_offset=now_utc_offset,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass TimedeltaSchema(TypedDict, total=False):\n    type: Required[Literal['timedelta']]\n    strict: bool\n    le: timedelta\n    ge: timedelta\n    lt: timedelta\n    gt: timedelta\n    microseconds_precision: Literal['truncate', 'error']\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef timedelta_schema(\n    *,\n    strict: bool | None = None,\n    le: timedelta | None = None,\n    ge: timedelta | None = None,\n    lt: timedelta | None = None,\n    gt: timedelta | None = None,\n    microseconds_precision: Literal['truncate', 'error'] = 'truncate',\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> TimedeltaSchema:\n    \"\"\"\n    Returns a schema that matches a timedelta value, e.g.:\n\n    ```py\n    from datetime import timedelta\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.timedelta_schema(le=timedelta(days=1), ge=timedelta(days=0))\n    v = SchemaValidator(schema)\n    assert v.validate_python(timedelta(hours=12)) == timedelta(hours=12)\n    ```\n\n    Args:\n        strict: Whether the value should be a timedelta or a value that can be converted to a timedelta\n        le: The value must be less than or equal to this timedelta\n        ge: The value must be greater than or equal to this timedelta\n        lt: The value must be strictly less than this timedelta\n        gt: The value must be strictly greater than this timedelta\n        microseconds_precision: The behavior when seconds have more than 6 digits or microseconds is too large\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='timedelta',\n        strict=strict,\n        le=le,\n        ge=ge,\n        lt=lt,\n        gt=gt,\n        microseconds_precision=microseconds_precision,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass LiteralSchema(TypedDict, total=False):\n    type: Required[Literal['literal']]\n    expected: Required[List[Any]]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef literal_schema(\n    expected: list[Any], *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None\n) -> LiteralSchema:\n    \"\"\"\n    Returns a schema that matches a literal value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.literal_schema(['hello', 'world'])\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    ```\n\n    Args:\n        expected: The value must be one of these values\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='literal', expected=expected, ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass EnumSchema(TypedDict, total=False):\n    type: Required[Literal['enum']]\n    cls: Required[Any]\n    members: Required[List[Any]]\n    sub_type: Literal['str', 'int', 'float']\n    missing: Callable[[Any], Any]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef enum_schema(\n    cls: Any,\n    members: list[Any],\n    *,\n    sub_type: Literal['str', 'int', 'float'] | None = None,\n    missing: Callable[[Any], Any] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> EnumSchema:\n    \"\"\"\n    Returns a schema that matches an enum value, e.g.:\n\n    ```py\n    from enum import Enum\n    from pydantic_core import SchemaValidator, core_schema\n\n    class Color(Enum):\n        RED = 1\n        GREEN = 2\n        BLUE = 3\n\n    schema = core_schema.enum_schema(Color, list(Color.__members__.values()))\n    v = SchemaValidator(schema)\n    assert v.validate_python(2) is Color.GREEN\n    ```\n\n    Args:\n        cls: The enum class\n        members: The members of the enum, generally `list(MyEnum.__members__.values())`\n        sub_type: The type of the enum, either 'str' or 'int' or None for plain enums\n        missing: A function to use when the value is not found in the enum, from `_missing_`\n        strict: Whether to use strict mode, defaults to False\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='enum',\n        cls=cls,\n        members=members,\n        sub_type=sub_type,\n        missing=missing,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\n# must match input/parse_json.rs::JsonType::try_from\nJsonType = Literal['null', 'bool', 'int', 'float', 'str', 'list', 'dict']\n\n\nclass IsInstanceSchema(TypedDict, total=False):\n    type: Required[Literal['is-instance']]\n    cls: Required[Any]\n    cls_repr: str\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef is_instance_schema(\n    cls: Any,\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> IsInstanceSchema:\n    \"\"\"\n    Returns a schema that checks if a value is an instance of a class, equivalent to python's `isinstance` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    class A:\n        pass\n\n    schema = core_schema.is_instance_schema(cls=A)\n    v = SchemaValidator(schema)\n    v.validate_python(A())\n    ```\n\n    Args:\n        cls: The value must be an instance of this class\n        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='is-instance', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization\n    )\n\n\nclass IsSubclassSchema(TypedDict, total=False):\n    type: Required[Literal['is-subclass']]\n    cls: Required[Type[Any]]\n    cls_repr: str\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef is_subclass_schema(\n    cls: Type[Any],\n    *,\n    cls_repr: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> IsInstanceSchema:\n    \"\"\"\n    Returns a schema that checks if a value is a subtype of a class, equivalent to python's `issubclass` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    class A:\n        pass\n\n    class B(A):\n        pass\n\n    schema = core_schema.is_subclass_schema(cls=A)\n    v = SchemaValidator(schema)\n    v.validate_python(B)\n    ```\n\n    Args:\n        cls: The value must be a subclass of this class\n        cls_repr: If provided this string is used in the validator name instead of `repr(cls)`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='is-subclass', cls=cls, cls_repr=cls_repr, ref=ref, metadata=metadata, serialization=serialization\n    )\n\n\nclass CallableSchema(TypedDict, total=False):\n    type: Required[Literal['callable']]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef callable_schema(\n    *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None\n) -> CallableSchema:\n    \"\"\"\n    Returns a schema that checks if a value is callable, equivalent to python's `callable` method, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.callable_schema()\n    v = SchemaValidator(schema)\n    v.validate_python(min)\n    ```\n\n    Args:\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='callable', ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass UuidSchema(TypedDict, total=False):\n    type: Required[Literal['uuid']]\n    version: Literal[1, 3, 4, 5]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef uuid_schema(\n    *,\n    version: Literal[1, 3, 4, 5] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> UuidSchema:\n    return _dict_not_none(\n        type='uuid', version=version, strict=strict, ref=ref, metadata=metadata, serialization=serialization\n    )\n\n\nclass IncExSeqSerSchema(TypedDict, total=False):\n    type: Required[Literal['include-exclude-sequence']]\n    include: Set[int]\n    exclude: Set[int]\n\n\ndef filter_seq_schema(*, include: Set[int] | None = None, exclude: Set[int] | None = None) -> IncExSeqSerSchema:\n    return _dict_not_none(type='include-exclude-sequence', include=include, exclude=exclude)\n\n\nIncExSeqOrElseSerSchema = Union[IncExSeqSerSchema, SerSchema]\n\n\nclass ListSchema(TypedDict, total=False):\n    type: Required[Literal['list']]\n    items_schema: CoreSchema\n    min_length: int\n    max_length: int\n    fail_fast: bool\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: IncExSeqOrElseSerSchema\n\n\ndef list_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -> ListSchema:\n    \"\"\"\n    Returns a schema that matches a list value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.list_schema(core_schema.int_schema(), min_length=0, max_length=10)\n    v = SchemaValidator(schema)\n    assert v.validate_python(['4']) == [4]\n    ```\n\n    Args:\n        items_schema: The value must be a list of items that match this schema\n        min_length: The value must be a list with at least this many items\n        max_length: The value must be a list with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a list with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='list',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\n# @deprecated('tuple_positional_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')\ndef tuple_positional_schema(\n    items_schema: list[CoreSchema],\n    *,\n    extras_schema: CoreSchema | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -> TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of schemas, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_positional_schema(\n        [core_schema.int_schema(), core_schema.str_schema()]\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((1, 'hello')) == (1, 'hello')\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match these schemas\n        extras_schema: The value must be a tuple with items that match this schema\n            This was inspired by JSON schema's `prefixItems` and `items` fields.\n            In python's `typing.Tuple`, you can't specify a type for \"extra\" items -- they must all be the same type\n            if the length is variable. So this field won't be set from a `typing.Tuple` annotation on a pydantic model.\n        strict: The value must be a tuple with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    if extras_schema is not None:\n        variadic_item_index = len(items_schema)\n        items_schema = items_schema + [extras_schema]\n    else:\n        variadic_item_index = None\n    return tuple_schema(\n        items_schema=items_schema,\n        variadic_item_index=variadic_item_index,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\n# @deprecated('tuple_variable_schema is deprecated. Use pydantic_core.core_schema.tuple_schema instead.')\ndef tuple_variable_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -> TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_variable_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(('1', 2, 3)) == (1, 2, 3)\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match this schema\n        min_length: The value must be a tuple with at least this many items\n        max_length: The value must be a tuple with at most this many items\n        strict: The value must be a tuple with exactly this many items\n        ref: Optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return tuple_schema(\n        items_schema=[items_schema or any_schema()],\n        variadic_item_index=0,\n        min_length=min_length,\n        max_length=max_length,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass TupleSchema(TypedDict, total=False):\n    type: Required[Literal['tuple']]\n    items_schema: Required[List[CoreSchema]]\n    variadic_item_index: int\n    min_length: int\n    max_length: int\n    fail_fast: bool\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: IncExSeqOrElseSerSchema\n\n\ndef tuple_schema(\n    items_schema: list[CoreSchema],\n    *,\n    variadic_item_index: int | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -> TupleSchema:\n    \"\"\"\n    Returns a schema that matches a tuple of schemas, with an optional variadic item, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.tuple_schema(\n        [core_schema.int_schema(), core_schema.str_schema(), core_schema.float_schema()],\n        variadic_item_index=1,\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((1, 'hello', 'world', 1.5)) == (1, 'hello', 'world', 1.5)\n    ```\n\n    Args:\n        items_schema: The value must be a tuple with items that match these schemas\n        variadic_item_index: The index of the schema in `items_schema` to be treated as variadic (following PEP 646)\n        min_length: The value must be a tuple with at least this many items\n        max_length: The value must be a tuple with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a tuple with exactly this many items\n        ref: Optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='tuple',\n        items_schema=items_schema,\n        variadic_item_index=variadic_item_index,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass SetSchema(TypedDict, total=False):\n    type: Required[Literal['set']]\n    items_schema: CoreSchema\n    min_length: int\n    max_length: int\n    fail_fast: bool\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef set_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> SetSchema:\n    \"\"\"\n    Returns a schema that matches a set of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.set_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({1, '2', 3}) == {1, 2, 3}\n    ```\n\n    Args:\n        items_schema: The value must be a set with items that match this schema\n        min_length: The value must be a set with at least this many items\n        max_length: The value must be a set with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a set with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='set',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass FrozenSetSchema(TypedDict, total=False):\n    type: Required[Literal['frozenset']]\n    items_schema: CoreSchema\n    min_length: int\n    max_length: int\n    fail_fast: bool\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef frozenset_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    fail_fast: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> FrozenSetSchema:\n    \"\"\"\n    Returns a schema that matches a frozenset of a given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.frozenset_schema(\n        items_schema=core_schema.int_schema(), min_length=0, max_length=10\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(frozenset(range(3))) == frozenset({0, 1, 2})\n    ```\n\n    Args:\n        items_schema: The value must be a frozenset with items that match this schema\n        min_length: The value must be a frozenset with at least this many items\n        max_length: The value must be a frozenset with at most this many items\n        fail_fast: Stop validation on the first error\n        strict: The value must be a frozenset with exactly this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='frozenset',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        fail_fast=fail_fast,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass GeneratorSchema(TypedDict, total=False):\n    type: Required[Literal['generator']]\n    items_schema: CoreSchema\n    min_length: int\n    max_length: int\n    ref: str\n    metadata: Any\n    serialization: IncExSeqOrElseSerSchema\n\n\ndef generator_schema(\n    items_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: IncExSeqOrElseSerSchema | None = None,\n) -> GeneratorSchema:\n    \"\"\"\n    Returns a schema that matches a generator value, e.g.:\n\n    ```py\n    from typing import Iterator\n    from pydantic_core import SchemaValidator, core_schema\n\n    def gen() -> Iterator[int]:\n        yield 1\n\n    schema = core_schema.generator_schema(items_schema=core_schema.int_schema())\n    v = SchemaValidator(schema)\n    v.validate_python(gen())\n    ```\n\n    Unlike other types, validated generators do not raise ValidationErrors eagerly,\n    but instead will raise a ValidationError when a violating value is actually read from the generator.\n    This is to ensure that \"validated\" generators retain the benefit of lazy evaluation.\n\n    Args:\n        items_schema: The value must be a generator with items that match this schema\n        min_length: The value must be a generator that yields at least this many items\n        max_length: The value must be a generator that yields at most this many items\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='generator',\n        items_schema=items_schema,\n        min_length=min_length,\n        max_length=max_length,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nIncExDict = Set[Union[int, str]]\n\n\nclass IncExDictSerSchema(TypedDict, total=False):\n    type: Required[Literal['include-exclude-dict']]\n    include: IncExDict\n    exclude: IncExDict\n\n\ndef filter_dict_schema(*, include: IncExDict | None = None, exclude: IncExDict | None = None) -> IncExDictSerSchema:\n    return _dict_not_none(type='include-exclude-dict', include=include, exclude=exclude)\n\n\nIncExDictOrElseSerSchema = Union[IncExDictSerSchema, SerSchema]\n\n\nclass DictSchema(TypedDict, total=False):\n    type: Required[Literal['dict']]\n    keys_schema: CoreSchema  # default: AnySchema\n    values_schema: CoreSchema  # default: AnySchema\n    min_length: int\n    max_length: int\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: IncExDictOrElseSerSchema\n\n\ndef dict_schema(\n    keys_schema: CoreSchema | None = None,\n    values_schema: CoreSchema | None = None,\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> DictSchema:\n    \"\"\"\n    Returns a schema that matches a dict value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.dict_schema(\n        keys_schema=core_schema.str_schema(), values_schema=core_schema.int_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': '1', 'b': 2}) == {'a': 1, 'b': 2}\n    ```\n\n    Args:\n        keys_schema: The value must be a dict with keys that match this schema\n        values_schema: The value must be a dict with values that match this schema\n        min_length: The value must be a dict with at least this many items\n        max_length: The value must be a dict with at most this many items\n        strict: Whether the keys and values should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='dict',\n        keys_schema=keys_schema,\n        values_schema=values_schema,\n        min_length=min_length,\n        max_length=max_length,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\n# (input_value: Any, /) -> Any\nNoInfoValidatorFunction = Callable[[Any], Any]\n\n\nclass NoInfoValidatorFunctionSchema(TypedDict):\n    type: Literal['no-info']\n    function: NoInfoValidatorFunction\n\n\n# (input_value: Any, info: ValidationInfo, /) -> Any\nWithInfoValidatorFunction = Callable[[Any, ValidationInfo], Any]\n\n\nclass WithInfoValidatorFunctionSchema(TypedDict, total=False):\n    type: Required[Literal['with-info']]\n    function: Required[WithInfoValidatorFunction]\n    field_name: str\n\n\nValidationFunction = Union[NoInfoValidatorFunctionSchema, WithInfoValidatorFunctionSchema]\n\n\nclass _ValidatorFunctionSchema(TypedDict, total=False):\n    function: Required[ValidationFunction]\n    schema: Required[CoreSchema]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\nclass BeforeValidatorFunctionSchema(_ValidatorFunctionSchema, total=False):\n    type: Required[Literal['function-before']]\n\n\ndef no_info_before_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> BeforeValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function before validating, no `info` argument is provided, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: bytes) -> str:\n        return v.decode() + 'world'\n\n    func_schema = core_schema.no_info_before_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-before',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\ndef with_info_before_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> BeforeValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function before validation, the function is called with\n    an `info` argument, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: bytes, info: core_schema.ValidationInfo) -> str:\n        assert info.data is not None\n        assert info.field_name is not None\n        return v.decode() + 'world'\n\n    func_schema = core_schema.with_info_before_validator_function(\n        function=fn, schema=core_schema.str_schema(), field_name='a'\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call\n        field_name: The name of the field\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-before',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass AfterValidatorFunctionSchema(_ValidatorFunctionSchema, total=False):\n    type: Required[Literal['function-after']]\n\n\ndef no_info_after_validator_function(\n    function: NoInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> AfterValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function after validating, no `info` argument is provided, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str) -> str:\n        return v + 'world'\n\n    func_schema = core_schema.no_info_after_validator_function(fn, core_schema.str_schema())\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call after the schema is validated\n        schema: The schema to validate before the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-after',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\ndef with_info_after_validator_function(\n    function: WithInfoValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> AfterValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that calls a validator function after validation, the function is called with\n    an `info` argument, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -> str:\n        assert info.data is not None\n        assert info.field_name is not None\n        return v + 'world'\n\n    func_schema = core_schema.with_info_after_validator_function(\n        function=fn, schema=core_schema.str_schema(), field_name='a'\n    )\n    schema = core_schema.typed_dict_schema({'a': core_schema.typed_dict_field(func_schema)})\n\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': b'hello '}) == {'a': 'hello world'}\n    ```\n\n    Args:\n        function: The validator function to call after the schema is validated\n        schema: The schema to validate before the validator function\n        field_name: The name of the field this validators is applied to, if any\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-after',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass ValidatorFunctionWrapHandler(Protocol):\n    def __call__(self, input_value: Any, outer_location: str | int | None = None, /) -> Any:  # pragma: no cover\n        ...\n\n\n# (input_value: Any, validator: ValidatorFunctionWrapHandler, /) -> Any\nNoInfoWrapValidatorFunction = Callable[[Any, ValidatorFunctionWrapHandler], Any]\n\n\nclass NoInfoWrapValidatorFunctionSchema(TypedDict):\n    type: Literal['no-info']\n    function: NoInfoWrapValidatorFunction\n\n\n# (input_value: Any, validator: ValidatorFunctionWrapHandler, info: ValidationInfo, /) -> Any\nWithInfoWrapValidatorFunction = Callable[[Any, ValidatorFunctionWrapHandler, ValidationInfo], Any]\n\n\nclass WithInfoWrapValidatorFunctionSchema(TypedDict, total=False):\n    type: Required[Literal['with-info']]\n    function: Required[WithInfoWrapValidatorFunction]\n    field_name: str\n\n\nWrapValidatorFunction = Union[NoInfoWrapValidatorFunctionSchema, WithInfoWrapValidatorFunctionSchema]\n\n\nclass WrapValidatorFunctionSchema(TypedDict, total=False):\n    type: Required[Literal['function-wrap']]\n    function: Required[WrapValidatorFunction]\n    schema: Required[CoreSchema]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef no_info_wrap_validator_function(\n    function: NoInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> WrapValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema which calls a function with a `validator` callable argument which can\n    optionally be used to call inner validation with the function logic, this is much like the\n    \"onion\" implementation of middleware in many popular web frameworks, no `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(\n        v: str,\n        validator: core_schema.ValidatorFunctionWrapHandler,\n    ) -> str:\n        return validator(input_value=v) + 'world'\n\n    schema = core_schema.no_info_wrap_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-wrap',\n        function={'type': 'no-info', 'function': function},\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\ndef with_info_wrap_validator_function(\n    function: WithInfoWrapValidatorFunction,\n    schema: CoreSchema,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> WrapValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema which calls a function with a `validator` callable argument which can\n    optionally be used to call inner validation with the function logic, this is much like the\n    \"onion\" implementation of middleware in many popular web frameworks, an `info` argument is also passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(\n        v: str,\n        validator: core_schema.ValidatorFunctionWrapHandler,\n        info: core_schema.ValidationInfo,\n    ) -> str:\n        return validator(input_value=v) + 'world'\n\n    schema = core_schema.with_info_wrap_validator_function(\n        function=fn, schema=core_schema.str_schema()\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        schema: The schema to validate the output of the validator function\n        field_name: The name of the field this validators is applied to, if any\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-wrap',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        schema=schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass PlainValidatorFunctionSchema(TypedDict, total=False):\n    type: Required[Literal['function-plain']]\n    function: Required[ValidationFunction]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef no_info_plain_validator_function(\n    function: NoInfoValidatorFunction,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> PlainValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that uses the provided function for validation, no `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str) -> str:\n        assert 'hello' in v\n        return v + 'world'\n\n    schema = core_schema.no_info_plain_validator_function(function=fn)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-plain',\n        function={'type': 'no-info', 'function': function},\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\ndef with_info_plain_validator_function(\n    function: WithInfoValidatorFunction,\n    *,\n    field_name: str | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> PlainValidatorFunctionSchema:\n    \"\"\"\n    Returns a schema that uses the provided function for validation, an `info` argument is passed, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -> str:\n        assert 'hello' in v\n        return v + 'world'\n\n    schema = core_schema.with_info_plain_validator_function(function=fn)\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello ') == 'hello world'\n    ```\n\n    Args:\n        function: The validator function to call\n        field_name: The name of the field this validators is applied to, if any\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='function-plain',\n        function=_dict_not_none(type='with-info', function=function, field_name=field_name),\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass WithDefaultSchema(TypedDict, total=False):\n    type: Required[Literal['default']]\n    schema: Required[CoreSchema]\n    default: Any\n    default_factory: Callable[[], Any]\n    on_error: Literal['raise', 'omit', 'default']  # default: 'raise'\n    validate_default: bool  # default: False\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef with_default_schema(\n    schema: CoreSchema,\n    *,\n    default: Any = PydanticUndefined,\n    default_factory: Callable[[], Any] | None = None,\n    on_error: Literal['raise', 'omit', 'default'] | None = None,\n    validate_default: bool | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> WithDefaultSchema:\n    \"\"\"\n    Returns a schema that adds a default value to the given schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.with_default_schema(core_schema.str_schema(), default='hello')\n    wrapper_schema = core_schema.typed_dict_schema(\n        {'a': core_schema.typed_dict_field(schema)}\n    )\n    v = SchemaValidator(wrapper_schema)\n    assert v.validate_python({}) == v.validate_python({'a': 'hello'})\n    ```\n\n    Args:\n        schema: The schema to add a default value to\n        default: The default value to use\n        default_factory: A function that returns the default value to use\n        on_error: What to do if the schema validation fails. One of 'raise', 'omit', 'default'\n        validate_default: Whether the default value should be validated\n        strict: Whether the underlying schema should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    s = _dict_not_none(\n        type='default',\n        schema=schema,\n        default_factory=default_factory,\n        on_error=on_error,\n        validate_default=validate_default,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n    if default is not PydanticUndefined:\n        s['default'] = default\n    return s\n\n\nclass NullableSchema(TypedDict, total=False):\n    type: Required[Literal['nullable']]\n    schema: Required[CoreSchema]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef nullable_schema(\n    schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> NullableSchema:\n    \"\"\"\n    Returns a schema that matches a nullable value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.nullable_schema(core_schema.str_schema())\n    v = SchemaValidator(schema)\n    assert v.validate_python(None) is None\n    ```\n\n    Args:\n        schema: The schema to wrap\n        strict: Whether the underlying schema should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='nullable', schema=schema, strict=strict, ref=ref, metadata=metadata, serialization=serialization\n    )\n\n\nclass UnionSchema(TypedDict, total=False):\n    type: Required[Literal['union']]\n    choices: Required[List[Union[CoreSchema, Tuple[CoreSchema, str]]]]\n    # default true, whether to automatically collapse unions with one element to the inner validator\n    auto_collapse: bool\n    custom_error_type: str\n    custom_error_message: str\n    custom_error_context: Dict[str, Union[str, int, float]]\n    mode: Literal['smart', 'left_to_right']  # default: 'smart'\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef union_schema(\n    choices: list[CoreSchema | tuple[CoreSchema, str]],\n    *,\n    auto_collapse: bool | None = None,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, str | int] | None = None,\n    mode: Literal['smart', 'left_to_right'] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> UnionSchema:\n    \"\"\"\n    Returns a schema that matches a union value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.union_schema([core_schema.str_schema(), core_schema.int_schema()])\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello'\n    assert v.validate_python(1) == 1\n    ```\n\n    Args:\n        choices: The schemas to match. If a tuple, the second item is used as the label for the case.\n        auto_collapse: whether to automatically collapse unions with one element to the inner validator, default true\n        custom_error_type: The custom error type to use if the validation fails\n        custom_error_message: The custom error message to use if the validation fails\n        custom_error_context: The custom error context to use if the validation fails\n        mode: How to select which choice to return\n            * `smart` (default) will try to return the choice which is the closest match to the input value\n            * `left_to_right` will return the first choice in `choices` which succeeds validation\n        strict: Whether the underlying schemas should be validated with strict mode\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='union',\n        choices=choices,\n        auto_collapse=auto_collapse,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        mode=mode,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass TaggedUnionSchema(TypedDict, total=False):\n    type: Required[Literal['tagged-union']]\n    choices: Required[Dict[Hashable, CoreSchema]]\n    discriminator: Required[Union[str, List[Union[str, int]], List[List[Union[str, int]]], Callable[[Any], Hashable]]]\n    custom_error_type: str\n    custom_error_message: str\n    custom_error_context: Dict[str, Union[str, int, float]]\n    strict: bool\n    from_attributes: bool  # default: True\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef tagged_union_schema(\n    choices: Dict[Any, CoreSchema],\n    discriminator: str | list[str | int] | list[list[str | int]] | Callable[[Any], Any],\n    *,\n    custom_error_type: str | None = None,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, int | str | float] | None = None,\n    strict: bool | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> TaggedUnionSchema:\n    \"\"\"\n    Returns a schema that matches a tagged union value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    apple_schema = core_schema.typed_dict_schema(\n        {\n            'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n            'bar': core_schema.typed_dict_field(core_schema.int_schema()),\n        }\n    )\n    banana_schema = core_schema.typed_dict_schema(\n        {\n            'foo': core_schema.typed_dict_field(core_schema.str_schema()),\n            'spam': core_schema.typed_dict_field(\n                core_schema.list_schema(items_schema=core_schema.int_schema())\n            ),\n        }\n    )\n    schema = core_schema.tagged_union_schema(\n        choices={\n            'apple': apple_schema,\n            'banana': banana_schema,\n        },\n        discriminator='foo',\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python({'foo': 'apple', 'bar': '123'}) == {'foo': 'apple', 'bar': 123}\n    assert v.validate_python({'foo': 'banana', 'spam': [1, 2, 3]}) == {\n        'foo': 'banana',\n        'spam': [1, 2, 3],\n    }\n    ```\n\n    Args:\n        choices: The schemas to match\n            When retrieving a schema from `choices` using the discriminator value, if the value is a str,\n            it should be fed back into the `choices` map until a schema is obtained\n            (This approach is to prevent multiple ownership of a single schema in Rust)\n        discriminator: The discriminator to use to determine the schema to use\n            * If `discriminator` is a str, it is the name of the attribute to use as the discriminator\n            * If `discriminator` is a list of int/str, it should be used as a \"path\" to access the discriminator\n            * If `discriminator` is a list of lists, each inner list is a path, and the first path that exists is used\n            * If `discriminator` is a callable, it should return the discriminator when called on the value to validate;\n              the callable can return `None` to indicate that there is no matching discriminator present on the input\n        custom_error_type: The custom error type to use if the validation fails\n        custom_error_message: The custom error message to use if the validation fails\n        custom_error_context: The custom error context to use if the validation fails\n        strict: Whether the underlying schemas should be validated with strict mode\n        from_attributes: Whether to use the attributes of the object to retrieve the discriminator value\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='tagged-union',\n        choices=choices,\n        discriminator=discriminator,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        strict=strict,\n        from_attributes=from_attributes,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass ChainSchema(TypedDict, total=False):\n    type: Required[Literal['chain']]\n    steps: Required[List[CoreSchema]]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef chain_schema(\n    steps: list[CoreSchema], *, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None\n) -> ChainSchema:\n    \"\"\"\n    Returns a schema that chains the provided validation schemas, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -> str:\n        assert 'hello' in v\n        return v + ' world'\n\n    fn_schema = core_schema.with_info_plain_validator_function(function=fn)\n    schema = core_schema.chain_schema(\n        [fn_schema, fn_schema, fn_schema, core_schema.str_schema()]\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('hello') == 'hello world world world'\n    ```\n\n    Args:\n        steps: The schemas to chain\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='chain', steps=steps, ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass LaxOrStrictSchema(TypedDict, total=False):\n    type: Required[Literal['lax-or-strict']]\n    lax_schema: Required[CoreSchema]\n    strict_schema: Required[CoreSchema]\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef lax_or_strict_schema(\n    lax_schema: CoreSchema,\n    strict_schema: CoreSchema,\n    *,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> LaxOrStrictSchema:\n    \"\"\"\n    Returns a schema that uses the lax or strict schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    def fn(v: str, info: core_schema.ValidationInfo) -> str:\n        assert 'hello' in v\n        return v + ' world'\n\n    lax_schema = core_schema.int_schema(strict=False)\n    strict_schema = core_schema.int_schema(strict=True)\n\n    schema = core_schema.lax_or_strict_schema(\n        lax_schema=lax_schema, strict_schema=strict_schema, strict=True\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python(123) == 123\n\n    schema = core_schema.lax_or_strict_schema(\n        lax_schema=lax_schema, strict_schema=strict_schema, strict=False\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python('123') == 123\n    ```\n\n    Args:\n        lax_schema: The lax schema to use\n        strict_schema: The strict schema to use\n        strict: Whether the strict schema should be used\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='lax-or-strict',\n        lax_schema=lax_schema,\n        strict_schema=strict_schema,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass JsonOrPythonSchema(TypedDict, total=False):\n    type: Required[Literal['json-or-python']]\n    json_schema: Required[CoreSchema]\n    python_schema: Required[CoreSchema]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef json_or_python_schema(\n    json_schema: CoreSchema,\n    python_schema: CoreSchema,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> JsonOrPythonSchema:\n    \"\"\"\n    Returns a schema that uses the Json or Python schema depending on the input:\n\n    ```py\n    from pydantic_core import SchemaValidator, ValidationError, core_schema\n\n    v = SchemaValidator(\n        core_schema.json_or_python_schema(\n            json_schema=core_schema.int_schema(),\n            python_schema=core_schema.int_schema(strict=True),\n        )\n    )\n\n    assert v.validate_json('\"123\"') == 123\n\n    try:\n        v.validate_python('123')\n    except ValidationError:\n        pass\n    else:\n        raise AssertionError('Validation should have failed')\n    ```\n\n    Args:\n        json_schema: The schema to use for Json inputs\n        python_schema: The schema to use for Python inputs\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='json-or-python',\n        json_schema=json_schema,\n        python_schema=python_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass TypedDictField(TypedDict, total=False):\n    type: Required[Literal['typed-dict-field']]\n    schema: Required[CoreSchema]\n    required: bool\n    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]\n    serialization_alias: str\n    serialization_exclude: bool  # default: False\n    metadata: Any\n\n\ndef typed_dict_field(\n    schema: CoreSchema,\n    *,\n    required: bool | None = None,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: Any = None,\n) -> TypedDictField:\n    \"\"\"\n    Returns a schema that matches a typed dict field, e.g.:\n\n    ```py\n    from pydantic_core import core_schema\n\n    field = core_schema.typed_dict_field(schema=core_schema.int_schema(), required=True)\n    ```\n\n    Args:\n        schema: The schema to use for the field\n        required: Whether the field is required\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='typed-dict-field',\n        schema=schema,\n        required=required,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        metadata=metadata,\n    )\n\n\nclass TypedDictSchema(TypedDict, total=False):\n    type: Required[Literal['typed-dict']]\n    fields: Required[Dict[str, TypedDictField]]\n    computed_fields: List[ComputedField]\n    strict: bool\n    extras_schema: CoreSchema\n    # all these values can be set via config, equivalent fields have `typed_dict_` prefix\n    extra_behavior: ExtraBehavior\n    total: bool  # default: True\n    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n    config: CoreConfig\n\n\ndef typed_dict_schema(\n    fields: Dict[str, TypedDictField],\n    *,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    total: bool | None = None,\n    populate_by_name: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n    config: CoreConfig | None = None,\n) -> TypedDictSchema:\n    \"\"\"\n    Returns a schema that matches a typed dict, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    wrapper_schema = core_schema.typed_dict_schema(\n        {'a': core_schema.typed_dict_field(core_schema.str_schema())}\n    )\n    v = SchemaValidator(wrapper_schema)\n    assert v.validate_python({'a': 'hello'}) == {'a': 'hello'}\n    ```\n\n    Args:\n        fields: The fields to use for the typed dict\n        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model\n        strict: Whether the typed dict is strict\n        extras_schema: The extra validator to use for the typed dict\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        extra_behavior: The extra behavior to use for the typed dict\n        total: Whether the typed dict is total\n        populate_by_name: Whether the typed dict should populate by name\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='typed-dict',\n        fields=fields,\n        computed_fields=computed_fields,\n        strict=strict,\n        extras_schema=extras_schema,\n        extra_behavior=extra_behavior,\n        total=total,\n        populate_by_name=populate_by_name,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        config=config,\n    )\n\n\nclass ModelField(TypedDict, total=False):\n    type: Required[Literal['model-field']]\n    schema: Required[CoreSchema]\n    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]\n    serialization_alias: str\n    serialization_exclude: bool  # default: False\n    frozen: bool\n    metadata: Any\n\n\ndef model_field(\n    schema: CoreSchema,\n    *,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    frozen: bool | None = None,\n    metadata: Any = None,\n) -> ModelField:\n    \"\"\"\n    Returns a schema for a model field, e.g.:\n\n    ```py\n    from pydantic_core import core_schema\n\n    field = core_schema.model_field(schema=core_schema.int_schema())\n    ```\n\n    Args:\n        schema: The schema to use for the field\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        frozen: Whether the field is frozen\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n    \"\"\"\n    return _dict_not_none(\n        type='model-field',\n        schema=schema,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        frozen=frozen,\n        metadata=metadata,\n    )\n\n\nclass ModelFieldsSchema(TypedDict, total=False):\n    type: Required[Literal['model-fields']]\n    fields: Required[Dict[str, ModelField]]\n    model_name: str\n    computed_fields: List[ComputedField]\n    strict: bool\n    extras_schema: CoreSchema\n    # all these values can be set via config, equivalent fields have `typed_dict_` prefix\n    extra_behavior: ExtraBehavior\n    populate_by_name: bool  # replaces `allow_population_by_field_name` in pydantic v1\n    from_attributes: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef model_fields_schema(\n    fields: Dict[str, ModelField],\n    *,\n    model_name: str | None = None,\n    computed_fields: list[ComputedField] | None = None,\n    strict: bool | None = None,\n    extras_schema: CoreSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    populate_by_name: bool | None = None,\n    from_attributes: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> ModelFieldsSchema:\n    \"\"\"\n    Returns a schema that matches a typed dict, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    wrapper_schema = core_schema.model_fields_schema(\n        {'a': core_schema.model_field(core_schema.str_schema())}\n    )\n    v = SchemaValidator(wrapper_schema)\n    print(v.validate_python({'a': 'hello'}))\n    #> ({'a': 'hello'}, None, {'a'})\n    ```\n\n    Args:\n        fields: The fields to use for the typed dict\n        model_name: The name of the model, used for error messages, defaults to \"Model\"\n        computed_fields: Computed fields to use when serializing the model, only applies when directly inside a model\n        strict: Whether the typed dict is strict\n        extras_schema: The extra validator to use for the typed dict\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        extra_behavior: The extra behavior to use for the typed dict\n        populate_by_name: Whether the typed dict should populate by name\n        from_attributes: Whether the typed dict should be populated from attributes\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='model-fields',\n        fields=fields,\n        model_name=model_name,\n        computed_fields=computed_fields,\n        strict=strict,\n        extras_schema=extras_schema,\n        extra_behavior=extra_behavior,\n        populate_by_name=populate_by_name,\n        from_attributes=from_attributes,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass ModelSchema(TypedDict, total=False):\n    type: Required[Literal['model']]\n    cls: Required[Type[Any]]\n    schema: Required[CoreSchema]\n    custom_init: bool\n    root_model: bool\n    post_init: str\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']  # default: 'never'\n    strict: bool\n    frozen: bool\n    extra_behavior: ExtraBehavior\n    config: CoreConfig\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef model_schema(\n    cls: Type[Any],\n    schema: CoreSchema,\n    *,\n    custom_init: bool | None = None,\n    root_model: bool | None = None,\n    post_init: str | None = None,\n    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,\n    strict: bool | None = None,\n    frozen: bool | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n    config: CoreConfig | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> ModelSchema:\n    \"\"\"\n    A model schema generally contains a typed-dict schema.\n    It will run the typed dict validator, then create a new class\n    and set the dict and fields set returned from the typed dict validator\n    to `__dict__` and `__pydantic_fields_set__` respectively.\n\n    Example:\n\n    ```py\n    from pydantic_core import CoreConfig, SchemaValidator, core_schema\n\n    class MyModel:\n        __slots__ = (\n            '__dict__',\n            '__pydantic_fields_set__',\n            '__pydantic_extra__',\n            '__pydantic_private__',\n        )\n\n    schema = core_schema.model_schema(\n        cls=MyModel,\n        config=CoreConfig(str_max_length=5),\n        schema=core_schema.model_fields_schema(\n            fields={'a': core_schema.model_field(core_schema.str_schema())},\n        ),\n    )\n    v = SchemaValidator(schema)\n    assert v.isinstance_python({'a': 'hello'}) is True\n    assert v.isinstance_python({'a': 'too long'}) is False\n    ```\n\n    Args:\n        cls: The class to use for the model\n        schema: The schema to use for the model\n        custom_init: Whether the model has a custom init method\n        root_model: Whether the model is a `RootModel`\n        post_init: The call after init to use for the model\n        revalidate_instances: whether instances of models and dataclasses (including subclass instances)\n            should re-validate defaults to config.revalidate_instances, else 'never'\n        strict: Whether the model is strict\n        frozen: Whether the model is frozen\n        extra_behavior: The extra behavior to use for the model, used in serialization\n        config: The config to use for the model\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='model',\n        cls=cls,\n        schema=schema,\n        custom_init=custom_init,\n        root_model=root_model,\n        post_init=post_init,\n        revalidate_instances=revalidate_instances,\n        strict=strict,\n        frozen=frozen,\n        extra_behavior=extra_behavior,\n        config=config,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass DataclassField(TypedDict, total=False):\n    type: Required[Literal['dataclass-field']]\n    name: Required[str]\n    schema: Required[CoreSchema]\n    kw_only: bool  # default: True\n    init: bool  # default: True\n    init_only: bool  # default: False\n    frozen: bool  # default: False\n    validation_alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]\n    serialization_alias: str\n    serialization_exclude: bool  # default: False\n    metadata: Any\n\n\ndef dataclass_field(\n    name: str,\n    schema: CoreSchema,\n    *,\n    kw_only: bool | None = None,\n    init: bool | None = None,\n    init_only: bool | None = None,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    metadata: Any = None,\n    frozen: bool | None = None,\n) -> DataclassField:\n    \"\"\"\n    Returns a schema for a dataclass field, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    field = core_schema.dataclass_field(\n        name='a', schema=core_schema.str_schema(), kw_only=False\n    )\n    schema = core_schema.dataclass_args_schema('Foobar', [field])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hello'}) == ({'a': 'hello'}, None)\n    ```\n\n    Args:\n        name: The name to use for the argument parameter\n        schema: The schema to use for the argument parameter\n        kw_only: Whether the field can be set with a positional argument as well as a keyword argument\n        init: Whether the field should be validated during initialization\n        init_only: Whether the field should be omitted  from `__dict__` and passed to `__post_init__`\n        validation_alias: The alias(es) to use to find the field in the validation data\n        serialization_alias: The alias to use as a key when serializing\n        serialization_exclude: Whether to exclude the field when serializing\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        frozen: Whether the field is frozen\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass-field',\n        name=name,\n        schema=schema,\n        kw_only=kw_only,\n        init=init,\n        init_only=init_only,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        serialization_exclude=serialization_exclude,\n        metadata=metadata,\n        frozen=frozen,\n    )\n\n\nclass DataclassArgsSchema(TypedDict, total=False):\n    type: Required[Literal['dataclass-args']]\n    dataclass_name: Required[str]\n    fields: Required[List[DataclassField]]\n    computed_fields: List[ComputedField]\n    populate_by_name: bool  # default: False\n    collect_init_only: bool  # default: False\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n    extra_behavior: ExtraBehavior\n\n\ndef dataclass_args_schema(\n    dataclass_name: str,\n    fields: list[DataclassField],\n    *,\n    computed_fields: List[ComputedField] | None = None,\n    populate_by_name: bool | None = None,\n    collect_init_only: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n    extra_behavior: ExtraBehavior | None = None,\n) -> DataclassArgsSchema:\n    \"\"\"\n    Returns a schema for validating dataclass arguments, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    field_a = core_schema.dataclass_field(\n        name='a', schema=core_schema.str_schema(), kw_only=False\n    )\n    field_b = core_schema.dataclass_field(\n        name='b', schema=core_schema.bool_schema(), kw_only=False\n    )\n    schema = core_schema.dataclass_args_schema('Foobar', [field_a, field_b])\n    v = SchemaValidator(schema)\n    assert v.validate_python({'a': 'hello', 'b': True}) == ({'a': 'hello', 'b': True}, None)\n    ```\n\n    Args:\n        dataclass_name: The name of the dataclass being validated\n        fields: The fields to use for the dataclass\n        computed_fields: Computed fields to use when serializing the dataclass\n        populate_by_name: Whether to populate by name\n        collect_init_only: Whether to collect init only fields into a dict to pass to `__post_init__`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n        extra_behavior: How to handle extra fields\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass-args',\n        dataclass_name=dataclass_name,\n        fields=fields,\n        computed_fields=computed_fields,\n        populate_by_name=populate_by_name,\n        collect_init_only=collect_init_only,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        extra_behavior=extra_behavior,\n    )\n\n\nclass DataclassSchema(TypedDict, total=False):\n    type: Required[Literal['dataclass']]\n    cls: Required[Type[Any]]\n    schema: Required[CoreSchema]\n    fields: Required[List[str]]\n    cls_name: str\n    post_init: bool  # default: False\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']  # default: 'never'\n    strict: bool  # default: False\n    frozen: bool  # default False\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n    slots: bool\n    config: CoreConfig\n\n\ndef dataclass_schema(\n    cls: Type[Any],\n    schema: CoreSchema,\n    fields: List[str],\n    *,\n    cls_name: str | None = None,\n    post_init: bool | None = None,\n    revalidate_instances: Literal['always', 'never', 'subclass-instances'] | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n    frozen: bool | None = None,\n    slots: bool | None = None,\n    config: CoreConfig | None = None,\n) -> DataclassSchema:\n    \"\"\"\n    Returns a schema for a dataclass. As with `ModelSchema`, this schema can only be used as a field within\n    another schema, not as the root type.\n\n    Args:\n        cls: The dataclass type, used to perform subclass checks\n        schema: The schema to use for the dataclass fields\n        fields: Fields of the dataclass, this is used in serialization and in validation during re-validation\n            and while validating assignment\n        cls_name: The name to use in error locs, etc; this is useful for generics (default: `cls.__name__`)\n        post_init: Whether to call `__post_init__` after validation\n        revalidate_instances: whether instances of models and dataclasses (including subclass instances)\n            should re-validate defaults to config.revalidate_instances, else 'never'\n        strict: Whether to require an exact instance of `cls`\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n        frozen: Whether the dataclass is frozen\n        slots: Whether `slots=True` on the dataclass, means each field is assigned independently, rather than\n            simply setting `__dict__`, default false\n    \"\"\"\n    return _dict_not_none(\n        type='dataclass',\n        cls=cls,\n        fields=fields,\n        cls_name=cls_name,\n        schema=schema,\n        post_init=post_init,\n        revalidate_instances=revalidate_instances,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n        frozen=frozen,\n        slots=slots,\n        config=config,\n    )\n\n\nclass ArgumentsParameter(TypedDict, total=False):\n    name: Required[str]\n    schema: Required[CoreSchema]\n    mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only']  # default positional_or_keyword\n    alias: Union[str, List[Union[str, int]], List[List[Union[str, int]]]]\n\n\ndef arguments_parameter(\n    name: str,\n    schema: CoreSchema,\n    *,\n    mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,\n    alias: str | list[str | int] | list[list[str | int]] | None = None,\n) -> ArgumentsParameter:\n    \"\"\"\n    Returns a schema that matches an argument parameter, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    schema = core_schema.arguments_schema([param])\n    v = SchemaValidator(schema)\n    assert v.validate_python(('hello',)) == (('hello',), {})\n    ```\n\n    Args:\n        name: The name to use for the argument parameter\n        schema: The schema to use for the argument parameter\n        mode: The mode to use for the argument parameter\n        alias: The alias to use for the argument parameter\n    \"\"\"\n    return _dict_not_none(name=name, schema=schema, mode=mode, alias=alias)\n\n\nclass ArgumentsSchema(TypedDict, total=False):\n    type: Required[Literal['arguments']]\n    arguments_schema: Required[List[ArgumentsParameter]]\n    populate_by_name: bool\n    var_args_schema: CoreSchema\n    var_kwargs_schema: CoreSchema\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef arguments_schema(\n    arguments: list[ArgumentsParameter],\n    *,\n    populate_by_name: bool | None = None,\n    var_args_schema: CoreSchema | None = None,\n    var_kwargs_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> ArgumentsSchema:\n    \"\"\"\n    Returns a schema that matches an arguments schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param_a = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    param_b = core_schema.arguments_parameter(\n        name='b', schema=core_schema.bool_schema(), mode='positional_only'\n    )\n    schema = core_schema.arguments_schema([param_a, param_b])\n    v = SchemaValidator(schema)\n    assert v.validate_python(('hello', True)) == (('hello', True), {})\n    ```\n\n    Args:\n        arguments: The arguments to use for the arguments schema\n        populate_by_name: Whether to populate by name\n        var_args_schema: The variable args schema to use for the arguments schema\n        var_kwargs_schema: The variable kwargs schema to use for the arguments schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='arguments',\n        arguments_schema=arguments,\n        populate_by_name=populate_by_name,\n        var_args_schema=var_args_schema,\n        var_kwargs_schema=var_kwargs_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass CallSchema(TypedDict, total=False):\n    type: Required[Literal['call']]\n    arguments_schema: Required[CoreSchema]\n    function: Required[Callable[..., Any]]\n    function_name: str  # default function.__name__\n    return_schema: CoreSchema\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef call_schema(\n    arguments: CoreSchema,\n    function: Callable[..., Any],\n    *,\n    function_name: str | None = None,\n    return_schema: CoreSchema | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> CallSchema:\n    \"\"\"\n    Returns a schema that matches an arguments schema, then calls a function, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    param_a = core_schema.arguments_parameter(\n        name='a', schema=core_schema.str_schema(), mode='positional_only'\n    )\n    param_b = core_schema.arguments_parameter(\n        name='b', schema=core_schema.bool_schema(), mode='positional_only'\n    )\n    args_schema = core_schema.arguments_schema([param_a, param_b])\n\n    schema = core_schema.call_schema(\n        arguments=args_schema,\n        function=lambda a, b: a + str(not b),\n        return_schema=core_schema.str_schema(),\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python((('hello', True))) == 'helloFalse'\n    ```\n\n    Args:\n        arguments: The arguments to use for the arguments schema\n        function: The function to use for the call schema\n        function_name: The function name to use for the call schema, if not provided `function.__name__` is used\n        return_schema: The return schema to use for the call schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='call',\n        arguments_schema=arguments,\n        function=function,\n        function_name=function_name,\n        return_schema=return_schema,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass CustomErrorSchema(TypedDict, total=False):\n    type: Required[Literal['custom-error']]\n    schema: Required[CoreSchema]\n    custom_error_type: Required[str]\n    custom_error_message: str\n    custom_error_context: Dict[str, Union[str, int, float]]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef custom_error_schema(\n    schema: CoreSchema,\n    custom_error_type: str,\n    *,\n    custom_error_message: str | None = None,\n    custom_error_context: dict[str, Any] | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> CustomErrorSchema:\n    \"\"\"\n    Returns a schema that matches a custom error value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.custom_error_schema(\n        schema=core_schema.int_schema(),\n        custom_error_type='MyError',\n        custom_error_message='Error msg',\n    )\n    v = SchemaValidator(schema)\n    v.validate_python(1)\n    ```\n\n    Args:\n        schema: The schema to use for the custom error schema\n        custom_error_type: The custom error type to use for the custom error schema\n        custom_error_message: The custom error message to use for the custom error schema\n        custom_error_context: The custom error context to use for the custom error schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='custom-error',\n        schema=schema,\n        custom_error_type=custom_error_type,\n        custom_error_message=custom_error_message,\n        custom_error_context=custom_error_context,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass JsonSchema(TypedDict, total=False):\n    type: Required[Literal['json']]\n    schema: CoreSchema\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef json_schema(\n    schema: CoreSchema | None = None,\n    *,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> JsonSchema:\n    \"\"\"\n    Returns a schema that matches a JSON value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    dict_schema = core_schema.model_fields_schema(\n        {\n            'field_a': core_schema.model_field(core_schema.str_schema()),\n            'field_b': core_schema.model_field(core_schema.bool_schema()),\n        },\n    )\n\n    class MyModel:\n        __slots__ = (\n            '__dict__',\n            '__pydantic_fields_set__',\n            '__pydantic_extra__',\n            '__pydantic_private__',\n        )\n        field_a: str\n        field_b: bool\n\n    json_schema = core_schema.json_schema(schema=dict_schema)\n    schema = core_schema.model_schema(cls=MyModel, schema=json_schema)\n    v = SchemaValidator(schema)\n    m = v.validate_python('{\"field_a\": \"hello\", \"field_b\": true}')\n    assert isinstance(m, MyModel)\n    ```\n\n    Args:\n        schema: The schema to use for the JSON schema\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(type='json', schema=schema, ref=ref, metadata=metadata, serialization=serialization)\n\n\nclass UrlSchema(TypedDict, total=False):\n    type: Required[Literal['url']]\n    max_length: int\n    allowed_schemes: List[str]\n    host_required: bool  # default False\n    default_host: str\n    default_port: int\n    default_path: str\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef url_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> UrlSchema:\n    \"\"\"\n    Returns a schema that matches a URL value, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.url_schema()\n    v = SchemaValidator(schema)\n    print(v.validate_python('https://example.com'))\n    #> https://example.com/\n    ```\n\n    Args:\n        max_length: The maximum length of the URL\n        allowed_schemes: The allowed URL schemes\n        host_required: Whether the URL must have a host\n        default_host: The default host to use if the URL does not have a host\n        default_port: The default port to use if the URL does not have a port\n        default_path: The default path to use if the URL does not have a path\n        strict: Whether to use strict URL parsing\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='url',\n        max_length=max_length,\n        allowed_schemes=allowed_schemes,\n        host_required=host_required,\n        default_host=default_host,\n        default_port=default_port,\n        default_path=default_path,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass MultiHostUrlSchema(TypedDict, total=False):\n    type: Required[Literal['multi-host-url']]\n    max_length: int\n    allowed_schemes: List[str]\n    host_required: bool  # default False\n    default_host: str\n    default_port: int\n    default_path: str\n    strict: bool\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef multi_host_url_schema(\n    *,\n    max_length: int | None = None,\n    allowed_schemes: list[str] | None = None,\n    host_required: bool | None = None,\n    default_host: str | None = None,\n    default_port: int | None = None,\n    default_path: str | None = None,\n    strict: bool | None = None,\n    ref: str | None = None,\n    metadata: Any = None,\n    serialization: SerSchema | None = None,\n) -> MultiHostUrlSchema:\n    \"\"\"\n    Returns a schema that matches a URL value with possibly multiple hosts, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.multi_host_url_schema()\n    v = SchemaValidator(schema)\n    print(v.validate_python('redis://localhost,0.0.0.0,127.0.0.1'))\n    #> redis://localhost,0.0.0.0,127.0.0.1\n    ```\n\n    Args:\n        max_length: The maximum length of the URL\n        allowed_schemes: The allowed URL schemes\n        host_required: Whether the URL must have a host\n        default_host: The default host to use if the URL does not have a host\n        default_port: The default port to use if the URL does not have a port\n        default_path: The default path to use if the URL does not have a path\n        strict: Whether to use strict URL parsing\n        ref: optional unique identifier of the schema, used to reference the schema in other places\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='multi-host-url',\n        max_length=max_length,\n        allowed_schemes=allowed_schemes,\n        host_required=host_required,\n        default_host=default_host,\n        default_port=default_port,\n        default_path=default_path,\n        strict=strict,\n        ref=ref,\n        metadata=metadata,\n        serialization=serialization,\n    )\n\n\nclass DefinitionsSchema(TypedDict, total=False):\n    type: Required[Literal['definitions']]\n    schema: Required[CoreSchema]\n    definitions: Required[List[CoreSchema]]\n    metadata: Any\n    serialization: SerSchema\n\n\ndef definitions_schema(schema: CoreSchema, definitions: list[CoreSchema]) -> DefinitionsSchema:\n    \"\"\"\n    Build a schema that contains both an inner schema and a list of definitions which can be used\n    within the inner schema.\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema = core_schema.definitions_schema(\n        core_schema.list_schema(core_schema.definition_reference_schema('foobar')),\n        [core_schema.int_schema(ref='foobar')],\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python([1, 2, '3']) == [1, 2, 3]\n    ```\n\n    Args:\n        schema: The inner schema\n        definitions: List of definitions which can be referenced within inner schema\n    \"\"\"\n    return DefinitionsSchema(type='definitions', schema=schema, definitions=definitions)\n\n\nclass DefinitionReferenceSchema(TypedDict, total=False):\n    type: Required[Literal['definition-ref']]\n    schema_ref: Required[str]\n    ref: str\n    metadata: Any\n    serialization: SerSchema\n\n\ndef definition_reference_schema(\n    schema_ref: str, ref: str | None = None, metadata: Any = None, serialization: SerSchema | None = None\n) -> DefinitionReferenceSchema:\n    \"\"\"\n    Returns a schema that points to a schema stored in \"definitions\", this is useful for nested recursive\n    models and also when you want to define validators separately from the main schema, e.g.:\n\n    ```py\n    from pydantic_core import SchemaValidator, core_schema\n\n    schema_definition = core_schema.definition_reference_schema('list-schema')\n    schema = core_schema.definitions_schema(\n        schema=schema_definition,\n        definitions=[\n            core_schema.list_schema(items_schema=schema_definition, ref='list-schema'),\n        ],\n    )\n    v = SchemaValidator(schema)\n    assert v.validate_python([()]) == [[]]\n    ```\n\n    Args:\n        schema_ref: The schema ref to use for the definition reference schema\n        metadata: Any other information you want to include with the schema, not used by pydantic-core\n        serialization: Custom serialization schema\n    \"\"\"\n    return _dict_not_none(\n        type='definition-ref', schema_ref=schema_ref, ref=ref, metadata=metadata, serialization=serialization\n    )\n\n\nMYPY = False\n# See https://github.com/python/mypy/issues/14034 for details, in summary mypy is extremely slow to process this\n# union which kills performance not just for pydantic, but even for code using pydantic\nif not MYPY:\n    CoreSchema = Union[\n        AnySchema,\n        NoneSchema,\n        BoolSchema,\n        IntSchema,\n        FloatSchema,\n        DecimalSchema,\n        StringSchema,\n        BytesSchema,\n        DateSchema,\n        TimeSchema,\n        DatetimeSchema,\n        TimedeltaSchema,\n        LiteralSchema,\n        EnumSchema,\n        IsInstanceSchema,\n        IsSubclassSchema,\n        CallableSchema,\n        ListSchema,\n        TupleSchema,\n        SetSchema,\n        FrozenSetSchema,\n        GeneratorSchema,\n        DictSchema,\n        AfterValidatorFunctionSchema,\n        BeforeValidatorFunctionSchema,\n        WrapValidatorFunctionSchema,\n        PlainValidatorFunctionSchema,\n        WithDefaultSchema,\n        NullableSchema,\n        UnionSchema,\n        TaggedUnionSchema,\n        ChainSchema,\n        LaxOrStrictSchema,\n        JsonOrPythonSchema,\n        TypedDictSchema,\n        ModelFieldsSchema,\n        ModelSchema,\n        DataclassArgsSchema,\n        DataclassSchema,\n        ArgumentsSchema,\n        CallSchema,\n        CustomErrorSchema,\n        JsonSchema,\n        UrlSchema,\n        MultiHostUrlSchema,\n        DefinitionsSchema,\n        DefinitionReferenceSchema,\n        UuidSchema,\n    ]\nelif False:\n    CoreSchema: TypeAlias = Mapping[str, Any]\n\n\n# to update this, call `pytest -k test_core_schema_type_literal` and copy the output\nCoreSchemaType = Literal[\n    'any',\n    'none',\n    'bool',\n    'int',\n    'float',\n    'decimal',\n    'str',\n    'bytes',\n    'date',\n    'time',\n    'datetime',\n    'timedelta',\n    'literal',\n    'enum',\n    'is-instance',\n    'is-subclass',\n    'callable',\n    'list',\n    'tuple',\n    'set',\n    'frozenset',\n    'generator',\n    'dict',\n    'function-after',\n    'function-before',\n    'function-wrap',\n    'function-plain',\n    'default',\n    'nullable',\n    'union',\n    'tagged-union',\n    'chain',\n    'lax-or-strict',\n    'json-or-python',\n    'typed-dict',\n    'model-fields',\n    'model',\n    'dataclass-args',\n    'dataclass',\n    'arguments',\n    'call',\n    'custom-error',\n    'json',\n    'url',\n    'multi-host-url',\n    'definitions',\n    'definition-ref',\n    'uuid',\n]\n\nCoreSchemaFieldType = Literal['model-field', 'dataclass-field', 'typed-dict-field', 'computed-field']\n\n\n# used in _pydantic_core.pyi::PydanticKnownError\n# to update this, call `pytest -k test_all_errors` and copy the output\nErrorType = Literal[\n    'no_such_attribute',\n    'json_invalid',\n    'json_type',\n    'recursion_loop',\n    'missing',\n    'frozen_field',\n    'frozen_instance',\n    'extra_forbidden',\n    'invalid_key',\n    'get_attribute_error',\n    'model_type',\n    'model_attributes_type',\n    'dataclass_type',\n    'dataclass_exact_type',\n    'none_required',\n    'greater_than',\n    'greater_than_equal',\n    'less_than',\n    'less_than_equal',\n    'multiple_of',\n    'finite_number',\n    'too_short',\n    'too_long',\n    'iterable_type',\n    'iteration_error',\n    'string_type',\n    'string_sub_type',\n    'string_unicode',\n    'string_too_short',\n    'string_too_long',\n    'string_pattern_mismatch',\n    'enum',\n    'dict_type',\n    'mapping_type',\n    'list_type',\n    'tuple_type',\n    'set_type',\n    'bool_type',\n    'bool_parsing',\n    'int_type',\n    'int_parsing',\n    'int_parsing_size',\n    'int_from_float',\n    'float_type',\n    'float_parsing',\n    'bytes_type',\n    'bytes_too_short',\n    'bytes_too_long',\n    'value_error',\n    'assertion_error',\n    'literal_error',\n    'date_type',\n    'date_parsing',\n    'date_from_datetime_parsing',\n    'date_from_datetime_inexact',\n    'date_past',\n    'date_future',\n    'time_type',\n    'time_parsing',\n    'datetime_type',\n    'datetime_parsing',\n    'datetime_object_invalid',\n    'datetime_from_date_parsing',\n    'datetime_past',\n    'datetime_future',\n    'timezone_naive',\n    'timezone_aware',\n    'timezone_offset',\n    'time_delta_type',\n    'time_delta_parsing',\n    'frozen_set_type',\n    'is_instance_of',\n    'is_subclass_of',\n    'callable_type',\n    'union_tag_invalid',\n    'union_tag_not_found',\n    'arguments_type',\n    'missing_argument',\n    'unexpected_keyword_argument',\n    'missing_keyword_only_argument',\n    'unexpected_positional_argument',\n    'missing_positional_only_argument',\n    'multiple_argument_values',\n    'url_type',\n    'url_parsing',\n    'url_syntax_violation',\n    'url_too_long',\n    'url_scheme',\n    'uuid_type',\n    'uuid_parsing',\n    'uuid_version',\n    'decimal_type',\n    'decimal_parsing',\n    'decimal_max_digits',\n    'decimal_max_places',\n    'decimal_whole_digits',\n]\n\n\ndef _dict_not_none(**kwargs: Any) -> Any:\n    return {k: v for k, v in kwargs.items() if v is not None}\n\n\n###############################################################################\n# All this stuff is deprecated by #980 and will be removed eventually\n# They're kept because some code external code will be using them\n\n\n@deprecated('`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.')\ndef field_before_validator_function(function: WithInfoValidatorFunction, field_name: str, schema: CoreSchema, **kwargs):\n    warnings.warn(\n        '`field_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_before_validator_function(function, schema, field_name=field_name, **kwargs)\n\n\n@deprecated('`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.')\ndef general_before_validator_function(*args, **kwargs):\n    warnings.warn(\n        '`general_before_validator_function` is deprecated, use `with_info_before_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_before_validator_function(*args, **kwargs)\n\n\n@deprecated('`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.')\ndef field_after_validator_function(function: WithInfoValidatorFunction, field_name: str, schema: CoreSchema, **kwargs):\n    warnings.warn(\n        '`field_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_after_validator_function(function, schema, field_name=field_name, **kwargs)\n\n\n@deprecated('`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.')\ndef general_after_validator_function(*args, **kwargs):\n    warnings.warn(\n        '`general_after_validator_function` is deprecated, use `with_info_after_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_after_validator_function(*args, **kwargs)\n\n\n@deprecated('`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.')\ndef field_wrap_validator_function(\n    function: WithInfoWrapValidatorFunction, field_name: str, schema: CoreSchema, **kwargs\n):\n    warnings.warn(\n        '`field_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_wrap_validator_function(function, schema, field_name=field_name, **kwargs)\n\n\n@deprecated('`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.')\ndef general_wrap_validator_function(*args, **kwargs):\n    warnings.warn(\n        '`general_wrap_validator_function` is deprecated, use `with_info_wrap_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_wrap_validator_function(*args, **kwargs)\n\n\n@deprecated('`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.')\ndef field_plain_validator_function(function: WithInfoValidatorFunction, field_name: str, **kwargs):\n    warnings.warn(\n        '`field_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_plain_validator_function(function, field_name=field_name, **kwargs)\n\n\n@deprecated('`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.')\ndef general_plain_validator_function(*args, **kwargs):\n    warnings.warn(\n        '`general_plain_validator_function` is deprecated, use `with_info_plain_validator_function` instead.',\n        DeprecationWarning,\n    )\n    return with_info_plain_validator_function(*args, **kwargs)\n\n\n_deprecated_import_lookup = {\n    'FieldValidationInfo': ValidationInfo,\n    'FieldValidatorFunction': WithInfoValidatorFunction,\n    'GeneralValidatorFunction': WithInfoValidatorFunction,\n    'FieldWrapValidatorFunction': WithInfoWrapValidatorFunction,\n}\n\nif TYPE_CHECKING:\n    FieldValidationInfo = ValidationInfo\n\n\ndef __getattr__(attr_name: str) -> object:\n    new_attr = _deprecated_import_lookup.get(attr_name)\n    if new_attr is None:\n        raise AttributeError(f\"module 'pydantic_core' has no attribute '{attr_name}'\")\n    else:\n        import warnings\n\n        msg = f'`{attr_name}` is deprecated, use `{new_attr.__name__}` instead.'\n        warnings.warn(msg, DeprecationWarning, stacklevel=1)\n        return new_attr\n", "python/pydantic_core/__init__.py": "from __future__ import annotations\n\nimport sys as _sys\nfrom typing import Any as _Any\n\nfrom ._pydantic_core import (\n    ArgsKwargs,\n    MultiHostUrl,\n    PydanticCustomError,\n    PydanticKnownError,\n    PydanticOmit,\n    PydanticSerializationError,\n    PydanticSerializationUnexpectedValue,\n    PydanticUndefined,\n    PydanticUndefinedType,\n    PydanticUseDefault,\n    SchemaError,\n    SchemaSerializer,\n    SchemaValidator,\n    Some,\n    TzInfo,\n    Url,\n    ValidationError,\n    __version__,\n    from_json,\n    to_json,\n    to_jsonable_python,\n    validate_core_schema,\n)\nfrom .core_schema import CoreConfig, CoreSchema, CoreSchemaType, ErrorType\n\nif _sys.version_info < (3, 11):\n    from typing_extensions import NotRequired as _NotRequired\nelse:\n    from typing import NotRequired as _NotRequired\n\nif _sys.version_info < (3, 9):\n    from typing_extensions import TypedDict as _TypedDict\nelse:\n    from typing import TypedDict as _TypedDict\n\n__all__ = [\n    '__version__',\n    'CoreConfig',\n    'CoreSchema',\n    'CoreSchemaType',\n    'SchemaValidator',\n    'SchemaSerializer',\n    'Some',\n    'Url',\n    'MultiHostUrl',\n    'ArgsKwargs',\n    'PydanticUndefined',\n    'PydanticUndefinedType',\n    'SchemaError',\n    'ErrorDetails',\n    'InitErrorDetails',\n    'ValidationError',\n    'PydanticCustomError',\n    'PydanticKnownError',\n    'PydanticOmit',\n    'PydanticUseDefault',\n    'PydanticSerializationError',\n    'PydanticSerializationUnexpectedValue',\n    'TzInfo',\n    'to_json',\n    'from_json',\n    'to_jsonable_python',\n    'validate_core_schema',\n]\n\n\nclass ErrorDetails(_TypedDict):\n    type: str\n    \"\"\"\n    The type of error that occurred, this is an identifier designed for\n    programmatic use that will change rarely or never.\n\n    `type` is unique for each error message, and can hence be used as an identifier to build custom error messages.\n    \"\"\"\n    loc: tuple[int | str, ...]\n    \"\"\"Tuple of strings and ints identifying where in the schema the error occurred.\"\"\"\n    msg: str\n    \"\"\"A human readable error message.\"\"\"\n    input: _Any\n    \"\"\"The input data at this `loc` that caused the error.\"\"\"\n    ctx: _NotRequired[dict[str, _Any]]\n    \"\"\"\n    Values which are required to render the error message, and could hence be useful in rendering custom error messages.\n    Also useful for passing custom error data forward.\n    \"\"\"\n\n\nclass InitErrorDetails(_TypedDict):\n    type: str | PydanticCustomError\n    \"\"\"The type of error that occurred, this should a \"slug\" identifier that changes rarely or never.\"\"\"\n    loc: _NotRequired[tuple[int | str, ...]]\n    \"\"\"Tuple of strings and ints identifying where in the schema the error occurred.\"\"\"\n    input: _Any\n    \"\"\"The input data at this `loc` that caused the error.\"\"\"\n    ctx: _NotRequired[dict[str, _Any]]\n    \"\"\"\n    Values which are required to render the error message, and could hence be useful in rendering custom error messages.\n    Also useful for passing custom error data forward.\n    \"\"\"\n\n\nclass ErrorTypeInfo(_TypedDict):\n    \"\"\"\n    Gives information about errors.\n    \"\"\"\n\n    type: ErrorType\n    \"\"\"The type of error that occurred, this should a \"slug\" identifier that changes rarely or never.\"\"\"\n    message_template_python: str\n    \"\"\"String template to render a human readable error message from using context, when the input is Python.\"\"\"\n    example_message_python: str\n    \"\"\"Example of a human readable error message, when the input is Python.\"\"\"\n    message_template_json: _NotRequired[str]\n    \"\"\"String template to render a human readable error message from using context, when the input is JSON data.\"\"\"\n    example_message_json: _NotRequired[str]\n    \"\"\"Example of a human readable error message, when the input is JSON data.\"\"\"\n    example_context: dict[str, _Any] | None\n    \"\"\"Example of context values.\"\"\"\n\n\nclass MultiHostHost(_TypedDict):\n    \"\"\"\n    A host part of a multi-host URL.\n    \"\"\"\n\n    username: str | None\n    \"\"\"The username part of this host, or `None`.\"\"\"\n    password: str | None\n    \"\"\"The password part of this host, or `None`.\"\"\"\n    host: str | None\n    \"\"\"The host part of this host, or `None`.\"\"\"\n    port: int | None\n    \"\"\"The port part of this host, or `None`.\"\"\"\n", ".github/check_version.py": "#!/usr/bin/env python3\n\"\"\"\nCheck the version in Cargo.toml matches the version from `GITHUB_REF` environment variable.\n\"\"\"\nimport os\nimport re\nimport sys\nfrom pathlib import Path\n\n\ndef main() -> int:\n    cargo_path = Path('Cargo.toml')\n    if not cargo_path.is_file():\n        print(f'\u2716 path \"{cargo_path}\" does not exist')\n        return 1\n\n    version_ref = os.getenv('GITHUB_REF')\n    if version_ref:\n        version = re.sub('^refs/tags/v*', '', version_ref.lower())\n    else:\n        print(f'\u2716 \"GITHUB_REF\" env variables not found')\n        return 1\n\n    # convert from python pre-release version to rust pre-release version\n    # this is the reverse of what's done in lib.rs::_rust_notify\n    version = version.replace('a', '-alpha').replace('b', '-beta')\n\n    version_regex = re.compile(r\"\"\"^version ?= ?([\"'])(.+)\\1\"\"\", re.M)\n    cargo_content = cargo_path.read_text()\n    match = version_regex.search(cargo_content)\n    if not match:\n        print(f'\u2716 {version_regex!r} not found in {cargo_path}')\n        return 1\n\n    cargo_version = match.group(2)\n    if cargo_version == version:\n        print(f'\u2713 GITHUB_REF version matches {cargo_path} version \"{cargo_version}\"')\n        return 0\n    else:\n        print(f'\u2716 GITHUB_REF version \"{version}\" does not match {cargo_path} version \"{cargo_version}\"')\n        return 1\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n"}