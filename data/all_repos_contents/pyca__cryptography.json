{"release.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pathlib\nimport re\nimport subprocess\n\nimport click\nimport tomllib\nfrom packaging.version import Version\n\n\ndef run(*args: str) -> None:\n    print(f\"[running] {list(args)}\")\n    subprocess.check_call(list(args))\n\n\n@click.group()\ndef cli():\n    pass\n\n\n@cli.command()\ndef release() -> None:\n    base_dir = pathlib.Path(__file__).parent\n    with (base_dir / \"pyproject.toml\").open(\"rb\") as f:\n        pyproject = tomllib.load(f)\n        version = pyproject[\"project\"][\"version\"]\n\n    if Version(version).is_prerelease:\n        raise RuntimeError(\n            f\"Can't release, pyproject.toml version is pre-release: {version}\"\n        )\n\n    # Tag and push the tag (this will trigger the wheel builder in Actions)\n    run(\"git\", \"tag\", \"-s\", version, \"-m\", f\"{version} release\")\n    run(\"git\", \"push\", \"--tags\", \"git@github.com:pyca/cryptography.git\")\n\n\ndef replace_pattern(p: pathlib.Path, pattern: str, replacement: str) -> None:\n    content = p.read_text()\n    match = re.search(pattern, content, re.MULTILINE)\n    assert match is not None\n\n    start, end = match.span()\n    new_content = content[:start] + replacement + content[end:]\n    p.write_text(new_content)\n\n\ndef replace_version(\n    p: pathlib.Path, variable_name: str, new_version: str\n) -> None:\n    replace_pattern(\n        p, rf\"^{variable_name}\\s*=\\s*.*$\", f'{variable_name} = \"{new_version}\"'\n    )\n\n\n@cli.command()\n@click.argument(\"new_version\")\ndef bump_version(new_version: str) -> None:\n    base_dir = pathlib.Path(__file__).parent\n\n    replace_version(base_dir / \"pyproject.toml\", \"version\", new_version)\n    replace_version(\n        base_dir / \"src/cryptography/__about__.py\", \"__version__\", new_version\n    )\n    replace_version(\n        base_dir / \"vectors/pyproject.toml\",\n        \"version\",\n        new_version,\n    )\n    replace_version(\n        base_dir / \"vectors/cryptography_vectors/__about__.py\",\n        \"__version__\",\n        new_version,\n    )\n\n    if Version(new_version).is_prerelease:\n        replace_pattern(\n            base_dir / \"pyproject.toml\",\n            r'\"cryptography_vectors(==.*?)?\"',\n            '\"cryptography_vectors\"',\n        )\n    else:\n        replace_pattern(\n            base_dir / \"pyproject.toml\",\n            r'\"cryptography_vectors(==.*?)?\"',\n            f'\"cryptography_vectors=={new_version}\"',\n        )\n\n\nif __name__ == \"__main__\":\n    cli()\n", "noxfile.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport glob\nimport itertools\nimport json\nimport pathlib\nimport re\nimport sys\nimport uuid\n\nimport nox\n\ntry:\n    import tomllib\nexcept ImportError:\n    import tomli as tomllib  # type: ignore[import-not-found,no-redef]\n\nnox.options.reuse_existing_virtualenvs = True\n\n\ndef install(\n    session: nox.Session,\n    *args: str,\n    verbose: bool = True,\n) -> None:\n    if verbose:\n        args += (\"-v\",)\n    session.install(\n        \"-c\",\n        \"ci-constraints-requirements.txt\",\n        *args,\n        silent=False,\n    )\n\n\ndef load_pyproject_toml() -> dict:\n    with (pathlib.Path(__file__).parent / \"pyproject.toml\").open(\"rb\") as f:\n        return tomllib.load(f)\n\n\n@nox.session\n@nox.session(name=\"tests-ssh\")\n@nox.session(name=\"tests-randomorder\")\n@nox.session(name=\"tests-nocoverage\")\ndef tests(session: nox.Session) -> None:\n    extras = \"test\"\n    if session.name == \"tests-ssh\":\n        extras += \",ssh\"\n    if session.name == \"tests-randomorder\":\n        extras += \",test-randomorder\"\n\n    prof_location = (\n        pathlib.Path(\".\") / \".rust-cov\" / str(uuid.uuid4())\n    ).absolute()\n    if session.name != \"tests-nocoverage\":\n        session.env.update(\n            {\n                \"RUSTFLAGS\": \"-Cinstrument-coverage \"\n                + session.env.get(\"RUSTFLAGS\", \"\"),\n                \"LLVM_PROFILE_FILE\": str(prof_location / \"cov-%p.profraw\"),\n            }\n        )\n\n    install(session, f\".[{extras}]\")\n    install(session, \"-e\", \"./vectors\")\n\n    session.run(\"pip\", \"list\")\n\n    if session.name != \"tests-nocoverage\":\n        cov_args = [\n            \"--cov=cryptography\",\n            \"--cov=tests\",\n        ]\n    else:\n        cov_args = []\n\n    if session.posargs:\n        tests = session.posargs\n    else:\n        tests = [\"tests/\"]\n\n    session.run(\n        \"pytest\",\n        \"-n\",\n        \"auto\",\n        \"--dist=worksteal\",\n        *cov_args,\n        \"--durations=10\",\n        *tests,\n    )\n\n    if session.name != \"tests-nocoverage\":\n        [rust_so] = glob.glob(\n            f\"{session.virtualenv.location}/**/cryptography/hazmat/bindings/_rust.*\",\n            recursive=True,\n        )\n        process_rust_coverage(session, [rust_so], prof_location)\n\n\n@nox.session\ndef docs(session: nox.Session) -> None:\n    install(session, \".[docs,docstest,sdist,ssh]\")\n\n    temp_dir = session.create_tmp()\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"html\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"latex\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/latex\",\n    )\n\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"doctest\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"spelling\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n\n    session.run(\n        \"python3\", \"-m\", \"readme_renderer\", \"README.rst\", \"-o\", \"/dev/null\"\n    )\n\n\n@nox.session(name=\"docs-linkcheck\")\ndef docs_linkcheck(session: nox.Session) -> None:\n    install(session, \".[docs]\")\n\n    session.run(\n        \"sphinx-build\", \"-W\", \"-b\", \"linkcheck\", \"docs\", \"docs/_build/html\"\n    )\n\n\n@nox.session\ndef flake(session: nox.Session) -> None:\n    # TODO: Ideally there'd be a pip flag to install just our dependencies,\n    # but not install us.\n    pyproject_data = load_pyproject_toml()\n    install(\n        session,\n        *pyproject_data[\"build-system\"][\"requires\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"pep8test\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"test\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"ssh\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"nox\"],\n    )\n    install(session, \"-e\", \"vectors/\")\n\n    session.run(\"ruff\", \"check\", \".\")\n    session.run(\"ruff\", \"format\", \"--check\", \".\")\n    session.run(\n        \"mypy\",\n        \"src/cryptography/\",\n        \"vectors/cryptography_vectors/\",\n        \"tests/\",\n        \"release.py\",\n        \"noxfile.py\",\n    )\n    session.run(\"check-sdist\", \"--no-isolation\")\n\n\n@nox.session\n@nox.session(name=\"rust-noclippy\")\ndef rust(session: nox.Session) -> None:\n    prof_location = (\n        pathlib.Path(\".\") / \".rust-cov\" / str(uuid.uuid4())\n    ).absolute()\n    session.env.update(\n        {\n            \"RUSTFLAGS\": \"-Cinstrument-coverage  \"\n            + session.env.get(\"RUSTFLAGS\", \"\"),\n            \"LLVM_PROFILE_FILE\": str(prof_location / \"cov-%p.profraw\"),\n        }\n    )\n\n    # TODO: Ideally there'd be a pip flag to install just our dependencies,\n    # but not install us.\n    pyproject_data = load_pyproject_toml()\n    install(session, *pyproject_data[\"build-system\"][\"requires\"])\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\"cargo\", \"fmt\", \"--all\", \"--\", \"--check\", external=True)\n        if session.name != \"rust-noclippy\":\n            session.run(\n                \"cargo\",\n                \"clippy\",\n                \"--all\",\n                \"--\",\n                \"-D\",\n                \"warnings\",\n                external=True,\n            )\n\n        build_output = session.run(\n            \"cargo\",\n            \"test\",\n            \"--no-default-features\",\n            \"--all\",\n            \"--no-run\",\n            \"-q\",\n            \"--message-format=json\",\n            external=True,\n            silent=True,\n        )\n        session.run(\n            \"cargo\", \"test\", \"--no-default-features\", \"--all\", external=True\n        )\n\n    # It's None on install-only invocations\n    if build_output is not None:\n        assert isinstance(build_output, str)\n        rust_tests = []\n        for line in build_output.splitlines():\n            data = json.loads(line)\n            if data.get(\"profile\", {}).get(\"test\", False):\n                rust_tests.extend(data[\"filenames\"])\n\n        process_rust_coverage(session, rust_tests, prof_location)\n\n\n@nox.session(venv_backend=\"uv\")\ndef local(session):\n    pyproject_data = load_pyproject_toml()\n    test_dependencies = pyproject_data[\"project\"][\"optional-dependencies\"][\n        \"test\"\n    ]\n    test_dependencies.remove(\"cryptography_vectors\")\n    install(\n        session,\n        *pyproject_data[\"build-system\"][\"requires\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"pep8test\"],\n        *test_dependencies,\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"ssh\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"nox\"],\n        \"./vectors/\",\n        verbose=False,\n    )\n\n    session.run(\"ruff\", \"format\", \".\")\n    session.run(\"ruff\", \"check\", \".\")\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\"cargo\", \"fmt\", \"--all\", external=True)\n        session.run(\"cargo\", \"check\", \"--all\", \"--tests\", external=True)\n        session.run(\n            \"cargo\",\n            \"clippy\",\n            \"--all\",\n            \"--\",\n            \"-D\",\n            \"warnings\",\n            external=True,\n        )\n\n    session.run(\n        \"mypy\",\n        \"src/cryptography/\",\n        \"vectors/cryptography_vectors/\",\n        \"tests/\",\n        \"release.py\",\n        \"noxfile.py\",\n    )\n\n    install(\n        session,\n        # Needed until https://github.com/astral-sh/uv/issues/2152 is fixed\n        \"--reinstall-package\",\n        \"cryptography\",\n        \"--refresh-package\",\n        \"cryptography\",\n        \".\",\n    )\n\n    if session.posargs:\n        tests = session.posargs\n    else:\n        tests = [\"tests/\"]\n\n    session.run(\n        \"pytest\",\n        \"-n\",\n        \"auto\",\n        \"--dist=worksteal\",\n        \"--durations=10\",\n        *tests,\n    )\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\n            \"cargo\", \"test\", \"--no-default-features\", \"--all\", external=True\n        )\n\n\nLCOV_SOURCEFILE_RE = re.compile(\n    r\"^SF:.*[\\\\/]src[\\\\/]rust[\\\\/](.*)$\", flags=re.MULTILINE\n)\nBIN_EXT = \".exe\" if sys.platform == \"win32\" else \"\"\n\n\ndef process_rust_coverage(\n    session: nox.Session,\n    rust_binaries: list[str],\n    prof_raw_location: pathlib.Path,\n) -> None:\n    # Hitting weird issues merging Windows and Linux Rust coverage, so just\n    # say the hell with it.\n    if sys.platform == \"win32\":\n        return\n\n    target_libdir = session.run(\n        \"rustc\", \"--print\", \"target-libdir\", external=True, silent=True\n    )\n    if target_libdir is not None:\n        target_bindir = pathlib.Path(target_libdir).parent / \"bin\"\n\n        profraws = [\n            str(prof_raw_location / p)\n            for p in prof_raw_location.glob(\"*.profraw\")\n        ]\n        session.run(\n            str(target_bindir / (\"llvm-profdata\" + BIN_EXT)),\n            \"merge\",\n            \"-sparse\",\n            *profraws,\n            \"-o\",\n            \"rust-cov.profdata\",\n            external=True,\n        )\n\n        lcov_data = session.run(\n            str(target_bindir / (\"llvm-cov\" + BIN_EXT)),\n            \"export\",\n            rust_binaries[0],\n            *itertools.chain.from_iterable(\n                [\"-object\", b] for b in rust_binaries[1:]\n            ),\n            \"-instr-profile=rust-cov.profdata\",\n            \"--ignore-filename-regex=[/\\\\].cargo[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\]rustc[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\].rustup[/\\\\]toolchains[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\]target[/\\\\]\",\n            \"--format=lcov\",\n            silent=True,\n            external=True,\n        )\n        assert isinstance(lcov_data, str)\n        lcov_data = LCOV_SOURCEFILE_RE.sub(\n            lambda m: \"SF:src/rust/\" + m.group(1).replace(\"\\\\\", \"/\"),\n            lcov_data.replace(\"\\r\\n\", \"\\n\"),\n        )\n        with open(f\"{uuid.uuid4()}.lcov\", \"w\") as f:\n            f.write(lcov_data)\n", ".github/compare_benchmarks.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport json\nimport sys\n\n\ndef bench_data_as_dict(data):\n    return {d[\"fullname\"]: d[\"stats\"] for d in data[\"benchmarks\"]}\n\n\ndef main(base_bench_path, pr_bench_path):\n    with open(base_bench_path) as f:\n        base_bench_data = bench_data_as_dict(json.load(f))\n    with open(pr_bench_path) as f:\n        pr_bench_data = bench_data_as_dict(json.load(f))\n\n    print(\"| Benchmark | Base | PR | Delta |\")\n    print(\"| --------- | ---- | -- | ----- |\")\n    for bench_name in sorted(base_bench_data):\n        # TODO: use better statistics than just comparing medians\n        base_result = base_bench_data[bench_name][\"median\"]\n        pr_result = pr_bench_data[bench_name][\"median\"]\n\n        if base_result == pr_result:\n            # PR and base are identical\n            delta = \"--\"\n        elif base_result > pr_result:\n            # PR is faster than base\n            delta = f\"{100 - round(100 * pr_result / base_result)}% faster\"\n        else:\n            delta = f\"{100 - round(100 * base_result / pr_result)}% slower\"\n\n        print(\n            f\"| `{bench_name}` | {round(base_result * 1000 * 1000 * 1000, 2)} \"\n            f\"ns | {round(pr_result * 1000 * 1000 * 1000, 2)} ns | {delta} |\"\n        )\n\n\nif __name__ == \"__main__\":\n    main(*sys.argv[1:])\n", "src/_cffi_src/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nfrom cffi import FFI\n\n# Load the cryptography __about__ to get the current package version\nbase_src = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nabout: dict = {}\nwith open(os.path.join(base_src, \"cryptography\", \"__about__.py\")) as f:\n    exec(f.read(), about)\n\n\ndef build_ffi_for_binding(\n    module_name: str,\n    module_prefix: str,\n    modules: list[str],\n):\n    \"\"\"\n    Modules listed in ``modules`` should have the following attributes:\n\n    * ``INCLUDES``: A string containing C includes.\n    * ``TYPES``: A string containing C declarations for types.\n    * ``FUNCTIONS``: A string containing C declarations for functions & macros.\n    * ``CUSTOMIZATIONS``: A string containing arbitrary top-level C code, this\n        can be used to do things like test for a define and provide an\n        alternate implementation based on that.\n    \"\"\"\n    types = []\n    includes = []\n    functions = []\n    customizations = []\n    for name in modules:\n        __import__(module_prefix + name)\n        module = sys.modules[module_prefix + name]\n\n        types.append(module.TYPES)\n        functions.append(module.FUNCTIONS)\n        includes.append(module.INCLUDES)\n        customizations.append(module.CUSTOMIZATIONS)\n\n    verify_source = \"\\n\".join(includes + customizations)\n    return build_ffi(\n        module_name,\n        cdef_source=\"\\n\".join(types + functions),\n        verify_source=verify_source,\n    )\n\n\ndef build_ffi(\n    module_name: str,\n    cdef_source: str,\n    verify_source: str,\n):\n    ffi = FFI()\n    # Always add the CRYPTOGRAPHY_PACKAGE_VERSION to the shared object\n    cdef_source += \"\\nstatic const char *const CRYPTOGRAPHY_PACKAGE_VERSION;\"\n    verify_source += '\\n#define CRYPTOGRAPHY_PACKAGE_VERSION \"{}\"'.format(\n        about[\"__version__\"]\n    )\n    if platform.python_implementation() == \"PyPy\":\n        verify_source += r\"\"\"\nint Cryptography_make_openssl_module(void) {\n    int result;\n\n    Py_BEGIN_ALLOW_THREADS\n    result = cffi_start_python();\n    Py_END_ALLOW_THREADS\n\n    return result;\n}\n\"\"\"\n    ffi.cdef(cdef_source)\n    ffi.set_source(\n        module_name,\n        verify_source,\n    )\n    return ffi\n", "src/_cffi_src/__init__.py": "", "src/_cffi_src/build_openssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport pathlib\nimport platform\nimport sys\n\n# Add the src directory to the path so we can import _cffi_src.utils\nsrc_dir = str(pathlib.Path(__file__).parent.parent)\nsys.path.insert(0, src_dir)\n\nfrom _cffi_src.utils import build_ffi_for_binding  # noqa: E402\n\nffi = build_ffi_for_binding(\n    module_name=\"_openssl\",\n    module_prefix=\"_cffi_src.openssl.\",\n    modules=[\n        # This goes first so we can define some cryptography-wide symbols.\n        \"cryptography\",\n        \"asn1\",\n        \"bignum\",\n        \"bio\",\n        \"crypto\",\n        \"dh\",\n        \"dsa\",\n        \"ec\",\n        \"engine\",\n        \"err\",\n        \"evp\",\n        \"nid\",\n        \"objects\",\n        \"opensslv\",\n        \"pem\",\n        \"pkcs12\",\n        \"rand\",\n        \"rsa\",\n        \"ssl\",\n        \"x509\",\n        \"x509name\",\n        \"x509v3\",\n        \"x509_vfy\",\n        \"pkcs7\",\n    ],\n)\n\nif __name__ == \"__main__\":\n    out_dir = os.environ[\"OUT_DIR\"]\n    module_name, source, source_extension, kwds = ffi._assigned_source\n    c_file = os.path.join(out_dir, module_name + source_extension)\n    if platform.python_implementation() == \"PyPy\":\n        # Necessary because CFFI will ignore this if there's no declarations.\n        ffi.embedding_api(\n            \"\"\"\n            extern \"Python\" void Cryptography_unused(void);\n        \"\"\"\n        )\n        ffi.embedding_init_code(\"\")\n    ffi.emit_c_code(c_file)\n", "src/_cffi_src/openssl/engine.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/engine.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... ENGINE;\ntypedef ... UI_METHOD;\n\nstatic const long Cryptography_HAS_ENGINE;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nENGINE *ENGINE_by_id(const char *);\nint ENGINE_init(ENGINE *);\nint ENGINE_finish(ENGINE *);\nENGINE *ENGINE_get_default_RAND(void);\nint ENGINE_set_default_RAND(ENGINE *);\nvoid ENGINE_unregister_RAND(ENGINE *);\nint ENGINE_ctrl_cmd(ENGINE *, const char *, long, void *, void (*)(void), int);\nint ENGINE_free(ENGINE *);\nconst char *ENGINE_get_name(const ENGINE *);\n\n// These bindings are unused by cryptography or pyOpenSSL but are present\n// for advanced users who need them.\nint ENGINE_ctrl_cmd_string(ENGINE *, const char *, const char *, int);\nvoid ENGINE_load_builtin_engines(void);\nEVP_PKEY *ENGINE_load_private_key(ENGINE *, const char *, UI_METHOD *, void *);\nEVP_PKEY *ENGINE_load_public_key(ENGINE *, const char *, UI_METHOD *, void *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef OPENSSL_NO_ENGINE\nstatic const long Cryptography_HAS_ENGINE = 0;\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\ntypedef void UI_METHOD;\n#endif\n\n/* Despite being OPENSSL_NO_ENGINE, BoringSSL/LibreSSL define these symbols. */\n#if !CRYPTOGRAPHY_IS_BORINGSSL && !CRYPTOGRAPHY_IS_LIBRESSL\nint (*ENGINE_free)(ENGINE *) = NULL;\nvoid (*ENGINE_load_builtin_engines)(void) = NULL;\n#endif\n\nENGINE *(*ENGINE_get_default_RAND)(void) = NULL;\nint (*ENGINE_set_default_RAND)(ENGINE *) = NULL;\nvoid (*ENGINE_unregister_RAND)(ENGINE *) = NULL;\n\n#if !CRYPTOGRAPHY_IS_LIBRESSL\nENGINE *(*ENGINE_by_id)(const char *) = NULL;\nint (*ENGINE_init)(ENGINE *) = NULL;\nint (*ENGINE_finish)(ENGINE *) = NULL;\nint (*ENGINE_ctrl_cmd)(ENGINE *, const char *, long, void *,\n                       void (*)(void), int) = NULL;\n\nconst char *(*ENGINE_get_id)(const ENGINE *) = NULL;\nconst char *(*ENGINE_get_name)(const ENGINE *) = NULL;\n\nint (*ENGINE_ctrl_cmd_string)(ENGINE *, const char *, const char *,\n                              int) = NULL;\nEVP_PKEY *(*ENGINE_load_private_key)(ENGINE *, const char *, UI_METHOD *,\n                                     void *) = NULL;\nEVP_PKEY *(*ENGINE_load_public_key)(ENGINE *, const char *,\n                                    UI_METHOD *, void *) = NULL;\n#endif\n\n#else\nstatic const long Cryptography_HAS_ENGINE = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/asn1.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/asn1.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef int... time_t;\n\ntypedef ... ASN1_INTEGER;\n\nstruct asn1_string_st {\n    int length;\n    int type;\n    unsigned char *data;\n    long flags;\n};\n\ntypedef struct asn1_string_st ASN1_OCTET_STRING;\ntypedef struct asn1_string_st ASN1_IA5STRING;\ntypedef struct asn1_string_st ASN1_TIME;\ntypedef ... ASN1_OBJECT;\ntypedef struct asn1_string_st ASN1_STRING;\ntypedef struct asn1_string_st ASN1_UTF8STRING;\ntypedef ... ASN1_GENERALIZEDTIME;\ntypedef ... ASN1_ENUMERATED;\n\nstatic const int V_ASN1_GENERALIZEDTIME;\n\nstatic const int MBSTRING_UTF8;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n/*  ASN1 STRING */\nconst unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *);\n\n/*  ASN1 INTEGER */\nvoid ASN1_INTEGER_free(ASN1_INTEGER *);\nint ASN1_INTEGER_set(ASN1_INTEGER *, long);\n\n/*  ASN1 TIME */\nASN1_TIME *ASN1_TIME_new(void);\nvoid ASN1_TIME_free(ASN1_TIME *);\nint ASN1_TIME_set_string(ASN1_TIME *, const char *);\n\n/*  ASN1 GENERALIZEDTIME */\nvoid ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *);\n\n/*  ASN1 ENUMERATED */\nASN1_ENUMERATED *ASN1_ENUMERATED_new(void);\nvoid ASN1_ENUMERATED_free(ASN1_ENUMERATED *);\nint ASN1_ENUMERATED_set(ASN1_ENUMERATED *, long);\n\nint ASN1_STRING_type(const ASN1_STRING *);\nint ASN1_STRING_to_UTF8(unsigned char **, const ASN1_STRING *);\nint i2a_ASN1_INTEGER(BIO *, const ASN1_INTEGER *);\n\nASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *,\n                                                   ASN1_GENERALIZEDTIME **);\n\nint ASN1_STRING_length(ASN1_STRING *);\n\nBIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *, BIGNUM *);\nASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *, ASN1_INTEGER *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/opensslv.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/opensslv.h>\n\"\"\"\n\nTYPES = \"\"\"\n/* Note that these will be resolved when cryptography is compiled and are NOT\n   guaranteed to be the version that it actually loads. */\nstatic const int OPENSSL_VERSION_NUMBER;\nstatic const char *const OPENSSL_VERSION_TEXT;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/x509.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ssl.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\ntypedef STACK_OF(X509) Cryptography_STACK_OF_X509;\ntypedef STACK_OF(X509_CRL) Cryptography_STACK_OF_X509_CRL;\ntypedef STACK_OF(X509_REVOKED) Cryptography_STACK_OF_X509_REVOKED;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_X509;\ntypedef ... Cryptography_STACK_OF_X509_CRL;\ntypedef ... Cryptography_STACK_OF_X509_REVOKED;\n\ntypedef ... X509_ALGOR;\ntypedef ... X509_ATTRIBUTE;\ntypedef ... X509_EXTENSION;\ntypedef ... X509_EXTENSIONS;\ntypedef ... X509_REQ;\ntypedef ... X509_REVOKED;\ntypedef ... X509_CRL;\ntypedef ... X509;\n\ntypedef ... NETSCAPE_SPKI;\n\ntypedef ... PKCS8_PRIV_KEY_INFO;\n\ntypedef void (*sk_X509_EXTENSION_freefunc)(X509_EXTENSION *);\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509 *X509_new(void);\nvoid X509_free(X509 *);\nX509 *X509_dup(X509 *);\nint X509_up_ref(X509 *);\n\nint X509_print_ex(BIO *, X509 *, unsigned long, unsigned long);\n\nint X509_set_version(X509 *, long);\n\nEVP_PKEY *X509_get_pubkey(X509 *);\nint X509_set_pubkey(X509 *, EVP_PKEY *);\n\nunsigned char *X509_alias_get0(X509 *, int *);\nint X509_alias_set1(X509 *, const unsigned char *, int);\nint X509_sign(X509 *, EVP_PKEY *, const EVP_MD *);\n\nint X509_digest(const X509 *, const EVP_MD *, unsigned char *, unsigned int *);\n\nASN1_TIME *X509_gmtime_adj(ASN1_TIME *, long);\n\nunsigned long X509_subject_name_hash(X509 *);\n\nint X509_set_subject_name(X509 *, X509_NAME *);\n\nint X509_set_issuer_name(X509 *, X509_NAME *);\n\nint X509_add_ext(X509 *, X509_EXTENSION *, int);\nX509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *);\n\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *);\nvoid X509_EXTENSION_free(X509_EXTENSION *);\n\nint X509_REQ_set_version(X509_REQ *, long);\nX509_REQ *X509_REQ_new(void);\nvoid X509_REQ_free(X509_REQ *);\nint X509_REQ_set_pubkey(X509_REQ *, EVP_PKEY *);\nint X509_REQ_sign(X509_REQ *, EVP_PKEY *, const EVP_MD *);\nint X509_REQ_verify(X509_REQ *, EVP_PKEY *);\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *);\nint X509_REQ_print_ex(BIO *, X509_REQ *, unsigned long, unsigned long);\nint X509_REQ_add_extensions(X509_REQ *, X509_EXTENSIONS *);\nX509_EXTENSIONS *X509_REQ_get_extensions(X509_REQ *);\n\nint X509V3_EXT_print(BIO *, X509_EXTENSION *, unsigned long, int);\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *);\n\nX509_REVOKED *X509_REVOKED_new(void);\nvoid X509_REVOKED_free(X509_REVOKED *);\n\nint X509_REVOKED_set_serialNumber(X509_REVOKED *, ASN1_INTEGER *);\n\nint X509_REVOKED_add1_ext_i2d(X509_REVOKED *, int, void *, int, unsigned long);\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *, int);\n\nint X509_REVOKED_set_revocationDate(X509_REVOKED *, ASN1_TIME *);\n\nX509_CRL *X509_CRL_new(void);\nX509_CRL *d2i_X509_CRL_bio(BIO *, X509_CRL **);\nint X509_CRL_add0_revoked(X509_CRL *, X509_REVOKED *);\nint X509_CRL_print(BIO *, X509_CRL *);\nint X509_CRL_set_issuer_name(X509_CRL *, X509_NAME *);\nint X509_CRL_set_version(X509_CRL *, long);\nint X509_CRL_sign(X509_CRL *, EVP_PKEY *, const EVP_MD *);\nint X509_CRL_sort(X509_CRL *);\nint i2d_X509_CRL_bio(BIO *, X509_CRL *);\nvoid X509_CRL_free(X509_CRL *);\n\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *, EVP_PKEY *);\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *, EVP_PKEY *, const EVP_MD *);\nchar *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *);\nEVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *);\nint NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *, EVP_PKEY *);\nNETSCAPE_SPKI *NETSCAPE_SPKI_new(void);\nvoid NETSCAPE_SPKI_free(NETSCAPE_SPKI *);\n\n/*  ASN1 serialization */\nint i2d_X509_bio(BIO *, X509 *);\nX509 *d2i_X509_bio(BIO *, X509 **);\n\nint i2d_X509_REQ_bio(BIO *, X509_REQ *);\nX509_REQ *d2i_X509_REQ_bio(BIO *, X509_REQ **);\n\nint i2d_PrivateKey_bio(BIO *, EVP_PKEY *);\nEVP_PKEY *d2i_PrivateKey_bio(BIO *, EVP_PKEY **);\nint i2d_PUBKEY_bio(BIO *, EVP_PKEY *);\nEVP_PKEY *d2i_PUBKEY_bio(BIO *, EVP_PKEY **);\n\nASN1_INTEGER *X509_get_serialNumber(X509 *);\nint X509_set_serialNumber(X509 *, ASN1_INTEGER *);\n\nconst char *X509_verify_cert_error_string(long);\n\nconst char *X509_get_default_cert_dir(void);\nconst char *X509_get_default_cert_file(void);\nconst char *X509_get_default_cert_dir_env(void);\nconst char *X509_get_default_cert_file_env(void);\n\nint X509_get_ext_count(const X509 *);\nX509_EXTENSION *X509_get_ext(const X509 *, int);\nX509_NAME *X509_get_subject_name(const X509 *);\nX509_NAME *X509_get_issuer_name(const X509 *);\n\nint X509_EXTENSION_get_critical(const X509_EXTENSION *);\n\nint X509_REVOKED_get_ext_count(const X509_REVOKED *);\nX509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *, int);\n\nX509_REVOKED *X509_REVOKED_dup(X509_REVOKED *);\n\nconst X509_ALGOR *X509_get0_tbs_sigalg(const X509 *);\n\nlong X509_get_version(X509 *);\n\nASN1_TIME *X509_getm_notBefore(const X509 *);\nASN1_TIME *X509_getm_notAfter(const X509 *);\n\nlong X509_REQ_get_version(X509_REQ *);\nX509_NAME *X509_REQ_get_subject_name(X509_REQ *);\n\nCryptography_STACK_OF_X509 *sk_X509_new_null(void);\nvoid sk_X509_free(Cryptography_STACK_OF_X509 *);\nint sk_X509_num(Cryptography_STACK_OF_X509 *);\nint sk_X509_push(Cryptography_STACK_OF_X509 *, X509 *);\nX509 *sk_X509_value(Cryptography_STACK_OF_X509 *, int);\n\nX509_EXTENSIONS *sk_X509_EXTENSION_new_null(void);\nint sk_X509_EXTENSION_num(X509_EXTENSIONS *);\nX509_EXTENSION *sk_X509_EXTENSION_value(X509_EXTENSIONS *, int);\nint sk_X509_EXTENSION_push(X509_EXTENSIONS *, X509_EXTENSION *);\nvoid sk_X509_EXTENSION_free(X509_EXTENSIONS *);\nvoid sk_X509_EXTENSION_pop_free(X509_EXTENSIONS *, sk_X509_EXTENSION_freefunc);\n\nint sk_X509_REVOKED_num(Cryptography_STACK_OF_X509_REVOKED *);\nX509_REVOKED *sk_X509_REVOKED_value(Cryptography_STACK_OF_X509_REVOKED *, int);\n\nX509_NAME *X509_CRL_get_issuer(X509_CRL *);\nCryptography_STACK_OF_X509_REVOKED *X509_CRL_get_REVOKED(X509_CRL *);\n\nint X509_CRL_set1_lastUpdate(X509_CRL *, const ASN1_TIME *);\nint X509_CRL_set1_nextUpdate(X509_CRL *, const ASN1_TIME *);\n\nconst ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *);\nconst ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *);\n\nvoid X509_ALGOR_get0(const ASN1_OBJECT **, int *, const void **,\n                     const X509_ALGOR *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/cryptography.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = r\"\"\"\n/* define our OpenSSL API compatibility level to 1.1.0. Any symbols older than\n   that will raise an error during compilation. */\n#define OPENSSL_API_COMPAT 0x10100000L\n\n#if defined(_WIN32)\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <Wincrypt.h>\n#include <Winsock2.h>\n/*\n    undef some macros that are defined by wincrypt.h but are also types in\n    boringssl. openssl has worked around this but boring has not yet. see:\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base\n    /win/wincrypt_shim.h\n*/\n#undef X509_NAME\n#undef X509_EXTENSIONS\n#undef PKCS7_SIGNER_INFO\n#endif\n\n#include <openssl/opensslv.h>\n\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#define CRYPTOGRAPHY_IS_LIBRESSL 1\n#else\n#define CRYPTOGRAPHY_IS_LIBRESSL 0\n#endif\n\n#if defined(OPENSSL_IS_BORINGSSL)\n#define CRYPTOGRAPHY_IS_BORINGSSL 1\n#else\n#define CRYPTOGRAPHY_IS_BORINGSSL 0\n#endif\n\n#if OPENSSL_VERSION_NUMBER < 0x10101050\n    #error \"pyca/cryptography MUST be linked with Openssl 1.1.1e or later\"\n#endif\n\n#define CRYPTOGRAPHY_OPENSSL_300_OR_GREATER \\\n    (OPENSSL_VERSION_NUMBER >= 0x30000000 && !CRYPTOGRAPHY_IS_LIBRESSL)\n#define CRYPTOGRAPHY_OPENSSL_320_OR_GREATER \\\n    (OPENSSL_VERSION_NUMBER >= 0x30200000 && !CRYPTOGRAPHY_IS_LIBRESSL)\n\"\"\"\n\nTYPES = \"\"\"\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/bio.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/bio.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... BIO;\ntypedef ... BIO_METHOD;\ntypedef ... BIO_ADDR;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint BIO_free(BIO *);\nBIO *BIO_new_file(const char *, const char *);\nint BIO_read(BIO *, void *, int);\nint BIO_write(BIO *, const void *, int);\n\nBIO *BIO_new(BIO_METHOD *);\nconst BIO_METHOD *BIO_s_mem(void);\nBIO *BIO_new_mem_buf(const void *, int);\nlong BIO_set_mem_eof_return(BIO *, int);\nlong BIO_get_mem_data(BIO *, char **);\nint BIO_should_read(BIO *);\nint BIO_should_write(BIO *);\nint BIO_should_io_special(BIO *);\nint BIO_should_retry(BIO *);\nint BIO_reset(BIO *);\n\nBIO_ADDR *BIO_ADDR_new(void);\nvoid BIO_ADDR_free(BIO_ADDR *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\n\n#if !defined(_WIN32)\n#include <sys/socket.h>\n#endif\n\n#include <stdlib.h>\ntypedef struct sockaddr BIO_ADDR;\n\nBIO_ADDR *BIO_ADDR_new(void) {\n    return malloc(sizeof(struct sockaddr_storage));\n}\n\nvoid BIO_ADDR_free(BIO_ADDR *ptr) {\n    free(ptr);\n}\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/dh.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... DH;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid DH_free(DH *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/dsa.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... DSA;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint DSA_generate_key(DSA *);\nDSA *DSA_new(void);\nvoid DSA_free(DSA *);\n\nint DSA_generate_parameters_ex(DSA *, int, unsigned char *, int,\n                               int *, unsigned long *, BN_GENCB *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ec.h>\n#include <openssl/obj_mac.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EC_KEY;\ntypedef struct {\n    int nid;\n    const char *comment;\n} EC_builtin_curve;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nsize_t EC_get_builtin_curves(EC_builtin_curve *, size_t);\n\nvoid EC_KEY_free(EC_KEY *);\n\nEC_KEY *EC_KEY_new_by_curve_name(int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/bignum.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/bn.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PRIME_CHECKS;\n\ntypedef ... BN_CTX;\ntypedef ... BIGNUM;\ntypedef int... BN_ULONG;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nBIGNUM *BN_new(void);\nvoid BN_free(BIGNUM *);\n\nint BN_rand_range(BIGNUM *, const BIGNUM *);\n\nint BN_set_word(BIGNUM *, BN_ULONG);\n\nchar *BN_bn2hex(const BIGNUM *);\nint BN_hex2bn(BIGNUM **, const char *);\n\n/* The following 3 prime methods are exposed for Tribler. */\nint BN_generate_prime_ex(BIGNUM *, int, int, const BIGNUM *,\n                         const BIGNUM *, BN_GENCB *);\nint BN_is_prime_ex(const BIGNUM *, int, BN_CTX *, BN_GENCB *);\nconst int BN_prime_checks_for_size(int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PRIME_CHECKS = 0;\nint (*BN_prime_checks_for_size)(int) = NULL;\n#else\nstatic const long Cryptography_HAS_PRIME_CHECKS = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/objects.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/objects.h>\n\"\"\"\n\nTYPES = \"\"\"\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst char *OBJ_nid2ln(int);\nconst char *OBJ_nid2sn(int);\nint OBJ_obj2nid(const ASN1_OBJECT *);\nint OBJ_txt2nid(const char *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/pkcs12.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pkcs12.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PKCS12_SET_MAC;\n\ntypedef ... PKCS12;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid PKCS12_free(PKCS12 *);\n\nPKCS12 *d2i_PKCS12_bio(BIO *, PKCS12 **);\nint i2d_PKCS12_bio(BIO *, PKCS12 *);\nint PKCS12_parse(PKCS12 *, const char *, EVP_PKEY **, X509 **,\n                 Cryptography_STACK_OF_X509 **);\nPKCS12 *PKCS12_create(char *, char *, EVP_PKEY *, X509 *,\n                      Cryptography_STACK_OF_X509 *, int, int, int, int, int);\nint PKCS12_set_mac(PKCS12 *, const char *, int, unsigned char *, int, int,\n                   const EVP_MD *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PKCS12_SET_MAC = 0;\nint (*PKCS12_set_mac)(PKCS12 *, const char *, int, unsigned char *, int, int,\n                      const EVP_MD *) = NULL;\n#else\nstatic const long Cryptography_HAS_PKCS12_SET_MAC = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/rand.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/rand.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... RAND_METHOD;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid RAND_add(const void *, int, double);\nint RAND_status(void);\nint RAND_bytes(unsigned char *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/ssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ssl.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_SSL_ST;\nstatic const long Cryptography_HAS_TLS_ST;\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS;\nstatic const long Cryptography_HAS_SIGALGS;\nstatic const long Cryptography_HAS_PSK;\nstatic const long Cryptography_HAS_PSK_TLSv1_3;\nstatic const long Cryptography_HAS_VERIFIED_CHAIN;\nstatic const long Cryptography_HAS_KEYLOG;\nstatic const long Cryptography_HAS_SSL_COOKIE;\n\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION;\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF;\nstatic const long Cryptography_HAS_ALPN;\nstatic const long Cryptography_HAS_NEXTPROTONEG;\nstatic const long Cryptography_HAS_SET_CERT_CB;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT;\nstatic const long Cryptography_HAS_CUSTOM_EXT;\nstatic const long Cryptography_HAS_SRTP;\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU;\n\nstatic const long SSL_FILETYPE_PEM;\nstatic const long SSL_FILETYPE_ASN1;\nstatic const long SSL_ERROR_NONE;\nstatic const long SSL_ERROR_ZERO_RETURN;\nstatic const long SSL_ERROR_WANT_READ;\nstatic const long SSL_ERROR_WANT_WRITE;\nstatic const long SSL_ERROR_WANT_X509_LOOKUP;\nstatic const long SSL_ERROR_SYSCALL;\nstatic const long SSL_ERROR_SSL;\nstatic const long SSL_SENT_SHUTDOWN;\nstatic const long SSL_RECEIVED_SHUTDOWN;\nstatic const long SSL_OP_NO_SSLv2;\nstatic const long SSL_OP_NO_SSLv3;\nstatic const long SSL_OP_NO_TLSv1;\nstatic const long SSL_OP_NO_TLSv1_1;\nstatic const long SSL_OP_NO_TLSv1_2;\nstatic const long SSL_OP_NO_TLSv1_3;\nstatic const long SSL_OP_NO_RENEGOTIATION;\nstatic const long SSL_OP_NO_COMPRESSION;\nstatic const long SSL_OP_SINGLE_DH_USE;\nstatic const long SSL_OP_EPHEMERAL_RSA;\nstatic const long SSL_OP_MICROSOFT_SESS_ID_BUG;\nstatic const long SSL_OP_NETSCAPE_CHALLENGE_BUG;\nstatic const long SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;\nstatic const long SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;\nstatic const long SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;\nstatic const long SSL_OP_MSIE_SSLV2_RSA_PADDING;\nstatic const long SSL_OP_SSLEAY_080_CLIENT_DH_BUG;\nstatic const long SSL_OP_TLS_D5_BUG;\nstatic const long SSL_OP_TLS_BLOCK_PADDING_BUG;\nstatic const long SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\nstatic const long SSL_OP_CIPHER_SERVER_PREFERENCE;\nstatic const long SSL_OP_TLS_ROLLBACK_BUG;\nstatic const long SSL_OP_PKCS1_CHECK_1;\nstatic const long SSL_OP_PKCS1_CHECK_2;\nstatic const long SSL_OP_NETSCAPE_CA_DN_BUG;\nstatic const long SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;\nstatic const long SSL_OP_NO_QUERY_MTU;\nstatic const long SSL_OP_COOKIE_EXCHANGE;\nstatic const long SSL_OP_NO_TICKET;\nstatic const long SSL_OP_ALL;\nstatic const long SSL_OP_SINGLE_ECDH_USE;\nstatic const long SSL_OP_IGNORE_UNEXPECTED_EOF;\nstatic const long SSL_OP_LEGACY_SERVER_CONNECT;\nstatic const long SSL_VERIFY_PEER;\nstatic const long SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\nstatic const long SSL_VERIFY_CLIENT_ONCE;\nstatic const long SSL_VERIFY_NONE;\nstatic const long SSL_VERIFY_POST_HANDSHAKE;\nstatic const long SSL_SESS_CACHE_OFF;\nstatic const long SSL_SESS_CACHE_CLIENT;\nstatic const long SSL_SESS_CACHE_SERVER;\nstatic const long SSL_SESS_CACHE_BOTH;\nstatic const long SSL_SESS_CACHE_NO_AUTO_CLEAR;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL_STORE;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL;\nstatic const long SSL_ST_CONNECT;\nstatic const long SSL_ST_ACCEPT;\nstatic const long SSL_ST_MASK;\nstatic const long SSL_ST_INIT;\nstatic const long SSL_ST_BEFORE;\nstatic const long SSL_ST_OK;\nstatic const long SSL_ST_RENEGOTIATE;\nstatic const long SSL_CB_LOOP;\nstatic const long SSL_CB_EXIT;\nstatic const long SSL_CB_READ;\nstatic const long SSL_CB_WRITE;\nstatic const long SSL_CB_ALERT;\nstatic const long SSL_CB_READ_ALERT;\nstatic const long SSL_CB_WRITE_ALERT;\nstatic const long SSL_CB_ACCEPT_LOOP;\nstatic const long SSL_CB_ACCEPT_EXIT;\nstatic const long SSL_CB_CONNECT_LOOP;\nstatic const long SSL_CB_CONNECT_EXIT;\nstatic const long SSL_CB_HANDSHAKE_START;\nstatic const long SSL_CB_HANDSHAKE_DONE;\nstatic const long SSL_MODE_RELEASE_BUFFERS;\nstatic const long SSL_MODE_ENABLE_PARTIAL_WRITE;\nstatic const long SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\nstatic const long SSL_MODE_AUTO_RETRY;\nstatic const long TLS_ST_BEFORE;\nstatic const long TLS_ST_OK;\n\nstatic const long SSL3_VERSION;\nstatic const long TLS1_VERSION;\nstatic const long TLS1_1_VERSION;\nstatic const long TLS1_2_VERSION;\nstatic const long TLS1_3_VERSION;\n\ntypedef ... SSL_METHOD;\ntypedef ... SSL_CTX;\n\ntypedef ... SSL_SESSION;\n\ntypedef ... SSL;\n\nstatic const long TLSEXT_NAMETYPE_host_name;\nstatic const long TLSEXT_STATUSTYPE_ocsp;\n\ntypedef ... SSL_CIPHER;\n\ntypedef struct {\n    const char *name;\n    unsigned long id;\n} SRTP_PROTECTION_PROFILE;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n/*  SSL */\nconst char *SSL_state_string_long(const SSL *);\nSSL_SESSION *SSL_get1_session(SSL *);\nint SSL_set_session(SSL *, SSL_SESSION *);\nint SSL_session_reused(const SSL *);\nSSL *SSL_new(SSL_CTX *);\nvoid SSL_free(SSL *);\nint SSL_set_fd(SSL *, int);\nSSL_CTX *SSL_set_SSL_CTX(SSL *, SSL_CTX *);\nvoid SSL_set_bio(SSL *, BIO *, BIO *);\nvoid SSL_set_connect_state(SSL *);\nvoid SSL_set_accept_state(SSL *);\nvoid SSL_set_shutdown(SSL *, int);\nint SSL_get_shutdown(const SSL *);\nint SSL_pending(const SSL *);\nint SSL_write(SSL *, const void *, int);\nint SSL_read(SSL *, void *, int);\nint SSL_peek(SSL *, void *, int);\nX509 *SSL_get_certificate(const SSL *);\nX509 *SSL_get_peer_certificate(const SSL *);\nint SSL_get_ex_data_X509_STORE_CTX_idx(void);\nvoid SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));\nint SSL_get_verify_mode(const SSL *);\n\nlong SSL_get_extms_support(SSL *);\n\nX509_VERIFY_PARAM *SSL_get0_param(SSL *);\nX509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *);\n\nCryptography_STACK_OF_X509 *SSL_get_peer_cert_chain(const SSL *);\nCryptography_STACK_OF_X509 *SSL_get0_verified_chain(const SSL *);\nCryptography_STACK_OF_X509_NAME *SSL_get_client_CA_list(const SSL *);\n\nint SSL_get_error(const SSL *, int);\nlong SSL_get_verify_result(const SSL *ssl);\nint SSL_do_handshake(SSL *);\nint SSL_shutdown(SSL *);\nint SSL_renegotiate(SSL *);\nint SSL_renegotiate_pending(SSL *);\nconst char *SSL_get_cipher_list(const SSL *, int);\nint SSL_use_certificate(SSL *, X509 *);\nint SSL_use_PrivateKey(SSL *, EVP_PKEY *);\n\n/*  context */\nvoid SSL_CTX_free(SSL_CTX *);\nlong SSL_CTX_set_timeout(SSL_CTX *, long);\nint SSL_CTX_set_default_verify_paths(SSL_CTX *);\nvoid SSL_CTX_set_verify(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *));\nvoid SSL_CTX_set_verify_depth(SSL_CTX *, int);\nint SSL_CTX_get_verify_mode(const SSL_CTX *);\nint SSL_CTX_get_verify_depth(const SSL_CTX *);\nint SSL_CTX_set_cipher_list(SSL_CTX *, const char *);\nint SSL_CTX_load_verify_locations(SSL_CTX *, const char *, const char *);\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *, pem_password_cb *);\nint SSL_CTX_use_certificate(SSL_CTX *, X509 *);\nint SSL_CTX_use_certificate_file(SSL_CTX *, const char *, int);\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *, const char *);\nint SSL_CTX_use_PrivateKey(SSL_CTX *, EVP_PKEY *);\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *, const char *, int);\nint SSL_CTX_check_private_key(const SSL_CTX *);\n\nvoid SSL_CTX_set_cookie_generate_cb(SSL_CTX *,\n                                    int (*)(\n                                        SSL *,\n                                        unsigned char *,\n                                        unsigned int *\n                                    ));\nvoid SSL_CTX_set_cookie_verify_cb(SSL_CTX *,\n                                    int (*)(\n                                        SSL *,\n                                        const unsigned char *,\n                                        unsigned int\n                                    ));\n\nint SSL_CTX_use_psk_identity_hint(SSL_CTX *, const char *);\nvoid SSL_CTX_set_psk_server_callback(SSL_CTX *,\n                                     unsigned int (*)(\n                                         SSL *,\n                                         const char *,\n                                         unsigned char *,\n                                         unsigned int\n                                     ));\nvoid SSL_CTX_set_psk_client_callback(SSL_CTX *,\n                                     unsigned int (*)(\n                                         SSL *,\n                                         const char *,\n                                         char *,\n                                         unsigned int,\n                                         unsigned char *,\n                                         unsigned int\n                                     ));\nvoid SSL_CTX_set_psk_find_session_callback(SSL_CTX *,\n                                           int (*)(\n                                               SSL *,\n                                               const unsigned char *,\n                                               size_t,\n                                               SSL_SESSION **\n                                           ));\nvoid SSL_CTX_set_psk_use_session_callback(SSL_CTX *,\n                                          int (*)(\n                                              SSL *,\n                                              const EVP_MD *,\n                                              const unsigned char **,\n                                              size_t *,\n                                              SSL_SESSION **\n                                          ));\nconst SSL_CIPHER *SSL_CIPHER_find(SSL *, const unsigned char *);\n/* Wrap SSL_SESSION_new to avoid namespace collision. */\nSSL_SESSION *Cryptography_SSL_SESSION_new(void);\nint SSL_SESSION_set1_master_key(SSL_SESSION *, const unsigned char *,\n                                 size_t);\nint SSL_SESSION_set_cipher(SSL_SESSION *, const SSL_CIPHER *);\nint SSL_SESSION_set_protocol_version(SSL_SESSION *, int);\n\nint SSL_CTX_set_session_id_context(SSL_CTX *, const unsigned char *,\n                                   unsigned int);\n\nX509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);\nvoid SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);\nint SSL_CTX_add_client_CA(SSL_CTX *, X509 *);\n\nvoid SSL_CTX_set_client_CA_list(SSL_CTX *, Cryptography_STACK_OF_X509_NAME *);\n\nvoid SSL_CTX_set_info_callback(SSL_CTX *, void (*)(const SSL *, int, int));\n\nvoid SSL_CTX_set_msg_callback(SSL_CTX *,\n                              void (*)(\n                                int,\n                                int,\n                                int,\n                                const void *,\n                                size_t,\n                                SSL *,\n                                void *\n                              ));\nvoid SSL_CTX_set_msg_callback_arg(SSL_CTX *, void *);\n\nvoid SSL_CTX_set_keylog_callback(SSL_CTX *,\n                                 void (*)(const SSL *, const char *));\nvoid (*SSL_CTX_get_keylog_callback(SSL_CTX *))(const SSL *, const char *);\n\nlong SSL_CTX_set1_sigalgs_list(SSL_CTX *, const char *);\n\n/*  SSL_SESSION */\nvoid SSL_SESSION_free(SSL_SESSION *);\n\n/* Information about actually used cipher */\nconst char *SSL_CIPHER_get_name(const SSL_CIPHER *);\nint SSL_CIPHER_get_bits(const SSL_CIPHER *, int *);\n\nsize_t SSL_get_finished(const SSL *, void *, size_t);\nsize_t SSL_get_peer_finished(const SSL *, void *, size_t);\nCryptography_STACK_OF_X509_NAME *SSL_load_client_CA_file(const char *);\n\nconst char *SSL_get_servername(const SSL *, const int);\nconst char *SSL_CIPHER_get_version(const SSL_CIPHER *);\n\nSSL_SESSION *SSL_get_session(const SSL *);\n\nuint64_t SSL_set_options(SSL *, uint64_t);\nuint64_t SSL_get_options(SSL *);\n\nint SSL_want_read(const SSL *);\nint SSL_want_write(const SSL *);\n\nlong SSL_total_renegotiations(SSL *);\n\nlong SSL_CTX_set_min_proto_version(SSL_CTX *, int);\nlong SSL_CTX_set_max_proto_version(SSL_CTX *, int);\n\nlong SSL_CTX_set_tmp_ecdh(SSL_CTX *, EC_KEY *);\nlong SSL_CTX_set_tmp_dh(SSL_CTX *, DH *);\nlong SSL_CTX_set_session_cache_mode(SSL_CTX *, long);\nlong SSL_CTX_get_session_cache_mode(SSL_CTX *);\nlong SSL_CTX_add_extra_chain_cert(SSL_CTX *, X509 *);\n\nuint64_t SSL_CTX_set_options(SSL_CTX *, uint64_t);\nuint64_t SSL_CTX_get_options(SSL_CTX *);\n\nlong SSL_CTX_set_mode(SSL_CTX *, long);\nlong SSL_CTX_clear_mode(SSL_CTX *, long);\nlong SSL_set_mode(SSL *, long);\nlong SSL_clear_mode(SSL *, long);\n\nconst SSL_METHOD *DTLS_method(void);\nconst SSL_METHOD *DTLS_server_method(void);\nconst SSL_METHOD *DTLS_client_method(void);\n\nconst SSL_METHOD *TLS_method(void);\nconst SSL_METHOD *TLS_server_method(void);\nconst SSL_METHOD *TLS_client_method(void);\n\n/*- These aren't macros these arguments are all const X on openssl > 1.0.x -*/\nSSL_CTX *SSL_CTX_new(SSL_METHOD *);\nlong SSL_CTX_get_timeout(const SSL_CTX *);\n\nconst SSL_CIPHER *SSL_get_current_cipher(const SSL *);\nconst char *SSL_get_version(const SSL *);\nint SSL_version(const SSL *);\n\nvoid SSL_set_tlsext_host_name(SSL *, char *);\nvoid SSL_CTX_set_tlsext_servername_callback(\n    SSL_CTX *,\n    int (*)(SSL *, int *, void *));\n\nlong SSL_set_tlsext_status_ocsp_resp(SSL *, unsigned char *, int);\nlong SSL_get_tlsext_status_ocsp_resp(SSL *, const unsigned char **);\nlong SSL_set_tlsext_status_type(SSL *, long);\nlong SSL_CTX_set_tlsext_status_cb(SSL_CTX *, int(*)(SSL *, void *));\nlong SSL_CTX_set_tlsext_status_arg(SSL_CTX *, void *);\n\nint SSL_CTX_set_tlsext_use_srtp(SSL_CTX *, const char *);\nint SSL_set_tlsext_use_srtp(SSL *, const char *);\nSRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *);\n\nint SSL_CTX_set_alpn_protos(SSL_CTX *, const unsigned char *, unsigned);\nint SSL_set_alpn_protos(SSL *, const unsigned char *, unsigned);\nvoid SSL_CTX_set_alpn_select_cb(SSL_CTX *,\n                                int (*) (SSL *,\n                                         const unsigned char **,\n                                         unsigned char *,\n                                         const unsigned char *,\n                                         unsigned int,\n                                         void *),\n                                void *);\nvoid SSL_get0_alpn_selected(const SSL *, const unsigned char **, unsigned *);\n\nvoid SSL_CTX_set_cert_cb(SSL_CTX *, int (*)(SSL *, void *), void *);\nvoid SSL_set_cert_cb(SSL *, int (*)(SSL *, void *), void *);\n\nsize_t SSL_SESSION_get_master_key(const SSL_SESSION *, unsigned char *,\n                                  size_t);\nsize_t SSL_get_client_random(const SSL *, unsigned char *, size_t);\nsize_t SSL_get_server_random(const SSL *, unsigned char *, size_t);\nint SSL_export_keying_material(SSL *, unsigned char *, size_t, const char *,\n                               size_t, const unsigned char *, size_t, int);\n\n/* DTLS support */\nlong Cryptography_DTLSv1_get_timeout(SSL *, time_t *, long *);\nlong DTLSv1_handle_timeout(SSL *);\nlong SSL_set_mtu(SSL *, long);\nint DTLSv1_listen(SSL *, BIO_ADDR *);\nsize_t DTLS_get_data_mtu(SSL *);\n\n\n/* Custom extensions. */\ntypedef int (*custom_ext_add_cb)(SSL *, unsigned int,\n                                 const unsigned char **,\n                                 size_t *, int *,\n                                 void *);\n\ntypedef void (*custom_ext_free_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   void *);\n\ntypedef int (*custom_ext_parse_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   size_t, int *,\n                                   void *);\n\nint SSL_CTX_add_client_custom_ext(SSL_CTX *, unsigned int,\n                                  custom_ext_add_cb,\n                                  custom_ext_free_cb, void *,\n                                  custom_ext_parse_cb,\n                                  void *);\n\nint SSL_CTX_add_server_custom_ext(SSL_CTX *, unsigned int,\n                                  custom_ext_add_cb,\n                                  custom_ext_free_cb, void *,\n                                  custom_ext_parse_cb,\n                                  void *);\n\nint SSL_extension_supported(unsigned int);\n\nint SSL_CTX_set_ciphersuites(SSL_CTX *, const char *);\nint SSL_verify_client_post_handshake(SSL *);\nvoid SSL_CTX_set_post_handshake_auth(SSL_CTX *, int);\nvoid SSL_set_post_handshake_auth(SSL *, int);\n\nuint32_t SSL_SESSION_get_max_early_data(const SSL_SESSION *);\nint SSL_write_early_data(SSL *, const void *, size_t, size_t *);\nint SSL_read_early_data(SSL *, void *, size_t, size_t *);\nint SSL_CTX_set_max_early_data(SSL_CTX *, uint32_t);\n\n/*\n  Added as an advanced user escape hatch. This symbol is tied to\n  engine support but is declared in ssl.h\n*/\nint SSL_CTX_set_client_cert_engine(SSL_CTX *, ENGINE *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef OPENSSL_NO_ENGINE\nint (*SSL_CTX_set_client_cert_engine)(SSL_CTX *, ENGINE *) = NULL;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_VERIFIED_CHAIN = 0;\nCryptography_STACK_OF_X509 *(*SSL_get0_verified_chain)(const SSL *) = NULL;\n#else\nstatic const long Cryptography_HAS_VERIFIED_CHAIN = 1;\n#endif\n\nstatic const long Cryptography_HAS_KEYLOG = 1;\n\nstatic const long Cryptography_HAS_NEXTPROTONEG = 0;\nstatic const long Cryptography_HAS_ALPN = 1;\n\n#ifdef SSL_OP_NO_RENEGOTIATION\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION = 1;\n#else\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION = 0;\nstatic const long SSL_OP_NO_RENEGOTIATION = 0;\n#endif\n\n#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF = 1;\n#else\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF = 0;\nstatic const long SSL_OP_IGNORE_UNEXPECTED_EOF = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL\nvoid (*SSL_CTX_set_cert_cb)(SSL_CTX *, int (*)(SSL *, void *), void *) = NULL;\nvoid (*SSL_set_cert_cb)(SSL *, int (*)(SSL *, void *), void *) = NULL;\nstatic const long Cryptography_HAS_SET_CERT_CB = 0;\n\nlong (*SSL_get_extms_support)(SSL *) = NULL;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT = 0;\n#else\nstatic const long Cryptography_HAS_SET_CERT_CB = 1;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT = 1;\n#endif\n\n/* in OpenSSL 1.1.0 the SSL_ST values were renamed to TLS_ST and several were\n   removed */\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_SSL_ST = 1;\n#else\nstatic const long Cryptography_HAS_SSL_ST = 0;\nstatic const long SSL_ST_BEFORE = 0;\nstatic const long SSL_ST_OK = 0;\nstatic const long SSL_ST_INIT = 0;\nstatic const long SSL_ST_RENEGOTIATE = 0;\n#endif\n#if !CRYPTOGRAPHY_IS_LIBRESSL\nstatic const long Cryptography_HAS_TLS_ST = 1;\n#else\nstatic const long Cryptography_HAS_TLS_ST = 0;\nstatic const long TLS_ST_BEFORE = 0;\nstatic const long TLS_ST_OK = 0;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU = 0;\nsize_t (*DTLS_get_data_mtu)(SSL *) = NULL;\n#else\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU = 1;\n#endif\n\n/* Wrap DTLSv1_get_timeout to avoid cffi to handle a 'struct timeval'. */\nlong Cryptography_DTLSv1_get_timeout(SSL *ssl, time_t *ptv_sec,\n                                     long *ptv_usec) {\n    struct timeval tv = { 0 };\n    long r = DTLSv1_get_timeout(ssl, &tv);\n\n    if (r == 1) {\n        if (ptv_sec) {\n            *ptv_sec = tv.tv_sec;\n        }\n\n        if (ptv_usec) {\n            *ptv_usec = tv.tv_usec;\n        }\n    }\n\n    return r;\n}\n\n#if CRYPTOGRAPHY_IS_LIBRESSL\nstatic const long Cryptography_HAS_SIGALGS = 0;\nconst long (*SSL_CTX_set1_sigalgs_list)(SSL_CTX *, const char *) = NULL;\n#else\nstatic const long Cryptography_HAS_SIGALGS = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL || defined(OPENSSL_NO_PSK)\nstatic const long Cryptography_HAS_PSK = 0;\nint (*SSL_CTX_use_psk_identity_hint)(SSL_CTX *, const char *) = NULL;\nvoid (*SSL_CTX_set_psk_server_callback)(SSL_CTX *,\n                                        unsigned int (*)(\n                                            SSL *,\n                                            const char *,\n                                            unsigned char *,\n                                            unsigned int\n                                        )) = NULL;\nvoid (*SSL_CTX_set_psk_client_callback)(SSL_CTX *,\n                                        unsigned int (*)(\n                                            SSL *,\n                                            const char *,\n                                            char *,\n                                            unsigned int,\n                                            unsigned char *,\n                                            unsigned int\n                                        )) = NULL;\n#else\nstatic const long Cryptography_HAS_PSK = 1;\n#endif\n\n#if !CRYPTOGRAPHY_IS_LIBRESSL && !CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_CUSTOM_EXT = 1;\n#else\nstatic const long Cryptography_HAS_CUSTOM_EXT = 0;\ntypedef int (*custom_ext_add_cb)(SSL *, unsigned int,\n                                 const unsigned char **,\n                                 size_t *, int *,\n                                 void *);\ntypedef void (*custom_ext_free_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   void *);\ntypedef int (*custom_ext_parse_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   size_t, int *,\n                                   void *);\nint (*SSL_CTX_add_client_custom_ext)(SSL_CTX *, unsigned int,\n                                     custom_ext_add_cb,\n                                     custom_ext_free_cb, void *,\n                                     custom_ext_parse_cb,\n                                     void *) = NULL;\nint (*SSL_CTX_add_server_custom_ext)(SSL_CTX *, unsigned int,\n                                     custom_ext_add_cb,\n                                     custom_ext_free_cb, void *,\n                                     custom_ext_parse_cb,\n                                     void *) = NULL;\nint (*SSL_extension_supported)(unsigned int) = NULL;\n#endif\n\n#ifndef OPENSSL_NO_SRTP\nstatic const long Cryptography_HAS_SRTP = 1;\n#else\nstatic const long Cryptography_HAS_SRTP = 0;\nint (*SSL_CTX_set_tlsext_use_srtp)(SSL_CTX *, const char *) = NULL;\nint (*SSL_set_tlsext_use_srtp)(SSL *, const char *) = NULL;\nSRTP_PROTECTION_PROFILE * (*SSL_get_selected_srtp_profile)(SSL *) = NULL;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 0;\n\nstatic const long SSL_VERIFY_POST_HANDSHAKE = 0;\nint (*SSL_CTX_set_ciphersuites)(SSL_CTX *, const char *) = NULL;\nint (*SSL_verify_client_post_handshake)(SSL *) = NULL;\nvoid (*SSL_CTX_set_post_handshake_auth)(SSL_CTX *, int) = NULL;\nvoid (*SSL_set_post_handshake_auth)(SSL *, int) = NULL;\nuint32_t (*SSL_SESSION_get_max_early_data)(const SSL_SESSION *) = NULL;\nint (*SSL_write_early_data)(SSL *, const void *, size_t, size_t *) = NULL;\nint (*SSL_read_early_data)(SSL *, void *, size_t, size_t *) = NULL;\nint (*SSL_CTX_set_max_early_data)(SSL_CTX *, uint32_t) = NULL;\n#else\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_SSL_COOKIE = 0;\n\nstatic const long SSL_OP_COOKIE_EXCHANGE = 0;\nint (*DTLSv1_listen)(SSL *, BIO_ADDR *) = NULL;\nvoid (*SSL_CTX_set_cookie_generate_cb)(SSL_CTX *,\n                                       int (*)(\n                                           SSL *,\n                                           unsigned char *,\n                                           unsigned int *\n                                       )) = NULL;\nvoid (*SSL_CTX_set_cookie_verify_cb)(SSL_CTX *,\n                                       int (*)(\n                                           SSL *,\n                                           const unsigned char *,\n                                           unsigned int\n                                       )) = NULL;\n#else\nstatic const long Cryptography_HAS_SSL_COOKIE = 1;\n#endif\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PSK_TLSv1_3 = 0;\nvoid (*SSL_CTX_set_psk_find_session_callback)(SSL_CTX *,\n                                           int (*)(\n                                               SSL *,\n                                               const unsigned char *,\n                                               size_t,\n                                               SSL_SESSION **\n                                           )) = NULL;\nvoid (*SSL_CTX_set_psk_use_session_callback)(SSL_CTX *,\n                                          int (*)(\n                                              SSL *,\n                                              const EVP_MD *,\n                                              const unsigned char **,\n                                              size_t *,\n                                              SSL_SESSION **\n                                          )) = NULL;\n#if CRYPTOGRAPHY_IS_BORINGSSL\nconst SSL_CIPHER *(*SSL_CIPHER_find)(SSL *, const unsigned char *) = NULL;\n#endif\nint (*SSL_SESSION_set1_master_key)(SSL_SESSION *, const unsigned char *,\n                                   size_t) = NULL;\nint (*SSL_SESSION_set_cipher)(SSL_SESSION *, const SSL_CIPHER *) = NULL;\n#if !CRYPTOGRAPHY_IS_BORINGSSL\nint (*SSL_SESSION_set_protocol_version)(SSL_SESSION *, int) = NULL;\n#endif\nSSL_SESSION *(*Cryptography_SSL_SESSION_new)(void) = NULL;\n#else\nstatic const long Cryptography_HAS_PSK_TLSv1_3 = 1;\nSSL_SESSION *Cryptography_SSL_SESSION_new(void) {\n    return SSL_SESSION_new();\n}\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/pem.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pem.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509 *PEM_read_bio_X509(BIO *, X509 **, pem_password_cb *, void *);\nint PEM_write_bio_X509(BIO *, X509 *);\n\nint PEM_write_bio_PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,\n                             unsigned char *, int, pem_password_cb *, void *);\n\nEVP_PKEY *PEM_read_bio_PrivateKey(BIO *, EVP_PKEY **, pem_password_cb *,\n                                 void *);\n\nPKCS7 *d2i_PKCS7_bio(BIO *, PKCS7 **);\n\nint PEM_write_bio_X509_REQ(BIO *, X509_REQ *);\n\nX509_REQ *PEM_read_bio_X509_REQ(BIO *, X509_REQ **, pem_password_cb *, void *);\n\nX509_CRL *PEM_read_bio_X509_CRL(BIO *, X509_CRL **, pem_password_cb *, void *);\n\nint PEM_write_bio_X509_CRL(BIO *, X509_CRL *);\n\nPKCS7 *PEM_read_bio_PKCS7(BIO *, PKCS7 **, pem_password_cb *, void *);\n\nDH *PEM_read_bio_DHparams(BIO *, DH **, pem_password_cb *, void *);\n\nEVP_PKEY *PEM_read_bio_PUBKEY(BIO *, EVP_PKEY **, pem_password_cb *, void *);\nint PEM_write_bio_PUBKEY(BIO *, EVP_PKEY *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/crypto.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/crypto.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int OPENSSL_VERSION;\nstatic const int OPENSSL_CFLAGS;\nstatic const int OPENSSL_BUILT_ON;\nstatic const int OPENSSL_PLATFORM;\nstatic const int OPENSSL_DIR;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid OPENSSL_cleanup(void);\n\nunsigned long OpenSSL_version_num(void);\nconst char *OpenSSL_version(int);\n\nvoid *OPENSSL_malloc(size_t);\nvoid OPENSSL_free(void *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/pkcs7.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pkcs7.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PKCS7_FUNCS;\ntypedef ... PKCS7;\nstatic const int PKCS7_TEXT;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid PKCS7_free(PKCS7 *);\n/* Included verify due to external consumer, see\n   https://github.com/pyca/cryptography/issues/5433 */\nint PKCS7_verify(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,\n                 BIO *, int);\nPKCS7 *SMIME_read_PKCS7(BIO *, BIO **);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PKCS7_FUNCS = 0;\n\nint (*PKCS7_verify)(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,\n                    BIO *, int) = NULL;\nPKCS7 *(*SMIME_read_PKCS7)(BIO *, BIO **) = NULL;\n#else\nstatic const long Cryptography_HAS_PKCS7_FUNCS = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/x509_vfy.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509_vfy.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\ntypedef STACK_OF(ASN1_OBJECT) Cryptography_STACK_OF_ASN1_OBJECT;\ntypedef STACK_OF(X509_OBJECT) Cryptography_STACK_OF_X509_OBJECT;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_ASN1_OBJECT;\ntypedef ... Cryptography_STACK_OF_X509_OBJECT;\n\ntypedef ... X509_OBJECT;\ntypedef ... X509_STORE;\ntypedef ... X509_VERIFY_PARAM;\ntypedef ... X509_STORE_CTX;\n\ntypedef int (*X509_STORE_CTX_get_issuer_fn)(X509 **, X509_STORE_CTX *, X509 *);\n\nstatic const int X509_V_OK;\nstatic const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\nstatic const int X509_V_ERR_UNABLE_TO_GET_CRL;\nstatic const int X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE;\nstatic const int X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE;\nstatic const int X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\nstatic const int X509_V_ERR_CERT_SIGNATURE_FAILURE;\nstatic const int X509_V_ERR_CRL_SIGNATURE_FAILURE;\nstatic const int X509_V_ERR_CERT_NOT_YET_VALID;\nstatic const int X509_V_ERR_CERT_HAS_EXPIRED;\nstatic const int X509_V_ERR_CRL_NOT_YET_VALID;\nstatic const int X509_V_ERR_CRL_HAS_EXPIRED;\nstatic const int X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\nstatic const int X509_V_ERR_OUT_OF_MEM;\nstatic const int X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\nstatic const int X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\nstatic const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\nstatic const int X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\nstatic const int X509_V_ERR_CERT_CHAIN_TOO_LONG;\nstatic const int X509_V_ERR_CERT_REVOKED;\nstatic const int X509_V_ERR_INVALID_CA;\nstatic const int X509_V_ERR_PATH_LENGTH_EXCEEDED;\nstatic const int X509_V_ERR_INVALID_PURPOSE;\nstatic const int X509_V_ERR_CERT_UNTRUSTED;\nstatic const int X509_V_ERR_CERT_REJECTED;\nstatic const int X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\nstatic const int X509_V_ERR_AKID_SKID_MISMATCH;\nstatic const int X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\nstatic const int X509_V_ERR_KEYUSAGE_NO_CERTSIGN;\nstatic const int X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\nstatic const int X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\nstatic const int X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\nstatic const int X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\nstatic const int X509_V_ERR_INVALID_NON_CA;\nstatic const int X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\nstatic const int X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;\nstatic const int X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\nstatic const int X509_V_ERR_INVALID_EXTENSION;\nstatic const int X509_V_ERR_INVALID_POLICY_EXTENSION;\nstatic const int X509_V_ERR_NO_EXPLICIT_POLICY;\nstatic const int X509_V_ERR_DIFFERENT_CRL_SCOPE;\nstatic const int X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE;\nstatic const int X509_V_ERR_UNNESTED_RESOURCE;\nstatic const int X509_V_ERR_PERMITTED_VIOLATION;\nstatic const int X509_V_ERR_EXCLUDED_VIOLATION;\nstatic const int X509_V_ERR_SUBTREE_MINMAX;\nstatic const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\nstatic const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX;\nstatic const int X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\nstatic const int X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\nstatic const int X509_V_ERR_HOSTNAME_MISMATCH;\nstatic const int X509_V_ERR_EMAIL_MISMATCH;\nstatic const int X509_V_ERR_IP_ADDRESS_MISMATCH;\nstatic const int X509_V_ERR_APPLICATION_VERIFICATION;\n\n\n/* While these are defined in the source as ints, they're tagged here\n   as longs, just in case they ever grow to large, such as what we saw\n   with OP_ALL. */\n\n/* Verification parameters */\nstatic const long X509_V_FLAG_CRL_CHECK;\nstatic const long X509_V_FLAG_CRL_CHECK_ALL;\nstatic const long X509_V_FLAG_IGNORE_CRITICAL;\nstatic const long X509_V_FLAG_X509_STRICT;\nstatic const long X509_V_FLAG_ALLOW_PROXY_CERTS;\nstatic const long X509_V_FLAG_POLICY_CHECK;\nstatic const long X509_V_FLAG_EXPLICIT_POLICY;\nstatic const long X509_V_FLAG_INHIBIT_MAP;\nstatic const long X509_V_FLAG_CHECK_SS_SIGNATURE;\nstatic const long X509_V_FLAG_PARTIAL_CHAIN;\n\nstatic const long X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT;\nstatic const long X509_CHECK_FLAG_NO_WILDCARDS;\nstatic const long X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\nstatic const long X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;\nstatic const long X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;\nstatic const long X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n/* Included due to external consumer, see\n   https://github.com/pyca/pyopenssl/issues/1031 */\nstatic const long X509_PURPOSE_SSL_CLIENT;\nstatic const long X509_PURPOSE_SSL_SERVER;\nstatic const long X509_PURPOSE_NS_SSL_SERVER;\nstatic const long X509_PURPOSE_SMIME_SIGN;\nstatic const long X509_PURPOSE_SMIME_ENCRYPT;\nstatic const long X509_PURPOSE_CRL_SIGN;\nstatic const long X509_PURPOSE_ANY;\nstatic const long X509_PURPOSE_OCSP_HELPER;\nstatic const long X509_PURPOSE_TIMESTAMP_SIGN;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint X509_verify_cert(X509_STORE_CTX *);\n\n/* X509_STORE */\nX509_STORE *X509_STORE_new(void);\nint X509_STORE_add_cert(X509_STORE *, X509 *);\nint X509_STORE_add_crl(X509_STORE *, X509_CRL *);\nint X509_STORE_load_locations(X509_STORE *, const char *, const char *);\nint X509_STORE_set1_param(X509_STORE *, X509_VERIFY_PARAM *);\nint X509_STORE_set_default_paths(X509_STORE *);\nint X509_STORE_set_flags(X509_STORE *, unsigned long);\n/* Included due to external consumer, see\n   https://github.com/pyca/pyopenssl/issues/1031 */\nint X509_STORE_set_purpose(X509_STORE *, int);\nint X509_STORE_up_ref(X509_STORE *);\nvoid X509_STORE_free(X509_STORE *);\n\n/* X509_STORE_CTX */\nX509_STORE_CTX *X509_STORE_CTX_new(void);\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *);\nvoid X509_STORE_CTX_free(X509_STORE_CTX *);\nint X509_STORE_CTX_init(X509_STORE_CTX *, X509_STORE *, X509 *,\n                        Cryptography_STACK_OF_X509 *);\nCryptography_STACK_OF_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *);\nint X509_STORE_CTX_get_error(X509_STORE_CTX *);\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *, int);\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *);\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *);\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *, int);\n\n/* X509_VERIFY_PARAM */\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *, unsigned long);\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *, time_t);\nvoid X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *);\n\nint X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *, const char *,\n                                size_t);\nvoid X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *, unsigned int);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *, const unsigned char *,\n                              size_t);\n\nint sk_X509_OBJECT_num(Cryptography_STACK_OF_X509_OBJECT *);\nCryptography_STACK_OF_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *);\n\nX509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/rsa.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... RSA;\ntypedef ... BN_GENCB;\nstatic const int RSA_F4;\n\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nRSA *RSA_new(void);\nvoid RSA_free(RSA *);\nint RSA_generate_key_ex(RSA *, int, BIGNUM *, BN_GENCB *);\nint RSA_check_key(const RSA *);\nint RSA_print(BIO *, const RSA *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if defined(EVP_PKEY_CTRL_RSA_IMPLICIT_REJECTION)\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION = 1;\n#else\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION = 0;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/x509name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509.h>\n\n/*\n * See the comment above Cryptography_STACK_OF_X509 in x509.py\n */\ntypedef STACK_OF(X509_NAME) Cryptography_STACK_OF_X509_NAME;\ntypedef STACK_OF(X509_NAME_ENTRY) Cryptography_STACK_OF_X509_NAME_ENTRY;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_X509_NAME_ENTRY;\ntypedef ... X509_NAME;\ntypedef ... X509_NAME_ENTRY;\ntypedef ... Cryptography_STACK_OF_X509_NAME;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509_NAME *X509_NAME_new(void);\nvoid X509_NAME_free(X509_NAME *);\n\nunsigned long X509_NAME_hash(X509_NAME *);\n\nint i2d_X509_NAME(X509_NAME *, unsigned char **);\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *, int);\nvoid X509_NAME_ENTRY_free(X509_NAME_ENTRY *);\nint X509_NAME_get_index_by_NID(X509_NAME *, int, int);\nint X509_NAME_cmp(const X509_NAME *, const X509_NAME *);\nX509_NAME *X509_NAME_dup(X509_NAME *);\nint X509_NAME_entry_count(const X509_NAME *);\nX509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *, int);\nchar *X509_NAME_oneline(const X509_NAME *, char *, int);\n\nASN1_OBJECT *X509_NAME_ENTRY_get_object(const X509_NAME_ENTRY *);\nASN1_STRING *X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *);\n\nint X509_NAME_add_entry_by_NID(X509_NAME *, int, int, const unsigned char *,\n                               int, int, int);\n\nCryptography_STACK_OF_X509_NAME *sk_X509_NAME_new_null(void);\nint sk_X509_NAME_num(Cryptography_STACK_OF_X509_NAME *);\nint sk_X509_NAME_push(Cryptography_STACK_OF_X509_NAME *, X509_NAME *);\nX509_NAME *sk_X509_NAME_value(Cryptography_STACK_OF_X509_NAME *, int);\nvoid sk_X509_NAME_free(Cryptography_STACK_OF_X509_NAME *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/_cffi_src/openssl/x509v3.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509v3.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EXTENDED_KEY_USAGE;\ntypedef ... CONF;\n\ntypedef struct {\n    X509 *issuer_cert;\n    X509 *subject_cert;\n    ...;\n} X509V3_CTX;\n\nstatic const int GEN_EMAIL;\nstatic const int GEN_DNS;\nstatic const int GEN_URI;\n\ntypedef ... GENERAL_NAMES;\n\n/* Only include the one union element used by pyOpenSSL. */\ntypedef struct {\n    int type;\n    union {\n        ASN1_IA5STRING *ia5;   /* rfc822Name, dNSName, */\n                               /*   uniformResourceIdentifier */\n    } d;\n    ...;\n} GENERAL_NAME;\n\nstatic const long X509V3_EXT_ERROR_UNKNOWN;\n\"\"\"\n\n\nFUNCTIONS = \"\"\"\nvoid X509V3_set_ctx(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int);\nint GENERAL_NAME_print(BIO *, GENERAL_NAME *);\nvoid GENERAL_NAMES_free(GENERAL_NAMES *);\nvoid *X509V3_EXT_d2i(X509_EXTENSION *);\nX509_EXTENSION *X509V3_EXT_nconf(CONF *, X509V3_CTX *, const char *,\n                                 const char *);\n\nvoid X509V3_set_ctx_nodb(X509V3_CTX *);\n\nint sk_GENERAL_NAME_num(GENERAL_NAMES *);\nGENERAL_NAME *sk_GENERAL_NAME_value(GENERAL_NAMES *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/err.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/err.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int EVP_F_EVP_ENCRYPTFINAL_EX;\nstatic const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH;\n\nstatic const int ERR_LIB_EVP;\n\nstatic const int SSL_TLSEXT_ERR_OK;\nstatic const int SSL_TLSEXT_ERR_ALERT_FATAL;\nstatic const int SSL_TLSEXT_ERR_NOACK;\n\nstatic const int SSL_R_UNEXPECTED_EOF_WHILE_READING;\n\nstatic const int Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst char *ERR_lib_error_string(unsigned long);\nconst char *ERR_func_error_string(unsigned long);\nconst char *ERR_reason_error_string(unsigned long);\nunsigned long ERR_get_error(void);\nunsigned long ERR_peek_error(void);\nvoid ERR_clear_error(void);\nvoid ERR_put_error(int, int, int, const char *, int);\n\nint ERR_GET_REASON(unsigned long);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const int EVP_F_EVP_ENCRYPTFINAL_EX = 0;\nstatic const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH = 0;\n#endif\n\n/* SSL_R_UNEXPECTED_EOF_WHILE_READING is needed for pyOpenSSL\n   with OpenSSL 3+ */\n#if defined(SSL_R_UNEXPECTED_EOF_WHILE_READING)\n#define Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING 1\n#else\n#define Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING 0\n#define SSL_R_UNEXPECTED_EOF_WHILE_READING 0\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/nid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/obj_mac.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int Cryptography_HAS_ED448;\n\nstatic const int NID_undef;\nstatic const int NID_aes_256_cbc;\nstatic const int NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\n\nstatic const int NID_subject_alt_name;\nstatic const int NID_crl_reason;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifndef NID_ED448\nstatic const long Cryptography_HAS_ED448 = 0;\n#else\nstatic const long Cryptography_HAS_ED448 = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/evp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/evp.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EVP_CIPHER;\ntypedef ... EVP_MD;\ntypedef ... EVP_MD_CTX;\n\ntypedef ... EVP_PKEY;\ntypedef ... EVP_PKEY_CTX;\nstatic const int EVP_PKEY_RSA;\nstatic const int EVP_PKEY_RSA_PSS;\nstatic const int EVP_PKEY_DSA;\nstatic const int EVP_PKEY_DH;\nstatic const int EVP_PKEY_EC;\nstatic const int EVP_PKEY_X25519;\nstatic const int EVP_PKEY_ED25519;\nstatic const int EVP_MAX_MD_SIZE;\n\nstatic const int Cryptography_HAS_EVP_PKEY_DHX;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *);\n\nconst EVP_MD *EVP_get_digestbyname(const char *);\n\nEVP_PKEY *EVP_PKEY_new(void);\nvoid EVP_PKEY_free(EVP_PKEY *);\nint EVP_PKEY_type(int);\nint EVP_PKEY_size(EVP_PKEY *);\nRSA *EVP_PKEY_get1_RSA(EVP_PKEY *);\n\nint EVP_SignInit(EVP_MD_CTX *, const EVP_MD *);\nint EVP_SignUpdate(EVP_MD_CTX *, const void *, size_t);\nint EVP_SignFinal(EVP_MD_CTX *, unsigned char *, unsigned int *, EVP_PKEY *);\n\nint EVP_VerifyInit(EVP_MD_CTX *, const EVP_MD *);\nint EVP_VerifyUpdate(EVP_MD_CTX *, const void *, size_t);\nint EVP_VerifyFinal(EVP_MD_CTX *, const unsigned char *, unsigned int,\n                    EVP_PKEY *);\n\n\nint EVP_PKEY_set1_RSA(EVP_PKEY *, RSA *);\nint EVP_PKEY_set1_DSA(EVP_PKEY *, DSA *);\n\nint EVP_PKEY_id(const EVP_PKEY *);\n\nEVP_MD_CTX *EVP_MD_CTX_new(void);\nvoid EVP_MD_CTX_free(EVP_MD_CTX *);\n\nint EVP_PKEY_bits(const EVP_PKEY *);\n\nint EVP_PKEY_assign_RSA(EVP_PKEY *, RSA *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef EVP_PKEY_DHX\nconst long Cryptography_HAS_EVP_PKEY_DHX = 1;\n#else\nconst long Cryptography_HAS_EVP_PKEY_DHX = 0;\n#endif\n\"\"\"\n", "src/cryptography/exceptions.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import exceptions as rust_exceptions\n\nif typing.TYPE_CHECKING:\n    from cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n_Reasons = rust_exceptions._Reasons\n\n\nclass UnsupportedAlgorithm(Exception):\n    def __init__(self, message: str, reason: _Reasons | None = None) -> None:\n        super().__init__(message)\n        self._reason = reason\n\n\nclass AlreadyFinalized(Exception):\n    pass\n\n\nclass AlreadyUpdated(Exception):\n    pass\n\n\nclass NotYetFinalized(Exception):\n    pass\n\n\nclass InvalidTag(Exception):\n    pass\n\n\nclass InvalidSignature(Exception):\n    pass\n\n\nclass InternalError(Exception):\n    def __init__(\n        self, msg: str, err_code: list[rust_openssl.OpenSSLError]\n    ) -> None:\n        super().__init__(msg)\n        self.err_code = err_code\n\n\nclass InvalidKey(Exception):\n    pass\n", "src/cryptography/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport enum\nimport sys\nimport types\nimport typing\nimport warnings\n\n\n# We use a UserWarning subclass, instead of DeprecationWarning, because CPython\n# decided deprecation warnings should be invisible by default.\nclass CryptographyDeprecationWarning(UserWarning):\n    pass\n\n\n# Several APIs were deprecated with no specific end-of-life date because of the\n# ubiquity of their use. They should not be removed until we agree on when that\n# cycle ends.\nDeprecatedIn36 = CryptographyDeprecationWarning\nDeprecatedIn37 = CryptographyDeprecationWarning\nDeprecatedIn40 = CryptographyDeprecationWarning\nDeprecatedIn41 = CryptographyDeprecationWarning\nDeprecatedIn42 = CryptographyDeprecationWarning\nDeprecatedIn43 = CryptographyDeprecationWarning\n\n\ndef _check_bytes(name: str, value: bytes) -> None:\n    if not isinstance(value, bytes):\n        raise TypeError(f\"{name} must be bytes\")\n\n\ndef _check_byteslike(name: str, value: bytes) -> None:\n    try:\n        memoryview(value)\n    except TypeError:\n        raise TypeError(f\"{name} must be bytes-like\")\n\n\ndef int_to_bytes(integer: int, length: int | None = None) -> bytes:\n    return integer.to_bytes(\n        length or (integer.bit_length() + 7) // 8 or 1, \"big\"\n    )\n\n\nclass InterfaceNotImplemented(Exception):\n    pass\n\n\nclass _DeprecatedValue:\n    def __init__(self, value: object, message: str, warning_class):\n        self.value = value\n        self.message = message\n        self.warning_class = warning_class\n\n\nclass _ModuleWithDeprecations(types.ModuleType):\n    def __init__(self, module: types.ModuleType):\n        super().__init__(module.__name__)\n        self.__dict__[\"_module\"] = module\n\n    def __getattr__(self, attr: str) -> object:\n        obj = getattr(self._module, attr)\n        if isinstance(obj, _DeprecatedValue):\n            warnings.warn(obj.message, obj.warning_class, stacklevel=2)\n            obj = obj.value\n        return obj\n\n    def __setattr__(self, attr: str, value: object) -> None:\n        setattr(self._module, attr, value)\n\n    def __delattr__(self, attr: str) -> None:\n        obj = getattr(self._module, attr)\n        if isinstance(obj, _DeprecatedValue):\n            warnings.warn(obj.message, obj.warning_class, stacklevel=2)\n\n        delattr(self._module, attr)\n\n    def __dir__(self) -> typing.Sequence[str]:\n        return [\"_module\", *dir(self._module)]\n\n\ndef deprecated(\n    value: object,\n    module_name: str,\n    message: str,\n    warning_class: type[Warning],\n    name: str | None = None,\n) -> _DeprecatedValue:\n    module = sys.modules[module_name]\n    if not isinstance(module, _ModuleWithDeprecations):\n        sys.modules[module_name] = module = _ModuleWithDeprecations(module)\n    dv = _DeprecatedValue(value, message, warning_class)\n    # Maintain backwards compatibility with `name is None` for pyOpenSSL.\n    if name is not None:\n        setattr(module, name, dv)\n    return dv\n\n\ndef cached_property(func: typing.Callable) -> property:\n    cached_name = f\"_cached_{func}\"\n    sentinel = object()\n\n    def inner(instance: object):\n        cache = getattr(instance, cached_name, sentinel)\n        if cache is not sentinel:\n            return cache\n        result = func(instance)\n        setattr(instance, cached_name, result)\n        return result\n\n    return property(inner)\n\n\n# Python 3.10 changed representation of enums. We use well-defined object\n# representation and string representation from Python 3.9.\nclass Enum(enum.Enum):\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}.{self._name_}: {self._value_!r}>\"\n\n    def __str__(self) -> str:\n        return f\"{self.__class__.__name__}.{self._name_}\"\n", "src/cryptography/fernet.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport base64\nimport binascii\nimport os\nimport time\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, padding\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.hmac import HMAC\n\n\nclass InvalidToken(Exception):\n    pass\n\n\n_MAX_CLOCK_SKEW = 60\n\n\nclass Fernet:\n    def __init__(\n        self,\n        key: bytes | str,\n        backend: typing.Any = None,\n    ) -> None:\n        try:\n            key = base64.urlsafe_b64decode(key)\n        except binascii.Error as exc:\n            raise ValueError(\n                \"Fernet key must be 32 url-safe base64-encoded bytes.\"\n            ) from exc\n        if len(key) != 32:\n            raise ValueError(\n                \"Fernet key must be 32 url-safe base64-encoded bytes.\"\n            )\n\n        self._signing_key = key[:16]\n        self._encryption_key = key[16:]\n\n    @classmethod\n    def generate_key(cls) -> bytes:\n        return base64.urlsafe_b64encode(os.urandom(32))\n\n    def encrypt(self, data: bytes) -> bytes:\n        return self.encrypt_at_time(data, int(time.time()))\n\n    def encrypt_at_time(self, data: bytes, current_time: int) -> bytes:\n        iv = os.urandom(16)\n        return self._encrypt_from_parts(data, current_time, iv)\n\n    def _encrypt_from_parts(\n        self, data: bytes, current_time: int, iv: bytes\n    ) -> bytes:\n        utils._check_bytes(\"data\", data)\n\n        padder = padding.PKCS7(algorithms.AES.block_size).padder()\n        padded_data = padder.update(data) + padder.finalize()\n        encryptor = Cipher(\n            algorithms.AES(self._encryption_key),\n            modes.CBC(iv),\n        ).encryptor()\n        ciphertext = encryptor.update(padded_data) + encryptor.finalize()\n\n        basic_parts = (\n            b\"\\x80\"\n            + current_time.to_bytes(length=8, byteorder=\"big\")\n            + iv\n            + ciphertext\n        )\n\n        h = HMAC(self._signing_key, hashes.SHA256())\n        h.update(basic_parts)\n        hmac = h.finalize()\n        return base64.urlsafe_b64encode(basic_parts + hmac)\n\n    def decrypt(self, token: bytes | str, ttl: int | None = None) -> bytes:\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        if ttl is None:\n            time_info = None\n        else:\n            time_info = (ttl, int(time.time()))\n        return self._decrypt_data(data, timestamp, time_info)\n\n    def decrypt_at_time(\n        self, token: bytes | str, ttl: int, current_time: int\n    ) -> bytes:\n        if ttl is None:\n            raise ValueError(\n                \"decrypt_at_time() can only be used with a non-None ttl\"\n            )\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        return self._decrypt_data(data, timestamp, (ttl, current_time))\n\n    def extract_timestamp(self, token: bytes | str) -> int:\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        # Verify the token was not tampered with.\n        self._verify_signature(data)\n        return timestamp\n\n    @staticmethod\n    def _get_unverified_token_data(token: bytes | str) -> tuple[int, bytes]:\n        if not isinstance(token, (str, bytes)):\n            raise TypeError(\"token must be bytes or str\")\n\n        try:\n            data = base64.urlsafe_b64decode(token)\n        except (TypeError, binascii.Error):\n            raise InvalidToken\n\n        if not data or data[0] != 0x80:\n            raise InvalidToken\n\n        if len(data) < 9:\n            raise InvalidToken\n\n        timestamp = int.from_bytes(data[1:9], byteorder=\"big\")\n        return timestamp, data\n\n    def _verify_signature(self, data: bytes) -> None:\n        h = HMAC(self._signing_key, hashes.SHA256())\n        h.update(data[:-32])\n        try:\n            h.verify(data[-32:])\n        except InvalidSignature:\n            raise InvalidToken\n\n    def _decrypt_data(\n        self,\n        data: bytes,\n        timestamp: int,\n        time_info: tuple[int, int] | None,\n    ) -> bytes:\n        if time_info is not None:\n            ttl, current_time = time_info\n            if timestamp + ttl < current_time:\n                raise InvalidToken\n\n            if current_time + _MAX_CLOCK_SKEW < timestamp:\n                raise InvalidToken\n\n        self._verify_signature(data)\n\n        iv = data[9:25]\n        ciphertext = data[25:-32]\n        decryptor = Cipher(\n            algorithms.AES(self._encryption_key), modes.CBC(iv)\n        ).decryptor()\n        plaintext_padded = decryptor.update(ciphertext)\n        try:\n            plaintext_padded += decryptor.finalize()\n        except ValueError:\n            raise InvalidToken\n        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()\n\n        unpadded = unpadder.update(plaintext_padded)\n        try:\n            unpadded += unpadder.finalize()\n        except ValueError:\n            raise InvalidToken\n        return unpadded\n\n\nclass MultiFernet:\n    def __init__(self, fernets: typing.Iterable[Fernet]):\n        fernets = list(fernets)\n        if not fernets:\n            raise ValueError(\n                \"MultiFernet requires at least one Fernet instance\"\n            )\n        self._fernets = fernets\n\n    def encrypt(self, msg: bytes) -> bytes:\n        return self.encrypt_at_time(msg, int(time.time()))\n\n    def encrypt_at_time(self, msg: bytes, current_time: int) -> bytes:\n        return self._fernets[0].encrypt_at_time(msg, current_time)\n\n    def rotate(self, msg: bytes | str) -> bytes:\n        timestamp, data = Fernet._get_unverified_token_data(msg)\n        for f in self._fernets:\n            try:\n                p = f._decrypt_data(data, timestamp, None)\n                break\n            except InvalidToken:\n                pass\n        else:\n            raise InvalidToken\n\n        iv = os.urandom(16)\n        return self._fernets[0]._encrypt_from_parts(p, timestamp, iv)\n\n    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n        for f in self._fernets:\n            try:\n                return f.decrypt(msg, ttl)\n            except InvalidToken:\n                pass\n        raise InvalidToken\n\n    def decrypt_at_time(\n        self, msg: bytes | str, ttl: int, current_time: int\n    ) -> bytes:\n        for f in self._fernets:\n            try:\n                return f.decrypt_at_time(msg, ttl, current_time)\n            except InvalidToken:\n                pass\n        raise InvalidToken\n", "src/cryptography/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.__about__ import __author__, __copyright__, __version__\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__version__\",\n]\n", "src/cryptography/__about__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__version__\",\n]\n\n__version__ = \"43.0.0.dev1\"\n\n\n__author__ = \"The Python Cryptographic Authority and individual contributors\"\n__copyright__ = f\"Copyright 2013-2024 {__author__}\"\n", "src/cryptography/x509/general_name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport ipaddress\nimport typing\nfrom email.utils import parseaddr\n\nfrom cryptography.x509.name import Name\nfrom cryptography.x509.oid import ObjectIdentifier\n\n_IPAddressTypes = typing.Union[\n    ipaddress.IPv4Address,\n    ipaddress.IPv6Address,\n    ipaddress.IPv4Network,\n    ipaddress.IPv6Network,\n]\n\n\nclass UnsupportedGeneralNameType(Exception):\n    pass\n\n\nclass GeneralName(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def value(self) -> typing.Any:\n        \"\"\"\n        Return the value of the object\n        \"\"\"\n\n\nclass RFC822Name(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"RFC822Name values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        name, address = parseaddr(value)\n        if name or not address:\n            # parseaddr has found a name (e.g. Name <email>) or the entire\n            # value is an empty string.\n            raise ValueError(\"Invalid rfc822name value\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> RFC822Name:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<RFC822Name(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RFC822Name):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass DNSName(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"DNSName values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> DNSName:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<DNSName(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DNSName):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass UniformResourceIdentifier(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"URI values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> UniformResourceIdentifier:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<UniformResourceIdentifier(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UniformResourceIdentifier):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass DirectoryName(GeneralName):\n    def __init__(self, value: Name) -> None:\n        if not isinstance(value, Name):\n            raise TypeError(\"value must be a Name\")\n\n        self._value = value\n\n    @property\n    def value(self) -> Name:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<DirectoryName(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DirectoryName):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass RegisteredID(GeneralName):\n    def __init__(self, value: ObjectIdentifier) -> None:\n        if not isinstance(value, ObjectIdentifier):\n            raise TypeError(\"value must be an ObjectIdentifier\")\n\n        self._value = value\n\n    @property\n    def value(self) -> ObjectIdentifier:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<RegisteredID(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RegisteredID):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass IPAddress(GeneralName):\n    def __init__(self, value: _IPAddressTypes) -> None:\n        if not isinstance(\n            value,\n            (\n                ipaddress.IPv4Address,\n                ipaddress.IPv6Address,\n                ipaddress.IPv4Network,\n                ipaddress.IPv6Network,\n            ),\n        ):\n            raise TypeError(\n                \"value must be an instance of ipaddress.IPv4Address, \"\n                \"ipaddress.IPv6Address, ipaddress.IPv4Network, or \"\n                \"ipaddress.IPv6Network\"\n            )\n\n        self._value = value\n\n    @property\n    def value(self) -> _IPAddressTypes:\n        return self._value\n\n    def _packed(self) -> bytes:\n        if isinstance(\n            self.value, (ipaddress.IPv4Address, ipaddress.IPv6Address)\n        ):\n            return self.value.packed\n        else:\n            return (\n                self.value.network_address.packed + self.value.netmask.packed\n            )\n\n    def __repr__(self) -> str:\n        return f\"<IPAddress(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IPAddress):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass OtherName(GeneralName):\n    def __init__(self, type_id: ObjectIdentifier, value: bytes) -> None:\n        if not isinstance(type_id, ObjectIdentifier):\n            raise TypeError(\"type_id must be an ObjectIdentifier\")\n        if not isinstance(value, bytes):\n            raise TypeError(\"value must be a binary string\")\n\n        self._type_id = type_id\n        self._value = value\n\n    @property\n    def type_id(self) -> ObjectIdentifier:\n        return self._type_id\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<OtherName(type_id={self.type_id}, value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OtherName):\n            return NotImplemented\n\n        return self.type_id == other.type_id and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.type_id, self.value))\n", "src/cryptography/x509/name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport binascii\nimport re\nimport sys\nimport typing\nimport warnings\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.x509.oid import NameOID, ObjectIdentifier\n\n\nclass _ASN1Type(utils.Enum):\n    BitString = 3\n    OctetString = 4\n    UTF8String = 12\n    NumericString = 18\n    PrintableString = 19\n    T61String = 20\n    IA5String = 22\n    UTCTime = 23\n    GeneralizedTime = 24\n    VisibleString = 26\n    UniversalString = 28\n    BMPString = 30\n\n\n_ASN1_TYPE_TO_ENUM = {i.value: i for i in _ASN1Type}\n_NAMEOID_DEFAULT_TYPE: dict[ObjectIdentifier, _ASN1Type] = {\n    NameOID.COUNTRY_NAME: _ASN1Type.PrintableString,\n    NameOID.JURISDICTION_COUNTRY_NAME: _ASN1Type.PrintableString,\n    NameOID.SERIAL_NUMBER: _ASN1Type.PrintableString,\n    NameOID.DN_QUALIFIER: _ASN1Type.PrintableString,\n    NameOID.EMAIL_ADDRESS: _ASN1Type.IA5String,\n    NameOID.DOMAIN_COMPONENT: _ASN1Type.IA5String,\n}\n\n# Type alias\n_OidNameMap = typing.Mapping[ObjectIdentifier, str]\n_NameOidMap = typing.Mapping[str, ObjectIdentifier]\n\n#: Short attribute names from RFC 4514:\n#: https://tools.ietf.org/html/rfc4514#page-7\n_NAMEOID_TO_NAME: _OidNameMap = {\n    NameOID.COMMON_NAME: \"CN\",\n    NameOID.LOCALITY_NAME: \"L\",\n    NameOID.STATE_OR_PROVINCE_NAME: \"ST\",\n    NameOID.ORGANIZATION_NAME: \"O\",\n    NameOID.ORGANIZATIONAL_UNIT_NAME: \"OU\",\n    NameOID.COUNTRY_NAME: \"C\",\n    NameOID.STREET_ADDRESS: \"STREET\",\n    NameOID.DOMAIN_COMPONENT: \"DC\",\n    NameOID.USER_ID: \"UID\",\n}\n_NAME_TO_NAMEOID = {v: k for k, v in _NAMEOID_TO_NAME.items()}\n\n\ndef _escape_dn_value(val: str | bytes) -> str:\n    \"\"\"Escape special characters in RFC4514 Distinguished Name value.\"\"\"\n\n    if not val:\n        return \"\"\n\n    # RFC 4514 Section 2.4 defines the value as being the # (U+0023) character\n    # followed by the hexadecimal encoding of the octets.\n    if isinstance(val, bytes):\n        return \"#\" + binascii.hexlify(val).decode(\"utf8\")\n\n    # See https://tools.ietf.org/html/rfc4514#section-2.4\n    val = val.replace(\"\\\\\", \"\\\\\\\\\")\n    val = val.replace('\"', '\\\\\"')\n    val = val.replace(\"+\", \"\\\\+\")\n    val = val.replace(\",\", \"\\\\,\")\n    val = val.replace(\";\", \"\\\\;\")\n    val = val.replace(\"<\", \"\\\\<\")\n    val = val.replace(\">\", \"\\\\>\")\n    val = val.replace(\"\\0\", \"\\\\00\")\n\n    if val[0] in (\"#\", \" \"):\n        val = \"\\\\\" + val\n    if val[-1] == \" \":\n        val = val[:-1] + \"\\\\ \"\n\n    return val\n\n\ndef _unescape_dn_value(val: str) -> str:\n    if not val:\n        return \"\"\n\n    # See https://tools.ietf.org/html/rfc4514#section-3\n\n    # special = escaped / SPACE / SHARP / EQUALS\n    # escaped = DQUOTE / PLUS / COMMA / SEMI / LANGLE / RANGLE\n    def sub(m):\n        val = m.group(1)\n        # Regular escape\n        if len(val) == 1:\n            return val\n        # Hex-value scape\n        return chr(int(val, 16))\n\n    return _RFC4514NameParser._PAIR_RE.sub(sub, val)\n\n\nclass NameAttribute:\n    def __init__(\n        self,\n        oid: ObjectIdentifier,\n        value: str | bytes,\n        _type: _ASN1Type | None = None,\n        *,\n        _validate: bool = True,\n    ) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\n                \"oid argument must be an ObjectIdentifier instance.\"\n            )\n        if _type == _ASN1Type.BitString:\n            if oid != NameOID.X500_UNIQUE_IDENTIFIER:\n                raise TypeError(\n                    \"oid must be X500_UNIQUE_IDENTIFIER for BitString type.\"\n                )\n            if not isinstance(value, bytes):\n                raise TypeError(\"value must be bytes for BitString\")\n        else:\n            if not isinstance(value, str):\n                raise TypeError(\"value argument must be a str\")\n\n        if oid in (NameOID.COUNTRY_NAME, NameOID.JURISDICTION_COUNTRY_NAME):\n            assert isinstance(value, str)\n            c_len = len(value.encode(\"utf8\"))\n            if c_len != 2 and _validate is True:\n                raise ValueError(\n                    \"Country name must be a 2 character country code\"\n                )\n            elif c_len != 2:\n                warnings.warn(\n                    \"Country names should be two characters, but the \"\n                    f\"attribute is {c_len} characters in length.\",\n                    stacklevel=2,\n                )\n\n        # The appropriate ASN1 string type varies by OID and is defined across\n        # multiple RFCs including 2459, 3280, and 5280. In general UTF8String\n        # is preferred (2459), but 3280 and 5280 specify several OIDs with\n        # alternate types. This means when we see the sentinel value we need\n        # to look up whether the OID has a non-UTF8 type. If it does, set it\n        # to that. Otherwise, UTF8!\n        if _type is None:\n            _type = _NAMEOID_DEFAULT_TYPE.get(oid, _ASN1Type.UTF8String)\n\n        if not isinstance(_type, _ASN1Type):\n            raise TypeError(\"_type must be from the _ASN1Type enum\")\n\n        self._oid = oid\n        self._value = value\n        self._type = _type\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def value(self) -> str | bytes:\n        return self._value\n\n    @property\n    def rfc4514_attribute_name(self) -> str:\n        \"\"\"\n        The short attribute name (for example \"CN\") if available,\n        otherwise the OID dotted string.\n        \"\"\"\n        return _NAMEOID_TO_NAME.get(self.oid, self.oid.dotted_string)\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n\n        Use short attribute name if available, otherwise fall back to OID\n        dotted string.\n        \"\"\"\n        attr_name = (\n            attr_name_overrides.get(self.oid) if attr_name_overrides else None\n        )\n        if attr_name is None:\n            attr_name = self.rfc4514_attribute_name\n\n        return f\"{attr_name}={_escape_dn_value(self.value)}\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NameAttribute):\n            return NotImplemented\n\n        return self.oid == other.oid and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value))\n\n    def __repr__(self) -> str:\n        return f\"<NameAttribute(oid={self.oid}, value={self.value!r})>\"\n\n\nclass RelativeDistinguishedName:\n    def __init__(self, attributes: typing.Iterable[NameAttribute]):\n        attributes = list(attributes)\n        if not attributes:\n            raise ValueError(\"a relative distinguished name cannot be empty\")\n        if not all(isinstance(x, NameAttribute) for x in attributes):\n            raise TypeError(\"attributes must be an iterable of NameAttribute\")\n\n        # Keep list and frozenset to preserve attribute order where it matters\n        self._attributes = attributes\n        self._attribute_set = frozenset(attributes)\n\n        if len(self._attribute_set) != len(attributes):\n            raise ValueError(\"duplicate attributes are not allowed\")\n\n    def get_attributes_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> list[NameAttribute]:\n        return [i for i in self if i.oid == oid]\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n\n        Within each RDN, attributes are joined by '+', although that is rarely\n        used in certificates.\n        \"\"\"\n        return \"+\".join(\n            attr.rfc4514_string(attr_name_overrides)\n            for attr in self._attributes\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RelativeDistinguishedName):\n            return NotImplemented\n\n        return self._attribute_set == other._attribute_set\n\n    def __hash__(self) -> int:\n        return hash(self._attribute_set)\n\n    def __iter__(self) -> typing.Iterator[NameAttribute]:\n        return iter(self._attributes)\n\n    def __len__(self) -> int:\n        return len(self._attributes)\n\n    def __repr__(self) -> str:\n        return f\"<RelativeDistinguishedName({self.rfc4514_string()})>\"\n\n\nclass Name:\n    @typing.overload\n    def __init__(self, attributes: typing.Iterable[NameAttribute]) -> None: ...\n\n    @typing.overload\n    def __init__(\n        self, attributes: typing.Iterable[RelativeDistinguishedName]\n    ) -> None: ...\n\n    def __init__(\n        self,\n        attributes: typing.Iterable[NameAttribute | RelativeDistinguishedName],\n    ) -> None:\n        attributes = list(attributes)\n        if all(isinstance(x, NameAttribute) for x in attributes):\n            self._attributes = [\n                RelativeDistinguishedName([typing.cast(NameAttribute, x)])\n                for x in attributes\n            ]\n        elif all(isinstance(x, RelativeDistinguishedName) for x in attributes):\n            self._attributes = typing.cast(\n                typing.List[RelativeDistinguishedName], attributes\n            )\n        else:\n            raise TypeError(\n                \"attributes must be a list of NameAttribute\"\n                \" or a list RelativeDistinguishedName\"\n            )\n\n    @classmethod\n    def from_rfc4514_string(\n        cls,\n        data: str,\n        attr_name_overrides: _NameOidMap | None = None,\n    ) -> Name:\n        return _RFC4514NameParser(data, attr_name_overrides or {}).parse()\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n        For example 'CN=foobar.com,O=Foo Corp,C=US'\n\n        An X.509 name is a two-level structure: a list of sets of attributes.\n        Each list element is separated by ',' and within each list element, set\n        elements are separated by '+'. The latter is almost never used in\n        real world certificates. According to RFC4514 section 2.1 the\n        RDNSequence must be reversed when converting to string representation.\n        \"\"\"\n        return \",\".join(\n            attr.rfc4514_string(attr_name_overrides)\n            for attr in reversed(self._attributes)\n        )\n\n    def get_attributes_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> list[NameAttribute]:\n        return [i for i in self if i.oid == oid]\n\n    @property\n    def rdns(self) -> list[RelativeDistinguishedName]:\n        return self._attributes\n\n    def public_bytes(self, backend: typing.Any = None) -> bytes:\n        return rust_x509.encode_name_bytes(self)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Name):\n            return NotImplemented\n\n        return self._attributes == other._attributes\n\n    def __hash__(self) -> int:\n        # TODO: this is relatively expensive, if this looks like a bottleneck\n        # for you, consider optimizing!\n        return hash(tuple(self._attributes))\n\n    def __iter__(self) -> typing.Iterator[NameAttribute]:\n        for rdn in self._attributes:\n            yield from rdn\n\n    def __len__(self) -> int:\n        return sum(len(rdn) for rdn in self._attributes)\n\n    def __repr__(self) -> str:\n        rdns = \",\".join(attr.rfc4514_string() for attr in self._attributes)\n        return f\"<Name({rdns})>\"\n\n\nclass _RFC4514NameParser:\n    _OID_RE = re.compile(r\"(0|([1-9]\\d*))(\\.(0|([1-9]\\d*)))+\")\n    _DESCR_RE = re.compile(r\"[a-zA-Z][a-zA-Z\\d-]*\")\n\n    _PAIR = r\"\\\\([\\\\ #=\\\"\\+,;<>]|[\\da-zA-Z]{2})\"\n    _PAIR_RE = re.compile(_PAIR)\n    _LUTF1 = r\"[\\x01-\\x1f\\x21\\x24-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _SUTF1 = r\"[\\x01-\\x21\\x23-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _TUTF1 = r\"[\\x01-\\x1F\\x21\\x23-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _UTFMB = rf\"[\\x80-{chr(sys.maxunicode)}]\"\n    _LEADCHAR = rf\"{_LUTF1}|{_UTFMB}\"\n    _STRINGCHAR = rf\"{_SUTF1}|{_UTFMB}\"\n    _TRAILCHAR = rf\"{_TUTF1}|{_UTFMB}\"\n    _STRING_RE = re.compile(\n        rf\"\"\"\n        (\n            ({_LEADCHAR}|{_PAIR})\n            (\n                ({_STRINGCHAR}|{_PAIR})*\n                ({_TRAILCHAR}|{_PAIR})\n            )?\n        )?\n        \"\"\",\n        re.VERBOSE,\n    )\n    _HEXSTRING_RE = re.compile(r\"#([\\da-zA-Z]{2})+\")\n\n    def __init__(self, data: str, attr_name_overrides: _NameOidMap) -> None:\n        self._data = data\n        self._idx = 0\n\n        self._attr_name_overrides = attr_name_overrides\n\n    def _has_data(self) -> bool:\n        return self._idx < len(self._data)\n\n    def _peek(self) -> str | None:\n        if self._has_data():\n            return self._data[self._idx]\n        return None\n\n    def _read_char(self, ch: str) -> None:\n        if self._peek() != ch:\n            raise ValueError\n        self._idx += 1\n\n    def _read_re(self, pat) -> str:\n        match = pat.match(self._data, pos=self._idx)\n        if match is None:\n            raise ValueError\n        val = match.group()\n        self._idx += len(val)\n        return val\n\n    def parse(self) -> Name:\n        \"\"\"\n        Parses the `data` string and converts it to a Name.\n\n        According to RFC4514 section 2.1 the RDNSequence must be\n        reversed when converting to string representation. So, when\n        we parse it, we need to reverse again to get the RDNs on the\n        correct order.\n        \"\"\"\n\n        if not self._has_data():\n            return Name([])\n\n        rdns = [self._parse_rdn()]\n\n        while self._has_data():\n            self._read_char(\",\")\n            rdns.append(self._parse_rdn())\n\n        return Name(reversed(rdns))\n\n    def _parse_rdn(self) -> RelativeDistinguishedName:\n        nas = [self._parse_na()]\n        while self._peek() == \"+\":\n            self._read_char(\"+\")\n            nas.append(self._parse_na())\n\n        return RelativeDistinguishedName(nas)\n\n    def _parse_na(self) -> NameAttribute:\n        try:\n            oid_value = self._read_re(self._OID_RE)\n        except ValueError:\n            name = self._read_re(self._DESCR_RE)\n            oid = self._attr_name_overrides.get(\n                name, _NAME_TO_NAMEOID.get(name)\n            )\n            if oid is None:\n                raise ValueError\n        else:\n            oid = ObjectIdentifier(oid_value)\n\n        self._read_char(\"=\")\n        if self._peek() == \"#\":\n            value = self._read_re(self._HEXSTRING_RE)\n            value = binascii.unhexlify(value[1:]).decode()\n        else:\n            raw_value = self._read_re(self._STRING_RE)\n            value = _unescape_dn_value(raw_value)\n\n        return NameAttribute(oid, value)\n", "src/cryptography/x509/certificate_transparency.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives.hashes import HashAlgorithm\n\n\nclass LogEntryType(utils.Enum):\n    X509_CERTIFICATE = 0\n    PRE_CERTIFICATE = 1\n\n\nclass Version(utils.Enum):\n    v1 = 0\n\n\nclass SignatureAlgorithm(utils.Enum):\n    \"\"\"\n    Signature algorithms that are valid for SCTs.\n\n    These are exactly the same as SignatureAlgorithm in RFC 5246 (TLS 1.2).\n\n    See: <https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.1.4.1>\n    \"\"\"\n\n    ANONYMOUS = 0\n    RSA = 1\n    DSA = 2\n    ECDSA = 3\n\n\nclass SignedCertificateTimestamp(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def version(self) -> Version:\n        \"\"\"\n        Returns the SCT version.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def log_id(self) -> bytes:\n        \"\"\"\n        Returns an identifier indicating which log this SCT is for.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def timestamp(self) -> datetime.datetime:\n        \"\"\"\n        Returns the timestamp for this SCT.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def entry_type(self) -> LogEntryType:\n        \"\"\"\n        Returns whether this is an SCT for a certificate or pre-certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(self) -> HashAlgorithm:\n        \"\"\"\n        Returns the hash algorithm used for the SCT's signature.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm(self) -> SignatureAlgorithm:\n        \"\"\"\n        Returns the signing algorithm used for the SCT's signature.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature for this SCT.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extension_bytes(self) -> bytes:\n        \"\"\"\n        Returns the raw bytes of any extensions for this SCT.\n        \"\"\"\n\n\nSignedCertificateTimestamp.register(rust_x509.Sct)\n", "src/cryptography/x509/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport os\nimport typing\nimport warnings\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    padding,\n    rsa,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPrivateKeyTypes,\n    CertificateIssuerPublicKeyTypes,\n    CertificatePublicKeyTypes,\n)\nfrom cryptography.x509.extensions import (\n    Extension,\n    Extensions,\n    ExtensionType,\n    _make_sequence_methods,\n)\nfrom cryptography.x509.name import Name, _ASN1Type\nfrom cryptography.x509.oid import ObjectIdentifier\n\n_EARLIEST_UTC_TIME = datetime.datetime(1950, 1, 1)\n\n# This must be kept in sync with sign.rs's list of allowable types in\n# identify_hash_type\n_AllowedHashTypes = typing.Union[\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n    hashes.SHA3_224,\n    hashes.SHA3_256,\n    hashes.SHA3_384,\n    hashes.SHA3_512,\n]\n\n\nclass AttributeNotFound(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\ndef _reject_duplicate_extension(\n    extension: Extension[ExtensionType],\n    extensions: list[Extension[ExtensionType]],\n) -> None:\n    # This is quadratic in the number of extensions\n    for e in extensions:\n        if e.oid == extension.oid:\n            raise ValueError(\"This extension has already been set.\")\n\n\ndef _reject_duplicate_attribute(\n    oid: ObjectIdentifier,\n    attributes: list[tuple[ObjectIdentifier, bytes, int | None]],\n) -> None:\n    # This is quadratic in the number of attributes\n    for attr_oid, _, _ in attributes:\n        if attr_oid == oid:\n            raise ValueError(\"This attribute has already been set.\")\n\n\ndef _convert_to_naive_utc_time(time: datetime.datetime) -> datetime.datetime:\n    \"\"\"Normalizes a datetime to a naive datetime in UTC.\n\n    time -- datetime to normalize. Assumed to be in UTC if not timezone\n            aware.\n    \"\"\"\n    if time.tzinfo is not None:\n        offset = time.utcoffset()\n        offset = offset if offset else datetime.timedelta()\n        return time.replace(tzinfo=None) - offset\n    else:\n        return time\n\n\nclass Attribute:\n    def __init__(\n        self,\n        oid: ObjectIdentifier,\n        value: bytes,\n        _type: int = _ASN1Type.UTF8String.value,\n    ) -> None:\n        self._oid = oid\n        self._value = value\n        self._type = _type\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<Attribute(oid={self.oid}, value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Attribute):\n            return NotImplemented\n\n        return (\n            self.oid == other.oid\n            and self.value == other.value\n            and self._type == other._type\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value, self._type))\n\n\nclass Attributes:\n    def __init__(\n        self,\n        attributes: typing.Iterable[Attribute],\n    ) -> None:\n        self._attributes = list(attributes)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_attributes\")\n\n    def __repr__(self) -> str:\n        return f\"<Attributes({self._attributes})>\"\n\n    def get_attribute_for_oid(self, oid: ObjectIdentifier) -> Attribute:\n        for attr in self:\n            if attr.oid == oid:\n                return attr\n\n        raise AttributeNotFound(f\"No {oid} attribute was found\", oid)\n\n\nclass Version(utils.Enum):\n    v1 = 0\n    v3 = 2\n\n\nclass InvalidVersion(Exception):\n    def __init__(self, msg: str, parsed_version: int) -> None:\n        super().__init__(msg)\n        self.parsed_version = parsed_version\n\n\nclass Certificate(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def fingerprint(self, algorithm: hashes.HashAlgorithm) -> bytes:\n        \"\"\"\n        Returns bytes using digest passed.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        Returns certificate serial number\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def version(self) -> Version:\n        \"\"\"\n        Returns the certificate version\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> CertificatePublicKeyTypes:\n        \"\"\"\n        Returns the public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def public_key_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the public key.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_before(self) -> datetime.datetime:\n        \"\"\"\n        Not before time (represented as UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_before_utc(self) -> datetime.datetime:\n        \"\"\"\n        Not before time (represented as a non-naive UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_after(self) -> datetime.datetime:\n        \"\"\"\n        Not after time (represented as UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_after_utc(self) -> datetime.datetime:\n        \"\"\"\n        Not after time (represented as a non-naive UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer(self) -> Name:\n        \"\"\"\n        Returns the issuer name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def subject(self) -> Name:\n        \"\"\"\n        Returns the subject name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certificate_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertificate payload bytes as defined in RFC 5280.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_precertificate_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertificate payload bytes with the SCT list extension\n        stripped.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Computes a hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the certificate to PEM or DER format.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify_directly_issued_by(self, issuer: Certificate) -> None:\n        \"\"\"\n        This method verifies that certificate issuer name matches the\n        issuer subject name and that the certificate is signed by the\n        issuer's private key. No other validation is performed.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nCertificate.register(rust_x509.Certificate)\n\n\nclass RevokedCertificate(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        Returns the serial number of the revoked certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_date(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of when this certificate was revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_date_utc(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of when this certificate was revoked as a non-naive\n        UTC datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object containing a list of Revoked extensions.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nRevokedCertificate.register(rust_x509.RevokedCertificate)\n\n\nclass _RawRevokedCertificate(RevokedCertificate):\n    def __init__(\n        self,\n        serial_number: int,\n        revocation_date: datetime.datetime,\n        extensions: Extensions,\n    ):\n        self._serial_number = serial_number\n        self._revocation_date = revocation_date\n        self._extensions = extensions\n\n    @property\n    def serial_number(self) -> int:\n        return self._serial_number\n\n    @property\n    def revocation_date(self) -> datetime.datetime:\n        warnings.warn(\n            \"Properties that return a na\u00efve datetime object have been \"\n            \"deprecated. Please switch to revocation_date_utc.\",\n            utils.DeprecatedIn42,\n            stacklevel=2,\n        )\n        return self._revocation_date\n\n    @property\n    def revocation_date_utc(self) -> datetime.datetime:\n        return self._revocation_date.replace(tzinfo=datetime.timezone.utc)\n\n    @property\n    def extensions(self) -> Extensions:\n        return self._extensions\n\n\nclass CertificateRevocationList(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the CRL to PEM or DER format.\n        \"\"\"\n\n    @abc.abstractmethod\n    def fingerprint(self, algorithm: hashes.HashAlgorithm) -> bytes:\n        \"\"\"\n        Returns bytes using digest passed.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_revoked_certificate_by_serial_number(\n        self, serial_number: int\n    ) -> RevokedCertificate | None:\n        \"\"\"\n        Returns an instance of RevokedCertificate or None if the serial_number\n        is not in the CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer(self) -> Name:\n        \"\"\"\n        Returns the X509Name with the issuer of this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        Returns the date of next update for this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update_utc(self) -> datetime.datetime | None:\n        \"\"\"\n        Returns the date of next update for this CRL as a non-naive UTC\n        datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def last_update(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of last update for this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def last_update_utc(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of last update for this CRL as a non-naive UTC\n        datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object containing a list of CRL extensions.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certlist_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertList payload bytes as defined in RFC 5280.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __len__(self) -> int:\n        \"\"\"\n        Number of revoked certificates in the CRL.\n        \"\"\"\n\n    @typing.overload\n    def __getitem__(self, idx: int) -> RevokedCertificate: ...\n\n    @typing.overload\n    def __getitem__(self, idx: slice) -> list[RevokedCertificate]: ...\n\n    @abc.abstractmethod\n    def __getitem__(\n        self, idx: int | slice\n    ) -> RevokedCertificate | list[RevokedCertificate]:\n        \"\"\"\n        Returns a revoked certificate (or slice of revoked certificates).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> typing.Iterator[RevokedCertificate]:\n        \"\"\"\n        Iterator over the revoked certificates\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_signature_valid(\n        self, public_key: CertificateIssuerPublicKeyTypes\n    ) -> bool:\n        \"\"\"\n        Verifies signature of revocation list against given public key.\n        \"\"\"\n\n\nCertificateRevocationList.register(rust_x509.CertificateRevocationList)\n\n\nclass CertificateSigningRequest(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Computes a hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> CertificatePublicKeyTypes:\n        \"\"\"\n        Returns the public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def subject(self) -> Name:\n        \"\"\"\n        Returns the subject name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns the extensions in the signing request.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def attributes(self) -> Attributes:\n        \"\"\"\n        Returns an Attributes object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Encodes the request to PEM or DER format.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certrequest_bytes(self) -> bytes:\n        \"\"\"\n        Returns the PKCS#10 CertificationRequestInfo bytes as defined in RFC\n        2986.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_signature_valid(self) -> bool:\n        \"\"\"\n        Verifies signature of signing request.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_attribute_for_oid(self, oid: ObjectIdentifier) -> bytes:\n        \"\"\"\n        Get the attribute value for a given OID.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nCertificateSigningRequest.register(rust_x509.CertificateSigningRequest)\n\n\nload_pem_x509_certificate = rust_x509.load_pem_x509_certificate\nload_der_x509_certificate = rust_x509.load_der_x509_certificate\n\nload_pem_x509_certificates = rust_x509.load_pem_x509_certificates\n\nload_pem_x509_csr = rust_x509.load_pem_x509_csr\nload_der_x509_csr = rust_x509.load_der_x509_csr\n\nload_pem_x509_crl = rust_x509.load_pem_x509_crl\nload_der_x509_crl = rust_x509.load_der_x509_crl\n\n\nclass CertificateSigningRequestBuilder:\n    def __init__(\n        self,\n        subject_name: Name | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n        attributes: list[tuple[ObjectIdentifier, bytes, int | None]] = [],\n    ):\n        \"\"\"\n        Creates an empty X.509 certificate request (v1).\n        \"\"\"\n        self._subject_name = subject_name\n        self._extensions = extensions\n        self._attributes = attributes\n\n    def subject_name(self, name: Name) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Sets the certificate requestor's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._subject_name is not None:\n            raise ValueError(\"The subject name may only be set once.\")\n        return CertificateSigningRequestBuilder(\n            name, self._extensions, self._attributes\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate request.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return CertificateSigningRequestBuilder(\n            self._subject_name,\n            [*self._extensions, extension],\n            self._attributes,\n        )\n\n    def add_attribute(\n        self,\n        oid: ObjectIdentifier,\n        value: bytes,\n        *,\n        _tag: _ASN1Type | None = None,\n    ) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Adds an X.509 attribute with an OID and associated value.\n        \"\"\"\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n\n        if not isinstance(value, bytes):\n            raise TypeError(\"value must be bytes\")\n\n        if _tag is not None and not isinstance(_tag, _ASN1Type):\n            raise TypeError(\"tag must be _ASN1Type\")\n\n        _reject_duplicate_attribute(oid, self._attributes)\n\n        if _tag is not None:\n            tag = _tag.value\n        else:\n            tag = None\n\n        return CertificateSigningRequestBuilder(\n            self._subject_name,\n            self._extensions,\n            [*self._attributes, (oid, value, tag)],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> CertificateSigningRequest:\n        \"\"\"\n        Signs the request using the requestor's private key.\n        \"\"\"\n        if self._subject_name is None:\n            raise ValueError(\"A CertificateSigningRequest must have a subject\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_csr(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass CertificateBuilder:\n    _extensions: list[Extension[ExtensionType]]\n\n    def __init__(\n        self,\n        issuer_name: Name | None = None,\n        subject_name: Name | None = None,\n        public_key: CertificatePublicKeyTypes | None = None,\n        serial_number: int | None = None,\n        not_valid_before: datetime.datetime | None = None,\n        not_valid_after: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n    ) -> None:\n        self._version = Version.v3\n        self._issuer_name = issuer_name\n        self._subject_name = subject_name\n        self._public_key = public_key\n        self._serial_number = serial_number\n        self._not_valid_before = not_valid_before\n        self._not_valid_after = not_valid_after\n        self._extensions = extensions\n\n    def issuer_name(self, name: Name) -> CertificateBuilder:\n        \"\"\"\n        Sets the CA's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._issuer_name is not None:\n            raise ValueError(\"The issuer name may only be set once.\")\n        return CertificateBuilder(\n            name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def subject_name(self, name: Name) -> CertificateBuilder:\n        \"\"\"\n        Sets the requestor's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._subject_name is not None:\n            raise ValueError(\"The subject name may only be set once.\")\n        return CertificateBuilder(\n            self._issuer_name,\n            name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def public_key(\n        self,\n        key: CertificatePublicKeyTypes,\n    ) -> CertificateBuilder:\n        \"\"\"\n        Sets the requestor's public key (as found in the signing request).\n        \"\"\"\n        if not isinstance(\n            key,\n            (\n                dsa.DSAPublicKey,\n                rsa.RSAPublicKey,\n                ec.EllipticCurvePublicKey,\n                ed25519.Ed25519PublicKey,\n                ed448.Ed448PublicKey,\n                x25519.X25519PublicKey,\n                x448.X448PublicKey,\n            ),\n        ):\n            raise TypeError(\n                \"Expecting one of DSAPublicKey, RSAPublicKey,\"\n                \" EllipticCurvePublicKey, Ed25519PublicKey,\"\n                \" Ed448PublicKey, X25519PublicKey, or \"\n                \"X448PublicKey.\"\n            )\n        if self._public_key is not None:\n            raise ValueError(\"The public key may only be set once.\")\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def serial_number(self, number: int) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate serial number.\n        \"\"\"\n        if not isinstance(number, int):\n            raise TypeError(\"Serial number must be of integral type.\")\n        if self._serial_number is not None:\n            raise ValueError(\"The serial number may only be set once.\")\n        if number <= 0:\n            raise ValueError(\"The serial number should be positive.\")\n\n        # ASN.1 integers are always signed, so most significant bit must be\n        # zero.\n        if number.bit_length() >= 160:  # As defined in RFC 5280\n            raise ValueError(\n                \"The serial number should not be more than 159 bits.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def not_valid_before(self, time: datetime.datetime) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate activation time.\n        \"\"\"\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._not_valid_before is not None:\n            raise ValueError(\"The not valid before may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The not valid before date must be on or after\"\n                \" 1950 January 1).\"\n            )\n        if self._not_valid_after is not None and time > self._not_valid_after:\n            raise ValueError(\n                \"The not valid before date must be before the not valid after \"\n                \"date.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            time,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def not_valid_after(self, time: datetime.datetime) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate expiration time.\n        \"\"\"\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._not_valid_after is not None:\n            raise ValueError(\"The not valid after may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The not valid after date must be on or after\"\n                \" 1950 January 1.\"\n            )\n        if (\n            self._not_valid_before is not None\n            and time < self._not_valid_before\n        ):\n            raise ValueError(\n                \"The not valid after date must be after the not valid before \"\n                \"date.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            time,\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            [*self._extensions, extension],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> Certificate:\n        \"\"\"\n        Signs the certificate using the CA's private key.\n        \"\"\"\n        if self._subject_name is None:\n            raise ValueError(\"A certificate must have a subject name\")\n\n        if self._issuer_name is None:\n            raise ValueError(\"A certificate must have an issuer name\")\n\n        if self._serial_number is None:\n            raise ValueError(\"A certificate must have a serial number\")\n\n        if self._not_valid_before is None:\n            raise ValueError(\"A certificate must have a not valid before time\")\n\n        if self._not_valid_after is None:\n            raise ValueError(\"A certificate must have a not valid after time\")\n\n        if self._public_key is None:\n            raise ValueError(\"A certificate must have a public key\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_certificate(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass CertificateRevocationListBuilder:\n    _extensions: list[Extension[ExtensionType]]\n    _revoked_certificates: list[RevokedCertificate]\n\n    def __init__(\n        self,\n        issuer_name: Name | None = None,\n        last_update: datetime.datetime | None = None,\n        next_update: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n        revoked_certificates: list[RevokedCertificate] = [],\n    ):\n        self._issuer_name = issuer_name\n        self._last_update = last_update\n        self._next_update = next_update\n        self._extensions = extensions\n        self._revoked_certificates = revoked_certificates\n\n    def issuer_name(\n        self, issuer_name: Name\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(issuer_name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._issuer_name is not None:\n            raise ValueError(\"The issuer name may only be set once.\")\n        return CertificateRevocationListBuilder(\n            issuer_name,\n            self._last_update,\n            self._next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def last_update(\n        self, last_update: datetime.datetime\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(last_update, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._last_update is not None:\n            raise ValueError(\"Last update may only be set once.\")\n        last_update = _convert_to_naive_utc_time(last_update)\n        if last_update < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The last update date must be on or after 1950 January 1.\"\n            )\n        if self._next_update is not None and last_update > self._next_update:\n            raise ValueError(\n                \"The last update date must be before the next update date.\"\n            )\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            last_update,\n            self._next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def next_update(\n        self, next_update: datetime.datetime\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(next_update, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._next_update is not None:\n            raise ValueError(\"Last update may only be set once.\")\n        next_update = _convert_to_naive_utc_time(next_update)\n        if next_update < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The last update date must be on or after 1950 January 1.\"\n            )\n        if self._last_update is not None and next_update < self._last_update:\n            raise ValueError(\n                \"The next update date must be after the last update date.\"\n            )\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateRevocationListBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate revocation list.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            self._next_update,\n            [*self._extensions, extension],\n            self._revoked_certificates,\n        )\n\n    def add_revoked_certificate(\n        self, revoked_certificate: RevokedCertificate\n    ) -> CertificateRevocationListBuilder:\n        \"\"\"\n        Adds a revoked certificate to the CRL.\n        \"\"\"\n        if not isinstance(revoked_certificate, RevokedCertificate):\n            raise TypeError(\"Must be an instance of RevokedCertificate\")\n\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            self._next_update,\n            self._extensions,\n            [*self._revoked_certificates, revoked_certificate],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> CertificateRevocationList:\n        if self._issuer_name is None:\n            raise ValueError(\"A CRL must have an issuer name\")\n\n        if self._last_update is None:\n            raise ValueError(\"A CRL must have a last update time\")\n\n        if self._next_update is None:\n            raise ValueError(\"A CRL must have a next update time\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_crl(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass RevokedCertificateBuilder:\n    def __init__(\n        self,\n        serial_number: int | None = None,\n        revocation_date: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n    ):\n        self._serial_number = serial_number\n        self._revocation_date = revocation_date\n        self._extensions = extensions\n\n    def serial_number(self, number: int) -> RevokedCertificateBuilder:\n        if not isinstance(number, int):\n            raise TypeError(\"Serial number must be of integral type.\")\n        if self._serial_number is not None:\n            raise ValueError(\"The serial number may only be set once.\")\n        if number <= 0:\n            raise ValueError(\"The serial number should be positive\")\n\n        # ASN.1 integers are always signed, so most significant bit must be\n        # zero.\n        if number.bit_length() >= 160:  # As defined in RFC 5280\n            raise ValueError(\n                \"The serial number should not be more than 159 bits.\"\n            )\n        return RevokedCertificateBuilder(\n            number, self._revocation_date, self._extensions\n        )\n\n    def revocation_date(\n        self, time: datetime.datetime\n    ) -> RevokedCertificateBuilder:\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._revocation_date is not None:\n            raise ValueError(\"The revocation date may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The revocation date must be on or after 1950 January 1.\"\n            )\n        return RevokedCertificateBuilder(\n            self._serial_number, time, self._extensions\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> RevokedCertificateBuilder:\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n        return RevokedCertificateBuilder(\n            self._serial_number,\n            self._revocation_date,\n            [*self._extensions, extension],\n        )\n\n    def build(self, backend: typing.Any = None) -> RevokedCertificate:\n        if self._serial_number is None:\n            raise ValueError(\"A revoked certificate must have a serial number\")\n        if self._revocation_date is None:\n            raise ValueError(\n                \"A revoked certificate must have a revocation date\"\n            )\n        return _RawRevokedCertificate(\n            self._serial_number,\n            self._revocation_date,\n            Extensions(self._extensions),\n        )\n\n\ndef random_serial_number() -> int:\n    return int.from_bytes(os.urandom(20), \"big\") >> 1\n", "src/cryptography/x509/verification.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.x509.general_name import DNSName, IPAddress\n\n__all__ = [\n    \"ClientVerifier\",\n    \"PolicyBuilder\",\n    \"ServerVerifier\",\n    \"Store\",\n    \"Subject\",\n    \"VerificationError\",\n    \"VerifiedClient\",\n]\n\nStore = rust_x509.Store\nSubject = typing.Union[DNSName, IPAddress]\nVerifiedClient = rust_x509.VerifiedClient\nClientVerifier = rust_x509.ClientVerifier\nServerVerifier = rust_x509.ServerVerifier\nPolicyBuilder = rust_x509.PolicyBuilder\nVerificationError = rust_x509.VerificationError\n", "src/cryptography/x509/extensions.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport hashlib\nimport ipaddress\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import asn1\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives import constant_time, serialization\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPublicKeyTypes,\n    CertificatePublicKeyTypes,\n)\nfrom cryptography.x509.certificate_transparency import (\n    SignedCertificateTimestamp,\n)\nfrom cryptography.x509.general_name import (\n    DirectoryName,\n    DNSName,\n    GeneralName,\n    IPAddress,\n    OtherName,\n    RegisteredID,\n    RFC822Name,\n    UniformResourceIdentifier,\n    _IPAddressTypes,\n)\nfrom cryptography.x509.name import Name, RelativeDistinguishedName\nfrom cryptography.x509.oid import (\n    CRLEntryExtensionOID,\n    ExtensionOID,\n    ObjectIdentifier,\n    OCSPExtensionOID,\n)\n\nExtensionTypeVar = typing.TypeVar(\n    \"ExtensionTypeVar\", bound=\"ExtensionType\", covariant=True\n)\n\n\ndef _key_identifier_from_public_key(\n    public_key: CertificatePublicKeyTypes,\n) -> bytes:\n    if isinstance(public_key, RSAPublicKey):\n        data = public_key.public_bytes(\n            serialization.Encoding.DER,\n            serialization.PublicFormat.PKCS1,\n        )\n    elif isinstance(public_key, EllipticCurvePublicKey):\n        data = public_key.public_bytes(\n            serialization.Encoding.X962,\n            serialization.PublicFormat.UncompressedPoint,\n        )\n    else:\n        # This is a very slow way to do this.\n        serialized = public_key.public_bytes(\n            serialization.Encoding.DER,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        data = asn1.parse_spki_for_data(serialized)\n\n    return hashlib.sha1(data).digest()\n\n\ndef _make_sequence_methods(field_name: str):\n    def len_method(self) -> int:\n        return len(getattr(self, field_name))\n\n    def iter_method(self):\n        return iter(getattr(self, field_name))\n\n    def getitem_method(self, idx):\n        return getattr(self, field_name)[idx]\n\n    return len_method, iter_method, getitem_method\n\n\nclass DuplicateExtension(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\nclass ExtensionNotFound(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\nclass ExtensionType(metaclass=abc.ABCMeta):\n    oid: typing.ClassVar[ObjectIdentifier]\n\n    def public_bytes(self) -> bytes:\n        \"\"\"\n        Serializes the extension type to DER.\n        \"\"\"\n        raise NotImplementedError(\n            f\"public_bytes is not implemented for extension type {self!r}\"\n        )\n\n\nclass Extensions:\n    def __init__(\n        self, extensions: typing.Iterable[Extension[ExtensionType]]\n    ) -> None:\n        self._extensions = list(extensions)\n\n    def get_extension_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> Extension[ExtensionType]:\n        for ext in self:\n            if ext.oid == oid:\n                return ext\n\n        raise ExtensionNotFound(f\"No {oid} extension was found\", oid)\n\n    def get_extension_for_class(\n        self, extclass: type[ExtensionTypeVar]\n    ) -> Extension[ExtensionTypeVar]:\n        if extclass is UnrecognizedExtension:\n            raise TypeError(\n                \"UnrecognizedExtension can't be used with \"\n                \"get_extension_for_class because more than one instance of the\"\n                \" class may be present.\"\n            )\n\n        for ext in self:\n            if isinstance(ext.value, extclass):\n                return ext\n\n        raise ExtensionNotFound(\n            f\"No {extclass} extension was found\", extclass.oid\n        )\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_extensions\")\n\n    def __repr__(self) -> str:\n        return f\"<Extensions({self._extensions})>\"\n\n\nclass CRLNumber(ExtensionType):\n    oid = ExtensionOID.CRL_NUMBER\n\n    def __init__(self, crl_number: int) -> None:\n        if not isinstance(crl_number, int):\n            raise TypeError(\"crl_number must be an integer\")\n\n        self._crl_number = crl_number\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLNumber):\n            return NotImplemented\n\n        return self.crl_number == other.crl_number\n\n    def __hash__(self) -> int:\n        return hash(self.crl_number)\n\n    def __repr__(self) -> str:\n        return f\"<CRLNumber({self.crl_number})>\"\n\n    @property\n    def crl_number(self) -> int:\n        return self._crl_number\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AuthorityKeyIdentifier(ExtensionType):\n    oid = ExtensionOID.AUTHORITY_KEY_IDENTIFIER\n\n    def __init__(\n        self,\n        key_identifier: bytes | None,\n        authority_cert_issuer: typing.Iterable[GeneralName] | None,\n        authority_cert_serial_number: int | None,\n    ) -> None:\n        if (authority_cert_issuer is None) != (\n            authority_cert_serial_number is None\n        ):\n            raise ValueError(\n                \"authority_cert_issuer and authority_cert_serial_number \"\n                \"must both be present or both None\"\n            )\n\n        if authority_cert_issuer is not None:\n            authority_cert_issuer = list(authority_cert_issuer)\n            if not all(\n                isinstance(x, GeneralName) for x in authority_cert_issuer\n            ):\n                raise TypeError(\n                    \"authority_cert_issuer must be a list of GeneralName \"\n                    \"objects\"\n                )\n\n        if authority_cert_serial_number is not None and not isinstance(\n            authority_cert_serial_number, int\n        ):\n            raise TypeError(\"authority_cert_serial_number must be an integer\")\n\n        self._key_identifier = key_identifier\n        self._authority_cert_issuer = authority_cert_issuer\n        self._authority_cert_serial_number = authority_cert_serial_number\n\n    # This takes a subset of CertificatePublicKeyTypes because an issuer\n    # cannot have an X25519/X448 key. This introduces some unfortunate\n    # asymmetry that requires typing users to explicitly\n    # narrow their type, but we should make this accurate and not just\n    # convenient.\n    @classmethod\n    def from_issuer_public_key(\n        cls, public_key: CertificateIssuerPublicKeyTypes\n    ) -> AuthorityKeyIdentifier:\n        digest = _key_identifier_from_public_key(public_key)\n        return cls(\n            key_identifier=digest,\n            authority_cert_issuer=None,\n            authority_cert_serial_number=None,\n        )\n\n    @classmethod\n    def from_issuer_subject_key_identifier(\n        cls, ski: SubjectKeyIdentifier\n    ) -> AuthorityKeyIdentifier:\n        return cls(\n            key_identifier=ski.digest,\n            authority_cert_issuer=None,\n            authority_cert_serial_number=None,\n        )\n\n    def __repr__(self) -> str:\n        return (\n            f\"<AuthorityKeyIdentifier(key_identifier={self.key_identifier!r}, \"\n            f\"authority_cert_issuer={self.authority_cert_issuer}, \"\n            f\"authority_cert_serial_number={self.authority_cert_serial_number}\"\n            \")>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AuthorityKeyIdentifier):\n            return NotImplemented\n\n        return (\n            self.key_identifier == other.key_identifier\n            and self.authority_cert_issuer == other.authority_cert_issuer\n            and self.authority_cert_serial_number\n            == other.authority_cert_serial_number\n        )\n\n    def __hash__(self) -> int:\n        if self.authority_cert_issuer is None:\n            aci = None\n        else:\n            aci = tuple(self.authority_cert_issuer)\n        return hash(\n            (self.key_identifier, aci, self.authority_cert_serial_number)\n        )\n\n    @property\n    def key_identifier(self) -> bytes | None:\n        return self._key_identifier\n\n    @property\n    def authority_cert_issuer(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._authority_cert_issuer\n\n    @property\n    def authority_cert_serial_number(self) -> int | None:\n        return self._authority_cert_serial_number\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SubjectKeyIdentifier(ExtensionType):\n    oid = ExtensionOID.SUBJECT_KEY_IDENTIFIER\n\n    def __init__(self, digest: bytes) -> None:\n        self._digest = digest\n\n    @classmethod\n    def from_public_key(\n        cls, public_key: CertificatePublicKeyTypes\n    ) -> SubjectKeyIdentifier:\n        return cls(_key_identifier_from_public_key(public_key))\n\n    @property\n    def digest(self) -> bytes:\n        return self._digest\n\n    @property\n    def key_identifier(self) -> bytes:\n        return self._digest\n\n    def __repr__(self) -> str:\n        return f\"<SubjectKeyIdentifier(digest={self.digest!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectKeyIdentifier):\n            return NotImplemented\n\n        return constant_time.bytes_eq(self.digest, other.digest)\n\n    def __hash__(self) -> int:\n        return hash(self.digest)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AuthorityInformationAccess(ExtensionType):\n    oid = ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n\n    def __init__(\n        self, descriptions: typing.Iterable[AccessDescription]\n    ) -> None:\n        descriptions = list(descriptions)\n        if not all(isinstance(x, AccessDescription) for x in descriptions):\n            raise TypeError(\n                \"Every item in the descriptions list must be an \"\n                \"AccessDescription\"\n            )\n\n        self._descriptions = descriptions\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_descriptions\")\n\n    def __repr__(self) -> str:\n        return f\"<AuthorityInformationAccess({self._descriptions})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AuthorityInformationAccess):\n            return NotImplemented\n\n        return self._descriptions == other._descriptions\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._descriptions))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SubjectInformationAccess(ExtensionType):\n    oid = ExtensionOID.SUBJECT_INFORMATION_ACCESS\n\n    def __init__(\n        self, descriptions: typing.Iterable[AccessDescription]\n    ) -> None:\n        descriptions = list(descriptions)\n        if not all(isinstance(x, AccessDescription) for x in descriptions):\n            raise TypeError(\n                \"Every item in the descriptions list must be an \"\n                \"AccessDescription\"\n            )\n\n        self._descriptions = descriptions\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_descriptions\")\n\n    def __repr__(self) -> str:\n        return f\"<SubjectInformationAccess({self._descriptions})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectInformationAccess):\n            return NotImplemented\n\n        return self._descriptions == other._descriptions\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._descriptions))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AccessDescription:\n    def __init__(\n        self, access_method: ObjectIdentifier, access_location: GeneralName\n    ) -> None:\n        if not isinstance(access_method, ObjectIdentifier):\n            raise TypeError(\"access_method must be an ObjectIdentifier\")\n\n        if not isinstance(access_location, GeneralName):\n            raise TypeError(\"access_location must be a GeneralName\")\n\n        self._access_method = access_method\n        self._access_location = access_location\n\n    def __repr__(self) -> str:\n        return (\n            f\"<AccessDescription(access_method={self.access_method}, \"\n            f\"access_location={self.access_location})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AccessDescription):\n            return NotImplemented\n\n        return (\n            self.access_method == other.access_method\n            and self.access_location == other.access_location\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.access_method, self.access_location))\n\n    @property\n    def access_method(self) -> ObjectIdentifier:\n        return self._access_method\n\n    @property\n    def access_location(self) -> GeneralName:\n        return self._access_location\n\n\nclass BasicConstraints(ExtensionType):\n    oid = ExtensionOID.BASIC_CONSTRAINTS\n\n    def __init__(self, ca: bool, path_length: int | None) -> None:\n        if not isinstance(ca, bool):\n            raise TypeError(\"ca must be a boolean value\")\n\n        if path_length is not None and not ca:\n            raise ValueError(\"path_length must be None when ca is False\")\n\n        if path_length is not None and (\n            not isinstance(path_length, int) or path_length < 0\n        ):\n            raise TypeError(\n                \"path_length must be a non-negative integer or None\"\n            )\n\n        self._ca = ca\n        self._path_length = path_length\n\n    @property\n    def ca(self) -> bool:\n        return self._ca\n\n    @property\n    def path_length(self) -> int | None:\n        return self._path_length\n\n    def __repr__(self) -> str:\n        return (\n            f\"<BasicConstraints(ca={self.ca}, \"\n            f\"path_length={self.path_length})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BasicConstraints):\n            return NotImplemented\n\n        return self.ca == other.ca and self.path_length == other.path_length\n\n    def __hash__(self) -> int:\n        return hash((self.ca, self.path_length))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass DeltaCRLIndicator(ExtensionType):\n    oid = ExtensionOID.DELTA_CRL_INDICATOR\n\n    def __init__(self, crl_number: int) -> None:\n        if not isinstance(crl_number, int):\n            raise TypeError(\"crl_number must be an integer\")\n\n        self._crl_number = crl_number\n\n    @property\n    def crl_number(self) -> int:\n        return self._crl_number\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DeltaCRLIndicator):\n            return NotImplemented\n\n        return self.crl_number == other.crl_number\n\n    def __hash__(self) -> int:\n        return hash(self.crl_number)\n\n    def __repr__(self) -> str:\n        return f\"<DeltaCRLIndicator(crl_number={self.crl_number})>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CRLDistributionPoints(ExtensionType):\n    oid = ExtensionOID.CRL_DISTRIBUTION_POINTS\n\n    def __init__(\n        self, distribution_points: typing.Iterable[DistributionPoint]\n    ) -> None:\n        distribution_points = list(distribution_points)\n        if not all(\n            isinstance(x, DistributionPoint) for x in distribution_points\n        ):\n            raise TypeError(\n                \"distribution_points must be a list of DistributionPoint \"\n                \"objects\"\n            )\n\n        self._distribution_points = distribution_points\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_distribution_points\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<CRLDistributionPoints({self._distribution_points})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLDistributionPoints):\n            return NotImplemented\n\n        return self._distribution_points == other._distribution_points\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._distribution_points))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass FreshestCRL(ExtensionType):\n    oid = ExtensionOID.FRESHEST_CRL\n\n    def __init__(\n        self, distribution_points: typing.Iterable[DistributionPoint]\n    ) -> None:\n        distribution_points = list(distribution_points)\n        if not all(\n            isinstance(x, DistributionPoint) for x in distribution_points\n        ):\n            raise TypeError(\n                \"distribution_points must be a list of DistributionPoint \"\n                \"objects\"\n            )\n\n        self._distribution_points = distribution_points\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_distribution_points\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<FreshestCRL({self._distribution_points})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, FreshestCRL):\n            return NotImplemented\n\n        return self._distribution_points == other._distribution_points\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._distribution_points))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass DistributionPoint:\n    def __init__(\n        self,\n        full_name: typing.Iterable[GeneralName] | None,\n        relative_name: RelativeDistinguishedName | None,\n        reasons: frozenset[ReasonFlags] | None,\n        crl_issuer: typing.Iterable[GeneralName] | None,\n    ) -> None:\n        if full_name and relative_name:\n            raise ValueError(\n                \"You cannot provide both full_name and relative_name, at \"\n                \"least one must be None.\"\n            )\n        if not full_name and not relative_name and not crl_issuer:\n            raise ValueError(\n                \"Either full_name, relative_name or crl_issuer must be \"\n                \"provided.\"\n            )\n\n        if full_name is not None:\n            full_name = list(full_name)\n            if not all(isinstance(x, GeneralName) for x in full_name):\n                raise TypeError(\n                    \"full_name must be a list of GeneralName objects\"\n                )\n\n        if relative_name:\n            if not isinstance(relative_name, RelativeDistinguishedName):\n                raise TypeError(\n                    \"relative_name must be a RelativeDistinguishedName\"\n                )\n\n        if crl_issuer is not None:\n            crl_issuer = list(crl_issuer)\n            if not all(isinstance(x, GeneralName) for x in crl_issuer):\n                raise TypeError(\n                    \"crl_issuer must be None or a list of general names\"\n                )\n\n        if reasons and (\n            not isinstance(reasons, frozenset)\n            or not all(isinstance(x, ReasonFlags) for x in reasons)\n        ):\n            raise TypeError(\"reasons must be None or frozenset of ReasonFlags\")\n\n        if reasons and (\n            ReasonFlags.unspecified in reasons\n            or ReasonFlags.remove_from_crl in reasons\n        ):\n            raise ValueError(\n                \"unspecified and remove_from_crl are not valid reasons in a \"\n                \"DistributionPoint\"\n            )\n\n        self._full_name = full_name\n        self._relative_name = relative_name\n        self._reasons = reasons\n        self._crl_issuer = crl_issuer\n\n    def __repr__(self) -> str:\n        return (\n            \"<DistributionPoint(full_name={0.full_name}, relative_name={0.rela\"\n            \"tive_name}, reasons={0.reasons}, \"\n            \"crl_issuer={0.crl_issuer})>\".format(self)\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DistributionPoint):\n            return NotImplemented\n\n        return (\n            self.full_name == other.full_name\n            and self.relative_name == other.relative_name\n            and self.reasons == other.reasons\n            and self.crl_issuer == other.crl_issuer\n        )\n\n    def __hash__(self) -> int:\n        if self.full_name is not None:\n            fn: tuple[GeneralName, ...] | None = tuple(self.full_name)\n        else:\n            fn = None\n\n        if self.crl_issuer is not None:\n            crl_issuer: tuple[GeneralName, ...] | None = tuple(self.crl_issuer)\n        else:\n            crl_issuer = None\n\n        return hash((fn, self.relative_name, self.reasons, crl_issuer))\n\n    @property\n    def full_name(self) -> list[GeneralName] | None:\n        return self._full_name\n\n    @property\n    def relative_name(self) -> RelativeDistinguishedName | None:\n        return self._relative_name\n\n    @property\n    def reasons(self) -> frozenset[ReasonFlags] | None:\n        return self._reasons\n\n    @property\n    def crl_issuer(self) -> list[GeneralName] | None:\n        return self._crl_issuer\n\n\nclass ReasonFlags(utils.Enum):\n    unspecified = \"unspecified\"\n    key_compromise = \"keyCompromise\"\n    ca_compromise = \"cACompromise\"\n    affiliation_changed = \"affiliationChanged\"\n    superseded = \"superseded\"\n    cessation_of_operation = \"cessationOfOperation\"\n    certificate_hold = \"certificateHold\"\n    privilege_withdrawn = \"privilegeWithdrawn\"\n    aa_compromise = \"aACompromise\"\n    remove_from_crl = \"removeFromCRL\"\n\n\n# These are distribution point bit string mappings. Not to be confused with\n# CRLReason reason flags bit string mappings.\n# ReasonFlags ::= BIT STRING {\n#      unused                  (0),\n#      keyCompromise           (1),\n#      cACompromise            (2),\n#      affiliationChanged      (3),\n#      superseded              (4),\n#      cessationOfOperation    (5),\n#      certificateHold         (6),\n#      privilegeWithdrawn      (7),\n#      aACompromise            (8) }\n_REASON_BIT_MAPPING = {\n    1: ReasonFlags.key_compromise,\n    2: ReasonFlags.ca_compromise,\n    3: ReasonFlags.affiliation_changed,\n    4: ReasonFlags.superseded,\n    5: ReasonFlags.cessation_of_operation,\n    6: ReasonFlags.certificate_hold,\n    7: ReasonFlags.privilege_withdrawn,\n    8: ReasonFlags.aa_compromise,\n}\n\n_CRLREASONFLAGS = {\n    ReasonFlags.key_compromise: 1,\n    ReasonFlags.ca_compromise: 2,\n    ReasonFlags.affiliation_changed: 3,\n    ReasonFlags.superseded: 4,\n    ReasonFlags.cessation_of_operation: 5,\n    ReasonFlags.certificate_hold: 6,\n    ReasonFlags.privilege_withdrawn: 7,\n    ReasonFlags.aa_compromise: 8,\n}\n\n#    CRLReason ::= ENUMERATED {\n#        unspecified             (0),\n#        keyCompromise           (1),\n#        cACompromise            (2),\n#        affiliationChanged      (3),\n#        superseded              (4),\n#        cessationOfOperation    (5),\n#        certificateHold         (6),\n#             -- value 7 is not used\n#        removeFromCRL           (8),\n#        privilegeWithdrawn      (9),\n#        aACompromise           (10) }\n_CRL_ENTRY_REASON_ENUM_TO_CODE = {\n    ReasonFlags.unspecified: 0,\n    ReasonFlags.key_compromise: 1,\n    ReasonFlags.ca_compromise: 2,\n    ReasonFlags.affiliation_changed: 3,\n    ReasonFlags.superseded: 4,\n    ReasonFlags.cessation_of_operation: 5,\n    ReasonFlags.certificate_hold: 6,\n    ReasonFlags.remove_from_crl: 8,\n    ReasonFlags.privilege_withdrawn: 9,\n    ReasonFlags.aa_compromise: 10,\n}\n\n\nclass PolicyConstraints(ExtensionType):\n    oid = ExtensionOID.POLICY_CONSTRAINTS\n\n    def __init__(\n        self,\n        require_explicit_policy: int | None,\n        inhibit_policy_mapping: int | None,\n    ) -> None:\n        if require_explicit_policy is not None and not isinstance(\n            require_explicit_policy, int\n        ):\n            raise TypeError(\n                \"require_explicit_policy must be a non-negative integer or \"\n                \"None\"\n            )\n\n        if inhibit_policy_mapping is not None and not isinstance(\n            inhibit_policy_mapping, int\n        ):\n            raise TypeError(\n                \"inhibit_policy_mapping must be a non-negative integer or None\"\n            )\n\n        if inhibit_policy_mapping is None and require_explicit_policy is None:\n            raise ValueError(\n                \"At least one of require_explicit_policy and \"\n                \"inhibit_policy_mapping must not be None\"\n            )\n\n        self._require_explicit_policy = require_explicit_policy\n        self._inhibit_policy_mapping = inhibit_policy_mapping\n\n    def __repr__(self) -> str:\n        return (\n            \"<PolicyConstraints(require_explicit_policy={0.require_explicit\"\n            \"_policy}, inhibit_policy_mapping={0.inhibit_policy_\"\n            \"mapping})>\".format(self)\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PolicyConstraints):\n            return NotImplemented\n\n        return (\n            self.require_explicit_policy == other.require_explicit_policy\n            and self.inhibit_policy_mapping == other.inhibit_policy_mapping\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (self.require_explicit_policy, self.inhibit_policy_mapping)\n        )\n\n    @property\n    def require_explicit_policy(self) -> int | None:\n        return self._require_explicit_policy\n\n    @property\n    def inhibit_policy_mapping(self) -> int | None:\n        return self._inhibit_policy_mapping\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CertificatePolicies(ExtensionType):\n    oid = ExtensionOID.CERTIFICATE_POLICIES\n\n    def __init__(self, policies: typing.Iterable[PolicyInformation]) -> None:\n        policies = list(policies)\n        if not all(isinstance(x, PolicyInformation) for x in policies):\n            raise TypeError(\n                \"Every item in the policies list must be a \"\n                \"PolicyInformation\"\n            )\n\n        self._policies = policies\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_policies\")\n\n    def __repr__(self) -> str:\n        return f\"<CertificatePolicies({self._policies})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CertificatePolicies):\n            return NotImplemented\n\n        return self._policies == other._policies\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._policies))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PolicyInformation:\n    def __init__(\n        self,\n        policy_identifier: ObjectIdentifier,\n        policy_qualifiers: typing.Iterable[str | UserNotice] | None,\n    ) -> None:\n        if not isinstance(policy_identifier, ObjectIdentifier):\n            raise TypeError(\"policy_identifier must be an ObjectIdentifier\")\n\n        self._policy_identifier = policy_identifier\n\n        if policy_qualifiers is not None:\n            policy_qualifiers = list(policy_qualifiers)\n            if not all(\n                isinstance(x, (str, UserNotice)) for x in policy_qualifiers\n            ):\n                raise TypeError(\n                    \"policy_qualifiers must be a list of strings and/or \"\n                    \"UserNotice objects or None\"\n                )\n\n        self._policy_qualifiers = policy_qualifiers\n\n    def __repr__(self) -> str:\n        return (\n            f\"<PolicyInformation(policy_identifier={self.policy_identifier}, \"\n            f\"policy_qualifiers={self.policy_qualifiers})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PolicyInformation):\n            return NotImplemented\n\n        return (\n            self.policy_identifier == other.policy_identifier\n            and self.policy_qualifiers == other.policy_qualifiers\n        )\n\n    def __hash__(self) -> int:\n        if self.policy_qualifiers is not None:\n            pq: tuple[str | UserNotice, ...] | None = tuple(\n                self.policy_qualifiers\n            )\n        else:\n            pq = None\n\n        return hash((self.policy_identifier, pq))\n\n    @property\n    def policy_identifier(self) -> ObjectIdentifier:\n        return self._policy_identifier\n\n    @property\n    def policy_qualifiers(\n        self,\n    ) -> list[str | UserNotice] | None:\n        return self._policy_qualifiers\n\n\nclass UserNotice:\n    def __init__(\n        self,\n        notice_reference: NoticeReference | None,\n        explicit_text: str | None,\n    ) -> None:\n        if notice_reference and not isinstance(\n            notice_reference, NoticeReference\n        ):\n            raise TypeError(\n                \"notice_reference must be None or a NoticeReference\"\n            )\n\n        self._notice_reference = notice_reference\n        self._explicit_text = explicit_text\n\n    def __repr__(self) -> str:\n        return (\n            f\"<UserNotice(notice_reference={self.notice_reference}, \"\n            f\"explicit_text={self.explicit_text!r})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UserNotice):\n            return NotImplemented\n\n        return (\n            self.notice_reference == other.notice_reference\n            and self.explicit_text == other.explicit_text\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.notice_reference, self.explicit_text))\n\n    @property\n    def notice_reference(self) -> NoticeReference | None:\n        return self._notice_reference\n\n    @property\n    def explicit_text(self) -> str | None:\n        return self._explicit_text\n\n\nclass NoticeReference:\n    def __init__(\n        self,\n        organization: str | None,\n        notice_numbers: typing.Iterable[int],\n    ) -> None:\n        self._organization = organization\n        notice_numbers = list(notice_numbers)\n        if not all(isinstance(x, int) for x in notice_numbers):\n            raise TypeError(\"notice_numbers must be a list of integers\")\n\n        self._notice_numbers = notice_numbers\n\n    def __repr__(self) -> str:\n        return (\n            f\"<NoticeReference(organization={self.organization!r}, \"\n            f\"notice_numbers={self.notice_numbers})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NoticeReference):\n            return NotImplemented\n\n        return (\n            self.organization == other.organization\n            and self.notice_numbers == other.notice_numbers\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.organization, tuple(self.notice_numbers)))\n\n    @property\n    def organization(self) -> str | None:\n        return self._organization\n\n    @property\n    def notice_numbers(self) -> list[int]:\n        return self._notice_numbers\n\n\nclass ExtendedKeyUsage(ExtensionType):\n    oid = ExtensionOID.EXTENDED_KEY_USAGE\n\n    def __init__(self, usages: typing.Iterable[ObjectIdentifier]) -> None:\n        usages = list(usages)\n        if not all(isinstance(x, ObjectIdentifier) for x in usages):\n            raise TypeError(\n                \"Every item in the usages list must be an ObjectIdentifier\"\n            )\n\n        self._usages = usages\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_usages\")\n\n    def __repr__(self) -> str:\n        return f\"<ExtendedKeyUsage({self._usages})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, ExtendedKeyUsage):\n            return NotImplemented\n\n        return self._usages == other._usages\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._usages))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPNoCheck(ExtensionType):\n    oid = ExtensionOID.OCSP_NO_CHECK\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPNoCheck):\n            return NotImplemented\n\n        return True\n\n    def __hash__(self) -> int:\n        return hash(OCSPNoCheck)\n\n    def __repr__(self) -> str:\n        return \"<OCSPNoCheck()>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PrecertPoison(ExtensionType):\n    oid = ExtensionOID.PRECERT_POISON\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PrecertPoison):\n            return NotImplemented\n\n        return True\n\n    def __hash__(self) -> int:\n        return hash(PrecertPoison)\n\n    def __repr__(self) -> str:\n        return \"<PrecertPoison()>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass TLSFeature(ExtensionType):\n    oid = ExtensionOID.TLS_FEATURE\n\n    def __init__(self, features: typing.Iterable[TLSFeatureType]) -> None:\n        features = list(features)\n        if (\n            not all(isinstance(x, TLSFeatureType) for x in features)\n            or len(features) == 0\n        ):\n            raise TypeError(\n                \"features must be a list of elements from the TLSFeatureType \"\n                \"enum\"\n            )\n\n        self._features = features\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_features\")\n\n    def __repr__(self) -> str:\n        return f\"<TLSFeature(features={self._features})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, TLSFeature):\n            return NotImplemented\n\n        return self._features == other._features\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._features))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass TLSFeatureType(utils.Enum):\n    # status_request is defined in RFC 6066 and is used for what is commonly\n    # called OCSP Must-Staple when present in the TLS Feature extension in an\n    # X.509 certificate.\n    status_request = 5\n    # status_request_v2 is defined in RFC 6961 and allows multiple OCSP\n    # responses to be provided. It is not currently in use by clients or\n    # servers.\n    status_request_v2 = 17\n\n\n_TLS_FEATURE_TYPE_TO_ENUM = {x.value: x for x in TLSFeatureType}\n\n\nclass InhibitAnyPolicy(ExtensionType):\n    oid = ExtensionOID.INHIBIT_ANY_POLICY\n\n    def __init__(self, skip_certs: int) -> None:\n        if not isinstance(skip_certs, int):\n            raise TypeError(\"skip_certs must be an integer\")\n\n        if skip_certs < 0:\n            raise ValueError(\"skip_certs must be a non-negative integer\")\n\n        self._skip_certs = skip_certs\n\n    def __repr__(self) -> str:\n        return f\"<InhibitAnyPolicy(skip_certs={self.skip_certs})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, InhibitAnyPolicy):\n            return NotImplemented\n\n        return self.skip_certs == other.skip_certs\n\n    def __hash__(self) -> int:\n        return hash(self.skip_certs)\n\n    @property\n    def skip_certs(self) -> int:\n        return self._skip_certs\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass KeyUsage(ExtensionType):\n    oid = ExtensionOID.KEY_USAGE\n\n    def __init__(\n        self,\n        digital_signature: bool,\n        content_commitment: bool,\n        key_encipherment: bool,\n        data_encipherment: bool,\n        key_agreement: bool,\n        key_cert_sign: bool,\n        crl_sign: bool,\n        encipher_only: bool,\n        decipher_only: bool,\n    ) -> None:\n        if not key_agreement and (encipher_only or decipher_only):\n            raise ValueError(\n                \"encipher_only and decipher_only can only be true when \"\n                \"key_agreement is true\"\n            )\n\n        self._digital_signature = digital_signature\n        self._content_commitment = content_commitment\n        self._key_encipherment = key_encipherment\n        self._data_encipherment = data_encipherment\n        self._key_agreement = key_agreement\n        self._key_cert_sign = key_cert_sign\n        self._crl_sign = crl_sign\n        self._encipher_only = encipher_only\n        self._decipher_only = decipher_only\n\n    @property\n    def digital_signature(self) -> bool:\n        return self._digital_signature\n\n    @property\n    def content_commitment(self) -> bool:\n        return self._content_commitment\n\n    @property\n    def key_encipherment(self) -> bool:\n        return self._key_encipherment\n\n    @property\n    def data_encipherment(self) -> bool:\n        return self._data_encipherment\n\n    @property\n    def key_agreement(self) -> bool:\n        return self._key_agreement\n\n    @property\n    def key_cert_sign(self) -> bool:\n        return self._key_cert_sign\n\n    @property\n    def crl_sign(self) -> bool:\n        return self._crl_sign\n\n    @property\n    def encipher_only(self) -> bool:\n        if not self.key_agreement:\n            raise ValueError(\n                \"encipher_only is undefined unless key_agreement is true\"\n            )\n        else:\n            return self._encipher_only\n\n    @property\n    def decipher_only(self) -> bool:\n        if not self.key_agreement:\n            raise ValueError(\n                \"decipher_only is undefined unless key_agreement is true\"\n            )\n        else:\n            return self._decipher_only\n\n    def __repr__(self) -> str:\n        try:\n            encipher_only = self.encipher_only\n            decipher_only = self.decipher_only\n        except ValueError:\n            # Users found None confusing because even though encipher/decipher\n            # have no meaning unless key_agreement is true, to construct an\n            # instance of the class you still need to pass False.\n            encipher_only = False\n            decipher_only = False\n\n        return (\n            f\"<KeyUsage(digital_signature={self.digital_signature}, \"\n            f\"content_commitment={self.content_commitment}, \"\n            f\"key_encipherment={self.key_encipherment}, \"\n            f\"data_encipherment={self.data_encipherment}, \"\n            f\"key_agreement={self.key_agreement}, \"\n            f\"key_cert_sign={self.key_cert_sign}, crl_sign={self.crl_sign}, \"\n            f\"encipher_only={encipher_only}, decipher_only={decipher_only})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, KeyUsage):\n            return NotImplemented\n\n        return (\n            self.digital_signature == other.digital_signature\n            and self.content_commitment == other.content_commitment\n            and self.key_encipherment == other.key_encipherment\n            and self.data_encipherment == other.data_encipherment\n            and self.key_agreement == other.key_agreement\n            and self.key_cert_sign == other.key_cert_sign\n            and self.crl_sign == other.crl_sign\n            and self._encipher_only == other._encipher_only\n            and self._decipher_only == other._decipher_only\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.digital_signature,\n                self.content_commitment,\n                self.key_encipherment,\n                self.data_encipherment,\n                self.key_agreement,\n                self.key_cert_sign,\n                self.crl_sign,\n                self._encipher_only,\n                self._decipher_only,\n            )\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass NameConstraints(ExtensionType):\n    oid = ExtensionOID.NAME_CONSTRAINTS\n\n    def __init__(\n        self,\n        permitted_subtrees: typing.Iterable[GeneralName] | None,\n        excluded_subtrees: typing.Iterable[GeneralName] | None,\n    ) -> None:\n        if permitted_subtrees is not None:\n            permitted_subtrees = list(permitted_subtrees)\n            if not permitted_subtrees:\n                raise ValueError(\n                    \"permitted_subtrees must be a non-empty list or None\"\n                )\n            if not all(isinstance(x, GeneralName) for x in permitted_subtrees):\n                raise TypeError(\n                    \"permitted_subtrees must be a list of GeneralName objects \"\n                    \"or None\"\n                )\n\n            self._validate_tree(permitted_subtrees)\n\n        if excluded_subtrees is not None:\n            excluded_subtrees = list(excluded_subtrees)\n            if not excluded_subtrees:\n                raise ValueError(\n                    \"excluded_subtrees must be a non-empty list or None\"\n                )\n            if not all(isinstance(x, GeneralName) for x in excluded_subtrees):\n                raise TypeError(\n                    \"excluded_subtrees must be a list of GeneralName objects \"\n                    \"or None\"\n                )\n\n            self._validate_tree(excluded_subtrees)\n\n        if permitted_subtrees is None and excluded_subtrees is None:\n            raise ValueError(\n                \"At least one of permitted_subtrees and excluded_subtrees \"\n                \"must not be None\"\n            )\n\n        self._permitted_subtrees = permitted_subtrees\n        self._excluded_subtrees = excluded_subtrees\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NameConstraints):\n            return NotImplemented\n\n        return (\n            self.excluded_subtrees == other.excluded_subtrees\n            and self.permitted_subtrees == other.permitted_subtrees\n        )\n\n    def _validate_tree(self, tree: typing.Iterable[GeneralName]) -> None:\n        self._validate_ip_name(tree)\n        self._validate_dns_name(tree)\n\n    def _validate_ip_name(self, tree: typing.Iterable[GeneralName]) -> None:\n        if any(\n            isinstance(name, IPAddress)\n            and not isinstance(\n                name.value, (ipaddress.IPv4Network, ipaddress.IPv6Network)\n            )\n            for name in tree\n        ):\n            raise TypeError(\n                \"IPAddress name constraints must be an IPv4Network or\"\n                \" IPv6Network object\"\n            )\n\n    def _validate_dns_name(self, tree: typing.Iterable[GeneralName]) -> None:\n        if any(\n            isinstance(name, DNSName) and \"*\" in name.value for name in tree\n        ):\n            raise ValueError(\n                \"DNSName name constraints must not contain the '*' wildcard\"\n                \" character\"\n            )\n\n    def __repr__(self) -> str:\n        return (\n            f\"<NameConstraints(permitted_subtrees={self.permitted_subtrees}, \"\n            f\"excluded_subtrees={self.excluded_subtrees})>\"\n        )\n\n    def __hash__(self) -> int:\n        if self.permitted_subtrees is not None:\n            ps: tuple[GeneralName, ...] | None = tuple(self.permitted_subtrees)\n        else:\n            ps = None\n\n        if self.excluded_subtrees is not None:\n            es: tuple[GeneralName, ...] | None = tuple(self.excluded_subtrees)\n        else:\n            es = None\n\n        return hash((ps, es))\n\n    @property\n    def permitted_subtrees(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._permitted_subtrees\n\n    @property\n    def excluded_subtrees(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._excluded_subtrees\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass Extension(typing.Generic[ExtensionTypeVar]):\n    def __init__(\n        self, oid: ObjectIdentifier, critical: bool, value: ExtensionTypeVar\n    ) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\n                \"oid argument must be an ObjectIdentifier instance.\"\n            )\n\n        if not isinstance(critical, bool):\n            raise TypeError(\"critical must be a boolean value\")\n\n        self._oid = oid\n        self._critical = critical\n        self._value = value\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def critical(self) -> bool:\n        return self._critical\n\n    @property\n    def value(self) -> ExtensionTypeVar:\n        return self._value\n\n    def __repr__(self) -> str:\n        return (\n            f\"<Extension(oid={self.oid}, critical={self.critical}, \"\n            f\"value={self.value})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Extension):\n            return NotImplemented\n\n        return (\n            self.oid == other.oid\n            and self.critical == other.critical\n            and self.value == other.value\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.critical, self.value))\n\n\nclass GeneralNames:\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        general_names = list(general_names)\n        if not all(isinstance(x, GeneralName) for x in general_names):\n            raise TypeError(\n                \"Every item in the general_names list must be an \"\n                \"object conforming to the GeneralName interface\"\n            )\n\n        self._general_names = general_names\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        # Return the value of each GeneralName, except for OtherName instances\n        # which we return directly because it has two important properties not\n        # just one value.\n        objs = (i for i in self if isinstance(i, type))\n        if type != OtherName:\n            return [i.value for i in objs]\n        return list(objs)\n\n    def __repr__(self) -> str:\n        return f\"<GeneralNames({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, GeneralNames):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._general_names))\n\n\nclass SubjectAlternativeName(ExtensionType):\n    oid = ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<SubjectAlternativeName({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectAlternativeName):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass IssuerAlternativeName(ExtensionType):\n    oid = ExtensionOID.ISSUER_ALTERNATIVE_NAME\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<IssuerAlternativeName({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IssuerAlternativeName):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CertificateIssuer(ExtensionType):\n    oid = CRLEntryExtensionOID.CERTIFICATE_ISSUER\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<CertificateIssuer({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CertificateIssuer):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CRLReason(ExtensionType):\n    oid = CRLEntryExtensionOID.CRL_REASON\n\n    def __init__(self, reason: ReasonFlags) -> None:\n        if not isinstance(reason, ReasonFlags):\n            raise TypeError(\"reason must be an element from ReasonFlags\")\n\n        self._reason = reason\n\n    def __repr__(self) -> str:\n        return f\"<CRLReason(reason={self._reason})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLReason):\n            return NotImplemented\n\n        return self.reason == other.reason\n\n    def __hash__(self) -> int:\n        return hash(self.reason)\n\n    @property\n    def reason(self) -> ReasonFlags:\n        return self._reason\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass InvalidityDate(ExtensionType):\n    oid = CRLEntryExtensionOID.INVALIDITY_DATE\n\n    def __init__(self, invalidity_date: datetime.datetime) -> None:\n        if not isinstance(invalidity_date, datetime.datetime):\n            raise TypeError(\"invalidity_date must be a datetime.datetime\")\n\n        self._invalidity_date = invalidity_date\n\n    def __repr__(self) -> str:\n        return f\"<InvalidityDate(invalidity_date={self._invalidity_date})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, InvalidityDate):\n            return NotImplemented\n\n        return self.invalidity_date == other.invalidity_date\n\n    def __hash__(self) -> int:\n        return hash(self.invalidity_date)\n\n    @property\n    def invalidity_date(self) -> datetime.datetime:\n        return self._invalidity_date\n\n    @property\n    def invalidity_date_utc(self) -> datetime.datetime:\n        if self._invalidity_date.tzinfo is None:\n            return self._invalidity_date.replace(tzinfo=datetime.timezone.utc)\n        else:\n            return self._invalidity_date.astimezone(tz=datetime.timezone.utc)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PrecertificateSignedCertificateTimestamps(ExtensionType):\n    oid = ExtensionOID.PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS\n\n    def __init__(\n        self,\n        signed_certificate_timestamps: typing.Iterable[\n            SignedCertificateTimestamp\n        ],\n    ) -> None:\n        signed_certificate_timestamps = list(signed_certificate_timestamps)\n        if not all(\n            isinstance(sct, SignedCertificateTimestamp)\n            for sct in signed_certificate_timestamps\n        ):\n            raise TypeError(\n                \"Every item in the signed_certificate_timestamps list must be \"\n                \"a SignedCertificateTimestamp\"\n            )\n        self._signed_certificate_timestamps = signed_certificate_timestamps\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_signed_certificate_timestamps\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<PrecertificateSignedCertificateTimestamps({list(self)})>\"\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._signed_certificate_timestamps))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PrecertificateSignedCertificateTimestamps):\n            return NotImplemented\n\n        return (\n            self._signed_certificate_timestamps\n            == other._signed_certificate_timestamps\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SignedCertificateTimestamps(ExtensionType):\n    oid = ExtensionOID.SIGNED_CERTIFICATE_TIMESTAMPS\n\n    def __init__(\n        self,\n        signed_certificate_timestamps: typing.Iterable[\n            SignedCertificateTimestamp\n        ],\n    ) -> None:\n        signed_certificate_timestamps = list(signed_certificate_timestamps)\n        if not all(\n            isinstance(sct, SignedCertificateTimestamp)\n            for sct in signed_certificate_timestamps\n        ):\n            raise TypeError(\n                \"Every item in the signed_certificate_timestamps list must be \"\n                \"a SignedCertificateTimestamp\"\n            )\n        self._signed_certificate_timestamps = signed_certificate_timestamps\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_signed_certificate_timestamps\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<SignedCertificateTimestamps({list(self)})>\"\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._signed_certificate_timestamps))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SignedCertificateTimestamps):\n            return NotImplemented\n\n        return (\n            self._signed_certificate_timestamps\n            == other._signed_certificate_timestamps\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPNonce(ExtensionType):\n    oid = OCSPExtensionOID.NONCE\n\n    def __init__(self, nonce: bytes) -> None:\n        if not isinstance(nonce, bytes):\n            raise TypeError(\"nonce must be bytes\")\n\n        self._nonce = nonce\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPNonce):\n            return NotImplemented\n\n        return self.nonce == other.nonce\n\n    def __hash__(self) -> int:\n        return hash(self.nonce)\n\n    def __repr__(self) -> str:\n        return f\"<OCSPNonce(nonce={self.nonce!r})>\"\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPAcceptableResponses(ExtensionType):\n    oid = OCSPExtensionOID.ACCEPTABLE_RESPONSES\n\n    def __init__(self, responses: typing.Iterable[ObjectIdentifier]) -> None:\n        responses = list(responses)\n        if any(not isinstance(r, ObjectIdentifier) for r in responses):\n            raise TypeError(\"All responses must be ObjectIdentifiers\")\n\n        self._responses = responses\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPAcceptableResponses):\n            return NotImplemented\n\n        return self._responses == other._responses\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._responses))\n\n    def __repr__(self) -> str:\n        return f\"<OCSPAcceptableResponses(responses={self._responses})>\"\n\n    def __iter__(self) -> typing.Iterator[ObjectIdentifier]:\n        return iter(self._responses)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass IssuingDistributionPoint(ExtensionType):\n    oid = ExtensionOID.ISSUING_DISTRIBUTION_POINT\n\n    def __init__(\n        self,\n        full_name: typing.Iterable[GeneralName] | None,\n        relative_name: RelativeDistinguishedName | None,\n        only_contains_user_certs: bool,\n        only_contains_ca_certs: bool,\n        only_some_reasons: frozenset[ReasonFlags] | None,\n        indirect_crl: bool,\n        only_contains_attribute_certs: bool,\n    ) -> None:\n        if full_name is not None:\n            full_name = list(full_name)\n\n        if only_some_reasons and (\n            not isinstance(only_some_reasons, frozenset)\n            or not all(isinstance(x, ReasonFlags) for x in only_some_reasons)\n        ):\n            raise TypeError(\n                \"only_some_reasons must be None or frozenset of ReasonFlags\"\n            )\n\n        if only_some_reasons and (\n            ReasonFlags.unspecified in only_some_reasons\n            or ReasonFlags.remove_from_crl in only_some_reasons\n        ):\n            raise ValueError(\n                \"unspecified and remove_from_crl are not valid reasons in an \"\n                \"IssuingDistributionPoint\"\n            )\n\n        if not (\n            isinstance(only_contains_user_certs, bool)\n            and isinstance(only_contains_ca_certs, bool)\n            and isinstance(indirect_crl, bool)\n            and isinstance(only_contains_attribute_certs, bool)\n        ):\n            raise TypeError(\n                \"only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl and only_contains_attribute_certs \"\n                \"must all be boolean.\"\n            )\n\n        crl_constraints = [\n            only_contains_user_certs,\n            only_contains_ca_certs,\n            indirect_crl,\n            only_contains_attribute_certs,\n        ]\n\n        if len([x for x in crl_constraints if x]) > 1:\n            raise ValueError(\n                \"Only one of the following can be set to True: \"\n                \"only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl, only_contains_attribute_certs\"\n            )\n\n        if not any(\n            [\n                only_contains_user_certs,\n                only_contains_ca_certs,\n                indirect_crl,\n                only_contains_attribute_certs,\n                full_name,\n                relative_name,\n                only_some_reasons,\n            ]\n        ):\n            raise ValueError(\n                \"Cannot create empty extension: \"\n                \"if only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl, and only_contains_attribute_certs are all False\"\n                \", then either full_name, relative_name, or only_some_reasons \"\n                \"must have a value.\"\n            )\n\n        self._only_contains_user_certs = only_contains_user_certs\n        self._only_contains_ca_certs = only_contains_ca_certs\n        self._indirect_crl = indirect_crl\n        self._only_contains_attribute_certs = only_contains_attribute_certs\n        self._only_some_reasons = only_some_reasons\n        self._full_name = full_name\n        self._relative_name = relative_name\n\n    def __repr__(self) -> str:\n        return (\n            f\"<IssuingDistributionPoint(full_name={self.full_name}, \"\n            f\"relative_name={self.relative_name}, \"\n            f\"only_contains_user_certs={self.only_contains_user_certs}, \"\n            f\"only_contains_ca_certs={self.only_contains_ca_certs}, \"\n            f\"only_some_reasons={self.only_some_reasons}, \"\n            f\"indirect_crl={self.indirect_crl}, \"\n            \"only_contains_attribute_certs=\"\n            f\"{self.only_contains_attribute_certs})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IssuingDistributionPoint):\n            return NotImplemented\n\n        return (\n            self.full_name == other.full_name\n            and self.relative_name == other.relative_name\n            and self.only_contains_user_certs == other.only_contains_user_certs\n            and self.only_contains_ca_certs == other.only_contains_ca_certs\n            and self.only_some_reasons == other.only_some_reasons\n            and self.indirect_crl == other.indirect_crl\n            and self.only_contains_attribute_certs\n            == other.only_contains_attribute_certs\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.full_name,\n                self.relative_name,\n                self.only_contains_user_certs,\n                self.only_contains_ca_certs,\n                self.only_some_reasons,\n                self.indirect_crl,\n                self.only_contains_attribute_certs,\n            )\n        )\n\n    @property\n    def full_name(self) -> list[GeneralName] | None:\n        return self._full_name\n\n    @property\n    def relative_name(self) -> RelativeDistinguishedName | None:\n        return self._relative_name\n\n    @property\n    def only_contains_user_certs(self) -> bool:\n        return self._only_contains_user_certs\n\n    @property\n    def only_contains_ca_certs(self) -> bool:\n        return self._only_contains_ca_certs\n\n    @property\n    def only_some_reasons(\n        self,\n    ) -> frozenset[ReasonFlags] | None:\n        return self._only_some_reasons\n\n    @property\n    def indirect_crl(self) -> bool:\n        return self._indirect_crl\n\n    @property\n    def only_contains_attribute_certs(self) -> bool:\n        return self._only_contains_attribute_certs\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass MSCertificateTemplate(ExtensionType):\n    oid = ExtensionOID.MS_CERTIFICATE_TEMPLATE\n\n    def __init__(\n        self,\n        template_id: ObjectIdentifier,\n        major_version: int | None,\n        minor_version: int | None,\n    ) -> None:\n        if not isinstance(template_id, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n        self._template_id = template_id\n        if (\n            major_version is not None and not isinstance(major_version, int)\n        ) or (\n            minor_version is not None and not isinstance(minor_version, int)\n        ):\n            raise TypeError(\n                \"major_version and minor_version must be integers or None\"\n            )\n        self._major_version = major_version\n        self._minor_version = minor_version\n\n    @property\n    def template_id(self) -> ObjectIdentifier:\n        return self._template_id\n\n    @property\n    def major_version(self) -> int | None:\n        return self._major_version\n\n    @property\n    def minor_version(self) -> int | None:\n        return self._minor_version\n\n    def __repr__(self) -> str:\n        return (\n            f\"<MSCertificateTemplate(template_id={self.template_id}, \"\n            f\"major_version={self.major_version}, \"\n            f\"minor_version={self.minor_version})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, MSCertificateTemplate):\n            return NotImplemented\n\n        return (\n            self.template_id == other.template_id\n            and self.major_version == other.major_version\n            and self.minor_version == other.minor_version\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.template_id, self.major_version, self.minor_version))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass UnrecognizedExtension(ExtensionType):\n    def __init__(self, oid: ObjectIdentifier, value: bytes) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n        self._oid = oid\n        self._value = value\n\n    @property\n    def oid(self) -> ObjectIdentifier:  # type: ignore[override]\n        return self._oid\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return (\n            f\"<UnrecognizedExtension(oid={self.oid}, \"\n            f\"value={self.value!r})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UnrecognizedExtension):\n            return NotImplemented\n\n        return self.oid == other.oid and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value))\n\n    def public_bytes(self) -> bytes:\n        return self.value\n", "src/cryptography/x509/ocsp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.hazmat.bindings._rust import ocsp\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPrivateKeyTypes,\n)\nfrom cryptography.x509.base import (\n    _EARLIEST_UTC_TIME,\n    _convert_to_naive_utc_time,\n    _reject_duplicate_extension,\n)\n\n\nclass OCSPResponderEncoding(utils.Enum):\n    HASH = \"By Hash\"\n    NAME = \"By Name\"\n\n\nclass OCSPResponseStatus(utils.Enum):\n    SUCCESSFUL = 0\n    MALFORMED_REQUEST = 1\n    INTERNAL_ERROR = 2\n    TRY_LATER = 3\n    SIG_REQUIRED = 5\n    UNAUTHORIZED = 6\n\n\n_ALLOWED_HASHES = (\n    hashes.SHA1,\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n)\n\n\ndef _verify_algorithm(algorithm: hashes.HashAlgorithm) -> None:\n    if not isinstance(algorithm, _ALLOWED_HASHES):\n        raise ValueError(\n            \"Algorithm must be SHA1, SHA224, SHA256, SHA384, or SHA512\"\n        )\n\n\nclass OCSPCertStatus(utils.Enum):\n    GOOD = 0\n    REVOKED = 1\n    UNKNOWN = 2\n\n\nclass _SingleResponse:\n    def __init__(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n        cert_status: OCSPCertStatus,\n        this_update: datetime.datetime,\n        next_update: datetime.datetime | None,\n        revocation_time: datetime.datetime | None,\n        revocation_reason: x509.ReasonFlags | None,\n    ):\n        if not isinstance(cert, x509.Certificate) or not isinstance(\n            issuer, x509.Certificate\n        ):\n            raise TypeError(\"cert and issuer must be a Certificate\")\n\n        _verify_algorithm(algorithm)\n        if not isinstance(this_update, datetime.datetime):\n            raise TypeError(\"this_update must be a datetime object\")\n        if next_update is not None and not isinstance(\n            next_update, datetime.datetime\n        ):\n            raise TypeError(\"next_update must be a datetime object or None\")\n\n        self._cert = cert\n        self._issuer = issuer\n        self._algorithm = algorithm\n        self._this_update = this_update\n        self._next_update = next_update\n\n        if not isinstance(cert_status, OCSPCertStatus):\n            raise TypeError(\n                \"cert_status must be an item from the OCSPCertStatus enum\"\n            )\n        if cert_status is not OCSPCertStatus.REVOKED:\n            if revocation_time is not None:\n                raise ValueError(\n                    \"revocation_time can only be provided if the certificate \"\n                    \"is revoked\"\n                )\n            if revocation_reason is not None:\n                raise ValueError(\n                    \"revocation_reason can only be provided if the certificate\"\n                    \" is revoked\"\n                )\n        else:\n            if not isinstance(revocation_time, datetime.datetime):\n                raise TypeError(\"revocation_time must be a datetime object\")\n\n            revocation_time = _convert_to_naive_utc_time(revocation_time)\n            if revocation_time < _EARLIEST_UTC_TIME:\n                raise ValueError(\n                    \"The revocation_time must be on or after\"\n                    \" 1950 January 1.\"\n                )\n\n            if revocation_reason is not None and not isinstance(\n                revocation_reason, x509.ReasonFlags\n            ):\n                raise TypeError(\n                    \"revocation_reason must be an item from the ReasonFlags \"\n                    \"enum or None\"\n                )\n\n        self._cert_status = cert_status\n        self._revocation_time = revocation_time\n        self._revocation_reason = revocation_reason\n\n\nclass OCSPRequest(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the request to DER\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of request extensions. Not single request extensions.\n        \"\"\"\n\n\nclass OCSPSingleResponse(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def certificate_status(self) -> OCSPCertStatus:\n        \"\"\"\n        The status of the certificate (an element from the OCSPCertStatus enum)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_time(self) -> datetime.datetime | None:\n        \"\"\"\n        The date of when the certificate was revoked or None if not\n        revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_reason(self) -> x509.ReasonFlags | None:\n        \"\"\"\n        The reason the certificate was revoked or None if not specified or\n        not revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def this_update(self) -> datetime.datetime:\n        \"\"\"\n        The most recent time at which the status being indicated is known by\n        the responder to have been correct\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        The time when newer information will be available\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n\nclass OCSPResponse(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def responses(self) -> typing.Iterator[OCSPSingleResponse]:\n        \"\"\"\n        An iterator over the individual SINGLERESP structures in the\n        response\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def response_status(self) -> OCSPResponseStatus:\n        \"\"\"\n        The status of the response. This is a value from the OCSPResponseStatus\n        enumeration\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> x509.ObjectIdentifier:\n        \"\"\"\n        The ObjectIdentifier of the signature algorithm\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        The signature bytes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_response_bytes(self) -> bytes:\n        \"\"\"\n        The tbsResponseData bytes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def certificates(self) -> list[x509.Certificate]:\n        \"\"\"\n        A list of certificates used to help build a chain to verify the OCSP\n        response. This situation occurs when the OCSP responder uses a delegate\n        certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def responder_key_hash(self) -> bytes | None:\n        \"\"\"\n        The responder's key hash or None\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def responder_name(self) -> x509.Name | None:\n        \"\"\"\n        The responder's Name or None\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def produced_at(self) -> datetime.datetime:\n        \"\"\"\n        The time the response was produced\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def certificate_status(self) -> OCSPCertStatus:\n        \"\"\"\n        The status of the certificate (an element from the OCSPCertStatus enum)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_time(self) -> datetime.datetime | None:\n        \"\"\"\n        The date of when the certificate was revoked or None if not\n        revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_reason(self) -> x509.ReasonFlags | None:\n        \"\"\"\n        The reason the certificate was revoked or None if not specified or\n        not revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def this_update(self) -> datetime.datetime:\n        \"\"\"\n        The most recent time at which the status being indicated is known by\n        the responder to have been correct\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        The time when newer information will be available\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of response extensions. Not single response extensions.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def single_extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of single response extensions. Not response extensions.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the response to DER\n        \"\"\"\n\n\nOCSPRequest.register(ocsp.OCSPRequest)\nOCSPResponse.register(ocsp.OCSPResponse)\nOCSPSingleResponse.register(ocsp.OCSPSingleResponse)\n\n\nclass OCSPRequestBuilder:\n    def __init__(\n        self,\n        request: tuple[\n            x509.Certificate, x509.Certificate, hashes.HashAlgorithm\n        ]\n        | None = None,\n        request_hash: tuple[bytes, bytes, int, hashes.HashAlgorithm]\n        | None = None,\n        extensions: list[x509.Extension[x509.ExtensionType]] = [],\n    ) -> None:\n        self._request = request\n        self._request_hash = request_hash\n        self._extensions = extensions\n\n    def add_certificate(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n    ) -> OCSPRequestBuilder:\n        if self._request is not None or self._request_hash is not None:\n            raise ValueError(\"Only one certificate can be added to a request\")\n\n        _verify_algorithm(algorithm)\n        if not isinstance(cert, x509.Certificate) or not isinstance(\n            issuer, x509.Certificate\n        ):\n            raise TypeError(\"cert and issuer must be a Certificate\")\n\n        return OCSPRequestBuilder(\n            (cert, issuer, algorithm), self._request_hash, self._extensions\n        )\n\n    def add_certificate_by_hash(\n        self,\n        issuer_name_hash: bytes,\n        issuer_key_hash: bytes,\n        serial_number: int,\n        algorithm: hashes.HashAlgorithm,\n    ) -> OCSPRequestBuilder:\n        if self._request is not None or self._request_hash is not None:\n            raise ValueError(\"Only one certificate can be added to a request\")\n\n        if not isinstance(serial_number, int):\n            raise TypeError(\"serial_number must be an integer\")\n\n        _verify_algorithm(algorithm)\n        utils._check_bytes(\"issuer_name_hash\", issuer_name_hash)\n        utils._check_bytes(\"issuer_key_hash\", issuer_key_hash)\n        if algorithm.digest_size != len(\n            issuer_name_hash\n        ) or algorithm.digest_size != len(issuer_key_hash):\n            raise ValueError(\n                \"issuer_name_hash and issuer_key_hash must be the same length \"\n                \"as the digest size of the algorithm\"\n            )\n\n        return OCSPRequestBuilder(\n            self._request,\n            (issuer_name_hash, issuer_key_hash, serial_number, algorithm),\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: x509.ExtensionType, critical: bool\n    ) -> OCSPRequestBuilder:\n        if not isinstance(extval, x509.ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = x509.Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return OCSPRequestBuilder(\n            self._request, self._request_hash, [*self._extensions, extension]\n        )\n\n    def build(self) -> OCSPRequest:\n        if self._request is None and self._request_hash is None:\n            raise ValueError(\"You must add a certificate before building\")\n\n        return ocsp.create_ocsp_request(self)\n\n\nclass OCSPResponseBuilder:\n    def __init__(\n        self,\n        response: _SingleResponse | None = None,\n        responder_id: tuple[x509.Certificate, OCSPResponderEncoding]\n        | None = None,\n        certs: list[x509.Certificate] | None = None,\n        extensions: list[x509.Extension[x509.ExtensionType]] = [],\n    ):\n        self._response = response\n        self._responder_id = responder_id\n        self._certs = certs\n        self._extensions = extensions\n\n    def add_response(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n        cert_status: OCSPCertStatus,\n        this_update: datetime.datetime,\n        next_update: datetime.datetime | None,\n        revocation_time: datetime.datetime | None,\n        revocation_reason: x509.ReasonFlags | None,\n    ) -> OCSPResponseBuilder:\n        if self._response is not None:\n            raise ValueError(\"Only one response per OCSPResponse.\")\n\n        singleresp = _SingleResponse(\n            cert,\n            issuer,\n            algorithm,\n            cert_status,\n            this_update,\n            next_update,\n            revocation_time,\n            revocation_reason,\n        )\n        return OCSPResponseBuilder(\n            singleresp,\n            self._responder_id,\n            self._certs,\n            self._extensions,\n        )\n\n    def responder_id(\n        self, encoding: OCSPResponderEncoding, responder_cert: x509.Certificate\n    ) -> OCSPResponseBuilder:\n        if self._responder_id is not None:\n            raise ValueError(\"responder_id can only be set once\")\n        if not isinstance(responder_cert, x509.Certificate):\n            raise TypeError(\"responder_cert must be a Certificate\")\n        if not isinstance(encoding, OCSPResponderEncoding):\n            raise TypeError(\n                \"encoding must be an element from OCSPResponderEncoding\"\n            )\n\n        return OCSPResponseBuilder(\n            self._response,\n            (responder_cert, encoding),\n            self._certs,\n            self._extensions,\n        )\n\n    def certificates(\n        self, certs: typing.Iterable[x509.Certificate]\n    ) -> OCSPResponseBuilder:\n        if self._certs is not None:\n            raise ValueError(\"certificates may only be set once\")\n        certs = list(certs)\n        if len(certs) == 0:\n            raise ValueError(\"certs must not be an empty list\")\n        if not all(isinstance(x, x509.Certificate) for x in certs):\n            raise TypeError(\"certs must be a list of Certificates\")\n        return OCSPResponseBuilder(\n            self._response,\n            self._responder_id,\n            certs,\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: x509.ExtensionType, critical: bool\n    ) -> OCSPResponseBuilder:\n        if not isinstance(extval, x509.ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = x509.Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return OCSPResponseBuilder(\n            self._response,\n            self._responder_id,\n            self._certs,\n            [*self._extensions, extension],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: hashes.HashAlgorithm | None,\n    ) -> OCSPResponse:\n        if self._response is None:\n            raise ValueError(\"You must add a response before signing\")\n        if self._responder_id is None:\n            raise ValueError(\"You must add a responder_id before signing\")\n\n        return ocsp.create_ocsp_response(\n            OCSPResponseStatus.SUCCESSFUL, self, private_key, algorithm\n        )\n\n    @classmethod\n    def build_unsuccessful(\n        cls, response_status: OCSPResponseStatus\n    ) -> OCSPResponse:\n        if not isinstance(response_status, OCSPResponseStatus):\n            raise TypeError(\n                \"response_status must be an item from OCSPResponseStatus\"\n            )\n        if response_status is OCSPResponseStatus.SUCCESSFUL:\n            raise ValueError(\"response_status cannot be SUCCESSFUL\")\n\n        return ocsp.create_ocsp_response(response_status, None, None, None)\n\n\nload_der_ocsp_request = ocsp.load_der_ocsp_request\nload_der_ocsp_response = ocsp.load_der_ocsp_response\n", "src/cryptography/x509/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.x509 import certificate_transparency, verification\nfrom cryptography.x509.base import (\n    Attribute,\n    AttributeNotFound,\n    Attributes,\n    Certificate,\n    CertificateBuilder,\n    CertificateRevocationList,\n    CertificateRevocationListBuilder,\n    CertificateSigningRequest,\n    CertificateSigningRequestBuilder,\n    InvalidVersion,\n    RevokedCertificate,\n    RevokedCertificateBuilder,\n    Version,\n    load_der_x509_certificate,\n    load_der_x509_crl,\n    load_der_x509_csr,\n    load_pem_x509_certificate,\n    load_pem_x509_certificates,\n    load_pem_x509_crl,\n    load_pem_x509_csr,\n    random_serial_number,\n)\nfrom cryptography.x509.extensions import (\n    AccessDescription,\n    AuthorityInformationAccess,\n    AuthorityKeyIdentifier,\n    BasicConstraints,\n    CertificateIssuer,\n    CertificatePolicies,\n    CRLDistributionPoints,\n    CRLNumber,\n    CRLReason,\n    DeltaCRLIndicator,\n    DistributionPoint,\n    DuplicateExtension,\n    ExtendedKeyUsage,\n    Extension,\n    ExtensionNotFound,\n    Extensions,\n    ExtensionType,\n    FreshestCRL,\n    GeneralNames,\n    InhibitAnyPolicy,\n    InvalidityDate,\n    IssuerAlternativeName,\n    IssuingDistributionPoint,\n    KeyUsage,\n    MSCertificateTemplate,\n    NameConstraints,\n    NoticeReference,\n    OCSPAcceptableResponses,\n    OCSPNoCheck,\n    OCSPNonce,\n    PolicyConstraints,\n    PolicyInformation,\n    PrecertificateSignedCertificateTimestamps,\n    PrecertPoison,\n    ReasonFlags,\n    SignedCertificateTimestamps,\n    SubjectAlternativeName,\n    SubjectInformationAccess,\n    SubjectKeyIdentifier,\n    TLSFeature,\n    TLSFeatureType,\n    UnrecognizedExtension,\n    UserNotice,\n)\nfrom cryptography.x509.general_name import (\n    DirectoryName,\n    DNSName,\n    GeneralName,\n    IPAddress,\n    OtherName,\n    RegisteredID,\n    RFC822Name,\n    UniformResourceIdentifier,\n    UnsupportedGeneralNameType,\n)\nfrom cryptography.x509.name import (\n    Name,\n    NameAttribute,\n    RelativeDistinguishedName,\n)\nfrom cryptography.x509.oid import (\n    AuthorityInformationAccessOID,\n    CertificatePoliciesOID,\n    CRLEntryExtensionOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    ObjectIdentifier,\n    PublicKeyAlgorithmOID,\n    SignatureAlgorithmOID,\n)\n\nOID_AUTHORITY_INFORMATION_ACCESS = ExtensionOID.AUTHORITY_INFORMATION_ACCESS\nOID_AUTHORITY_KEY_IDENTIFIER = ExtensionOID.AUTHORITY_KEY_IDENTIFIER\nOID_BASIC_CONSTRAINTS = ExtensionOID.BASIC_CONSTRAINTS\nOID_CERTIFICATE_POLICIES = ExtensionOID.CERTIFICATE_POLICIES\nOID_CRL_DISTRIBUTION_POINTS = ExtensionOID.CRL_DISTRIBUTION_POINTS\nOID_EXTENDED_KEY_USAGE = ExtensionOID.EXTENDED_KEY_USAGE\nOID_FRESHEST_CRL = ExtensionOID.FRESHEST_CRL\nOID_INHIBIT_ANY_POLICY = ExtensionOID.INHIBIT_ANY_POLICY\nOID_ISSUER_ALTERNATIVE_NAME = ExtensionOID.ISSUER_ALTERNATIVE_NAME\nOID_KEY_USAGE = ExtensionOID.KEY_USAGE\nOID_NAME_CONSTRAINTS = ExtensionOID.NAME_CONSTRAINTS\nOID_OCSP_NO_CHECK = ExtensionOID.OCSP_NO_CHECK\nOID_POLICY_CONSTRAINTS = ExtensionOID.POLICY_CONSTRAINTS\nOID_POLICY_MAPPINGS = ExtensionOID.POLICY_MAPPINGS\nOID_SUBJECT_ALTERNATIVE_NAME = ExtensionOID.SUBJECT_ALTERNATIVE_NAME\nOID_SUBJECT_DIRECTORY_ATTRIBUTES = ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES\nOID_SUBJECT_INFORMATION_ACCESS = ExtensionOID.SUBJECT_INFORMATION_ACCESS\nOID_SUBJECT_KEY_IDENTIFIER = ExtensionOID.SUBJECT_KEY_IDENTIFIER\n\nOID_DSA_WITH_SHA1 = SignatureAlgorithmOID.DSA_WITH_SHA1\nOID_DSA_WITH_SHA224 = SignatureAlgorithmOID.DSA_WITH_SHA224\nOID_DSA_WITH_SHA256 = SignatureAlgorithmOID.DSA_WITH_SHA256\nOID_ECDSA_WITH_SHA1 = SignatureAlgorithmOID.ECDSA_WITH_SHA1\nOID_ECDSA_WITH_SHA224 = SignatureAlgorithmOID.ECDSA_WITH_SHA224\nOID_ECDSA_WITH_SHA256 = SignatureAlgorithmOID.ECDSA_WITH_SHA256\nOID_ECDSA_WITH_SHA384 = SignatureAlgorithmOID.ECDSA_WITH_SHA384\nOID_ECDSA_WITH_SHA512 = SignatureAlgorithmOID.ECDSA_WITH_SHA512\nOID_RSA_WITH_MD5 = SignatureAlgorithmOID.RSA_WITH_MD5\nOID_RSA_WITH_SHA1 = SignatureAlgorithmOID.RSA_WITH_SHA1\nOID_RSA_WITH_SHA224 = SignatureAlgorithmOID.RSA_WITH_SHA224\nOID_RSA_WITH_SHA256 = SignatureAlgorithmOID.RSA_WITH_SHA256\nOID_RSA_WITH_SHA384 = SignatureAlgorithmOID.RSA_WITH_SHA384\nOID_RSA_WITH_SHA512 = SignatureAlgorithmOID.RSA_WITH_SHA512\nOID_RSASSA_PSS = SignatureAlgorithmOID.RSASSA_PSS\n\nOID_COMMON_NAME = NameOID.COMMON_NAME\nOID_COUNTRY_NAME = NameOID.COUNTRY_NAME\nOID_DOMAIN_COMPONENT = NameOID.DOMAIN_COMPONENT\nOID_DN_QUALIFIER = NameOID.DN_QUALIFIER\nOID_EMAIL_ADDRESS = NameOID.EMAIL_ADDRESS\nOID_GENERATION_QUALIFIER = NameOID.GENERATION_QUALIFIER\nOID_GIVEN_NAME = NameOID.GIVEN_NAME\nOID_LOCALITY_NAME = NameOID.LOCALITY_NAME\nOID_ORGANIZATIONAL_UNIT_NAME = NameOID.ORGANIZATIONAL_UNIT_NAME\nOID_ORGANIZATION_NAME = NameOID.ORGANIZATION_NAME\nOID_PSEUDONYM = NameOID.PSEUDONYM\nOID_SERIAL_NUMBER = NameOID.SERIAL_NUMBER\nOID_STATE_OR_PROVINCE_NAME = NameOID.STATE_OR_PROVINCE_NAME\nOID_SURNAME = NameOID.SURNAME\nOID_TITLE = NameOID.TITLE\n\nOID_CLIENT_AUTH = ExtendedKeyUsageOID.CLIENT_AUTH\nOID_CODE_SIGNING = ExtendedKeyUsageOID.CODE_SIGNING\nOID_EMAIL_PROTECTION = ExtendedKeyUsageOID.EMAIL_PROTECTION\nOID_OCSP_SIGNING = ExtendedKeyUsageOID.OCSP_SIGNING\nOID_SERVER_AUTH = ExtendedKeyUsageOID.SERVER_AUTH\nOID_TIME_STAMPING = ExtendedKeyUsageOID.TIME_STAMPING\n\nOID_ANY_POLICY = CertificatePoliciesOID.ANY_POLICY\nOID_CPS_QUALIFIER = CertificatePoliciesOID.CPS_QUALIFIER\nOID_CPS_USER_NOTICE = CertificatePoliciesOID.CPS_USER_NOTICE\n\nOID_CERTIFICATE_ISSUER = CRLEntryExtensionOID.CERTIFICATE_ISSUER\nOID_CRL_REASON = CRLEntryExtensionOID.CRL_REASON\nOID_INVALIDITY_DATE = CRLEntryExtensionOID.INVALIDITY_DATE\n\nOID_CA_ISSUERS = AuthorityInformationAccessOID.CA_ISSUERS\nOID_OCSP = AuthorityInformationAccessOID.OCSP\n\n__all__ = [\n    \"OID_CA_ISSUERS\",\n    \"OID_OCSP\",\n    \"AccessDescription\",\n    \"Attribute\",\n    \"AttributeNotFound\",\n    \"Attributes\",\n    \"AuthorityInformationAccess\",\n    \"AuthorityKeyIdentifier\",\n    \"BasicConstraints\",\n    \"CRLDistributionPoints\",\n    \"CRLNumber\",\n    \"CRLReason\",\n    \"Certificate\",\n    \"CertificateBuilder\",\n    \"CertificateIssuer\",\n    \"CertificatePolicies\",\n    \"CertificateRevocationList\",\n    \"CertificateRevocationListBuilder\",\n    \"CertificateSigningRequest\",\n    \"CertificateSigningRequestBuilder\",\n    \"DNSName\",\n    \"DeltaCRLIndicator\",\n    \"DirectoryName\",\n    \"DistributionPoint\",\n    \"DuplicateExtension\",\n    \"ExtendedKeyUsage\",\n    \"Extension\",\n    \"ExtensionNotFound\",\n    \"ExtensionType\",\n    \"Extensions\",\n    \"FreshestCRL\",\n    \"GeneralName\",\n    \"GeneralNames\",\n    \"IPAddress\",\n    \"InhibitAnyPolicy\",\n    \"InvalidVersion\",\n    \"InvalidityDate\",\n    \"IssuerAlternativeName\",\n    \"IssuingDistributionPoint\",\n    \"KeyUsage\",\n    \"MSCertificateTemplate\",\n    \"Name\",\n    \"NameAttribute\",\n    \"NameConstraints\",\n    \"NameOID\",\n    \"NoticeReference\",\n    \"OCSPAcceptableResponses\",\n    \"OCSPNoCheck\",\n    \"OCSPNonce\",\n    \"ObjectIdentifier\",\n    \"OtherName\",\n    \"PolicyConstraints\",\n    \"PolicyInformation\",\n    \"PrecertPoison\",\n    \"PrecertificateSignedCertificateTimestamps\",\n    \"PublicKeyAlgorithmOID\",\n    \"RFC822Name\",\n    \"ReasonFlags\",\n    \"RegisteredID\",\n    \"RelativeDistinguishedName\",\n    \"RevokedCertificate\",\n    \"RevokedCertificateBuilder\",\n    \"SignatureAlgorithmOID\",\n    \"SignedCertificateTimestamps\",\n    \"SubjectAlternativeName\",\n    \"SubjectInformationAccess\",\n    \"SubjectKeyIdentifier\",\n    \"TLSFeature\",\n    \"TLSFeatureType\",\n    \"UniformResourceIdentifier\",\n    \"UnrecognizedExtension\",\n    \"UnsupportedGeneralNameType\",\n    \"UserNotice\",\n    \"Version\",\n    \"certificate_transparency\",\n    \"load_der_x509_certificate\",\n    \"load_der_x509_crl\",\n    \"load_der_x509_csr\",\n    \"load_pem_x509_certificate\",\n    \"load_pem_x509_certificates\",\n    \"load_pem_x509_crl\",\n    \"load_pem_x509_csr\",\n    \"random_serial_number\",\n    \"verification\",\n    \"verification\",\n]\n", "src/cryptography/x509/oid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat._oid import (\n    AttributeOID,\n    AuthorityInformationAccessOID,\n    CertificatePoliciesOID,\n    CRLEntryExtensionOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    ObjectIdentifier,\n    OCSPExtensionOID,\n    PublicKeyAlgorithmOID,\n    SignatureAlgorithmOID,\n    SubjectInformationAccessOID,\n)\n\n__all__ = [\n    \"AttributeOID\",\n    \"AuthorityInformationAccessOID\",\n    \"CRLEntryExtensionOID\",\n    \"CertificatePoliciesOID\",\n    \"ExtendedKeyUsageOID\",\n    \"ExtensionOID\",\n    \"NameOID\",\n    \"OCSPExtensionOID\",\n    \"ObjectIdentifier\",\n    \"PublicKeyAlgorithmOID\",\n    \"SignatureAlgorithmOID\",\n    \"SubjectInformationAccessOID\",\n]\n", "src/cryptography/hazmat/_oid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import (\n    ObjectIdentifier as ObjectIdentifier,\n)\nfrom cryptography.hazmat.primitives import hashes\n\n\nclass ExtensionOID:\n    SUBJECT_DIRECTORY_ATTRIBUTES = ObjectIdentifier(\"2.5.29.9\")\n    SUBJECT_KEY_IDENTIFIER = ObjectIdentifier(\"2.5.29.14\")\n    KEY_USAGE = ObjectIdentifier(\"2.5.29.15\")\n    SUBJECT_ALTERNATIVE_NAME = ObjectIdentifier(\"2.5.29.17\")\n    ISSUER_ALTERNATIVE_NAME = ObjectIdentifier(\"2.5.29.18\")\n    BASIC_CONSTRAINTS = ObjectIdentifier(\"2.5.29.19\")\n    NAME_CONSTRAINTS = ObjectIdentifier(\"2.5.29.30\")\n    CRL_DISTRIBUTION_POINTS = ObjectIdentifier(\"2.5.29.31\")\n    CERTIFICATE_POLICIES = ObjectIdentifier(\"2.5.29.32\")\n    POLICY_MAPPINGS = ObjectIdentifier(\"2.5.29.33\")\n    AUTHORITY_KEY_IDENTIFIER = ObjectIdentifier(\"2.5.29.35\")\n    POLICY_CONSTRAINTS = ObjectIdentifier(\"2.5.29.36\")\n    EXTENDED_KEY_USAGE = ObjectIdentifier(\"2.5.29.37\")\n    FRESHEST_CRL = ObjectIdentifier(\"2.5.29.46\")\n    INHIBIT_ANY_POLICY = ObjectIdentifier(\"2.5.29.54\")\n    ISSUING_DISTRIBUTION_POINT = ObjectIdentifier(\"2.5.29.28\")\n    AUTHORITY_INFORMATION_ACCESS = ObjectIdentifier(\"1.3.6.1.5.5.7.1.1\")\n    SUBJECT_INFORMATION_ACCESS = ObjectIdentifier(\"1.3.6.1.5.5.7.1.11\")\n    OCSP_NO_CHECK = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.5\")\n    TLS_FEATURE = ObjectIdentifier(\"1.3.6.1.5.5.7.1.24\")\n    CRL_NUMBER = ObjectIdentifier(\"2.5.29.20\")\n    DELTA_CRL_INDICATOR = ObjectIdentifier(\"2.5.29.27\")\n    PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS = ObjectIdentifier(\n        \"1.3.6.1.4.1.11129.2.4.2\"\n    )\n    PRECERT_POISON = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.3\")\n    SIGNED_CERTIFICATE_TIMESTAMPS = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.5\")\n    MS_CERTIFICATE_TEMPLATE = ObjectIdentifier(\"1.3.6.1.4.1.311.21.7\")\n\n\nclass OCSPExtensionOID:\n    NONCE = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.2\")\n    ACCEPTABLE_RESPONSES = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.4\")\n\n\nclass CRLEntryExtensionOID:\n    CERTIFICATE_ISSUER = ObjectIdentifier(\"2.5.29.29\")\n    CRL_REASON = ObjectIdentifier(\"2.5.29.21\")\n    INVALIDITY_DATE = ObjectIdentifier(\"2.5.29.24\")\n\n\nclass NameOID:\n    COMMON_NAME = ObjectIdentifier(\"2.5.4.3\")\n    COUNTRY_NAME = ObjectIdentifier(\"2.5.4.6\")\n    LOCALITY_NAME = ObjectIdentifier(\"2.5.4.7\")\n    STATE_OR_PROVINCE_NAME = ObjectIdentifier(\"2.5.4.8\")\n    STREET_ADDRESS = ObjectIdentifier(\"2.5.4.9\")\n    ORGANIZATION_IDENTIFIER = ObjectIdentifier(\"2.5.4.97\")\n    ORGANIZATION_NAME = ObjectIdentifier(\"2.5.4.10\")\n    ORGANIZATIONAL_UNIT_NAME = ObjectIdentifier(\"2.5.4.11\")\n    SERIAL_NUMBER = ObjectIdentifier(\"2.5.4.5\")\n    SURNAME = ObjectIdentifier(\"2.5.4.4\")\n    GIVEN_NAME = ObjectIdentifier(\"2.5.4.42\")\n    TITLE = ObjectIdentifier(\"2.5.4.12\")\n    INITIALS = ObjectIdentifier(\"2.5.4.43\")\n    GENERATION_QUALIFIER = ObjectIdentifier(\"2.5.4.44\")\n    X500_UNIQUE_IDENTIFIER = ObjectIdentifier(\"2.5.4.45\")\n    DN_QUALIFIER = ObjectIdentifier(\"2.5.4.46\")\n    PSEUDONYM = ObjectIdentifier(\"2.5.4.65\")\n    USER_ID = ObjectIdentifier(\"0.9.2342.19200300.100.1.1\")\n    DOMAIN_COMPONENT = ObjectIdentifier(\"0.9.2342.19200300.100.1.25\")\n    EMAIL_ADDRESS = ObjectIdentifier(\"1.2.840.113549.1.9.1\")\n    JURISDICTION_COUNTRY_NAME = ObjectIdentifier(\"1.3.6.1.4.1.311.60.2.1.3\")\n    JURISDICTION_LOCALITY_NAME = ObjectIdentifier(\"1.3.6.1.4.1.311.60.2.1.1\")\n    JURISDICTION_STATE_OR_PROVINCE_NAME = ObjectIdentifier(\n        \"1.3.6.1.4.1.311.60.2.1.2\"\n    )\n    BUSINESS_CATEGORY = ObjectIdentifier(\"2.5.4.15\")\n    POSTAL_ADDRESS = ObjectIdentifier(\"2.5.4.16\")\n    POSTAL_CODE = ObjectIdentifier(\"2.5.4.17\")\n    INN = ObjectIdentifier(\"1.2.643.3.131.1.1\")\n    OGRN = ObjectIdentifier(\"1.2.643.100.1\")\n    SNILS = ObjectIdentifier(\"1.2.643.100.3\")\n    UNSTRUCTURED_NAME = ObjectIdentifier(\"1.2.840.113549.1.9.2\")\n\n\nclass SignatureAlgorithmOID:\n    RSA_WITH_MD5 = ObjectIdentifier(\"1.2.840.113549.1.1.4\")\n    RSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.113549.1.1.5\")\n    # This is an alternate OID for RSA with SHA1 that is occasionally seen\n    _RSA_WITH_SHA1 = ObjectIdentifier(\"1.3.14.3.2.29\")\n    RSA_WITH_SHA224 = ObjectIdentifier(\"1.2.840.113549.1.1.14\")\n    RSA_WITH_SHA256 = ObjectIdentifier(\"1.2.840.113549.1.1.11\")\n    RSA_WITH_SHA384 = ObjectIdentifier(\"1.2.840.113549.1.1.12\")\n    RSA_WITH_SHA512 = ObjectIdentifier(\"1.2.840.113549.1.1.13\")\n    RSA_WITH_SHA3_224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.13\")\n    RSA_WITH_SHA3_256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.14\")\n    RSA_WITH_SHA3_384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.15\")\n    RSA_WITH_SHA3_512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.16\")\n    RSASSA_PSS = ObjectIdentifier(\"1.2.840.113549.1.1.10\")\n    ECDSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.10045.4.1\")\n    ECDSA_WITH_SHA224 = ObjectIdentifier(\"1.2.840.10045.4.3.1\")\n    ECDSA_WITH_SHA256 = ObjectIdentifier(\"1.2.840.10045.4.3.2\")\n    ECDSA_WITH_SHA384 = ObjectIdentifier(\"1.2.840.10045.4.3.3\")\n    ECDSA_WITH_SHA512 = ObjectIdentifier(\"1.2.840.10045.4.3.4\")\n    ECDSA_WITH_SHA3_224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.9\")\n    ECDSA_WITH_SHA3_256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.10\")\n    ECDSA_WITH_SHA3_384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.11\")\n    ECDSA_WITH_SHA3_512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.12\")\n    DSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.10040.4.3\")\n    DSA_WITH_SHA224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.1\")\n    DSA_WITH_SHA256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.2\")\n    DSA_WITH_SHA384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.3\")\n    DSA_WITH_SHA512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.4\")\n    ED25519 = ObjectIdentifier(\"1.3.101.112\")\n    ED448 = ObjectIdentifier(\"1.3.101.113\")\n    GOSTR3411_94_WITH_3410_2001 = ObjectIdentifier(\"1.2.643.2.2.3\")\n    GOSTR3410_2012_WITH_3411_2012_256 = ObjectIdentifier(\"1.2.643.7.1.1.3.2\")\n    GOSTR3410_2012_WITH_3411_2012_512 = ObjectIdentifier(\"1.2.643.7.1.1.3.3\")\n\n\n_SIG_OIDS_TO_HASH: dict[ObjectIdentifier, hashes.HashAlgorithm | None] = {\n    SignatureAlgorithmOID.RSA_WITH_MD5: hashes.MD5(),\n    SignatureAlgorithmOID.RSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID._RSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.RSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.RSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.RSA_WITH_SHA384: hashes.SHA384(),\n    SignatureAlgorithmOID.RSA_WITH_SHA512: hashes.SHA512(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_224: hashes.SHA3_224(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_256: hashes.SHA3_256(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_384: hashes.SHA3_384(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_512: hashes.SHA3_512(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA384: hashes.SHA384(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA512: hashes.SHA512(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_224: hashes.SHA3_224(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_256: hashes.SHA3_256(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_384: hashes.SHA3_384(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_512: hashes.SHA3_512(),\n    SignatureAlgorithmOID.DSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.DSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.DSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.ED25519: None,\n    SignatureAlgorithmOID.ED448: None,\n    SignatureAlgorithmOID.GOSTR3411_94_WITH_3410_2001: None,\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_256: None,\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_512: None,\n}\n\n\nclass PublicKeyAlgorithmOID:\n    DSA = ObjectIdentifier(\"1.2.840.10040.4.1\")\n    EC_PUBLIC_KEY = ObjectIdentifier(\"1.2.840.10045.2.1\")\n    RSAES_PKCS1_v1_5 = ObjectIdentifier(\"1.2.840.113549.1.1.1\")\n    RSASSA_PSS = ObjectIdentifier(\"1.2.840.113549.1.1.10\")\n    X25519 = ObjectIdentifier(\"1.3.101.110\")\n    X448 = ObjectIdentifier(\"1.3.101.111\")\n    ED25519 = ObjectIdentifier(\"1.3.101.112\")\n    ED448 = ObjectIdentifier(\"1.3.101.113\")\n\n\nclass ExtendedKeyUsageOID:\n    SERVER_AUTH = ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\")\n    CLIENT_AUTH = ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\")\n    CODE_SIGNING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.3\")\n    EMAIL_PROTECTION = ObjectIdentifier(\"1.3.6.1.5.5.7.3.4\")\n    TIME_STAMPING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.8\")\n    OCSP_SIGNING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.9\")\n    ANY_EXTENDED_KEY_USAGE = ObjectIdentifier(\"2.5.29.37.0\")\n    SMARTCARD_LOGON = ObjectIdentifier(\"1.3.6.1.4.1.311.20.2.2\")\n    KERBEROS_PKINIT_KDC = ObjectIdentifier(\"1.3.6.1.5.2.3.5\")\n    IPSEC_IKE = ObjectIdentifier(\"1.3.6.1.5.5.7.3.17\")\n    CERTIFICATE_TRANSPARENCY = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.4\")\n\n\nclass AuthorityInformationAccessOID:\n    CA_ISSUERS = ObjectIdentifier(\"1.3.6.1.5.5.7.48.2\")\n    OCSP = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1\")\n\n\nclass SubjectInformationAccessOID:\n    CA_REPOSITORY = ObjectIdentifier(\"1.3.6.1.5.5.7.48.5\")\n\n\nclass CertificatePoliciesOID:\n    CPS_QUALIFIER = ObjectIdentifier(\"1.3.6.1.5.5.7.2.1\")\n    CPS_USER_NOTICE = ObjectIdentifier(\"1.3.6.1.5.5.7.2.2\")\n    ANY_POLICY = ObjectIdentifier(\"2.5.29.32.0\")\n\n\nclass AttributeOID:\n    CHALLENGE_PASSWORD = ObjectIdentifier(\"1.2.840.113549.1.9.7\")\n    UNSTRUCTURED_NAME = ObjectIdentifier(\"1.2.840.113549.1.9.2\")\n\n\n_OID_NAMES = {\n    NameOID.COMMON_NAME: \"commonName\",\n    NameOID.COUNTRY_NAME: \"countryName\",\n    NameOID.LOCALITY_NAME: \"localityName\",\n    NameOID.STATE_OR_PROVINCE_NAME: \"stateOrProvinceName\",\n    NameOID.STREET_ADDRESS: \"streetAddress\",\n    NameOID.ORGANIZATION_NAME: \"organizationName\",\n    NameOID.ORGANIZATIONAL_UNIT_NAME: \"organizationalUnitName\",\n    NameOID.SERIAL_NUMBER: \"serialNumber\",\n    NameOID.SURNAME: \"surname\",\n    NameOID.GIVEN_NAME: \"givenName\",\n    NameOID.TITLE: \"title\",\n    NameOID.GENERATION_QUALIFIER: \"generationQualifier\",\n    NameOID.X500_UNIQUE_IDENTIFIER: \"x500UniqueIdentifier\",\n    NameOID.DN_QUALIFIER: \"dnQualifier\",\n    NameOID.PSEUDONYM: \"pseudonym\",\n    NameOID.USER_ID: \"userID\",\n    NameOID.DOMAIN_COMPONENT: \"domainComponent\",\n    NameOID.EMAIL_ADDRESS: \"emailAddress\",\n    NameOID.JURISDICTION_COUNTRY_NAME: \"jurisdictionCountryName\",\n    NameOID.JURISDICTION_LOCALITY_NAME: \"jurisdictionLocalityName\",\n    NameOID.JURISDICTION_STATE_OR_PROVINCE_NAME: (\n        \"jurisdictionStateOrProvinceName\"\n    ),\n    NameOID.BUSINESS_CATEGORY: \"businessCategory\",\n    NameOID.POSTAL_ADDRESS: \"postalAddress\",\n    NameOID.POSTAL_CODE: \"postalCode\",\n    NameOID.INN: \"INN\",\n    NameOID.OGRN: \"OGRN\",\n    NameOID.SNILS: \"SNILS\",\n    NameOID.UNSTRUCTURED_NAME: \"unstructuredName\",\n    SignatureAlgorithmOID.RSA_WITH_MD5: \"md5WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA1: \"sha1WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA224: \"sha224WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA256: \"sha256WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA384: \"sha384WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA512: \"sha512WithRSAEncryption\",\n    SignatureAlgorithmOID.RSASSA_PSS: \"RSASSA-PSS\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA1: \"ecdsa-with-SHA1\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA224: \"ecdsa-with-SHA224\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA256: \"ecdsa-with-SHA256\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA384: \"ecdsa-with-SHA384\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA512: \"ecdsa-with-SHA512\",\n    SignatureAlgorithmOID.DSA_WITH_SHA1: \"dsa-with-sha1\",\n    SignatureAlgorithmOID.DSA_WITH_SHA224: \"dsa-with-sha224\",\n    SignatureAlgorithmOID.DSA_WITH_SHA256: \"dsa-with-sha256\",\n    SignatureAlgorithmOID.ED25519: \"ed25519\",\n    SignatureAlgorithmOID.ED448: \"ed448\",\n    SignatureAlgorithmOID.GOSTR3411_94_WITH_3410_2001: (\n        \"GOST R 34.11-94 with GOST R 34.10-2001\"\n    ),\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_256: (\n        \"GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)\"\n    ),\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_512: (\n        \"GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)\"\n    ),\n    PublicKeyAlgorithmOID.DSA: \"dsaEncryption\",\n    PublicKeyAlgorithmOID.EC_PUBLIC_KEY: \"id-ecPublicKey\",\n    PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5: \"rsaEncryption\",\n    PublicKeyAlgorithmOID.RSASSA_PSS: \"rsassaPss\",\n    PublicKeyAlgorithmOID.X25519: \"X25519\",\n    PublicKeyAlgorithmOID.X448: \"X448\",\n    ExtendedKeyUsageOID.SERVER_AUTH: \"serverAuth\",\n    ExtendedKeyUsageOID.CLIENT_AUTH: \"clientAuth\",\n    ExtendedKeyUsageOID.CODE_SIGNING: \"codeSigning\",\n    ExtendedKeyUsageOID.EMAIL_PROTECTION: \"emailProtection\",\n    ExtendedKeyUsageOID.TIME_STAMPING: \"timeStamping\",\n    ExtendedKeyUsageOID.OCSP_SIGNING: \"OCSPSigning\",\n    ExtendedKeyUsageOID.SMARTCARD_LOGON: \"msSmartcardLogin\",\n    ExtendedKeyUsageOID.KERBEROS_PKINIT_KDC: \"pkInitKDC\",\n    ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES: \"subjectDirectoryAttributes\",\n    ExtensionOID.SUBJECT_KEY_IDENTIFIER: \"subjectKeyIdentifier\",\n    ExtensionOID.KEY_USAGE: \"keyUsage\",\n    ExtensionOID.SUBJECT_ALTERNATIVE_NAME: \"subjectAltName\",\n    ExtensionOID.ISSUER_ALTERNATIVE_NAME: \"issuerAltName\",\n    ExtensionOID.BASIC_CONSTRAINTS: \"basicConstraints\",\n    ExtensionOID.PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS: (\n        \"signedCertificateTimestampList\"\n    ),\n    ExtensionOID.SIGNED_CERTIFICATE_TIMESTAMPS: (\n        \"signedCertificateTimestampList\"\n    ),\n    ExtensionOID.PRECERT_POISON: \"ctPoison\",\n    ExtensionOID.MS_CERTIFICATE_TEMPLATE: \"msCertificateTemplate\",\n    CRLEntryExtensionOID.CRL_REASON: \"cRLReason\",\n    CRLEntryExtensionOID.INVALIDITY_DATE: \"invalidityDate\",\n    CRLEntryExtensionOID.CERTIFICATE_ISSUER: \"certificateIssuer\",\n    ExtensionOID.NAME_CONSTRAINTS: \"nameConstraints\",\n    ExtensionOID.CRL_DISTRIBUTION_POINTS: \"cRLDistributionPoints\",\n    ExtensionOID.CERTIFICATE_POLICIES: \"certificatePolicies\",\n    ExtensionOID.POLICY_MAPPINGS: \"policyMappings\",\n    ExtensionOID.AUTHORITY_KEY_IDENTIFIER: \"authorityKeyIdentifier\",\n    ExtensionOID.POLICY_CONSTRAINTS: \"policyConstraints\",\n    ExtensionOID.EXTENDED_KEY_USAGE: \"extendedKeyUsage\",\n    ExtensionOID.FRESHEST_CRL: \"freshestCRL\",\n    ExtensionOID.INHIBIT_ANY_POLICY: \"inhibitAnyPolicy\",\n    ExtensionOID.ISSUING_DISTRIBUTION_POINT: \"issuingDistributionPoint\",\n    ExtensionOID.AUTHORITY_INFORMATION_ACCESS: \"authorityInfoAccess\",\n    ExtensionOID.SUBJECT_INFORMATION_ACCESS: \"subjectInfoAccess\",\n    ExtensionOID.OCSP_NO_CHECK: \"OCSPNoCheck\",\n    ExtensionOID.CRL_NUMBER: \"cRLNumber\",\n    ExtensionOID.DELTA_CRL_INDICATOR: \"deltaCRLIndicator\",\n    ExtensionOID.TLS_FEATURE: \"TLSFeature\",\n    AuthorityInformationAccessOID.OCSP: \"OCSP\",\n    AuthorityInformationAccessOID.CA_ISSUERS: \"caIssuers\",\n    SubjectInformationAccessOID.CA_REPOSITORY: \"caRepository\",\n    CertificatePoliciesOID.CPS_QUALIFIER: \"id-qt-cps\",\n    CertificatePoliciesOID.CPS_USER_NOTICE: \"id-qt-unotice\",\n    OCSPExtensionOID.NONCE: \"OCSPNonce\",\n    AttributeOID.CHALLENGE_PASSWORD: \"challengePassword\",\n}\n", "src/cryptography/hazmat/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\"\"\"\nHazardous Materials\n\nThis is a \"Hazardous Materials\" module. You should ONLY use it if you're\n100% absolutely sure that you know what you're doing because this module\nis full of land mines, dragons, and dinosaurs with laser guns.\n\"\"\"\n", "src/cryptography/hazmat/primitives/constant_time.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport hmac\n\n\ndef bytes_eq(a: bytes, b: bytes) -> bool:\n    if not isinstance(a, bytes) or not isinstance(b, bytes):\n        raise TypeError(\"a and b must be bytes.\")\n\n    return hmac.compare_digest(a, b)\n", "src/cryptography/hazmat/primitives/hashes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\n    \"MD5\",\n    \"SHA1\",\n    \"SHA3_224\",\n    \"SHA3_256\",\n    \"SHA3_384\",\n    \"SHA3_512\",\n    \"SHA224\",\n    \"SHA256\",\n    \"SHA384\",\n    \"SHA512\",\n    \"SHA512_224\",\n    \"SHA512_256\",\n    \"SHAKE128\",\n    \"SHAKE256\",\n    \"SM3\",\n    \"BLAKE2b\",\n    \"BLAKE2s\",\n    \"ExtendableOutputFunction\",\n    \"Hash\",\n    \"HashAlgorithm\",\n    \"HashContext\",\n]\n\n\nclass HashAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this algorithm (e.g. \"sha256\", \"md5\").\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def digest_size(self) -> int:\n        \"\"\"\n        The size of the resulting digest in bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def block_size(self) -> int | None:\n        \"\"\"\n        The internal block size of the hash function, or None if the hash\n        function does not use blocks internally (e.g. SHA3).\n        \"\"\"\n\n\nclass HashContext(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def algorithm(self) -> HashAlgorithm:\n        \"\"\"\n        A HashAlgorithm that will be used by this context.\n        \"\"\"\n\n    @abc.abstractmethod\n    def update(self, data: bytes) -> None:\n        \"\"\"\n        Processes the provided bytes through the hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Finalizes the hash context and returns the hash digest as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def copy(self) -> HashContext:\n        \"\"\"\n        Return a HashContext that is a copy of the current context.\n        \"\"\"\n\n\nHash = rust_openssl.hashes.Hash\nHashContext.register(Hash)\n\n\nclass ExtendableOutputFunction(metaclass=abc.ABCMeta):\n    \"\"\"\n    An interface for extendable output functions.\n    \"\"\"\n\n\nclass SHA1(HashAlgorithm):\n    name = \"sha1\"\n    digest_size = 20\n    block_size = 64\n\n\nclass SHA512_224(HashAlgorithm):  # noqa: N801\n    name = \"sha512-224\"\n    digest_size = 28\n    block_size = 128\n\n\nclass SHA512_256(HashAlgorithm):  # noqa: N801\n    name = \"sha512-256\"\n    digest_size = 32\n    block_size = 128\n\n\nclass SHA224(HashAlgorithm):\n    name = \"sha224\"\n    digest_size = 28\n    block_size = 64\n\n\nclass SHA256(HashAlgorithm):\n    name = \"sha256\"\n    digest_size = 32\n    block_size = 64\n\n\nclass SHA384(HashAlgorithm):\n    name = \"sha384\"\n    digest_size = 48\n    block_size = 128\n\n\nclass SHA512(HashAlgorithm):\n    name = \"sha512\"\n    digest_size = 64\n    block_size = 128\n\n\nclass SHA3_224(HashAlgorithm):  # noqa: N801\n    name = \"sha3-224\"\n    digest_size = 28\n    block_size = None\n\n\nclass SHA3_256(HashAlgorithm):  # noqa: N801\n    name = \"sha3-256\"\n    digest_size = 32\n    block_size = None\n\n\nclass SHA3_384(HashAlgorithm):  # noqa: N801\n    name = \"sha3-384\"\n    digest_size = 48\n    block_size = None\n\n\nclass SHA3_512(HashAlgorithm):  # noqa: N801\n    name = \"sha3-512\"\n    digest_size = 64\n    block_size = None\n\n\nclass SHAKE128(HashAlgorithm, ExtendableOutputFunction):\n    name = \"shake128\"\n    block_size = None\n\n    def __init__(self, digest_size: int):\n        if not isinstance(digest_size, int):\n            raise TypeError(\"digest_size must be an integer\")\n\n        if digest_size < 1:\n            raise ValueError(\"digest_size must be a positive integer\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass SHAKE256(HashAlgorithm, ExtendableOutputFunction):\n    name = \"shake256\"\n    block_size = None\n\n    def __init__(self, digest_size: int):\n        if not isinstance(digest_size, int):\n            raise TypeError(\"digest_size must be an integer\")\n\n        if digest_size < 1:\n            raise ValueError(\"digest_size must be a positive integer\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass MD5(HashAlgorithm):\n    name = \"md5\"\n    digest_size = 16\n    block_size = 64\n\n\nclass BLAKE2b(HashAlgorithm):\n    name = \"blake2b\"\n    _max_digest_size = 64\n    _min_digest_size = 1\n    block_size = 128\n\n    def __init__(self, digest_size: int):\n        if digest_size != 64:\n            raise ValueError(\"Digest size must be 64\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass BLAKE2s(HashAlgorithm):\n    name = \"blake2s\"\n    block_size = 64\n    _max_digest_size = 32\n    _min_digest_size = 1\n\n    def __init__(self, digest_size: int):\n        if digest_size != 32:\n            raise ValueError(\"Digest size must be 32\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass SM3(HashAlgorithm):\n    name = \"sm3\"\n    digest_size = 32\n    block_size = 64\n", "src/cryptography/hazmat/primitives/keywrap.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher\nfrom cryptography.hazmat.primitives.ciphers.algorithms import AES\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\nfrom cryptography.hazmat.primitives.constant_time import bytes_eq\n\n\ndef _wrap_core(\n    wrapping_key: bytes,\n    a: bytes,\n    r: list[bytes],\n) -> bytes:\n    # RFC 3394 Key Wrap - 2.2.1 (index method)\n    encryptor = Cipher(AES(wrapping_key), ECB()).encryptor()\n    n = len(r)\n    for j in range(6):\n        for i in range(n):\n            # every encryption operation is a discrete 16 byte chunk (because\n            # AES has a 128-bit block size) and since we're using ECB it is\n            # safe to reuse the encryptor for the entire operation\n            b = encryptor.update(a + r[i])\n            a = (\n                int.from_bytes(b[:8], byteorder=\"big\") ^ ((n * j) + i + 1)\n            ).to_bytes(length=8, byteorder=\"big\")\n            r[i] = b[-8:]\n\n    assert encryptor.finalize() == b\"\"\n\n    return a + b\"\".join(r)\n\n\ndef aes_key_wrap(\n    wrapping_key: bytes,\n    key_to_wrap: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    if len(key_to_wrap) < 16:\n        raise ValueError(\"The key to wrap must be at least 16 bytes\")\n\n    if len(key_to_wrap) % 8 != 0:\n        raise ValueError(\"The key to wrap must be a multiple of 8 bytes\")\n\n    a = b\"\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\"\n    r = [key_to_wrap[i : i + 8] for i in range(0, len(key_to_wrap), 8)]\n    return _wrap_core(wrapping_key, a, r)\n\n\ndef _unwrap_core(\n    wrapping_key: bytes,\n    a: bytes,\n    r: list[bytes],\n) -> tuple[bytes, list[bytes]]:\n    # Implement RFC 3394 Key Unwrap - 2.2.2 (index method)\n    decryptor = Cipher(AES(wrapping_key), ECB()).decryptor()\n    n = len(r)\n    for j in reversed(range(6)):\n        for i in reversed(range(n)):\n            atr = (\n                int.from_bytes(a, byteorder=\"big\") ^ ((n * j) + i + 1)\n            ).to_bytes(length=8, byteorder=\"big\") + r[i]\n            # every decryption operation is a discrete 16 byte chunk so\n            # it is safe to reuse the decryptor for the entire operation\n            b = decryptor.update(atr)\n            a = b[:8]\n            r[i] = b[-8:]\n\n    assert decryptor.finalize() == b\"\"\n    return a, r\n\n\ndef aes_key_wrap_with_padding(\n    wrapping_key: bytes,\n    key_to_wrap: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    aiv = b\"\\xa6\\x59\\x59\\xa6\" + len(key_to_wrap).to_bytes(\n        length=4, byteorder=\"big\"\n    )\n    # pad the key to wrap if necessary\n    pad = (8 - (len(key_to_wrap) % 8)) % 8\n    key_to_wrap = key_to_wrap + b\"\\x00\" * pad\n    if len(key_to_wrap) == 8:\n        # RFC 5649 - 4.1 - exactly 8 octets after padding\n        encryptor = Cipher(AES(wrapping_key), ECB()).encryptor()\n        b = encryptor.update(aiv + key_to_wrap)\n        assert encryptor.finalize() == b\"\"\n        return b\n    else:\n        r = [key_to_wrap[i : i + 8] for i in range(0, len(key_to_wrap), 8)]\n        return _wrap_core(wrapping_key, aiv, r)\n\n\ndef aes_key_unwrap_with_padding(\n    wrapping_key: bytes,\n    wrapped_key: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapped_key) < 16:\n        raise InvalidUnwrap(\"Must be at least 16 bytes\")\n\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    if len(wrapped_key) == 16:\n        # RFC 5649 - 4.2 - exactly two 64-bit blocks\n        decryptor = Cipher(AES(wrapping_key), ECB()).decryptor()\n        out = decryptor.update(wrapped_key)\n        assert decryptor.finalize() == b\"\"\n        a = out[:8]\n        data = out[8:]\n        n = 1\n    else:\n        r = [wrapped_key[i : i + 8] for i in range(0, len(wrapped_key), 8)]\n        encrypted_aiv = r.pop(0)\n        n = len(r)\n        a, r = _unwrap_core(wrapping_key, encrypted_aiv, r)\n        data = b\"\".join(r)\n\n    # 1) Check that MSB(32,A) = A65959A6.\n    # 2) Check that 8*(n-1) < LSB(32,A) <= 8*n.  If so, let\n    #    MLI = LSB(32,A).\n    # 3) Let b = (8*n)-MLI, and then check that the rightmost b octets of\n    #    the output data are zero.\n    mli = int.from_bytes(a[4:], byteorder=\"big\")\n    b = (8 * n) - mli\n    if (\n        not bytes_eq(a[:4], b\"\\xa6\\x59\\x59\\xa6\")\n        or not 8 * (n - 1) < mli <= 8 * n\n        or (b != 0 and not bytes_eq(data[-b:], b\"\\x00\" * b))\n    ):\n        raise InvalidUnwrap()\n\n    if b == 0:\n        return data\n    else:\n        return data[:-b]\n\n\ndef aes_key_unwrap(\n    wrapping_key: bytes,\n    wrapped_key: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapped_key) < 24:\n        raise InvalidUnwrap(\"Must be at least 24 bytes\")\n\n    if len(wrapped_key) % 8 != 0:\n        raise InvalidUnwrap(\"The wrapped key must be a multiple of 8 bytes\")\n\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    aiv = b\"\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\"\n    r = [wrapped_key[i : i + 8] for i in range(0, len(wrapped_key), 8)]\n    a = r.pop(0)\n    a, r = _unwrap_core(wrapping_key, a, r)\n    if not bytes_eq(a, aiv):\n        raise InvalidUnwrap()\n\n    return b\"\".join(r)\n\n\nclass InvalidUnwrap(Exception):\n    pass\n", "src/cryptography/hazmat/primitives/cmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\"CMAC\"]\nCMAC = rust_openssl.cmac.CMAC\n", "src/cryptography/hazmat/primitives/_serialization.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\nfrom cryptography.hazmat.primitives.hashes import HashAlgorithm\n\n# This exists to break an import cycle. These classes are normally accessible\n# from the serialization module.\n\n\nclass PBES(utils.Enum):\n    PBESv1SHA1And3KeyTripleDESCBC = \"PBESv1 using SHA1 and 3-Key TripleDES\"\n    PBESv2SHA256AndAES256CBC = \"PBESv2 using SHA256 PBKDF2 and AES256 CBC\"\n\n\nclass Encoding(utils.Enum):\n    PEM = \"PEM\"\n    DER = \"DER\"\n    OpenSSH = \"OpenSSH\"\n    Raw = \"Raw\"\n    X962 = \"ANSI X9.62\"\n    SMIME = \"S/MIME\"\n\n\nclass PrivateFormat(utils.Enum):\n    PKCS8 = \"PKCS8\"\n    TraditionalOpenSSL = \"TraditionalOpenSSL\"\n    Raw = \"Raw\"\n    OpenSSH = \"OpenSSH\"\n    PKCS12 = \"PKCS12\"\n\n    def encryption_builder(self) -> KeySerializationEncryptionBuilder:\n        if self not in (PrivateFormat.OpenSSH, PrivateFormat.PKCS12):\n            raise ValueError(\n                \"encryption_builder only supported with PrivateFormat.OpenSSH\"\n                \" and PrivateFormat.PKCS12\"\n            )\n        return KeySerializationEncryptionBuilder(self)\n\n\nclass PublicFormat(utils.Enum):\n    SubjectPublicKeyInfo = \"X.509 subjectPublicKeyInfo with PKCS#1\"\n    PKCS1 = \"Raw PKCS#1\"\n    OpenSSH = \"OpenSSH\"\n    Raw = \"Raw\"\n    CompressedPoint = \"X9.62 Compressed Point\"\n    UncompressedPoint = \"X9.62 Uncompressed Point\"\n\n\nclass ParameterFormat(utils.Enum):\n    PKCS3 = \"PKCS3\"\n\n\nclass KeySerializationEncryption(metaclass=abc.ABCMeta):\n    pass\n\n\nclass BestAvailableEncryption(KeySerializationEncryption):\n    def __init__(self, password: bytes):\n        if not isinstance(password, bytes) or len(password) == 0:\n            raise ValueError(\"Password must be 1 or more bytes.\")\n\n        self.password = password\n\n\nclass NoEncryption(KeySerializationEncryption):\n    pass\n\n\nclass KeySerializationEncryptionBuilder:\n    def __init__(\n        self,\n        format: PrivateFormat,\n        *,\n        _kdf_rounds: int | None = None,\n        _hmac_hash: HashAlgorithm | None = None,\n        _key_cert_algorithm: PBES | None = None,\n    ) -> None:\n        self._format = format\n\n        self._kdf_rounds = _kdf_rounds\n        self._hmac_hash = _hmac_hash\n        self._key_cert_algorithm = _key_cert_algorithm\n\n    def kdf_rounds(self, rounds: int) -> KeySerializationEncryptionBuilder:\n        if self._kdf_rounds is not None:\n            raise ValueError(\"kdf_rounds already set\")\n\n        if not isinstance(rounds, int):\n            raise TypeError(\"kdf_rounds must be an integer\")\n\n        if rounds < 1:\n            raise ValueError(\"kdf_rounds must be a positive integer\")\n\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=rounds,\n            _hmac_hash=self._hmac_hash,\n            _key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n    def hmac_hash(\n        self, algorithm: HashAlgorithm\n    ) -> KeySerializationEncryptionBuilder:\n        if self._format is not PrivateFormat.PKCS12:\n            raise TypeError(\n                \"hmac_hash only supported with PrivateFormat.PKCS12\"\n            )\n\n        if self._hmac_hash is not None:\n            raise ValueError(\"hmac_hash already set\")\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=self._kdf_rounds,\n            _hmac_hash=algorithm,\n            _key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n    def key_cert_algorithm(\n        self, algorithm: PBES\n    ) -> KeySerializationEncryptionBuilder:\n        if self._format is not PrivateFormat.PKCS12:\n            raise TypeError(\n                \"key_cert_algorithm only supported with \"\n                \"PrivateFormat.PKCS12\"\n            )\n        if self._key_cert_algorithm is not None:\n            raise ValueError(\"key_cert_algorithm already set\")\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=self._kdf_rounds,\n            _hmac_hash=self._hmac_hash,\n            _key_cert_algorithm=algorithm,\n        )\n\n    def build(self, password: bytes) -> KeySerializationEncryption:\n        if not isinstance(password, bytes) or len(password) == 0:\n            raise ValueError(\"Password must be 1 or more bytes.\")\n\n        return _KeySerializationEncryption(\n            self._format,\n            password,\n            kdf_rounds=self._kdf_rounds,\n            hmac_hash=self._hmac_hash,\n            key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n\nclass _KeySerializationEncryption(KeySerializationEncryption):\n    def __init__(\n        self,\n        format: PrivateFormat,\n        password: bytes,\n        *,\n        kdf_rounds: int | None,\n        hmac_hash: HashAlgorithm | None,\n        key_cert_algorithm: PBES | None,\n    ):\n        self._format = format\n        self.password = password\n\n        self._kdf_rounds = kdf_rounds\n        self._hmac_hash = hmac_hash\n        self._key_cert_algorithm = key_cert_algorithm\n", "src/cryptography/hazmat/primitives/padding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized\nfrom cryptography.hazmat.bindings._rust import (\n    PKCS7PaddingContext,\n    check_ansix923_padding,\n    check_pkcs7_padding,\n)\n\n\nclass PaddingContext(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def update(self, data: bytes) -> bytes:\n        \"\"\"\n        Pads the provided bytes and returns any available data as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Finalize the padding, returns bytes.\n        \"\"\"\n\n\ndef _byte_padding_check(block_size: int) -> None:\n    if not (0 <= block_size <= 2040):\n        raise ValueError(\"block_size must be in range(0, 2041).\")\n\n    if block_size % 8 != 0:\n        raise ValueError(\"block_size must be a multiple of 8.\")\n\n\ndef _byte_padding_update(\n    buffer_: bytes | None, data: bytes, block_size: int\n) -> tuple[bytes, bytes]:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    utils._check_byteslike(\"data\", data)\n\n    buffer_ += bytes(data)\n\n    finished_blocks = len(buffer_) // (block_size // 8)\n\n    result = buffer_[: finished_blocks * (block_size // 8)]\n    buffer_ = buffer_[finished_blocks * (block_size // 8) :]\n\n    return buffer_, result\n\n\ndef _byte_padding_pad(\n    buffer_: bytes | None,\n    block_size: int,\n    paddingfn: typing.Callable[[int], bytes],\n) -> bytes:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    pad_size = block_size // 8 - len(buffer_)\n    return buffer_ + paddingfn(pad_size)\n\n\ndef _byte_unpadding_update(\n    buffer_: bytes | None, data: bytes, block_size: int\n) -> tuple[bytes, bytes]:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    utils._check_byteslike(\"data\", data)\n\n    buffer_ += bytes(data)\n\n    finished_blocks = max(len(buffer_) // (block_size // 8) - 1, 0)\n\n    result = buffer_[: finished_blocks * (block_size // 8)]\n    buffer_ = buffer_[finished_blocks * (block_size // 8) :]\n\n    return buffer_, result\n\n\ndef _byte_unpadding_check(\n    buffer_: bytes | None,\n    block_size: int,\n    checkfn: typing.Callable[[bytes], int],\n) -> bytes:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    if len(buffer_) != block_size // 8:\n        raise ValueError(\"Invalid padding bytes.\")\n\n    valid = checkfn(buffer_)\n\n    if not valid:\n        raise ValueError(\"Invalid padding bytes.\")\n\n    pad_size = buffer_[-1]\n    return buffer_[:-pad_size]\n\n\nclass PKCS7:\n    def __init__(self, block_size: int):\n        _byte_padding_check(block_size)\n        self.block_size = block_size\n\n    def padder(self) -> PaddingContext:\n        return PKCS7PaddingContext(self.block_size)\n\n    def unpadder(self) -> PaddingContext:\n        return _PKCS7UnpaddingContext(self.block_size)\n\n\nclass _PKCS7UnpaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_unpadding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def finalize(self) -> bytes:\n        result = _byte_unpadding_check(\n            self._buffer, self.block_size, check_pkcs7_padding\n        )\n        self._buffer = None\n        return result\n\n\nPaddingContext.register(PKCS7PaddingContext)\n\n\nclass ANSIX923:\n    def __init__(self, block_size: int):\n        _byte_padding_check(block_size)\n        self.block_size = block_size\n\n    def padder(self) -> PaddingContext:\n        return _ANSIX923PaddingContext(self.block_size)\n\n    def unpadder(self) -> PaddingContext:\n        return _ANSIX923UnpaddingContext(self.block_size)\n\n\nclass _ANSIX923PaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_padding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def _padding(self, size: int) -> bytes:\n        return bytes([0]) * (size - 1) + bytes([size])\n\n    def finalize(self) -> bytes:\n        result = _byte_padding_pad(\n            self._buffer, self.block_size, self._padding\n        )\n        self._buffer = None\n        return result\n\n\nclass _ANSIX923UnpaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_unpadding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def finalize(self) -> bytes:\n        result = _byte_unpadding_check(\n            self._buffer,\n            self.block_size,\n            check_ansix923_padding,\n        )\n        self._buffer = None\n        return result\n", "src/cryptography/hazmat/primitives/_cipheralgorithm.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\n\n# This exists to break an import cycle. It is normally accessible from the\n# ciphers module.\n\n\nclass CipherAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this mode (e.g. \"AES\", \"Camellia\").\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_sizes(self) -> frozenset[int]:\n        \"\"\"\n        Valid key sizes for this algorithm in bits\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The size of the key being used as an integer in bits (e.g. 128, 256).\n        \"\"\"\n\n\nclass BlockCipherAlgorithm(CipherAlgorithm):\n    key: bytes\n\n    @property\n    @abc.abstractmethod\n    def block_size(self) -> int:\n        \"\"\"\n        The size of a block as an integer in bits (e.g. 64, 128).\n        \"\"\"\n\n\ndef _verify_key_size(algorithm: CipherAlgorithm, key: bytes) -> bytes:\n    # Verify that the key is instance of bytes\n    utils._check_byteslike(\"key\", key)\n\n    # Verify that the key size matches the expected key size\n    if len(key) * 8 not in algorithm.key_sizes:\n        raise ValueError(\n            f\"Invalid key size ({len(key) * 8}) for {algorithm.name}.\"\n        )\n    return key\n", "src/cryptography/hazmat/primitives/poly1305.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\"Poly1305\"]\n\nPoly1305 = rust_openssl.poly1305.Poly1305\n", "src/cryptography/hazmat/primitives/hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes\n\n__all__ = [\"HMAC\"]\n\nHMAC = rust_openssl.hmac.HMAC\nhashes.HashContext.register(HMAC)\n", "src/cryptography/hazmat/primitives/_asymmetric.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\n# This exists to break an import cycle. It is normally accessible from the\n# asymmetric padding module.\n\n\nclass AsymmetricPadding(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this padding (e.g. \"PSS\", \"PKCS1\").\n        \"\"\"\n", "src/cryptography/hazmat/primitives/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/primitives/twofactor/totp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\nfrom cryptography.hazmat.primitives.twofactor.hotp import (\n    HOTP,\n    HOTPHashTypes,\n    _generate_uri,\n)\n\n\nclass TOTP:\n    def __init__(\n        self,\n        key: bytes,\n        length: int,\n        algorithm: HOTPHashTypes,\n        time_step: int,\n        backend: typing.Any = None,\n        enforce_key_length: bool = True,\n    ):\n        self._time_step = time_step\n        self._hotp = HOTP(\n            key, length, algorithm, enforce_key_length=enforce_key_length\n        )\n\n    def generate(self, time: int | float) -> bytes:\n        counter = int(time / self._time_step)\n        return self._hotp.generate(counter)\n\n    def verify(self, totp: bytes, time: int) -> None:\n        if not constant_time.bytes_eq(self.generate(time), totp):\n            raise InvalidToken(\"Supplied TOTP value does not match.\")\n\n    def get_provisioning_uri(\n        self, account_name: str, issuer: str | None\n    ) -> str:\n        return _generate_uri(\n            self._hotp,\n            \"totp\",\n            account_name,\n            issuer,\n            [(\"period\", int(self._time_step))],\n        )\n", "src/cryptography/hazmat/primitives/twofactor/hotp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport base64\nimport typing\nfrom urllib.parse import quote, urlencode\n\nfrom cryptography.hazmat.primitives import constant_time, hmac\nfrom cryptography.hazmat.primitives.hashes import SHA1, SHA256, SHA512\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\n\nHOTPHashTypes = typing.Union[SHA1, SHA256, SHA512]\n\n\ndef _generate_uri(\n    hotp: HOTP,\n    type_name: str,\n    account_name: str,\n    issuer: str | None,\n    extra_parameters: list[tuple[str, int]],\n) -> str:\n    parameters = [\n        (\"digits\", hotp._length),\n        (\"secret\", base64.b32encode(hotp._key)),\n        (\"algorithm\", hotp._algorithm.name.upper()),\n    ]\n\n    if issuer is not None:\n        parameters.append((\"issuer\", issuer))\n\n    parameters.extend(extra_parameters)\n\n    label = (\n        f\"{quote(issuer)}:{quote(account_name)}\"\n        if issuer\n        else quote(account_name)\n    )\n    return f\"otpauth://{type_name}/{label}?{urlencode(parameters)}\"\n\n\nclass HOTP:\n    def __init__(\n        self,\n        key: bytes,\n        length: int,\n        algorithm: HOTPHashTypes,\n        backend: typing.Any = None,\n        enforce_key_length: bool = True,\n    ) -> None:\n        if len(key) < 16 and enforce_key_length is True:\n            raise ValueError(\"Key length has to be at least 128 bits.\")\n\n        if not isinstance(length, int):\n            raise TypeError(\"Length parameter must be an integer type.\")\n\n        if length < 6 or length > 8:\n            raise ValueError(\"Length of HOTP has to be between 6 and 8.\")\n\n        if not isinstance(algorithm, (SHA1, SHA256, SHA512)):\n            raise TypeError(\"Algorithm must be SHA1, SHA256 or SHA512.\")\n\n        self._key = key\n        self._length = length\n        self._algorithm = algorithm\n\n    def generate(self, counter: int) -> bytes:\n        truncated_value = self._dynamic_truncate(counter)\n        hotp = truncated_value % (10**self._length)\n        return \"{0:0{1}}\".format(hotp, self._length).encode()\n\n    def verify(self, hotp: bytes, counter: int) -> None:\n        if not constant_time.bytes_eq(self.generate(counter), hotp):\n            raise InvalidToken(\"Supplied HOTP value does not match.\")\n\n    def _dynamic_truncate(self, counter: int) -> int:\n        ctx = hmac.HMAC(self._key, self._algorithm)\n        ctx.update(counter.to_bytes(length=8, byteorder=\"big\"))\n        hmac_value = ctx.finalize()\n\n        offset = hmac_value[len(hmac_value) - 1] & 0b1111\n        p = hmac_value[offset : offset + 4]\n        return int.from_bytes(p, byteorder=\"big\") & 0x7FFFFFFF\n\n    def get_provisioning_uri(\n        self, account_name: str, counter: int, issuer: str | None\n    ) -> str:\n        return _generate_uri(\n            self, \"hotp\", account_name, issuer, [(\"counter\", int(counter))]\n        )\n", "src/cryptography/hazmat/primitives/twofactor/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\nclass InvalidToken(Exception):\n    pass\n", "src/cryptography/hazmat/primitives/asymmetric/dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\ngenerate_parameters = rust_openssl.dh.generate_parameters\n\n\nDHPrivateNumbers = rust_openssl.dh.DHPrivateNumbers\nDHPublicNumbers = rust_openssl.dh.DHPublicNumbers\nDHParameterNumbers = rust_openssl.dh.DHParameterNumbers\n\n\nclass DHParameters(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def generate_private_key(self) -> DHPrivateKey:\n        \"\"\"\n        Generates and returns a DHPrivateKey.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.ParameterFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the parameters serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_numbers(self) -> DHParameterNumbers:\n        \"\"\"\n        Returns a DHParameterNumbers.\n        \"\"\"\n\n\nDHParametersWithSerialization = DHParameters\nDHParameters.register(rust_openssl.dh.DHParameters)\n\n\nclass DHPublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DHParameters:\n        \"\"\"\n        The DHParameters object associated with this public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> DHPublicNumbers:\n        \"\"\"\n        Returns a DHPublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nDHPublicKeyWithSerialization = DHPublicKey\nDHPublicKey.register(rust_openssl.dh.DHPublicKey)\n\n\nclass DHPrivateKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> DHPublicKey:\n        \"\"\"\n        The DHPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DHParameters:\n        \"\"\"\n        The DHParameters object associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: DHPublicKey) -> bytes:\n        \"\"\"\n        Given peer's DHPublicKey, carry out the key exchange and\n        return shared key as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> DHPrivateNumbers:\n        \"\"\"\n        Returns a DHPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nDHPrivateKeyWithSerialization = DHPrivateKey\nDHPrivateKey.register(rust_openssl.dh.DHPrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass DSAParameters(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def generate_private_key(self) -> DSAPrivateKey:\n        \"\"\"\n        Generates and returns a DSAPrivateKey.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_numbers(self) -> DSAParameterNumbers:\n        \"\"\"\n        Returns a DSAParameterNumbers.\n        \"\"\"\n\n\nDSAParametersWithNumbers = DSAParameters\nDSAParameters.register(rust_openssl.dsa.DSAParameters)\n\n\nclass DSAPrivateKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> DSAPublicKey:\n        \"\"\"\n        The DSAPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DSAParameters:\n        \"\"\"\n        The DSAParameters object associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> DSAPrivateNumbers:\n        \"\"\"\n        Returns a DSAPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nDSAPrivateKeyWithSerialization = DSAPrivateKey\nDSAPrivateKey.register(rust_openssl.dsa.DSAPrivateKey)\n\n\nclass DSAPublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DSAParameters:\n        \"\"\"\n        The DSAParameters object associated with this public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> DSAPublicNumbers:\n        \"\"\"\n        Returns a DSAPublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nDSAPublicKeyWithSerialization = DSAPublicKey\nDSAPublicKey.register(rust_openssl.dsa.DSAPublicKey)\n\nDSAPrivateNumbers = rust_openssl.dsa.DSAPrivateNumbers\nDSAPublicNumbers = rust_openssl.dsa.DSAPublicNumbers\nDSAParameterNumbers = rust_openssl.dsa.DSAParameterNumbers\n\n\ndef generate_parameters(\n    key_size: int, backend: typing.Any = None\n) -> DSAParameters:\n    if key_size not in (1024, 2048, 3072, 4096):\n        raise ValueError(\"Key size must be 1024, 2048, 3072, or 4096 bits.\")\n\n    return rust_openssl.dsa.generate_parameters(key_size)\n\n\ndef generate_private_key(\n    key_size: int, backend: typing.Any = None\n) -> DSAPrivateKey:\n    parameters = generate_parameters(key_size)\n    return parameters.generate_private_key()\n", "src/cryptography/hazmat/primitives/asymmetric/ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat._oid import ObjectIdentifier\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass EllipticCurveOID:\n    SECP192R1 = ObjectIdentifier(\"1.2.840.10045.3.1.1\")\n    SECP224R1 = ObjectIdentifier(\"1.3.132.0.33\")\n    SECP256K1 = ObjectIdentifier(\"1.3.132.0.10\")\n    SECP256R1 = ObjectIdentifier(\"1.2.840.10045.3.1.7\")\n    SECP384R1 = ObjectIdentifier(\"1.3.132.0.34\")\n    SECP521R1 = ObjectIdentifier(\"1.3.132.0.35\")\n    BRAINPOOLP256R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.7\")\n    BRAINPOOLP384R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.11\")\n    BRAINPOOLP512R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.13\")\n    SECT163K1 = ObjectIdentifier(\"1.3.132.0.1\")\n    SECT163R2 = ObjectIdentifier(\"1.3.132.0.15\")\n    SECT233K1 = ObjectIdentifier(\"1.3.132.0.26\")\n    SECT233R1 = ObjectIdentifier(\"1.3.132.0.27\")\n    SECT283K1 = ObjectIdentifier(\"1.3.132.0.16\")\n    SECT283R1 = ObjectIdentifier(\"1.3.132.0.17\")\n    SECT409K1 = ObjectIdentifier(\"1.3.132.0.36\")\n    SECT409R1 = ObjectIdentifier(\"1.3.132.0.37\")\n    SECT571K1 = ObjectIdentifier(\"1.3.132.0.38\")\n    SECT571R1 = ObjectIdentifier(\"1.3.132.0.39\")\n\n\nclass EllipticCurve(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The name of the curve. e.g. secp256r1.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n\nclass EllipticCurveSignatureAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def algorithm(\n        self,\n    ) -> asym_utils.Prehashed | hashes.HashAlgorithm:\n        \"\"\"\n        The digest algorithm used with this signature.\n        \"\"\"\n\n\nclass EllipticCurvePrivateKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def exchange(\n        self, algorithm: ECDH, peer_public_key: EllipticCurvePublicKey\n    ) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided algorithm with the\n        provided peer's public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> EllipticCurvePublicKey:\n        \"\"\"\n        The EllipticCurvePublicKey for this private key.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def curve(self) -> EllipticCurve:\n        \"\"\"\n        The EllipticCurve that this key is on.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        signature_algorithm: EllipticCurveSignatureAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> EllipticCurvePrivateNumbers:\n        \"\"\"\n        Returns an EllipticCurvePrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nEllipticCurvePrivateKeyWithSerialization = EllipticCurvePrivateKey\nEllipticCurvePrivateKey.register(rust_openssl.ec.ECPrivateKey)\n\n\nclass EllipticCurvePublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def curve(self) -> EllipticCurve:\n        \"\"\"\n        The EllipticCurve that this key is on.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> EllipticCurvePublicNumbers:\n        \"\"\"\n        Returns an EllipticCurvePublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        signature_algorithm: EllipticCurveSignatureAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @classmethod\n    def from_encoded_point(\n        cls, curve: EllipticCurve, data: bytes\n    ) -> EllipticCurvePublicKey:\n        utils._check_bytes(\"data\", data)\n\n        if len(data) == 0:\n            raise ValueError(\"data must not be an empty byte string\")\n\n        if data[0] not in [0x02, 0x03, 0x04]:\n            raise ValueError(\"Unsupported elliptic curve point type\")\n\n        return rust_openssl.ec.from_public_bytes(curve, data)\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nEllipticCurvePublicKeyWithSerialization = EllipticCurvePublicKey\nEllipticCurvePublicKey.register(rust_openssl.ec.ECPublicKey)\n\nEllipticCurvePrivateNumbers = rust_openssl.ec.EllipticCurvePrivateNumbers\nEllipticCurvePublicNumbers = rust_openssl.ec.EllipticCurvePublicNumbers\n\n\nclass SECT571R1(EllipticCurve):\n    name = \"sect571r1\"\n    key_size = 570\n\n\nclass SECT409R1(EllipticCurve):\n    name = \"sect409r1\"\n    key_size = 409\n\n\nclass SECT283R1(EllipticCurve):\n    name = \"sect283r1\"\n    key_size = 283\n\n\nclass SECT233R1(EllipticCurve):\n    name = \"sect233r1\"\n    key_size = 233\n\n\nclass SECT163R2(EllipticCurve):\n    name = \"sect163r2\"\n    key_size = 163\n\n\nclass SECT571K1(EllipticCurve):\n    name = \"sect571k1\"\n    key_size = 571\n\n\nclass SECT409K1(EllipticCurve):\n    name = \"sect409k1\"\n    key_size = 409\n\n\nclass SECT283K1(EllipticCurve):\n    name = \"sect283k1\"\n    key_size = 283\n\n\nclass SECT233K1(EllipticCurve):\n    name = \"sect233k1\"\n    key_size = 233\n\n\nclass SECT163K1(EllipticCurve):\n    name = \"sect163k1\"\n    key_size = 163\n\n\nclass SECP521R1(EllipticCurve):\n    name = \"secp521r1\"\n    key_size = 521\n\n\nclass SECP384R1(EllipticCurve):\n    name = \"secp384r1\"\n    key_size = 384\n\n\nclass SECP256R1(EllipticCurve):\n    name = \"secp256r1\"\n    key_size = 256\n\n\nclass SECP256K1(EllipticCurve):\n    name = \"secp256k1\"\n    key_size = 256\n\n\nclass SECP224R1(EllipticCurve):\n    name = \"secp224r1\"\n    key_size = 224\n\n\nclass SECP192R1(EllipticCurve):\n    name = \"secp192r1\"\n    key_size = 192\n\n\nclass BrainpoolP256R1(EllipticCurve):\n    name = \"brainpoolP256r1\"\n    key_size = 256\n\n\nclass BrainpoolP384R1(EllipticCurve):\n    name = \"brainpoolP384r1\"\n    key_size = 384\n\n\nclass BrainpoolP512R1(EllipticCurve):\n    name = \"brainpoolP512r1\"\n    key_size = 512\n\n\n_CURVE_TYPES: dict[str, EllipticCurve] = {\n    \"prime192v1\": SECP192R1(),\n    \"prime256v1\": SECP256R1(),\n    \"secp192r1\": SECP192R1(),\n    \"secp224r1\": SECP224R1(),\n    \"secp256r1\": SECP256R1(),\n    \"secp384r1\": SECP384R1(),\n    \"secp521r1\": SECP521R1(),\n    \"secp256k1\": SECP256K1(),\n    \"sect163k1\": SECT163K1(),\n    \"sect233k1\": SECT233K1(),\n    \"sect283k1\": SECT283K1(),\n    \"sect409k1\": SECT409K1(),\n    \"sect571k1\": SECT571K1(),\n    \"sect163r2\": SECT163R2(),\n    \"sect233r1\": SECT233R1(),\n    \"sect283r1\": SECT283R1(),\n    \"sect409r1\": SECT409R1(),\n    \"sect571r1\": SECT571R1(),\n    \"brainpoolP256r1\": BrainpoolP256R1(),\n    \"brainpoolP384r1\": BrainpoolP384R1(),\n    \"brainpoolP512r1\": BrainpoolP512R1(),\n}\n\n\nclass ECDSA(EllipticCurveSignatureAlgorithm):\n    def __init__(\n        self,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n        deterministic_signing: bool = False,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if (\n            deterministic_signing\n            and not backend.ecdsa_deterministic_supported()\n        ):\n            raise UnsupportedAlgorithm(\n                \"ECDSA with deterministic signature (RFC 6979) is not \"\n                \"supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n        self._algorithm = algorithm\n        self._deterministic_signing = deterministic_signing\n\n    @property\n    def algorithm(\n        self,\n    ) -> asym_utils.Prehashed | hashes.HashAlgorithm:\n        return self._algorithm\n\n    @property\n    def deterministic_signing(\n        self,\n    ) -> bool:\n        return self._deterministic_signing\n\n\ngenerate_private_key = rust_openssl.ec.generate_private_key\n\n\ndef derive_private_key(\n    private_value: int,\n    curve: EllipticCurve,\n    backend: typing.Any = None,\n) -> EllipticCurvePrivateKey:\n    if not isinstance(private_value, int):\n        raise TypeError(\"private_value must be an integer type.\")\n\n    if private_value <= 0:\n        raise ValueError(\"private_value must be a positive integer.\")\n\n    return rust_openssl.ec.derive_private_key(private_value, curve)\n\n\nclass ECDH:\n    pass\n\n\n_OID_TO_CURVE = {\n    EllipticCurveOID.SECP192R1: SECP192R1,\n    EllipticCurveOID.SECP224R1: SECP224R1,\n    EllipticCurveOID.SECP256K1: SECP256K1,\n    EllipticCurveOID.SECP256R1: SECP256R1,\n    EllipticCurveOID.SECP384R1: SECP384R1,\n    EllipticCurveOID.SECP521R1: SECP521R1,\n    EllipticCurveOID.BRAINPOOLP256R1: BrainpoolP256R1,\n    EllipticCurveOID.BRAINPOOLP384R1: BrainpoolP384R1,\n    EllipticCurveOID.BRAINPOOLP512R1: BrainpoolP512R1,\n    EllipticCurveOID.SECT163K1: SECT163K1,\n    EllipticCurveOID.SECT163R2: SECT163R2,\n    EllipticCurveOID.SECT233K1: SECT233K1,\n    EllipticCurveOID.SECT233R1: SECT233R1,\n    EllipticCurveOID.SECT283K1: SECT283K1,\n    EllipticCurveOID.SECT283R1: SECT283R1,\n    EllipticCurveOID.SECT409K1: SECT409K1,\n    EllipticCurveOID.SECT409R1: SECT409R1,\n    EllipticCurveOID.SECT571K1: SECT571K1,\n    EllipticCurveOID.SECT571R1: SECT571R1,\n}\n\n\ndef get_curve_for_oid(oid: ObjectIdentifier) -> type[EllipticCurve]:\n    try:\n        return _OID_TO_CURVE[oid]\n    except KeyError:\n        raise LookupError(\n            \"The provided object identifier has no matching elliptic \"\n            \"curve class\"\n        )\n", "src/cryptography/hazmat/primitives/asymmetric/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import asn1\nfrom cryptography.hazmat.primitives import hashes\n\ndecode_dss_signature = asn1.decode_dss_signature\nencode_dss_signature = asn1.encode_dss_signature\n\n\nclass Prehashed:\n    def __init__(self, algorithm: hashes.HashAlgorithm):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of HashAlgorithm.\")\n\n        self._algorithm = algorithm\n        self._digest_size = algorithm.digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n", "src/cryptography/hazmat/primitives/asymmetric/padding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives._asymmetric import (\n    AsymmetricPadding as AsymmetricPadding,\n)\nfrom cryptography.hazmat.primitives.asymmetric import rsa\n\n\nclass PKCS1v15(AsymmetricPadding):\n    name = \"EMSA-PKCS1-v1_5\"\n\n\nclass _MaxLength:\n    \"Sentinel value for `MAX_LENGTH`.\"\n\n\nclass _Auto:\n    \"Sentinel value for `AUTO`.\"\n\n\nclass _DigestLength:\n    \"Sentinel value for `DIGEST_LENGTH`.\"\n\n\nclass PSS(AsymmetricPadding):\n    MAX_LENGTH = _MaxLength()\n    AUTO = _Auto()\n    DIGEST_LENGTH = _DigestLength()\n    name = \"EMSA-PSS\"\n    _salt_length: int | _MaxLength | _Auto | _DigestLength\n\n    def __init__(\n        self,\n        mgf: MGF,\n        salt_length: int | _MaxLength | _Auto | _DigestLength,\n    ) -> None:\n        self._mgf = mgf\n\n        if not isinstance(\n            salt_length, (int, _MaxLength, _Auto, _DigestLength)\n        ):\n            raise TypeError(\n                \"salt_length must be an integer, MAX_LENGTH, \"\n                \"DIGEST_LENGTH, or AUTO\"\n            )\n\n        if isinstance(salt_length, int) and salt_length < 0:\n            raise ValueError(\"salt_length must be zero or greater.\")\n\n        self._salt_length = salt_length\n\n    @property\n    def mgf(self) -> MGF:\n        return self._mgf\n\n\nclass OAEP(AsymmetricPadding):\n    name = \"EME-OAEP\"\n\n    def __init__(\n        self,\n        mgf: MGF,\n        algorithm: hashes.HashAlgorithm,\n        label: bytes | None,\n    ):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of hashes.HashAlgorithm.\")\n\n        self._mgf = mgf\n        self._algorithm = algorithm\n        self._label = label\n\n    @property\n    def algorithm(self) -> hashes.HashAlgorithm:\n        return self._algorithm\n\n    @property\n    def mgf(self) -> MGF:\n        return self._mgf\n\n\nclass MGF(metaclass=abc.ABCMeta):\n    _algorithm: hashes.HashAlgorithm\n\n\nclass MGF1(MGF):\n    MAX_LENGTH = _MaxLength()\n\n    def __init__(self, algorithm: hashes.HashAlgorithm):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of hashes.HashAlgorithm.\")\n\n        self._algorithm = algorithm\n\n\ndef calculate_max_pss_salt_length(\n    key: rsa.RSAPrivateKey | rsa.RSAPublicKey,\n    hash_algorithm: hashes.HashAlgorithm,\n) -> int:\n    if not isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):\n        raise TypeError(\"key must be an RSA public or private key\")\n    # bit length - 1 per RFC 3447\n    emlen = (key.key_size + 6) // 8\n    salt_length = emlen - hash_algorithm.digest_size - 2\n    assert salt_length >= 0\n    return salt_length\n", "src/cryptography/hazmat/primitives/asymmetric/ed448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass Ed448PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> Ed448PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, signature: bytes, data: bytes) -> None:\n        \"\"\"\n        Verify the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"ed448\"):\n    Ed448PublicKey.register(rust_openssl.ed448.Ed448PublicKey)\n\n\nclass Ed448PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> Ed448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> Ed448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> Ed448PublicKey:\n        \"\"\"\n        The Ed448PublicKey derived from the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(self, data: bytes) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    Ed448PrivateKey.register(rust_openssl.ed448.Ed448PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/x25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass X25519PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> X25519PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x25519.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nX25519PublicKey.register(rust_openssl.x25519.X25519PublicKey)\n\n\nclass X25519PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> X25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n        return rust_openssl.x25519.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> X25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x25519.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> X25519PublicKey:\n        \"\"\"\n        Returns the public key associated with this private key\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: X25519PublicKey) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided peer's public key.\n        \"\"\"\n\n\nX25519PrivateKey.register(rust_openssl.x25519.X25519PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/ed25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass Ed25519PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> Ed25519PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, signature: bytes, data: bytes) -> None:\n        \"\"\"\n        Verify the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nEd25519PublicKey.register(rust_openssl.ed25519.Ed25519PublicKey)\n\n\nclass Ed25519PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> Ed25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> Ed25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> Ed25519PublicKey:\n        \"\"\"\n        The Ed25519PublicKey derived from the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(self, data: bytes) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n\nEd25519PrivateKey.register(rust_openssl.ed25519.Ed25519PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/types.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dh,\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n    x448,\n    x25519,\n)\n\n# Every asymmetric key type\nPublicKeyTypes = typing.Union[\n    dh.DHPublicKey,\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n    x25519.X25519PublicKey,\n    x448.X448PublicKey,\n]\nPUBLIC_KEY_TYPES = PublicKeyTypes\nutils.deprecated(\n    PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use PublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"PUBLIC_KEY_TYPES\",\n)\n# Every asymmetric key type\nPrivateKeyTypes = typing.Union[\n    dh.DHPrivateKey,\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n    x25519.X25519PrivateKey,\n    x448.X448PrivateKey,\n]\nPRIVATE_KEY_TYPES = PrivateKeyTypes\nutils.deprecated(\n    PRIVATE_KEY_TYPES,\n    __name__,\n    \"Use PrivateKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"PRIVATE_KEY_TYPES\",\n)\n# Just the key types we allow to be used for x509 signing. This mirrors\n# the certificate public key types\nCertificateIssuerPrivateKeyTypes = typing.Union[\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n]\nCERTIFICATE_PRIVATE_KEY_TYPES = CertificateIssuerPrivateKeyTypes\nutils.deprecated(\n    CERTIFICATE_PRIVATE_KEY_TYPES,\n    __name__,\n    \"Use CertificateIssuerPrivateKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_PRIVATE_KEY_TYPES\",\n)\n# Just the key types we allow to be used for x509 signing. This mirrors\n# the certificate private key types\nCertificateIssuerPublicKeyTypes = typing.Union[\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n]\nCERTIFICATE_ISSUER_PUBLIC_KEY_TYPES = CertificateIssuerPublicKeyTypes\nutils.deprecated(\n    CERTIFICATE_ISSUER_PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use CertificateIssuerPublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_ISSUER_PUBLIC_KEY_TYPES\",\n)\n# This type removes DHPublicKey. x448/x25519 can be a public key\n# but cannot be used in signing so they are allowed here.\nCertificatePublicKeyTypes = typing.Union[\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n    x25519.X25519PublicKey,\n    x448.X448PublicKey,\n]\nCERTIFICATE_PUBLIC_KEY_TYPES = CertificatePublicKeyTypes\nutils.deprecated(\n    CERTIFICATE_PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use CertificatePublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_PUBLIC_KEY_TYPES\",\n)\n", "src/cryptography/hazmat/primitives/asymmetric/rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\nfrom math import gcd\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass RSAPrivateKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def decrypt(self, ciphertext: bytes, padding: AsymmetricPadding) -> bytes:\n        \"\"\"\n        Decrypts the provided ciphertext.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the public modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> RSAPublicKey:\n        \"\"\"\n        The RSAPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        padding: AsymmetricPadding,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> RSAPrivateNumbers:\n        \"\"\"\n        Returns an RSAPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nRSAPrivateKeyWithSerialization = RSAPrivateKey\nRSAPrivateKey.register(rust_openssl.rsa.RSAPrivateKey)\n\n\nclass RSAPublicKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def encrypt(self, plaintext: bytes, padding: AsymmetricPadding) -> bytes:\n        \"\"\"\n        Encrypts the given plaintext.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the public modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> RSAPublicNumbers:\n        \"\"\"\n        Returns an RSAPublicNumbers\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        padding: AsymmetricPadding,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def recover_data_from_signature(\n        self,\n        signature: bytes,\n        padding: AsymmetricPadding,\n        algorithm: hashes.HashAlgorithm | None,\n    ) -> bytes:\n        \"\"\"\n        Recovers the original data from the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nRSAPublicKeyWithSerialization = RSAPublicKey\nRSAPublicKey.register(rust_openssl.rsa.RSAPublicKey)\n\nRSAPrivateNumbers = rust_openssl.rsa.RSAPrivateNumbers\nRSAPublicNumbers = rust_openssl.rsa.RSAPublicNumbers\n\n\ndef generate_private_key(\n    public_exponent: int,\n    key_size: int,\n    backend: typing.Any = None,\n) -> RSAPrivateKey:\n    _verify_rsa_parameters(public_exponent, key_size)\n    return rust_openssl.rsa.generate_private_key(public_exponent, key_size)\n\n\ndef _verify_rsa_parameters(public_exponent: int, key_size: int) -> None:\n    if public_exponent not in (3, 65537):\n        raise ValueError(\n            \"public_exponent must be either 3 (for legacy compatibility) or \"\n            \"65537. Almost everyone should choose 65537 here!\"\n        )\n\n    if key_size < 1024:\n        raise ValueError(\"key_size must be at least 1024-bits.\")\n\n\ndef _modinv(e: int, m: int) -> int:\n    \"\"\"\n    Modular Multiplicative Inverse. Returns x such that: (x*e) mod m == 1\n    \"\"\"\n    x1, x2 = 1, 0\n    a, b = e, m\n    while b > 0:\n        q, r = divmod(a, b)\n        xn = x1 - q * x2\n        a, b, x1, x2 = b, r, x2, xn\n    return x1 % m\n\n\ndef rsa_crt_iqmp(p: int, q: int) -> int:\n    \"\"\"\n    Compute the CRT (q ** -1) % p value from RSA primes p and q.\n    \"\"\"\n    return _modinv(q, p)\n\n\ndef rsa_crt_dmp1(private_exponent: int, p: int) -> int:\n    \"\"\"\n    Compute the CRT private_exponent % (p - 1) value from the RSA\n    private_exponent (d) and p.\n    \"\"\"\n    return private_exponent % (p - 1)\n\n\ndef rsa_crt_dmq1(private_exponent: int, q: int) -> int:\n    \"\"\"\n    Compute the CRT private_exponent % (q - 1) value from the RSA\n    private_exponent (d) and q.\n    \"\"\"\n    return private_exponent % (q - 1)\n\n\n# Controls the number of iterations rsa_recover_prime_factors will perform\n# to obtain the prime factors. Each iteration increments by 2 so the actual\n# maximum attempts is half this number.\n_MAX_RECOVERY_ATTEMPTS = 1000\n\n\ndef rsa_recover_prime_factors(n: int, e: int, d: int) -> tuple[int, int]:\n    \"\"\"\n    Compute factors p and q from the private exponent d. We assume that n has\n    no more than two factors. This function is adapted from code in PyCrypto.\n    \"\"\"\n    # See 8.2.2(i) in Handbook of Applied Cryptography.\n    ktot = d * e - 1\n    # The quantity d*e-1 is a multiple of phi(n), even,\n    # and can be represented as t*2^s.\n    t = ktot\n    while t % 2 == 0:\n        t = t // 2\n    # Cycle through all multiplicative inverses in Zn.\n    # The algorithm is non-deterministic, but there is a 50% chance\n    # any candidate a leads to successful factoring.\n    # See \"Digitalized Signatures and Public Key Functions as Intractable\n    # as Factorization\", M. Rabin, 1979\n    spotted = False\n    a = 2\n    while not spotted and a < _MAX_RECOVERY_ATTEMPTS:\n        k = t\n        # Cycle through all values a^{t*2^i}=a^k\n        while k < ktot:\n            cand = pow(a, k, n)\n            # Check if a^k is a non-trivial root of unity (mod n)\n            if cand != 1 and cand != (n - 1) and pow(cand, 2, n) == 1:\n                # We have found a number such that (cand-1)(cand+1)=0 (mod n).\n                # Either of the terms divides n.\n                p = gcd(cand + 1, n)\n                spotted = True\n                break\n            k *= 2\n        # This value was not any good... let's try another!\n        a += 2\n    if not spotted:\n        raise ValueError(\"Unable to compute factors p and q from exponent d.\")\n    # Found !\n    q, r = divmod(n, p)\n    assert r == 0\n    p, q = sorted((p, q), reverse=True)\n    return (p, q)\n", "src/cryptography/hazmat/primitives/asymmetric/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/primitives/asymmetric/x448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass X448PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> X448PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    X448PublicKey.register(rust_openssl.x448.X448PublicKey)\n\n\nclass X448PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> X448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> X448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> X448PublicKey:\n        \"\"\"\n        Returns the public key associated with this private key\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: X448PublicKey) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided peer's public key.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    X448PrivateKey.register(rust_openssl.x448.X448PrivateKey)\n", "src/cryptography/hazmat/primitives/serialization/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\nload_pem_private_key = rust_openssl.keys.load_pem_private_key\nload_der_private_key = rust_openssl.keys.load_der_private_key\n\nload_pem_public_key = rust_openssl.keys.load_pem_public_key\nload_der_public_key = rust_openssl.keys.load_der_public_key\n\nload_pem_parameters = rust_openssl.dh.from_pem_parameters\nload_der_parameters = rust_openssl.dh.from_der_parameters\n", "src/cryptography/hazmat/primitives/serialization/pkcs12.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import x509\nfrom cryptography.hazmat.bindings._rust import pkcs12 as rust_pkcs12\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives._serialization import PBES as PBES\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes\n\n__all__ = [\n    \"PBES\",\n    \"PKCS12Certificate\",\n    \"PKCS12KeyAndCertificates\",\n    \"PKCS12PrivateKeyTypes\",\n    \"load_key_and_certificates\",\n    \"load_pkcs12\",\n    \"serialize_key_and_certificates\",\n]\n\nPKCS12PrivateKeyTypes = typing.Union[\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n]\n\n\nPKCS12Certificate = rust_pkcs12.PKCS12Certificate\n\n\nclass PKCS12KeyAndCertificates:\n    def __init__(\n        self,\n        key: PrivateKeyTypes | None,\n        cert: PKCS12Certificate | None,\n        additional_certs: list[PKCS12Certificate],\n    ):\n        if key is not None and not isinstance(\n            key,\n            (\n                rsa.RSAPrivateKey,\n                dsa.DSAPrivateKey,\n                ec.EllipticCurvePrivateKey,\n                ed25519.Ed25519PrivateKey,\n                ed448.Ed448PrivateKey,\n            ),\n        ):\n            raise TypeError(\n                \"Key must be RSA, DSA, EllipticCurve, ED25519, or ED448\"\n                \" private key, or None.\"\n            )\n        if cert is not None and not isinstance(cert, PKCS12Certificate):\n            raise TypeError(\"cert must be a PKCS12Certificate object or None\")\n        if not all(\n            isinstance(add_cert, PKCS12Certificate)\n            for add_cert in additional_certs\n        ):\n            raise TypeError(\n                \"all values in additional_certs must be PKCS12Certificate\"\n                \" objects\"\n            )\n        self._key = key\n        self._cert = cert\n        self._additional_certs = additional_certs\n\n    @property\n    def key(self) -> PrivateKeyTypes | None:\n        return self._key\n\n    @property\n    def cert(self) -> PKCS12Certificate | None:\n        return self._cert\n\n    @property\n    def additional_certs(self) -> list[PKCS12Certificate]:\n        return self._additional_certs\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PKCS12KeyAndCertificates):\n            return NotImplemented\n\n        return (\n            self.key == other.key\n            and self.cert == other.cert\n            and self.additional_certs == other.additional_certs\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.key, self.cert, tuple(self.additional_certs)))\n\n    def __repr__(self) -> str:\n        fmt = (\n            \"<PKCS12KeyAndCertificates(key={}, cert={}, additional_certs={})>\"\n        )\n        return fmt.format(self.key, self.cert, self.additional_certs)\n\n\nload_key_and_certificates = rust_pkcs12.load_key_and_certificates\nload_pkcs12 = rust_pkcs12.load_pkcs12\n\n\n_PKCS12CATypes = typing.Union[\n    x509.Certificate,\n    PKCS12Certificate,\n]\n\n\ndef serialize_key_and_certificates(\n    name: bytes | None,\n    key: PKCS12PrivateKeyTypes | None,\n    cert: x509.Certificate | None,\n    cas: typing.Iterable[_PKCS12CATypes] | None,\n    encryption_algorithm: serialization.KeySerializationEncryption,\n) -> bytes:\n    if key is not None and not isinstance(\n        key,\n        (\n            rsa.RSAPrivateKey,\n            dsa.DSAPrivateKey,\n            ec.EllipticCurvePrivateKey,\n            ed25519.Ed25519PrivateKey,\n            ed448.Ed448PrivateKey,\n        ),\n    ):\n        raise TypeError(\n            \"Key must be RSA, DSA, EllipticCurve, ED25519, or ED448\"\n            \" private key, or None.\"\n        )\n    if cert is not None and not isinstance(cert, x509.Certificate):\n        raise TypeError(\"cert must be a certificate or None\")\n\n    if cas is not None:\n        cas = list(cas)\n        if not all(\n            isinstance(\n                val,\n                (\n                    x509.Certificate,\n                    PKCS12Certificate,\n                ),\n            )\n            for val in cas\n        ):\n            raise TypeError(\"all values in cas must be certificates\")\n\n    if not isinstance(\n        encryption_algorithm, serialization.KeySerializationEncryption\n    ):\n        raise TypeError(\n            \"Key encryption algorithm must be a \"\n            \"KeySerializationEncryption instance\"\n        )\n\n    if key is None and cert is None and not cas:\n        raise ValueError(\"You must supply at least one of key, cert, or cas\")\n\n    if isinstance(encryption_algorithm, serialization.NoEncryption):\n        return rust_pkcs12.serialize_key_and_certificates(\n            name, key, cert, cas, encryption_algorithm\n        )\n\n    from cryptography.hazmat.backends.openssl.backend import backend\n\n    return backend.serialize_key_and_certificates_to_pkcs12(\n        name, key, cert, cas, encryption_algorithm\n    )\n", "src/cryptography/hazmat/primitives/serialization/ssh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport binascii\nimport enum\nimport os\nimport re\nimport typing\nimport warnings\nfrom base64 import encodebytes as _base64_encode\nfrom dataclasses import dataclass\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed25519,\n    padding,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\nfrom cryptography.hazmat.primitives.ciphers import (\n    AEADDecryptionContext,\n    Cipher,\n    algorithms,\n    modes,\n)\nfrom cryptography.hazmat.primitives.serialization import (\n    Encoding,\n    KeySerializationEncryption,\n    NoEncryption,\n    PrivateFormat,\n    PublicFormat,\n    _KeySerializationEncryption,\n)\n\ntry:\n    from bcrypt import kdf as _bcrypt_kdf\n\n    _bcrypt_supported = True\nexcept ImportError:\n    _bcrypt_supported = False\n\n    def _bcrypt_kdf(\n        password: bytes,\n        salt: bytes,\n        desired_key_bytes: int,\n        rounds: int,\n        ignore_few_rounds: bool = False,\n    ) -> bytes:\n        raise UnsupportedAlgorithm(\"Need bcrypt module\")\n\n\n_SSH_ED25519 = b\"ssh-ed25519\"\n_SSH_RSA = b\"ssh-rsa\"\n_SSH_DSA = b\"ssh-dss\"\n_ECDSA_NISTP256 = b\"ecdsa-sha2-nistp256\"\n_ECDSA_NISTP384 = b\"ecdsa-sha2-nistp384\"\n_ECDSA_NISTP521 = b\"ecdsa-sha2-nistp521\"\n_CERT_SUFFIX = b\"-cert-v01@openssh.com\"\n\n# U2F application string suffixed pubkey\n_SK_SSH_ED25519 = b\"sk-ssh-ed25519@openssh.com\"\n_SK_SSH_ECDSA_NISTP256 = b\"sk-ecdsa-sha2-nistp256@openssh.com\"\n\n# These are not key types, only algorithms, so they cannot appear\n# as a public key type\n_SSH_RSA_SHA256 = b\"rsa-sha2-256\"\n_SSH_RSA_SHA512 = b\"rsa-sha2-512\"\n\n_SSH_PUBKEY_RC = re.compile(rb\"\\A(\\S+)[ \\t]+(\\S+)\")\n_SK_MAGIC = b\"openssh-key-v1\\0\"\n_SK_START = b\"-----BEGIN OPENSSH PRIVATE KEY-----\"\n_SK_END = b\"-----END OPENSSH PRIVATE KEY-----\"\n_BCRYPT = b\"bcrypt\"\n_NONE = b\"none\"\n_DEFAULT_CIPHER = b\"aes256-ctr\"\n_DEFAULT_ROUNDS = 16\n\n# re is only way to work on bytes-like data\n_PEM_RC = re.compile(_SK_START + b\"(.*?)\" + _SK_END, re.DOTALL)\n\n# padding for max blocksize\n_PADDING = memoryview(bytearray(range(1, 1 + 16)))\n\n\n@dataclass\nclass _SSHCipher:\n    alg: type[algorithms.AES]\n    key_len: int\n    mode: type[modes.CTR] | type[modes.CBC] | type[modes.GCM]\n    block_len: int\n    iv_len: int\n    tag_len: int | None\n    is_aead: bool\n\n\n# ciphers that are actually used in key wrapping\n_SSH_CIPHERS: dict[bytes, _SSHCipher] = {\n    b\"aes256-ctr\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.CTR,\n        block_len=16,\n        iv_len=16,\n        tag_len=None,\n        is_aead=False,\n    ),\n    b\"aes256-cbc\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.CBC,\n        block_len=16,\n        iv_len=16,\n        tag_len=None,\n        is_aead=False,\n    ),\n    b\"aes256-gcm@openssh.com\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.GCM,\n        block_len=16,\n        iv_len=12,\n        tag_len=16,\n        is_aead=True,\n    ),\n}\n\n# map local curve name to key type\n_ECDSA_KEY_TYPE = {\n    \"secp256r1\": _ECDSA_NISTP256,\n    \"secp384r1\": _ECDSA_NISTP384,\n    \"secp521r1\": _ECDSA_NISTP521,\n}\n\n\ndef _get_ssh_key_type(key: SSHPrivateKeyTypes | SSHPublicKeyTypes) -> bytes:\n    if isinstance(key, ec.EllipticCurvePrivateKey):\n        key_type = _ecdsa_key_type(key.public_key())\n    elif isinstance(key, ec.EllipticCurvePublicKey):\n        key_type = _ecdsa_key_type(key)\n    elif isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):\n        key_type = _SSH_RSA\n    elif isinstance(key, (dsa.DSAPrivateKey, dsa.DSAPublicKey)):\n        key_type = _SSH_DSA\n    elif isinstance(\n        key, (ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey)\n    ):\n        key_type = _SSH_ED25519\n    else:\n        raise ValueError(\"Unsupported key type\")\n\n    return key_type\n\n\ndef _ecdsa_key_type(public_key: ec.EllipticCurvePublicKey) -> bytes:\n    \"\"\"Return SSH key_type and curve_name for private key.\"\"\"\n    curve = public_key.curve\n    if curve.name not in _ECDSA_KEY_TYPE:\n        raise ValueError(\n            f\"Unsupported curve for ssh private key: {curve.name!r}\"\n        )\n    return _ECDSA_KEY_TYPE[curve.name]\n\n\ndef _ssh_pem_encode(\n    data: bytes,\n    prefix: bytes = _SK_START + b\"\\n\",\n    suffix: bytes = _SK_END + b\"\\n\",\n) -> bytes:\n    return b\"\".join([prefix, _base64_encode(data), suffix])\n\n\ndef _check_block_size(data: bytes, block_len: int) -> None:\n    \"\"\"Require data to be full blocks\"\"\"\n    if not data or len(data) % block_len != 0:\n        raise ValueError(\"Corrupt data: missing padding\")\n\n\ndef _check_empty(data: bytes) -> None:\n    \"\"\"All data should have been parsed.\"\"\"\n    if data:\n        raise ValueError(\"Corrupt data: unparsed data\")\n\n\ndef _init_cipher(\n    ciphername: bytes,\n    password: bytes | None,\n    salt: bytes,\n    rounds: int,\n) -> Cipher[modes.CBC | modes.CTR | modes.GCM]:\n    \"\"\"Generate key + iv and return cipher.\"\"\"\n    if not password:\n        raise ValueError(\"Key is password-protected.\")\n\n    ciph = _SSH_CIPHERS[ciphername]\n    seed = _bcrypt_kdf(\n        password, salt, ciph.key_len + ciph.iv_len, rounds, True\n    )\n    return Cipher(\n        ciph.alg(seed[: ciph.key_len]),\n        ciph.mode(seed[ciph.key_len :]),\n    )\n\n\ndef _get_u32(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Uint32\"\"\"\n    if len(data) < 4:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(data[:4], byteorder=\"big\"), data[4:]\n\n\ndef _get_u64(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Uint64\"\"\"\n    if len(data) < 8:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(data[:8], byteorder=\"big\"), data[8:]\n\n\ndef _get_sshstr(data: memoryview) -> tuple[memoryview, memoryview]:\n    \"\"\"Bytes with u32 length prefix\"\"\"\n    n, data = _get_u32(data)\n    if n > len(data):\n        raise ValueError(\"Invalid data\")\n    return data[:n], data[n:]\n\n\ndef _get_mpint(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Big integer.\"\"\"\n    val, data = _get_sshstr(data)\n    if val and val[0] > 0x7F:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(val, \"big\"), data\n\n\ndef _to_mpint(val: int) -> bytes:\n    \"\"\"Storage format for signed bigint.\"\"\"\n    if val < 0:\n        raise ValueError(\"negative mpint not allowed\")\n    if not val:\n        return b\"\"\n    nbytes = (val.bit_length() + 8) // 8\n    return utils.int_to_bytes(val, nbytes)\n\n\nclass _FragList:\n    \"\"\"Build recursive structure without data copy.\"\"\"\n\n    flist: list[bytes]\n\n    def __init__(self, init: list[bytes] | None = None) -> None:\n        self.flist = []\n        if init:\n            self.flist.extend(init)\n\n    def put_raw(self, val: bytes) -> None:\n        \"\"\"Add plain bytes\"\"\"\n        self.flist.append(val)\n\n    def put_u32(self, val: int) -> None:\n        \"\"\"Big-endian uint32\"\"\"\n        self.flist.append(val.to_bytes(length=4, byteorder=\"big\"))\n\n    def put_u64(self, val: int) -> None:\n        \"\"\"Big-endian uint64\"\"\"\n        self.flist.append(val.to_bytes(length=8, byteorder=\"big\"))\n\n    def put_sshstr(self, val: bytes | _FragList) -> None:\n        \"\"\"Bytes prefixed with u32 length\"\"\"\n        if isinstance(val, (bytes, memoryview, bytearray)):\n            self.put_u32(len(val))\n            self.flist.append(val)\n        else:\n            self.put_u32(val.size())\n            self.flist.extend(val.flist)\n\n    def put_mpint(self, val: int) -> None:\n        \"\"\"Big-endian bigint prefixed with u32 length\"\"\"\n        self.put_sshstr(_to_mpint(val))\n\n    def size(self) -> int:\n        \"\"\"Current number of bytes\"\"\"\n        return sum(map(len, self.flist))\n\n    def render(self, dstbuf: memoryview, pos: int = 0) -> int:\n        \"\"\"Write into bytearray\"\"\"\n        for frag in self.flist:\n            flen = len(frag)\n            start, pos = pos, pos + flen\n            dstbuf[start:pos] = frag\n        return pos\n\n    def tobytes(self) -> bytes:\n        \"\"\"Return as bytes\"\"\"\n        buf = memoryview(bytearray(self.size()))\n        self.render(buf)\n        return buf.tobytes()\n\n\nclass _SSHFormatRSA:\n    \"\"\"Format for RSA keys.\n\n    Public:\n        mpint e, n\n    Private:\n        mpint n, e, d, iqmp, p, q\n    \"\"\"\n\n    def get_public(self, data: memoryview):\n        \"\"\"RSA public fields\"\"\"\n        e, data = _get_mpint(data)\n        n, data = _get_mpint(data)\n        return (e, n), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[rsa.RSAPublicKey, memoryview]:\n        \"\"\"Make RSA public key from data.\"\"\"\n        (e, n), data = self.get_public(data)\n        public_numbers = rsa.RSAPublicNumbers(e, n)\n        public_key = public_numbers.public_key()\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[rsa.RSAPrivateKey, memoryview]:\n        \"\"\"Make RSA private key from data.\"\"\"\n        n, data = _get_mpint(data)\n        e, data = _get_mpint(data)\n        d, data = _get_mpint(data)\n        iqmp, data = _get_mpint(data)\n        p, data = _get_mpint(data)\n        q, data = _get_mpint(data)\n\n        if (e, n) != pubfields:\n            raise ValueError(\"Corrupt data: rsa field mismatch\")\n        dmp1 = rsa.rsa_crt_dmp1(d, p)\n        dmq1 = rsa.rsa_crt_dmq1(d, q)\n        public_numbers = rsa.RSAPublicNumbers(e, n)\n        private_numbers = rsa.RSAPrivateNumbers(\n            p, q, d, dmp1, dmq1, iqmp, public_numbers\n        )\n        private_key = private_numbers.private_key()\n        return private_key, data\n\n    def encode_public(\n        self, public_key: rsa.RSAPublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write RSA public key\"\"\"\n        pubn = public_key.public_numbers()\n        f_pub.put_mpint(pubn.e)\n        f_pub.put_mpint(pubn.n)\n\n    def encode_private(\n        self, private_key: rsa.RSAPrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write RSA private key\"\"\"\n        private_numbers = private_key.private_numbers()\n        public_numbers = private_numbers.public_numbers\n\n        f_priv.put_mpint(public_numbers.n)\n        f_priv.put_mpint(public_numbers.e)\n\n        f_priv.put_mpint(private_numbers.d)\n        f_priv.put_mpint(private_numbers.iqmp)\n        f_priv.put_mpint(private_numbers.p)\n        f_priv.put_mpint(private_numbers.q)\n\n\nclass _SSHFormatDSA:\n    \"\"\"Format for DSA keys.\n\n    Public:\n        mpint p, q, g, y\n    Private:\n        mpint p, q, g, y, x\n    \"\"\"\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"DSA public fields\"\"\"\n        p, data = _get_mpint(data)\n        q, data = _get_mpint(data)\n        g, data = _get_mpint(data)\n        y, data = _get_mpint(data)\n        return (p, q, g, y), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[dsa.DSAPublicKey, memoryview]:\n        \"\"\"Make DSA public key from data.\"\"\"\n        (p, q, g, y), data = self.get_public(data)\n        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)\n        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)\n        self._validate(public_numbers)\n        public_key = public_numbers.public_key()\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[dsa.DSAPrivateKey, memoryview]:\n        \"\"\"Make DSA private key from data.\"\"\"\n        (p, q, g, y), data = self.get_public(data)\n        x, data = _get_mpint(data)\n\n        if (p, q, g, y) != pubfields:\n            raise ValueError(\"Corrupt data: dsa field mismatch\")\n        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)\n        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)\n        self._validate(public_numbers)\n        private_numbers = dsa.DSAPrivateNumbers(x, public_numbers)\n        private_key = private_numbers.private_key()\n        return private_key, data\n\n    def encode_public(\n        self, public_key: dsa.DSAPublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write DSA public key\"\"\"\n        public_numbers = public_key.public_numbers()\n        parameter_numbers = public_numbers.parameter_numbers\n        self._validate(public_numbers)\n\n        f_pub.put_mpint(parameter_numbers.p)\n        f_pub.put_mpint(parameter_numbers.q)\n        f_pub.put_mpint(parameter_numbers.g)\n        f_pub.put_mpint(public_numbers.y)\n\n    def encode_private(\n        self, private_key: dsa.DSAPrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write DSA private key\"\"\"\n        self.encode_public(private_key.public_key(), f_priv)\n        f_priv.put_mpint(private_key.private_numbers().x)\n\n    def _validate(self, public_numbers: dsa.DSAPublicNumbers) -> None:\n        parameter_numbers = public_numbers.parameter_numbers\n        if parameter_numbers.p.bit_length() != 1024:\n            raise ValueError(\"SSH supports only 1024 bit DSA keys\")\n\n\nclass _SSHFormatECDSA:\n    \"\"\"Format for ECDSA keys.\n\n    Public:\n        str curve\n        bytes point\n    Private:\n        str curve\n        bytes point\n        mpint secret\n    \"\"\"\n\n    def __init__(self, ssh_curve_name: bytes, curve: ec.EllipticCurve):\n        self.ssh_curve_name = ssh_curve_name\n        self.curve = curve\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"ECDSA public fields\"\"\"\n        curve, data = _get_sshstr(data)\n        point, data = _get_sshstr(data)\n        if curve != self.ssh_curve_name:\n            raise ValueError(\"Curve name mismatch\")\n        if point[0] != 4:\n            raise NotImplementedError(\"Need uncompressed point\")\n        return (curve, point), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ec.EllipticCurvePublicKey, memoryview]:\n        \"\"\"Make ECDSA public key from data.\"\"\"\n        (_, point), data = self.get_public(data)\n        public_key = ec.EllipticCurvePublicKey.from_encoded_point(\n            self.curve, point.tobytes()\n        )\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[ec.EllipticCurvePrivateKey, memoryview]:\n        \"\"\"Make ECDSA private key from data.\"\"\"\n        (curve_name, point), data = self.get_public(data)\n        secret, data = _get_mpint(data)\n\n        if (curve_name, point) != pubfields:\n            raise ValueError(\"Corrupt data: ecdsa field mismatch\")\n        private_key = ec.derive_private_key(secret, self.curve)\n        return private_key, data\n\n    def encode_public(\n        self, public_key: ec.EllipticCurvePublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write ECDSA public key\"\"\"\n        point = public_key.public_bytes(\n            Encoding.X962, PublicFormat.UncompressedPoint\n        )\n        f_pub.put_sshstr(self.ssh_curve_name)\n        f_pub.put_sshstr(point)\n\n    def encode_private(\n        self, private_key: ec.EllipticCurvePrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write ECDSA private key\"\"\"\n        public_key = private_key.public_key()\n        private_numbers = private_key.private_numbers()\n\n        self.encode_public(public_key, f_priv)\n        f_priv.put_mpint(private_numbers.private_value)\n\n\nclass _SSHFormatEd25519:\n    \"\"\"Format for Ed25519 keys.\n\n    Public:\n        bytes point\n    Private:\n        bytes point\n        bytes secret_and_point\n    \"\"\"\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"Ed25519 public fields\"\"\"\n        point, data = _get_sshstr(data)\n        return (point,), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ed25519.Ed25519PublicKey, memoryview]:\n        \"\"\"Make Ed25519 public key from data.\"\"\"\n        (point,), data = self.get_public(data)\n        public_key = ed25519.Ed25519PublicKey.from_public_bytes(\n            point.tobytes()\n        )\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[ed25519.Ed25519PrivateKey, memoryview]:\n        \"\"\"Make Ed25519 private key from data.\"\"\"\n        (point,), data = self.get_public(data)\n        keypair, data = _get_sshstr(data)\n\n        secret = keypair[:32]\n        point2 = keypair[32:]\n        if point != point2 or (point,) != pubfields:\n            raise ValueError(\"Corrupt data: ed25519 field mismatch\")\n        private_key = ed25519.Ed25519PrivateKey.from_private_bytes(secret)\n        return private_key, data\n\n    def encode_public(\n        self, public_key: ed25519.Ed25519PublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write Ed25519 public key\"\"\"\n        raw_public_key = public_key.public_bytes(\n            Encoding.Raw, PublicFormat.Raw\n        )\n        f_pub.put_sshstr(raw_public_key)\n\n    def encode_private(\n        self, private_key: ed25519.Ed25519PrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write Ed25519 private key\"\"\"\n        public_key = private_key.public_key()\n        raw_private_key = private_key.private_bytes(\n            Encoding.Raw, PrivateFormat.Raw, NoEncryption()\n        )\n        raw_public_key = public_key.public_bytes(\n            Encoding.Raw, PublicFormat.Raw\n        )\n        f_keypair = _FragList([raw_private_key, raw_public_key])\n\n        self.encode_public(public_key, f_priv)\n        f_priv.put_sshstr(f_keypair)\n\n\ndef load_application(data) -> tuple[memoryview, memoryview]:\n    \"\"\"\n    U2F application strings\n    \"\"\"\n    application, data = _get_sshstr(data)\n    if not application.tobytes().startswith(b\"ssh:\"):\n        raise ValueError(\n            \"U2F application string does not start with b'ssh:' \"\n            f\"({application})\"\n        )\n    return application, data\n\n\nclass _SSHFormatSKEd25519:\n    \"\"\"\n    The format of a sk-ssh-ed25519@openssh.com public key is:\n\n        string\t\t\"sk-ssh-ed25519@openssh.com\"\n        string\t\tpublic key\n        string\t\tapplication (user-specified, but typically \"ssh:\")\n    \"\"\"\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ed25519.Ed25519PublicKey, memoryview]:\n        \"\"\"Make Ed25519 public key from data.\"\"\"\n        public_key, data = _lookup_kformat(_SSH_ED25519).load_public(data)\n        _, data = load_application(data)\n        return public_key, data\n\n\nclass _SSHFormatSKECDSA:\n    \"\"\"\n    The format of a sk-ecdsa-sha2-nistp256@openssh.com public key is:\n\n        string\t\t\"sk-ecdsa-sha2-nistp256@openssh.com\"\n        string\t\tcurve name\n        ec_point\tQ\n        string\t\tapplication (user-specified, but typically \"ssh:\")\n    \"\"\"\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ec.EllipticCurvePublicKey, memoryview]:\n        \"\"\"Make ECDSA public key from data.\"\"\"\n        public_key, data = _lookup_kformat(_ECDSA_NISTP256).load_public(data)\n        _, data = load_application(data)\n        return public_key, data\n\n\n_KEY_FORMATS = {\n    _SSH_RSA: _SSHFormatRSA(),\n    _SSH_DSA: _SSHFormatDSA(),\n    _SSH_ED25519: _SSHFormatEd25519(),\n    _ECDSA_NISTP256: _SSHFormatECDSA(b\"nistp256\", ec.SECP256R1()),\n    _ECDSA_NISTP384: _SSHFormatECDSA(b\"nistp384\", ec.SECP384R1()),\n    _ECDSA_NISTP521: _SSHFormatECDSA(b\"nistp521\", ec.SECP521R1()),\n    _SK_SSH_ED25519: _SSHFormatSKEd25519(),\n    _SK_SSH_ECDSA_NISTP256: _SSHFormatSKECDSA(),\n}\n\n\ndef _lookup_kformat(key_type: bytes):\n    \"\"\"Return valid format or throw error\"\"\"\n    if not isinstance(key_type, bytes):\n        key_type = memoryview(key_type).tobytes()\n    if key_type in _KEY_FORMATS:\n        return _KEY_FORMATS[key_type]\n    raise UnsupportedAlgorithm(f\"Unsupported key type: {key_type!r}\")\n\n\nSSHPrivateKeyTypes = typing.Union[\n    ec.EllipticCurvePrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ed25519.Ed25519PrivateKey,\n]\n\n\ndef load_ssh_private_key(\n    data: bytes,\n    password: bytes | None,\n    backend: typing.Any = None,\n) -> SSHPrivateKeyTypes:\n    \"\"\"Load private key from OpenSSH custom encoding.\"\"\"\n    utils._check_byteslike(\"data\", data)\n    if password is not None:\n        utils._check_bytes(\"password\", password)\n\n    m = _PEM_RC.search(data)\n    if not m:\n        raise ValueError(\"Not OpenSSH private key format\")\n    p1 = m.start(1)\n    p2 = m.end(1)\n    data = binascii.a2b_base64(memoryview(data)[p1:p2])\n    if not data.startswith(_SK_MAGIC):\n        raise ValueError(\"Not OpenSSH private key format\")\n    data = memoryview(data)[len(_SK_MAGIC) :]\n\n    # parse header\n    ciphername, data = _get_sshstr(data)\n    kdfname, data = _get_sshstr(data)\n    kdfoptions, data = _get_sshstr(data)\n    nkeys, data = _get_u32(data)\n    if nkeys != 1:\n        raise ValueError(\"Only one key supported\")\n\n    # load public key data\n    pubdata, data = _get_sshstr(data)\n    pub_key_type, pubdata = _get_sshstr(pubdata)\n    kformat = _lookup_kformat(pub_key_type)\n    pubfields, pubdata = kformat.get_public(pubdata)\n    _check_empty(pubdata)\n\n    if (ciphername, kdfname) != (_NONE, _NONE):\n        ciphername_bytes = ciphername.tobytes()\n        if ciphername_bytes not in _SSH_CIPHERS:\n            raise UnsupportedAlgorithm(\n                f\"Unsupported cipher: {ciphername_bytes!r}\"\n            )\n        if kdfname != _BCRYPT:\n            raise UnsupportedAlgorithm(f\"Unsupported KDF: {kdfname!r}\")\n        blklen = _SSH_CIPHERS[ciphername_bytes].block_len\n        tag_len = _SSH_CIPHERS[ciphername_bytes].tag_len\n        # load secret data\n        edata, data = _get_sshstr(data)\n        # see https://bugzilla.mindrot.org/show_bug.cgi?id=3553 for\n        # information about how OpenSSH handles AEAD tags\n        if _SSH_CIPHERS[ciphername_bytes].is_aead:\n            tag = bytes(data)\n            if len(tag) != tag_len:\n                raise ValueError(\"Corrupt data: invalid tag length for cipher\")\n        else:\n            _check_empty(data)\n        _check_block_size(edata, blklen)\n        salt, kbuf = _get_sshstr(kdfoptions)\n        rounds, kbuf = _get_u32(kbuf)\n        _check_empty(kbuf)\n        ciph = _init_cipher(ciphername_bytes, password, salt.tobytes(), rounds)\n        dec = ciph.decryptor()\n        edata = memoryview(dec.update(edata))\n        if _SSH_CIPHERS[ciphername_bytes].is_aead:\n            assert isinstance(dec, AEADDecryptionContext)\n            _check_empty(dec.finalize_with_tag(tag))\n        else:\n            # _check_block_size requires data to be a full block so there\n            # should be no output from finalize\n            _check_empty(dec.finalize())\n    else:\n        # load secret data\n        edata, data = _get_sshstr(data)\n        _check_empty(data)\n        blklen = 8\n        _check_block_size(edata, blklen)\n    ck1, edata = _get_u32(edata)\n    ck2, edata = _get_u32(edata)\n    if ck1 != ck2:\n        raise ValueError(\"Corrupt data: broken checksum\")\n\n    # load per-key struct\n    key_type, edata = _get_sshstr(edata)\n    if key_type != pub_key_type:\n        raise ValueError(\"Corrupt data: key type mismatch\")\n    private_key, edata = kformat.load_private(edata, pubfields)\n    # We don't use the comment\n    _, edata = _get_sshstr(edata)\n\n    # yes, SSH does padding check *after* all other parsing is done.\n    # need to follow as it writes zero-byte padding too.\n    if edata != _PADDING[: len(edata)]:\n        raise ValueError(\"Corrupt data: invalid padding\")\n\n    if isinstance(private_key, dsa.DSAPrivateKey):\n        warnings.warn(\n            \"SSH DSA keys are deprecated and will be removed in a future \"\n            \"release.\",\n            utils.DeprecatedIn40,\n            stacklevel=2,\n        )\n\n    return private_key\n\n\ndef _serialize_ssh_private_key(\n    private_key: SSHPrivateKeyTypes,\n    password: bytes,\n    encryption_algorithm: KeySerializationEncryption,\n) -> bytes:\n    \"\"\"Serialize private key with OpenSSH custom encoding.\"\"\"\n    utils._check_bytes(\"password\", password)\n    if isinstance(private_key, dsa.DSAPrivateKey):\n        warnings.warn(\n            \"SSH DSA key support is deprecated and will be \"\n            \"removed in a future release\",\n            utils.DeprecatedIn40,\n            stacklevel=4,\n        )\n\n    key_type = _get_ssh_key_type(private_key)\n    kformat = _lookup_kformat(key_type)\n\n    # setup parameters\n    f_kdfoptions = _FragList()\n    if password:\n        ciphername = _DEFAULT_CIPHER\n        blklen = _SSH_CIPHERS[ciphername].block_len\n        kdfname = _BCRYPT\n        rounds = _DEFAULT_ROUNDS\n        if (\n            isinstance(encryption_algorithm, _KeySerializationEncryption)\n            and encryption_algorithm._kdf_rounds is not None\n        ):\n            rounds = encryption_algorithm._kdf_rounds\n        salt = os.urandom(16)\n        f_kdfoptions.put_sshstr(salt)\n        f_kdfoptions.put_u32(rounds)\n        ciph = _init_cipher(ciphername, password, salt, rounds)\n    else:\n        ciphername = kdfname = _NONE\n        blklen = 8\n        ciph = None\n    nkeys = 1\n    checkval = os.urandom(4)\n    comment = b\"\"\n\n    # encode public and private parts together\n    f_public_key = _FragList()\n    f_public_key.put_sshstr(key_type)\n    kformat.encode_public(private_key.public_key(), f_public_key)\n\n    f_secrets = _FragList([checkval, checkval])\n    f_secrets.put_sshstr(key_type)\n    kformat.encode_private(private_key, f_secrets)\n    f_secrets.put_sshstr(comment)\n    f_secrets.put_raw(_PADDING[: blklen - (f_secrets.size() % blklen)])\n\n    # top-level structure\n    f_main = _FragList()\n    f_main.put_raw(_SK_MAGIC)\n    f_main.put_sshstr(ciphername)\n    f_main.put_sshstr(kdfname)\n    f_main.put_sshstr(f_kdfoptions)\n    f_main.put_u32(nkeys)\n    f_main.put_sshstr(f_public_key)\n    f_main.put_sshstr(f_secrets)\n\n    # copy result info bytearray\n    slen = f_secrets.size()\n    mlen = f_main.size()\n    buf = memoryview(bytearray(mlen + blklen))\n    f_main.render(buf)\n    ofs = mlen - slen\n\n    # encrypt in-place\n    if ciph is not None:\n        ciph.encryptor().update_into(buf[ofs:mlen], buf[ofs:])\n\n    return _ssh_pem_encode(buf[:mlen])\n\n\nSSHPublicKeyTypes = typing.Union[\n    ec.EllipticCurvePublicKey,\n    rsa.RSAPublicKey,\n    dsa.DSAPublicKey,\n    ed25519.Ed25519PublicKey,\n]\n\nSSHCertPublicKeyTypes = typing.Union[\n    ec.EllipticCurvePublicKey,\n    rsa.RSAPublicKey,\n    ed25519.Ed25519PublicKey,\n]\n\n\nclass SSHCertificateType(enum.Enum):\n    USER = 1\n    HOST = 2\n\n\nclass SSHCertificate:\n    def __init__(\n        self,\n        _nonce: memoryview,\n        _public_key: SSHPublicKeyTypes,\n        _serial: int,\n        _cctype: int,\n        _key_id: memoryview,\n        _valid_principals: list[bytes],\n        _valid_after: int,\n        _valid_before: int,\n        _critical_options: dict[bytes, bytes],\n        _extensions: dict[bytes, bytes],\n        _sig_type: memoryview,\n        _sig_key: memoryview,\n        _inner_sig_type: memoryview,\n        _signature: memoryview,\n        _tbs_cert_body: memoryview,\n        _cert_key_type: bytes,\n        _cert_body: memoryview,\n    ):\n        self._nonce = _nonce\n        self._public_key = _public_key\n        self._serial = _serial\n        try:\n            self._type = SSHCertificateType(_cctype)\n        except ValueError:\n            raise ValueError(\"Invalid certificate type\")\n        self._key_id = _key_id\n        self._valid_principals = _valid_principals\n        self._valid_after = _valid_after\n        self._valid_before = _valid_before\n        self._critical_options = _critical_options\n        self._extensions = _extensions\n        self._sig_type = _sig_type\n        self._sig_key = _sig_key\n        self._inner_sig_type = _inner_sig_type\n        self._signature = _signature\n        self._cert_key_type = _cert_key_type\n        self._cert_body = _cert_body\n        self._tbs_cert_body = _tbs_cert_body\n\n    @property\n    def nonce(self) -> bytes:\n        return bytes(self._nonce)\n\n    def public_key(self) -> SSHCertPublicKeyTypes:\n        # make mypy happy until we remove DSA support entirely and\n        # the underlying union won't have a disallowed type\n        return typing.cast(SSHCertPublicKeyTypes, self._public_key)\n\n    @property\n    def serial(self) -> int:\n        return self._serial\n\n    @property\n    def type(self) -> SSHCertificateType:\n        return self._type\n\n    @property\n    def key_id(self) -> bytes:\n        return bytes(self._key_id)\n\n    @property\n    def valid_principals(self) -> list[bytes]:\n        return self._valid_principals\n\n    @property\n    def valid_before(self) -> int:\n        return self._valid_before\n\n    @property\n    def valid_after(self) -> int:\n        return self._valid_after\n\n    @property\n    def critical_options(self) -> dict[bytes, bytes]:\n        return self._critical_options\n\n    @property\n    def extensions(self) -> dict[bytes, bytes]:\n        return self._extensions\n\n    def signature_key(self) -> SSHCertPublicKeyTypes:\n        sigformat = _lookup_kformat(self._sig_type)\n        signature_key, sigkey_rest = sigformat.load_public(self._sig_key)\n        _check_empty(sigkey_rest)\n        return signature_key\n\n    def public_bytes(self) -> bytes:\n        return (\n            bytes(self._cert_key_type)\n            + b\" \"\n            + binascii.b2a_base64(bytes(self._cert_body), newline=False)\n        )\n\n    def verify_cert_signature(self) -> None:\n        signature_key = self.signature_key()\n        if isinstance(signature_key, ed25519.Ed25519PublicKey):\n            signature_key.verify(\n                bytes(self._signature), bytes(self._tbs_cert_body)\n            )\n        elif isinstance(signature_key, ec.EllipticCurvePublicKey):\n            # The signature is encoded as a pair of big-endian integers\n            r, data = _get_mpint(self._signature)\n            s, data = _get_mpint(data)\n            _check_empty(data)\n            computed_sig = asym_utils.encode_dss_signature(r, s)\n            hash_alg = _get_ec_hash_alg(signature_key.curve)\n            signature_key.verify(\n                computed_sig, bytes(self._tbs_cert_body), ec.ECDSA(hash_alg)\n            )\n        else:\n            assert isinstance(signature_key, rsa.RSAPublicKey)\n            if self._inner_sig_type == _SSH_RSA:\n                hash_alg = hashes.SHA1()\n            elif self._inner_sig_type == _SSH_RSA_SHA256:\n                hash_alg = hashes.SHA256()\n            else:\n                assert self._inner_sig_type == _SSH_RSA_SHA512\n                hash_alg = hashes.SHA512()\n            signature_key.verify(\n                bytes(self._signature),\n                bytes(self._tbs_cert_body),\n                padding.PKCS1v15(),\n                hash_alg,\n            )\n\n\ndef _get_ec_hash_alg(curve: ec.EllipticCurve) -> hashes.HashAlgorithm:\n    if isinstance(curve, ec.SECP256R1):\n        return hashes.SHA256()\n    elif isinstance(curve, ec.SECP384R1):\n        return hashes.SHA384()\n    else:\n        assert isinstance(curve, ec.SECP521R1)\n        return hashes.SHA512()\n\n\ndef _load_ssh_public_identity(\n    data: bytes,\n    _legacy_dsa_allowed=False,\n) -> SSHCertificate | SSHPublicKeyTypes:\n    utils._check_byteslike(\"data\", data)\n\n    m = _SSH_PUBKEY_RC.match(data)\n    if not m:\n        raise ValueError(\"Invalid line format\")\n    key_type = orig_key_type = m.group(1)\n    key_body = m.group(2)\n    with_cert = False\n    if key_type.endswith(_CERT_SUFFIX):\n        with_cert = True\n        key_type = key_type[: -len(_CERT_SUFFIX)]\n    if key_type == _SSH_DSA and not _legacy_dsa_allowed:\n        raise UnsupportedAlgorithm(\n            \"DSA keys aren't supported in SSH certificates\"\n        )\n    kformat = _lookup_kformat(key_type)\n\n    try:\n        rest = memoryview(binascii.a2b_base64(key_body))\n    except (TypeError, binascii.Error):\n        raise ValueError(\"Invalid format\")\n\n    if with_cert:\n        cert_body = rest\n    inner_key_type, rest = _get_sshstr(rest)\n    if inner_key_type != orig_key_type:\n        raise ValueError(\"Invalid key format\")\n    if with_cert:\n        nonce, rest = _get_sshstr(rest)\n    public_key, rest = kformat.load_public(rest)\n    if with_cert:\n        serial, rest = _get_u64(rest)\n        cctype, rest = _get_u32(rest)\n        key_id, rest = _get_sshstr(rest)\n        principals, rest = _get_sshstr(rest)\n        valid_principals = []\n        while principals:\n            principal, principals = _get_sshstr(principals)\n            valid_principals.append(bytes(principal))\n        valid_after, rest = _get_u64(rest)\n        valid_before, rest = _get_u64(rest)\n        crit_options, rest = _get_sshstr(rest)\n        critical_options = _parse_exts_opts(crit_options)\n        exts, rest = _get_sshstr(rest)\n        extensions = _parse_exts_opts(exts)\n        # Get the reserved field, which is unused.\n        _, rest = _get_sshstr(rest)\n        sig_key_raw, rest = _get_sshstr(rest)\n        sig_type, sig_key = _get_sshstr(sig_key_raw)\n        if sig_type == _SSH_DSA and not _legacy_dsa_allowed:\n            raise UnsupportedAlgorithm(\n                \"DSA signatures aren't supported in SSH certificates\"\n            )\n        # Get the entire cert body and subtract the signature\n        tbs_cert_body = cert_body[: -len(rest)]\n        signature_raw, rest = _get_sshstr(rest)\n        _check_empty(rest)\n        inner_sig_type, sig_rest = _get_sshstr(signature_raw)\n        # RSA certs can have multiple algorithm types\n        if (\n            sig_type == _SSH_RSA\n            and inner_sig_type\n            not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]\n        ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):\n            raise ValueError(\"Signature key type does not match\")\n        signature, sig_rest = _get_sshstr(sig_rest)\n        _check_empty(sig_rest)\n        return SSHCertificate(\n            nonce,\n            public_key,\n            serial,\n            cctype,\n            key_id,\n            valid_principals,\n            valid_after,\n            valid_before,\n            critical_options,\n            extensions,\n            sig_type,\n            sig_key,\n            inner_sig_type,\n            signature,\n            tbs_cert_body,\n            orig_key_type,\n            cert_body,\n        )\n    else:\n        _check_empty(rest)\n        return public_key\n\n\ndef load_ssh_public_identity(\n    data: bytes,\n) -> SSHCertificate | SSHPublicKeyTypes:\n    return _load_ssh_public_identity(data)\n\n\ndef _parse_exts_opts(exts_opts: memoryview) -> dict[bytes, bytes]:\n    result: dict[bytes, bytes] = {}\n    last_name = None\n    while exts_opts:\n        name, exts_opts = _get_sshstr(exts_opts)\n        bname: bytes = bytes(name)\n        if bname in result:\n            raise ValueError(\"Duplicate name\")\n        if last_name is not None and bname < last_name:\n            raise ValueError(\"Fields not lexically sorted\")\n        value, exts_opts = _get_sshstr(exts_opts)\n        if len(value) > 0:\n            value, extra = _get_sshstr(value)\n            if len(extra) > 0:\n                raise ValueError(\"Unexpected extra data after value\")\n        result[bname] = bytes(value)\n        last_name = bname\n    return result\n\n\ndef load_ssh_public_key(\n    data: bytes, backend: typing.Any = None\n) -> SSHPublicKeyTypes:\n    cert_or_key = _load_ssh_public_identity(data, _legacy_dsa_allowed=True)\n    public_key: SSHPublicKeyTypes\n    if isinstance(cert_or_key, SSHCertificate):\n        public_key = cert_or_key.public_key()\n    else:\n        public_key = cert_or_key\n\n    if isinstance(public_key, dsa.DSAPublicKey):\n        warnings.warn(\n            \"SSH DSA keys are deprecated and will be removed in a future \"\n            \"release.\",\n            utils.DeprecatedIn40,\n            stacklevel=2,\n        )\n    return public_key\n\n\ndef serialize_ssh_public_key(public_key: SSHPublicKeyTypes) -> bytes:\n    \"\"\"One-line public key format for OpenSSH\"\"\"\n    if isinstance(public_key, dsa.DSAPublicKey):\n        warnings.warn(\n            \"SSH DSA key support is deprecated and will be \"\n            \"removed in a future release\",\n            utils.DeprecatedIn40,\n            stacklevel=4,\n        )\n    key_type = _get_ssh_key_type(public_key)\n    kformat = _lookup_kformat(key_type)\n\n    f_pub = _FragList()\n    f_pub.put_sshstr(key_type)\n    kformat.encode_public(public_key, f_pub)\n\n    pub = binascii.b2a_base64(f_pub.tobytes()).strip()\n    return b\"\".join([key_type, b\" \", pub])\n\n\nSSHCertPrivateKeyTypes = typing.Union[\n    ec.EllipticCurvePrivateKey,\n    rsa.RSAPrivateKey,\n    ed25519.Ed25519PrivateKey,\n]\n\n\n# This is an undocumented limit enforced in the openssh codebase for sshd and\n# ssh-keygen, but it is undefined in the ssh certificates spec.\n_SSHKEY_CERT_MAX_PRINCIPALS = 256\n\n\nclass SSHCertificateBuilder:\n    def __init__(\n        self,\n        _public_key: SSHCertPublicKeyTypes | None = None,\n        _serial: int | None = None,\n        _type: SSHCertificateType | None = None,\n        _key_id: bytes | None = None,\n        _valid_principals: list[bytes] = [],\n        _valid_for_all_principals: bool = False,\n        _valid_before: int | None = None,\n        _valid_after: int | None = None,\n        _critical_options: list[tuple[bytes, bytes]] = [],\n        _extensions: list[tuple[bytes, bytes]] = [],\n    ):\n        self._public_key = _public_key\n        self._serial = _serial\n        self._type = _type\n        self._key_id = _key_id\n        self._valid_principals = _valid_principals\n        self._valid_for_all_principals = _valid_for_all_principals\n        self._valid_before = _valid_before\n        self._valid_after = _valid_after\n        self._critical_options = _critical_options\n        self._extensions = _extensions\n\n    def public_key(\n        self, public_key: SSHCertPublicKeyTypes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(\n            public_key,\n            (\n                ec.EllipticCurvePublicKey,\n                rsa.RSAPublicKey,\n                ed25519.Ed25519PublicKey,\n            ),\n        ):\n            raise TypeError(\"Unsupported key type\")\n        if self._public_key is not None:\n            raise ValueError(\"public_key already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def serial(self, serial: int) -> SSHCertificateBuilder:\n        if not isinstance(serial, int):\n            raise TypeError(\"serial must be an integer\")\n        if not 0 <= serial < 2**64:\n            raise ValueError(\"serial must be between 0 and 2**64\")\n        if self._serial is not None:\n            raise ValueError(\"serial already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def type(self, type: SSHCertificateType) -> SSHCertificateBuilder:\n        if not isinstance(type, SSHCertificateType):\n            raise TypeError(\"type must be an SSHCertificateType\")\n        if self._type is not None:\n            raise ValueError(\"type already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def key_id(self, key_id: bytes) -> SSHCertificateBuilder:\n        if not isinstance(key_id, bytes):\n            raise TypeError(\"key_id must be bytes\")\n        if self._key_id is not None:\n            raise ValueError(\"key_id already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_principals(\n        self, valid_principals: list[bytes]\n    ) -> SSHCertificateBuilder:\n        if self._valid_for_all_principals:\n            raise ValueError(\n                \"Principals can't be set because the cert is valid \"\n                \"for all principals\"\n            )\n        if (\n            not all(isinstance(x, bytes) for x in valid_principals)\n            or not valid_principals\n        ):\n            raise TypeError(\n                \"principals must be a list of bytes and can't be empty\"\n            )\n        if self._valid_principals:\n            raise ValueError(\"valid_principals already set\")\n\n        if len(valid_principals) > _SSHKEY_CERT_MAX_PRINCIPALS:\n            raise ValueError(\n                \"Reached or exceeded the maximum number of valid_principals\"\n            )\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_for_all_principals(self):\n        if self._valid_principals:\n            raise ValueError(\n                \"valid_principals already set, can't set \"\n                \"valid_for_all_principals\"\n            )\n        if self._valid_for_all_principals:\n            raise ValueError(\"valid_for_all_principals already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=True,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_before(self, valid_before: int | float) -> SSHCertificateBuilder:\n        if not isinstance(valid_before, (int, float)):\n            raise TypeError(\"valid_before must be an int or float\")\n        valid_before = int(valid_before)\n        if valid_before < 0 or valid_before >= 2**64:\n            raise ValueError(\"valid_before must [0, 2**64)\")\n        if self._valid_before is not None:\n            raise ValueError(\"valid_before already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_after(self, valid_after: int | float) -> SSHCertificateBuilder:\n        if not isinstance(valid_after, (int, float)):\n            raise TypeError(\"valid_after must be an int or float\")\n        valid_after = int(valid_after)\n        if valid_after < 0 or valid_after >= 2**64:\n            raise ValueError(\"valid_after must [0, 2**64)\")\n        if self._valid_after is not None:\n            raise ValueError(\"valid_after already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def add_critical_option(\n        self, name: bytes, value: bytes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(name, bytes) or not isinstance(value, bytes):\n            raise TypeError(\"name and value must be bytes\")\n        # This is O(n**2)\n        if name in [name for name, _ in self._critical_options]:\n            raise ValueError(\"Duplicate critical option name\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=[*self._critical_options, (name, value)],\n            _extensions=self._extensions,\n        )\n\n    def add_extension(\n        self, name: bytes, value: bytes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(name, bytes) or not isinstance(value, bytes):\n            raise TypeError(\"name and value must be bytes\")\n        # This is O(n**2)\n        if name in [name for name, _ in self._extensions]:\n            raise ValueError(\"Duplicate extension name\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=[*self._extensions, (name, value)],\n        )\n\n    def sign(self, private_key: SSHCertPrivateKeyTypes) -> SSHCertificate:\n        if not isinstance(\n            private_key,\n            (\n                ec.EllipticCurvePrivateKey,\n                rsa.RSAPrivateKey,\n                ed25519.Ed25519PrivateKey,\n            ),\n        ):\n            raise TypeError(\"Unsupported private key type\")\n\n        if self._public_key is None:\n            raise ValueError(\"public_key must be set\")\n\n        # Not required\n        serial = 0 if self._serial is None else self._serial\n\n        if self._type is None:\n            raise ValueError(\"type must be set\")\n\n        # Not required\n        key_id = b\"\" if self._key_id is None else self._key_id\n\n        # A zero length list is valid, but means the certificate\n        # is valid for any principal of the specified type. We require\n        # the user to explicitly set valid_for_all_principals to get\n        # that behavior.\n        if not self._valid_principals and not self._valid_for_all_principals:\n            raise ValueError(\n                \"valid_principals must be set if valid_for_all_principals \"\n                \"is False\"\n            )\n\n        if self._valid_before is None:\n            raise ValueError(\"valid_before must be set\")\n\n        if self._valid_after is None:\n            raise ValueError(\"valid_after must be set\")\n\n        if self._valid_after > self._valid_before:\n            raise ValueError(\"valid_after must be earlier than valid_before\")\n\n        # lexically sort our byte strings\n        self._critical_options.sort(key=lambda x: x[0])\n        self._extensions.sort(key=lambda x: x[0])\n\n        key_type = _get_ssh_key_type(self._public_key)\n        cert_prefix = key_type + _CERT_SUFFIX\n\n        # Marshal the bytes to be signed\n        nonce = os.urandom(32)\n        kformat = _lookup_kformat(key_type)\n        f = _FragList()\n        f.put_sshstr(cert_prefix)\n        f.put_sshstr(nonce)\n        kformat.encode_public(self._public_key, f)\n        f.put_u64(serial)\n        f.put_u32(self._type.value)\n        f.put_sshstr(key_id)\n        fprincipals = _FragList()\n        for p in self._valid_principals:\n            fprincipals.put_sshstr(p)\n        f.put_sshstr(fprincipals.tobytes())\n        f.put_u64(self._valid_after)\n        f.put_u64(self._valid_before)\n        fcrit = _FragList()\n        for name, value in self._critical_options:\n            fcrit.put_sshstr(name)\n            if len(value) > 0:\n                foptval = _FragList()\n                foptval.put_sshstr(value)\n                fcrit.put_sshstr(foptval.tobytes())\n            else:\n                fcrit.put_sshstr(value)\n        f.put_sshstr(fcrit.tobytes())\n        fext = _FragList()\n        for name, value in self._extensions:\n            fext.put_sshstr(name)\n            if len(value) > 0:\n                fextval = _FragList()\n                fextval.put_sshstr(value)\n                fext.put_sshstr(fextval.tobytes())\n            else:\n                fext.put_sshstr(value)\n        f.put_sshstr(fext.tobytes())\n        f.put_sshstr(b\"\")  # RESERVED FIELD\n        # encode CA public key\n        ca_type = _get_ssh_key_type(private_key)\n        caformat = _lookup_kformat(ca_type)\n        caf = _FragList()\n        caf.put_sshstr(ca_type)\n        caformat.encode_public(private_key.public_key(), caf)\n        f.put_sshstr(caf.tobytes())\n        # Sigs according to the rules defined for the CA's public key\n        # (RFC4253 section 6.6 for ssh-rsa, RFC5656 for ECDSA,\n        # and RFC8032 for Ed25519).\n        if isinstance(private_key, ed25519.Ed25519PrivateKey):\n            signature = private_key.sign(f.tobytes())\n            fsig = _FragList()\n            fsig.put_sshstr(ca_type)\n            fsig.put_sshstr(signature)\n            f.put_sshstr(fsig.tobytes())\n        elif isinstance(private_key, ec.EllipticCurvePrivateKey):\n            hash_alg = _get_ec_hash_alg(private_key.curve)\n            signature = private_key.sign(f.tobytes(), ec.ECDSA(hash_alg))\n            r, s = asym_utils.decode_dss_signature(signature)\n            fsig = _FragList()\n            fsig.put_sshstr(ca_type)\n            fsigblob = _FragList()\n            fsigblob.put_mpint(r)\n            fsigblob.put_mpint(s)\n            fsig.put_sshstr(fsigblob.tobytes())\n            f.put_sshstr(fsig.tobytes())\n\n        else:\n            assert isinstance(private_key, rsa.RSAPrivateKey)\n            # Just like Golang, we're going to use SHA512 for RSA\n            # https://cs.opensource.google/go/x/crypto/+/refs/tags/\n            # v0.4.0:ssh/certs.go;l=445\n            # RFC 8332 defines SHA256 and 512 as options\n            fsig = _FragList()\n            fsig.put_sshstr(_SSH_RSA_SHA512)\n            signature = private_key.sign(\n                f.tobytes(), padding.PKCS1v15(), hashes.SHA512()\n            )\n            fsig.put_sshstr(signature)\n            f.put_sshstr(fsig.tobytes())\n\n        cert_data = binascii.b2a_base64(f.tobytes()).strip()\n        # load_ssh_public_identity returns a union, but this is\n        # guaranteed to be an SSHCertificate, so we cast to make\n        # mypy happy.\n        return typing.cast(\n            SSHCertificate,\n            load_ssh_public_identity(b\"\".join([cert_prefix, b\" \", cert_data])),\n        )\n", "src/cryptography/hazmat/primitives/serialization/pkcs7.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport email.base64mime\nimport email.generator\nimport email.message\nimport email.policy\nimport io\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.hazmat.bindings._rust import pkcs7 as rust_pkcs7\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, padding, rsa\nfrom cryptography.utils import _check_byteslike\n\nload_pem_pkcs7_certificates = rust_pkcs7.load_pem_pkcs7_certificates\n\nload_der_pkcs7_certificates = rust_pkcs7.load_der_pkcs7_certificates\n\nserialize_certificates = rust_pkcs7.serialize_certificates\n\nPKCS7HashTypes = typing.Union[\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n]\n\nPKCS7PrivateKeyTypes = typing.Union[\n    rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey\n]\n\n\nclass PKCS7Options(utils.Enum):\n    Text = \"Add text/plain MIME type\"\n    Binary = \"Don't translate input data into canonical MIME format\"\n    DetachedSignature = \"Don't embed data in the PKCS7 structure\"\n    NoCapabilities = \"Don't embed SMIME capabilities\"\n    NoAttributes = \"Don't embed authenticatedAttributes\"\n    NoCerts = \"Don't embed signer certificate\"\n\n\nclass PKCS7SignatureBuilder:\n    def __init__(\n        self,\n        data: bytes | None = None,\n        signers: list[\n            tuple[\n                x509.Certificate,\n                PKCS7PrivateKeyTypes,\n                PKCS7HashTypes,\n                padding.PSS | padding.PKCS1v15 | None,\n            ]\n        ] = [],\n        additional_certs: list[x509.Certificate] = [],\n    ):\n        self._data = data\n        self._signers = signers\n        self._additional_certs = additional_certs\n\n    def set_data(self, data: bytes) -> PKCS7SignatureBuilder:\n        _check_byteslike(\"data\", data)\n        if self._data is not None:\n            raise ValueError(\"data may only be set once\")\n\n        return PKCS7SignatureBuilder(data, self._signers)\n\n    def add_signer(\n        self,\n        certificate: x509.Certificate,\n        private_key: PKCS7PrivateKeyTypes,\n        hash_algorithm: PKCS7HashTypes,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> PKCS7SignatureBuilder:\n        if not isinstance(\n            hash_algorithm,\n            (\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        ):\n            raise TypeError(\n                \"hash_algorithm must be one of hashes.SHA224, \"\n                \"SHA256, SHA384, or SHA512\"\n            )\n        if not isinstance(certificate, x509.Certificate):\n            raise TypeError(\"certificate must be a x509.Certificate\")\n\n        if not isinstance(\n            private_key, (rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey)\n        ):\n            raise TypeError(\"Only RSA & EC keys are supported at this time.\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return PKCS7SignatureBuilder(\n            self._data,\n            [\n                *self._signers,\n                (certificate, private_key, hash_algorithm, rsa_padding),\n            ],\n        )\n\n    def add_certificate(\n        self, certificate: x509.Certificate\n    ) -> PKCS7SignatureBuilder:\n        if not isinstance(certificate, x509.Certificate):\n            raise TypeError(\"certificate must be a x509.Certificate\")\n\n        return PKCS7SignatureBuilder(\n            self._data, self._signers, [*self._additional_certs, certificate]\n        )\n\n    def sign(\n        self,\n        encoding: serialization.Encoding,\n        options: typing.Iterable[PKCS7Options],\n        backend: typing.Any = None,\n    ) -> bytes:\n        if len(self._signers) == 0:\n            raise ValueError(\"Must have at least one signer\")\n        if self._data is None:\n            raise ValueError(\"You must add data to sign\")\n        options = list(options)\n        if not all(isinstance(x, PKCS7Options) for x in options):\n            raise ValueError(\"options must be from the PKCS7Options enum\")\n        if encoding not in (\n            serialization.Encoding.PEM,\n            serialization.Encoding.DER,\n            serialization.Encoding.SMIME,\n        ):\n            raise ValueError(\n                \"Must be PEM, DER, or SMIME from the Encoding enum\"\n            )\n\n        # Text is a meaningless option unless it is accompanied by\n        # DetachedSignature\n        if (\n            PKCS7Options.Text in options\n            and PKCS7Options.DetachedSignature not in options\n        ):\n            raise ValueError(\n                \"When passing the Text option you must also pass \"\n                \"DetachedSignature\"\n            )\n\n        if PKCS7Options.Text in options and encoding in (\n            serialization.Encoding.DER,\n            serialization.Encoding.PEM,\n        ):\n            raise ValueError(\n                \"The Text option is only available for SMIME serialization\"\n            )\n\n        # No attributes implies no capabilities so we'll error if you try to\n        # pass both.\n        if (\n            PKCS7Options.NoAttributes in options\n            and PKCS7Options.NoCapabilities in options\n        ):\n            raise ValueError(\n                \"NoAttributes is a superset of NoCapabilities. Do not pass \"\n                \"both values.\"\n            )\n\n        return rust_pkcs7.sign_and_serialize(self, encoding, options)\n\n\ndef _smime_encode(\n    data: bytes, signature: bytes, micalg: str, text_mode: bool\n) -> bytes:\n    # This function works pretty hard to replicate what OpenSSL does\n    # precisely. For good and for ill.\n\n    m = email.message.Message()\n    m.add_header(\"MIME-Version\", \"1.0\")\n    m.add_header(\n        \"Content-Type\",\n        \"multipart/signed\",\n        protocol=\"application/x-pkcs7-signature\",\n        micalg=micalg,\n    )\n\n    m.preamble = \"This is an S/MIME signed message\\n\"\n\n    msg_part = OpenSSLMimePart()\n    msg_part.set_payload(data)\n    if text_mode:\n        msg_part.add_header(\"Content-Type\", \"text/plain\")\n    m.attach(msg_part)\n\n    sig_part = email.message.MIMEPart()\n    sig_part.add_header(\n        \"Content-Type\", \"application/x-pkcs7-signature\", name=\"smime.p7s\"\n    )\n    sig_part.add_header(\"Content-Transfer-Encoding\", \"base64\")\n    sig_part.add_header(\n        \"Content-Disposition\", \"attachment\", filename=\"smime.p7s\"\n    )\n    sig_part.set_payload(\n        email.base64mime.body_encode(signature, maxlinelen=65)\n    )\n    del sig_part[\"MIME-Version\"]\n    m.attach(sig_part)\n\n    fp = io.BytesIO()\n    g = email.generator.BytesGenerator(\n        fp,\n        maxheaderlen=0,\n        mangle_from_=False,\n        policy=m.policy.clone(linesep=\"\\r\\n\"),\n    )\n    g.flatten(m)\n    return fp.getvalue()\n\n\nclass OpenSSLMimePart(email.message.MIMEPart):\n    # A MIMEPart subclass that replicates OpenSSL's behavior of not including\n    # a newline if there are no headers.\n    def _write_headers(self, generator) -> None:\n        if list(self.raw_items()):\n            generator._write_headers(self)\n", "src/cryptography/hazmat/primitives/serialization/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._serialization import (\n    BestAvailableEncryption,\n    Encoding,\n    KeySerializationEncryption,\n    NoEncryption,\n    ParameterFormat,\n    PrivateFormat,\n    PublicFormat,\n    _KeySerializationEncryption,\n)\nfrom cryptography.hazmat.primitives.serialization.base import (\n    load_der_parameters,\n    load_der_private_key,\n    load_der_public_key,\n    load_pem_parameters,\n    load_pem_private_key,\n    load_pem_public_key,\n)\nfrom cryptography.hazmat.primitives.serialization.ssh import (\n    SSHCertificate,\n    SSHCertificateBuilder,\n    SSHCertificateType,\n    SSHCertPrivateKeyTypes,\n    SSHCertPublicKeyTypes,\n    SSHPrivateKeyTypes,\n    SSHPublicKeyTypes,\n    load_ssh_private_key,\n    load_ssh_public_identity,\n    load_ssh_public_key,\n)\n\n__all__ = [\n    \"BestAvailableEncryption\",\n    \"Encoding\",\n    \"KeySerializationEncryption\",\n    \"NoEncryption\",\n    \"ParameterFormat\",\n    \"PrivateFormat\",\n    \"PublicFormat\",\n    \"SSHCertPrivateKeyTypes\",\n    \"SSHCertPublicKeyTypes\",\n    \"SSHCertificate\",\n    \"SSHCertificateBuilder\",\n    \"SSHCertificateType\",\n    \"SSHPrivateKeyTypes\",\n    \"SSHPublicKeyTypes\",\n    \"_KeySerializationEncryption\",\n    \"load_der_parameters\",\n    \"load_der_private_key\",\n    \"load_der_public_key\",\n    \"load_pem_parameters\",\n    \"load_pem_private_key\",\n    \"load_pem_public_key\",\n    \"load_ssh_private_key\",\n    \"load_ssh_public_identity\",\n    \"load_ssh_public_key\",\n]\n", "src/cryptography/hazmat/primitives/ciphers/algorithms.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography import utils\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    ARC4 as ARC4,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    CAST5 as CAST5,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    IDEA as IDEA,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    SEED as SEED,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    Blowfish as Blowfish,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    TripleDES as TripleDES,\n)\nfrom cryptography.hazmat.primitives._cipheralgorithm import _verify_key_size\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\n\n\nclass AES(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    # 512 added to support AES-256-XTS, which uses 512-bit keys\n    key_sizes = frozenset([128, 192, 256, 512])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass AES128(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    key_sizes = frozenset([128])\n    key_size = 128\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n\nclass AES256(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    key_sizes = frozenset([256])\n    key_size = 256\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n\nclass Camellia(BlockCipherAlgorithm):\n    name = \"camellia\"\n    block_size = 128\n    key_sizes = frozenset([128, 192, 256])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nutils.deprecated(\n    ARC4,\n    __name__,\n    \"ARC4 has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.ARC4 and \"\n    \"will be removed from this module in 48.0.0.\",\n    utils.DeprecatedIn43,\n    name=\"ARC4\",\n)\n\n\nutils.deprecated(\n    TripleDES,\n    __name__,\n    \"TripleDES has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.TripleDES and \"\n    \"will be removed from this module in 48.0.0.\",\n    utils.DeprecatedIn43,\n    name=\"TripleDES\",\n)\n\nutils.deprecated(\n    Blowfish,\n    __name__,\n    \"Blowfish has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.Blowfish and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"Blowfish\",\n)\n\n\nutils.deprecated(\n    CAST5,\n    __name__,\n    \"CAST5 has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.CAST5 and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"CAST5\",\n)\n\n\nutils.deprecated(\n    IDEA,\n    __name__,\n    \"IDEA has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.IDEA and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"IDEA\",\n)\n\n\nutils.deprecated(\n    SEED,\n    __name__,\n    \"SEED has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.SEED and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"SEED\",\n)\n\n\nclass ChaCha20(CipherAlgorithm):\n    name = \"ChaCha20\"\n    key_sizes = frozenset([256])\n\n    def __init__(self, key: bytes, nonce: bytes):\n        self.key = _verify_key_size(self, key)\n        utils._check_byteslike(\"nonce\", nonce)\n\n        if len(nonce) != 16:\n            raise ValueError(\"nonce must be 128-bits (16 bytes)\")\n\n        self._nonce = nonce\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass SM4(BlockCipherAlgorithm):\n    name = \"SM4\"\n    block_size = 128\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n", "src/cryptography/hazmat/primitives/ciphers/aead.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\n    \"AESCCM\",\n    \"AESGCM\",\n    \"AESGCMSIV\",\n    \"AESOCB3\",\n    \"AESSIV\",\n    \"ChaCha20Poly1305\",\n]\n\nAESGCM = rust_openssl.aead.AESGCM\nChaCha20Poly1305 = rust_openssl.aead.ChaCha20Poly1305\nAESCCM = rust_openssl.aead.AESCCM\nAESSIV = rust_openssl.aead.AESSIV\nAESOCB3 = rust_openssl.aead.AESOCB3\nAESGCMSIV = rust_openssl.aead.AESGCMSIV\n", "src/cryptography/hazmat/primitives/ciphers/modes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers import algorithms\n\n\nclass Mode(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this mode (e.g. \"ECB\", \"CBC\").\n        \"\"\"\n\n    @abc.abstractmethod\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        \"\"\"\n        Checks that all the necessary invariants of this (mode, algorithm)\n        combination are met.\n        \"\"\"\n\n\nclass ModeWithInitializationVector(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def initialization_vector(self) -> bytes:\n        \"\"\"\n        The value of the initialization vector for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithTweak(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tweak(self) -> bytes:\n        \"\"\"\n        The value of the tweak for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithNonce(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def nonce(self) -> bytes:\n        \"\"\"\n        The value of the nonce for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithAuthenticationTag(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tag(self) -> bytes | None:\n        \"\"\"\n        The value of the tag supplied to the constructor of this mode.\n        \"\"\"\n\n\ndef _check_aes_key_length(self: Mode, algorithm: CipherAlgorithm) -> None:\n    if algorithm.key_size > 256 and algorithm.name == \"AES\":\n        raise ValueError(\n            \"Only 128, 192, and 256 bit keys are allowed for this AES mode\"\n        )\n\n\ndef _check_iv_length(\n    self: ModeWithInitializationVector, algorithm: BlockCipherAlgorithm\n) -> None:\n    iv_len = len(self.initialization_vector)\n    if iv_len * 8 != algorithm.block_size:\n        raise ValueError(f\"Invalid IV size ({iv_len}) for {self.name}.\")\n\n\ndef _check_nonce_length(\n    nonce: bytes, name: str, algorithm: CipherAlgorithm\n) -> None:\n    if not isinstance(algorithm, BlockCipherAlgorithm):\n        raise UnsupportedAlgorithm(\n            f\"{name} requires a block cipher algorithm\",\n            _Reasons.UNSUPPORTED_CIPHER,\n        )\n    if len(nonce) * 8 != algorithm.block_size:\n        raise ValueError(f\"Invalid nonce size ({len(nonce)}) for {name}.\")\n\n\ndef _check_iv_and_key_length(\n    self: ModeWithInitializationVector, algorithm: CipherAlgorithm\n) -> None:\n    if not isinstance(algorithm, BlockCipherAlgorithm):\n        raise UnsupportedAlgorithm(\n            f\"{self} requires a block cipher algorithm\",\n            _Reasons.UNSUPPORTED_CIPHER,\n        )\n    _check_aes_key_length(self, algorithm)\n    _check_iv_length(self, algorithm)\n\n\nclass CBC(ModeWithInitializationVector):\n    name = \"CBC\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass XTS(ModeWithTweak):\n    name = \"XTS\"\n\n    def __init__(self, tweak: bytes):\n        utils._check_byteslike(\"tweak\", tweak)\n\n        if len(tweak) != 16:\n            raise ValueError(\"tweak must be 128-bits (16 bytes)\")\n\n        self._tweak = tweak\n\n    @property\n    def tweak(self) -> bytes:\n        return self._tweak\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        if isinstance(algorithm, (algorithms.AES128, algorithms.AES256)):\n            raise TypeError(\n                \"The AES128 and AES256 classes do not support XTS, please use \"\n                \"the standard AES class instead.\"\n            )\n\n        if algorithm.key_size not in (256, 512):\n            raise ValueError(\n                \"The XTS specification requires a 256-bit key for AES-128-XTS\"\n                \" and 512-bit key for AES-256-XTS\"\n            )\n\n\nclass ECB(Mode):\n    name = \"ECB\"\n\n    validate_for_algorithm = _check_aes_key_length\n\n\nclass OFB(ModeWithInitializationVector):\n    name = \"OFB\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CFB(ModeWithInitializationVector):\n    name = \"CFB\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CFB8(ModeWithInitializationVector):\n    name = \"CFB8\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CTR(ModeWithNonce):\n    name = \"CTR\"\n\n    def __init__(self, nonce: bytes):\n        utils._check_byteslike(\"nonce\", nonce)\n        self._nonce = nonce\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        _check_aes_key_length(self, algorithm)\n        _check_nonce_length(self.nonce, self.name, algorithm)\n\n\nclass GCM(ModeWithInitializationVector, ModeWithAuthenticationTag):\n    name = \"GCM\"\n    _MAX_ENCRYPTED_BYTES = (2**39 - 256) // 8\n    _MAX_AAD_BYTES = (2**64) // 8\n\n    def __init__(\n        self,\n        initialization_vector: bytes,\n        tag: bytes | None = None,\n        min_tag_length: int = 16,\n    ):\n        # OpenSSL 3.0.0 constrains GCM IVs to [64, 1024] bits inclusive\n        # This is a sane limit anyway so we'll enforce it here.\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        if len(initialization_vector) < 8 or len(initialization_vector) > 128:\n            raise ValueError(\n                \"initialization_vector must be between 8 and 128 bytes (64 \"\n                \"and 1024 bits).\"\n            )\n        self._initialization_vector = initialization_vector\n        if tag is not None:\n            utils._check_bytes(\"tag\", tag)\n            if min_tag_length < 4:\n                raise ValueError(\"min_tag_length must be >= 4\")\n            if len(tag) < min_tag_length:\n                raise ValueError(\n                    f\"Authentication tag must be {min_tag_length} bytes or \"\n                    \"longer.\"\n                )\n        self._tag = tag\n        self._min_tag_length = min_tag_length\n\n    @property\n    def tag(self) -> bytes | None:\n        return self._tag\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        _check_aes_key_length(self, algorithm)\n        if not isinstance(algorithm, BlockCipherAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"GCM requires a block cipher algorithm\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n        block_size_bytes = algorithm.block_size // 8\n        if self._tag is not None and len(self._tag) > block_size_bytes:\n            raise ValueError(\n                f\"Authentication tag cannot be more than {block_size_bytes} \"\n                \"bytes.\"\n            )\n", "src/cryptography/hazmat/primitives/ciphers/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives._cipheralgorithm import CipherAlgorithm\nfrom cryptography.hazmat.primitives.ciphers import modes\n\n\nclass CipherContext(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def update(self, data: bytes) -> bytes:\n        \"\"\"\n        Processes the provided bytes through the cipher and returns the results\n        as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def update_into(self, data: bytes, buf: bytes) -> int:\n        \"\"\"\n        Processes the provided bytes and writes the resulting data into the\n        provided buffer. Returns the number of bytes written.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Returns the results of processing the final block as bytes.\n        \"\"\"\n\n\nclass AEADCipherContext(CipherContext, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def authenticate_additional_data(self, data: bytes) -> None:\n        \"\"\"\n        Authenticates the provided bytes.\n        \"\"\"\n\n\nclass AEADDecryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def finalize_with_tag(self, tag: bytes) -> bytes:\n        \"\"\"\n        Returns the results of processing the final block as bytes and allows\n        delayed passing of the authentication tag.\n        \"\"\"\n\n\nclass AEADEncryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tag(self) -> bytes:\n        \"\"\"\n        Returns tag bytes. This is only available after encryption is\n        finalized.\n        \"\"\"\n\n\nMode = typing.TypeVar(\n    \"Mode\", bound=typing.Optional[modes.Mode], covariant=True\n)\n\n\nclass Cipher(typing.Generic[Mode]):\n    def __init__(\n        self,\n        algorithm: CipherAlgorithm,\n        mode: Mode,\n        backend: typing.Any = None,\n    ) -> None:\n        if not isinstance(algorithm, CipherAlgorithm):\n            raise TypeError(\"Expected interface of CipherAlgorithm.\")\n\n        if mode is not None:\n            # mypy needs this assert to narrow the type from our generic\n            # type. Maybe it won't some time in the future.\n            assert isinstance(mode, modes.Mode)\n            mode.validate_for_algorithm(algorithm)\n\n        self.algorithm = algorithm\n        self.mode = mode\n\n    @typing.overload\n    def encryptor(\n        self: Cipher[modes.ModeWithAuthenticationTag],\n    ) -> AEADEncryptionContext: ...\n\n    @typing.overload\n    def encryptor(\n        self: _CIPHER_TYPE,\n    ) -> CipherContext: ...\n\n    def encryptor(self):\n        if isinstance(self.mode, modes.ModeWithAuthenticationTag):\n            if self.mode.tag is not None:\n                raise ValueError(\n                    \"Authentication tag must be None when encrypting.\"\n                )\n\n        return rust_openssl.ciphers.create_encryption_ctx(\n            self.algorithm, self.mode\n        )\n\n    @typing.overload\n    def decryptor(\n        self: Cipher[modes.ModeWithAuthenticationTag],\n    ) -> AEADDecryptionContext: ...\n\n    @typing.overload\n    def decryptor(\n        self: _CIPHER_TYPE,\n    ) -> CipherContext: ...\n\n    def decryptor(self):\n        return rust_openssl.ciphers.create_decryption_ctx(\n            self.algorithm, self.mode\n        )\n\n\n_CIPHER_TYPE = Cipher[\n    typing.Union[\n        modes.ModeWithNonce,\n        modes.ModeWithTweak,\n        None,\n        modes.ECB,\n        modes.ModeWithInitializationVector,\n    ]\n]\n\nCipherContext.register(rust_openssl.ciphers.CipherContext)\nAEADEncryptionContext.register(rust_openssl.ciphers.AEADEncryptionContext)\nAEADDecryptionContext.register(rust_openssl.ciphers.AEADDecryptionContext)\n", "src/cryptography/hazmat/primitives/ciphers/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.base import (\n    AEADCipherContext,\n    AEADDecryptionContext,\n    AEADEncryptionContext,\n    Cipher,\n    CipherContext,\n)\n\n__all__ = [\n    \"AEADCipherContext\",\n    \"AEADDecryptionContext\",\n    \"AEADEncryptionContext\",\n    \"BlockCipherAlgorithm\",\n    \"Cipher\",\n    \"CipherAlgorithm\",\n    \"CipherContext\",\n]\n", "src/cryptography/hazmat/primitives/kdf/concatkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\ndef _int_to_u32be(n: int) -> bytes:\n    return n.to_bytes(length=4, byteorder=\"big\")\n\n\ndef _common_args_checks(\n    algorithm: hashes.HashAlgorithm,\n    length: int,\n    otherinfo: bytes | None,\n) -> None:\n    max_length = algorithm.digest_size * (2**32 - 1)\n    if length > max_length:\n        raise ValueError(f\"Cannot derive keys larger than {max_length} bits.\")\n    if otherinfo is not None:\n        utils._check_bytes(\"otherinfo\", otherinfo)\n\n\ndef _concatkdf_derive(\n    key_material: bytes,\n    length: int,\n    auxfn: typing.Callable[[], hashes.HashContext],\n    otherinfo: bytes,\n) -> bytes:\n    utils._check_byteslike(\"key_material\", key_material)\n    output = [b\"\"]\n    outlen = 0\n    counter = 1\n\n    while length > outlen:\n        h = auxfn()\n        h.update(_int_to_u32be(counter))\n        h.update(key_material)\n        h.update(otherinfo)\n        output.append(h.finalize())\n        outlen += len(output[-1])\n        counter += 1\n\n    return b\"\".join(output)[:length]\n\n\nclass ConcatKDFHash(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        otherinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        _common_args_checks(algorithm, length, otherinfo)\n        self._algorithm = algorithm\n        self._length = length\n        self._otherinfo: bytes = otherinfo if otherinfo is not None else b\"\"\n\n        self._used = False\n\n    def _hash(self) -> hashes.Hash:\n        return hashes.Hash(self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        return _concatkdf_derive(\n            key_material, self._length, self._hash, self._otherinfo\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass ConcatKDFHMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes | None,\n        otherinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        _common_args_checks(algorithm, length, otherinfo)\n        self._algorithm = algorithm\n        self._length = length\n        self._otherinfo: bytes = otherinfo if otherinfo is not None else b\"\"\n\n        if algorithm.block_size is None:\n            raise TypeError(f\"{algorithm.name} is unsupported for ConcatKDF\")\n\n        if salt is None:\n            salt = b\"\\x00\" * algorithm.block_size\n        else:\n            utils._check_bytes(\"salt\", salt)\n\n        self._salt = salt\n\n        self._used = False\n\n    def _hmac(self) -> hmac.HMAC:\n        return hmac.HMAC(self._salt, self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        return _concatkdf_derive(\n            key_material, self._length, self._hmac, self._otherinfo\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/x963kdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\ndef _int_to_u32be(n: int) -> bytes:\n    return n.to_bytes(length=4, byteorder=\"big\")\n\n\nclass X963KDF(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        sharedinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        max_len = algorithm.digest_size * (2**32 - 1)\n        if length > max_len:\n            raise ValueError(f\"Cannot derive keys larger than {max_len} bits.\")\n        if sharedinfo is not None:\n            utils._check_bytes(\"sharedinfo\", sharedinfo)\n\n        self._algorithm = algorithm\n        self._length = length\n        self._sharedinfo = sharedinfo\n        self._used = False\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        utils._check_byteslike(\"key_material\", key_material)\n        output = [b\"\"]\n        outlen = 0\n        counter = 1\n\n        while self._length > outlen:\n            h = hashes.Hash(self._algorithm)\n            h.update(key_material)\n            h.update(_int_to_u32be(counter))\n            if self._sharedinfo is not None:\n                h.update(self._sharedinfo)\n            output.append(h.finalize())\n            outlen += len(output[-1])\n            counter += 1\n\n        return b\"\".join(output)[: self._length]\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/pbkdf2.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n    _Reasons,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import constant_time, hashes\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass PBKDF2HMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                f\"{algorithm.name} is not supported for PBKDF2.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")\n", "src/cryptography/hazmat/primitives/kdf/kbkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n    _Reasons,\n)\nfrom cryptography.hazmat.primitives import (\n    ciphers,\n    cmac,\n    constant_time,\n    hashes,\n    hmac,\n)\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass Mode(utils.Enum):\n    CounterMode = \"ctr\"\n\n\nclass CounterLocation(utils.Enum):\n    BeforeFixed = \"before_fixed\"\n    AfterFixed = \"after_fixed\"\n    MiddleFixed = \"middle_fixed\"\n\n\nclass _KBKDFDeriver:\n    def __init__(\n        self,\n        prf: typing.Callable,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        break_location: int | None,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n    ):\n        assert callable(prf)\n\n        if not isinstance(mode, Mode):\n            raise TypeError(\"mode must be of type Mode\")\n\n        if not isinstance(location, CounterLocation):\n            raise TypeError(\"location must be of type CounterLocation\")\n\n        if break_location is None and location is CounterLocation.MiddleFixed:\n            raise ValueError(\"Please specify a break_location\")\n\n        if (\n            break_location is not None\n            and location != CounterLocation.MiddleFixed\n        ):\n            raise ValueError(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            )\n\n        if break_location is not None and not isinstance(break_location, int):\n            raise TypeError(\"break_location must be an integer\")\n\n        if break_location is not None and break_location < 0:\n            raise ValueError(\"break_location must be a positive integer\")\n\n        if (label or context) and fixed:\n            raise ValueError(\n                \"When supplying fixed data, label and context are ignored.\"\n            )\n\n        if rlen is None or not self._valid_byte_length(rlen):\n            raise ValueError(\"rlen must be between 1 and 4\")\n\n        if llen is None and fixed is None:\n            raise ValueError(\"Please specify an llen\")\n\n        if llen is not None and not isinstance(llen, int):\n            raise TypeError(\"llen must be an integer\")\n\n        if label is None:\n            label = b\"\"\n\n        if context is None:\n            context = b\"\"\n\n        utils._check_bytes(\"label\", label)\n        utils._check_bytes(\"context\", context)\n        self._prf = prf\n        self._mode = mode\n        self._length = length\n        self._rlen = rlen\n        self._llen = llen\n        self._location = location\n        self._break_location = break_location\n        self._label = label\n        self._context = context\n        self._used = False\n        self._fixed_data = fixed\n\n    @staticmethod\n    def _valid_byte_length(value: int) -> bool:\n        if not isinstance(value, int):\n            raise TypeError(\"value must be of type int\")\n\n        value_bin = utils.int_to_bytes(1, value)\n        if not 1 <= len(value_bin) <= 4:\n            return False\n        return True\n\n    def derive(self, key_material: bytes, prf_output_size: int) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n\n        utils._check_byteslike(\"key_material\", key_material)\n        self._used = True\n\n        # inverse floor division (equivalent to ceiling)\n        rounds = -(-self._length // prf_output_size)\n\n        output = [b\"\"]\n\n        # For counter mode, the number of iterations shall not be\n        # larger than 2^r-1, where r <= 32 is the binary length of the counter\n        # This ensures that the counter values used as an input to the\n        # PRF will not repeat during a particular call to the KDF function.\n        r_bin = utils.int_to_bytes(1, self._rlen)\n        if rounds > pow(2, len(r_bin) * 8) - 1:\n            raise ValueError(\"There are too many iterations.\")\n\n        fixed = self._generate_fixed_input()\n\n        if self._location == CounterLocation.BeforeFixed:\n            data_before_ctr = b\"\"\n            data_after_ctr = fixed\n        elif self._location == CounterLocation.AfterFixed:\n            data_before_ctr = fixed\n            data_after_ctr = b\"\"\n        else:\n            if isinstance(\n                self._break_location, int\n            ) and self._break_location > len(fixed):\n                raise ValueError(\"break_location offset > len(fixed)\")\n            data_before_ctr = fixed[: self._break_location]\n            data_after_ctr = fixed[self._break_location :]\n\n        for i in range(1, rounds + 1):\n            h = self._prf(key_material)\n\n            counter = utils.int_to_bytes(i, self._rlen)\n            input_data = data_before_ctr + counter + data_after_ctr\n\n            h.update(input_data)\n\n            output.append(h.finalize())\n\n        return b\"\".join(output)[: self._length]\n\n    def _generate_fixed_input(self) -> bytes:\n        if self._fixed_data and isinstance(self._fixed_data, bytes):\n            return self._fixed_data\n\n        l_val = utils.int_to_bytes(self._length * 8, self._llen)\n\n        return b\"\".join([self._label, b\"\\x00\", self._context, l_val])\n\n\nclass KBKDFHMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n        backend: typing.Any = None,\n        *,\n        break_location: int | None = None,\n    ):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported hash algorithm.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported hmac algorithm.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n\n        self._algorithm = algorithm\n\n        self._deriver = _KBKDFDeriver(\n            self._prf,\n            mode,\n            length,\n            rlen,\n            llen,\n            location,\n            break_location,\n            label,\n            context,\n            fixed,\n        )\n\n    def _prf(self, key_material: bytes) -> hmac.HMAC:\n        return hmac.HMAC(key_material, self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        return self._deriver.derive(key_material, self._algorithm.digest_size)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass KBKDFCMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n        backend: typing.Any = None,\n        *,\n        break_location: int | None = None,\n    ):\n        if not issubclass(\n            algorithm, ciphers.BlockCipherAlgorithm\n        ) or not issubclass(algorithm, ciphers.CipherAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported cipher algorithm.\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        self._algorithm = algorithm\n        self._cipher: ciphers.BlockCipherAlgorithm | None = None\n\n        self._deriver = _KBKDFDeriver(\n            self._prf,\n            mode,\n            length,\n            rlen,\n            llen,\n            location,\n            break_location,\n            label,\n            context,\n            fixed,\n        )\n\n    def _prf(self, _: bytes) -> cmac.CMAC:\n        assert self._cipher is not None\n\n        return cmac.CMAC(self._cipher)\n\n    def derive(self, key_material: bytes) -> bytes:\n        self._cipher = self._algorithm(key_material)\n\n        assert self._cipher is not None\n\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.cmac_algorithm_supported(self._cipher):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported cipher algorithm.\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        return self._deriver.derive(key_material, self._cipher.block_size // 8)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/scrypt.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport sys\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n# This is used by the scrypt tests to skip tests that require more memory\n# than the MEM_LIMIT\n_MEM_LIMIT = sys.maxsize // 2\n\n\nclass Scrypt(KeyDerivationFunction):\n    def __init__(\n        self,\n        salt: bytes,\n        length: int,\n        n: int,\n        r: int,\n        p: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.scrypt_supported():\n            raise UnsupportedAlgorithm(\n                \"This version of OpenSSL does not support scrypt\"\n            )\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        if n < 2 or (n & (n - 1)) != 0:\n            raise ValueError(\"n must be greater than 1 and be a power of 2.\")\n\n        if r < 1:\n            raise ValueError(\"r must be greater than or equal to 1.\")\n\n        if p < 1:\n            raise ValueError(\"p must be greater than or equal to 1.\")\n\n        self._used = False\n        self._salt = salt\n        self._n = n\n        self._r = r\n        self._p = p\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"Scrypt instances can only be used once.\")\n        self._used = True\n\n        utils._check_byteslike(\"key_material\", key_material)\n\n        return rust_openssl.kdf.derive_scrypt(\n            key_material,\n            self._salt,\n            self._n,\n            self._r,\n            self._p,\n            _MEM_LIMIT,\n            self._length,\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")\n", "src/cryptography/hazmat/primitives/kdf/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\n\nclass KeyDerivationFunction(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def derive(self, key_material: bytes) -> bytes:\n        \"\"\"\n        Deterministically generates and returns a new key based on the existing\n        key material.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        \"\"\"\n        Checks whether the key generated by the key material matches the\n        expected derived key. Raises an exception if they do not match.\n        \"\"\"\n", "src/cryptography/hazmat/primitives/kdf/hkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass HKDF(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes | None,\n        info: bytes | None,\n        backend: typing.Any = None,\n    ):\n        self._algorithm = algorithm\n\n        if salt is None:\n            salt = b\"\\x00\" * self._algorithm.digest_size\n        else:\n            utils._check_bytes(\"salt\", salt)\n\n        self._salt = salt\n\n        self._hkdf_expand = HKDFExpand(self._algorithm, length, info)\n\n    def _extract(self, key_material: bytes) -> bytes:\n        h = hmac.HMAC(self._salt, self._algorithm)\n        h.update(key_material)\n        return h.finalize()\n\n    def derive(self, key_material: bytes) -> bytes:\n        utils._check_byteslike(\"key_material\", key_material)\n        return self._hkdf_expand.derive(self._extract(key_material))\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass HKDFExpand(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        info: bytes | None,\n        backend: typing.Any = None,\n    ):\n        self._algorithm = algorithm\n\n        max_length = 255 * algorithm.digest_size\n\n        if length > max_length:\n            raise ValueError(\n                f\"Cannot derive keys larger than {max_length} octets.\"\n            )\n\n        self._length = length\n\n        if info is None:\n            info = b\"\"\n        else:\n            utils._check_bytes(\"info\", info)\n\n        self._info = info\n\n        self._used = False\n\n    def _expand(self, key_material: bytes) -> bytes:\n        output = [b\"\"]\n        counter = 1\n\n        while self._algorithm.digest_size * (len(output) - 1) < self._length:\n            h = hmac.HMAC(key_material, self._algorithm)\n            h.update(output[-1])\n            h.update(self._info)\n            h.update(bytes([counter]))\n            output.append(h.finalize())\n            counter += 1\n\n        return b\"\".join(output)[: self._length]\n\n    def derive(self, key_material: bytes) -> bytes:\n        utils._check_byteslike(\"key_material\", key_material)\n        if self._used:\n            raise AlreadyFinalized\n\n        self._used = True\n        return self._expand(key_material)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/decrepit/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n", "src/cryptography/hazmat/decrepit/ciphers/algorithms.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n    _verify_key_size,\n)\n\n\nclass ARC4(CipherAlgorithm):\n    name = \"RC4\"\n    key_sizes = frozenset([40, 56, 64, 80, 128, 160, 192, 256])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass TripleDES(BlockCipherAlgorithm):\n    name = \"3DES\"\n    block_size = 64\n    key_sizes = frozenset([64, 128, 192])\n\n    def __init__(self, key: bytes):\n        if len(key) == 8:\n            key += key + key\n        elif len(key) == 16:\n            key += key[:8]\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass Blowfish(BlockCipherAlgorithm):\n    name = \"Blowfish\"\n    block_size = 64\n    key_sizes = frozenset(range(32, 449, 8))\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass CAST5(BlockCipherAlgorithm):\n    name = \"CAST5\"\n    block_size = 64\n    key_sizes = frozenset(range(40, 129, 8))\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass SEED(BlockCipherAlgorithm):\n    name = \"SEED\"\n    block_size = 128\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass IDEA(BlockCipherAlgorithm):\n    name = \"IDEA\"\n    block_size = 64\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\n# This class only allows RC2 with a 128-bit key. No support for\n# effective key bits or other key sizes is provided.\nclass RC2(BlockCipherAlgorithm):\n    name = \"RC2\"\n    block_size = 64\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n", "src/cryptography/hazmat/decrepit/ciphers/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n", "src/cryptography/hazmat/bindings/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/bindings/openssl/_conditional.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\ndef cryptography_has_set_cert_cb() -> list[str]:\n    return [\n        \"SSL_CTX_set_cert_cb\",\n        \"SSL_set_cert_cb\",\n    ]\n\n\ndef cryptography_has_ssl_st() -> list[str]:\n    return [\n        \"SSL_ST_BEFORE\",\n        \"SSL_ST_OK\",\n        \"SSL_ST_INIT\",\n        \"SSL_ST_RENEGOTIATE\",\n    ]\n\n\ndef cryptography_has_tls_st() -> list[str]:\n    return [\n        \"TLS_ST_BEFORE\",\n        \"TLS_ST_OK\",\n    ]\n\n\ndef cryptography_has_ssl_sigalgs() -> list[str]:\n    return [\n        \"SSL_CTX_set1_sigalgs_list\",\n    ]\n\n\ndef cryptography_has_psk() -> list[str]:\n    return [\n        \"SSL_CTX_use_psk_identity_hint\",\n        \"SSL_CTX_set_psk_server_callback\",\n        \"SSL_CTX_set_psk_client_callback\",\n    ]\n\n\ndef cryptography_has_psk_tlsv13() -> list[str]:\n    return [\n        \"SSL_CTX_set_psk_find_session_callback\",\n        \"SSL_CTX_set_psk_use_session_callback\",\n        \"Cryptography_SSL_SESSION_new\",\n        \"SSL_CIPHER_find\",\n        \"SSL_SESSION_set1_master_key\",\n        \"SSL_SESSION_set_cipher\",\n        \"SSL_SESSION_set_protocol_version\",\n    ]\n\n\ndef cryptography_has_custom_ext() -> list[str]:\n    return [\n        \"SSL_CTX_add_client_custom_ext\",\n        \"SSL_CTX_add_server_custom_ext\",\n        \"SSL_extension_supported\",\n    ]\n\n\ndef cryptography_has_tlsv13_functions() -> list[str]:\n    return [\n        \"SSL_VERIFY_POST_HANDSHAKE\",\n        \"SSL_CTX_set_ciphersuites\",\n        \"SSL_verify_client_post_handshake\",\n        \"SSL_CTX_set_post_handshake_auth\",\n        \"SSL_set_post_handshake_auth\",\n        \"SSL_SESSION_get_max_early_data\",\n        \"SSL_write_early_data\",\n        \"SSL_read_early_data\",\n        \"SSL_CTX_set_max_early_data\",\n    ]\n\n\ndef cryptography_has_engine() -> list[str]:\n    return [\n        \"ENGINE_by_id\",\n        \"ENGINE_init\",\n        \"ENGINE_finish\",\n        \"ENGINE_get_default_RAND\",\n        \"ENGINE_set_default_RAND\",\n        \"ENGINE_unregister_RAND\",\n        \"ENGINE_ctrl_cmd\",\n        \"ENGINE_free\",\n        \"ENGINE_get_name\",\n        \"ENGINE_ctrl_cmd_string\",\n        \"ENGINE_load_builtin_engines\",\n        \"ENGINE_load_private_key\",\n        \"ENGINE_load_public_key\",\n        \"SSL_CTX_set_client_cert_engine\",\n    ]\n\n\ndef cryptography_has_verified_chain() -> list[str]:\n    return [\n        \"SSL_get0_verified_chain\",\n    ]\n\n\ndef cryptography_has_srtp() -> list[str]:\n    return [\n        \"SSL_CTX_set_tlsext_use_srtp\",\n        \"SSL_set_tlsext_use_srtp\",\n        \"SSL_get_selected_srtp_profile\",\n    ]\n\n\ndef cryptography_has_op_no_renegotiation() -> list[str]:\n    return [\n        \"SSL_OP_NO_RENEGOTIATION\",\n    ]\n\n\ndef cryptography_has_dtls_get_data_mtu() -> list[str]:\n    return [\n        \"DTLS_get_data_mtu\",\n    ]\n\n\ndef cryptography_has_ssl_cookie() -> list[str]:\n    return [\n        \"SSL_OP_COOKIE_EXCHANGE\",\n        \"DTLSv1_listen\",\n        \"SSL_CTX_set_cookie_generate_cb\",\n        \"SSL_CTX_set_cookie_verify_cb\",\n    ]\n\n\ndef cryptography_has_pkcs7_funcs() -> list[str]:\n    return [\n        \"PKCS7_verify\",\n        \"SMIME_read_PKCS7\",\n    ]\n\n\ndef cryptography_has_prime_checks() -> list[str]:\n    return [\n        \"BN_prime_checks_for_size\",\n    ]\n\n\ndef cryptography_has_unexpected_eof_while_reading() -> list[str]:\n    return [\"SSL_R_UNEXPECTED_EOF_WHILE_READING\"]\n\n\ndef cryptography_has_pkcs12_set_mac() -> list[str]:\n    return [\"PKCS12_set_mac\"]\n\n\ndef cryptography_has_ssl_op_ignore_unexpected_eof() -> list[str]:\n    return [\n        \"SSL_OP_IGNORE_UNEXPECTED_EOF\",\n    ]\n\n\ndef cryptography_has_get_extms_support() -> list[str]:\n    return [\"SSL_get_extms_support\"]\n\n\n# This is a mapping of\n# {condition: function-returning-names-dependent-on-that-condition} so we can\n# loop over them and delete unsupported names at runtime. It will be removed\n# when cffi supports #if in cdef. We use functions instead of just a dict of\n# lists so we can use coverage to measure which are used.\nCONDITIONAL_NAMES = {\n    \"Cryptography_HAS_SET_CERT_CB\": cryptography_has_set_cert_cb,\n    \"Cryptography_HAS_SSL_ST\": cryptography_has_ssl_st,\n    \"Cryptography_HAS_TLS_ST\": cryptography_has_tls_st,\n    \"Cryptography_HAS_SIGALGS\": cryptography_has_ssl_sigalgs,\n    \"Cryptography_HAS_PSK\": cryptography_has_psk,\n    \"Cryptography_HAS_PSK_TLSv1_3\": cryptography_has_psk_tlsv13,\n    \"Cryptography_HAS_CUSTOM_EXT\": cryptography_has_custom_ext,\n    \"Cryptography_HAS_TLSv1_3_FUNCTIONS\": cryptography_has_tlsv13_functions,\n    \"Cryptography_HAS_ENGINE\": cryptography_has_engine,\n    \"Cryptography_HAS_VERIFIED_CHAIN\": cryptography_has_verified_chain,\n    \"Cryptography_HAS_SRTP\": cryptography_has_srtp,\n    \"Cryptography_HAS_OP_NO_RENEGOTIATION\": (\n        cryptography_has_op_no_renegotiation\n    ),\n    \"Cryptography_HAS_DTLS_GET_DATA_MTU\": cryptography_has_dtls_get_data_mtu,\n    \"Cryptography_HAS_SSL_COOKIE\": cryptography_has_ssl_cookie,\n    \"Cryptography_HAS_PKCS7_FUNCS\": cryptography_has_pkcs7_funcs,\n    \"Cryptography_HAS_PRIME_CHECKS\": cryptography_has_prime_checks,\n    \"Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING\": (\n        cryptography_has_unexpected_eof_while_reading\n    ),\n    \"Cryptography_HAS_PKCS12_SET_MAC\": cryptography_has_pkcs12_set_mac,\n    \"Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF\": (\n        cryptography_has_ssl_op_ignore_unexpected_eof\n    ),\n    \"Cryptography_HAS_GET_EXTMS_SUPPORT\": cryptography_has_get_extms_support,\n}\n", "src/cryptography/hazmat/bindings/openssl/binding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nimport threading\nimport types\nimport typing\nimport warnings\n\nimport cryptography\nfrom cryptography.exceptions import InternalError\nfrom cryptography.hazmat.bindings._rust import _openssl, openssl\nfrom cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES\n\n\ndef _openssl_assert(ok: bool) -> None:\n    if not ok:\n        errors = openssl.capture_error_stack()\n\n        raise InternalError(\n            \"Unknown OpenSSL error. This error is commonly encountered when \"\n            \"another library is not cleaning up the OpenSSL error stack. If \"\n            \"you are using cryptography with another library that uses \"\n            \"OpenSSL try disabling it before reporting a bug. Otherwise \"\n            \"please file an issue at https://github.com/pyca/cryptography/\"\n            \"issues with information on how to reproduce \"\n            f\"this. ({errors!r})\",\n            errors,\n        )\n\n\ndef build_conditional_library(\n    lib: typing.Any,\n    conditional_names: dict[str, typing.Callable[[], list[str]]],\n) -> typing.Any:\n    conditional_lib = types.ModuleType(\"lib\")\n    conditional_lib._original_lib = lib  # type: ignore[attr-defined]\n    excluded_names = set()\n    for condition, names_cb in conditional_names.items():\n        if not getattr(lib, condition):\n            excluded_names.update(names_cb())\n\n    for attr in dir(lib):\n        if attr not in excluded_names:\n            setattr(conditional_lib, attr, getattr(lib, attr))\n\n    return conditional_lib\n\n\nclass Binding:\n    \"\"\"\n    OpenSSL API wrapper.\n    \"\"\"\n\n    lib: typing.ClassVar = None\n    ffi = _openssl.ffi\n    _lib_loaded = False\n    _init_lock = threading.Lock()\n\n    def __init__(self) -> None:\n        self._ensure_ffi_initialized()\n\n    @classmethod\n    def _ensure_ffi_initialized(cls) -> None:\n        with cls._init_lock:\n            if not cls._lib_loaded:\n                cls.lib = build_conditional_library(\n                    _openssl.lib, CONDITIONAL_NAMES\n                )\n                cls._lib_loaded = True\n\n    @classmethod\n    def init_static_locks(cls) -> None:\n        cls._ensure_ffi_initialized()\n\n\ndef _verify_package_version(version: str) -> None:\n    # Occasionally we run into situations where the version of the Python\n    # package does not match the version of the shared object that is loaded.\n    # This may occur in environments where multiple versions of cryptography\n    # are installed and available in the python path. To avoid errors cropping\n    # up later this code checks that the currently imported package and the\n    # shared object that were loaded have the same version and raise an\n    # ImportError if they do not\n    so_package_version = _openssl.ffi.string(\n        _openssl.lib.CRYPTOGRAPHY_PACKAGE_VERSION\n    )\n    if version.encode(\"ascii\") != so_package_version:\n        raise ImportError(\n            \"The version of cryptography does not match the loaded \"\n            \"shared object. This can happen if you have multiple copies of \"\n            \"cryptography installed in your Python path. Please try creating \"\n            \"a new virtual environment to resolve this issue. \"\n            f\"Loaded python version: {version}, \"\n            f\"shared object version: {so_package_version}\"\n        )\n\n    _openssl_assert(\n        _openssl.lib.OpenSSL_version_num() == openssl.openssl_version(),\n    )\n\n\n_verify_package_version(cryptography.__version__)\n\nBinding.init_static_locks()\n\nif (\n    sys.platform == \"win32\"\n    and os.environ.get(\"PROCESSOR_ARCHITEW6432\") is not None\n):\n    warnings.warn(\n        \"You are using cryptography on a 32-bit Python on a 64-bit Windows \"\n        \"Operating System. Cryptography will be significantly faster if you \"\n        \"switch to using a 64-bit Python.\",\n        UserWarning,\n        stacklevel=2,\n    )\n", "src/cryptography/hazmat/bindings/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/backends/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n\ndef default_backend() -> Any:\n    from cryptography.hazmat.backends.openssl.backend import backend\n\n    return backend\n", "src/cryptography/hazmat/backends/openssl/backend.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport collections\nimport contextlib\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.bindings.openssl import binding\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\nfrom cryptography.hazmat.primitives.asymmetric.padding import (\n    MGF1,\n    OAEP,\n    PSS,\n    PKCS1v15,\n)\nfrom cryptography.hazmat.primitives.ciphers import (\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import (\n    CBC,\n    Mode,\n)\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import (\n    PBES,\n    PKCS12Certificate,\n    PKCS12PrivateKeyTypes,\n    _PKCS12CATypes,\n)\n\n_MemoryBIO = collections.namedtuple(\"_MemoryBIO\", [\"bio\", \"char_ptr\"])\n\n\nclass Backend:\n    \"\"\"\n    OpenSSL API binding interfaces.\n    \"\"\"\n\n    name = \"openssl\"\n\n    # TripleDES encryption is disallowed/deprecated throughout 2023 in\n    # FIPS 140-3. To keep it simple we denylist any use of TripleDES (TDEA).\n    _fips_ciphers = (AES,)\n    # Sometimes SHA1 is still permissible. That logic is contained\n    # within the various *_supported methods.\n    _fips_hashes = (\n        hashes.SHA224,\n        hashes.SHA256,\n        hashes.SHA384,\n        hashes.SHA512,\n        hashes.SHA512_224,\n        hashes.SHA512_256,\n        hashes.SHA3_224,\n        hashes.SHA3_256,\n        hashes.SHA3_384,\n        hashes.SHA3_512,\n        hashes.SHAKE128,\n        hashes.SHAKE256,\n    )\n    _fips_ecdh_curves = (\n        ec.SECP224R1,\n        ec.SECP256R1,\n        ec.SECP384R1,\n        ec.SECP521R1,\n    )\n    _fips_rsa_min_key_size = 2048\n    _fips_rsa_min_public_exponent = 65537\n    _fips_dsa_min_modulus = 1 << 2048\n    _fips_dh_min_key_size = 2048\n    _fips_dh_min_modulus = 1 << _fips_dh_min_key_size\n\n    def __init__(self) -> None:\n        self._binding = binding.Binding()\n        self._ffi = self._binding.ffi\n        self._lib = self._binding.lib\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def __repr__(self) -> str:\n        return (\n            f\"<OpenSSLBackend(version: {self.openssl_version_text()}, \"\n            f\"FIPS: {self._fips_enabled}, \"\n            f\"Legacy: {rust_openssl._legacy_provider_loaded})>\"\n        )\n\n    def openssl_assert(self, ok: bool) -> None:\n        return binding._openssl_assert(ok)\n\n    def _enable_fips(self) -> None:\n        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that\n        # have the FIPS provider installed properly.\n        rust_openssl.enable_fips(rust_openssl._providers)\n        assert rust_openssl.is_fips_enabled()\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def openssl_version_text(self) -> str:\n        \"\"\"\n        Friendly string name of the loaded OpenSSL library. This is not\n        necessarily the same version as it was compiled against.\n\n        Example: OpenSSL 3.2.1 30 Jan 2024\n        \"\"\"\n        return rust_openssl.openssl_version_text()\n\n    def openssl_version_number(self) -> int:\n        return rust_openssl.openssl_version()\n\n    def _evp_md_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        if algorithm.name in (\"blake2b\", \"blake2s\"):\n            alg = f\"{algorithm.name}{algorithm.digest_size * 8}\".encode(\n                \"ascii\"\n            )\n        else:\n            alg = algorithm.name.encode(\"ascii\")\n\n        evp_md = self._lib.EVP_get_digestbyname(alg)\n        return evp_md\n\n    def _evp_md_non_null_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        self.openssl_assert(evp_md != self._ffi.NULL)\n        return evp_md\n\n    def hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and not isinstance(algorithm, self._fips_hashes):\n            return False\n\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        return evp_md != self._ffi.NULL\n\n    def signature_hash_supported(\n        self, algorithm: hashes.HashAlgorithm\n    ) -> bool:\n        # Dedicated check for hashing algorithm use in message digest for\n        # signatures, e.g. RSA PKCS#1 v1.5 SHA1 (sha1WithRSAEncryption).\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n        return self.hash_supported(algorithm)\n\n    def scrypt_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        else:\n            return hasattr(rust_openssl.kdf, \"derive_scrypt\")\n\n    def hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        # FIPS mode still allows SHA1 for HMAC\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return True\n\n        return self.hash_supported(algorithm)\n\n    def cipher_supported(self, cipher: CipherAlgorithm, mode: Mode) -> bool:\n        if self._fips_enabled:\n            # FIPS mode requires AES. TripleDES is disallowed/deprecated in\n            # FIPS 140-3.\n            if not isinstance(cipher, self._fips_ciphers):\n                return False\n\n        return rust_openssl.ciphers.cipher_supported(cipher, mode)\n\n    def pbkdf2_hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        return self.hmac_supported(algorithm)\n\n    def _consume_errors(self) -> list[rust_openssl.OpenSSLError]:\n        return rust_openssl.capture_error_stack()\n\n    def _bytes_to_bio(self, data: bytes) -> _MemoryBIO:\n        \"\"\"\n        Return a _MemoryBIO namedtuple of (BIO, char*).\n\n        The char* is the storage for the BIO and it must stay alive until the\n        BIO is finished with.\n        \"\"\"\n        data_ptr = self._ffi.from_buffer(data)\n        bio = self._lib.BIO_new_mem_buf(data_ptr, len(data))\n        self.openssl_assert(bio != self._ffi.NULL)\n\n        return _MemoryBIO(self._ffi.gc(bio, self._lib.BIO_free), data_ptr)\n\n    def _create_mem_bio_gc(self):\n        \"\"\"\n        Creates an empty memory BIO.\n        \"\"\"\n        bio_method = self._lib.BIO_s_mem()\n        self.openssl_assert(bio_method != self._ffi.NULL)\n        bio = self._lib.BIO_new(bio_method)\n        self.openssl_assert(bio != self._ffi.NULL)\n        bio = self._ffi.gc(bio, self._lib.BIO_free)\n        return bio\n\n    def _read_mem_bio(self, bio) -> bytes:\n        \"\"\"\n        Reads a memory BIO. This only works on memory BIOs.\n        \"\"\"\n        buf = self._ffi.new(\"char **\")\n        buf_len = self._lib.BIO_get_mem_data(bio, buf)\n        self.openssl_assert(buf_len > 0)\n        self.openssl_assert(buf[0] != self._ffi.NULL)\n        bio_data = self._ffi.buffer(buf[0], buf_len)[:]\n        return bio_data\n\n    def _oaep_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n\n        return isinstance(\n            algorithm,\n            (\n                hashes.SHA1,\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        )\n\n    def rsa_padding_supported(self, padding: AsymmetricPadding) -> bool:\n        if isinstance(padding, PKCS1v15):\n            return True\n        elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):\n            # SHA1 is permissible in MGF1 in FIPS even when SHA1 is blocked\n            # as signature algorithm.\n            if self._fips_enabled and isinstance(\n                padding._mgf._algorithm, hashes.SHA1\n            ):\n                return True\n            else:\n                return self.hash_supported(padding._mgf._algorithm)\n        elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):\n            return self._oaep_hash_supported(\n                padding._mgf._algorithm\n            ) and self._oaep_hash_supported(padding._algorithm)\n        else:\n            return False\n\n    def rsa_encryption_supported(self, padding: AsymmetricPadding) -> bool:\n        if self._fips_enabled and isinstance(padding, PKCS1v15):\n            return False\n        else:\n            return self.rsa_padding_supported(padding)\n\n    def dsa_supported(self) -> bool:\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._fips_enabled\n        )\n\n    def dsa_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if not self.dsa_supported():\n            return False\n        return self.signature_hash_supported(algorithm)\n\n    def cmac_algorithm_supported(self, algorithm) -> bool:\n        return self.cipher_supported(\n            algorithm, CBC(b\"\\x00\" * algorithm.block_size)\n        )\n\n    def _cert2ossl(self, cert: x509.Certificate) -> typing.Any:\n        data = cert.public_bytes(serialization.Encoding.DER)\n        mem_bio = self._bytes_to_bio(data)\n        x509 = self._lib.d2i_X509_bio(mem_bio.bio, self._ffi.NULL)\n        self.openssl_assert(x509 != self._ffi.NULL)\n        x509 = self._ffi.gc(x509, self._lib.X509_free)\n        return x509\n\n    def _key2ossl(self, key: PKCS12PrivateKeyTypes) -> typing.Any:\n        data = key.private_bytes(\n            serialization.Encoding.DER,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        mem_bio = self._bytes_to_bio(data)\n\n        evp_pkey = self._lib.d2i_PrivateKey_bio(\n            mem_bio.bio,\n            self._ffi.NULL,\n        )\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        return self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n    def elliptic_curve_supported(self, curve: ec.EllipticCurve) -> bool:\n        if self._fips_enabled and not isinstance(\n            curve, self._fips_ecdh_curves\n        ):\n            return False\n\n        return rust_openssl.ec.curve_supported(curve)\n\n    def elliptic_curve_signature_algorithm_supported(\n        self,\n        signature_algorithm: ec.EllipticCurveSignatureAlgorithm,\n        curve: ec.EllipticCurve,\n    ) -> bool:\n        # We only support ECDSA right now.\n        if not isinstance(signature_algorithm, ec.ECDSA):\n            return False\n\n        return self.elliptic_curve_supported(curve) and (\n            isinstance(signature_algorithm.algorithm, asym_utils.Prehashed)\n            or self.hash_supported(signature_algorithm.algorithm)\n        )\n\n    def elliptic_curve_exchange_algorithm_supported(\n        self, algorithm: ec.ECDH, curve: ec.EllipticCurve\n    ) -> bool:\n        return self.elliptic_curve_supported(curve) and isinstance(\n            algorithm, ec.ECDH\n        )\n\n    def dh_supported(self) -> bool:\n        return not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def dh_x942_serialization_supported(self) -> bool:\n        return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1\n\n    def x25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def x448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL\n            and not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def ed448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL\n            and not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ecdsa_deterministic_supported(self) -> bool:\n        return (\n            rust_openssl.CRYPTOGRAPHY_OPENSSL_320_OR_GREATER\n            and not self._fips_enabled\n        )\n\n    def _zero_data(self, data, length: int) -> None:\n        # We clear things this way because at the moment we're not\n        # sure of a better way that can guarantee it overwrites the\n        # memory of a bytearray and doesn't just replace the underlying char *.\n        for i in range(length):\n            data[i] = 0\n\n    @contextlib.contextmanager\n    def _zeroed_null_terminated_buf(self, data):\n        \"\"\"\n        This method takes bytes, which can be a bytestring or a mutable\n        buffer like a bytearray, and yields a null-terminated version of that\n        data. This is required because PKCS12_parse doesn't take a length with\n        its password char * and ffi.from_buffer doesn't provide null\n        termination. So, to support zeroing the data via bytearray we\n        need to build this ridiculous construct that copies the memory, but\n        zeroes it after use.\n        \"\"\"\n        if data is None:\n            yield self._ffi.NULL\n        else:\n            data_len = len(data)\n            buf = self._ffi.new(\"char[]\", data_len + 1)\n            self._ffi.memmove(buf, data, data_len)\n            try:\n                yield buf\n            finally:\n                # Cast to a uint8_t * so we can assign by integer\n                self._zero_data(self._ffi.cast(\"uint8_t *\", buf), data_len)\n\n    def serialize_key_and_certificates_to_pkcs12(\n        self,\n        name: bytes | None,\n        key: PKCS12PrivateKeyTypes | None,\n        cert: x509.Certificate | None,\n        cas: list[_PKCS12CATypes] | None,\n        encryption_algorithm: serialization.KeySerializationEncryption,\n    ) -> bytes:\n        password = None\n        if name is not None:\n            utils._check_bytes(\"name\", name)\n\n        assert not isinstance(encryption_algorithm, serialization.NoEncryption)\n        if isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            # PKCS12 encryption is hopeless trash and can never be fixed.\n            # OpenSSL 3 supports PBESv2, but Libre and Boring do not, so\n            # we use PBESv1 with 3DES on the older paths.\n            if rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            # At least we can set this higher than OpenSSL's default\n            pkcs12_iter = 20000\n            mac_iter = 0\n            # MAC algorithm can only be set on OpenSSL 3.0.0+\n            mac_alg = self._ffi.NULL\n            password = encryption_algorithm.password\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is serialization.PrivateFormat.PKCS12\n        ):\n            # Default to OpenSSL's defaults. Behavior will vary based on the\n            # version of OpenSSL cryptography is compiled against.\n            nid_cert = 0\n            nid_key = 0\n            # Use the default iters we use in best available\n            pkcs12_iter = 20000\n            mac_iter = 0\n            password = encryption_algorithm.password\n            keycertalg = encryption_algorithm._key_cert_algorithm\n            if keycertalg is PBES.PBESv1SHA1And3KeyTripleDESCBC:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            elif keycertalg is PBES.PBESv2SHA256AndAES256CBC:\n                if not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                    raise UnsupportedAlgorithm(\n                        \"PBESv2 is not supported by this version of OpenSSL\"\n                    )\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                assert keycertalg is None\n                # We use OpenSSL's defaults\n\n            if encryption_algorithm._hmac_hash is not None:\n                if not self._lib.Cryptography_HAS_PKCS12_SET_MAC:\n                    raise UnsupportedAlgorithm(\n                        \"Setting MAC algorithm is not supported by this \"\n                        \"version of OpenSSL.\"\n                    )\n                mac_alg = self._evp_md_non_null_from_algorithm(\n                    encryption_algorithm._hmac_hash\n                )\n                self.openssl_assert(mac_alg != self._ffi.NULL)\n            else:\n                mac_alg = self._ffi.NULL\n\n            if encryption_algorithm._kdf_rounds is not None:\n                pkcs12_iter = encryption_algorithm._kdf_rounds\n\n        else:\n            raise ValueError(\"Unsupported key encryption type\")\n\n        if cas is None or len(cas) == 0:\n            sk_x509 = self._ffi.NULL\n        else:\n            sk_x509 = self._lib.sk_X509_new_null()\n            sk_x509 = self._ffi.gc(sk_x509, self._lib.sk_X509_free)\n\n            # This list is to keep the x509 values alive until end of function\n            ossl_cas = []\n            for ca in cas:\n                if isinstance(ca, PKCS12Certificate):\n                    ca_alias = ca.friendly_name\n                    ossl_ca = self._cert2ossl(ca.certificate)\n                    if ca_alias is None:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, self._ffi.NULL, -1\n                        )\n                    else:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, ca_alias, len(ca_alias)\n                        )\n                    self.openssl_assert(res == 1)\n                else:\n                    ossl_ca = self._cert2ossl(ca)\n                ossl_cas.append(ossl_ca)\n                res = self._lib.sk_X509_push(sk_x509, ossl_ca)\n                backend.openssl_assert(res >= 1)\n\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            with self._zeroed_null_terminated_buf(name) as name_buf:\n                ossl_cert = self._cert2ossl(cert) if cert else self._ffi.NULL\n                ossl_pkey = (\n                    self._key2ossl(key) if key is not None else self._ffi.NULL\n                )\n\n                p12 = self._lib.PKCS12_create(\n                    password_buf,\n                    name_buf,\n                    ossl_pkey,\n                    ossl_cert,\n                    sk_x509,\n                    nid_key,\n                    nid_cert,\n                    pkcs12_iter,\n                    mac_iter,\n                    0,\n                )\n                if p12 == self._ffi.NULL:\n                    errors = self._consume_errors()\n                    raise ValueError(\n                        (\n                            \"Failed to create PKCS12 (does the key match the \"\n                            \"certificate?)\"\n                        ),\n                        errors,\n                    )\n\n            if (\n                self._lib.Cryptography_HAS_PKCS12_SET_MAC\n                and mac_alg != self._ffi.NULL\n            ):\n                self._lib.PKCS12_set_mac(\n                    p12,\n                    password_buf,\n                    -1,\n                    self._ffi.NULL,\n                    0,\n                    mac_iter,\n                    mac_alg,\n                )\n\n        self.openssl_assert(p12 != self._ffi.NULL)\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_PKCS12_bio(bio, p12)\n        self.openssl_assert(res > 0)\n        return self._read_mem_bio(bio)\n\n    def poly1305_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def pkcs7_supported(self) -> bool:\n        return not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n\n\nbackend = Backend()\n", "src/cryptography/hazmat/backends/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.backends.openssl.backend import backend\n\n__all__ = [\"backend\"]\n", "vectors/cryptography_vectors/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport os\nimport typing\n\nfrom cryptography_vectors.__about__ import __version__\n\n__all__ = [\n    \"__version__\",\n]\n\n\ndef open_vector_file(filename: str, mode: str) -> typing.IO:\n    base = os.path.dirname(__file__)\n    return open(os.path.join(base, filename), mode)\n", "vectors/cryptography_vectors/__about__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__all__ = [\n    \"__version__\",\n]\n\n__version__ = \"43.0.0.dev1\"\n"}