{"release.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pathlib\nimport re\nimport subprocess\n\nimport click\nimport tomllib\nfrom packaging.version import Version\n\n\ndef run(*args: str) -> None:\n    print(f\"[running] {list(args)}\")\n    subprocess.check_call(list(args))\n\n\n@click.group()\ndef cli():\n    pass\n\n\n@cli.command()\ndef release() -> None:\n    base_dir = pathlib.Path(__file__).parent\n    with (base_dir / \"pyproject.toml\").open(\"rb\") as f:\n        pyproject = tomllib.load(f)\n        version = pyproject[\"project\"][\"version\"]\n\n    if Version(version).is_prerelease:\n        raise RuntimeError(\n            f\"Can't release, pyproject.toml version is pre-release: {version}\"\n        )\n\n    # Tag and push the tag (this will trigger the wheel builder in Actions)\n    run(\"git\", \"tag\", \"-s\", version, \"-m\", f\"{version} release\")\n    run(\"git\", \"push\", \"--tags\", \"git@github.com:pyca/cryptography.git\")\n\n\ndef replace_pattern(p: pathlib.Path, pattern: str, replacement: str) -> None:\n    content = p.read_text()\n    match = re.search(pattern, content, re.MULTILINE)\n    assert match is not None\n\n    start, end = match.span()\n    new_content = content[:start] + replacement + content[end:]\n    p.write_text(new_content)\n\n\ndef replace_version(\n    p: pathlib.Path, variable_name: str, new_version: str\n) -> None:\n    replace_pattern(\n        p, rf\"^{variable_name}\\s*=\\s*.*$\", f'{variable_name} = \"{new_version}\"'\n    )\n\n\n@cli.command()\n@click.argument(\"new_version\")\ndef bump_version(new_version: str) -> None:\n    base_dir = pathlib.Path(__file__).parent\n\n    replace_version(base_dir / \"pyproject.toml\", \"version\", new_version)\n    replace_version(\n        base_dir / \"src/cryptography/__about__.py\", \"__version__\", new_version\n    )\n    replace_version(\n        base_dir / \"vectors/pyproject.toml\",\n        \"version\",\n        new_version,\n    )\n    replace_version(\n        base_dir / \"vectors/cryptography_vectors/__about__.py\",\n        \"__version__\",\n        new_version,\n    )\n\n    if Version(new_version).is_prerelease:\n        replace_pattern(\n            base_dir / \"pyproject.toml\",\n            r'\"cryptography_vectors(==.*?)?\"',\n            '\"cryptography_vectors\"',\n        )\n    else:\n        replace_pattern(\n            base_dir / \"pyproject.toml\",\n            r'\"cryptography_vectors(==.*?)?\"',\n            f'\"cryptography_vectors=={new_version}\"',\n        )\n\n\nif __name__ == \"__main__\":\n    cli()\n", "noxfile.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport glob\nimport itertools\nimport json\nimport pathlib\nimport re\nimport sys\nimport uuid\n\nimport nox\n\ntry:\n    import tomllib\nexcept ImportError:\n    import tomli as tomllib  # type: ignore[import-not-found,no-redef]\n\nnox.options.reuse_existing_virtualenvs = True\n\n\ndef install(\n    session: nox.Session,\n    *args: str,\n    verbose: bool = True,\n) -> None:\n    if verbose:\n        args += (\"-v\",)\n    session.install(\n        \"-c\",\n        \"ci-constraints-requirements.txt\",\n        *args,\n        silent=False,\n    )\n\n\ndef load_pyproject_toml() -> dict:\n    with (pathlib.Path(__file__).parent / \"pyproject.toml\").open(\"rb\") as f:\n        return tomllib.load(f)\n\n\n@nox.session\n@nox.session(name=\"tests-ssh\")\n@nox.session(name=\"tests-randomorder\")\n@nox.session(name=\"tests-nocoverage\")\ndef tests(session: nox.Session) -> None:\n    extras = \"test\"\n    if session.name == \"tests-ssh\":\n        extras += \",ssh\"\n    if session.name == \"tests-randomorder\":\n        extras += \",test-randomorder\"\n\n    prof_location = (\n        pathlib.Path(\".\") / \".rust-cov\" / str(uuid.uuid4())\n    ).absolute()\n    if session.name != \"tests-nocoverage\":\n        session.env.update(\n            {\n                \"RUSTFLAGS\": \"-Cinstrument-coverage \"\n                + session.env.get(\"RUSTFLAGS\", \"\"),\n                \"LLVM_PROFILE_FILE\": str(prof_location / \"cov-%p.profraw\"),\n            }\n        )\n\n    install(session, f\".[{extras}]\")\n    install(session, \"-e\", \"./vectors\")\n\n    session.run(\"pip\", \"list\")\n\n    if session.name != \"tests-nocoverage\":\n        cov_args = [\n            \"--cov=cryptography\",\n            \"--cov=tests\",\n        ]\n    else:\n        cov_args = []\n\n    if session.posargs:\n        tests = session.posargs\n    else:\n        tests = [\"tests/\"]\n\n    session.run(\n        \"pytest\",\n        \"-n\",\n        \"auto\",\n        \"--dist=worksteal\",\n        *cov_args,\n        \"--durations=10\",\n        *tests,\n    )\n\n    if session.name != \"tests-nocoverage\":\n        [rust_so] = glob.glob(\n            f\"{session.virtualenv.location}/**/cryptography/hazmat/bindings/_rust.*\",\n            recursive=True,\n        )\n        process_rust_coverage(session, [rust_so], prof_location)\n\n\n@nox.session\ndef docs(session: nox.Session) -> None:\n    install(session, \".[docs,docstest,sdist,ssh]\")\n\n    temp_dir = session.create_tmp()\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"html\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"latex\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/latex\",\n    )\n\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"doctest\",\n        \"-d\",\n        f\"{temp_dir}/doctrees\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n    session.run(\n        \"sphinx-build\",\n        \"-T\",\n        \"-W\",\n        \"-b\",\n        \"spelling\",\n        \"docs\",\n        \"docs/_build/html\",\n    )\n\n    session.run(\n        \"python3\", \"-m\", \"readme_renderer\", \"README.rst\", \"-o\", \"/dev/null\"\n    )\n\n\n@nox.session(name=\"docs-linkcheck\")\ndef docs_linkcheck(session: nox.Session) -> None:\n    install(session, \".[docs]\")\n\n    session.run(\n        \"sphinx-build\", \"-W\", \"-b\", \"linkcheck\", \"docs\", \"docs/_build/html\"\n    )\n\n\n@nox.session\ndef flake(session: nox.Session) -> None:\n    # TODO: Ideally there'd be a pip flag to install just our dependencies,\n    # but not install us.\n    pyproject_data = load_pyproject_toml()\n    install(\n        session,\n        *pyproject_data[\"build-system\"][\"requires\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"pep8test\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"test\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"ssh\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"nox\"],\n    )\n    install(session, \"-e\", \"vectors/\")\n\n    session.run(\"ruff\", \"check\", \".\")\n    session.run(\"ruff\", \"format\", \"--check\", \".\")\n    session.run(\n        \"mypy\",\n        \"src/cryptography/\",\n        \"vectors/cryptography_vectors/\",\n        \"tests/\",\n        \"release.py\",\n        \"noxfile.py\",\n    )\n    session.run(\"check-sdist\", \"--no-isolation\")\n\n\n@nox.session\n@nox.session(name=\"rust-noclippy\")\ndef rust(session: nox.Session) -> None:\n    prof_location = (\n        pathlib.Path(\".\") / \".rust-cov\" / str(uuid.uuid4())\n    ).absolute()\n    session.env.update(\n        {\n            \"RUSTFLAGS\": \"-Cinstrument-coverage  \"\n            + session.env.get(\"RUSTFLAGS\", \"\"),\n            \"LLVM_PROFILE_FILE\": str(prof_location / \"cov-%p.profraw\"),\n        }\n    )\n\n    # TODO: Ideally there'd be a pip flag to install just our dependencies,\n    # but not install us.\n    pyproject_data = load_pyproject_toml()\n    install(session, *pyproject_data[\"build-system\"][\"requires\"])\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\"cargo\", \"fmt\", \"--all\", \"--\", \"--check\", external=True)\n        if session.name != \"rust-noclippy\":\n            session.run(\n                \"cargo\",\n                \"clippy\",\n                \"--all\",\n                \"--\",\n                \"-D\",\n                \"warnings\",\n                external=True,\n            )\n\n        build_output = session.run(\n            \"cargo\",\n            \"test\",\n            \"--no-default-features\",\n            \"--all\",\n            \"--no-run\",\n            \"-q\",\n            \"--message-format=json\",\n            external=True,\n            silent=True,\n        )\n        session.run(\n            \"cargo\", \"test\", \"--no-default-features\", \"--all\", external=True\n        )\n\n    # It's None on install-only invocations\n    if build_output is not None:\n        assert isinstance(build_output, str)\n        rust_tests = []\n        for line in build_output.splitlines():\n            data = json.loads(line)\n            if data.get(\"profile\", {}).get(\"test\", False):\n                rust_tests.extend(data[\"filenames\"])\n\n        process_rust_coverage(session, rust_tests, prof_location)\n\n\n@nox.session(venv_backend=\"uv\")\ndef local(session):\n    pyproject_data = load_pyproject_toml()\n    test_dependencies = pyproject_data[\"project\"][\"optional-dependencies\"][\n        \"test\"\n    ]\n    test_dependencies.remove(\"cryptography_vectors\")\n    install(\n        session,\n        *pyproject_data[\"build-system\"][\"requires\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"pep8test\"],\n        *test_dependencies,\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"ssh\"],\n        *pyproject_data[\"project\"][\"optional-dependencies\"][\"nox\"],\n        \"./vectors/\",\n        verbose=False,\n    )\n\n    session.run(\"ruff\", \"format\", \".\")\n    session.run(\"ruff\", \"check\", \".\")\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\"cargo\", \"fmt\", \"--all\", external=True)\n        session.run(\"cargo\", \"check\", \"--all\", \"--tests\", external=True)\n        session.run(\n            \"cargo\",\n            \"clippy\",\n            \"--all\",\n            \"--\",\n            \"-D\",\n            \"warnings\",\n            external=True,\n        )\n\n    session.run(\n        \"mypy\",\n        \"src/cryptography/\",\n        \"vectors/cryptography_vectors/\",\n        \"tests/\",\n        \"release.py\",\n        \"noxfile.py\",\n    )\n\n    install(\n        session,\n        # Needed until https://github.com/astral-sh/uv/issues/2152 is fixed\n        \"--reinstall-package\",\n        \"cryptography\",\n        \"--refresh-package\",\n        \"cryptography\",\n        \".\",\n    )\n\n    if session.posargs:\n        tests = session.posargs\n    else:\n        tests = [\"tests/\"]\n\n    session.run(\n        \"pytest\",\n        \"-n\",\n        \"auto\",\n        \"--dist=worksteal\",\n        \"--durations=10\",\n        *tests,\n    )\n\n    with session.chdir(\"src/rust/\"):\n        session.run(\n            \"cargo\", \"test\", \"--no-default-features\", \"--all\", external=True\n        )\n\n\nLCOV_SOURCEFILE_RE = re.compile(\n    r\"^SF:.*[\\\\/]src[\\\\/]rust[\\\\/](.*)$\", flags=re.MULTILINE\n)\nBIN_EXT = \".exe\" if sys.platform == \"win32\" else \"\"\n\n\ndef process_rust_coverage(\n    session: nox.Session,\n    rust_binaries: list[str],\n    prof_raw_location: pathlib.Path,\n) -> None:\n    # Hitting weird issues merging Windows and Linux Rust coverage, so just\n    # say the hell with it.\n    if sys.platform == \"win32\":\n        return\n\n    target_libdir = session.run(\n        \"rustc\", \"--print\", \"target-libdir\", external=True, silent=True\n    )\n    if target_libdir is not None:\n        target_bindir = pathlib.Path(target_libdir).parent / \"bin\"\n\n        profraws = [\n            str(prof_raw_location / p)\n            for p in prof_raw_location.glob(\"*.profraw\")\n        ]\n        session.run(\n            str(target_bindir / (\"llvm-profdata\" + BIN_EXT)),\n            \"merge\",\n            \"-sparse\",\n            *profraws,\n            \"-o\",\n            \"rust-cov.profdata\",\n            external=True,\n        )\n\n        lcov_data = session.run(\n            str(target_bindir / (\"llvm-cov\" + BIN_EXT)),\n            \"export\",\n            rust_binaries[0],\n            *itertools.chain.from_iterable(\n                [\"-object\", b] for b in rust_binaries[1:]\n            ),\n            \"-instr-profile=rust-cov.profdata\",\n            \"--ignore-filename-regex=[/\\\\].cargo[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\]rustc[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\].rustup[/\\\\]toolchains[/\\\\]\",\n            \"--ignore-filename-regex=[/\\\\]target[/\\\\]\",\n            \"--format=lcov\",\n            silent=True,\n            external=True,\n        )\n        assert isinstance(lcov_data, str)\n        lcov_data = LCOV_SOURCEFILE_RE.sub(\n            lambda m: \"SF:src/rust/\" + m.group(1).replace(\"\\\\\", \"/\"),\n            lcov_data.replace(\"\\r\\n\", \"\\n\"),\n        )\n        with open(f\"{uuid.uuid4()}.lcov\", \"w\") as f:\n            f.write(lcov_data)\n", ".github/compare_benchmarks.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport json\nimport sys\n\n\ndef bench_data_as_dict(data):\n    return {d[\"fullname\"]: d[\"stats\"] for d in data[\"benchmarks\"]}\n\n\ndef main(base_bench_path, pr_bench_path):\n    with open(base_bench_path) as f:\n        base_bench_data = bench_data_as_dict(json.load(f))\n    with open(pr_bench_path) as f:\n        pr_bench_data = bench_data_as_dict(json.load(f))\n\n    print(\"| Benchmark | Base | PR | Delta |\")\n    print(\"| --------- | ---- | -- | ----- |\")\n    for bench_name in sorted(base_bench_data):\n        # TODO: use better statistics than just comparing medians\n        base_result = base_bench_data[bench_name][\"median\"]\n        pr_result = pr_bench_data[bench_name][\"median\"]\n\n        if base_result == pr_result:\n            # PR and base are identical\n            delta = \"--\"\n        elif base_result > pr_result:\n            # PR is faster than base\n            delta = f\"{100 - round(100 * pr_result / base_result)}% faster\"\n        else:\n            delta = f\"{100 - round(100 * base_result / pr_result)}% slower\"\n\n        print(\n            f\"| `{bench_name}` | {round(base_result * 1000 * 1000 * 1000, 2)} \"\n            f\"ns | {round(pr_result * 1000 * 1000 * 1000, 2)} ns | {delta} |\"\n        )\n\n\nif __name__ == \"__main__\":\n    main(*sys.argv[1:])\n", "docs/conf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n# Cryptography documentation build configuration file, created by\n# sphinx-quickstart on Tue Aug  6 19:19:14 2013.\n#\n# This file is execfile()d with the current directory set to its containing dir\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport os\nimport sys\n\ntry:\n    import sphinx_rtd_theme\nexcept ImportError:\n    sphinx_rtd_theme = None\n\ntry:\n    from sphinxcontrib import spelling\nexcept ImportError:\n    spelling = None\n\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath(\"_ext\"))\n\n# -- General configuration ----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions  coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.autosectionlabel\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.linkcode\",\n    \"cryptography-docs\",\n    \"sphinx_rtd_theme\",\n]\n\nif spelling is not None:\n    extensions.append(\"sphinxcontrib.spelling\")\n\n# Linkcode resolver\nfrom linkcode_res import linkcode_resolve  # noqa: E402, F401\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\nnitpicky = True\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"Cryptography\"\ncopyright = \"2013-2024, Individual Contributors\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n\nbase_dir = os.path.join(os.path.dirname(__file__), os.pardir)\nabout = {}\nwith open(os.path.join(base_dir, \"src\", \"cryptography\", \"__about__.py\")) as f:\n    exec(f.read(), about)\n\nversion = release = about[\"__version__\"]\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all documents\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# -- Options for HTML output --------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nif sphinx_rtd_theme:\n    html_theme = \"sphinx_rtd_theme\"\nelse:\n    html_theme = \"default\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"Cryptographydoc\"\n\n\n# -- Options for LaTeX output -------------------------------------------------\n\nlatex_elements = {}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual])\nlatex_documents = [\n    (\n        \"index\",\n        \"Cryptography.tex\",\n        \"Cryptography Documentation\",\n        \"Individual Contributors\",\n        \"manual\",\n    ),\n]\n\n# -- Options for manual page output -------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\n        \"index\",\n        \"cryptography\",\n        \"Cryptography Documentation\",\n        [\"Individual Contributors\"],\n        1,\n    )\n]\n\n# -- Options for Texinfo output -----------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        \"Cryptography\",\n        \"Cryptography Documentation\",\n        \"Individual Contributors\",\n        \"Cryptography\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\n\nepub_theme = \"epub\"\n\n# Retry requests in the linkcheck builder so that we're resillient against\n# transient network errors.\nlinkcheck_retries = 10\n\nlinkcheck_timeout = 5\n\nlinkcheck_ignore = [\n    # Insecure renegotiation settings\n    r\"https://info.isl.ntt.co.jp/crypt/eng/camellia/\",\n    # Cloudflare returns 403s for all non-browser requests\n    r\"https://speakerdeck.com\",\n    r\"https://\\w+.stackexchange.com\",\n    r\"https://stackoverflow.com\",\n    # GitHub changed how they do page renders so anchor detection\n    # no longer works in source view\n    r\"https://github.com/.*/blob/.*#L\\d+\",\n    # Kuleuven struggles with the endless forward march of time\n    r\"https://www.cosic.esat.kuleuven.be\",\n]\n\nautosectionlabel_prefix_document = True\n", "docs/development/custom-vectors/rsa-oaep-sha2/generate_rsa_oaep_sha2.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport itertools\nimport os\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import padding, rsa\nfrom tests.utils import load_pkcs1_vectors, load_vectors_from_file\n\n\ndef build_vectors(mgf1alg, hashalg, filename):\n    vectors = load_vectors_from_file(filename, load_pkcs1_vectors)\n\n    output = []\n    for vector in vectors:\n        # RSA keys for this must be long enough to accommodate the length of\n        # the underlying hash function. This means we can't use the keys from\n        # the sha1 test vectors for sha512 tests because 1024-bit keys are too\n        # small. Instead we parse the vectors for the test cases, then\n        # generate our own 2048-bit keys for each.\n        private, _ = vector\n        skey = rsa.generate_private_key(65537, 2048)\n        pn = skey.private_numbers()\n        examples = private[\"examples\"]\n        output.append(\"# =============================================\")\n        output.append(\"# Example\")\n        output.append(\"# Public key\")\n        output.append(\"# Modulus:\")\n        output.append(format(pn.public_numbers.n, \"x\"))\n        output.append(\"# Exponent:\")\n        output.append(format(pn.public_numbers.e, \"x\"))\n        output.append(\"# Private key\")\n        output.append(\"# Modulus:\")\n        output.append(format(pn.public_numbers.n, \"x\"))\n        output.append(\"# Public exponent:\")\n        output.append(format(pn.public_numbers.e, \"x\"))\n        output.append(\"# Exponent:\")\n        output.append(format(pn.d, \"x\"))\n        output.append(\"# Prime 1:\")\n        output.append(format(pn.p, \"x\"))\n        output.append(\"# Prime 2:\")\n        output.append(format(pn.q, \"x\"))\n        output.append(\"# Prime exponent 1:\")\n        output.append(format(pn.dmp1, \"x\"))\n        output.append(\"# Prime exponent 2:\")\n        output.append(format(pn.dmq1, \"x\"))\n        output.append(\"# Coefficient:\")\n        output.append(format(pn.iqmp, \"x\"))\n        pkey = skey.public_key()\n        vectorkey = rsa.RSAPrivateNumbers(\n            p=private[\"p\"],\n            q=private[\"q\"],\n            d=private[\"private_exponent\"],\n            dmp1=private[\"dmp1\"],\n            dmq1=private[\"dmq1\"],\n            iqmp=private[\"iqmp\"],\n            public_numbers=rsa.RSAPublicNumbers(\n                e=private[\"public_exponent\"], n=private[\"modulus\"]\n            ),\n        ).private_key()\n        count = 1\n\n        for example in examples:\n            message = vectorkey.decrypt(\n                binascii.unhexlify(example[\"encryption\"]),\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                    algorithm=hashes.SHA1(),\n                    label=None,\n                ),\n            )\n            assert message == binascii.unhexlify(example[\"message\"])\n            ct = pkey.encrypt(\n                message,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=mgf1alg),\n                    algorithm=hashalg,\n                    label=None,\n                ),\n            )\n            output.append(\n                f\"# OAEP Example {count} alg={hashalg.name} \"\n                f\"mgf1={mgf1alg.name}\"\n            )\n            count += 1\n            output.append(\"# Message:\")\n            output.append(example[\"message\"].decode(\"utf-8\"))\n            output.append(\"# Encryption:\")\n            output.append(binascii.hexlify(ct).decode(\"utf-8\"))\n\n    return \"\\n\".join(output)\n\n\ndef write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\noaep_path = os.path.join(\n    \"asymmetric\", \"RSA\", \"pkcs-1v2-1d2-vec\", \"oaep-vect.txt\"\n)\nhashalgs = [\n    hashes.SHA1(),\n    hashes.SHA224(),\n    hashes.SHA256(),\n    hashes.SHA384(),\n    hashes.SHA512(),\n]\nfor hashtuple in itertools.product(hashalgs, hashalgs):\n    if isinstance(hashtuple[0], hashes.SHA1) and isinstance(\n        hashtuple[1], hashes.SHA1\n    ):\n        continue\n\n    write_file(\n        build_vectors(hashtuple[0], hashtuple[1], oaep_path),\n        f\"oaep-{hashtuple[0].name}-{hashtuple[1].name}.txt\",\n    )\n", "docs/development/custom-vectors/chacha20/generate_chacha20_overflow.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport struct\n\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import algorithms\n\n_N_BLOCKS = [1, 1.5, 2, 2.5, 3]\n_INITIAL_COUNTERS = [2**32 - 1, 2**64 - 1]\n\n\ndef _build_vectors():\n    count = 0\n    output = []\n    key = \"0\" * 64\n    nonce = \"0\" * 16\n    for blocks in _N_BLOCKS:\n        plaintext = binascii.unhexlify(\"0\" * int(128 * blocks))\n        for counter in _INITIAL_COUNTERS:\n            full_nonce = struct.pack(\"<Q\", counter) + binascii.unhexlify(nonce)\n            cipher = ciphers.Cipher(\n                algorithms.ChaCha20(binascii.unhexlify(key), full_nonce),\n                None,\n            )\n            encryptor = cipher.encryptor()\n            output.append(f\"\\nCOUNT = {count}\")\n            count += 1\n            output.append(f\"KEY = {key}\")\n            output.append(f\"NONCE = {nonce}\")\n            output.append(f\"INITIAL_BLOCK_COUNTER = {counter}\")\n            output.append(f\"PLAINTEXT = {binascii.hexlify(plaintext)}\")\n            output.append(\n                f\"CIPHERTEXT = {binascii.hexlify(encryptor.update(plaintext))}\"\n            )\n    return \"\\n\".join(output)\n\n\ndef _write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\nif __name__ == \"__main__\":\n    _write_file(_build_vectors(), \"counter-overflow.txt\")\n", "docs/development/custom-vectors/chacha20/verify_chacha20_overflow.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport math\nimport struct\nfrom pathlib import Path\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms\nfrom tests.utils import load_nist_vectors\n\nBLOCK_SIZE = 64\nMAX_COUNTER = 2**64 - 1\n\n\ndef encrypt(\n    key: bytes, nonce: bytes, initial_block_counter: int, plaintext: bytes\n) -> bytes:\n    full_nonce = struct.pack(\"<Q\", initial_block_counter) + nonce\n    encryptor = Cipher(\n        algorithms.ChaCha20(key, full_nonce), mode=None\n    ).encryptor()\n\n    plaintext_len_blocks = math.ceil(len(plaintext) / BLOCK_SIZE)\n    blocks_until_overflow = MAX_COUNTER - initial_block_counter + 1\n\n    if plaintext_len_blocks <= blocks_until_overflow:\n        return binascii.hexlify(encryptor.update(plaintext))\n    else:\n        bytes_until_overflow = min(blocks_until_overflow * 64, len(plaintext))\n        first_batch = binascii.hexlify(\n            encryptor.update(plaintext[:bytes_until_overflow])\n        )\n        # We manually handle the overflow by resetting the counter to zero once\n        # we surpass MAX_COUNTER blocks. This way we can check the vectors are\n        # correct without relying on the same logic that generated them.\n        full_nonce = struct.pack(\"<Q\", 0) + nonce\n        encryptor = Cipher(\n            algorithms.ChaCha20(key, full_nonce), mode=None\n        ).encryptor()\n        second_batch = binascii.hexlify(\n            encryptor.update(plaintext[bytes_until_overflow:])\n        )\n        return first_batch + second_batch\n\n\ndef verify_vectors(filename: Path):\n    with open(filename) as f:\n        vector_file = f.read().splitlines()\n\n    vectors = load_nist_vectors(vector_file)\n    for vector in vectors:\n        key = binascii.unhexlify(vector[\"key\"])\n        nonce = binascii.unhexlify(vector[\"nonce\"])\n        ibc = int(vector[\"initial_block_counter\"])\n        pt = binascii.unhexlify(vector[\"plaintext\"])\n\n        computed_ct = encrypt(key, nonce, ibc, pt)\n\n        assert computed_ct == vector[\"ciphertext\"]\n\n\noverflow_path = Path(\n    \"vectors/cryptography_vectors/ciphers/ChaCha20/counter-overflow.txt\"\n)\nverify_vectors(overflow_path)\n", "docs/development/custom-vectors/arc4/generate_arc4.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import algorithms\n\n_RFC6229_KEY_MATERIALS = [\n    (\n        True,\n        8 * \"0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f20\",\n    ),\n    (\n        False,\n        8 * \"1ada31d5cf688221c109163908ebe51debb46227c6cc8b37641910833222772a\",\n    ),\n]\n\n\n_RFC6229_OFFSETS = [\n    0,\n    16,\n    240,\n    256,\n    496,\n    512,\n    752,\n    768,\n    1008,\n    1024,\n    1520,\n    1536,\n    2032,\n    2048,\n    3056,\n    3072,\n    4080,\n    4096,\n]\n\n\n_SIZES_TO_GENERATE = [160]\n\n\ndef _key_for_size(size, keyinfo):\n    msb, key = keyinfo\n    if msb:\n        return key[: size // 4]\n    else:\n        return key[-size // 4 :]\n\n\ndef _build_vectors():\n    count = 0\n    output = []\n    key = None\n    plaintext = binascii.unhexlify(32 * \"0\")\n    for size in _SIZES_TO_GENERATE:\n        for keyinfo in _RFC6229_KEY_MATERIALS:\n            key = _key_for_size(size, keyinfo)\n            cipher = ciphers.Cipher(\n                algorithms.ARC4(binascii.unhexlify(key)),\n                None,\n            )\n            encryptor = cipher.encryptor()\n            current_offset = 0\n            for offset in _RFC6229_OFFSETS:\n                if offset % 16 != 0:\n                    raise ValueError(\n                        f\"Offset {offset} is not evenly divisible by 16\"\n                    )\n                while current_offset < offset:\n                    encryptor.update(plaintext)\n                    current_offset += len(plaintext)\n                output.append(f\"\\nCOUNT = {count}\")\n                count += 1\n                output.append(f\"KEY = {key}\")\n                output.append(f\"OFFSET = {offset}\")\n                output.append(f\"PLAINTEXT = {binascii.hexlify(plaintext)}\")\n                output.append(\n                    f\"CIPHERTEXT = \"\n                    f\"{binascii.hexlify(encryptor.update(plaintext))}\"\n                )\n                current_offset += len(plaintext)\n            assert not encryptor.finalize()\n    return \"\\n\".join(output)\n\n\ndef _write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\nif __name__ == \"__main__\":\n    _write_file(_build_vectors(), \"arc4.txt\")\n", "docs/development/custom-vectors/seed/generate_seed.py": "import binascii\n\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\n\ndef encrypt(mode, key, iv, plaintext):\n    cipher = base.Cipher(\n        algorithms.SEED(binascii.unhexlify(key)),\n        mode(binascii.unhexlify(iv)),\n    )\n    encryptor = cipher.encryptor()\n    ct = encryptor.update(binascii.unhexlify(plaintext))\n    ct += encryptor.finalize()\n    return binascii.hexlify(ct)\n\n\ndef build_vectors(mode, filename):\n    with open(filename) as f:\n        vector_file = f.read().splitlines()\n\n    count = 0\n    output = []\n    key = None\n    iv = None\n    plaintext = None\n    for line in vector_file:\n        line = line.strip()\n        if line.startswith(\"KEY\"):\n            if count != 0:\n                output.append(\n                    f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\"\n                )\n            output.append(f\"\\nCOUNT = {count}\")\n            count += 1\n            _, key = line.split(\" = \")\n            output.append(f\"KEY = {key}\")\n        elif line.startswith(\"IV\"):\n            _, iv = line.split(\" = \")\n            output.append(f\"IV = {iv}\")\n        elif line.startswith(\"PLAINTEXT\"):\n            _, plaintext = line.split(\" = \")\n            output.append(f\"PLAINTEXT = {plaintext}\")\n\n    output.append(f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\")\n    return \"\\n\".join(output)\n\n\ndef write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\nOFB_PATH = \"vectors/cryptography_vectors/ciphers/AES/OFB/OFBMMT128.rsp\"\nwrite_file(build_vectors(modes.OFB, OFB_PATH), \"seed-ofb.txt\")\nCFB_PATH = \"vectors/cryptography_vectors/ciphers/AES/CFB/CFB128MMT128.rsp\"\nwrite_file(build_vectors(modes.CFB, CFB_PATH), \"seed-cfb.txt\")\n", "docs/development/custom-vectors/seed/verify_seed.py": "import binascii\n\nimport botan\n\nfrom tests.utils import load_nist_vectors\n\n\ndef encrypt(mode, key, iv, plaintext):\n    encryptor = botan.Cipher(\n        f\"SEED/{mode}/NoPadding\", \"encrypt\", binascii.unhexlify(key)\n    )\n\n    cipher_text = encryptor.cipher(\n        binascii.unhexlify(plaintext), binascii.unhexlify(iv)\n    )\n    return binascii.hexlify(cipher_text)\n\n\ndef verify_vectors(mode, filename):\n    with open(filename) as f:\n        vector_file = f.read().splitlines()\n\n    vectors = load_nist_vectors(vector_file)\n    for vector in vectors:\n        ct = encrypt(mode, vector[\"key\"], vector[\"iv\"], vector[\"plaintext\"])\n        assert ct == vector[\"ciphertext\"]\n\n\nofb_path = \"vectors/cryptography_vectors/ciphers/SEED/seed-ofb.txt\"\nverify_vectors(\"OFB\", ofb_path)\ncfb_path = \"vectors/cryptography_vectors/ciphers/SEED/seed-cfb.txt\"\nverify_vectors(\"CFB\", cfb_path)\n", "docs/development/custom-vectors/aes-192-gcm-siv/generate_aes192gcmsiv.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nfrom cryptography.hazmat.primitives.ciphers.aead import AESGCMSIV\n\n\ndef convert_key_to_192_bits(key: str) -> str:\n    \"\"\"\n    This takes existing 128 and 256-bit keys from test vectors from OpenSSL\n    and makes them 192-bit by either appending 0 or truncating the key.\n    \"\"\"\n    new_key = binascii.unhexlify(key)\n    if len(new_key) == 16:\n        new_key += b\"\\x00\" * 8\n    elif len(new_key) == 32:\n        new_key = new_key[0:24]\n    else:\n        raise RuntimeError(\n            \"Unexpected key length. OpenSSL AES-GCM-SIV test vectors only \"\n            \"contain 128-bit and 256-bit keys\"\n        )\n\n    return binascii.hexlify(new_key).decode(\"ascii\")\n\n\ndef encrypt(key: str, iv: str, plaintext: str, aad: str) -> (str, str):\n    aesgcmsiv = AESGCMSIV(binascii.unhexlify(key))\n    encrypted_output = aesgcmsiv.encrypt(\n        binascii.unhexlify(iv),\n        binascii.unhexlify(plaintext),\n        binascii.unhexlify(aad) if aad else None,\n    )\n    ciphertext, tag = encrypted_output[:-16], encrypted_output[-16:]\n\n    return (\n        binascii.hexlify(ciphertext).decode(\"ascii\"),\n        binascii.hexlify(tag).decode(\"ascii\"),\n    )\n\n\ndef build_vectors(filename):\n    count = 0\n    output = []\n    key = None\n    iv = None\n    aad = None\n    plaintext = None\n\n    with open(filename) as vector_file:\n        for line in vector_file:\n            line = line.strip()\n            if line.startswith(\"Key\"):\n                if count != 0:\n                    ciphertext, tag = encrypt(key, iv, plaintext, aad)\n                    output.append(f\"Tag = {tag}\\nCiphertext = {ciphertext}\\n\")\n                output.append(f\"\\nCOUNT = {count}\")\n                count += 1\n                aad = None\n                _, key = line.split(\" = \")\n                key = convert_key_to_192_bits(key)\n                output.append(f\"Key = {key}\")\n            elif line.startswith(\"IV\"):\n                _, iv = line.split(\" = \")\n                output.append(f\"IV = {iv}\")\n            elif line.startswith(\"AAD\"):\n                _, aad = line.split(\" = \")\n                output.append(f\"AAD = {aad}\")\n            elif line.startswith(\"Plaintext\"):\n                _, plaintext = line.split(\" = \")\n                output.append(f\"Plaintext = {plaintext}\")\n\n        ciphertext, tag = encrypt(key, iv, plaintext, aad)\n        output.append(f\"Tag = {tag}\\nCiphertext = {ciphertext}\\n\")\n        return \"\\n\".join(output)\n\n\ndef write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\npath = \"vectors/cryptography_vectors/ciphers/AES/GCM-SIV/openssl.txt\"\nwrite_file(build_vectors(path), \"aes-192-gcm-siv.txt\")\n", "docs/development/custom-vectors/hkdf/generate_hkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\n\nIKM = binascii.unhexlify(b\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\")\nL = 1200\nOKM = HKDF(\n    algorithm=hashes.SHA256(),\n    length=L,\n    salt=None,\n    info=None,\n).derive(IKM)\n\n\ndef _build_vectors():\n    output = [\n        \"COUNT = 0\",\n        \"Hash = SHA-256\",\n        \"IKM = \" + binascii.hexlify(IKM).decode(\"ascii\"),\n        \"salt = \",\n        \"info = \",\n        f\"L = {L}\",\n        \"OKM = \" + binascii.hexlify(OKM).decode(\"ascii\"),\n    ]\n    return \"\\n\".join(output)\n\n\ndef _write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\nif __name__ == \"__main__\":\n    _write_file(_build_vectors(), \"hkdf.txt\")\n", "docs/development/custom-vectors/cast5/generate_cast5.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\n\ndef encrypt(mode, key, iv, plaintext):\n    cipher = base.Cipher(\n        algorithms.CAST5(binascii.unhexlify(key)),\n        mode(binascii.unhexlify(iv)),\n    )\n    encryptor = cipher.encryptor()\n    ct = encryptor.update(binascii.unhexlify(plaintext))\n    ct += encryptor.finalize()\n    return binascii.hexlify(ct)\n\n\ndef build_vectors(mode, filename):\n    count = 0\n    output = []\n    key = None\n    iv = None\n    plaintext = None\n\n    with open(filename) as vector_file:\n        for line in vector_file:\n            line = line.strip()\n            if line.startswith(\"KEY\"):\n                if count != 0:\n                    output.append(\n                        f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\"\n                    )\n                output.append(f\"\\nCOUNT = {count}\")\n                count += 1\n                _, key = line.split(\" = \")\n                output.append(f\"KEY = {key}\")\n            elif line.startswith(\"IV\"):\n                _, iv = line.split(\" = \")\n                iv = iv[0:16]\n                output.append(f\"IV = {iv}\")\n            elif line.startswith(\"PLAINTEXT\"):\n                _, plaintext = line.split(\" = \")\n                output.append(f\"PLAINTEXT = {plaintext}\")\n        output.append(f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\")\n    return \"\\n\".join(output)\n\n\ndef write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\ncbc_path = \"tests/hazmat/primitives/vectors/ciphers/AES/CBC/CBCMMT128.rsp\"\nwrite_file(build_vectors(modes.CBC, cbc_path), \"cast5-cbc.txt\")\nofb_path = \"tests/hazmat/primitives/vectors/ciphers/AES/OFB/OFBMMT128.rsp\"\nwrite_file(build_vectors(modes.OFB, ofb_path), \"cast5-ofb.txt\")\ncfb_path = \"tests/hazmat/primitives/vectors/ciphers/AES/CFB/CFB128MMT128.rsp\"\nwrite_file(build_vectors(modes.CFB, cfb_path), \"cast5-cfb.txt\")\nctr_path = \"tests/hazmat/primitives/vectors/ciphers/AES/CTR/aes-128-ctr.txt\"\nwrite_file(build_vectors(modes.CTR, ctr_path), \"cast5-ctr.txt\")\n", "docs/development/custom-vectors/secp256k1/verify_secp256k1.py": "import os\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric.utils import (\n    encode_dss_signature,\n)\nfrom tests.utils import load_fips_ecdsa_signing_vectors, load_vectors_from_file\n\nCRYPTOGRAPHY_HASH_TYPES = {\n    \"SHA-1\": hashes.SHA1,\n    \"SHA-224\": hashes.SHA224,\n    \"SHA-256\": hashes.SHA256,\n    \"SHA-384\": hashes.SHA384,\n    \"SHA-512\": hashes.SHA512,\n}\n\n\ndef verify_one_vector(vector):\n    digest_algorithm = vector[\"digest_algorithm\"]\n    message = vector[\"message\"]\n    x = vector[\"x\"]\n    y = vector[\"y\"]\n    signature = encode_dss_signature(vector[\"r\"], vector[\"s\"])\n\n    numbers = ec.EllipticCurvePublicNumbers(x, y, ec.SECP256K1())\n\n    key = numbers.public_key()\n\n    verifier = key.verifier(\n        signature, ec.ECDSA(CRYPTOGRAPHY_HASH_TYPES[digest_algorithm]())\n    )\n    verifier.update(message)\n    verifier.verify()\n\n\ndef verify_vectors(vectors):\n    for vector in vectors:\n        verify_one_vector(vector)\n\n\nvector_path = os.path.join(\"asymmetric\", \"ECDSA\", \"SECP256K1\", \"SigGen.txt\")\n\nsecp256k1_vectors = load_vectors_from_file(\n    vector_path, load_fips_ecdsa_signing_vectors\n)\n\nverify_vectors(secp256k1_vectors)\n", "docs/development/custom-vectors/secp256k1/generate_secp256k1.py": "import hashlib\nimport os\nfrom binascii import hexlify\nfrom collections import defaultdict\n\nfrom ecdsa import SECP256k1, SigningKey\nfrom ecdsa.util import sigdecode_der, sigencode_der\n\nfrom cryptography_vectors import open_vector_file\nfrom tests.utils import load_fips_ecdsa_signing_vectors, load_vectors_from_file\n\nHASHLIB_HASH_TYPES = {\n    \"SHA-1\": hashlib.sha1,\n    \"SHA-224\": hashlib.sha224,\n    \"SHA-256\": hashlib.sha256,\n    \"SHA-384\": hashlib.sha384,\n    \"SHA-512\": hashlib.sha512,\n}\n\n\nclass TruncatedHash:\n    def __init__(self, hasher):\n        self.hasher = hasher\n\n    def __call__(self, data):\n        self.hasher.update(data)\n        return self\n\n    def digest(self):\n        return self.hasher.digest()[: 256 // 8]\n\n\ndef build_vectors(fips_vectors):\n    vectors = defaultdict(list)\n    for vector in fips_vectors:\n        vectors[vector[\"digest_algorithm\"]].append(vector[\"message\"])\n\n    for digest_algorithm, messages in vectors.items():\n        if digest_algorithm not in HASHLIB_HASH_TYPES:\n            continue\n\n        yield \"\"\n        yield f\"[K-256,{digest_algorithm}]\"\n        yield \"\"\n\n        for message in messages:\n            # Make a hash context\n            hash_func = TruncatedHash(HASHLIB_HASH_TYPES[digest_algorithm]())\n\n            # Sign the message using warner/ecdsa\n            secret_key = SigningKey.generate(curve=SECP256k1)\n            public_key = secret_key.get_verifying_key()\n            signature = secret_key.sign(\n                message, hashfunc=hash_func, sigencode=sigencode_der\n            )\n\n            r, s = sigdecode_der(signature, None)\n\n            yield f\"Msg = {hexlify(message)}\"\n            yield f\"d = {secret_key.privkey.secret_multiplier:x}\"\n            yield f\"Qx = {public_key.pubkey.point.x():x}\"\n            yield f\"Qy = {public_key.pubkey.point.y():x}\"\n            yield f\"R = {r:x}\"\n            yield f\"S = {s:x}\"\n            yield \"\"\n\n\ndef write_file(lines, dest):\n    for line in lines:\n        print(line)\n        print(line, file=dest)\n\n\nsource_path = os.path.join(\"asymmetric\", \"ECDSA\", \"FIPS_186-3\", \"SigGen.txt\")\ndest_path = os.path.join(\"asymmetric\", \"ECDSA\", \"SECP256K1\", \"SigGen.txt\")\n\nfips_vectors = load_vectors_from_file(\n    source_path, load_fips_ecdsa_signing_vectors\n)\n\nwith open_vector_file(dest_path, \"w\") as dest_file:\n    write_file(build_vectors(fips_vectors), dest_file)\n", "docs/development/custom-vectors/idea/verify_idea.py": "import binascii\n\nimport botan\n\nfrom tests.utils import load_nist_vectors\n\nBLOCK_SIZE = 64\n\n\ndef encrypt(mode, key, iv, plaintext):\n    encryptor = botan.Cipher(\n        f\"IDEA/{mode}/NoPadding\", \"encrypt\", binascii.unhexlify(key)\n    )\n\n    cipher_text = encryptor.cipher(\n        binascii.unhexlify(plaintext), binascii.unhexlify(iv)\n    )\n    return binascii.hexlify(cipher_text)\n\n\ndef verify_vectors(mode, filename):\n    with open(filename) as f:\n        vector_file = f.read().splitlines()\n\n    vectors = load_nist_vectors(vector_file)\n    for vector in vectors:\n        ct = encrypt(mode, vector[\"key\"], vector[\"iv\"], vector[\"plaintext\"])\n        assert ct == vector[\"ciphertext\"]\n\n\ncbc_path = \"tests/hazmat/primitives/vectors/ciphers/IDEA/idea-cbc.txt\"\nverify_vectors(\"CBC\", cbc_path)\nofb_path = \"tests/hazmat/primitives/vectors/ciphers/IDEA/idea-ofb.txt\"\nverify_vectors(\"OFB\", ofb_path)\ncfb_path = \"tests/hazmat/primitives/vectors/ciphers/IDEA/idea-cfb.txt\"\nverify_vectors(\"CFB\", cfb_path)\n", "docs/development/custom-vectors/idea/generate_idea.py": "import binascii\n\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\n\ndef encrypt(mode, key, iv, plaintext):\n    cipher = base.Cipher(\n        algorithms.IDEA(binascii.unhexlify(key)),\n        mode(binascii.unhexlify(iv)),\n    )\n    encryptor = cipher.encryptor()\n    ct = encryptor.update(binascii.unhexlify(plaintext))\n    ct += encryptor.finalize()\n    return binascii.hexlify(ct)\n\n\ndef build_vectors(mode, filename):\n    with open(filename) as f:\n        vector_file = f.read().splitlines()\n\n    count = 0\n    output = []\n    key = None\n    iv = None\n    plaintext = None\n    for line in vector_file:\n        line = line.strip()\n        if line.startswith(\"KEY\"):\n            if count != 0:\n                output.append(\n                    f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\"\n                )\n            output.append(f\"\\nCOUNT = {count}\")\n            count += 1\n            _, key = line.split(\" = \")\n            output.append(f\"KEY = {key}\")\n        elif line.startswith(\"IV\"):\n            _, iv = line.split(\" = \")\n            iv = iv[0:16]\n            output.append(f\"IV = {iv}\")\n        elif line.startswith(\"PLAINTEXT\"):\n            _, plaintext = line.split(\" = \")\n            output.append(f\"PLAINTEXT = {plaintext}\")\n\n    output.append(f\"CIPHERTEXT = {encrypt(mode, key, iv, plaintext)}\")\n    return \"\\n\".join(output)\n\n\ndef write_file(data, filename):\n    with open(filename, \"w\") as f:\n        f.write(data)\n\n\nCBC_PATH = \"tests/hazmat/primitives/vectors/ciphers/AES/CBC/CBCMMT128.rsp\"\nwrite_file(build_vectors(modes.CBC, CBC_PATH), \"idea-cbc.txt\")\nOFB_PATH = \"tests/hazmat/primitives/vectors/ciphers/AES/OFB/OFBMMT128.rsp\"\nwrite_file(build_vectors(modes.OFB, OFB_PATH), \"idea-ofb.txt\")\nCFB_PATH = \"tests/hazmat/primitives/vectors/ciphers/AES/CFB/CFB128MMT128.rsp\"\nwrite_file(build_vectors(modes.CFB, CFB_PATH), \"idea-cfb.txt\")\n", "docs/_ext/linkcode_res.py": "import importlib\nimport inspect\nimport os\nimport sys\n\nimport cryptography\n\n# -- Linkcode resolver -----------------------------------------------------\n\n# This is HEAVILY inspired by numpy's\n# https://github.com/numpy/numpy/blob/73fe877ff967f279d470b81ad447b9f3056c1335/doc/source/conf.py#L390\n\n# Copyright (c) 2005-2020, NumPy Developers.\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions are\n# met:\n#\n#     * Redistributions of source code must retain the above copyright\n#        notice, this list of conditions and the following disclaimer.\n#\n#     * Redistributions in binary form must reproduce the above\n#        copyright notice, this list of conditions and the following\n#        disclaimer in the documentation and/or other materials provided\n#        with the distribution.\n#\n#     * Neither the name of the NumPy Developers nor the names of any\n#        contributors may be used to endorse or promote products derived\n#        from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\ndef linkcode_resolve(domain, info):\n    \"\"\"\n    Determine the url corresponding to Python object\n    \"\"\"\n    if domain != \"py\":\n        return None\n\n    modname = info[\"module\"]\n    fullname = info[\"fullname\"]\n\n    try:\n        importlib.import_module(modname)\n    except Exception:\n        return None\n    submod = sys.modules.get(modname)\n    if submod is None:\n        return None\n\n    obj = submod\n    for part in fullname.split(\".\"):\n        try:\n            obj = getattr(obj, part)\n        except Exception:\n            return None\n\n    # strip decorators, which would resolve to the source of the decorator\n    # possibly an upstream bug in getsourcefile, bpo-1764286\n    try:\n        unwrap = inspect.unwrap\n    except AttributeError:\n        pass\n    else:\n        obj = unwrap(obj)\n\n    fn = None\n    lineno = None\n\n    try:\n        fn = inspect.getsourcefile(obj)\n    except Exception:\n        fn = None\n    if not fn:\n        return None\n\n    try:\n        source, lineno = inspect.getsourcelines(obj)\n    except Exception:\n        lineno = None\n\n    fn = os.path.relpath(fn, start=os.path.dirname(cryptography.__file__))\n\n    if lineno:\n        linespec = \"#L%d-L%d\" % (lineno, lineno + len(source) - 1)\n    else:\n        linespec = \"\"\n\n    url = \"https://github.com/pyca/cryptography/blob/%s/src/cryptography/%s%s\"\n    if \"dev\" in cryptography.__version__:\n        return url % (\"main\", fn, linespec)\n    else:\n        version = \".\".join(cryptography.__version__.split(\".\")[:2] + [\"x\"])\n        return url % (version, fn, linespec)\n", "docs/_ext/cryptography-docs.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom docutils import nodes\nfrom docutils.parsers.rst import Directive\n\nDANGER_MESSAGE = \"\"\"\nThis is a \"Hazardous Materials\" module. You should **ONLY** use it if you're\n100% absolutely sure that you know what you're doing because this module is\nfull of land mines, dragons, and dinosaurs with laser guns.\n\"\"\"\n\nDANGER_ALTERNATE = \"\"\"\n\nYou may instead be interested in :doc:`{alternate}`.\n\"\"\"\n\n\nclass HazmatDirective(Directive):\n    has_content = True\n\n    def run(self):\n        message = DANGER_MESSAGE\n        if self.content:\n            message += DANGER_ALTERNATE.format(alternate=self.content[0])\n\n        content = nodes.paragraph(\"\", message)\n        admonition_node = Hazmat(\"\\n\".join(content))\n        self.state.nested_parse(content, self.content_offset, admonition_node)\n        admonition_node.line = self.lineno\n        return [admonition_node]\n\n\nclass Hazmat(nodes.Admonition, nodes.Element):\n    pass\n\n\ndef html_visit_hazmat_node(self, node):\n    return self.visit_admonition(node, \"danger\")\n\n\ndef latex_visit_hazmat_node(self, node):\n    return self.visit_admonition(node)\n\n\ndef depart_hazmat_node(self, node):\n    return self.depart_admonition(node)\n\n\ndef setup(app):\n    app.add_node(\n        Hazmat,\n        html=(html_visit_hazmat_node, depart_hazmat_node),\n        latex=(latex_visit_hazmat_node, depart_hazmat_node),\n    )\n    app.add_directive(\"hazmat\", HazmatDirective)\n\n    return {\n        \"parallel_read_safe\": True,\n    }\n", "tests/test_cryptography_utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport enum\nimport typing\n\nimport pytest\n\nfrom cryptography import utils\n\n\nclass TestCachedProperty:\n    def test_simple(self):\n        class T:\n            @utils.cached_property\n            def t(self):\n                accesses.append(None)\n                return 14\n\n        accesses: typing.List[typing.Optional[T]] = []\n\n        assert T.t\n        t = T()\n        assert t.t == 14\n        assert len(accesses) == 1\n        assert t.t == 14\n        assert len(accesses) == 1\n\n        t = T()\n        assert t.t == 14\n        assert len(accesses) == 2\n        assert t.t == 14\n        assert len(accesses) == 2\n\n    def test_set(self):\n        class T:\n            @utils.cached_property\n            def t(self):\n                accesses.append(None)\n                return 14\n\n        accesses: typing.List[typing.Optional[T]] = []\n        t = T()\n        with pytest.raises(AttributeError):\n            t.t = None\n        assert len(accesses) == 0\n        assert t.t == 14\n        assert len(accesses) == 1\n        with pytest.raises(AttributeError):\n            t.t = None\n        assert len(accesses) == 1\n        assert t.t == 14\n        assert len(accesses) == 1\n\n\ndef test_enum():\n    class TestEnum(utils.Enum):\n        something = \"something\"\n\n    assert issubclass(TestEnum, enum.Enum)\n    assert isinstance(TestEnum.something, enum.Enum)\n    assert repr(TestEnum.something) == \"<TestEnum.something: 'something'>\"\n    assert str(TestEnum.something) == \"TestEnum.something\"\n", "tests/deprecated_module.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography import utils\n\n# This module exists to test `cryptography.utils.deprecated`\n\nDEPRECATED = 3\nutils.deprecated(\n    DEPRECATED,\n    __name__,\n    \"Test Deprecated Object\",\n    DeprecationWarning,\n    name=\"DEPRECATED\",\n)\n\nNOT_DEPRECATED = 12\n", "tests/test_meta.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport os\nimport pkgutil\nimport subprocess\nimport sys\nimport typing\n\nimport cryptography\n\n\ndef find_all_modules() -> typing.List[str]:\n    return sorted(\n        mod\n        for _, mod, _ in pkgutil.walk_packages(\n            cryptography.__path__,\n            prefix=cryptography.__name__ + \".\",\n        )\n    )\n\n\ndef test_no_circular_imports(subtests):\n    env = os.environ.copy()\n    env[\"PYTHONPATH\"] = os.pathsep.join(sys.path)\n\n    # When using pytest-cov it attempts to instrument subprocesses. This\n    # causes the memleak tests to raise exceptions.\n    # we don't need coverage so we remove the env vars.\n    env.pop(\"COV_CORE_CONFIG\", None)\n    env.pop(\"COV_CORE_DATAFILE\", None)\n    env.pop(\"COV_CORE_SOURCE\", None)\n\n    for module in find_all_modules():\n        with subtests.test():\n            argv = [sys.executable, \"-c\", f\"__import__({module!r})\"]\n            subprocess.check_call(argv, env=env)\n", "tests/test_warnings.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport sys\nimport types\nimport typing\nimport warnings\n\nimport pytest\n\nfrom cryptography.utils import deprecated\n\n\nclass TestDeprecated:\n    @typing.no_type_check\n    def test_deprecated(self, monkeypatch):\n        mod = types.ModuleType(\"TestDeprecated/test_deprecated\")\n        monkeypatch.setitem(sys.modules, mod.__name__, mod)\n        deprecated(\n            name=\"X\",\n            value=1,\n            module_name=mod.__name__,\n            message=\"deprecated message text\",\n            warning_class=DeprecationWarning,\n        )\n        mod.Y = deprecated(\n            value=2,\n            module_name=mod.__name__,\n            message=\"more deprecated text\",\n            warning_class=PendingDeprecationWarning,\n        )\n        mod = sys.modules[mod.__name__]\n        mod.Z = 3\n\n        with warnings.catch_warnings(record=True) as log:\n            warnings.simplefilter(\"always\", PendingDeprecationWarning)\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            assert mod.X == 1\n            assert mod.Y == 2\n            assert mod.Z == 3\n\n        [msg1, msg2] = log\n        assert msg1.category is DeprecationWarning\n        assert msg1.message.args == (\"deprecated message text\",)\n\n        assert msg2.category is PendingDeprecationWarning\n        assert msg2.message.args == (\"more deprecated text\",)\n\n        assert \"Y\" in dir(mod)\n\n    @typing.no_type_check\n    def test_deleting_deprecated_members(self, monkeypatch):\n        mod = types.ModuleType(\"TestDeprecated/test_deprecated\")\n        monkeypatch.setitem(sys.modules, mod.__name__, mod)\n        deprecated(\n            name=\"X\",\n            value=1,\n            module_name=mod.__name__,\n            message=\"deprecated message text\",\n            warning_class=DeprecationWarning,\n        )\n        mod.Y = deprecated(\n            value=2,\n            module_name=mod.__name__,\n            message=\"more deprecated text\",\n            warning_class=PendingDeprecationWarning,\n        )\n        mod = sys.modules[mod.__name__]\n        mod.Z = 3\n\n        with warnings.catch_warnings(record=True) as log:\n            warnings.simplefilter(\"always\", PendingDeprecationWarning)\n            warnings.simplefilter(\"always\", DeprecationWarning)\n            del mod.X\n            del mod.Y\n            del mod.Z\n\n        [msg1, msg2] = log\n        assert msg1.category is DeprecationWarning\n        assert msg1.message.args == (\"deprecated message text\",)\n\n        assert msg2.category is PendingDeprecationWarning\n        assert msg2.message.args == (\"more deprecated text\",)\n\n        assert \"X\" not in dir(mod)\n        assert \"Y\" not in dir(mod)\n        assert \"Z\" not in dir(mod)\n\n        with pytest.raises(AttributeError):\n            del mod.X\n", "tests/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport collections\nimport json\nimport os\nimport re\nimport typing\nfrom contextlib import contextmanager\n\nimport pytest\n\nimport cryptography_vectors\nfrom cryptography.exceptions import UnsupportedAlgorithm\n\nHashVector = collections.namedtuple(\"HashVector\", [\"message\", \"digest\"])\nKeyedHashVector = collections.namedtuple(\n    \"KeyedHashVector\", [\"message\", \"digest\", \"key\"]\n)\n\n\ndef check_backend_support(backend, item):\n    for mark in item.node.iter_markers(\"supported\"):\n        if not mark.kwargs[\"only_if\"](backend):\n            pytest.skip(\"{} ({})\".format(mark.kwargs[\"skip_message\"], backend))\n\n\n@contextmanager\ndef raises_unsupported_algorithm(reason):\n    with pytest.raises(UnsupportedAlgorithm) as exc_info:\n        yield exc_info\n\n    assert exc_info.value._reason == reason\n\n\nT = typing.TypeVar(\"T\")\n\n\ndef load_vectors_from_file(\n    filename, loader: typing.Callable[..., T], mode=\"r\"\n) -> T:\n    with cryptography_vectors.open_vector_file(filename, mode) as vector_file:\n        return loader(vector_file)\n\n\ndef load_nist_vectors(vector_data):\n    test_data = {}\n    data = []\n\n    for line in vector_data:\n        line = line.strip()\n\n        # Blank lines, comments, and section headers are ignored\n        if (\n            not line\n            or line.startswith(\"#\")\n            or (line.startswith(\"[\") and line.endswith(\"]\"))\n        ):\n            continue\n\n        if line.strip() == \"FAIL\":\n            test_data[\"fail\"] = True\n            continue\n\n        # Build our data using a simple Key = Value format\n        name, value = (c.strip() for c in line.split(\"=\"))\n\n        # Some tests (PBKDF2) contain \\0, which should be interpreted as a\n        # null character rather than literal.\n        value = value.replace(\"\\\\0\", \"\\0\")\n\n        # COUNT is a special token that indicates a new block of data\n        if name.upper() == \"COUNT\":\n            test_data = {}\n            data.append(test_data)\n            continue\n        # For all other tokens we simply want the name, value stored in\n        # the dictionary\n        else:\n            test_data[name.lower()] = value.encode(\"ascii\")\n\n    return data\n\n\ndef load_cryptrec_vectors(vector_data):\n    cryptrec_list = []\n\n    for line in vector_data:\n        line = line.strip()\n\n        # Blank lines and comments are ignored\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line.startswith(\"K\"):\n            key = line.split(\" : \")[1].replace(\" \", \"\").encode(\"ascii\")\n        elif line.startswith(\"P\"):\n            pt = line.split(\" : \")[1].replace(\" \", \"\").encode(\"ascii\")\n        elif line.startswith(\"C\"):\n            ct = line.split(\" : \")[1].replace(\" \", \"\").encode(\"ascii\")\n            # after a C is found the K+P+C tuple is complete\n            # there are many P+C pairs for each K\n            cryptrec_list.append(\n                {\"key\": key, \"plaintext\": pt, \"ciphertext\": ct}\n            )\n        else:\n            raise ValueError(f\"Invalid line in file '{line}'\")\n    return cryptrec_list\n\n\ndef load_hash_vectors(vector_data):\n    vectors: typing.List[typing.Union[KeyedHashVector, HashVector]] = []\n    key = None\n    msg = None\n    md = None\n\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\") or line.startswith(\"[\"):\n            continue\n\n        if line.startswith(\"Len\"):\n            length = int(line.split(\" = \")[1])\n        elif line.startswith(\"Key\"):\n            # HMAC vectors contain a key attribute. Hash vectors do not.\n            key = line.split(\" = \")[1].encode(\"ascii\")\n        elif line.startswith(\"Msg\"):\n            # In the NIST vectors they have chosen to represent an empty\n            # string as hex 00, which is of course not actually an empty\n            # string. So we parse the provided length and catch this edge case.\n            msg = line.split(\" = \")[1].encode(\"ascii\") if length > 0 else b\"\"\n        elif line.startswith(\"MD\") or line.startswith(\"Output\"):\n            md = line.split(\" = \")[1]\n            # after MD is found the Msg+MD (+ potential key) tuple is complete\n            if key is not None:\n                vectors.append(KeyedHashVector(msg, md, key))\n                key = None\n                msg = None\n                md = None\n            else:\n                vectors.append(HashVector(msg, md))\n                msg = None\n                md = None\n        else:\n            raise ValueError(\"Unknown line in hash vector\")\n    return vectors\n\n\ndef load_pkcs1_vectors(vector_data):\n    \"\"\"\n    Loads data out of RSA PKCS #1 vector files.\n    \"\"\"\n    private_key_vector: typing.Optional[typing.Dict[str, typing.Any]] = None\n    public_key_vector: typing.Optional[typing.Dict[str, typing.Any]] = None\n    attr = None\n    key: typing.Any = None\n    example_vector: typing.Optional[typing.Dict[str, typing.Any]] = None\n    examples = []\n    vectors = []\n    for line in vector_data:\n        if (\n            line.startswith(\"# PSS Example\")\n            or line.startswith(\"# OAEP Example\")\n            or line.startswith(\"# PKCS#1 v1.5\")\n        ):\n            if example_vector:\n                for key, value in example_vector.items():\n                    hex_bytes = \"\".join(value).replace(\" \", \"\").encode(\"ascii\")\n                    example_vector[key] = hex_bytes\n                examples.append(example_vector)\n\n            attr = None\n            example_vector = collections.defaultdict(list)\n\n        if line.startswith(\"# Message\"):\n            attr = \"message\"\n            continue\n        elif line.startswith(\"# Salt\"):\n            attr = \"salt\"\n            continue\n        elif line.startswith(\"# Seed\"):\n            attr = \"seed\"\n            continue\n        elif line.startswith(\"# Signature\"):\n            attr = \"signature\"\n            continue\n        elif line.startswith(\"# Encryption\"):\n            attr = \"encryption\"\n            continue\n        elif example_vector and line.startswith(\n            \"# =============================================\"\n        ):\n            for key, value in example_vector.items():\n                hex_bytes = \"\".join(value).replace(\" \", \"\").encode(\"ascii\")\n                example_vector[key] = hex_bytes\n            examples.append(example_vector)\n            example_vector = None\n            attr = None\n        elif example_vector and line.startswith(\"#\"):\n            continue\n        else:\n            if attr is not None and example_vector is not None:\n                example_vector[attr].append(line.strip())\n                continue\n\n        if line.startswith(\"# Example\") or line.startswith(\n            \"# =============================================\"\n        ):\n            if key:\n                assert private_key_vector\n                assert public_key_vector\n\n                for key, value in public_key_vector.items():\n                    hex_str = \"\".join(value).replace(\" \", \"\")\n                    public_key_vector[key] = int(hex_str, 16)\n\n                for key, value in private_key_vector.items():\n                    hex_str = \"\".join(value).replace(\" \", \"\")\n                    private_key_vector[key] = int(hex_str, 16)\n\n                private_key_vector[\"examples\"] = examples\n                examples = []\n\n                assert (\n                    private_key_vector[\"public_exponent\"]\n                    == public_key_vector[\"public_exponent\"]\n                )\n\n                assert (\n                    private_key_vector[\"modulus\"]\n                    == public_key_vector[\"modulus\"]\n                )\n\n                vectors.append((private_key_vector, public_key_vector))\n\n            public_key_vector = collections.defaultdict(list)\n            private_key_vector = collections.defaultdict(list)\n            key = None\n            attr = None\n\n        if private_key_vector is None or public_key_vector is None:\n            continue\n\n        if line.startswith(\"# Private key\"):\n            key = private_key_vector\n        elif line.startswith(\"# Public key\"):\n            key = public_key_vector\n        elif line.startswith(\"# Modulus:\"):\n            attr = \"modulus\"\n        elif line.startswith(\"# Public exponent:\"):\n            attr = \"public_exponent\"\n        elif line.startswith(\"# Exponent:\"):\n            if key is public_key_vector:\n                attr = \"public_exponent\"\n            else:\n                assert key is private_key_vector\n                attr = \"private_exponent\"\n        elif line.startswith(\"# Prime 1:\"):\n            attr = \"p\"\n        elif line.startswith(\"# Prime 2:\"):\n            attr = \"q\"\n        elif line.startswith(\"# Prime exponent 1:\"):\n            attr = \"dmp1\"\n        elif line.startswith(\"# Prime exponent 2:\"):\n            attr = \"dmq1\"\n        elif line.startswith(\"# Coefficient:\"):\n            attr = \"iqmp\"\n        elif line.startswith(\"#\"):\n            attr = None\n        else:\n            if key is not None and attr is not None:\n                key[attr].append(line.strip())\n    return vectors\n\n\ndef load_rsa_nist_vectors(vector_data):\n    test_data: typing.Dict[str, typing.Any] = {}\n    p = None\n    salt_length = None\n    data = []\n\n    for line in vector_data:\n        line = line.strip()\n\n        # Blank lines and section headers are ignored\n        if not line or line.startswith(\"[\"):\n            continue\n\n        if line.startswith(\"# Salt len:\"):\n            salt_length = int(line.split(\":\")[1].strip())\n            continue\n        elif line.startswith(\"#\"):\n            continue\n\n        # Build our data using a simple Key = Value format\n        name, value = (c.strip() for c in line.split(\"=\"))\n\n        if name == \"n\":\n            n = int(value, 16)\n        elif name == \"e\" and p is None:\n            e = int(value, 16)\n        elif name == \"p\":\n            p = int(value, 16)\n        elif name == \"q\":\n            q = int(value, 16)\n        elif name == \"SHAAlg\":\n            if p is None:\n                test_data = {\n                    \"modulus\": n,\n                    \"public_exponent\": e,\n                    \"salt_length\": salt_length,\n                    \"algorithm\": value,\n                    \"fail\": False,\n                }\n            else:\n                test_data = {\"modulus\": n, \"p\": p, \"q\": q, \"algorithm\": value}\n                if salt_length is not None:\n                    test_data[\"salt_length\"] = salt_length\n            data.append(test_data)\n        elif name == \"e\" and p is not None:\n            test_data[\"public_exponent\"] = int(value, 16)\n        elif name == \"d\":\n            test_data[\"private_exponent\"] = int(value, 16)\n        elif name == \"Result\":\n            test_data[\"fail\"] = value.startswith(\"F\")\n        # For all other tokens we simply want the name, value stored in\n        # the dictionary\n        else:\n            test_data[name.lower()] = value.encode(\"ascii\")\n\n    return data\n\n\ndef load_fips_dsa_key_pair_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS DSA KeyPair vector files.\n    \"\"\"\n    vectors = []\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\") or line.startswith(\"[mod\"):\n            continue\n\n        if line.startswith(\"P\"):\n            vectors.append({\"p\": int(line.split(\"=\")[1], 16)})\n        elif line.startswith(\"Q\"):\n            vectors[-1][\"q\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"G\"):\n            vectors[-1][\"g\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"X\") and \"x\" not in vectors[-1]:\n            vectors[-1][\"x\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"X\") and \"x\" in vectors[-1]:\n            vectors.append(\n                {\n                    \"p\": vectors[-1][\"p\"],\n                    \"q\": vectors[-1][\"q\"],\n                    \"g\": vectors[-1][\"g\"],\n                    \"x\": int(line.split(\"=\")[1], 16),\n                }\n            )\n        elif line.startswith(\"Y\"):\n            vectors[-1][\"y\"] = int(line.split(\"=\")[1], 16)\n\n    return vectors\n\n\nFIPS_SHA_REGEX = re.compile(\n    r\"\\[mod = L=...., N=..., SHA-(?P<sha>1|224|256|384|512)\\]\"\n)\n\n\ndef load_fips_dsa_sig_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS DSA SigVer vector files.\n    \"\"\"\n    vectors = []\n\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        sha_match = FIPS_SHA_REGEX.match(line)\n        if sha_match:\n            digest_algorithm = \"SHA-{}\".format(sha_match.group(\"sha\"))\n\n        if line.startswith(\"[mod\"):\n            continue\n\n        name, value = (c.strip() for c in line.split(\"=\"))\n\n        if name == \"P\":\n            vectors.append(\n                {\"p\": int(value, 16), \"digest_algorithm\": digest_algorithm}\n            )\n        elif name == \"Q\":\n            vectors[-1][\"q\"] = int(value, 16)\n        elif name == \"G\":\n            vectors[-1][\"g\"] = int(value, 16)\n        elif name == \"Msg\" and \"msg\" not in vectors[-1]:\n            hexmsg = value.strip().encode(\"ascii\")\n            vectors[-1][\"msg\"] = binascii.unhexlify(hexmsg)\n        elif name == \"Msg\" and \"msg\" in vectors[-1]:\n            hexmsg = value.strip().encode(\"ascii\")\n            vectors.append(\n                {\n                    \"p\": vectors[-1][\"p\"],\n                    \"q\": vectors[-1][\"q\"],\n                    \"g\": vectors[-1][\"g\"],\n                    \"digest_algorithm\": vectors[-1][\"digest_algorithm\"],\n                    \"msg\": binascii.unhexlify(hexmsg),\n                }\n            )\n        elif name == \"X\":\n            vectors[-1][\"x\"] = int(value, 16)\n        elif name == \"Y\":\n            vectors[-1][\"y\"] = int(value, 16)\n        elif name == \"R\":\n            vectors[-1][\"r\"] = int(value, 16)\n        elif name == \"S\":\n            vectors[-1][\"s\"] = int(value, 16)\n        elif name == \"Result\":\n            vectors[-1][\"result\"] = value.split(\"(\")[0].strip()\n\n    return vectors\n\n\n# https://tools.ietf.org/html/rfc4492#appendix-A\n_ECDSA_CURVE_NAMES = {\n    \"P-192\": \"secp192r1\",\n    \"P-224\": \"secp224r1\",\n    \"P-256\": \"secp256r1\",\n    \"P-384\": \"secp384r1\",\n    \"P-521\": \"secp521r1\",\n    \"K-163\": \"sect163k1\",\n    \"K-233\": \"sect233k1\",\n    \"K-256\": \"secp256k1\",\n    \"K-283\": \"sect283k1\",\n    \"K-409\": \"sect409k1\",\n    \"K-571\": \"sect571k1\",\n    \"B-163\": \"sect163r2\",\n    \"B-233\": \"sect233r1\",\n    \"B-283\": \"sect283r1\",\n    \"B-409\": \"sect409r1\",\n    \"B-571\": \"sect571r1\",\n}\n\n\ndef load_fips_ecdsa_key_pair_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS ECDSA KeyPair vector files.\n    \"\"\"\n    vectors = []\n    key_data = None\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line[1:-1] in _ECDSA_CURVE_NAMES:\n            curve_name = _ECDSA_CURVE_NAMES[line[1:-1]]\n\n        elif line.startswith(\"d = \"):\n            if key_data is not None:\n                vectors.append(key_data)\n\n            key_data = {\"curve\": curve_name, \"d\": int(line.split(\"=\")[1], 16)}\n\n        elif key_data is not None:\n            if line.startswith(\"Qx = \"):\n                key_data[\"x\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"Qy = \"):\n                key_data[\"y\"] = int(line.split(\"=\")[1], 16)\n\n    assert key_data is not None\n    vectors.append(key_data)\n\n    return vectors\n\n\nCURVE_REGEX = re.compile(\n    r\"\\[(?P<curve>[PKB]-[0-9]{3}),SHA-(?P<sha>1|224|256|384|512)\\]\"\n)\n\n\ndef load_fips_ecdsa_signing_vectors(vector_data):\n    \"\"\"\n    Loads data out of the FIPS ECDSA SigGen vector files.\n    \"\"\"\n    vectors = []\n\n    data: typing.Optional[typing.Dict[str, object]] = None\n    for line in vector_data:\n        line = line.strip()\n\n        curve_match = CURVE_REGEX.match(line)\n        if curve_match:\n            curve_name = _ECDSA_CURVE_NAMES[curve_match.group(\"curve\")]\n            digest_name = \"SHA-{}\".format(curve_match.group(\"sha\"))\n\n        elif line.startswith(\"Msg = \"):\n            if data is not None:\n                vectors.append(data)\n\n            hexmsg = line.split(\"=\")[1].strip().encode(\"ascii\")\n\n            data = {\n                \"curve\": curve_name,\n                \"digest_algorithm\": digest_name,\n                \"message\": binascii.unhexlify(hexmsg),\n            }\n\n        elif data is not None:\n            if line.startswith(\"Qx = \"):\n                data[\"x\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"Qy = \"):\n                data[\"y\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"R = \"):\n                data[\"r\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"S = \"):\n                data[\"s\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"d = \"):\n                data[\"d\"] = int(line.split(\"=\")[1], 16)\n            elif line.startswith(\"Result = \"):\n                data[\"fail\"] = line.split(\"=\")[1].strip()[0] == \"F\"\n\n    assert data is not None\n    vectors.append(data)\n    return vectors\n\n\nKASVS_RESULT_REGEX = re.compile(r\"([FP]) \\(([0-9]+) -\")\n\n\ndef load_kasvs_dh_vectors(vector_data):\n    \"\"\"\n    Loads data out of the KASVS key exchange vector data\n    \"\"\"\n\n    vectors = []\n    data: typing.Dict[str, typing.Any] = {\"fail_z\": False, \"fail_agree\": False}\n\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line.startswith(\"P = \"):\n            data[\"p\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"Q = \"):\n            data[\"q\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"G = \"):\n            data[\"g\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"Z = \"):\n            z_hex = line.split(\"=\")[1].strip().encode(\"ascii\")\n            data[\"z\"] = binascii.unhexlify(z_hex)\n        elif line.startswith(\"XstatCAVS = \"):\n            data[\"x1\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"YstatCAVS = \"):\n            data[\"y1\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"XstatIUT = \"):\n            data[\"x2\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"YstatIUT = \"):\n            data[\"y2\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"Result = \"):\n            result_str = line.split(\"=\")[1].strip()\n            match = KASVS_RESULT_REGEX.match(result_str)\n            assert match is not None\n\n            if match.group(1) == \"F\":\n                if int(match.group(2)) in (5, 10):\n                    data[\"fail_z\"] = True\n                else:\n                    data[\"fail_agree\"] = True\n\n            vectors.append(data)\n\n            data = {\n                \"p\": data[\"p\"],\n                \"q\": data[\"q\"],\n                \"g\": data[\"g\"],\n                \"fail_z\": False,\n                \"fail_agree\": False,\n            }\n\n    return vectors\n\n\ndef load_kasvs_ecdh_vectors(vector_data):\n    \"\"\"\n    Loads data out of the KASVS key exchange vector data\n    \"\"\"\n\n    curve_name_map = {\n        \"P-192\": \"secp192r1\",\n        \"P-224\": \"secp224r1\",\n        \"P-256\": \"secp256r1\",\n        \"P-384\": \"secp384r1\",\n        \"P-521\": \"secp521r1\",\n    }\n\n    tags = []\n    sets = {}\n    vectors = []\n\n    # find info in header\n    for line in vector_data:\n        line = line.strip()\n\n        if line.startswith(\"#\"):\n            parm = line.split(\"Parameter set(s) supported:\")\n            if len(parm) == 2:\n                names = parm[1].strip().split()\n                for n in names:\n                    tags.append(f\"[{n}]\")\n                break\n\n    # Sets Metadata\n    tag = None\n    curve = None\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line in tags:\n            tag = line\n            curve = None\n        elif line.startswith(\"[Curve selected:\"):\n            curve = curve_name_map[line.split(\":\")[1].strip()[:-1]]\n\n        if tag is not None and curve is not None:\n            sets[tag.strip(\"[]\")] = curve\n            tag = None\n        if len(tags) == len(sets):\n            break\n\n    # Data\n    data: typing.Dict[str, typing.Any] = {\n        \"CAVS\": {},\n        \"IUT\": {},\n    }\n    tag = None\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line.startswith(\"[\"):\n            tag = line.split()[0][1:]\n        elif line.startswith(\"COUNT = \"):\n            data[\"COUNT\"] = int(line.split(\"=\")[1])\n        elif line.startswith(\"dsCAVS = \"):\n            data[\"CAVS\"][\"d\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"QsCAVSx = \"):\n            data[\"CAVS\"][\"x\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"QsCAVSy = \"):\n            data[\"CAVS\"][\"y\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"dsIUT = \"):\n            data[\"IUT\"][\"d\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"QsIUTx = \"):\n            data[\"IUT\"][\"x\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"QsIUTy = \"):\n            data[\"IUT\"][\"y\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"OI = \"):\n            data[\"OI\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"Z = \"):\n            data[\"Z\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"DKM = \"):\n            data[\"DKM\"] = int(line.split(\"=\")[1], 16)\n        elif line.startswith(\"Result = \"):\n            result_str = line.split(\"=\")[1].strip()\n            match = KASVS_RESULT_REGEX.match(result_str)\n            assert match is not None\n\n            if match.group(1) == \"F\":\n                data[\"fail\"] = True\n            else:\n                data[\"fail\"] = False\n            data[\"errno\"] = int(match.group(2))\n\n            data[\"curve\"] = sets[tag]\n\n            vectors.append(data)\n\n            data = {\n                \"CAVS\": {},\n                \"IUT\": {},\n            }\n\n    return vectors\n\n\ndef load_rfc6979_vectors(vector_data):\n    \"\"\"\n    Loads data out of the ECDSA and DSA RFC6979 vector files.\n    \"\"\"\n    vectors = []\n    keys: typing.Dict[str, typing.List[str]] = dict()\n    reading_key = False\n    current_key_name = None\n\n    data: typing.Dict[str, object] = dict()\n    for line in vector_data:\n        line = line.strip()\n\n        if reading_key and current_key_name:\n            keys[current_key_name].append(line)\n            if line.startswith(\"-----END\"):\n                reading_key = False\n                current_key_name = None\n\n        if line.startswith(\"PrivateKey=\") or line.startswith(\"PublicKey=\"):\n            reading_key = True\n            current_key_name = line.split(\"=\")[1].strip()\n            keys[current_key_name] = []\n        elif line.startswith(\"DigestSign = \"):\n            data[\"digest_sign\"] = line.split(\"=\")[1].strip()\n            data[\"deterministic_nonce\"] = False\n        elif line.startswith(\"DigestVerify = \"):\n            data[\"digest_verify\"] = line.split(\"=\")[1].strip()\n            data[\"verify_error\"] = False\n        elif line.startswith(\"Key = \"):\n            key_name = line.split(\"=\")[1].strip()\n            assert key_name in keys\n            data[\"key\"] = keys[key_name]\n            data[\"key_name\"] = key_name\n        elif line.startswith(\"NonceType = \"):\n            nonce_type = line.split(\"=\")[1].strip()\n            data[\"deterministic_nonce\"] = nonce_type == \"deterministic\"\n        elif line.startswith(\"Input = \"):\n            data[\"input\"] = line.split(\"=\")[1].strip(' \"')\n        elif line.startswith(\"Output = \"):\n            data[\"output\"] = line.split(\"=\")[1].strip()\n        elif line.startswith(\"Result = \"):\n            data[\"verify_error\"] = line.split(\"=\")[1].strip() == \"VERIFY_ERROR\"\n\n        elif not line:\n            if data:\n                vectors.append(data)\n                data = {}\n\n    return vectors\n\n\ndef load_x963_vectors(vector_data):\n    \"\"\"\n    Loads data out of the X9.63 vector data\n    \"\"\"\n\n    vectors = []\n\n    # Sets Metadata\n    hashname = None\n    vector = {}\n    for line in vector_data:\n        line = line.strip()\n\n        if line.startswith(\"[SHA\"):\n            hashname = line[1:-1]\n            shared_secret_len = 0\n            shared_info_len = 0\n            key_data_len = 0\n        elif line.startswith(\"[shared secret length\"):\n            shared_secret_len = int(line[1:-1].split(\"=\")[1].strip())\n        elif line.startswith(\"[SharedInfo length\"):\n            shared_info_len = int(line[1:-1].split(\"=\")[1].strip())\n        elif line.startswith(\"[key data length\"):\n            key_data_len = int(line[1:-1].split(\"=\")[1].strip())\n        elif line.startswith(\"COUNT\"):\n            count = int(line.split(\"=\")[1].strip())\n            vector[\"hash\"] = hashname\n            vector[\"count\"] = count\n            vector[\"shared_secret_length\"] = shared_secret_len\n            vector[\"sharedinfo_length\"] = shared_info_len\n            vector[\"key_data_length\"] = key_data_len\n        elif line.startswith(\"Z\"):\n            vector[\"Z\"] = line.split(\"=\")[1].strip()\n            assert vector[\"Z\"] is not None\n            assert ((shared_secret_len + 7) // 8) * 2 == len(vector[\"Z\"])\n        elif line.startswith(\"SharedInfo\"):\n            if shared_info_len != 0:\n                vector[\"sharedinfo\"] = line.split(\"=\")[1].strip()\n                assert vector[\"sharedinfo\"] is not None\n                silen = len(vector[\"sharedinfo\"])\n                assert ((shared_info_len + 7) // 8) * 2 == silen\n        elif line.startswith(\"key_data\"):\n            vector[\"key_data\"] = line.split(\"=\")[1].strip()\n            assert vector[\"key_data\"] is not None\n            assert ((key_data_len + 7) // 8) * 2 == len(vector[\"key_data\"])\n            vectors.append(vector)\n            vector = {}\n\n    return vectors\n\n\ndef load_nist_kbkdf_vectors(vector_data):\n    \"\"\"\n    Load NIST SP 800-108 KDF Vectors\n    \"\"\"\n    vectors = []\n    test_data = None\n    tag = {}\n\n    for line in vector_data:\n        line = line.strip()\n\n        if not line or line.startswith(\"#\"):\n            continue\n\n        if line.startswith(\"[\") and line.endswith(\"]\"):\n            tag_data = line[1:-1]\n            name, value = (c.strip() for c in tag_data.split(\"=\"))\n            if value.endswith(\"_BITS\"):\n                value = int(value.split(\"_\")[0])\n                tag.update({name.lower(): value})\n                continue\n\n            tag.update({name.lower(): value.lower()})\n        elif line.startswith(\"COUNT=\"):\n            test_data = {}\n            test_data.update(tag)\n            vectors.append(test_data)\n        elif line.startswith((\"L\", \"DataBeforeCtrLen\", \"DataAfterCtrLen\")):\n            name, value = (c.strip() for c in line.split(\"=\"))\n            test_data[name.lower()] = int(value)\n        else:\n            name, value = (c.strip() for c in line.split(\"=\"))\n            test_data[name.lower()] = value.encode(\"ascii\")\n\n    return vectors\n\n\ndef load_ed25519_vectors(vector_data):\n    data = []\n    for line in vector_data:\n        secret_key, public_key, message, signature, _ = line.split(\":\")\n        # In the vectors the first element is secret key + public key\n        secret_key = secret_key[0:64]\n        # In the vectors the signature section is signature + message\n        signature = signature[0:128]\n        data.append(\n            {\n                \"secret_key\": secret_key,\n                \"public_key\": public_key,\n                \"message\": message,\n                \"signature\": signature,\n            }\n        )\n    return data\n\n\ndef load_nist_ccm_vectors(vector_data):\n    test_data = {}\n    section_data = None\n    global_data = {}\n    new_section = False\n    data = []\n\n    for line in vector_data:\n        line = line.strip()\n\n        # Blank lines and comments should be ignored\n        if not line or line.startswith(\"#\"):\n            continue\n\n        # Some of the CCM vectors have global values for this. They are always\n        # at the top before the first section header (see: VADT, VNT, VPT)\n        if line.startswith((\"Alen\", \"Plen\", \"Nlen\", \"Tlen\")):\n            name, value = (c.strip() for c in line.split(\"=\"))\n            global_data[name.lower()] = int(value)\n            continue\n\n        # section headers contain length data we might care about\n        if line.startswith(\"[\"):\n            new_section = True\n            section_data = {}\n            section = line[1:-1]\n            items = [c.strip() for c in section.split(\",\")]\n            for item in items:\n                name, value = (c.strip() for c in item.split(\"=\"))\n                section_data[name.lower()] = int(value)\n            continue\n\n        name, value = (c.strip() for c in line.split(\"=\"))\n\n        if name.lower() in (\"key\", \"nonce\") and new_section:\n            section_data[name.lower()] = value.encode(\"ascii\")\n            continue\n\n        new_section = False\n\n        # Payload is sometimes special because these vectors are absurd. Each\n        # example may or may not have a payload. If it does not then the\n        # previous example's payload should be used. We accomplish this by\n        # writing it into the section_data. Because we update each example\n        # with the section data it will be overwritten if a new payload value\n        # is present. NIST should be ashamed of their vector creation.\n        if name.lower() == \"payload\":\n            section_data[name.lower()] = value.encode(\"ascii\")\n\n        # Result is a special token telling us if the test should pass/fail.\n        # This is only present in the DVPT CCM tests\n        if name.lower() == \"result\":\n            if value.lower() == \"pass\":\n                test_data[\"fail\"] = False\n            else:\n                test_data[\"fail\"] = True\n            continue\n\n        # COUNT is a special token that indicates a new block of data\n        if name.lower() == \"count\":\n            test_data = {}\n            test_data.update(global_data)\n            test_data.update(section_data)\n            data.append(test_data)\n            continue\n        # For all other tokens we simply want the name, value stored in\n        # the dictionary\n        else:\n            test_data[name.lower()] = value.encode(\"ascii\")\n\n    return data\n\n\nclass WycheproofTest:\n    def __init__(self, testfiledata, testgroup, testcase):\n        self.testfiledata = testfiledata\n        self.testgroup = testgroup\n        self.testcase = testcase\n\n    def __repr__(self):\n        return \"<WycheproofTest({!r}, {!r}, {!r}, tcId={})>\".format(\n            self.testfiledata,\n            self.testgroup,\n            self.testcase,\n            self.testcase[\"tcId\"],\n        )\n\n    @property\n    def valid(self) -> bool:\n        return self.testcase[\"result\"] == \"valid\"\n\n    @property\n    def acceptable(self) -> bool:\n        return self.testcase[\"result\"] == \"acceptable\"\n\n    @property\n    def invalid(self) -> bool:\n        return self.testcase[\"result\"] == \"invalid\"\n\n    def has_flag(self, flag: str) -> bool:\n        return flag in self.testcase[\"flags\"]\n\n    def cache_value_to_group(self, cache_key: str, func):\n        cache_val = self.testgroup.get(cache_key)\n        if cache_val is not None:\n            return cache_val\n        self.testgroup[cache_key] = cache_val = func()\n        return cache_val\n\n\ndef load_wycheproof_tests(wycheproof, test_file, subdir):\n    path = os.path.join(wycheproof, subdir, test_file)\n    with open(path) as f:\n        data = json.load(f)\n        for group in data.pop(\"testGroups\"):\n            cases = group.pop(\"tests\")\n            for c in cases:\n                yield WycheproofTest(data, group, c)\n", "tests/doubles.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import Mode\n\n\nclass DummyCipherAlgorithm(CipherAlgorithm):\n    name = \"dummy-cipher\"\n    block_size = 128\n    key_size = 256\n    key_sizes = frozenset([256])\n\n\nclass DummyBlockCipherAlgorithm(DummyCipherAlgorithm, BlockCipherAlgorithm):\n    def __init__(self, _: object) -> None:\n        pass\n\n    name = \"dummy-block-cipher\"\n\n\nclass DummyMode(Mode):\n    name = \"dummy-mode\"\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        pass\n\n\nclass DummyHashAlgorithm(hashes.HashAlgorithm):\n    name = \"dummy-hash\"\n    block_size = None\n    digest_size = 32\n\n\nclass DummyKeySerializationEncryption(\n    serialization.KeySerializationEncryption\n):\n    pass\n\n\nclass DummyAsymmetricPadding(padding.AsymmetricPadding):\n    name = \"dummy-padding\"\n", "tests/conftest.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport contextlib\n\nimport pytest\n\nfrom cryptography.hazmat.backends.openssl import backend as openssl_backend\n\nfrom .utils import check_backend_support\n\n\ndef pytest_configure(config):\n    if config.getoption(\"--enable-fips\"):\n        openssl_backend._enable_fips()\n\n\ndef pytest_report_header(config):\n    return \"\\n\".join(\n        [\n            f\"OpenSSL: {openssl_backend.openssl_version_text()}\",\n            f\"FIPS Enabled: {openssl_backend._fips_enabled}\",\n        ]\n    )\n\n\ndef pytest_addoption(parser):\n    parser.addoption(\"--wycheproof-root\", default=None)\n    parser.addoption(\"--x509-limbo-root\", default=None)\n    parser.addoption(\"--enable-fips\", default=False)\n\n\ndef pytest_runtest_setup(item):\n    if openssl_backend._fips_enabled:\n        for marker in item.iter_markers(name=\"skip_fips\"):\n            pytest.skip(marker.kwargs[\"reason\"])\n\n\n@pytest.fixture(autouse=True)\ndef backend(request):\n    check_backend_support(openssl_backend, request)\n\n    # Ensure the error stack is clear before the test\n    errors = openssl_backend._consume_errors()\n    assert not errors\n    yield openssl_backend\n    # Ensure the error stack is clear after the test\n    errors = openssl_backend._consume_errors()\n    assert not errors\n\n\n@pytest.fixture()\ndef subtests():\n    # This is a miniature version of the pytest-subtests package, but\n    # optimized for lower overhead.\n    #\n    # When tests are skipped, these are not logged in the final pytest output.\n    yield SubTests()\n\n\nclass SubTests:\n    @contextlib.contextmanager\n    def test(self):\n        try:\n            yield\n        except pytest.skip.Exception:\n            pass\n", "tests/test_fernet.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport base64\nimport datetime\nimport json\nimport os\nimport time\n\nimport pretend\nimport pytest\n\nimport cryptography_vectors\nfrom cryptography.fernet import Fernet, InvalidToken, MultiFernet\nfrom cryptography.hazmat.primitives.ciphers import algorithms, modes\n\n\ndef json_parametrize(keys, filename):\n    vector_file = cryptography_vectors.open_vector_file(\n        os.path.join(\"fernet\", filename), \"r\"\n    )\n    with vector_file:\n        data = json.load(vector_file)\n        return pytest.mark.parametrize(\n            keys,\n            [tuple([entry[k] for k in keys]) for entry in data],\n            ids=[f\"{filename}[{i}]\" for i in range(len(data))],\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 32), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CBC\",\n)\nclass TestFernet:\n    @json_parametrize(\n        (\"secret\", \"now\", \"iv\", \"src\", \"token\"),\n        \"generate.json\",\n    )\n    def test_generate(self, secret, now, iv, src, token, backend):\n        f = Fernet(secret.encode(\"ascii\"), backend=backend)\n        actual_token = f._encrypt_from_parts(\n            src.encode(\"ascii\"),\n            int(datetime.datetime.fromisoformat(now).timestamp()),\n            bytes(iv),\n        )\n        assert actual_token == token.encode(\"ascii\")\n\n    @json_parametrize(\n        (\"secret\", \"now\", \"src\", \"ttl_sec\", \"token\"),\n        \"verify.json\",\n    )\n    def test_verify(\n        self, secret, now, src, ttl_sec, token, backend, monkeypatch\n    ):\n        # secret & token are both str\n        f = Fernet(secret.encode(\"ascii\"), backend=backend)\n        current_time = int(datetime.datetime.fromisoformat(now).timestamp())\n        payload = f.decrypt_at_time(\n            token,  # str\n            ttl=ttl_sec,\n            current_time=current_time,\n        )\n        assert payload == src.encode(\"ascii\")\n\n        payload = f.decrypt_at_time(\n            token.encode(\"ascii\"),  # bytes\n            ttl=ttl_sec,\n            current_time=current_time,\n        )\n        assert payload == src.encode(\"ascii\")\n\n        monkeypatch.setattr(time, \"time\", lambda: current_time)\n\n        payload = f.decrypt(token, ttl=ttl_sec)  # str\n        assert payload == src.encode(\"ascii\")\n\n        payload = f.decrypt(token.encode(\"ascii\"), ttl=ttl_sec)  # bytes\n        assert payload == src.encode(\"ascii\")\n\n    @json_parametrize((\"secret\", \"token\", \"now\", \"ttl_sec\"), \"invalid.json\")\n    def test_invalid(self, secret, token, now, ttl_sec, backend, monkeypatch):\n        f = Fernet(secret.encode(\"ascii\"), backend=backend)\n        current_time = int(datetime.datetime.fromisoformat(now).timestamp())\n        with pytest.raises(InvalidToken):\n            f.decrypt_at_time(\n                token.encode(\"ascii\"),\n                ttl=ttl_sec,\n                current_time=current_time,\n            )\n        monkeypatch.setattr(time, \"time\", lambda: current_time)\n        with pytest.raises(InvalidToken):\n            f.decrypt(token.encode(\"ascii\"), ttl=ttl_sec)\n\n    def test_invalid_start_byte(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        with pytest.raises(InvalidToken):\n            f.decrypt(base64.urlsafe_b64encode(b\"\\x81\"))\n\n    def test_timestamp_too_short(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        with pytest.raises(InvalidToken):\n            f.decrypt(base64.urlsafe_b64encode(b\"\\x80abc\"))\n\n    def test_non_base64_token(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        with pytest.raises(InvalidToken):\n            f.decrypt(b\"\\x00\")\n        with pytest.raises(InvalidToken):\n            f.decrypt(\"nonsensetoken\")\n\n    def test_invalid_types(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        with pytest.raises(TypeError):\n            f.encrypt(\"\")  # type: ignore[arg-type]\n        with pytest.raises(TypeError):\n            f.decrypt(12345)  # type: ignore[arg-type]\n\n    def test_timestamp_ignored_no_ttl(self, monkeypatch, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        pt = b\"encrypt me\"\n        token = f.encrypt(pt)\n        monkeypatch.setattr(time, \"time\", pretend.raiser(ValueError))\n        assert f.decrypt(token, ttl=None) == pt\n\n    def test_ttl_required_in_decrypt_at_time(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        pt = b\"encrypt me\"\n        token = f.encrypt(pt)\n        with pytest.raises(ValueError):\n            f.decrypt_at_time(\n                token,\n                ttl=None,  # type: ignore[arg-type]\n                current_time=int(time.time()),\n            )\n\n    @pytest.mark.parametrize(\"message\", [b\"\", b\"Abc!\", b\"\\x00\\xff\\x00\\x80\"])\n    def test_roundtrips(self, message, backend):\n        f = Fernet(Fernet.generate_key(), backend=backend)\n        assert f.decrypt(f.encrypt(message)) == message\n\n    @pytest.mark.parametrize(\"key\", [base64.urlsafe_b64encode(b\"abc\"), b\"abc\"])\n    def test_bad_key(self, backend, key):\n        with pytest.raises(ValueError):\n            Fernet(key, backend=backend)\n\n    def test_extract_timestamp(self, backend):\n        f = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        current_time = 1526138327\n        token = f.encrypt_at_time(b\"encrypt me\", current_time)\n        assert f.extract_timestamp(token) == current_time\n        assert f.extract_timestamp(token.decode(\"ascii\")) == current_time\n        with pytest.raises(InvalidToken):\n            f.extract_timestamp(b\"nonsensetoken\")\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 32), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CBC\",\n)\nclass TestMultiFernet:\n    def test_encrypt(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n        f = MultiFernet([f1, f2])\n\n        assert f1.decrypt(f.encrypt(b\"abc\")) == b\"abc\"\n\n    def test_decrypt(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n        f = MultiFernet([f1, f2])\n\n        # token as bytes\n        assert f.decrypt(f1.encrypt(b\"abc\")) == b\"abc\"\n        assert f.decrypt(f2.encrypt(b\"abc\")) == b\"abc\"\n\n        # token as str\n        assert f.decrypt(f1.encrypt(b\"abc\").decode(\"ascii\")) == b\"abc\"\n        assert f.decrypt(f2.encrypt(b\"abc\").decode(\"ascii\")) == b\"abc\"\n\n        with pytest.raises(InvalidToken):\n            f.decrypt(b\"\\x00\" * 16)\n\n    def test_decrypt_at_time(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f = MultiFernet([f1])\n        pt = b\"encrypt me\"\n        token = f.encrypt_at_time(pt, current_time=100)\n        assert f.decrypt_at_time(token, ttl=1, current_time=100) == pt\n        with pytest.raises(InvalidToken):\n            f.decrypt_at_time(token, ttl=1, current_time=102)\n        with pytest.raises(ValueError):\n            f.decrypt_at_time(\n                token,\n                ttl=None,  # type: ignore[arg-type]\n                current_time=100,\n            )\n\n    def test_no_fernets(self, backend):\n        with pytest.raises(ValueError):\n            MultiFernet([])\n\n    def test_non_iterable_argument(self, backend):\n        with pytest.raises(TypeError):\n            MultiFernet(None)  # type: ignore[arg-type]\n\n    def test_rotate_bytes(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n\n        mf1 = MultiFernet([f1])\n        mf2 = MultiFernet([f2, f1])\n\n        plaintext = b\"abc\"\n        mf1_ciphertext = mf1.encrypt(plaintext)\n\n        assert mf2.decrypt(mf1_ciphertext) == plaintext\n\n        rotated = mf2.rotate(mf1_ciphertext)\n\n        assert rotated != mf1_ciphertext\n        assert mf2.decrypt(rotated) == plaintext\n\n        with pytest.raises(InvalidToken):\n            mf1.decrypt(rotated)\n\n    def test_rotate_str(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n\n        mf1 = MultiFernet([f1])\n        mf2 = MultiFernet([f2, f1])\n\n        plaintext = b\"abc\"\n        mf1_ciphertext = mf1.encrypt(plaintext).decode(\"ascii\")\n\n        assert mf2.decrypt(mf1_ciphertext) == plaintext\n        rotated = mf2.rotate(mf1_ciphertext).decode(\"ascii\")\n\n        assert rotated != mf1_ciphertext\n        assert mf2.decrypt(rotated) == plaintext\n\n        with pytest.raises(InvalidToken):\n            mf1.decrypt(rotated)\n\n    def test_rotate_preserves_timestamp(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n\n        mf1 = MultiFernet([f1])\n        mf2 = MultiFernet([f2, f1])\n\n        plaintext = b\"abc\"\n        original_time = int(time.time()) - 5 * 60\n        mf1_ciphertext = mf1.encrypt_at_time(plaintext, original_time)\n\n        rotated_time, _ = Fernet._get_unverified_token_data(\n            mf2.rotate(mf1_ciphertext)\n        )\n\n        assert int(time.time()) != rotated_time\n        assert original_time == rotated_time\n\n    def test_rotate_decrypt_no_shared_keys(self, backend):\n        f1 = Fernet(base64.urlsafe_b64encode(b\"\\x00\" * 32), backend=backend)\n        f2 = Fernet(base64.urlsafe_b64encode(b\"\\x01\" * 32), backend=backend)\n\n        mf1 = MultiFernet([f1])\n        mf2 = MultiFernet([f2])\n\n        with pytest.raises(InvalidToken):\n            mf2.rotate(mf1.encrypt(b\"abc\"))\n", "tests/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/test_utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport inspect\nimport os\nimport textwrap\n\nimport pretend\nimport pytest\n\nimport cryptography\nimport cryptography.utils\nimport cryptography_vectors\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\n\nfrom . import deprecated_module\nfrom .utils import (\n    check_backend_support,\n    load_cryptrec_vectors,\n    load_ed25519_vectors,\n    load_fips_dsa_key_pair_vectors,\n    load_fips_dsa_sig_vectors,\n    load_fips_ecdsa_key_pair_vectors,\n    load_fips_ecdsa_signing_vectors,\n    load_hash_vectors,\n    load_kasvs_dh_vectors,\n    load_kasvs_ecdh_vectors,\n    load_nist_ccm_vectors,\n    load_nist_kbkdf_vectors,\n    load_nist_vectors,\n    load_pkcs1_vectors,\n    load_rsa_nist_vectors,\n    load_vectors_from_file,\n    load_x963_vectors,\n    raises_unsupported_algorithm,\n)\n\n\ndef test_check_backend_support_skip():\n    supported = pretend.stub(\n        kwargs={\"only_if\": lambda backend: False, \"skip_message\": \"Nope\"}\n    )\n    node = pretend.stub(iter_markers=lambda x: [supported])\n    item = pretend.stub(node=node)\n    with pytest.raises(pytest.skip.Exception) as exc_info:\n        check_backend_support(True, item)\n    assert exc_info.value.args[0] == \"Nope (True)\"\n\n\ndef test_check_backend_support_no_skip():\n    supported = pretend.stub(\n        kwargs={\"only_if\": lambda backend: True, \"skip_message\": \"Nope\"}\n    )\n    node = pretend.stub(iter_markers=lambda x: [supported])\n    item = pretend.stub(node=node)\n    assert check_backend_support(None, item) is None\n\n\ndef test_load_nist_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.1\n    # Config info for aes_values\n    # AESVS GFSbox test data for CBC\n    # State : Encrypt and Decrypt\n    # Key Length : 128\n    # Generated on Fri Apr 22 15:11:33 2011\n\n    [ENCRYPT]\n\n    COUNT = 0\n    KEY = 00000000000000000000000000000000\n    IV = 00000000000000000000000000000000\n    PLAINTEXT = f34481ec3cc627bacd5dc3fb08f273e6\n    CIPHERTEXT = 0336763e966d92595a567cc9ce537f5e\n\n    COUNT = 1\n    KEY = 00000000000000000000000000000000\n    IV = 00000000000000000000000000000000\n    PLAINTEXT = 9798c4640bad75c7c3227db910174e72\n    CIPHERTEXT = a9a1631bf4996954ebc093957b234589\n\n    [DECRYPT]\n\n    COUNT = 0\n    KEY = 00000000000000000000000000000000\n    IV = 00000000000000000000000000000000\n    CIPHERTEXT = 0336763e966d92595a567cc9ce537f5e\n    PLAINTEXT = f34481ec3cc627bacd5dc3fb08f273e6\n\n    COUNT = 1\n    KEY = 00000000000000000000000000000000\n    IV = 00000000000000000000000000000000\n    CIPHERTEXT = a9a1631bf4996954ebc093957b234589\n    PLAINTEXT = 9798c4640bad75c7c3227db910174e72\n    \"\"\"\n    ).splitlines()\n\n    assert load_nist_vectors(vector_data) == [\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"iv\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"f34481ec3cc627bacd5dc3fb08f273e6\",\n            \"ciphertext\": b\"0336763e966d92595a567cc9ce537f5e\",\n        },\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"iv\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"9798c4640bad75c7c3227db910174e72\",\n            \"ciphertext\": b\"a9a1631bf4996954ebc093957b234589\",\n        },\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"iv\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"f34481ec3cc627bacd5dc3fb08f273e6\",\n            \"ciphertext\": b\"0336763e966d92595a567cc9ce537f5e\",\n        },\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"iv\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"9798c4640bad75c7c3227db910174e72\",\n            \"ciphertext\": b\"a9a1631bf4996954ebc093957b234589\",\n        },\n    ]\n\n\ndef test_load_nist_vectors_with_null_chars():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    COUNT = 0\n    KEY = thing\\\\0withnulls\n\n    COUNT = 1\n    KEY = 00000000000000000000000000000000\n    \"\"\"\n    ).splitlines()\n\n    assert load_nist_vectors(vector_data) == [\n        {\"key\": b\"thing\\x00withnulls\"},\n        {\"key\": b\"00000000000000000000000000000000\"},\n    ]\n\n\ndef test_load_ed25519_vectors():\n    vector_data = (\n        \"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7f60d75a9\"\n        \"80182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a:d75a98018\"\n        \"2b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f707511a::e5564300c360\"\n        \"ac729086e2cc806e828a84877f1eb8e5d974d873e065224901555fb8821590a33bacc\"\n        \"61e39701cf9b46bd25bf5f0595bbe24655141438e7a100b:\\n\"\n        \"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a6fb3d401\"\n        \"7c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c:3d4017c3e\"\n        \"843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af4660c:72:92a009a9f0\"\n        \"d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb69da085ac1e43e15996\"\n        \"e458f3613d0f11d8c387b2eaeb4302aeeb00d291612bb0c0072:\\n\"\n        \"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b4458f7fc51c\"\n        \"d8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025:fc51cd8e6\"\n        \"218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908025:af82:6291d657\"\n        \"deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac3ac18ff9b538d16f\"\n        \"290ae67f760984dc6594a7c15e9716ed28dc027beceea1ec40aaf82:\\n\"\n        \"0d4a05b07352a5436e180356da0ae6efa0345ff7fb1572575772e8005ed978e9e61a1\"\n        \"85bcef2613a6c7cb79763ce945d3b245d76114dd440bcf5f2dc1aa57057:e61a185bc\"\n        \"ef2613a6c7cb79763ce945d3b245d76114dd440bcf5f2dc1aa57057:cbc77b:d9868d\"\n        \"52c2bebce5f3fa5a79891970f309cb6591e3e1702a70276fa97c24b3a8e58606c38c9\"\n        \"758529da50ee31b8219cba45271c689afa60b0ea26c99db19b00ccbc77b:\\n\"\n    ).splitlines()\n\n    assert load_ed25519_vectors(vector_data) == [\n        {\n            \"secret_key\": (\n                \"9d61b19deffd5a60ba844af492ec2cc44449c5697b326919703bac031cae7\"\n                \"f60\"\n            ),\n            \"public_key\": (\n                \"d75a980182b10ab7d54bfed3c964073a0ee172f3daa62325af021a68f7075\"\n                \"11a\"\n            ),\n            \"message\": \"\",\n            \"signature\": (\n                \"e5564300c360ac729086e2cc806e828a84877f1eb8e5d974d873e06522490\"\n                \"1555fb8821590a33bacc61e39701cf9b46bd25bf5f0595bbe24655141438e\"\n                \"7a100b\"\n            ),\n        },\n        {\n            \"secret_key\": (\n                \"4ccd089b28ff96da9db6c346ec114e0f5b8a319f35aba624da8cf6ed4fb8a\"\n                \"6fb\"\n            ),\n            \"public_key\": (\n                \"3d4017c3e843895a92b70aa74d1b7ebc9c982ccf2ec4968cc0cd55f12af46\"\n                \"60c\"\n            ),\n            \"message\": \"72\",\n            \"signature\": (\n                \"92a009a9f0d4cab8720e820b5f642540a2b27b5416503f8fb3762223ebdb6\"\n                \"9da085ac1e43e15996e458f3613d0f11d8c387b2eaeb4302aeeb00d291612\"\n                \"bb0c00\"\n            ),\n        },\n        {\n            \"secret_key\": (\n                \"c5aa8df43f9f837bedb7442f31dcb7b166d38535076f094b85ce3a2e0b445\"\n                \"8f7\"\n            ),\n            \"public_key\": (\n                \"fc51cd8e6218a1a38da47ed00230f0580816ed13ba3303ac5deb911548908\"\n                \"025\"\n            ),\n            \"message\": \"af82\",\n            \"signature\": (\n                \"6291d657deec24024827e69c3abe01a30ce548a284743a445e3680d7db5ac\"\n                \"3ac18ff9b538d16f290ae67f760984dc6594a7c15e9716ed28dc027beceea\"\n                \"1ec40a\"\n            ),\n        },\n        {\n            \"secret_key\": (\n                \"0d4a05b07352a5436e180356da0ae6efa0345ff7fb1572575772e8005ed97\"\n                \"8e9\"\n            ),\n            \"public_key\": (\n                \"e61a185bcef2613a6c7cb79763ce945d3b245d76114dd440bcf5f2dc1aa57\"\n                \"057\"\n            ),\n            \"message\": \"cbc77b\",\n            \"signature\": (\n                \"d9868d52c2bebce5f3fa5a79891970f309cb6591e3e1702a70276fa97c24b\"\n                \"3a8e58606c38c9758529da50ee31b8219cba45271c689afa60b0ea26c99db\"\n                \"19b00c\"\n            ),\n        },\n    ]\n\n\ndef test_load_cryptrec_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # Vectors taken from https://info.isl.ntt.co.jp/crypt/eng/camellia/\n    # Download is t_camelia.txt\n\n    # Camellia with 128-bit key\n\n    K No.001 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\n    P No.001 : 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    C No.001 : 07 92 3A 39 EB 0A 81 7D 1C 4D 87 BD B8 2D 1F 1C\n\n    P No.002 : 40 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    C No.002 : 48 CD 64 19 80 96 72 D2 34 92 60 D8 9A 08 D3 D3\n\n    K No.002 : 10 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n\n    P No.001 : 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    C No.001 : 07 92 3A 39 EB 0A 81 7D 1C 4D 87 BD B8 2D 1F 1C\n    \"\"\"\n    ).splitlines()\n\n    assert load_cryptrec_vectors(vector_data) == [\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"80000000000000000000000000000000\",\n            \"ciphertext\": b\"07923A39EB0A817D1C4D87BDB82D1F1C\",\n        },\n        {\n            \"key\": b\"00000000000000000000000000000000\",\n            \"plaintext\": b\"40000000000000000000000000000000\",\n            \"ciphertext\": b\"48CD6419809672D2349260D89A08D3D3\",\n        },\n        {\n            \"key\": b\"10000000000000000000000000000000\",\n            \"plaintext\": b\"80000000000000000000000000000000\",\n            \"ciphertext\": b\"07923A39EB0A817D1C4D87BDB82D1F1C\",\n        },\n    ]\n\n\ndef test_load_cryptrec_vectors_invalid():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # Vectors taken from https://info.isl.ntt.co.jp/crypt/eng/camellia/\n    # Download is t_camelia.txt\n\n    # Camellia with 128-bit key\n\n    E No.001 : 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\n    \"\"\"\n    ).splitlines()\n\n    with pytest.raises(ValueError):\n        load_cryptrec_vectors(vector_data)\n\n\ndef test_load_hash_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n\n        # https://tools.ietf.org/html/rfc1321\n        [irrelevant]\n\n        Len = 0\n        Msg = 00\n        MD = d41d8cd98f00b204e9800998ecf8427e\n\n        Len = 8\n        Msg = 61\n        MD = 0cc175b9c0f1b6a831c399e269772661\n\n        Len = 24\n        Msg = 616263\n        MD = 900150983cd24fb0d6963f7d28e17f72\n\n        Len = 112\n        Msg = 6d65737361676520646967657374\n        MD = f96b697d7cb7938d525a2f31aaf161d0\n    \"\"\"\n    ).splitlines()\n    assert load_hash_vectors(vector_data) == [\n        (b\"\", \"d41d8cd98f00b204e9800998ecf8427e\"),\n        (b\"61\", \"0cc175b9c0f1b6a831c399e269772661\"),\n        (b\"616263\", \"900150983cd24fb0d6963f7d28e17f72\"),\n        (b\"6d65737361676520646967657374\", \"f96b697d7cb7938d525a2f31aaf161d0\"),\n    ]\n\n\ndef test_load_hmac_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\nLen = 224\n# \"Jefe\"\nKey = 4a656665\n# \"what do ya want for nothing?\"\nMsg = 7768617420646f2079612077616e7420666f72206e6f7468696e673f\nMD = 750c783e6ab0b503eaa86e310a5db738\n    \"\"\"\n    ).splitlines()\n    assert load_hash_vectors(vector_data) == [\n        (\n            b\"7768617420646f2079612077616e7420666f72206e6f7468696e673f\",\n            \"750c783e6ab0b503eaa86e310a5db738\",\n            b\"4a656665\",\n        ),\n    ]\n\n\ndef test_load_hash_vectors_bad_data():\n    vector_data = textwrap.dedent(\n        \"\"\"\n        # https://tools.ietf.org/html/rfc1321\n\n        Len = 0\n        Msg = 00\n        UNKNOWN=Hello World\n    \"\"\"\n    ).splitlines()\n    with pytest.raises(ValueError):\n        load_hash_vectors(vector_data)\n\n\ndef test_load_vectors_from_file():\n    vectors = load_vectors_from_file(\n        os.path.join(\"ciphers\", \"Blowfish\", \"bf-cfb.txt\"),\n        load_nist_vectors,\n    )\n    assert vectors == [\n        {\n            \"key\": b\"0123456789ABCDEFF0E1D2C3B4A59687\",\n            \"iv\": b\"FEDCBA9876543210\",\n            \"plaintext\": (\n                b\"37363534333231204E6F77206973207468652074696D6520666F722000\"\n            ),\n            \"ciphertext\": (\n                b\"E73214A2822139CAF26ECF6D2EB9E76E3DA3DE04D1517200519D57A6C3\"\n            ),\n        }\n    ]\n\n\ndef test_load_nist_gcm_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n        [Keylen = 128]\n        [IVlen = 96]\n        [PTlen = 0]\n        [AADlen = 0]\n        [Taglen = 128]\n\n        Count = 0\n        Key = 11754cd72aec309bf52f7687212e8957\n        IV = 3c819d9a9bed087615030b65\n        PT =\n        AAD =\n        CT =\n        Tag = 250327c674aaf477aef2675748cf6971\n\n        Count = 1\n        Key = 272f16edb81a7abbea887357a58c1917\n        IV = 794ec588176c703d3d2a7a07\n        PT =\n        AAD =\n        CT =\n        Tag = b6e6f197168f5049aeda32dafbdaeb\n\n        Count = 2\n        Key = a49a5e26a2f8cb63d05546c2a62f5343\n        IV = 907763b19b9b4ab6bd4f0281\n        CT =\n        AAD =\n        Tag = a2be08210d8c470a8df6e8fbd79ec5cf\n        FAIL\n\n        Count = 3\n        Key = 5c1155084cc0ede76b3bc22e9f7574ef\n        IV = 9549e4ba69a61cad7856efc1\n        PT = d1448fa852b84408e2dad8381f363de7\n        AAD = e98e9d9c618e46fef32660976f854ee3\n        CT = f78b60ca125218493bea1c50a2e12ef4\n        Tag = d72da7f5c6cf0bca7242c71835809449\n\n        [Keylen = 128]\n        [IVlen = 96]\n        [PTlen = 0]\n        [AADlen = 0]\n        [Taglen = 120]\n\n        Count = 0\n        Key = eac258e99c55e6ae8ef1da26640613d7\n        IV = 4e8df20faaf2c8eebe922902\n        CT =\n        AAD =\n        Tag = e39aeaebe86aa309a4d062d6274339\n        PT =\n\n        Count = 1\n        Key = 3726cf02fcc6b8639a5497652c94350d\n        IV = 55fef82cde693ce76efcc193\n        CT =\n        AAD =\n        Tag = 3d68111a81ed22d2ef5bccac4fc27f\n        FAIL\n\n        Count = 2\n        Key = f202299d5fd74f03b12d2119a6c4c038\n        IV = eec51e7958c3f20a1bb71815\n        CT =\n        AAD =\n        Tag = a81886b3fb26e51fca87b267e1e157\n        FAIL\n\n        Count = 3\n        Key = fd52925f39546b4c55ffb6b20c59898c\n        IV = f5cf3227444afd905a5f6dba\n        CT =\n        AAD =\n        Tag = 1665b0f1a0b456e1664cfd3de08ccd\n        PT =\n\n        [Keylen = 128]\n        [IVlen = 8]\n        [PTlen = 104]\n        [AADlen = 0]\n        [Taglen = 128]\n\n        Count = 0\n        Key = 58fab7632bcf10d2bcee58520bf37414\n        IV = 3c\n        CT = 15c4db4cbb451211179d57017f\n        AAD =\n        Tag = eae841d4355feeb3f786bc86625f1e5b\n        FAIL\n    \"\"\"\n    ).splitlines()\n    assert load_nist_vectors(vector_data) == [\n        {\n            \"aad\": b\"\",\n            \"pt\": b\"\",\n            \"iv\": b\"3c819d9a9bed087615030b65\",\n            \"tag\": b\"250327c674aaf477aef2675748cf6971\",\n            \"key\": b\"11754cd72aec309bf52f7687212e8957\",\n            \"ct\": b\"\",\n        },\n        {\n            \"aad\": b\"\",\n            \"pt\": b\"\",\n            \"iv\": b\"794ec588176c703d3d2a7a07\",\n            \"tag\": b\"b6e6f197168f5049aeda32dafbdaeb\",\n            \"key\": b\"272f16edb81a7abbea887357a58c1917\",\n            \"ct\": b\"\",\n        },\n        {\n            \"aad\": b\"\",\n            \"iv\": b\"907763b19b9b4ab6bd4f0281\",\n            \"tag\": b\"a2be08210d8c470a8df6e8fbd79ec5cf\",\n            \"key\": b\"a49a5e26a2f8cb63d05546c2a62f5343\",\n            \"ct\": b\"\",\n            \"fail\": True,\n        },\n        {\n            \"aad\": b\"e98e9d9c618e46fef32660976f854ee3\",\n            \"pt\": b\"d1448fa852b84408e2dad8381f363de7\",\n            \"iv\": b\"9549e4ba69a61cad7856efc1\",\n            \"tag\": b\"d72da7f5c6cf0bca7242c71835809449\",\n            \"key\": b\"5c1155084cc0ede76b3bc22e9f7574ef\",\n            \"ct\": b\"f78b60ca125218493bea1c50a2e12ef4\",\n        },\n        {\n            \"aad\": b\"\",\n            \"pt\": b\"\",\n            \"iv\": b\"4e8df20faaf2c8eebe922902\",\n            \"tag\": b\"e39aeaebe86aa309a4d062d6274339\",\n            \"key\": b\"eac258e99c55e6ae8ef1da26640613d7\",\n            \"ct\": b\"\",\n        },\n        {\n            \"aad\": b\"\",\n            \"iv\": b\"55fef82cde693ce76efcc193\",\n            \"tag\": b\"3d68111a81ed22d2ef5bccac4fc27f\",\n            \"key\": b\"3726cf02fcc6b8639a5497652c94350d\",\n            \"ct\": b\"\",\n            \"fail\": True,\n        },\n        {\n            \"aad\": b\"\",\n            \"iv\": b\"eec51e7958c3f20a1bb71815\",\n            \"tag\": b\"a81886b3fb26e51fca87b267e1e157\",\n            \"key\": b\"f202299d5fd74f03b12d2119a6c4c038\",\n            \"ct\": b\"\",\n            \"fail\": True,\n        },\n        {\n            \"aad\": b\"\",\n            \"pt\": b\"\",\n            \"iv\": b\"f5cf3227444afd905a5f6dba\",\n            \"tag\": b\"1665b0f1a0b456e1664cfd3de08ccd\",\n            \"key\": b\"fd52925f39546b4c55ffb6b20c59898c\",\n            \"ct\": b\"\",\n        },\n        {\n            \"aad\": b\"\",\n            \"iv\": b\"3c\",\n            \"tag\": b\"eae841d4355feeb3f786bc86625f1e5b\",\n            \"key\": b\"58fab7632bcf10d2bcee58520bf37414\",\n            \"ct\": b\"15c4db4cbb451211179d57017f\",\n            \"fail\": True,\n        },\n    ]\n\n\ndef test_load_pkcs1_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    Test vectors for RSA-PSS\n    ========================\n\n    This file contains an extract of the original pss-vect.txt\n\n    Key lengths:\n\n    Key  8: 1031 bits\n    Key  9: 1536 bits\n    ===========================================================================\n\n    <snip>\n\n    # Example 8: A 1031-bit RSA key pair\n    # -----------------------------------\n\n\n    # Public key\n    # ----------\n\n    # Modulus:\n    49 53 70 a1 fb 18 54 3c 16 d3 63 1e 31 63 25 5d\n    f6 2b e6 ee e8 90 d5 f2 55 09 e4 f7 78 a8 ea 6f\n    bb bc df 85 df f6 4e 0d 97 20 03 ab 36 81 fb ba\n    6d d4 1f d5 41 82 9b 2e 58 2d e9 f2 a4 a4 e0 a2\n    d0 90 0b ef 47 53 db 3c ee 0e e0 6c 7d fa e8 b1\n    d5 3b 59 53 21 8f 9c ce ea 69 5b 08 66 8e de aa\n    dc ed 94 63 b1 d7 90 d5 eb f2 7e 91 15 b4 6c ad\n    4d 9a 2b 8e fa b0 56 1b 08 10 34 47 39 ad a0 73\n    3f\n\n    # Exponent:\n    01 00 01\n\n    # Private key\n    # -----------\n\n    # Modulus:\n    49 53 70 a1 fb 18 54 3c 16 d3 63 1e 31 63 25 5d\n    f6 2b e6 ee e8 90 d5 f2 55 09 e4 f7 78 a8 ea 6f\n    bb bc df 85 df f6 4e 0d 97 20 03 ab 36 81 fb ba\n    6d d4 1f d5 41 82 9b 2e 58 2d e9 f2 a4 a4 e0 a2\n    d0 90 0b ef 47 53 db 3c ee 0e e0 6c 7d fa e8 b1\n    d5 3b 59 53 21 8f 9c ce ea 69 5b 08 66 8e de aa\n    dc ed 94 63 b1 d7 90 d5 eb f2 7e 91 15 b4 6c ad\n    4d 9a 2b 8e fa b0 56 1b 08 10 34 47 39 ad a0 73\n    3f\n\n    # Public exponent:\n    01 00 01\n\n    # Exponent:\n    6c 66 ff e9 89 80 c3 8f cd ea b5 15 98 98 83 61\n    65 f4 b4 b8 17 c4 f6 a8 d4 86 ee 4e a9 13 0f e9\n    b9 09 2b d1 36 d1 84 f9 5f 50 4a 60 7e ac 56 58\n    46 d2 fd d6 59 7a 89 67 c7 39 6e f9 5a 6e ee bb\n    45 78 a6 43 96 6d ca 4d 8e e3 de 84 2d e6 32 79\n    c6 18 15 9c 1a b5 4a 89 43 7b 6a 61 20 e4 93 0a\n    fb 52 a4 ba 6c ed 8a 49 47 ac 64 b3 0a 34 97 cb\n    e7 01 c2 d6 26 6d 51 72 19 ad 0e c6 d3 47 db e9\n\n    # Prime 1:\n    08 da d7 f1 13 63 fa a6 23 d5 d6 d5 e8 a3 19 32\n    8d 82 19 0d 71 27 d2 84 6c 43 9b 0a b7 26 19 b0\n    a4 3a 95 32 0e 4e c3 4f c3 a9 ce a8 76 42 23 05\n    bd 76 c5 ba 7b e9 e2 f4 10 c8 06 06 45 a1 d2 9e\n    db\n\n    # Prime 2:\n    08 47 e7 32 37 6f c7 90 0f 89 8e a8 2e b2 b0 fc\n    41 85 65 fd ae 62 f7 d9 ec 4c e2 21 7b 97 99 0d\n    d2 72 db 15 7f 99 f6 3c 0d cb b9 fb ac db d4 c4\n    da db 6d f6 77 56 35 8c a4 17 48 25 b4 8f 49 70\n    6d\n\n    # Prime exponent 1:\n    05 c2 a8 3c 12 4b 36 21 a2 aa 57 ea 2c 3e fe 03\n    5e ff 45 60 f3 3d de bb 7a da b8 1f ce 69 a0 c8\n    c2 ed c1 65 20 dd a8 3d 59 a2 3b e8 67 96 3a c6\n    5f 2c c7 10 bb cf b9 6e e1 03 de b7 71 d1 05 fd\n    85\n\n    # Prime exponent 2:\n    04 ca e8 aa 0d 9f aa 16 5c 87 b6 82 ec 14 0b 8e\n    d3 b5 0b 24 59 4b 7a 3b 2c 22 0b 36 69 bb 81 9f\n    98 4f 55 31 0a 1a e7 82 36 51 d4 a0 2e 99 44 79\n    72 59 51 39 36 34 34 e5 e3 0a 7e 7d 24 15 51 e1\n    b9\n\n    # Coefficient:\n    07 d3 e4 7b f6 86 60 0b 11 ac 28 3c e8 8d bb 3f\n    60 51 e8 ef d0 46 80 e4 4c 17 1e f5 31 b8 0b 2b\n    7c 39 fc 76 63 20 e2 cf 15 d8 d9 98 20 e9 6f f3\n    0d c6 96 91 83 9c 4b 40 d7 b0 6e 45 30 7d c9 1f\n    3f\n\n    # RSA-PSS signing of 6 random messages with random salts\n    # -------------------------------------------------------\n    # PSS Example 8.1\n\n    # -----------------\n\n    # Message to be signed:\n    81 33 2f 4b e6 29 48 41 5e a1 d8 99 79 2e ea cf\n    6c 6e 1d b1 da 8b e1 3b 5c ea 41 db 2f ed 46 70\n    92 e1 ff 39 89 14 c7 14 25 97 75 f5 95 f8 54 7f\n    73 56 92 a5 75 e6 92 3a f7 8f 22 c6 99 7d db 90\n    fb 6f 72 d7 bb 0d d5 74 4a 31 de cd 3d c3 68 58\n    49 83 6e d3 4a ec 59 63 04 ad 11 84 3c 4f 88 48\n    9f 20 97 35 f5 fb 7f da f7 ce c8 ad dc 58 18 16\n    8f 88 0a cb f4 90 d5 10 05 b7 a8 e8 4e 43 e5 42\n    87 97 75 71 dd 99 ee a4 b1 61 eb 2d f1 f5 10 8f\n    12 a4 14 2a 83 32 2e db 05 a7 54 87 a3 43 5c 9a\n    78 ce 53 ed 93 bc 55 08 57 d7 a9 fb\n\n    # Salt:\n    1d 65 49 1d 79 c8 64 b3 73 00 9b e6 f6 f2 46 7b\n    ac 4c 78 fa\n\n    # Signature:\n    02 62 ac 25 4b fa 77 f3 c1 ac a2 2c 51 79 f8 f0\n    40 42 2b 3c 5b af d4 0a 8f 21 cf 0f a5 a6 67 cc\n    d5 99 3d 42 db af b4 09 c5 20 e2 5f ce 2b 1e e1\n    e7 16 57 7f 1e fa 17 f3 da 28 05 2f 40 f0 41 9b\n    23 10 6d 78 45 aa f0 11 25 b6 98 e7 a4 df e9 2d\n    39 67 bb 00 c4 d0 d3 5b a3 55 2a b9 a8 b3 ee f0\n    7c 7f ec db c5 42 4a c4 db 1e 20 cb 37 d0 b2 74\n    47 69 94 0e a9 07 e1 7f bb ca 67 3b 20 52 23 80\n    c5\n\n    # PSS Example 8.2\n\n    # -----------------\n\n    # Message to be signed:\n    e2 f9 6e af 0e 05 e7 ba 32 6e cc a0 ba 7f d2 f7\n    c0 23 56 f3 ce de 9d 0f aa bf 4f cc 8e 60 a9 73\n    e5 59 5f d9 ea 08\n\n    # Salt:\n    43 5c 09 8a a9 90 9e b2 37 7f 12 48 b0 91 b6 89\n    87 ff 18 38\n\n    # Signature:\n    27 07 b9 ad 51 15 c5 8c 94 e9 32 e8 ec 0a 28 0f\n    56 33 9e 44 a1 b5 8d 4d dc ff 2f 31 2e 5f 34 dc\n    fe 39 e8 9c 6a 94 dc ee 86 db bd ae 5b 79 ba 4e\n    08 19 a9 e7 bf d9 d9 82 e7 ee 6c 86 ee 68 39 6e\n    8b 3a 14 c9 c8 f3 4b 17 8e b7 41 f9 d3 f1 21 10\n    9b f5 c8 17 2f ad a2 e7 68 f9 ea 14 33 03 2c 00\n    4a 8a a0 7e b9 90 00 0a 48 dc 94 c8 ba c8 aa be\n    2b 09 b1 aa 46 c0 a2 aa 0e 12 f6 3f bb a7 75 ba\n    7e\n\n    # <snip>\n\n    # =============================================\n\n    # Example 9: A 1536-bit RSA key pair\n    # -----------------------------------\n\n\n    # Public key\n    # ----------\n\n    # Modulus:\n    e6 bd 69 2a c9 66 45 79 04 03 fd d0 f5 be b8 b9\n    bf 92 ed 10 00 7f c3 65 04 64 19 dd 06 c0 5c 5b\n    5b 2f 48 ec f9 89 e4 ce 26 91 09 97 9c bb 40 b4\n    a0 ad 24 d2 24 83 d1 ee 31 5a d4 cc b1 53 42 68\n    35 26 91 c5 24 f6 dd 8e 6c 29 d2 24 cf 24 69 73\n    ae c8 6c 5b f6 b1 40 1a 85 0d 1b 9a d1 bb 8c bc\n    ec 47 b0 6f 0f 8c 7f 45 d3 fc 8f 31 92 99 c5 43\n    3d db c2 b3 05 3b 47 de d2 ec d4 a4 ca ef d6 14\n    83 3d c8 bb 62 2f 31 7e d0 76 b8 05 7f e8 de 3f\n    84 48 0a d5 e8 3e 4a 61 90 4a 4f 24 8f b3 97 02\n    73 57 e1 d3 0e 46 31 39 81 5c 6f d4 fd 5a c5 b8\n    17 2a 45 23 0e cb 63 18 a0 4f 14 55 d8 4e 5a 8b\n\n    # Exponent:\n    01 00 01\n\n    # Private key\n    # -----------\n\n    # Modulus:\n    e6 bd 69 2a c9 66 45 79 04 03 fd d0 f5 be b8 b9\n    bf 92 ed 10 00 7f c3 65 04 64 19 dd 06 c0 5c 5b\n    5b 2f 48 ec f9 89 e4 ce 26 91 09 97 9c bb 40 b4\n    a0 ad 24 d2 24 83 d1 ee 31 5a d4 cc b1 53 42 68\n    35 26 91 c5 24 f6 dd 8e 6c 29 d2 24 cf 24 69 73\n    ae c8 6c 5b f6 b1 40 1a 85 0d 1b 9a d1 bb 8c bc\n    ec 47 b0 6f 0f 8c 7f 45 d3 fc 8f 31 92 99 c5 43\n    3d db c2 b3 05 3b 47 de d2 ec d4 a4 ca ef d6 14\n    83 3d c8 bb 62 2f 31 7e d0 76 b8 05 7f e8 de 3f\n    84 48 0a d5 e8 3e 4a 61 90 4a 4f 24 8f b3 97 02\n    73 57 e1 d3 0e 46 31 39 81 5c 6f d4 fd 5a c5 b8\n    17 2a 45 23 0e cb 63 18 a0 4f 14 55 d8 4e 5a 8b\n\n    # Public exponent:\n    01 00 01\n\n    # Exponent:\n    6a 7f d8 4f b8 5f ad 07 3b 34 40 6d b7 4f 8d 61\n    a6 ab c1 21 96 a9 61 dd 79 56 5e 9d a6 e5 18 7b\n    ce 2d 98 02 50 f7 35 95 75 35 92 70 d9 15 90 bb\n    0e 42 7c 71 46 0b 55 d5 14 10 b1 91 bc f3 09 fe\n    a1 31 a9 2c 8e 70 27 38 fa 71 9f 1e 00 41 f5 2e\n    40 e9 1f 22 9f 4d 96 a1 e6 f1 72 e1 55 96 b4 51\n    0a 6d ae c2 61 05 f2 be bc 53 31 6b 87 bd f2 13\n    11 66 60 70 e8 df ee 69 d5 2c 71 a9 76 ca ae 79\n    c7 2b 68 d2 85 80 dc 68 6d 9f 51 29 d2 25 f8 2b\n    3d 61 55 13 a8 82 b3 db 91 41 6b 48 ce 08 88 82\n    13 e3 7e eb 9a f8 00 d8 1c ab 32 8c e4 20 68 99\n    03 c0 0c 7b 5f d3 1b 75 50 3a 6d 41 96 84 d6 29\n\n    # Prime 1:\n    f8 eb 97 e9 8d f1 26 64 ee fd b7 61 59 6a 69 dd\n    cd 0e 76 da ec e6 ed 4b f5 a1 b5 0a c0 86 f7 92\n    8a 4d 2f 87 26 a7 7e 51 5b 74 da 41 98 8f 22 0b\n    1c c8 7a a1 fc 81 0c e9 9a 82 f2 d1 ce 82 1e dc\n    ed 79 4c 69 41 f4 2c 7a 1a 0b 8c 4d 28 c7 5e c6\n    0b 65 22 79 f6 15 4a 76 2a ed 16 5d 47 de e3 67\n\n    # Prime 2:\n    ed 4d 71 d0 a6 e2 4b 93 c2 e5 f6 b4 bb e0 5f 5f\n    b0 af a0 42 d2 04 fe 33 78 d3 65 c2 f2 88 b6 a8\n    da d7 ef e4 5d 15 3e ef 40 ca cc 7b 81 ff 93 40\n    02 d1 08 99 4b 94 a5 e4 72 8c d9 c9 63 37 5a e4\n    99 65 bd a5 5c bf 0e fe d8 d6 55 3b 40 27 f2 d8\n    62 08 a6 e6 b4 89 c1 76 12 80 92 d6 29 e4 9d 3d\n\n    # Prime exponent 1:\n    2b b6 8b dd fb 0c 4f 56 c8 55 8b ff af 89 2d 80\n    43 03 78 41 e7 fa 81 cf a6 1a 38 c5 e3 9b 90 1c\n    8e e7 11 22 a5 da 22 27 bd 6c de eb 48 14 52 c1\n    2a d3 d6 1d 5e 4f 77 6a 0a b5 56 59 1b ef e3 e5\n    9e 5a 7f dd b8 34 5e 1f 2f 35 b9 f4 ce e5 7c 32\n    41 4c 08 6a ec 99 3e 93 53 e4 80 d9 ee c6 28 9f\n\n    # Prime exponent 2:\n    4f f8 97 70 9f ad 07 97 46 49 45 78 e7 0f d8 54\n    61 30 ee ab 56 27 c4 9b 08 0f 05 ee 4a d9 f3 e4\n    b7 cb a9 d6 a5 df f1 13 a4 1c 34 09 33 68 33 f1\n    90 81 6d 8a 6b c4 2e 9b ec 56 b7 56 7d 0f 3c 9c\n    69 6d b6 19 b2 45 d9 01 dd 85 6d b7 c8 09 2e 77\n    e9 a1 cc cd 56 ee 4d ba 42 c5 fd b6 1a ec 26 69\n\n    # Coefficient:\n    77 b9 d1 13 7b 50 40 4a 98 27 29 31 6e fa fc 7d\n    fe 66 d3 4e 5a 18 26 00 d5 f3 0a 0a 85 12 05 1c\n    56 0d 08 1d 4d 0a 18 35 ec 3d 25 a6 0f 4e 4d 6a\n    a9 48 b2 bf 3d bb 5b 12 4c bb c3 48 92 55 a3 a9\n    48 37 2f 69 78 49 67 45 f9 43 e1 db 4f 18 38 2c\n    ea a5 05 df c6 57 57 bb 3f 85 7a 58 dc e5 21 56\n\n    # PKCS#1 v1.5 Signature Example 2.17\n\n    # -----------------\n\n    # Message to be signed:\n    06 ad d7 5a b6 89 de 06 77 44 e6 9a 2e bd 4b 90\n    fa 93 83 00 3c d0 5f f5 36 cb f2 94 cd 21 5f 09\n    23 b7 fc 90 04 f0 aa 18 52 71 a1 d0 06 1f d0 e9\n    77 7a d1 ec 0c 71 59 1f 57 8b f7 b8 e5 a1\n\n    # Signature:\n    45 14 21 0e 54 1d 5b ad 7d d6 0a e5 49 b9 43 ac\n    c4 4f 21 39 0d f5 b6 13 18 45 5a 17 61 0d f5 b7\n    4d 84 ae d2 32 f1 7e 59 d9 1d d2 65 99 22 f8 12\n    db d4 96 81 69 03 84 b9 54 e9 ad fb 9b 1a 96 8c\n    0c bf f7 63 ec ee d6 27 50 c5 91 64 b5 e0 80 a8\n    fe f3 d5 5b fe 2a cf ad 27 52 a6 a8 45 9f a1 fa\n    b4 9a d3 78 c6 96 4b 23 ee 97 fd 10 34 61 0c 5c\n    c1 4c 61 e0 eb fb 17 11 f8 ad e9 6f e6 55 7b 38\n\n    # <snip>\n\n    # =============================================\n\n    # <snip>\n    \"\"\"\n    ).splitlines()\n\n    vectors = tuple(load_pkcs1_vectors(vector_data))\n    expected = (\n        (\n            {\n                \"modulus\": int(\n                    \"495370a1fb18543c16d3631e3163255df62be6eee890d5f25509e4f77\"\n                    \"8a8ea6fbbbcdf85dff64e0d972003ab3681fbba6dd41fd541829b2e58\"\n                    \"2de9f2a4a4e0a2d0900bef4753db3cee0ee06c7dfae8b1d53b5953218\"\n                    \"f9cceea695b08668edeaadced9463b1d790d5ebf27e9115b46cad4d9a\"\n                    \"2b8efab0561b0810344739ada0733f\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n                \"private_exponent\": int(\n                    \"6c66ffe98980c38fcdeab5159898836165f4b4b817c4f6a8d486ee4ea\"\n                    \"9130fe9b9092bd136d184f95f504a607eac565846d2fdd6597a8967c7\"\n                    \"396ef95a6eeebb4578a643966dca4d8ee3de842de63279c618159c1ab\"\n                    \"54a89437b6a6120e4930afb52a4ba6ced8a4947ac64b30a3497cbe701\"\n                    \"c2d6266d517219ad0ec6d347dbe9\",\n                    16,\n                ),\n                \"p\": int(\n                    \"8dad7f11363faa623d5d6d5e8a319328d82190d7127d2846c439b0ab7\"\n                    \"2619b0a43a95320e4ec34fc3a9cea876422305bd76c5ba7be9e2f410c\"\n                    \"8060645a1d29edb\",\n                    16,\n                ),\n                \"q\": int(\n                    \"847e732376fc7900f898ea82eb2b0fc418565fdae62f7d9ec4ce2217b\"\n                    \"97990dd272db157f99f63c0dcbb9fbacdbd4c4dadb6df67756358ca41\"\n                    \"74825b48f49706d\",\n                    16,\n                ),\n                \"dmp1\": int(\n                    \"05c2a83c124b3621a2aa57ea2c3efe035eff4560f33ddebb7adab81fc\"\n                    \"e69a0c8c2edc16520dda83d59a23be867963ac65f2cc710bbcfb96ee1\"\n                    \"03deb771d105fd85\",\n                    16,\n                ),\n                \"dmq1\": int(\n                    \"04cae8aa0d9faa165c87b682ec140b8ed3b50b24594b7a3b2c220b366\"\n                    \"9bb819f984f55310a1ae7823651d4a02e99447972595139363434e5e3\"\n                    \"0a7e7d241551e1b9\",\n                    16,\n                ),\n                \"iqmp\": int(\n                    \"07d3e47bf686600b11ac283ce88dbb3f6051e8efd04680e44c171ef53\"\n                    \"1b80b2b7c39fc766320e2cf15d8d99820e96ff30dc69691839c4b40d7\"\n                    \"b06e45307dc91f3f\",\n                    16,\n                ),\n                \"examples\": [\n                    {\n                        \"message\": b\"81332f4be62948415ea1d899792eeacf6c6e1db1d\"\n                        b\"a8be13b5cea41db2fed467092e1ff398914c71425\"\n                        b\"9775f595f8547f735692a575e6923af78f22c6997\"\n                        b\"ddb90fb6f72d7bb0dd5744a31decd3dc368584983\"\n                        b\"6ed34aec596304ad11843c4f88489f209735f5fb7\"\n                        b\"fdaf7cec8addc5818168f880acbf490d51005b7a8\"\n                        b\"e84e43e54287977571dd99eea4b161eb2df1f5108\"\n                        b\"f12a4142a83322edb05a75487a3435c9a78ce53ed\"\n                        b\"93bc550857d7a9fb\",\n                        \"salt\": b\"1d65491d79c864b373009be6f6f2467bac4c78fa\",\n                        \"signature\": b\"0262ac254bfa77f3c1aca22c5179f8f040422b3\"\n                        b\"c5bafd40a8f21cf0fa5a667ccd5993d42dbafb4\"\n                        b\"09c520e25fce2b1ee1e716577f1efa17f3da280\"\n                        b\"52f40f0419b23106d7845aaf01125b698e7a4df\"\n                        b\"e92d3967bb00c4d0d35ba3552ab9a8b3eef07c7\"\n                        b\"fecdbc5424ac4db1e20cb37d0b2744769940ea9\"\n                        b\"07e17fbbca673b20522380c5\",\n                    },\n                    {\n                        \"message\": b\"e2f96eaf0e05e7ba326ecca0ba7fd2f7c02356f3c\"\n                        b\"ede9d0faabf4fcc8e60a973e5595fd9ea08\",\n                        \"salt\": b\"435c098aa9909eb2377f1248b091b68987ff1838\",\n                        \"signature\": b\"2707b9ad5115c58c94e932e8ec0a280f56339e4\"\n                        b\"4a1b58d4ddcff2f312e5f34dcfe39e89c6a94dc\"\n                        b\"ee86dbbdae5b79ba4e0819a9e7bfd9d982e7ee6\"\n                        b\"c86ee68396e8b3a14c9c8f34b178eb741f9d3f1\"\n                        b\"21109bf5c8172fada2e768f9ea1433032c004a8\"\n                        b\"aa07eb990000a48dc94c8bac8aabe2b09b1aa46\"\n                        b\"c0a2aa0e12f63fbba775ba7e\",\n                    },\n                ],\n            },\n            {\n                \"modulus\": int(\n                    \"495370a1fb18543c16d3631e3163255df62be6eee890d5f25509e4f77\"\n                    \"8a8ea6fbbbcdf85dff64e0d972003ab3681fbba6dd41fd541829b2e58\"\n                    \"2de9f2a4a4e0a2d0900bef4753db3cee0ee06c7dfae8b1d53b5953218\"\n                    \"f9cceea695b08668edeaadced9463b1d790d5ebf27e9115b46cad4d9a\"\n                    \"2b8efab0561b0810344739ada0733f\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n            },\n        ),\n        (\n            {\n                \"modulus\": int(\n                    \"e6bd692ac96645790403fdd0f5beb8b9bf92ed10007fc365046419dd0\"\n                    \"6c05c5b5b2f48ecf989e4ce269109979cbb40b4a0ad24d22483d1ee31\"\n                    \"5ad4ccb1534268352691c524f6dd8e6c29d224cf246973aec86c5bf6b\"\n                    \"1401a850d1b9ad1bb8cbcec47b06f0f8c7f45d3fc8f319299c5433ddb\"\n                    \"c2b3053b47ded2ecd4a4caefd614833dc8bb622f317ed076b8057fe8d\"\n                    \"e3f84480ad5e83e4a61904a4f248fb397027357e1d30e463139815c6f\"\n                    \"d4fd5ac5b8172a45230ecb6318a04f1455d84e5a8b\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n                \"private_exponent\": int(\n                    \"6a7fd84fb85fad073b34406db74f8d61a6abc12196a961dd79565e9da\"\n                    \"6e5187bce2d980250f7359575359270d91590bb0e427c71460b55d514\"\n                    \"10b191bcf309fea131a92c8e702738fa719f1e0041f52e40e91f229f4\"\n                    \"d96a1e6f172e15596b4510a6daec26105f2bebc53316b87bdf2131166\"\n                    \"6070e8dfee69d52c71a976caae79c72b68d28580dc686d9f5129d225f\"\n                    \"82b3d615513a882b3db91416b48ce08888213e37eeb9af800d81cab32\"\n                    \"8ce420689903c00c7b5fd31b75503a6d419684d629\",\n                    16,\n                ),\n                \"p\": int(\n                    \"f8eb97e98df12664eefdb761596a69ddcd0e76daece6ed4bf5a1b50ac\"\n                    \"086f7928a4d2f8726a77e515b74da41988f220b1cc87aa1fc810ce99a\"\n                    \"82f2d1ce821edced794c6941f42c7a1a0b8c4d28c75ec60b652279f61\"\n                    \"54a762aed165d47dee367\",\n                    16,\n                ),\n                \"q\": int(\n                    \"ed4d71d0a6e24b93c2e5f6b4bbe05f5fb0afa042d204fe3378d365c2f\"\n                    \"288b6a8dad7efe45d153eef40cacc7b81ff934002d108994b94a5e472\"\n                    \"8cd9c963375ae49965bda55cbf0efed8d6553b4027f2d86208a6e6b48\"\n                    \"9c176128092d629e49d3d\",\n                    16,\n                ),\n                \"dmp1\": int(\n                    \"2bb68bddfb0c4f56c8558bffaf892d8043037841e7fa81cfa61a38c5e\"\n                    \"39b901c8ee71122a5da2227bd6cdeeb481452c12ad3d61d5e4f776a0a\"\n                    \"b556591befe3e59e5a7fddb8345e1f2f35b9f4cee57c32414c086aec9\"\n                    \"93e9353e480d9eec6289f\",\n                    16,\n                ),\n                \"dmq1\": int(\n                    \"4ff897709fad079746494578e70fd8546130eeab5627c49b080f05ee4\"\n                    \"ad9f3e4b7cba9d6a5dff113a41c3409336833f190816d8a6bc42e9bec\"\n                    \"56b7567d0f3c9c696db619b245d901dd856db7c8092e77e9a1cccd56e\"\n                    \"e4dba42c5fdb61aec2669\",\n                    16,\n                ),\n                \"iqmp\": int(\n                    \"77b9d1137b50404a982729316efafc7dfe66d34e5a182600d5f30a0a8\"\n                    \"512051c560d081d4d0a1835ec3d25a60f4e4d6aa948b2bf3dbb5b124c\"\n                    \"bbc3489255a3a948372f6978496745f943e1db4f18382ceaa505dfc65\"\n                    \"757bb3f857a58dce52156\",\n                    16,\n                ),\n                \"examples\": [\n                    {\n                        \"message\": b\"06add75ab689de067744e69a2ebd4b90fa9383003\"\n                        b\"cd05ff536cbf294cd215f0923b7fc9004f0aa1852\"\n                        b\"71a1d0061fd0e9777ad1ec0c71591f578bf7b8e5a\"\n                        b\"1\",\n                        \"signature\": b\"4514210e541d5bad7dd60ae549b943acc44f213\"\n                        b\"90df5b61318455a17610df5b74d84aed232f17e\"\n                        b\"59d91dd2659922f812dbd49681690384b954e9a\"\n                        b\"dfb9b1a968c0cbff763eceed62750c59164b5e0\"\n                        b\"80a8fef3d55bfe2acfad2752a6a8459fa1fab49\"\n                        b\"ad378c6964b23ee97fd1034610c5cc14c61e0eb\"\n                        b\"fb1711f8ade96fe6557b38\",\n                    }\n                ],\n            },\n            {\n                \"modulus\": int(\n                    \"e6bd692ac96645790403fdd0f5beb8b9bf92ed10007fc365046419dd0\"\n                    \"6c05c5b5b2f48ecf989e4ce269109979cbb40b4a0ad24d22483d1ee31\"\n                    \"5ad4ccb1534268352691c524f6dd8e6c29d224cf246973aec86c5bf6b\"\n                    \"1401a850d1b9ad1bb8cbcec47b06f0f8c7f45d3fc8f319299c5433ddb\"\n                    \"c2b3053b47ded2ecd4a4caefd614833dc8bb622f317ed076b8057fe8d\"\n                    \"e3f84480ad5e83e4a61904a4f248fb397027357e1d30e463139815c6f\"\n                    \"d4fd5ac5b8172a45230ecb6318a04f1455d84e5a8b\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n            },\n        ),\n    )\n    assert vectors == expected\n\n\ndef test_load_pkcs1_oaep_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    Test vectors for RSA-OAEP\n    =========================\n\n    This file contains test vectors for the RSA-OAEP encryption\n\n    Key lengths:\n\n    Key  1: 1024 bits\n    # <snip>\n    ===========================================================================\n    # Example 1: A 1024-bit RSA key pair\n    # -----------------------------------\n\n\n    # Public key\n    # ----------\n\n    # Modulus:\n    a8 b3 b2 84 af 8e b5 0b 38 70 34 a8 60 f1 46 c4\n    91 9f 31 87 63 cd 6c 55 98 c8 ae 48 11 a1 e0 ab\n    c4 c7 e0 b0 82 d6 93 a5 e7 fc ed 67 5c f4 66 85\n    12 77 2c 0c bc 64 a7 42 c6 c6 30 f5 33 c8 cc 72\n    f6 2a e8 33 c4 0b f2 58 42 e9 84 bb 78 bd bf 97\n    c0 10 7d 55 bd b6 62 f5 c4 e0 fa b9 84 5c b5 14\n    8e f7 39 2d d3 aa ff 93 ae 1e 6b 66 7b b3 d4 24\n    76 16 d4 f5 ba 10 d4 cf d2 26 de 88 d3 9f 16 fb\n\n    # Exponent:\n    01 00 01\n\n    # Private key\n    # -----------\n\n    # Modulus:\n    a8 b3 b2 84 af 8e b5 0b 38 70 34 a8 60 f1 46 c4\n    91 9f 31 87 63 cd 6c 55 98 c8 ae 48 11 a1 e0 ab\n    c4 c7 e0 b0 82 d6 93 a5 e7 fc ed 67 5c f4 66 85\n    12 77 2c 0c bc 64 a7 42 c6 c6 30 f5 33 c8 cc 72\n    f6 2a e8 33 c4 0b f2 58 42 e9 84 bb 78 bd bf 97\n    c0 10 7d 55 bd b6 62 f5 c4 e0 fa b9 84 5c b5 14\n    8e f7 39 2d d3 aa ff 93 ae 1e 6b 66 7b b3 d4 24\n    76 16 d4 f5 ba 10 d4 cf d2 26 de 88 d3 9f 16 fb\n\n    # Public exponent:\n    01 00 01\n\n    # Exponent:\n    53 33 9c fd b7 9f c8 46 6a 65 5c 73 16 ac a8 5c\n    55 fd 8f 6d d8 98 fd af 11 95 17 ef 4f 52 e8 fd\n    8e 25 8d f9 3f ee 18 0f a0 e4 ab 29 69 3c d8 3b\n    15 2a 55 3d 4a c4 d1 81 2b 8b 9f a5 af 0e 7f 55\n    fe 73 04 df 41 57 09 26 f3 31 1f 15 c4 d6 5a 73\n    2c 48 31 16 ee 3d 3d 2d 0a f3 54 9a d9 bf 7c bf\n    b7 8a d8 84 f8 4d 5b eb 04 72 4d c7 36 9b 31 de\n    f3 7d 0c f5 39 e9 cf cd d3 de 65 37 29 ea d5 d1\n\n    # Prime 1:\n    d3 27 37 e7 26 7f fe 13 41 b2 d5 c0 d1 50 a8 1b\n    58 6f b3 13 2b ed 2f 8d 52 62 86 4a 9c b9 f3 0a\n    f3 8b e4 48 59 8d 41 3a 17 2e fb 80 2c 21 ac f1\n    c1 1c 52 0c 2f 26 a4 71 dc ad 21 2e ac 7c a3 9d\n\n    # Prime 2:\n    cc 88 53 d1 d5 4d a6 30 fa c0 04 f4 71 f2 81 c7\n    b8 98 2d 82 24 a4 90 ed be b3 3d 3e 3d 5c c9 3c\n    47 65 70 3d 1d d7 91 64 2f 1f 11 6a 0d d8 52 be\n    24 19 b2 af 72 bf e9 a0 30 e8 60 b0 28 8b 5d 77\n\n    # Prime exponent 1:\n    0e 12 bf 17 18 e9 ce f5 59 9b a1 c3 88 2f e8 04\n    6a 90 87 4e ef ce 8f 2c cc 20 e4 f2 74 1f b0 a3\n    3a 38 48 ae c9 c9 30 5f be cb d2 d7 68 19 96 7d\n    46 71 ac c6 43 1e 40 37 96 8d b3 78 78 e6 95 c1\n\n    # Prime exponent 2:\n    95 29 7b 0f 95 a2 fa 67 d0 07 07 d6 09 df d4 fc\n    05 c8 9d af c2 ef 6d 6e a5 5b ec 77 1e a3 33 73\n    4d 92 51 e7 90 82 ec da 86 6e fe f1 3c 45 9e 1a\n    63 13 86 b7 e3 54 c8 99 f5 f1 12 ca 85 d7 15 83\n\n    # Coefficient:\n    4f 45 6c 50 24 93 bd c0 ed 2a b7 56 a3 a6 ed 4d\n    67 35 2a 69 7d 42 16 e9 32 12 b1 27 a6 3d 54 11\n    ce 6f a9 8d 5d be fd 73 26 3e 37 28 14 27 43 81\n    81 66 ed 7d d6 36 87 dd 2a 8c a1 d2 f4 fb d8 e1\n\n    # RSA-OAEP encryption of 6 random messages with random seeds\n    # -----------------------------------------------------------\n\n    # OAEP Example 1.1\n    # ------------------\n\n    # Message:\n    66 28 19 4e 12 07 3d b0 3b a9 4c da 9e f9 53 23\n    97 d5 0d ba 79 b9 87 00 4a fe fe 34\n\n    # Seed:\n    18 b7 76 ea 21 06 9d 69 77 6a 33 e9 6b ad 48 e1\n    dd a0 a5 ef\n\n    # Encryption:\n    35 4f e6 7b 4a 12 6d 5d 35 fe 36 c7 77 79 1a 3f\n    7b a1 3d ef 48 4e 2d 39 08 af f7 22 fa d4 68 fb\n    21 69 6d e9 5d 0b e9 11 c2 d3 17 4f 8a fc c2 01\n    03 5f 7b 6d 8e 69 40 2d e5 45 16 18 c2 1a 53 5f\n    a9 d7 bf c5 b8 dd 9f c2 43 f8 cf 92 7d b3 13 22\n    d6 e8 81 ea a9 1a 99 61 70 e6 57 a0 5a 26 64 26\n    d9 8c 88 00 3f 84 77 c1 22 70 94 a0 d9 fa 1e 8c\n    40 24 30 9c e1 ec cc b5 21 00 35 d4 7a c7 2e 8a\n\n    # OAEP Example 1.2\n    # ------------------\n\n    # Message:\n    75 0c 40 47 f5 47 e8 e4 14 11 85 65 23 29 8a c9\n    ba e2 45 ef af 13 97 fb e5 6f 9d d5\n\n    # Seed:\n    0c c7 42 ce 4a 9b 7f 32 f9 51 bc b2 51 ef d9 25\n    fe 4f e3 5f\n\n    # Encryption:\n    64 0d b1 ac c5 8e 05 68 fe 54 07 e5 f9 b7 01 df\n    f8 c3 c9 1e 71 6c 53 6f c7 fc ec 6c b5 b7 1c 11\n    65 98 8d 4a 27 9e 15 77 d7 30 fc 7a 29 93 2e 3f\n    00 c8 15 15 23 6d 8d 8e 31 01 7a 7a 09 df 43 52\n    d9 04 cd eb 79 aa 58 3a dc c3 1e a6 98 a4 c0 52\n    83 da ba 90 89 be 54 91 f6 7c 1a 4e e4 8d c7 4b\n    bb e6 64 3a ef 84 66 79 b4 cb 39 5a 35 2d 5e d1\n    15 91 2d f6 96 ff e0 70 29 32 94 6d 71 49 2b 44\n\n    # =============================================\n    \"\"\"\n    ).splitlines()\n\n    vectors = load_pkcs1_vectors(vector_data)\n    expected = [\n        (\n            {\n                \"modulus\": int(\n                    \"a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae481\"\n                    \"1a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6\"\n                    \"c630f533c8cc72f62ae833c40bf25842e984bb78bdbf97c0107d55bdb\"\n                    \"662f5c4e0fab9845cb5148ef7392dd3aaff93ae1e6b667bb3d4247616\"\n                    \"d4f5ba10d4cfd226de88d39f16fb\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n                \"private_exponent\": int(\n                    \"53339cfdb79fc8466a655c7316aca85c55fd8f6dd898fdaf119517ef4\"\n                    \"f52e8fd8e258df93fee180fa0e4ab29693cd83b152a553d4ac4d1812b\"\n                    \"8b9fa5af0e7f55fe7304df41570926f3311f15c4d65a732c483116ee3\"\n                    \"d3d2d0af3549ad9bf7cbfb78ad884f84d5beb04724dc7369b31def37d\"\n                    \"0cf539e9cfcdd3de653729ead5d1\",\n                    16,\n                ),\n                \"p\": int(\n                    \"d32737e7267ffe1341b2d5c0d150a81b586fb3132bed2f8d5262864a9\"\n                    \"cb9f30af38be448598d413a172efb802c21acf1c11c520c2f26a471dc\"\n                    \"ad212eac7ca39d\",\n                    16,\n                ),\n                \"q\": int(\n                    \"cc8853d1d54da630fac004f471f281c7b8982d8224a490edbeb33d3e3\"\n                    \"d5cc93c4765703d1dd791642f1f116a0dd852be2419b2af72bfe9a030\"\n                    \"e860b0288b5d77\",\n                    16,\n                ),\n                \"dmp1\": int(\n                    \"0e12bf1718e9cef5599ba1c3882fe8046a90874eefce8f2ccc20e4f27\"\n                    \"41fb0a33a3848aec9c9305fbecbd2d76819967d4671acc6431e403796\"\n                    \"8db37878e695c1\",\n                    16,\n                ),\n                \"dmq1\": int(\n                    \"95297b0f95a2fa67d00707d609dfd4fc05c89dafc2ef6d6ea55bec771\"\n                    \"ea333734d9251e79082ecda866efef13c459e1a631386b7e354c899f5\"\n                    \"f112ca85d71583\",\n                    16,\n                ),\n                \"iqmp\": int(\n                    \"4f456c502493bdc0ed2ab756a3a6ed4d67352a697d4216e93212b127a\"\n                    \"63d5411ce6fa98d5dbefd73263e3728142743818166ed7dd63687dd2a\"\n                    \"8ca1d2f4fbd8e1\",\n                    16,\n                ),\n                \"examples\": [\n                    {\n                        \"message\": b\"6628194e12073db03ba94cda9ef9532397d50dba7\"\n                        b\"9b987004afefe34\",\n                        \"seed\": b\"18b776ea21069d69776a33e96bad48e1dda0a5ef\",\n                        \"encryption\": b\"354fe67b4a126d5d35fe36c777791a3f7ba13d\"\n                        b\"ef484e2d3908aff722fad468fb21696de95d0b\"\n                        b\"e911c2d3174f8afcc201035f7b6d8e69402de5\"\n                        b\"451618c21a535fa9d7bfc5b8dd9fc243f8cf92\"\n                        b\"7db31322d6e881eaa91a996170e657a05a2664\"\n                        b\"26d98c88003f8477c1227094a0d9fa1e8c4024\"\n                        b\"309ce1ecccb5210035d47ac72e8a\",\n                    },\n                    {\n                        \"message\": b\"750c4047f547e8e41411856523298ac9bae245efa\"\n                        b\"f1397fbe56f9dd5\",\n                        \"seed\": b\"0cc742ce4a9b7f32f951bcb251efd925fe4fe35f\",\n                        \"encryption\": b\"640db1acc58e0568fe5407e5f9b701dff8c3c9\"\n                        b\"1e716c536fc7fcec6cb5b71c1165988d4a279e\"\n                        b\"1577d730fc7a29932e3f00c81515236d8d8e31\"\n                        b\"017a7a09df4352d904cdeb79aa583adcc31ea6\"\n                        b\"98a4c05283daba9089be5491f67c1a4ee48dc7\"\n                        b\"4bbbe6643aef846679b4cb395a352d5ed11591\"\n                        b\"2df696ffe0702932946d71492b44\",\n                    },\n                ],\n            },\n            {\n                \"modulus\": int(\n                    \"a8b3b284af8eb50b387034a860f146c4919f318763cd6c5598c8ae481\"\n                    \"1a1e0abc4c7e0b082d693a5e7fced675cf4668512772c0cbc64a742c6\"\n                    \"c630f533c8cc72f62ae833c40bf25842e984bb78bdbf97c0107d55bdb\"\n                    \"662f5c4e0fab9845cb5148ef7392dd3aaff93ae1e6b667bb3d4247616\"\n                    \"d4f5ba10d4cfd226de88d39f16fb\",\n                    16,\n                ),\n                \"public_exponent\": int(\"10001\", 16),\n            },\n        )\n    ]\n    assert vectors == expected\n\n\ndef test_load_hotp_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # HOTP Test Vectors\n    # RFC 4226 Appendix D\n\n    COUNT = 0\n    COUNTER = 0\n    INTERMEDIATE = cc93cf18508d94934c64b65d8ba7667fb7cde4b0\n    TRUNCATED = 4c93cf18\n    HOTP = 755224\n    SECRET = 12345678901234567890\n\n    COUNT = 1\n    COUNTER = 1\n    INTERMEDIATE = 75a48a19d4cbe100644e8ac1397eea747a2d33ab\n    TRUNCATED = 41397eea\n    HOTP = 287082\n    SECRET = 12345678901234567890\n\n\n    COUNT = 2\n    COUNTER = 2\n    INTERMEDIATE = 0bacb7fa082fef30782211938bc1c5e70416ff44\n    TRUNCATED = 82fef30\n    HOTP = 359152\n    SECRET = 12345678901234567890\n\n\n    COUNT = 3\n    COUNTER = 3\n    INTERMEDIATE = 66c28227d03a2d5529262ff016a1e6ef76557ece\n    TRUNCATED = 66ef7655\n    HOTP = 969429\n    SECRET = 12345678901234567890\n    \"\"\"\n    ).splitlines()\n\n    assert load_nist_vectors(vector_data) == [\n        {\n            \"counter\": b\"0\",\n            \"intermediate\": b\"cc93cf18508d94934c64b65d8ba7667fb7cde4b0\",\n            \"truncated\": b\"4c93cf18\",\n            \"hotp\": b\"755224\",\n            \"secret\": b\"12345678901234567890\",\n        },\n        {\n            \"counter\": b\"1\",\n            \"intermediate\": b\"75a48a19d4cbe100644e8ac1397eea747a2d33ab\",\n            \"truncated\": b\"41397eea\",\n            \"hotp\": b\"287082\",\n            \"secret\": b\"12345678901234567890\",\n        },\n        {\n            \"counter\": b\"2\",\n            \"intermediate\": b\"0bacb7fa082fef30782211938bc1c5e70416ff44\",\n            \"truncated\": b\"82fef30\",\n            \"hotp\": b\"359152\",\n            \"secret\": b\"12345678901234567890\",\n        },\n        {\n            \"counter\": b\"3\",\n            \"intermediate\": b\"66c28227d03a2d5529262ff016a1e6ef76557ece\",\n            \"truncated\": b\"66ef7655\",\n            \"hotp\": b\"969429\",\n            \"secret\": b\"12345678901234567890\",\n        },\n    ]\n\n\ndef test_load_totp_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # TOTP Test Vectors\n    # RFC 6238 Appendix B\n\n    COUNT = 0\n    TIME = 59\n    TOTP = 94287082\n    MODE = SHA1\n    SECRET = 12345678901234567890\n\n    COUNT = 1\n    TIME = 59\n    TOTP = 46119246\n    MODE = SHA256\n    SECRET = 12345678901234567890\n\n    COUNT = 2\n    TIME = 59\n    TOTP = 90693936\n    MODE = SHA512\n    SECRET = 12345678901234567890\n    \"\"\"\n    ).splitlines()\n\n    assert load_nist_vectors(vector_data) == [\n        {\n            \"time\": b\"59\",\n            \"totp\": b\"94287082\",\n            \"mode\": b\"SHA1\",\n            \"secret\": b\"12345678901234567890\",\n        },\n        {\n            \"time\": b\"59\",\n            \"totp\": b\"46119246\",\n            \"mode\": b\"SHA256\",\n            \"secret\": b\"12345678901234567890\",\n        },\n        {\n            \"time\": b\"59\",\n            \"totp\": b\"90693936\",\n            \"mode\": b\"SHA512\",\n            \"secret\": b\"12345678901234567890\",\n        },\n    ]\n\n\ndef test_load_rsa_nist_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.4\n    # \"SigGen PKCS#1 RSASSA-PSS\" information\n    # Mod sizes selected: 1024 1536 2048 3072 4096\n    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512\n    # Salt len: 20\n\n    [mod = 1024]\n\n    n = bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda707a146b3b4e29989d\n\n    e = 00000000000000000000000000000000000000000000000000000000000000000010001\n    SHAAlg = SHA1\n    Msg = 1248f62a4389f42f7b4bb131053d6c88a994db2075b912ccbe3ea7dc611714f14e\n    S = 682cf53c1145d22a50caa9eb1a9ba70670c5915e0fdfde6457a765de2a8fe12de97\n\n    SHAAlg = SHA384\n    Msg = e511903c2f1bfba245467295ac95413ac4746c984c3750a728c388aa628b0ebf\n    S = 9c748702bbcc1f9468864cd360c8c39d007b2d8aaee833606c70f7593cf0d1519\n\n    [mod = 1024]\n\n    n = 1234567890\n\n    e = 0010001\n\n    SHAAlg = SHA512\n    Msg = 3456781293fab829\n    S = deadbeef0000\n    \"\"\"\n    ).splitlines()\n\n    vectors = load_rsa_nist_vectors(vector_data)\n    assert vectors == [\n        {\n            \"modulus\": int(\n                \"bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda\"\n                \"707a146b3b4e29989d\",\n                16,\n            ),\n            \"public_exponent\": 65537,\n            \"algorithm\": \"SHA1\",\n            \"salt_length\": 20,\n            \"msg\": b\"1248f62a4389f42f7b4bb131053d6c88a994db2075b912ccbe3ea7dc6\"\n            b\"11714f14e\",\n            \"s\": b\"682cf53c1145d22a50caa9eb1a9ba70670c5915e0fdfde6457a765de2a8\"\n            b\"fe12de97\",\n            \"fail\": False,\n        },\n        {\n            \"modulus\": int(\n                \"bcb47b2e0dafcba81ff2a2b5cb115ca7e757184c9d72bcdcda\"\n                \"707a146b3b4e29989d\",\n                16,\n            ),\n            \"public_exponent\": 65537,\n            \"algorithm\": \"SHA384\",\n            \"salt_length\": 20,\n            \"msg\": b\"e511903c2f1bfba245467295ac95413ac4746c984c3750a728c388aa6\"\n            b\"28b0ebf\",\n            \"s\": b\"9c748702bbcc1f9468864cd360c8c39d007b2d8aaee833606c70f7593cf\"\n            b\"0d1519\",\n            \"fail\": False,\n        },\n        {\n            \"modulus\": 78187493520,\n            \"public_exponent\": 65537,\n            \"algorithm\": \"SHA512\",\n            \"salt_length\": 20,\n            \"msg\": b\"3456781293fab829\",\n            \"s\": b\"deadbeef0000\",\n            \"fail\": False,\n        },\n    ]\n\n\ndef test_load_rsa_nist_pkcs1v15_verification_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.0\n    # \"SigVer PKCS#1 Ver 1.5\" information\n    # Mod sizes selected: 1024 1536 2048 3072 4096\n    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512\n    # Generated on Wed Mar 02 00:13:02 2011\n\n    [mod = 1024]\n\n    n = be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b9bfeb7aa72db126411\n\n    p = e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003eaa5931e6be5c3\n    q = d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e49354d66ff84f\n\n    SHAAlg = SHA1\n    e = 00000000000000000000000000000000000000000000000000000000000000000011\n    d = 0d0f17362bdad181db4e1fe03e8de1a3208989914e14bf269558826bfa20faf4b68d\n    Msg = 6b9cfac0ba1c7890b13e381ce752195cc1375237db2afcf6a9dcd1f95ec733a80c\n    S = 562d87b5781c01d166fef3972669a0495c145b898a17df4743fbefb0a1582bd6ba9d\n    SaltVal = 11223344555432167890\n    Result = F (3 - Signature changed )\n\n    SHAAlg = SHA1\n    e = 0000000000003\n    d = bfa20faf4b68d\n    Msg = 2a67c70ff14f9b34ddb42e6f89d5971057a0da980fc9ae70c81a84da0c0ac42737\n    S = 2b91c6ae2b3c46ff18d5b7abe239634cb752d0acb53eea0ccd8ea8483036a50e8faf\n    SaltVal = 11223344555432167890\n    Result = P\n    \"\"\"\n    ).splitlines()\n\n    vectors = load_rsa_nist_vectors(vector_data)\n    assert vectors == [\n        {\n            \"modulus\": int(\n                \"be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b\"\n                \"9bfeb7aa72db126411\",\n                16,\n            ),\n            \"p\": int(\n                \"e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003ea\"\n                \"a5931e6be5c3\",\n                16,\n            ),\n            \"q\": int(\n                \"d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e4\"\n                \"9354d66ff84f\",\n                16,\n            ),\n            \"public_exponent\": 17,\n            \"algorithm\": \"SHA1\",\n            \"private_exponent\": int(\n                \"0d0f17362bdad181db4e1fe03e8de1a3208989914\"\n                \"e14bf269558826bfa20faf4b68d\",\n                16,\n            ),\n            \"msg\": b\"6b9cfac0ba1c7890b13e381ce752195cc1375237db2afcf6a9dcd1f95\"\n            b\"ec733a80c\",\n            \"s\": b\"562d87b5781c01d166fef3972669a0495c145b898a17df4743fbefb0a15\"\n            b\"82bd6ba9d\",\n            \"saltval\": b\"11223344555432167890\",\n            \"fail\": True,\n        },\n        {\n            \"modulus\": int(\n                \"be499b5e7f06c83fa0293e31465c8eb6b58af920bae52a7b5b\"\n                \"9bfeb7aa72db126411\",\n                16,\n            ),\n            \"p\": int(\n                \"e7a80c5d211c06acb900939495f26d365fc2b4825b75e356f89003ea\"\n                \"a5931e6be5c3\",\n                16,\n            ),\n            \"q\": int(\n                \"d248aa248000f720258742da67b711940c8f76e1ecd52b67a6ffe1e4\"\n                \"9354d66ff84f\",\n                16,\n            ),\n            \"public_exponent\": 3,\n            \"algorithm\": \"SHA1\",\n            \"private_exponent\": int(\"bfa20faf4b68d\", 16),\n            \"msg\": b\"2a67c70ff14f9b34ddb42e6f89d5971057a0da980fc9ae70c81a84da0\"\n            b\"c0ac42737\",\n            \"s\": b\"2b91c6ae2b3c46ff18d5b7abe239634cb752d0acb53eea0ccd8ea848303\"\n            b\"6a50e8faf\",\n            \"saltval\": b\"11223344555432167890\",\n            \"fail\": False,\n        },\n    ]\n\n\ndef test_load_rsa_nist_pss_verification_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.0\n    # \"SigVer PKCS#1 RSASSA-PSS\" information\n    # Mod sizes selected: 1024 1536 2048 3072 4096\n    # SHA Algorithm selected:SHA1 SHA224 SHA256 SHA384 SHA512\n    # Salt len: 10\n    # Generated on Wed Mar 02 00:25:22 2011\n\n    [mod = 1024]\n\n    n = be499b5e7f06c83fa0293e31465c8eb6b5\n\n    p = e7a80c5d211c06acb900939495f26d365f\n    q = d248aa248000f720258742da67b711940c\n\n    SHAAlg = SHA1\n    e = 00000000000000011\n    d = c8e26a88239672cf49b3422a07c4d834ba\n    Msg = 6b9cfac0ba1c7890b13e381ce752195c\n    S = 562d87b5781c01d166fef3972669a0495c\n    SaltVal = 11223344555432167890\n    Result = F (3 - Signature changed )\n\n    SHAAlg = SHA384\n    e = 000003\n    d = 0d0f17362bdad181db4e1fe03e8de1a320\n    Msg = 2a67c70ff14f9b34ddb42e6f89d59710\n    S = 2b91c6ae2b3c46ff18d5b7abe239634cb7\n    SaltVal = 11223344555432167890\n    Result = P\n    \"\"\"\n    ).splitlines()\n\n    vectors = load_rsa_nist_vectors(vector_data)\n    assert vectors == [\n        {\n            \"modulus\": int(\"be499b5e7f06c83fa0293e31465c8eb6b5\", 16),\n            \"p\": int(\"e7a80c5d211c06acb900939495f26d365f\", 16),\n            \"q\": int(\"d248aa248000f720258742da67b711940c\", 16),\n            \"public_exponent\": 17,\n            \"algorithm\": \"SHA1\",\n            \"private_exponent\": int(\"c8e26a88239672cf49b3422a07c4d834ba\", 16),\n            \"msg\": b\"6b9cfac0ba1c7890b13e381ce752195c\",\n            \"s\": b\"562d87b5781c01d166fef3972669a0495c\",\n            \"saltval\": b\"11223344555432167890\",\n            \"salt_length\": 10,\n            \"fail\": True,\n        },\n        {\n            \"modulus\": int(\"be499b5e7f06c83fa0293e31465c8eb6b5\", 16),\n            \"p\": int(\"e7a80c5d211c06acb900939495f26d365f\", 16),\n            \"q\": int(\"d248aa248000f720258742da67b711940c\", 16),\n            \"public_exponent\": 3,\n            \"algorithm\": \"SHA384\",\n            \"private_exponent\": int(\"0d0f17362bdad181db4e1fe03e8de1a320\", 16),\n            \"msg\": b\"2a67c70ff14f9b34ddb42e6f89d59710\",\n            \"s\": b\"2b91c6ae2b3c46ff18d5b7abe239634cb7\",\n            \"saltval\": b\"11223344555432167890\",\n            \"salt_length\": 10,\n            \"fail\": False,\n        },\n    ]\n\n\ndef test_load_fips_dsa_key_pair_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.1\n    #  \"KeyPair\" information\n    #  Mod sizes selected: L=1024, N=160:: L=2048, N=224 :: L=2048, N=256 :: L\n=3072, N=256\n    # Generated on Wed May 04 08:50:52 2011\n\n\n    [mod = L=1024, N=160]\n\n    P = d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef341eabb47cf8a7a\\\n8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6b502e59050b5b21ce263dddb2044b65223\\\n6f4d42ab4b5d6aa73189cef1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097\\\nf719076640e20980a0093113a8bd73\n    Q = 96c5390a8b612c0e422bb2b0ea194a3ec935a281\n    G = 06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce4991d2b862259d6b\\\n4548a6495b195aa0e0b6137ca37eb23b94074d3c3d300042bdf15762812b6333ef7b07ceba7860\\\n7610fcc9ee68491dbc1e34cd12615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3\\\nf4fd9f93cd6f4f17fc076341a7e7d9\n\n    X = 8185fee9cc7c0e91fd85503274f1cd5a3fd15a49\n    Y = 6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422070edb71db44ff5682\\\n80fdb1709f8fc3feab39f1f824adaeb2a298088156ac31af1aa04bf54f475bdcfdcf2f8a2dd973\\\ne922d83e76f016558617603129b21c70bf7d0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1c\\\ne80204646bf99b5771d249a6fea627\n\n    X = 85322d6ea73083064376099ca2f65f56e8522d9b\n    Y = 21f8690f717c9f4dcb8f4b6971de2f15b9231fcf41b7eeb997d781f240bfdddfd2090d\\\n22083c26cca39bf37c9caf1ec89518ea64845a50d747b49131ffff6a2fd11ea7bacbb93c7d0513\\\n7383a06365af82225dd3713ca5a45006316f53bd12b0e260d5f79795e5a4c9f353f12867a1d320\\\n2394673ada8563b71555e53f415254\n\n    [mod = L=2048, N=256]\n\n    P = ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace5e9c41434c9cf0a8e9\\\n498acb0f4663c08b4484eace845f6fb17dac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc\\\n1a66f3e8b12252c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d244e54561\\\nb0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5119fbf78ebe3e6564ee235c6a15cb\\\nb9ac247baba5a423bc6582a1a9d8a2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf2\\\n1bff2947fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a908c36e95e60\\\nbf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac5aa66ef7\n    Q = 8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b18f507192c19d\n    G = e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b1913413d344d1d\\\n8d84a333839d88eee431521f6e357c16e6a93be111a98076739cd401bab3b9d565bf4fb99e9d18\\\n5b1e14d61c93700133f908bae03e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5\\\n551b2fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78d0706b10a26f23b\\\n4f197c322b825002284a0aca91807bba98ece912b80e10cdf180cf99a35f210c1655fbfdd74f13\\\nb1b5046591f8403873d12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b14\\\n6ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302\n\n    X = 405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6bd818a0348a1\n    Y = 6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5b0434e1253092e8a0b\\\n231f9c87f3fc8a4cb5634eb194bf1b638b7a7889620ce6711567e36aa36cda4604cfaa601a4591\\\n8371d4ccf68d8b10a50a0460eb1dc0fff62ef5e6ee4d473e18ea4a66c196fb7e677a49b48241a0\\\nb4a97128eff30fa437050501a584f8771e7280d26d5af30784039159c11ebfea10b692fd0a5821\\\n5eeb18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e9773505166f4bd8cedbb286\\\nea28232972da7bae836ba97329ba6b0a36508e50a52a7675e476d4d4137eae13f22a9d2fefde70\\\n8ba8f34bf336c6e76331761e4b0617633fe7ec3f23672fb19d27\n\n    X = 0e0b95e31fda3f888059c46c3002ef8f2d6be112d0209aeb9e9545da67aeea80\n    Y = 778082b77ddba6f56597cc74c3a612abf2ddbd85cc81430c99ab843c1f630b9db01399\\\n65f563978164f9bf3a8397256be714625cd41cd7fa0067d94ea66d7e073f7125af692ad01371d4\\\na17f4550590378f2b074030c20e36911598a1018772f61be3b24de4be5a388ccc09e15a92819c3\\\n1dec50de9fde105b49eaa097b9d13d9219eeb33b628facfd1c78a7159c8430d0647c506e7e3de7\\\n4763cb351eada72c00bef3c9641881e6254870c1e6599f8ca2f1bbb74f39a905e3a34e4544168e\\\n6e50c9e3305fd09cab6ed4aff6fda6e0d5bf375c81ac9054406d9193b003c89272f1bd83d48250\\\n134b65c77c2b6332d38d34d9016f0e8975536ad6c348a1faedb0\n\n    [mod = L=3072, N=256]\n\n    P = f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828c352f593a9a7\\\n87760ce34b789879941f2f01f02319f6ae0b756f1a842ba54c85612ed632ee2d79ef17f06b77c6\\\n41b7b080aff52a03fc2462e80abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a8\\\n4ec389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651b372f8b58a0a65554d\\\nb2561d706a63685000ac576b7e4562e262a14285a9c6370b290e4eb7757527d80b6c0fd5df831d\\\n36f3d1d35f12ab060548de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9844\\\nd48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d54f90cce1a491a9c74fea88f\\\n7e7230b047d16b5a6027881d6f154818f06e513faf40c8814630e4e254f17a47bfe9cb519b9828\\\n9935bf17673ae4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476cd715eaab\\\nb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c1136f303f4b4d25ad5b692229957\n    Q = d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210f6169041653b\n    G = ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978db2104d7394b493c183\\\n32c64cec906a71c3778bd93341165dee8e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4\\\n768b82dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1395420d778228f1461f5d0\\\nb8e47357e87b1fe3286223b553e3fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce7782\\\n0d88cdf50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721ff141f93a9fb23c1\\\nd1f7654c07c46e58836d1652828f71057b8aff0b0778ef2ca934ea9d0f37daddade2d823a4d8e3\\\n62721082e279d003b575ee59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b\\\n0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd10117e45774406c4c947da802\\\n0649c3168f690e0bd6e91ac67074d1d436b58ae374523deaf6c93c1e6920db4a080b744804bb07\\\n3cecfe83fa9398cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d775ae\n\n    X = b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef033097de954b17706\n    Y = 814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f2418871968c2\\\nbabfc2baf47742148828f8612183178f126504da73566b6bab33ba1f124c15aa461555c2451d86\\\nc94ee21c3e3fc24c55527e01b1f03adcdd8ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0\\\nce0078d3d414d31fa47e9726be2989b8d06da2e6cd363f5a7d1515e3f4925e0b32adeae3025cc5\\\na996f6fd27494ea408763de48f3bb39f6a06514b019899b312ec570851637b8865cff3a52bf5d5\\\n4ad5a19e6e400a2d33251055d0a440b50d53f4791391dc754ad02b9eab74c46b4903f9d76f8243\\\n39914db108057af7cde657d41766a99991ac8787694f4185d6f91d7627048f827b405ec67bf2fe\\\n56141c4c581d8c317333624e073e5879a82437cb0c7b435c0ce434e15965db1315d64895991e6b\\\nbe7dac040c42052408bbc53423fd31098248a58f8a67da3a39895cd0cc927515d044c1e3cb6a32\\\n59c3d0da354cce89ea3552c59609db10ee989986527436af21d9485ddf25f90f7dff6d2bae\n\n    X = 52e3e040efb30e1befd909a0bdbcfd140d005b1bff094af97186080262f1904d\n    Y = a5ae6e8f9b7a68ab0516dad4d7b7d002126f811d5a52e3d35c6d387fcb43fd19bf7792\\\n362f9c98f8348aa058bb62376685f3d0c366c520d697fcd8416947151d4bbb6f32b53528a01647\\\n9e99d2cd48d1fc679027c15f0042f207984efe05c1796bca8eba678dfdd00b80418e3ea840557e\\\n73b09e003882f9a68edba3431d351d1ca07a8150b018fdbdf6c2f1ab475792a3ccaa6594472a45\\\nf8dc777b60bf67de3e0f65c20d11b7d59faedf83fbce52617f500d9e514947c455274c6e900464\\\n767fb56599b81344cf6d12c25cb2b7d038d7b166b6cf30534811c15d0e8ab880a2ac06786ae2dd\\\nde61329a78d526f65245380ce877e979c5b50de66c9c30d66382c8f254653d25a1eb1d3a4897d7\\\n623399b473ce712a2184cf2da1861706c41466806aefe41b497db82aca6c31c8f4aa68c17d1d9e\\\n380b57998917655783ec96e5234a131f7299398d36f1f5f84297a55ff292f1f060958c358fed34\\\n6db2de45127ca728a9417b2c54203e33e53b9a061d924395b09afab8daf3e8dd7eedcec3ac\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"g\": int(\n                \"06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce499\"\n                \"1d2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d3000\"\n                \"42bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34cd12\"\n                \"615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f\"\n                \"4fd9f93cd6f4f17fc076341a7e7d9\",\n                16,\n            ),\n            \"p\": int(\n                \"d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725e\"\n                \"f341eabb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae791210\"\n                \"2b6b502e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189c\"\n                \"ef1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097f7\"\n                \"19076640e20980a0093113a8bd73\",\n                16,\n            ),\n            \"q\": int(\"96c5390a8b612c0e422bb2b0ea194a3ec935a281\", 16),\n            \"x\": int(\"8185fee9cc7c0e91fd85503274f1cd5a3fd15a49\", 16),\n            \"y\": int(\n                \"6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422\"\n                \"070edb71db44ff568280fdb1709f8fc3feab39f1f824adaeb2a29808815\"\n                \"6ac31af1aa04bf54f475bdcfdcf2f8a2dd973e922d83e76f01655861760\"\n                \"3129b21c70bf7d0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1ce80\"\n                \"204646bf99b5771d249a6fea627\",\n                16,\n            ),\n        },\n        {\n            \"g\": int(\n                \"06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce4991d\"\n                \"2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d30004\"\n                \"2bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34cd126\"\n                \"15474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f4fd9\"\n                \"f93cd6f4f17fc076341a7e7d9\",\n                16,\n            ),\n            \"p\": int(\n                \"d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef341e\"\n                \"abb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6b50\"\n                \"2e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189cef1a\"\n                \"ce778d7845a5c1c1c7147123188f8dc551054ee162b634d6\"\n                \"0f097f719076640e20980a0093113a8bd73\",\n                16,\n            ),\n            \"q\": int(\"96c5390a8b612c0e422bb2b0ea194a3ec935a281\", 16),\n            \"x\": int(\"85322d6ea73083064376099ca2f65f56e8522d9b\", 16),\n            \"y\": int(\n                \"21f8690f717c9f4dcb8f4b6971de2f15b9231fcf41b7eeb997d781f240\"\n                \"bfdddfd2090d22083c26cca39bf37c9caf1ec89518ea64845a50d747b49\"\n                \"131ffff6a2fd11ea7bacbb93c7d05137383a06365af82225dd3713c\"\n                \"a5a45006316f53bd12b0e260d5f79795e5a4c9f353f12867a1d3\"\n                \"202394673ada8563b71555e53f415254\",\n                16,\n            ),\n        },\n        {\n            \"g\": int(\n                \"e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b191\"\n                \"3413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9807\"\n                \"6739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908bae0\"\n                \"3e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5551b2\"\n                \"fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78\"\n                \"d0706b10a26f23b4f197c322b825002284a0aca91807bba98ece912\"\n                \"b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f8403873d\"\n                \"12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b1\"\n                \"46ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302\",\n                16,\n            ),\n            \"p\": int(\n                \"ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace\"\n                \"5e9c41434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17d\"\n                \"ac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b122\"\n                \"52c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d2\"\n                \"44e54561b0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5\"\n                \"119fbf78ebe3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a\"\n                \"2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf21bff2947\"\n                \"fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a\"\n                \"908c36e95e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac\"\n                \"5aa66ef7\",\n                16,\n            ),\n            \"q\": int(\n                \"8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b1\"\n                \"8f507192c19d\",\n                16,\n            ),\n            \"x\": int(\n                \"405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6\"\n                \"bd818a0348a1\",\n                16,\n            ),\n            \"y\": int(\n                \"6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5\"\n                \"b0434e1253092e8a0b231f9c87f3fc8a4cb5634eb194bf1b638\"\n                \"b7a7889620ce6711567e36aa36cda4604cfaa601a45918371d\"\n                \"4ccf68d8b10a50a0460eb1dc0fff62ef5e6ee4d473e18ea4a6\"\n                \"6c196fb7e677a49b48241a0b4a97128eff30fa437050501a584\"\n                \"f8771e7280d26d5af30784039159c11ebfea10b692fd0a58215ee\"\n                \"b18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e97\"\n                \"73505166f4bd8cedbb286ea28232972da7bae836ba97329ba6b0a36508\"\n                \"e50a52a7675e476d4d4137eae13f22a9d2fefde708ba8f34bf336c6e7\"\n                \"6331761e4b0617633fe7ec3f23672fb19d27\",\n                16,\n            ),\n        },\n        {\n            \"g\": int(\n                \"e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b191\"\n                \"3413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9807\"\n                \"6739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908bae0\"\n                \"3e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d5551b2\"\n                \"fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c61568f78\"\n                \"d0706b10a26f23b4f197c322b825002284a0aca91807bba98ece912\"\n                \"b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f8403873d\"\n                \"12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed273b1\"\n                \"46ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302\",\n                16,\n            ),\n            \"p\": int(\n                \"ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace\"\n                \"5e9c41434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17d\"\n                \"ac62c98e706af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b122\"\n                \"52c40278fff9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d2\"\n                \"44e54561b0dca39b301de8c49da9fb23df33c6182e3f983208c560fb5\"\n                \"119fbf78ebe3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a\"\n                \"2b4f0e9e3d9dbac122f750dd754325135257488b1f6ecabf21bff2947\"\n                \"fe0d3b2cb7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a\"\n                \"908c36e95e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac\"\n                \"5aa66ef7\",\n                16,\n            ),\n            \"q\": int(\n                \"8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b1\"\n                \"8f507192c19d\",\n                16,\n            ),\n            \"x\": int(\n                \"0e0b95e31fda3f888059c46c3002ef8f2d6be112d0209aeb9e95\"\n                \"45da67aeea80\",\n                16,\n            ),\n            \"y\": int(\n                \"778082b77ddba6f56597cc74c3a612abf2ddbd85cc81430c99ab\"\n                \"843c1f630b9db0139965f563978164f9bf3a8397256be714625\"\n                \"cd41cd7fa0067d94ea66d7e073f7125af692ad01371d4a17f45\"\n                \"50590378f2b074030c20e36911598a1018772f61be3b24de4be\"\n                \"5a388ccc09e15a92819c31dec50de9fde105b49eaa097b9d13d\"\n                \"9219eeb33b628facfd1c78a7159c8430d0647c506e7e3de74763c\"\n                \"b351eada72c00bef3c9641881e6254870c1e6599f8ca2f1bbb74f\"\n                \"39a905e3a34e4544168e6e50c9e3305fd09cab6ed4aff6fda6e0d\"\n                \"5bf375c81ac9054406d9193b003c89272f1bd83d48250134b65c77\"\n                \"c2b6332d38d34d9016f0e8975536ad6c348a1faedb0\",\n                16,\n            ),\n        },\n        {\n            \"g\": int(\n                \"ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978d\"\n                \"b2104d7394b493c18332c64cec906a71c3778bd93341165dee8\"\n                \"e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4768b82\"\n                \"dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1\"\n                \"395420d778228f1461f5d0b8e47357e87b1fe3286223b553e3\"\n                \"fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce77820d88cdf\"\n                \"50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721f\"\n                \"f141f93a9fb23c1d1f7654c07c46e58836d1652828f71057b8aff0b077\"\n                \"8ef2ca934ea9d0f37daddade2d823a4d8e362721082e279d003b575ee\"\n                \"59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b\"\n                \"0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd1011\"\n                \"7e45774406c4c947da8020649c3168f690e0bd6e91ac67074d1d436b\"\n                \"58ae374523deaf6c93c1e6920db4a080b744804bb073cecfe83fa939\"\n                \"8cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d\"\n                \"775ae\",\n                16,\n            ),\n            \"p\": int(\n                \"f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828\"\n                \"c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a842\"\n                \"ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e8\"\n                \"0abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84ec\"\n                \"389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651\"\n                \"b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a1428\"\n                \"5a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab0605\"\n                \"48de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9\"\n                \"844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d\"\n                \"54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818f\"\n                \"06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673a\"\n                \"e4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476\"\n                \"cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c11\"\n                \"36f303f4b4d25ad5b692229957\",\n                16,\n            ),\n            \"q\": int(\n                \"d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210\"\n                \"f6169041653b\",\n                16,\n            ),\n            \"x\": int(\n                \"b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef03309\"\n                \"7de954b17706\",\n                16,\n            ),\n            \"y\": int(\n                \"814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f2\"\n                \"418871968c2babfc2baf47742148828f8612183178f126504da73566b6\"\n                \"bab33ba1f124c15aa461555c2451d86c94ee21c3e3fc24c55527e\"\n                \"01b1f03adcdd8ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0c\"\n                \"e0078d3d414d31fa47e9726be2989b8d06da2e6cd363f5a7d1515e3f4\"\n                \"925e0b32adeae3025cc5a996f6fd27494ea408763de48f3bb39f6a06\"\n                \"514b019899b312ec570851637b8865cff3a52bf5d54ad5a19e6e400\"\n                \"a2d33251055d0a440b50d53f4791391dc754ad02b9eab74c46b4903\"\n                \"f9d76f824339914db108057af7cde657d41766a99991ac8787694f\"\n                \"4185d6f91d7627048f827b405ec67bf2fe56141c4c581d8c317333\"\n                \"624e073e5879a82437cb0c7b435c0ce434e15965db1315d648959\"\n                \"91e6bbe7dac040c42052408bbc53423fd31098248a58f8a67da3a\"\n                \"39895cd0cc927515d044c1e3cb6a3259c3d0da354cce89ea3552c\"\n                \"59609db10ee989986527436af21d9485ddf25f90f7dff6d2bae\",\n                16,\n            ),\n        },\n        {\n            \"g\": int(\n                \"ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978d\"\n                \"b2104d7394b493c18332c64cec906a71c3778bd93341165dee8\"\n                \"e6cd4ca6f13afff531191194ada55ecf01ff94d6cf7c4768b82\"\n                \"dd29cd131aaf202aefd40e564375285c01f3220af4d70b96f1\"\n                \"395420d778228f1461f5d0b8e47357e87b1fe3286223b553e3\"\n                \"fc9928f16ae3067ded6721bedf1d1a01bfd22b9ae85fce77820d88cdf\"\n                \"50a6bde20668ad77a707d1c60fcc5d51c9de488610d0285eb8ff721f\"\n                \"f141f93a9fb23c1d1f7654c07c46e58836d1652828f71057b8aff0b077\"\n                \"8ef2ca934ea9d0f37daddade2d823a4d8e362721082e279d003b575ee\"\n                \"59fd050d105dfd71cd63154efe431a0869178d9811f4f231dc5dcf3b\"\n                \"0ec0f2b0f9896c32ec6c7ee7d60aa97109e09224907328d4e6acd1011\"\n                \"7e45774406c4c947da8020649c3168f690e0bd6e91ac67074d1d436b\"\n                \"58ae374523deaf6c93c1e6920db4a080b744804bb073cecfe83fa939\"\n                \"8cf150afa286dc7eb7949750cf5001ce104e9187f7e16859afa8fd0d\"\n                \"775ae\",\n                16,\n            ),\n            \"p\": int(\n                \"f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d5828\"\n                \"c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a842\"\n                \"ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e8\"\n                \"0abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84ec\"\n                \"389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea2651\"\n                \"b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a1428\"\n                \"5a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab0605\"\n                \"48de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba9\"\n                \"844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1d\"\n                \"54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818f\"\n                \"06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673a\"\n                \"e4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f7476\"\n                \"cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c11\"\n                \"36f303f4b4d25ad5b692229957\",\n                16,\n            ),\n            \"q\": int(\n                \"d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210\"\n                \"f6169041653b\",\n                16,\n            ),\n            \"x\": int(\n                \"52e3e040efb30e1befd909a0bdbcfd140d005b1bff094af97186\"\n                \"080262f1904d\",\n                16,\n            ),\n            \"y\": int(\n                \"a5ae6e8f9b7a68ab0516dad4d7b7d002126f811d5a52e3d35c6d\"\n                \"387fcb43fd19bf7792362f9c98f8348aa058bb62376685f3d0c3\"\n                \"66c520d697fcd8416947151d4bbb6f32b53528a016479e99d2cd\"\n                \"48d1fc679027c15f0042f207984efe05c1796bca8eba678dfdd0\"\n                \"0b80418e3ea840557e73b09e003882f9a68edba3431d351d1ca0\"\n                \"7a8150b018fdbdf6c2f1ab475792a3ccaa6594472a45f8dc777b\"\n                \"60bf67de3e0f65c20d11b7d59faedf83fbce52617f500d9e5149\"\n                \"47c455274c6e900464767fb56599b81344cf6d12c25cb2b7d038\"\n                \"d7b166b6cf30534811c15d0e8ab880a2ac06786ae2ddde61329a\"\n                \"78d526f65245380ce877e979c5b50de66c9c30d66382c8f25465\"\n                \"3d25a1eb1d3a4897d7623399b473ce712a2184cf2da1861706c4\"\n                \"1466806aefe41b497db82aca6c31c8f4aa68c17d1d9e380b5799\"\n                \"8917655783ec96e5234a131f7299398d36f1f5f84297a55ff292\"\n                \"f1f060958c358fed346db2de45127ca728a9417b2c54203e33e5\"\n                \"3b9a061d924395b09afab8daf3e8dd7eedcec3ac\",\n                16,\n            ),\n        },\n    ]\n\n    assert expected == load_fips_dsa_key_pair_vectors(vector_data)\n\n\ndef test_load_fips_dsa_sig_ver_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.0\n    # \"SigVer\" information\n    # Mod sizes selected: SHA-1 L=1024, N=160,SHA-384 L=2048, N=256\n    # Generated on Fri Apr 01 08:37:15 2011\n\n    [mod = L=1024, N=160, SHA-1]\n\n    P = dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1f35147b795cae\\\na923f0d3577158f8a0c89dabd1962c2c453306b5d70cacfb01430aceb54e5a5fa6f93\\\n40d3bd2da612fceeb76b0ec1ebfae635a56ab141b108e00dc76eefe2edd0c514c21c4\\\n57457c39065dba9d0ecb7569c247172d8438ad2827b60435b\n    Q = e956602b83d195dbe945b3ac702fc61f81571f1d\n    G = d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe548c234895baa\\\n77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6edb127a4b5d75cd8b46608bfa1\\\n48249dffdb59807c5d7dde3fe3080ca3a2d28312142becb1fa8e24003e21c72871081\\\n74b95d5bc711e1c8d9b1076784f5dc37a964a5e51390da713\n\n    Msg = 0fe1bfee500bdb76026099b1d37553f6bdfe48c82094ef98cb309dd777330bedfaa\\\n2f94c823ef74ef4074b50d8706041ac0e371c7c22dcf70263b8d60e17a86c7c379c\\\nfda8f22469e0df9d49d59439fc99891873628fff25dda5fac5ac794e948babdde96\\\n8143ba05f1128f34fdad5875edc4cd71c6c24ba2060ffbd439ce2b3\n    X = 1d93010c29ecfc432188942f46f19f44f0e1bb5d\n    Y = 6240ea0647117c38fe705106d56db578f3e10130928452d4f3587881b8a2bc6873a8b\\\nefc3237f20914e2a91c7f07a928ee22adeed23d74ab7f82ea11f70497e578f7a9b4cb\\\nd6f10226222b0b4da2ea1e49813d6bb9882fbf675c0846bb80cc891857b89b0ef1beb\\\n6cce3378a9aab5d66ad4cb9277cf447dfe1e64434749432fb\n    R = b5af307867fb8b54390013cc67020ddf1f2c0b81\n    S = 620d3b22ab5031440c3e35eab6f481298f9e9f08\n    Result = P\n\n    Msg = 97d50898025d2f9ba633866e968ca75e969d394edba6517204cb3dd537c2ba38778\\\na2dc9dbc685a915e5676fcd43bc3726bc59ce3d7a9fae35565082a069c139fa37c9\\\n0d922b126933db3fa6c5ef6b1edf00d174a51887bb76909c6a94fe994ecc7b7fc8f\\\n26113b17f30f9d01693df99a125b4f17e184331c6b6e8ca00f54f3a\n    X = 350e13534692a7e0c4b7d58836046c436fbb2322\n    Y = 69974de550fe6bd3099150faea1623ad3fb6d9bf23a07215093f319725ad0877accff\\\nd291b6da18eb0cbe51676ceb0977504eb97c27c0b191883f72fb2710a9fbd8bcf13be\\\n0bf854410b32f42b33ec89d3cc1cf892bcd536c4195ca9ada302ad600c3408739935d\\\n77dc247529ca47f844cc86f5016a2fe962c6e20ca7c4d4e8f\n    R = b5d05faa7005764e8dae0327c5bf1972ff7681b9\n    S = 18ea15bd9f00475b25204cbc23f8c23e01588015\n    Result = F (3 - R changed )\n\n    [mod = L=2048, N=256, SHA-384]\n\n    P = e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a46b989e59f4d984\\\n25ee3c932fa3c2b6f637bdb6545bec526faa037e11f5578a4363b9fca5eba60d6a9cb\\\naa2befd04141d989c7356285132c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f\\\n8cc7949631fd0e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c8\\\n51ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2da293a01622cf43c\\\n6dd79625d41ba8f9ef7e3086ab39134283d8e96c89249488120fd061e4a87d34af410\\\n69c0b4fd3934c31b589cbe85b68b912718d5dab859fda7082511fad1d152044905005\\\n546e19b14aa96585a55269bf2b831\n    Q = 8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b38bd43db2f\n    G = dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05aab636528b7b1f\\\ne9cd33765f853d6dbe13d09f2681f8c7b1ed7886aaed70c7bd76dbe858ffb8bd86235\\\nddf759244678f428c6519af593dc94eeadbd9852ba2b3d61664e8d58c29d2039af3c3\\\nd6d16f90988f6a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84c\\\n763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a34c077c5aa8026c\\\nb2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8f2e91316905b6add1fd22e83bc2f0\\\n89f1d5e6a6e6707c18ff55ddcb7954e8bceaf0efc4e8314910c03b0e51175f344faaf\\\nee476a373ac95743cec712b72cf2e\n\n    Msg = 6cd6ccfd66bcd832189c5f0c77994210e3bf2c43416f0fe77c4e92f31c5369538dc\\\n2c003f146c5ac79df43194ccf3c44d470d9f1083bd15b99b5bcf88c32d8a9021f09\\\nea2288d7b3bf345a12aef3949c1e121b9fb371a67c2d1377364206ac839dd784835\\\n61426bda0303f285aa12e9c45d3cdfc6beae3549703b187deeb3296\n    X = 56c897b5938ad5b3d437d7e4826da586a6b3be15e893fa1aaa946f20a028b6b3\n    Y = 38ad44489e1a5778b9689f4dcf40e2acf23840fb954e987d6e8cb629106328ac64e1f\\\n3c3eba48b21176ad4afe3b733bead382ee1597e1b83e4b43424f2daaba04e5bd79e14\\\n36693ac2bddb79a298f026e57e200a252efd1e848a4a2e90be6e78f5242b468b9c0c6\\\nd2615047a5a40b9ae7e57a519114db55bf3bed65e580f894b094630ca9c217f6accd0\\\n91e72d2f22da620044ff372d7273f9445017fad492959e59600b7494dbe766a03e401\\\n25d4e6747c76f68a5b0cdc0e7d7cee12d08c6fb7d0fb049e420a33405075ed4463296\\\n345ca695fb7feab7c1b5333ae519fcd4bb6a043f4555378969114743d4face96cad31\\\nc0e0089da4e3f61b6d7dabc088ab7\n    R = 3b85b17be240ed658beb3652c9d93e8e9eea160d35ee2459614305802963374e\n    S = 726800a5174a53b56dce86064109c0273cd11fcfa3c92c5cd6aa910260c0e3c7\n    Result = F (1 - Message changed)\n\n    Msg = 3ad6b0884f358dea09c31a9abc40c45a6000611fc2b907b30eac00413fd2819de70\\\n15488a411609d46c499b8f7afa1b78b352ac7f8535bd805b8ff2a5eae557098c668\\\nf7ccd73af886d6823a6d456c29931ee864ed46d767382785728c2a83fcff5271007\\\nd2a67d06fa205fd7b9d1a42ea5d6dc76e5e18a9eb148cd1e8b262ae\n    X = 2faf566a9f057960f1b50c69508f483d9966d6e35743591f3a677a9dc40e1555\n    Y = 926425d617babe87c442b03903e32ba5bbf0cd9d602b59c4df791a4d64a6d4333ca0c\\\n0d370552539197d327dcd1bbf8c454f24b03fc7805f862db34c7b066ddfddbb11dbd0\\\n10b27123062d028fe041cb56a2e77488348ae0ab6705d87aac4d4e9e6600e9e706326\\\nd9979982cffa839beb9eacc3963bcca455a507e80c1c37ad4e765b2c9c0477a075e9b\\\nc584feacdf3a35a9391d4711f14e197c54022282bfed9a191213d64127f17a9c5affe\\\nc26e0c71f15d3a5b16098fec118c45bf8bb2f3b1560df0949254c1c0aeb0a16d5a95a\\\n40fab8521fbe8ea77c51169b587cc3360e5733e6a23b9fded8c40724ea1f9e93614b3\\\na6c9b4f8dbbe915b794497227ba62\n    R = 343ea0a9e66277380f604d5880fca686bffab69ca97bfba015a102a7e23dce0e\n    S = 6258488c770e0f5ad7b9da8bade5023fc0d17c6ec517bd08d53e6dc01ac5c2b3\n    Result = P\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"p\": int(\n                \"dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1\"\n                \"f35147b795caea923f0d3577158f8a0c89dabd1962c2c453306b5d70\"\n                \"cacfb01430aceb54e5a5fa6f9340d3bd2da612fceeb76b0ec1ebfae6\"\n                \"35a56ab141b108e00dc76eefe2edd0c514c21c457457c39065dba9d0\"\n                \"ecb7569c247172d8438ad2827b60435b\",\n                16,\n            ),\n            \"q\": int(\"e956602b83d195dbe945b3ac702fc61f81571f1d\", 16),\n            \"g\": int(\n                \"d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe\"\n                \"548c234895baa77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6\"\n                \"edb127a4b5d75cd8b46608bfa148249dffdb59807c5d7dde3fe3080c\"\n                \"a3a2d28312142becb1fa8e24003e21c7287108174b95d5bc711e1c8d\"\n                \"9b1076784f5dc37a964a5e51390da713\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-1\",\n            \"msg\": binascii.unhexlify(\n                b\"0fe1bfee500bdb76026099b1d37553f6bdfe48c82094ef98cb309dd77733\"\n                b\"0bedfaa2f94c823ef74ef4074b50d8706041ac0e371c7c22dcf70263b8d6\"\n                b\"0e17a86c7c379cfda8f22469e0df9d49d59439fc99891873628fff25dda5\"\n                b\"fac5ac794e948babdde968143ba05f1128f34fdad5875edc4cd71c6c24ba\"\n                b\"2060ffbd439ce2b3\"\n            ),\n            \"x\": int(\"1d93010c29ecfc432188942f46f19f44f0e1bb5d\", 16),\n            \"y\": int(\n                \"6240ea0647117c38fe705106d56db578f3e10130928452d4f3587881\"\n                \"b8a2bc6873a8befc3237f20914e2a91c7f07a928ee22adeed23d74ab\"\n                \"7f82ea11f70497e578f7a9b4cbd6f10226222b0b4da2ea1e49813d6b\"\n                \"b9882fbf675c0846bb80cc891857b89b0ef1beb6cce3378a9aab5d66\"\n                \"ad4cb9277cf447dfe1e64434749432fb\",\n                16,\n            ),\n            \"r\": int(\"b5af307867fb8b54390013cc67020ddf1f2c0b81\", 16),\n            \"s\": int(\"620d3b22ab5031440c3e35eab6f481298f9e9f08\", 16),\n            \"result\": \"P\",\n        },\n        {\n            \"p\": int(\n                \"dc5bf3a88b2d99e4c95cdd7a0501cc38630d425cf5c390af3429cff1\"\n                \"f35147b795caea923f0d3577158f8a0c89dabd1962c2c453306b5d70\"\n                \"cacfb01430aceb54e5a5fa6f9340d3bd2da612fceeb76b0ec1ebfae6\"\n                \"35a56ab141b108e00dc76eefe2edd0c514c21c457457c39065dba9d0\"\n                \"ecb7569c247172d8438ad2827b60435b\",\n                16,\n            ),\n            \"q\": int(\"e956602b83d195dbe945b3ac702fc61f81571f1d\", 16),\n            \"g\": int(\n                \"d7eb9ca20a3c7a079606bafc4c9261ccaba303a5dc9fe9953f197dfe\"\n                \"548c234895baa77f441ee6a2d97b909cbbd26ff7b869d24cae51b5c6\"\n                \"edb127a4b5d75cd8b46608bfa148249dffdb59807c5d7dde3fe3080c\"\n                \"a3a2d28312142becb1fa8e24003e21c7287108174b95d5bc711e1c8d\"\n                \"9b1076784f5dc37a964a5e51390da713\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-1\",\n            \"msg\": binascii.unhexlify(\n                b\"97d50898025d2f9ba633866e968ca75e969d394edba6517204cb3dd537c2\"\n                b\"ba38778a2dc9dbc685a915e5676fcd43bc3726bc59ce3d7a9fae35565082\"\n                b\"a069c139fa37c90d922b126933db3fa6c5ef6b1edf00d174a51887bb7690\"\n                b\"9c6a94fe994ecc7b7fc8f26113b17f30f9d01693df99a125b4f17e184331\"\n                b\"c6b6e8ca00f54f3a\"\n            ),\n            \"x\": int(\"350e13534692a7e0c4b7d58836046c436fbb2322\", 16),\n            \"y\": int(\n                \"69974de550fe6bd3099150faea1623ad3fb6d9bf23a07215093f3197\"\n                \"25ad0877accffd291b6da18eb0cbe51676ceb0977504eb97c27c0b19\"\n                \"1883f72fb2710a9fbd8bcf13be0bf854410b32f42b33ec89d3cc1cf8\"\n                \"92bcd536c4195ca9ada302ad600c3408739935d77dc247529ca47f84\"\n                \"4cc86f5016a2fe962c6e20ca7c4d4e8f\",\n                16,\n            ),\n            \"r\": int(\"b5d05faa7005764e8dae0327c5bf1972ff7681b9\", 16),\n            \"s\": int(\"18ea15bd9f00475b25204cbc23f8c23e01588015\", 16),\n            \"result\": \"F\",\n        },\n        {\n            \"p\": int(\n                \"e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a4\"\n                \"6b989e59f4d98425ee3c932fa3c2b6f637bdb6545bec526faa037e1\"\n                \"1f5578a4363b9fca5eba60d6a9cbaa2befd04141d989c7356285132\"\n                \"c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f8cc7949631fd0\"\n                \"e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c\"\n                \"851ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2d\"\n                \"a293a01622cf43c6dd79625d41ba8f9ef7e3086ab39134283d8e96c\"\n                \"89249488120fd061e4a87d34af41069c0b4fd3934c31b589cbe85b6\"\n                \"8b912718d5dab859fda7082511fad1d152044905005546e19b14aa9\"\n                \"6585a55269bf2b831\",\n                16,\n            ),\n            \"q\": int(\n                \"8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b3\"\n                \"8bd43db2f\",\n                16,\n            ),\n            \"g\": int(\n                \"dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05\"\n                \"aab636528b7b1fe9cd33765f853d6dbe13d09f2681f8c7b1ed7886a\"\n                \"aed70c7bd76dbe858ffb8bd86235ddf759244678f428c6519af593d\"\n                \"c94eeadbd9852ba2b3d61664e8d58c29d2039af3c3d6d16f90988f6\"\n                \"a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84\"\n                \"c763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a\"\n                \"34c077c5aa8026cb2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8\"\n                \"f2e91316905b6add1fd22e83bc2f089f1d5e6a6e6707c18ff55ddcb\"\n                \"7954e8bceaf0efc4e8314910c03b0e51175f344faafee476a373ac9\"\n                \"5743cec712b72cf2e\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-384\",\n            \"msg\": binascii.unhexlify(\n                b\"6cd6ccfd66bcd832189c5f0c77994210e3bf2c43416f0fe77c4e92f31c5\"\n                b\"369538dc2c003f146c5ac79df43194ccf3c44d470d9f1083bd15b99b5bc\"\n                b\"f88c32d8a9021f09ea2288d7b3bf345a12aef3949c1e121b9fb371a67c2\"\n                b\"d1377364206ac839dd78483561426bda0303f285aa12e9c45d3cdfc6bea\"\n                b\"e3549703b187deeb3296\"\n            ),\n            \"x\": int(\n                \"56c897b5938ad5b3d437d7e4826da586a6b3be15e893fa1aaa946f2\"\n                \"0a028b6b3\",\n                16,\n            ),\n            \"y\": int(\n                \"38ad44489e1a5778b9689f4dcf40e2acf23840fb954e987d6e8cb62\"\n                \"9106328ac64e1f3c3eba48b21176ad4afe3b733bead382ee1597e1b\"\n                \"83e4b43424f2daaba04e5bd79e1436693ac2bddb79a298f026e57e2\"\n                \"00a252efd1e848a4a2e90be6e78f5242b468b9c0c6d2615047a5a40\"\n                \"b9ae7e57a519114db55bf3bed65e580f894b094630ca9c217f6accd\"\n                \"091e72d2f22da620044ff372d7273f9445017fad492959e59600b74\"\n                \"94dbe766a03e40125d4e6747c76f68a5b0cdc0e7d7cee12d08c6fb7\"\n                \"d0fb049e420a33405075ed4463296345ca695fb7feab7c1b5333ae5\"\n                \"19fcd4bb6a043f4555378969114743d4face96cad31c0e0089da4e3\"\n                \"f61b6d7dabc088ab7\",\n                16,\n            ),\n            \"r\": int(\n                \"3b85b17be240ed658beb3652c9d93e8e9eea160d35ee24596143058\"\n                \"02963374e\",\n                16,\n            ),\n            \"s\": int(\n                \"726800a5174a53b56dce86064109c0273cd11fcfa3c92c5cd6aa910\"\n                \"260c0e3c7\",\n                16,\n            ),\n            \"result\": \"F\",\n        },\n        {\n            \"p\": int(\n                \"e7c1c86125db9ef417da1ced7ea0861bdad629216a3f3c745df42a4\"\n                \"6b989e59f4d98425ee3c932fa3c2b6f637bdb6545bec526faa037e1\"\n                \"1f5578a4363b9fca5eba60d6a9cbaa2befd04141d989c7356285132\"\n                \"c2eaf74f2d868521cdc0a17ae9a2546ef863027d3f8cc7949631fd0\"\n                \"e2971417a912c8b8c5c989730db6ea6e8baee0e667850429038093c\"\n                \"851ccb6fb173bb081e0efe0bd7450e0946888f89f75e443ab93ef2d\"\n                \"a293a01622cf43c6dd79625d41ba8f9ef7e3086ab39134283d8e96c\"\n                \"89249488120fd061e4a87d34af41069c0b4fd3934c31b589cbe85b6\"\n                \"8b912718d5dab859fda7082511fad1d152044905005546e19b14aa9\"\n                \"6585a55269bf2b831\",\n                16,\n            ),\n            \"q\": int(\n                \"8e056ec9d4b7acb580087a6ed9ba3478711bb025d5b8d9c731ef9b3\"\n                \"8bd43db2f\",\n                16,\n            ),\n            \"g\": int(\n                \"dc2bfb9776786ad310c8b0cdcbba3062402613c67e6959a8d8d1b05\"\n                \"aab636528b7b1fe9cd33765f853d6dbe13d09f2681f8c7b1ed7886a\"\n                \"aed70c7bd76dbe858ffb8bd86235ddf759244678f428c6519af593d\"\n                \"c94eeadbd9852ba2b3d61664e8d58c29d2039af3c3d6d16f90988f6\"\n                \"a8c824569f3d48050e30896a9e17cd0232ef01ab8790008f6973b84\"\n                \"c763a72f4ae8b485abfb7e8efeb86808fa2b281d3e5d65d28f5992a\"\n                \"34c077c5aa8026cb2fbc34a45f7e9bd216b10e6f12ecb172e9a6eb8\"\n                \"f2e91316905b6add1fd22e83bc2f089f1d5e6a6e6707c18ff55ddcb\"\n                \"7954e8bceaf0efc4e8314910c03b0e51175f344faafee476a373ac9\"\n                \"5743cec712b72cf2e\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-384\",\n            \"msg\": binascii.unhexlify(\n                b\"3ad6b0884f358dea09c31a9abc40c45a6000611fc2b907b30eac00413fd\"\n                b\"2819de7015488a411609d46c499b8f7afa1b78b352ac7f8535bd805b8ff\"\n                b\"2a5eae557098c668f7ccd73af886d6823a6d456c29931ee864ed46d7673\"\n                b\"82785728c2a83fcff5271007d2a67d06fa205fd7b9d1a42ea5d6dc76e5e\"\n                b\"18a9eb148cd1e8b262ae\"\n            ),\n            \"x\": int(\n                \"2faf566a9f057960f1b50c69508f483d9966d6e35743591f3a677a9\"\n                \"dc40e1555\",\n                16,\n            ),\n            \"y\": int(\n                \"926425d617babe87c442b03903e32ba5bbf0cd9d602b59c4df791a4d\"\n                \"64a6d4333ca0c0d370552539197d327dcd1bbf8c454f24b03fc7805f\"\n                \"862db34c7b066ddfddbb11dbd010b27123062d028fe041cb56a2e774\"\n                \"88348ae0ab6705d87aac4d4e9e6600e9e706326d9979982cffa839be\"\n                \"b9eacc3963bcca455a507e80c1c37ad4e765b2c9c0477a075e9bc584\"\n                \"feacdf3a35a9391d4711f14e197c54022282bfed9a191213d64127f1\"\n                \"7a9c5affec26e0c71f15d3a5b16098fec118c45bf8bb2f3b1560df09\"\n                \"49254c1c0aeb0a16d5a95a40fab8521fbe8ea77c51169b587cc3360e\"\n                \"5733e6a23b9fded8c40724ea1f9e93614b3a6c9b4f8dbbe915b79449\"\n                \"7227ba62\",\n                16,\n            ),\n            \"r\": int(\n                \"343ea0a9e66277380f604d5880fca686bffab69ca97bfba015a102a\"\n                \"7e23dce0e\",\n                16,\n            ),\n            \"s\": int(\n                \"6258488c770e0f5ad7b9da8bade5023fc0d17c6ec517bd08d53e6dc\"\n                \"01ac5c2b3\",\n                16,\n            ),\n            \"result\": \"P\",\n        },\n    ]\n\n    assert expected == load_fips_dsa_sig_vectors(vector_data)\n\n\ndef test_load_fips_dsa_sig_gen_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 11.2\n    # \"SigGen\" information for \"dsa2_values\"\n    # Mod sizes selected: SHA-1 L=1024, N=160, SHA-256 L=2048, N=256\n\n    [mod = L=1024, N=160, SHA-1]\n\n    P = a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed3256b26d0e80a0e49\\\na8fffaaad2a24f472d2573241d4d6d6c7480c80b4c67bb4479c15ada7ea8424d2502fa01472e7\\\n60241713dab025ae1b02e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd5eb\\\ne2d1229681b5b06439ac9c7e9d8bde283\n    Q = f85f0f83ac4df7ea0cdf8f469bfeeaea14156495\n    G = 2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df131f8b856e3ad6c\\\n8455dab87cc0da8ac973417ce4f7878557d6cdf40b35b4a0ca3eb310c6a95d68ce284ad4e25ea\\\n28591611ee08b8444bd64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909a6a\\\n3a99bbe089216368171bd0ba81de4fe33\n\n    Msg = 3b46736d559bd4e0c2c1b2553a33ad3c6cf23cac998d3d0c0e8fa4b19bca06f2f38\\\n6db2dcff9dca4f40ad8f561ffc308b46c5f31a7735b5fa7e0f9e6cb512e63d7eea05538d66a75\\\ncd0d4234b5ccf6c1715ccaaf9cdc0a2228135f716ee9bdee7fc13ec27a03a6d11c5c5b3685f51\\\n900b1337153bc6c4e8f52920c33fa37f4e7\n    Y = 313fd9ebca91574e1c2eebe1517c57e0c21b0209872140c5328761bbb2450b33f1b18\\\nb409ce9ab7c4cd8fda3391e8e34868357c199e16a6b2eba06d6749def791d79e95d3a4d09b24c\\\n392ad89dbf100995ae19c01062056bb14bce005e8731efde175f95b975089bdcdaea562b32786\\\nd96f5a31aedf75364008ad4fffebb970b\n    R = 50ed0e810e3f1c7cb6ac62332058448bd8b284c0\n    S = c6aded17216b46b7e4b6f2a97c1ad7cc3da83fde\n\n    Msg = d2bcb53b044b3e2e4b61ba2f91c0995fb83a6a97525e66441a3b489d9594238bc74\\\n0bdeea0f718a769c977e2de003877b5d7dc25b182ae533db33e78f2c3ff0645f2137abc137d4e\\\n7d93ccf24f60b18a820bc07c7b4b5fe08b4f9e7d21b256c18f3b9d49acc4f93e2ce6f3754c780\\\n7757d2e1176042612cb32fc3f4f70700e25\n    Y = 29bdd759aaa62d4bf16b4861c81cf42eac2e1637b9ecba512bdbc13ac12a80ae8de25\\\n26b899ae5e4a231aef884197c944c732693a634d7659abc6975a773f8d3cd5a361fe2492386a3\\\nc09aaef12e4a7e73ad7dfc3637f7b093f2c40d6223a195c136adf2ea3fbf8704a675aa7817aa7\\\nec7f9adfb2854d4e05c3ce7f76560313b\n    R = a26c00b5750a2d27fe7435b93476b35438b4d8ab\n    S = 61c9bfcb2938755afa7dad1d1e07c6288617bf70\n\n    [mod = L=2048, N=256, SHA-256]\n\n    P = a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe13a059705e66323\\\n0a377bf7323a8fa117100200bfd5adf857393b0bbd67906c081e585410e38480ead51684dac3a\\\n38f7b64c9eb109f19739a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4104\\\n7dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543eadb7718f317bf5d9577a61565\\\n61b082a10029cd44012b18de6844509fe058ba87980792285f2750969fe89c2cd6498db354563\\\n8d5379d125dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31b9f96d5f34445c\\\neb6309f2f6d2c8dde06441e87980d303ef9a1ff007e8be2f0be06cc15f\n    Q = e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e68604d6b9dfb\n    G = 5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa104abfb5d84579\\\na623b2574b37d22ccae9b3e415e48f5c0f9bcbdff8071d63b9bb956e547af3a8df99e5d306197\\\n9652ff96b765cb3ee493643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533039\\\n2a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec1354f09e2eb78e95f037a5804\\\nb6171659f88715ce1a9b0cc90c27f35ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372\\\nf4240de8347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d2183f1ba3b7b45\\\na68f1ff1893caf69a827802f7b6a48d51da6fbefb64fd9a6c5b75c4561\n\n    Msg = 4e3a28bcf90d1d2e75f075d9fbe55b36c5529b17bc3a9ccaba6935c9e20548255b3\\\ndfae0f91db030c12f2c344b3a29c4151c5b209f5e319fdf1c23b190f64f1fe5b330cb7c8fa952\\\nf9d90f13aff1cb11d63181da9efc6f7e15bfed4862d1a62c7dcf3ba8bf1ff304b102b1ec3f149\\\n7dddf09712cf323f5610a9d10c3d9132659\n    Y = 5a55dceddd1134ee5f11ed85deb4d634a3643f5f36dc3a70689256469a0b651ad2288\\\n0f14ab85719434f9c0e407e60ea420e2a0cd29422c4899c416359dbb1e592456f2b3cce233259\\\nc117542fd05f31ea25b015d9121c890b90e0bad033be1368d229985aac7226d1c8c2eab325ef3\\\nb2cd59d3b9f7de7dbc94af1a9339eb430ca36c26c46ecfa6c5481711496f624e188ad7540ef5d\\\nf26f8efacb820bd17a1f618acb50c9bc197d4cb7ccac45d824a3bf795c234b556b06aeb929173\\\n453252084003f69fe98045fe74002ba658f93475622f76791d9b2623d1b5fff2cc16844746efd\\\n2d30a6a8134bfc4c8cc80a46107901fb973c28fc553130f3286c1489da\n    R = 633055e055f237c38999d81c397848c38cce80a55b649d9e7905c298e2a51447\n    S = 2bbf68317660ec1e4b154915027b0bc00ee19cfc0bf75d01930504f2ce10a8b0\n\n    Msg = a733b3f588d5ac9b9d4fe2f804df8c256403a9f8eef6f191fc48e1267fb5b4d546b\\\na11e77b667844e489bf0d5f72990aeb061d01ccd7949a23def74a803b7d92d51abfadeb4885ff\\\nd8ffd58ab87548a15c087a39b8993b2fa64c9d31a594eeb7512da16955834336a234435c5a9d0\\\ndd9b15a94e116154dea63fdc8dd7a512181\n    Y = 356ed47537fbf02cb30a8cee0537f300dff1d0c467399ce70b87a8758d5ec9dd25624\\\n6fccaeb9dfe109f2a984f2ddaa87aad54ce0d31f907e504521baf4207d7073b0a4a9fc67d8ddd\\\na99f87aed6e0367cec27f9c608af743bf1ee6e11d55a182d43b024ace534029b866f6422828bb\\\n81a39aae9601ee81c7f81dd358e69f4e2edfa4654d8a65bc64311dc86aac4abc1fc7a3f651596\\\n61a0d8e288eb8d665cb0adf5ac3d6ba8e9453facf7542393ae24fd50451d3828086558f7ec528\\\ne284935a53f67a1aa8e25d8ad5c4ad55d83aef883a4d9eeb6297e6a53f65049ba9e2c6b7953a7\\\n60bc1dc46f78ceaaa2c02f5375dd82e708744aa40b15799eb81d7e5b1a\n    R = bcd490568c0a89ba311bef88ea4f4b03d273e793722722327095a378dd6f3522\n    S = 74498fc43091fcdd2d1ef0775f8286945a01cd72b805256b0451f9cbd943cf82\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"p\": int(\n                \"a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed325\"\n                \"6b26d0e80a0e49a8fffaaad2a24f472d2573241d4d6d6c7480c80b4\"\n                \"c67bb4479c15ada7ea8424d2502fa01472e760241713dab025ae1b0\"\n                \"2e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd\"\n                \"5ebe2d1229681b5b06439ac9c7e9d8bde283\",\n                16,\n            ),\n            \"q\": int(\"f85f0f83ac4df7ea0cdf8f469bfeeaea14156495\", 16),\n            \"g\": int(\n                \"2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df1\"\n                \"31f8b856e3ad6c8455dab87cc0da8ac973417ce4f7878557d6cdf40\"\n                \"b35b4a0ca3eb310c6a95d68ce284ad4e25ea28591611ee08b8444bd\"\n                \"64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909\"\n                \"a6a3a99bbe089216368171bd0ba81de4fe33\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-1\",\n            \"msg\": binascii.unhexlify(\n                b\"3b46736d559bd4e0c2c1b2553a33ad3c6cf23cac998d3d0c0e8fa4b19bc\"\n                b\"a06f2f386db2dcff9dca4f40ad8f561ffc308b46c5f31a7735b5fa7e0f9\"\n                b\"e6cb512e63d7eea05538d66a75cd0d4234b5ccf6c1715ccaaf9cdc0a222\"\n                b\"8135f716ee9bdee7fc13ec27a03a6d11c5c5b3685f51900b1337153bc6c\"\n                b\"4e8f52920c33fa37f4e7\"\n            ),\n            \"y\": int(\n                \"313fd9ebca91574e1c2eebe1517c57e0c21b0209872140c5328761b\"\n                \"bb2450b33f1b18b409ce9ab7c4cd8fda3391e8e34868357c199e16a\"\n                \"6b2eba06d6749def791d79e95d3a4d09b24c392ad89dbf100995ae1\"\n                \"9c01062056bb14bce005e8731efde175f95b975089bdcdaea562b32\"\n                \"786d96f5a31aedf75364008ad4fffebb970b\",\n                16,\n            ),\n            \"r\": int(\"50ed0e810e3f1c7cb6ac62332058448bd8b284c0\", 16),\n            \"s\": int(\"c6aded17216b46b7e4b6f2a97c1ad7cc3da83fde\", 16),\n        },\n        {\n            \"p\": int(\n                \"a8f9cd201e5e35d892f85f80e4db2599a5676a3b1d4f190330ed325\"\n                \"6b26d0e80a0e49a8fffaaad2a24f472d2573241d4d6d6c7480c80b4\"\n                \"c67bb4479c15ada7ea8424d2502fa01472e760241713dab025ae1b0\"\n                \"2e1703a1435f62ddf4ee4c1b664066eb22f2e3bf28bb70a2a76e4fd\"\n                \"5ebe2d1229681b5b06439ac9c7e9d8bde283\",\n                16,\n            ),\n            \"q\": int(\"f85f0f83ac4df7ea0cdf8f469bfeeaea14156495\", 16),\n            \"g\": int(\n                \"2b3152ff6c62f14622b8f48e59f8af46883b38e79b8c74deeae9df1\"\n                \"31f8b856e3ad6c8455dab87cc0da8ac973417ce4f7878557d6cdf40\"\n                \"b35b4a0ca3eb310c6a95d68ce284ad4e25ea28591611ee08b8444bd\"\n                \"64b25f3f7c572410ddfb39cc728b9c936f85f419129869929cdb909\"\n                \"a6a3a99bbe089216368171bd0ba81de4fe33\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-1\",\n            \"msg\": binascii.unhexlify(\n                b\"d2bcb53b044b3e2e4b61ba2f91c0995fb83a6a97525e66441a3b489d959\"\n                b\"4238bc740bdeea0f718a769c977e2de003877b5d7dc25b182ae533db33e\"\n                b\"78f2c3ff0645f2137abc137d4e7d93ccf24f60b18a820bc07c7b4b5fe08\"\n                b\"b4f9e7d21b256c18f3b9d49acc4f93e2ce6f3754c7807757d2e11760426\"\n                b\"12cb32fc3f4f70700e25\"\n            ),\n            \"y\": int(\n                \"29bdd759aaa62d4bf16b4861c81cf42eac2e1637b9ecba512bdbc13\"\n                \"ac12a80ae8de2526b899ae5e4a231aef884197c944c732693a634d7\"\n                \"659abc6975a773f8d3cd5a361fe2492386a3c09aaef12e4a7e73ad7\"\n                \"dfc3637f7b093f2c40d6223a195c136adf2ea3fbf8704a675aa7817\"\n                \"aa7ec7f9adfb2854d4e05c3ce7f76560313b\",\n                16,\n            ),\n            \"r\": int(\"a26c00b5750a2d27fe7435b93476b35438b4d8ab\", 16),\n            \"s\": int(\"61c9bfcb2938755afa7dad1d1e07c6288617bf70\", 16),\n        },\n        {\n            \"p\": int(\n                \"a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe1\"\n                \"3a059705e663230a377bf7323a8fa117100200bfd5adf857393b0bb\"\n                \"d67906c081e585410e38480ead51684dac3a38f7b64c9eb109f1973\"\n                \"9a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4\"\n                \"1047dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543e\"\n                \"adb7718f317bf5d9577a6156561b082a10029cd44012b18de684450\"\n                \"9fe058ba87980792285f2750969fe89c2cd6498db3545638d5379d1\"\n                \"25dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31\"\n                \"b9f96d5f34445ceb6309f2f6d2c8dde06441e87980d303ef9a1ff00\"\n                \"7e8be2f0be06cc15f\",\n                16,\n            ),\n            \"q\": int(\n                \"e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e686\"\n                \"04d6b9dfb\",\n                16,\n            ),\n            \"g\": int(\n                \"5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa\"\n                \"104abfb5d84579a623b2574b37d22ccae9b3e415e48f5c0f9bcbdff\"\n                \"8071d63b9bb956e547af3a8df99e5d3061979652ff96b765cb3ee49\"\n                \"3643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533\"\n                \"0392a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec\"\n                \"1354f09e2eb78e95f037a5804b6171659f88715ce1a9b0cc90c27f3\"\n                \"5ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372f4240de8\"\n                \"347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d\"\n                \"2183f1ba3b7b45a68f1ff1893caf69a827802f7b6a48d51da6fbefb\"\n                \"64fd9a6c5b75c4561\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-256\",\n            \"msg\": binascii.unhexlify(\n                b\"4e3a28bcf90d1d2e75f075d9fbe55b36c5529b17bc3a9ccaba6935c9e20\"\n                b\"548255b3dfae0f91db030c12f2c344b3a29c4151c5b209f5e319fdf1c23\"\n                b\"b190f64f1fe5b330cb7c8fa952f9d90f13aff1cb11d63181da9efc6f7e1\"\n                b\"5bfed4862d1a62c7dcf3ba8bf1ff304b102b1ec3f1497dddf09712cf323\"\n                b\"f5610a9d10c3d9132659\"\n            ),\n            \"y\": int(\n                \"5a55dceddd1134ee5f11ed85deb4d634a3643f5f36dc3a706892564\"\n                \"69a0b651ad22880f14ab85719434f9c0e407e60ea420e2a0cd29422\"\n                \"c4899c416359dbb1e592456f2b3cce233259c117542fd05f31ea25b\"\n                \"015d9121c890b90e0bad033be1368d229985aac7226d1c8c2eab325\"\n                \"ef3b2cd59d3b9f7de7dbc94af1a9339eb430ca36c26c46ecfa6c548\"\n                \"1711496f624e188ad7540ef5df26f8efacb820bd17a1f618acb50c9\"\n                \"bc197d4cb7ccac45d824a3bf795c234b556b06aeb92917345325208\"\n                \"4003f69fe98045fe74002ba658f93475622f76791d9b2623d1b5fff\"\n                \"2cc16844746efd2d30a6a8134bfc4c8cc80a46107901fb973c28fc5\"\n                \"53130f3286c1489da\",\n                16,\n            ),\n            \"r\": int(\n                \"633055e055f237c38999d81c397848c38cce80a55b649d9e7905c29\"\n                \"8e2a51447\",\n                16,\n            ),\n            \"s\": int(\n                \"2bbf68317660ec1e4b154915027b0bc00ee19cfc0bf75d01930504f\"\n                \"2ce10a8b0\",\n                16,\n            ),\n        },\n        {\n            \"p\": int(\n                \"a8adb6c0b4cf9588012e5deff1a871d383e0e2a85b5e8e03d814fe1\"\n                \"3a059705e663230a377bf7323a8fa117100200bfd5adf857393b0bb\"\n                \"d67906c081e585410e38480ead51684dac3a38f7b64c9eb109f1973\"\n                \"9a4517cd7d5d6291e8af20a3fbf17336c7bf80ee718ee087e322ee4\"\n                \"1047dabefbcc34d10b66b644ddb3160a28c0639563d71993a26543e\"\n                \"adb7718f317bf5d9577a6156561b082a10029cd44012b18de684450\"\n                \"9fe058ba87980792285f2750969fe89c2cd6498db3545638d5379d1\"\n                \"25dccf64e06c1af33a6190841d223da1513333a7c9d78462abaab31\"\n                \"b9f96d5f34445ceb6309f2f6d2c8dde06441e87980d303ef9a1ff00\"\n                \"7e8be2f0be06cc15f\",\n                16,\n            ),\n            \"q\": int(\n                \"e71f8567447f42e75f5ef85ca20fe557ab0343d37ed09edc3f6e686\"\n                \"04d6b9dfb\",\n                16,\n            ),\n            \"g\": int(\n                \"5ba24de9607b8998e66ce6c4f812a314c6935842f7ab54cd82b19fa\"\n                \"104abfb5d84579a623b2574b37d22ccae9b3e415e48f5c0f9bcbdff\"\n                \"8071d63b9bb956e547af3a8df99e5d3061979652ff96b765cb3ee49\"\n                \"3643544c75dbe5bb39834531952a0fb4b0378b3fcbb4c8b5800a533\"\n                \"0392a2a04e700bb6ed7e0b85795ea38b1b962741b3f33b9dde2f4ec\"\n                \"1354f09e2eb78e95f037a5804b6171659f88715ce1a9b0cc90c27f3\"\n                \"5ef2f10ff0c7c7a2bb0154d9b8ebe76a3d764aa879af372f4240de8\"\n                \"347937e5a90cec9f41ff2f26b8da9a94a225d1a913717d73f10397d\"\n                \"2183f1ba3b7b45a68f1ff1893caf69a827802f7b6a48d51da6fbefb\"\n                \"64fd9a6c5b75c4561\",\n                16,\n            ),\n            \"digest_algorithm\": \"SHA-256\",\n            \"msg\": binascii.unhexlify(\n                b\"a733b3f588d5ac9b9d4fe2f804df8c256403a9f8eef6f191fc48e1267fb\"\n                b\"5b4d546ba11e77b667844e489bf0d5f72990aeb061d01ccd7949a23def7\"\n                b\"4a803b7d92d51abfadeb4885ffd8ffd58ab87548a15c087a39b8993b2fa\"\n                b\"64c9d31a594eeb7512da16955834336a234435c5a9d0dd9b15a94e11615\"\n                b\"4dea63fdc8dd7a512181\"\n            ),\n            \"y\": int(\n                \"356ed47537fbf02cb30a8cee0537f300dff1d0c467399ce70b87a87\"\n                \"58d5ec9dd256246fccaeb9dfe109f2a984f2ddaa87aad54ce0d31f9\"\n                \"07e504521baf4207d7073b0a4a9fc67d8ddda99f87aed6e0367cec2\"\n                \"7f9c608af743bf1ee6e11d55a182d43b024ace534029b866f642282\"\n                \"8bb81a39aae9601ee81c7f81dd358e69f4e2edfa4654d8a65bc6431\"\n                \"1dc86aac4abc1fc7a3f65159661a0d8e288eb8d665cb0adf5ac3d6b\"\n                \"a8e9453facf7542393ae24fd50451d3828086558f7ec528e284935a\"\n                \"53f67a1aa8e25d8ad5c4ad55d83aef883a4d9eeb6297e6a53f65049\"\n                \"ba9e2c6b7953a760bc1dc46f78ceaaa2c02f5375dd82e708744aa40\"\n                \"b15799eb81d7e5b1a\",\n                16,\n            ),\n            \"r\": int(\n                \"bcd490568c0a89ba311bef88ea4f4b03d273e793722722327095a37\"\n                \"8dd6f3522\",\n                16,\n            ),\n            \"s\": int(\n                \"74498fc43091fcdd2d1ef0775f8286945a01cd72b805256b0451f9c\"\n                \"bd943cf82\",\n                16,\n            ),\n        },\n    ]\n    assert expected == load_fips_dsa_sig_vectors(vector_data)\n\n\ndef test_load_fips_ecdsa_key_pair_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.0\n    #  \"Key Pair\" information\n    #  Curves selected: P-192 K-233 B-571\n    #  Generated on Wed Mar 16 16:16:42 2011\n\n\n    [P-192]\n\n    [B.4.2 Key Pair Generation by Testing Candidates]\n    N = 2\n\n    d = e5ce89a34adddf25ff3bf1ffe6803f57d0220de3118798ea\n    Qx = 8abf7b3ceb2b02438af19543d3e5b1d573fa9ac60085840f\n    Qy = a87f80182dcd56a6a061f81f7da393e7cffd5e0738c6b245\n\n    d = 7d14435714ad13ff23341cb567cc91198ff8617cc39751b2\n    Qx = 39dc723b19527daa1e80425209c56463481b9b47c51f8cbd\n    Qy = 432a3e84f2a16418834fabaf6b7d2341669512951f1672ad\n\n\n    [K-233]\n\n    [B.4.2 Key Pair Generation by Testing Candidates]\n    N = 2\n\n    d = 01da7422b50e3ff051f2aaaed10acea6cbf6110c517da2f4eaca8b5b87\n    Qx = 01c7475da9a161e4b3f7d6b086494063543a979e34b8d7ac44204d47bf9f\n    Qy = 0131cbd433f112871cc175943991b6a1350bf0cdd57ed8c831a2a7710c92\n\n    d = 530951158f7b1586978c196603c12d25607d2cb0557efadb23cd0ce8\n    Qx = d37500a0391d98d3070d493e2b392a2c79dc736c097ed24b7dd5ddec44\n    Qy = 01d996cc79f37d8dba143d4a8ad9a8a60ed7ea760aae1ddba34d883f65d9\n\n\n    [B-571]\n\n    [B.4.2 Key Pair Generation by Testing Candidates]\n    N = 2\n\n    d = 01443e93c7ef6802655f641ecbe95e75f1f15b02d2e172f49a32e22047d5c00ebe1b3f\\\nf0456374461360667dbf07bc67f7d6135ee0d1d46a226a530fefe8ebf3b926e9fbad8d57a6\n    Qx = 053e3710d8e7d4138db0a369c97e5332c1be38a20a4a84c36f5e55ea9fd6f34545b86\\\n4ea64f319e74b5ee9e4e1fa1b7c5b2db0e52467518f8c45b658824871d5d4025a6320ca06f8\n    Qy = 03a22cfd370c4a449b936ae97ab97aab11c57686cca99d14ef184f9417fad8bedae4d\\\nf8357e3710bcda1833b30e297d4bf637938b995d231e557d13f062e81e830af5ab052208ead\n\n    d = 03d2bd44ca9eeee8c860a4873ed55a54bdfdf5dab4060df7292877960b85d1fd496aa3\\\n3c587347213d7f6bf208a6ab4b430546e7b6ffbc3135bd12f44a28517867ca3c83a821d6f8\n    Qx = 07a7af10f6617090bade18b2e092d0dfdc87cd616db7f2db133477a82bfe3ea421ebb\\\n7d6289980819292a719eb247195529ea60ad62862de0a26c72bfc49ecc81c2f9ed704e3168f\n    Qy = 0721496cf16f988b1aabef3368450441df8439a0ca794170f270ead56203d675b57f5\\\na4090a3a2f602a77ff3bac1417f7e25a683f667b3b91f105016a47afad46a0367b18e2bdf0c\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"curve\": \"secp192r1\",\n            \"d\": int(\"e5ce89a34adddf25ff3bf1ffe6803f57d0220de3118798ea\", 16),\n            \"x\": int(\"8abf7b3ceb2b02438af19543d3e5b1d573fa9ac60085840f\", 16),\n            \"y\": int(\"a87f80182dcd56a6a061f81f7da393e7cffd5e0738c6b245\", 16),\n        },\n        {\n            \"curve\": \"secp192r1\",\n            \"d\": int(\"7d14435714ad13ff23341cb567cc91198ff8617cc39751b2\", 16),\n            \"x\": int(\"39dc723b19527daa1e80425209c56463481b9b47c51f8cbd\", 16),\n            \"y\": int(\"432a3e84f2a16418834fabaf6b7d2341669512951f1672ad\", 16),\n        },\n        {\n            \"curve\": \"sect233k1\",\n            \"d\": int(\n                \"1da7422b50e3ff051f2aaaed10acea6cbf6110c517da2f4eaca8b5b87\",\n                16,\n            ),\n            \"x\": int(\n                \"1c7475da9a161e4b3f7d6b086494063543a979e34b8d7ac4\"\n                \"4204d47bf9f\",\n                16,\n            ),\n            \"y\": int(\n                \"131cbd433f112871cc175943991b6a1350bf0cdd57ed8c83\"\n                \"1a2a7710c92\",\n                16,\n            ),\n        },\n        {\n            \"curve\": \"sect233k1\",\n            \"d\": int(\n                \"530951158f7b1586978c196603c12d25607d2cb0557efadb23cd0ce8\",\n                16,\n            ),\n            \"x\": int(\n                \"d37500a0391d98d3070d493e2b392a2c79dc736c097ed24b\"\n                \"7dd5ddec44\",\n                16,\n            ),\n            \"y\": int(\n                \"1d996cc79f37d8dba143d4a8ad9a8a60ed7ea760aae1ddba\"\n                \"34d883f65d9\",\n                16,\n            ),\n        },\n        {\n            \"curve\": \"sect571r1\",\n            \"d\": int(\n                \"1443e93c7ef6802655f641ecbe95e75f1f15b02d2e172f49\"\n                \"a32e22047d5c00ebe1b3ff0456374461360667dbf07bc67f\"\n                \"7d6135ee0d1d46a226a530fefe8ebf3b926e9fbad8d57a6\",\n                16,\n            ),\n            \"x\": int(\n                \"53e3710d8e7d4138db0a369c97e5332c1be38a20a4a84c36\"\n                \"f5e55ea9fd6f34545b864ea64f319e74b5ee9e4e1fa1b7c5\"\n                \"b2db0e52467518f8c45b658824871d5d4025a6320ca06f8\",\n                16,\n            ),\n            \"y\": int(\n                \"3a22cfd370c4a449b936ae97ab97aab11c57686cca99d14e\"\n                \"f184f9417fad8bedae4df8357e3710bcda1833b30e297d4b\"\n                \"f637938b995d231e557d13f062e81e830af5ab052208ead\",\n                16,\n            ),\n        },\n        {\n            \"curve\": \"sect571r1\",\n            \"d\": int(\n                \"3d2bd44ca9eeee8c860a4873ed55a54bdfdf5dab4060df72\"\n                \"92877960b85d1fd496aa33c587347213d7f6bf208a6ab4b4\"\n                \"30546e7b6ffbc3135bd12f44a28517867ca3c83a821d6f8\",\n                16,\n            ),\n            \"x\": int(\n                \"7a7af10f6617090bade18b2e092d0dfdc87cd616db7f2db1\"\n                \"33477a82bfe3ea421ebb7d6289980819292a719eb2471955\"\n                \"29ea60ad62862de0a26c72bfc49ecc81c2f9ed704e3168f\",\n                16,\n            ),\n            \"y\": int(\n                \"721496cf16f988b1aabef3368450441df8439a0ca794170f\"\n                \"270ead56203d675b57f5a4090a3a2f602a77ff3bac1417f7\"\n                \"e25a683f667b3b91f105016a47afad46a0367b18e2bdf0c\",\n                16,\n            ),\n        },\n    ]\n\n    assert expected == load_fips_ecdsa_key_pair_vectors(vector_data)\n\n\ndef test_load_fips_ecdsa_signing_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.2\n    #  \"SigVer\" information for \"ecdsa_values\"\n    #  Curves/SHAs selected: P-192, B-571,SHA-512\n    #  Generated on Tue Aug 16 15:27:42 2011\n\n    [P-192,SHA-1]\n\n    Msg = ebf748d748ebbca7d29fb473698a6e6b4fb10c865d4af024cc39ae3df3464ba4f1d6\\\nd40f32bf9618a91bb5986fa1a2af048a0e14dc51e5267eb05e127d689d0ac6f1a7f156ce066316\\\nb971cc7a11d0fd7a2093e27cf2d08727a4e6748cc32fd59c7810c5b9019df21cdcc0bca432c0a3\\\need0785387508877114359cee4a071cf\n    d = e14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\n    Qx = 07008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6\n    Qy = 76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477\n    k = cb0abc7043a10783684556fb12c4154d57bc31a289685f25\n    R = 6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e\n    S = 02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41\n    Result = F (3 - S changed)\n\n    Msg = 0dcb3e96d77ee64e9d0a350d31563d525755fc675f0c833504e83fc69c030181b42f\\\ne80c378e86274a93922c570d54a7a358c05755ec3ae91928e02236e81b43e596e4ccbf6a910488\\\n9c388072bec4e1faeae11fe4eb24fa4f9573560dcf2e3abc703c526d46d502c7a7222583431cc8\\\n178354ae7dbb84e3479917707bce0968\n    d = 7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244\n    Qx = 0ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d\n    Qy = 7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225\n    k = 3c646b0f03f5575e5fd463d4319817ce8bd3022eaf551cef\n    R = a3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e\n    S = 8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7\n\n    [B-571,SHA-512]\n\n    Msg = 10d2e00ae57176c79cdfc746c0c887abe799ee445b151b008e3d9f81eb69be40298d\\\ndf37b5c45a9b6e5ff83785d8c140cf11e6a4c3879a2845796872363da24b10f1f8d9cc48f8af20\\\n681dceb60dd62095d6d3b1779a4a805de3d74e38983b24c0748618e2f92ef7cac257ff4bd1f411\\\n13f2891eb13c47930e69ddbe91f270fb\n    d = 03e1b03ffca4399d5b439fac8f87a5cb06930f00d304193d7daf83d5947d0c1e293f74\\\naef8e56849f16147133c37a6b3d1b1883e5d61d6b871ea036c5291d9a74541f28878cb986\n    Qx = 3b236fc135d849d50140fdaae1045e6ae35ef61091e98f5059b30eb16acdd0deb2bc0\\\nd3544bc3a666e0014e50030134fe5466a9e4d3911ed580e28851f3747c0010888e819d3d1f\n    Qy = 3a8b6627a587d289032bd76374d16771188d7ff281c39542c8977f6872fa932e5daa1\\\n4e13792dea9ffe8e9f68d6b525ec99b81a5a60cfb0590cc6f297cfff8d7ba1a8bb81fe2e16\n    k = 2e56a94cfbbcd293e242f0c2a2e9df289a9480e6ba52e0f00fa19bcf2a7769bd155e6b\\\n79ddbd6a8646b0e69c8baea27f8034a18796e8eb4fe6e0e2358c383521d9375d2b6b437f9\n    R = 2eb1c5c1fc93cf3c8babed12c031cf1504e094174fd335104cbe4a2abd210b5a14b1c3\\\na455579f1ed0517c31822340e4dd3c1f967e1b4b9d071a1072afc1a199f8c548cd449a634\n    S = 22f97bb48641235826cf4e597fa8de849402d6bd6114ad2d7fbcf53a08247e5ee921f1\\\nbd5994dffee36eedff5592bb93b8bb148214da3b7baebffbd96b4f86c55b3f6bbac142442\n    Result = P (0 )\n\n    Msg = b61a0849a28672cb536fcf61ea2eb389d02ff7a09aa391744cae6597bd56703c40c5\\\n0ca2dee5f7ee796acfd47322f03d8dbe4d99dc8eec588b4e5467f123075b2d74b2a0b0bbfd3ac5\\\n487a905fad6d6ac1421c2e564c0cf15e1f0f10bc31c249b7b46edd2462a55f85560d99bde9d5b0\\\n6b97817d1dbe0a67c701d6e6e7878272\n    d = 2e09ffd8b434bb7f67d1d3ccf482164f1653c6e4ec64dec2517aa21b7a93b2b21ea1ee\\\nbb54734882f29303e489f02e3b741a87287e2dcdf3858eb6d2ec668f8b5b26f442ce513a2\n    Qx = 36f1be8738dd7dae4486b86a08fe90424f3673e76b10e739442e15f3bfafaf841842a\\\nc98e490521b7e7bb94c127529f6ec6a42cc6f06fc80606f1210fe020ff508148f93301c9d3\n    Qy = 4d39666ebe99fe214336ad440d776c88eb916f2f4a3433548b87d2aebed840b424d15\\\nc8341b4a0a657bf6a234d4fe78631c8e07ac1f4dc7474cd6b4545d536b7b17c160db4562d9\n    k = 378e7801566d7b77db7a474717ab2195b02957cc264a9449d4126a7cc574728ed5a476\\\n9abd5dde987ca66cfe3d45b5fc52ffd266acb8a8bb3fcb4b60f7febbf48aebe33bd3efbdd\n    R = 3d8105f87fe3166046c08e80a28acc98a80b8b7a729623053c2a9e80afd06756edfe09\\\nbdcf3035f6829ede041b745955d219dc5d30ddd8b37f6ba0f6d2857504cdc68a1ed812a10\n    S = 34db9998dc53527114518a7ce3783d674ca8cced823fa05e2942e7a0a20b3cc583dcd9\\\n30c43f9b93079c5ee18a1f5a66e7c3527c18610f9b47a4da7e245ef803e0662e4d2ad721c\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"curve\": \"secp192r1\",\n            \"digest_algorithm\": \"SHA-1\",\n            \"message\": binascii.unhexlify(\n                b\"ebf748d748ebbca7d29fb473698a6e6b4fb10c865d4af024cc39ae3df346\"\n                b\"4ba4f1d6d40f32bf9618a91bb5986fa1a2af048a0e14dc51e5267eb05e12\"\n                b\"7d689d0ac6f1a7f156ce066316b971cc7a11d0fd7a2093e27cf2d08727a4\"\n                b\"e6748cc32fd59c7810c5b9019df21cdcc0bca432c0a3eed0785387508877\"\n                b\"114359cee4a071cf\"\n            ),\n            \"d\": int(\"e14f37b3d1374ff8b03f41b9b3fdd2f0ebccf275d660d7f3\", 16),\n            \"x\": int(\"7008ea40b08dbe76432096e80a2494c94982d2d5bcf98e6\", 16),\n            \"y\": int(\"76fab681d00b414ea636ba215de26d98c41bd7f2e4d65477\", 16),\n            \"r\": int(\"6994d962bdd0d793ffddf855ec5bf2f91a9698b46258a63e\", 16),\n            \"s\": int(\"02ba6465a234903744ab02bc8521405b73cf5fc00e1a9f41\", 16),\n            \"fail\": True,\n        },\n        {\n            \"curve\": \"secp192r1\",\n            \"digest_algorithm\": \"SHA-1\",\n            \"message\": binascii.unhexlify(\n                b\"0dcb3e96d77ee64e9d0a350d31563d525755fc675f0c833504e83fc69c03\"\n                b\"0181b42fe80c378e86274a93922c570d54a7a358c05755ec3ae91928e022\"\n                b\"36e81b43e596e4ccbf6a9104889c388072bec4e1faeae11fe4eb24fa4f95\"\n                b\"73560dcf2e3abc703c526d46d502c7a7222583431cc8178354ae7dbb84e3\"\n                b\"479917707bce0968\"\n            ),\n            \"d\": int(\"7a0235bea3d70445f14d56f9b7fb80ec8ff4eb2f76865244\", 16),\n            \"x\": int(\"ea3c1fa1f124f26530cbfddeb831eecc67df31e08889d1d\", 16),\n            \"y\": int(\"7215a0cce0501b47903bd8fe1179c2dfe07bd076f89f5225\", 16),\n            \"r\": int(\"a3ba51c39c43991d87dff0f34d0bec7c883299e04f60f95e\", 16),\n            \"s\": int(\"8a7f9c59c6d65ad390e4c19636ba92b53be5d0f848b4e1f7\", 16),\n        },\n        {\n            \"curve\": \"sect571r1\",\n            \"digest_algorithm\": \"SHA-512\",\n            \"message\": binascii.unhexlify(\n                b\"10d2e00ae57176c79cdfc746c0c887abe799ee445b151b008e3d9f81eb69\"\n                b\"be40298ddf37b5c45a9b6e5ff83785d8c140cf11e6a4c3879a2845796872\"\n                b\"363da24b10f1f8d9cc48f8af20681dceb60dd62095d6d3b1779a4a805de3\"\n                b\"d74e38983b24c0748618e2f92ef7cac257ff4bd1f41113f2891eb13c4793\"\n                b\"0e69ddbe91f270fb\"\n            ),\n            \"d\": int(\n                \"3e1b03ffca4399d5b439fac8f87a5cb06930f00d304193d7daf83d59\"\n                \"47d0c1e293f74aef8e56849f16147133c37a6b3d1b1883e5d61d6b87\"\n                \"1ea036c5291d9a74541f28878cb986\",\n                16,\n            ),\n            \"x\": int(\n                \"3b236fc135d849d50140fdaae1045e6ae35ef61091e98f5059b30eb1\"\n                \"6acdd0deb2bc0d3544bc3a666e0014e50030134fe5466a9e4d3911ed\"\n                \"580e28851f3747c0010888e819d3d1f\",\n                16,\n            ),\n            \"y\": int(\n                \"3a8b6627a587d289032bd76374d16771188d7ff281c39542c8977f68\"\n                \"72fa932e5daa14e13792dea9ffe8e9f68d6b525ec99b81a5a60cfb05\"\n                \"90cc6f297cfff8d7ba1a8bb81fe2e16\",\n                16,\n            ),\n            \"r\": int(\n                \"2eb1c5c1fc93cf3c8babed12c031cf1504e094174fd335104cbe4a2a\"\n                \"bd210b5a14b1c3a455579f1ed0517c31822340e4dd3c1f967e1b4b9d\"\n                \"071a1072afc1a199f8c548cd449a634\",\n                16,\n            ),\n            \"s\": int(\n                \"22f97bb48641235826cf4e597fa8de849402d6bd6114ad2d7fbcf53a\"\n                \"08247e5ee921f1bd5994dffee36eedff5592bb93b8bb148214da3b7b\"\n                \"aebffbd96b4f86c55b3f6bbac142442\",\n                16,\n            ),\n            \"fail\": False,\n        },\n        {\n            \"curve\": \"sect571r1\",\n            \"digest_algorithm\": \"SHA-512\",\n            \"message\": binascii.unhexlify(\n                b\"b61a0849a28672cb536fcf61ea2eb389d02ff7a09aa391744cae6597bd56\"\n                b\"703c40c50ca2dee5f7ee796acfd47322f03d8dbe4d99dc8eec588b4e5467\"\n                b\"f123075b2d74b2a0b0bbfd3ac5487a905fad6d6ac1421c2e564c0cf15e1f\"\n                b\"0f10bc31c249b7b46edd2462a55f85560d99bde9d5b06b97817d1dbe0a67\"\n                b\"c701d6e6e7878272\"\n            ),\n            \"d\": int(\n                \"2e09ffd8b434bb7f67d1d3ccf482164f1653c6e4ec64dec2517aa21b\"\n                \"7a93b2b21ea1eebb54734882f29303e489f02e3b741a87287e2dcdf3\"\n                \"858eb6d2ec668f8b5b26f442ce513a2\",\n                16,\n            ),\n            \"x\": int(\n                \"36f1be8738dd7dae4486b86a08fe90424f3673e76b10e739442e15f3\"\n                \"bfafaf841842ac98e490521b7e7bb94c127529f6ec6a42cc6f06fc80\"\n                \"606f1210fe020ff508148f93301c9d3\",\n                16,\n            ),\n            \"y\": int(\n                \"4d39666ebe99fe214336ad440d776c88eb916f2f4a3433548b87d2ae\"\n                \"bed840b424d15c8341b4a0a657bf6a234d4fe78631c8e07ac1f4dc74\"\n                \"74cd6b4545d536b7b17c160db4562d9\",\n                16,\n            ),\n            \"r\": int(\n                \"3d8105f87fe3166046c08e80a28acc98a80b8b7a729623053c2a9e80\"\n                \"afd06756edfe09bdcf3035f6829ede041b745955d219dc5d30ddd8b3\"\n                \"7f6ba0f6d2857504cdc68a1ed812a10\",\n                16,\n            ),\n            \"s\": int(\n                \"34db9998dc53527114518a7ce3783d674ca8cced823fa05e2942e7a0\"\n                \"a20b3cc583dcd930c43f9b93079c5ee18a1f5a66e7c3527c18610f9b\"\n                \"47a4da7e245ef803e0662e4d2ad721c\",\n                16,\n            ),\n        },\n    ]\n    assert expected == load_fips_ecdsa_signing_vectors(vector_data)\n\n\ndef test_load_kasvs_dh_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    [SHA(s) supported (Used for hashing Z): SHA256 ]\n    #  Generated on Thu Mar 17 20:44:26 2011\n\n\n\n    [FA - SHA1]\n    P = da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a06848bf7a\\\n42f18895c97402e81118e01a00d0855d51922f434c022350861d58ddf60d65bc6941fc6064b147\\\n071a4c30426d82fc90d888f94990267c64beef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8\\\nb59afb62cfe9ea3ba042c73a6ade35\n    Q = f2ca7621eb250aa5f22cef1907011295defc50a7\n    G = a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5e3e5af586\\\n3a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc623f648fd6d95e9cefcb0745763\\\ncddf564c87bcf4ba7928e74fd6a3080481f588d535e4c026b58a21e1e5ec412ff241b436043e29\\\n173f1dc6cb943c09742de989547288\n\n\n\n    COUNT = 0\n    XstatCAVS = 42c6ee70beb7465928a1efe692d2281b8f7b53d6\n    YstatCAVS = 5a7890f6d20ee9c7162cd84222cb0c7cb5b4f29244a58fc95327fc41045f47\\\n6fb3da42fca76a1dd59222a7a7c3872d5af7d8dc254e003eccdb38f291619c51911df2b6ed67d0\\\nb459f4bc25819c0078777b9a1a24c72e7c037a3720a1edad5863ef5ac75ce816869c820859558d\\\n5721089ddbe331f55bef741396a3bbf85c6c1a\n    XstatIUT = 54081a8fef2127a1f22ed90440b1b09c331d0614\n    YstatIUT = 0b92af0468b841ea5de4ca91d895b5e922245421de57ed7a88d2de41610b208\\\ne8e233705f17b2e9eb91914bad2fa87f0a58519a7da2980bc06e7411c925a6050526bd86e62150\\\n5e6f610b63fdcd9afcfaa96bd087afca44d9197cc35b559f731357a5b979250c0f3a254bb8165f\\\n5072156e3fd6f9a6e69bcf4b4578f78b3bde7\n    Z = 8d8f4175e16e15a42eb9099b11528af88741cc206a088971d3064bb291eda608d1600b\\\nff829624db258fd15e95d96d3e74c6be3232afe5c855b9c59681ce13b7aea9ff2b16707e4c02f0\\\ne82bf6dadf2149ac62630f6c62dea0e505e3279404da5ffd5a088e8474ae0c8726b8189cb3d2f0\\\n4baffe700be849df9f91567fc2ebb8\n    CAVSHashZZ = eb99e77ac2272c7a2ee70c59375ac4d167312c20\n    Result = P (0 - Correct)\n\n\n\n    COUNT = 2\n    XstatCAVS = 32e642683d745a23dccf4f12f989d8dfd1fd9894c422930950cb4c71\n    YstatCAVS = 8cd371363b32fcc2e936e345f2278b77001f2efdf78512c3ee75c12f88507e\\\n2d5c0e5cdded3bb78435506c8028a3f4d6f028c0f49a0d61f1285795197e56deac80279e723f2b\\\n3746e213ac8ec60f1cefc2308ff17a7e9e2efab537e17406d2829fd85e0c54dda2d9f0b4fcda3d\\\n2776110e096a817588e19588b77be8b41bafdd41ad91b0edf629333bd6ac1e461208ead124c31b\\\n8a7935c723e1c450c5798dc05f8265ad9e35095ff112af9e889f00315fa337a76a450670866eca\\\n12cc6ad0778576962eb9cdc12721d3c15e4d87b67488a145d400240670eb26695a42879cd3940a\\\n55087f6527667277e1212a202dbe455c45c64b9be4a38153557bbb8fd755\n    XstatIUT = 7d8ae93df3bc09d399a4157ec562126acf51092c3269ab27f60a3a2b\n    YstatIUT = 22127e9728e906ea4b1512c8b1e80474b58446210c23ccfc800f83c2c15da81\\\n59940e494b235266f6a9d5f80529067794f1a9edd566755d23d0a3060fe074c5a10122df3e4729\\\n73bba39ea3a988e8387f5f0491e590b6b5edc299b4598ab1e79b72681a0be8cd8735a5adb85fa3\\\n1310f29ec407c9654f1bb83bcdf7f771b68d176817f662e8d798b53ebb4e5dd407b7b1d8fdb62e\\\na9e1b60d6c3d75d9bcf83f4b8d1ed39408bd8d973b4ea81e8e832eac361dcd530713388a60971e\\\na9f8b1e69c1e99df1cca12bdaf293dacfa1419c5692ceffa91988aef3321ac8cbc2efae6c4337c\\\n8808310fb5a240395a98e6004fe613c39e84f4177341746d9e388dcb2e8\n    Z = 0efeaa399a182e0a603baf0dd95aa0fae5289ebd47d5f0f60c86bc936839c31c9f7f37\\\nbf04f76ab02f4094a8ab10ed907ec7291585cc085c3e8981df2bd46a01c19ec9a2f66709df1d4f\\\nefbeb48c8263554e46890f59eb642bf95ff7f0de70138621c22c4cc32be6c3d5c82c0c9a76a9f5\\\na65bffe0c096a350f96a9da945d7e5095b15b566ce3cb8b0377cd9375b6c046afa9ea0bc084677\\\n3445f16566b2c84cae4f6d212e89ee539a1ce7ea325273fd228053efce2a585eb9e8f308b48cf4\\\ne29593b6f7a02e8625e1e8bff1ea1405f8c8c34b8339a9a99c7c9de4eb9895df7719ccda9394f5\\\n3080eff1226f6b9c7ae0a38941e18b1a137aabbb62308eb35ba2\n    CAVSHashZZ = 76dedc997d5113573bbeeaf991f62b257511b7d9aa83270dfc4fec40\n    Result = P (10 - Z value should have leading 0 nibble )\n\n\n\n    COUNT = 3\n    XstatCAVS = 66502429aba271e2f2ee2197a2b336e5f0467f192aa28b60dcbf1194\n    YstatCAVS = dfb001294215423d7146a2453cdb8598ccef01e1d931a913c3e4ed4a3cf38a\\\n912066c28e4eaf77dd80ff07183a6160bd95932f513402f864dcf7a70cbedc9b60bbfbc67f72a8\\\n3d5f6463a2b5a4fc906d3e921f5e1069126113265b440e15ccf2d7164bad7131f1613fec35df7f\\\n470d45888e0c91be091f3f9552d670b8b7f479853193cb3c39f35fc7bd547ccb1bc579a67302b4\\\nba948e6db51043d351bb74a952e6a694e6e7456f714c47d7c8eeeb4fd83ad93c86b78445f9393f\\\ndfd65c7dbd7fd6eba9794ddf183901b1d213321fd0ab3f7588ab0f6b3692f365a87131eda0e062\\\n505861988f6ce63150207545ecf9678e0971330253dfb7cfd546c5346fec\n    XstatIUT = 106b358be4f068348ac240ecbb454e5c39ca80b078cb0fafd856e9c5\n    YstatIUT = 715d0781975b7b03162f4401c1eda343fd9bf1140006034573b31828a618c35\\\n6163554cd27da956f7179a69e860fb6efeaa2e2aa9f1261506a8344c4929953621381b13d6426e\\\n152c0f2f94bfcd2b758eca24923596d427ed8f957e8bc9b1c7d21a87ef02222a1477cf3bfaadc6\\\n8106456ab9706026006eccd290b21543de6bb97d5b8cf4ccee1c081a6d1dd27aaef060fa93888a\\\n47a4a416ad5c5bd490ea600e04379232fb1077fbf394f4579accdbe352714e25b88916dca8d8f7\\\ne0c4ed9594f7693f656a235a2e88ebda48b0d557e32da9f12d2a4c3180f05b16b4fba9bec79278\\\na3971b77f9223b5ab78b857e0376c5008211592c8c72d521373ee3b22b8\n    Z = cf879ebd107bb877457809c3fc410218b7acba3c5967495a8f1c3370d57f038a48dd69\\\nf9f69b9f4dd855e7c58a1e4ec32646a978266eb314db468ea1dfcee8a85a1644a5732498c4fbcd\\\nf85098c6ed0ce12e431e99142fd2335369b3f56620ada21aa69d883e82a0b5e35484dde32d17c2\\\ndc873f2cc5518eb7fc19695dff9fc94c9d9432bb4b09d8180323cfc561ebc2d6eff8dd5f8496f2\\\nb22377700a22bbfe61a6969c198129397454843e4fc3540026986039665095490056287e4fc49e\\\n6cb3181cb2bf06444fd0040150271c9ce1f61c13ecd5dd022194a2dbf3e1c7fbc6bd19497c7b88\\\n8b4da613d28fa6f378a43369cb8795a1c823f7d6cf4d84bba578\n    CAVSHashZZ = ebac4fb70699224f85d9e3c799b1f3a56dab268b882aba49525df02d\n    Result = F (5 - Z changed )\n\n\n\n    [FB - SHA224]\n    P = f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e57920d356e5047\\\n8d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b17293fea3e3d6bff8ac4cca93a805386f062a\\\n8a27ae906ef5da94d279fd7b3d7289e00956f76bae9c0d2b8d11742ca5809630632aae58f9c6dc\\\ne00c7380581deffde2187b022f83c6ceaeaadb0844a17fcbb04039ca6843c91f0c9058b22434b2\\\n63c3dfda8de8429e087c5be97fc5c9db9526031ad3a218bd9916fb4a3c27966d208b1e360014c0\\\n1e95530c148fb3cd27e6a7250d3c3b81dcd220ca14548dbccf99ebb9e334db6bcd14e632c98dd3\\\nf9860af7ae450f1b7809b45f0ec10e6f27672beebc9963befc73\n    Q = a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5\n    G = 035513ec441402b78353ab1bba550b21c76c89973885a627170262ef52497d5d137b89\\\n27a212aaab2f051198c90bb81dffd9eb10b36b7ca3b63565b4c1025aea3b5e9c4a348c9cfa17f3\\\n907a1e4469701c0dedb8a4b9e96c5965b1fb8c229b0c34baac774bf9dda4fc5ee8764358b3c848\\\n12878aab7464bc09e97aecab7d7e3fbb4870e2a3b89667a4158bf1ed1a90dfaf47019fbb52b1b9\\\n6365bb4e1e9474993fe382fd23480dc875861be152997a621fdb7aef977ea5b4d3d74486b162dc\\\n28f95a64cf65587a919a57eef92934fc9410df7f09fa82f975328ed82ff29cc3e15a971f56f4ac\\\n2dcb289252575e02a6cdb7fcc6cddd7b0dca9c422e63eb2b8f05\n\n\n\n    COUNT = 0\n    XstatCAVS = 1610eaa4e0ccc8857e2b53149e008492b1fbd9025a6e8d95aaee9c0f\n    YstatCAVS = 51ee21cd9f97015180f258fad5c94ff5a458806b1412087236bf77fe87aae1\\\na36735816ed6e2160a731159814b6ae1f3f52c478dd9207094adfb62f7667d5c366327e66d2309\\\n6395e938504db330953a708015f861fe9d9487611093b9fe7327518a7cc15994ab573313e15411\\\n7c1a3ae88b8bdd1e316748249e4a9cbd1947f159836d13613d1f9449fc3442171d1970bc28958c\\\n1cafa2776a6f14ccdb29db02f64911bd83bfdcdfc843dd14a4cab9acb0bda8b293d2f5f7050768\\\ne57533cbc415a29e6f31cc365e107f91ae3722484e2c7329a85af69055a5a104da37e810878896\\\nd1b247b02b75234ecff82b1958f42d7b031622e9394c98b5229112f7f620\n    XstatIUT = 0c4c83d75b27864b052cadc556e500e25aabf0c9d1bc01f0e1fe3862\n    YstatIUT = 467a857337a82472a1307a64dccc8e9994c5c63ec4312936885d17be419051a\\\n5f037fbb052d7010ebe01634d9e8b8b522d9ab4749fdc274f465369b89e360df8f70b7865a3c71\\\nd2dbcd2df19e9293dab1153d3d63fcb7deb559b684dde6c6eed63214444807041c9a0ce3f52ca4\\\n39ec16dd231995b5dc6f18e6801b6bd6454babccf9abbfacffb49c71e6494a4779cbfa550c5d71\\\n44114e6fc193f460dcd0be7e6e06e546da7653770dc5859df87029e722dbe81361030569148d16\\\n36988926bf0dcfe47c9d8a54698c08b3b5c70afe86b5c6f643463f8f34889d27d6cfd2d478c2d7\\\nb3d008a985c7380f0b43f10024b59c3543880883c42d0e7e0a07326ba3a\n    Z = 10a30bacab82e652415376baffdbc008c7eb2e5a3aa68bc10ce486ca84983fd89b1b02\\\n7bb40e75333406361005f5e756526a95fe01202df9217d81b1713d5187c368fdd4c9c2433d9e6c\\\n18844769479b725c4140c92a304ee1bc5726d8f5321b5b1c54a1a6b67c527e6817c0ed613a0d4e\\\n60db55de898788b7e8d4aa9a81ab5ed7f6282962c433d246ed640555bdd76d29c2874551264d74\\\nc76373f8a88871b41b041c98041b16f94f983ddf00f5bc7d2416d19168c90178974a0602436cd1\\\n86748bcc63a629edc3a0db59415cccd37a65130ea477c89da92d41371f5972891cf41f9c7f0e75\\\nccbff9893225384db30daa5e310f08e3e0fad98bcdf8ecf35fe5\n    CAVSHashZZ = 014f5daea733d0e9e100f852e74d64a319f741cfbdb47975ab9dd3d0\n    Result = F (3 - IUT's Static public key fails PKV 5.6.2.4)\n\n\n    COUNT = 1\n    XstatCAVS = 9ee22ac51664e40e0a24dbb94142dba40605e2b6eeaaa0268a0f6847\n    YstatCAVS = c2630c9d38ed5c825d1c6a3eba7143f3fc8a049c8bcd1efc212d2af64eca99\\\n4308208691d330aa8f27fc4a1e55de4e512113996d21375a667f8c26d76dee2f6809b15432a33f\\\nb735aca5c2263940f58712bded08f55443dee300b9489589e0462bd6bce19deaec4adc12fa61a6\\\n94c8c5c999b28211d7835bac0ffd2b316850823e2dc1d1f58e05cbf75c673036d116b3f03b9687\\\nc89f9c2a0d43c4ffc9a605addbdcce0cb3790c6db846156bb857a7b3df40dc6ed04d19cc9eaebb\\\n6bbc034e77c3d882a1a62317cce25b6130f0803e3bc49b5e36768260073a617034872be0b50bed\\\n32740224beaf582d67fbcfef3b3ecc18f9c71c782e9a68495ef31dc7986e\n    XstatIUT = 438093a468236658821bf64eb08456139963d4fb27121c3ed6c55876\n    YstatIUT = e192da8e1244e27221c1765344a5bb379dce741d427a734b4bdb6c4d16b2490\\\nbd37564d745008e63ae46ef332331d79887ac63298ce143e125f8b320c0f859b7f5f2c1e0053e4\\\na7a16997e6143ff702300c9863ae7caef5c1dfca0ecf5197c557745b793f0790a4fe678aeb93fd\\\nb52490d4f273a5553944dda3ac8b9b792c9b67f8d7b9496398e432a423ae87ebeba688be3ed67e\\\nddd7575fa56431cd48579bf53c903bbe066dd78b23c0996ef3a880f0d91315104366a82f01abde\\\ncce96fd371f94e8420f8bc5b896c801df573554f749b03d0d28b1e1a990bc61c7e9659342ac7e2\\\n68e9c0b7c40fdaab394f29cf0a54f780022f9a03b0bd28eb7db8b0b1b47\n    Z = 56f8f40fa4b8f3580f9014b30d60a42933a53a62182a690142f458dc275c3b2f0e721b\\\nc5ee6e890b14516419110f5252ff1cceea8e274b2987aa78e3bae90c1935b276b7a1f1c944f79d\\\n4774b7a85b3355bdf25cb02bddfbda4ee7918bc93a5c9ca6d7e8fdedbda8e6c8a6ca794bad055a\\\n52b19c148958227344cbddd70271d4610316cfea1e559b0bc3a12d15023b30d9f2db602053a056\\\n9c3bd2ce1faf59280ecd339f845dbcaaf2e883c5cc6263996f866b18b75d049d4c82097af8a5ce\\\n353e14416b3eeb31ba9bc4f6f3dbd846c5299fb5c0043a1b95b9149b39d14df9e6a69547abf8a4\\\nd518475576730ed528779366568e46b7dd4ed787cb72d0733c93\n    CAVSHashZZ = 17dbbaa7a20c1390cd8cb3d31ee947bf9dde87739e067b9861ffeea9\n    Result = P (0 - Correct)\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"fail_agree\": False,\n            \"fail_z\": False,\n            \"g\": int(\n                \"a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5\"\n                \"e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6\"\n                \"23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f\"\n                \"588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974\"\n                \"2de989547288\",\n                16,\n            ),\n            \"p\": int(\n                \"da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a\"\n                \"06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d\"\n                \"58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b\"\n                \"eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0\"\n                \"42c73a6ade35\",\n                16,\n            ),\n            \"q\": 1386090807861091316803998193774751098153687863463,\n            \"x1\": 381229709512864262422021151581620734547375903702,\n            \"x2\": 479735944608461101114916716909067001453470352916,\n            \"y1\": int(\n                \"5a7890f6d20ee9c7162cd84222cb0c7cb5b4f29244a58fc95327fc41045f4\"\n                \"76fb3da42fca76a1dd59222a7a7c3872d5af7d8dc254e003eccdb38f29161\"\n                \"9c51911df2b6ed67d0b459f4bc25819c0078777b9a1a24c72e7c037a3720a\"\n                \"1edad5863ef5ac75ce816869c820859558d5721089ddbe331f55bef741396\"\n                \"a3bbf85c6c1a\",\n                16,\n            ),\n            \"y2\": int(\n                \"b92af0468b841ea5de4ca91d895b5e922245421de57ed7a88d2de41610b20\"\n                \"8e8e233705f17b2e9eb91914bad2fa87f0a58519a7da2980bc06e7411c925\"\n                \"a6050526bd86e621505e6f610b63fdcd9afcfaa96bd087afca44d9197cc35\"\n                \"b559f731357a5b979250c0f3a254bb8165f5072156e3fd6f9a6e69bcf4b45\"\n                \"78f78b3bde7\",\n                16,\n            ),\n            \"z\": binascii.unhexlify(\n                b\"8d8f4175e16e15a42eb9099b11528af88741cc206a088971d3064bb291ed\"\n                b\"a608d1600bff829624db258fd15e95d96d3e74c6be3232afe5c855b9c596\"\n                b\"81ce13b7aea9ff2b16707e4c02f0e82bf6dadf2149ac62630f6c62dea0e5\"\n                b\"05e3279404da5ffd5a088e8474ae0c8726b8189cb3d2f04baffe700be849\"\n                b\"df9f91567fc2ebb8\"\n            ),\n        },\n        {\n            \"fail_agree\": False,\n            \"fail_z\": False,\n            \"g\": int(\n                \"a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5\"\n                \"e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6\"\n                \"23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f\"\n                \"588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974\"\n                \"2de989547288\",\n                16,\n            ),\n            \"p\": int(\n                \"da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a\"\n                \"06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d\"\n                \"58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b\"\n                \"eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0\"\n                \"42c73a6ade35\",\n                16,\n            ),\n            \"q\": 1386090807861091316803998193774751098153687863463,\n            \"x1\": int(\n                \"32e642683d745a23dccf4f12f989d8dfd1fd9894c422930950cb4c71\", 16\n            ),\n            \"x2\": int(\n                \"7d8ae93df3bc09d399a4157ec562126acf51092c3269ab27f60a3a2b\", 16\n            ),\n            \"y1\": int(\n                \"8cd371363b32fcc2e936e345f2278b77001f2efdf78512c3ee75c12f88507\"\n                \"e2d5c0e5cdded3bb78435506c8028a3f4d6f028c0f49a0d61f1285795197e\"\n                \"56deac80279e723f2b3746e213ac8ec60f1cefc2308ff17a7e9e2efab537e\"\n                \"17406d2829fd85e0c54dda2d9f0b4fcda3d2776110e096a817588e19588b7\"\n                \"7be8b41bafdd41ad91b0edf629333bd6ac1e461208ead124c31b8a7935c72\"\n                \"3e1c450c5798dc05f8265ad9e35095ff112af9e889f00315fa337a76a4506\"\n                \"70866eca12cc6ad0778576962eb9cdc12721d3c15e4d87b67488a145d4002\"\n                \"40670eb26695a42879cd3940a55087f6527667277e1212a202dbe455c45c6\"\n                \"4b9be4a38153557bbb8fd755\",\n                16,\n            ),\n            \"y2\": int(\n                \"22127e9728e906ea4b1512c8b1e80474b58446210c23ccfc800f83c2c15da\"\n                \"8159940e494b235266f6a9d5f80529067794f1a9edd566755d23d0a3060fe\"\n                \"074c5a10122df3e472973bba39ea3a988e8387f5f0491e590b6b5edc299b4\"\n                \"598ab1e79b72681a0be8cd8735a5adb85fa31310f29ec407c9654f1bb83bc\"\n                \"df7f771b68d176817f662e8d798b53ebb4e5dd407b7b1d8fdb62ea9e1b60d\"\n                \"6c3d75d9bcf83f4b8d1ed39408bd8d973b4ea81e8e832eac361dcd5307133\"\n                \"88a60971ea9f8b1e69c1e99df1cca12bdaf293dacfa1419c5692ceffa9198\"\n                \"8aef3321ac8cbc2efae6c4337c8808310fb5a240395a98e6004fe613c39e8\"\n                \"4f4177341746d9e388dcb2e8\",\n                16,\n            ),\n            \"z\": binascii.unhexlify(\n                b\"0efeaa399a182e0a603baf0dd95aa0fae5289ebd47d5f0f60c86bc936839\"\n                b\"c31c9f7f37bf04f76ab02f4094a8ab10ed907ec7291585cc085c3e8981df\"\n                b\"2bd46a01c19ec9a2f66709df1d4fefbeb48c8263554e46890f59eb642bf9\"\n                b\"5ff7f0de70138621c22c4cc32be6c3d5c82c0c9a76a9f5a65bffe0c096a3\"\n                b\"50f96a9da945d7e5095b15b566ce3cb8b0377cd9375b6c046afa9ea0bc08\"\n                b\"46773445f16566b2c84cae4f6d212e89ee539a1ce7ea325273fd228053ef\"\n                b\"ce2a585eb9e8f308b48cf4e29593b6f7a02e8625e1e8bff1ea1405f8c8c3\"\n                b\"4b8339a9a99c7c9de4eb9895df7719ccda9394f53080eff1226f6b9c7ae0\"\n                b\"a38941e18b1a137aabbb62308eb35ba2\"\n            ),\n        },\n        {\n            \"fail_agree\": False,\n            \"fail_z\": True,\n            \"g\": int(\n                \"a51883e9ac0539859df3d25c716437008bb4bd8ec4786eb4bc643299daef5\"\n                \"e3e5af5863a6ac40a597b83a27583f6a658d408825105b16d31b6ed088fc6\"\n                \"23f648fd6d95e9cefcb0745763cddf564c87bcf4ba7928e74fd6a3080481f\"\n                \"588d535e4c026b58a21e1e5ec412ff241b436043e29173f1dc6cb943c0974\"\n                \"2de989547288\",\n                16,\n            ),\n            \"p\": int(\n                \"da3a8085d372437805de95b88b675122f575df976610c6a844de99f1df82a\"\n                \"06848bf7a42f18895c97402e81118e01a00d0855d51922f434c022350861d\"\n                \"58ddf60d65bc6941fc6064b147071a4c30426d82fc90d888f94990267c64b\"\n                \"eef8c304a4b2b26fb93724d6a9472fa16bc50c5b9b8b59afb62cfe9ea3ba0\"\n                \"42c73a6ade35\",\n                16,\n            ),\n            \"q\": 1386090807861091316803998193774751098153687863463,\n            \"x1\": int(\n                \"66502429aba271e2f2ee2197a2b336e5f0467f192aa28b60dcbf1194\", 16\n            ),\n            \"x2\": int(\n                \"106b358be4f068348ac240ecbb454e5c39ca80b078cb0fafd856e9c5\", 16\n            ),\n            \"y1\": int(\n                \"dfb001294215423d7146a2453cdb8598ccef01e1d931a913c3e4ed4a3cf38\"\n                \"a912066c28e4eaf77dd80ff07183a6160bd95932f513402f864dcf7a70cbe\"\n                \"dc9b60bbfbc67f72a83d5f6463a2b5a4fc906d3e921f5e1069126113265b4\"\n                \"40e15ccf2d7164bad7131f1613fec35df7f470d45888e0c91be091f3f9552\"\n                \"d670b8b7f479853193cb3c39f35fc7bd547ccb1bc579a67302b4ba948e6db\"\n                \"51043d351bb74a952e6a694e6e7456f714c47d7c8eeeb4fd83ad93c86b784\"\n                \"45f9393fdfd65c7dbd7fd6eba9794ddf183901b1d213321fd0ab3f7588ab0\"\n                \"f6b3692f365a87131eda0e062505861988f6ce63150207545ecf9678e0971\"\n                \"330253dfb7cfd546c5346fec\",\n                16,\n            ),\n            \"y2\": int(\n                \"715d0781975b7b03162f4401c1eda343fd9bf1140006034573b31828a618c\"\n                \"356163554cd27da956f7179a69e860fb6efeaa2e2aa9f1261506a8344c492\"\n                \"9953621381b13d6426e152c0f2f94bfcd2b758eca24923596d427ed8f957e\"\n                \"8bc9b1c7d21a87ef02222a1477cf3bfaadc68106456ab9706026006eccd29\"\n                \"0b21543de6bb97d5b8cf4ccee1c081a6d1dd27aaef060fa93888a47a4a416\"\n                \"ad5c5bd490ea600e04379232fb1077fbf394f4579accdbe352714e25b8891\"\n                \"6dca8d8f7e0c4ed9594f7693f656a235a2e88ebda48b0d557e32da9f12d2a\"\n                \"4c3180f05b16b4fba9bec79278a3971b77f9223b5ab78b857e0376c500821\"\n                \"1592c8c72d521373ee3b22b8\",\n                16,\n            ),\n            \"z\": binascii.unhexlify(\n                b\"cf879ebd107bb877457809c3fc410218b7acba3c5967495a8f1c3370d57f\"\n                b\"038a48dd69f9f69b9f4dd855e7c58a1e4ec32646a978266eb314db468ea1\"\n                b\"dfcee8a85a1644a5732498c4fbcdf85098c6ed0ce12e431e99142fd23353\"\n                b\"69b3f56620ada21aa69d883e82a0b5e35484dde32d17c2dc873f2cc5518e\"\n                b\"b7fc19695dff9fc94c9d9432bb4b09d8180323cfc561ebc2d6eff8dd5f84\"\n                b\"96f2b22377700a22bbfe61a6969c198129397454843e4fc3540026986039\"\n                b\"665095490056287e4fc49e6cb3181cb2bf06444fd0040150271c9ce1f61c\"\n                b\"13ecd5dd022194a2dbf3e1c7fbc6bd19497c7b888b4da613d28fa6f378a4\"\n                b\"3369cb8795a1c823f7d6cf4d84bba578\"\n            ),\n        },\n        {\n            \"fail_agree\": True,\n            \"fail_z\": False,\n            \"g\": int(\n                \"35513ec441402b78353ab1bba550b21c76c89973885a627170262ef52497d\"\n                \"5d137b8927a212aaab2f051198c90bb81dffd9eb10b36b7ca3b63565b4c10\"\n                \"25aea3b5e9c4a348c9cfa17f3907a1e4469701c0dedb8a4b9e96c5965b1fb\"\n                \"8c229b0c34baac774bf9dda4fc5ee8764358b3c84812878aab7464bc09e97\"\n                \"aecab7d7e3fbb4870e2a3b89667a4158bf1ed1a90dfaf47019fbb52b1b963\"\n                \"65bb4e1e9474993fe382fd23480dc875861be152997a621fdb7aef977ea5b\"\n                \"4d3d74486b162dc28f95a64cf65587a919a57eef92934fc9410df7f09fa82\"\n                \"f975328ed82ff29cc3e15a971f56f4ac2dcb289252575e02a6cdb7fcc6cdd\"\n                \"d7b0dca9c422e63eb2b8f05\",\n                16,\n            ),\n            \"p\": int(\n                \"f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e57920\"\n                \"d356e50478d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b17293fea3e3\"\n                \"d6bff8ac4cca93a805386f062a8a27ae906ef5da94d279fd7b3d7289e0095\"\n                \"6f76bae9c0d2b8d11742ca5809630632aae58f9c6dce00c7380581deffde2\"\n                \"187b022f83c6ceaeaadb0844a17fcbb04039ca6843c91f0c9058b22434b26\"\n                \"3c3dfda8de8429e087c5be97fc5c9db9526031ad3a218bd9916fb4a3c2796\"\n                \"6d208b1e360014c01e95530c148fb3cd27e6a7250d3c3b81dcd220ca14548\"\n                \"dbccf99ebb9e334db6bcd14e632c98dd3f9860af7ae450f1b7809b45f0ec1\"\n                \"0e6f27672beebc9963befc73\",\n                16,\n            ),\n            \"q\": int(\n                \"a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5\", 16\n            ),\n            \"x1\": int(\n                \"1610eaa4e0ccc8857e2b53149e008492b1fbd9025a6e8d95aaee9c0f\", 16\n            ),\n            \"x2\": int(\n                \"c4c83d75b27864b052cadc556e500e25aabf0c9d1bc01f0e1fe3862\", 16\n            ),\n            \"y1\": int(\n                \"51ee21cd9f97015180f258fad5c94ff5a458806b1412087236bf77fe87aae\"\n                \"1a36735816ed6e2160a731159814b6ae1f3f52c478dd9207094adfb62f766\"\n                \"7d5c366327e66d23096395e938504db330953a708015f861fe9d948761109\"\n                \"3b9fe7327518a7cc15994ab573313e154117c1a3ae88b8bdd1e316748249e\"\n                \"4a9cbd1947f159836d13613d1f9449fc3442171d1970bc28958c1cafa2776\"\n                \"a6f14ccdb29db02f64911bd83bfdcdfc843dd14a4cab9acb0bda8b293d2f5\"\n                \"f7050768e57533cbc415a29e6f31cc365e107f91ae3722484e2c7329a85af\"\n                \"69055a5a104da37e810878896d1b247b02b75234ecff82b1958f42d7b0316\"\n                \"22e9394c98b5229112f7f620\",\n                16,\n            ),\n            \"y2\": int(\n                \"467a857337a82472a1307a64dccc8e9994c5c63ec4312936885d17be41905\"\n                \"1a5f037fbb052d7010ebe01634d9e8b8b522d9ab4749fdc274f465369b89e\"\n                \"360df8f70b7865a3c71d2dbcd2df19e9293dab1153d3d63fcb7deb559b684\"\n                \"dde6c6eed63214444807041c9a0ce3f52ca439ec16dd231995b5dc6f18e68\"\n                \"01b6bd6454babccf9abbfacffb49c71e6494a4779cbfa550c5d7144114e6f\"\n                \"c193f460dcd0be7e6e06e546da7653770dc5859df87029e722dbe81361030\"\n                \"569148d1636988926bf0dcfe47c9d8a54698c08b3b5c70afe86b5c6f64346\"\n                \"3f8f34889d27d6cfd2d478c2d7b3d008a985c7380f0b43f10024b59c35438\"\n                \"80883c42d0e7e0a07326ba3a\",\n                16,\n            ),\n            \"z\": binascii.unhexlify(\n                b\"10a30bacab82e652415376baffdbc008c7eb2e5a3aa68bc10ce486ca8498\"\n                b\"3fd89b1b027bb40e75333406361005f5e756526a95fe01202df9217d81b1\"\n                b\"713d5187c368fdd4c9c2433d9e6c18844769479b725c4140c92a304ee1bc\"\n                b\"5726d8f5321b5b1c54a1a6b67c527e6817c0ed613a0d4e60db55de898788\"\n                b\"b7e8d4aa9a81ab5ed7f6282962c433d246ed640555bdd76d29c287455126\"\n                b\"4d74c76373f8a88871b41b041c98041b16f94f983ddf00f5bc7d2416d191\"\n                b\"68c90178974a0602436cd186748bcc63a629edc3a0db59415cccd37a6513\"\n                b\"0ea477c89da92d41371f5972891cf41f9c7f0e75ccbff9893225384db30d\"\n                b\"aa5e310f08e3e0fad98bcdf8ecf35fe5\"\n            ),\n        },\n        {\n            \"fail_agree\": False,\n            \"fail_z\": False,\n            \"g\": int(\n                \"35513ec441402b78353ab1bba550b21c76c89973885a627170262ef5\"\n                \"2497d5d137b8927a212aaab2f051198c90bb81dffd9eb10b36b7ca3b\"\n                \"63565b4c1025aea3b5e9c4a348c9cfa17f3907a1e4469701c0dedb8a\"\n                \"4b9e96c5965b1fb8c229b0c34baac774bf9dda4fc5ee8764358b3c84\"\n                \"812878aab7464bc09e97aecab7d7e3fbb4870e2a3b89667a4158bf1e\"\n                \"d1a90dfaf47019fbb52b1b96365bb4e1e9474993fe382fd23480dc87\"\n                \"5861be152997a621fdb7aef977ea5b4d3d74486b162dc28f95a64cf6\"\n                \"5587a919a57eef92934fc9410df7f09fa82f975328ed82ff29cc3e15\"\n                \"a971f56f4ac2dcb289252575e02a6cdb7fcc6cddd7b0dca9c422e63e\"\n                \"b2b8f05\",\n                16,\n            ),\n            \"p\": int(\n                \"f3722b9b911c6aede9eaeeaa406283de66a097f39a7225df6c3c916e\"\n                \"57920d356e50478d307dbfd146bfb91b6f68ecbbcf54b3d19c33a4b1\"\n                \"7293fea3e3d6bff8ac4cca93a805386f062a8a27ae906ef5da94d279\"\n                \"fd7b3d7289e00956f76bae9c0d2b8d11742ca5809630632aae58f9c6\"\n                \"dce00c7380581deffde2187b022f83c6ceaeaadb0844a17fcbb04039\"\n                \"ca6843c91f0c9058b22434b263c3dfda8de8429e087c5be97fc5c9db\"\n                \"9526031ad3a218bd9916fb4a3c27966d208b1e360014c01e95530c14\"\n                \"8fb3cd27e6a7250d3c3b81dcd220ca14548dbccf99ebb9e334db6bcd\"\n                \"14e632c98dd3f9860af7ae450f1b7809b45f0ec10e6f27672beebc99\"\n                \"63befc73\",\n                16,\n            ),\n            \"q\": int(\n                \"a9a17de95a29091bf8e07dab53ea1aba9403be3c61027c6c8f48bac5\", 16\n            ),\n            \"x1\": int(\n                \"9ee22ac51664e40e0a24dbb94142dba40605e2b6eeaaa0268a0f6847\", 16\n            ),\n            \"x2\": int(\n                \"438093a468236658821bf64eb08456139963d4fb27121c3ed6c55876\", 16\n            ),\n            \"y1\": int(\n                \"c2630c9d38ed5c825d1c6a3eba7143f3fc8a049c8bcd1efc212d2af64eca9\"\n                \"94308208691d330aa8f27fc4a1e55de4e512113996d21375a667f8c26d76d\"\n                \"ee2f6809b15432a33fb735aca5c2263940f58712bded08f55443dee300b94\"\n                \"89589e0462bd6bce19deaec4adc12fa61a694c8c5c999b28211d7835bac0f\"\n                \"fd2b316850823e2dc1d1f58e05cbf75c673036d116b3f03b9687c89f9c2a0\"\n                \"d43c4ffc9a605addbdcce0cb3790c6db846156bb857a7b3df40dc6ed04d19\"\n                \"cc9eaebb6bbc034e77c3d882a1a62317cce25b6130f0803e3bc49b5e36768\"\n                \"260073a617034872be0b50bed32740224beaf582d67fbcfef3b3ecc18f9c7\"\n                \"1c782e9a68495ef31dc7986e\",\n                16,\n            ),\n            \"y2\": int(\n                \"e192da8e1244e27221c1765344a5bb379dce741d427a734b4bdb6c4d16b24\"\n                \"90bd37564d745008e63ae46ef332331d79887ac63298ce143e125f8b320c0\"\n                \"f859b7f5f2c1e0053e4a7a16997e6143ff702300c9863ae7caef5c1dfca0e\"\n                \"cf5197c557745b793f0790a4fe678aeb93fdb52490d4f273a5553944dda3a\"\n                \"c8b9b792c9b67f8d7b9496398e432a423ae87ebeba688be3ed67eddd7575f\"\n                \"a56431cd48579bf53c903bbe066dd78b23c0996ef3a880f0d91315104366a\"\n                \"82f01abdecce96fd371f94e8420f8bc5b896c801df573554f749b03d0d28b\"\n                \"1e1a990bc61c7e9659342ac7e268e9c0b7c40fdaab394f29cf0a54f780022\"\n                \"f9a03b0bd28eb7db8b0b1b47\",\n                16,\n            ),\n            \"z\": binascii.unhexlify(\n                b\"56f8f40fa4b8f3580f9014b30d60a42933a53a62182a690142f458dc275c\"\n                b\"3b2f0e721bc5ee6e890b14516419110f5252ff1cceea8e274b2987aa78e3\"\n                b\"bae90c1935b276b7a1f1c944f79d4774b7a85b3355bdf25cb02bddfbda4e\"\n                b\"e7918bc93a5c9ca6d7e8fdedbda8e6c8a6ca794bad055a52b19c14895822\"\n                b\"7344cbddd70271d4610316cfea1e559b0bc3a12d15023b30d9f2db602053\"\n                b\"a0569c3bd2ce1faf59280ecd339f845dbcaaf2e883c5cc6263996f866b18\"\n                b\"b75d049d4c82097af8a5ce353e14416b3eeb31ba9bc4f6f3dbd846c5299f\"\n                b\"b5c0043a1b95b9149b39d14df9e6a69547abf8a4d518475576730ed52877\"\n                b\"9366568e46b7dd4ed787cb72d0733c93\"\n            ),\n        },\n    ]\n\n    assert expected == load_kasvs_dh_vectors(vector_data)\n\n\ndef test_load_kasvs_ecdh_vectors_empty_vector_data():\n    assert [] == load_kasvs_ecdh_vectors([])\n\n\ndef test_load_kasvs_ecdh_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.0\n    #  Parameter set(s) supported: EA EB EC ED EE\n    #  CAVSid: CAVSid (in hex: 434156536964)\n    #  IUTid: In hex: a1b2c3d4e5\n    [EA]\n\n    [Curve selected:  P-192]\n    [SHA(s) supported (Used for hashing Z):  SHA1]\n    [EB]\n\n    [Curve selected:  P-224]\n    [SHA(s) supported (Used for hashing Z):  SHA224]\n    [EC]\n\n    [Curve selected:  P-256]\n    [SHA(s) supported (Used for hashing Z):  SHA256]\n    [ED]\n\n    [Curve selected:  P-384]\n    [SHA(s) supported (Used for hashing Z):  SHA384]\n    [EE]\n\n    [Curve selected:  P-521]\n    [SHA(s) supported (Used for hashing Z):  SHA512]\n    #  Generated on Thu Mar 17 19:46:10 2011\n\n\n\n    [EA - SHA1]\n\n\n    COUNT = 0\n    dsCAVS = f70c297a683d6b7ef82b5af7349606c4447c8b4fc6fa5e80\n    QsCAVSx = f7b5061fb557e516c50abf541d97dbfd76ca7172b22cf590\n    QsCAVSy = 135e15e21f9e85c76205fd148a92ac19f9e6243ddab322d1\n    dsIUT = a5b4bbad57f101ca48021cb7440cd681a9d40cd51b99d917\n    QsIUTx = 79a77fcb18a32cdb59ed5d87740f29e8565d649dbf01ce86\n    QsIUTy = f7187efaa0b1573f1fb00905d46810b880bf738b4c720bb7\n    Z = 26382468d721761e14a87dc3bee67340095c6455962d1ba3\n    CAVSHashZZ = af52ba700d3bbba7ce2916d6b729422c26c32364\n    Result = P (0 - Correct)\n\n\n\n    COUNT = 2\n    dsCAVS = 5f909dcb0ccce58c82fada748c47297579e6a981b5518a96\n    QsCAVSx = 537f1ecfda0e366de393a9bc8188fcc280311bffefe21ecf\n    QsCAVSy = a1fa1f98498d65f2754caff4e5303a4066a5ff89fde95381\n    dsIUT = 3357aa7f47f3e09421602cc12cdce4434c68e330d44de05e\n    QsIUTx = 6a33d43d9c72173eabc7a771a5687748c4774c62762e96ec\n    QsIUTy = 8033f238b3abc69470aad4be8dbe4f60a2fd50207626c56a\n    Z = 3153034f6617326f19c35be8c99a0585431adf09d2f8e0fd\n    CAVSHashZZ = f8414e30c2d382e28d2a57a2447fdc203baa416b\n    Result = F (8 - Z changed )\n\n\n\n    COUNT = 8\n    dsCAVS = 8fcfaf0524cc868fad20e50410a2205319f1327308d98dc8\n    QsCAVSx = 9b0243d80a9e328738080fb4d46bc450243d0efb7ead0c92\n    QsCAVSy = ad5bebad7f03849693071537f60ef858cad214123beee7c7\n    dsIUT = bba95dac90289cb68ca2b006f9757219b70579c299ad7a7d\n    QsIUTx = 7733dc0cb365cd6312724196b9b4eb491fd4d2e31b9afdb1\n    QsIUTy = 92ffa3722acc5b94d772258ba2d471b06c0f53f56fcd8662\n    Z = 0f3c6e4a29a08296ae730f56a1ebf819ea2edfa6f0434e40\n    CAVSHashZZ = c124545eed4b83a799e7e90371d806b5684a1bd2\n    Result = P (13 - Z value should have leading 0 nibble )\n\n\n    [EB - SHA224]\n\n\n    COUNT = 0\n    dsCAVS = e53a88af7cf8ce6bf13c8b9ad191494e37a6acc1368c71f4306e39e5\n    QsCAVSx = 3a24217c4b957fea922eec9d9ac52d5cb4b3fcd95efde1e4fa0dd6e2\n    QsCAVSy = 775b94025a808eb6f4af14ea4b57dca576c35373c6dc198b15b981df\n    dsIUT = 09f51e302c6a0fe6ff48f34c208c6af91e70f65f88102e6fcab9af4a\n    QsIUTx = c5d5706ccd7424c74fd616e699865af96e56f39adea6aa059e5092b5\n    QsIUTy = f0729077bb602404d56d2f7e2ba5bb2f383df4a5425567881ff0165d\n    Z = b1259ceedfb663d9515089cf727e7024fb3d86cbcec611b4ba0b4ab6\n    CAVSHashZZ = 8b21fd05a4b50e401908cd8f26757f5c57f22b69f170aa7381f8596d\n    Result = P (0 - Correct)\n\n\n\n    [EC - SHA256]\n\n\n    COUNT = 0\n    dsCAVS = 305dfb4a8850cc59280891147baf457bfe5e2bae984571634a77dc8d3472fa9b\n    QsCAVSx = 202cb5a224e6c2a84e624094486edf04116c8d68ec1f4a0e0ed9ee090e1a900b\n    QsCAVSy = cacf3a5789bb33954be600425d62d9eae5371f90f88167258814213e4a4f4b1a\n    dsIUT = 72cc52808f294b64b6f7233c3d2f5d96cc1d29287320e39e1c151deef0bc14eb\n    QsIUTx = 49a768c9a4ca56e374f685dd76a461b1016c59dcded2c8d8cbd9f23ca453831f\n    QsIUTy = b1e3bb9b5f12a3b5ae788535d4554bd8c46e0e6130075e4e437d3854cf8f1c34\n    Z = c0147c3c2691b450b5edc08b51aea224d9f4359ff67aab6da3146f396dbceaea\n    CAVSHashZZ = ea9ffd54511979ab8c4b387784972cbd05fc5fd4ff78e048b0026557b56a5\\\n1dd\n    Result = F (2 - CAVS's Static public key Y fails PKV 5.6.2.5)\n\n\n\n    [ED - SHA384]\n\n\n    COUNT = 0\n    dsCAVS = 0e5c98ff2d2a3aab14ad0067b60dbe64e4f541ab5bed11c5a0c55ae1e60b51ff5\\\nfaaf377837977d80cbfdc33c2ff542b\n    QsCAVSx = d1bf2ac21637d66d6398aac01dcd56ac6f065fb45d1f6f16747bab9e9b01b463\\\n0b59b20927aea147355bf41838acb482\n    QsCAVSy = 4c9e23f1c5a41647d094086bf4ed31708651f21d996c47780688ac10f77deee2\\\ne43b5241b6caecd2fd5444bc50472e0e\n    dsIUT = f865418473e5bf7d2e1bbcd9bd5a9270c003a9dd35e778133ca59fcab4bb64fe24\\\nd6800e7047bdd033abc8bfa8db35b5\n    QsIUTx = 32b72ab9b558249dcbc6cbade234f58e4f7aa5d3f6420ea99a5f997e8c2a91fb7\\\nfd83779d0d2169428683771c745fd1a\n    QsIUTy = c749e02a3719bb56bf1dfc4ba3820309c01ab6e84cb29db7cdd80f127233f5295\\\n687f8178f3a8704c1063b84c2ee472f\n    Z = a781430e6078a179df3f9ee27cd8fdc6188f161b6c4ccc4053ef6c6ca6fc222946883a\\\n53c06db08f0a020023ced055aa\n    CAVSHashZZ = ccb70d0adbabe4d8956519db0d536605cbb366aed58fc55718f56ae3648fa\\\n5c9ee7bae56cc463587cb74e2f9c6ace1cb\n    Result = P (0 - Correct)\n\n\n\n    [EE - SHA512]\n\n\n    COUNT = 0\n    dsCAVS = 0000002fef62381162942889a6094a6bb9ac1f4ddf66d9cda9f618232d31b90c5\\\n0d7da78a47ed91d40cae946898571db972dc294b109815f38feee9eaac0d5f7c3250728\n    QsCAVSx = 0000004b05ffa025113390797f2736174aa1c784f4dd34e764ee40d40e4d2442\\\n677ebea3498086c9473e5c92789cbdb02bb327bbd61d58690f6a83d9ca73bccbde37dec4\n    QsCAVSy = 0000004da67cffc98070b82af61feba78787efefb13bd810d80ff92304788e49\\\na4e5b634b3565474a8ecb1615d7b1b77a7a27875adb73a8a5d8f3f84e5e8b744cda250b0\n    dsIUT = 00000311a5e520e238141527671a38cb6f776d96a9f82ef70dffa11dc0895f4060\\\nf1abbb9ad6fd259e4a7beaf5f7266ea1bb45bcbfebfda2705e5c551e710fb1d745f57e\n    QsIUTx = 0000010ba3778cb2cc965834c0a9593adc6a222692656d657fb0d15293edf0ab3\\\n3762384a96a16fddea7540b7ccbcca46ec4ac9bcf95fdb5aa18e158aab4d91981bd733e\n    QsIUTy = 0000018522df93ddd636e5bc94daecdc600fa241686ec18634fd30b7cbdfdc9ff\\\nba1166ac08df34a31896f6fad191414929261ebd7187afb72919f8a0c926be37f99c1e5\n    Z = 01a5e4b31be4b1346e53906b6767b1fe94ec1a8a5abc28fb6f01518c056959af3bc933\\\n5dddab178b52318cc5512559931b8dc18de0ce810c2c7f15769d7ce70e719c\n    CAVSHashZZ = d2d6538feb65d609f377b81a027dc800eed07b69c0e9eedb243369202ed47\\\nf47021022a6c9b45ed791d09d9540eb81ea065fc1959eca365001ee39928c343d75\n    Result = F (7 - IUT's Static private key d changed-prikey validity)\n\n\n\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"errno\": 0,\n            \"fail\": False,\n            \"COUNT\": 0,\n            \"CAVS\": {\n                \"d\": int(\n                    \"f70c297a683d6b7ef82b5af7349606c4447c8b4fc6fa5e80\", 16\n                ),\n                \"x\": int(\n                    \"f7b5061fb557e516c50abf541d97dbfd76ca7172b22cf590\", 16\n                ),\n                \"y\": int(\n                    \"135e15e21f9e85c76205fd148a92ac19f9e6243ddab322d1\", 16\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"a5b4bbad57f101ca48021cb7440cd681a9d40cd51b99d917\", 16\n                ),\n                \"x\": int(\n                    \"79a77fcb18a32cdb59ed5d87740f29e8565d649dbf01ce86\", 16\n                ),\n                \"y\": int(\n                    \"f7187efaa0b1573f1fb00905d46810b880bf738b4c720bb7\", 16\n                ),\n            },\n            \"Z\": int(\"26382468d721761e14a87dc3bee67340095c6455962d1ba3\", 16),\n            \"curve\": \"secp192r1\",\n        },\n        {\n            \"errno\": 8,\n            \"fail\": True,\n            \"COUNT\": 2,\n            \"CAVS\": {\n                \"d\": int(\n                    \"5f909dcb0ccce58c82fada748c47297579e6a981b5518a96\", 16\n                ),\n                \"x\": int(\n                    \"537f1ecfda0e366de393a9bc8188fcc280311bffefe21ecf\", 16\n                ),\n                \"y\": int(\n                    \"a1fa1f98498d65f2754caff4e5303a4066a5ff89fde95381\", 16\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"3357aa7f47f3e09421602cc12cdce4434c68e330d44de05e\", 16\n                ),\n                \"x\": int(\n                    \"6a33d43d9c72173eabc7a771a5687748c4774c62762e96ec\", 16\n                ),\n                \"y\": int(\n                    \"8033f238b3abc69470aad4be8dbe4f60a2fd50207626c56a\", 16\n                ),\n            },\n            \"Z\": int(\"3153034f6617326f19c35be8c99a0585431adf09d2f8e0fd\", 16),\n            \"curve\": \"secp192r1\",\n        },\n        {\n            \"errno\": 13,\n            \"fail\": False,\n            \"COUNT\": 8,\n            \"CAVS\": {\n                \"d\": int(\n                    \"8fcfaf0524cc868fad20e50410a2205319f1327308d98dc8\", 16\n                ),\n                \"x\": int(\n                    \"9b0243d80a9e328738080fb4d46bc450243d0efb7ead0c92\", 16\n                ),\n                \"y\": int(\n                    \"ad5bebad7f03849693071537f60ef858cad214123beee7c7\", 16\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"bba95dac90289cb68ca2b006f9757219b70579c299ad7a7d\", 16\n                ),\n                \"x\": int(\n                    \"7733dc0cb365cd6312724196b9b4eb491fd4d2e31b9afdb1\", 16\n                ),\n                \"y\": int(\n                    \"92ffa3722acc5b94d772258ba2d471b06c0f53f56fcd8662\", 16\n                ),\n            },\n            \"Z\": int(\"0f3c6e4a29a08296ae730f56a1ebf819ea2edfa6f0434e40\", 16),\n            \"curve\": \"secp192r1\",\n        },\n        {\n            \"errno\": 0,\n            \"fail\": False,\n            \"COUNT\": 0,\n            \"CAVS\": {\n                \"d\": int(\n                    \"e53a88af7cf8ce6bf13c8b9ad191494e37a6acc1368c71f4\"\n                    \"306e39e5\",\n                    16,\n                ),\n                \"x\": int(\n                    \"3a24217c4b957fea922eec9d9ac52d5cb4b3fcd95efde1e4\"\n                    \"fa0dd6e2\",\n                    16,\n                ),\n                \"y\": int(\n                    \"775b94025a808eb6f4af14ea4b57dca576c35373c6dc198b\"\n                    \"15b981df\",\n                    16,\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"09f51e302c6a0fe6ff48f34c208c6af91e70f65f88102e6f\"\n                    \"cab9af4a\",\n                    16,\n                ),\n                \"x\": int(\n                    \"c5d5706ccd7424c74fd616e699865af96e56f39adea6aa05\"\n                    \"9e5092b5\",\n                    16,\n                ),\n                \"y\": int(\n                    \"f0729077bb602404d56d2f7e2ba5bb2f383df4a542556788\"\n                    \"1ff0165d\",\n                    16,\n                ),\n            },\n            \"Z\": int(\n                \"b1259ceedfb663d9515089cf727e7024fb3d86cbcec611b4ba0b4ab6\",\n                16,\n            ),\n            \"curve\": \"secp224r1\",\n        },\n        {\n            \"errno\": 2,\n            \"fail\": True,\n            \"COUNT\": 0,\n            \"CAVS\": {\n                \"d\": int(\n                    \"305dfb4a8850cc59280891147baf457bfe5e2bae98457163\"\n                    \"4a77dc8d3472fa9b\",\n                    16,\n                ),\n                \"x\": int(\n                    \"202cb5a224e6c2a84e624094486edf04116c8d68ec1f4a0e\"\n                    \"0ed9ee090e1a900b\",\n                    16,\n                ),\n                \"y\": int(\n                    \"cacf3a5789bb33954be600425d62d9eae5371f90f8816725\"\n                    \"8814213e4a4f4b1a\",\n                    16,\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"72cc52808f294b64b6f7233c3d2f5d96cc1d29287320e39e\"\n                    \"1c151deef0bc14eb\",\n                    16,\n                ),\n                \"x\": int(\n                    \"49a768c9a4ca56e374f685dd76a461b1016c59dcded2c8d8\"\n                    \"cbd9f23ca453831f\",\n                    16,\n                ),\n                \"y\": int(\n                    \"b1e3bb9b5f12a3b5ae788535d4554bd8c46e0e6130075e4e\"\n                    \"437d3854cf8f1c34\",\n                    16,\n                ),\n            },\n            \"Z\": int(\n                \"c0147c3c2691b450b5edc08b51aea224d9f4359ff67aab6d\"\n                \"a3146f396dbceaea\",\n                16,\n            ),\n            \"curve\": \"secp256r1\",\n        },\n        {\n            \"errno\": 0,\n            \"fail\": False,\n            \"COUNT\": 0,\n            \"CAVS\": {\n                \"d\": int(\n                    \"0e5c98ff2d2a3aab14ad0067b60dbe64e4f541ab5bed11c5\"\n                    \"a0c55ae1e60b51ff5faaf377837977d80cbfdc33c2ff542b\",\n                    16,\n                ),\n                \"x\": int(\n                    \"d1bf2ac21637d66d6398aac01dcd56ac6f065fb45d1f6f16\"\n                    \"747bab9e9b01b4630b59b20927aea147355bf41838acb482\",\n                    16,\n                ),\n                \"y\": int(\n                    \"4c9e23f1c5a41647d094086bf4ed31708651f21d996c4778\"\n                    \"0688ac10f77deee2e43b5241b6caecd2fd5444bc50472e0e\",\n                    16,\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"f865418473e5bf7d2e1bbcd9bd5a9270c003a9dd35e77813\"\n                    \"3ca59fcab4bb64fe24d6800e7047bdd033abc8bfa8db35b5\",\n                    16,\n                ),\n                \"x\": int(\n                    \"32b72ab9b558249dcbc6cbade234f58e4f7aa5d3f6420ea9\"\n                    \"9a5f997e8c2a91fb7fd83779d0d2169428683771c745fd1a\",\n                    16,\n                ),\n                \"y\": int(\n                    \"c749e02a3719bb56bf1dfc4ba3820309c01ab6e84cb29db7\"\n                    \"cdd80f127233f5295687f8178f3a8704c1063b84c2ee472f\",\n                    16,\n                ),\n            },\n            \"Z\": int(\n                \"a781430e6078a179df3f9ee27cd8fdc6188f161b6c4ccc40\"\n                \"53ef6c6ca6fc222946883a53c06db08f0a020023ced055aa\",\n                16,\n            ),\n            \"curve\": \"secp384r1\",\n        },\n        {\n            \"errno\": 7,\n            \"fail\": True,\n            \"COUNT\": 0,\n            \"CAVS\": {\n                \"d\": int(\n                    \"0000002fef62381162942889a6094a6bb9ac1f4ddf66d9cd\"\n                    \"a9f618232d31b90c50d7da78a47ed91d40cae946898571db\"\n                    \"972dc294b109815f38feee9eaac0d5f7c3250728\",\n                    16,\n                ),\n                \"x\": int(\n                    \"0000004b05ffa025113390797f2736174aa1c784f4dd34e7\"\n                    \"64ee40d40e4d2442677ebea3498086c9473e5c92789cbdb0\"\n                    \"2bb327bbd61d58690f6a83d9ca73bccbde37dec4\",\n                    16,\n                ),\n                \"y\": int(\n                    \"0000004da67cffc98070b82af61feba78787efefb13bd810\"\n                    \"d80ff92304788e49a4e5b634b3565474a8ecb1615d7b1b77\"\n                    \"a7a27875adb73a8a5d8f3f84e5e8b744cda250b0\",\n                    16,\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"00000311a5e520e238141527671a38cb6f776d96a9f82ef7\"\n                    \"0dffa11dc0895f4060f1abbb9ad6fd259e4a7beaf5f7266e\"\n                    \"a1bb45bcbfebfda2705e5c551e710fb1d745f57e\",\n                    16,\n                ),\n                \"x\": int(\n                    \"0000010ba3778cb2cc965834c0a9593adc6a222692656d65\"\n                    \"7fb0d15293edf0ab33762384a96a16fddea7540b7ccbcca4\"\n                    \"6ec4ac9bcf95fdb5aa18e158aab4d91981bd733e\",\n                    16,\n                ),\n                \"y\": int(\n                    \"0000018522df93ddd636e5bc94daecdc600fa241686ec186\"\n                    \"34fd30b7cbdfdc9ffba1166ac08df34a31896f6fad191414\"\n                    \"929261ebd7187afb72919f8a0c926be37f99c1e5\",\n                    16,\n                ),\n            },\n            \"Z\": int(\n                \"01a5e4b31be4b1346e53906b6767b1fe94ec1a8a5abc28fb\"\n                \"6f01518c056959af3bc9335dddab178b52318cc551255993\"\n                \"1b8dc18de0ce810c2c7f15769d7ce70e719c\",\n                16,\n            ),\n            \"curve\": \"secp521r1\",\n        },\n    ]\n\n    assert expected == load_kasvs_ecdh_vectors(vector_data)\n\n\ndef test_load_kasvs_ecdh_kdf_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  Parameter set(s) supported: EB EC ED EE\n    #  CAVSid: CAVSid (in hex: 434156536964)\n    #  IUTid: In hex: a1b2c3d4e5\n    [EB]\n\n    [Curve selected:  P-224]\n    [SHA(s) supported (Used in the KDF function):  SHA224 SHA256 SHA384 SHA512]\n    [MAC algorithm supported:  HMAC]\n    [HMAC SHAs supported:  SHA512]\n    [HMACKeySize(in bits):  112]\n    [HMAC Tag length(in bits):  64]\n\n    #  Generated on Mon Dec 22 11:45:18 2014\n\n\n\n    [EB - SHA224]\n\n\n    COUNT = 50\n    dsCAVS = 540904b67b3716823dd621ed72ad3dbc615887b4f56f910b78a57199\n    QsCAVSx = 28e5f3a72d8f6b8499dd1bcdfceafcecec68a0d715789bcf4b55fe15\n    QsCAVSy = 8c8006a7da7c1a19f5328d7e865522b0c0dfb9a29b2c46dc96590d2a\n    Nonce = 4eefb2a29a0e89c3898a7affdfa60dd7\n    dsIUT = 5e717ae889fc8d67be11c2ebe1a7d3550051448d68a040b2dee8e327\n    QsIUTx = ae7f3db340b647d61713f5374c019f1be2b28573cb6219bb7b747223\n    QsIUTy = 800e6bffcf97c15864ec6e5673fb83359b45f89b8a26a27f6f3dfbff\n    NonceDKMIUT = bb7f1b40d14ebd70443393990b57\n    OI = a1b2c3d4e5bb7f1b40d14ebd70443393990b574341565369645b1582daab9cc6c30d6\\\n1fdcf1cdfc7e9a304651e0fdb\n    CAVSTag = 84de198c3a958c62\n    Z = 43f23b2c760d686fc99cc008b63aea92f866e224265af60d2d8ae540\n    MacData = 5374616e646172642054657374204d6573736167654eefb2a29a0e89c3898a7a\\\nffdfa60dd7\n    DKM = ad65fa2d12541c3a21f3cd223efb\n    Result = F (12 - Tag changed )\n    \"\"\"\n    ).splitlines()\n\n    expected = [\n        {\n            \"errno\": 12,\n            \"fail\": True,\n            \"COUNT\": 50,\n            \"CAVS\": {\n                \"d\": int(\n                    \"540904b67b3716823dd621ed72ad3dbc615887b4f56f910b\"\n                    \"78a57199\",\n                    16,\n                ),\n                \"x\": int(\n                    \"28e5f3a72d8f6b8499dd1bcdfceafcecec68a0d715789bcf\"\n                    \"4b55fe15\",\n                    16,\n                ),\n                \"y\": int(\n                    \"8c8006a7da7c1a19f5328d7e865522b0c0dfb9a29b2c46dc\"\n                    \"96590d2a\",\n                    16,\n                ),\n            },\n            \"IUT\": {\n                \"d\": int(\n                    \"5e717ae889fc8d67be11c2ebe1a7d3550051448d68a040b2\"\n                    \"dee8e327\",\n                    16,\n                ),\n                \"x\": int(\n                    \"ae7f3db340b647d61713f5374c019f1be2b28573cb6219bb\"\n                    \"7b747223\",\n                    16,\n                ),\n                \"y\": int(\n                    \"800e6bffcf97c15864ec6e5673fb83359b45f89b8a26a27f\"\n                    \"6f3dfbff\",\n                    16,\n                ),\n            },\n            \"OI\": int(\n                \"a1b2c3d4e5bb7f1b40d14ebd70443393990b574341565369\"\n                \"645b1582daab9cc6c30d61fdcf1cdfc7e9a304651e0fdb\",\n                16,\n            ),\n            \"Z\": int(\n                \"43f23b2c760d686fc99cc008b63aea92f866e224265af60d2d8ae540\",\n                16,\n            ),\n            \"DKM\": int(\"ad65fa2d12541c3a21f3cd223efb\", 16),\n            \"curve\": \"secp224r1\",\n        }\n    ]\n\n    assert expected == load_kasvs_ecdh_vectors(vector_data)\n\n\ndef test_load_x963_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 12.0\n    # 'ANS X9.63-2001' information for sample\n\n    [SHA-1]\n    [shared secret length = 192]\n    [SharedInfo length = 0]\n    [key data length = 128]\n\n    COUNT = 0\n    Z = 1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd\n    SharedInfo =\n        Counter = 00000001\n        Hash input 1 = 1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd00000001\n        K1 = bf71dffd8f4d99223936beb46fee8ccc60439b7e\n    key_data = bf71dffd8f4d99223936beb46fee8ccc\n\n    COUNT = 1\n    Z = 5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab1\n    SharedInfo =\n        Counter = 00000001\n        Hash input 1 = 5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab100000001\n        K1 = ec3e224446bfd7b3be1df404104af953c1b2d0f5\n    key_data = ec3e224446bfd7b3be1df404104af953\n\n    [SHA-512]\n    [shared secret length = 521]\n    [SharedInfo length = 128]\n    [key data length = 1024]\n\n    COUNT = 0\n    Z = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9adb369348b8150739\\\n2f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d\n    SharedInfo = e3b5b4c1b0d5cf1d2b3a2f9937895d31\n        Counter = 00000001\n        Hash input 1 = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9ad\\\nb369348b81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d0\\\n0000001e3b5b4c1b0d5cf1d2b3a2f9937895d31\n        K1 = 4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7fa733633d6\\\ne4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee20800226\n        Counter = 00000002\n        Hash input 2 = 00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9ad\\\nb369348b81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e753f55ef05a2d0\\\n0000002e3b5b4c1b0d5cf1d2b3a2f9937895d31\n        K2 = 7089dbf351f3f5022aa9638bf1ee419dea9c4ff745a25ac27bda33ca08bd56dd1\\\na59b4106cf2dbbc0ab2aa8e2efa7b17902d34276951ceccab87f9661c3e8816\n    key_data = 4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7fa733633\\\nd6e4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee208002267089dbf351f3f\\\n5022aa9638bf1ee419dea9c4ff745a25ac27bda33ca08bd56dd1a59b4106cf2dbbc0ab2aa8e2ef\\\na7b17902d34276951ceccab87f9661c3e8816\n    \"\"\"\n    ).splitlines()\n\n    assert load_x963_vectors(vector_data) == [\n        {\n            \"hash\": \"SHA-1\",\n            \"count\": 0,\n            \"shared_secret_length\": 192,\n            \"Z\": \"1c7d7b5f0597b03d06a018466ed1a93e30ed4b04dc64ccdd\",\n            \"sharedinfo_length\": 0,\n            \"key_data_length\": 128,\n            \"key_data\": \"bf71dffd8f4d99223936beb46fee8ccc\",\n        },\n        {\n            \"hash\": \"SHA-1\",\n            \"count\": 1,\n            \"shared_secret_length\": 192,\n            \"Z\": \"5ed096510e3fcf782ceea98e9737993e2b21370f6cda2ab1\",\n            \"sharedinfo_length\": 0,\n            \"key_data_length\": 128,\n            \"key_data\": \"ec3e224446bfd7b3be1df404104af953\",\n        },\n        {\n            \"hash\": \"SHA-512\",\n            \"count\": 0,\n            \"shared_secret_length\": 521,\n            \"Z\": (\n                \"00aa5bb79b33e389fa58ceadc047197f14e73712f452caa9fc4c9adb3693\"\n                \"48b81507392f1a86ddfdb7c4ff8231c4bd0f44e44a1b55b1404747a9e2e7\"\n                \"53f55ef05a2d\"\n            ),\n            \"sharedinfo_length\": 128,\n            \"sharedinfo\": \"e3b5b4c1b0d5cf1d2b3a2f9937895d31\",\n            \"key_data_length\": 1024,\n            \"key_data\": (\n                \"4463f869f3cc18769b52264b0112b5858f7ad32a5a2d96d8cffabf7fa733\"\n                \"633d6e4dd2a599acceb3ea54a6217ce0b50eef4f6b40a5c30250a5a8eeee\"\n                \"208002267089dbf351f3f5022aa9638bf1ee419dea9c4ff745a25ac27bda\"\n                \"33ca08bd56dd1a59b4106cf2dbbc0ab2aa8e2efa7b17902d34276951cecc\"\n                \"ab87f9661c3e8816\"\n            ),\n        },\n    ]\n\n\ndef test_load_kbkdf_vectors():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    # CAVS 14.4\n    # \"SP800-108 - KDF\" information for \"test1\"\n    # KDF Mode Supported: Counter Mode\n    # Location of counter tested: (Before Fixed Input Data)\\\n( After Fixed Input Data)(In Middle of Fixed Input Data before Context)\n    # PRFs tested: CMAC with key sizes:\tAES128  AES192  AES256  TDES2  TDES3\\\nHMAC with key sizes:\tSHA1  SHA224  SHA256  SHA384  SHA512\n    # Generated on Tue Apr 23 12:20:16 2013\n\n    [PRF=HMAC_SHA1]\n    [CTRLOCATION=BEFORE_FIXED]\n    [RLEN=8_BITS]\n\n    COUNT=0\n    L = 128\n    KI = 00a39bd547fb88b2d98727cf64c195c61e1cad6c\n    FixedInputDataByteLen = 60\n    FixedInputData = 98132c1ffaf59ae5cbc0a3133d84c551bb97e0c75ecaddfc30056f68\\\n76f59803009bffc7d75c4ed46f40b8f80426750d15bc1ddb14ac5dcb69a68242\n        Binary rep of i = 01\n        instring = 0198132c1ffaf59ae5cbc0a3133d84c551bb97e0c75ecaddfc30056f68\\\n76f59803009bffc7d75c4ed46f40b8f80426750d15bc1ddb14ac5dcb69a68242\n    KO = 0611e1903609b47ad7a5fc2c82e47702\n\n    COUNT=1\n    L = 128\n    KI = a39bdf744ed7e33fdec060c8736e9725179885a8\n    FixedInputDataByteLen = 60\n    FixedInputData = af71b44940acff98949ad17f1ca20e8fdb3957cacdcd41e9c591e182\\\n35019f90b9f8ee6e75700bcab2f8407525a104799b3e9725e27d738a9045e832\n        Binary rep of i = 01\n        instring = 01af71b44940acff98949ad17f1ca20e8fdb3957cacdcd41e9c591e182\\\n35019f90b9f8ee6e75700bcab2f8407525a104799b3e9725e27d738a9045e832\n    KO = 51dc4668947e3685099bc3b5f8527468\n\n    [PRF=HMAC_SHA224]\n    [CTRLOCATION=AFTER_FIXED]\n    [RLEN=8_BITS]\n\n    COUNT=0\n    L = 128\n    KI = ab56556b107a3a79fe084df0f1bb3ad049a6cc1490f20da4b3df282c\n    FixedInputDataByteLen = 60\n    FixedInputData = 7f50fc1f77c3ac752443154c1577d3c47b86fccffe82ff43aa1b91ee\\\nb5730d7e9e6aab78374d854aecb7143faba6b1eb90d3d9e7a2f6d78dd9a6c4a7\n        Binary rep of i = 01\n        instring = 7f50fc1f77c3ac752443154c1577d3c47b86fccffe82ff43aa1b91eeb5\\\n730d7e9e6aab78374d854aecb7143faba6b1eb90d3d9e7a2f6d78dd9a6c4a701\n    KO = b8894c6133a46701909b5c8a84322dec\n    \"\"\"\n    ).splitlines()\n\n    assert load_nist_kbkdf_vectors(vector_data) == [\n        {\n            \"prf\": \"hmac_sha1\",\n            \"ctrlocation\": \"before_fixed\",\n            \"rlen\": 8,\n            \"l\": 128,\n            \"ki\": b\"00a39bd547fb88b2d98727cf64c195c61e1cad6c\",\n            \"fixedinputdatabytelen\": b\"60\",\n            \"fixedinputdata\": (\n                b\"98132c1ffaf59ae5cbc0a3133d84c551bb97e0c75ecaddfc30056f6876f\"\n                b\"59803009bffc7d75c4ed46f40b8f80426750d15bc1ddb14ac5dcb69a682\"\n                b\"42\"\n            ),\n            \"binary rep of i\": b\"01\",\n            \"instring\": (\n                b\"0198132c1ffaf59ae5cbc0a3133d84c551bb97e0c75ecaddfc30056f687\"\n                b\"6f59803009bffc7d75c4ed46f40b8f80426750d15bc1ddb14ac5dcb69a6\"\n                b\"8242\"\n            ),\n            \"ko\": b\"0611e1903609b47ad7a5fc2c82e47702\",\n        },\n        {\n            \"prf\": \"hmac_sha1\",\n            \"ctrlocation\": \"before_fixed\",\n            \"rlen\": 8,\n            \"l\": 128,\n            \"ki\": b\"a39bdf744ed7e33fdec060c8736e9725179885a8\",\n            \"fixedinputdatabytelen\": b\"60\",\n            \"fixedinputdata\": (\n                b\"af71b44940acff98949ad17f1ca20e8fdb3957cacdcd41e9c591e182350\"\n                b\"19f90b9f8ee6e75700bcab2f8407525a104799b3e9725e27d738a9045e8\"\n                b\"32\"\n            ),\n            \"binary rep of i\": b\"01\",\n            \"instring\": (\n                b\"01af71b44940acff98949ad17f1ca20e8fdb3957cacdcd41e9c591e1823\"\n                b\"5019f90b9f8ee6e75700bcab2f8407525a104799b3e9725e27d738a9045\"\n                b\"e832\"\n            ),\n            \"ko\": b\"51dc4668947e3685099bc3b5f8527468\",\n        },\n        {\n            \"prf\": \"hmac_sha224\",\n            \"ctrlocation\": \"after_fixed\",\n            \"rlen\": 8,\n            \"l\": 128,\n            \"ki\": b\"ab56556b107a3a79fe084df0f1bb3ad049a6cc1490f20da4b3df282c\",\n            \"fixedinputdatabytelen\": b\"60\",\n            \"fixedinputdata\": (\n                b\"7f50fc1f77c3ac752443154c1577d3c47b86fccffe82ff43aa1b91eeb57\"\n                b\"30d7e9e6aab78374d854aecb7143faba6b1eb90d3d9e7a2f6d78dd9a6c4\"\n                b\"a7\"\n            ),\n            \"binary rep of i\": b\"01\",\n            \"instring\": (\n                b\"7f50fc1f77c3ac752443154c1577d3c47b86fccffe82ff43aa1b91eeb57\"\n                b\"30d7e9e6aab78374d854aecb7143faba6b1eb90d3d9e7a2f6d78dd9a6c4\"\n                b\"a701\"\n            ),\n            \"ko\": b\"b8894c6133a46701909b5c8a84322dec\",\n        },\n    ]\n\n\ndef test_load_nist_ccm_vectors_dvpt():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.0\n    #  \"CCM-DVPT\" information\n    #  AES Keylen: 128\n    #  Generated on Tue Mar 15 08:09:25 2011\n\n\n    [Alen = 0, Plen = 0, Nlen = 7, Tlen = 4]\n\n    Key = 4ae701103c63deca5b5a3939d7d05992\n\n    Count = 0\n    Nonce = 5a8aa485c316e9\n    Adata = 00\n    CT = 02209f55\n    Result = Pass\n    Payload = 00\n\n    Count = 1\n    Nonce = 3796cf51b87266\n    Adata = 00\n    CT = 9a04c241\n    Result = Fail\n\n    [Alen = 0, Plen = 0, Nlen = 7, Tlen = 16]\n\n    Key = 4bb3c4a4f893ad8c9bdc833c325d62b3\n\n    Count = 15\n    Nonce = 5a8aa485c316e9\n    Adata = 00\n    CT = 75d582db43ce9b13ab4b6f7f14341330\n    Result = Pass\n    Payload = 00\n\n    Count = 16\n    Nonce = 3796cf51b87266\n    Adata = 00\n    CT = 3a65e03af37b81d05acc7ec1bc39deb0\n    Result = Fail\n    \"\"\"\n    ).splitlines()\n    assert load_nist_ccm_vectors(vector_data) == [\n        {\n            \"key\": b\"4ae701103c63deca5b5a3939d7d05992\",\n            \"alen\": 0,\n            \"plen\": 0,\n            \"nlen\": 7,\n            \"tlen\": 4,\n            \"nonce\": b\"5a8aa485c316e9\",\n            \"adata\": b\"00\",\n            \"ct\": b\"02209f55\",\n            \"fail\": False,\n            \"payload\": b\"00\",\n        },\n        {\n            \"key\": b\"4ae701103c63deca5b5a3939d7d05992\",\n            \"alen\": 0,\n            \"plen\": 0,\n            \"nlen\": 7,\n            \"tlen\": 4,\n            \"nonce\": b\"3796cf51b87266\",\n            \"adata\": b\"00\",\n            \"ct\": b\"9a04c241\",\n            \"fail\": True,\n            \"payload\": b\"00\",\n        },\n        {\n            \"key\": b\"4bb3c4a4f893ad8c9bdc833c325d62b3\",\n            \"alen\": 0,\n            \"plen\": 0,\n            \"nlen\": 7,\n            \"tlen\": 16,\n            \"nonce\": b\"5a8aa485c316e9\",\n            \"adata\": b\"00\",\n            \"ct\": b\"75d582db43ce9b13ab4b6f7f14341330\",\n            \"fail\": False,\n            \"payload\": b\"00\",\n        },\n        {\n            \"key\": b\"4bb3c4a4f893ad8c9bdc833c325d62b3\",\n            \"alen\": 0,\n            \"plen\": 0,\n            \"nlen\": 7,\n            \"tlen\": 16,\n            \"nonce\": b\"3796cf51b87266\",\n            \"adata\": b\"00\",\n            \"ct\": b\"3a65e03af37b81d05acc7ec1bc39deb0\",\n            \"fail\": True,\n            \"payload\": b\"00\",\n        },\n    ]\n\n\ndef test_load_nist_ccm_vectors_vadt():\n    vector_data = textwrap.dedent(\n        \"\"\"\n    #  CAVS 11.0\n    #  \"CCM-VADT\" information\n    #  AES Keylen: 128\n    #  Generated on Tue Mar 15 08:09:24 2011\n\n    Plen = 24\n    Nlen = 13\n    Tlen = 16\n\n    [Alen = 0]\n\n    Key = d24a3d3dde8c84830280cb87abad0bb3\n    Nonce = f1100035bb24a8d26004e0e24b\n\n    Count = 0\n    Adata = 00\n    Payload = 7c86135ed9c2a515aaae0e9a208133897269220f30870006\n    CT = 1faeb0ee2ca2cd52f0aa3966578344f24e69b742c4ab37ab11233\n\n    Count = 1\n    Adata = 00\n    Payload = 48df73208cdc63d716752df7794807b1b2a80794a2433455\n    CT = 2bf7d09079bc0b904c711a0b0e4a70ca8ea892d9566f03f8b77a1\n    CT = 642145210f947bc4a0b1e678fd8c990c2c1d89d4110a95c954d61\n\n    [Alen = 1]\n\n    Key = 08b0da255d2083808a1b4d367090bacc\n    Nonce = 777828b13679a9e2ca89568233\n\n    Count = 10\n    Adata = dd\n    Payload = 1b156d7e2bf7c9a25ad91cff7b0b02161cb78ff9162286b0\n    CT = e8b80af4960d5417c15726406e345c5c46831192b03432eed16b6\n\n    Count = 11\n    Adata = c5\n    Payload = 032fee9dbffccc751e6a1ee6d07bb218b3a7ec6bf5740ead\n    CT = f0828917020651c085e42459c544ec52e99372005362baf308ebe\n    \"\"\"\n    ).splitlines()\n    assert load_nist_ccm_vectors(vector_data) == [\n        {\n            \"plen\": 24,\n            \"nlen\": 13,\n            \"tlen\": 16,\n            \"alen\": 0,\n            \"key\": b\"d24a3d3dde8c84830280cb87abad0bb3\",\n            \"nonce\": b\"f1100035bb24a8d26004e0e24b\",\n            \"adata\": b\"00\",\n            \"payload\": b\"7c86135ed9c2a515aaae0e9a208133897269220f30870006\",\n            \"ct\": b\"1faeb0ee2ca2cd52f0aa3966578344f24e69b742c4ab37ab11233\",\n        },\n        {\n            \"plen\": 24,\n            \"nlen\": 13,\n            \"tlen\": 16,\n            \"alen\": 0,\n            \"key\": b\"d24a3d3dde8c84830280cb87abad0bb3\",\n            \"nonce\": b\"f1100035bb24a8d26004e0e24b\",\n            \"adata\": b\"00\",\n            \"payload\": b\"48df73208cdc63d716752df7794807b1b2a80794a2433455\",\n            \"ct\": b\"642145210f947bc4a0b1e678fd8c990c2c1d89d4110a95c954d61\",\n        },\n        {\n            \"plen\": 24,\n            \"nlen\": 13,\n            \"tlen\": 16,\n            \"alen\": 1,\n            \"key\": b\"08b0da255d2083808a1b4d367090bacc\",\n            \"nonce\": b\"777828b13679a9e2ca89568233\",\n            \"adata\": b\"dd\",\n            \"payload\": b\"1b156d7e2bf7c9a25ad91cff7b0b02161cb78ff9162286b0\",\n            \"ct\": b\"e8b80af4960d5417c15726406e345c5c46831192b03432eed16b6\",\n        },\n        {\n            \"plen\": 24,\n            \"nlen\": 13,\n            \"tlen\": 16,\n            \"alen\": 1,\n            \"key\": b\"08b0da255d2083808a1b4d367090bacc\",\n            \"nonce\": b\"777828b13679a9e2ca89568233\",\n            \"adata\": b\"c5\",\n            \"payload\": b\"032fee9dbffccc751e6a1ee6d07bb218b3a7ec6bf5740ead\",\n            \"ct\": b\"f0828917020651c085e42459c544ec52e99372005362baf308ebe\",\n        },\n    ]\n\n\ndef test_vector_version():\n    assert cryptography.__version__ == cryptography_vectors.__version__\n\n\ndef test_raises_unsupported_algorithm_wrong_type():\n    # Check that it raises if the wrong type of exception is raised.\n    class TestException(Exception):\n        pass\n\n    with pytest.raises(TestException):\n        with raises_unsupported_algorithm(None):\n            raise TestException\n\n\ndef test_raises_unsupported_algorithm_wrong_reason():\n    # Check that it fails if the wrong reason code is raised.\n    with pytest.raises(AssertionError):\n        with raises_unsupported_algorithm(None):\n            raise UnsupportedAlgorithm(\n                \"An error.\", _Reasons.BACKEND_MISSING_INTERFACE\n            )\n\n\ndef test_raises_unsupported_no_exc():\n    # Check that it fails if no exception is raised.\n    with pytest.raises(pytest.fail.Exception):\n        with raises_unsupported_algorithm(_Reasons.BACKEND_MISSING_INTERFACE):\n            pass\n\n\ndef test_raises_unsupported_algorithm():\n    # Check that it doesn't assert if the right things are raised.\n    with raises_unsupported_algorithm(\n        _Reasons.BACKEND_MISSING_INTERFACE\n    ) as exc_info:\n        raise UnsupportedAlgorithm(\n            \"An error.\", _Reasons.BACKEND_MISSING_INTERFACE\n        )\n    assert exc_info.type is UnsupportedAlgorithm\n\n\nclass TestDeprecated:\n    def test_getattr(self):\n        with pytest.warns(DeprecationWarning):\n            assert deprecated_module.DEPRECATED == 3\n\n        assert deprecated_module.NOT_DEPRECATED == 12\n\n    def test_inspect_deprecated_module(self):\n        # Check if inspection is supported by _ModuleWithDeprecations.\n        assert isinstance(\n            deprecated_module, cryptography.utils._ModuleWithDeprecations\n        )\n        source_file = inspect.getsourcefile(deprecated_module)\n        assert isinstance(source_file, str)\n        assert source_file.endswith(\"deprecated_module.py\")\n", "tests/bench/test_x509.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport datetime\nimport json\nimport os\n\nimport certifi\n\nfrom cryptography import x509\n\nfrom ..utils import load_vectors_from_file\n\n\ndef test_object_identifier_constructor(benchmark):\n    benchmark(x509.ObjectIdentifier, \"1.3.6.1.4.1.11129.2.4.5\")\n\n\ndef test_aki_public_bytes(benchmark):\n    aki = x509.AuthorityKeyIdentifier(\n        key_identifier=b\"\\x00\" * 16,\n        authority_cert_issuer=None,\n        authority_cert_serial_number=None,\n    )\n    benchmark(aki.public_bytes)\n\n\ndef test_load_der_certificate(benchmark):\n    cert_bytes = load_vectors_from_file(\n        os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n        loader=lambda pemfile: pemfile.read(),\n        mode=\"rb\",\n    )\n\n    benchmark(x509.load_der_x509_certificate, cert_bytes)\n\n\ndef test_load_pem_certificate(benchmark):\n    cert_bytes = load_vectors_from_file(\n        os.path.join(\"x509\", \"cryptography.io.pem\"),\n        loader=lambda pemfile: pemfile.read(),\n        mode=\"rb\",\n    )\n\n    benchmark(x509.load_pem_x509_certificate, cert_bytes)\n\n\ndef test_verify_docs_python_org(benchmark, pytestconfig):\n    limbo_root = pytestconfig.getoption(\"--x509-limbo-root\", skip=True)\n    with open(os.path.join(limbo_root, \"limbo.json\"), \"rb\") as f:\n        [testcase] = [\n            tc\n            for tc in json.load(f)[\"testcases\"]\n            if tc[\"id\"] == \"online::docs.python.org\"\n        ]\n\n    with open(certifi.where(), \"rb\") as f:\n        store = x509.verification.Store(\n            x509.load_pem_x509_certificates(f.read())\n        )\n\n    leaf = x509.load_pem_x509_certificate(\n        testcase[\"peer_certificate\"].encode()\n    )\n    intermediates = [\n        x509.load_pem_x509_certificate(c.encode())\n        for c in testcase[\"untrusted_intermediates\"]\n    ]\n    time = datetime.datetime.fromisoformat(testcase[\"validation_time\"])\n\n    def bench():\n        verifier = (\n            x509.verification.PolicyBuilder()\n            .store(store)\n            .time(time)\n            .build_server_verifier(x509.DNSName(\"docs.python.org\"))\n        )\n        verifier.verify(leaf, intermediates)\n\n    benchmark(bench)\n", "tests/bench/test_hashes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography.hazmat.primitives import hashes\n\n\ndef test_sha256(benchmark):\n    def bench():\n        h = hashes.Hash(hashes.SHA256())\n        h.update(b\"I love hashing. So much. The best.\")\n        return h.finalize()\n\n    benchmark(bench)\n", "tests/bench/test_aead.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pytest\n\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives.ciphers.aead import (\n    AESCCM,\n    AESGCM,\n    AESOCB3,\n    AESSIV,\n    ChaCha20Poly1305,\n)\n\n\ndef _aead_supported(cls):\n    try:\n        cls(b\"0\" * 32)\n        return True\n    except UnsupportedAlgorithm:\n        return False\n\n\n@pytest.mark.skipif(\n    not _aead_supported(ChaCha20Poly1305),\n    reason=\"Requires OpenSSL with ChaCha20Poly1305 support\",\n)\ndef test_chacha20poly1305_encrypt(benchmark):\n    chacha = ChaCha20Poly1305(b\"\\x00\" * 32)\n    benchmark(chacha.encrypt, b\"\\x00\" * 12, b\"hello world plaintext\", b\"\")\n\n\n@pytest.mark.skipif(\n    not _aead_supported(ChaCha20Poly1305),\n    reason=\"Requires OpenSSL with ChaCha20Poly1305 support\",\n)\ndef test_chacha20poly1305_decrypt(benchmark):\n    chacha = ChaCha20Poly1305(b\"\\x00\" * 32)\n    ct = chacha.encrypt(b\"\\x00\" * 12, b\"hello world plaintext\", b\"\")\n    benchmark(chacha.decrypt, b\"\\x00\" * 12, ct, b\"\")\n\n\ndef test_aesgcm_encrypt(benchmark):\n    aes = AESGCM(b\"\\x00\" * 32)\n    benchmark(aes.encrypt, b\"\\x00\" * 12, b\"hello world plaintext\", None)\n\n\ndef test_aesgcm_decrypt(benchmark):\n    aes = AESGCM(b\"\\x00\" * 32)\n    ct = aes.encrypt(b\"\\x00\" * 12, b\"hello world plaintext\", None)\n    benchmark(aes.decrypt, b\"\\x00\" * 12, ct, None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESSIV),\n    reason=\"Requires OpenSSL with AES-SIV support\",\n)\ndef test_aessiv_encrypt(benchmark):\n    aes = AESSIV(b\"\\x00\" * 32)\n    benchmark(aes.encrypt, b\"hello world plaintext\", None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESSIV),\n    reason=\"Requires OpenSSL with AES-SIV support\",\n)\ndef test_aessiv_decrypt(benchmark):\n    aes = AESSIV(b\"\\x00\" * 32)\n    ct = aes.encrypt(b\"hello world plaintext\", None)\n    benchmark(aes.decrypt, ct, None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESOCB3),\n    reason=\"Requires OpenSSL with AES-OCB3 support\",\n)\ndef test_aesocb3_encrypt(benchmark):\n    aes = AESOCB3(b\"\\x00\" * 32)\n    benchmark(aes.encrypt, b\"\\x00\" * 12, b\"hello world plaintext\", None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESOCB3),\n    reason=\"Requires OpenSSL with AES-OCB3 support\",\n)\ndef test_aesocb3_decrypt(benchmark):\n    aes = AESOCB3(b\"\\x00\" * 32)\n    ct = aes.encrypt(b\"\\x00\" * 12, b\"hello world plaintext\", None)\n    benchmark(aes.decrypt, b\"\\x00\" * 12, ct, None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESCCM),\n    reason=\"Requires OpenSSL with AES-CCM support\",\n)\ndef test_aesccm_encrypt(benchmark):\n    aes = AESCCM(b\"\\x00\" * 32)\n    benchmark(aes.encrypt, b\"\\x00\" * 12, b\"hello world plaintext\", None)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESCCM),\n    reason=\"Requires OpenSSL with AES-CCM support\",\n)\ndef test_aesccm_decrypt(benchmark):\n    aes = AESCCM(b\"\\x00\" * 32)\n    ct = aes.encrypt(b\"\\x00\" * 12, b\"hello world plaintext\", None)\n    benchmark(aes.decrypt, b\"\\x00\" * 12, ct, None)\n", "tests/bench/test_ec_load.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom ..hazmat.primitives.fixtures_ec import EC_KEY_SECP256R1\n\n\ndef test_load_ec_public_numbers(benchmark):\n    benchmark(EC_KEY_SECP256R1.public_numbers.public_key)\n\n\ndef test_load_ec_private_numbers(benchmark):\n    benchmark(EC_KEY_SECP256R1.private_key)\n", "tests/bench/test_fernet.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography import fernet\n\n\ndef test_fernet_encrypt(benchmark):\n    f = fernet.Fernet(fernet.Fernet.generate_key())\n    benchmark(f.encrypt, b\"\\x00\" * 256)\n", "tests/bench/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/bench/test_hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography.hazmat.primitives import hashes, hmac\n\n\ndef test_hmac_sha256(benchmark):\n    def bench():\n        h = hmac.HMAC(b\"my extremely secure key\", hashes.SHA256())\n        h.update(b\"I love hashing. So much. The best.\")\n        return h.finalize()\n\n    benchmark(bench)\n", "tests/wycheproof/test_aes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidTag\nfrom cryptography.hazmat.primitives import padding\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.ciphers.aead import AESCCM, AESGCM\n\nfrom ..hazmat.primitives.test_aead import _aead_supported\nfrom .utils import wycheproof_tests\n\n\n@wycheproof_tests(\"aes_cbc_pkcs5_test.json\")\ndef test_aes_cbc_pkcs5(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    iv = binascii.unhexlify(wycheproof.testcase[\"iv\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    ct = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n\n    padder = padding.PKCS7(128).padder()\n\n    cipher = Cipher(algorithms.AES(key), modes.CBC(iv), backend)\n    enc = cipher.encryptor()\n    computed_ct = (\n        enc.update(padder.update(msg) + padder.finalize()) + enc.finalize()\n    )\n    dec = cipher.decryptor()\n    padded_msg = dec.update(ct) + dec.finalize()\n    unpadder = padding.PKCS7(128).unpadder()\n    if wycheproof.valid or wycheproof.acceptable:\n        assert computed_ct == ct\n        computed_msg = unpadder.update(padded_msg) + unpadder.finalize()\n        assert computed_msg == msg\n    else:\n        assert computed_ct != ct\n        with pytest.raises(ValueError):\n            unpadder.update(padded_msg) + unpadder.finalize()\n\n\n@wycheproof_tests(\"aes_gcm_test.json\")\ndef test_aes_gcm(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    iv = binascii.unhexlify(wycheproof.testcase[\"iv\"])\n    aad = binascii.unhexlify(wycheproof.testcase[\"aad\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    ct = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n    tag = binascii.unhexlify(wycheproof.testcase[\"tag\"])\n    if len(iv) < 8 or len(iv) > 128:\n        pytest.skip(\n            \"Less than 64-bit IVs (and greater than 1024-bit) are no longer \"\n            \"supported\"\n        )\n    if backend._fips_enabled and len(iv) != 12:\n        # Red Hat disables non-96-bit IV support as part of its FIPS\n        # patches.\n        pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n    if wycheproof.valid or wycheproof.acceptable:\n        enc = Cipher(algorithms.AES(key), modes.GCM(iv), backend).encryptor()\n        enc.authenticate_additional_data(aad)\n        computed_ct = enc.update(msg) + enc.finalize()\n        computed_tag = enc.tag\n        assert computed_ct == ct\n        assert computed_tag == tag\n        dec = Cipher(\n            algorithms.AES(key),\n            modes.GCM(iv, tag, min_tag_length=len(tag)),\n            backend,\n        ).decryptor()\n        dec.authenticate_additional_data(aad)\n        computed_msg = dec.update(ct) + dec.finalize()\n        assert computed_msg == msg\n    else:\n        dec = Cipher(\n            algorithms.AES(key),\n            modes.GCM(iv, tag, min_tag_length=len(tag)),\n            backend,\n        ).decryptor()\n        dec.authenticate_additional_data(aad)\n        dec.update(ct)\n        with pytest.raises(InvalidTag):\n            dec.finalize()\n\n\n@wycheproof_tests(\"aes_gcm_test.json\")\ndef test_aes_gcm_aead_api(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    iv = binascii.unhexlify(wycheproof.testcase[\"iv\"])\n    aad = binascii.unhexlify(wycheproof.testcase[\"aad\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    ct = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n    tag = binascii.unhexlify(wycheproof.testcase[\"tag\"])\n    if len(iv) < 8 or len(iv) > 128:\n        pytest.skip(\n            \"Less than 64-bit IVs (and greater than 1024-bit) are no longer \"\n            \"supported\"\n        )\n\n    if backend._fips_enabled and len(iv) != 12:\n        # Red Hat disables non-96-bit IV support as part of its FIPS\n        # patches.\n        pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n    aesgcm = AESGCM(key)\n    if wycheproof.valid or wycheproof.acceptable:\n        computed_ct = aesgcm.encrypt(iv, msg, aad)\n        assert computed_ct == ct + tag\n        computed_msg = aesgcm.decrypt(iv, ct + tag, aad)\n        assert computed_msg == msg\n    else:\n        with pytest.raises(InvalidTag):\n            aesgcm.decrypt(iv, ct + tag, aad)\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESCCM),\n    reason=\"Requires OpenSSL with AES-CCM support\",\n)\n@wycheproof_tests(\"aes_ccm_test.json\")\ndef test_aes_ccm_aead_api(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    iv = binascii.unhexlify(wycheproof.testcase[\"iv\"])\n    aad = binascii.unhexlify(wycheproof.testcase[\"aad\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    ct = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n    tag = binascii.unhexlify(wycheproof.testcase[\"tag\"])\n\n    if (\n        wycheproof.invalid\n        and wycheproof.testcase[\"comment\"] == \"Invalid tag size\"\n    ):\n        with pytest.raises(ValueError):\n            AESCCM(key, tag_length=wycheproof.testgroup[\"tagSize\"] // 8)\n        return\n\n    aesccm = AESCCM(key, tag_length=wycheproof.testgroup[\"tagSize\"] // 8)\n    if wycheproof.valid or wycheproof.acceptable:\n        computed_ct = aesccm.encrypt(iv, msg, aad)\n        assert computed_ct == ct + tag\n        computed_msg = aesccm.decrypt(iv, ct + tag, aad)\n        assert computed_msg == msg\n    elif not 7 <= len(iv) <= 13:\n        with pytest.raises(ValueError):\n            aesccm.decrypt(iv, ct + tag, aad)\n    else:\n        with pytest.raises(InvalidTag):\n            aesccm.decrypt(iv, ct + tag, aad)\n", "tests/wycheproof/test_hkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF\n\nfrom .utils import wycheproof_tests\n\n_HASH_ALGORITHMS = {\n    \"HKDF-SHA-1\": hashes.SHA1(),\n    \"HKDF-SHA-256\": hashes.SHA256(),\n    \"HKDF-SHA-384\": hashes.SHA384(),\n    \"HKDF-SHA-512\": hashes.SHA512(),\n}\n\n\n@wycheproof_tests(\n    \"hkdf_sha1_test.json\",\n    \"hkdf_sha256_test.json\",\n    \"hkdf_sha384_test.json\",\n    \"hkdf_sha512_test.json\",\n)\ndef test_hkdf(backend, wycheproof):\n    hash_algo = _HASH_ALGORITHMS[wycheproof.testfiledata[\"algorithm\"]]\n    if wycheproof.invalid:\n        with pytest.raises(ValueError):\n            HKDF(\n                algorithm=hash_algo,\n                length=wycheproof.testcase[\"size\"],\n                salt=binascii.unhexlify(wycheproof.testcase[\"salt\"]),\n                info=binascii.unhexlify(wycheproof.testcase[\"info\"]),\n                backend=backend,\n            )\n        return\n\n    h = HKDF(\n        algorithm=hash_algo,\n        length=wycheproof.testcase[\"size\"],\n        salt=binascii.unhexlify(wycheproof.testcase[\"salt\"]),\n        info=binascii.unhexlify(wycheproof.testcase[\"info\"]),\n        backend=backend,\n    )\n    result = h.derive(binascii.unhexlify(wycheproof.testcase[\"ikm\"]))\n    assert result == binascii.unhexlify(wycheproof.testcase[\"okm\"])\n", "tests/wycheproof/test_ecdsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nfrom .utils import wycheproof_tests\n\n_DIGESTS = {\n    \"SHA-1\": hashes.SHA1(),\n    \"SHA-224\": hashes.SHA224(),\n    \"SHA-256\": hashes.SHA256(),\n    \"SHA-384\": hashes.SHA384(),\n    \"SHA-512\": hashes.SHA512(),\n    \"SHA3-224\": hashes.SHA3_224(),\n    \"SHA3-256\": hashes.SHA3_256(),\n    \"SHA3-384\": hashes.SHA3_384(),\n    \"SHA3-512\": hashes.SHA3_512(),\n}\n\n\n@wycheproof_tests(\n    \"ecdsa_test.json\",\n    \"ecdsa_brainpoolP224r1_sha224_test.json\",\n    \"ecdsa_brainpoolP256r1_sha256_test.json\",\n    \"ecdsa_brainpoolP320r1_sha384_test.json\",\n    \"ecdsa_brainpoolP384r1_sha384_test.json\",\n    \"ecdsa_brainpoolP512r1_sha512_test.json\",\n    \"ecdsa_secp224r1_sha224_test.json\",\n    \"ecdsa_secp224r1_sha256_test.json\",\n    \"ecdsa_secp224r1_sha512_test.json\",\n    \"ecdsa_secp224r1_sha3_224_test.json\",\n    \"ecdsa_secp224r1_sha3_256_test.json\",\n    \"ecdsa_secp224r1_sha3_512_test.json\",\n    \"ecdsa_secp256k1_sha256_test.json\",\n    \"ecdsa_secp256k1_sha512_test.json\",\n    \"ecdsa_secp256k1_sha3_256_test.json\",\n    \"ecdsa_secp256k1_sha3_512_test.json\",\n    \"ecdsa_secp256r1_sha256_test.json\",\n    \"ecdsa_secp256r1_sha512_test.json\",\n    \"ecdsa_secp256r1_sha3_256_test.json\",\n    \"ecdsa_secp256r1_sha3_512_test.json\",\n    \"ecdsa_secp384r1_sha384_test.json\",\n    \"ecdsa_secp384r1_sha512_test.json\",\n    \"ecdsa_secp384r1_sha3_384_test.json\",\n    \"ecdsa_secp384r1_sha3_512_test.json\",\n    \"ecdsa_secp521r1_sha512_test.json\",\n    \"ecdsa_secp521r1_sha3_512_test.json\",\n    \"ecdsa_secp160k1_sha256_test.json\",\n    \"ecdsa_secp160r1_sha256_test.json\",\n    \"ecdsa_secp160r2_sha256_test.json\",\n    \"ecdsa_secp192k1_sha256_test.json\",\n    \"ecdsa_secp192r1_sha256_test.json\",\n)\ndef test_ecdsa_signature(backend, wycheproof):\n    try:\n        key = wycheproof.cache_value_to_group(\n            \"cache_key\",\n            lambda: serialization.load_der_public_key(\n                binascii.unhexlify(wycheproof.testgroup[\"keyDer\"])\n            ),\n        )\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n    except (UnsupportedAlgorithm, ValueError):\n        # In some OpenSSL 1.1.1 versions (RHEL and Fedora), some keys fail to\n        # load with ValueError, instead of  Unsupported Algorithm. We can\n        # remove handling for that exception when we drop support.\n        pytest.skip(\n            \"unable to load key (curve {})\".format(\n                wycheproof.testgroup[\"key\"][\"curve\"]\n            )\n        )\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n\n    alg = ec.ECDSA(digest)\n    if not backend.elliptic_curve_signature_algorithm_supported(\n        alg, key.curve\n    ):\n        pytest.skip(f\"Signature with {digest} and {key.curve} not supported\")\n\n    if wycheproof.valid or (\n        wycheproof.acceptable and not wycheproof.has_flag(\"MissingZero\")\n    ):\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            alg,\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n                alg,\n            )\n", "tests/wycheproof/test_rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding, rsa\n\nfrom .utils import wycheproof_tests\n\n_DIGESTS = {\n    \"SHA-1\": hashes.SHA1(),\n    \"SHA-224\": hashes.SHA224(),\n    \"SHA-256\": hashes.SHA256(),\n    \"SHA-384\": hashes.SHA384(),\n    \"SHA-512\": hashes.SHA512(),\n    # Not supported by OpenSSL<3 for RSA signing.\n    # Enable these when we require CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n    \"SHA-512/224\": None,\n    \"SHA-512/256\": None,\n    \"SHA3-224\": hashes.SHA3_224(),\n    \"SHA3-256\": hashes.SHA3_256(),\n    \"SHA3-384\": hashes.SHA3_384(),\n    \"SHA3-512\": hashes.SHA3_512(),\n}\n\n\ndef should_verify(backend, wycheproof):\n    if wycheproof.valid:\n        return True\n\n    if wycheproof.acceptable:\n        return not wycheproof.has_flag(\"MissingNull\")\n\n    return False\n\n\n@wycheproof_tests(\n    \"rsa_signature_test.json\",\n    \"rsa_signature_2048_sha224_test.json\",\n    \"rsa_signature_2048_sha256_test.json\",\n    \"rsa_signature_2048_sha384_test.json\",\n    \"rsa_signature_2048_sha512_test.json\",\n    \"rsa_signature_2048_sha512_224_test.json\",\n    \"rsa_signature_2048_sha512_256_test.json\",\n    \"rsa_signature_2048_sha3_224_test.json\",\n    \"rsa_signature_2048_sha3_256_test.json\",\n    \"rsa_signature_2048_sha3_384_test.json\",\n    \"rsa_signature_2048_sha3_512_test.json\",\n    \"rsa_signature_3072_sha256_test.json\",\n    \"rsa_signature_3072_sha384_test.json\",\n    \"rsa_signature_3072_sha512_test.json\",\n    \"rsa_signature_3072_sha512_256_test.json\",\n    \"rsa_signature_3072_sha3_256_test.json\",\n    \"rsa_signature_3072_sha3_384_test.json\",\n    \"rsa_signature_3072_sha3_512_test.json\",\n    \"rsa_signature_4096_sha384_test.json\",\n    \"rsa_signature_4096_sha512_test.json\",\n    \"rsa_signature_4096_sha512_256_test.json\",\n)\ndef test_rsa_pkcs1v15_signature(backend, wycheproof):\n    key = wycheproof.cache_value_to_group(\n        \"cached_key\",\n        lambda: serialization.load_der_public_key(\n            binascii.unhexlify(wycheproof.testgroup[\"keyDer\"]),\n        ),\n    )\n    assert isinstance(key, rsa.RSAPublicKey)\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n\n    if digest is None or not backend.hash_supported(digest):\n        pytest.skip(\n            \"Hash {} not supported\".format(wycheproof.testgroup[\"sha\"])\n        )\n\n    if should_verify(backend, wycheproof):\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            padding.PKCS1v15(),\n            digest,\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n                padding.PKCS1v15(),\n                digest,\n            )\n\n\n@wycheproof_tests(\"rsa_sig_gen_misc_test.json\")\ndef test_rsa_pkcs1v15_signature_generation(backend, wycheproof):\n    key = wycheproof.cache_value_to_group(\n        \"cached_key\",\n        lambda: serialization.load_pem_private_key(\n            wycheproof.testgroup[\"privateKeyPem\"].encode(\"ascii\"),\n            password=None,\n            unsafe_skip_rsa_key_validation=True,\n        ),\n    )\n    assert isinstance(key, rsa.RSAPrivateKey)\n\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n    assert digest is not None\n    if backend._fips_enabled:\n        if key.key_size < backend._fips_rsa_min_key_size or isinstance(\n            digest, hashes.SHA1\n        ):\n            pytest.skip(\n                f\"Invalid params for FIPS. key: {key.key_size} bits, \"\n                f\"digest: {digest.name}\"\n            )\n\n    sig = key.sign(\n        binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n        padding.PKCS1v15(),\n        digest,\n    )\n    assert sig == binascii.unhexlify(wycheproof.testcase[\"sig\"])\n\n\n@wycheproof_tests(\n    \"rsa_pss_2048_sha1_mgf1_20_test.json\",\n    \"rsa_pss_2048_sha256_mgf1_0_test.json\",\n    \"rsa_pss_2048_sha256_mgf1_32_test.json\",\n    \"rsa_pss_2048_sha512_256_mgf1_28_test.json\",\n    \"rsa_pss_2048_sha512_256_mgf1_32_test.json\",\n    \"rsa_pss_3072_sha256_mgf1_32_test.json\",\n    \"rsa_pss_4096_sha256_mgf1_32_test.json\",\n    \"rsa_pss_4096_sha512_mgf1_32_test.json\",\n    \"rsa_pss_misc_test.json\",\n)\ndef test_rsa_pss_signature(backend, wycheproof):\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n    if backend._fips_enabled and isinstance(digest, hashes.SHA1):\n        pytest.skip(\"Invalid params for FIPS. SHA1 is disallowed\")\n\n    key = wycheproof.cache_value_to_group(\n        \"cached_key\",\n        lambda: serialization.load_der_public_key(\n            binascii.unhexlify(wycheproof.testgroup[\"keyDer\"]),\n        ),\n    )\n    assert isinstance(key, rsa.RSAPublicKey)\n    mgf_digest = _DIGESTS[wycheproof.testgroup[\"mgfSha\"]]\n\n    if digest is None or mgf_digest is None:\n        pytest.skip(\n            \"PSS with digest={} and MGF digest={} not supported\".format(\n                wycheproof.testgroup[\"sha\"],\n                wycheproof.testgroup[\"mgfSha\"],\n            )\n        )\n\n    if wycheproof.valid or wycheproof.acceptable:\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            padding.PSS(\n                mgf=padding.MGF1(mgf_digest),\n                salt_length=wycheproof.testgroup[\"sLen\"],\n            ),\n            digest,\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n                padding.PSS(\n                    mgf=padding.MGF1(mgf_digest),\n                    salt_length=wycheproof.testgroup[\"sLen\"],\n                ),\n                digest,\n            )\n\n\n@wycheproof_tests(\n    \"rsa_oaep_2048_sha1_mgf1sha1_test.json\",\n    \"rsa_oaep_2048_sha224_mgf1sha1_test.json\",\n    \"rsa_oaep_2048_sha224_mgf1sha224_test.json\",\n    \"rsa_oaep_2048_sha256_mgf1sha1_test.json\",\n    \"rsa_oaep_2048_sha256_mgf1sha256_test.json\",\n    \"rsa_oaep_2048_sha384_mgf1sha1_test.json\",\n    \"rsa_oaep_2048_sha384_mgf1sha384_test.json\",\n    \"rsa_oaep_2048_sha512_mgf1sha1_test.json\",\n    \"rsa_oaep_2048_sha512_mgf1sha512_test.json\",\n    \"rsa_oaep_3072_sha256_mgf1sha1_test.json\",\n    \"rsa_oaep_3072_sha256_mgf1sha256_test.json\",\n    \"rsa_oaep_3072_sha512_mgf1sha1_test.json\",\n    \"rsa_oaep_3072_sha512_mgf1sha512_test.json\",\n    \"rsa_oaep_4096_sha256_mgf1sha1_test.json\",\n    \"rsa_oaep_4096_sha256_mgf1sha256_test.json\",\n    \"rsa_oaep_4096_sha512_mgf1sha1_test.json\",\n    \"rsa_oaep_4096_sha512_mgf1sha512_test.json\",\n    \"rsa_oaep_misc_test.json\",\n)\ndef test_rsa_oaep_encryption(backend, wycheproof):\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n    mgf_digest = _DIGESTS[wycheproof.testgroup[\"mgfSha\"]]\n    assert digest is not None\n    assert mgf_digest is not None\n    padding_algo = padding.OAEP(\n        mgf=padding.MGF1(algorithm=mgf_digest),\n        algorithm=digest,\n        label=binascii.unhexlify(wycheproof.testcase[\"label\"]),\n    )\n    if not backend.rsa_encryption_supported(padding_algo):\n        pytest.skip(\n            f\"Does not support OAEP using {mgf_digest.name} MGF1 \"\n            f\"or {digest.name} hash.\"\n        )\n\n    key = wycheproof.cache_value_to_group(\n        \"cached_key\",\n        lambda: serialization.load_pem_private_key(\n            wycheproof.testgroup[\"privateKeyPem\"].encode(\"ascii\"),\n            password=None,\n            unsafe_skip_rsa_key_validation=True,\n        ),\n    )\n    assert isinstance(key, rsa.RSAPrivateKey)\n    if backend._fips_enabled and key.key_size < backend._fips_rsa_min_key_size:\n        pytest.skip(\"Invalid params for FIPS. <2048 bit keys are disallowed\")\n\n    if wycheproof.valid or wycheproof.acceptable:\n        pt = key.decrypt(\n            binascii.unhexlify(wycheproof.testcase[\"ct\"]), padding_algo\n        )\n        assert pt == binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    else:\n        with pytest.raises(ValueError):\n            key.decrypt(\n                binascii.unhexlify(wycheproof.testcase[\"ct\"]), padding_algo\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.rsa_encryption_supported(\n        padding.PKCS1v15()\n    ),\n    skip_message=\"Does not support PKCS1v1.5 for encryption.\",\n)\n@wycheproof_tests(\n    \"rsa_pkcs1_2048_test.json\",\n    \"rsa_pkcs1_3072_test.json\",\n    \"rsa_pkcs1_4096_test.json\",\n)\ndef test_rsa_pkcs1_encryption(backend, wycheproof):\n    key = wycheproof.cache_value_to_group(\n        \"cached_key\",\n        lambda: serialization.load_pem_private_key(\n            wycheproof.testgroup[\"privateKeyPem\"].encode(\"ascii\"),\n            password=None,\n            unsafe_skip_rsa_key_validation=True,\n        ),\n    )\n    assert isinstance(key, rsa.RSAPrivateKey)\n\n    if wycheproof.valid:\n        pt = key.decrypt(\n            binascii.unhexlify(wycheproof.testcase[\"ct\"]), padding.PKCS1v15()\n        )\n        assert pt == binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    else:\n        if backend._lib.Cryptography_HAS_IMPLICIT_RSA_REJECTION:\n            try:\n                assert key.decrypt(\n                    binascii.unhexlify(wycheproof.testcase[\"ct\"]),\n                    padding.PKCS1v15(),\n                ) != binascii.unhexlify(wycheproof.testcase[\"ct\"])\n            except ValueError:\n                # Some raise ValueError due to length mismatch.\n                pass\n        else:\n            with pytest.raises(ValueError):\n                key.decrypt(\n                    binascii.unhexlify(wycheproof.testcase[\"ct\"]),\n                    padding.PKCS1v15(),\n                )\n", "tests/wycheproof/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pytest\n\nfrom ..utils import load_wycheproof_tests\n\n\ndef wycheproof_tests(*paths, subdir=\"testvectors\"):\n    def wrapper(func):\n        @pytest.mark.parametrize(\"path\", paths)\n        def run_wycheproof(backend, subtests, pytestconfig, path):\n            wycheproof_root = pytestconfig.getoption(\n                \"--wycheproof-root\", skip=True\n            )\n            for test in load_wycheproof_tests(wycheproof_root, path, subdir):\n                with subtests.test():\n                    func(backend, test)\n\n        return run_wycheproof\n\n    return wrapper\n", "tests/wycheproof/test_keywrap.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import keywrap\n\nfrom .utils import wycheproof_tests\n\n\n@wycheproof_tests(\"kwp_test.json\")\ndef test_keywrap_with_padding(backend, wycheproof):\n    wrapping_key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    key_to_wrap = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    expected = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n\n    result = keywrap.aes_key_wrap_with_padding(\n        wrapping_key, key_to_wrap, backend\n    )\n    if wycheproof.valid or wycheproof.acceptable:\n        assert result == expected\n\n    if wycheproof.valid or (wycheproof.acceptable and not len(expected) < 16):\n        result = keywrap.aes_key_unwrap_with_padding(\n            wrapping_key, expected, backend\n        )\n        assert result == key_to_wrap\n    else:\n        with pytest.raises(keywrap.InvalidUnwrap):\n            keywrap.aes_key_unwrap_with_padding(\n                wrapping_key, expected, backend\n            )\n\n\n@wycheproof_tests(\"kw_test.json\")\ndef test_keywrap(backend, wycheproof):\n    wrapping_key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    key_to_wrap = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    expected = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n\n    if wycheproof.valid or (\n        wycheproof.acceptable\n        and wycheproof.testcase[\"comment\"] != \"invalid size of wrapped key\"\n    ):\n        result = keywrap.aes_key_wrap(wrapping_key, key_to_wrap, backend)\n        assert result == expected\n\n    if wycheproof.valid or wycheproof.acceptable:\n        result = keywrap.aes_key_unwrap(wrapping_key, expected, backend)\n        assert result == key_to_wrap\n    else:\n        with pytest.raises(keywrap.InvalidUnwrap):\n            keywrap.aes_key_unwrap(wrapping_key, expected, backend)\n", "tests/wycheproof/test_ecdh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nfrom ..hazmat.primitives.test_ec import _skip_exchange_algorithm_unsupported\nfrom .utils import wycheproof_tests\n\n_CURVES = {\n    \"secp224r1\": ec.SECP224R1(),\n    \"secp256r1\": ec.SECP256R1(),\n    \"secp384r1\": ec.SECP384R1(),\n    \"secp521r1\": ec.SECP521R1(),\n    \"secp224k1\": None,\n    \"secp256k1\": ec.SECP256K1(),\n    \"sect283r1\": ec.SECT283R1(),\n    \"sect409r1\": ec.SECT409R1(),\n    \"sect571r1\": ec.SECT571R1(),\n    \"sect283k1\": ec.SECT283K1(),\n    \"sect409k1\": ec.SECT409K1(),\n    \"sect571k1\": ec.SECT571K1(),\n    \"brainpoolP224r1\": None,\n    \"brainpoolP256r1\": ec.BrainpoolP256R1(),\n    \"brainpoolP320r1\": None,\n    \"brainpoolP384r1\": ec.BrainpoolP384R1(),\n    \"brainpoolP512r1\": ec.BrainpoolP512R1(),\n    \"brainpoolP224t1\": None,\n    \"brainpoolP256t1\": None,\n    \"brainpoolP320t1\": None,\n    \"brainpoolP384t1\": None,\n    \"brainpoolP512t1\": None,\n    \"FRP256v1\": None,\n}\n\n\n@wycheproof_tests(\n    \"ecdh_test.json\",\n    \"ecdh_brainpoolP224r1_test.json\",\n    \"ecdh_brainpoolP256r1_test.json\",\n    \"ecdh_brainpoolP320r1_test.json\",\n    \"ecdh_brainpoolP384r1_test.json\",\n    \"ecdh_brainpoolP512r1_test.json\",\n    \"ecdh_secp224r1_test.json\",\n    \"ecdh_secp256k1_test.json\",\n    \"ecdh_secp256r1_test.json\",\n    \"ecdh_secp384r1_test.json\",\n    \"ecdh_secp521r1_test.json\",\n    \"ecdh_sect283k1_test.json\",\n    \"ecdh_sect283r1_test.json\",\n    \"ecdh_sect409k1_test.json\",\n    \"ecdh_sect409r1_test.json\",\n    \"ecdh_sect571k1_test.json\",\n    \"ecdh_sect571r1_test.json\",\n)\ndef test_ecdh(backend, wycheproof):\n    curve = _CURVES[wycheproof.testgroup[\"curve\"]]\n    if curve is None:\n        pytest.skip(\n            \"Unsupported curve ({})\".format(wycheproof.testgroup[\"curve\"])\n        )\n    _skip_exchange_algorithm_unsupported(backend, ec.ECDH(), curve)\n    private_key = wycheproof.cache_value_to_group(\n        f\"private_key_{wycheproof.testcase['private']}\",\n        lambda: ec.derive_private_key(\n            int(wycheproof.testcase[\"private\"], 16), curve\n        ),\n    )\n\n    try:\n        # caching these values shows no performance improvement\n        public_key = serialization.load_der_public_key(\n            binascii.unhexlify(wycheproof.testcase[\"public\"]), backend\n        )\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n    except ValueError:\n        assert wycheproof.invalid or wycheproof.acceptable\n        return\n    except UnsupportedAlgorithm:\n        return\n\n    if wycheproof.valid or wycheproof.acceptable:\n        computed_shared = private_key.exchange(ec.ECDH(), public_key)\n        expected_shared = binascii.unhexlify(wycheproof.testcase[\"shared\"])\n        assert computed_shared == expected_shared\n    else:\n        with pytest.raises(ValueError):\n            private_key.exchange(ec.ECDH(), public_key)\n\n\n@wycheproof_tests(\n    \"ecdh_secp224r1_ecpoint_test.json\",\n    \"ecdh_secp256r1_ecpoint_test.json\",\n    \"ecdh_secp384r1_ecpoint_test.json\",\n    \"ecdh_secp521r1_ecpoint_test.json\",\n)\ndef test_ecdh_ecpoint(backend, wycheproof):\n    curve = _CURVES[wycheproof.testgroup[\"curve\"]]\n    assert isinstance(curve, ec.EllipticCurve)\n    _skip_exchange_algorithm_unsupported(backend, ec.ECDH(), curve)\n\n    private_key = wycheproof.cache_value_to_group(\n        f\"private_key_{wycheproof.testcase['private']}\",\n        lambda: ec.derive_private_key(\n            int(wycheproof.testcase[\"private\"], 16), curve\n        ),\n    )\n\n    if wycheproof.invalid:\n        with pytest.raises(ValueError):\n            ec.EllipticCurvePublicKey.from_encoded_point(\n                curve, binascii.unhexlify(wycheproof.testcase[\"public\"])\n            )\n        return\n\n    assert wycheproof.valid or wycheproof.acceptable\n    # caching these values shows no performance improvement\n    public_key = ec.EllipticCurvePublicKey.from_encoded_point(\n        curve, binascii.unhexlify(wycheproof.testcase[\"public\"])\n    )\n    computed_shared = private_key.exchange(ec.ECDH(), public_key)\n    expected_shared = binascii.unhexlify(wycheproof.testcase[\"shared\"])\n    assert computed_shared == expected_shared\n", "tests/wycheproof/test_x448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.hazmat.primitives.asymmetric.x448 import (\n    X448PrivateKey,\n    X448PublicKey,\n)\n\nfrom .utils import wycheproof_tests\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x448_supported(),\n    skip_message=\"Requires OpenSSL with X448 support\",\n)\n@wycheproof_tests(\"x448_test.json\")\ndef test_x448(backend, wycheproof):\n    assert set(wycheproof.testgroup.items()) == {\n        (\"curve\", \"curve448\"),\n        (\"type\", \"XdhComp\"),\n    }\n\n    private_key = X448PrivateKey.from_private_bytes(\n        binascii.unhexlify(wycheproof.testcase[\"private\"])\n    )\n    public_key_bytes = binascii.unhexlify(wycheproof.testcase[\"public\"])\n    if len(public_key_bytes) == 57:\n        assert wycheproof.acceptable\n        assert wycheproof.has_flag(\"NonCanonicalPublic\")\n        with pytest.raises(ValueError):\n            X448PublicKey.from_public_bytes(public_key_bytes)\n        return\n\n    public_key = X448PublicKey.from_public_bytes(public_key_bytes)\n\n    assert wycheproof.valid or wycheproof.acceptable\n\n    expected = binascii.unhexlify(wycheproof.testcase[\"shared\"])\n    if expected == b\"\\x00\" * 56:\n        assert wycheproof.acceptable\n        # OpenSSL returns an error on all zeros shared key\n        with pytest.raises(ValueError):\n            private_key.exchange(public_key)\n    else:\n        assert private_key.exchange(public_key) == expected\n", "tests/wycheproof/test_x25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.hazmat.primitives.asymmetric.x25519 import (\n    X25519PrivateKey,\n    X25519PublicKey,\n)\n\nfrom .utils import wycheproof_tests\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL with X25519 support\",\n)\n@wycheproof_tests(\"x25519_test.json\")\ndef test_x25519(backend, wycheproof):\n    assert set(wycheproof.testgroup.items()) == {\n        (\"curve\", \"curve25519\"),\n        (\"type\", \"XdhComp\"),\n    }\n\n    private_key = X25519PrivateKey.from_private_bytes(\n        binascii.unhexlify(wycheproof.testcase[\"private\"])\n    )\n    public_key = X25519PublicKey.from_public_bytes(\n        binascii.unhexlify(wycheproof.testcase[\"public\"])\n    )\n\n    assert wycheproof.valid or wycheproof.acceptable\n\n    expected = binascii.unhexlify(wycheproof.testcase[\"shared\"])\n    if expected == b\"\\x00\" * 32:\n        assert wycheproof.acceptable\n        # OpenSSL returns an error on all zeros shared key\n        with pytest.raises(ValueError):\n            private_key.exchange(public_key)\n    else:\n        assert private_key.exchange(public_key) == expected\n", "tests/wycheproof/test_cmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives.ciphers.algorithms import AES\nfrom cryptography.hazmat.primitives.cmac import CMAC\n\nfrom .utils import wycheproof_tests\n\n\n@wycheproof_tests(\"aes_cmac_test.json\")\ndef test_aes_cmac(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    tag = binascii.unhexlify(wycheproof.testcase[\"tag\"])\n\n    # skip truncated tags, which we don't support in the API\n    if wycheproof.valid and len(tag) == 16:\n        ctx = CMAC(AES(key), backend)\n        ctx.update(msg)\n        ctx.verify(tag)\n    elif len(key) not in [16, 24, 32]:\n        with pytest.raises(ValueError):\n            CMAC(AES(key), backend)\n    else:\n        ctx = CMAC(AES(key), backend)\n        ctx.update(msg)\n        with pytest.raises(InvalidSignature):\n            ctx.verify(tag)\n", "tests/wycheproof/test_chacha20poly1305.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidTag\nfrom cryptography.hazmat.primitives.ciphers.aead import ChaCha20Poly1305\n\nfrom ..hazmat.primitives.test_aead import _aead_supported\nfrom .utils import wycheproof_tests\n\n\n@pytest.mark.skipif(\n    not _aead_supported(ChaCha20Poly1305),\n    reason=\"Requires OpenSSL with ChaCha20Poly1305 support\",\n)\n@wycheproof_tests(\"chacha20_poly1305_test.json\")\ndef test_chacha20poly1305(backend, wycheproof):\n    key = binascii.unhexlify(wycheproof.testcase[\"key\"])\n    iv = binascii.unhexlify(wycheproof.testcase[\"iv\"])\n    aad = binascii.unhexlify(wycheproof.testcase[\"aad\"])\n    msg = binascii.unhexlify(wycheproof.testcase[\"msg\"])\n    ct = binascii.unhexlify(wycheproof.testcase[\"ct\"])\n    tag = binascii.unhexlify(wycheproof.testcase[\"tag\"])\n\n    if wycheproof.valid:\n        chacha = ChaCha20Poly1305(key)\n        computed_ct = chacha.encrypt(iv, msg, aad)\n        assert computed_ct == ct + tag\n        computed_msg = chacha.decrypt(iv, ct + tag, aad)\n        assert computed_msg == msg\n    elif len(iv) != 12:\n        chacha = ChaCha20Poly1305(key)\n        with pytest.raises(ValueError):\n            chacha.encrypt(iv, msg, aad)\n        with pytest.raises(ValueError):\n            chacha.decrypt(iv, ct + tag, aad)\n    else:\n        chacha = ChaCha20Poly1305(key)\n        with pytest.raises(InvalidTag):\n            chacha.decrypt(iv, msg + tag, aad)\n", "tests/wycheproof/__init__.py": "", "tests/wycheproof/test_hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, hmac\n\nfrom .utils import wycheproof_tests\n\n_HMAC_ALGORITHMS = {\n    \"HMACSHA1\": hashes.SHA1(),\n    \"HMACSHA224\": hashes.SHA224(),\n    \"HMACSHA256\": hashes.SHA256(),\n    \"HMACSHA384\": hashes.SHA384(),\n    \"HMACSHA512\": hashes.SHA512(),\n    \"HMACSHA3-224\": hashes.SHA3_224(),\n    \"HMACSHA3-256\": hashes.SHA3_256(),\n    \"HMACSHA3-384\": hashes.SHA3_384(),\n    \"HMACSHA3-512\": hashes.SHA3_512(),\n}\n\n\n@wycheproof_tests(\n    \"hmac_sha1_test.json\",\n    \"hmac_sha224_test.json\",\n    \"hmac_sha256_test.json\",\n    \"hmac_sha384_test.json\",\n    \"hmac_sha3_224_test.json\",\n    \"hmac_sha3_256_test.json\",\n    \"hmac_sha3_384_test.json\",\n    \"hmac_sha3_512_test.json\",\n    \"hmac_sha512_test.json\",\n)\ndef test_hmac(backend, wycheproof):\n    hash_algo = _HMAC_ALGORITHMS[wycheproof.testfiledata[\"algorithm\"]]\n    if wycheproof.testgroup[\"tagSize\"] // 8 != hash_algo.digest_size:\n        pytest.skip(\"Truncated HMAC not supported\")\n    if not backend.hmac_supported(hash_algo):\n        pytest.skip(f\"Hash {hash_algo.name} not supported\")\n\n    h = hmac.HMAC(\n        key=binascii.unhexlify(wycheproof.testcase[\"key\"]),\n        algorithm=hash_algo,\n        backend=backend,\n    )\n    h.update(binascii.unhexlify(wycheproof.testcase[\"msg\"]))\n\n    if wycheproof.invalid:\n        with pytest.raises(InvalidSignature):\n            h.verify(binascii.unhexlify(wycheproof.testcase[\"tag\"]))\n    else:\n        tag = h.finalize()\n        assert tag == binascii.unhexlify(wycheproof.testcase[\"tag\"])\n\n        h = hmac.HMAC(\n            key=binascii.unhexlify(wycheproof.testcase[\"key\"]),\n            algorithm=hash_algo,\n            backend=backend,\n        )\n        h.update(binascii.unhexlify(wycheproof.testcase[\"msg\"]))\n        h.verify(binascii.unhexlify(wycheproof.testcase[\"tag\"]))\n", "tests/wycheproof/test_pbkdf2.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nfrom .utils import wycheproof_tests\n\n_HASH_ALGORITHMS = {\n    \"PBKDF2-HMACSHA1\": hashes.SHA1(),\n    \"PBKDF2-HMACSHA224\": hashes.SHA224(),\n    \"PBKDF2-HMACSHA256\": hashes.SHA256(),\n    \"PBKDF2-HMACSHA384\": hashes.SHA384(),\n    \"PBKDF2-HMACSHA512\": hashes.SHA512(),\n}\n\n\n@wycheproof_tests(\n    \"pbkdf2_hmacsha1_test.json\",\n    \"pbkdf2_hmacsha224_test.json\",\n    \"pbkdf2_hmacsha256_test.json\",\n    \"pbkdf2_hmacsha384_test.json\",\n    \"pbkdf2_hmacsha512_test.json\",\n    subdir=\"testvectors_v1\",\n)\ndef test_pbkdf2(backend, wycheproof):\n    assert wycheproof.valid\n\n    algorithm = _HASH_ALGORITHMS[wycheproof.testfiledata[\"algorithm\"]]\n\n    p = PBKDF2HMAC(\n        algorithm=algorithm,\n        length=wycheproof.testcase[\"dkLen\"],\n        salt=binascii.unhexlify(wycheproof.testcase[\"salt\"]),\n        iterations=wycheproof.testcase[\"iterationCount\"],\n    )\n    assert p.derive(\n        binascii.unhexlify(wycheproof.testcase[\"password\"])\n    ) == binascii.unhexlify(wycheproof.testcase[\"dk\"])\n", "tests/wycheproof/test_eddsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives.asymmetric.ed448 import Ed448PublicKey\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PublicKey\n\nfrom .utils import wycheproof_tests\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\n@wycheproof_tests(\"eddsa_test.json\")\ndef test_ed25519_signature(backend, wycheproof):\n    # We want to fail if/when wycheproof adds more edwards curve tests\n    # so we can add them as well.\n    assert wycheproof.testgroup[\"key\"][\"curve\"] == \"edwards25519\"\n\n    key = Ed25519PublicKey.from_public_bytes(\n        binascii.unhexlify(wycheproof.testgroup[\"key\"][\"pk\"])\n    )\n\n    if wycheproof.valid or wycheproof.acceptable:\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\n@wycheproof_tests(\"ed448_test.json\")\ndef test_ed448_signature(backend, wycheproof):\n    key = Ed448PublicKey.from_public_bytes(\n        binascii.unhexlify(wycheproof.testgroup[\"key\"][\"pk\"])\n    )\n\n    if wycheproof.valid or wycheproof.acceptable:\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            )\n", "tests/wycheproof/test_utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom ..utils import WycheproofTest\n\n\ndef test_wycheproof_test_repr():\n    wycheproof = WycheproofTest({}, {}, {\"tcId\": 3})\n    assert repr(wycheproof) == \"<WycheproofTest({}, {}, {'tcId': 3}, tcId=3)>\"\n", "tests/wycheproof/test_dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\n\nfrom .utils import wycheproof_tests\n\n_DIGESTS = {\n    \"SHA-1\": hashes.SHA1(),\n    \"SHA-224\": hashes.SHA224(),\n    \"SHA-256\": hashes.SHA256(),\n}\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Requires OpenSSL with DSA support\",\n)\n@wycheproof_tests(\n    \"dsa_test.json\",\n    \"dsa_2048_224_sha224_test.json\",\n    \"dsa_2048_224_sha256_test.json\",\n    \"dsa_2048_256_sha256_test.json\",\n    \"dsa_3072_256_sha256_test.json\",\n)\ndef test_dsa_signature(backend, wycheproof):\n    key = serialization.load_der_public_key(\n        binascii.unhexlify(wycheproof.testgroup[\"keyDer\"]), backend\n    )\n    assert isinstance(key, dsa.DSAPublicKey)\n    digest = _DIGESTS[wycheproof.testgroup[\"sha\"]]\n\n    if wycheproof.valid or (\n        wycheproof.acceptable and not wycheproof.has_flag(\"NoLeadingZero\")\n    ):\n        key.verify(\n            binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n            binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n            digest,\n        )\n    else:\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                binascii.unhexlify(wycheproof.testcase[\"sig\"]),\n                binascii.unhexlify(wycheproof.testcase[\"msg\"]),\n                digest,\n            )\n", "tests/x509/test_x509.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport datetime\nimport ipaddress\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import InvalidSignature, UnsupportedAlgorithm\nfrom cryptography.hazmat.bindings._rust import asn1\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dh,\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    padding,\n    rsa,\n    types,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.asymmetric.utils import (\n    decode_dss_signature,\n)\nfrom cryptography.x509.name import _ASN1Type\nfrom cryptography.x509.oid import (\n    AuthorityInformationAccessOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    PublicKeyAlgorithmOID,\n    SignatureAlgorithmOID,\n    SubjectInformationAccessOID,\n)\n\nfrom ..hazmat.primitives.fixtures_dsa import DSA_KEY_2048, DSA_KEY_3072\nfrom ..hazmat.primitives.fixtures_ec import EC_KEY_SECP256R1\nfrom ..hazmat.primitives.fixtures_rsa import (\n    RSA_KEY_2048_ALT,\n)\nfrom ..hazmat.primitives.test_ec import _skip_curve_unsupported\nfrom ..hazmat.primitives.test_rsa import rsa_key_512, rsa_key_2048\nfrom ..utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n# Make ruff happy since we're importing fixtures that pytest patches in as\n# func args\n__all__ = [\"rsa_key_512\", \"rsa_key_2048\"]\n\n\nclass DummyExtension(x509.ExtensionType):\n    oid = x509.ObjectIdentifier(\"1.2.3.4\")\n\n\nclass FakeGeneralName(x509.GeneralName):\n    def __init__(self, value):\n        self._value = value\n\n    @property\n    def value(self):\n        return self._value\n\n\nT = typing.TypeVar(\"T\")\n\n\ndef _load_cert(filename, loader: typing.Callable[..., T]) -> T:\n    return load_vectors_from_file(\n        filename=filename,\n        loader=lambda pemfile: loader(pemfile.read()),\n        mode=\"rb\",\n    )\n\n\ndef _generate_ca_and_leaf(\n    issuer_private_key: types.CertificateIssuerPrivateKeyTypes,\n    subject_private_key: types.CertificateIssuerPrivateKeyTypes,\n):\n    if isinstance(\n        issuer_private_key,\n        (ed25519.Ed25519PrivateKey, ed448.Ed448PrivateKey),\n    ):\n        hash_alg = None\n    else:\n        hash_alg = hashes.SHA256()\n\n    builder = (\n        x509.CertificateBuilder()\n        .subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n        )\n        .issuer_name(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n        )\n        .public_key(issuer_private_key.public_key())\n        .serial_number(1)\n        .not_valid_before(datetime.datetime(2020, 1, 1))\n        .not_valid_after(datetime.datetime(2030, 1, 1))\n    )\n    ca = builder.sign(issuer_private_key, hash_alg)\n    builder = (\n        x509.CertificateBuilder()\n        .subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"leaf\")])\n        )\n        .issuer_name(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n        )\n        .public_key(subject_private_key.public_key())\n        .serial_number(100)\n        .not_valid_before(datetime.datetime(2020, 1, 1))\n        .not_valid_after(datetime.datetime(2025, 1, 1))\n    )\n    cert = builder.sign(issuer_private_key, hash_alg)\n    return ca, cert\n\n\ndef _break_cert_sig(cert: x509.Certificate) -> x509.Certificate:\n    cert_bad_sig = bytearray(cert.public_bytes(serialization.Encoding.PEM))\n    # Break the sig by mutating 5 bytes. That's the base64 representation\n    # though so there's somewhere closer to 2**-32 probability of\n    # not breaking the sig. Spin that roulette wheel.\n    cert_bad_sig[-40:-35] = 90, 90, 90, 90, 90\n    return x509.load_pem_x509_certificate(bytes(cert_bad_sig))\n\n\ndef _check_cert_times(\n    cert: x509.Certificate,\n    not_valid_before: typing.Optional[datetime.datetime],\n    not_valid_after: typing.Optional[datetime.datetime],\n) -> None:\n    if not_valid_before:\n        with pytest.warns(utils.DeprecatedIn42):\n            assert cert.not_valid_before == not_valid_before\n        assert cert.not_valid_before_utc == not_valid_before.replace(\n            tzinfo=datetime.timezone.utc\n        )\n    if not_valid_after:\n        with pytest.warns(utils.DeprecatedIn42):\n            assert cert.not_valid_after == not_valid_after\n        assert cert.not_valid_after_utc == not_valid_after.replace(\n            tzinfo=datetime.timezone.utc\n        )\n\n\ndef _check_crl_times(\n    crl: x509.CertificateRevocationList,\n    last_update: datetime.datetime,\n    next_update: datetime.datetime,\n) -> None:\n    with pytest.warns(utils.DeprecatedIn42):\n        assert crl.last_update == last_update\n        assert crl.next_update == next_update\n\n    assert crl.last_update_utc == last_update.replace(\n        tzinfo=datetime.timezone.utc\n    )\n    assert crl.next_update_utc == next_update.replace(\n        tzinfo=datetime.timezone.utc\n    )\n\n\nclass TestCertificateRevocationList:\n    def test_load_pem_crl(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        assert isinstance(crl, x509.CertificateRevocationList)\n        fingerprint = binascii.hexlify(crl.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"191b3428bf9d0dafa4edd42bc98603e182614c57\"\n        assert isinstance(crl.signature_hash_algorithm, hashes.SHA256)\n        assert (\n            crl.signature_algorithm_oid\n            == SignatureAlgorithmOID.RSA_WITH_SHA256\n        )\n\n    def test_load_der_crl(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n\n        assert isinstance(crl, x509.CertificateRevocationList)\n        fingerprint = binascii.hexlify(crl.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"dd3db63c50f4c4a13e090f14053227cb1011a5ad\"\n        assert isinstance(crl.signature_hash_algorithm, hashes.SHA256)\n\n    def test_load_large_crl(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_almost_10k.pem\"),\n            x509.load_pem_x509_crl,\n        )\n        assert len(crl) == 9999\n\n    def test_empty_crl_no_sequence(self, backend):\n        # The SEQUENCE for revoked certificates is optional so let's\n        # test that we handle it properly.\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_empty_no_sequence.der\"),\n            x509.load_der_x509_crl,\n        )\n        assert len(crl) == 0\n\n        with pytest.raises(IndexError):\n            crl[0]\n        assert crl.get_revoked_certificate_by_serial_number(12) is None\n        assert list(iter(crl)) == []\n\n    def test_invalid_pem(self, backend):\n        with pytest.raises(ValueError):\n            x509.load_pem_x509_crl(b\"notacrl\", backend)\n\n        pem_bytes = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"valid_signature_cert.pem\"),\n            lambda data: data,\n        )\n        with pytest.raises(ValueError):\n            x509.load_pem_x509_crl(pem_bytes, backend)\n\n    def test_invalid_der(self, backend):\n        with pytest.raises(ValueError):\n            x509.load_der_x509_crl(b\"notacrl\", backend)\n\n    def test_invalid_time(self, backend):\n        with pytest.raises(ValueError, match=\"TBSCertList::this_update\"):\n            _load_cert(\n                os.path.join(\"x509\", \"custom\", \"crl_invalid_time.der\"),\n                x509.load_der_x509_crl,\n            )\n\n    def test_unknown_signature_algorithm(self, backend):\n        crl = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"crl_md2_unknown_crit_entry_ext.pem\"\n            ),\n            x509.load_pem_x509_crl,\n        )\n\n        with raises_unsupported_algorithm(None):\n            crl.signature_hash_algorithm\n\n    def test_invalid_version(self, backend):\n        with pytest.raises(x509.InvalidVersion):\n            _load_cert(\n                os.path.join(\"x509\", \"custom\", \"crl_bad_version.pem\"),\n                x509.load_pem_x509_crl,\n            )\n\n    def test_issuer(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n\n        assert isinstance(crl.issuer, x509.Name)\n        assert list(crl.issuer) == [\n            x509.NameAttribute(x509.OID_COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(\n                x509.OID_ORGANIZATION_NAME, \"Test Certificates 2011\"\n            ),\n            x509.NameAttribute(x509.OID_COMMON_NAME, \"Good CA\"),\n        ]\n        assert crl.issuer.get_attributes_for_oid(x509.OID_COMMON_NAME) == [\n            x509.NameAttribute(x509.OID_COMMON_NAME, \"Good CA\")\n        ]\n\n    def test_equality(self, backend):\n        crl1 = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n\n        crl2 = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n\n        crl3 = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        assert crl1 == crl2\n        assert crl1 != crl3\n        assert crl1 != object()\n\n    def test_comparison(self, backend):\n        crl1 = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n        with pytest.raises(TypeError):\n            crl1 < crl1  # type: ignore[operator]\n\n    def test_update_dates(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.warns(utils.DeprecatedIn42):\n            assert isinstance(crl.next_update, datetime.datetime)\n            assert isinstance(crl.last_update, datetime.datetime)\n            assert crl.next_update.isoformat() == \"2016-01-01T00:00:00\"\n            assert crl.last_update.isoformat() == \"2015-01-01T00:00:00\"\n\n        assert isinstance(crl.next_update_utc, datetime.datetime)\n        assert isinstance(crl.last_update_utc, datetime.datetime)\n        assert crl.next_update_utc.isoformat() == \"2016-01-01T00:00:00+00:00\"\n        assert crl.last_update_utc.isoformat() == \"2015-01-01T00:00:00+00:00\"\n\n    def test_no_next_update(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_no_next_update.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl.next_update is None\n        assert crl.next_update_utc is None\n\n    def test_unrecognized_extension(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_unrecognized_extension.der\"),\n            x509.load_der_x509_crl,\n        )\n        unrecognized = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4.5\"),\n            b\"abcdef\",\n        )\n        ext = crl.extensions.get_extension_for_oid(unrecognized.oid)\n        assert ext.value == unrecognized\n\n    def test_revoked_cert_retrieval(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        for r in crl:\n            assert isinstance(r, x509.RevokedCertificate)\n\n        # Check that len() works for CRLs.\n        assert len(crl) == 12\n        it = iter(crl)\n        assert len(typing.cast(typing.Sized, it)) == 12\n        next(it)\n        assert len(typing.cast(typing.Sized, it)) == 11\n\n    def test_get_revoked_certificate_by_serial_number(self, backend):\n        crl = _load_cert(\n            os.path.join(\n                \"x509\", \"PKITS_data\", \"crls\", \"LongSerialNumberCACRL.crl\"\n            ),\n            x509.load_der_x509_crl,\n        )\n        serial_number = 725064303890588110203033396814564464046290047507\n        revoked = crl.get_revoked_certificate_by_serial_number(serial_number)\n        assert isinstance(revoked, x509.RevokedCertificate)\n        assert revoked.serial_number == serial_number\n        assert crl.get_revoked_certificate_by_serial_number(500) is None\n\n    def test_revoked_cert_retrieval_retain_only_revoked(self, backend):\n        \"\"\"\n        This test attempts to trigger the crash condition described in\n        https://github.com/pyca/cryptography/issues/2557\n        PyPy does gc at its own pace, so it will only be reliable on CPython.\n        \"\"\"\n        revoked = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )[11]\n        with pytest.warns(utils.DeprecatedIn42):\n            assert revoked.revocation_date == datetime.datetime(\n                2015, 1, 1, 0, 0\n            )\n        assert revoked.revocation_date_utc == datetime.datetime(\n            2015, 1, 1, 0, 0, tzinfo=datetime.timezone.utc\n        )\n        assert revoked.serial_number == 11\n\n    def test_extensions(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_ian_aia_aki.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        crl_number = crl.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_NUMBER\n        )\n        aki = crl.extensions.get_extension_for_class(\n            x509.AuthorityKeyIdentifier\n        )\n        aia = crl.extensions.get_extension_for_class(\n            x509.AuthorityInformationAccess\n        )\n        ian = crl.extensions.get_extension_for_class(\n            x509.IssuerAlternativeName\n        )\n        assert crl_number.value == x509.CRLNumber(1)\n        assert crl_number.critical is False\n        assert aki.value == x509.AuthorityKeyIdentifier(\n            key_identifier=(b\"yu\\xbb\\x84:\\xcb,\\xdez\\t\\xbe1\\x1bC\\xbc\\x1c*MSX\"),\n            authority_cert_issuer=None,\n            authority_cert_serial_number=None,\n        )\n        assert aia.value == x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.DNSName(\"cryptography.io\"),\n                )\n            ]\n        )\n        assert ian.value == x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n\n    def test_delta_crl_indicator(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_delta_crl_indicator.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        dci = crl.extensions.get_extension_for_oid(\n            ExtensionOID.DELTA_CRL_INDICATOR\n        )\n        assert dci.value == x509.DeltaCRLIndicator(12345678901234567890)\n        assert dci.critical is True\n\n    def test_signature(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        assert crl.signature == binascii.unhexlify(\n            b\"536a5a0794f68267361e7bc2f19167a3e667a2ab141535616855d8deb2ba1af\"\n            b\"9fd4546b1fe76b454eb436af7b28229fedff4634dfc9dd92254266219ae0ea8\"\n            b\"75d9ff972e9a2da23d5945f073da18c50a4265bfed9ca16586347800ef49dd1\"\n            b\"6856d7265f4f3c498a57f04dc04404e2bd2e2ada1f5697057aacef779a18371\"\n            b\"c621edc9a5c2b8ec1716e8fa22feeb7fcec0ce9156c8d344aa6ae8d1a5d99d0\"\n            b\"9386df36307df3b63c83908f4a61a0ff604c1e292ad63b349d1082ddd7ae1b7\"\n            b\"c178bba995523ec6999310c54da5706549797bfb1230f5593ba7b4353dade4f\"\n            b\"d2be13a57580a6eb20b5c4083f000abac3bf32cd8b75f23e4c8f4b3a79e1e2d\"\n            b\"58a472b0\"\n        )\n\n    def test_tbs_certlist_bytes(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n            x509.load_der_x509_crl,\n        )\n\n        ca_cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n\n        public_key = ca_cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert crl.signature_hash_algorithm is not None\n        public_key.verify(\n            crl.signature,\n            crl.tbs_certlist_bytes,\n            padding.PKCS1v15(),\n            crl.signature_hash_algorithm,\n        )\n\n    def test_public_bytes_pem(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_empty.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        # Encode it to PEM and load it back.\n        crl = x509.load_pem_x509_crl(\n            crl.public_bytes(\n                encoding=serialization.Encoding.PEM,\n            ),\n        )\n\n        assert len(crl) == 0\n        _check_crl_times(\n            crl,\n            last_update=datetime.datetime(2015, 12, 20, 23, 44, 47),\n            next_update=datetime.datetime(2015, 12, 28, 0, 44, 47),\n        )\n\n    def test_public_bytes_der(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        # Encode it to DER and load it back.\n        crl = x509.load_der_x509_crl(\n            crl.public_bytes(\n                encoding=serialization.Encoding.DER,\n            ),\n        )\n\n        assert len(crl) == 12\n        _check_crl_times(\n            crl,\n            last_update=datetime.datetime(2015, 1, 1, 0, 0, 0),\n            next_update=datetime.datetime(2016, 1, 1, 0, 0, 0),\n        )\n\n    @pytest.mark.parametrize(\n        (\"cert_path\", \"loader_func\", \"encoding\"),\n        [\n            (\n                os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n                x509.load_pem_x509_crl,\n                serialization.Encoding.PEM,\n            ),\n            (\n                os.path.join(\"x509\", \"PKITS_data\", \"crls\", \"GoodCACRL.crl\"),\n                x509.load_der_x509_crl,\n                serialization.Encoding.DER,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, cert_path, loader_func, encoding, backend\n    ):\n        crl_bytes = load_vectors_from_file(\n            cert_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        crl = loader_func(crl_bytes, backend)\n        serialized = crl.public_bytes(encoding)\n        assert serialized == crl_bytes\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_empty.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(TypeError):\n            crl.public_bytes(\"NotAnEncoding\")  # type: ignore[arg-type]\n\n    def test_verify_bad(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"invalid_signature_crl.pem\"),\n            x509.load_pem_x509_crl,\n        )\n        crt = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"invalid_signature_cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        public_key = crt.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert not crl.is_signature_valid(public_key)\n\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_inner_outer_mismatch.der\"),\n            x509.load_der_x509_crl,\n        )\n        assert not crl.is_signature_valid(public_key)\n\n    def test_verify_good(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"valid_signature_crl.pem\"),\n            x509.load_pem_x509_crl,\n        )\n        crt = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"valid_signature_cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        public_key = crt.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert crl.is_signature_valid(public_key)\n\n    def test_verify_argument_must_be_a_public_key(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"valid_signature_crl.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(TypeError):\n            crl.is_signature_valid(\n                \"not a public key\"  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            crl.is_signature_valid(object)  # type: ignore[arg-type]\n\n\nclass TestRevokedCertificate:\n    def test_revoked_basics(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        for i, rev in enumerate(crl):\n            assert isinstance(rev, x509.RevokedCertificate)\n            assert isinstance(rev.serial_number, int)\n            with pytest.warns(utils.DeprecatedIn42):\n                assert isinstance(rev.revocation_date, datetime.datetime)\n            assert isinstance(rev.revocation_date_utc, datetime.datetime)\n            assert isinstance(rev.extensions, x509.Extensions)\n\n            assert rev.serial_number == i\n            with pytest.warns(utils.DeprecatedIn42):\n                assert rev.revocation_date.isoformat() == \"2015-01-01T00:00:00\"\n            assert (\n                rev.revocation_date_utc.isoformat()\n                == \"2015-01-01T00:00:00+00:00\"\n            )\n\n    def test_revoked_extensions(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        exp_issuer = [\n            x509.DirectoryName(\n                x509.Name(\n                    [\n                        x509.NameAttribute(x509.OID_COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(\n                            x509.OID_COMMON_NAME, \"cryptography.io\"\n                        ),\n                    ]\n                )\n            )\n        ]\n\n        # First revoked cert doesn't have extensions, test if it is handled\n        # correctly.\n        rev0 = crl[0]\n        # It should return an empty Extensions object.\n        assert isinstance(rev0.extensions, x509.Extensions)\n        assert len(rev0.extensions) == 0\n        with pytest.raises(x509.ExtensionNotFound):\n            rev0.extensions.get_extension_for_oid(x509.OID_CRL_REASON)\n        with pytest.raises(x509.ExtensionNotFound):\n            rev0.extensions.get_extension_for_oid(x509.OID_CERTIFICATE_ISSUER)\n        with pytest.raises(x509.ExtensionNotFound):\n            rev0.extensions.get_extension_for_oid(x509.OID_INVALIDITY_DATE)\n\n        # Test manual retrieval of extension values.\n        rev1 = crl[1]\n        assert isinstance(rev1.extensions, x509.Extensions)\n\n        reason = rev1.extensions.get_extension_for_class(x509.CRLReason).value\n        assert reason == x509.CRLReason(x509.ReasonFlags.unspecified)\n\n        issuer = rev1.extensions.get_extension_for_class(\n            x509.CertificateIssuer\n        ).value\n        assert issuer == x509.CertificateIssuer(exp_issuer)\n\n        date = rev1.extensions.get_extension_for_class(\n            x509.InvalidityDate\n        ).value\n        assert date == x509.InvalidityDate(datetime.datetime(2015, 1, 1, 0, 0))\n\n        # Check if all reason flags can be found in the CRL.\n        flags = set(x509.ReasonFlags)\n        for rev in crl:\n            try:\n                r = rev.extensions.get_extension_for_class(x509.CRLReason)\n            except x509.ExtensionNotFound:\n                # Not all revoked certs have a reason extension.\n                pass\n            else:\n                flags.discard(r.value.reason)\n\n        assert len(flags) == 0\n\n    def test_no_revoked_certs(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_empty.pem\"),\n            x509.load_pem_x509_crl,\n        )\n        assert len(crl) == 0\n\n    def test_duplicate_entry_ext(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_dup_entry_ext.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(x509.DuplicateExtension):\n            crl[0].extensions\n\n    def test_unsupported_crit_entry_ext(self, backend):\n        crl = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"crl_md2_unknown_crit_entry_ext.pem\"\n            ),\n            x509.load_pem_x509_crl,\n        )\n\n        ext = crl[0].extensions.get_extension_for_oid(\n            x509.ObjectIdentifier(\"1.2.3.4\")\n        )\n        assert isinstance(ext.value, x509.UnrecognizedExtension)\n        assert ext.value.value == b\"\\n\\x01\\x00\"\n\n    def test_unsupported_reason(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_unsupported_reason.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(ValueError):\n            crl[0].extensions\n\n    def test_invalid_cert_issuer_ext(self, backend):\n        crl = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"crl_inval_cert_issuer_entry_ext.pem\"\n            ),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(ValueError):\n            crl[0].extensions\n\n    def test_indexing(self, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"crl_all_reasons.pem\"),\n            x509.load_pem_x509_crl,\n        )\n\n        with pytest.raises(IndexError):\n            crl[-13]\n        with pytest.raises(IndexError):\n            crl[12]\n\n        assert crl[-1].serial_number == crl[11].serial_number\n        assert len(crl[2:4]) == 2\n        assert crl[2:4][0].serial_number == crl[2].serial_number\n        assert crl[2:4][1].serial_number == crl[3].serial_number\n\n    def test_get_revoked_certificate_doesnt_reorder(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n        for i in [2, 500, 3, 49, 7, 1]:\n            revoked_cert = (\n                x509.RevokedCertificateBuilder()\n                .serial_number(i)\n                .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n                .build(backend)\n            )\n            builder = builder.add_revoked_certificate(revoked_cert)\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert crl[0].serial_number == 2\n        assert crl[2].serial_number == 3\n        # make sure get_revoked_certificate_by_serial_number doesn't affect\n        # ordering after being invoked\n        crl.get_revoked_certificate_by_serial_number(500)\n        assert crl[0].serial_number == 2\n        assert crl[2].serial_number == 3\n\n\nclass TestRSAECertificate:\n    def test_load_cert_pub_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsae_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        expected_pub_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        ).public_key()\n        assert isinstance(expected_pub_key, rsa.RSAPublicKey)\n        pub_key = cert.public_key()\n        assert isinstance(pub_key, rsa.RSAPublicKey)\n        assert (\n            cert.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5\n        )\n        assert pub_key == expected_pub_key\n        pss = cert.signature_algorithm_parameters\n        assert isinstance(pss, padding.PSS)\n        assert isinstance(pss._mgf, padding.MGF1)\n        assert isinstance(pss._mgf._algorithm, hashes.SHA256)\n        assert pss._salt_length == 0x14\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n        pub_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            pss,\n            cert.signature_hash_algorithm,\n        )\n\n\nclass TestRSAPSSCertificate:\n    def test_load_cert_pub_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"rsa_pss_cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        expected_pub_key = _load_cert(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"rsa_pss_2048_pub.der\"),\n            serialization.load_der_public_key,\n        )\n        assert isinstance(expected_pub_key, rsa.RSAPublicKey)\n        pub_key = cert.public_key()\n        assert isinstance(pub_key, rsa.RSAPublicKey)\n        assert (\n            cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.RSASSA_PSS\n        )\n        assert pub_key == expected_pub_key\n        pss = cert.signature_algorithm_parameters\n        assert isinstance(pss, padding.PSS)\n        assert isinstance(pss._mgf, padding.MGF1)\n        assert isinstance(pss._mgf._algorithm, hashes.SHA256)\n        assert pss._salt_length == 222\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n        pub_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            pss,\n            cert.signature_hash_algorithm,\n        )\n\n    def test_load_pss_cert_no_null(self, backend):\n        \"\"\"\n        This test verifies that PSS certs where the hash algorithm\n        identifiers have no trailing null still load properly. LibreSSL\n        generates certs like this.\n        \"\"\"\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"rsa_pss_sha256_no_null.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        pss = cert.signature_algorithm_parameters\n        assert isinstance(pss, padding.PSS)\n        assert isinstance(pss._mgf, padding.MGF1)\n        assert isinstance(pss._mgf._algorithm, hashes.SHA256)\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n\n    def test_load_pss_sha1_mgf1_sha1(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ee-pss-sha1-cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        pub_key = cert.public_key()\n        assert isinstance(pub_key, rsa.RSAPublicKey)\n        pss = cert.signature_algorithm_parameters\n        assert isinstance(pss, padding.PSS)\n        assert isinstance(pss._mgf, padding.MGF1)\n        assert isinstance(pss._mgf._algorithm, hashes.SHA1)\n        assert pss._salt_length == 20\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)\n\n    def test_invalid_mgf(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"rsa_pss_cert_invalid_mgf.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.signature_algorithm_parameters\n\n    def test_unsupported_mgf_hash(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"rsa_pss_cert_unsupported_mgf_hash.der\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(UnsupportedAlgorithm):\n            cert.signature_algorithm_parameters\n\n    def test_no_sig_params(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"rsa_pss_cert_no_sig_params.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.signature_algorithm_parameters\n        with pytest.raises(ValueError):\n            cert.signature_hash_algorithm\n\n\nclass TestRSACertificate:\n    def test_load_pem_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        assert cert.serial_number == 11559813051657483483\n        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"2b619ed04bfc9c3b08eb677d272192286a0947a8\"\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)\n        assert (\n            cert.signature_algorithm_oid == SignatureAlgorithmOID.RSA_WITH_SHA1\n        )\n        assert isinstance(\n            cert.signature_algorithm_parameters, padding.PKCS1v15\n        )\n        assert isinstance(cert.public_key(), rsa.RSAPublicKey)\n        assert (\n            cert.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5\n        )\n\n    def test_check_pkcs1_signature_algorithm_parameters(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        assert isinstance(\n            cert.signature_algorithm_parameters, padding.PKCS1v15\n        )\n        pk = cert.public_key()\n        assert isinstance(pk, rsa.RSAPublicKey)\n        assert cert.signature_hash_algorithm is not None\n        pk.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            cert.signature_algorithm_parameters,\n            cert.signature_hash_algorithm,\n        )\n\n    def test_load_legacy_pem_header(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.old_header.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n\n    def test_load_with_other_sections(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.with_garbage.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.with_headers.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n\n    def test_load_multiple_sections(self, backend):\n        # We match OpenSSL's behavior of loading the first cert\n        # if there are multiple. Arguably this would ideally be an\n        # error, but \"load the first\" is a common expectation.\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.chain.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert2 = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert == cert2\n\n    def test_negative_serial_number(self, backend):\n        # We load certificates with negative serial numbers but on load\n        # and on access of the attribute we raise a warning\n        with pytest.warns(utils.DeprecatedIn36):\n            cert = _load_cert(\n                os.path.join(\"x509\", \"custom\", \"negative_serial.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n\n        with pytest.warns(utils.DeprecatedIn36):\n            assert cert.serial_number == -18008675309\n\n    def test_country_jurisdiction_country_too_long(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"bad_country.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.warns(UserWarning):\n            assert (\n                cert.subject.get_attributes_for_oid(x509.NameOID.COUNTRY_NAME)[\n                    0\n                ].value\n                == \"too long\"\n            )\n\n        with pytest.warns(UserWarning):\n            assert (\n                cert.subject.get_attributes_for_oid(\n                    x509.NameOID.JURISDICTION_COUNTRY_NAME\n                )[0].value\n                == \"also too long\"\n            )\n\n    def test_alternate_rsa_with_sha1_oid(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"alternate-rsa-sha1-oid.der\"),\n            x509.load_der_x509_certificate,\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)\n        assert (\n            cert.signature_algorithm_oid\n            == SignatureAlgorithmOID._RSA_WITH_SHA1\n        )\n        assert isinstance(cert.public_key(), rsa.RSAPublicKey)\n        assert (\n            cert.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5\n        )\n\n    def test_load_bmpstring_explicittext(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"accvraiz1.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.CertificatePolicies)\n        et = ext.value[0].policy_qualifiers[0].explicit_text\n        assert et == (\n            \"Autoridad de Certificaci\u00f3n Ra\u00edz de la ACCV (Agencia \"\n            \"de Tecnolog\u00eda y Certificaci\u00f3n Electr\u00f3nica, CIF Q4601\"\n            \"156E). CPS en http://www.accv.es\"\n        )\n\n    def test_load_der_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n        assert isinstance(cert, x509.Certificate)\n        assert cert.serial_number == 2\n        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"6f49779533d565e8b7c1062503eab41492c38e4d\"\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n\n    def test_signature(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.signature == binascii.unhexlify(\n            b\"8e0f72fcbebe4755abcaf76c8ce0bae17cde4db16291638e1b1ce04a93cdb4c\"\n            b\"44a3486070986c5a880c14fdf8497e7d289b2630ccb21d24a3d1aa1b2d87482\"\n            b\"07f3a1e16ccdf8daa8a7ea1a33d49774f513edf09270bd8e665b6300a10f003\"\n            b\"66a59076905eb63cf10a81a0ca78a6ef3127f6cb2f6fb7f947fce22a30d8004\"\n            b\"8c243ba2c1a54c425fe12310e8a737638f4920354d4cce25cbd9dea25e6a2fe\"\n            b\"0d8579a5c8d929b9275be221975479f3f75075bcacf09526523b5fd67f7683f\"\n            b\"3cda420fabb1e9e6fc26bc0649cf61bb051d6932fac37066bb16f55903dfe78\"\n            b\"53dc5e505e2a10fbba4f9e93a0d3b53b7fa34b05d7ba6eef869bfc34b8e514f\"\n            b\"d5419f75\"\n        )\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert len(cert.signature) == public_key.key_size // 8\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA-1 signature.\",\n    )\n    def test_tbs_certificate_bytes(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.tbs_certificate_bytes == binascii.unhexlify(\n            b\"308202d8a003020102020900a06cb4b955f7f4db300d06092a864886f70d010\"\n            b\"10505003058310b3009060355040613024155311330110603550408130a536f\"\n            b\"6d652d53746174653121301f060355040a1318496e7465726e6574205769646\"\n            b\"769747320507479204c74643111300f0603550403130848656c6c6f20434130\"\n            b\"1e170d3134313132363231343132305a170d3134313232363231343132305a3\"\n            b\"058310b3009060355040613024155311330110603550408130a536f6d652d53\"\n            b\"746174653121301f060355040a1318496e7465726e657420576964676974732\"\n            b\"0507479204c74643111300f0603550403130848656c6c6f2043413082012230\"\n            b\"0d06092a864886f70d01010105000382010f003082010a0282010100b03af70\"\n            b\"2059e27f1e2284b56bbb26c039153bf81f295b73a49132990645ede4d2da0a9\"\n            b\"13c42e7d38d3589a00d3940d194f6e6d877c2ef812da22a275e83d8be786467\"\n            b\"48b4e7f23d10e873fd72f57a13dec732fc56ab138b1bb308399bb412cd73921\"\n            b\"4ef714e1976e09603405e2556299a05522510ac4574db5e9cb2cf5f99e8f48c\"\n            b\"1696ab3ea2d6d2ddab7d4e1b317188b76a572977f6ece0a4ad396f0150e7d8b\"\n            b\"1a9986c0cb90527ec26ca56e2914c270d2a198b632fa8a2fda55079d3d39864\"\n            b\"b6fb96ddbe331cacb3cb8783a8494ccccd886a3525078847ca01ca5f803e892\"\n            b\"14403e8a4b5499539c0b86f7a0daa45b204a8e079d8a5b03db7ba1ba3d7011a\"\n            b\"70203010001a381bc3081b9301d0603551d0e04160414d8e89dc777e4472656\"\n            b\"f1864695a9f66b7b0400ae3081890603551d23048181307f8014d8e89dc777e\"\n            b\"4472656f1864695a9f66b7b0400aea15ca45a3058310b300906035504061302\"\n            b\"4155311330110603550408130a536f6d652d53746174653121301f060355040\"\n            b\"a1318496e7465726e6574205769646769747320507479204c74643111300f06\"\n            b\"03550403130848656c6c6f204341820900a06cb4b955f7f4db300c0603551d1\"\n            b\"3040530030101ff\"\n        )\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert cert.signature_hash_algorithm is not None\n        public_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            padding.PKCS1v15(),\n            cert.signature_hash_algorithm,\n        )\n\n    def test_tbs_precertificate_bytes_duplicate_extensions_raises(\n        self, backend\n    ):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"two_basic_constraints.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        with pytest.raises(\n            x509.DuplicateExtension,\n            match=\"Duplicate 2.5.29.19 extension found\",\n        ):\n            cert.tbs_precertificate_bytes\n\n    def test_tbs_precertificate_bytes_no_extensions_raises(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"v1_cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        with pytest.raises(\n            ValueError,\n            match=\"Could not find pre-certificate SCT list extension\",\n        ):\n            cert.tbs_precertificate_bytes\n\n    def test_tbs_precertificate_bytes_missing_extension_raises(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        # This cert doesn't have an SCT list extension, so it will throw a\n        # `ValueError` when we try to retrieve the property\n        with pytest.raises(\n            ValueError,\n            match=\"Could not find pre-certificate SCT list extension\",\n        ):\n            cert.tbs_precertificate_bytes\n\n    def test_tbs_precertificate_bytes_strips_scts(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography-scts.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        expected_tbs_precertificate_bytes = load_vectors_from_file(\n            filename=os.path.join(\"x509\", \"cryptography-scts-tbs-precert.der\"),\n            loader=lambda data: data.read(),\n            mode=\"rb\",\n        )\n        assert (\n            expected_tbs_precertificate_bytes == cert.tbs_precertificate_bytes\n        )\n        assert cert.tbs_precertificate_bytes != cert.tbs_certificate_bytes\n\n    def test_issuer(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"Validpre2000UTCnotBeforeDateTest3EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        issuer = cert.issuer\n        assert isinstance(issuer, x509.Name)\n        assert list(issuer) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(\n                NameOID.ORGANIZATION_NAME, \"Test Certificates 2011\"\n            ),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"Good CA\"),\n        ]\n        assert issuer.get_attributes_for_oid(NameOID.COMMON_NAME) == [\n            x509.NameAttribute(NameOID.COMMON_NAME, \"Good CA\")\n        ]\n\n    def test_all_issuer_name_types(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"all_supported_names.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        issuer = cert.issuer\n\n        assert isinstance(issuer, x509.Name)\n        assert list(issuer) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"CA\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Illinois\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Chicago\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Zero, LLC\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"One, LLC\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"common name 0\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"common name 1\"),\n            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, \"OU 0\"),\n            x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, \"OU 1\"),\n            x509.NameAttribute(NameOID.DN_QUALIFIER, \"dnQualifier0\"),\n            x509.NameAttribute(NameOID.DN_QUALIFIER, \"dnQualifier1\"),\n            x509.NameAttribute(NameOID.SERIAL_NUMBER, \"123\"),\n            x509.NameAttribute(NameOID.SERIAL_NUMBER, \"456\"),\n            x509.NameAttribute(NameOID.TITLE, \"Title 0\"),\n            x509.NameAttribute(NameOID.TITLE, \"Title 1\"),\n            x509.NameAttribute(NameOID.SURNAME, \"Surname 0\"),\n            x509.NameAttribute(NameOID.SURNAME, \"Surname 1\"),\n            x509.NameAttribute(NameOID.GIVEN_NAME, \"Given Name 0\"),\n            x509.NameAttribute(NameOID.GIVEN_NAME, \"Given Name 1\"),\n            x509.NameAttribute(NameOID.PSEUDONYM, \"Incognito 0\"),\n            x509.NameAttribute(NameOID.PSEUDONYM, \"Incognito 1\"),\n            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, \"Last Gen\"),\n            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, \"Next Gen\"),\n            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"dc0\"),\n            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"dc1\"),\n            x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"test0@test.local\"),\n            x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"test1@test.local\"),\n        ]\n\n    def test_subject(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"Validpre2000UTCnotBeforeDateTest3EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        subject = cert.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(\n                NameOID.ORGANIZATION_NAME, \"Test Certificates 2011\"\n            ),\n            x509.NameAttribute(\n                NameOID.COMMON_NAME,\n                \"Valid pre2000 UTC notBefore Date EE Certificate Test3\",\n            ),\n        ]\n        assert subject.get_attributes_for_oid(NameOID.COMMON_NAME) == [\n            x509.NameAttribute(\n                NameOID.COMMON_NAME,\n                \"Valid pre2000 UTC notBefore Date EE Certificate Test3\",\n            )\n        ]\n\n    def test_unicode_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"utf8_common_name.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.subject.get_attributes_for_oid(NameOID.COMMON_NAME) == [\n            x509.NameAttribute(NameOID.COMMON_NAME, \"We heart UTF8!\\u2122\")\n        ]\n        assert cert.issuer.get_attributes_for_oid(NameOID.COMMON_NAME) == [\n            x509.NameAttribute(NameOID.COMMON_NAME, \"We heart UTF8!\\u2122\")\n        ]\n\n    def test_invalid_unicode_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"invalid_utf8_common_name.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError, match=\"subject\"):\n            cert.subject\n        with pytest.raises(ValueError, match=\"issuer\"):\n            cert.issuer\n\n    def test_non_ascii_dns_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"utf8-dnsname.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        san = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        ).value\n\n        names = san.get_values_for_type(x509.DNSName)\n\n        assert names == [\n            \"partner.biztositas.hu\",\n            \"biztositas.hu\",\n            \"*.biztositas.hu\",\n            \"biztos\\xedt\\xe1s.hu\",\n            \"*.biztos\\xedt\\xe1s.hu\",\n            \"xn--biztosts-fza2j.hu\",\n            \"*.xn--biztosts-fza2j.hu\",\n        ]\n\n    def test_all_subject_name_types(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"all_supported_names.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        subject = cert.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"AU\"),\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"DE\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"California\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"New York\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"San Francisco\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Ithaca\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Org Zero, LLC\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Org One, LLC\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"CN 0\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"CN 1\"),\n            x509.NameAttribute(\n                NameOID.ORGANIZATIONAL_UNIT_NAME, \"Engineering 0\"\n            ),\n            x509.NameAttribute(\n                NameOID.ORGANIZATIONAL_UNIT_NAME, \"Engineering 1\"\n            ),\n            x509.NameAttribute(NameOID.DN_QUALIFIER, \"qualified0\"),\n            x509.NameAttribute(NameOID.DN_QUALIFIER, \"qualified1\"),\n            x509.NameAttribute(NameOID.SERIAL_NUMBER, \"789\"),\n            x509.NameAttribute(NameOID.SERIAL_NUMBER, \"012\"),\n            x509.NameAttribute(NameOID.TITLE, \"Title IX\"),\n            x509.NameAttribute(NameOID.TITLE, \"Title X\"),\n            x509.NameAttribute(NameOID.SURNAME, \"Last 0\"),\n            x509.NameAttribute(NameOID.SURNAME, \"Last 1\"),\n            x509.NameAttribute(NameOID.GIVEN_NAME, \"First 0\"),\n            x509.NameAttribute(NameOID.GIVEN_NAME, \"First 1\"),\n            x509.NameAttribute(NameOID.PSEUDONYM, \"Guy Incognito 0\"),\n            x509.NameAttribute(NameOID.PSEUDONYM, \"Guy Incognito 1\"),\n            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, \"32X\"),\n            x509.NameAttribute(NameOID.GENERATION_QUALIFIER, \"Dreamcast\"),\n            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"dc2\"),\n            x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"dc3\"),\n            x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"test2@test.local\"),\n            x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"test3@test.local\"),\n        ]\n\n    def test_load_good_ca_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2010, 1, 1, 8, 30),\n            not_valid_after=datetime.datetime(2030, 12, 31, 8, 30),\n        )\n        assert cert.serial_number == 2\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert cert.version is x509.Version.v3\n        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"6f49779533d565e8b7c1062503eab41492c38e4d\"\n\n    def test_utc_pre_2000_not_before_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"Validpre2000UTCnotBeforeDateTest3EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(1950, 1, 1, 12, 1),\n            not_valid_after=None,\n        )\n\n    def test_pre_2000_utc_not_after_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"Invalidpre2000UTCEEnotAfterDateTest7EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n\n        _check_cert_times(\n            cert,\n            not_valid_before=None,\n            not_valid_after=datetime.datetime(1999, 1, 1, 12, 1),\n        )\n\n    def test_post_2000_utc_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2014, 11, 26, 21, 41, 20),\n            not_valid_after=datetime.datetime(2014, 12, 26, 21, 41, 20),\n        )\n\n    def test_generalized_time_not_before_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"ValidGeneralizedTimenotBeforeDateTest4EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2002, 1, 1, 12, 1),\n            not_valid_after=datetime.datetime(2030, 12, 31, 8, 30),\n        )\n        assert cert.version is x509.Version.v3\n\n    def test_generalized_time_not_after_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"ValidGeneralizedTimenotAfterDateTest8EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2010, 1, 1, 8, 30),\n            not_valid_after=datetime.datetime(2050, 1, 1, 12, 1),\n        )\n        assert cert.version is x509.Version.v3\n\n    def test_invalid_version_cert(self, backend):\n        with pytest.raises(x509.InvalidVersion) as exc:\n            _load_cert(\n                os.path.join(\"x509\", \"custom\", \"invalid_version.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n\n        assert exc.value.parsed_version == 7\n\n    def test_invalid_visiblestring_in_explicit_text(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"belgian-eid-invalid-visiblestring.pem\",\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.warns(utils.DeprecatedIn41):\n            cp = cert.extensions.get_extension_for_class(\n                x509.CertificatePolicies\n            ).value\n        assert isinstance(cp, x509.CertificatePolicies)\n        assert cp[0].policy_qualifiers[1].explicit_text == (\n            \"Gebruik onderworpen aan aansprakelijkheidsbeperkingen, zie CPS \"\n            \"- Usage soumis \u00e0 des limitations de responsabilit\u00e9, voir CPS - \"\n            \"Verwendung unterliegt Haftungsbeschr\u00e4nkungen, gem\u00e4ss CPS\"\n        )\n\n    def test_eq(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert2 = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert == cert2\n\n    def test_ne(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert2 = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"ValidGeneralizedTimenotAfterDateTest8EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        assert cert != cert2\n        assert cert != object()\n\n    def test_ordering_unsupported(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert2 = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(TypeError, match=\"'>' not supported\"):\n            cert > cert2  # type: ignore[operator]\n\n    def test_hash(self, backend):\n        cert1 = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert2 = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"post2000utctime.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert3 = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"ValidGeneralizedTimenotAfterDateTest8EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n\n        assert hash(cert1) == hash(cert2)\n        assert hash(cert1) != hash(cert3)\n\n    def test_version_1_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"v1_cert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.version is x509.Version.v1\n\n    def test_invalid_pem(self, backend):\n        with pytest.raises(ValueError, match=\"Unable to load\"):\n            x509.load_pem_x509_certificate(b\"notacert\", backend)\n\n        crl = load_vectors_from_file(\n            filename=os.path.join(\"x509\", \"custom\", \"crl_empty.pem\"),\n            loader=lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError, match=\"Valid PEM but no\"):\n            x509.load_pem_x509_certificate(crl, backend)\n\n    def test_invalid_der(self, backend):\n        with pytest.raises(ValueError):\n            x509.load_der_x509_certificate(b\"notacert\", backend)\n\n    def test_unsupported_signature_hash_algorithm_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"verisign_md2_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with raises_unsupported_algorithm(None):\n            cert.signature_hash_algorithm\n\n    def test_public_bytes_pem(self, backend):\n        # Load an existing certificate.\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n\n        # Encode it to PEM and load it back.\n        cert = x509.load_pem_x509_certificate(\n            cert.public_bytes(\n                encoding=serialization.Encoding.PEM,\n            ),\n            backend,\n        )\n\n        # We should recover what we had to start with.\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2010, 1, 1, 8, 30),\n            not_valid_after=datetime.datetime(2030, 12, 31, 8, 30),\n        )\n        assert cert.serial_number == 2\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert cert.version is x509.Version.v3\n        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"6f49779533d565e8b7c1062503eab41492c38e4d\"\n\n    def test_public_bytes_der(self, backend):\n        # Load an existing certificate.\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n\n        # Encode it to DER and load it back.\n        cert = x509.load_der_x509_certificate(\n            cert.public_bytes(\n                encoding=serialization.Encoding.DER,\n            ),\n        )\n\n        # We should recover what we had to start with.\n        _check_cert_times(\n            cert,\n            not_valid_before=datetime.datetime(2010, 1, 1, 8, 30),\n            not_valid_after=datetime.datetime(2030, 12, 31, 8, 30),\n        )\n        assert cert.serial_number == 2\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert cert.version is x509.Version.v3\n        fingerprint = binascii.hexlify(cert.fingerprint(hashes.SHA1()))\n        assert fingerprint == b\"6f49779533d565e8b7c1062503eab41492c38e4d\"\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n\n        with pytest.raises(TypeError):\n            cert.public_bytes(\"NotAnEncoding\")  # type: ignore[arg-type]\n\n    @pytest.mark.parametrize(\n        (\"cert_path\", \"loader_func\", \"encoding\"),\n        [\n            (\n                os.path.join(\"x509\", \"v1_cert.pem\"),\n                x509.load_pem_x509_certificate,\n                serialization.Encoding.PEM,\n            ),\n            (\n                os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n                x509.load_der_x509_certificate,\n                serialization.Encoding.DER,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, cert_path, loader_func, encoding, backend\n    ):\n        cert_bytes = load_vectors_from_file(\n            cert_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        cert = loader_func(cert_bytes)\n        serialized = cert.public_bytes(encoding)\n        assert serialized == cert_bytes\n\n    def test_certificate_repr(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert repr(cert) == (\n            \"<Certificate(subject=<Name(OU=GT48742965,OU=See www.rapidssl.com\"\n            \"/resources/cps (c)14,OU=Domain Control Validated - RapidSSL(R),\"\n            \"CN=www.cryptography.io)>, ...)>\"\n        )\n\n    def test_parse_tls_feature_extension(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"tls-feature-ocsp-staple.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.TLSFeature)\n        assert ext.critical is False\n        assert ext.value == x509.TLSFeature(\n            [x509.TLSFeatureType.status_request]\n        )\n\n    def test_verify_directly_issued_by_rsa_pss(\n        self, rsa_key_2048: rsa.RSAPrivateKey\n    ):\n        subject_private_key = RSA_KEY_2048_ALT.private_key(\n            unsafe_skip_rsa_key_validation=True\n        )\n\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(1)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2030, 1, 1))\n        )\n        ca = builder.sign(rsa_key_2048, hashes.SHA256())\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"leaf\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .serial_number(100)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2025, 1, 1))\n        )\n        cert = builder.sign(\n            rsa_key_2048,\n            hashes.SHA256(),\n            rsa_padding=padding.PSS(\n                padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            ),\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_rsa(\n        self, rsa_key_2048: rsa.RSAPrivateKey\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = RSA_KEY_2048_ALT.private_key(\n            unsafe_skip_rsa_key_validation=True\n        )\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_rsa_bad_sig(\n        self, rsa_key_2048: rsa.RSAPrivateKey\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = RSA_KEY_2048_ALT.private_key(\n            unsafe_skip_rsa_key_validation=True\n        )\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert_bad_sig = _break_cert_sig(cert)\n        with pytest.raises(InvalidSignature):\n            cert_bad_sig.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_rsa_mismatched_inner_out_oid(self):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"mismatch_inner_outer_sig_algorithm.der\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError) as exc:\n            cert.verify_directly_issued_by(cert)\n\n        assert str(exc.value) == (\n            \"Inner and outer signature algorithms do not match. This is an \"\n            \"invalid certificate.\"\n        )\n\n    def test_verify_directly_issued_by_subject_issuer_mismatch(self):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError) as exc:\n            cert.verify_directly_issued_by(cert)\n\n        assert str(exc.value) == (\n            \"Issuer certificate subject does not match certificate issuer.\"\n        )\n\n    def test_verify_directly_issued_by_algorithm_mismatch(\n        self, rsa_key_2048: rsa.RSAPrivateKey\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = RSA_KEY_2048_ALT.private_key(\n            unsafe_skip_rsa_key_validation=True\n        )\n        _, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        # We need a CA with the same issuer DN but diff signature algorithm\n        secondary_issuer_key = ec.generate_private_key(ec.SECP256R1())\n        ca2, _ = _generate_ca_and_leaf(\n            secondary_issuer_key, subject_private_key\n        )\n        with pytest.raises(ValueError):\n            cert.verify_directly_issued_by(ca2)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.ed25519_supported() and backend.x25519_supported()\n        ),\n        skip_message=\"Requires OpenSSL with Ed25519 and X25519 support\",\n    )\n    def test_verify_directly_issued_by_unsupported_key_type(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        x25519_public = x25519.X25519PrivateKey.generate().public_key()\n        # Generate an ed25519 CA\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .public_key(private_key.public_key())\n            .serial_number(1)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2030, 1, 1))\n        )\n        cert = builder.sign(private_key, None)\n        # Make a cert with the right issuer name but the wrong public key\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"PyCA CA\")])\n            )\n            .public_key(x25519_public)\n            .serial_number(1)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2030, 1, 1))\n        )\n        leaf = builder.sign(private_key, None)\n\n        with pytest.raises(TypeError):\n            cert.verify_directly_issued_by(leaf)\n\n\nclass TestRSACertificateRequest:\n    @pytest.mark.parametrize(\n        (\"path\", \"loader_func\"),\n        [\n            [\n                os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n                x509.load_pem_x509_csr,\n            ],\n            [\n                os.path.join(\"x509\", \"requests\", \"rsa_sha1.der\"),\n                x509.load_der_x509_csr,\n            ],\n        ],\n    )\n    def test_load_rsa_certificate_request(self, path, loader_func, backend):\n        request = _load_cert(path, loader_func)\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)\n        assert (\n            request.signature_algorithm_oid\n            == SignatureAlgorithmOID.RSA_WITH_SHA1\n        )\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert (\n            request.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5\n        )\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n        ]\n        extensions = request.extensions\n        assert isinstance(extensions, x509.Extensions)\n        assert list(extensions) == []\n\n    def test_load_legacy_pem_header(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"ec_sha256_old_header.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert isinstance(cert, x509.CertificateSigningRequest)\n\n    def test_invalid_pem(self, backend):\n        with pytest.raises(ValueError, match=\"Unable to load\"):\n            x509.load_pem_x509_csr(b\"notacsr\")\n\n        crl = load_vectors_from_file(\n            filename=os.path.join(\"x509\", \"custom\", \"crl_empty.pem\"),\n            loader=lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError, match=\"Valid PEM but no\"):\n            x509.load_pem_x509_csr(crl)\n\n    @pytest.mark.parametrize(\n        \"loader_func\", [x509.load_pem_x509_csr, x509.load_der_x509_csr]\n    )\n    def test_invalid_certificate_request(self, loader_func, backend):\n        with pytest.raises(ValueError):\n            loader_func(b\"notacsr\")\n\n    def test_unsupported_signature_hash_algorithm_request(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_md4.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with raises_unsupported_algorithm(None):\n            request.signature_hash_algorithm\n\n    def test_invalid_version(self, backend):\n        with pytest.raises(x509.InvalidVersion):\n            _load_cert(\n                os.path.join(\"x509\", \"requests\", \"bad-version.pem\"),\n                x509.load_pem_x509_csr,\n            )\n\n    def test_duplicate_extension(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"two_basic_constraints.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.raises(x509.DuplicateExtension) as exc:\n            request.extensions\n\n        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS\n\n    def test_unsupported_critical_extension(self, backend):\n        request = _load_cert(\n            os.path.join(\n                \"x509\", \"requests\", \"unsupported_extension_critical.pem\"\n            ),\n            x509.load_pem_x509_csr,\n        )\n        ext = request.extensions.get_extension_for_oid(\n            x509.ObjectIdentifier(\"1.2.3.4\")\n        )\n        assert isinstance(ext.value, x509.UnrecognizedExtension)\n        assert ext.value.value == b\"value\"\n\n    def test_unsupported_extension(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"unsupported_extension.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        extensions = request.extensions\n        assert len(extensions) == 1\n        assert extensions[0].oid == x509.ObjectIdentifier(\"1.2.3.4\")\n        assert extensions[0].value == x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"value\"\n        )\n\n    def test_no_extension_with_other_attributes(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"challenge-unstructured.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert len(request.extensions) == 0\n\n    def test_request_basic_constraints(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"basic_constraints.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        extensions = request.extensions\n        assert isinstance(extensions, x509.Extensions)\n        assert list(extensions) == [\n            x509.Extension(\n                ExtensionOID.BASIC_CONSTRAINTS,\n                True,\n                x509.BasicConstraints(ca=True, path_length=1),\n            ),\n        ]\n\n    def test_subject_alt_name(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"san_rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        ext = request.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert list(ext.value) == [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"sub.cryptography.io\"),\n        ]\n\n    def test_freeipa_bad_critical(self, backend):\n        csr = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"freeipa-bad-critical.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.raises(ValueError):\n            csr.extensions\n\n    def test_public_bytes_pem(self, backend):\n        # Load an existing CSR.\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        # Encode it to PEM and load it back.\n        request = x509.load_pem_x509_csr(\n            request.public_bytes(\n                encoding=serialization.Encoding.PEM,\n            ),\n        )\n\n        # We should recover what we had to start with.\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n        ]\n\n    def test_public_bytes_der(self, backend):\n        # Load an existing CSR.\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        # Encode it to DER and load it back.\n        request = x509.load_der_x509_csr(\n            request.public_bytes(\n                encoding=serialization.Encoding.DER,\n            ),\n        )\n\n        # We should recover what we had to start with.\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n        ]\n\n    def test_signature(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.signature == binascii.unhexlify(\n            b\"8364c86ffbbfe0bfc9a21f831256658ca8989741b80576d36f08a934603a43b1\"\n            b\"837246d00167a518abb1de7b51a1e5b7ebea14944800818b1a923c804f120a0d\"\n            b\"624f6310ef79e8612755c2b01dcc7f59dfdbce0db3f2630f185f504b8c17af80\"\n            b\"cbd364fa5fda68337153930948226cd4638287a0aed6524d3006885c19028a1e\"\n            b\"e2f5a91d6e77dbaa0b49996ee0a0c60b55b61bd080a08bb34aa7f3e07e91f37f\"\n            b\"6a11645be2d8654c1570dcda145ed7cc92017f7d53225d7f283f3459ec5bda41\"\n            b\"cf6dd75d43676c543483385226b7e4fa29c8739f1b0eaf199613593991979862\"\n            b\"e36181e8c4c270c354b7f52c128db1b70639823324c7ea24791b7bc3d7005f3b\"\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA-1 signature.\",\n    )\n    def test_tbs_certrequest_bytes(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.tbs_certrequest_bytes == binascii.unhexlify(\n            b\"308201840201003057310b3009060355040613025553310e300c060355040813\"\n            b\"055465786173310f300d0603550407130641757374696e310d300b060355040a\"\n            b\"130450794341311830160603550403130f63727970746f6772617068792e696f\"\n            b\"30820122300d06092a864886f70d01010105000382010f003082010a02820101\"\n            b\"00a840a78460cb861066dfa3045a94ba6cf1b7ab9d24c761cffddcc2cb5e3f1d\"\n            b\"c3e4be253e7039ef14fe9d6d2304f50d9f2e1584c51530ab75086f357138bff7\"\n            b\"b854d067d1d5f384f1f2f2c39cc3b15415e2638554ef8402648ae3ef08336f22\"\n            b\"b7ecc6d4331c2b21c3091a7f7a9518180754a646640b60419e4cc6f5c798110a\"\n            b\"7f030a639fe87e33b4776dfcd993940ec776ab57a181ad8598857976dc303f9a\"\n            b\"573ca619ab3fe596328e92806b828683edc17cc256b41948a2bfa8d047d2158d\"\n            b\"3d8e069aa05fa85b3272abb1c4b4422b6366f3b70e642377b145cd6259e5d3e7\"\n            b\"db048d51921e50766a37b1b130ee6b11f507d20a834001e8de16a92c14f2e964\"\n            b\"a30203010001a000\"\n        )\n        assert request.signature_hash_algorithm is not None\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        public_key.verify(\n            request.signature,\n            request.tbs_certrequest_bytes,\n            padding.PKCS1v15(),\n            request.signature_hash_algorithm,\n        )\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        with pytest.raises(TypeError):\n            request.public_bytes(\"NotAnEncoding\")  # type: ignore[arg-type]\n\n    def test_signature_invalid(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"invalid_signature.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert not request.is_signature_valid\n\n    def test_signature_valid(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.is_signature_valid\n\n    @pytest.mark.parametrize(\n        (\"request_path\", \"loader_func\", \"encoding\"),\n        [\n            (\n                os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n                x509.load_pem_x509_csr,\n                serialization.Encoding.PEM,\n            ),\n            (\n                os.path.join(\"x509\", \"requests\", \"rsa_sha1.der\"),\n                x509.load_der_x509_csr,\n                serialization.Encoding.DER,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, request_path, loader_func, encoding, backend\n    ):\n        request_bytes = load_vectors_from_file(\n            request_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        request = loader_func(request_bytes)\n        serialized = request.public_bytes(encoding)\n        assert serialized == request_bytes\n\n    def test_eq(self, backend):\n        request1 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        request2 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        assert request1 == request2\n\n    def test_ne(self, backend):\n        request1 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        request2 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"san_rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        assert request1 != request2\n        assert request1 != object()\n\n    def test_ordering_unsupported(self, backend):\n        csr = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        csr2 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.raises(TypeError, match=\"'>' not supported\"):\n            csr > csr2  # type: ignore[operator]\n\n    def test_hash(self, backend):\n        request1 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        request2 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        request3 = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"san_rsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n\n        assert hash(request1) == hash(request2)\n        assert hash(request1) != hash(request3)\n\n    @pytest.mark.parametrize(\n        (\"hashalg\", \"hashalg_oid\"),\n        [\n            (hashes.SHA224, x509.SignatureAlgorithmOID.RSA_WITH_SHA224),\n            (hashes.SHA256, x509.SignatureAlgorithmOID.RSA_WITH_SHA256),\n            (hashes.SHA384, x509.SignatureAlgorithmOID.RSA_WITH_SHA384),\n            (hashes.SHA512, x509.SignatureAlgorithmOID.RSA_WITH_SHA512),\n            (hashes.SHA3_224, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_224),\n            (hashes.SHA3_256, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_256),\n            (hashes.SHA3_384, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_384),\n            (hashes.SHA3_512, x509.SignatureAlgorithmOID.RSA_WITH_SHA3_512),\n        ],\n    )\n    def test_build_cert(\n        self, rsa_key_2048: rsa.RSAPrivateKey, hashalg, hashalg_oid, backend\n    ):\n        if not backend.signature_hash_supported(hashalg()):\n            pytest.skip(f\"{hashalg} signature not supported\")\n\n        issuer_private_key = rsa_key_2048\n        subject_private_key = rsa_key_2048\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                        x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io\"\n                        ),\n                    ]\n                )\n            )\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                        x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io\"\n                        ),\n                    ]\n                )\n            )\n            .public_key(subject_private_key.public_key())\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashalg(), backend)\n\n        assert cert.version is x509.Version.v3\n        public_key = cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        assert (\n            cert.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5\n        )\n        assert cert.signature_algorithm_oid == hashalg_oid\n        assert type(cert.signature_hash_algorithm) is hashalg\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        basic_constraints = cert.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n        subject_alternative_name = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(\n            subject_alternative_name.value, x509.SubjectAlternativeName\n        )\n        assert list(subject_alternative_name.value) == [\n            x509.DNSName(\"cryptography.io\"),\n        ]\n\n    def test_build_cert_private_type_encoding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = rsa_key_2048\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n        name = x509.Name(\n            [\n                x509.NameAttribute(\n                    NameOID.STATE_OR_PROVINCE_NAME,\n                    \"Texas\",\n                    _ASN1Type.PrintableString,\n                ),\n                x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n                x509.NameAttribute(\n                    NameOID.COMMON_NAME,\n                    \"cryptography.io\",\n                    _ASN1Type.IA5String,\n                ),\n            ]\n        )\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(name)\n            .subject_name(name)\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)\n\n        for dn in (cert.subject, cert.issuer):\n            assert (\n                dn.get_attributes_for_oid(NameOID.STATE_OR_PROVINCE_NAME)[\n                    0\n                ]._type\n                == _ASN1Type.PrintableString\n            )\n            assert (\n                dn.get_attributes_for_oid(NameOID.STATE_OR_PROVINCE_NAME)[\n                    0\n                ]._type\n                == _ASN1Type.PrintableString\n            )\n            assert (\n                dn.get_attributes_for_oid(NameOID.LOCALITY_NAME)[0]._type\n                == _ASN1Type.UTF8String\n            )\n\n    def test_build_cert_printable_string_country_name(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = rsa_key_2048\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(\n                            NameOID.JURISDICTION_COUNTRY_NAME, \"US\"\n                        ),\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(\n                            NameOID.JURISDICTION_COUNTRY_NAME, \"US\"\n                        ),\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)\n\n        parsed = asn1.test_parse_certificate(\n            cert.public_bytes(serialization.Encoding.DER)\n        )\n\n        # Check that each value was encoded as an ASN.1 PRINTABLESTRING.\n        assert parsed.issuer_value_tags[0] == 0x13\n        assert parsed.subject_value_tags[0] == 0x13\n        assert parsed.issuer_value_tags[1] == 0x13\n        assert parsed.subject_value_tags[1] == 0x13\n\n\nclass TestCertificateBuilder:\n    def test_checks_for_unsupported_extensions(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(private_key.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(1999, 1, 1))\n            .not_valid_after(datetime.datetime(2020, 1, 1))\n            .add_extension(DummyExtension(), False)\n        )\n\n        with pytest.raises(NotImplementedError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_encode_nonstandard_aia(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    x509.ObjectIdentifier(\"2.999.7\"),\n                    x509.UniformResourceIdentifier(\"http://example.com\"),\n                ),\n            ]\n        )\n\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(private_key.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(1999, 1, 1))\n            .not_valid_after(datetime.datetime(2020, 1, 1))\n            .add_extension(aia, False)\n        )\n\n        builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_encode_nonstandard_sia(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    x509.ObjectIdentifier(\"2.999.7\"),\n                    x509.UniformResourceIdentifier(\"http://example.com\"),\n                ),\n            ]\n        )\n\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(private_key.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2015, 1, 1))\n            .not_valid_after(datetime.datetime(2040, 1, 1))\n            .add_extension(sia, False)\n        )\n\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_INFORMATION_ACCESS\n        )\n        assert ext.value == sia\n\n    def test_subject_dn_asn1_types(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        name = x509.Name(\n            [\n                x509.NameAttribute(NameOID.COMMON_NAME, \"mysite.com\"),\n                x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                x509.NameAttribute(NameOID.LOCALITY_NAME, \"value\"),\n                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"value\"),\n                x509.NameAttribute(NameOID.STREET_ADDRESS, \"value\"),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"value\"),\n                x509.NameAttribute(NameOID.ORGANIZATIONAL_UNIT_NAME, \"value\"),\n                x509.NameAttribute(NameOID.SERIAL_NUMBER, \"value\"),\n                x509.NameAttribute(NameOID.SURNAME, \"value\"),\n                x509.NameAttribute(NameOID.GIVEN_NAME, \"value\"),\n                x509.NameAttribute(NameOID.TITLE, \"value\"),\n                x509.NameAttribute(NameOID.GENERATION_QUALIFIER, \"value\"),\n                x509.NameAttribute(NameOID.X500_UNIQUE_IDENTIFIER, \"value\"),\n                x509.NameAttribute(NameOID.DN_QUALIFIER, \"value\"),\n                x509.NameAttribute(NameOID.PSEUDONYM, \"value\"),\n                x509.NameAttribute(NameOID.USER_ID, \"value\"),\n                x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"value\"),\n                x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"value\"),\n                x509.NameAttribute(NameOID.JURISDICTION_COUNTRY_NAME, \"US\"),\n                x509.NameAttribute(\n                    NameOID.JURISDICTION_LOCALITY_NAME, \"value\"\n                ),\n                x509.NameAttribute(\n                    NameOID.JURISDICTION_STATE_OR_PROVINCE_NAME, \"value\"\n                ),\n                x509.NameAttribute(NameOID.BUSINESS_CATEGORY, \"value\"),\n                x509.NameAttribute(NameOID.POSTAL_ADDRESS, \"value\"),\n                x509.NameAttribute(NameOID.POSTAL_CODE, \"value\"),\n            ]\n        )\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(name)\n            .issuer_name(name)\n            .public_key(private_key.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(1999, 1, 1))\n            .not_valid_after(datetime.datetime(2020, 1, 1))\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        for dn in (cert.subject, cert.issuer):\n            for oid, asn1_type in TestNameAttribute.EXPECTED_TYPES:\n                assert dn.get_attributes_for_oid(oid)[0]._type == asn1_type\n\n    @pytest.mark.parametrize(\n        (\"not_valid_before\", \"not_valid_after\"),\n        [\n            [datetime.datetime(1970, 2, 1), datetime.datetime(9999, 1, 1)],\n            [datetime.datetime(1970, 2, 1), datetime.datetime(9999, 12, 31)],\n        ],\n    )\n    def test_extreme_times(\n        self,\n        rsa_key_2048: rsa.RSAPrivateKey,\n        not_valid_before,\n        not_valid_after,\n        backend,\n    ):\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(private_key.public_key())\n            .serial_number(777)\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        parsed = asn1.test_parse_certificate(\n            cert.public_bytes(serialization.Encoding.DER)\n        )\n        # UTC TIME\n        assert parsed.not_before_tag == 0x17\n        # GENERALIZED TIME\n        assert parsed.not_after_tag == 0x18\n\n    def test_rdns_preserve_iteration_order(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        \"\"\"\n        This test checks that RDN ordering is consistent when loading\n        data from a certificate. Since the underlying RDN is an ASN.1\n        set these values get lexicographically ordered on encode and\n        the parsed value won't necessarily be in the same order as\n        the originally provided list. However, we want to make sure\n        that the order is always consistent since it confuses people\n        when it isn't.\n        \"\"\"\n        name = x509.Name(\n            [\n                x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(NameOID.TITLE, \"Test\"),\n                        x509.NameAttribute(NameOID.COMMON_NAME, \"Multivalue\"),\n                        x509.NameAttribute(NameOID.SURNAME, \"RDNs\"),\n                    ]\n                ),\n            ]\n        )\n\n        cert = (\n            x509.CertificateBuilder()\n            .serial_number(1)\n            .issuer_name(name)\n            .subject_name(name)\n            .public_key(rsa_key_2048.public_key())\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n            .sign(rsa_key_2048, hashes.SHA256(), backend)\n        )\n        loaded_cert = x509.load_pem_x509_certificate(\n            cert.public_bytes(encoding=serialization.Encoding.PEM)\n        )\n        assert next(iter(loaded_cert.subject.rdns[0])) == x509.NameAttribute(\n            NameOID.SURNAME, \"RDNs\"\n        )\n\n    @pytest.mark.parametrize(\n        (\"alg\", \"mgf_alg\"),\n        [\n            (hashes.SHA512(), hashes.SHA256()),\n            (hashes.SHA3_512(), hashes.SHA3_256()),\n        ],\n    )\n    def test_sign_pss(\n        self, rsa_key_2048: rsa.RSAPrivateKey, alg, mgf_alg, backend\n    ):\n        if not backend.signature_hash_supported(alg):\n            pytest.skip(f\"{alg} signature not supported\")\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(mgf_alg), salt_length=alg.digest_size\n        )\n        cert = builder.sign(rsa_key_2048, alg, rsa_padding=pss)\n        pk = cert.public_key()\n        assert isinstance(pk, rsa.RSAPublicKey)\n        assert isinstance(cert.signature_hash_algorithm, type(alg))\n        cert_params = cert.signature_algorithm_parameters\n        assert isinstance(cert_params, padding.PSS)\n        assert cert_params._salt_length == pss._salt_length\n        assert isinstance(cert_params._mgf, padding.MGF1)\n        assert isinstance(cert_params._mgf._algorithm, type(mgf_alg))\n        pk.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            cert_params,\n            alg,\n        )\n\n    @pytest.mark.parametrize(\n        (\"padding_len\", \"computed_len\"),\n        [\n            (padding.PSS.MAX_LENGTH, 222),\n            (padding.PSS.DIGEST_LENGTH, 32),\n        ],\n    )\n    def test_sign_pss_length_options(\n        self,\n        rsa_key_2048: rsa.RSAPrivateKey,\n        padding_len,\n        computed_len,\n        backend,\n    ):\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()), salt_length=padding_len\n        )\n        cert = builder.sign(rsa_key_2048, hashes.SHA256(), rsa_padding=pss)\n        assert isinstance(cert.signature_algorithm_parameters, padding.PSS)\n        assert cert.signature_algorithm_parameters._salt_length == computed_len\n\n    def test_sign_pss_auto_unsupported(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.AUTO\n        )\n        with pytest.raises(TypeError):\n            builder.sign(rsa_key_2048, hashes.SHA256(), rsa_padding=pss)\n\n    def test_sign_invalid_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n        )\n        with pytest.raises(TypeError):\n            builder.sign(\n                rsa_key_2048,\n                hashes.SHA256(),\n                rsa_padding=b\"notapadding\",  # type: ignore[arg-type]\n            )\n        eckey = ec.generate_private_key(ec.SECP256R1())\n        with pytest.raises(TypeError):\n            builder.sign(\n                eckey, hashes.SHA256(), rsa_padding=padding.PKCS1v15()\n            )\n\n    def test_sign_pss_hash_none(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(rsa_key_2048.public_key())\n            .serial_number(777)\n            .not_valid_before(datetime.datetime(2020, 1, 1))\n            .not_valid_after(datetime.datetime(2038, 1, 1))\n        )\n        pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32)\n        with pytest.raises(TypeError):\n            builder.sign(rsa_key_2048, None, rsa_padding=pss)\n\n    def test_no_subject_name(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_no_issuer_name(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_no_public_key(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_no_not_valid_before(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_no_not_valid_after(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_no_serial_number(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        with pytest.raises(ValueError):\n            builder.sign(subject_private_key, hashes.SHA256(), backend)\n\n    def test_issuer_name_must_be_a_name_type(self):\n        builder = x509.CertificateBuilder()\n\n        with pytest.raises(TypeError):\n            builder.issuer_name(\"subject\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            builder.issuer_name(object)  # type:ignore[arg-type]\n\n    def test_issuer_name_may_only_be_set_once(self):\n        name = x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        builder = x509.CertificateBuilder().issuer_name(name)\n\n        with pytest.raises(ValueError):\n            builder.issuer_name(name)\n\n    def test_subject_name_must_be_a_name_type(self):\n        builder = x509.CertificateBuilder()\n\n        with pytest.raises(TypeError):\n            builder.subject_name(\"subject\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            builder.subject_name(object)  # type:ignore[arg-type]\n\n    def test_subject_name_may_only_be_set_once(self):\n        name = x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        builder = x509.CertificateBuilder().subject_name(name)\n\n        with pytest.raises(ValueError):\n            builder.subject_name(name)\n\n    def test_not_valid_before_after_not_valid_after(self):\n        builder = x509.CertificateBuilder()\n\n        builder = builder.not_valid_after(datetime.datetime(2002, 1, 1, 12, 1))\n        with pytest.raises(ValueError):\n            builder.not_valid_before(datetime.datetime(2003, 1, 1, 12, 1))\n\n    def test_not_valid_after_before_not_valid_before(self):\n        builder = x509.CertificateBuilder()\n\n        builder = builder.not_valid_before(\n            datetime.datetime(2002, 1, 1, 12, 1)\n        )\n        with pytest.raises(ValueError):\n            builder.not_valid_after(datetime.datetime(2001, 1, 1, 12, 1))\n\n    def test_public_key_must_be_public_key(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        builder = x509.CertificateBuilder()\n\n        with pytest.raises(TypeError):\n            builder.public_key(private_key)  # type: ignore[arg-type]\n\n    def test_public_key_may_only_be_set_once(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        builder = x509.CertificateBuilder().public_key(public_key)\n\n        with pytest.raises(ValueError):\n            builder.public_key(public_key)\n\n    def test_serial_number_must_be_an_integer_type(self):\n        with pytest.raises(TypeError):\n            x509.CertificateBuilder().serial_number(\n                10.0  # type:ignore[arg-type]\n            )\n\n    def test_serial_number_must_be_non_negative(self):\n        with pytest.raises(ValueError):\n            x509.CertificateBuilder().serial_number(-1)\n\n    def test_serial_number_must_be_positive(self):\n        with pytest.raises(ValueError):\n            x509.CertificateBuilder().serial_number(0)\n\n    def test_minimal_serial_number(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(1)\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"RU\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"RU\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        cert = builder.sign(subject_private_key, hashes.SHA256(), backend)\n        assert cert.serial_number == 1\n\n    def test_biggest_serial_number(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        subject_private_key = rsa_key_2048\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number((1 << 159) - 1)\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"RU\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"RU\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n        )\n        cert = builder.sign(subject_private_key, hashes.SHA256(), backend)\n        assert cert.serial_number == (1 << 159) - 1\n\n    def test_serial_number_must_be_less_than_160_bits_long(self):\n        with pytest.raises(ValueError):\n            x509.CertificateBuilder().serial_number(1 << 159)\n\n    def test_serial_number_may_only_be_set_once(self):\n        builder = x509.CertificateBuilder().serial_number(10)\n\n        with pytest.raises(ValueError):\n            builder.serial_number(20)\n\n    def test_aware_not_valid_after(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        tz = datetime.timezone(datetime.timedelta(hours=-8))\n        time = datetime.datetime(2012, 1, 16, 22, 43, tzinfo=tz)\n        utc_time = datetime.datetime(2012, 1, 17, 6, 43)\n        private_key = rsa_key_2048\n        cert_builder = x509.CertificateBuilder().not_valid_after(time)\n        cert_builder = (\n            cert_builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(utc_time - datetime.timedelta(days=365))\n        )\n\n        cert = cert_builder.sign(private_key, hashes.SHA256(), backend)\n        _check_cert_times(\n            cert, not_valid_before=None, not_valid_after=utc_time\n        )\n\n    def test_earliest_time(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        time = datetime.datetime(1950, 1, 1)\n        private_key = rsa_key_2048\n        cert_builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(time)\n            .not_valid_after(time)\n        )\n        cert = cert_builder.sign(private_key, hashes.SHA256(), backend)\n        _check_cert_times(cert, not_valid_before=time, not_valid_after=time)\n        parsed = asn1.test_parse_certificate(\n            cert.public_bytes(serialization.Encoding.DER)\n        )\n        # UTC TIME\n        assert parsed.not_before_tag == 0x17\n        assert parsed.not_after_tag == 0x17\n\n    def test_invalid_not_valid_after(self):\n        with pytest.raises(TypeError):\n            x509.CertificateBuilder().not_valid_after(\n                104204304504  # type:ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            x509.CertificateBuilder().not_valid_after(\n                datetime.time()  # type:ignore[arg-type]\n            )\n\n        with pytest.raises(ValueError):\n            x509.CertificateBuilder().not_valid_after(\n                datetime.datetime(1940, 8, 10)\n            )\n\n    def test_not_valid_after_may_only_be_set_once(self):\n        builder = x509.CertificateBuilder().not_valid_after(\n            datetime.datetime.now()\n        )\n\n        with pytest.raises(ValueError):\n            builder.not_valid_after(datetime.datetime.now())\n\n    def test_aware_not_valid_before(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        tz = datetime.timezone(datetime.timedelta(hours=-8))\n        time = datetime.datetime(2012, 1, 16, 22, 43, tzinfo=tz)\n        utc_time = datetime.datetime(2012, 1, 17, 6, 43)\n        private_key = rsa_key_2048\n        cert_builder = x509.CertificateBuilder().not_valid_before(time)\n        cert_builder = (\n            cert_builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_after(utc_time + datetime.timedelta(days=366))\n        )\n\n        cert = cert_builder.sign(private_key, hashes.SHA256(), backend)\n        _check_cert_times(\n            cert, not_valid_before=utc_time, not_valid_after=None\n        )\n\n    def test_invalid_not_valid_before(self):\n        with pytest.raises(TypeError):\n            x509.CertificateBuilder().not_valid_before(\n                104204304504  # type:ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            x509.CertificateBuilder().not_valid_before(\n                datetime.time()  # type:ignore[arg-type]\n            )\n\n        with pytest.raises(ValueError):\n            x509.CertificateBuilder().not_valid_before(\n                datetime.datetime(1940, 8, 10)\n            )\n\n    def test_not_valid_before_may_only_be_set_once(self):\n        builder = x509.CertificateBuilder().not_valid_before(\n            datetime.datetime.now()\n        )\n\n        with pytest.raises(ValueError):\n            builder.not_valid_before(datetime.datetime.now())\n\n    def test_add_extension_checks_for_duplicates(self):\n        builder = x509.CertificateBuilder().add_extension(\n            x509.BasicConstraints(ca=False, path_length=None),\n            True,\n        )\n\n        with pytest.raises(ValueError):\n            builder.add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n\n    def test_add_invalid_extension_type(self):\n        builder = x509.CertificateBuilder()\n\n        with pytest.raises(TypeError):\n            builder.add_extension(\n                object(),  # type:ignore[arg-type]\n                False,\n            )\n\n    @pytest.mark.parametrize(\"algorithm\", [object(), None])\n    def test_sign_with_unsupported_hash(\n        self, rsa_key_2048: rsa.RSAPrivateKey, algorithm, backend\n    ):\n        private_key = rsa_key_2048\n        builder = x509.CertificateBuilder()\n        builder = (\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(private_key, algorithm, backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_sign_with_unsupported_hash_ed25519(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_sign_with_unsupported_hash_ed448(self, backend):\n        private_key = ed448.Ed448PrivateKey.generate()\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(hashes.MD5()),\n        skip_message=\"Requires OpenSSL with MD5 support\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        \"hash_algorithm\",\n        [\n            hashes.MD5(),\n            hashes.SHA3_224(),\n            hashes.SHA3_256(),\n            hashes.SHA3_384(),\n            hashes.SHA3_512(),\n        ],\n    )\n    def test_sign_dsa_with_unsupported_hash(self, hash_algorithm, backend):\n        private_key = DSA_KEY_2048.private_key(backend)\n        builder = x509.CertificateBuilder()\n        builder = (\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n        with pytest.raises(UnsupportedAlgorithm):\n            builder.sign(private_key, hash_algorithm, backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(hashes.MD5()),\n        skip_message=\"Requires OpenSSL with MD5 support\",\n    )\n    def test_sign_ec_with_md5(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = EC_KEY_SECP256R1.private_key(backend)\n        builder = x509.CertificateBuilder()\n        builder = (\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n        with pytest.raises(UnsupportedAlgorithm):\n            builder.sign(\n                private_key,\n                hashes.MD5(),  # type: ignore[arg-type]\n                backend,\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        (\"hashalg\", \"hashalg_oid\"),\n        [\n            (hashes.SHA224, x509.SignatureAlgorithmOID.DSA_WITH_SHA224),\n            (hashes.SHA256, x509.SignatureAlgorithmOID.DSA_WITH_SHA256),\n            (hashes.SHA384, x509.SignatureAlgorithmOID.DSA_WITH_SHA384),\n            (hashes.SHA512, x509.SignatureAlgorithmOID.DSA_WITH_SHA512),\n        ],\n    )\n    def test_build_cert_with_dsa_private_key(\n        self, hashalg, hashalg_oid, backend\n    ):\n        issuer_private_key = DSA_KEY_2048.private_key(backend)\n        subject_private_key = DSA_KEY_2048.private_key(backend)\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashalg(), backend)\n\n        assert cert.version is x509.Version.v3\n        assert cert.signature_algorithm_oid == hashalg_oid\n        public_key = cert.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.DSA\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        basic_constraints = cert.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n        subject_alternative_name = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(\n            subject_alternative_name.value, x509.SubjectAlternativeName\n        )\n        assert list(subject_alternative_name.value) == [\n            x509.DNSName(\"cryptography.io\"),\n        ]\n\n    @pytest.mark.parametrize(\n        (\"hashalg\", \"hashalg_oid\"),\n        [\n            (hashes.SHA224, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA224),\n            (hashes.SHA256, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA256),\n            (hashes.SHA384, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA384),\n            (hashes.SHA512, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA512),\n            (hashes.SHA3_224, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_224),\n            (hashes.SHA3_256, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_256),\n            (hashes.SHA3_384, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_384),\n            (hashes.SHA3_512, x509.SignatureAlgorithmOID.ECDSA_WITH_SHA3_512),\n        ],\n    )\n    def test_build_cert_with_ec_private_key(\n        self, hashalg, hashalg_oid, backend\n    ):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        if not backend.signature_hash_supported(hashalg()):\n            pytest.skip(f\"{hashalg} signature not supported\")\n\n        issuer_private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        subject_private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashalg(), backend)\n\n        assert cert.version is x509.Version.v3\n        public_key = cert.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        assert (\n            cert.public_key_algorithm_oid\n            == PublicKeyAlgorithmOID.EC_PUBLIC_KEY\n        )\n        assert cert.signature_algorithm_oid == hashalg_oid\n        assert type(cert.signature_hash_algorithm) is hashalg\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        basic_constraints = cert.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n        subject_alternative_name = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(\n            subject_alternative_name.value, x509.SubjectAlternativeName\n        )\n        assert list(subject_alternative_name.value) == [\n            x509.DNSName(\"cryptography.io\"),\n        ]\n\n    def test_build_cert_with_bmpstring_universalstring_name(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        issuer = x509.Name(\n            [\n                x509.NameAttribute(\n                    NameOID.COMMON_NAME,\n                    \"cryptography.io\",\n                    _ASN1Type.BMPString,\n                ),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            ]\n        )\n        subject = x509.Name(\n            [\n                x509.NameAttribute(\n                    NameOID.COMMON_NAME,\n                    \"cryptography.io\",\n                    _ASN1Type.UniversalString,\n                ),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            ]\n        )\n        builder = x509.CertificateBuilder()\n        builder = (\n            builder.subject_name(subject)\n            .issuer_name(issuer)\n            .serial_number(1)\n            .public_key(private_key.public_key())\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2032, 1, 1, 12, 1))\n        )\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        assert cert.issuer == issuer\n        assert cert.subject == subject\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_build_cert_with_ed25519(self, backend):\n        issuer_private_key = ed25519.Ed25519PrivateKey.generate()\n        subject_private_key = ed25519.Ed25519PrivateKey.generate()\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, None, backend)\n        issuer_private_key.public_key().verify(\n            cert.signature, cert.tbs_certificate_bytes\n        )\n        assert cert.signature_algorithm_oid == SignatureAlgorithmOID.ED25519\n        assert cert.signature_hash_algorithm is None\n        assert isinstance(cert.public_key(), ed25519.Ed25519PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED25519\n        assert cert.version is x509.Version.v3\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        basic_constraints = cert.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n        subject_alternative_name = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(\n            subject_alternative_name.value, x509.SubjectAlternativeName\n        )\n        assert list(subject_alternative_name.value) == [\n            x509.DNSName(\"cryptography.io\"),\n        ]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_build_cert_with_public_ed25519_rsa_sig(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = ed25519.Ed25519PrivateKey.generate()\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)\n        assert cert.signature_hash_algorithm is not None\n        issuer_private_key.public_key().verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            padding.PKCS1v15(),\n            cert.signature_hash_algorithm,\n        )\n        assert cert.signature_algorithm_oid == (\n            SignatureAlgorithmOID.RSA_WITH_SHA256\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n        assert isinstance(cert.public_key(), ed25519.Ed25519PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED25519\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_build_cert_with_ed448(self, backend):\n        issuer_private_key = ed448.Ed448PrivateKey.generate()\n        subject_private_key = ed448.Ed448PrivateKey.generate()\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                True,\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, None, backend)\n        issuer_private_key.public_key().verify(\n            cert.signature, cert.tbs_certificate_bytes\n        )\n        assert cert.signature_algorithm_oid == SignatureAlgorithmOID.ED448\n        assert cert.signature_hash_algorithm is None\n        assert isinstance(cert.public_key(), ed448.Ed448PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED448\n        assert cert.version is x509.Version.v3\n        _check_cert_times(\n            cert,\n            not_valid_before=not_valid_before,\n            not_valid_after=not_valid_after,\n        )\n        basic_constraints = cert.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n        subject_alternative_name = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(\n            subject_alternative_name.value, x509.SubjectAlternativeName\n        )\n        assert list(subject_alternative_name.value) == [\n            x509.DNSName(\"cryptography.io\"),\n        ]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_build_cert_with_public_ed448_rsa_sig(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = ed448.Ed448PrivateKey.generate()\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)\n        assert cert.signature_hash_algorithm is not None\n        issuer_private_key.public_key().verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            padding.PKCS1v15(),\n            cert.signature_hash_algorithm,\n        )\n        assert cert.signature_algorithm_oid == (\n            SignatureAlgorithmOID.RSA_WITH_SHA256\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n        assert isinstance(cert.public_key(), ed448.Ed448PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED448\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.x25519_supported() and backend.x448_supported()\n        ),\n        skip_message=\"Requires OpenSSL with x25519 & x448 support\",\n    )\n    @pytest.mark.parametrize(\n        (\"priv_key_cls\", \"pub_key_cls\", \"pub_key_oid\"),\n        [\n            (\n                x25519.X25519PrivateKey,\n                x25519.X25519PublicKey,\n                PublicKeyAlgorithmOID.X25519,\n            ),\n            (\n                x448.X448PrivateKey,\n                x448.X448PublicKey,\n                PublicKeyAlgorithmOID.X448,\n            ),\n        ],\n    )\n    def test_build_cert_with_public_x25519_x448_rsa_sig(\n        self,\n        rsa_key_2048: rsa.RSAPrivateKey,\n        priv_key_cls,\n        pub_key_cls,\n        pub_key_oid,\n        backend,\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = priv_key_cls.generate()\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        cert = builder.sign(issuer_private_key, hashes.SHA256(), backend)\n        assert cert.signature_hash_algorithm is not None\n        issuer_private_key.public_key().verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            padding.PKCS1v15(),\n            cert.signature_hash_algorithm,\n        )\n        assert cert.signature_algorithm_oid == (\n            SignatureAlgorithmOID.RSA_WITH_SHA256\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n        assert isinstance(cert.public_key(), pub_key_cls)\n        assert cert.public_key_algorithm_oid == pub_key_oid\n\n    def test_build_cert_with_rsa_key_too_small(\n        self, rsa_key_512: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_512\n        subject_private_key = rsa_key_512\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(subject_private_key.public_key())\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(issuer_private_key, hashes.SHA512(), backend)\n\n    @pytest.mark.parametrize(\n        \"add_ext\",\n        [\n            x509.SubjectAlternativeName(\n                [\n                    # These examples exist to verify compatibility with\n                    # certificates that have utf8 encoded data in the ia5string\n                    x509.DNSName._init_without_validation(\"a\\xedt\\xe1s.test\"),\n                    x509.RFC822Name._init_without_validation(\n                        \"test@a\\xedt\\xe1s.test\"\n                    ),\n                    x509.UniformResourceIdentifier._init_without_validation(\n                        \"http://a\\xedt\\xe1s.test\"\n                    ),\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        [\"http://other.com/cps\"],\n                    )\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        None,\n                    )\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        [\n                            \"http://example.com/cps\",\n                            \"http://other.com/cps\",\n                            x509.UserNotice(\n                                x509.NoticeReference(\"my org\", [1, 2, 3, 4]),\n                                \"thing\",\n                            ),\n                        ],\n                    )\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        [\n                            \"http://example.com/cps\",\n                            x509.UserNotice(\n                                x509.NoticeReference(\n                                    \"UTF8\\u2122'\", [1, 2, 3, 4]\n                                ),\n                                \"We heart UTF8!\\u2122\",\n                            ),\n                        ],\n                    )\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        [x509.UserNotice(None, \"thing\")],\n                    )\n                ]\n            ),\n            x509.CertificatePolicies(\n                [\n                    x509.PolicyInformation(\n                        x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                        [\n                            x509.UserNotice(\n                                x509.NoticeReference(\"my org\", [1, 2, 3, 4]),\n                                None,\n                            )\n                        ],\n                    )\n                ]\n            ),\n            x509.IssuerAlternativeName(\n                [\n                    x509.DNSName(\"myissuer\"),\n                    x509.RFC822Name(\"email@domain.com\"),\n                ]\n            ),\n            x509.ExtendedKeyUsage(\n                [\n                    ExtendedKeyUsageOID.CLIENT_AUTH,\n                    ExtendedKeyUsageOID.SERVER_AUTH,\n                    ExtendedKeyUsageOID.CODE_SIGNING,\n                ]\n            ),\n            x509.InhibitAnyPolicy(3),\n            x509.TLSFeature([x509.TLSFeatureType.status_request]),\n            x509.TLSFeature([x509.TLSFeatureType.status_request_v2]),\n            x509.TLSFeature(\n                [\n                    x509.TLSFeatureType.status_request,\n                    x509.TLSFeatureType.status_request_v2,\n                ]\n            ),\n            x509.NameConstraints(\n                permitted_subtrees=[\n                    x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/24\")),\n                    x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/29\")),\n                    x509.IPAddress(ipaddress.IPv4Network(\"127.0.0.1/32\")),\n                    x509.IPAddress(ipaddress.IPv4Network(\"8.0.0.0/8\")),\n                    x509.IPAddress(ipaddress.IPv4Network(\"0.0.0.0/0\")),\n                    x509.IPAddress(\n                        ipaddress.IPv6Network(\"FF:0:0:0:0:0:0:0/96\")\n                    ),\n                    x509.IPAddress(\n                        ipaddress.IPv6Network(\"FF:FF:0:0:0:0:0:0/128\")\n                    ),\n                ],\n                excluded_subtrees=[x509.DNSName(\"name.local\")],\n            ),\n            x509.NameConstraints(\n                permitted_subtrees=[\n                    x509.IPAddress(ipaddress.IPv4Network(\"0.0.0.0/0\")),\n                ],\n                excluded_subtrees=None,\n            ),\n            x509.NameConstraints(\n                permitted_subtrees=None,\n                excluded_subtrees=[x509.DNSName(\"name.local\")],\n            ),\n            x509.PolicyConstraints(\n                require_explicit_policy=None, inhibit_policy_mapping=1\n            ),\n            x509.PolicyConstraints(\n                require_explicit_policy=3, inhibit_policy_mapping=1\n            ),\n            x509.PolicyConstraints(\n                require_explicit_policy=0, inhibit_policy_mapping=None\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=None,\n                        relative_name=x509.RelativeDistinguishedName(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME,\n                                    \"indirect CRL for indirectCRL CA3\",\n                                ),\n                            ]\n                        ),\n                        reasons=None,\n                        crl_issuer=[\n                            x509.DirectoryName(\n                                x509.Name(\n                                    [\n                                        x509.NameAttribute(\n                                            NameOID.COUNTRY_NAME, \"US\"\n                                        ),\n                                        x509.NameAttribute(\n                                            NameOID.ORGANIZATION_NAME,\n                                            \"Test Certificates 2011\",\n                                        ),\n                                        x509.NameAttribute(\n                                            NameOID.ORGANIZATIONAL_UNIT_NAME,\n                                            \"indirectCRL CA3 cRLIssuer\",\n                                        ),\n                                    ]\n                                )\n                            )\n                        ],\n                    )\n                ]\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=[\n                            x509.DirectoryName(\n                                x509.Name(\n                                    [\n                                        x509.NameAttribute(\n                                            NameOID.COUNTRY_NAME, \"US\"\n                                        ),\n                                    ]\n                                )\n                            )\n                        ],\n                        relative_name=None,\n                        reasons=None,\n                        crl_issuer=[\n                            x509.DirectoryName(\n                                x509.Name(\n                                    [\n                                        x509.NameAttribute(\n                                            NameOID.ORGANIZATION_NAME,\n                                            \"cryptography Testing\",\n                                        ),\n                                    ]\n                                )\n                            )\n                        ],\n                    )\n                ]\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=[\n                            x509.UniformResourceIdentifier(\n                                \"http://myhost.com/myca.crl\"\n                            ),\n                            x509.UniformResourceIdentifier(\n                                \"http://backup.myhost.com/myca.crl\"\n                            ),\n                        ],\n                        relative_name=None,\n                        reasons=frozenset(\n                            [\n                                x509.ReasonFlags.key_compromise,\n                                x509.ReasonFlags.ca_compromise,\n                            ]\n                        ),\n                        crl_issuer=[\n                            x509.DirectoryName(\n                                x509.Name(\n                                    [\n                                        x509.NameAttribute(\n                                            NameOID.COUNTRY_NAME, \"US\"\n                                        ),\n                                        x509.NameAttribute(\n                                            NameOID.COMMON_NAME,\n                                            \"cryptography CA\",\n                                        ),\n                                    ]\n                                )\n                            )\n                        ],\n                    )\n                ]\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=[\n                            x509.UniformResourceIdentifier(\n                                \"http://domain.com/some.crl\"\n                            )\n                        ],\n                        relative_name=None,\n                        reasons=frozenset(\n                            [\n                                x509.ReasonFlags.key_compromise,\n                                x509.ReasonFlags.ca_compromise,\n                                x509.ReasonFlags.affiliation_changed,\n                                x509.ReasonFlags.superseded,\n                                x509.ReasonFlags.privilege_withdrawn,\n                                x509.ReasonFlags.cessation_of_operation,\n                                x509.ReasonFlags.aa_compromise,\n                                x509.ReasonFlags.certificate_hold,\n                            ]\n                        ),\n                        crl_issuer=None,\n                    )\n                ]\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=None,\n                        relative_name=None,\n                        reasons=None,\n                        crl_issuer=[\n                            x509.DirectoryName(\n                                x509.Name(\n                                    [\n                                        x509.NameAttribute(\n                                            NameOID.COMMON_NAME,\n                                            \"cryptography CA\",\n                                        ),\n                                    ]\n                                )\n                            )\n                        ],\n                    )\n                ]\n            ),\n            x509.CRLDistributionPoints(\n                [\n                    x509.DistributionPoint(\n                        full_name=[\n                            x509.UniformResourceIdentifier(\n                                \"http://domain.com/some.crl\"\n                            )\n                        ],\n                        relative_name=None,\n                        reasons=frozenset([x509.ReasonFlags.aa_compromise]),\n                        crl_issuer=None,\n                    )\n                ]\n            ),\n            x509.FreshestCRL(\n                [\n                    x509.DistributionPoint(\n                        full_name=[\n                            x509.UniformResourceIdentifier(\n                                \"http://domain.com/some.crl\"\n                            )\n                        ],\n                        relative_name=None,\n                        reasons=frozenset(\n                            [\n                                x509.ReasonFlags.key_compromise,\n                                x509.ReasonFlags.ca_compromise,\n                                x509.ReasonFlags.affiliation_changed,\n                                x509.ReasonFlags.superseded,\n                                x509.ReasonFlags.privilege_withdrawn,\n                                x509.ReasonFlags.cessation_of_operation,\n                                x509.ReasonFlags.aa_compromise,\n                                x509.ReasonFlags.certificate_hold,\n                            ]\n                        ),\n                        crl_issuer=None,\n                    )\n                ]\n            ),\n            x509.FreshestCRL(\n                [\n                    x509.DistributionPoint(\n                        full_name=None,\n                        relative_name=x509.RelativeDistinguishedName(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME,\n                                    \"indirect CRL for indirectCRL CA3\",\n                                ),\n                            ]\n                        ),\n                        reasons=None,\n                        crl_issuer=None,\n                    )\n                ]\n            ),\n            x509.FreshestCRL(\n                [\n                    x509.DistributionPoint(\n                        full_name=None,\n                        relative_name=x509.RelativeDistinguishedName(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME,\n                                    \"indirect CRL for indirectCRL CA3\",\n                                ),\n                                x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                            ]\n                        ),\n                        reasons=None,\n                        crl_issuer=None,\n                    )\n                ]\n            ),\n            x509.AuthorityInformationAccess(\n                [\n                    x509.AccessDescription(\n                        AuthorityInformationAccessOID.OCSP,\n                        x509.UniformResourceIdentifier(\n                            \"http://ocsp.domain.com\"\n                        ),\n                    ),\n                    x509.AccessDescription(\n                        AuthorityInformationAccessOID.CA_ISSUERS,\n                        x509.UniformResourceIdentifier(\n                            \"http://domain.com/ca.crt\"\n                        ),\n                    ),\n                ]\n            ),\n            x509.SubjectInformationAccess(\n                [\n                    x509.AccessDescription(\n                        SubjectInformationAccessOID.CA_REPOSITORY,\n                        x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                    ),\n                ]\n            ),\n            x509.AuthorityKeyIdentifier(\n                b\"\\xc3\\x9c\\xf3\\xfc\\xd3F\\x084\\xbb\\xceF\\x7f\\xa0|[\\xf3\\xe2\\x08\"\n                b\"\\xcbY\",\n                None,\n                None,\n            ),\n            x509.AuthorityKeyIdentifier(\n                b\"\\xc3\\x9c\\xf3\\xfc\\xd3F\\x084\\xbb\\xceF\\x7f\\xa0|[\\xf3\\xe2\\x08\"\n                b\"\\xcbY\",\n                [\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME, \"PyCA\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"cryptography CA\"\n                                ),\n                            ]\n                        )\n                    )\n                ],\n                333,\n            ),\n            x509.AuthorityKeyIdentifier(\n                None,\n                [\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME, \"PyCA\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"cryptography CA\"\n                                ),\n                            ]\n                        )\n                    )\n                ],\n                333,\n            ),\n            x509.KeyUsage(\n                digital_signature=True,\n                content_commitment=True,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=False,\n                key_cert_sign=True,\n                crl_sign=False,\n                encipher_only=False,\n                decipher_only=False,\n            ),\n            x509.OCSPNoCheck(),\n            x509.SubjectKeyIdentifier,\n        ],\n    )\n    def test_extensions(\n        self, rsa_key_2048: rsa.RSAPrivateKey, add_ext, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = rsa_key_2048\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        if add_ext is x509.SubjectKeyIdentifier:\n            add_ext = x509.SubjectKeyIdentifier.from_public_key(\n                subject_private_key.public_key()\n            )\n\n        # Cert\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n            .public_key(subject_private_key.public_key())\n            .serial_number(123)\n            .add_extension(add_ext, critical=False)\n            .sign(issuer_private_key, hashes.SHA256(), backend)\n        )\n\n        ext = cert.extensions.get_extension_for_class(type(add_ext))\n        assert ext.critical is False\n        assert ext.value == add_ext\n\n        # CSR\n        csr = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .add_extension(add_ext, False)\n            .sign(subject_private_key, hashes.SHA256())\n        )\n        ext = csr.extensions.get_extension_for_class(type(add_ext))\n        assert ext.critical is False\n        assert ext.value == add_ext\n\n    def test_build_ca_request_with_path_length_none(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\")]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=None), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        loaded_request = x509.load_pem_x509_csr(\n            request.public_bytes(encoding=serialization.Encoding.PEM), backend\n        )\n        subject = loaded_request.subject\n        assert isinstance(subject, x509.Name)\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.path_length is None\n\n    @pytest.mark.parametrize(\n        \"unrecognized\",\n        [\n            x509.UnrecognizedExtension(\n                x509.ObjectIdentifier(\"1.2.3.4.5\"),\n                b\"abcdef\",\n            )\n        ],\n    )\n    def test_unrecognized_extension(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend, unrecognized\n    ):\n        private_key = rsa_key_2048\n\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(x509.OID_COUNTRY_NAME, \"US\")])\n            )\n            .not_valid_before(datetime.datetime(2002, 1, 1, 12, 1))\n            .not_valid_after(datetime.datetime(2030, 12, 31, 8, 30))\n            .public_key(private_key.public_key())\n            .serial_number(123)\n            .add_extension(unrecognized, critical=False)\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        ext = cert.extensions.get_extension_for_oid(unrecognized.oid)\n\n        assert ext.value == unrecognized\n\n\nclass TestCertificateSigningRequestBuilder:\n    def test_sign_invalid_hash_algorithm(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([])\n        )\n        with pytest.raises(TypeError):\n            builder.sign(\n                private_key,\n                \"NotAHash\",  # type: ignore[arg-type]\n                backend,\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_request_with_unsupported_hash_ed25519(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_request_with_unsupported_hash_ed448(self, backend):\n        private_key = ed448.Ed448PrivateKey.generate()\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_no_subject_name(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n\n        builder = x509.CertificateSigningRequestBuilder()\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_build_ca_request_with_rsa(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\")]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n\n    def test_build_ca_request_with_unicode(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.ORGANIZATION_NAME, \"PyCA\\U0001f37a\"\n                        ),\n                    ]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        loaded_request = x509.load_pem_x509_csr(\n            request.public_bytes(encoding=serialization.Encoding.PEM), backend\n        )\n        subject = loaded_request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\\U0001f37a\"),\n        ]\n\n    def test_subject_dn_asn1_types(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.COMMON_NAME, \"mysite.com\"),\n                        x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        x509.NameAttribute(NameOID.LOCALITY_NAME, \"value\"),\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"value\"\n                        ),\n                        x509.NameAttribute(NameOID.STREET_ADDRESS, \"value\"),\n                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"value\"),\n                        x509.NameAttribute(\n                            NameOID.ORGANIZATIONAL_UNIT_NAME, \"value\"\n                        ),\n                        x509.NameAttribute(NameOID.SERIAL_NUMBER, \"value\"),\n                        x509.NameAttribute(NameOID.SURNAME, \"value\"),\n                        x509.NameAttribute(NameOID.GIVEN_NAME, \"value\"),\n                        x509.NameAttribute(NameOID.TITLE, \"value\"),\n                        x509.NameAttribute(\n                            NameOID.GENERATION_QUALIFIER, \"value\"\n                        ),\n                        x509.NameAttribute(\n                            NameOID.X500_UNIQUE_IDENTIFIER, \"value\"\n                        ),\n                        x509.NameAttribute(NameOID.DN_QUALIFIER, \"value\"),\n                        x509.NameAttribute(NameOID.PSEUDONYM, \"value\"),\n                        x509.NameAttribute(NameOID.USER_ID, \"value\"),\n                        x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"value\"),\n                        x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"value\"),\n                        x509.NameAttribute(\n                            NameOID.JURISDICTION_COUNTRY_NAME, \"US\"\n                        ),\n                        x509.NameAttribute(\n                            NameOID.JURISDICTION_LOCALITY_NAME, \"value\"\n                        ),\n                        x509.NameAttribute(\n                            NameOID.JURISDICTION_STATE_OR_PROVINCE_NAME,\n                            \"value\",\n                        ),\n                        x509.NameAttribute(NameOID.BUSINESS_CATEGORY, \"value\"),\n                        x509.NameAttribute(NameOID.POSTAL_ADDRESS, \"value\"),\n                        x509.NameAttribute(NameOID.POSTAL_CODE, \"value\"),\n                    ]\n                )\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n        for oid, asn1_type in TestNameAttribute.EXPECTED_TYPES:\n            assert (\n                request.subject.get_attributes_for_oid(oid)[0]._type\n                == asn1_type\n            )\n\n    def test_build_ca_request_with_multivalue_rdns(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        subject = x509.Name(\n            [\n                x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(NameOID.TITLE, \"Test\"),\n                        x509.NameAttribute(NameOID.COMMON_NAME, \"Multivalue\"),\n                        x509.NameAttribute(NameOID.SURNAME, \"RDNs\"),\n                    ]\n                ),\n                x509.RelativeDistinguishedName(\n                    [x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\")]\n                ),\n            ]\n        )\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(subject)\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        loaded_request = x509.load_pem_x509_csr(\n            request.public_bytes(encoding=serialization.Encoding.PEM), backend\n        )\n        assert isinstance(loaded_request.subject, x509.Name)\n        assert loaded_request.subject == subject\n\n    def test_build_nonca_request_with_rsa(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=False, path_length=None),\n                critical=True,\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is False\n        assert basic_constraints.value.path_length is None\n\n    def test_build_ca_request_with_ec(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_build_ca_request_with_ed25519(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, None, backend)\n        )\n\n        assert request.signature_hash_algorithm is None\n        public_key = request.public_key()\n        assert isinstance(public_key, ed25519.Ed25519PublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_class(\n            x509.BasicConstraints\n        )\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_build_ca_request_with_ed448(self, backend):\n        private_key = ed448.Ed448PrivateKey.generate()\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, None, backend)\n        )\n\n        assert request.signature_hash_algorithm is None\n        public_key = request.public_key()\n        assert isinstance(public_key, ed448.Ed448PublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_class(\n            x509.BasicConstraints\n        )\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    def test_build_ca_request_with_dsa(self, backend):\n        private_key = DSA_KEY_2048.private_key(backend)\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n        ]\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n\n    def test_add_duplicate_extension(self):\n        builder = x509.CertificateSigningRequestBuilder().add_extension(\n            x509.BasicConstraints(True, 2),\n            critical=True,\n        )\n        with pytest.raises(ValueError):\n            builder.add_extension(\n                x509.BasicConstraints(True, 2),\n                critical=True,\n            )\n\n    def test_set_invalid_subject(self):\n        builder = x509.CertificateSigningRequestBuilder()\n        with pytest.raises(TypeError):\n            builder.subject_name(\"NotAName\")  # type:ignore[arg-type]\n\n    def test_add_invalid_extension_type(self):\n        builder = x509.CertificateSigningRequestBuilder()\n\n        with pytest.raises(TypeError):\n            builder.add_extension(\n                object(),  # type:ignore[arg-type]\n                False,\n            )\n\n    def test_add_unsupported_extension(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        builder = x509.CertificateSigningRequestBuilder()\n        builder = (\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .add_extension(DummyExtension(), False)\n        )\n        with pytest.raises(NotImplementedError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_add_two_extensions(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        builder = x509.CertificateSigningRequestBuilder()\n        request = (\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")]),\n                critical=False,\n            )\n            .add_extension(\n                x509.BasicConstraints(ca=True, path_length=2), critical=True\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        basic_constraints = request.extensions.get_extension_for_oid(\n            ExtensionOID.BASIC_CONSTRAINTS\n        )\n        assert isinstance(basic_constraints.value, x509.BasicConstraints)\n        assert basic_constraints.value.ca is True\n        assert basic_constraints.value.path_length == 2\n        ext = request.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n        assert isinstance(ext.value, x509.SubjectAlternativeName)\n        assert list(ext.value) == [x509.DNSName(\"cryptography.io\")]\n\n    def test_add_attributes(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        challenge_password = b\"challenge me!\"\n        unstructured_name = b\"no structure, for shame\"\n        locality = b\"this shouldn't even be an X509 attribute\"\n\n        request = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                        ),\n                    ]\n                )\n            )\n            .add_attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD, challenge_password\n            )\n            .add_attribute(\n                x509.oid.AttributeOID.UNSTRUCTURED_NAME, unstructured_name\n            )\n            .add_attribute(x509.oid.NameOID.LOCALITY_NAME, locality)\n            .add_extension(\n                x509.ExtendedKeyUsage(\n                    [\n                        ExtendedKeyUsageOID.CLIENT_AUTH,\n                        ExtendedKeyUsageOID.SERVER_AUTH,\n                        ExtendedKeyUsageOID.CODE_SIGNING,\n                    ]\n                ),\n                False,\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert (\n            request.attributes.get_attribute_for_oid(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD\n            ).value\n            == challenge_password\n        )\n        assert (\n            request.attributes.get_attribute_for_oid(\n                x509.oid.AttributeOID.UNSTRUCTURED_NAME\n            ).value\n            == unstructured_name\n        )\n        assert (\n            request.attributes.get_attribute_for_oid(\n                x509.oid.NameOID.LOCALITY_NAME\n            ).value\n            == locality\n        )\n        assert len(request.attributes) == 4\n\n    def test_add_attributes_non_utf8(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        builder = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(x509.Name([]))\n            .add_attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n                b\"\\xbb\\xad\\x16\\x9a\\xac\\xc9\\x03i\\xec\\xcc\\xdd6\\xcbh\\xfc\\xf3\",\n            )\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_add_attribute_bad_types(self, backend):\n        request = x509.CertificateSigningRequestBuilder()\n        with pytest.raises(TypeError):\n            request.add_attribute(\n                b\"not an oid\",  # type:ignore[arg-type]\n                b\"val\",\n            )\n\n        with pytest.raises(TypeError):\n            request.add_attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n                383,  # type:ignore[arg-type]\n            )\n\n    def test_duplicate_attribute(self, backend):\n        request = x509.CertificateSigningRequestBuilder().add_attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD, b\"val\"\n        )\n        with pytest.raises(ValueError):\n            request.add_attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD, b\"val2\"\n            )\n\n    def test_add_attribute_tag(self, backend):\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        builder = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(x509.Name([]))\n            .add_attribute(\n                x509.ObjectIdentifier(\"1.2.3.4\"),\n                b\"\\x00\\x00\",\n                _tag=_ASN1Type.GeneralizedTime,\n            )\n        )\n        request = builder.sign(private_key, hashes.SHA256(), backend)\n        attr = request.attributes.get_attribute_for_oid(\n            x509.ObjectIdentifier(\"1.2.3.4\")\n        )\n\n        assert attr.value == b\"\\x00\\x00\"\n        assert attr._type == _ASN1Type.GeneralizedTime.value\n\n    def test_add_attribute_tag_non_int(self, backend):\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([])\n        )\n        with pytest.raises(TypeError):\n            builder.add_attribute(\n                x509.ObjectIdentifier(\"1.2.3.4\"),\n                b\"\",\n                _tag=object(),  # type:ignore[arg-type]\n            )\n\n    def test_set_subject_twice(self):\n        builder = x509.CertificateSigningRequestBuilder()\n        builder = builder.subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        with pytest.raises(ValueError):\n            builder.subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n\n    @pytest.mark.parametrize(\n        \"add_ext\",\n        [\n            x509.KeyUsage(\n                digital_signature=True,\n                content_commitment=True,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=False,\n                key_cert_sign=True,\n                crl_sign=False,\n                encipher_only=False,\n                decipher_only=False,\n            ),\n            x509.KeyUsage(\n                digital_signature=False,\n                content_commitment=False,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=True,\n                key_cert_sign=True,\n                crl_sign=False,\n                encipher_only=False,\n                decipher_only=True,\n            ),\n            x509.SubjectAlternativeName(\n                [\n                    x509.DNSName(\"example.com\"),\n                    x509.DNSName(\"*.example.com\"),\n                    x509.RegisteredID(x509.ObjectIdentifier(\"1.2.3.4.5.6.7\")),\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"PyCA\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME,\n                                    \"We heart UTF8!\\u2122\",\n                                ),\n                            ]\n                        )\n                    ),\n                    x509.IPAddress(ipaddress.ip_address(\"127.0.0.1\")),\n                    x509.IPAddress(ipaddress.ip_address(\"ff::\")),\n                    x509.OtherName(\n                        type_id=x509.ObjectIdentifier(\"1.2.3.3.3.3\"),\n                        value=b\"0\\x03\\x02\\x01\\x05\",\n                    ),\n                    x509.RFC822Name(\"test@example.com\"),\n                    x509.RFC822Name(\"email\"),\n                    x509.RFC822Name(\"email@xn--eml-vla4c.com\"),\n                    x509.UniformResourceIdentifier(\n                        \"https://xn--80ato2c.cryptography\"\n                    ),\n                    x509.UniformResourceIdentifier(\n                        \"gopher://cryptography:70/some/path\"\n                    ),\n                ]\n            ),\n            x509.ExtendedKeyUsage(\n                [\n                    ExtendedKeyUsageOID.CLIENT_AUTH,\n                    ExtendedKeyUsageOID.SERVER_AUTH,\n                    ExtendedKeyUsageOID.CODE_SIGNING,\n                ]\n            ),\n        ],\n    )\n    def test_extensions(\n        self, rsa_key_2048: rsa.RSAPrivateKey, add_ext, backend\n    ):\n        private_key = rsa_key_2048\n\n        csr = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"SAN\")])\n            )\n            .add_extension(\n                add_ext,\n                critical=False,\n            )\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n\n        assert len(csr.extensions) == 1\n        ext = csr.extensions.get_extension_for_class(type(add_ext))\n        assert not ext.critical\n        assert ext.value == add_ext\n\n    def test_invalid_asn1_othername(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        builder = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"SAN\")])\n            )\n            .add_extension(\n                x509.SubjectAlternativeName(\n                    [\n                        x509.OtherName(\n                            type_id=x509.ObjectIdentifier(\"1.2.3.3.3.3\"),\n                            # Invalid length\n                            value=b\"\\x01\\x05\\x01\\x05\",\n                        ),\n                    ]\n                ),\n                critical=False,\n            )\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_subject_alt_name_unsupported_general_name(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n\n        builder = (\n            x509.CertificateSigningRequestBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"SAN\")])\n            )\n            .add_extension(\n                x509.SubjectAlternativeName([FakeGeneralName(\"\")]),\n                critical=False,\n            )\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_rsa_key_too_small(self, rsa_key_512: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_512\n        builder = x509.CertificateSigningRequestBuilder()\n        builder = builder.subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA512(), backend)\n\n    @pytest.mark.parametrize(\n        (\"alg\", \"mgf_alg\"),\n        [\n            (hashes.SHA512(), hashes.SHA256()),\n            (hashes.SHA3_512(), hashes.SHA3_256()),\n        ],\n    )\n    def test_sign_pss(\n        self, rsa_key_2048: rsa.RSAPrivateKey, alg, mgf_alg, backend\n    ):\n        if not backend.signature_hash_supported(alg):\n            pytest.skip(f\"{alg} signature not supported\")\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(mgf_alg), salt_length=alg.digest_size\n        )\n        csr = builder.sign(rsa_key_2048, alg, rsa_padding=pss)\n        pk = csr.public_key()\n        assert isinstance(pk, rsa.RSAPublicKey)\n        assert isinstance(csr.signature_hash_algorithm, type(alg))\n        cert_params = csr.signature_algorithm_parameters\n        assert isinstance(cert_params, padding.PSS)\n        assert cert_params._salt_length == pss._salt_length\n        assert isinstance(cert_params._mgf, padding.MGF1)\n        assert isinstance(cert_params._mgf._algorithm, type(mgf_alg))\n        pk.verify(\n            csr.signature,\n            csr.tbs_certrequest_bytes,\n            cert_params,\n            alg,\n        )\n\n    @pytest.mark.parametrize(\n        (\"padding_len\", \"computed_len\"),\n        [\n            (padding.PSS.MAX_LENGTH, 222),\n            (padding.PSS.DIGEST_LENGTH, 32),\n        ],\n    )\n    def test_sign_pss_length_options(\n        self,\n        rsa_key_2048: rsa.RSAPrivateKey,\n        padding_len,\n        computed_len,\n        backend,\n    ):\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()), salt_length=padding_len\n        )\n        csr = builder.sign(rsa_key_2048, hashes.SHA256(), rsa_padding=pss)\n        assert isinstance(csr.signature_algorithm_parameters, padding.PSS)\n        assert csr.signature_algorithm_parameters._salt_length == computed_len\n\n    def test_sign_pss_auto_unsupported(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()), salt_length=padding.PSS.AUTO\n        )\n        with pytest.raises(TypeError):\n            builder.sign(rsa_key_2048, hashes.SHA256(), rsa_padding=pss)\n\n    def test_sign_invalid_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        with pytest.raises(TypeError):\n            builder.sign(\n                rsa_key_2048,\n                hashes.SHA256(),\n                rsa_padding=b\"notapadding\",  # type: ignore[arg-type]\n            )\n        eckey = ec.generate_private_key(ec.SECP256R1())\n        with pytest.raises(TypeError):\n            builder.sign(\n                eckey, hashes.SHA256(), rsa_padding=padding.PKCS1v15()\n            )\n\n    def test_sign_pss_hash_none(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=32)\n        with pytest.raises(TypeError):\n            builder.sign(rsa_key_2048, None, rsa_padding=pss)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSACertificate:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA-1 signature.\",\n    )\n    def test_load_dsa_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA1)\n        public_key = cert.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        assert cert.signature_algorithm_parameters is None\n        num = public_key.public_numbers()\n        assert num.y == int(\n            \"4c08bfe5f2d76649c80acf7d431f6ae2124b217abc8c9f6aca776ddfa94\"\n            \"53b6656f13e543684cd5f6431a314377d2abfa068b7080cb8ddc065afc2\"\n            \"dea559f0b584c97a2b235b9b69b46bc6de1aed422a6f341832618bcaae2\"\n            \"198aba388099dafb05ff0b5efecb3b0ae169a62e1c72022af50ae68af3b\"\n            \"033c18e6eec1f7df4692c456ccafb79cc7e08da0a5786e9816ceda651d6\"\n            \"1b4bb7b81c2783da97cea62df67af5e85991fdc13aff10fc60e06586386\"\n            \"b96bb78d65750f542f86951e05a6d81baadbcd35a2e5cad4119923ae6a2\"\n            \"002091a3d17017f93c52970113cdc119970b9074ca506eac91c3dd37632\"\n            \"5df4af6b3911ef267d26623a5a1c5df4a6d13f1c\",\n            16,\n        )\n        assert num.parameter_numbers.g == int(\n            \"4b7ced71dc353965ecc10d441a9a06fc24943a32d66429dd5ef44d43e67\"\n            \"d789d99770aec32c0415dc92970880872da45fef8dd1e115a3e4801387b\"\n            \"a6d755861f062fd3b6e9ea8e2641152339b828315b1528ee6c7b79458d2\"\n            \"1f3db973f6fc303f9397174c2799dd2351282aa2d8842c357a73495bbaa\"\n            \"c4932786414c55e60d73169f5761036fba29e9eebfb049f8a3b1b7cee6f\"\n            \"3fbfa136205f130bee2cf5b9c38dc1095d4006f2e73335c07352c64130a\"\n            \"1ab2b89f13b48f628d3cc3868beece9bb7beade9f830eacc6fa241425c0\"\n            \"b3fcc0df416a0c89f7bf35668d765ec95cdcfbe9caff49cfc156c668c76\"\n            \"fa6247676a6d3ac945844a083509c6a1b436baca\",\n            16,\n        )\n        assert num.parameter_numbers.p == int(\n            \"bfade6048e373cd4e48b677e878c8e5b08c02102ae04eb2cb5c46a523a3\"\n            \"af1c73d16b24f34a4964781ae7e50500e21777754a670bd19a7420d6330\"\n            \"84e5556e33ca2c0e7d547ea5f46a07a01bf8669ae3bdec042d9b2ae5e6e\"\n            \"cf49f00ba9dac99ab6eff140d2cedf722ee62c2f9736857971444c25d0a\"\n            \"33d2017dc36d682a1054fe2a9428dda355a851ce6e6d61e03e419fd4ca4\"\n            \"e703313743d86caa885930f62ed5bf342d8165627681e9cc3244ba72aa2\"\n            \"2148400a6bbe80154e855d042c9dc2a3405f1e517be9dea50562f56da93\"\n            \"f6085f844a7e705c1f043e65751c583b80d29103e590ccb26efdaa0893d\"\n            \"833e36468f3907cfca788a3cb790f0341c8a31bf\",\n            16,\n        )\n        assert num.parameter_numbers.q == int(\n            \"822ff5d234e073b901cf5941f58e1f538e71d40d\", 16\n        )\n\n    def test_load_dsa_cert_null_alg_params(self, backend):\n        \"\"\"\n        This test verifies that we successfully load certificates with encoded\n        null parameters in the signature AlgorithmIdentifier. This is invalid,\n        but all versions of Java less than 21 generate certificates with this\n        encoding so we need to tolerate it at the moment.\n        \"\"\"\n        with pytest.warns(utils.DeprecatedIn41):\n            cert = _load_cert(\n                os.path.join(\"x509\", \"custom\", \"dsa_null_alg_params.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n            assert isinstance(cert.public_key(), dsa.DSAPublicKey)\n\n    def test_signature(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.signature == binascii.unhexlify(\n            b\"302c021425c4a84a936ab311ee017d3cbd9a3c650bb3ae4a02145d30c64b4326\"\n            b\"86bdf925716b4ed059184396bcce\"\n        )\n        r, s = decode_dss_signature(cert.signature)\n        assert r == 215618264820276283222494627481362273536404860490\n        assert s == 532023851299196869156027211159466197586787351758\n\n    def test_tbs_certificate_bytes(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.tbs_certificate_bytes == binascii.unhexlify(\n            b\"3082051aa003020102020900a37352e0b2142f86300906072a8648ce3804033\"\n            b\"067310b3009060355040613025553310e300c06035504081305546578617331\"\n            b\"0f300d0603550407130641757374696e3121301f060355040a1318496e74657\"\n            b\"26e6574205769646769747320507479204c7464311430120603550403130b50\"\n            b\"79434120445341204341301e170d3134313132373035313431375a170d31343\"\n            b\"13232373035313431375a3067310b3009060355040613025553310e300c0603\"\n            b\"55040813055465786173310f300d0603550407130641757374696e3121301f0\"\n            b\"60355040a1318496e7465726e6574205769646769747320507479204c746431\"\n            b\"1430120603550403130b50794341204453412043413082033a3082022d06072\"\n            b\"a8648ce380401308202200282010100bfade6048e373cd4e48b677e878c8e5b\"\n            b\"08c02102ae04eb2cb5c46a523a3af1c73d16b24f34a4964781ae7e50500e217\"\n            b\"77754a670bd19a7420d633084e5556e33ca2c0e7d547ea5f46a07a01bf8669a\"\n            b\"e3bdec042d9b2ae5e6ecf49f00ba9dac99ab6eff140d2cedf722ee62c2f9736\"\n            b\"857971444c25d0a33d2017dc36d682a1054fe2a9428dda355a851ce6e6d61e0\"\n            b\"3e419fd4ca4e703313743d86caa885930f62ed5bf342d8165627681e9cc3244\"\n            b\"ba72aa22148400a6bbe80154e855d042c9dc2a3405f1e517be9dea50562f56d\"\n            b\"a93f6085f844a7e705c1f043e65751c583b80d29103e590ccb26efdaa0893d8\"\n            b\"33e36468f3907cfca788a3cb790f0341c8a31bf021500822ff5d234e073b901\"\n            b\"cf5941f58e1f538e71d40d028201004b7ced71dc353965ecc10d441a9a06fc2\"\n            b\"4943a32d66429dd5ef44d43e67d789d99770aec32c0415dc92970880872da45\"\n            b\"fef8dd1e115a3e4801387ba6d755861f062fd3b6e9ea8e2641152339b828315\"\n            b\"b1528ee6c7b79458d21f3db973f6fc303f9397174c2799dd2351282aa2d8842\"\n            b\"c357a73495bbaac4932786414c55e60d73169f5761036fba29e9eebfb049f8a\"\n            b\"3b1b7cee6f3fbfa136205f130bee2cf5b9c38dc1095d4006f2e73335c07352c\"\n            b\"64130a1ab2b89f13b48f628d3cc3868beece9bb7beade9f830eacc6fa241425\"\n            b\"c0b3fcc0df416a0c89f7bf35668d765ec95cdcfbe9caff49cfc156c668c76fa\"\n            b\"6247676a6d3ac945844a083509c6a1b436baca0382010500028201004c08bfe\"\n            b\"5f2d76649c80acf7d431f6ae2124b217abc8c9f6aca776ddfa9453b6656f13e\"\n            b\"543684cd5f6431a314377d2abfa068b7080cb8ddc065afc2dea559f0b584c97\"\n            b\"a2b235b9b69b46bc6de1aed422a6f341832618bcaae2198aba388099dafb05f\"\n            b\"f0b5efecb3b0ae169a62e1c72022af50ae68af3b033c18e6eec1f7df4692c45\"\n            b\"6ccafb79cc7e08da0a5786e9816ceda651d61b4bb7b81c2783da97cea62df67\"\n            b\"af5e85991fdc13aff10fc60e06586386b96bb78d65750f542f86951e05a6d81\"\n            b\"baadbcd35a2e5cad4119923ae6a2002091a3d17017f93c52970113cdc119970\"\n            b\"b9074ca506eac91c3dd376325df4af6b3911ef267d26623a5a1c5df4a6d13f1\"\n            b\"ca381cc3081c9301d0603551d0e04160414a4fb887a13fcdeb303bbae9a1dec\"\n            b\"a72f125a541b3081990603551d2304819130818e8014a4fb887a13fcdeb303b\"\n            b\"bae9a1deca72f125a541ba16ba4693067310b3009060355040613025553310e\"\n            b\"300c060355040813055465786173310f300d0603550407130641757374696e3\"\n            b\"121301f060355040a1318496e7465726e657420576964676974732050747920\"\n            b\"4c7464311430120603550403130b5079434120445341204341820900a37352e\"\n            b\"0b2142f86300c0603551d13040530030101ff\"\n        )\n        assert cert.signature_hash_algorithm is not None\n        public_key = cert.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        public_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            cert.signature_hash_algorithm,\n        )\n\n    def test_verify_directly_issued_by_dsa(self, backend):\n        issuer_private_key = DSA_KEY_3072.private_key()\n        subject_private_key = DSA_KEY_2048.private_key()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_dsa_bad_sig(self, backend):\n        issuer_private_key = DSA_KEY_3072.private_key()\n        subject_private_key = DSA_KEY_2048.private_key()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert_bad_sig = _break_cert_sig(cert)\n        with pytest.raises(InvalidSignature):\n            cert_bad_sig.verify_directly_issued_by(ca)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\n@pytest.mark.supported(\n    only_if=lambda backend: backend.signature_hash_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA-1 signature.\",\n)\nclass TestDSACertificateRequest:\n    @pytest.mark.parametrize(\n        (\"path\", \"loader_func\"),\n        [\n            [\n                os.path.join(\"x509\", \"requests\", \"dsa_sha1.pem\"),\n                x509.load_pem_x509_csr,\n            ],\n            [\n                os.path.join(\"x509\", \"requests\", \"dsa_sha1.der\"),\n                x509.load_der_x509_csr,\n            ],\n        ],\n    )\n    def test_load_dsa_request(self, path, loader_func, backend):\n        request = _load_cert(path, loader_func)\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA1)\n        public_key = request.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n        ]\n\n    def test_signature(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"dsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.signature == binascii.unhexlify(\n            b\"302c021461d58dc028d0110818a7d817d74235727c4acfdf0214097b52e198e\"\n            b\"ce95de17273f0a924df23ce9d8188\"\n        )\n\n    def test_tbs_certrequest_bytes(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"dsa_sha1.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.tbs_certrequest_bytes == binascii.unhexlify(\n            b\"3082021802010030573118301606035504030c0f63727970746f677261706879\"\n            b\"2e696f310d300b060355040a0c0450794341310b300906035504061302555331\"\n            b\"0e300c06035504080c055465786173310f300d06035504070c0641757374696e\"\n            b\"308201b63082012b06072a8648ce3804013082011e028181008d7fadbc09e284\"\n            b\"aafa69154cea24177004909e519f8b35d685cde5b4ecdc9583e74d370a0f88ad\"\n            b\"a98f026f27762fb3d5da7836f986dfcdb3589e5b925bea114defc03ef81dae30\"\n            b\"c24bbc6df3d588e93427bba64203d4a5b1687b2b5e3b643d4c614976f89f95a3\"\n            b\"8d3e4c89065fba97514c22c50adbbf289163a74b54859b35b7021500835de56b\"\n            b\"d07cf7f82e2032fe78949aed117aa2ef0281801f717b5a07782fc2e4e68e311f\"\n            b\"ea91a54edd36b86ac634d14f05a68a97eae9d2ef31fb1ef3de42c3d100df9ca6\"\n            b\"4f5bdc2aec7bfdfb474cf831fea05853b5e059f2d24980a0ac463f1e818af352\"\n            b\"3e3cb79a39d45fa92731897752842469cf8540b01491024eaafbce6018e8a1f4\"\n            b\"658c343f4ba7c0b21e5376a21f4beb8491961e038184000281800713f07641f6\"\n            b\"369bb5a9545274a2d4c01998367fb371bb9e13436363672ed68f82174c2de05c\"\n            b\"8e839bc6de568dd50ba28d8d9d8719423aaec5557df10d773ab22d6d65cbb878\"\n            b\"04a697bc8fd965b952f9f7e850edf13c8acdb5d753b6d10e59e0b5732e3c82ba\"\n            b\"fa140342bc4a3bba16bd0681c8a6a2dbbb7efe6ce2b8463b170ba000\"\n        )\n        assert request.signature_hash_algorithm is not None\n        public_key = request.public_key()\n        assert isinstance(public_key, dsa.DSAPublicKey)\n        public_key.verify(\n            request.signature,\n            request.tbs_certrequest_bytes,\n            request.signature_hash_algorithm,\n        )\n\n\nclass TestGOSTCertificate:\n    def test_numeric_string_x509_name_entry(self):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"e-trust.ru.der\"),\n            x509.load_der_x509_certificate,\n        )\n        assert (\n            cert.subject.get_attributes_for_oid(\n                x509.ObjectIdentifier(\"1.2.643.3.131.1.1\")\n            )[0].value\n            == \"007710474375\"\n        )\n\n\nclass TestECDSACertificate:\n    def test_load_ecdsa_cert(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ecdsa_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(cert.signature_hash_algorithm, hashes.SHA384)\n        public_key = cert.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        num = public_key.public_numbers()\n        assert num.x == int(\n            \"dda7d9bb8ab80bfb0b7f21d2f0bebe73f3335d1abc34eadec69bbcd095f\"\n            \"6f0ccd00bba615b51467e9e2d9fee8e630c17\",\n            16,\n        )\n        assert num.y == int(\n            \"ec0770f5cf842e40839ce83f416d3badd3a4145936789d0343ee10136c7\"\n            \"2deae88a7a16bb543ce67dc23ff031ca3e23e\",\n            16,\n        )\n        assert isinstance(num.curve, ec.SECP384R1)\n        assert isinstance(cert.signature_algorithm_parameters, ec.ECDSA)\n        assert isinstance(\n            cert.signature_algorithm_parameters.algorithm, hashes.SHA384\n        )\n        public_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            cert.signature_algorithm_parameters,\n        )\n\n    def test_load_ecdsa_cert_null_alg_params(self, backend):\n        \"\"\"\n        This test verifies that we successfully load certificates with encoded\n        null parameters in the signature AlgorithmIdentifier. This is invalid,\n        but Java 11 (up to at least 11.0.19) generates certificates with this\n        encoding so we need to tolerate it at the moment.\n        \"\"\"\n        with pytest.warns(utils.DeprecatedIn41):\n            cert = _load_cert(\n                os.path.join(\"x509\", \"custom\", \"ecdsa_null_alg.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            assert isinstance(cert.signature_hash_algorithm, hashes.SHA256)\n            assert isinstance(cert.public_key(), ec.EllipticCurvePublicKey)\n\n    def test_load_bitstring_dn(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"scottishpower-bitstring-dn.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.subject == x509.Name(\n            [\n                x509.NameAttribute(x509.NameOID.COMMON_NAME, \"ScottishPower\"),\n                x509.NameAttribute(\n                    x509.NameOID.ORGANIZATIONAL_UNIT_NAME, \"02\"\n                ),\n                x509.NameAttribute(\n                    NameOID.X500_UNIQUE_IDENTIFIER,\n                    b\"\\x00\\x70\\xb3\\xd5\\x1f\\x30\\x5f\\x00\\x01\",\n                    _ASN1Type.BitString,\n                ),\n            ]\n        )\n        assert repr(cert.subject) == (\n            \"<Name(CN=ScottishPower,OU=02,2.5.4.45=#0070b3d51f305f0001)>\"\n        )\n\n    def test_load_name_attribute_long_form_asn1_tag(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"long-form-name-attribute.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError, match=\"Long-form\"):\n            cert.subject\n        with pytest.raises(ValueError, match=\"Long-form\"):\n            cert.issuer\n\n    def test_ms_certificate_template(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ms-certificate-template.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.MSCertificateTemplate\n        )\n        tpl = ext.value\n        assert isinstance(tpl, x509.MSCertificateTemplate)\n        assert tpl == x509.MSCertificateTemplate(\n            template_id=x509.ObjectIdentifier(\"1.2.3.4.5.6.7.8.9.0\"),\n            major_version=1,\n            minor_version=None,\n        )\n\n    def test_signature(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ecdsa_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.signature == binascii.unhexlify(\n            b\"3065023100adbcf26c3f124ad12d39c30a099773f488368c8827bbe6888d5085\"\n            b\"a763f99e32de66930ff1ccb1098fdd6cabfa6b7fa0023039665bc2648db89e50\"\n            b\"dca8d549a2edc7dcd1497f1701b8c8868f4e8c882ba89aa98ac5d100bdf854e2\"\n            b\"9ae55b7cb32717\"\n        )\n        r, s = decode_dss_signature(cert.signature)\n        assert r == int(\n            \"adbcf26c3f124ad12d39c30a099773f488368c8827bbe6888d5085a763f99e32\"\n            \"de66930ff1ccb1098fdd6cabfa6b7fa0\",\n            16,\n        )\n        assert s == int(\n            \"39665bc2648db89e50dca8d549a2edc7dcd1497f1701b8c8868f4e8c882ba89a\"\n            \"a98ac5d100bdf854e29ae55b7cb32717\",\n            16,\n        )\n\n    def test_tbs_certificate_bytes(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ecdsa_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert cert.tbs_certificate_bytes == binascii.unhexlify(\n            b\"308201c5a0030201020210055556bcf25ea43535c3a40fd5ab4572300a06082\"\n            b\"a8648ce3d0403033061310b300906035504061302555331153013060355040a\"\n            b\"130c446967694365727420496e6331193017060355040b13107777772e64696\"\n            b\"769636572742e636f6d3120301e06035504031317446967694365727420476c\"\n            b\"6f62616c20526f6f74204733301e170d3133303830313132303030305a170d3\"\n            b\"338303131353132303030305a3061310b300906035504061302555331153013\"\n            b\"060355040a130c446967694365727420496e6331193017060355040b1310777\"\n            b\"7772e64696769636572742e636f6d3120301e06035504031317446967694365\"\n            b\"727420476c6f62616c20526f6f742047333076301006072a8648ce3d0201060\"\n            b\"52b8104002203620004dda7d9bb8ab80bfb0b7f21d2f0bebe73f3335d1abc34\"\n            b\"eadec69bbcd095f6f0ccd00bba615b51467e9e2d9fee8e630c17ec0770f5cf8\"\n            b\"42e40839ce83f416d3badd3a4145936789d0343ee10136c72deae88a7a16bb5\"\n            b\"43ce67dc23ff031ca3e23ea3423040300f0603551d130101ff040530030101f\"\n            b\"f300e0603551d0f0101ff040403020186301d0603551d0e04160414b3db48a4\"\n            b\"f9a1c5d8ae3641cc1163696229bc4bc6\"\n        )\n        assert cert.signature_hash_algorithm is not None\n        public_key = cert.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        public_key.verify(\n            cert.signature,\n            cert.tbs_certificate_bytes,\n            ec.ECDSA(cert.signature_hash_algorithm),\n        )\n\n    def test_load_ecdsa_no_named_curve(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ec_no_named_curve.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        # This test can trigger three different value errors depending\n        # on OpenSSL/BoringSSL and versions. Match on the text to ensure\n        # we are getting the right error.\n        with pytest.raises(ValueError, match=\"explicit parameters\"):\n            cert.public_key()\n\n    def test_verify_directly_issued_by_ec(self):\n        issuer_private_key = ec.generate_private_key(ec.SECP256R1())\n        subject_private_key = ec.generate_private_key(ec.SECP256R1())\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_ec_bad_sig(self):\n        issuer_private_key = ec.generate_private_key(ec.SECP256R1())\n        subject_private_key = ec.generate_private_key(ec.SECP256R1())\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert_bad_sig = _break_cert_sig(cert)\n        with pytest.raises(InvalidSignature):\n            cert_bad_sig.verify_directly_issued_by(ca)\n\n\nclass TestECDSACertificateRequest:\n    @pytest.mark.parametrize(\n        (\"path\", \"loader_func\"),\n        [\n            [\n                os.path.join(\"x509\", \"requests\", \"ec_sha256.pem\"),\n                x509.load_pem_x509_csr,\n            ],\n            [\n                os.path.join(\"x509\", \"requests\", \"ec_sha256.der\"),\n                x509.load_der_x509_csr,\n            ],\n        ],\n    )\n    def test_load_ecdsa_certificate_request(self, path, loader_func, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        request = _load_cert(path, loader_func)\n        assert isinstance(request.signature_hash_algorithm, hashes.SHA256)\n        public_key = request.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        subject = request.subject\n        assert isinstance(subject, x509.Name)\n        assert list(subject) == [\n            x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n            x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"),\n            x509.NameAttribute(NameOID.LOCALITY_NAME, \"Austin\"),\n        ]\n\n    def test_signature(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"ec_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.signature == binascii.unhexlify(\n            b\"306502302c1a9f7de8c1787332d2307a886b476a59f172b9b0e250262f3238b1\"\n            b\"b45ee112bb6eb35b0fb56a123b9296eb212dffc302310094cf440c95c52827d5\"\n            b\"56ae6d76500e3008255d47c29f7ee782ed7558e51bfd76aa45df6d999ed5c463\"\n            b\"347fe2382d1751\"\n        )\n\n    def test_tbs_certrequest_bytes(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"ec_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert request.tbs_certrequest_bytes == binascii.unhexlify(\n            b\"3081d602010030573118301606035504030c0f63727970746f6772617068792\"\n            b\"e696f310d300b060355040a0c0450794341310b300906035504061302555331\"\n            b\"0e300c06035504080c055465786173310f300d06035504070c0641757374696\"\n            b\"e3076301006072a8648ce3d020106052b8104002203620004de19b514c0b3c3\"\n            b\"ae9b398ea3e26b5e816bdcf9102cad8f12fe02f9e4c9248724b39297ed7582e\"\n            b\"04d8b32a551038d09086803a6d3fb91a1a1167ec02158b00efad39c9396462f\"\n            b\"accff0ffaf7155812909d3726bd59fde001cff4bb9b2f5af8cbaa000\"\n        )\n        assert request.signature_hash_algorithm is not None\n        public_key = request.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        public_key.verify(\n            request.signature,\n            request.tbs_certrequest_bytes,\n            ec.ECDSA(request.signature_hash_algorithm),\n        )\n\n\nclass TestOtherCertificate:\n    def test_unsupported_subject_public_key_info(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"unsupported_subject_public_key_info.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n\n        with pytest.raises(ValueError):\n            cert.public_key()\n\n    def test_bad_time_in_validity(self, backend):\n        with pytest.raises(ValueError, match=\"Validity::not_after\"):\n            _load_cert(\n                os.path.join(\"x509\", \"badasn1time.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n\n\nclass TestNameAttribute:\n    EXPECTED_TYPES: typing.ClassVar[\n        typing.List[typing.Tuple[x509.ObjectIdentifier, _ASN1Type]]\n    ] = [\n        (NameOID.COMMON_NAME, _ASN1Type.UTF8String),\n        (NameOID.COUNTRY_NAME, _ASN1Type.PrintableString),\n        (NameOID.LOCALITY_NAME, _ASN1Type.UTF8String),\n        (NameOID.STATE_OR_PROVINCE_NAME, _ASN1Type.UTF8String),\n        (NameOID.STREET_ADDRESS, _ASN1Type.UTF8String),\n        (NameOID.ORGANIZATION_NAME, _ASN1Type.UTF8String),\n        (NameOID.ORGANIZATIONAL_UNIT_NAME, _ASN1Type.UTF8String),\n        (NameOID.SERIAL_NUMBER, _ASN1Type.PrintableString),\n        (NameOID.SURNAME, _ASN1Type.UTF8String),\n        (NameOID.GIVEN_NAME, _ASN1Type.UTF8String),\n        (NameOID.TITLE, _ASN1Type.UTF8String),\n        (NameOID.GENERATION_QUALIFIER, _ASN1Type.UTF8String),\n        (NameOID.X500_UNIQUE_IDENTIFIER, _ASN1Type.UTF8String),\n        (NameOID.DN_QUALIFIER, _ASN1Type.PrintableString),\n        (NameOID.PSEUDONYM, _ASN1Type.UTF8String),\n        (NameOID.USER_ID, _ASN1Type.UTF8String),\n        (NameOID.DOMAIN_COMPONENT, _ASN1Type.IA5String),\n        (NameOID.EMAIL_ADDRESS, _ASN1Type.IA5String),\n        (NameOID.JURISDICTION_COUNTRY_NAME, _ASN1Type.PrintableString),\n        (NameOID.JURISDICTION_LOCALITY_NAME, _ASN1Type.UTF8String),\n        (NameOID.JURISDICTION_STATE_OR_PROVINCE_NAME, _ASN1Type.UTF8String),\n        (NameOID.BUSINESS_CATEGORY, _ASN1Type.UTF8String),\n        (NameOID.POSTAL_ADDRESS, _ASN1Type.UTF8String),\n        (NameOID.POSTAL_CODE, _ASN1Type.UTF8String),\n    ]\n\n    def test_default_types(self):\n        for oid, asn1_type in TestNameAttribute.EXPECTED_TYPES:\n            na = x509.NameAttribute(oid, \"US\")\n            assert na._type == asn1_type\n\n    def test_alternate_type(self):\n        na2 = x509.NameAttribute(\n            NameOID.COMMON_NAME, \"common\", _ASN1Type.IA5String\n        )\n        assert na2._type == _ASN1Type.IA5String\n\n    def test_init_bad_oid(self):\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                None,  # type:ignore[arg-type]\n                \"value\",\n            )\n\n    def test_init_bad_value(self):\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                x509.ObjectIdentifier(\"2.999.1\"),\n                b\"bytes\",\n            )\n\n    def test_init_bitstring_not_bytes(self):\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                x509.ObjectIdentifier(\"2.5.4.45\"), \"str\", _ASN1Type.BitString\n            )\n\n    def test_init_bitstring_not_allowed_random_oid(self):\n        # We only allow BitString type with X500_UNIQUE_IDENTIFIER\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                x509.NameOID.COMMON_NAME, b\"ok\", _ASN1Type.BitString\n            )\n\n    def test_init_none_value(self):\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                NameOID.ORGANIZATION_NAME,\n                None,  # type:ignore[arg-type]\n            )\n\n    def test_init_bad_country_code_value(self):\n        with pytest.raises(ValueError):\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"United States\")\n\n        # unicode string of length 2, but > 2 bytes\n        with pytest.raises(ValueError):\n            x509.NameAttribute(NameOID.COUNTRY_NAME, \"\\U0001f37a\\U0001f37a\")\n\n    def test_invalid_type(self):\n        with pytest.raises(TypeError):\n            x509.NameAttribute(\n                NameOID.COMMON_NAME,\n                \"common\",\n                \"notanenum\",  # type:ignore[arg-type]\n            )\n\n    def test_eq(self):\n        assert x509.NameAttribute(\n            x509.ObjectIdentifier(\"2.999.1\"), \"value\"\n        ) == x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value\")\n\n    def test_ne(self):\n        assert x509.NameAttribute(\n            x509.ObjectIdentifier(\"2.5.4.3\"), \"value\"\n        ) != x509.NameAttribute(x509.ObjectIdentifier(\"2.5.4.5\"), \"value\")\n        assert x509.NameAttribute(\n            x509.ObjectIdentifier(\"2.999.1\"), \"value\"\n        ) != x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value2\")\n        assert (\n            x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value\")\n            != object()\n        )\n\n    def test_repr(self):\n        na = x509.NameAttribute(x509.ObjectIdentifier(\"2.5.4.3\"), \"value\")\n        assert repr(na) == (\n            \"<NameAttribute(oid=<ObjectIdentifier(oid=2.5.4.3, name=commo\"\n            \"nName)>, value='value')>\"\n        )\n\n    def test_distinguished_name(self):\n        # Escaping\n        na = x509.NameAttribute(NameOID.COMMON_NAME, 'James \"Jim\" Smith, III')\n        assert na.rfc4514_string() == r\"CN=James \\\"Jim\\\" Smith\\, III\"\n        na = x509.NameAttribute(NameOID.USER_ID, \"# escape+,;\\0this \")\n        assert na.rfc4514_string() == r\"UID=\\# escape\\+\\,\\;\\00this\\ \"\n\n        # Nonstandard attribute OID\n        na = x509.NameAttribute(NameOID.BUSINESS_CATEGORY, \"banking\")\n        assert na.rfc4514_string() == \"2.5.4.15=banking\"\n\n        # non-utf8 attribute (bitstring with raw bytes)\n        na = x509.NameAttribute(\n            x509.ObjectIdentifier(\"2.5.4.45\"),\n            b\"\\x01\\x02\\x03\\x04\",\n            _ASN1Type.BitString,\n        )\n        assert na.rfc4514_string() == \"2.5.4.45=#01020304\"\n\n    def test_distinguished_name_custom_attrs(self):\n        name = x509.Name(\n            [\n                x509.NameAttribute(NameOID.EMAIL_ADDRESS, \"santa@north.pole\"),\n                x509.NameAttribute(NameOID.COMMON_NAME, \"Santa Claus\"),\n            ]\n        )\n        assert name.rfc4514_string({}) == (\n            \"CN=Santa Claus,1.2.840.113549.1.9.1=santa@north.pole\"\n        )\n        assert name.rfc4514_string({NameOID.EMAIL_ADDRESS: \"E\"}) == (\n            \"CN=Santa Claus,E=santa@north.pole\"\n        )\n        assert name.rfc4514_string(\n            {NameOID.COMMON_NAME: \"CommonName\", NameOID.EMAIL_ADDRESS: \"E\"}\n        ) == (\"CommonName=Santa Claus,E=santa@north.pole\")\n\n    def test_empty_name(self):\n        assert x509.Name([]).rfc4514_string() == \"\"\n\n    def test_empty_value(self):\n        na = x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"\")\n        assert na.rfc4514_string() == r\"ST=\"\n\n\nclass TestRelativeDistinguishedName:\n    def test_init_empty(self):\n        with pytest.raises(ValueError):\n            x509.RelativeDistinguishedName([])\n\n    def test_init_not_nameattribute(self):\n        with pytest.raises(TypeError):\n            x509.RelativeDistinguishedName(\n                [\"not-a-NameAttribute\"]  # type:ignore[list-item]\n            )\n\n    def test_init_duplicate_attribute(self):\n        with pytest.raises(ValueError):\n            x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.1\"), \"val1\"\n                    ),\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.1\"), \"val1\"\n                    ),\n                ]\n            )\n\n    def test_hash(self):\n        rdn1 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\"),\n            ]\n        )\n        rdn2 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n            ]\n        )\n        rdn3 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value3\"),\n            ]\n        )\n        assert hash(rdn1) == hash(rdn2)\n        assert hash(rdn1) != hash(rdn3)\n\n    def test_eq(self):\n        rdn1 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\"),\n            ]\n        )\n        rdn2 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n            ]\n        )\n        assert rdn1 == rdn2\n\n    def test_ne(self):\n        rdn1 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\"),\n            ]\n        )\n        rdn2 = x509.RelativeDistinguishedName(\n            [\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n                x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value3\"),\n            ]\n        )\n        assert rdn1 != rdn2\n        assert rdn1 != object()\n\n    def test_iter_input(self):\n        # Order must be preserved too\n        attrs = [\n            x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\"),\n            x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value2\"),\n            x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value3\"),\n        ]\n        rdn = x509.RelativeDistinguishedName(iter(attrs))\n        assert list(rdn) == attrs\n        assert list(rdn) == attrs\n\n    def test_get_attributes_for_oid(self):\n        oid = x509.ObjectIdentifier(\"2.999.1\")\n        attr = x509.NameAttribute(oid, \"value1\")\n        rdn = x509.RelativeDistinguishedName([attr])\n        assert rdn.get_attributes_for_oid(oid) == [attr]\n        assert rdn.get_attributes_for_oid(x509.ObjectIdentifier(\"1.2.3\")) == []\n\n\nclass TestObjectIdentifier:\n    def test_eq(self):\n        oid1 = x509.ObjectIdentifier(\"2.999.1\")\n        oid2 = x509.ObjectIdentifier(\"2.999.1\")\n        assert oid1 == oid2\n\n    def test_ne(self):\n        oid1 = x509.ObjectIdentifier(\"2.999.1\")\n        assert oid1 != x509.ObjectIdentifier(\"2.999.2\")\n        assert oid1 != object()\n\n    def test_comparison(self):\n        oid1 = x509.ObjectIdentifier(\"2.999.1\")\n        oid2 = x509.ObjectIdentifier(\"2.999.2\")\n        with pytest.raises(TypeError):\n            oid1 < oid2  # type: ignore[operator]\n\n    def test_repr(self):\n        oid = x509.ObjectIdentifier(\"2.5.4.3\")\n        assert repr(oid) == \"<ObjectIdentifier(oid=2.5.4.3, name=commonName)>\"\n        oid = x509.ObjectIdentifier(\"2.999.1\")\n        assert repr(oid) == \"<ObjectIdentifier(oid=2.999.1, name=Unknown OID)>\"\n\n    def test_name_property(self):\n        oid = x509.ObjectIdentifier(\"2.5.4.3\")\n        assert oid._name == \"commonName\"\n        oid = x509.ObjectIdentifier(\"2.999.1\")\n        assert oid._name == \"Unknown OID\"\n\n    def test_too_short(self):\n        with pytest.raises(ValueError):\n            x509.ObjectIdentifier(\"1\")\n\n    def test_invalid_input(self):\n        with pytest.raises(ValueError):\n            x509.ObjectIdentifier(\"notavalidform\")\n\n    def test_invalid_node1(self):\n        with pytest.raises(ValueError):\n            x509.ObjectIdentifier(\"7.1.37\")\n\n    def test_invalid_node2(self):\n        with pytest.raises(ValueError):\n            x509.ObjectIdentifier(\"1.50.200\")\n\n    def test_valid(self):\n        x509.ObjectIdentifier(\"0.35.200\")\n        x509.ObjectIdentifier(\"1.39.999\")\n        x509.ObjectIdentifier(\"2.5.29.3\")\n        x509.ObjectIdentifier(\"2.999.37.5.22.8\")\n\n    def test_oid_arc_too_large(self):\n        with pytest.raises(ValueError):\n            x509.ObjectIdentifier(f\"2.25.{2**128 - 1}\")\n\n\nclass TestName:\n    def test_eq(self):\n        ava1 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")\n        ava2 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")\n        name1 = x509.Name([ava1, ava2])\n        name2 = x509.Name(\n            [\n                x509.RelativeDistinguishedName([ava1]),\n                x509.RelativeDistinguishedName([ava2]),\n            ]\n        )\n        name3 = x509.Name([x509.RelativeDistinguishedName([ava1, ava2])])\n        name4 = x509.Name([x509.RelativeDistinguishedName([ava2, ava1])])\n        assert name1 == name2\n        assert name3 == name4\n\n    def test_ne(self):\n        ava1 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")\n        ava2 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")\n        name1 = x509.Name([ava1, ava2])\n        name2 = x509.Name([ava2, ava1])\n        name3 = x509.Name([x509.RelativeDistinguishedName([ava1, ava2])])\n        assert name1 != name2\n        assert name1 != name3\n        assert name1 != object()\n\n    def test_hash(self):\n        ava1 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")\n        ava2 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")\n        name1 = x509.Name([ava1, ava2])\n        name2 = x509.Name(\n            [\n                x509.RelativeDistinguishedName([ava1]),\n                x509.RelativeDistinguishedName([ava2]),\n            ]\n        )\n        name3 = x509.Name([ava2, ava1])\n        name4 = x509.Name([x509.RelativeDistinguishedName([ava1, ava2])])\n        name5 = x509.Name([x509.RelativeDistinguishedName([ava2, ava1])])\n        assert hash(name1) == hash(name2)\n        assert hash(name1) != hash(name3)\n        assert hash(name1) != hash(name4)\n        assert hash(name4) == hash(name5)\n\n    def test_iter_input(self):\n        attrs = [\n            x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")\n        ]\n        name = x509.Name(iter(attrs))\n        assert list(name) == attrs\n        assert list(name) == attrs\n\n    def test_rdns(self):\n        rdn1 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")\n        rdn2 = x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")\n        name1 = x509.Name([rdn1, rdn2])\n        assert name1.rdns == [\n            x509.RelativeDistinguishedName([rdn1]),\n            x509.RelativeDistinguishedName([rdn2]),\n        ]\n        name2 = x509.Name([x509.RelativeDistinguishedName([rdn1, rdn2])])\n        assert name2.rdns == [x509.RelativeDistinguishedName([rdn1, rdn2])]\n\n    @pytest.mark.parametrize(\n        (\"common_name\", \"org_name\", \"expected_repr\"),\n        [\n            (\n                \"cryptography.io\",\n                \"PyCA\",\n                \"<Name(CN=cryptography.io,O=PyCA)>\",\n            ),\n            (\n                \"Certificaci\u00f3n\",\n                \"Certificaci\u00f3n\",\n                \"<Name(CN=Certificaci\u00f3n,O=Certificaci\u00f3n)>\",\n            ),\n        ],\n    )\n    def test_repr(self, common_name, org_name, expected_repr):\n        name = x509.Name(\n            [\n                x509.NameAttribute(NameOID.COMMON_NAME, common_name),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, org_name),\n            ]\n        )\n\n        assert repr(name) == expected_repr\n\n    def test_rfc4514_attribute_name(self):\n        a = x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\")\n        assert a.rfc4514_attribute_name == \"CN\"\n        b = x509.NameAttribute(NameOID.PSEUDONYM, \"cryptography.io\")\n        assert b.rfc4514_attribute_name == \"2.5.4.65\"\n\n    def test_rfc4514_string(self):\n        n = x509.Name(\n            [\n                x509.RelativeDistinguishedName(\n                    [x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"net\")]\n                ),\n                x509.RelativeDistinguishedName(\n                    [x509.NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\")]\n                ),\n                x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(\n                            NameOID.ORGANIZATIONAL_UNIT_NAME, \"Sales\"\n                        ),\n                        x509.NameAttribute(NameOID.COMMON_NAME, \"J.  Smith\"),\n                    ]\n                ),\n            ]\n        )\n        assert n.rfc4514_string() == \"OU=Sales+CN=J.  Smith,DC=example,DC=net\"\n\n    def test_rfc4514_string_empty_values(self):\n        n = x509.Name(\n            [\n                x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                x509.NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"\"),\n                x509.NameAttribute(NameOID.LOCALITY_NAME, \"\"),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n            ]\n        )\n        assert n.rfc4514_string() == \"CN=cryptography.io,O=PyCA,L=,ST=,C=US\"\n\n    def test_not_nameattribute(self):\n        with pytest.raises(TypeError):\n            x509.Name([\"not-a-NameAttribute\"])  # type: ignore[list-item]\n\n    def test_bytes(self, backend):\n        name = x509.Name(\n            [\n                x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            ]\n        )\n        assert name.public_bytes(backend) == binascii.unhexlify(\n            b\"30293118301606035504030c0f63727970746f6772617068792e696f310d300\"\n            b\"b060355040a0c0450794341\"\n        )\n\n    def test_bitstring_encoding(self):\n        name = x509.Name(\n            [\n                x509.NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n                x509.NameAttribute(\n                    x509.ObjectIdentifier(\"2.5.4.45\"),\n                    b\"\\x01\\x02\",\n                    _ASN1Type.BitString,\n                ),\n            ]\n        )\n        assert name.public_bytes() == binascii.unhexlify(\n            b\"30273118301606035504030c0f63727970746f6772617068792e696f310b3\"\n            b\"009060355042d03020102\"\n        )\n\n    def test_bmpstring_bytes(self, backend):\n        # For this test we need an odd length string. BMPString is UCS-2\n        # encoded so it will always be even length and OpenSSL will error if\n        # you pass an odd length string without encoding it properly first.\n        name = x509.Name(\n            [\n                x509.NameAttribute(\n                    NameOID.COMMON_NAME,\n                    \"cryptography.io\",\n                    _ASN1Type.BMPString,\n                ),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            ]\n        )\n        assert name.public_bytes(backend) == binascii.unhexlify(\n            b\"30383127302506035504031e1e00630072007900700074006f00670072006100\"\n            b\"7000680079002e0069006f310d300b060355040a0c0450794341\"\n        )\n\n    def test_universalstring_bytes(self, backend):\n        # UniversalString is UCS-4\n        name = x509.Name(\n            [\n                x509.NameAttribute(\n                    NameOID.COMMON_NAME,\n                    \"cryptography.io\",\n                    _ASN1Type.UniversalString,\n                ),\n                x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n            ]\n        )\n        assert name.public_bytes(backend) == binascii.unhexlify(\n            b\"30563145304306035504031c3c00000063000000720000007900000070000000\"\n            b\"740000006f000000670000007200000061000000700000006800000079000000\"\n            b\"2e000000690000006f310d300b060355040a0c0450794341\"\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\nclass TestEd25519Certificate:\n    def test_load_pem_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ed25519\", \"root-ed25519.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        # self-signed, so this will work\n        public_key = cert.public_key()\n        assert isinstance(public_key, ed25519.Ed25519PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED25519\n        public_key.verify(cert.signature, cert.tbs_certificate_bytes)\n        assert isinstance(cert, x509.Certificate)\n        assert cert.serial_number == 9579446940964433301\n        assert cert.signature_hash_algorithm is None\n        assert cert.signature_algorithm_oid == SignatureAlgorithmOID.ED25519\n        assert cert.signature_algorithm_parameters is None\n\n    def test_deepcopy(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ed25519\", \"root-ed25519.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert copy.deepcopy(cert) is cert\n\n    def test_verify_directly_issued_by_ed25519(self, backend):\n        issuer_private_key = ed25519.Ed25519PrivateKey.generate()\n        subject_private_key = ed25519.Ed25519PrivateKey.generate()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_ed25519_bad_sig(self, backend):\n        issuer_private_key = ed25519.Ed25519PrivateKey.generate()\n        subject_private_key = ed25519.Ed25519PrivateKey.generate()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert_bad_sig = _break_cert_sig(cert)\n        with pytest.raises(InvalidSignature):\n            cert_bad_sig.verify_directly_issued_by(ca)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\nclass TestEd448Certificate:\n    def test_load_pem_cert(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ed448\", \"root-ed448.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        # self-signed, so this will work\n        public_key = cert.public_key()\n        assert isinstance(public_key, ed448.Ed448PublicKey)\n        assert cert.public_key_algorithm_oid == PublicKeyAlgorithmOID.ED448\n        public_key.verify(cert.signature, cert.tbs_certificate_bytes)\n        assert isinstance(cert, x509.Certificate)\n        assert cert.serial_number == 448\n        assert cert.signature_hash_algorithm is None\n        assert cert.signature_algorithm_oid == SignatureAlgorithmOID.ED448\n        assert cert.signature_algorithm_parameters is None\n\n    def test_verify_directly_issued_by_ed448(self, backend):\n        issuer_private_key = ed448.Ed448PrivateKey.generate()\n        subject_private_key = ed448.Ed448PrivateKey.generate()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert.verify_directly_issued_by(ca)\n\n    def test_verify_directly_issued_by_ed448_bad_sig(self, backend):\n        issuer_private_key = ed448.Ed448PrivateKey.generate()\n        subject_private_key = ed448.Ed448PrivateKey.generate()\n        ca, cert = _generate_ca_and_leaf(\n            issuer_private_key, subject_private_key\n        )\n        cert_bad_sig = _break_cert_sig(cert)\n        with pytest.raises(InvalidSignature):\n            cert_bad_sig.verify_directly_issued_by(ca)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestSignatureRejection:\n    \"\"\"Test if signing rejects DH keys properly.\"\"\"\n\n    def load_key(self, backend):\n        vector = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"rfc3526.txt\"),\n            load_nist_vectors,\n        )[1]\n        p = int.from_bytes(binascii.unhexlify(vector[\"p\"]), \"big\")\n        params = dh.DHParameterNumbers(p, int(vector[\"g\"]))\n        param = params.parameters(backend)\n        return param.generate_private_key()\n\n    def test_crt_signing_check(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        issuer_private_key = self.load_key(backend)\n        public_key = rsa_key_2048.public_key()\n        not_valid_before = datetime.datetime(2020, 1, 1, 1, 1)\n        not_valid_after = datetime.datetime(2050, 12, 31, 8, 30)\n        builder = (\n            x509.CertificateBuilder()\n            .serial_number(777)\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .public_key(public_key)\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(issuer_private_key, hashes.SHA256(), backend)\n\n    def test_csr_signing_check(self, backend):\n        private_key = self.load_key(backend)\n        builder = x509.CertificateSigningRequestBuilder().subject_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_crl_signing_check(self, backend):\n        private_key = self.load_key(backend)\n        last_time = (\n            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n        )\n        next_time = last_time\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"CA\")])\n            )\n            .last_update(last_time)\n            .next_update(next_time)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n\ndef test_random_serial_number(monkeypatch):\n    sample_data = os.urandom(20)\n\n    def notrandom(size):\n        assert size == len(sample_data)\n        return sample_data\n\n    monkeypatch.setattr(os, \"urandom\", notrandom)\n\n    serial_number = x509.random_serial_number()\n\n    assert serial_number == int.from_bytes(sample_data, \"big\") >> 1\n    assert serial_number.bit_length() < 160\n\n\nclass TestAttribute:\n    def test_eq(self):\n        attr1 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n        )\n        attr2 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n        )\n        assert attr1 == attr2\n\n    def test_ne(self):\n        attr1 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n        )\n        attr2 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n            _ASN1Type.IA5String.value,\n        )\n        attr3 = x509.Attribute(\n            x509.oid.AttributeOID.UNSTRUCTURED_NAME,\n            b\"value\",\n        )\n        attr4 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"other value\",\n        )\n        assert attr1 != attr2\n        assert attr1 != attr3\n        assert attr1 != attr4\n        assert attr1 != object()\n\n    def test_repr(self):\n        attr1 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n        )\n        assert repr(attr1) == (\n            \"<Attribute(oid=<ObjectIdentifier(oid=1.2.840.113549.1.9.7, name=\"\n            \"challengePassword)>, value=b'value')>\"\n        )\n\n    def test_hash(self):\n        attr1 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n            _ASN1Type.UTF8String.value,\n        )\n        attr2 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n            _ASN1Type.UTF8String.value,\n        )\n        attr3 = x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"value\",\n            _ASN1Type.IA5String.value,\n        )\n        assert hash(attr1) == hash(attr2)\n        assert hash(attr1) != hash(attr3)\n\n\nclass TestAttributes:\n    def test_no_attributes(self):\n        attrs = x509.Attributes([])\n        assert len(attrs) == 0\n\n    def test_get_attribute_for_oid(self):\n        attr_list = [\n            x509.Attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n                b\"nonsense\",\n            ),\n            x509.Attribute(\n                x509.oid.AttributeOID.UNSTRUCTURED_NAME,\n                b\"montessori\",\n                _ASN1Type.PrintableString.value,\n            ),\n        ]\n        attrs = x509.Attributes(attr_list)\n        attr = attrs.get_attribute_for_oid(\n            x509.oid.AttributeOID.UNSTRUCTURED_NAME\n        )\n        assert attr.oid == x509.oid.AttributeOID.UNSTRUCTURED_NAME\n        assert attr.value == b\"montessori\"\n        assert attr._type == _ASN1Type.PrintableString.value\n\n    def test_indexing(self):\n        attr_list = [\n            x509.Attribute(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n                b\"nonsense\",\n            ),\n            x509.Attribute(\n                x509.oid.AttributeOID.UNSTRUCTURED_NAME,\n                b\"montessori\",\n            ),\n            x509.Attribute(\n                x509.ObjectIdentifier(\"2.999.2\"),\n                b\"meaningless\",\n            ),\n            x509.Attribute(\n                x509.ObjectIdentifier(\"2.999.1\"),\n                b\"meaningless\",\n            ),\n        ]\n        attrs = x509.Attributes(attr_list)\n        assert len(attrs) == 4\n        assert list(attrs) == attr_list\n        assert attrs[-1] == attrs[3]\n        assert attrs[0:3:2] == [attrs[0], attrs[2]]\n\n    def test_get_attribute_not_found(self):\n        attrs = x509.Attributes([])\n        with pytest.raises(x509.AttributeNotFound) as exc:\n            attrs.get_attribute_for_oid(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD\n            )\n        assert exc.value.oid == x509.oid.AttributeOID.CHALLENGE_PASSWORD\n\n    def test_repr(self):\n        attrs = x509.Attributes(\n            [\n                x509.Attribute(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n                    b\"nonsense\",\n                ),\n            ]\n        )\n        assert repr(attrs) == (\n            \"<Attributes([<Attribute(oid=<ObjectIdentifier(oid=1.2.840.11354\"\n            \"9.1.9.7, name=challengePassword)>, value=b'nonsense')>])>\"\n        )\n\n\nclass TestRequestAttributes:\n    def test_get_attribute_for_oid_challenge(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"challenge.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.warns(utils.DeprecatedIn36):\n            assert (\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD\n                )\n                == b\"challenge me!\"\n            )\n\n        assert request.attributes.get_attribute_for_oid(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD\n        ) == x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"challenge me!\",\n        )\n\n    def test_get_attribute_for_oid_multiple(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"challenge-unstructured.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.warns(utils.DeprecatedIn36):\n            assert (\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD\n                )\n                == b\"beauty\"\n            )\n\n        with pytest.warns(utils.DeprecatedIn36):\n            assert (\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.UNSTRUCTURED_NAME\n                )\n                == b\"an unstructured field\"\n            )\n\n        assert request.attributes.get_attribute_for_oid(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD\n        ) == x509.Attribute(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD,\n            b\"beauty\",\n        )\n\n        assert request.attributes.get_attribute_for_oid(\n            x509.oid.AttributeOID.UNSTRUCTURED_NAME\n        ) == x509.Attribute(\n            x509.oid.AttributeOID.UNSTRUCTURED_NAME,\n            b\"an unstructured field\",\n        )\n\n    def test_unsupported_asn1_type_in_attribute(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"challenge-invalid.der\"),\n            x509.load_der_x509_csr,\n        )\n\n        # Unsupported in the legacy path\n        with pytest.raises(ValueError):\n            with pytest.warns(utils.DeprecatedIn36):\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD\n                )\n\n        # supported in the new path where we just store the type and\n        # return raw bytes\n        attr = request.attributes.get_attribute_for_oid(\n            x509.oid.AttributeOID.CHALLENGE_PASSWORD\n        )\n        assert attr._type == 2\n\n    def test_long_form_asn1_tag_in_attribute(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"long-form-attribute.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.raises(ValueError, match=\"Long-form\"):\n            request.attributes\n\n    def test_challenge_multivalued(self, backend):\n        \"\"\"\n        We only support single-valued SETs in our X509 request attributes\n        \"\"\"\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"challenge-multi-valued.der\"),\n            x509.load_der_x509_csr,\n        )\n        with pytest.raises(ValueError, match=\"Only single-valued\"):\n            with pytest.warns(utils.DeprecatedIn36):\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD\n                )\n\n        with pytest.raises(ValueError, match=\"Only single-valued\"):\n            request.attributes\n\n    def test_no_challenge_password(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        with pytest.raises(x509.AttributeNotFound) as exc:\n            with pytest.warns(utils.DeprecatedIn36):\n                request.get_attribute_for_oid(\n                    x509.oid.AttributeOID.CHALLENGE_PASSWORD\n                )\n        assert exc.value.oid == x509.oid.AttributeOID.CHALLENGE_PASSWORD\n\n        with pytest.raises(x509.AttributeNotFound) as exc:\n            request.attributes.get_attribute_for_oid(\n                x509.oid.AttributeOID.CHALLENGE_PASSWORD\n            )\n        assert exc.value.oid == x509.oid.AttributeOID.CHALLENGE_PASSWORD\n\n    def test_no_attributes(self, backend):\n        request = _load_cert(\n            os.path.join(\"x509\", \"requests\", \"rsa_sha256.pem\"),\n            x509.load_pem_x509_csr,\n        )\n        assert len(request.attributes) == 0\n\n\ndef test_load_pem_x509_certificates():\n    with pytest.raises(ValueError):\n        x509.load_pem_x509_certificates(b\"\")\n\n    certs = load_vectors_from_file(\n        filename=os.path.join(\"x509\", \"cryptography.io.chain.pem\"),\n        loader=lambda pemfile: x509.load_pem_x509_certificates(pemfile.read()),\n        mode=\"rb\",\n    )\n    assert len(certs) == 2\n    assert certs[0].serial_number == 16160\n    assert certs[1].serial_number == 146039\n\n    certs = load_vectors_from_file(\n        filename=os.path.join(\n            \"x509\", \"cryptography.io.chain_with_garbage.pem\"\n        ),\n        loader=lambda pemfile: x509.load_pem_x509_certificates(pemfile.read()),\n        mode=\"rb\",\n    )\n    assert len(certs) == 2\n    assert certs[0].serial_number == 16160\n    assert certs[1].serial_number == 146039\n", "tests/x509/test_x509_crlbuilder.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport datetime\n\nimport pytest\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import (\n    ec,\n    ed448,\n    ed25519,\n    padding,\n    rsa,\n)\nfrom cryptography.x509.oid import (\n    AuthorityInformationAccessOID,\n    NameOID,\n    SignatureAlgorithmOID,\n)\n\nfrom ..hazmat.primitives.fixtures_dsa import DSA_KEY_2048\nfrom ..hazmat.primitives.fixtures_ec import EC_KEY_SECP256R1\nfrom ..hazmat.primitives.test_ec import _skip_curve_unsupported\nfrom ..hazmat.primitives.test_rsa import rsa_key_512, rsa_key_2048\nfrom .test_x509 import DummyExtension\n\n# Make ruff happy since we're importing fixtures that pytest patches in as\n# func args\n__all__ = [\"rsa_key_512\", \"rsa_key_2048\"]\n\n\nclass TestCertificateRevocationListBuilder:\n    def test_issuer_name_invalid(self):\n        builder = x509.CertificateRevocationListBuilder()\n        with pytest.raises(TypeError):\n            builder.issuer_name(\"notanx509name\")  # type:ignore[arg-type]\n\n    def test_set_issuer_name_twice(self):\n        builder = x509.CertificateRevocationListBuilder().issuer_name(\n            x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n        )\n        with pytest.raises(ValueError):\n            builder.issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n\n    def test_aware_last_update(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        tz = datetime.timezone(datetime.timedelta(hours=-8))\n        last_time = datetime.datetime(2012, 1, 16, 22, 43, tzinfo=tz)\n        utc_last = datetime.datetime(2012, 1, 17, 6, 43)\n        next_time = datetime.datetime(2022, 1, 17, 6, 43)\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_time)\n            .next_update(next_time)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl.last_update == utc_last\n        assert crl.last_update_utc == utc_last.replace(\n            tzinfo=datetime.timezone.utc\n        )\n\n    def test_last_update_invalid(self):\n        builder = x509.CertificateRevocationListBuilder()\n        with pytest.raises(TypeError):\n            builder.last_update(\"notadatetime\")  # type:ignore[arg-type]\n\n    def test_last_update_before_1950(self):\n        builder = x509.CertificateRevocationListBuilder()\n        with pytest.raises(ValueError):\n            builder.last_update(datetime.datetime(1940, 8, 10))\n\n    def test_set_last_update_twice(self):\n        builder = x509.CertificateRevocationListBuilder().last_update(\n            datetime.datetime(2002, 1, 1, 12, 1)\n        )\n        with pytest.raises(ValueError):\n            builder.last_update(datetime.datetime(2002, 1, 1, 12, 1))\n\n    def test_aware_next_update(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        tz = datetime.timezone(datetime.timedelta(hours=-8))\n        next_time = datetime.datetime(2022, 1, 16, 22, 43, tzinfo=tz)\n        utc_next = datetime.datetime(2022, 1, 17, 6, 43)\n        last_time = datetime.datetime(2012, 1, 17, 6, 43)\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_time)\n            .next_update(next_time)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl.next_update == utc_next\n        assert crl.next_update_utc == utc_next.replace(\n            tzinfo=datetime.timezone.utc\n        )\n\n    def test_next_update_invalid(self):\n        builder = x509.CertificateRevocationListBuilder()\n        with pytest.raises(TypeError):\n            builder.next_update(\"notadatetime\")  # type:ignore[arg-type]\n\n    def test_next_update_before_1950(self):\n        builder = x509.CertificateRevocationListBuilder()\n        with pytest.raises(ValueError):\n            builder.next_update(datetime.datetime(1940, 8, 10))\n\n    def test_set_next_update_twice(self):\n        builder = x509.CertificateRevocationListBuilder().next_update(\n            datetime.datetime(2002, 1, 1, 12, 1)\n        )\n        with pytest.raises(ValueError):\n            builder.next_update(datetime.datetime(2002, 1, 1, 12, 1))\n\n    def test_last_update_after_next_update(self):\n        builder = x509.CertificateRevocationListBuilder()\n\n        builder = builder.next_update(datetime.datetime(2002, 1, 1, 12, 1))\n        with pytest.raises(ValueError):\n            builder.last_update(datetime.datetime(2003, 1, 1, 12, 1))\n\n    def test_next_update_after_last_update(self):\n        builder = x509.CertificateRevocationListBuilder()\n\n        builder = builder.last_update(datetime.datetime(2002, 1, 1, 12, 1))\n        with pytest.raises(ValueError):\n            builder.next_update(datetime.datetime(2001, 1, 1, 12, 1))\n\n    def test_add_extension_checks_for_duplicates(self):\n        builder = x509.CertificateRevocationListBuilder().add_extension(\n            x509.CRLNumber(1), False\n        )\n\n        with pytest.raises(ValueError):\n            builder.add_extension(x509.CRLNumber(2), False)\n\n    def test_add_invalid_extension(self):\n        builder = x509.CertificateRevocationListBuilder()\n\n        with pytest.raises(TypeError):\n            builder.add_extension(object(), False)  # type:ignore[arg-type]\n\n    def test_add_invalid_revoked_certificate(self):\n        builder = x509.CertificateRevocationListBuilder()\n\n        with pytest.raises(TypeError):\n            builder.add_revoked_certificate(object())  # type:ignore[arg-type]\n\n    def test_no_issuer_name(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .last_update(datetime.datetime(2002, 1, 1, 12, 1))\n            .next_update(datetime.datetime(2030, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_no_last_update(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .next_update(datetime.datetime(2030, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_no_next_update(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .last_update(datetime.datetime(2030, 1, 1, 12, 1))\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_sign_invalid_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(\n                rsa_key_2048,\n                hashes.SHA256(),\n                rsa_padding=b\"notapadding\",  # type: ignore[arg-type]\n            )\n        eckey = ec.generate_private_key(ec.SECP256R1())\n        with pytest.raises(TypeError):\n            builder.sign(\n                eckey, hashes.SHA256(), rsa_padding=padding.PKCS1v15()\n            )\n\n    def test_sign_empty_list(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert len(crl) == 0\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl.last_update == last_update\n            assert crl.next_update == next_update\n        assert crl.last_update_utc == last_update.replace(\n            tzinfo=datetime.timezone.utc\n        )\n        assert crl.next_update_utc == next_update.replace(\n            tzinfo=datetime.timezone.utc\n        )\n\n    def test_sign_pss(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.DIGEST_LENGTH,\n        )\n        crl = builder.sign(private_key, hashes.SHA256(), rsa_padding=pss)\n        assert len(crl) == 0\n        assert isinstance(crl.signature_algorithm_parameters, padding.PSS)\n        assert crl.signature_algorithm_parameters._salt_length == 32\n        private_key.public_key().verify(\n            crl.signature,\n            crl.tbs_certlist_bytes,\n            crl.signature_algorithm_parameters,\n            hashes.SHA256(),\n        )\n\n    @pytest.mark.parametrize(\n        \"extension\",\n        [\n            x509.CRLNumber(13),\n            x509.DeltaCRLIndicator(12345678901234567890),\n            x509.AuthorityKeyIdentifier(\n                b\"\\xc3\\x9c\\xf3\\xfc\\xd3F\\x084\\xbb\\xceF\\x7f\\xa0|[\\xf3\\xe2\\x08\"\n                b\"\\xcbY\",\n                None,\n                None,\n            ),\n            x509.AuthorityInformationAccess(\n                [\n                    x509.AccessDescription(\n                        AuthorityInformationAccessOID.CA_ISSUERS,\n                        x509.DNSName(\"cryptography.io\"),\n                    )\n                ]\n            ),\n            x509.IssuerAlternativeName(\n                [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n            ),\n        ],\n    )\n    def test_sign_extensions(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend, extension\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_extension(extension, False)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert len(crl) == 0\n        assert len(crl.extensions) == 1\n        ext = crl.extensions.get_extension_for_class(type(extension))\n        assert ext.critical is False\n        assert ext.value == extension\n\n    def test_sign_multiple_extensions_critical(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        ian = x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n        crl_number = x509.CRLNumber(13)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_extension(crl_number, False)\n            .add_extension(ian, True)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert len(crl) == 0\n        assert len(crl.extensions) == 2\n        ext1 = crl.extensions.get_extension_for_class(x509.CRLNumber)\n        assert ext1.critical is False\n        assert ext1.value == crl_number\n        ext2 = crl.extensions.get_extension_for_class(\n            x509.IssuerAlternativeName\n        )\n        assert ext2.critical is True\n        assert ext2.value == ian\n\n    def test_freshestcrl_extension(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        freshest = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"http://d.om/delta\")],\n                    None,\n                    None,\n                    None,\n                )\n            ]\n        )\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_extension(freshest, False)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert len(crl) == 0\n        assert len(crl.extensions) == 1\n        ext1 = crl.extensions.get_extension_for_class(x509.FreshestCRL)\n        assert ext1.critical is False\n        assert isinstance(ext1.value, x509.FreshestCRL)\n        assert isinstance(ext1.value[0], x509.DistributionPoint)\n        assert ext1.value[0].full_name is not None\n        uri = ext1.value[0].full_name[0]\n        assert isinstance(uri, x509.UniformResourceIdentifier)\n        assert uri.value == \"http://d.om/delta\"\n\n    def test_add_unsupported_extension(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_extension(DummyExtension(), False)\n        )\n        with pytest.raises(NotImplementedError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_add_unsupported_entry_extension(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(\n                x509.RevokedCertificateBuilder()\n                .serial_number(1234)\n                .revocation_date(\n                    datetime.datetime.now(datetime.timezone.utc).replace(\n                        tzinfo=None\n                    )\n                )\n                .add_extension(DummyExtension(), critical=False)\n                .build()\n            )\n        )\n        with pytest.raises(NotImplementedError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    def test_sign_rsa_key_too_small(\n        self, rsa_key_512: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_512\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA512(), backend)\n\n    def test_sign_with_invalid_hash(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(\n                private_key,\n                object(),  # type: ignore[arg-type]\n                backend,\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_sign_with_invalid_hash_ed25519(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(\n                private_key,\n                object(),  # type:ignore[arg-type]\n                backend,\n            )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_sign_with_invalid_hash_ed448(self, backend):\n        private_key = ed448.Ed448PrivateKey.generate()\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n        )\n\n        with pytest.raises(TypeError):\n            builder.sign(\n                private_key,\n                object(),  # type:ignore[arg-type]\n                backend,\n            )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256(), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Requires OpenSSL with DSA support\",\n    )\n    def test_sign_dsa_key(self, backend):\n        private_key = DSA_KEY_2048.private_key(backend)\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2002, 1, 1, 0, 0)\n        )\n        ian = x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n        revoked_cert0 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(2)\n            .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n            .add_extension(invalidity_date, False)\n            .build(backend)\n        )\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(revoked_cert0)\n            .add_extension(ian, False)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert (\n            crl.extensions.get_extension_for_class(\n                x509.IssuerAlternativeName\n            ).value\n            == ian\n        )\n        assert crl[0].serial_number == revoked_cert0.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[0].revocation_date == revoked_cert0.revocation_date\n        assert crl[0].revocation_date_utc == revoked_cert0.revocation_date_utc\n        assert len(crl[0].extensions) == 1\n        ext = crl[0].extensions.get_extension_for_class(x509.InvalidityDate)\n        assert ext.critical is False\n        assert ext.value == invalidity_date\n\n    def test_sign_ec_key(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2002, 1, 1, 0, 0)\n        )\n        ian = x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n        revoked_cert0 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(2)\n            .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n            .add_extension(invalidity_date, False)\n            .build(backend)\n        )\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(revoked_cert0)\n            .add_extension(ian, False)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert (\n            crl.extensions.get_extension_for_class(\n                x509.IssuerAlternativeName\n            ).value\n            == ian\n        )\n        assert crl[0].serial_number == revoked_cert0.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[0].revocation_date == revoked_cert0.revocation_date\n        assert crl[0].revocation_date_utc == revoked_cert0.revocation_date_utc\n        assert len(crl[0].extensions) == 1\n        ext = crl[0].extensions.get_extension_for_class(x509.InvalidityDate)\n        assert ext.critical is False\n        assert ext.value == invalidity_date\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_sign_ed25519_key(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2002, 1, 1, 0, 0)\n        )\n        ian = x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n        revoked_cert0 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(2)\n            .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n            .add_extension(invalidity_date, False)\n            .build(backend)\n        )\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(revoked_cert0)\n            .add_extension(ian, False)\n        )\n\n        crl = builder.sign(private_key, None, backend)\n        assert crl.signature_hash_algorithm is None\n        assert crl.signature_algorithm_oid == SignatureAlgorithmOID.ED25519\n        assert (\n            crl.extensions.get_extension_for_class(\n                x509.IssuerAlternativeName\n            ).value\n            == ian\n        )\n        assert crl[0].serial_number == revoked_cert0.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[0].revocation_date == revoked_cert0.revocation_date\n        assert crl[0].revocation_date_utc == revoked_cert0.revocation_date_utc\n        assert len(crl[0].extensions) == 1\n        ext = crl[0].extensions.get_extension_for_class(x509.InvalidityDate)\n        assert ext.critical is False\n        assert ext.value == invalidity_date\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_sign_ed448_key(self, backend):\n        private_key = ed448.Ed448PrivateKey.generate()\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2002, 1, 1, 0, 0)\n        )\n        ian = x509.IssuerAlternativeName(\n            [x509.UniformResourceIdentifier(\"https://cryptography.io\")]\n        )\n        revoked_cert0 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(2)\n            .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n            .add_extension(invalidity_date, False)\n            .build(backend)\n        )\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(revoked_cert0)\n            .add_extension(ian, False)\n        )\n\n        crl = builder.sign(private_key, None, backend)\n        assert crl.signature_hash_algorithm is None\n        assert crl.signature_algorithm_oid == SignatureAlgorithmOID.ED448\n        assert (\n            crl.extensions.get_extension_for_class(\n                x509.IssuerAlternativeName\n            ).value\n            == ian\n        )\n        assert crl[0].serial_number == revoked_cert0.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[0].revocation_date == revoked_cert0.revocation_date\n        assert crl[0].revocation_date_utc == revoked_cert0.revocation_date_utc\n        assert len(crl[0].extensions) == 1\n        ext = crl[0].extensions.get_extension_for_class(x509.InvalidityDate)\n        assert ext.critical is False\n        assert ext.value == invalidity_date\n\n    def test_dsa_key_sign_md5(self, backend):\n        private_key = DSA_KEY_2048.private_key(backend)\n        last_time = datetime.datetime(2012, 1, 16, 22, 43)\n        next_time = datetime.datetime(2022, 1, 17, 6, 43)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_time)\n            .next_update(next_time)\n        )\n\n        with pytest.raises(UnsupportedAlgorithm):\n            builder.sign(\n                private_key,\n                hashes.MD5(),  # type: ignore[arg-type]\n                backend,\n            )\n\n    def test_ec_key_sign_md5(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        private_key = EC_KEY_SECP256R1.private_key(backend)\n        last_time = datetime.datetime(2012, 1, 16, 22, 43)\n        next_time = datetime.datetime(2022, 1, 17, 6, 43)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_time)\n            .next_update(next_time)\n        )\n\n        with pytest.raises(UnsupportedAlgorithm):\n            builder.sign(\n                private_key,\n                hashes.MD5(),  # type: ignore[arg-type]\n                backend,\n            )\n\n    def test_sign_with_revoked_certificates(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2002, 1, 1, 0, 0)\n        )\n        revoked_cert0 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(38)\n            .revocation_date(datetime.datetime(2011, 1, 1, 1, 1))\n            .build(backend)\n        )\n        revoked_cert1 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(2)\n            .revocation_date(datetime.datetime(2012, 1, 1, 1, 1))\n            .add_extension(invalidity_date, False)\n            .add_extension(\n                x509.CRLReason(x509.ReasonFlags.ca_compromise), False\n            )\n            .build(backend)\n        )\n        ci = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        revoked_cert2 = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(40)\n            .revocation_date(datetime.datetime(2011, 1, 1, 1, 1))\n            .add_extension(ci, False)\n            .build(backend)\n        )\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_revoked_certificate(revoked_cert0)\n            .add_revoked_certificate(revoked_cert1)\n            .add_revoked_certificate(revoked_cert2)\n        )\n\n        crl = builder.sign(private_key, hashes.SHA256(), backend)\n        assert len(crl) == 3\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl.last_update == last_update\n            assert crl.next_update == next_update\n        assert crl.last_update_utc == last_update.replace(\n            tzinfo=datetime.timezone.utc\n        )\n        assert crl.next_update_utc == next_update.replace(\n            tzinfo=datetime.timezone.utc\n        )\n        assert crl[0].serial_number == revoked_cert0.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[0].revocation_date == revoked_cert0.revocation_date\n        assert crl[0].revocation_date_utc == revoked_cert0.revocation_date_utc\n        assert len(crl[0].extensions) == 0\n        assert crl[1].serial_number == revoked_cert1.serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert crl[1].revocation_date == revoked_cert1.revocation_date\n        assert crl[1].revocation_date_utc == revoked_cert1.revocation_date_utc\n        assert len(crl[1].extensions) == 2\n        ext = crl[1].extensions.get_extension_for_class(x509.InvalidityDate)\n        assert ext.critical is False\n        assert ext.value == invalidity_date\n        assert (\n            crl[2]\n            .extensions.get_extension_for_class(x509.CertificateIssuer)\n            .value\n            == ci\n        )\n", "tests/x509/test_x509_ext.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport datetime\nimport ipaddress\nimport os\nimport typing\n\nimport pretend\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.hazmat._oid import _OID_NAMES\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import ec, rsa\nfrom cryptography.x509 import (\n    DNSName,\n    NameConstraints,\n    SubjectAlternativeName,\n    ocsp,\n)\nfrom cryptography.x509.extensions import (\n    ExtensionType,\n    _key_identifier_from_public_key,\n)\nfrom cryptography.x509.oid import (\n    AuthorityInformationAccessOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    ObjectIdentifier,\n    SubjectInformationAccessOID,\n)\n\nfrom ..hazmat.primitives.test_ec import _skip_curve_unsupported\nfrom ..hazmat.primitives.test_rsa import rsa_key_2048\nfrom ..utils import load_vectors_from_file\nfrom .test_x509 import _load_cert\n\n# Make ruff happy since we're importing fixtures that pytest patches in as\n# func args\n__all__ = [\"rsa_key_2048\"]\n\n\ndef _make_certbuilder(private_key):\n    name = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"example.org\")])\n    return (\n        x509.CertificateBuilder()\n        .subject_name(name)\n        .issuer_name(name)\n        .public_key(private_key.public_key())\n        .serial_number(777)\n        .not_valid_before(datetime.datetime(1999, 1, 1))\n        .not_valid_after(datetime.datetime(2020, 1, 1))\n    )\n\n\nclass TestExtension:\n    def test_not_an_oid(self):\n        bc = x509.BasicConstraints(ca=False, path_length=None)\n        with pytest.raises(TypeError):\n            x509.Extension(\"notanoid\", True, bc)  # type:ignore[arg-type]\n\n    def test_critical_not_a_bool(self):\n        bc = x509.BasicConstraints(ca=False, path_length=None)\n        with pytest.raises(TypeError):\n            x509.Extension(\n                ExtensionOID.BASIC_CONSTRAINTS,\n                \"notabool\",  # type:ignore[arg-type]\n                bc,\n            )\n\n    def test_repr(self):\n        bc = x509.BasicConstraints(ca=False, path_length=None)\n        ext = x509.Extension(ExtensionOID.BASIC_CONSTRAINTS, True, bc)\n        assert repr(ext) == (\n            \"<Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name=basicConst\"\n            \"raints)>, critical=True, value=<BasicConstraints(ca=False, path\"\n            \"_length=None)>)>\"\n        )\n\n    def test_eq(self):\n        ext1 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.4\"),\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext2 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.4\"),\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        assert ext1 == ext2\n\n    def test_ne(self):\n        ext1 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.4\"),\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext2 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.5\"),\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext3 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.4\"),\n            True,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext4 = x509.Extension(\n            x509.ObjectIdentifier(\"1.2.3.4\"),\n            False,\n            x509.BasicConstraints(ca=True, path_length=None),\n        )\n        assert ext1 != ext2\n        assert ext1 != ext3\n        assert ext1 != ext4\n        assert ext1 != object()\n\n    def test_hash(self):\n        ext1 = x509.Extension(\n            ExtensionOID.BASIC_CONSTRAINTS,\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext2 = x509.Extension(\n            ExtensionOID.BASIC_CONSTRAINTS,\n            False,\n            x509.BasicConstraints(ca=False, path_length=None),\n        )\n        ext3 = x509.Extension(\n            ExtensionOID.BASIC_CONSTRAINTS,\n            False,\n            x509.BasicConstraints(ca=True, path_length=None),\n        )\n        assert hash(ext1) == hash(ext2)\n        assert hash(ext1) != hash(ext3)\n\n\nclass TestTLSFeature:\n    def test_not_enum_type(self):\n        with pytest.raises(TypeError):\n            x509.TLSFeature([3])  # type:ignore[list-item]\n\n    def test_empty_list(self):\n        with pytest.raises(TypeError):\n            x509.TLSFeature([])\n\n    def test_repr(self):\n        ext1 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        assert repr(ext1) == (\n            \"<TLSFeature(features=[<TLSFeatureType.status_request: 5>])>\"\n        )\n\n    def test_eq(self):\n        ext1 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        ext2 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        assert ext1 == ext2\n\n    def test_ne(self):\n        ext1 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        ext2 = x509.TLSFeature([x509.TLSFeatureType.status_request_v2])\n        ext3 = x509.TLSFeature(\n            [\n                x509.TLSFeatureType.status_request,\n                x509.TLSFeatureType.status_request_v2,\n            ]\n        )\n        assert ext1 != ext2\n        assert ext1 != ext3\n        assert ext1 != object()\n\n    def test_hash(self):\n        ext1 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        ext2 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        ext3 = x509.TLSFeature(\n            [\n                x509.TLSFeatureType.status_request,\n                x509.TLSFeatureType.status_request_v2,\n            ]\n        )\n        assert hash(ext1) == hash(ext2)\n        assert hash(ext1) != hash(ext3)\n\n    def test_iter(self):\n        ext1_features = [x509.TLSFeatureType.status_request]\n        ext1 = x509.TLSFeature(ext1_features)\n        assert len(ext1) == 1\n        assert list(ext1) == ext1_features\n        ext2_features = [\n            x509.TLSFeatureType.status_request,\n            x509.TLSFeatureType.status_request_v2,\n        ]\n        ext2 = x509.TLSFeature(ext2_features)\n        assert len(ext2) == 2\n        assert list(ext2) == ext2_features\n\n    def test_indexing(self):\n        ext = x509.TLSFeature(\n            [\n                x509.TLSFeatureType.status_request,\n                x509.TLSFeatureType.status_request_v2,\n            ]\n        )\n        assert ext[-1] == ext[1]\n        assert ext[0] == x509.TLSFeatureType.status_request\n\n    def test_public_bytes(self):\n        ext1 = x509.TLSFeature([x509.TLSFeatureType.status_request])\n        assert ext1.public_bytes() == b\"\\x30\\x03\\x02\\x01\\x05\"\n        ext2 = x509.TLSFeature([x509.TLSFeatureType.status_request_v2])\n        assert ext2.public_bytes() == b\"\\x30\\x03\\x02\\x01\\x11\"\n\n\nclass TestUnrecognizedExtension:\n    def test_invalid_oid(self):\n        with pytest.raises(TypeError):\n            x509.UnrecognizedExtension(\n                \"notanoid\",  # type:ignore[arg-type]\n                b\"somedata\",\n            )\n\n    def test_eq(self):\n        ext1 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        ext2 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        assert ext1 == ext2\n\n    def test_ne(self):\n        ext1 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        ext2 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x02\"\n        )\n        ext3 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.5\"), b\"\\x03\\x02\\x01\"\n        )\n        assert ext1 != ext2\n        assert ext1 != ext3\n        assert ext1 != object()\n\n    def test_repr(self):\n        ext1 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        assert repr(ext1) == (\n            \"<UnrecognizedExtension(oid=<ObjectIdentifier(oid=1.2.3.4, \"\n            \"name=Unknown OID)>, value=b'\\\\x03\\\\x02\\\\x01')>\"\n        )\n\n    def test_hash(self):\n        ext1 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        ext2 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x03\\x02\\x01\"\n        )\n        ext3 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.5\"), b\"\\x03\\x02\\x01\"\n        )\n        assert hash(ext1) == hash(ext2)\n        assert hash(ext1) != hash(ext3)\n\n    def test_public_bytes(self):\n        ext1 = x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.2.3.5\"), b\"\\x03\\x02\\x01\"\n        )\n        assert ext1.public_bytes() == b\"\\x03\\x02\\x01\"\n\n        # The following creates a BasicConstraints extension with an invalid\n        # value. The serialization code should still handle it correctly by\n        # special-casing UnrecognizedExtension.\n        ext2 = x509.UnrecognizedExtension(\n            x509.oid.ExtensionOID.BASIC_CONSTRAINTS, b\"\\x03\\x02\\x01\"\n        )\n        assert ext2.public_bytes() == b\"\\x03\\x02\\x01\"\n\n\nclass TestCertificateIssuer:\n    def test_iter_names(self):\n        ci = x509.CertificateIssuer(\n            [x509.DNSName(\"cryptography.io\"), x509.DNSName(\"crypto.local\")]\n        )\n        assert len(ci) == 2\n        assert list(ci) == [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"crypto.local\"),\n        ]\n\n    def test_indexing(self):\n        ci = x509.CertificateIssuer(\n            [\n                x509.DNSName(\"cryptography.io\"),\n                x509.DNSName(\"crypto.local\"),\n                x509.DNSName(\"another.local\"),\n                x509.RFC822Name(\"email@another.local\"),\n                x509.UniformResourceIdentifier(\"http://another.local\"),\n            ]\n        )\n        assert ci[-1] == ci[4]\n        assert ci[2:6:2] == [ci[2], ci[4]]\n\n    def test_eq(self):\n        ci1 = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        ci2 = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        assert ci1 == ci2\n\n    def test_ne(self):\n        ci1 = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        ci2 = x509.CertificateIssuer([x509.DNSName(\"somethingelse.tld\")])\n        assert ci1 != ci2\n        assert ci1 != object()\n\n    def test_repr(self):\n        ci = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        assert repr(ci) == (\n            \"<CertificateIssuer(<GeneralNames([<DNSName(value=\"\n            \"'cryptography.io')>])>)>\"\n        )\n\n    def test_get_values_for_type(self):\n        ci = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        names = ci.get_values_for_type(x509.DNSName)\n        assert names == [\"cryptography.io\"]\n\n    def test_hash(self):\n        ci1 = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        ci2 = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        ci3 = x509.CertificateIssuer(\n            [x509.UniformResourceIdentifier(\"http://something\")]\n        )\n        assert hash(ci1) == hash(ci2)\n        assert hash(ci1) != hash(ci3)\n\n    def test_public_bytes(self):\n        ext = x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")])\n        assert ext.public_bytes() == b\"0\\x11\\x82\\x0fcryptography.io\"\n\n\nclass TestCRLReason:\n    def test_invalid_reason_flags(self):\n        with pytest.raises(TypeError):\n            x509.CRLReason(\"notareason\")  # type:ignore[arg-type]\n\n    def test_eq(self):\n        reason1 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        reason2 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        assert reason1 == reason2\n\n    def test_ne(self):\n        reason1 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        reason2 = x509.CRLReason(x509.ReasonFlags.ca_compromise)\n        assert reason1 != reason2\n        assert reason1 != object()\n\n    def test_hash(self):\n        reason1 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        reason2 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        reason3 = x509.CRLReason(x509.ReasonFlags.ca_compromise)\n\n        assert hash(reason1) == hash(reason2)\n        assert hash(reason1) != hash(reason3)\n\n    def test_repr(self):\n        reason1 = x509.CRLReason(x509.ReasonFlags.unspecified)\n        assert repr(reason1) == (\"<CRLReason(reason=ReasonFlags.unspecified)>\")\n\n    def test_public_bytes(self):\n        ext = x509.CRLReason(x509.ReasonFlags.ca_compromise)\n        assert ext.public_bytes() == b\"\\n\\x01\\x02\"\n\n\nclass TestDeltaCRLIndicator:\n    def test_not_int(self):\n        with pytest.raises(TypeError):\n            x509.DeltaCRLIndicator(\"notanint\")  # type:ignore[arg-type]\n\n    def test_eq(self):\n        delta1 = x509.DeltaCRLIndicator(1)\n        delta2 = x509.DeltaCRLIndicator(1)\n        assert delta1 == delta2\n\n    def test_ne(self):\n        delta1 = x509.DeltaCRLIndicator(1)\n        delta2 = x509.DeltaCRLIndicator(2)\n        assert delta1 != delta2\n        assert delta1 != object()\n\n    def test_repr(self):\n        delta1 = x509.DeltaCRLIndicator(2)\n        assert repr(delta1) == (\"<DeltaCRLIndicator(crl_number=2)>\")\n\n    def test_hash(self):\n        delta1 = x509.DeltaCRLIndicator(1)\n        delta2 = x509.DeltaCRLIndicator(1)\n        delta3 = x509.DeltaCRLIndicator(2)\n        assert hash(delta1) == hash(delta2)\n        assert hash(delta1) != hash(delta3)\n\n    def test_public_bytes(self):\n        ext = x509.DeltaCRLIndicator(2)\n        assert ext.public_bytes() == b\"\\x02\\x01\\x02\"\n\n\nclass TestInvalidityDate:\n    def test_invalid_invalidity_date(self):\n        with pytest.raises(TypeError):\n            x509.InvalidityDate(\"notadate\")  # type:ignore[arg-type]\n\n    def test_eq(self):\n        invalid1 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        invalid2 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        assert invalid1 == invalid2\n\n    def test_ne(self):\n        invalid1 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        invalid2 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 2))\n        assert invalid1 != invalid2\n        assert invalid1 != object()\n\n    def test_repr(self):\n        invalid1 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        assert repr(invalid1) == (\n            \"<InvalidityDate(invalidity_date=2015-01-01 01:01:00)>\"\n        )\n\n    def test_hash(self):\n        invalid1 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        invalid2 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        invalid3 = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 2))\n        assert hash(invalid1) == hash(invalid2)\n        assert hash(invalid1) != hash(invalid3)\n\n    def test_public_bytes(self):\n        ext = x509.InvalidityDate(datetime.datetime(2015, 1, 1, 1, 1))\n        assert ext.public_bytes() == b\"\\x18\\x0f20150101010100Z\"\n\n    def test_timezone_aware_api(self):\n        naive_date = datetime.datetime(2015, 1, 1, 1, 1)\n        ext_naive = x509.InvalidityDate(invalidity_date=naive_date)\n        assert ext_naive.invalidity_date_utc == datetime.datetime(\n            2015, 1, 1, 1, 1, tzinfo=datetime.timezone.utc\n        )\n\n        tz_aware_date = datetime.datetime(\n            2015,\n            1,\n            1,\n            1,\n            1,\n            tzinfo=datetime.timezone(datetime.timedelta(hours=-8)),\n        )\n        ext_aware = x509.InvalidityDate(invalidity_date=tz_aware_date)\n        assert ext_aware.invalidity_date_utc == datetime.datetime(\n            2015, 1, 1, 9, 1, tzinfo=datetime.timezone.utc\n        )\n\n\nclass TestNoticeReference:\n    def test_notice_numbers_not_all_int(self):\n        with pytest.raises(TypeError):\n            x509.NoticeReference(\n                \"org\",\n                [1, 2, \"three\"],  # type:ignore[list-item]\n            )\n\n    def test_notice_numbers_none(self):\n        with pytest.raises(TypeError):\n            x509.NoticeReference(\"org\", None)  # type:ignore[arg-type]\n\n    def test_iter_input(self):\n        numbers = [1, 3, 4]\n        nr = x509.NoticeReference(\"org\", iter(numbers))\n        assert list(nr.notice_numbers) == numbers\n\n    def test_repr(self):\n        nr = x509.NoticeReference(\"org\", [1, 3, 4])\n\n        assert repr(nr) == (\n            \"<NoticeReference(organization='org', notice_numbers=[1, 3, 4\"\n            \"])>\"\n        )\n\n    def test_eq(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1, 2])\n        assert nr == nr2\n\n    def test_ne(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1])\n        nr3 = x509.NoticeReference(None, [1, 2])\n        assert nr != nr2\n        assert nr != nr3\n        assert nr != object()\n\n    def test_hash(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1, 2])\n        nr3 = x509.NoticeReference(None, [1, 2])\n        assert hash(nr) == hash(nr2)\n        assert hash(nr) != hash(nr3)\n\n\nclass TestUserNotice:\n    def test_notice_reference_invalid(self):\n        with pytest.raises(TypeError):\n            x509.UserNotice(\"invalid\", None)  # type:ignore[arg-type]\n\n    def test_notice_reference_none(self):\n        un = x509.UserNotice(None, \"text\")\n        assert un.notice_reference is None\n        assert un.explicit_text == \"text\"\n\n    def test_repr(self):\n        un = x509.UserNotice(x509.NoticeReference(\"org\", [1]), \"text\")\n        assert repr(un) == (\n            \"<UserNotice(notice_reference=<NoticeReference(organization='\"\n            \"org', notice_numbers=[1])>, explicit_text='text')>\"\n        )\n\n    def test_eq(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1, 2])\n        un = x509.UserNotice(nr, \"text\")\n        un2 = x509.UserNotice(nr2, \"text\")\n        assert un == un2\n\n    def test_ne(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1])\n        un = x509.UserNotice(nr, \"text\")\n        un2 = x509.UserNotice(nr2, \"text\")\n        un3 = x509.UserNotice(nr, \"text3\")\n        assert un != un2\n        assert un != un3\n        assert un != object()\n\n    def test_hash(self):\n        nr = x509.NoticeReference(\"org\", [1, 2])\n        nr2 = x509.NoticeReference(\"org\", [1, 2])\n        un = x509.UserNotice(nr, \"text\")\n        un2 = x509.UserNotice(nr2, \"text\")\n        un3 = x509.UserNotice(None, \"text\")\n        assert hash(un) == hash(un2)\n        assert hash(un) != hash(un3)\n\n\nclass TestPolicyInformation:\n    def test_invalid_policy_identifier(self):\n        with pytest.raises(TypeError):\n            x509.PolicyInformation(\"notanoid\", None)  # type:ignore[arg-type]\n\n    def test_none_policy_qualifiers(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), None)\n        assert pi.policy_identifier == x509.ObjectIdentifier(\"1.2.3\")\n        assert pi.policy_qualifiers is None\n\n    def test_policy_qualifiers(self):\n        pq = [\"string\"]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), pq)\n        assert pi.policy_identifier == x509.ObjectIdentifier(\"1.2.3\")\n        assert pi.policy_qualifiers == pq\n\n    def test_invalid_policy_identifiers(self):\n        with pytest.raises(TypeError):\n            x509.PolicyInformation(\n                x509.ObjectIdentifier(\"1.2.3\"),\n                [1, 2],  # type:ignore[list-item]\n            )\n\n    def test_iter_input(self):\n        qual = [\"foo\", \"bar\"]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), iter(qual))\n        assert pi.policy_qualifiers is not None\n        assert list(pi.policy_qualifiers) == qual\n\n    def test_repr(self):\n        pq: typing.List[typing.Union[str, x509.UserNotice]] = [\n            \"string\",\n            x509.UserNotice(None, \"hi\"),\n        ]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), pq)\n        assert repr(pi) == (\n            \"<PolicyInformation(policy_identifier=<ObjectIdentifier(oid=1.\"\n            \"2.3, name=Unknown OID)>, policy_qualifiers=['string', <UserNo\"\n            \"tice(notice_reference=None, explicit_text='hi')>])>\"\n        )\n\n    def test_eq(self):\n        pi = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"),\n            [\"string\", x509.UserNotice(None, \"hi\")],\n        )\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"),\n            [\"string\", x509.UserNotice(None, \"hi\")],\n        )\n        assert pi == pi2\n\n    def test_ne(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"string\"])\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"), [\"string2\"]\n        )\n        pi3 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3.4\"), [\"string\"]\n        )\n        assert pi != pi2\n        assert pi != pi3\n        assert pi != object()\n\n    def test_hash(self):\n        pi = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"),\n            [\"string\", x509.UserNotice(None, \"hi\")],\n        )\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"),\n            [\"string\", x509.UserNotice(None, \"hi\")],\n        )\n        pi3 = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), None)\n        assert hash(pi) == hash(pi2)\n        assert hash(pi) != hash(pi3)\n\n\nclass TestCertificatePolicies:\n    def test_invalid_policies(self):\n        pq = [\"string\"]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), pq)\n        with pytest.raises(TypeError):\n            x509.CertificatePolicies([1, pi])  # type:ignore[list-item]\n\n    def test_iter_len(self):\n        pq = [\"string\"]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), pq)\n        cp = x509.CertificatePolicies([pi])\n        assert len(cp) == 1\n        for policyinfo in cp:\n            assert policyinfo == pi\n\n    def test_iter_input(self):\n        policies = [\n            x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"string\"])\n        ]\n        cp = x509.CertificatePolicies(iter(policies))\n        assert list(cp) == policies\n\n    def test_repr(self):\n        pq = [\"string\"]\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), pq)\n        cp = x509.CertificatePolicies([pi])\n        assert repr(cp) == (\n            \"<CertificatePolicies([<PolicyInformation(policy_identifier=<O\"\n            \"bjectIdentifier(oid=1.2.3, name=Unknown OID)>, policy_qualifi\"\n            \"ers=['string'])>])>\"\n        )\n\n    def test_eq(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"string\"])\n        cp = x509.CertificatePolicies([pi])\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"), [\"string\"]\n        )\n        cp2 = x509.CertificatePolicies([pi2])\n        assert cp == cp2\n\n    def test_ne(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"string\"])\n        cp = x509.CertificatePolicies([pi])\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"), [\"string2\"]\n        )\n        cp2 = x509.CertificatePolicies([pi2])\n        assert cp != cp2\n        assert cp != object()\n\n    def test_indexing(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"test\"])\n        pi2 = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.4\"), [\"test\"])\n        pi3 = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.5\"), [\"test\"])\n        pi4 = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.6\"), [\"test\"])\n        pi5 = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.7\"), [\"test\"])\n        cp = x509.CertificatePolicies([pi, pi2, pi3, pi4, pi5])\n        assert cp[-1] == cp[4]\n        assert cp[2:6:2] == [cp[2], cp[4]]\n\n    def test_long_oid(self, backend):\n        \"\"\"\n        Test that parsing a CertificatePolicies ext with\n        a very long OID succeeds.\n        \"\"\"\n        cert = _load_cert(\n            os.path.join(\"x509\", \"bigoid.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.CertificatePolicies)\n\n        oid = x509.ObjectIdentifier(\n            \"1.3.6.1.4.1.311.21.8.8950086.10656446.2706058\"\n            \".12775672.480128.147.13466065.13029902\"\n        )\n\n        assert ext.value[0].policy_identifier == oid\n\n    def test_hash(self):\n        pi = x509.PolicyInformation(x509.ObjectIdentifier(\"1.2.3\"), [\"string\"])\n        cp = x509.CertificatePolicies([pi])\n        pi2 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"), [\"string\"]\n        )\n        cp2 = x509.CertificatePolicies([pi2])\n        pi3 = x509.PolicyInformation(\n            x509.ObjectIdentifier(\"1.2.3\"), [x509.UserNotice(None, \"text\")]\n        )\n        cp3 = x509.CertificatePolicies([pi3])\n        assert hash(cp) == hash(cp2)\n        assert hash(cp) != hash(cp3)\n\n\nclass TestCertificatePoliciesExtension:\n    def test_cps_uri_policy_qualifier(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cp_cps_uri.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        cp = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CERTIFICATE_POLICIES\n        ).value\n\n        assert cp == x509.CertificatePolicies(\n            [\n                x509.PolicyInformation(\n                    x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                    [\"http://other.com/cps\"],\n                )\n            ]\n        )\n\n    def test_user_notice_with_notice_reference(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"cp_user_notice_with_notice_reference.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n\n        cp = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CERTIFICATE_POLICIES\n        ).value\n\n        assert cp == x509.CertificatePolicies(\n            [\n                x509.PolicyInformation(\n                    x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                    [\n                        \"http://example.com/cps\",\n                        \"http://other.com/cps\",\n                        x509.UserNotice(\n                            x509.NoticeReference(\"my org\", [1, 2, 3, 4]),\n                            \"thing\",\n                        ),\n                    ],\n                )\n            ]\n        )\n\n    def test_user_notice_with_explicit_text(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"cp_user_notice_with_explicit_text.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n\n        cp = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CERTIFICATE_POLICIES\n        ).value\n\n        assert cp == x509.CertificatePolicies(\n            [\n                x509.PolicyInformation(\n                    x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                    [x509.UserNotice(None, \"thing\")],\n                )\n            ]\n        )\n\n    def test_user_notice_no_explicit_text(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"cp_user_notice_no_explicit_text.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n\n        cp = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CERTIFICATE_POLICIES\n        ).value\n\n        assert cp == x509.CertificatePolicies(\n            [\n                x509.PolicyInformation(\n                    x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                    [\n                        x509.UserNotice(\n                            x509.NoticeReference(\"my org\", [1, 2, 3, 4]), None\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_non_ascii_qualifier(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        issuer_private_key = rsa_key_2048\n        subject_private_key = rsa_key_2048\n\n        not_valid_before = datetime.datetime(2002, 1, 1, 12, 1)\n        not_valid_after = datetime.datetime(2030, 12, 31, 8, 30)\n\n        builder = (\n            x509.CertificateBuilder()\n            .subject_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .issuer_name(\n                x509.Name([x509.NameAttribute(NameOID.COUNTRY_NAME, \"US\")])\n            )\n            .not_valid_before(not_valid_before)\n            .not_valid_after(not_valid_after)\n            .public_key(subject_private_key.public_key())\n            .serial_number(123)\n            .add_extension(\n                x509.CertificatePolicies(\n                    [\n                        x509.PolicyInformation(\n                            x509.ObjectIdentifier(\"1.2.3\"), \"\ud83e\udd13\"\n                        )\n                    ]\n                ),\n                critical=False,\n            )\n        )\n\n        with pytest.raises(ValueError, match=\"Qualifier\"):\n            builder.sign(issuer_private_key, hashes.SHA256(), backend)\n\n    def test_public_bytes(self):\n        ext = x509.CertificatePolicies(\n            [\n                x509.PolicyInformation(\n                    x509.ObjectIdentifier(\"2.16.840.1.12345.1.2.3.4.1\"),\n                    [\n                        x509.UserNotice(\n                            x509.NoticeReference(\"my org\", [1, 2, 3, 4]), None\n                        )\n                    ],\n                )\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0705\\x06\\x0b`\\x86H\\x01\\xe09\\x01\\x02\\x03\\x04\\x010&0$\\x06\\x08+\"\n            b\"\\x06\\x01\\x05\\x05\\x07\\x02\\x020\\x180\\x16\\x0c\\x06my org0\\x0c\\x02\"\n            b\"\\x01\\x01\\x02\\x01\\x02\\x02\\x01\\x03\\x02\\x01\\x04\"\n        )\n\n\nclass TestKeyUsage:\n    def test_key_agreement_false_encipher_decipher_true(self):\n        with pytest.raises(ValueError):\n            x509.KeyUsage(\n                digital_signature=False,\n                content_commitment=False,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=False,\n                key_cert_sign=False,\n                crl_sign=False,\n                encipher_only=True,\n                decipher_only=False,\n            )\n\n        with pytest.raises(ValueError):\n            x509.KeyUsage(\n                digital_signature=False,\n                content_commitment=False,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=False,\n                key_cert_sign=False,\n                crl_sign=False,\n                encipher_only=True,\n                decipher_only=True,\n            )\n\n        with pytest.raises(ValueError):\n            x509.KeyUsage(\n                digital_signature=False,\n                content_commitment=False,\n                key_encipherment=False,\n                data_encipherment=False,\n                key_agreement=False,\n                key_cert_sign=False,\n                crl_sign=False,\n                encipher_only=False,\n                decipher_only=True,\n            )\n\n    def test_properties_key_agreement_true(self):\n        ku = x509.KeyUsage(\n            digital_signature=True,\n            content_commitment=True,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=False,\n            key_cert_sign=True,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert ku.digital_signature is True\n        assert ku.content_commitment is True\n        assert ku.key_encipherment is False\n        assert ku.data_encipherment is False\n        assert ku.key_agreement is False\n        assert ku.key_cert_sign is True\n        assert ku.crl_sign is False\n\n    def test_key_agreement_true_properties(self):\n        ku = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        assert ku.key_agreement is True\n        assert ku.encipher_only is False\n        assert ku.decipher_only is True\n\n    def test_key_agreement_false_properties(self):\n        ku = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=False,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert ku.key_agreement is False\n        with pytest.raises(ValueError):\n            ku.encipher_only\n\n        with pytest.raises(ValueError):\n            ku.decipher_only\n\n    def test_repr_key_agreement_false(self):\n        ku = x509.KeyUsage(\n            digital_signature=True,\n            content_commitment=True,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=False,\n            key_cert_sign=True,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert repr(ku) == (\n            \"<KeyUsage(digital_signature=True, content_commitment=True, key_en\"\n            \"cipherment=False, data_encipherment=False, key_agreement=False, k\"\n            \"ey_cert_sign=True, crl_sign=False, encipher_only=False, decipher_\"\n            \"only=False)>\"\n        )\n\n    def test_repr_key_agreement_true(self):\n        ku = x509.KeyUsage(\n            digital_signature=True,\n            content_commitment=True,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=True,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert repr(ku) == (\n            \"<KeyUsage(digital_signature=True, content_commitment=True, key_en\"\n            \"cipherment=False, data_encipherment=False, key_agreement=True, k\"\n            \"ey_cert_sign=True, crl_sign=False, encipher_only=False, decipher_\"\n            \"only=False)>\"\n        )\n\n    def test_eq(self):\n        ku = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        ku2 = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        assert ku == ku2\n\n    def test_ne(self):\n        ku = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        ku2 = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=False,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert ku != ku2\n        assert ku != object()\n\n    def test_hash(self):\n        ku = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        ku2 = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=False,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=True,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=True,\n        )\n        ku3 = x509.KeyUsage(\n            digital_signature=False,\n            content_commitment=True,\n            key_encipherment=False,\n            data_encipherment=False,\n            key_agreement=False,\n            key_cert_sign=False,\n            crl_sign=False,\n            encipher_only=False,\n            decipher_only=False,\n        )\n        assert hash(ku) == hash(ku2)\n        assert hash(ku) != hash(ku3)\n\n    @pytest.mark.parametrize(\n        (\"ext\", \"serialized\"),\n        [\n            (\n                x509.KeyUsage(\n                    digital_signature=False,\n                    content_commitment=True,\n                    key_encipherment=False,\n                    data_encipherment=False,\n                    key_agreement=False,\n                    key_cert_sign=False,\n                    crl_sign=False,\n                    encipher_only=False,\n                    decipher_only=False,\n                ),\n                b\"\\x03\\x02\\x06@\",\n            ),\n            (\n                x509.KeyUsage(\n                    digital_signature=False,\n                    content_commitment=True,\n                    key_encipherment=False,\n                    data_encipherment=False,\n                    key_agreement=True,\n                    key_cert_sign=False,\n                    crl_sign=False,\n                    encipher_only=False,\n                    decipher_only=True,\n                ),\n                b\"\\x03\\x03\\x07H\\x80\",\n            ),\n            (\n                x509.KeyUsage(\n                    digital_signature=True,\n                    content_commitment=False,\n                    key_encipherment=False,\n                    data_encipherment=False,\n                    key_agreement=True,\n                    key_cert_sign=False,\n                    crl_sign=False,\n                    encipher_only=True,\n                    decipher_only=False,\n                ),\n                b\"\\x03\\x02\\x00\\x89\",\n            ),\n            (\n                x509.KeyUsage(\n                    digital_signature=True,\n                    content_commitment=False,\n                    key_encipherment=False,\n                    data_encipherment=True,\n                    key_agreement=False,\n                    key_cert_sign=True,\n                    crl_sign=False,\n                    encipher_only=False,\n                    decipher_only=False,\n                ),\n                b\"\\x03\\x02\\x02\\x94\",\n            ),\n            (\n                x509.KeyUsage(\n                    digital_signature=False,\n                    content_commitment=False,\n                    key_encipherment=False,\n                    data_encipherment=False,\n                    key_agreement=False,\n                    key_cert_sign=False,\n                    crl_sign=False,\n                    encipher_only=False,\n                    decipher_only=False,\n                ),\n                b\"\\x03\\x01\\x00\",\n            ),\n        ],\n    )\n    def test_public_bytes(self, ext, serialized):\n        assert ext.public_bytes() == serialized\n\n\nclass TestSubjectKeyIdentifier:\n    def test_properties(self):\n        value = binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        ski = x509.SubjectKeyIdentifier(value)\n        assert ski.digest == value\n        assert ski.key_identifier == value\n\n    def test_repr(self):\n        ski = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        ext = x509.Extension(ExtensionOID.SUBJECT_KEY_IDENTIFIER, False, ski)\n        assert repr(ext) == (\n            \"<Extension(oid=<ObjectIdentifier(oid=2.5.29.14, name=subjectK\"\n            \"eyIdentifier)>, critical=False, value=<SubjectKeyIdentifier(d\"\n            \"igest=b'\\\\t#\\\\x84\\\\x93\\\"0I\\\\x8b\\\\xc9\\\\x80\\\\xaa\\\\x80\\\\x98Eoo\"\n            \"\\\\xf7\\\\xff:\\\\xc9')>)>\"\n        )\n\n    def test_eq(self):\n        ski = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        ski2 = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        assert ski == ski2\n\n    def test_ne(self):\n        ski = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        ski2 = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"aa8098456f6ff7ff3ac9092384932230498bc980\")\n        )\n        assert ski != ski2\n        assert ski != object()\n\n    def test_hash(self):\n        ski1 = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        ski2 = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        ski3 = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"aa8098456f6ff7ff3ac9092384932230498bc980\")\n        )\n        assert hash(ski1) == hash(ski2)\n        assert hash(ski1) != hash(ski3)\n\n    def test_public_bytes(self):\n        ext = x509.SubjectKeyIdentifier(\n            binascii.unhexlify(b\"092384932230498bc980aa8098456f6ff7ff3ac9\")\n        )\n        assert (\n            ext.public_bytes()\n            == b'\\x04\\x14\\t#\\x84\\x93\"0I\\x8b\\xc9\\x80\\xaa\\x80\\x98Eoo\\xf7\\xff:'\n            b\"\\xc9\"\n        )\n\n\nclass TestAuthorityKeyIdentifier:\n    def test_authority_cert_issuer_not_generalname(self):\n        with pytest.raises(TypeError):\n            x509.AuthorityKeyIdentifier(\n                b\"identifier\",\n                [\"notname\"],  # type:ignore[list-item]\n                3,\n            )\n\n    def test_authority_cert_serial_number_not_integer(self):\n        dirname = x509.DirectoryName(\n            x509.Name(\n                [\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.1\"), \"value1\"\n                    ),\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.2\"), \"value2\"\n                    ),\n                ]\n            )\n        )\n        with pytest.raises(TypeError):\n            x509.AuthorityKeyIdentifier(\n                b\"identifier\",\n                [dirname],\n                \"notanint\",  # type:ignore[arg-type]\n            )\n\n    def test_authority_issuer_none_serial_not_none(self):\n        with pytest.raises(ValueError):\n            x509.AuthorityKeyIdentifier(b\"identifier\", None, 3)\n\n    def test_authority_issuer_not_none_serial_none(self):\n        dirname = x509.DirectoryName(\n            x509.Name(\n                [\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.1\"), \"value1\"\n                    ),\n                    x509.NameAttribute(\n                        x509.ObjectIdentifier(\"2.999.2\"), \"value2\"\n                    ),\n                ]\n            )\n        )\n        with pytest.raises(ValueError):\n            x509.AuthorityKeyIdentifier(b\"identifier\", [dirname], None)\n\n    def test_authority_cert_serial_and_issuer_none(self):\n        aki = x509.AuthorityKeyIdentifier(b\"id\", None, None)\n        assert aki.key_identifier == b\"id\"\n        assert aki.authority_cert_issuer is None\n        assert aki.authority_cert_serial_number is None\n\n    def test_authority_cert_serial_zero(self):\n        dns = x509.DNSName(\"SomeIssuer\")\n        aki = x509.AuthorityKeyIdentifier(b\"id\", [dns], 0)\n        assert aki.key_identifier == b\"id\"\n        assert aki.authority_cert_issuer == [dns]\n        assert aki.authority_cert_serial_number == 0\n\n    def test_iter_input(self):\n        dirnames = [\n            x509.DirectoryName(\n                x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n            )\n        ]\n        aki = x509.AuthorityKeyIdentifier(b\"digest\", iter(dirnames), 1234)\n        assert aki.authority_cert_issuer is not None\n        assert list(aki.authority_cert_issuer) == dirnames\n\n    def test_repr(self):\n        dirname = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        aki = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n\n        assert repr(aki) == (\n            \"<AuthorityKeyIdentifier(key_identifier=b'digest', authority_\"\n            \"cert_issuer=[<DirectoryName(value=<Name(CN=myCN)>)>], author\"\n            \"ity_cert_serial_number=1234)>\"\n        )\n\n    def test_eq(self):\n        dirname = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        aki = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n        dirname2 = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        aki2 = x509.AuthorityKeyIdentifier(b\"digest\", [dirname2], 1234)\n        assert aki == aki2\n\n    def test_ne(self):\n        dirname = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        dirname5 = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"aCN\")])\n        )\n        aki = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n        aki2 = x509.AuthorityKeyIdentifier(b\"diges\", [dirname], 1234)\n        aki3 = x509.AuthorityKeyIdentifier(b\"digest\", None, None)\n        aki4 = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 12345)\n        aki5 = x509.AuthorityKeyIdentifier(b\"digest\", [dirname5], 12345)\n        assert aki != aki2\n        assert aki != aki3\n        assert aki != aki4\n        assert aki != aki5\n        assert aki != object()\n\n    def test_hash(self):\n        dirname = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        aki1 = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n        aki2 = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n        aki3 = x509.AuthorityKeyIdentifier(b\"digest\", None, None)\n        assert hash(aki1) == hash(aki2)\n        assert hash(aki1) != hash(aki3)\n\n    def test_public_bytes(self):\n        dirname = x509.DirectoryName(\n            x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")])\n        )\n        ext = x509.AuthorityKeyIdentifier(b\"digest\", [dirname], 1234)\n        assert (\n            ext.public_bytes()\n            == b\"0!\\x80\\x06digest\\xa1\\x13\\xa4\\x110\\x0f1\\r0\\x0b\\x06\\x03U\\x04\"\n            b\"\\x03\\x0c\\x04myCN\\x82\\x02\\x04\\xd2\"\n        )\n\n\nclass TestBasicConstraints:\n    def test_ca_not_boolean(self):\n        with pytest.raises(TypeError):\n            x509.BasicConstraints(\n                ca=\"notbool\",  # type:ignore[arg-type]\n                path_length=None,\n            )\n\n    def test_path_length_not_ca(self):\n        with pytest.raises(ValueError):\n            x509.BasicConstraints(ca=False, path_length=0)\n\n    def test_path_length_not_int(self):\n        with pytest.raises(TypeError):\n            x509.BasicConstraints(\n                ca=True,\n                path_length=1.1,  # type:ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            x509.BasicConstraints(\n                ca=True,\n                path_length=\"notint\",  # type:ignore[arg-type]\n            )\n\n    def test_path_length_negative(self):\n        with pytest.raises(TypeError):\n            x509.BasicConstraints(ca=True, path_length=-1)\n\n    def test_repr(self):\n        na = x509.BasicConstraints(ca=True, path_length=None)\n        assert repr(na) == (\"<BasicConstraints(ca=True, path_length=None)>\")\n\n    def test_hash(self):\n        na = x509.BasicConstraints(ca=True, path_length=None)\n        na2 = x509.BasicConstraints(ca=True, path_length=None)\n        na3 = x509.BasicConstraints(ca=True, path_length=0)\n        assert hash(na) == hash(na2)\n        assert hash(na) != hash(na3)\n\n    def test_eq(self):\n        na = x509.BasicConstraints(ca=True, path_length=None)\n        na2 = x509.BasicConstraints(ca=True, path_length=None)\n        assert na == na2\n\n    def test_ne(self):\n        na = x509.BasicConstraints(ca=True, path_length=None)\n        na2 = x509.BasicConstraints(ca=True, path_length=1)\n        na3 = x509.BasicConstraints(ca=False, path_length=None)\n        assert na != na2\n        assert na != na3\n        assert na != object()\n\n    def test_public_bytes(self):\n        ext = x509.BasicConstraints(ca=True, path_length=None)\n        assert ext.public_bytes() == b\"0\\x03\\x01\\x01\\xff\"\n\n\nclass TestExtendedKeyUsage:\n    def test_not_all_oids(self):\n        with pytest.raises(TypeError):\n            x509.ExtendedKeyUsage([\"notoid\"])  # type:ignore[list-item]\n\n    def test_iter_len(self):\n        eku = x509.ExtendedKeyUsage(\n            [\n                x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\"),\n                x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\"),\n            ]\n        )\n        assert len(eku) == 2\n        assert list(eku) == [\n            ExtendedKeyUsageOID.SERVER_AUTH,\n            ExtendedKeyUsageOID.CLIENT_AUTH,\n        ]\n\n    def test_iter_input(self):\n        usages = [\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\"),\n        ]\n        aia = x509.ExtendedKeyUsage(iter(usages))\n        assert list(aia) == usages\n\n    def test_repr(self):\n        eku = x509.ExtendedKeyUsage(\n            [\n                x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\"),\n                x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\"),\n            ]\n        )\n        assert repr(eku) == (\n            \"<ExtendedKeyUsage([<ObjectIdentifier(oid=1.3.6.1.5.5.7.3.1, name=\"\n            \"serverAuth)>, <ObjectIdentifier(oid=1.3.6.1.5.5.7.3.2, name=clien\"\n            \"tAuth)>])>\"\n        )\n\n    def test_eq(self):\n        eku = x509.ExtendedKeyUsage(\n            [x509.ObjectIdentifier(\"1.3.6\"), x509.ObjectIdentifier(\"1.3.7\")]\n        )\n        eku2 = x509.ExtendedKeyUsage(\n            [x509.ObjectIdentifier(\"1.3.6\"), x509.ObjectIdentifier(\"1.3.7\")]\n        )\n        assert eku == eku2\n\n    def test_ne(self):\n        eku = x509.ExtendedKeyUsage([x509.ObjectIdentifier(\"1.3.6\")])\n        eku2 = x509.ExtendedKeyUsage([x509.ObjectIdentifier(\"1.3.6.1\")])\n        assert eku != eku2\n        assert eku != object()\n\n    def test_hash(self):\n        eku = x509.ExtendedKeyUsage(\n            [x509.ObjectIdentifier(\"1.3.6\"), x509.ObjectIdentifier(\"1.3.7\")]\n        )\n        eku2 = x509.ExtendedKeyUsage(\n            [x509.ObjectIdentifier(\"1.3.6\"), x509.ObjectIdentifier(\"1.3.7\")]\n        )\n        eku3 = x509.ExtendedKeyUsage([x509.ObjectIdentifier(\"1.3.6\")])\n        assert hash(eku) == hash(eku2)\n        assert hash(eku) != hash(eku3)\n\n    def test_public_bytes(self):\n        ext = x509.ExtendedKeyUsage(\n            [x509.ObjectIdentifier(\"1.3.6\"), x509.ObjectIdentifier(\"1.3.7\")]\n        )\n        assert ext.public_bytes() == b\"0\\x08\\x06\\x02+\\x06\\x06\\x02+\\x07\"\n\n\nclass TestExtensions:\n    def test_no_extensions(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"verisign_md2_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions\n        assert len(ext) == 0\n        assert list(ext) == []\n        with pytest.raises(x509.ExtensionNotFound) as exc:\n            ext.get_extension_for_oid(ExtensionOID.BASIC_CONSTRAINTS)\n\n        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS\n\n    def test_one_extension(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"basic_constraints_not_critical.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.value.ca is False\n\n    def test_duplicate_extension(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"two_basic_constraints.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(x509.DuplicateExtension) as exc:\n            cert.extensions\n\n        assert exc.value.oid == ExtensionOID.BASIC_CONSTRAINTS\n\n    def test_unsupported_critical_extension(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"unsupported_extension_critical.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            x509.ObjectIdentifier(\"1.2.3.4\")\n        )\n        assert isinstance(ext.value, x509.UnrecognizedExtension)\n        assert ext.value.value == b\"value\"\n\n    def test_unsupported_extension(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"unsupported_extension_2.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        extensions = cert.extensions\n        assert len(extensions) == 2\n        assert extensions[0].critical is False\n        assert extensions[0].oid == x509.ObjectIdentifier(\n            \"1.3.6.1.4.1.41482.2\"\n        )\n        assert extensions[0].value == x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.3.6.1.4.1.41482.2\"),\n            b\"1.3.6.1.4.1.41482.1.2\",\n        )\n        assert extensions[1].critical is False\n        assert extensions[1].oid == x509.ObjectIdentifier(\n            \"1.3.6.1.4.1.45724.2.1.1\"\n        )\n        assert extensions[1].value == x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.3.6.1.4.1.45724.2.1.1\"), b\"\\x03\\x02\\x040\"\n        )\n\n    def test_no_extensions_get_for_class(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        exts = cert.extensions\n        with pytest.raises(x509.ExtensionNotFound) as exc:\n            exts.get_extension_for_class(x509.IssuerAlternativeName)\n        assert exc.value.oid == ExtensionOID.ISSUER_ALTERNATIVE_NAME\n\n    def test_unrecognized_extension_for_class(self):\n        exts = x509.Extensions([])\n        with pytest.raises(TypeError):\n            exts.get_extension_for_class(x509.UnrecognizedExtension)\n\n    def test_indexing(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        exts = cert.extensions\n        assert exts[-1] == exts[7]\n        assert exts[2:6:2] == [exts[2], exts[4]]\n\n    def test_one_extension_get_for_class(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"basic_constraints_not_critical.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n\n    def test_repr(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"basic_constraints_not_critical.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        assert repr(cert.extensions) == (\n            \"<Extensions([<Extension(oid=<ObjectIdentifier(oid=2.5.29.19, name\"\n            \"=basicConstraints)>, critical=False, value=<BasicConstraints(ca=F\"\n            \"alse, path_length=None)>)>])>\"\n        )\n\n\nclass TestBasicConstraintsExtension:\n    def test_ca_true_pathlen_6(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"PKITS_data\", \"certs\", \"pathLenConstraint6CACert.crt\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.critical is True\n        assert ext.value.ca is True\n        assert ext.value.path_length == 6\n\n    def test_path_length_zero(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"bc_path_length_zero.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.critical is True\n        assert ext.value.ca is True\n        assert ext.value.path_length == 0\n\n    def test_ca_true_no_pathlen(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.critical is True\n        assert ext.value.ca is True\n        assert ext.value.path_length is None\n\n    def test_ca_false(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.critical is True\n        assert ext.value.ca is False\n        assert ext.value.path_length is None\n\n    def test_no_basic_constraints(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\",\n                \"PKITS_data\",\n                \"certs\",\n                \"ValidCertificatePathTest1EE.crt\",\n            ),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(x509.ExtensionNotFound):\n            cert.extensions.get_extension_for_oid(\n                ExtensionOID.BASIC_CONSTRAINTS\n            )\n\n    def test_basic_constraint_not_critical(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"basic_constraints_not_critical.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.BasicConstraints)\n        assert ext is not None\n        assert ext.critical is False\n        assert ext.value.ca is False\n\n\nclass TestSubjectKeyIdentifierExtension:\n    def test_subject_key_identifier(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectKeyIdentifier\n        )\n        ski = ext.value\n        assert ext is not None\n        assert ext.critical is False\n        assert ski.digest == binascii.unhexlify(\n            b\"580184241bbc2b52944a3da510721451f5af3ac9\"\n        )\n\n    def test_no_subject_key_identifier(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"bc_path_length_zero.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(x509.ExtensionNotFound):\n            cert.extensions.get_extension_for_oid(\n                ExtensionOID.SUBJECT_KEY_IDENTIFIER\n            )\n\n    def test_from_rsa_public_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"PKITS_data\", \"certs\", \"GoodCACert.crt\"),\n            x509.load_der_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_KEY_IDENTIFIER\n        )\n        ski = x509.SubjectKeyIdentifier.from_public_key(cert.public_key())\n        assert ext.value == ski\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    def test_from_dsa_public_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_KEY_IDENTIFIER\n        )\n        ski = x509.SubjectKeyIdentifier.from_public_key(cert.public_key())\n        assert ext.value == ski\n\n    def test_invalid_bit_string_padding_from_public_key(self, backend):\n        data = load_vectors_from_file(\n            filename=os.path.join(\n                \"asymmetric\",\n                \"DER_Serialization\",\n                \"dsa_public_key_invalid_bit_string.der\",\n            ),\n            loader=lambda data: data.read(),\n            mode=\"rb\",\n        )\n        pretend_key = pretend.stub(public_bytes=lambda x, y: data)\n        with pytest.raises(ValueError):\n            _key_identifier_from_public_key(pretend_key)\n\n        # The previous value is invalid for 2 reasons: a) it's got non-zero\n        # padding bits (i.e. the first byte of the value is not zero), b) the\n        # padding bits aren't all set to zero (i.e. the last bits of the value)\n        # Here we swap the last byte out with zeros so we can hit both error\n        # checks.\n        pretend_key = pretend.stub(\n            public_bytes=lambda x, y: data[:-1] + b\"\\x00\"\n        )\n        with pytest.raises(ValueError, match=\"Invalid public key encoding\"):\n            _key_identifier_from_public_key(pretend_key)\n\n    def test_from_ec_public_key(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ecdsa_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_KEY_IDENTIFIER\n        )\n        ski = x509.SubjectKeyIdentifier.from_public_key(cert.public_key())\n        assert ext.value == ski\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_from_ed25519_public_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ed25519\", \"root-ed25519.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_KEY_IDENTIFIER\n        )\n        ski = x509.SubjectKeyIdentifier.from_public_key(cert.public_key())\n        assert ext.value == ski\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support\",\n    )\n    def test_from_ed448_public_key(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"ed448\", \"root-ed448.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_KEY_IDENTIFIER\n        )\n        ski = x509.SubjectKeyIdentifier.from_public_key(cert.public_key())\n        assert ext.value == ski\n\n\nclass TestKeyUsageExtension:\n    def test_no_key_usage(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"verisign_md2_root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions\n        with pytest.raises(x509.ExtensionNotFound) as exc:\n            ext.get_extension_for_oid(ExtensionOID.KEY_USAGE)\n\n        assert exc.value.oid == ExtensionOID.KEY_USAGE\n\n    def test_all_purposes(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"all_key_usages.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.KeyUsage)\n        assert ext is not None\n\n        ku = ext.value\n        assert ku.digital_signature is True\n        assert ku.content_commitment is True\n        assert ku.key_encipherment is True\n        assert ku.data_encipherment is True\n        assert ku.key_agreement is True\n        assert ku.key_cert_sign is True\n        assert ku.crl_sign is True\n        assert ku.encipher_only is True\n        assert ku.decipher_only is True\n\n    def test_key_cert_sign_crl_sign(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"PKITS_data\", \"certs\", \"pathLenConstraint6CACert.crt\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.KeyUsage)\n        assert ext is not None\n        assert ext.critical is True\n\n        ku = ext.value\n        assert ku.digital_signature is False\n        assert ku.content_commitment is False\n        assert ku.key_encipherment is False\n        assert ku.data_encipherment is False\n        assert ku.key_agreement is False\n        assert ku.key_cert_sign is True\n        assert ku.crl_sign is True\n\n\nclass TestDNSName:\n    def test_non_a_label(self):\n        with pytest.raises(ValueError):\n            x509.DNSName(\".\\xf5\\xe4\\xf6\\xfc.example.com\")\n\n    def test_init(self):\n        name = x509.DNSName(\"*.xn--4ca7aey.example.com\")\n        assert name.value == \"*.xn--4ca7aey.example.com\"\n\n        with pytest.raises(TypeError):\n            x509.DNSName(1.3)  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            x509.DNSName(b\"bytes not allowed\")  # type:ignore[arg-type]\n\n    def test_ne(self):\n        n1 = x509.DNSName(\"test1\")\n        n2 = x509.DNSName(\"test2\")\n        n3 = x509.DNSName(\"test2\")\n        assert n1 != n2\n        assert not (n2 != n3)\n\n    def test_hash(self):\n        n1 = x509.DNSName(\"test1\")\n        n2 = x509.DNSName(\"test2\")\n        n3 = x509.DNSName(\"test2\")\n        assert hash(n1) != hash(n2)\n        assert hash(n2) == hash(n3)\n\n\nclass TestDirectoryName:\n    def test_not_name(self):\n        with pytest.raises(TypeError):\n            x509.DirectoryName(b\"notaname\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            x509.DirectoryName(1.3)  # type:ignore[arg-type]\n\n    def test_repr(self):\n        name = x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"value1\")])\n        gn = x509.DirectoryName(name)\n        assert repr(gn) == \"<DirectoryName(value=<Name(CN=value1)>)>\"\n\n    def test_eq(self):\n        name = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")]\n        )\n        name2 = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")]\n        )\n        gn = x509.DirectoryName(name)\n        gn2 = x509.DirectoryName(name2)\n        assert gn == gn2\n\n    def test_ne(self):\n        name = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")]\n        )\n        name2 = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")]\n        )\n        gn = x509.DirectoryName(name)\n        gn2 = x509.DirectoryName(name2)\n        assert gn != gn2\n        assert gn != object()\n\n    def test_hash(self):\n        name = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.1\"), \"value1\")]\n        )\n        name2 = x509.Name(\n            [x509.NameAttribute(x509.ObjectIdentifier(\"2.999.2\"), \"value2\")]\n        )\n        gn = x509.DirectoryName(name)\n        gn2 = x509.DirectoryName(name)\n        gn3 = x509.DirectoryName(name2)\n        assert hash(gn) == hash(gn2)\n        assert hash(gn) != hash(gn3)\n\n\nclass TestRFC822Name:\n    def test_repr(self):\n        gn = x509.RFC822Name(\"string\")\n        assert repr(gn) == \"<RFC822Name(value='string')>\"\n\n    def test_equality(self):\n        gn = x509.RFC822Name(\"string\")\n        gn2 = x509.RFC822Name(\"string2\")\n        gn3 = x509.RFC822Name(\"string\")\n        assert gn != gn2\n        assert gn != object()\n        assert gn == gn3\n\n    def test_not_text(self):\n        with pytest.raises(TypeError):\n            x509.RFC822Name(1.3)  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            x509.RFC822Name(b\"bytes\")  # type:ignore[arg-type]\n\n    def test_invalid_email(self):\n        with pytest.raises(ValueError):\n            x509.RFC822Name(\"Name <email>\")\n\n        with pytest.raises(ValueError):\n            x509.RFC822Name(\"\")\n\n    def test_single_label(self):\n        gn = x509.RFC822Name(\"administrator\")\n        assert gn.value == \"administrator\"\n\n    def test_non_a_label(self):\n        with pytest.raises(ValueError):\n            x509.RFC822Name(\"email@em\\xe5\\xefl.com\")\n\n    def test_hash(self):\n        g1 = x509.RFC822Name(\"email@host.com\")\n        g2 = x509.RFC822Name(\"email@host.com\")\n        g3 = x509.RFC822Name(\"admin@host.com\")\n\n        assert hash(g1) == hash(g2)\n        assert hash(g1) != hash(g3)\n\n\nclass TestUniformResourceIdentifier:\n    def test_equality(self):\n        gn = x509.UniformResourceIdentifier(\"string\")\n        gn2 = x509.UniformResourceIdentifier(\"string2\")\n        gn3 = x509.UniformResourceIdentifier(\"string\")\n        assert gn != gn2\n        assert gn != object()\n        assert gn == gn3\n\n    def test_not_text(self):\n        with pytest.raises(TypeError):\n            x509.UniformResourceIdentifier(1.3)  # type:ignore[arg-type]\n\n    def test_no_parsed_hostname(self):\n        gn = x509.UniformResourceIdentifier(\"singlelabel\")\n        assert gn.value == \"singlelabel\"\n\n    def test_with_port(self):\n        gn = x509.UniformResourceIdentifier(\"singlelabel:443/test\")\n        assert gn.value == \"singlelabel:443/test\"\n\n    def test_non_a_label(self):\n        with pytest.raises(ValueError):\n            x509.UniformResourceIdentifier(\n                \"http://\\u043f\\u044b\\u043a\\u0430.cryptography\"\n            )\n\n    def test_empty_hostname(self):\n        gn = x509.UniformResourceIdentifier(\"ldap:///some-nonsense\")\n        assert gn.value == \"ldap:///some-nonsense\"\n\n    def test_hash(self):\n        g1 = x509.UniformResourceIdentifier(\"http://host.com\")\n        g2 = x509.UniformResourceIdentifier(\"http://host.com\")\n        g3 = x509.UniformResourceIdentifier(\"http://other.com\")\n\n        assert hash(g1) == hash(g2)\n        assert hash(g1) != hash(g3)\n\n    def test_repr(self):\n        gn = x509.UniformResourceIdentifier(\"string\")\n        assert repr(gn) == (\"<UniformResourceIdentifier(value='string')>\")\n\n\nclass TestRegisteredID:\n    def test_not_oid(self):\n        with pytest.raises(TypeError):\n            x509.RegisteredID(b\"notanoid\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            x509.RegisteredID(1.3)  # type:ignore[arg-type]\n\n    def test_repr(self):\n        gn = x509.RegisteredID(NameOID.COMMON_NAME)\n        assert repr(gn) == (\n            \"<RegisteredID(value=<ObjectIdentifier(oid=2.5.4.3, name=commonNam\"\n            \"e)>)>\"\n        )\n\n    def test_eq(self):\n        gn = x509.RegisteredID(NameOID.COMMON_NAME)\n        gn2 = x509.RegisteredID(NameOID.COMMON_NAME)\n        assert gn == gn2\n\n    def test_ne(self):\n        gn = x509.RegisteredID(NameOID.COMMON_NAME)\n        gn2 = x509.RegisteredID(ExtensionOID.BASIC_CONSTRAINTS)\n        assert gn != gn2\n        assert gn != object()\n\n    def test_hash(self):\n        gn = x509.RegisteredID(NameOID.COMMON_NAME)\n        gn2 = x509.RegisteredID(NameOID.COMMON_NAME)\n        gn3 = x509.RegisteredID(ExtensionOID.BASIC_CONSTRAINTS)\n        assert hash(gn) == hash(gn2)\n        assert hash(gn) != hash(gn3)\n\n\nclass TestIPAddress:\n    def test_not_ipaddress(self):\n        with pytest.raises(TypeError):\n            x509.IPAddress(b\"notanipaddress\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            x509.IPAddress(1.3)  # type:ignore[arg-type]\n\n    def test_repr(self):\n        gn = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        assert repr(gn) == \"<IPAddress(value=127.0.0.1)>\"\n\n        gn2 = x509.IPAddress(ipaddress.IPv6Address(\"ff::\"))\n        assert repr(gn2) == \"<IPAddress(value=ff::)>\"\n\n        gn3 = x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/24\"))\n        assert repr(gn3) == \"<IPAddress(value=192.168.0.0/24)>\"\n\n        gn4 = x509.IPAddress(ipaddress.IPv6Network(\"ff::/96\"))\n        assert repr(gn4) == \"<IPAddress(value=ff::/96)>\"\n\n    def test_eq(self):\n        gn = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        gn2 = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        assert gn == gn2\n\n    def test_ne(self):\n        gn = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        gn2 = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.2\"))\n        assert gn != gn2\n        assert gn != object()\n\n    def test_hash(self):\n        gn = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        gn2 = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n        gn3 = x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.2\"))\n        assert hash(gn) == hash(gn2)\n        assert hash(gn) != hash(gn3)\n\n\nclass TestOtherName:\n    def test_invalid_args(self):\n        with pytest.raises(TypeError):\n            x509.OtherName(\n                b\"notanobjectidentifier\",  # type:ignore[arg-type]\n                b\"derdata\",\n            )\n\n        with pytest.raises(TypeError):\n            x509.OtherName(\n                x509.ObjectIdentifier(\"1.2.3.4\"),\n                \"notderdata\",  # type:ignore[arg-type]\n            )\n\n    def test_repr(self):\n        gn = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        assert repr(gn) == (\n            \"<OtherName(type_id=<ObjectIdentifier(oid=1.2.3.4, \"\n            \"name=Unknown OID)>, value=b'derdata')>\"\n        )\n\n        gn = x509.OtherName(x509.ObjectIdentifier(\"2.5.4.65\"), b\"derdata\")\n        assert repr(gn) == (\n            \"<OtherName(type_id=<ObjectIdentifier(oid=2.5.4.65, \"\n            \"name=pseudonym)>, value=b'derdata')>\"\n        )\n\n    def test_eq(self):\n        gn = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        gn2 = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        assert gn == gn2\n\n    def test_ne(self):\n        gn = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        assert gn != object()\n\n        gn2 = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata2\")\n        assert gn != gn2\n\n        gn2 = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.5\"), b\"derdata\")\n        assert gn != gn2\n\n    def test_hash(self):\n        gn = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        gn2 = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.4\"), b\"derdata\")\n        gn3 = x509.OtherName(x509.ObjectIdentifier(\"1.2.3.5\"), b\"derdata\")\n        assert hash(gn) == hash(gn2)\n        assert hash(gn) != hash(gn3)\n\n\nclass TestGeneralNames:\n    def test_get_values_for_type(self):\n        gns = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        names = gns.get_values_for_type(x509.DNSName)\n        assert names == [\"cryptography.io\"]\n\n    def test_iter_names(self):\n        gns = x509.GeneralNames(\n            [x509.DNSName(\"cryptography.io\"), x509.DNSName(\"crypto.local\")]\n        )\n        assert len(gns) == 2\n        assert list(gns) == [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"crypto.local\"),\n        ]\n\n    def test_iter_input(self):\n        names = [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"crypto.local\"),\n        ]\n        gns = x509.GeneralNames(iter(names))\n        assert list(gns) == names\n\n    def test_indexing(self):\n        gn = x509.GeneralNames(\n            [\n                x509.DNSName(\"cryptography.io\"),\n                x509.DNSName(\"crypto.local\"),\n                x509.DNSName(\"another.local\"),\n                x509.RFC822Name(\"email@another.local\"),\n                x509.UniformResourceIdentifier(\"http://another.local\"),\n            ]\n        )\n        assert gn[-1] == gn[4]\n        assert gn[2:6:2] == [gn[2], gn[4]]\n\n    def test_invalid_general_names(self):\n        with pytest.raises(TypeError):\n            x509.GeneralNames(\n                [\n                    x509.DNSName(\"cryptography.io\"),\n                    \"invalid\",  # type:ignore[list-item]\n                ]\n            )\n\n    def test_repr(self):\n        gns = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        assert repr(gns) == (\n            \"<GeneralNames([<DNSName(value='cryptography.io')>])>\"\n        )\n\n    def test_eq(self):\n        gns = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        gns2 = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        assert gns == gns2\n\n    def test_ne(self):\n        gns = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        gns2 = x509.GeneralNames([x509.RFC822Name(\"admin@cryptography.io\")])\n        assert gns != gns2\n        assert gns != object()\n\n    def test_hash(self):\n        gns = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        gns2 = x509.GeneralNames([x509.DNSName(\"cryptography.io\")])\n        gns3 = x509.GeneralNames([x509.RFC822Name(\"admin@cryptography.io\")])\n        assert hash(gns) == hash(gns2)\n        assert hash(gns) != hash(gns3)\n\n\nclass TestIssuerAlternativeName:\n    def test_get_values_for_type(self):\n        san = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        names = san.get_values_for_type(x509.DNSName)\n        assert names == [\"cryptography.io\"]\n\n    def test_iter_names(self):\n        san = x509.IssuerAlternativeName(\n            [x509.DNSName(\"cryptography.io\"), x509.DNSName(\"crypto.local\")]\n        )\n        assert len(san) == 2\n        assert list(san) == [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"crypto.local\"),\n        ]\n\n    def test_indexing(self):\n        ian = x509.IssuerAlternativeName(\n            [\n                x509.DNSName(\"cryptography.io\"),\n                x509.DNSName(\"crypto.local\"),\n                x509.DNSName(\"another.local\"),\n                x509.RFC822Name(\"email@another.local\"),\n                x509.UniformResourceIdentifier(\"http://another.local\"),\n            ]\n        )\n        assert ian[-1] == ian[4]\n        assert ian[2:6:2] == [ian[2], ian[4]]\n\n    def test_invalid_general_names(self):\n        with pytest.raises(TypeError):\n            x509.IssuerAlternativeName(\n                [\n                    x509.DNSName(\"cryptography.io\"),\n                    \"invalid\",  # type:ignore[list-item]\n                ]\n            )\n\n    def test_repr(self):\n        san = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert repr(san) == (\n            \"<IssuerAlternativeName(\"\n            \"<GeneralNames([<DNSName(value='cryptography.io')>])>)>\"\n        )\n\n    def test_eq(self):\n        san = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san2 = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert san == san2\n\n    def test_ne(self):\n        san = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san2 = x509.IssuerAlternativeName(\n            [x509.RFC822Name(\"admin@cryptography.io\")]\n        )\n        assert san != san2\n        assert san != object()\n\n    def test_hash(self):\n        ian = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        ian2 = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        ian3 = x509.IssuerAlternativeName(\n            [x509.RFC822Name(\"admin@cryptography.io\")]\n        )\n        assert hash(ian) == hash(ian2)\n        assert hash(ian) != hash(ian3)\n\n    def test_public_bytes(self):\n        ext = x509.IssuerAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert ext.public_bytes() == b\"0\\x11\\x82\\x0fcryptography.io\"\n\n\nclass TestRSAIssuerAlternativeNameExtension:\n    def test_uri(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ian_uri.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.IssuerAlternativeName\n        )\n        assert list(ext.value) == [\n            x509.UniformResourceIdentifier(\"http://path.to.root/root.crt\"),\n        ]\n\n\nclass TestCRLNumber:\n    def test_eq(self):\n        crl_number = x509.CRLNumber(15)\n        assert crl_number == x509.CRLNumber(15)\n\n    def test_ne(self):\n        crl_number = x509.CRLNumber(15)\n        assert crl_number != x509.CRLNumber(14)\n        assert crl_number != object()\n\n    def test_repr(self):\n        crl_number = x509.CRLNumber(15)\n        assert repr(crl_number) == \"<CRLNumber(15)>\"\n\n    def test_invalid_number(self):\n        with pytest.raises(TypeError):\n            x509.CRLNumber(\"notanumber\")  # type:ignore[arg-type]\n\n    def test_hash(self):\n        c1 = x509.CRLNumber(1)\n        c2 = x509.CRLNumber(1)\n        c3 = x509.CRLNumber(2)\n        assert hash(c1) == hash(c2)\n        assert hash(c1) != hash(c3)\n\n    def test_public_bytes(self):\n        ext = x509.CRLNumber(15)\n        assert ext.public_bytes() == b\"\\x02\\x01\\x0f\"\n\n\nclass TestSubjectAlternativeName:\n    def test_get_values_for_type(self):\n        san = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        names = san.get_values_for_type(x509.DNSName)\n        assert names == [\"cryptography.io\"]\n\n    def test_iter_names(self):\n        san = x509.SubjectAlternativeName(\n            [x509.DNSName(\"cryptography.io\"), x509.DNSName(\"crypto.local\")]\n        )\n        assert len(san) == 2\n        assert list(san) == [\n            x509.DNSName(\"cryptography.io\"),\n            x509.DNSName(\"crypto.local\"),\n        ]\n\n    def test_indexing(self):\n        san = x509.SubjectAlternativeName(\n            [\n                x509.DNSName(\"cryptography.io\"),\n                x509.DNSName(\"crypto.local\"),\n                x509.DNSName(\"another.local\"),\n                x509.RFC822Name(\"email@another.local\"),\n                x509.UniformResourceIdentifier(\"http://another.local\"),\n            ]\n        )\n        assert san[-1] == san[4]\n        assert san[2:6:2] == [san[2], san[4]]\n\n    def test_invalid_general_names(self):\n        with pytest.raises(TypeError):\n            x509.SubjectAlternativeName(\n                [\n                    x509.DNSName(\"cryptography.io\"),\n                    \"invalid\",  # type:ignore[list-item]\n                ]\n            )\n\n    def test_repr(self):\n        san = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert repr(san) == (\n            \"<SubjectAlternativeName(\"\n            \"<GeneralNames([<DNSName(value='cryptography.io')>])>)>\"\n        )\n\n    def test_eq(self):\n        san = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san2 = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert san == san2\n\n    def test_ne(self):\n        san = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san2 = x509.SubjectAlternativeName(\n            [x509.RFC822Name(\"admin@cryptography.io\")]\n        )\n        assert san != san2\n        assert san != object()\n\n    def test_hash(self):\n        san = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san2 = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        san3 = x509.SubjectAlternativeName(\n            [x509.RFC822Name(\"admin@cryptography.io\")]\n        )\n        assert hash(san) == hash(san2)\n        assert hash(san) != hash(san3)\n\n    def test_public_bytes(self):\n        ext = x509.SubjectAlternativeName([x509.DNSName(\"cryptography.io\")])\n        assert ext.public_bytes() == b\"0\\x11\\x82\\x0fcryptography.io\"\n\n\nclass TestRSASubjectAlternativeNameExtension:\n    def test_dns_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n\n        dns = san.get_values_for_type(x509.DNSName)\n        assert dns == [\"www.cryptography.io\", \"cryptography.io\"]\n\n    def test_wildcard_dns_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"wildcard_san.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n\n        dns = ext.value.get_values_for_type(x509.DNSName)\n        assert dns == [\n            \"*.langui.sh\",\n            \"langui.sh\",\n            \"*.saseliminator.com\",\n            \"saseliminator.com\",\n        ]\n\n    def test_san_empty_hostname(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_empty_hostname.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        san = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n        )\n\n        assert isinstance(san.value, x509.SubjectAlternativeName)\n        dns = san.value.get_values_for_type(x509.DNSName)\n        assert dns == [\"\"]\n\n    def test_san_wildcard_idna_dns_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_wildcard_idna.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n\n        dns = ext.value.get_values_for_type(x509.DNSName)\n        assert dns == [\"*.xn--80ato2c.cryptography\"]\n\n    def test_unsupported_gn(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"san_x400address.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(x509.UnsupportedGeneralNameType):\n            cert.extensions\n\n    def test_registered_id(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_registered_id.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n        rid = san.get_values_for_type(x509.RegisteredID)\n        assert rid == [x509.ObjectIdentifier(\"1.2.3.4\")]\n\n    def test_uri(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_uri_with_port.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        uri = ext.value.get_values_for_type(x509.UniformResourceIdentifier)\n        assert uri == [\n            \"gopher://xn--80ato2c.cryptography:70/path?q=s#hello\",\n            \"http://someregulardomain.com\",\n        ]\n\n    def test_ipaddress(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_ipaddr.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n\n        ip = san.get_values_for_type(x509.IPAddress)\n        assert [\n            ipaddress.ip_address(\"127.0.0.1\"),\n            ipaddress.ip_address(\"ff::\"),\n        ] == ip\n\n    def test_dirname(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_dirname.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n\n        dirname = san.get_values_for_type(x509.DirectoryName)\n        assert [\n            x509.Name(\n                [\n                    x509.NameAttribute(NameOID.COMMON_NAME, \"test\"),\n                    x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"Org\"),\n                    x509.NameAttribute(\n                        NameOID.STATE_OR_PROVINCE_NAME, \"Texas\"\n                    ),\n                ]\n            )\n        ] == dirname\n\n    def test_rfc822name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_rfc822_idna.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n\n        rfc822name = san.get_values_for_type(x509.RFC822Name)\n        assert [\"email@xn--eml-vla4c.com\"] == rfc822name\n\n    def test_idna2003_invalid(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_idna2003_dnsname.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        san = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        ).value\n\n        assert len(san) == 1\n        [name] = san\n        assert name.value == \"xn--k4h.ws\"\n\n    def test_unicode_rfc822_name_dns_name_uri(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_idna_names.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        rfc822_name = ext.value.get_values_for_type(x509.RFC822Name)\n        dns_name = ext.value.get_values_for_type(x509.DNSName)\n        uri = ext.value.get_values_for_type(x509.UniformResourceIdentifier)\n        assert rfc822_name == [\"email@xn--80ato2c.cryptography\"]\n        assert dns_name == [\"xn--80ato2c.cryptography\"]\n        assert uri == [\"https://www.xn--80ato2c.cryptography\"]\n\n    def test_rfc822name_dnsname_ipaddress_directoryname_uri(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_email_dns_ip_dirname_uri.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        san = ext.value\n\n        rfc822_name = san.get_values_for_type(x509.RFC822Name)\n        uri = san.get_values_for_type(x509.UniformResourceIdentifier)\n        dns = san.get_values_for_type(x509.DNSName)\n        ip = san.get_values_for_type(x509.IPAddress)\n        dirname = san.get_values_for_type(x509.DirectoryName)\n        assert [\"user@cryptography.io\"] == rfc822_name\n        assert [\"https://cryptography.io\"] == uri\n        assert [\"cryptography.io\"] == dns\n        assert [\n            x509.Name(\n                [\n                    x509.NameAttribute(NameOID.COMMON_NAME, \"dirCN\"),\n                    x509.NameAttribute(\n                        NameOID.ORGANIZATION_NAME, \"Cryptographic Authority\"\n                    ),\n                ]\n            )\n        ] == dirname\n        assert [\n            ipaddress.ip_address(\"127.0.0.1\"),\n            ipaddress.ip_address(\"ff::\"),\n        ] == ip\n\n    def test_invalid_rfc822name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_rfc822_names.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        san = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        ).value\n        values = san.get_values_for_type(x509.RFC822Name)\n        assert values == [\n            \"email\",\n            \"email <email>\",\n            \"email <email@email>\",\n            \"email <email@xn--eml-vla4c.com>\",\n            \"myemail:\",\n        ]\n\n    def test_other_name(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"san_other_name.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        ext = cert.extensions.get_extension_for_class(\n            x509.SubjectAlternativeName\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        expected = x509.OtherName(\n            x509.ObjectIdentifier(\"1.2.3.4\"), b\"\\x16\\x0bHello World\"\n        )\n        assert len(ext.value) == 1\n        assert next(iter(ext.value)) == expected\n\n        othernames = ext.value.get_values_for_type(x509.OtherName)\n        assert othernames == [expected]\n\n    def test_certbuilder(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        sans = [\n            \"*.example.org\",\n            \"*.xn--4ca7aey.example.com\",\n            \"foobar.example.net\",\n        ]\n        private_key = rsa_key_2048\n        builder = _make_certbuilder(private_key)\n        builder = builder.add_extension(\n            SubjectAlternativeName(list(map(DNSName, sans))), True\n        )\n\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        result = [\n            x.value\n            for x in cert.extensions.get_extension_for_class(\n                SubjectAlternativeName\n            ).value\n        ]\n        assert result == sans\n\n\nclass TestExtendedKeyUsageExtension:\n    def test_eku(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"extended_key_usage.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(x509.ExtendedKeyUsage)\n        assert ext is not None\n        assert ext.critical is False\n\n        assert [\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.3\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.4\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.9\"),\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.3.8\"),\n            x509.ObjectIdentifier(\"2.5.29.37.0\"),\n            x509.ObjectIdentifier(\"2.16.840.1.113730.4.1\"),\n        ] == list(ext.value)\n\n\nclass TestAccessDescription:\n    def test_invalid_access_method(self):\n        with pytest.raises(TypeError):\n            x509.AccessDescription(\n                \"notanoid\",  # type:ignore[arg-type]\n                x509.DNSName(\"test\"),\n            )\n\n    def test_invalid_access_location(self):\n        with pytest.raises(TypeError):\n            x509.AccessDescription(\n                AuthorityInformationAccessOID.CA_ISSUERS,\n                \"invalid\",  # type:ignore[arg-type]\n            )\n\n    def test_valid_nonstandard_method(self):\n        ad = x509.AccessDescription(\n            ObjectIdentifier(\"2.999.1\"),\n            x509.UniformResourceIdentifier(\"http://example.com\"),\n        )\n        assert ad is not None\n\n    def test_repr(self):\n        ad = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        assert repr(ad) == (\n            \"<AccessDescription(access_method=<ObjectIdentifier(oid=1.3.6\"\n            \".1.5.5.7.48.1, name=OCSP)>, access_location=<UniformResource\"\n            \"Identifier(value='http://ocsp.domain.com')>)>\"\n        )\n\n    def test_eq(self):\n        ad = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        ad2 = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        assert ad == ad2\n\n    def test_ne(self):\n        ad = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        ad2 = x509.AccessDescription(\n            AuthorityInformationAccessOID.CA_ISSUERS,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        ad3 = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://notthesame\"),\n        )\n        assert ad != ad2\n        assert ad != ad3\n        assert ad != object()\n\n    def test_hash(self):\n        ad = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        ad2 = x509.AccessDescription(\n            AuthorityInformationAccessOID.OCSP,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        ad3 = x509.AccessDescription(\n            AuthorityInformationAccessOID.CA_ISSUERS,\n            x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n        )\n        assert hash(ad) == hash(ad2)\n        assert hash(ad) != hash(ad3)\n\n\nclass TestPolicyConstraints:\n    def test_invalid_explicit_policy(self):\n        with pytest.raises(TypeError):\n            x509.PolicyConstraints(\"invalid\", None)  # type:ignore[arg-type]\n\n    def test_invalid_inhibit_policy(self):\n        with pytest.raises(TypeError):\n            x509.PolicyConstraints(None, \"invalid\")  # type:ignore[arg-type]\n\n    def test_both_none(self):\n        with pytest.raises(ValueError):\n            x509.PolicyConstraints(None, None)\n\n    def test_repr(self):\n        pc = x509.PolicyConstraints(0, None)\n\n        assert repr(pc) == (\n            \"<PolicyConstraints(require_explicit_policy=0, inhibit_policy_ma\"\n            \"pping=None)>\"\n        )\n\n    def test_eq(self):\n        pc = x509.PolicyConstraints(2, 1)\n        pc2 = x509.PolicyConstraints(2, 1)\n        assert pc == pc2\n\n    def test_ne(self):\n        pc = x509.PolicyConstraints(2, 1)\n        pc2 = x509.PolicyConstraints(2, 2)\n        pc3 = x509.PolicyConstraints(3, 1)\n        assert pc != pc2\n        assert pc != pc3\n        assert pc != object()\n\n    def test_hash(self):\n        pc = x509.PolicyConstraints(2, 1)\n        pc2 = x509.PolicyConstraints(2, 1)\n        pc3 = x509.PolicyConstraints(2, None)\n        assert hash(pc) == hash(pc2)\n        assert hash(pc) != hash(pc3)\n\n    def test_public_bytes(self):\n        ext = x509.PolicyConstraints(2, 1)\n        assert ext.public_bytes() == b\"0\\x06\\x80\\x01\\x02\\x81\\x01\\x01\"\n\n\nclass TestPolicyConstraintsExtension:\n    def test_inhibit_policy_mapping(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"department-of-state-root.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.POLICY_CONSTRAINTS,\n        )\n        assert ext.critical is True\n\n        assert ext.value == x509.PolicyConstraints(\n            require_explicit_policy=None,\n            inhibit_policy_mapping=0,\n        )\n\n    def test_require_explicit_policy(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"policy_constraints_explicit.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.POLICY_CONSTRAINTS\n        )\n        assert ext.critical is True\n        assert ext.value == x509.PolicyConstraints(\n            require_explicit_policy=1,\n            inhibit_policy_mapping=None,\n        )\n\n    def test_public_bytes(self):\n        ext = x509.PolicyConstraints(\n            require_explicit_policy=None,\n            inhibit_policy_mapping=0,\n        )\n        assert ext.public_bytes() == b\"\\x30\\x03\\x81\\x01\\x00\"\n\n\nclass TestAuthorityInformationAccess:\n    def test_invalid_descriptions(self):\n        with pytest.raises(TypeError):\n            x509.AuthorityInformationAccess(\n                [\"notanAccessDescription\"]  # type:ignore[list-item]\n            )\n\n    def test_iter_len(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        assert len(aia) == 2\n        assert list(aia) == [\n            x509.AccessDescription(\n                AuthorityInformationAccessOID.OCSP,\n                x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n            ),\n            x509.AccessDescription(\n                AuthorityInformationAccessOID.CA_ISSUERS,\n                x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n            ),\n        ]\n\n    def test_iter_input(self):\n        desc = [\n            x509.AccessDescription(\n                AuthorityInformationAccessOID.OCSP,\n                x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n            )\n        ]\n        aia = x509.AuthorityInformationAccess(iter(desc))\n        assert list(aia) == desc\n\n    def test_repr(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        assert repr(aia) == (\n            \"<AuthorityInformationAccess([<AccessDescription(access_method\"\n            \"=<ObjectIdentifier(oid=1.3.6.1.5.5.7.48.1, name=OCSP)>, acces\"\n            \"s_location=<UniformResourceIdentifier(value='http://oc\"\n            \"sp.domain.com')>)>, <AccessDescription(access_method=<ObjectI\"\n            \"dentifier(oid=1.3.6.1.5.5.7.48.2, name=caIssuers)>, access_lo\"\n            \"cation=<UniformResourceIdentifier(value='http://domain\"\n            \".com/ca.crt')>)>])>\"\n        )\n\n    def test_eq(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        aia2 = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        assert aia == aia2\n\n    def test_ne(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        aia2 = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n            ]\n        )\n\n        assert aia != aia2\n        assert aia != object()\n\n    def test_indexing(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp2.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp3.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp4.domain.com\"),\n                ),\n            ]\n        )\n        assert aia[-1] == aia[4]\n        assert aia[2:6:2] == [aia[2], aia[4]]\n\n    def test_hash(self):\n        aia = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        aia2 = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        aia3 = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.other.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        assert hash(aia) == hash(aia2)\n        assert hash(aia) != hash(aia3)\n\n    def test_public_bytes(self):\n        ext = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.other.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\"http://domain.com/ca.crt\"),\n                ),\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0I0!\\x06\\x08+\\x06\\x01\\x05\\x05\\x070\\x01\\x86\\x15http://\"\n            b\"ocsp.other.com0$\\x06\\x08+\\x06\\x01\\x05\\x05\\x070\\x02\\x86\\x18\"\n            b\"http://domain.com/ca.crt\"\n        )\n\n\nclass TestSubjectInformationAccess:\n    def test_invalid_descriptions(self):\n        with pytest.raises(TypeError):\n            x509.SubjectInformationAccess(\n                [\"notanAccessDescription\"]  # type:ignore[list-item]\n            )\n\n    def test_iter_len(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        assert len(sia) == 2\n        assert list(sia) == [\n            x509.AccessDescription(\n                SubjectInformationAccessOID.CA_REPOSITORY,\n                x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n            ),\n            x509.AccessDescription(\n                SubjectInformationAccessOID.CA_REPOSITORY,\n                x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n            ),\n        ]\n\n    def test_iter_input(self):\n        desc = [\n            x509.AccessDescription(\n                SubjectInformationAccessOID.CA_REPOSITORY,\n                x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n            )\n        ]\n        sia = x509.SubjectInformationAccess(iter(desc))\n        assert list(sia) == desc\n\n    def test_repr(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                )\n            ]\n        )\n        assert repr(sia) == (\n            \"<SubjectInformationAccess([<AccessDescription(access_method\"\n            \"=<ObjectIdentifier(oid=1.3.6.1.5.5.7.48.5, name=caRepositor\"\n            \"y)>, access_location=<UniformResourceIdentifier(value='http\"\n            \"://ca.domain.com')>)>])>\"\n        )\n\n    def test_eq(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        sia2 = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        assert sia == sia2\n\n    def test_ne(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        sia2 = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n            ]\n        )\n\n        assert sia != sia2\n        assert sia != object()\n\n    def test_indexing(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca3.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca4.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca5.domain.com\"),\n                ),\n            ]\n        )\n        assert sia[-1] == sia[4]\n        assert sia[2:6:2] == [sia[2], sia[4]]\n\n    def test_hash(self):\n        sia = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        sia2 = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca2.domain.com\"),\n                ),\n            ]\n        )\n        sia3 = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca3.domain.com\"),\n                ),\n            ]\n        )\n        assert hash(sia) == hash(sia2)\n        assert hash(sia) != hash(sia3)\n\n    def test_public_bytes(self):\n        ext = x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"http://ca3.domain.com\"),\n                ),\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0E0 \\x06\\x08+\\x06\\x01\\x05\\x05\\x070\\x05\\x86\\x14http://\"\n            b\"ca.domain.com0!\\x06\\x08+\\x06\\x01\\x05\\x05\\x070\\x05\\x86\\x15\"\n            b\"http://ca3.domain.com\"\n        )\n\n\nclass TestSubjectInformationAccessExtension:\n    def test_sia(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"sia.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.SUBJECT_INFORMATION_ACCESS\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value == x509.SubjectInformationAccess(\n            [\n                x509.AccessDescription(\n                    SubjectInformationAccessOID.CA_REPOSITORY,\n                    x509.UniformResourceIdentifier(\"https://my.ca.issuer/\"),\n                ),\n                x509.AccessDescription(\n                    x509.ObjectIdentifier(\"2.999.7\"),\n                    x509.UniformResourceIdentifier(\n                        \"gopher://info-mac-archive\"\n                    ),\n                ),\n            ]\n        )\n\n\nclass TestAuthorityInformationAccessExtension:\n    def test_aia_ocsp_ca_issuers(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value == x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://gv.symcd.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.UniformResourceIdentifier(\n                        \"http://gv.symcb.com/gv.crt\"\n                    ),\n                ),\n            ]\n        )\n\n    def test_aia_multiple_ocsp_ca_issuers(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"aia_ocsp_ca_issuers.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value == x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp2.domain.com\"),\n                ),\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"myCN\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME, \"some Org\"\n                                ),\n                            ]\n                        )\n                    ),\n                ),\n            ]\n        )\n\n    def test_aia_ocsp_only(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"aia_ocsp.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value == x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.OCSP,\n                    x509.UniformResourceIdentifier(\"http://ocsp.domain.com\"),\n                ),\n            ]\n        )\n\n    def test_aia_ca_issuers_only(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"aia_ca_issuers.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value == x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"myCN\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME, \"some Org\"\n                                ),\n                            ]\n                        )\n                    ),\n                ),\n            ]\n        )\n\n    def test_public_bytes(self):\n        ext = x509.AuthorityInformationAccess(\n            [\n                x509.AccessDescription(\n                    AuthorityInformationAccessOID.CA_ISSUERS,\n                    x509.DirectoryName(\n                        x509.Name(\n                            [\n                                x509.NameAttribute(\n                                    NameOID.COMMON_NAME, \"myCN\"\n                                ),\n                                x509.NameAttribute(\n                                    NameOID.ORGANIZATION_NAME, \"some Org\"\n                                ),\n                            ]\n                        )\n                    ),\n                ),\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b'0200\\x06\\x08+\\x06\\x01\\x05\\x05\\x070\\x02\\xa4$0\"1\\r0\\x0b\\x06'\n            b\"\\x03U\\x04\\x03\\x0c\\x04myCN1\\x110\\x0f\\x06\\x03U\\x04\\n\\x0c\\x08\"\n            b\"some Org\"\n        )\n\n\nclass TestAuthorityKeyIdentifierExtension:\n    def test_aki_keyid(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.AuthorityKeyIdentifier\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value.key_identifier == (\n            b\"\\xc3\\x9c\\xf3\\xfc\\xd3F\\x084\\xbb\\xceF\\x7f\\xa0|[\\xf3\\xe2\\x08\\xcbY\"\n        )\n        assert ext.value.authority_cert_issuer is None\n        assert ext.value.authority_cert_serial_number is None\n\n    def test_aki_all_fields(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"authority_key_identifier.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.AuthorityKeyIdentifier\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value.key_identifier == (\n            b\"9E>\\xca=b\\x1d\\xea\\x86I\\xf6Z\\xab@\\xb7\\xa4p\\x98\\xf1\\xec\"\n        )\n        assert ext.value.authority_cert_issuer == [\n            x509.DirectoryName(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io\"\n                        ),\n                    ]\n                )\n            )\n        ]\n        assert ext.value.authority_cert_serial_number == 3\n\n    def test_aki_no_keyid(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"authority_key_identifier_no_keyid.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_class(\n            x509.AuthorityKeyIdentifier\n        )\n        assert ext is not None\n        assert ext.critical is False\n\n        assert ext.value.key_identifier is None\n        assert ext.value.authority_cert_issuer == [\n            x509.DirectoryName(\n                x509.Name(\n                    [\n                        x509.NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io\"\n                        ),\n                    ]\n                )\n            )\n        ]\n        assert ext.value.authority_cert_serial_number == 3\n\n    def test_from_certificate(self, backend):\n        issuer_cert = _load_cert(\n            os.path.join(\"x509\", \"rapidssl_sha256_ca_g3.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_KEY_IDENTIFIER\n        )\n        public_key = issuer_cert.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        aki = x509.AuthorityKeyIdentifier.from_issuer_public_key(public_key)\n        assert ext.value == aki\n\n    def test_from_issuer_subject_key_identifier(self, backend):\n        issuer_cert = _load_cert(\n            os.path.join(\"x509\", \"rapidssl_sha256_ca_g3.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(\n            ExtensionOID.AUTHORITY_KEY_IDENTIFIER\n        )\n        ski_ext = issuer_cert.extensions.get_extension_for_class(\n            x509.SubjectKeyIdentifier\n        )\n        aki = x509.AuthorityKeyIdentifier.from_issuer_subject_key_identifier(\n            ski_ext.value\n        )\n        assert ext.value == aki\n\n\nclass TestNameConstraints:\n    def test_ipaddress_wrong_type(self):\n        with pytest.raises(TypeError):\n            x509.NameConstraints(\n                permitted_subtrees=[\n                    x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n                ],\n                excluded_subtrees=None,\n            )\n\n        with pytest.raises(TypeError):\n            x509.NameConstraints(\n                permitted_subtrees=None,\n                excluded_subtrees=[\n                    x509.IPAddress(ipaddress.IPv4Address(\"127.0.0.1\"))\n                ],\n            )\n\n    def test_ipaddress_allowed_type(self):\n        permitted = [x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/29\"))]\n        excluded = [x509.IPAddress(ipaddress.IPv4Network(\"10.10.0.0/24\"))]\n        nc = x509.NameConstraints(\n            permitted_subtrees=permitted, excluded_subtrees=excluded\n        )\n        assert nc.permitted_subtrees == permitted\n        assert nc.excluded_subtrees == excluded\n\n    def test_dnsname_wrong_value(self):\n        with pytest.raises(ValueError):\n            x509.NameConstraints(\n                permitted_subtrees=[x509.DNSName(\"*.example.com\")],\n                excluded_subtrees=None,\n            )\n\n        with pytest.raises(ValueError):\n            x509.NameConstraints(\n                permitted_subtrees=None,\n                excluded_subtrees=[x509.DNSName(\"*.example.com\")],\n            )\n\n    def test_dnsname_allowed_value(self):\n        permitted = [x509.DNSName(\"example.com\")]\n        excluded = [x509.DNSName(\"www.example.com\")]\n        nc = x509.NameConstraints(\n            permitted_subtrees=permitted, excluded_subtrees=excluded\n        )\n        assert nc.permitted_subtrees == permitted\n        assert nc.excluded_subtrees == excluded\n\n    def test_invalid_permitted_subtrees(self):\n        with pytest.raises(TypeError):\n            x509.NameConstraints(\"badpermitted\", None)  # type:ignore[arg-type]\n\n    def test_invalid_excluded_subtrees(self):\n        with pytest.raises(TypeError):\n            x509.NameConstraints(None, \"badexcluded\")  # type:ignore[arg-type]\n\n    def test_no_subtrees(self):\n        with pytest.raises(ValueError):\n            x509.NameConstraints(None, None)\n\n    def test_permitted_none(self):\n        excluded = [x509.DNSName(\"name.local\")]\n        nc = x509.NameConstraints(\n            permitted_subtrees=None, excluded_subtrees=excluded\n        )\n        assert nc.permitted_subtrees is None\n        assert nc.excluded_subtrees is not None\n\n    def test_excluded_none(self):\n        permitted = [x509.DNSName(\"name.local\")]\n        nc = x509.NameConstraints(\n            permitted_subtrees=permitted, excluded_subtrees=None\n        )\n        assert nc.permitted_subtrees is not None\n        assert nc.excluded_subtrees is None\n\n    def test_iter_input(self):\n        subtrees = [x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/24\"))]\n        nc = x509.NameConstraints(iter(subtrees), iter(subtrees))\n        assert nc.permitted_subtrees is not None\n        assert list(nc.permitted_subtrees) == subtrees\n        assert nc.excluded_subtrees is not None\n        assert list(nc.excluded_subtrees) == subtrees\n\n    def test_empty_lists(self):\n        with pytest.raises(ValueError):\n            x509.NameConstraints(permitted_subtrees=None, excluded_subtrees=[])\n        with pytest.raises(ValueError):\n            x509.NameConstraints(permitted_subtrees=[], excluded_subtrees=None)\n\n    def test_repr(self):\n        permitted = [x509.DNSName(\"name.local\"), x509.DNSName(\"name2.local\")]\n        nc = x509.NameConstraints(\n            permitted_subtrees=permitted, excluded_subtrees=None\n        )\n        assert repr(nc) == (\n            \"<NameConstraints(permitted_subtrees=[<DNSName(\"\n            \"value='name.local')>, <DNSName(value=\"\n            \"'name2.local')>], excluded_subtrees=None)>\"\n        )\n\n    def test_eq(self):\n        nc = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        nc2 = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        assert nc == nc2\n\n    def test_ne(self):\n        nc = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        nc2 = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=None,\n        )\n        nc3 = x509.NameConstraints(\n            permitted_subtrees=None,\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n\n        assert nc != nc2\n        assert nc != nc3\n        assert nc != object()\n\n    def test_hash(self):\n        nc = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        nc2 = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        nc3 = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=None,\n        )\n        nc4 = x509.NameConstraints(\n            permitted_subtrees=None,\n            excluded_subtrees=[x509.DNSName(\"name.local\")],\n        )\n        assert hash(nc) == hash(nc2)\n        assert hash(nc) != hash(nc3)\n        assert hash(nc3) != hash(nc4)\n\n    def test_public_bytes(self):\n        ext = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"name.local\")],\n            excluded_subtrees=[x509.DNSName(\"name2.local\")],\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0!\\xa0\\x0e0\\x0c\\x82\\nname.local\\xa1\\x0f0\\r\\x82\\x0bname2.local\"\n        )\n\n\nclass TestNameConstraintsExtension:\n    def test_permitted_excluded(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_permitted_excluded_2.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"zombo.local\")],\n            excluded_subtrees=[\n                x509.DirectoryName(\n                    x509.Name(\n                        [x509.NameAttribute(NameOID.COMMON_NAME, \"zombo\")]\n                    )\n                )\n            ],\n        )\n\n    def test_permitted(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_permitted_2.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"zombo.local\")],\n            excluded_subtrees=None,\n        )\n\n    def test_permitted_with_leading_period(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_permitted.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=[\n                x509.DNSName(\".cryptography.io\"),\n                x509.UniformResourceIdentifier(\"ftp://cryptography.test\"),\n            ],\n            excluded_subtrees=None,\n        )\n\n    def test_excluded_with_leading_period(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_excluded.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=None,\n            excluded_subtrees=[\n                x509.DNSName(\".cryptography.io\"),\n                x509.UniformResourceIdentifier(\"gopher://cryptography.test\"),\n            ],\n        )\n\n    def test_permitted_excluded_with_ips(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_permitted_excluded.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=[\n                x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.0/24\")),\n                x509.IPAddress(ipaddress.IPv6Network(\"FF:0:0:0:0:0:0:0/96\")),\n            ],\n            excluded_subtrees=[\n                x509.DNSName(\".domain.com\"),\n                x509.UniformResourceIdentifier(\"http://test.local\"),\n            ],\n        )\n\n    def test_single_ip_netmask(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_single_ip_netmask.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        nc = cert.extensions.get_extension_for_oid(\n            ExtensionOID.NAME_CONSTRAINTS\n        ).value\n        assert nc == x509.NameConstraints(\n            permitted_subtrees=[\n                x509.IPAddress(ipaddress.IPv6Network(\"FF:0:0:0:0:0:0:0/128\")),\n                x509.IPAddress(ipaddress.IPv4Network(\"192.168.0.1/32\")),\n            ],\n            excluded_subtrees=None,\n        )\n\n    def test_ip_invalid_length(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_ip_invalid_length.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions.get_extension_for_oid(\n                ExtensionOID.NAME_CONSTRAINTS\n            )\n\n    def test_invalid_ipv6_netmask(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_invalid_ip_netmask.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions.get_extension_for_oid(\n                ExtensionOID.NAME_CONSTRAINTS\n            )\n\n    def test_invalid_ipv4_netmask(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"nc_invalid_ip4_netmask.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions.get_extension_for_oid(\n                ExtensionOID.NAME_CONSTRAINTS\n            )\n\n    def test_certbuilder(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        permitted = [\n            \".example.org\",\n            \".xn--4ca7aey.example.com\",\n            \"foobar.example.net\",\n        ]\n        private_key = rsa_key_2048\n        builder = _make_certbuilder(private_key)\n        builder = builder.add_extension(\n            NameConstraints(\n                permitted_subtrees=list(map(DNSName, permitted)),\n                excluded_subtrees=None,\n            ),\n            True,\n        )\n\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        result = [\n            x.value\n            for x in cert.extensions.get_extension_for_class(\n                NameConstraints\n            ).value.permitted_subtrees\n        ]\n        assert result == permitted\n\n    def test_public_bytes(self):\n        ext = x509.NameConstraints(\n            permitted_subtrees=[x509.DNSName(\"zombo.local\")],\n            excluded_subtrees=[\n                x509.DirectoryName(\n                    x509.Name(\n                        [x509.NameAttribute(NameOID.COMMON_NAME, \"zombo\")]\n                    )\n                )\n            ],\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0)\\xa0\\x0f0\\r\\x82\\x0bzombo.local\\xa1\\x160\\x14\\xa4\\x120\\x101\"\n            b\"\\x0e0\\x0c\\x06\\x03U\\x04\\x03\\x0c\\x05zombo\"\n        )\n\n\nclass TestDistributionPoint:\n    def test_distribution_point_full_name_not_general_names(self):\n        with pytest.raises(TypeError):\n            x509.DistributionPoint(\n                [\"notgn\"],  # type:ignore[list-item]\n                None,\n                None,\n                None,\n            )\n\n    def test_distribution_point_relative_name_not_name(self):\n        with pytest.raises(TypeError):\n            x509.DistributionPoint(\n                None,\n                \"notname\",  # type:ignore[arg-type]\n                None,\n                None,\n            )\n\n    def test_distribution_point_full_and_relative_not_none(self):\n        with pytest.raises(ValueError):\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n                x509.RelativeDistinguishedName(\n                    [x509.NameAttribute(NameOID.TITLE, \"Test\")]\n                ),\n                None,\n                None,\n            )\n\n    def test_no_full_name_relative_name_or_crl_issuer(self):\n        with pytest.raises(ValueError):\n            x509.DistributionPoint(None, None, None, None)\n\n    def test_crl_issuer_not_general_names(self):\n        with pytest.raises(TypeError):\n            x509.DistributionPoint(\n                None,\n                None,\n                None,\n                [\"notgn\"],  # type:ignore[list-item]\n            )\n\n    def test_reason_not_reasonflags(self):\n        with pytest.raises(TypeError):\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n                None,\n                frozenset([\"notreasonflags\"]),  # type:ignore[list-item]\n                None,\n            )\n\n    def test_reason_not_frozenset(self):\n        with pytest.raises(TypeError):\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n                None,\n                [x509.ReasonFlags.ca_compromise],  # type:ignore[arg-type]\n                None,\n            )\n\n    def test_disallowed_reasons(self):\n        with pytest.raises(ValueError):\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n                None,\n                frozenset([x509.ReasonFlags.unspecified]),\n                None,\n            )\n\n        with pytest.raises(ValueError):\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n                None,\n                frozenset([x509.ReasonFlags.remove_from_crl]),\n                None,\n            )\n\n    def test_reason_only(self):\n        with pytest.raises(ValueError):\n            x509.DistributionPoint(\n                None, None, frozenset([x509.ReasonFlags.aa_compromise]), None\n            )\n\n    def test_eq(self):\n        dp = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            frozenset([x509.ReasonFlags.superseded]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        dp2 = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            frozenset([x509.ReasonFlags.superseded]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        assert dp == dp2\n\n    def test_ne(self):\n        dp = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            frozenset([x509.ReasonFlags.superseded]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        dp2 = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            None,\n            None,\n        )\n        assert dp != dp2\n        assert dp != object()\n\n    def test_iter_input(self):\n        name = [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")]\n        issuer = [\n            x509.DirectoryName(\n                x509.Name(\n                    [x509.NameAttribute(NameOID.COMMON_NAME, \"Important CA\")]\n                )\n            )\n        ]\n        dp = x509.DistributionPoint(\n            iter(name),\n            None,\n            frozenset([x509.ReasonFlags.ca_compromise]),\n            iter(issuer),\n        )\n        assert dp.full_name is not None\n        assert list(dp.full_name) == name\n        assert dp.crl_issuer is not None\n        assert list(dp.crl_issuer) == issuer\n\n    def test_repr(self):\n        dp = x509.DistributionPoint(\n            None,\n            x509.RelativeDistinguishedName(\n                [x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")]\n            ),\n            frozenset([x509.ReasonFlags.ca_compromise]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        assert repr(dp) == (\n            \"<DistributionPoint(full_name=None, relative_name=<RelativeDis\"\n            \"tinguishedName(CN=myCN)>, reasons=frozenset({<ReasonFlags.ca_\"\n            \"compromise: 'cACompromise'>}), crl_issuer=[<DirectoryName(val\"\n            \"ue=<Name(CN=Important CA)>)>])>\"\n        )\n\n    def test_hash(self):\n        dp = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            frozenset([x509.ReasonFlags.superseded]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        dp2 = x509.DistributionPoint(\n            [x509.UniformResourceIdentifier(\"http://crypt.og/crl\")],\n            None,\n            frozenset([x509.ReasonFlags.superseded]),\n            [\n                x509.DirectoryName(\n                    x509.Name(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME, \"Important CA\"\n                            )\n                        ]\n                    )\n                )\n            ],\n        )\n        dp3 = x509.DistributionPoint(\n            None,\n            x509.RelativeDistinguishedName(\n                [x509.NameAttribute(NameOID.COMMON_NAME, \"myCN\")]\n            ),\n            None,\n            None,\n        )\n        assert hash(dp) == hash(dp2)\n        assert hash(dp) != hash(dp3)\n\n\nclass TestFreshestCRL:\n    def test_invalid_distribution_points(self):\n        with pytest.raises(TypeError):\n            x509.FreshestCRL(\n                [\"notadistributionpoint\"]  # type:ignore[list-item]\n            )\n\n    def test_iter_len(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"http://domain\")],\n                    None,\n                    None,\n                    None,\n                ),\n            ]\n        )\n        assert len(fcrl) == 1\n        assert list(fcrl) == [\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://domain\")],\n                None,\n                None,\n                None,\n            ),\n        ]\n\n    def test_iter_input(self):\n        points = [\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://domain\")],\n                None,\n                None,\n                None,\n            ),\n        ]\n        fcrl = x509.FreshestCRL(iter(points))\n        assert list(fcrl) == points\n\n    def test_repr(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    None,\n                ),\n            ]\n        )\n        assert repr(fcrl) == (\n            \"<FreshestCRL([<DistributionPoint(full_name=[<Unifo\"\n            \"rmResourceIdentifier(value='ftp://domain')>], relative\"\n            \"_name=None, reasons=frozenset({<ReasonFlags.key_compromise: \"\n            \"'keyCompromise'>}), crl_issuer=None)>])>\"\n        )\n\n    def test_eq(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl2 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        assert fcrl == fcrl2\n\n    def test_ne(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl2 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain2\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl3 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl4 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing2\")],\n                ),\n            ]\n        )\n        assert fcrl != fcrl2\n        assert fcrl != fcrl3\n        assert fcrl != fcrl4\n        assert fcrl != object()\n\n    def test_hash(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl2 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        fcrl3 = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        assert hash(fcrl) == hash(fcrl2)\n        assert hash(fcrl) != hash(fcrl3)\n\n    def test_indexing(self):\n        fcrl = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing2\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing3\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing4\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing5\")],\n                ),\n            ]\n        )\n        assert fcrl[-1] == fcrl[4]\n        assert fcrl[2:6:2] == [fcrl[2], fcrl[4]]\n\n    def test_public_bytes(self):\n        ext = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    None,\n                ),\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0\\x180\\x16\\xa0\\x10\\xa0\\x0e\\x86\\x0cftp://domain\\x81\\x02\\x06@\"\n        )\n\n\nclass TestCRLDistributionPoints:\n    def test_invalid_distribution_points(self):\n        with pytest.raises(TypeError):\n            x509.CRLDistributionPoints(\n                [\"notadistributionpoint\"],  # type:ignore[list-item]\n            )\n\n    def test_iter_len(self):\n        cdp = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"http://domain\")],\n                    None,\n                    None,\n                    None,\n                ),\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    None,\n                ),\n            ]\n        )\n        assert len(cdp) == 2\n        assert list(cdp) == [\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://domain\")],\n                None,\n                None,\n                None,\n            ),\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                None,\n                frozenset(\n                    [\n                        x509.ReasonFlags.key_compromise,\n                        x509.ReasonFlags.ca_compromise,\n                    ]\n                ),\n                None,\n            ),\n        ]\n\n    def test_iter_input(self):\n        points = [\n            x509.DistributionPoint(\n                [x509.UniformResourceIdentifier(\"http://domain\")],\n                None,\n                None,\n                None,\n            ),\n        ]\n        cdp = x509.CRLDistributionPoints(iter(points))\n        assert list(cdp) == points\n\n    def test_repr(self):\n        cdp = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    None,\n                ),\n            ]\n        )\n        assert repr(cdp) == (\n            \"<CRLDistributionPoints([<DistributionPoint(full_name=[<Unifo\"\n            \"rmResourceIdentifier(value='ftp://domain')>], relative\"\n            \"_name=None, reasons=frozenset({<ReasonFlags.key_compromise: \"\n            \"'keyCompromise'>}), crl_issuer=None)>])>\"\n        )\n\n    def test_eq(self):\n        cdp = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp2 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        assert cdp == cdp2\n\n    def test_ne(self):\n        cdp = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp2 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain2\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp3 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp4 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing2\")],\n                ),\n            ]\n        )\n        assert cdp != cdp2\n        assert cdp != cdp3\n        assert cdp != cdp4\n        assert cdp != object()\n\n    def test_hash(self):\n        cdp = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp2 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        cdp3 = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset([x509.ReasonFlags.key_compromise]),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        assert hash(cdp) == hash(cdp2)\n        assert hash(cdp) != hash(cdp3)\n\n    def test_indexing(self):\n        ci = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing2\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing3\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing4\")],\n                ),\n                x509.DistributionPoint(\n                    None,\n                    None,\n                    None,\n                    [x509.UniformResourceIdentifier(\"uri://thing5\")],\n                ),\n            ]\n        )\n        assert ci[-1] == ci[4]\n        assert ci[2:6:2] == [ci[2], ci[4]]\n\n    def test_public_bytes(self):\n        ext = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    [x509.UniformResourceIdentifier(\"ftp://domain\")],\n                    None,\n                    frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    [x509.UniformResourceIdentifier(\"uri://thing\")],\n                ),\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0'0%\\xa0\\x10\\xa0\\x0e\\x86\\x0cftp://domain\\x81\\x02\\x05`\\xa2\\r\"\n            b\"\\x86\\x0buri://thing\"\n        )\n\n\nclass TestCRLDistributionPointsExtension:\n    def test_fullname_and_crl_issuer(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"PKITS_data\", \"certs\", \"ValidcRLIssuerTest28EE.crt\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATION_NAME,\n                                        \"Test Certificates 2011\",\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATIONAL_UNIT_NAME,\n                                        \"indirectCRL CA3 cRLIssuer\",\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.COMMON_NAME,\n                                        \"indirect CRL for indirectCRL CA3\",\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=None,\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATION_NAME,\n                                        \"Test Certificates 2011\",\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATIONAL_UNIT_NAME,\n                                        \"indirectCRL CA3 cRLIssuer\",\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_relativename_and_crl_issuer(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"PKITS_data\", \"certs\", \"ValidcRLIssuerTest29EE.crt\"\n            ),\n            x509.load_der_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=None,\n                    relative_name=x509.RelativeDistinguishedName(\n                        [\n                            x509.NameAttribute(\n                                NameOID.COMMON_NAME,\n                                \"indirect CRL for indirectCRL CA3\",\n                            ),\n                        ]\n                    ),\n                    reasons=None,\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATION_NAME,\n                                        \"Test Certificates 2011\",\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATIONAL_UNIT_NAME,\n                                        \"indirectCRL CA3 cRLIssuer\",\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_fullname_crl_issuer_reasons(self, backend):\n        cert = _load_cert(\n            os.path.join(\n                \"x509\", \"custom\", \"cdp_fullname_reasons_crl_issuer.pem\"\n            ),\n            x509.load_pem_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                        ]\n                    ),\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.ORGANIZATION_NAME, \"PyCA\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.COMMON_NAME, \"cryptography CA\"\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_all_reasons(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cdp_all_reasons.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://domain.com/some.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                            x509.ReasonFlags.affiliation_changed,\n                            x509.ReasonFlags.superseded,\n                            x509.ReasonFlags.privilege_withdrawn,\n                            x509.ReasonFlags.cessation_of_operation,\n                            x509.ReasonFlags.aa_compromise,\n                            x509.ReasonFlags.certificate_hold,\n                        ]\n                    ),\n                    crl_issuer=None,\n                )\n            ]\n        )\n\n    def test_single_reason(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cdp_reason_aa_compromise.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://domain.com/some.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=frozenset([x509.ReasonFlags.aa_compromise]),\n                    crl_issuer=None,\n                )\n            ]\n        )\n\n    def test_crl_issuer_only(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cdp_crl_issuer.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=None,\n                    relative_name=None,\n                    reasons=None,\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COMMON_NAME, \"cryptography CA\"\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_crl_empty_hostname(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cdp_empty_hostname.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        cdps = cert.extensions.get_extension_for_oid(\n            ExtensionOID.CRL_DISTRIBUTION_POINTS\n        ).value\n\n        assert cdps == x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"ldap:///CN=A,OU=B,dc=C,DC=D?E?F?G?H=I\"\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=None,\n                    crl_issuer=None,\n                )\n            ]\n        )\n\n    def test_public_bytes(self):\n        ext = x509.CRLDistributionPoints(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"ldap:///CN=A,OU=B,dc=C,DC=D?E?F?G?H=I\"\n                        )\n                    ],\n                    relative_name=None,\n                    reasons=None,\n                    crl_issuer=None,\n                )\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0-0+\\xa0)\\xa0'\\x86%ldap:///CN=A,OU=B,dc=C,DC=D?E?F?G?H=I\"\n        )\n\n\nclass TestFreshestCRLExtension:\n    def test_vector(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"freshestcrl.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        fcrl = cert.extensions.get_extension_for_class(x509.FreshestCRL).value\n        assert fcrl == x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        ),\n                        x509.UniformResourceIdentifier(\n                            \"http://backup.myhost.com/myca.crl\"\n                        ),\n                    ],\n                    relative_name=None,\n                    reasons=frozenset(\n                        [\n                            x509.ReasonFlags.ca_compromise,\n                            x509.ReasonFlags.key_compromise,\n                        ]\n                    ),\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.COMMON_NAME, \"cryptography CA\"\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n\n    def test_public_bytes(self):\n        ext = x509.FreshestCRL(\n            [\n                x509.DistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        ),\n                        x509.UniformResourceIdentifier(\n                            \"http://backup.myhost.com/myca.crl\"\n                        ),\n                    ],\n                    relative_name=None,\n                    reasons=frozenset(\n                        [\n                            x509.ReasonFlags.ca_compromise,\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.aa_compromise,\n                        ]\n                    ),\n                    crl_issuer=[\n                        x509.DirectoryName(\n                            x509.Name(\n                                [\n                                    x509.NameAttribute(\n                                        NameOID.COUNTRY_NAME, \"US\"\n                                    ),\n                                    x509.NameAttribute(\n                                        NameOID.COMMON_NAME, \"cryptography CA\"\n                                    ),\n                                ]\n                            )\n                        )\n                    ],\n                )\n            ]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0w0u\\xa0A\\xa0?\\x86\\x1ahttp://myhost.com/myca.crl\\x86!http://\"\n            b\"backup.myhost.com/myca.crl\\x81\\x03\\x07`\\x80\\xa2+\\xa4)0'1\\x0b0\\t\"\n            b\"\\x06\\x03U\\x04\\x06\\x13\\x02US1\\x180\\x16\\x06\\x03U\\x04\\x03\\x0c\\x0fc\"\n            b\"ryptography CA\"\n        )\n\n\nclass TestOCSPNoCheckExtension:\n    def test_nocheck(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"ocsp_nocheck.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        ext = cert.extensions.get_extension_for_oid(ExtensionOID.OCSP_NO_CHECK)\n        assert isinstance(ext.value, x509.OCSPNoCheck)\n\n    def test_eq(self):\n        onc1 = x509.OCSPNoCheck()\n        onc2 = x509.OCSPNoCheck()\n\n        assert onc1 == onc2\n\n    def test_hash(self):\n        onc1 = x509.OCSPNoCheck()\n        onc2 = x509.OCSPNoCheck()\n\n        assert hash(onc1) == hash(onc2)\n\n    def test_ne(self):\n        onc1 = x509.OCSPNoCheck()\n        onc2 = x509.OCSPNoCheck()\n\n        assert onc1 == onc2\n        assert (onc1 != onc2) is False\n        assert onc1 != object()\n\n    def test_repr(self):\n        onc = x509.OCSPNoCheck()\n\n        assert repr(onc) == \"<OCSPNoCheck()>\"\n\n    def test_public_bytes(self):\n        ext = x509.OCSPNoCheck()\n        assert ext.public_bytes() == b\"\\x05\\x00\"\n\n\nclass TestInhibitAnyPolicy:\n    def test_not_int(self):\n        with pytest.raises(TypeError):\n            x509.InhibitAnyPolicy(\"notint\")  # type:ignore[arg-type]\n\n    def test_negative_int(self):\n        with pytest.raises(ValueError):\n            x509.InhibitAnyPolicy(-1)\n\n    def test_repr(self):\n        iap = x509.InhibitAnyPolicy(0)\n        assert repr(iap) == \"<InhibitAnyPolicy(skip_certs=0)>\"\n\n    def test_eq(self):\n        iap = x509.InhibitAnyPolicy(1)\n        iap2 = x509.InhibitAnyPolicy(1)\n        assert iap == iap2\n\n    def test_ne(self):\n        iap = x509.InhibitAnyPolicy(1)\n        iap2 = x509.InhibitAnyPolicy(4)\n        assert iap != iap2\n        assert iap != object()\n\n    def test_hash(self):\n        iap = x509.InhibitAnyPolicy(1)\n        iap2 = x509.InhibitAnyPolicy(1)\n        iap3 = x509.InhibitAnyPolicy(4)\n        assert hash(iap) == hash(iap2)\n        assert hash(iap) != hash(iap3)\n\n    def test_public_bytes(self):\n        ext = x509.InhibitAnyPolicy(1)\n        assert ext.public_bytes() == b\"\\x02\\x01\\x01\"\n\n\nclass TestInhibitAnyPolicyExtension:\n    def test_inhibit_any_policy(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"inhibit_any_policy_5.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        iap = cert.extensions.get_extension_for_class(\n            x509.InhibitAnyPolicy\n        ).value\n        assert iap.skip_certs == 5\n\n\nclass TestIssuingDistributionPointExtension:\n    @pytest.mark.parametrize(\n        (\"filename\", \"expected\"),\n        [\n            (\n                \"crl_idp_fullname_indirect_crl.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=None,\n                    indirect_crl=True,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_fullname_only.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=None,\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_fullname_only_aa.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=None,\n                    indirect_crl=False,\n                    only_contains_attribute_certs=True,\n                ),\n            ),\n            (\n                \"crl_idp_fullname_only_user.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=[\n                        x509.UniformResourceIdentifier(\n                            \"http://myhost.com/myca.crl\"\n                        )\n                    ],\n                    relative_name=None,\n                    only_contains_user_certs=True,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=None,\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_only_ca.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=None,\n                    relative_name=x509.RelativeDistinguishedName(\n                        [\n                            x509.NameAttribute(\n                                oid=x509.NameOID.ORGANIZATION_NAME,\n                                value=\"PyCA\",\n                            )\n                        ]\n                    ),\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=True,\n                    only_some_reasons=None,\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_reasons_only.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=None,\n                    relative_name=None,\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=frozenset(\n                        [x509.ReasonFlags.key_compromise]\n                    ),\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_relative_user_all_reasons.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=None,\n                    relative_name=x509.RelativeDistinguishedName(\n                        [\n                            x509.NameAttribute(\n                                oid=x509.NameOID.ORGANIZATION_NAME,\n                                value=\"PyCA\",\n                            )\n                        ]\n                    ),\n                    only_contains_user_certs=True,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=frozenset(\n                        [\n                            x509.ReasonFlags.key_compromise,\n                            x509.ReasonFlags.ca_compromise,\n                            x509.ReasonFlags.affiliation_changed,\n                            x509.ReasonFlags.superseded,\n                            x509.ReasonFlags.cessation_of_operation,\n                            x509.ReasonFlags.certificate_hold,\n                            x509.ReasonFlags.privilege_withdrawn,\n                            x509.ReasonFlags.aa_compromise,\n                        ]\n                    ),\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n            (\n                \"crl_idp_relativename_only.pem\",\n                x509.IssuingDistributionPoint(\n                    full_name=None,\n                    relative_name=x509.RelativeDistinguishedName(\n                        [\n                            x509.NameAttribute(\n                                oid=x509.NameOID.ORGANIZATION_NAME,\n                                value=\"PyCA\",\n                            )\n                        ]\n                    ),\n                    only_contains_user_certs=False,\n                    only_contains_ca_certs=False,\n                    only_some_reasons=None,\n                    indirect_crl=False,\n                    only_contains_attribute_certs=False,\n                ),\n            ),\n        ],\n    )\n    def test_vectors(self, filename, expected, backend):\n        crl = _load_cert(\n            os.path.join(\"x509\", \"custom\", filename),\n            x509.load_pem_x509_crl,\n        )\n        idp = crl.extensions.get_extension_for_class(\n            x509.IssuingDistributionPoint\n        ).value\n        assert idp == expected\n\n    @pytest.mark.parametrize(\n        (\n            \"error\",\n            \"only_contains_user_certs\",\n            \"only_contains_ca_certs\",\n            \"indirect_crl\",\n            \"only_contains_attribute_certs\",\n            \"only_some_reasons\",\n            \"full_name\",\n            \"relative_name\",\n        ),\n        [\n            (\n                TypeError,\n                False,\n                False,\n                False,\n                False,\n                \"notafrozenset\",\n                None,\n                None,\n            ),\n            (\n                TypeError,\n                False,\n                False,\n                False,\n                False,\n                frozenset([\"bad\"]),\n                None,\n                None,\n            ),\n            (\n                ValueError,\n                False,\n                False,\n                False,\n                False,\n                frozenset([x509.ReasonFlags.unspecified]),\n                None,\n                None,\n            ),\n            (\n                ValueError,\n                False,\n                False,\n                False,\n                False,\n                frozenset([x509.ReasonFlags.remove_from_crl]),\n                None,\n                None,\n            ),\n            (TypeError, \"notabool\", False, False, False, None, None, None),\n            (TypeError, False, \"notabool\", False, False, None, None, None),\n            (TypeError, False, False, \"notabool\", False, None, None, None),\n            (TypeError, False, False, False, \"notabool\", None, None, None),\n            (ValueError, True, True, False, False, None, None, None),\n            (ValueError, False, False, True, True, None, None, None),\n            (ValueError, False, False, False, False, None, None, None),\n        ],\n    )\n    def test_invalid_init(\n        self,\n        error,\n        only_contains_user_certs,\n        only_contains_ca_certs,\n        indirect_crl,\n        only_contains_attribute_certs,\n        only_some_reasons,\n        full_name,\n        relative_name,\n    ):\n        with pytest.raises(error):\n            x509.IssuingDistributionPoint(\n                full_name,\n                relative_name,\n                only_contains_user_certs,\n                only_contains_ca_certs,\n                only_some_reasons,\n                indirect_crl,\n                only_contains_attribute_certs,\n            )\n\n    def test_repr(self):\n        idp = x509.IssuingDistributionPoint(\n            None,\n            None,\n            False,\n            False,\n            frozenset([x509.ReasonFlags.key_compromise]),\n            False,\n            False,\n        )\n        assert repr(idp) == (\n            \"<IssuingDistributionPoint(full_name=None, relative_name=None,\"\n            \" only_contains_user_certs=False, only_contains_ca_certs=False\"\n            \", only_some_reasons=frozenset({<ReasonFlags.key_compromise: '\"\n            \"keyCompromise'>}), indirect_crl=False, only_contains_attribut\"\n            \"e_certs=False)>\"\n        )\n\n    def test_eq(self):\n        idp1 = x509.IssuingDistributionPoint(\n            only_contains_user_certs=False,\n            only_contains_ca_certs=False,\n            indirect_crl=False,\n            only_contains_attribute_certs=False,\n            only_some_reasons=None,\n            full_name=None,\n            relative_name=x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                    )\n                ]\n            ),\n        )\n        idp2 = x509.IssuingDistributionPoint(\n            only_contains_user_certs=False,\n            only_contains_ca_certs=False,\n            indirect_crl=False,\n            only_contains_attribute_certs=False,\n            only_some_reasons=None,\n            full_name=None,\n            relative_name=x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                    )\n                ]\n            ),\n        )\n        assert idp1 == idp2\n\n    def test_ne(self):\n        idp1 = x509.IssuingDistributionPoint(\n            only_contains_user_certs=False,\n            only_contains_ca_certs=False,\n            indirect_crl=False,\n            only_contains_attribute_certs=False,\n            only_some_reasons=None,\n            full_name=None,\n            relative_name=x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                    )\n                ]\n            ),\n        )\n        idp2 = x509.IssuingDistributionPoint(\n            only_contains_user_certs=True,\n            only_contains_ca_certs=False,\n            indirect_crl=False,\n            only_contains_attribute_certs=False,\n            only_some_reasons=None,\n            full_name=None,\n            relative_name=x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                    )\n                ]\n            ),\n        )\n        assert idp1 != idp2\n        assert idp1 != object()\n\n    def test_hash(self):\n        idp1 = x509.IssuingDistributionPoint(\n            None, None, True, False, None, False, False\n        )\n        idp2 = x509.IssuingDistributionPoint(\n            None, None, True, False, None, False, False\n        )\n        idp3 = x509.IssuingDistributionPoint(\n            None,\n            x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                    )\n                ]\n            ),\n            True,\n            False,\n            None,\n            False,\n            False,\n        )\n        assert hash(idp1) == hash(idp2)\n        assert hash(idp1) != hash(idp3)\n\n    @pytest.mark.parametrize(\n        \"idp\",\n        [\n            x509.IssuingDistributionPoint(\n                full_name=[\n                    x509.UniformResourceIdentifier(\n                        \"http://myhost.com/myca.crl\"\n                    )\n                ],\n                relative_name=None,\n                only_contains_user_certs=False,\n                only_contains_ca_certs=False,\n                only_some_reasons=None,\n                indirect_crl=True,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=[\n                    x509.UniformResourceIdentifier(\n                        \"http://myhost.com/myca.crl\"\n                    )\n                ],\n                relative_name=None,\n                only_contains_user_certs=False,\n                only_contains_ca_certs=False,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=[\n                    x509.UniformResourceIdentifier(\n                        \"http://myhost.com/myca.crl\"\n                    )\n                ],\n                relative_name=None,\n                only_contains_user_certs=False,\n                only_contains_ca_certs=False,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=True,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=[\n                    x509.UniformResourceIdentifier(\n                        \"http://myhost.com/myca.crl\"\n                    )\n                ],\n                relative_name=None,\n                only_contains_user_certs=True,\n                only_contains_ca_certs=False,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=None,\n                relative_name=x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(\n                            oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                        )\n                    ]\n                ),\n                only_contains_user_certs=False,\n                only_contains_ca_certs=True,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=None,\n                relative_name=None,\n                only_contains_user_certs=False,\n                only_contains_ca_certs=True,\n                only_some_reasons=frozenset([x509.ReasonFlags.key_compromise]),\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=None,\n                relative_name=x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(\n                            oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                        ),\n                        x509.NameAttribute(\n                            oid=x509.NameOID.COMMON_NAME, value=\"cryptography\"\n                        ),\n                    ]\n                ),\n                only_contains_user_certs=True,\n                only_contains_ca_certs=False,\n                only_some_reasons=frozenset(\n                    [\n                        x509.ReasonFlags.key_compromise,\n                        x509.ReasonFlags.ca_compromise,\n                        x509.ReasonFlags.affiliation_changed,\n                        x509.ReasonFlags.privilege_withdrawn,\n                        x509.ReasonFlags.aa_compromise,\n                    ]\n                ),\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n            x509.IssuingDistributionPoint(\n                full_name=None,\n                relative_name=x509.RelativeDistinguishedName(\n                    [\n                        x509.NameAttribute(\n                            oid=x509.NameOID.ORGANIZATION_NAME, value=\"PyCA\"\n                        )\n                    ]\n                ),\n                only_contains_user_certs=False,\n                only_contains_ca_certs=False,\n                only_some_reasons=None,\n                indirect_crl=False,\n                only_contains_attribute_certs=False,\n            ),\n        ],\n    )\n    def test_generate(self, rsa_key_2048: rsa.RSAPrivateKey, idp, backend):\n        key = rsa_key_2048\n        last_update = datetime.datetime(2002, 1, 1, 12, 1)\n        next_update = datetime.datetime(2030, 1, 1, 12, 1)\n        builder = (\n            x509.CertificateRevocationListBuilder()\n            .issuer_name(\n                x509.Name(\n                    [\n                        x509.NameAttribute(\n                            NameOID.COMMON_NAME, \"cryptography.io CA\"\n                        )\n                    ]\n                )\n            )\n            .last_update(last_update)\n            .next_update(next_update)\n            .add_extension(idp, True)\n        )\n\n        crl = builder.sign(key, hashes.SHA256(), backend)\n        ext = crl.extensions.get_extension_for_class(\n            x509.IssuingDistributionPoint\n        )\n        assert ext.critical is True\n        assert ext.value == idp\n\n    def test_public_bytes(self):\n        ext = x509.IssuingDistributionPoint(\n            full_name=None,\n            relative_name=x509.RelativeDistinguishedName(\n                [\n                    x509.NameAttribute(\n                        oid=x509.NameOID.ORGANIZATION_NAME,\n                        value=\"PyCA\",\n                    )\n                ]\n            ),\n            only_contains_user_certs=False,\n            only_contains_ca_certs=False,\n            only_some_reasons=None,\n            indirect_crl=False,\n            only_contains_attribute_certs=False,\n        )\n        assert (\n            ext.public_bytes()\n            == b\"0\\x11\\xa0\\x0f\\xa1\\r0\\x0b\\x06\\x03U\\x04\\n\\x0c\\x04PyCA\"\n        )\n\n\nclass TestPrecertPoisonExtension:\n    def test_load(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.precert.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        poison = cert.extensions.get_extension_for_oid(\n            ExtensionOID.PRECERT_POISON\n        ).value\n        assert isinstance(poison, x509.PrecertPoison)\n        poison = cert.extensions.get_extension_for_class(\n            x509.PrecertPoison\n        ).value\n        assert isinstance(poison, x509.PrecertPoison)\n\n    def test_generate(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        cert = (\n            _make_certbuilder(private_key)\n            .add_extension(x509.PrecertPoison(), critical=True)\n            .sign(private_key, hashes.SHA256(), backend)\n        )\n        poison = cert.extensions.get_extension_for_oid(\n            ExtensionOID.PRECERT_POISON\n        ).value\n        assert isinstance(poison, x509.PrecertPoison)\n\n    def test_eq(self):\n        pcp1 = x509.PrecertPoison()\n        pcp2 = x509.PrecertPoison()\n\n        assert pcp1 == pcp2\n\n    def test_hash(self):\n        pcp1 = x509.PrecertPoison()\n        pcp2 = x509.PrecertPoison()\n\n        assert hash(pcp1) == hash(pcp2)\n\n    def test_ne(self):\n        pcp1 = x509.PrecertPoison()\n        pcp2 = x509.PrecertPoison()\n\n        assert pcp1 == pcp2\n        assert (pcp1 != pcp2) is False\n        assert pcp1 != object()\n\n    def test_repr(self):\n        pcp = x509.PrecertPoison()\n\n        assert repr(pcp) == \"<PrecertPoison()>\"\n\n    def test_public_bytes(self):\n        ext = x509.PrecertPoison()\n        assert ext.public_bytes() == b\"\\x05\\x00\"\n\n\nclass TestSignedCertificateTimestamps:\n    def test_eq(self, backend):\n        sct = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        sct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        assert sct == sct2\n\n    def test_ne(self, backend):\n        sct = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        sct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        assert sct != sct2\n        assert sct != object()\n\n    def test_hash(self, backend):\n        sct = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        sct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        sct3 = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value[0]\n        )\n        assert hash(sct) == hash(sct2)\n        assert hash(sct) != hash(sct3)\n\n    def test_public_bytes(self, backend):\n        ext = (\n            load_vectors_from_file(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                lambda data: ocsp.load_der_ocsp_response(data.read()),\n                mode=\"rb\",\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n\n        assert ext.public_bytes() == (\n            b\"\\x04\\x82\\x01\\xe6\\x01\\xe4\\x00w\\x00D\\x94e.\\xb0\\xee\\xce\\xaf\\xc4\"\n            b\"@\\x07\\xd8\\xa8\\xfe(\\xc0\\xda\\xe6\\x82\\xbe\\xd8\\xcb1\\xb5?\\xd33\"\n            b\"\\x96\\xb5\\xb6\\x81\\xa8\\x00\\x00\\x01no\\xc33h\\x00\\x00\\x04\\x03\\x00\"\n            b\"H0F\\x02!\\x00\\xa0}J\\xa7\\xb1Y\\xb4\\x15P\\xd7\\x95Y\\x12\\xfb\\xa1\"\n            b\"\\xdfh\\x96u\\xa3\\x0f_\\x01\\xf2\\xfd\\xcbMI\\x9bt\\xe2\\xfe\\x02!\\x00\"\n            b\"\\x89E\\xd7\\x86N<>\\xe8\\x07\\xc4\\xca\\xdbO:\\xb7\\x9f]E\\xbc\\x1az\"\n            b\"\\xe5h\\xab%\\xdaukT\\x8a\\xf7\\xc1\\x00w\\x00oSv\\xac1\\xf01\\x19\\xd8\"\n            b\"\\x99\\x00\\xa4Q\\x15\\xffw\\x15\\x1c\\x11\\xd9\\x02\\xc1\\x00)\\x06\\x8d\"\n            b\"\\xb2\\x08\\x9a7\\xd9\\x13\\x00\\x00\\x01no\\xc33m\\x00\\x00\\x04\\x03\"\n            b\"\\x00H0F\\x02!\\x00\\xd4\\xe06\\xd2\\xed~{\\x9fs-E2\\xd8\\xd2\\xb41\\xc6\"\n            b\"v\\x8b3\\xf2\\tS\\x1d\\xd8SUe\\xe1\\xcf\\xfc;\\x02!\\x00\\xd9cF[\\x8e\\xac\"\n            b'4\\x02@\\xd6\\x8a\\x10y\\x98\\x92\\xbee\\xf4\\n\\x11L\\xbfpI(Y\"O\\x1al'\n            b\"\\xe9g\\x00w\\x00\\xbb\\xd9\\xdf\\xbc\\x1f\\x8aq\\xb5\\x93\\x94#\\x97\\xaa\"\n            b\"\\x92{G8W\\x95\\n\\xabR\\xe8\\x1a\\x90\\x96d6\\x8e\\x1e\\xd1\\x85\\x00\"\n            b\"\\x00\\x01no\\xc34g\\x00\\x00\\x04\\x03\\x00H0F\\x02!\\x00\\xf4:\\xec\"\n            b\"\\x1b\\xdeQ\\r\\xf8S\\x9c\\xf2\\xeee<\\xcf\\xc5:\\x0f\\x0f\\xeb\\x8bv\\x9f\"\n            b'8d.z\\x9c\"K\\x9b\\x11\\x02!\\x00\\xe7`\\xe9Ex\\xf7)B<\\xf7\\xd62b\\xfa'\n            b\"\\xa2\\xc7!\\xc4\\xbau\\xcb\\xad\\x0ezEZ\\x11\\x13\\xa1+\\x89J\\x00w\\x00\"\n            b\"\\xeeK\\xbd\\xb7u\\xce`\\xba\\xe1Bi\\x1f\\xab\\xe1\\x9ef\\xa3\\x0f~_\\xb0\"\n            b\"r\\xd8\\x83\\x00\\xc4{\\x89z\\xa8\\xfd\\xcb\\x00\\x00\\x01no\\xc32\\xdd\"\n            b\"\\x00\\x00\\x04\\x03\\x00H0F\\x02!\\x00\\x95Y\\x81\\x7f\\xa4\\xe5\\x17o\"\n            b\"\\x06}\\xac\\xcdt-\\xb0\\xb8L\\x18H\\xecB\\xcc-\\xe5\\x13>\\x07\\xba\\xc0\"\n            b\"}\\xa3\\xe6\\x02!\\x00\\xbf\\xc8\\x88\\x93m\\x8d\\xc3(GS\\xaf=4}\\x97\"\n            b\"\\xe6\\xc2\\x1djQ\\x0e0\\x8c\\xcc\\x9d\\xc2\\xc7\\xc3\\xb1\\x0f\\xec\\x98\"\n        )\n\n\nclass TestPrecertificateSignedCertificateTimestampsExtension:\n    def test_init(self):\n        with pytest.raises(TypeError):\n            x509.PrecertificateSignedCertificateTimestamps(\n                [object()]  # type:ignore[list-item]\n            )\n\n    def test_repr(self):\n        assert repr(x509.PrecertificateSignedCertificateTimestamps([])) == (\n            \"<PrecertificateSignedCertificateTimestamps([])>\"\n        )\n\n    def test_eq(self, backend):\n        psct1 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        psct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        assert psct1 == psct2\n\n    def test_ne(self, backend):\n        psct1 = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        psct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        assert psct1 != psct2\n        assert psct1 != object()\n\n    def test_ordering(self, backend):\n        psct1 = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        psct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        with pytest.raises(TypeError):\n            psct1[0] < psct2[0]\n\n    def test_hash(self, backend):\n        psct1 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        psct2 = (\n            _load_cert(\n                os.path.join(\"x509\", \"badssl-sct.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        psct3 = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        assert hash(psct1) == hash(psct2)\n        assert hash(psct1) != hash(psct3)\n\n    def test_simple(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"badssl-sct.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        scts = cert.extensions.get_extension_for_class(\n            x509.PrecertificateSignedCertificateTimestamps\n        ).value\n        assert len(scts) == 1\n        [sct] = scts\n        assert scts[0] == sct\n        assert sct.version == x509.certificate_transparency.Version.v1\n        assert sct.log_id == (\n            b\"\\xa7\\xceJNb\\x07\\xe0\\xad\\xde\\xe5\\xfd\\xaaK\\x1f\\x86v\\x87g\\xb5\\xd0\"\n            b\"\\x02\\xa5]G1\\x0e~g\\n\\x95\\xea\\xb2\"\n        )\n        assert sct.timestamp == datetime.datetime(\n            2016, 11, 17, 1, 56, 25, 396000\n        )\n        assert (\n            sct.entry_type\n            == x509.certificate_transparency.LogEntryType.PRE_CERTIFICATE\n        )\n        assert isinstance(sct.signature_hash_algorithm, hashes.SHA256)\n        assert (\n            sct.signature_algorithm\n            == x509.certificate_transparency.SignatureAlgorithm.ECDSA\n        )\n        assert sct.signature == (\n            b\"\\x30\\x45\\x02\\x21\\x00\\xb8\\x03\\xad\\x34\\xf6\\xfc\\x0f\\x2c\\xff\\x84\\xa0\"\n            b\"\\x86\\xe5\\xd7\\xcf\\x5a\\xf0\\x0a\\x07\\x62\\x6a\\x7f\\xb3\\xa6\\x44\\x64\\xf1\"\n            b\"\\x95\\xa4\\x48\\x45\\x11\\x02\\x20\\x2f\\x61\\x8d\\x53\\x1b\\x6f\\x4a\\xb8\\x0a\"\n            b\"\\x67\\xb2\\x07\\xe1\\x8f\\x6d\\xad\\xd1\\x04\\x4a\\x5e\\xb3\\x89\\xef\\x7c\\x60\"\n            b\"\\xc2\\x68\\x53\\xf9\\x3d\\x1f\\x6d\"\n        )\n        assert sct.extension_bytes == b\"\"\n\n    def test_generate(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"badssl-sct.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        scts = cert.extensions.get_extension_for_class(\n            x509.PrecertificateSignedCertificateTimestamps\n        ).value\n        assert len(scts) == 1\n        [sct] = scts\n\n        private_key = rsa_key_2048\n        builder = _make_certbuilder(private_key).add_extension(\n            x509.PrecertificateSignedCertificateTimestamps([sct]),\n            critical=False,\n        )\n        cert = builder.sign(private_key, hashes.SHA256(), backend)\n        ext = cert.extensions.get_extension_for_class(\n            x509.PrecertificateSignedCertificateTimestamps\n        ).value\n        assert list(ext) == [sct]\n\n    def test_invalid_version(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"invalid-sct-version.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions\n\n    def test_invalid_hash_algorithm(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"badssl-sct-none-hash.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(\n            ValueError, match=\"Invalid/unsupported hash algorithm for SCT: 0\"\n        ):\n            cert.extensions\n\n    def test_invalid_signature_algorithm(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"badssl-sct-anonymous-sig.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(\n            ValueError,\n            match=\"Invalid/unsupported signature algorithm for SCT: 0\",\n        ):\n            cert.extensions\n\n    def test_invalid_length(self, backend):\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"invalid-sct-length.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions\n\n    def test_public_bytes(self, backend):\n        ext = (\n            _load_cert(\n                os.path.join(\"x509\", \"cryptography-scts.pem\"),\n                x509.load_pem_x509_certificate,\n            )\n            .extensions.get_extension_for_class(\n                x509.PrecertificateSignedCertificateTimestamps\n            )\n            .value\n        )\n        assert (\n            ext.public_bytes()\n            == b\"\\x04\\x81\\xf4\\x00\\xf2\\x00w\\x00)<Q\\x96T\\xc89e\\xba\\xaaP\\xfcX\"\n            b\"\\x07\\xd4\\xb7o\\xbfXz)r\\xdc\\xa4\\xc3\\x0c\\xf4\\xe5EG\\xf4x\\x00\\x00\"\n            b\"\\x01f\\x17\\xabJ\\xe9\\x00\\x00\\x04\\x03\\x00H0F\\x02!\\x00\\xa5\\xce\\xa8|\"\n            b\"Pnq\\x8c&\\xe3H\\xbb\\xf4\\x0b\\xc1\\x0eu\\xe8M}\\xe6:\\x8bM\\x1e~\\x89\\nr\"\n            b\"\\xda\\xa4@\\x02!\\x00\\xde\\xa9\\xf1\\xd0\\xc3S\\xfc\\xd37\\xe1[q_\\x80(\"\n            b\"\\x85u\\x80]Kw\\x02\\xc0'\\x02\\xee\\xd8\\xf7\\x15N|r\\x00w\\x00oSv\\xac1\"\n            b\"\\xf01\\x19\\xd8\\x99\\x00\\xa4Q\\x15\\xffw\\x15\\x1c\\x11\\xd9\\x02\\xc1\\x00\"\n            b\")\\x06\\x8d\\xb2\\x08\\x9a7\\xd9\\x13\\x00\\x00\\x01f\\x17\\xabKp\\x00\\x00\"\n            b\"\\x04\\x03\\x00H0F\\x02!\\x00\\xa2\\xe0\\xd9\\xfec\\x94\\x14\\xf8\\xbd\\xcd\"\n            b\"\\xd7\\xf6\\x9d\\xb0\\x90\\xd5\\xb8\\x92\\x07\\xb4\\x80\\xc7\\x8a\\xc2\\xc5\"\n            b\"\\xc4\\x0e6\\x1e\\x92\\xa3\\xa6\\x02!\\x00\\xbc\\xe7\\r\\xc3\\x841\\xfa\\xfc\"\n            b\"\\x85\\x1f%\\xc0#N\\\\\\xdeK\\x90d\\xe0\\x8d<{\\xca\\xdbdc\\xeft\\x87g\\x10\"\n        )\n\n\nclass TestInvalidExtension:\n    def test_invalid_certificate_policies_data(self, backend):\n        # UserNotice OID but CPSURI structure\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cp_invalid.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions\n\n        # CPSURI OID but UserNotice structure\n        cert = _load_cert(\n            os.path.join(\"x509\", \"custom\", \"cp_invalid2.der\"),\n            x509.load_der_x509_certificate,\n        )\n        with pytest.raises(ValueError):\n            cert.extensions\n\n\nclass TestOCSPNonce:\n    def test_non_bytes(self):\n        with pytest.raises(TypeError):\n            x509.OCSPNonce(38)  # type:ignore[arg-type]\n\n    def test_eq(self):\n        nonce1 = x509.OCSPNonce(b\"0\" * 5)\n        nonce2 = x509.OCSPNonce(b\"0\" * 5)\n        assert nonce1 == nonce2\n\n    def test_ne(self):\n        nonce1 = x509.OCSPNonce(b\"0\" * 5)\n        nonce2 = x509.OCSPNonce(b\"0\" * 6)\n        assert nonce1 != nonce2\n        assert nonce1 != object()\n\n    def test_repr(self):\n        nonce1 = x509.OCSPNonce(b\"nonce\")\n        assert repr(nonce1) == \"<OCSPNonce(nonce=b'nonce')>\"\n\n    def test_hash(self):\n        nonce1 = x509.OCSPNonce(b\"0\" * 5)\n        nonce2 = x509.OCSPNonce(b\"0\" * 5)\n        nonce3 = x509.OCSPNonce(b\"1\" * 5)\n        assert hash(nonce1) == hash(nonce2)\n        assert hash(nonce1) != hash(nonce3)\n\n    def test_public_bytes(self):\n        ext = x509.OCSPNonce(b\"0\" * 5)\n        assert ext.public_bytes() == b\"\\x04\\x0500000\"\n\n\nclass TestOCSPAcceptableResponses:\n    def test_invalid_types(self):\n        with pytest.raises(TypeError):\n            x509.OCSPAcceptableResponses(38)  # type:ignore[arg-type]\n        with pytest.raises(TypeError):\n            x509.OCSPAcceptableResponses([38])  # type:ignore[list-item]\n\n    def test_eq(self):\n        acceptable_responses1 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n        acceptable_responses2 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n        assert acceptable_responses1 == acceptable_responses2\n\n    def test_ne(self):\n        acceptable_responses1 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n        acceptable_responses2 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.4\")]\n        )\n        assert acceptable_responses1 != acceptable_responses2\n        assert acceptable_responses1 != object()\n\n    def test_repr(self):\n        acceptable_responses = x509.OCSPAcceptableResponses([])\n        assert (\n            repr(acceptable_responses)\n            == \"<OCSPAcceptableResponses(responses=[])>\"\n        )\n\n    def test_hash(self):\n        acceptable_responses1 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n        acceptable_responses2 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n        acceptable_responses3 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.4\")]\n        )\n\n        assert hash(acceptable_responses1) == hash(acceptable_responses2)\n        assert hash(acceptable_responses1) != hash(acceptable_responses3)\n\n    def test_iter(self):\n        acceptable_responses1 = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.2.3\")]\n        )\n\n        assert list(acceptable_responses1) == [ObjectIdentifier(\"1.2.3\")]\n\n    def test_public_bytes(self):\n        ext = x509.OCSPAcceptableResponses([])\n        assert ext.public_bytes() == b\"\\x30\\x00\"\n\n        ext = x509.OCSPAcceptableResponses(\n            [ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.1\")]\n        )\n        assert (\n            ext.public_bytes()\n            == b\"\\x30\\x0b\\x06\\t+\\x06\\x01\\x05\\x05\\x07\\x30\\x01\\x01\"\n        )\n\n\nclass TestMSCertificateTemplate:\n    def test_invalid_type(self):\n        with pytest.raises(TypeError):\n            x509.MSCertificateTemplate(\n                \"notanoid\",  # type:ignore[arg-type]\n                None,\n                None,\n            )\n        oid = x509.ObjectIdentifier(\"1.2.3.4\")\n        with pytest.raises(TypeError):\n            x509.MSCertificateTemplate(\n                oid,\n                \"notanint\",  # type:ignore[arg-type]\n                None,\n            )\n        with pytest.raises(TypeError):\n            x509.MSCertificateTemplate(\n                oid,\n                None,\n                \"notanint\",  # type:ignore[arg-type]\n            )\n\n    def test_eq(self):\n        template1 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        template2 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        assert template1 == template2\n\n    def test_ne(self):\n        template1 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        template2 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), 1, None\n        )\n        template3 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, 1\n        )\n        template4 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3\"), None, None\n        )\n        assert template1 != template2\n        assert template1 != template3\n        assert template1 != template4\n        assert template1 != object()\n\n    def test_repr(self):\n        template = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        assert repr(template) == (\n            \"<MSCertificateTemplate(template_id=<ObjectIdentifier(oid=1.2.3.4,\"\n            \" name=Unknown OID)>, major_version=None, minor_version=None)>\"\n        )\n\n    def test_hash(self):\n        template1 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        template2 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        template3 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, 1\n        )\n        template4 = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3\"), None, None\n        )\n\n        assert hash(template1) == hash(template2)\n        assert hash(template1) != hash(template3)\n        assert hash(template1) != hash(template4)\n\n    def test_public_bytes(self):\n        ext = x509.MSCertificateTemplate(\n            ObjectIdentifier(\"1.2.3.4\"), None, None\n        )\n        assert ext.public_bytes() == b\"0\\x05\\x06\\x03*\\x03\\x04\"\n\n        ext = x509.MSCertificateTemplate(ObjectIdentifier(\"1.2.3.4\"), 1, 0)\n        assert (\n            ext.public_bytes()\n            == b\"0\\x0b\\x06\\x03*\\x03\\x04\\x02\\x01\\x01\\x02\\x01\\x00\"\n        )\n\n\ndef test_all_extension_oid_members_have_names_defined():\n    for oid in dir(ExtensionOID):\n        if oid.startswith(\"__\"):\n            continue\n        assert getattr(ExtensionOID, oid) in _OID_NAMES\n\n\ndef test_unknown_extension():\n    class MyExtension(ExtensionType):\n        oid = x509.ObjectIdentifier(\"1.2.3.4\")\n\n    with pytest.raises(NotImplementedError):\n        MyExtension().public_bytes()\n\n    with pytest.raises(NotImplementedError):\n        rust_x509.encode_extension_value(MyExtension())\n", "tests/x509/test_name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.x509 import (\n    Name,\n    NameAttribute,\n    NameOID,\n    RelativeDistinguishedName,\n)\n\n\nclass TestRFC4514:\n    def test_invalid(self, subtests):\n        for value in [\n            \"C=US,CN=Joe , Smith,DC=example\",\n            \",C=US,CN=Joe , Smith,DC=example\",\n            \"C=US,UNKNOWN=Joe , Smith,DC=example\",\n            \"C=US,CN,DC=example\",\n            \"C=US,FOOBAR=example\",\n        ]:\n            with subtests.test():\n                with pytest.raises(ValueError):\n                    Name.from_rfc4514_string(value)\n\n    def test_valid(self, subtests):\n        for value, expected in [\n            (\n                r\"CN=James \\\"Jim\\\" Smith\\, III\",\n                Name(\n                    [\n                        NameAttribute(\n                            NameOID.COMMON_NAME, 'James \"Jim\" Smith, III'\n                        )\n                    ]\n                ),\n            ),\n            (\n                r\"UID=\\# escape\\+\\,\\;\\00this\\ \",\n                Name([NameAttribute(NameOID.USER_ID, \"# escape+,;\\0this \")]),\n            ),\n            (\n                r\"2.5.4.3=James \\\"Jim\\\" Smith\\, III\",\n                Name(\n                    [\n                        NameAttribute(\n                            NameOID.COMMON_NAME, 'James \"Jim\" Smith, III'\n                        )\n                    ]\n                ),\n            ),\n            (\"ST=\", Name([NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"\")])),\n            (\n                \"OU=Sales+CN=J.  Smith,DC=example,DC=net\",\n                Name(\n                    [\n                        RelativeDistinguishedName(\n                            [NameAttribute(NameOID.DOMAIN_COMPONENT, \"net\")]\n                        ),\n                        RelativeDistinguishedName(\n                            [\n                                NameAttribute(\n                                    NameOID.DOMAIN_COMPONENT, \"example\"\n                                )\n                            ]\n                        ),\n                        RelativeDistinguishedName(\n                            [\n                                NameAttribute(\n                                    NameOID.ORGANIZATIONAL_UNIT_NAME, \"Sales\"\n                                ),\n                                NameAttribute(\n                                    NameOID.COMMON_NAME, \"J.  Smith\"\n                                ),\n                            ]\n                        ),\n                    ]\n                ),\n            ),\n            (\n                \"CN=cryptography.io,O=PyCA,L=,ST=,C=US\",\n                Name(\n                    [\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                        NameAttribute(NameOID.STATE_OR_PROVINCE_NAME, \"\"),\n                        NameAttribute(NameOID.LOCALITY_NAME, \"\"),\n                        NameAttribute(NameOID.ORGANIZATION_NAME, \"PyCA\"),\n                        NameAttribute(NameOID.COMMON_NAME, \"cryptography.io\"),\n                    ]\n                ),\n            ),\n            (\n                r\"C=US,CN=Joe \\, Smith,DC=example\",\n                Name(\n                    [\n                        NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\"),\n                        NameAttribute(NameOID.COMMON_NAME, \"Joe , Smith\"),\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                    ]\n                ),\n            ),\n            (\n                r\"C=US,CN=Jane \\\"J\\,S\\\" Smith,DC=example\",\n                Name(\n                    [\n                        NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\"),\n                        NameAttribute(NameOID.COMMON_NAME, 'Jane \"J,S\" Smith'),\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                    ]\n                ),\n            ),\n            (\n                'C=US,CN=\\\\\"Jane J\\\\,S Smith\\\\\",DC=example',\n                Name(\n                    [\n                        NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\"),\n                        NameAttribute(NameOID.COMMON_NAME, '\"Jane J,S Smith\"'),\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                    ]\n                ),\n            ),\n            (\n                'C=US,CN=\\\\\"Jane \\\\\"J\\\\,S\\\\\" Smith\\\\\",DC=example',\n                Name(\n                    [\n                        NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\"),\n                        NameAttribute(\n                            NameOID.COMMON_NAME, '\"Jane \"J,S\" Smith\"'\n                        ),\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                    ]\n                ),\n            ),\n            (\n                r\"C=US,CN=Jane=Smith,DC=example\",\n                Name(\n                    [\n                        NameAttribute(NameOID.DOMAIN_COMPONENT, \"example\"),\n                        NameAttribute(NameOID.COMMON_NAME, \"Jane=Smith\"),\n                        NameAttribute(NameOID.COUNTRY_NAME, \"US\"),\n                    ]\n                ),\n            ),\n            (r\"CN=#616263\", Name([NameAttribute(NameOID.COMMON_NAME, \"abc\")])),\n            (r\"CN=\ud83d\udc4d\", Name([NameAttribute(NameOID.COMMON_NAME, \"\ud83d\udc4d\")])),\n            (\n                \"CN=\\\\\\\\123\",\n                Name([NameAttribute(NameOID.COMMON_NAME, \"\\\\123\")]),\n            ),\n            (\"CN=\\\\\\\\\\\\;\", Name([NameAttribute(NameOID.COMMON_NAME, \"\\\\;\")])),\n            (\n                \"CN=\\\\\\\\#123\",\n                Name([NameAttribute(NameOID.COMMON_NAME, \"\\\\#123\")]),\n            ),\n            (\n                \"2.5.4.10=abc\",\n                Name([NameAttribute(NameOID.ORGANIZATION_NAME, \"abc\")]),\n            ),\n            (\"\", Name([])),\n        ]:\n            with subtests.test():\n                result = Name.from_rfc4514_string(value)\n                assert result == expected\n\n    def test_attr_name_override(self):\n        assert Name.from_rfc4514_string(\n            \"CN=Santa Claus,E=santa@north.pole\", {\"E\": NameOID.EMAIL_ADDRESS}\n        ) == Name(\n            [\n                NameAttribute(NameOID.EMAIL_ADDRESS, \"santa@north.pole\"),\n                NameAttribute(NameOID.COMMON_NAME, \"Santa Claus\"),\n            ]\n        )\n\n        assert Name.from_rfc4514_string(\n            \"CN=Santa Claus\", {\"CN\": NameOID.EMAIL_ADDRESS}\n        ) == Name(\n            [\n                NameAttribute(NameOID.EMAIL_ADDRESS, \"Santa Claus\"),\n            ]\n        )\n\n    def test_generate_parse(self):\n        name_value = Name(\n            [\n                NameAttribute(NameOID.COMMON_NAME, \"Common Name 1\"),\n                NameAttribute(NameOID.LOCALITY_NAME, \"City for Name 1\"),\n                NameAttribute(\n                    NameOID.ORGANIZATION_NAME, \"Name 1 Organization\"\n                ),\n            ]\n        )\n\n        assert (\n            Name.from_rfc4514_string(name_value.rfc4514_string()) == name_value\n        )\n\n        name_string = \"O=Organization,L=City,CN=Common Name\"\n        assert (\n            Name.from_rfc4514_string(name_string).rfc4514_string()\n            == name_string\n        )\n", "tests/x509/__init__.py": "", "tests/x509/test_ocsp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport base64\nimport datetime\nimport os\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, ed448, ed25519, rsa\nfrom cryptography.hazmat.primitives.asymmetric.padding import PKCS1v15\nfrom cryptography.x509 import ocsp\n\nfrom ..hazmat.primitives.fixtures_ec import EC_KEY_SECP256R1\nfrom ..utils import load_vectors_from_file, raises_unsupported_algorithm\nfrom .test_x509 import DummyExtension, _load_cert\n\n\ndef _load_data(filename, loader):\n    return load_vectors_from_file(\n        filename=filename, loader=lambda data: loader(data.read()), mode=\"rb\"\n    )\n\n\ndef _cert_and_issuer():\n    cert = _load_cert(\n        os.path.join(\"x509\", \"cryptography.io.pem\"),\n        x509.load_pem_x509_certificate,\n    )\n    issuer = _load_cert(\n        os.path.join(\"x509\", \"rapidssl_sha256_ca_g3.pem\"),\n        x509.load_pem_x509_certificate,\n    )\n    return cert, issuer\n\n\ndef _generate_root(private_key=None, algorithm=hashes.SHA256()):\n    from cryptography.hazmat.backends.openssl.backend import backend\n\n    if private_key is None:\n        private_key = EC_KEY_SECP256R1.private_key(backend)\n\n    subject = x509.Name(\n        [\n            x509.NameAttribute(x509.NameOID.COUNTRY_NAME, \"US\"),\n            x509.NameAttribute(x509.NameOID.COMMON_NAME, \"Cryptography CA\"),\n        ]\n    )\n\n    builder = (\n        x509.CertificateBuilder()\n        .serial_number(123456789)\n        .issuer_name(subject)\n        .subject_name(subject)\n        .public_key(private_key.public_key())\n        .not_valid_before(datetime.datetime.now())\n        .not_valid_after(\n            datetime.datetime.now() + datetime.timedelta(days=3650)\n        )\n    )\n\n    cert = builder.sign(private_key, algorithm, backend)\n    return cert, private_key\n\n\nclass TestOCSPRequest:\n    def test_bad_request(self):\n        with pytest.raises(ValueError):\n            ocsp.load_der_ocsp_request(b\"invalid\")\n\n    def test_load_request(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-sha1.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        assert isinstance(req, ocsp.OCSPRequest)\n        assert req.issuer_name_hash == (\n            b\"8\\xcaF\\x8c\\x07D\\x8d\\xf4\\x81\\x96\\xc7mmLpQ\\x9e`\\xa7\\xbd\"\n        )\n        assert req.issuer_key_hash == (\n            b\"yu\\xbb\\x84:\\xcb,\\xdez\\t\\xbe1\\x1bC\\xbc\\x1c*MSX\"\n        )\n        assert isinstance(req.hash_algorithm, hashes.SHA1)\n        assert req.serial_number == int(\n            \"98D9E5C0B4C373552DF77C5D0F1EB5128E4945F9\", 16\n        )\n        assert len(req.extensions) == 0\n\n    def test_load_request_with_extensions(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-ext-nonce.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        assert len(req.extensions) == 1\n        ext = req.extensions[0]\n        assert ext.critical is False\n        assert ext.value == x509.OCSPNonce(\n            b\"{\\x80Z\\x1d7&\\xb8\\xb8OH\\xd2\\xf8\\xbf\\xd7-\\xfd\"\n        )\n\n    def test_load_request_with_acceptable_responses(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-acceptable-responses.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        assert len(req.extensions) == 1\n        ext = req.extensions[0]\n        assert ext.critical is False\n        assert ext.value == x509.OCSPAcceptableResponses(\n            [x509.ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.1\")]\n        )\n\n    def test_load_request_with_unknown_extension(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-ext-unknown-oid.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        assert len(req.extensions) == 1\n        ext = req.extensions[0]\n        assert ext.critical is False\n        assert ext.value == x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.2213\"),\n            b\"\\x04\\x10{\\x80Z\\x1d7&\\xb8\\xb8OH\\xd2\\xf8\\xbf\\xd7-\\xfd\",\n        )\n\n    def test_load_request_with_duplicate_extension(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-duplicate-ext.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        with pytest.raises(x509.DuplicateExtension):\n            req.extensions\n\n    def test_load_request_two_requests(self):\n        with pytest.raises(NotImplementedError):\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"req-multi-sha1.der\"),\n                ocsp.load_der_ocsp_request,\n            )\n\n    def test_invalid_hash_algorithm(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-invalid-hash-alg.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        with raises_unsupported_algorithm(None):\n            req.hash_algorithm\n\n    def test_serialize_request(self):\n        req_bytes = load_vectors_from_file(\n            filename=os.path.join(\"x509\", \"ocsp\", \"req-sha1.der\"),\n            loader=lambda data: data.read(),\n            mode=\"rb\",\n        )\n        req = ocsp.load_der_ocsp_request(req_bytes)\n        assert req.public_bytes(serialization.Encoding.DER) == req_bytes\n\n    def test_invalid_serialize_encoding(self):\n        req = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"req-sha1.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n        with pytest.raises(ValueError):\n            req.public_bytes(\"invalid\")\n        with pytest.raises(ValueError):\n            req.public_bytes(serialization.Encoding.PEM)\n\n\nclass TestOCSPRequestBuilder:\n    def test_add_cert_twice(self):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        builder = builder.add_certificate(cert, issuer, hashes.SHA1())\n        # Fails calling a second time\n        with pytest.raises(ValueError):\n            builder.add_certificate(cert, issuer, hashes.SHA1())\n        # Fails calling a second time with add_certificate_by_hash\n        with pytest.raises(ValueError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 20, b\"0\" * 20, 1, hashes.SHA1()\n            )\n\n    def test_add_cert_by_hash_twice(self):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        builder = builder.add_certificate_by_hash(\n            b\"0\" * 20, b\"0\" * 20, 1, hashes.SHA1()\n        )\n        # Fails calling a second time\n        with pytest.raises(ValueError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 20, b\"0\" * 20, 1, hashes.SHA1()\n            )\n        # Fails calling a second time with add_certificate\n        with pytest.raises(ValueError):\n            builder.add_certificate(cert, issuer, hashes.SHA1())\n\n    def test_add_cert_by_hash_bad_hash(self):\n        builder = ocsp.OCSPRequestBuilder()\n        with pytest.raises(ValueError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 20,\n                b\"0\" * 20,\n                1,\n                \"notahash\",  # type:ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 19, b\"0\" * 20, 1, hashes.SHA1()\n            )\n        with pytest.raises(ValueError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 20, b\"0\" * 21, 1, hashes.SHA1()\n            )\n        with pytest.raises(TypeError):\n            builder.add_certificate_by_hash(\n                b\"0\" * 20,\n                b\"0\" * 20,\n                \"notanint\",  # type:ignore[arg-type]\n                hashes.SHA1(),\n            )\n\n    def test_create_ocsp_request_no_req(self):\n        builder = ocsp.OCSPRequestBuilder()\n        with pytest.raises(ValueError):\n            builder.build()\n\n    def test_create_ocsp_request_invalid_alg(self):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        with pytest.raises(ValueError):\n            builder.add_certificate(cert, issuer, hashes.MD5())\n\n    def test_add_extension_twice(self):\n        builder = ocsp.OCSPRequestBuilder()\n        builder = builder.add_extension(x509.OCSPNonce(b\"123\"), False)\n        with pytest.raises(ValueError):\n            builder.add_extension(x509.OCSPNonce(b\"123\"), False)\n\n    def test_add_invalid_extension(self):\n        builder = ocsp.OCSPRequestBuilder()\n        with pytest.raises(TypeError):\n            builder.add_extension(\n                \"notanext\",  # type:ignore[arg-type]\n                False,\n            )\n\n    def test_unsupported_extension(self):\n        cert, issuer = _cert_and_issuer()\n        builder = (\n            ocsp.OCSPRequestBuilder()\n            .add_extension(DummyExtension(), critical=False)\n            .add_certificate(cert, issuer, hashes.SHA256())\n        )\n        with pytest.raises(NotImplementedError):\n            builder.build()\n\n    def test_create_ocsp_request_invalid_cert(self):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        with pytest.raises(TypeError):\n            builder.add_certificate(\n                b\"notacert\",  # type:ignore[arg-type]\n                issuer,\n                hashes.SHA1(),\n            )\n\n        with pytest.raises(TypeError):\n            builder.add_certificate(\n                cert,\n                b\"notacert\",  # type:ignore[arg-type]\n                hashes.SHA1(),\n            )\n\n    def test_create_ocsp_request(self):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        builder = builder.add_certificate(cert, issuer, hashes.SHA1())\n        req = builder.build()\n        serialized = req.public_bytes(serialization.Encoding.DER)\n        assert serialized == base64.b64decode(\n            b\"MEMwQTA/MD0wOzAJBgUrDgMCGgUABBRAC0Z68eay0wmDug1gfn5ZN0gkxAQUw5zz\"\n            b\"/NNGCDS7zkZ/oHxb8+IIy1kCAj8g\"\n        )\n\n    @pytest.mark.parametrize(\n        (\"ext\", \"critical\"),\n        [\n            [x509.OCSPNonce(b\"0000\"), False],\n            [x509.OCSPNonce(b\"\\x00\\x01\\x02\"), True],\n        ],\n    )\n    def test_create_ocsp_request_with_extension(self, ext, critical):\n        cert, issuer = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        builder = builder.add_certificate(\n            cert, issuer, hashes.SHA1()\n        ).add_extension(ext, critical)\n        req = builder.build()\n        assert len(req.extensions) == 1\n        assert req.extensions[0].value == ext\n        assert req.extensions[0].oid == ext.oid\n        assert req.extensions[0].critical is critical\n\n    def test_add_cert_by_hash(self):\n        cert, _ = _cert_and_issuer()\n        builder = ocsp.OCSPRequestBuilder()\n        h = hashes.Hash(hashes.SHA1())\n        h.update(cert.issuer.public_bytes())\n        issuer_name_hash = h.finalize()\n        # issuer_key_hash is a hash of the public key BitString DER,\n        # not the subjectPublicKeyInfo\n        issuer_key_hash = base64.b64decode(b\"w5zz/NNGCDS7zkZ/oHxb8+IIy1k=\")\n        builder = builder.add_certificate_by_hash(\n            issuer_name_hash,\n            issuer_key_hash,\n            cert.serial_number,\n            hashes.SHA1(),\n        )\n        req = builder.build()\n        serialized = req.public_bytes(serialization.Encoding.DER)\n        assert serialized == base64.b64decode(\n            b\"MEMwQTA/MD0wOzAJBgUrDgMCGgUABBRAC0Z68eay0wmDug1gfn5ZN0gkxAQUw5zz\"\n            b\"/NNGCDS7zkZ/oHxb8+IIy1kCAj8g\"\n        )\n\n\nclass TestOCSPResponseBuilder:\n    def test_add_response_twice(self):\n        cert, issuer = _cert_and_issuer()\n        time = datetime.datetime.now()\n        builder = ocsp.OCSPResponseBuilder()\n        builder = builder.add_response(\n            cert,\n            issuer,\n            hashes.SHA256(),\n            ocsp.OCSPCertStatus.GOOD,\n            time,\n            time,\n            None,\n            None,\n        )\n        with pytest.raises(ValueError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                None,\n                None,\n            )\n\n    def test_invalid_add_response(self):\n        cert, issuer = _cert_and_issuer()\n        time = datetime.datetime.now(datetime.timezone.utc).replace(\n            tzinfo=None\n        )\n        reason = x509.ReasonFlags.cessation_of_operation\n        builder = ocsp.OCSPResponseBuilder()\n        with pytest.raises(TypeError):\n            builder.add_response(\n                \"bad\",  # type:ignore[arg-type]\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                None,\n                None,\n            )\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                \"bad\",  # type:ignore[arg-type]\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                None,\n                None,\n            )\n        with pytest.raises(ValueError):\n            builder.add_response(\n                cert,\n                issuer,\n                \"notahash\",  # type:ignore[arg-type]\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                None,\n                None,\n            )\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                \"bad\",  # type:ignore[arg-type]\n                time,\n                None,\n                None,\n            )\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                \"bad\",  # type:ignore[arg-type]\n                None,\n                None,\n            )\n\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                0,  # type:ignore[arg-type]\n                time,\n                time,\n                None,\n                None,\n            )\n        with pytest.raises(ValueError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                time,\n                None,\n            )\n        with pytest.raises(ValueError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                time,\n                time,\n                None,\n                reason,\n            )\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.REVOKED,\n                time,\n                time,\n                None,\n                reason,\n            )\n        with pytest.raises(TypeError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.REVOKED,\n                time,\n                time,\n                time,\n                0,  # type:ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            builder.add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.REVOKED,\n                time,\n                time,\n                time - datetime.timedelta(days=36500),\n                None,\n            )\n\n    def test_invalid_certificates(self):\n        builder = ocsp.OCSPResponseBuilder()\n        with pytest.raises(ValueError):\n            builder.certificates([])\n        with pytest.raises(TypeError):\n            builder.certificates([\"notacert\"])  # type: ignore[list-item]\n        with pytest.raises(TypeError):\n            builder.certificates(\"invalid\")  # type: ignore[arg-type]\n\n        _, issuer = _cert_and_issuer()\n        builder = builder.certificates([issuer])\n        with pytest.raises(ValueError):\n            builder.certificates([issuer])\n\n    def test_invalid_responder_id(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, _ = _cert_and_issuer()\n        with pytest.raises(TypeError):\n            builder.responder_id(\n                ocsp.OCSPResponderEncoding.HASH,\n                \"invalid\",  # type: ignore[arg-type]\n            )\n        with pytest.raises(TypeError):\n            builder.responder_id(\"notanenum\", cert)  # type: ignore[arg-type]\n\n        builder = builder.responder_id(ocsp.OCSPResponderEncoding.NAME, cert)\n        with pytest.raises(ValueError):\n            builder.responder_id(ocsp.OCSPResponderEncoding.NAME, cert)\n\n    def test_invalid_extension(self):\n        builder = ocsp.OCSPResponseBuilder()\n        with pytest.raises(TypeError):\n            builder.add_extension(\n                \"notanextension\",  # type: ignore[arg-type]\n                True,\n            )\n\n    def test_unsupported_extension(self):\n        root_cert, private_key = _generate_root()\n        cert, issuer = _cert_and_issuer()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n\n        builder = (\n            ocsp.OCSPResponseBuilder()\n            .responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n            .add_response(\n                cert,\n                issuer,\n                hashes.SHA256(),\n                ocsp.OCSPCertStatus.GOOD,\n                this_update,\n                next_update,\n                None,\n                None,\n            )\n            .add_extension(DummyExtension(), critical=False)\n        )\n        with pytest.raises(NotImplementedError):\n            builder.sign(private_key, hashes.SHA256())\n\n    def test_sign_no_response(self):\n        builder = ocsp.OCSPResponseBuilder()\n        root_cert, private_key = _generate_root()\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256())\n\n    def test_sign_no_responder_id(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        _, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256())\n\n    def test_sign_invalid_hash_algorithm(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now().replace(tzinfo=None).replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        with pytest.raises(TypeError):\n            builder.sign(private_key, \"notahash\")  # type: ignore[arg-type]\n\n    def test_sign_good_cert(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.responder_name == root_cert.subject\n        assert resp.responder_key_hash is None\n        assert (current_time - resp.produced_at).total_seconds() < 10\n        assert (\n            resp.signature_algorithm_oid\n            == x509.SignatureAlgorithmOID.ECDSA_WITH_SHA256\n        )\n        assert resp.certificate_status == ocsp.OCSPCertStatus.GOOD\n        assert resp.revocation_time is None\n        assert resp.revocation_reason is None\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    def test_sign_revoked_cert(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            next_update,\n            revoked_date,\n            None,\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == revoked_date\n        assert resp.revocation_reason is None\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    def test_sign_unknown_cert(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.UNKNOWN,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        resp = builder.sign(private_key, hashes.SHA384())\n        assert resp.certificate_status == ocsp.OCSPCertStatus.UNKNOWN\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA384())\n        )\n\n    def test_sign_with_appended_certs(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = (\n            builder.responder_id(ocsp.OCSPResponderEncoding.NAME, root_cert)\n            .add_response(\n                cert,\n                issuer,\n                hashes.SHA1(),\n                ocsp.OCSPCertStatus.GOOD,\n                this_update,\n                next_update,\n                None,\n                None,\n            )\n            .certificates([root_cert])\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.certificates == [root_cert]\n\n    def test_sign_revoked_no_next_update(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            None,\n            revoked_date,\n            None,\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == revoked_date\n        assert resp.revocation_reason is None\n        assert resp.this_update == this_update\n        assert resp.next_update is None\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    def test_sign_revoked_with_reason(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            next_update,\n            revoked_date,\n            x509.ReasonFlags.key_compromise,\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == revoked_date\n        assert resp.revocation_reason is x509.ReasonFlags.key_compromise\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    def test_sign_responder_id_key_hash(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.HASH, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert resp.responder_name is None\n        assert resp.responder_key_hash == (\n            b\"\\x8ca\\x94\\xe0\\x948\\xed\\x89\\xd8\\xd4N\\x89p\\t\\xd6\\xf9^_\\xec}\"\n        )\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    def test_invalid_sign_responder_cert_does_not_match_private_key(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, _ = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.HASH, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        diff_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        with pytest.raises(ValueError):\n            builder.sign(diff_key, hashes.SHA256())\n\n    def test_sign_with_extension(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = (\n            builder.responder_id(ocsp.OCSPResponderEncoding.HASH, root_cert)\n            .add_response(\n                cert,\n                issuer,\n                hashes.SHA1(),\n                ocsp.OCSPCertStatus.GOOD,\n                this_update,\n                next_update,\n                None,\n                None,\n            )\n            .add_extension(x509.OCSPNonce(b\"012345\"), False)\n        )\n        resp = builder.sign(private_key, hashes.SHA256())\n        assert len(resp.extensions) == 1\n        assert resp.extensions[0].value == x509.OCSPNonce(b\"012345\")\n        assert resp.extensions[0].critical is False\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes, ec.ECDSA(hashes.SHA256())\n        )\n\n    @pytest.mark.parametrize(\n        (\"status\", \"der\"),\n        [\n            (ocsp.OCSPResponseStatus.MALFORMED_REQUEST, b\"0\\x03\\n\\x01\\x01\"),\n            (ocsp.OCSPResponseStatus.INTERNAL_ERROR, b\"0\\x03\\n\\x01\\x02\"),\n            (ocsp.OCSPResponseStatus.TRY_LATER, b\"0\\x03\\n\\x01\\x03\"),\n            (ocsp.OCSPResponseStatus.SIG_REQUIRED, b\"0\\x03\\n\\x01\\x05\"),\n            (ocsp.OCSPResponseStatus.UNAUTHORIZED, b\"0\\x03\\n\\x01\\x06\"),\n        ],\n    )\n    def test_build_non_successful_statuses(self, status, der):\n        resp = ocsp.OCSPResponseBuilder.build_unsuccessful(status)\n        assert resp.response_status is status\n        assert resp.public_bytes(serialization.Encoding.DER) == der\n\n    def test_invalid_build_not_a_status(self):\n        with pytest.raises(TypeError):\n            ocsp.OCSPResponseBuilder.build_unsuccessful(\n                \"notastatus\"  # type: ignore[arg-type]\n            )\n\n    def test_invalid_build_successful_status(self):\n        with pytest.raises(ValueError):\n            ocsp.OCSPResponseBuilder.build_unsuccessful(\n                ocsp.OCSPResponseStatus.SUCCESSFUL\n            )\n\n    def test_sign_unknown_private_key(self, backend):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, _ = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        with pytest.raises(TypeError):\n            builder.sign(object(), hashes.SHA256())  # type:ignore[arg-type]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(\n            hashes.BLAKE2b(digest_size=64)\n        ),\n        skip_message=\"Does not support BLAKE2b\",\n    )\n    def test_sign_unrecognized_hash_algorithm(self, backend):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n\n        with pytest.raises(UnsupportedAlgorithm):\n            builder.sign(private_key, hashes.BLAKE2b(digest_size=64))\n\n    def test_sign_none_hash_not_eddsa(self):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        root_cert, private_key = _generate_root()\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.GOOD,\n            this_update,\n            next_update,\n            None,\n            None,\n        )\n        with pytest.raises(TypeError):\n            builder.sign(private_key, None)\n\n\nclass TestSignedCertificateTimestampsExtension:\n    def test_init(self):\n        with pytest.raises(TypeError):\n            x509.SignedCertificateTimestamps(\n                [object()]  # type: ignore[list-item]\n            )\n\n    def test_repr(self):\n        assert repr(x509.SignedCertificateTimestamps([])) == (\n            \"<SignedCertificateTimestamps([])>\"\n        )\n\n    def test_eq(self, backend):\n        sct1 = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        sct2 = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        assert sct1 == sct2\n\n    def test_ne(self, backend):\n        sct1 = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        sct2 = x509.SignedCertificateTimestamps([])\n        assert sct1 != sct2\n        assert sct1 != object()\n\n    def test_hash(self, backend):\n        sct1 = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        sct2 = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        sct3 = x509.SignedCertificateTimestamps([])\n        assert hash(sct1) == hash(sct2)\n        assert hash(sct1) != hash(sct3)\n\n    def test_entry_type(self, backend):\n        [sct, _, _, _] = (\n            _load_data(\n                os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n                ocsp.load_der_ocsp_response,\n            )\n            .single_extensions.get_extension_for_class(\n                x509.SignedCertificateTimestamps\n            )\n            .value\n        )\n        assert (\n            sct.entry_type\n            == x509.certificate_transparency.LogEntryType.X509_CERTIFICATE\n        )\n\n\nclass TestOCSPResponse:\n    def test_bad_response(self):\n        with pytest.raises(ValueError):\n            ocsp.load_der_ocsp_response(b\"invalid\")\n\n    def test_load_response(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-sha256.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        issuer = _load_cert(\n            os.path.join(\"x509\", \"letsencryptx3.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n        assert isinstance(resp, ocsp.OCSPResponse)\n        assert resp.response_status == ocsp.OCSPResponseStatus.SUCCESSFUL\n        assert (\n            resp.signature_algorithm_oid\n            == x509.SignatureAlgorithmOID.RSA_WITH_SHA256\n        )\n        assert isinstance(resp.signature_hash_algorithm, hashes.SHA256)\n        assert resp.signature == base64.b64decode(\n            b\"I9KUlyLV/2LbNCVu1BQphxdNlU/jBzXsPYVscPjW5E93pCrSO84GkIWoOJtqsnt\"\n            b\"78DLcQPnF3W24NXGzSGKlSWfXIsyoXCxnBm0mIbD5ZMnKyXEnqSR33Z9He/A+ML\"\n            b\"A8gbrDUipGNPosesenkKUnOtFIzEGv29hV5E6AMP2ORPVsVlTAZegPJFbbVIWc0\"\n            b\"rZGFCXKxijDxtUtgWzBhpBAI50JbPHi+IVuaOe4aDJLYgZ0BIBNa6bDI+rScyoy\"\n            b\"5U0DToV7SZn6CoJ3U19X7BHdYn6TLX0xi43eXuzBGzdHnSzmsc7r/DvkAKJm3vb\"\n            b\"dVECXqe/gFlXJUBcZ25jhs70MUA==\"\n        )\n        assert resp.tbs_response_bytes == base64.b64decode(\n            b\"MIHWoUwwSjELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUxldCdzIEVuY3J5cHQxIzA\"\n            b\"hBgNVBAMTGkxldCdzIEVuY3J5cHQgQXV0aG9yaXR5IFgzGA8yMDE4MDgzMDExMT\"\n            b\"UwMFowdTBzMEswCQYFKw4DAhoFAAQUfuZq53Kas/z4oiBkbBahLWBxCF0EFKhKa\"\n            b\"mMEfd265tE5t6ZFZe/zqOyhAhIDHHh6fckClQB7xfIiCztSevCAABgPMjAxODA4\"\n            b\"MzAxMTAwMDBaoBEYDzIwMTgwOTA2MTEwMDAwWg==\"\n        )\n        public_key = issuer.public_key()\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        public_key.verify(\n            resp.signature,\n            resp.tbs_response_bytes,\n            PKCS1v15(),\n            resp.signature_hash_algorithm,\n        )\n        assert resp.certificates == []\n        assert resp.responder_key_hash is None\n        assert resp.responder_name == issuer.subject\n        assert resp.produced_at == datetime.datetime(2018, 8, 30, 11, 15)\n        assert resp.certificate_status == ocsp.OCSPCertStatus.GOOD\n        assert resp.revocation_time is None\n        assert resp.revocation_reason is None\n        assert resp.this_update == datetime.datetime(2018, 8, 30, 11, 0)\n        assert resp.next_update == datetime.datetime(2018, 9, 6, 11, 0)\n        assert resp.issuer_key_hash == (\n            b\"\\xa8Jjc\\x04}\\xdd\\xba\\xe6\\xd19\\xb7\\xa6Ee\\xef\\xf3\\xa8\\xec\\xa1\"\n        )\n        assert resp.issuer_name_hash == (\n            b\"~\\xe6j\\xe7r\\x9a\\xb3\\xfc\\xf8\\xa2 dl\\x16\\xa1-`q\\x08]\"\n        )\n        assert isinstance(resp.hash_algorithm, hashes.SHA1)\n        assert resp.serial_number == 271024907440004808294641238224534273948400\n        assert len(resp.extensions) == 0\n\n    def test_load_multi_valued_response(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"ocsp-army.deps.mil-resp.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n\n        with pytest.raises(ValueError):\n            resp.serial_number\n\n        assert isinstance(next(resp.responses), ocsp.OCSPSingleResponse)\n        assert len(list(resp.responses)) == 20\n\n    def test_multi_valued_responses(self):\n        req_valid = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"ocsp-army.valid-req.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n\n        req_revoked = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"ocsp-army.revoked-req.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n\n        req_irrelevant = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"ocsp-army.inapplicable-req.der\"),\n            ocsp.load_der_ocsp_request,\n        )\n\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"ocsp-army.deps.mil-resp.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n\n        for elem in resp.responses:\n            serial = elem.serial_number\n\n            assert req_irrelevant.serial_number != serial\n            if req_valid.serial_number == serial:\n                assert elem.issuer_key_hash == req_valid.issuer_key_hash\n                assert elem.issuer_name_hash == req_valid.issuer_name_hash\n                assert (\n                    elem.hash_algorithm.name == req_valid.hash_algorithm.name\n                )\n\n                assert elem.certificate_status == ocsp.OCSPCertStatus.GOOD\n\n                assert elem.this_update == datetime.datetime(2020, 2, 22, 0, 0)\n                assert elem.next_update == datetime.datetime(2020, 2, 29, 1, 0)\n            elif req_revoked.serial_number == serial:\n                assert elem.certificate_status == ocsp.OCSPCertStatus.REVOKED\n\n                assert (\n                    elem.revocation_reason\n                    == x509.ReasonFlags.cessation_of_operation\n                )\n                assert elem.revocation_time == datetime.datetime(\n                    2018, 5, 30, 14, 1, 39\n                )\n\n    def test_load_unauthorized(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-unauthorized.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.response_status == ocsp.OCSPResponseStatus.UNAUTHORIZED\n        with pytest.raises(ValueError):\n            resp.signature_algorithm_oid\n        with pytest.raises(ValueError):\n            resp.signature_hash_algorithm\n        with pytest.raises(ValueError):\n            resp.signature\n        with pytest.raises(ValueError):\n            resp.tbs_response_bytes\n        with pytest.raises(ValueError):\n            resp.certificates\n        with pytest.raises(ValueError):\n            resp.responder_key_hash\n        with pytest.raises(ValueError):\n            resp.responder_name\n        with pytest.raises(ValueError):\n            resp.produced_at\n        with pytest.raises(ValueError):\n            resp.certificate_status\n        with pytest.raises(ValueError):\n            resp.revocation_time\n        with pytest.raises(ValueError):\n            resp.revocation_reason\n        with pytest.raises(ValueError):\n            resp.this_update\n        with pytest.raises(ValueError):\n            resp.next_update\n        with pytest.raises(ValueError):\n            resp.issuer_key_hash\n        with pytest.raises(ValueError):\n            resp.issuer_name_hash\n        with pytest.raises(ValueError):\n            resp.hash_algorithm\n        with pytest.raises(ValueError):\n            resp.serial_number\n        with pytest.raises(ValueError):\n            resp.extensions\n\n    def test_load_revoked(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-revoked.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == datetime.datetime(\n            2016, 9, 2, 21, 28, 48\n        )\n        assert resp.revocation_reason is None\n\n    def test_load_delegate_unknown_cert(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-delegate-unknown-cert.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert len(resp.certificates) == 1\n        assert isinstance(resp.certificates[0], x509.Certificate)\n        assert resp.certificate_status == ocsp.OCSPCertStatus.UNKNOWN\n\n    def test_load_invalid_signature_oid(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-invalid-signature-oid.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.signature_algorithm_oid == x509.ObjectIdentifier(\n            \"1.2.840.113549.1.1.2\"\n        )\n        with raises_unsupported_algorithm(None):\n            resp.signature_hash_algorithm\n\n    def test_unknown_hash_algorithm(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-unknown-hash-alg.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        with raises_unsupported_algorithm(None):\n            resp.hash_algorithm\n\n    def test_load_responder_key_hash(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-responder-key-hash.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.responder_name is None\n        assert resp.responder_key_hash == (\n            b\"\\x0f\\x80a\\x1c\\x821a\\xd5/(\\xe7\\x8dF8\\xb4,\\xe1\\xc6\\xd9\\xe2\"\n        )\n\n    def test_load_revoked_reason(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-revoked-reason.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.revocation_reason is x509.ReasonFlags.superseded\n\n    def test_load_revoked_no_next_update(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-revoked-no-next-update.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert resp.serial_number == 16160\n        assert resp.next_update is None\n\n    def test_response_extensions(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-revoked-reason.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert len(resp.extensions) == 1\n        ext = resp.extensions[0]\n        assert ext.critical is False\n        assert ext.value == x509.OCSPNonce(\n            b'5\\x957\\x9fa\\x03\\x83\\x87\\x89rW\\x8f\\xae\\x99\\xf7\"'\n        )\n\n    def test_response_unknown_extension(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-unknown-extension.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert len(resp.extensions) == 1\n        ext = resp.extensions[0]\n        assert ext.critical is False\n        assert ext.value == x509.UnrecognizedExtension(\n            x509.ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.2.200\"),\n            b'\\x04\\x105\\x957\\x9fa\\x03\\x83\\x87\\x89rW\\x8f\\xae\\x99\\xf7\"',\n        )\n\n    def test_serialize_reponse(self):\n        resp_bytes = load_vectors_from_file(\n            filename=os.path.join(\"x509\", \"ocsp\", \"resp-revoked.der\"),\n            loader=lambda data: data.read(),\n            mode=\"rb\",\n        )\n        resp = ocsp.load_der_ocsp_response(resp_bytes)\n        assert resp.public_bytes(serialization.Encoding.DER) == resp_bytes\n\n    def test_invalid_serialize_encoding(self):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-revoked.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        with pytest.raises(ValueError):\n            resp.public_bytes(\"invalid\")\n        with pytest.raises(ValueError):\n            resp.public_bytes(serialization.Encoding.PEM)\n\n    def test_single_extensions_sct(self, backend):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-sct-extension.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert len(resp.single_extensions) == 1\n        ext = resp.single_extensions[0]\n        assert ext.oid == x509.ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.5\")\n        assert len(ext.value) == 4\n        log_ids = [base64.b64encode(sct.log_id) for sct in ext.value]\n        assert log_ids == [\n            b\"RJRlLrDuzq/EQAfYqP4owNrmgr7YyzG1P9MzlrW2gag=\",\n            b\"b1N2rDHwMRnYmQCkURX/dxUcEdkCwQApBo2yCJo32RM=\",\n            b\"u9nfvB+KcbWTlCOXqpJ7RzhXlQqrUugakJZkNo4e0YU=\",\n            b\"7ku9t3XOYLrhQmkfq+GeZqMPfl+wctiDAMR7iXqo/cs=\",\n        ]\n\n    def test_single_extensions(self, backend):\n        resp = _load_data(\n            os.path.join(\"x509\", \"ocsp\", \"resp-single-extension-reason.der\"),\n            ocsp.load_der_ocsp_response,\n        )\n        assert len(resp.single_extensions) == 1\n        ext = resp.single_extensions[0]\n        assert ext.oid == x509.CRLReason.oid\n        assert ext.value == x509.CRLReason(x509.ReasonFlags.unspecified)\n\n    def test_unknown_response_type(self):\n        with pytest.raises(ValueError):\n            _load_data(\n                os.path.join(\n                    \"x509\", \"ocsp\", \"resp-response-type-unknown-oid.der\"\n                ),\n                ocsp.load_der_ocsp_response,\n            )\n\n    def test_response_bytes_absent(self):\n        with pytest.raises(ValueError):\n            _load_data(\n                os.path.join(\n                    \"x509\", \"ocsp\", \"resp-successful-no-response-bytes.der\"\n                ),\n                ocsp.load_der_ocsp_response,\n            )\n\n    def test_unknown_response_status(self):\n        with pytest.raises(ValueError):\n            _load_data(\n                os.path.join(\n                    \"x509\", \"ocsp\", \"resp-unknown-response-status.der\"\n                ),\n                ocsp.load_der_ocsp_response,\n            )\n\n\nclass TestOCSPEdDSA:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support / OCSP\",\n    )\n    def test_invalid_algorithm(self, backend):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        root_cert, _ = _generate_root(private_key, None)\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            next_update,\n            revoked_date,\n            x509.ReasonFlags.key_compromise,\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key, hashes.SHA256())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support / OCSP\",\n    )\n    def test_sign_ed25519(self, backend):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        root_cert, _ = _generate_root(private_key, None)\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            next_update,\n            revoked_date,\n            x509.ReasonFlags.key_compromise,\n        )\n        resp = builder.sign(private_key, None)\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == revoked_date\n        assert resp.revocation_reason is x509.ReasonFlags.key_compromise\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        assert resp.signature_hash_algorithm is None\n        assert (\n            resp.signature_algorithm_oid == x509.SignatureAlgorithmOID.ED25519\n        )\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed448_supported(),\n        skip_message=\"Requires OpenSSL with Ed448 support / OCSP\",\n    )\n    def test_sign_ed448(self, backend):\n        builder = ocsp.OCSPResponseBuilder()\n        cert, issuer = _cert_and_issuer()\n        private_key = ed448.Ed448PrivateKey.generate()\n        root_cert, _ = _generate_root(private_key, None)\n        current_time = (\n            datetime.datetime.now(datetime.timezone.utc)\n            .replace(tzinfo=None)\n            .replace(microsecond=0)\n        )\n        this_update = current_time - datetime.timedelta(days=1)\n        next_update = this_update + datetime.timedelta(days=7)\n        revoked_date = this_update - datetime.timedelta(days=300)\n        builder = builder.responder_id(\n            ocsp.OCSPResponderEncoding.NAME, root_cert\n        ).add_response(\n            cert,\n            issuer,\n            hashes.SHA1(),\n            ocsp.OCSPCertStatus.REVOKED,\n            this_update,\n            next_update,\n            revoked_date,\n            x509.ReasonFlags.key_compromise,\n        )\n        resp = builder.sign(private_key, None)\n        assert resp.certificate_status == ocsp.OCSPCertStatus.REVOKED\n        assert resp.revocation_time == revoked_date\n        assert resp.revocation_reason is x509.ReasonFlags.key_compromise\n        assert resp.this_update == this_update\n        assert resp.next_update == next_update\n        assert resp.signature_hash_algorithm is None\n        assert resp.signature_algorithm_oid == x509.SignatureAlgorithmOID.ED448\n        private_key.public_key().verify(\n            resp.signature, resp.tbs_response_bytes\n        )\n", "tests/x509/test_x509_revokedcertbuilder.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport datetime\n\nimport pytest\n\nfrom cryptography import utils, x509\n\n\nclass TestRevokedCertificateBuilder:\n    def test_serial_number_must_be_integer(self):\n        with pytest.raises(TypeError):\n            x509.RevokedCertificateBuilder().serial_number(\n                \"notanx509name\"  # type: ignore[arg-type]\n            )\n\n    def test_serial_number_must_be_non_negative(self):\n        with pytest.raises(ValueError):\n            x509.RevokedCertificateBuilder().serial_number(-1)\n\n    def test_serial_number_must_be_positive(self):\n        with pytest.raises(ValueError):\n            x509.RevokedCertificateBuilder().serial_number(0)\n\n    def test_minimal_serial_number(self, backend):\n        revocation_date = datetime.datetime(2002, 1, 1, 12, 1)\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(1)\n            .revocation_date(revocation_date)\n        )\n\n        revoked_certificate = builder.build(backend)\n        assert revoked_certificate.serial_number == 1\n\n    def test_biggest_serial_number(self, backend):\n        revocation_date = datetime.datetime(2002, 1, 1, 12, 1)\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number((1 << 159) - 1)\n            .revocation_date(revocation_date)\n        )\n\n        revoked_certificate = builder.build(backend)\n        assert revoked_certificate.serial_number == (1 << 159) - 1\n\n    def test_serial_number_must_be_less_than_160_bits_long(self):\n        with pytest.raises(ValueError):\n            x509.RevokedCertificateBuilder().serial_number(1 << 159)\n\n    def test_set_serial_number_twice(self):\n        builder = x509.RevokedCertificateBuilder().serial_number(3)\n        with pytest.raises(ValueError):\n            builder.serial_number(4)\n\n    def test_aware_revocation_date(self, backend):\n        tz = datetime.timezone(datetime.timedelta(hours=-8))\n        time = datetime.datetime(2012, 1, 16, 22, 43, tzinfo=tz)\n        utc_time = datetime.datetime(2012, 1, 17, 6, 43)\n        serial_number = 333\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(serial_number)\n            .revocation_date(time)\n        )\n\n        revoked_certificate = builder.build(backend)\n        with pytest.warns(utils.DeprecatedIn42):\n            assert revoked_certificate.revocation_date == utc_time\n        assert revoked_certificate.revocation_date_utc == utc_time.replace(\n            tzinfo=datetime.timezone.utc\n        )\n\n    def test_revocation_date_invalid(self):\n        with pytest.raises(TypeError):\n            x509.RevokedCertificateBuilder().revocation_date(\n                \"notadatetime\"  # type: ignore[arg-type]\n            )\n\n    def test_revocation_date_before_1950(self):\n        with pytest.raises(ValueError):\n            x509.RevokedCertificateBuilder().revocation_date(\n                datetime.datetime(1940, 8, 10)\n            )\n\n    def test_set_revocation_date_twice(self):\n        builder = x509.RevokedCertificateBuilder().revocation_date(\n            datetime.datetime(2002, 1, 1, 12, 1)\n        )\n        with pytest.raises(ValueError):\n            builder.revocation_date(datetime.datetime(2002, 1, 1, 12, 1))\n\n    def test_add_extension_checks_for_duplicates(self):\n        builder = x509.RevokedCertificateBuilder().add_extension(\n            x509.CRLReason(x509.ReasonFlags.ca_compromise), False\n        )\n\n        with pytest.raises(ValueError):\n            builder.add_extension(\n                x509.CRLReason(x509.ReasonFlags.ca_compromise), False\n            )\n\n    def test_add_invalid_extension(self):\n        with pytest.raises(TypeError):\n            x509.RevokedCertificateBuilder().add_extension(\n                \"notanextension\",  # type: ignore[arg-type]\n                False,\n            )\n\n    def test_no_serial_number(self, backend):\n        builder = x509.RevokedCertificateBuilder().revocation_date(\n            datetime.datetime(2002, 1, 1, 12, 1)\n        )\n\n        with pytest.raises(ValueError):\n            builder.build(backend)\n\n    def test_no_revocation_date(self, backend):\n        builder = x509.RevokedCertificateBuilder().serial_number(3)\n\n        with pytest.raises(ValueError):\n            builder.build(backend)\n\n    def test_create_revoked(self, backend):\n        serial_number = 333\n        revocation_date = datetime.datetime(2002, 1, 1, 12, 1)\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(serial_number)\n            .revocation_date(revocation_date)\n        )\n\n        revoked_certificate = builder.build(backend)\n        assert revoked_certificate.serial_number == serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert revoked_certificate.revocation_date == revocation_date\n        assert (\n            revoked_certificate.revocation_date_utc\n            == revocation_date.replace(tzinfo=datetime.timezone.utc)\n        )\n        assert len(revoked_certificate.extensions) == 0\n\n    @pytest.mark.parametrize(\n        \"extension\",\n        [\n            x509.InvalidityDate(datetime.datetime(2015, 1, 1, 0, 0)),\n            x509.CRLReason(x509.ReasonFlags.ca_compromise),\n            x509.CertificateIssuer([x509.DNSName(\"cryptography.io\")]),\n        ],\n    )\n    def test_add_extensions(self, backend, extension):\n        serial_number = 333\n        revocation_date = datetime.datetime(2002, 1, 1, 12, 1)\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(serial_number)\n            .revocation_date(revocation_date)\n            .add_extension(extension, False)\n        )\n\n        revoked_certificate = builder.build(backend)\n        assert revoked_certificate.serial_number == serial_number\n        with pytest.warns(utils.DeprecatedIn42):\n            assert revoked_certificate.revocation_date == revocation_date\n        assert (\n            revoked_certificate.revocation_date_utc\n            == revocation_date.replace(tzinfo=datetime.timezone.utc)\n        )\n        assert len(revoked_certificate.extensions) == 1\n        ext = revoked_certificate.extensions.get_extension_for_class(\n            type(extension)\n        )\n        assert ext.critical is False\n        assert ext.value == extension\n\n    def test_add_multiple_extensions(self, backend):\n        serial_number = 333\n        revocation_date = datetime.datetime(2002, 1, 1, 12, 1)\n        invalidity_date = x509.InvalidityDate(\n            datetime.datetime(2015, 1, 1, 0, 0)\n        )\n        certificate_issuer = x509.CertificateIssuer(\n            [x509.DNSName(\"cryptography.io\")]\n        )\n        crl_reason = x509.CRLReason(x509.ReasonFlags.aa_compromise)\n        builder = (\n            x509.RevokedCertificateBuilder()\n            .serial_number(serial_number)\n            .revocation_date(revocation_date)\n            .add_extension(invalidity_date, True)\n            .add_extension(crl_reason, True)\n            .add_extension(certificate_issuer, True)\n        )\n\n        revoked_certificate = builder.build(backend)\n        assert len(revoked_certificate.extensions) == 3\n        for ext_data in [invalidity_date, certificate_issuer, crl_reason]:\n            ext = revoked_certificate.extensions.get_extension_for_class(\n                type(ext_data)\n            )\n            assert ext.critical is True\n            assert ext.value == ext_data\n", "tests/x509/verification/test_limbo.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport datetime\nimport ipaddress\nimport json\nimport os\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.x509 import load_pem_x509_certificate\nfrom cryptography.x509.verification import (\n    ClientVerifier,\n    PolicyBuilder,\n    ServerVerifier,\n    Store,\n    VerificationError,\n)\n\nLIMBO_UNSUPPORTED_FEATURES = {\n    # NOTE: Path validation is required to reject wildcards on public suffixes,\n    # however this isn't practical and most implementations make no attempt to\n    # comply with this.\n    \"pedantic-public-suffix-wildcard\",\n    # TODO: We don't support Distinguished Name Constraints yet.\n    \"name-constraint-dn\",\n    # Our support for custom EKUs is limited, and we (like most impls.) don't\n    # handle all EKU conditions under CABF.\n    \"pedantic-webpki-eku\",\n    # Most CABF validators do not enforce the CABF key requirements on\n    # subscriber keys (i.e., in the leaf certificate).\n    \"pedantic-webpki-subscriber-key\",\n    # Tests that fail based on a strict reading of RFC 5280\n    # but are widely ignored by validators.\n    \"pedantic-rfc5280\",\n    # In rare circumstances, CABF relaxes RFC 5280's prescriptions in\n    # incompatible ways. Our validator always tries (by default) to comply\n    # closer to CABF, so we skip these.\n    \"rfc5280-incompatible-with-webpki\",\n    # We do not support policy constraints.\n    \"has-policy-constraints\",\n}\n\nLIMBO_SKIP_TESTCASES = {\n    # We unconditionally count intermediate certificates for pathlen and max\n    # depth constraint purposes, even when self-issued.\n    # This is a violation of RFC 5280, but is consistent with Go's crypto/x509\n    # and Rust's webpki crate do.\n    \"pathlen::self-issued-certs-pathlen\",\n    \"pathlen::max-chain-depth-1-self-issued\",\n    # We allow certificates with serial numbers of zero. This is\n    # invalid under RFC 5280 but is widely violated by certs in common\n    # trust stores.\n    \"rfc5280::serial::zero\",\n    # We allow CAs that don't have AKIs, which is forbidden under\n    # RFC 5280. This is consistent with what Go's crypto/x509 and Rust's\n    # webpki crate do.\n    \"rfc5280::ski::root-missing-ski\",\n    \"rfc5280::ski::intermediate-missing-ski\",\n    # We currently allow intermediate CAs that don't have AKIs, which\n    # is technically forbidden under CABF. This is consistent with what\n    # Go's crypto/x509 and Rust's webpki crate do.\n    \"rfc5280::aki::intermediate-missing-aki\",\n    # We allow root CAs where the AKI and SKI mismatch, which is technically\n    # forbidden under CABF. This is consistent with what\n    # Go's crypto/x509 and Rust's webpki crate do.\n    \"webpki::aki::root-with-aki-ski-mismatch\",\n    # We allow RSA keys that aren't divisible by 8, which is technically\n    # forbidden under CABF. No other implementation checks this either.\n    \"webpki::forbidden-rsa-not-divisable-by-8-in-root\",\n    # We disallow CAs in the leaf position, which is explicitly forbidden\n    # by CABF (but implicitly permitted under RFC 5280). This is consistent\n    # with what webpki and rustls do, but inconsistent with Go and OpenSSL.\n    \"rfc5280::ca-as-leaf\",\n    \"pathlen::validation-ignores-pathlen-in-leaf\",\n}\n\n\ndef _get_limbo_peer(expected_peer):\n    kind = expected_peer[\"kind\"]\n    assert kind in (\"DNS\", \"IP\", \"RFC822\")\n    value = expected_peer[\"value\"]\n    if kind == \"DNS\":\n        return x509.DNSName(value)\n    elif kind == \"IP\":\n        return x509.IPAddress(ipaddress.ip_address(value))\n    else:\n        return x509.RFC822Name(value)\n\n\ndef _limbo_testcase(id_, testcase):\n    if id_ in LIMBO_SKIP_TESTCASES:\n        pytest.skip(f\"explicitly skipped testcase: {id_}\")\n\n    features = testcase[\"features\"]\n    unsupported = LIMBO_UNSUPPORTED_FEATURES.intersection(features)\n    if unsupported:\n        pytest.skip(f\"explicitly skipped features: {unsupported}\")\n\n    assert testcase[\"signature_algorithms\"] == []\n\n    trusted_certs = [\n        load_pem_x509_certificate(cert.encode())\n        for cert in testcase[\"trusted_certs\"]\n    ]\n    untrusted_intermediates = [\n        load_pem_x509_certificate(cert.encode())\n        for cert in testcase[\"untrusted_intermediates\"]\n    ]\n    peer_certificate = load_pem_x509_certificate(\n        testcase[\"peer_certificate\"].encode()\n    )\n    validation_time = testcase[\"validation_time\"]\n    validation_time = (\n        datetime.datetime.fromisoformat(validation_time)\n        if validation_time is not None\n        else None\n    )\n    max_chain_depth = testcase[\"max_chain_depth\"]\n    should_pass = testcase[\"expected_result\"] == \"SUCCESS\"\n\n    builder = PolicyBuilder().store(Store(trusted_certs))\n    if validation_time is not None:\n        builder = builder.time(validation_time)\n    if max_chain_depth is not None:\n        builder = builder.max_chain_depth(max_chain_depth)\n\n    verifier: ServerVerifier | ClientVerifier\n    if testcase[\"validation_kind\"] == \"SERVER\":\n        assert testcase[\"extended_key_usage\"] == [] or testcase[\n            \"extended_key_usage\"\n        ] == [\"serverAuth\"]\n        peer_name = _get_limbo_peer(testcase[\"expected_peer_name\"])\n        verifier = builder.build_server_verifier(peer_name)\n    else:\n        assert testcase[\"extended_key_usage\"] == [\"clientAuth\"]\n        verifier = builder.build_client_verifier()\n\n    if should_pass:\n        if isinstance(verifier, ServerVerifier):\n            built_chain = verifier.verify(\n                peer_certificate, untrusted_intermediates\n            )\n        else:\n            verified_client = verifier.verify(\n                peer_certificate, untrusted_intermediates\n            )\n\n            expected_subjects = [\n                _get_limbo_peer(p) for p in testcase[\"expected_peer_names\"]\n            ]\n            assert expected_subjects == verified_client.subjects\n\n            built_chain = verified_client.chain\n\n        # Assert that the verifier returns chains in [EE, ..., TA] order.\n        assert built_chain[0] == peer_certificate\n        for intermediate in built_chain[1:-1]:\n            assert intermediate in untrusted_intermediates\n        assert built_chain[-1] in trusted_certs\n    else:\n        with pytest.raises(VerificationError):\n            verifier.verify(peer_certificate, untrusted_intermediates)\n\n\ndef test_limbo(subtests, pytestconfig):\n    limbo_root = pytestconfig.getoption(\"--x509-limbo-root\", skip=True)\n    limbo_path = os.path.join(limbo_root, \"limbo.json\")\n    with open(limbo_path, mode=\"rb\") as limbo_file:\n        limbo = json.load(limbo_file)\n        testcases = limbo[\"testcases\"]\n        for testcase in testcases:\n            with subtests.test():\n                # NOTE: Pass in the id separately to make pytest\n                # error renderings slightly nicer.\n                _limbo_testcase(testcase[\"id\"], testcase)\n", "tests/x509/verification/test_verification.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport datetime\nimport os\nfrom functools import lru_cache\nfrom ipaddress import IPv4Address\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.x509.general_name import DNSName, IPAddress\nfrom cryptography.x509.verification import PolicyBuilder, Store\nfrom tests.x509.test_x509 import _load_cert\n\n\n@lru_cache(maxsize=1)\ndef dummy_store() -> Store:\n    cert = _load_cert(\n        os.path.join(\"x509\", \"cryptography.io.pem\"),\n        x509.load_pem_x509_certificate,\n    )\n    return Store([cert])\n\n\nclass TestPolicyBuilder:\n    def test_time_already_set(self):\n        with pytest.raises(ValueError):\n            PolicyBuilder().time(datetime.datetime.now()).time(\n                datetime.datetime.now()\n            )\n\n    def test_store_already_set(self):\n        with pytest.raises(ValueError):\n            PolicyBuilder().store(dummy_store()).store(dummy_store())\n\n    def test_max_chain_depth_already_set(self):\n        with pytest.raises(ValueError):\n            PolicyBuilder().max_chain_depth(8).max_chain_depth(9)\n\n    def test_ipaddress_subject(self):\n        policy = (\n            PolicyBuilder()\n            .store(dummy_store())\n            .build_server_verifier(IPAddress(IPv4Address(\"0.0.0.0\")))\n        )\n        assert policy.subject == IPAddress(IPv4Address(\"0.0.0.0\"))\n\n    def test_dnsname_subject(self):\n        policy = (\n            PolicyBuilder()\n            .store(dummy_store())\n            .build_server_verifier(DNSName(\"cryptography.io\"))\n        )\n        assert policy.subject == DNSName(\"cryptography.io\")\n\n    def test_subject_bad_types(self):\n        # Subject must be a supported GeneralName type\n        with pytest.raises(TypeError):\n            PolicyBuilder().store(dummy_store()).build_server_verifier(\n                \"cryptography.io\"  # type: ignore[arg-type]\n            )\n        with pytest.raises(TypeError):\n            PolicyBuilder().store(dummy_store()).build_server_verifier(\n                \"0.0.0.0\"  # type: ignore[arg-type]\n            )\n        with pytest.raises(TypeError):\n            PolicyBuilder().store(dummy_store()).build_server_verifier(\n                IPv4Address(\"0.0.0.0\")  # type: ignore[arg-type]\n            )\n        with pytest.raises(TypeError):\n            PolicyBuilder().store(dummy_store()).build_server_verifier(None)  # type: ignore[arg-type]\n\n    def test_builder_pattern(self):\n        now = datetime.datetime.now().replace(microsecond=0)\n        store = dummy_store()\n        max_chain_depth = 16\n\n        builder = PolicyBuilder()\n        builder = builder.time(now)\n        builder = builder.store(store)\n        builder = builder.max_chain_depth(max_chain_depth)\n\n        verifier = builder.build_server_verifier(DNSName(\"cryptography.io\"))\n        assert verifier.subject == DNSName(\"cryptography.io\")\n        assert verifier.validation_time == now\n        assert verifier.store == store\n        assert verifier.max_chain_depth == max_chain_depth\n\n    def test_build_server_verifier_missing_store(self):\n        with pytest.raises(\n            ValueError, match=\"A server verifier must have a trust store\"\n        ):\n            PolicyBuilder().build_server_verifier(DNSName(\"cryptography.io\"))\n\n\nclass TestStore:\n    def test_store_rejects_empty_list(self):\n        with pytest.raises(ValueError):\n            Store([])\n\n    def test_store_rejects_non_certificates(self):\n        with pytest.raises(TypeError):\n            Store([\"not a cert\"])  # type: ignore[list-item]\n\n\nclass TestClientVerifier:\n    def test_build_client_verifier_missing_store(self):\n        with pytest.raises(\n            ValueError, match=\"A client verifier must have a trust store\"\n        ):\n            PolicyBuilder().build_client_verifier()\n\n    def test_verify(self):\n        # expires 2018-11-16 01:15:03 UTC\n        leaf = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        store = Store([leaf])\n\n        validation_time = datetime.datetime.fromisoformat(\n            \"2018-11-16T00:00:00+00:00\"\n        )\n        builder = PolicyBuilder().store(store)\n        builder = builder.time(validation_time).max_chain_depth(16)\n        verifier = builder.build_client_verifier()\n\n        assert verifier.validation_time == validation_time.replace(tzinfo=None)\n        assert verifier.max_chain_depth == 16\n        assert verifier.store is store\n\n        verified_client = verifier.verify(leaf, [])\n        assert verified_client.chain == [leaf]\n\n        assert x509.DNSName(\"www.cryptography.io\") in verified_client.subjects\n        assert x509.DNSName(\"cryptography.io\") in verified_client.subjects\n        assert len(verified_client.subjects) == 2\n\n\nclass TestServerVerifier:\n    @pytest.mark.parametrize(\n        (\"validation_time\", \"valid\"),\n        [\n            # 03:15:02 UTC+2, or 1 second before expiry in UTC\n            (\"2018-11-16T03:15:02+02:00\", True),\n            # 00:15:04 UTC-1, or 1 second after expiry in UTC\n            (\"2018-11-16T00:15:04-01:00\", False),\n        ],\n    )\n    def test_verify_tz_aware(self, validation_time, valid):\n        # expires 2018-11-16 01:15:03 UTC\n        leaf = _load_cert(\n            os.path.join(\"x509\", \"cryptography.io.pem\"),\n            x509.load_pem_x509_certificate,\n        )\n\n        store = Store([leaf])\n\n        builder = PolicyBuilder().store(store)\n        builder = builder.time(\n            datetime.datetime.fromisoformat(validation_time)\n        )\n        verifier = builder.build_server_verifier(DNSName(\"cryptography.io\"))\n\n        if valid:\n            assert verifier.verify(leaf, []) == [leaf]\n        else:\n            with pytest.raises(\n                x509.verification.VerificationError,\n                match=\"cert is not valid at validation time\",\n            ):\n                verifier.verify(leaf, [])\n", "tests/x509/verification/__init__.py": "", "tests/hazmat/test_oid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport copy\n\nimport pytest\n\nfrom cryptography.hazmat._oid import ObjectIdentifier\n\n\ndef test_basic_oid():\n    assert ObjectIdentifier(\"1.2.3.4\").dotted_string == \"1.2.3.4\"\n\n\ndef test_oid_equal():\n    assert ObjectIdentifier(\"1.2.3.4\") == ObjectIdentifier(\"1.2.3.4\")\n\n\ndef test_oid_deepcopy():\n    oid = ObjectIdentifier(\"1.2.3.4\")\n    assert oid == copy.deepcopy(oid)\n\n\ndef test_oid_constraint():\n    # Too short\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"1\")\n\n    # First node too big\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"3.2.1\")\n\n    # Outside range\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"1.40\")\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"0.42\")\n\n    # non-decimal oid\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"1.2.foo.bar\")\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"1.2.0xf00.0xba4\")\n\n    # negative oid\n    with pytest.raises(ValueError):\n        ObjectIdentifier(\"1.2.-3.-4\")\n", "tests/hazmat/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/hazmat/primitives/test_kbkdf_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport os\n\nfrom ...utils import load_nist_kbkdf_vectors\nfrom .utils import generate_kbkdf_counter_mode_test\n\n\nclass TestCounterKDFCounterMode:\n    test_kbkdfctr = generate_kbkdf_counter_mode_test(\n        load_nist_kbkdf_vectors,\n        os.path.join(\"KDF\"),\n        [\"nist-800-108-KBKDF-CTR.txt\"],\n    )\n", "tests/hazmat/primitives/fixtures_rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography.hazmat.primitives.asymmetric.rsa import (\n    RSAPrivateNumbers,\n    RSAPublicNumbers,\n)\n\nRSA_KEY_512 = RSAPrivateNumbers(\n    p=int(\n        \"d57846898d5c0de249c08467586cb458fa9bc417cdf297f73cfc52281b787cd9\", 16\n    ),\n    q=int(\n        \"d10f71229e87e010eb363db6a85fd07df72d985b73c42786191f2ce9134afb2d\", 16\n    ),\n    d=int(\n        \"272869352cacf9c866c4e107acc95d4c608ca91460a93d28588d51cfccc07f449\"\n        \"18bbe7660f9f16adc2b4ed36ca310ef3d63b79bd447456e3505736a45a6ed21\",\n        16,\n    ),\n    dmp1=int(\n        \"addff2ec7564c6b64bc670d250b6f24b0b8db6b2810099813b7e7658cecf5c39\", 16\n    ),\n    dmq1=int(\n        \"463ae9c6b77aedcac1397781e50e4afc060d4b216dc2778494ebe42a6850c81\", 16\n    ),\n    iqmp=int(\n        \"54deef8548f65cad1d411527a32dcb8e712d3e128e4e0ff118663fae82a758f4\", 16\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"ae5411f963c50e3267fafcf76381c8b1e5f7b741fdb2a544bcf48bd607b10c991\"\n            \"90caeb8011dc22cf83d921da55ec32bd05cac3ee02ca5e1dbef93952850b525\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_522 = RSAPrivateNumbers(\n    p=int(\n        \"1a8aab9a069f92b52fdf05824f2846223dc27adfc806716a247a77d4c36885e4bf\",\n        16,\n    ),\n    q=int(\n        \"19e8d620d177ec54cdb733bb1915e72ef644b1202b889ceb524613efa49c07eb4f\",\n        16,\n    ),\n    d=int(\n        \"10b8a7c0a92c1ae2d678097d69db3bfa966b541fb857468291d48d1b52397ea2bac0d\"\n        \"4370c159015c7219e3806a01bbafaffdd46f86e3da1e2d1fe80a0369ccd745\",\n        16,\n    ),\n    dmp1=int(\n        \"3eb6277f66e6e2dcf89f1b8529431f730839dbd9a3e49555159bc8470eee886e5\", 16\n    ),\n    dmq1=int(\n        \"184b4d74aa54c361e51eb23fee4eae5e4786b37b11b6e0447af9c0b9c4e4953c5b\",\n        16,\n    ),\n    iqmp=int(\n        \"f80e9ab4fa7b35d0d232ef51c4736d1f2dcf2c7b1dd8716211b1bf1337e74f8ae\", 16\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"2afaea0e0bb6fca037da7d190b5270a6c665bc18e7a456f7e69beaac4433db748\"\n            \"ba99acdd14697e453bca596eb35b47f2d48f1f85ef08ce5109dad557a9cf85ebf\"\n            \"1\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_599 = RSAPrivateNumbers(\n    p=int(\n        \"cf95d20be0c7af69f4b3d909f65d858c26d1a7ef34da8e3977f4fa230580e58814b54\"\n        \"24be99\",\n        16,\n    ),\n    q=int(\n        \"6052be4b28debd4265fe12ace5aa4a0c4eb8d63ff8853c66824b35622161eb48a3bc8\"\n        \"c3ada5\",\n        16,\n    ),\n    d=int(\n        \"69d9adc465e61585d3142d7cc8dd30605e8d1cbbf31009bc2cd5538dc40528d5d68ee\"\n        \"fe6a42d23674b6ec76e192351bf368c8968f0392110bf1c2825dbcff071270b80adcc\"\n        \"fa1d19d00a1\",\n        16,\n    ),\n    dmp1=int(\n        \"a86d10edde456687fba968b1f298d2e07226adb1221b2a466a93f3d83280f0bb46c20\"\n        \"2b6811\",\n        16,\n    ),\n    dmq1=int(\n        \"40d570e08611e6b1da94b95d46f8e7fe80be48f7a5ff8838375b08039514a399b11c2\"\n        \"80735\",\n        16,\n    ),\n    iqmp=int(\n        \"cd051cb0ea68b88765c041262ace2ec4db11dab14afd192742e34d5da3328637fabdf\"\n        \"bae26e\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"4e1b470fe00642426f3808e74c959632dd67855a4c503c5b7876ccf4dc7f6a1a4\"\n            \"9107b90d26daf0a7879a6858218345fbc6e59f01cd095ca5647c27c25265e6c47\"\n            \"4fea89537191c7073d9d\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_745 = RSAPrivateNumbers(\n    p=int(\n        \"1c5a0cfe9a86debd19eca33ba961f15bc598aa7983a545ce775b933afc89eb51bcf90\"\n        \"836257fdd060d4b383240241d\",\n        16,\n    ),\n    q=int(\n        \"fb2634f657f82ee6b70553382c4e2ed26b947c97ce2f0016f1b282cf2998184ad0527\"\n        \"a9eead826dd95fe06b57a025\",\n        16,\n    ),\n    d=int(\n        \"402f30f976bc07d15ff0779abff127b20a8b6b1d0024cc2ad8b6762d38f174f81e792\"\n        \"3b49d80bdbdd80d9675cbc7b2793ec199a0430eb5c84604dacfdb29259ae6a1a44676\"\n        \"22f0b23d4cb0f5cb1db4b8173c8d9d3e57a74dbd200d2141\",\n        16,\n    ),\n    dmp1=int(\n        \"e5e95b7751a6649f199be21bef7a51c9e49821d945b6fc5f538b4a670d8762c375b00\"\n        \"8e70f31d52b3ea2bd14c3101\",\n        16,\n    ),\n    dmq1=int(\n        \"12b85d5843645f72990fcf8d2f58408b34b3a3b9d9078dd527fceb5d2fb7839008092\"\n        \"dd4aca2a1fb00542801dcef5\",\n        16,\n    ),\n    iqmp=int(\n        \"5672740d947f621fc7969e3a44ec26736f3f819863d330e63e9409e139d20753551ac\"\n        \"c16544dd2bdadb9dee917440\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"1bd085f92237774d34013b477ceebbb2f2feca71118db9b7429341477947e7b1d\"\n            \"04e8c43ede3c52bb25781af58d4ff81289f301eac62dc3bcd7dafd7a4d5304e9f\"\n            \"308e766952fbf2b62373e66611fa53189987dbef9f7243dcbbeb25831\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1024 = RSAPrivateNumbers(\n    p=int(\n        \"ea4d9d9a1a068be44b9a5f8f6de0512b2c5ba1fb804a4655babba688e6e890b347c1a\"\n        \"7426685a929337f513ae4256f0b7e5022d642237f960c5b24b96bee8e51\",\n        16,\n    ),\n    q=int(\n        \"cffb33e400d6f08b410d69deb18a85cf0ed88fcca9f32d6f2f66c62143d49aff92c11\"\n        \"4de937d4f1f62d4635ee89af99ce86d38a2b05310f3857c7b5d586ac8f9\",\n        16,\n    ),\n    d=int(\n        \"3d12d46d04ce942fb99be7bf30587b8cd3e21d75a2720e7bda1b867f1d418d91d8b9f\"\n        \"e1c00181fdde94f2faf33b4e6f800a1b3ae3b972ccb6d5079dcb6c794070ac8306d59\"\n        \"c00b58b7a9a81122a6b055832de7c72334a07494d8e7c9fbeed2cc37e011d9e6bfc6e\"\n        \"9bcddbef7f0f5771d9cf82cd4b268c97ec684575c24b6c881\",\n        16,\n    ),\n    dmp1=int(\n        \"470f2b11257b7ec9ca34136f487f939e6861920ad8a9ae132a02e74af5dceaa5b4c98\"\n        \"2949ccb44b67e2bcad2f58674db237fe250e0d62b47b28fa1dfaa603b41\",\n        16,\n    ),\n    dmq1=int(\n        \"c616e8317d6b3ae8272973709b80e8397256697ff14ea03389de454f619f99915a617\"\n        \"45319fefbe154ec1d49441a772c2f63f7d15c478199afc60469bfd0d561\",\n        16,\n    ),\n    iqmp=int(\n        \"d15e7c9ad357dfcd5dbdc8427680daf1006761bcfba93a7f86589ad88832a8d564b1c\"\n        \"d4291a658c96fbaea7ca588795820902d85caebd49c2d731e3fe0243130\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"be5aac07456d990133ebce69c06b48845b972ab1ad9f134bc5683c6b5489b5119\"\n            \"ede07be3bed0e355d48e0dfab1e4fb5187adf42d7d3fb0401c082acb8481bf17f\"\n            \"0e871f8877be04c3a1197d40aa260e2e0c48ed3fd2b93dc3fc0867591f67f3cd6\"\n            \"0a77adee1d68a8c3730a5702485f6ac9ede7f0fd2918e037ee4cc1fc1b4c9\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1025 = RSAPrivateNumbers(\n    p=int(\n        \"18e9bfb7071725da04d31c103fa3563648c69def43a204989214eb57b0c8b299f9ef3\"\n        \"5dda79a62d8d67fd2a9b69fbd8d0490aa2edc1e111a2b8eb7c737bb691a5\",\n        16,\n    ),\n    q=int(\n        \"d8eccaeeb95815f3079d13685f3f72ca2bf2550b349518049421375df88ca9bbb4ba8\"\n        \"cb0e3502203c9eeae174112509153445d251313e4711a102818c66fcbb7\",\n        16,\n    ),\n    d=int(\n        \"fe9ac54910b8b1bc948a03511c54cab206a1d36d50d591124109a48abb7480977ccb0\"\n        \"47b4d4f1ce7b0805df2d4fa3fe425f49b78535a11f4b87a4eba0638b3340c23d4e6b2\"\n        \"1ecebe9d5364ea6ead2d47b27836019e6ecb407000a50dc95a8614c9d0031a6e3a524\"\n        \"d2345cfb76e15c1f69d5ba35bdfb6ec63bcb115a757ef79d9\",\n        16,\n    ),\n    dmp1=int(\n        \"18537e81006a68ea76d590cc88e73bd26bc38d09c977959748e5265c0ce21c0b5fd26\"\n        \"53d975f97ef759b809f791487a8fff1264bf561627fb4527a3f0bbb72c85\",\n        16,\n    ),\n    dmq1=int(\n        \"c807eac5a1f1e1239f04b04dd16eff9a00565127a91046fa89e1eb5d6301cace85447\"\n        \"4d1f47b0332bd35b4214b66e9166953241538f761f30d969272ee214f17\",\n        16,\n    ),\n    iqmp=int(\n        \"133aa74dd41fe70fa244f07d0c4091a22f8c8f0134fe6aea9ec8b55383b758fefe358\"\n        \"2beec36eca91715eee7d21931f24fa9e97e8e3a50f9cd0f731574a5eafcc\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"151c44fed756370fb2d4a0e6ec7dcac84068ca459b6aaf22daf902dca72c77563\"\n            \"bf276fe3523f38f5ddaf3ea9aa88486a9d8760ff732489075862bee0e599de5c5\"\n            \"f509b4519f4f446521bad15cd279a498fe1e89107ce0d237e3103d7c5eb801666\"\n            \"42e2924b152aebff97b71fdd2d68ebb45034cc784e2e822ff6d1edf98af3f3\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1026 = RSAPrivateNumbers(\n    p=int(\n        \"1fcbfb8719c5bdb5fe3eb0937c76bb096e750b9442dfe31d6a877a13aed2a6a4e9f79\"\n        \"40f815f1c307dd6bc2b4b207bb6fe5be3a15bd2875a957492ce197cdedb1\",\n        16,\n    ),\n    q=int(\n        \"1f704a0f6b8966dd52582fdc08227dd3dbaeaa781918b41144b692711091b4ca4eb62\"\n        \"985c3513853828ce8739001dfba9a9a7f1a23cbcaf74280be925e2e7b50d\",\n        16,\n    ),\n    d=int(\n        \"c67975e35a1d0d0b3ebfca736262cf91990cb31cf4ac473c0c816f3bc2720bcba2475\"\n        \"e8d0de8535d257816c0fc53afc1b597eada8b229069d6ef2792fc23f59ffb4dc6c3d9\"\n        \"0a3c462082025a4cba7561296dd3d8870c4440d779406f00879afe2c681e7f5ee055e\"\n        \"ff829e6e55883ec20830c72300762e6e3a333d94b4dbe4501\",\n        16,\n    ),\n    dmp1=int(\n        \"314730ca7066c55d086a9fbdf3670ef7cef816b9efea8b514b882ae9d647217cf41d7\"\n        \"e9989269dc9893d02e315cb81f058c49043c2cac47adea58bdf5e20e841\",\n        16,\n    ),\n    dmq1=int(\n        \"1da28a9d687ff7cfeebc2439240de7505a8796376968c8ec723a2b669af8ce53d9c88\"\n        \"af18540bd78b2da429014923fa435f22697ac60812d7ca9c17a557f394cd\",\n        16,\n    ),\n    iqmp=int(\n        \"727947b57b8a36acd85180522f1b381bce5fdbd962743b3b14af98a36771a80f58ddd\"\n        \"62675d72a5935190da9ddc6fd6d6d5e9e9f805a2e92ab8d56b820493cdf\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"3e7a5e6483e55eb8b723f9c46732d21b0af9e06a4a1099962d67a35ee3f62e312\"\n            \"9cfae6ab0446da18e26f33e1d753bc1cc03585c100cf0ab5ef056695706fc8b0c\"\n            \"9c710cd73fe6e5beda70f515a96fabd3cc5ac49efcb2594b220ff3b603fcd927f\"\n            \"6a0838ef04bf52f3ed9eab801f09e5aed1613ddeb946ed0fbb02060b3a36fd\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1027 = RSAPrivateNumbers(\n    p=int(\n        \"30135e54cfb072c3d3eaf2000f3ed92ceafc85efc867b9d4bf5612f2978c432040093\"\n        \"4829f741c0f002b54af2a4433ff872b6321ef00ff1e72cba4e0ced937c7d\",\n        16,\n    ),\n    q=int(\n        \"1d01a8aead6f86b78c875f18edd74214e06535d65da054aeb8e1851d6f3319b4fb6d8\"\n        \"6b01e07d19f8261a1ded7dc08116345509ab9790e3f13e65c037e5bb7e27\",\n        16,\n    ),\n    d=int(\n        \"21cf4477df79561c7818731da9b9c88cd793f1b4b8e175bd0bfb9c0941a4dc648ecf1\"\n        \"6d96b35166c9ea116f4c2eb33ce1c231e641a37c25e54c17027bdec08ddafcb83642e\"\n        \"795a0dd133155ccc5eed03b6e745930d9ac7cfe91f9045149f33295af03a2198c660f\"\n        \"08d8150d13ce0e2eb02f21ac75d63b55822f77bd5be8d07619\",\n        16,\n    ),\n    dmp1=int(\n        \"173fb695931e845179511c18b546b265cb79b517c135902377281bdf9f34205e1f399\"\n        \"4603ad63e9f6e7885ea73a929f03fa0d6bed943051ce76cddde2d89d434d\",\n        16,\n    ),\n    dmq1=int(\n        \"10956b387b2621327da0c3c8ffea2af8be967ee25163222746c28115a406e632a7f12\"\n        \"5a9397224f1fa5c116cd3a313e5c508d31db2deb83b6e082d213e33f7fcf\",\n        16,\n    ),\n    iqmp=int(\n        \"234f833949f2c0d797bc6a0e906331e17394fa8fbc8449395766d3a8d222cf6167c48\"\n        \"8e7fe1fe9721d3e3b699a595c8e6f063d92bd840dbc84d763b2b37002109\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"57281707d7f9b1369c117911758980e32c05b133ac52c225bcf68b79157ff47ea\"\n            \"0a5ae9f579ef1fd7e42937f921eb3123c4a045cc47a2159fbbf904783e654954c\"\n            \"42294c30a95c15db7c7b91f136244e548f62474b137087346c5522e54f226f49d\"\n            \"6c93bc58cb39972e41bde452bb3ae9d60eb93e5e1ce91d222138d9890c7d0b\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1028 = RSAPrivateNumbers(\n    p=int(\n        \"359d17378fae8e9160097daee78a206bd52efe1b757c12a6da8026cc4fc4bb2620f12\"\n        \"b8254f4db6aed8228be8ee3e5a27ec7d31048602f01edb00befd209e8c75\",\n        16,\n    ),\n    q=int(\n        \"33a2e70b93d397c46e63b273dcd3dcfa64291342a6ce896e1ec8f1c0edc44106550f3\"\n        \"c06e7d3ca6ea29eccf3f6ab5ac6235c265313d6ea8e8767e6a343f616581\",\n        16,\n    ),\n    d=int(\n        \"880640088d331aa5c0f4cf2887809a420a2bc086e671e6ffe4e47a8c80792c038a314\"\n        \"9a8e45ef9a72816ab45b36e3af6800351067a6b2751843d4232413146bb575491463a\"\n        \"8addd06ce3d1bcf7028ec6c5d938c545a20f0a40214b5c574ca7e840062b2b5f8ed49\"\n        \"4b144bb2113677c4b10519177fee1d4f5fb8a1c159b0b47c01\",\n        16,\n    ),\n    dmp1=int(\n        \"75f8c52dad2c1cea26b8bba63236ee4059489e3d2db766136098bcc6b67fde8f77cd3\"\n        \"640035107bfb1ffc6480983cfb84fe0c3be008424ebc968a7db7e01f005\",\n        16,\n    ),\n    dmq1=int(\n        \"3893c59469e4ede5cd0e6ff9837ca023ba9b46ff40c60ccf1bec10f7d38db5b1ba817\"\n        \"6c41a3f750ec4203b711455aca06d1e0adffc5cffa42bb92c7cb77a6c01\",\n        16,\n    ),\n    iqmp=int(\n        \"ad32aafae3c962ac25459856dc8ef1f733c3df697eced29773677f435d186cf759d1a\"\n        \"5563dd421ec47b4d7e7f12f29647c615166d9c43fc49001b29089344f65\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"ad0696bef71597eb3a88e135d83c596930cac73868fbd7e6b2d64f34eea5c28cc\"\n            \"e3510c68073954d3ba4deb38643e7a820a4cf06e75f7f82eca545d412bd637819\"\n            \"45c28d406e95a6cced5ae924a8bfa4f3def3e0250d91246c269ec40c89c93a85a\"\n            \"cd3770ba4d2e774732f43abe94394de43fb57f93ca25f7a59d75d400a3eff5\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1029 = RSAPrivateNumbers(\n    p=int(\n        \"66f33e513c0b6b6adbf041d037d9b1f0ebf8de52812a3ac397a963d3f71ba64b3ad04\"\n        \"e4d4b5e377e6fa22febcac292c907dc8dcfe64c807fd9a7e3a698850d983\",\n        16,\n    ),\n    q=int(\n        \"3b47a89a19022461dcc2d3c05b501ee76955e8ce3cf821beb4afa85a21a26fd7203db\"\n        \"deb8941f1c60ada39fd6799f6c07eb8554113f1020460ec40e93cd5f6b21\",\n        16,\n    ),\n    d=int(\n        \"280c42af8b1c719821f2f6e2bf5f3dd53c81b1f3e1e7cc4fce6e2f830132da0665bde\"\n        \"bc1e307106b112b52ad5754867dddd028116cf4471bc14a58696b99524b1ad8f05b31\"\n        \"cf47256e54ab4399b6a073b2c0452441438dfddf47f3334c13c5ec86ece4d33409056\"\n        \"139328fafa992fb5f5156f25f9b21d3e1c37f156d963d97e41\",\n        16,\n    ),\n    dmp1=int(\n        \"198c7402a4ec10944c50ab8488d7b5991c767e75eb2817bd427dff10335ae141fa2e8\"\n        \"7c016dc22d975cac229b9ffdf7d943ddfd3a04b8bf82e83c3b32c5698b11\",\n        16,\n    ),\n    dmq1=int(\n        \"15fd30c7687b68ef7c2a30cdeb913ec56c4757c218cf9a04d995470797ee5f3a17558\"\n        \"fbb6d00af245d2631d893b382da48a72bc8a613024289895952ab245b0c1\",\n        16,\n    ),\n    iqmp=int(\n        \"4f8fde17e84557a3f4e242d889e898545ab55a1a8e075c9bb0220173ccffe84659abe\"\n        \"a235104f82e32750309389d4a52af57dbb6e48d831917b6efeb190176570\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"17d6e0a09aa5b2d003e51f43b9c37ffde74688f5e3b709fd02ef375cb6b8d15e2\"\n            \"99a9f74981c3eeaaf947d5c2d64a1a80f5c5108a49a715c3f7be95a016b8d3300\"\n            \"965ead4a4df76e642d761526803e9434d4ec61b10cb50526d4dcaef02593085de\"\n            \"d8c331c1b27b200a45628403065efcb2c0a0ca1f75d648d40a007fbfbf2cae3\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1030 = RSAPrivateNumbers(\n    p=int(\n        \"6f4ac8a8172ef1154cf7f80b5e91de723c35a4c512860bfdbafcc3b994a2384bf7796\"\n        \"3a2dd0480c7e04d5d418629651a0de8979add6f47b23da14c27a682b69c9\",\n        16,\n    ),\n    q=int(\n        \"65a9f83e07dea5b633e036a9dccfb32c46bf53c81040a19c574c3680838fc6d28bde9\"\n        \"55c0ff18b30481d4ab52a9f5e9f835459b1348bbb563ad90b15a682fadb3\",\n        16,\n    ),\n    d=int(\n        \"290db707b3e1a96445ae8ea93af55a9f211a54ebe52995c2eb28085d1e3f09c986e73\"\n        \"a00010c8e4785786eaaa5c85b98444bd93b585d0c24363ccc22c482e150a3fd900176\"\n        \"86968e4fa20423ae72823b0049defceccb39bb34aa4ef64e6b14463b76d6a871c859e\"\n        \"37285455b94b8e1527d1525b1682ac6f7c8fd79d576c55318c1\",\n        16,\n    ),\n    dmp1=int(\n        \"23f7fa84010225dea98297032dac5d45745a2e07976605681acfe87e0920a8ab3caf5\"\n        \"9d9602f3d63dc0584f75161fd8fff20c626c21c5e02a85282276a74628a9\",\n        16,\n    ),\n    dmq1=int(\n        \"18ebb657765464a8aa44bf019a882b72a2110a77934c54915f70e6375088b10331982\"\n        \"962bce1c7edd8ef9d3d95aa2566d2a99da6ebab890b95375919408d00f33\",\n        16,\n    ),\n    iqmp=int(\n        \"3d59d208743c74054151002d77dcdfc55af3d41357e89af88d7eef2767be54c290255\"\n        \"9258d85cf2a1083c035a33e65a1ca46dc8b706847c1c6434cef7b71a9dae\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"2c326574320818a6a8cb6b3328e2d6c1ba2a3f09b6eb2bc543c03ab18eb5efdaa\"\n            \"8fcdbb6b4e12168304f587999f9d96a421fc80cb933a490df85d25883e6a88750\"\n            \"d6bd8b3d4117251eee8f45e70e6daac7dbbd92a9103c623a09355cf00e3f16168\"\n            \"e38b9c4cb5b368deabbed8df466bc6835eaba959bc1c2f4ec32a09840becc8b\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1031 = RSAPrivateNumbers(\n    p=int(\n        \"c0958c08e50137db989fb7cc93abf1984543e2f955d4f43fb2967f40105e79274c852\"\n        \"293fa06ce63ca8436155e475ed6d1f73fea4c8e2516cc79153e3dc83e897\",\n        16,\n    ),\n    q=int(\n        \"78cae354ea5d6862e5d71d20273b7cddb8cdfab25478fe865180676b04250685c4d03\"\n        \"30c216574f7876a7b12dfe69f1661d3b0cea6c2c0dcfb84050f817afc28d\",\n        16,\n    ),\n    d=int(\n        \"1d55cc02b17a5d25bfb39f2bc58389004d0d7255051507f75ef347cdf5519d1a00f4b\"\n        \"d235ce4171bfab7bdb7a6dcfae1cf41433fb7da5923cc84f15a675c0b83492c95dd99\"\n        \"a9fc157aea352ffdcbb5d59dbc3662171d5838d69f130678ee27841a79ef64f679ce9\"\n        \"3821fa69c03f502244c04b737edad8967def8022a144feaab29\",\n        16,\n    ),\n    dmp1=int(\n        \"5b1c2504ec3a984f86b4414342b5bcf59a0754f13adf25b2a0edbc43f5ba8c3cc061d\"\n        \"80b03e5866d059968f0d10a98deaeb4f7830436d76b22cf41f2914e13eff\",\n        16,\n    ),\n    dmq1=int(\n        \"6c361e1819691ab5d67fb2a8f65c958d301cdf24d90617c68ec7005edfb4a7b638cde\"\n        \"79d4b61cfba5c86e8c0ccf296bc7f611cb8d4ae0e072a0f68552ec2d5995\",\n        16,\n    ),\n    iqmp=int(\n        \"b7d61945fdc8b92e075b15554bab507fa8a18edd0a18da373ec6c766c71eece61136a\"\n        \"84b90b6d01741d40458bfad17a9bee9d4a8ed2f6e270782dc3bf5d58b56e\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"5adebaa926ea11fb635879487fdd53dcfbb391a11ac7279bb3b4877c9b811370a\"\n            \"9f73da0690581691626d8a7cf5d972cced9c2091ccf999024b23b4e6dc6d99f80\"\n            \"a454737dec0caffaebe4a3fac250ed02079267c8f39620b5ae3e125ca35338522\"\n            \"dc9353ecac19cb2fe3b9e3a9291619dbb1ea3a7c388e9ee6469fbf5fb22892b\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_1536 = RSAPrivateNumbers(\n    p=int(\n        \"f1a65fa4e2aa6e7e2b560251e8a4cd65b625ad9f04f6571785782d1c213d91c961637\"\n        \"0c572f2783caf2899f7fb690cf99a0184257fbd4b071b212c88fb348279a5387e61f1\"\n        \"17e9c62980c45ea863fa9292087c0f66ecdcde6443d5a37268bf71\",\n        16,\n    ),\n    q=int(\n        \"e54c2cbc3839b1da6ae6fea45038d986d6f523a3ae76051ba20583aab711ea5965cf5\"\n        \"3cf54128cc9573f7460bba0fd6758a57aaf240c391790fb38ab473d83ef735510c53d\"\n        \"1d10c31782e8fd7da42615e33565745c30a5e6ceb2a3ae0666cc35\",\n        16,\n    ),\n    d=int(\n        \"7bcad87e23da2cb2a8c328883fabce06e1f8e9b776c8bf253ad9884e6200e3bd9bd3b\"\n        \"a2cbe87d3854527bf005ba5d878c5b0fa20cfb0a2a42884ae95ca12bf7304285e9214\"\n        \"5e992f7006c7c0ae839ad550da495b143bec0f4806c7f44caed45f3ccc6dc44cfaf30\"\n        \"7abdb757e3d28e41c2d21366835c0a41e50a95af490ac03af061d2feb36ac0afb87be\"\n        \"a13fb0f0c5a410727ebedb286c77f9469473fae27ef2c836da6071ef7efc1647f1233\"\n        \"4009a89eecb09a8287abc8c2afd1ddd9a1b0641\",\n        16,\n    ),\n    dmp1=int(\n        \"a845366cd6f9df1f34861bef7594ed025aa83a12759e245f58adaa9bdff9c3befb760\"\n        \"75d3701e90038e888eec9bf092df63400152cb25fc07effc6c74c45f0654ccbde15cd\"\n        \"90dd5504298a946fa5cf22a956072da27a6602e6c6e5c97f2db9c1\",\n        16,\n    ),\n    dmq1=int(\n        \"28b0c1e78cdac03310717992d321a3888830ec6829978c048156152d805b4f8919c61\"\n        \"70b5dd204e5ddf3c6c53bc6aff15d0bd09faff7f351b94abb9db980b31f150a6d7573\"\n        \"08eb66938f89a5225cb4dd817a824c89e7a0293b58fc2eefb7e259\",\n        16,\n    ),\n    iqmp=int(\n        \"6c1536c0e16e42a094b6caaf50231ba81916871497d73dcbbbd4bdeb9e60cae0413b3\"\n        \"8143b5d680275b29ed7769fe5577e4f9b3647ddb064941120914526d64d80016d2eb7\"\n        \"dc362da7c569623157f3d7cff8347f11494bf5c048d77e28d3f515\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"d871bb2d27672e54fc62c4680148cbdf848438da804e2c48b5a9c9f9daf6cc6e8\"\n            \"ea7d2296f25064537a9a542aef3dd449ea75774238d4da02c353d1bee70013dcc\"\n            \"c248ceef4050160705c188043c8559bf6dbfb6c4bb382eda4e9547575a8227d5b\"\n            \"3c0a7088391364cf9f018d8bea053b226ec65e8cdbeaf48a071d0074860a734b1\"\n            \"cb7d2146d43014b20776dea42f7853a54690e6cbbf3331a9f43763cfe2a51c329\"\n            \"3bea3b2eebec0d8e43eb317a443afe541107d886e5243c096091543ae65\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_2048 = RSAPrivateNumbers(\n    p=int(\n        \"e14202e58c5f7446648d75e5dc465781f661f6b73000c080368afcfb21377f4ef19da\"\n        \"845d4ef9bc6b151f6d9f34629103f2e57615f9ba0a3a2fbb035069e1d63b4bb0e78ad\"\n        \"dad1ec3c6f87e25c877a1c4c1972098e09158ef7b9bc163852a18d44a70b7b31a03dc\"\n        \"2614fd9ab7bf002cba79054544af3bfbdb6aed06c7b24e6ab\",\n        16,\n    ),\n    q=int(\n        \"dbe2bea1ff92599bd19f9d045d6ce62250c05cfeac5117f3cf3e626cb696e3d886379\"\n        \"557d5a57b7476f9cf886accfd40508a805fe3b45a78e1a8a125e516cda91640ee6398\"\n        \"ec5a39d3e6b177ef12ab00d07907a17640e4ca454fd8487da3c4ffa0d5c2a5edb1221\"\n        \"1c8e33c7ee9fa6753771fd111ec04b8317f86693eb2928c89\",\n        16,\n    ),\n    d=int(\n        \"aef17f80f2653bc30539f26dd4c82ed6abc1d1b53bc0abcdbee47e9a8ab433abde865\"\n        \"9fcfae1244d22de6ad333c95aee7d47f30b6815065ac3322744d3ea75058002cd1b29\"\n        \"3141ee2a6dc682342432707080071bd2131d6262cab07871c28aa5238b87173fb78c3\"\n        \"7f9c7bcd18c12e8971bb77fd9fa3e0792fec18d8d9bed0b03ba02b263606f24dbace1\"\n        \"c8263ce2802a769a090e993fd49abc50c3d3c78c29bee2de0c98055d2f102f1c5684b\"\n        \"8dddee611d5205392d8e8dd61a15bf44680972a87f040a611a149271eeb2573f8bf6f\"\n        \"627dfa70e77def2ee6584914fa0290e041349ea0999cdff3e493365885b906cbcf195\"\n        \"843345809a85098cca90fea014a21\",\n        16,\n    ),\n    dmp1=int(\n        \"9ba56522ffcfa5244eae805c87cc0303461f82be29691b9a7c15a5a050df6c143c575\"\n        \"7c288d3d7ab7f32c782e9d9fcddc10a604e6425c0e5d0e46069035d95a923646d276d\"\n        \"d9d95b8696fa29ab0de18e53f6f119310f8dd9efca62f0679291166fed8cbd5f18fe1\"\n        \"3a5f1ead1d71d8c90f40382818c18c8d069be793dbc094f69\",\n        16,\n    ),\n    dmq1=int(\n        \"a8d4a0aaa2212ccc875796a81353da1fdf00d46676c88d2b96a4bfcdd924622d8e607\"\n        \"f3ac1c01dda7ebfb0a97dd7875c2a7b2db6728fb827b89c519f5716fb3228f4121647\"\n        \"04b30253c17de2289e9cce3343baa82eb404f789e094a094577a9b0c5314f1725fdf5\"\n        \"8e87611ad20da331bd30b8aebc7dc97d0e9a9ba8579772c9\",\n        16,\n    ),\n    iqmp=int(\n        \"17bd5ef638c49440d1853acb3fa63a5aca28cb7f94ed350db7001c8445da8943866a7\"\n        \"0936e1ee2716c98b484e357cc054d82fbbd98d42f880695d38a1dd4eb096f629b9417\"\n        \"aca47e6de5da9f34e60e8a0ffd7e35be74deeef67298d94b3e0db73fc4b7a4cb360c8\"\n        \"9d2117a0bfd9434d37dc7c027d6b01e5295c875015510917d\",\n        16,\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"c17afc7e77474caa5aa83036158a3ffbf7b5216851ba2230e5d6abfcc1c6cfef5\"\n            \"9e923ea1330bc593b73802ab608a6e4a3306523a3116ba5aa3966145174e13b6c\"\n            \"49e9b78062e449d72efb10fd49e91fa08b96d051e782e9f5abc5b5a6f7984827a\"\n            \"db8e73da00f22b2efdcdb76eab46edad98ed65662743fdc6c0e336a5d0cdbaa7d\"\n            \"c29e53635e24c87a5b2c4215968063cdeb68a972babbc1e3cff00fb9a80e372a4\"\n            \"d0c2c920d1e8cee333ce470dc2e8145adb05bf29aee1d24f141e8cc784989c587\"\n            \"fc6fbacd979f3f2163c1d7299b365bc72ffe2848e967aed1e48dcc515b3a50ed4\"\n            \"de04fd053846ca10a223b10cc841cc80fdebee44f3114c13e886af583\",\n            16,\n        ),\n    ),\n)\n\nRSA_KEY_2048_ALT = RSAPrivateNumbers(\n    d=int(\n        \"7522768467449591813737881904131688860626637897199391200040629\"\n        \"8641018746450502628484395471408986929218353894683769457466923\"\n        \"3079369551423094451013669595729568593462009746342148367797495\"\n        \"5529909313614750246672441810743580455199636293179539903480635\"\n        \"3091286716112931976896334411287175213124504134181121011488550\"\n        \"5290054443979198998564749640800633368957384058700741073997703\"\n        \"8877364695937023906368630297588990131009278072614118207348356\"\n        \"4640244134189285070202534488517371577359510236833464698189075\"\n        \"5160693085297816063285814039518178249628112908466649245545732\"\n        \"5791532385553960363601827996980725025898649392004494256400884\"\n        \"092073\"\n    ),\n    dmp1=int(\n        \"5847872614112935747739644055317429405973942336206460017493394\"\n        \"9737607778799766591021036792892472774720417920838206576785118\"\n        \"8889624058962939702950175807073343659386156232294197300491647\"\n        \"1029508414050591959344812347424476498076532682798598325230069\"\n        \"0925827594762920534235575029199380552228825468180187156871965\"\n        \"973\"\n    ),\n    dmq1=int(\n        \"2949536259161239302081155875068405238857801001054083407704879\"\n        \"8210876832264504685327766351157044892283801611558399025326793\"\n        \"4131638001934454489864437565651739832511702151461257267169691\"\n        \"6611992398459006200708626815153304591390855807749769768978152\"\n        \"9854112656599931724820610358669306523835327459478374630794532\"\n        \"167\"\n    ),\n    iqmp=int(\n        \"7331180989818931535458916053540252830484856703208982675535284\"\n        \"4613815808798190559315018094080936347757336989616401164752221\"\n        \"8101156529898067044923499386460167055405998646366011838018441\"\n        \"3678947694258190172377716154009305082091341215866326061721180\"\n        \"3836418654472188816187630316821692982783286322262994892003058\"\n        \"782\"\n    ),\n    p=int(\n        \"1460007723851883695617573533155574746587863843382715314919865\"\n        \"2434108956187429726002840717317310431378483921058946835896252\"\n        \"7109559207437158778332364464259678946305487699031865937075508\"\n        \"8616612925453842458055546540240601585731206561647892336916583\"\n        \"0023641764106581040198845259766246869529221084602380669333021\"\n        \"0819\"\n    ),\n    q=int(\n        \"1433897765867889178402883410610177836503402597775250087462018\"\n        \"4617952933433119527945447840336616357136736935069377619782227\"\n        \"2822380830300262175671282877680573202309319960687756231128996\"\n        \"9764855320953993690199846269451095044922353809602378616938811\"\n        \"7513900906279873343591486841303392490561500301994171338761080\"\n        \"4439\"\n    ),\n    public_numbers=RSAPublicNumbers(\n        e=65537,\n        n=int(\n            \"209350181338107812610165420955871971489973659392253291327\"\n            \"839812910252466502190690572476688311285621239204212139711\"\n            \"207388949164851984253143698667018532039612470954223918242\"\n            \"145976986600705122576087630525229796950722166468064721258\"\n            \"490916138706756006902066136471049807637157890128560592039\"\n            \"941717275079733754782848729566190631725183735944031456237\"\n            \"089928120178187552521649483240599003240074352860189285952\"\n            \"078970127554801074176375499583703254849309993132931268013\"\n            \"715070507278514207864914944621214574162116786377990456375\"\n            \"964817771730371110612100247262908550409785456157505694419\"\n            \"00451152778245269283276012328748538414051025541\"\n        ),\n    ),\n)\n\nRSA_KEY_CORRUPTED = b\"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMIIEpQIBAAKCAQEAuYE4k09MAsi1yjMrXekMe6sT9bEt3ko47dnmN8YBgO8DiiCc\n226TnQPvuX3FGxU+Y1zTJpcvVL3L37UOvh4CSb9zKyrFK9/x/UcCfK3Eq8JdS98P\nCVeGpkp5E+vwIKY72rc1RSSSCs0PtFdYbSn4trwf5BjPxIqXwIOS3R7zC7cLPHY4\nYdsM4gLGVOP17uXJr/MPoAtWTBVm5zx4bHm6Xclzgf86sbPdL3LxNs0fz4HqJZgA\n6EUtyl6Qypq2LjXbdmm2i3vC+MxW6nEPItPqgComhq0zBmVonsiEO87rEtD548Yq\nDKvxwHhlcODcVkAYebJ+W5L6PPJBNYA3t5wYyQIDAQABAoIBAAbHkg5msftpGt5Z\nVb3yUuepem7hWTF5YFlIRw5l2wNcURNpbswEhOVNJbuG+KCple7Dw4TuDmhHs/zr\nBRqpDhXldhrUtb2uc3ihqWiVFJbieqE4jUbGvMJusvtXXeDwU6wGWzV/V4qndCrk\nu4PGypk4Cbbq6ZP2oufPryQ3D4Ff1TA06RSWdP3Cg673VqwLtkXwsRDhymAviiqU\nhxQg8bRNiD7mYoUKyLVeV7YRDLTBugfiFmy54yC99NJclLkYmzCgRt1EuoW0Hixx\nEIQFEOLftgpc+sKpbbiOileMsc/stytHXXqfgozhBxDNeSzdNYfwEpkLJpLZSUNV\nEhS4X1cCgYEAz+7DkXksWw9zLqYniMIcvcBnHQcy3Anqbcu8Zbw+I9wOwzNt44Bo\nf88i2idvWvMsRq/LX4WD4jjPB4Z3wAzGBCq+2cy0GrWByMu+VbpwCrntRBkS5huY\nIIf1nr1+BuySNt8TL6nZNKz0D8+5c8wT+VbVdPH//4MzfDrK81PPnesCgYEA5GMy\nji4l+8zO33LFMlWQGYgfSMd4jGMQD0VCvfhlosK0Py0AfZj/GKEGHduo/37KVVvb\n6XdJqYgB7OxPmdEqbMGeYPKv7pKkG1jXRuEtmXXJ9hS1t0oIvXJLHJnQrOOoRRAR\n+xJZbI7WjemY+ZCMOAPT1tm97pxjs81WgSJ6ExsCgYEAze5ADfEeNskkYAz6lnz4\njgzhkmQwwK+pVzgxy9g8brNkg3qJ2Iix9fKlJ71qkX7IWPF9z4qhxQhSMbfBHZkI\n+9OB1J7huJoOgVkXliwIbvcYvxq+Fts5XO6KGb699AmT/XgMvmXO0lbAGLC3kLGL\nDqQrH3kU+m9sLBrmKPrWYiUCgYEA3/8etW4zmMvd1jAFkoFyzGfCbyocZGxAcwm2\nFQYMAN8/03p6sbSd9XTwv9YR4Uxke+WURkjVuW2IneuDgtQv6QCFKob74Jx4Uc4H\njiAKDioFg9H6C6OUAOKZIpsFnJvIDLxfNkVf6WYKrrL+cz6/F61BVsbGTsGZ094/\nynWbDyMCgYEAh44C/wkebe0zz/llG+KTRGENsw1c7+pm0/l3wPYAlH02ewbyRjFf\nOKPfyyBtBkoD5rG3IbLyPxsbd3wWwyUzSYq02qRJq43XqyMZhRnNlYhEnNu/Gr5H\nsN1f13zqkKoRxxbIjyh4RDYlAv4Sehk27z2Q3gBe9bI5xKkoQ/VfF2w=\n-----END RSA PRIVATE KEY-----\n\"\"\"\n", "tests/hazmat/primitives/test_aes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\nfrom ...doubles import DummyMode\nfrom ...utils import load_nist_vectors\nfrom .utils import _load_all_params, generate_encrypt_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 32), modes.XTS(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES XTS\",\n)\nclass TestAESModeXTS:\n    def test_xts_vectors(self, backend, subtests):\n        # This list comprehension excludes any vector that does not have a\n        # data unit length that is divisible by 8. The NIST vectors include\n        # tests for implementations that support encryption of data that is\n        # not divisible modulo 8, but OpenSSL is not such an implementation.\n        vectors = [\n            x\n            for x in _load_all_params(\n                os.path.join(\"ciphers\", \"AES\", \"XTS\", \"tweak-128hexstr\"),\n                [\"XTSGenAES128.rsp\", \"XTSGenAES256.rsp\"],\n                load_nist_vectors,\n            )\n            if int(x[\"dataunitlen\"]) / 8.0 == int(x[\"dataunitlen\"]) // 8\n        ]\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                tweak = binascii.unhexlify(vector[\"i\"])\n                pt = binascii.unhexlify(vector[\"pt\"])\n                ct = binascii.unhexlify(vector[\"ct\"])\n                cipher = base.Cipher(\n                    algorithms.AES(key), modes.XTS(tweak), backend\n                )\n                enc = cipher.encryptor()\n                computed_ct = enc.update(pt) + enc.finalize()\n                assert computed_ct == ct\n                dec = cipher.decryptor()\n                computed_pt = dec.update(ct) + dec.finalize()\n                assert computed_pt == pt\n\n    def test_xts_too_short(self, backend):\n        key = b\"thirty_two_byte_keys_are_great!!\"\n        tweak = b\"\\x00\" * 16\n        cipher = base.Cipher(algorithms.AES(key), modes.XTS(tweak))\n        enc = cipher.encryptor()\n        with pytest.raises(ValueError):\n            enc.update(b\"0\" * 15)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL,\n        skip_message=\"duplicate key encryption error added in OpenSSL 1.1.1d\",\n    )\n    def test_xts_no_duplicate_keys_encryption(self, backend):\n        key = bytes(range(16)) * 2\n        tweak = b\"\\x00\" * 16\n        cipher = base.Cipher(algorithms.AES(key), modes.XTS(tweak))\n        with pytest.raises(ValueError, match=\"duplicated keys\"):\n            cipher.encryptor()\n\n    def test_xts_unsupported_with_aes128_aes256_classes(self):\n        with pytest.raises(TypeError):\n            base.Cipher(algorithms.AES128(b\"0\" * 16), modes.XTS(b\"\\x00\" * 16))\n\n        with pytest.raises(TypeError):\n            base.Cipher(algorithms.AES256(b\"0\" * 32), modes.XTS(b\"\\x00\" * 16))\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CBC\",\n)\nclass TestAESModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"CBC\"),\n        [\n            \"CBCGFSbox128.rsp\",\n            \"CBCGFSbox192.rsp\",\n            \"CBCGFSbox256.rsp\",\n            \"CBCKeySbox128.rsp\",\n            \"CBCKeySbox192.rsp\",\n            \"CBCKeySbox256.rsp\",\n            \"CBCVarKey128.rsp\",\n            \"CBCVarKey192.rsp\",\n            \"CBCVarKey256.rsp\",\n            \"CBCVarTxt128.rsp\",\n            \"CBCVarTxt192.rsp\",\n            \"CBCVarTxt256.rsp\",\n            \"CBCMMT128.rsp\",\n            \"CBCMMT192.rsp\",\n            \"CBCMMT256.rsp\",\n        ],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support AES ECB\",\n)\nclass TestAESModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"ECB\"),\n        [\n            \"ECBGFSbox128.rsp\",\n            \"ECBGFSbox192.rsp\",\n            \"ECBGFSbox256.rsp\",\n            \"ECBKeySbox128.rsp\",\n            \"ECBKeySbox192.rsp\",\n            \"ECBKeySbox256.rsp\",\n            \"ECBVarKey128.rsp\",\n            \"ECBVarKey192.rsp\",\n            \"ECBVarKey256.rsp\",\n            \"ECBVarTxt128.rsp\",\n            \"ECBVarTxt192.rsp\",\n            \"ECBVarTxt256.rsp\",\n            \"ECBMMT128.rsp\",\n            \"ECBMMT192.rsp\",\n            \"ECBMMT256.rsp\",\n        ],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES OFB\",\n)\nclass TestAESModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"OFB\"),\n        [\n            \"OFBGFSbox128.rsp\",\n            \"OFBGFSbox192.rsp\",\n            \"OFBGFSbox256.rsp\",\n            \"OFBKeySbox128.rsp\",\n            \"OFBKeySbox192.rsp\",\n            \"OFBKeySbox256.rsp\",\n            \"OFBVarKey128.rsp\",\n            \"OFBVarKey192.rsp\",\n            \"OFBVarKey256.rsp\",\n            \"OFBVarTxt128.rsp\",\n            \"OFBVarTxt192.rsp\",\n            \"OFBVarTxt256.rsp\",\n            \"OFBMMT128.rsp\",\n            \"OFBMMT192.rsp\",\n            \"OFBMMT256.rsp\",\n        ],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CFB\",\n)\nclass TestAESModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"CFB\"),\n        [\n            \"CFB128GFSbox128.rsp\",\n            \"CFB128GFSbox192.rsp\",\n            \"CFB128GFSbox256.rsp\",\n            \"CFB128KeySbox128.rsp\",\n            \"CFB128KeySbox192.rsp\",\n            \"CFB128KeySbox256.rsp\",\n            \"CFB128VarKey128.rsp\",\n            \"CFB128VarKey192.rsp\",\n            \"CFB128VarKey256.rsp\",\n            \"CFB128VarTxt128.rsp\",\n            \"CFB128VarTxt192.rsp\",\n            \"CFB128VarTxt256.rsp\",\n            \"CFB128MMT128.rsp\",\n            \"CFB128MMT192.rsp\",\n            \"CFB128MMT256.rsp\",\n        ],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.CFB8(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CFB8\",\n)\nclass TestAESModeCFB8:\n    test_cfb8 = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"CFB\"),\n        [\n            \"CFB8GFSbox128.rsp\",\n            \"CFB8GFSbox192.rsp\",\n            \"CFB8GFSbox256.rsp\",\n            \"CFB8KeySbox128.rsp\",\n            \"CFB8KeySbox192.rsp\",\n            \"CFB8KeySbox256.rsp\",\n            \"CFB8VarKey128.rsp\",\n            \"CFB8VarKey192.rsp\",\n            \"CFB8VarKey256.rsp\",\n            \"CFB8VarTxt128.rsp\",\n            \"CFB8VarTxt192.rsp\",\n            \"CFB8VarTxt256.rsp\",\n            \"CFB8MMT128.rsp\",\n            \"CFB8MMT192.rsp\",\n            \"CFB8MMT256.rsp\",\n        ],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.CTR(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support AES CTR\",\n)\nclass TestAESModeCTR:\n    test_ctr = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"CTR\"),\n        [\"aes-128-ctr.txt\", \"aes-192-ctr.txt\", \"aes-256-ctr.txt\"],\n        lambda key, **kwargs: algorithms.AES(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CTR(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.parametrize(\n    \"mode\",\n    [\n        modes.CBC(bytearray(b\"\\x00\" * 16)),\n        modes.CTR(bytearray(b\"\\x00\" * 16)),\n        modes.OFB(bytearray(b\"\\x00\" * 16)),\n        modes.CFB(bytearray(b\"\\x00\" * 16)),\n        modes.CFB8(bytearray(b\"\\x00\" * 16)),\n        modes.XTS(bytearray(b\"\\x00\" * 16)),\n        # Add a dummy mode for coverage of the cipher_supported check.\n        DummyMode(),\n    ],\n)\ndef test_buffer_protocol_alternate_modes(mode, backend):\n    data = bytearray(b\"sixteen_byte_msg\")\n    key = algorithms.AES(bytearray(os.urandom(32)))\n    if not backend.cipher_supported(key, mode):\n        pytest.skip(f\"AES in {mode.name} mode not supported\")\n    cipher = base.Cipher(key, mode, backend)\n    enc = cipher.encryptor()\n    ct = enc.update(data) + enc.finalize()\n    dec = cipher.decryptor()\n    pt = dec.update(ct) + dec.finalize()\n    assert pt == data\n\n\n@pytest.mark.parametrize(\n    \"mode\",\n    [\n        modes.ECB(),\n        modes.CBC(bytearray(b\"\\x00\" * 16)),\n        modes.CTR(bytearray(b\"\\x00\" * 16)),\n        modes.OFB(bytearray(b\"\\x00\" * 16)),\n        modes.CFB(bytearray(b\"\\x00\" * 16)),\n        modes.CFB8(bytearray(b\"\\x00\" * 16)),\n    ],\n)\n@pytest.mark.parametrize(\"alg_cls\", [algorithms.AES128, algorithms.AES256])\ndef test_alternate_aes_classes(mode, alg_cls, backend):\n    alg = alg_cls(b\"0\" * (alg_cls.key_size // 8))\n    if not backend.cipher_supported(alg, mode):\n        pytest.skip(f\"AES in {mode.name} mode not supported\")\n    data = bytearray(b\"sixteen_byte_msg\")\n    cipher = base.Cipher(alg, mode, backend)\n    enc = cipher.encryptor()\n    ct = enc.update(data) + enc.finalize()\n    dec = cipher.decryptor()\n    pt = dec.update(ct) + dec.finalize()\n    assert pt == data\n", "tests/hazmat/primitives/test_hkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand\n\nfrom ...utils import load_nist_vectors, load_vectors_from_file\n\n\nclass TestHKDF:\n    def test_length_limit(self, backend):\n        big_length = 255 * hashes.SHA256().digest_size + 1\n\n        with pytest.raises(ValueError):\n            HKDF(\n                hashes.SHA256(),\n                big_length,\n                salt=None,\n                info=None,\n                backend=backend,\n            )\n\n    def test_already_finalized(self, backend):\n        hkdf = HKDF(hashes.SHA256(), 16, salt=None, info=None, backend=backend)\n\n        hkdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"\\x02\" * 16)\n\n        hkdf = HKDF(hashes.SHA256(), 16, salt=None, info=None, backend=backend)\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n        hkdf = HKDF(hashes.SHA256(), 16, salt=None, info=None, backend=backend)\n\n    def test_verify(self, backend):\n        hkdf = HKDF(hashes.SHA256(), 16, salt=None, info=None, backend=backend)\n\n        hkdf.verify(b\"\\x01\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_verify_invalid(self, backend):\n        hkdf = HKDF(hashes.SHA256(), 16, salt=None, info=None, backend=backend)\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(b\"\\x02\" * 16, b\"gJ\\xfb{\\xb1Oi\\xc5sMC\\xb7\\xe4@\\xf7u\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=\"foo\",  # type: ignore[arg-type]\n                info=None,\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            HKDF(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                info=\"foo\",  # type: ignore[arg-type]\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(), 16, salt=None, info=None, backend=backend\n            )\n\n            hkdf.derive(\"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(), 16, salt=None, info=None, backend=backend\n            )\n\n            hkdf.verify(\"foo\", b\"bar\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            hkdf = HKDF(\n                hashes.SHA256(), 16, salt=None, info=None, backend=backend\n            )\n\n            hkdf.verify(b\"foo\", \"bar\")  # type: ignore[arg-type]\n\n    def test_derive_short_output(self, backend):\n        hkdf = HKDF(hashes.SHA256(), 4, salt=None, info=None, backend=backend)\n\n        assert hkdf.derive(b\"\\x01\" * 16) == b\"gJ\\xfb{\"\n\n    def test_derive_long_output(self, backend):\n        vector = load_vectors_from_file(\n            os.path.join(\"KDF\", \"hkdf-generated.txt\"), load_nist_vectors\n        )[0]\n        hkdf = HKDF(\n            hashes.SHA256(),\n            int(vector[\"l\"]),\n            salt=vector[\"salt\"],\n            info=vector[\"info\"],\n            backend=backend,\n        )\n        ikm = binascii.unhexlify(vector[\"ikm\"])\n\n        assert hkdf.derive(ikm) == binascii.unhexlify(vector[\"okm\"])\n\n    def test_buffer_protocol(self, backend):\n        vector = load_vectors_from_file(\n            os.path.join(\"KDF\", \"hkdf-generated.txt\"), load_nist_vectors\n        )[0]\n        hkdf = HKDF(\n            hashes.SHA256(),\n            int(vector[\"l\"]),\n            salt=vector[\"salt\"],\n            info=vector[\"info\"],\n            backend=backend,\n        )\n        ikm = bytearray(binascii.unhexlify(vector[\"ikm\"]))\n\n        assert hkdf.derive(ikm) == binascii.unhexlify(vector[\"okm\"])\n\n\nclass TestHKDFExpand:\n    def test_derive(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (\n            b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n            b\"5bf34007208d5b887185865\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert binascii.hexlify(hkdf.derive(prk)) == okm\n\n    def test_buffer_protocol(self, backend):\n        prk = bytearray(\n            binascii.unhexlify(\n                b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2\"\n                b\"b3e5\"\n            )\n        )\n\n        okm = (\n            b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n            b\"5bf34007208d5b887185865\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        assert binascii.hexlify(hkdf.derive(prk)) == okm\n\n    def test_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        okm = (\n            b\"3cb25f25faacd57a90434f64d0362f2a2d2d0a90cf1a5a4c5db02d56ecc4c\"\n            b\"5bf34007208d5b887185865\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        hkdf.verify(prk, binascii.unhexlify(okm))\n\n    def test_invalid_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"077709362c2e32df0ddc3f0dc47bba6390b6c73bb50f9c3122ec844ad7c2b3e5\"\n        )\n\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(InvalidKey):\n            hkdf.verify(prk, b\"wrong key\")\n\n    def test_already_finalized(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        hkdf.derive(b\"first\")\n\n        with pytest.raises(AlreadyFinalized):\n            hkdf.derive(b\"second\")\n\n    def test_unicode_error(self, backend):\n        info = binascii.unhexlify(b\"f0f1f2f3f4f5f6f7f8f9\")\n        hkdf = HKDFExpand(hashes.SHA256(), 42, info, backend)\n\n        with pytest.raises(TypeError):\n            hkdf.derive(\"first\")  # type: ignore[arg-type]\n", "tests/hazmat/primitives/test_constant_time.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import constant_time\n\n\nclass TestConstantTimeBytesEq:\n    def test_reject_unicode(self):\n        with pytest.raises(TypeError):\n            constant_time.bytes_eq(b\"foo\", \"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            constant_time.bytes_eq(\"foo\", b\"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            constant_time.bytes_eq(\"foo\", \"foo\")  # type: ignore[arg-type]\n\n    def test_compares(self):\n        assert constant_time.bytes_eq(b\"foo\", b\"foo\") is True\n\n        assert constant_time.bytes_eq(b\"foo\", b\"bar\") is False\n\n        assert constant_time.bytes_eq(b\"foobar\", b\"foo\") is False\n\n        assert constant_time.bytes_eq(b\"foo\", b\"foobar\") is False\n", "tests/hazmat/primitives/fixtures_dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography.hazmat.primitives.asymmetric import dh\n\nFFDH3072_P = dh.DHParameterNumbers(\n    p=int(\n        \"ffffffffffffffffadf85458a2bb4a9aafdc5620273d3cf1d8b9c583ce2d3695a9e\"\n        \"13641146433fbcc939dce249b3ef97d2fe363630c75d8f681b202aec4617ad3df1e\"\n        \"d5d5fd65612433f51f5f066ed0856365553ded1af3b557135e7f57c935984f0c70e\"\n        \"0e68b77e2a689daf3efe8721df158a136ade73530acca4f483a797abc0ab182b324\"\n        \"fb61d108a94bb2c8e3fbb96adab760d7f4681d4f42a3de394df4ae56ede76372bb1\"\n        \"90b07a7c8ee0a6d709e02fce1cdf7e2ecc03404cd28342f619172fe9ce98583ff8e\"\n        \"4f1232eef28183c3fe3b1b4c6fad733bb5fcbc2ec22005c58ef1837d1683b2c6f34\"\n        \"a26c1b2effa886b4238611fcfdcde355b3b6519035bbc34f4def99c023861b46fc9\"\n        \"d6e6c9077ad91d2691f7f7ee598cb0fac186d91caefe130985139270b4130c93bc4\"\n        \"37944f4fd4452e2d74dd364f2e21e71f54bff5cae82ab9c9df69ee86d2bc522363a\"\n        \"0dabc521979b0deada1dbf9a42d5c4484e0abcd06bfa53ddef3c1b20ee3fd59d7c2\"\n        \"5e41d2b66c62e37ffffffffffffffff\",\n        16,\n    ),\n    g=2,\n)\n", "tests/hazmat/primitives/test_hashes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, _Reasons\nfrom cryptography.hazmat.primitives import hashes\n\nfrom ...doubles import DummyHashAlgorithm\nfrom ...utils import raises_unsupported_algorithm\nfrom .utils import generate_base_hash_test\n\n\nclass TestHashContext:\n    def test_hash_reject_unicode(self, backend):\n        m = hashes.Hash(hashes.SHA1(), backend=backend)\n        with pytest.raises(TypeError):\n            m.update(\"\\u00fc\")  # type: ignore[arg-type]\n\n    def test_hash_algorithm_instance(self, backend):\n        with pytest.raises(TypeError):\n            hashes.Hash(hashes.SHA1, backend=backend)  # type: ignore[arg-type]\n\n    def test_raises_after_finalize(self, backend):\n        h = hashes.Hash(hashes.SHA1(), backend=backend)\n        h.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            h.update(b\"foo\")\n\n        with pytest.raises(AlreadyFinalized):\n            h.copy()\n\n        with pytest.raises(AlreadyFinalized):\n            h.finalize()\n\n    def test_unsupported_hash(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            hashes.Hash(DummyHashAlgorithm(), backend)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA1\",\n)\nclass TestSHA1:\n    test_sha1 = generate_base_hash_test(\n        hashes.SHA1(),\n        digest_size=20,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA224()),\n    skip_message=\"Does not support SHA224\",\n)\nclass TestSHA224:\n    test_sha224 = generate_base_hash_test(\n        hashes.SHA224(),\n        digest_size=28,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA256()),\n    skip_message=\"Does not support SHA256\",\n)\nclass TestSHA256:\n    test_sha256 = generate_base_hash_test(\n        hashes.SHA256(),\n        digest_size=32,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA384()),\n    skip_message=\"Does not support SHA384\",\n)\nclass TestSHA384:\n    test_sha384 = generate_base_hash_test(\n        hashes.SHA384(),\n        digest_size=48,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA512()),\n    skip_message=\"Does not support SHA512\",\n)\nclass TestSHA512:\n    test_sha512 = generate_base_hash_test(\n        hashes.SHA512(),\n        digest_size=64,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.MD5()),\n    skip_message=\"Does not support MD5\",\n)\nclass TestMD5:\n    test_md5 = generate_base_hash_test(\n        hashes.MD5(),\n        digest_size=16,\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.BLAKE2b(digest_size=64)\n    ),\n    skip_message=\"Does not support BLAKE2b\",\n)\nclass TestBLAKE2b:\n    test_blake2b = generate_base_hash_test(\n        hashes.BLAKE2b(digest_size=64),\n        digest_size=64,\n    )\n\n    def test_invalid_digest_size(self, backend):\n        with pytest.raises(ValueError):\n            hashes.BLAKE2b(digest_size=65)\n\n        with pytest.raises(ValueError):\n            hashes.BLAKE2b(digest_size=0)\n\n        with pytest.raises(ValueError):\n            hashes.BLAKE2b(digest_size=-1)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.BLAKE2s(digest_size=32)\n    ),\n    skip_message=\"Does not support BLAKE2s\",\n)\nclass TestBLAKE2s:\n    test_blake2s = generate_base_hash_test(\n        hashes.BLAKE2s(digest_size=32),\n        digest_size=32,\n    )\n\n    def test_invalid_digest_size(self, backend):\n        with pytest.raises(ValueError):\n            hashes.BLAKE2s(digest_size=33)\n\n        with pytest.raises(ValueError):\n            hashes.BLAKE2s(digest_size=0)\n\n        with pytest.raises(ValueError):\n            hashes.BLAKE2s(digest_size=-1)\n\n\ndef test_buffer_protocol_hash(backend):\n    data = binascii.unhexlify(b\"b4190e\")\n    h = hashes.Hash(hashes.SHA256(), backend)\n    h.update(bytearray(data))\n    assert h.finalize() == binascii.unhexlify(\n        b\"dff2e73091f6c05e528896c4c831b9448653dc2ff043528f6769437bc7b975c2\"\n    )\n\n\nclass TestSHAKE:\n    @pytest.mark.parametrize(\"xof\", [hashes.SHAKE128, hashes.SHAKE256])\n    def test_invalid_digest_type(self, xof):\n        with pytest.raises(TypeError):\n            xof(digest_size=object())\n\n    @pytest.mark.parametrize(\"xof\", [hashes.SHAKE128, hashes.SHAKE256])\n    def test_invalid_digest_size(self, xof):\n        with pytest.raises(ValueError):\n            xof(digest_size=-5)\n\n        with pytest.raises(ValueError):\n            xof(digest_size=0)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SM3()),\n    skip_message=\"Does not support SM3\",\n)\nclass TestSM3:\n    test_sm3 = generate_base_hash_test(\n        hashes.SM3(),\n        digest_size=32,\n    )\n", "tests/hazmat/primitives/test_camellia.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives.ciphers import algorithms, modes\n\nfrom ...utils import load_cryptrec_vectors, load_nist_vectors\nfrom .utils import generate_encrypt_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.Camellia(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support Camellia ECB\",\n)\nclass TestCamelliaModeECB:\n    test_ecb = generate_encrypt_test(\n        load_cryptrec_vectors,\n        os.path.join(\"ciphers\", \"Camellia\"),\n        [\n            \"camellia-128-ecb.txt\",\n            \"camellia-192-ecb.txt\",\n            \"camellia-256-ecb.txt\",\n        ],\n        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.Camellia(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support Camellia CBC\",\n)\nclass TestCamelliaModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Camellia\"),\n        [\"camellia-cbc.txt\"],\n        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.Camellia(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support Camellia OFB\",\n)\nclass TestCamelliaModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Camellia\"),\n        [\"camellia-ofb.txt\"],\n        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.Camellia(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support Camellia CFB\",\n)\nclass TestCamelliaModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Camellia\"),\n        [\"camellia-cfb.txt\"],\n        lambda key, **kwargs: algorithms.Camellia(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n", "tests/hazmat/primitives/test_asym_utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric.utils import (\n    Prehashed,\n    decode_dss_signature,\n    encode_dss_signature,\n)\n\n\ndef test_dss_signature():\n    sig = encode_dss_signature(1, 1)\n    assert sig == b\"0\\x06\\x02\\x01\\x01\\x02\\x01\\x01\"\n    assert decode_dss_signature(sig) == (1, 1)\n\n    r_s1 = (\n        1037234182290683143945502320610861668562885151617,\n        559776156650501990899426031439030258256861634312,\n    )\n    sig2 = encode_dss_signature(*r_s1)\n    assert sig2 == (\n        b\"0-\\x02\\x15\\x00\\xb5\\xaf0xg\\xfb\\x8bT9\\x00\\x13\\xccg\\x02\\r\\xdf\\x1f,\\x0b\"\n        b'\\x81\\x02\\x14b\\r;\"\\xabP1D\\x0c>5\\xea\\xb6\\xf4\\x81)\\x8f\\x9e\\x9f\\x08'\n    )\n    assert decode_dss_signature(sig2) == r_s1\n\n    sig3 = encode_dss_signature(0, 0)\n    assert sig3 == b\"0\\x06\\x02\\x01\\x00\\x02\\x01\\x00\"\n    assert decode_dss_signature(sig3) == (0, 0)\n\n\ndef test_encode_dss_non_integer():\n    with pytest.raises(TypeError):\n        encode_dss_signature(\"h\", 3)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        encode_dss_signature(\"3\", \"2\")  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        encode_dss_signature(3, \"h\")  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        encode_dss_signature(3.3, 1.2)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        encode_dss_signature(\"hello\", \"world\")  # type: ignore[arg-type]\n\n\ndef test_encode_dss_negative():\n    with pytest.raises(ValueError):\n        encode_dss_signature(-1, 0)\n    with pytest.raises(ValueError):\n        encode_dss_signature(0, -1)\n\n\ndef test_decode_dss_trailing_bytes():\n    with pytest.raises(ValueError):\n        decode_dss_signature(b\"0\\x06\\x02\\x01\\x01\\x02\\x01\\x01\\x00\\x00\\x00\")\n\n\ndef test_decode_dss_invalid_asn1():\n    with pytest.raises(ValueError):\n        # This byte sequence has an invalid ASN.1 sequence length as well as\n        # an invalid integer length for the second integer.\n        decode_dss_signature(b\"0\\x07\\x02\\x01\\x01\\x02\\x02\\x01\")\n\n    with pytest.raises(ValueError):\n        # This is the BER \"end-of-contents octets\".\n        decode_dss_signature(b\"\\x00\\x00\")\n\n\ndef test_pass_invalid_prehashed_arg():\n    with pytest.raises(TypeError):\n        Prehashed(object())  # type: ignore[arg-type]\n\n\ndef test_prehashed_digest_size():\n    p = Prehashed(hashes.SHA256())\n    assert p.digest_size == 32\n", "tests/hazmat/primitives/test_rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport itertools\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    InvalidSignature,\n    UnsupportedAlgorithm,\n    _Reasons,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding, rsa\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\nfrom cryptography.hazmat.primitives.asymmetric.rsa import (\n    RSAPrivateNumbers,\n    RSAPublicNumbers,\n)\n\nfrom ...doubles import (\n    DummyAsymmetricPadding,\n    DummyHashAlgorithm,\n    DummyKeySerializationEncryption,\n)\nfrom ...utils import (\n    load_nist_vectors,\n    load_pkcs1_vectors,\n    load_rsa_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\nfrom .fixtures_rsa import (\n    RSA_KEY_512,\n    RSA_KEY_522,\n    RSA_KEY_599,\n    RSA_KEY_745,\n    RSA_KEY_1024,\n    RSA_KEY_1025,\n    RSA_KEY_1026,\n    RSA_KEY_1027,\n    RSA_KEY_1028,\n    RSA_KEY_1029,\n    RSA_KEY_1030,\n    RSA_KEY_1031,\n    RSA_KEY_1536,\n    RSA_KEY_2048,\n    RSA_KEY_2048_ALT,\n    RSA_KEY_CORRUPTED,\n)\nfrom .utils import (\n    _check_rsa_private_numbers,\n    generate_rsa_verification_test,\n    skip_fips_traditional_openssl,\n)\n\n\n@pytest.fixture(scope=\"session\")\ndef rsa_key_512() -> rsa.RSAPrivateKey:\n    return RSA_KEY_512.private_key(unsafe_skip_rsa_key_validation=True)\n\n\n@pytest.fixture(scope=\"session\")\ndef rsa_key_2048() -> rsa.RSAPrivateKey:\n    return RSA_KEY_2048.private_key(unsafe_skip_rsa_key_validation=True)\n\n\nclass DummyMGF(padding.MGF):\n    _salt_length = 0\n    _algorithm = hashes.SHA256()\n\n\ndef _check_fips_key_length(backend, private_key):\n    if (\n        backend._fips_enabled\n        and private_key.key_size < backend._fips_rsa_min_key_size\n    ):\n        pytest.skip(f\"Key size not FIPS compliant: {private_key.key_size}\")\n\n\ndef _flatten_pkcs1_examples(vectors):\n    flattened_vectors = []\n    for vector in vectors:\n        examples = vector[0].pop(\"examples\")\n        for example in examples:\n            merged_vector = (vector[0], vector[1], example)\n            flattened_vectors.append(merged_vector)\n\n    return flattened_vectors\n\n\ndef _build_oaep_sha2_vectors():\n    base_path = os.path.join(\"asymmetric\", \"RSA\", \"oaep-custom\")\n    vectors = []\n    hashalgs = [\n        hashes.SHA1(),\n        hashes.SHA224(),\n        hashes.SHA256(),\n        hashes.SHA384(),\n        hashes.SHA512(),\n    ]\n    for mgf1alg, oaepalg in itertools.product(hashalgs, hashalgs):\n        if mgf1alg.name == \"sha1\" and oaepalg.name == \"sha1\":\n            # We need to generate the cartesian product of the permutations\n            # of all the SHAs above, but SHA1/SHA1 is something we already\n            # tested previously and thus did not generate custom vectors for.\n            continue\n\n        examples = _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\n                    base_path,\n                    f\"oaep-{mgf1alg.name}-{oaepalg.name}.txt\",\n                ),\n                load_pkcs1_vectors,\n            )\n        )\n        # We've loaded the files, but the loaders don't give us any information\n        # about the mgf1 or oaep hash algorithms. We know this info so we'll\n        # just add that to the end of the tuple\n        for private, public, vector in examples:\n            vectors.append((private, public, vector, mgf1alg, oaepalg))\n    return vectors\n\n\ndef _skip_pss_hash_algorithm_unsupported(backend, hash_alg):\n    if not backend.rsa_padding_supported(\n        padding.PSS(\n            mgf=padding.MGF1(hash_alg), salt_length=padding.PSS.MAX_LENGTH\n        )\n    ):\n        pytest.skip(f\"Does not support {hash_alg.name} in MGF1 using PSS.\")\n\n\ndef test_skip_pss_hash_algorithm_unsupported(backend):\n    with pytest.raises(pytest.skip.Exception):\n        _skip_pss_hash_algorithm_unsupported(backend, DummyHashAlgorithm())\n\n\ndef test_modular_inverse():\n    p = int(\n        \"d1f9f6c09fd3d38987f7970247b85a6da84907753d42ec52bc23b745093f4fff5cff3\"\n        \"617ce43d00121a9accc0051f519c76e08cf02fc18acfe4c9e6aea18da470a2b611d2e\"\n        \"56a7b35caa2c0239bc041a53cc5875ca0b668ae6377d4b23e932d8c995fd1e58ecfd8\"\n        \"c4b73259c0d8a54d691cca3f6fb85c8a5c1baf588e898d481\",\n        16,\n    )\n    q = int(\n        \"d1519255eb8f678c86cfd06802d1fbef8b664441ac46b73d33d13a8404580a33a8e74\"\n        \"cb2ea2e2963125b3d454d7a922cef24dd13e55f989cbabf64255a736671f4629a47b5\"\n        \"b2347cfcd669133088d1c159518531025297c2d67c9da856a12e80222cd03b4c6ec0f\"\n        \"86c957cb7bb8de7a127b645ec9e820aa94581e4762e209f01\",\n        16,\n    )\n    assert rsa._modinv(q, p) == int(\n        \"0275e06afa722999315f8f322275483e15e2fb46d827b17800f99110b269a6732748f\"\n        \"624a382fa2ed1ec68c99f7fc56fb60e76eea51614881f497ba7034c17dde955f92f15\"\n        \"772f8b2b41f3e56d88b1e096cdd293eba4eae1e82db815e0fadea0c4ec971bc6fd875\"\n        \"c20e67e48c31a611e98d32c6213ae4c4d7b53023b2f80c538\",\n        16,\n    )\n\n\nclass TestRSA:\n    @pytest.mark.parametrize(\n        (\"public_exponent\", \"key_size\"),\n        itertools.product(\n            (3, 65537),\n            (1024, 1536, 2048),\n        ),\n    )\n    def test_generate_rsa_keys(self, backend, public_exponent, key_size):\n        if backend._fips_enabled:\n            if key_size < backend._fips_rsa_min_key_size:\n                pytest.skip(f\"Key size not FIPS compliant: {key_size}\")\n            if public_exponent < backend._fips_rsa_min_public_exponent:\n                pytest.skip(f\"Exponent not FIPS compliant: {public_exponent}\")\n        skey = rsa.generate_private_key(public_exponent, key_size, backend)\n        assert skey.key_size == key_size\n\n        _check_rsa_private_numbers(skey.private_numbers())\n        pkey = skey.public_key()\n        assert isinstance(pkey.public_numbers(), rsa.RSAPublicNumbers)\n\n    def test_generate_bad_public_exponent(self, backend):\n        with pytest.raises(ValueError):\n            rsa.generate_private_key(\n                public_exponent=1, key_size=2048, backend=backend\n            )\n\n        with pytest.raises(ValueError):\n            rsa.generate_private_key(\n                public_exponent=4, key_size=2048, backend=backend\n            )\n\n        with pytest.raises(ValueError):\n            rsa.generate_private_key(\n                public_exponent=65535, key_size=2048, backend=backend\n            )\n\n    def test_cant_generate_insecure_tiny_key(self, backend):\n        with pytest.raises(ValueError):\n            rsa.generate_private_key(\n                public_exponent=65537, key_size=511, backend=backend\n            )\n\n        with pytest.raises(ValueError):\n            rsa.generate_private_key(\n                public_exponent=65537, key_size=256, backend=backend\n            )\n\n    @pytest.mark.parametrize(\n        \"pkcs1_example\",\n        load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"RSA\", \"pkcs-1v2-1d2-vec\", \"pss-vect.txt\"\n            ),\n            load_pkcs1_vectors,\n        ),\n    )\n    def test_load_pss_vect_example_keys(self, pkcs1_example):\n        secret, public = pkcs1_example\n\n        private_num = rsa.RSAPrivateNumbers(\n            p=secret[\"p\"],\n            q=secret[\"q\"],\n            d=secret[\"private_exponent\"],\n            dmp1=secret[\"dmp1\"],\n            dmq1=secret[\"dmq1\"],\n            iqmp=secret[\"iqmp\"],\n            public_numbers=rsa.RSAPublicNumbers(\n                e=secret[\"public_exponent\"], n=secret[\"modulus\"]\n            ),\n        )\n        _check_rsa_private_numbers(private_num)\n\n        public_num = rsa.RSAPublicNumbers(\n            e=public[\"public_exponent\"], n=public[\"modulus\"]\n        )\n        assert public_num\n\n        public_num2 = private_num.public_numbers\n        assert public_num2\n\n        assert public_num.n == public_num2.n\n        assert public_num.e == public_num2.e\n\n    @pytest.mark.supported(\n        only_if=lambda backend: not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL,\n        skip_message=\"Does not support RSA PSS loading\",\n    )\n    @pytest.mark.parametrize(\n        \"path\",\n        [\n            os.path.join(\"asymmetric\", \"PKCS8\", \"rsa_pss_2048.pem\"),\n            os.path.join(\"asymmetric\", \"PKCS8\", \"rsa_pss_2048_hash.pem\"),\n            os.path.join(\"asymmetric\", \"PKCS8\", \"rsa_pss_2048_hash_mask.pem\"),\n            os.path.join(\n                \"asymmetric\", \"PKCS8\", \"rsa_pss_2048_hash_mask_diff.pem\"\n            ),\n            os.path.join(\n                \"asymmetric\", \"PKCS8\", \"rsa_pss_2048_hash_mask_salt.pem\"\n            ),\n        ],\n    )\n    def test_load_pss_keys_strips_constraints(self, path, backend):\n        key = load_vectors_from_file(\n            filename=path,\n            loader=lambda p: serialization.load_pem_private_key(\n                p.read(), password=None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        # These keys have constraints that prohibit PKCS1v15 signing,\n        # but for now we load them without the constraint and test that\n        # it's truly removed by performing a disallowed signature.\n        assert isinstance(key, rsa.RSAPrivateKey)\n        signature = key.sign(b\"whatever\", padding.PKCS1v15(), hashes.SHA224())\n        key.public_key().verify(\n            signature, b\"whatever\", padding.PKCS1v15(), hashes.SHA224()\n        )\n\n    def test_load_pss_pub_keys_strips_constraints(self, backend):\n        key = load_vectors_from_file(\n            filename=os.path.join(\n                \"asymmetric\", \"PKCS8\", \"rsa_pss_2048_pub.der\"\n            ),\n            loader=lambda p: serialization.load_der_public_key(\n                p.read(),\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(key, rsa.RSAPublicKey)\n        with pytest.raises(InvalidSignature):\n            key.verify(\n                b\"badsig\", b\"whatever\", padding.PKCS1v15(), hashes.SHA256()\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL,\n        skip_message=\"Test requires a backend without RSA-PSS key support\",\n    )\n    def test_load_pss_unsupported(self, backend):\n        # Key loading errors unfortunately have multiple paths so\n        # we need to allow ValueError and UnsupportedAlgorithm\n        with pytest.raises((UnsupportedAlgorithm, ValueError)):\n            load_vectors_from_file(\n                filename=os.path.join(\n                    \"asymmetric\", \"PKCS8\", \"rsa_pss_2048.pem\"\n                ),\n                loader=lambda p: serialization.load_pem_private_key(\n                    p.read(), password=None\n                ),\n                mode=\"rb\",\n            )\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"RSA\", \"oaep-label.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=b\"label\",\n            )\n        ),\n        skip_message=\"Does not support RSA OAEP labels\",\n    )\n    def test_oaep_label_decrypt(self, vector, backend):\n        private_key = serialization.load_der_private_key(\n            binascii.unhexlify(vector[\"key\"]),\n            None,\n            backend,\n            unsafe_skip_rsa_key_validation=True,\n        )\n        assert isinstance(private_key, rsa.RSAPrivateKey)\n        assert vector[\"oaepdigest\"] == b\"SHA512\"\n        decrypted = private_key.decrypt(\n            binascii.unhexlify(vector[\"input\"]),\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA512()),\n                algorithm=hashes.SHA512(),\n                label=binascii.unhexlify(vector[\"oaeplabel\"]),\n            ),\n        )\n        assert vector[\"output\"][1:-1] == decrypted\n\n    @pytest.mark.parametrize(\n        (\"msg\", \"label\"),\n        [\n            (b\"amazing encrypted msg\", b\"some label\"),\n            (b\"amazing encrypted msg\", b\"\"),\n        ],\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=b\"label\",\n            )\n        ),\n        skip_message=\"Does not support RSA OAEP labels\",\n    )\n    def test_oaep_label_roundtrip(self, rsa_key_2048, msg, label, backend):\n        private_key = rsa_key_2048\n        ct = private_key.public_key().encrypt(\n            msg,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=label,\n            ),\n        )\n        pt = private_key.decrypt(\n            ct,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=label,\n            ),\n        )\n        assert pt == msg\n\n    @pytest.mark.parametrize(\n        (\"enclabel\", \"declabel\"),\n        [(b\"label1\", b\"label2\"), (b\"label3\", b\"\"), (b\"\", b\"label4\")],\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=b\"label\",\n            )\n        ),\n        skip_message=\"Does not support RSA OAEP labels\",\n    )\n    def test_oaep_wrong_label(self, rsa_key_2048, enclabel, declabel, backend):\n        private_key = rsa_key_2048\n        msg = b\"test\"\n        ct = private_key.public_key().encrypt(\n            msg,\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=enclabel,\n            ),\n        )\n        with pytest.raises(ValueError):\n            private_key.decrypt(\n                ct,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=declabel,\n                ),\n            )\n\n\nclass TestRSASignature:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA1 signature.\",\n    )\n    def test_pkcs1v15_signing(self, backend, subtests):\n        vectors = _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"RSA\", \"pkcs1v15sign-vectors.txt\"),\n                load_pkcs1_vectors,\n            )\n        )\n        for private, public, example in vectors:\n            with subtests.test():\n                private_key = rsa.RSAPrivateNumbers(\n                    p=private[\"p\"],\n                    q=private[\"q\"],\n                    d=private[\"private_exponent\"],\n                    dmp1=private[\"dmp1\"],\n                    dmq1=private[\"dmq1\"],\n                    iqmp=private[\"iqmp\"],\n                    public_numbers=rsa.RSAPublicNumbers(\n                        e=private[\"public_exponent\"], n=private[\"modulus\"]\n                    ),\n                ).private_key(backend, unsafe_skip_rsa_key_validation=True)\n                signature = private_key.sign(\n                    binascii.unhexlify(example[\"message\"]),\n                    padding.PKCS1v15(),\n                    hashes.SHA1(),\n                )\n                assert binascii.hexlify(signature) == example[\"signature\"]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA1()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA1 signature.\",\n    )\n    def test_pss_signing(self, subtests, backend):\n        for private, public, example in _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"RSA\", \"pkcs-1v2-1d2-vec\", \"pss-vect.txt\"\n                ),\n                load_pkcs1_vectors,\n            )\n        ):\n            with subtests.test():\n                private_key = rsa.RSAPrivateNumbers(\n                    p=private[\"p\"],\n                    q=private[\"q\"],\n                    d=private[\"private_exponent\"],\n                    dmp1=private[\"dmp1\"],\n                    dmq1=private[\"dmq1\"],\n                    iqmp=private[\"iqmp\"],\n                    public_numbers=rsa.RSAPublicNumbers(\n                        e=private[\"public_exponent\"], n=private[\"modulus\"]\n                    ),\n                ).private_key(backend, unsafe_skip_rsa_key_validation=True)\n                public_key = rsa.RSAPublicNumbers(\n                    e=public[\"public_exponent\"], n=public[\"modulus\"]\n                ).public_key(backend)\n                signature = private_key.sign(\n                    binascii.unhexlify(example[\"message\"]),\n                    padding.PSS(\n                        mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                        salt_length=padding.PSS.MAX_LENGTH,\n                    ),\n                    hashes.SHA1(),\n                )\n                assert len(signature) == (private_key.key_size + 7) // 8\n                # PSS signatures contain randomness so we can't do an exact\n                # signature check. Instead we'll verify that the signature\n                # created successfully verifies.\n                public_key.verify(\n                    signature,\n                    binascii.unhexlify(example[\"message\"]),\n                    padding.PSS(\n                        mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                        salt_length=padding.PSS.MAX_LENGTH,\n                    ),\n                    hashes.SHA1(),\n                )\n\n    @pytest.mark.parametrize(\n        \"hash_alg\",\n        [hashes.SHA224(), hashes.SHA256(), hashes.SHA384(), hashes.SHA512()],\n    )\n    def test_pss_signing_sha2(self, rsa_key_2048, hash_alg, backend):\n        _skip_pss_hash_algorithm_unsupported(backend, hash_alg)\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        pss = padding.PSS(\n            mgf=padding.MGF1(hash_alg), salt_length=padding.PSS.MAX_LENGTH\n        )\n        msg = b\"testing signature\"\n        signature = private_key.sign(msg, pss, hash_alg)\n        public_key.verify(signature, msg, pss, hash_alg)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_pss_digest_length(self, rsa_key_2048, backend):\n        private_key = rsa_key_2048\n        signature = private_key.sign(\n            b\"some data\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            ),\n            hashes.SHA256(),\n        )\n        public = private_key.public_key()\n        public.verify(\n            signature,\n            b\"some data\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            ),\n            hashes.SHA256(),\n        )\n        public.verify(\n            signature,\n            b\"some data\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=32,\n            ),\n            hashes.SHA256(),\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.hash_supported(hashes.SHA512())\n            and backend.rsa_padding_supported(\n                padding.PSS(\n                    mgf=padding.MGF1(hashes.SHA256()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                )\n            )\n        ),\n        skip_message=\"Does not support SHA512.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pss_minimum_key_size_for_digest(self, backend):\n        private_key = RSA_KEY_522.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n        private_key.sign(\n            b\"no failure\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            ),\n            hashes.SHA512(),\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(hashes.SHA512()),\n        skip_message=\"Does not support SHA512.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pss_signing_digest_too_large_for_key_size(\n        self, rsa_key_512: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_512\n        with pytest.raises(ValueError):\n            private_key.sign(\n                b\"msg\",\n                padding.PSS(\n                    mgf=padding.MGF1(hashes.SHA256()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA512(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_pss_signing_salt_length_too_long(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with pytest.raises(ValueError):\n            private_key.sign(\n                b\"failure coming\",\n                padding.PSS(\n                    mgf=padding.MGF1(hashes.SHA256()), salt_length=1000000\n                ),\n                hashes.SHA256(),\n            )\n\n    def test_unsupported_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            private_key.sign(b\"msg\", DummyAsymmetricPadding(), hashes.SHA256())\n\n    def test_padding_incorrect_type(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with pytest.raises(TypeError):\n            private_key.sign(\n                b\"msg\",\n                \"notpadding\",  # type: ignore[arg-type]\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_unsupported_pss_mgf(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):\n            private_key.sign(\n                b\"msg\",\n                padding.PSS(\n                    mgf=DummyMGF(),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.AUTO,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_pss_sign_unsupported_auto(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with pytest.raises(ValueError):\n            private_key.sign(\n                b\"some data\",\n                padding.PSS(\n                    mgf=padding.MGF1(hashes.SHA256()),\n                    salt_length=padding.PSS.AUTO,\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pkcs1_digest_too_large_for_key_size(self, backend):\n        private_key = RSA_KEY_599.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n        with pytest.raises(ValueError):\n            private_key.sign(\n                b\"failure coming\", padding.PKCS1v15(), hashes.SHA512()\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pkcs1_minimum_key_size(self, backend):\n        private_key = RSA_KEY_745.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n        private_key.sign(b\"no failure\", padding.PKCS1v15(), hashes.SHA512())\n\n    @pytest.mark.parametrize(\n        \"message\",\n        [\n            b\"one little message\",\n            bytearray(b\"one little message\"),\n        ],\n    )\n    def test_sign(self, rsa_key_2048: rsa.RSAPrivateKey, message, backend):\n        private_key = rsa_key_2048\n        pkcs = padding.PKCS1v15()\n        algorithm = hashes.SHA256()\n        signature = private_key.sign(message, pkcs, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, pkcs, algorithm)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_prehashed_sign(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        digest = h.finalize()\n        pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA256())\n        signature = private_key.sign(digest, pss, prehashed_alg)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, pss, hashes.SHA256())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_prehashed_digest_length(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        digest = h.finalize()\n        pss = padding.PSS(\n            mgf=padding.MGF1(hashes.SHA256()),\n            salt_length=padding.PSS.DIGEST_LENGTH,\n        )\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA256())\n        signature = private_key.sign(digest, pss, prehashed_alg)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, pss, hashes.SHA256())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(\n            hashes.BLAKE2s(digest_size=32)\n        ),\n        skip_message=\"Does not support BLAKE2s\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_unsupported_hash(self, rsa_key_512: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_512\n        message = b\"one little message\"\n        pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            private_key.sign(message, pss, hashes.BLAKE2s(32))\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_unsupported_hash_pss_mgf1(self, rsa_key_2048: rsa.RSAPrivateKey):\n        private_key = rsa_key_2048\n        message = b\"my message\"\n        pss = padding.PSS(\n            mgf=padding.MGF1(DummyHashAlgorithm()), salt_length=0\n        )\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            private_key.sign(message, pss, hashes.SHA256())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_prehashed_digest_mismatch(\n        self, rsa_key_512: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_512\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA512(), backend)\n        h.update(message)\n        digest = h.finalize()\n        pss = padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA256())\n        with pytest.raises(ValueError):\n            private_key.sign(digest, pss, prehashed_alg)\n\n    def test_prehashed_unsupported_in_signature_recover(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        signature = private_key.sign(\n            b\"sign me\", padding.PKCS1v15(), hashes.SHA256()\n        )\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA256())\n        with pytest.raises(TypeError):\n            public_key.recover_data_from_signature(\n                signature,\n                padding.PKCS1v15(),\n                prehashed_alg,  # type: ignore[arg-type]\n            )\n\n    def test_corrupted_private_key(self, backend):\n        with pytest.raises(ValueError):\n            serialization.load_pem_private_key(\n                RSA_KEY_CORRUPTED, password=None, backend=backend\n            )\n\n\nclass TestRSAVerification:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA1 signature.\",\n    )\n    def test_pkcs1v15_verification(self, backend, subtests):\n        vectors = _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"RSA\", \"pkcs1v15sign-vectors.txt\"),\n                load_pkcs1_vectors,\n            )\n        )\n        for private, public, example in vectors:\n            with subtests.test():\n                public_key = rsa.RSAPublicNumbers(\n                    e=public[\"public_exponent\"], n=public[\"modulus\"]\n                ).public_key(backend)\n                signature = binascii.unhexlify(example[\"signature\"])\n                message = binascii.unhexlify(example[\"message\"])\n                public_key.verify(\n                    signature, message, padding.PKCS1v15(), hashes.SHA1()\n                )\n\n                # Test digest recovery by providing hash\n                digest = hashes.Hash(hashes.SHA1())\n                digest.update(message)\n                msg_digest = digest.finalize()\n                rec_msg_digest = public_key.recover_data_from_signature(\n                    signature, padding.PKCS1v15(), hashes.SHA1()\n                )\n                assert msg_digest == rec_msg_digest\n\n                # Test recovery of all data (full DigestInfo) with hash alg. as\n                # None\n                rec_sig_data = public_key.recover_data_from_signature(\n                    signature, padding.PKCS1v15(), None\n                )\n                assert len(rec_sig_data) > len(msg_digest)\n                assert msg_digest == rec_sig_data[-len(msg_digest) :]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_invalid_pkcs1v15_signature_wrong_data(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        signature = private_key.sign(\n            b\"sign me\", padding.PKCS1v15(), hashes.SHA256()\n        )\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature,\n                b\"incorrect data\",\n                padding.PKCS1v15(),\n                hashes.SHA256(),\n            )\n\n    def test_invalid_pkcs1v15_signature_recover_wrong_hash_alg(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        signature = private_key.sign(\n            b\"sign me\", padding.PKCS1v15(), hashes.SHA256()\n        )\n        with pytest.raises(InvalidSignature):\n            public_key.recover_data_from_signature(\n                signature, padding.PKCS1v15(), hashes.SHA512()\n            )\n\n    def test_invalid_signature_sequence_removed(self, backend):\n        \"\"\"\n        This test comes from wycheproof\n        \"\"\"\n        key_der = binascii.unhexlify(\n            b\"30820122300d06092a864886f70d01010105000382010f003082010a02820101\"\n            b\"00a2b451a07d0aa5f96e455671513550514a8a5b462ebef717094fa1fee82224\"\n            b\"e637f9746d3f7cafd31878d80325b6ef5a1700f65903b469429e89d6eac88450\"\n            b\"97b5ab393189db92512ed8a7711a1253facd20f79c15e8247f3d3e42e46e48c9\"\n            b\"8e254a2fe9765313a03eff8f17e1a029397a1fa26a8dce26f490ed81299615d9\"\n            b\"814c22da610428e09c7d9658594266f5c021d0fceca08d945a12be82de4d1ece\"\n            b\"6b4c03145b5d3495d4ed5411eb878daf05fd7afc3e09ada0f1126422f590975a\"\n            b\"1969816f48698bcbba1b4d9cae79d460d8f9f85e7975005d9bc22c4e5ac0f7c1\"\n            b\"a45d12569a62807d3b9a02e5a530e773066f453d1f5b4c2e9cf7820283f742b9\"\n            b\"d50203010001\"\n        )\n        sig = binascii.unhexlify(\n            b\"498209f59a0679a1f926eccf3056da2cba553d7ab3064e7c41ad1d739f038249\"\n            b\"f02f5ad12ee246073d101bc3cdb563e8b6be61562056422b7e6c16ad53deb12a\"\n            b\"f5de744197753a35859833f41bb59c6597f3980132b7478fd0b95fd27dfad64a\"\n            b\"20fd5c25312bbd41a85286cd2a83c8df5efa0779158d01b0747ff165b055eb28\"\n            b\"80ea27095700a295593196d8c5922cf6aa9d7e29b5056db5ded5eb20aeb31b89\"\n            b\"42e26b15a5188a4934cd7e39cfe379a197f49a204343a493452deebca436ee61\"\n            b\"4f4daf989e355544489f7e69ffa8ccc6a1e81cf0ab33c3e6d7591091485a6a31\"\n            b\"bda3b33946490057b9a3003d3fd9daf7c4778b43fd46144d945d815f12628ff4\"\n        )\n        public_key = serialization.load_der_public_key(key_der, backend)\n        assert isinstance(public_key, rsa.RSAPublicKey)\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                sig,\n                binascii.unhexlify(b\"313233343030\"),\n                padding.PKCS1v15(),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_invalid_pkcs1v15_signature_wrong_key(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        private_key2 = RSA_KEY_2048_ALT.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n        public_key = private_key2.public_key()\n        msg = b\"sign me\"\n        signature = private_key.sign(msg, padding.PKCS1v15(), hashes.SHA256())\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature, msg, padding.PKCS1v15(), hashes.SHA256()\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA1()), salt_length=20)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.signature_hash_supported(\n            hashes.SHA1()\n        ),\n        skip_message=\"Does not support SHA1 signature.\",\n    )\n    def test_pss_verification(self, subtests, backend):\n        for private, public, example in _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"RSA\", \"pkcs-1v2-1d2-vec\", \"pss-vect.txt\"\n                ),\n                load_pkcs1_vectors,\n            )\n        ):\n            with subtests.test():\n                public_key = rsa.RSAPublicNumbers(\n                    e=public[\"public_exponent\"], n=public[\"modulus\"]\n                ).public_key(backend)\n                public_key.verify(\n                    binascii.unhexlify(example[\"signature\"]),\n                    binascii.unhexlify(example[\"message\"]),\n                    padding.PSS(\n                        mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                        salt_length=20,\n                    ),\n                    hashes.SHA1(),\n                )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.AUTO,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_pss_verify_auto_salt_length(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        signature = private_key.sign(\n            b\"some data\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            ),\n            hashes.SHA256(),\n        )\n        private_key.public_key().verify(\n            signature,\n            b\"some data\",\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.AUTO,\n            ),\n            hashes.SHA256(),\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_invalid_pss_signature_wrong_data(self, backend):\n        public_key = rsa.RSAPublicNumbers(\n            n=int(\n                b\"dffc2137d5e810cde9e4b4612f5796447218bab913b3fa98bdf7982e4fa6\"\n                b\"ec4d6653ef2b29fb1642b095befcbea6decc178fb4bed243d3c3592c6854\"\n                b\"6af2d3f3\",\n                16,\n            ),\n            e=65537,\n        ).public_key(backend)\n        signature = binascii.unhexlify(\n            b\"0e68c3649df91c5bc3665f96e157efa75b71934aaa514d91e94ca8418d100f45\"\n            b\"6f05288e58525f99666bab052adcffdf7186eb40f583bd38d98c97d3d524808b\"\n        )\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature,\n                b\"incorrect data\",\n                padding.PSS(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_invalid_pss_signature_wrong_key(self, backend):\n        signature = binascii.unhexlify(\n            b\"3a1880165014ba6eb53cc1449d13e5132ebcc0cfd9ade6d7a2494a0503bd0826\"\n            b\"f8a46c431e0d7be0ca3e453f8b2b009e2733764da7927cc6dbe7a021437a242e\"\n        )\n        public_key = rsa.RSAPublicNumbers(\n            n=int(\n                b\"381201f4905d67dfeb3dec131a0fbea773489227ec7a1448c3109189ac68\"\n                b\"5a95441be90866a14c4d2e139cd16db540ec6c7abab13ffff91443fd46a8\"\n                b\"960cbb7658ded26a5c95c86f6e40384e1c1239c63e541ba221191c4dd303\"\n                b\"231b42e33c6dbddf5ec9a746f09bf0c25d0f8d27f93ee0ae5c0d723348f4\"\n                b\"030d3581e13522e1\",\n                16,\n            ),\n            e=65537,\n        ).public_key(backend)\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature,\n                b\"sign me\",\n                padding.PSS(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_invalid_pss_signature_data_too_large_for_modulus(self, backend):\n        # 2048 bit PSS signature\n        signature = binascii.unhexlify(\n            b\"58750fc3d2f560d1f3e37c8e28bc8da6d3e93f5d58f8becd25b1c931eea30fea\"\n            b\"54cb17d44b90104a0aacb7fe9ffa2a59c5788435911d63de78178d21eb875ccd\"\n            b\"0b07121b641ed4fe6bcb1ca5060322765507b4f24bdba8a698a8e4e07e6bf2c4\"\n            b\"7a736abe5a912e85cd32f648f3e043b4385e8b612dcce342c5fddf18c524deb5\"\n            b\"6295b95f6dfa759b2896b793628a90f133e74c1ff7d3af43e3f7ee792df2e5b6\"\n            b\"a19e996ac3676884354899a437b3ae4e3ac91976c336c332a3b1db0d172b19cb\"\n            b\"40ad3d871296cfffb3c889ce74a179a3e290852c35d59525afe4b39dc907fad2\"\n            b\"ac462c50a488dca486031a3dc8c4cdbbc53e9f71d64732e1533a5d1249b833ce\"\n        )\n        # 1024 bit key\n        public_key = RSA_KEY_1024.private_key(\n            unsafe_skip_rsa_key_validation=True\n        ).public_key()\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature,\n                b\"sign me\",\n                padding.PSS(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA256(),\n            )\n\n    def test_invalid_pss_signature_recover(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        pss_padding = padding.PSS(\n            mgf=padding.MGF1(algorithm=hashes.SHA256()),\n            salt_length=padding.PSS.MAX_LENGTH,\n        )\n        signature = private_key.sign(b\"sign me\", pss_padding, hashes.SHA256())\n\n        # Hash algorithm cannot be absent for PSS padding\n        with pytest.raises(TypeError):\n            public_key.recover_data_from_signature(\n                signature, pss_padding, None\n            )\n\n        # Signature data recovery not supported with PSS\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            public_key.recover_data_from_signature(\n                signature, pss_padding, hashes.SHA256()\n            )\n\n    def test_unsupported_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            public_key.verify(\n                b\"sig\", b\"msg\", DummyAsymmetricPadding(), hashes.SHA256()\n            )\n\n    def test_padding_incorrect_type(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        with pytest.raises(TypeError):\n            public_key.verify(\n                b\"sig\",\n                b\"msg\",\n                \"notpadding\",  # type: ignore[arg-type]\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=0)\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    def test_unsupported_pss_mgf(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):\n            public_key.verify(\n                b\"sig\",\n                b\"msg\",\n                padding.PSS(\n                    mgf=DummyMGF(), salt_length=padding.PSS.MAX_LENGTH\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA512()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hash_supported(hashes.SHA512()),\n        skip_message=\"Does not support SHA512.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pss_verify_digest_too_large_for_key_size(\n        self, rsa_key_512: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_512\n        signature = binascii.unhexlify(\n            b\"8b9a3ae9fb3b64158f3476dd8d8a1f1425444e98940e0926378baa9944d219d8\"\n            b\"534c050ef6b19b1bdc6eb4da422e89161106a6f5b5cc16135b11eb6439b646bd\"\n        )\n        public_key = private_key.public_key()\n        with pytest.raises(ValueError):\n            public_key.verify(\n                signature,\n                b\"msg doesn't matter\",\n                padding.PSS(\n                    mgf=padding.MGF1(algorithm=hashes.SHA512()),\n                    salt_length=padding.PSS.MAX_LENGTH,\n                ),\n                hashes.SHA512(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS.\",\n    )\n    @pytest.mark.skip_fips(reason=\"Unsupported key size in FIPS mode.\")\n    def test_pss_verify_salt_length_too_long(self, backend):\n        signature = binascii.unhexlify(\n            b\"8b9a3ae9fb3b64158f3476dd8d8a1f1425444e98940e0926378baa9944d219d8\"\n            b\"534c050ef6b19b1bdc6eb4da422e89161106a6f5b5cc16135b11eb6439b646bd\"\n        )\n        public_key = rsa.RSAPublicNumbers(\n            n=int(\n                b\"d309e4612809437548b747d7f9eb9cd3340f54fe42bb3f84a36933b0839c\"\n                b\"11b0c8b7f67e11f7252370161e31159c49c784d4bc41c42a78ce0f0b40a3\"\n                b\"ca8ffb91\",\n                16,\n            ),\n            e=65537,\n        ).public_key(backend)\n        with pytest.raises(InvalidSignature):\n            public_key.verify(\n                signature,\n                b\"sign me\",\n                padding.PSS(\n                    mgf=padding.MGF1(\n                        algorithm=hashes.SHA256(),\n                    ),\n                    salt_length=1000000,\n                ),\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.parametrize(\n        \"message\",\n        [\n            b\"one little message\",\n            bytearray(b\"one little message\"),\n        ],\n    )\n    def test_verify(self, rsa_key_2048: rsa.RSAPrivateKey, message, backend):\n        private_key = rsa_key_2048\n        pkcs = padding.PKCS1v15()\n        algorithm = hashes.SHA256()\n        signature = private_key.sign(message, pkcs, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, pkcs, algorithm)\n\n    def test_prehashed_verify(self, rsa_key_2048: rsa.RSAPrivateKey, backend):\n        private_key = rsa_key_2048\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        digest = h.finalize()\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA256())\n        pkcs = padding.PKCS1v15()\n        signature = private_key.sign(message, pkcs, hashes.SHA256())\n        public_key = private_key.public_key()\n        public_key.verify(signature, digest, pkcs, prehashed_alg)\n\n    def test_prehashed_digest_mismatch(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        public_key = rsa_key_2048.public_key()\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        data = h.finalize()\n        prehashed_alg = asym_utils.Prehashed(hashes.SHA512())\n        pkcs = padding.PKCS1v15()\n        with pytest.raises(ValueError):\n            public_key.verify(b\"\\x00\" * 64, data, pkcs, prehashed_alg)\n\n\nclass TestRSAPSSMGF1Verification:\n    test_rsa_pss_mgf1_sha1 = pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA1()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        )\n        and backend.signature_hash_supported(hashes.SHA1()),\n        skip_message=(\n            \"Does not support PSS using MGF1 with SHA1 or SHA1 signature.\"\n        ),\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGenPSS_186-2.rsp\",\n                \"SigGenPSS_186-3.rsp\",\n                \"SigVerPSS_186-3.rsp\",\n            ],\n            hashes.SHA1(),\n            lambda params, hash_alg: padding.PSS(\n                mgf=padding.MGF1(\n                    algorithm=hash_alg,\n                ),\n                salt_length=params[\"salt_length\"],\n            ),\n        )\n    )\n\n    test_rsa_pss_mgf1_sha224 = pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA224()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS using MGF1 with SHA224.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGenPSS_186-2.rsp\",\n                \"SigGenPSS_186-3.rsp\",\n                \"SigVerPSS_186-3.rsp\",\n            ],\n            hashes.SHA224(),\n            lambda params, hash_alg: padding.PSS(\n                mgf=padding.MGF1(\n                    algorithm=hash_alg,\n                ),\n                salt_length=params[\"salt_length\"],\n            ),\n        )\n    )\n\n    test_rsa_pss_mgf1_sha256 = pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS using MGF1 with SHA256.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGenPSS_186-2.rsp\",\n                \"SigGenPSS_186-3.rsp\",\n                \"SigVerPSS_186-3.rsp\",\n            ],\n            hashes.SHA256(),\n            lambda params, hash_alg: padding.PSS(\n                mgf=padding.MGF1(\n                    algorithm=hash_alg,\n                ),\n                salt_length=params[\"salt_length\"],\n            ),\n        )\n    )\n\n    test_rsa_pss_mgf1_sha384 = pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA384()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS using MGF1 with SHA384.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGenPSS_186-2.rsp\",\n                \"SigGenPSS_186-3.rsp\",\n                \"SigVerPSS_186-3.rsp\",\n            ],\n            hashes.SHA384(),\n            lambda params, hash_alg: padding.PSS(\n                mgf=padding.MGF1(\n                    algorithm=hash_alg,\n                ),\n                salt_length=params[\"salt_length\"],\n            ),\n        )\n    )\n\n    test_rsa_pss_mgf1_sha512 = pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_padding_supported(\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA512()),\n                salt_length=padding.PSS.MAX_LENGTH,\n            )\n        ),\n        skip_message=\"Does not support PSS using MGF1 with SHA512.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGenPSS_186-2.rsp\",\n                \"SigGenPSS_186-3.rsp\",\n                \"SigVerPSS_186-3.rsp\",\n            ],\n            hashes.SHA512(),\n            lambda params, hash_alg: padding.PSS(\n                mgf=padding.MGF1(\n                    algorithm=hash_alg,\n                ),\n                salt_length=params[\"salt_length\"],\n            ),\n        )\n    )\n\n\nclass TestRSAPKCS1Verification:\n    test_rsa_pkcs1v15_verify_sha1 = pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.signature_hash_supported(hashes.SHA1())\n            and backend.rsa_padding_supported(padding.PKCS1v15())\n        ),\n        skip_message=\"Does not support SHA1 and PKCS1v1.5.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGen15_186-2.rsp\",\n                \"SigGen15_186-3.rsp\",\n                \"SigVer15_186-3.rsp\",\n            ],\n            hashes.SHA1(),\n            lambda params, hash_alg: padding.PKCS1v15(),\n        )\n    )\n\n    test_rsa_pkcs1v15_verify_sha224 = pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.signature_hash_supported(hashes.SHA224())\n            and backend.rsa_padding_supported(padding.PKCS1v15())\n        ),\n        skip_message=\"Does not support SHA224 and PKCS1v1.5.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGen15_186-2.rsp\",\n                \"SigGen15_186-3.rsp\",\n                \"SigVer15_186-3.rsp\",\n            ],\n            hashes.SHA224(),\n            lambda params, hash_alg: padding.PKCS1v15(),\n        )\n    )\n\n    test_rsa_pkcs1v15_verify_sha256 = pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.signature_hash_supported(hashes.SHA256())\n            and backend.rsa_padding_supported(padding.PKCS1v15())\n        ),\n        skip_message=\"Does not support SHA256 and PKCS1v1.5.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGen15_186-2.rsp\",\n                \"SigGen15_186-3.rsp\",\n                \"SigVer15_186-3.rsp\",\n            ],\n            hashes.SHA256(),\n            lambda params, hash_alg: padding.PKCS1v15(),\n        )\n    )\n\n    test_rsa_pkcs1v15_verify_sha384 = pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.signature_hash_supported(hashes.SHA384())\n            and backend.rsa_padding_supported(padding.PKCS1v15())\n        ),\n        skip_message=\"Does not support SHA384 and PKCS1v1.5.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGen15_186-2.rsp\",\n                \"SigGen15_186-3.rsp\",\n                \"SigVer15_186-3.rsp\",\n            ],\n            hashes.SHA384(),\n            lambda params, hash_alg: padding.PKCS1v15(),\n        )\n    )\n\n    test_rsa_pkcs1v15_verify_sha512 = pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.signature_hash_supported(hashes.SHA512())\n            and backend.rsa_padding_supported(padding.PKCS1v15())\n        ),\n        skip_message=\"Does not support SHA512 and PKCS1v1.5.\",\n    )(\n        generate_rsa_verification_test(\n            load_rsa_nist_vectors,\n            os.path.join(\"asymmetric\", \"RSA\", \"FIPS_186-2\"),\n            [\n                \"SigGen15_186-2.rsp\",\n                \"SigGen15_186-3.rsp\",\n                \"SigVer15_186-3.rsp\",\n            ],\n            hashes.SHA512(),\n            lambda params, hash_alg: padding.PKCS1v15(),\n        )\n    )\n\n\nclass TestPSS:\n    def test_calculate_max_pss_salt_length(self):\n        with pytest.raises(TypeError):\n            padding.calculate_max_pss_salt_length(\n                object(),  # type:ignore[arg-type]\n                hashes.SHA256(),\n            )\n\n    def test_invalid_salt_length_not_integer(self):\n        with pytest.raises(TypeError):\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA256()),\n                salt_length=b\"not_a_length\",  # type:ignore[arg-type]\n            )\n\n    def test_invalid_salt_length_negative_integer(self):\n        with pytest.raises(ValueError):\n            padding.PSS(mgf=padding.MGF1(hashes.SHA256()), salt_length=-1)\n\n    def test_valid_pss_parameters(self):\n        algorithm = hashes.SHA256()\n        salt_length = algorithm.digest_size\n        mgf = padding.MGF1(algorithm)\n        pss = padding.PSS(mgf=mgf, salt_length=salt_length)\n        assert pss._mgf == mgf\n        assert pss._salt_length == salt_length\n\n    def test_valid_pss_parameters_maximum(self):\n        algorithm = hashes.SHA256()\n        mgf = padding.MGF1(algorithm)\n        pss = padding.PSS(mgf=mgf, salt_length=padding.PSS.MAX_LENGTH)\n        assert pss._mgf == mgf\n        assert pss._salt_length == padding.PSS.MAX_LENGTH\n\n    def test_mgf_property(self):\n        algorithm = hashes.SHA256()\n        mgf = padding.MGF1(algorithm)\n        pss = padding.PSS(mgf=mgf, salt_length=padding.PSS.MAX_LENGTH)\n        assert pss.mgf == mgf\n        assert pss.mgf == pss._mgf\n\n\nclass TestMGF1:\n    def test_invalid_hash_algorithm(self):\n        with pytest.raises(TypeError):\n            padding.MGF1(b\"not_a_hash\")  # type:ignore[arg-type]\n\n    def test_valid_mgf1_parameters(self):\n        algorithm = hashes.SHA256()\n        mgf = padding.MGF1(algorithm)\n        assert mgf._algorithm == algorithm\n\n\nclass TestOAEP:\n    def test_invalid_algorithm(self):\n        mgf = padding.MGF1(hashes.SHA256())\n        with pytest.raises(TypeError):\n            padding.OAEP(\n                mgf=mgf,\n                algorithm=b\"\",  # type:ignore[arg-type]\n                label=None,\n            )\n\n    def test_algorithm_property(self):\n        algorithm = hashes.SHA256()\n        mgf = padding.MGF1(algorithm)\n        oaep = padding.OAEP(mgf=mgf, algorithm=algorithm, label=None)\n        assert oaep.algorithm == algorithm\n        assert oaep.algorithm == oaep._algorithm\n\n    def test_mgf_property(self):\n        algorithm = hashes.SHA256()\n        mgf = padding.MGF1(algorithm)\n        oaep = padding.OAEP(mgf=mgf, algorithm=algorithm, label=None)\n        assert oaep.mgf == mgf\n        assert oaep.mgf == oaep._mgf\n\n\nclass TestRSADecryption:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_decrypt_pkcs1v15_vectors(self, backend, subtests):\n        vectors = _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"RSA\", \"pkcs1v15crypt-vectors.txt\"),\n                load_pkcs1_vectors,\n            )\n        )\n        for private, public, example in vectors:\n            with subtests.test():\n                skey = rsa.RSAPrivateNumbers(\n                    p=private[\"p\"],\n                    q=private[\"q\"],\n                    d=private[\"private_exponent\"],\n                    dmp1=private[\"dmp1\"],\n                    dmq1=private[\"dmq1\"],\n                    iqmp=private[\"iqmp\"],\n                    public_numbers=rsa.RSAPublicNumbers(\n                        e=private[\"public_exponent\"], n=private[\"modulus\"]\n                    ),\n                ).private_key(backend, unsafe_skip_rsa_key_validation=True)\n                ciphertext = binascii.unhexlify(example[\"encryption\"])\n                assert len(ciphertext) == (skey.key_size + 7) // 8\n                message = skey.decrypt(ciphertext, padding.PKCS1v15())\n                assert message == binascii.unhexlify(example[\"message\"])\n\n    def test_unsupported_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            private_key.decrypt(b\"0\" * 256, DummyAsymmetricPadding())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            backend.rsa_encryption_supported(padding.PKCS1v15())\n            and not backend._lib.Cryptography_HAS_IMPLICIT_RSA_REJECTION\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_decrypt_invalid_decrypt(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with pytest.raises(ValueError):\n            private_key.decrypt(b\"\\x00\" * 256, padding.PKCS1v15())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_decrypt_ciphertext_too_large(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with pytest.raises(ValueError):\n            private_key.decrypt(b\"\\x00\" * 257, padding.PKCS1v15())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    def test_decrypt_ciphertext_too_small(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        ct = binascii.unhexlify(\n            b\"50b4c14136bd198c2f3c3ed243fce036e168d56517984a263cd66492b80804f1\"\n            b\"69d210f2b9bdfb48b12f9ea05009c77da257cc600ccefe3a6283789d8ea0\"\n        )\n        with pytest.raises(ValueError):\n            private_key.decrypt(ct, padding.PKCS1v15())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                algorithm=hashes.SHA1(),\n                label=None,\n            )\n        ),\n        skip_message=\"Does not support OAEP.\",\n    )\n    def test_decrypt_oaep_sha1_vectors(self, subtests, backend):\n        for private, public, example in _flatten_pkcs1_examples(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"RSA\", \"pkcs-1v2-1d2-vec\", \"oaep-vect.txt\"\n                ),\n                load_pkcs1_vectors,\n            )\n        ):\n            with subtests.test():\n                skey = rsa.RSAPrivateNumbers(\n                    p=private[\"p\"],\n                    q=private[\"q\"],\n                    d=private[\"private_exponent\"],\n                    dmp1=private[\"dmp1\"],\n                    dmq1=private[\"dmq1\"],\n                    iqmp=private[\"iqmp\"],\n                    public_numbers=rsa.RSAPublicNumbers(\n                        e=private[\"public_exponent\"], n=private[\"modulus\"]\n                    ),\n                ).private_key(backend, unsafe_skip_rsa_key_validation=True)\n                message = skey.decrypt(\n                    binascii.unhexlify(example[\"encryption\"]),\n                    padding.OAEP(\n                        mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                        algorithm=hashes.SHA1(),\n                        label=None,\n                    ),\n                )\n                assert message == binascii.unhexlify(example[\"message\"])\n\n    def test_decrypt_oaep_sha2_vectors(self, backend, subtests):\n        vectors = _build_oaep_sha2_vectors()\n        for private, public, example, mgf1_alg, hash_alg in vectors:\n            with subtests.test():\n                pad = padding.OAEP(\n                    mgf=padding.MGF1(algorithm=mgf1_alg),\n                    algorithm=hash_alg,\n                    label=None,\n                )\n                if not backend.rsa_encryption_supported(pad):\n                    pytest.skip(\n                        f\"Does not support OAEP using {mgf1_alg.name} MGF1 \"\n                        f\"or {hash_alg.name} hash.\"\n                    )\n                skey = rsa.RSAPrivateNumbers(\n                    p=private[\"p\"],\n                    q=private[\"q\"],\n                    d=private[\"private_exponent\"],\n                    dmp1=private[\"dmp1\"],\n                    dmq1=private[\"dmq1\"],\n                    iqmp=private[\"iqmp\"],\n                    public_numbers=rsa.RSAPublicNumbers(\n                        e=private[\"public_exponent\"], n=private[\"modulus\"]\n                    ),\n                ).private_key(backend, unsafe_skip_rsa_key_validation=True)\n                message = skey.decrypt(\n                    binascii.unhexlify(example[\"encryption\"]),\n                    pad,\n                )\n                assert message == binascii.unhexlify(example[\"message\"])\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None,\n            )\n        ),\n        skip_message=\"Does not support OAEP.\",\n    )\n    def test_invalid_oaep_decryption(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        # More recent versions of OpenSSL may raise different errors.\n        # This test triggers a failure and confirms that we properly handle\n        # it.\n        private_key = rsa_key_2048\n\n        ciphertext = private_key.public_key().encrypt(\n            b\"secure data\",\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None,\n            ),\n        )\n\n        private_key_alt = RSA_KEY_2048_ALT.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n\n        with pytest.raises(ValueError):\n            private_key_alt.decrypt(\n                ciphertext,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA1()),\n                algorithm=hashes.SHA1(),\n                label=None,\n            )\n        ),\n        skip_message=\"Does not support OAEP.\",\n    )\n    def test_invalid_oaep_decryption_data_to_large_for_modulus(self, backend):\n        key = RSA_KEY_2048_ALT.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n\n        ciphertext = (\n            b\"\\xb1ph\\xc0\\x0b\\x1a|\\xe6\\xda\\xea\\xb5\\xd7%\\x94\\x07\\xf96\\xfb\\x96\"\n            b\"\\x11\\x9b\\xdc4\\xea.-\\x91\\x80\\x13S\\x94\\x04m\\xe9\\xc5/F\\x1b\\x9b:\\\\\"\n            b\"\\x1d\\x04\\x16ML\\xae\\xb32J\\x01yuA\\xbb\\x83\\x1c\\x8f\\xf6\\xa5\\xdbp\\xcd\"\n            b\"\\nx\\xc7\\xf6\\x15\\xb2/\\xdcH\\xae\\xe7\\x13\\x13by\\r4t\\x99\\x0fc\\x1f\\xc1\"\n            b\"\\x1c\\xb1\\xdd\\xc5\\x08\\xd1\\xee\\xa1XQ\\xb8H@L5v\\xc3\\xaf\\xf2\\r\\x97\"\n            b\"\\xed\\xaa\\xe7\\xf1\\xd4xai\\xd3\\x83\\xd9\\xaa9\\xbfx\\xe1\\x87F \\x01\\xff\"\n            b\"L\\xccv}ae\\xb3\\xfa\\xf2B\\xb8\\xf9\\x04H\\x94\\x85\\xcb\\x86\\xbb\\\\ghx!W31\"\n            b\"\\xc7;t\\na_E\\xc2\\x16\\xb0;\\xa1\\x18\\t\\x1b\\xe1\\xdb\\x80>)\\x15\\xc6\\x12\"\n            b\"\\xcb\\xeeg`\\x8b\\x9b\\x1b\\x05y4\\xb0\\x84M6\\xcd\\xa1\\x827o\\xfd\\x96\\xba\"\n            b\"Z#\\x8d\\xae\\x01\\xc9\\xf2\\xb6\\xde\\x89{8&eQ\\x1e8\\x03\\x01#?\\xb66\\\\\"\n            b\"\\xad.\\xe9\\xfa!\\x95 c{\\xcaz\\xe0*\\tP\\r\\x91\\x9a)B\\xb5\\xadN\\xf4$\\x83\"\n            b\"\\t\\xb5u\\xab\\x19\\x99\"\n        )\n\n        with pytest.raises(ValueError):\n            key.decrypt(\n                ciphertext,\n                padding.OAEP(\n                    algorithm=hashes.SHA1(),\n                    mgf=padding.MGF1(hashes.SHA1()),\n                    label=None,\n                ),\n            )\n\n    def test_unsupported_oaep_hash(self, rsa_key_2048: rsa.RSAPrivateKey):\n        private_key = rsa_key_2048\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            private_key.decrypt(\n                b\"0\" * 256,\n                padding.OAEP(\n                    mgf=padding.MGF1(DummyHashAlgorithm()),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n            )\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            private_key.decrypt(\n                b\"0\" * 256,\n                padding.OAEP(\n                    mgf=padding.MGF1(hashes.SHA256()),\n                    algorithm=DummyHashAlgorithm(),\n                    label=None,\n                ),\n            )\n\n    def test_unsupported_oaep_mgf(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):\n            private_key.decrypt(\n                b\"0\" * 256,\n                padding.OAEP(\n                    mgf=DummyMGF(),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n            )\n\n\nclass TestRSAEncryption:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.OAEP(\n                mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                algorithm=hashes.SHA256(),\n                label=None,\n            )\n        ),\n        skip_message=\"Does not support OAEP.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_data\", \"pad\"),\n        itertools.product(\n            (\n                RSA_KEY_1024,\n                RSA_KEY_1025,\n                RSA_KEY_1026,\n                RSA_KEY_1027,\n                RSA_KEY_1028,\n                RSA_KEY_1029,\n                RSA_KEY_1030,\n                RSA_KEY_1031,\n                RSA_KEY_1536,\n                RSA_KEY_2048,\n            ),\n            [\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                )\n            ],\n        ),\n    )\n    def test_rsa_encrypt_oaep(self, key_data, pad, backend):\n        private_key = key_data.private_key(unsafe_skip_rsa_key_validation=True)\n        _check_fips_key_length(backend, private_key)\n        pt = b\"encrypt me!\"\n        public_key = private_key.public_key()\n        ct = public_key.encrypt(pt, pad)\n        assert ct != pt\n        assert len(ct) == (public_key.key_size + 7) // 8\n        recovered_pt = private_key.decrypt(ct, pad)\n        assert recovered_pt == pt\n\n    @pytest.mark.parametrize(\n        (\"mgf1hash\", \"oaephash\"),\n        itertools.product(\n            [\n                hashes.SHA1(),\n                hashes.SHA224(),\n                hashes.SHA256(),\n                hashes.SHA384(),\n                hashes.SHA512(),\n            ],\n            [\n                hashes.SHA1(),\n                hashes.SHA224(),\n                hashes.SHA256(),\n                hashes.SHA384(),\n                hashes.SHA512(),\n            ],\n        ),\n    )\n    def test_rsa_encrypt_oaep_sha2(\n        self, rsa_key_2048: rsa.RSAPrivateKey, mgf1hash, oaephash, backend\n    ):\n        pad = padding.OAEP(\n            mgf=padding.MGF1(algorithm=mgf1hash),\n            algorithm=oaephash,\n            label=None,\n        )\n        if not backend.rsa_encryption_supported(pad):\n            pytest.skip(\n                f\"Does not support OAEP using {mgf1hash.name} MGF1 \"\n                f\"or {oaephash.name} hash.\"\n            )\n        private_key = rsa_key_2048\n        pt = b\"encrypt me using sha2 hashes!\"\n        public_key = private_key.public_key()\n        ct = public_key.encrypt(pt, pad)\n        assert ct != pt\n        assert len(ct) == (public_key.key_size + 7) // 8\n        recovered_pt = private_key.decrypt(ct, pad)\n        assert recovered_pt == pt\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.rsa_encryption_supported(\n            padding.PKCS1v15()\n        ),\n        skip_message=\"Does not support PKCS1v1.5.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_data\", \"pad\"),\n        itertools.product(\n            (\n                RSA_KEY_1024,\n                RSA_KEY_1025,\n                RSA_KEY_1026,\n                RSA_KEY_1027,\n                RSA_KEY_1028,\n                RSA_KEY_1029,\n                RSA_KEY_1030,\n                RSA_KEY_1031,\n                RSA_KEY_1536,\n                RSA_KEY_2048,\n            ),\n            [padding.PKCS1v15()],\n        ),\n    )\n    def test_rsa_encrypt_pkcs1v15(self, key_data, pad, backend):\n        private_key = key_data.private_key(unsafe_skip_rsa_key_validation=True)\n        _check_fips_key_length(backend, private_key)\n        pt = b\"encrypt me!\"\n        public_key = private_key.public_key()\n        ct = public_key.encrypt(pt, pad)\n        assert ct != pt\n        assert len(ct) == (public_key.key_size + 7) // 8\n        recovered_pt = private_key.decrypt(ct, pad)\n        assert recovered_pt == pt\n\n    @pytest.mark.parametrize(\n        (\"key_data\", \"pad\"),\n        itertools.product(\n            (\n                RSA_KEY_1024,\n                RSA_KEY_1025,\n                RSA_KEY_1026,\n                RSA_KEY_1027,\n                RSA_KEY_1028,\n                RSA_KEY_1029,\n                RSA_KEY_1030,\n                RSA_KEY_1031,\n                RSA_KEY_1536,\n                RSA_KEY_2048,\n            ),\n            (\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n                padding.PKCS1v15(),\n            ),\n        ),\n    )\n    def test_rsa_encrypt_key_too_small(self, key_data, pad, backend):\n        private_key = key_data.private_key(unsafe_skip_rsa_key_validation=True)\n        if not backend.rsa_encryption_supported(pad):\n            pytest.skip(\"PKCS1v15 padding not allowed in FIPS\")\n        _check_fips_key_length(backend, private_key)\n        public_key = private_key.public_key()\n        # Slightly smaller than the key size but not enough for padding.\n        with pytest.raises(ValueError):\n            public_key.encrypt(b\"\\x00\" * (private_key.key_size // 8 - 1), pad)\n\n        # Larger than the key size.\n        with pytest.raises(ValueError):\n            public_key.encrypt(b\"\\x00\" * (private_key.key_size // 8 + 5), pad)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend._fips_enabled,\n        skip_message=\"Requires FIPS\",\n    )\n    def test_rsa_fips_small_key(self, rsa_key_512: rsa.RSAPrivateKey, backend):\n        with pytest.raises(ValueError):\n            rsa_key_512.sign(b\"somedata\", padding.PKCS1v15(), hashes.SHA512())\n\n    def test_unsupported_padding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            public_key.encrypt(b\"somedata\", DummyAsymmetricPadding())\n        with pytest.raises(TypeError):\n            public_key.encrypt(\n                b\"somedata\",\n                padding=object(),  # type: ignore[arg-type]\n            )\n\n    def test_unsupported_oaep_mgf(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        private_key = rsa_key_2048\n        public_key = private_key.public_key()\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MGF):\n            public_key.encrypt(\n                b\"ciphertext\",\n                padding.OAEP(\n                    mgf=DummyMGF(),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n            )\n\n\nclass TestRSANumbers:\n    def test_rsa_public_numbers(self):\n        public_numbers = rsa.RSAPublicNumbers(e=1, n=15)\n        assert public_numbers.e == 1\n        assert public_numbers.n == 15\n\n    def test_rsa_private_numbers(self):\n        public_numbers = rsa.RSAPublicNumbers(e=1, n=15)\n        private_numbers = rsa.RSAPrivateNumbers(\n            p=3,\n            q=5,\n            d=1,\n            dmp1=1,\n            dmq1=1,\n            iqmp=2,\n            public_numbers=public_numbers,\n        )\n\n        assert private_numbers.p == 3\n        assert private_numbers.q == 5\n        assert private_numbers.d == 1\n        assert private_numbers.dmp1 == 1\n        assert private_numbers.dmq1 == 1\n        assert private_numbers.iqmp == 2\n        assert private_numbers.public_numbers == public_numbers\n\n    def test_rsa_private_numbers_create_key(self, backend):\n        private_key = RSA_KEY_1024.private_key(\n            backend, unsafe_skip_rsa_key_validation=True\n        )\n        assert private_key\n\n    def test_rsa_public_numbers_create_key(self, backend):\n        public_key = RSA_KEY_1024.public_numbers.public_key(backend)\n        assert public_key\n\n        public_key = rsa.RSAPublicNumbers(n=10, e=3).public_key(backend)\n        assert public_key\n\n    def test_public_numbers_invalid_types(self):\n        with pytest.raises(TypeError):\n            rsa.RSAPublicNumbers(e=None, n=15)  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            rsa.RSAPublicNumbers(e=1, n=None)  # type: ignore[arg-type]\n\n    @pytest.mark.parametrize(\n        (\"p\", \"q\", \"d\", \"dmp1\", \"dmq1\", \"iqmp\", \"public_numbers\"),\n        [\n            (None, 5, 1, 1, 1, 2, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, None, 1, 1, 1, 2, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, 5, None, 1, 1, 2, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, 5, 1, None, 1, 2, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, 5, 1, 1, None, 2, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, 5, 1, 1, 1, None, rsa.RSAPublicNumbers(e=1, n=15)),\n            (3, 5, 1, 1, 1, 2, None),\n        ],\n    )\n    def test_private_numbers_invalid_types(\n        self, p, q, d, dmp1, dmq1, iqmp, public_numbers\n    ):\n        with pytest.raises(TypeError):\n            rsa.RSAPrivateNumbers(\n                p=p,\n                q=q,\n                d=d,\n                dmp1=dmp1,\n                dmq1=dmq1,\n                iqmp=iqmp,\n                public_numbers=public_numbers,\n            )\n\n    @pytest.mark.parametrize(\n        (\"e\", \"n\"),\n        [\n            (7, 2),  # modulus < 3\n            (1, 15),  # public_exponent < 3\n            (17, 15),  # public_exponent > modulus\n            (14, 15),  # public_exponent not odd\n        ],\n    )\n    def test_invalid_public_numbers_argument_values(self, e, n, backend):\n        # Start with public_exponent=7, modulus=15. Then change one value at a\n        # time to test the bounds.\n\n        with pytest.raises(ValueError):\n            rsa.RSAPublicNumbers(e=e, n=n).public_key(backend)\n\n    @pytest.mark.parametrize(\n        (\"p\", \"q\", \"d\", \"dmp1\", \"dmq1\", \"iqmp\", \"e\", \"n\"),\n        [\n            (3, 11, 3, 1, 3, 2, 7, 2),  # modulus < 3\n            (3, 11, 3, 1, 3, 2, 7, 35),  # modulus != p * q\n            (37, 11, 3, 1, 3, 2, 7, 33),  # p > modulus\n            (3, 37, 3, 1, 3, 2, 7, 33),  # q > modulus\n            (3, 11, 3, 35, 3, 2, 7, 33),  # dmp1 > modulus\n            (3, 11, 3, 1, 35, 2, 7, 33),  # dmq1 > modulus\n            (3, 11, 3, 1, 3, 35, 7, 33),  # iqmp > modulus\n            (3, 11, 37, 1, 3, 2, 7, 33),  # d > modulus\n            (3, 11, 3, 1, 3, 2, 1, 33),  # public_exponent < 3\n            (3, 11, 3, 1, 3, 35, 65537, 33),  # public_exponent > modulus\n            (3, 11, 3, 1, 3, 2, 6, 33),  # public_exponent is not odd\n            (3, 11, 3, 2, 3, 2, 7, 33),  # dmp1 is not odd\n            (3, 11, 3, 1, 4, 2, 7, 33),  # dmq1 is not odd\n        ],\n    )\n    def test_invalid_private_numbers_argument_values(\n        self, p, q, d, dmp1, dmq1, iqmp, e, n, backend\n    ):\n        # Start with p=3, q=11, private_exponent=3, public_exponent=7,\n        # modulus=33, dmp1=1, dmq1=3, iqmp=2. Then change one value at\n        # a time to test the bounds.\n\n        with pytest.raises(ValueError):\n            rsa.RSAPrivateNumbers(\n                p=p,\n                q=q,\n                d=d,\n                dmp1=dmp1,\n                dmq1=dmq1,\n                iqmp=iqmp,\n                public_numbers=rsa.RSAPublicNumbers(e=e, n=n),\n            ).private_key(backend)\n\n    def test_public_number_repr(self):\n        num = RSAPublicNumbers(1, 1)\n        assert repr(num) == \"<RSAPublicNumbers(e=1, n=1)>\"\n\n\nclass TestRSANumbersEquality:\n    def test_public_numbers_eq(self):\n        num = RSAPublicNumbers(1, 2)\n        num2 = RSAPublicNumbers(1, 2)\n        assert num == num2\n\n    def test_public_numbers_ne(self):\n        num = RSAPublicNumbers(1, 2)\n        assert num != RSAPublicNumbers(2, 2)\n        assert num != RSAPublicNumbers(1, 3)\n        assert num != object()\n\n    def test_private_numbers_eq(self):\n        pub = RSAPublicNumbers(1, 2)\n        num = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub)\n        pub2 = RSAPublicNumbers(1, 2)\n        num2 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub2)\n        assert num == num2\n\n    def test_private_numbers_ne(self):\n        pub = RSAPublicNumbers(1, 2)\n        num = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, pub)\n        assert num != RSAPrivateNumbers(\n            1, 2, 3, 4, 5, 7, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 2, 3, 4, 4, 6, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 2, 3, 5, 5, 6, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 2, 4, 4, 5, 6, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 3, 3, 4, 5, 6, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            2, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 2, 3, 4, 5, 6, RSAPublicNumbers(2, 2)\n        )\n        assert num != RSAPrivateNumbers(\n            1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 3)\n        )\n        assert num != object()\n\n    def test_public_numbers_hash(self):\n        pub1 = RSAPublicNumbers(3, 17)\n        pub2 = RSAPublicNumbers(3, 17)\n        pub3 = RSAPublicNumbers(7, 21)\n\n        assert hash(pub1) == hash(pub2)\n        assert hash(pub1) != hash(pub3)\n\n    def test_private_numbers_hash(self):\n        priv1 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2))\n        priv2 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 2))\n        priv3 = RSAPrivateNumbers(1, 2, 3, 4, 5, 6, RSAPublicNumbers(1, 3))\n\n        assert hash(priv1) == hash(priv2)\n        assert hash(priv1) != hash(priv3)\n\n\nclass TestRSAPrimeFactorRecovery:\n    def test_recover_prime_factors(self, subtests):\n        for key in [\n            RSA_KEY_1024,\n            RSA_KEY_1025,\n            RSA_KEY_1026,\n            RSA_KEY_1027,\n            RSA_KEY_1028,\n            RSA_KEY_1029,\n            RSA_KEY_1030,\n            RSA_KEY_1031,\n            RSA_KEY_1536,\n            RSA_KEY_2048,\n        ]:\n            with subtests.test():\n                p, q = rsa.rsa_recover_prime_factors(\n                    key.public_numbers.n,\n                    key.public_numbers.e,\n                    key.d,\n                )\n                # Unfortunately there is no convention on which prime should be\n                # p and which one q. The function we use always makes p > q,\n                # but the NIST vectors are not so consistent. Accordingly, we\n                # verify we've recovered the proper (p, q) by sorting them and\n                # asserting on that.\n                assert sorted([p, q]) == sorted([key.p, key.q])\n                assert p > q\n\n    def test_invalid_recover_prime_factors(self):\n        with pytest.raises(ValueError):\n            rsa.rsa_recover_prime_factors(34, 3, 7)\n\n\nclass TestRSAPrivateKeySerialization:\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        itertools.product(\n            [\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.PrivateFormat.PKCS8,\n            ],\n            [\n                b\"s\",\n                b\"longerpassword\",\n                b\"!*$&(@#$*&($T@%_somesymbols\",\n                b\"\\x01\" * 1000,\n            ],\n        ),\n    )\n    def test_private_bytes_encrypted_pem(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend, fmt, password\n    ):\n        skip_fips_traditional_openssl(backend, fmt)\n        key = rsa_key_2048\n        serialized = key.private_bytes(\n            serialization.Encoding.PEM,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_pem_private_key(\n            serialized, password, backend, unsafe_skip_rsa_key_validation=True\n        )\n        assert isinstance(loaded_key, rsa.RSAPrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend._fips_enabled,\n        skip_message=\"Requires FIPS\",\n    )\n    def test_traditional_serialization_fips(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.BestAvailableEncryption(b\"password\"),\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (serialization.Encoding.Raw, serialization.PrivateFormat.PKCS8),\n            (serialization.Encoding.DER, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.Raw, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.X962, serialization.PrivateFormat.PKCS8),\n        ],\n    )\n    def test_private_bytes_rejects_invalid(\n        self, rsa_key_2048: rsa.RSAPrivateKey, encoding, fmt, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(ValueError):\n            key.private_bytes(encoding, fmt, serialization.NoEncryption())\n\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        [\n            [serialization.PrivateFormat.PKCS8, b\"s\"],\n            [serialization.PrivateFormat.PKCS8, b\"longerpassword\"],\n            [serialization.PrivateFormat.PKCS8, b\"!*$&(@#$*&($T@%_somesymbol\"],\n            [serialization.PrivateFormat.PKCS8, b\"\\x01\" * 1000],\n        ],\n    )\n    def test_private_bytes_encrypted_der(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend, fmt, password\n    ):\n        key = rsa_key_2048\n        serialized = key.private_bytes(\n            serialization.Encoding.DER,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_der_private_key(\n            serialized, password, backend, unsafe_skip_rsa_key_validation=True\n        )\n        assert isinstance(loaded_key, rsa.RSAPrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"loader_func\"),\n        [\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_der_private_key,\n            ],\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_unencrypted(\n        self,\n        rsa_key_2048: rsa.RSAPrivateKey,\n        backend,\n        encoding,\n        fmt,\n        loader_func,\n    ):\n        key = rsa_key_2048\n        serialized = key.private_bytes(\n            encoding, fmt, serialization.NoEncryption()\n        )\n        loaded_key = loader_func(\n            serialized, None, backend, unsafe_skip_rsa_key_validation=True\n        )\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.skip_fips(\n        reason=\"Traditional OpenSSL key format is not supported in FIPS mode.\"\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader_func\"),\n        [\n            [\n                os.path.join(\n                    \"asymmetric\",\n                    \"Traditional_OpenSSL_Serialization\",\n                    \"testrsa.pem\",\n                ),\n                serialization.Encoding.PEM,\n                serialization.load_pem_private_key,\n            ],\n            [\n                os.path.join(\"asymmetric\", \"DER_Serialization\", \"testrsa.der\"),\n                serialization.Encoding.DER,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_traditional_openssl_unencrypted(\n        self, backend, key_path, encoding, loader_func\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(\n            key_bytes, None, backend, unsafe_skip_rsa_key_validation=True\n        )\n        serialized = key.private_bytes(\n            encoding,\n            serialization.PrivateFormat.TraditionalOpenSSL,\n            serialization.NoEncryption(),\n        )\n        assert serialized == key_bytes\n\n    def test_private_bytes_traditional_der_encrypted_invalid(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.BestAvailableEncryption(b\"password\"),\n            )\n\n    def test_private_bytes_invalid_encoding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_format(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encryption_algorithm(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                \"notanencalg\",  # type: ignore[arg-type]\n            )\n\n    def test_private_bytes_unsupported_encryption_type(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                DummyKeySerializationEncryption(),\n            )\n\n\nclass TestRSAPEMPublicKeySerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"encoding\", \"format\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"public\", \"PKCS1\", \"rsa.pub.pem\"),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n                serialization.PublicFormat.PKCS1,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"public\", \"PKCS1\", \"rsa.pub.der\"),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n                serialization.PublicFormat.PKCS1,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-rsa-pkcs8.pub.pem\"),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ),\n            (\n                os.path.join(\n                    \"asymmetric\",\n                    \"DER_Serialization\",\n                    \"unenc-rsa-pkcs8.pub.der\",\n                ),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, key_path, loader_func, encoding, format, backend\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, backend)\n        serialized = key.public_bytes(encoding, format)\n        assert serialized == key_bytes\n\n    def test_public_bytes_openssh(self, backend):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"public\", \"PKCS1\", \"rsa.pub.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = serialization.load_pem_public_key(key_bytes, backend)\n\n        ssh_bytes = key.public_bytes(\n            serialization.Encoding.OpenSSH, serialization.PublicFormat.OpenSSH\n        )\n        assert ssh_bytes == (\n            b\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAAgQC7JHoJfg6yNzLMOWet8Z49a4KD\"\n            b\"0dCspMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkkFPZk/7x0\"\n            b\"xmdsTPECSWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAvSKAFKEvy\"\n            b\"D43si00DQnXWrYHAEQ==\"\n        )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.OpenSSH\n            )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.DER, serialization.PublicFormat.OpenSSH\n            )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.OpenSSH,\n                serialization.PublicFormat.PKCS1,\n            )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.OpenSSH,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n    def test_public_bytes_invalid_encoding(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048.public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PublicFormat.PKCS1,\n            )\n\n    def test_public_bytes_invalid_format(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        key = rsa_key_2048.public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ),\n            (serialization.Encoding.Raw, serialization.PublicFormat.PKCS1),\n            *itertools.product(\n                [\n                    serialization.Encoding.Raw,\n                    serialization.Encoding.X962,\n                    serialization.Encoding.PEM,\n                    serialization.Encoding.DER,\n                ],\n                [\n                    serialization.PublicFormat.Raw,\n                    serialization.PublicFormat.UncompressedPoint,\n                    serialization.PublicFormat.CompressedPoint,\n                ],\n            ),\n        ],\n    )\n    def test_public_bytes_rejects_invalid(\n        self, rsa_key_2048: rsa.RSAPrivateKey, encoding, fmt, backend\n    ):\n        key = rsa_key_2048.public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(encoding, fmt)\n\n    def test_public_key_equality(self, rsa_key_2048: rsa.RSAPrivateKey):\n        key1 = rsa_key_2048.public_key()\n        key2 = RSA_KEY_2048.private_key(\n            unsafe_skip_rsa_key_validation=True\n        ).public_key()\n        key3 = RSA_KEY_2048_ALT.private_key(\n            unsafe_skip_rsa_key_validation=True\n        ).public_key()\n        assert key1 == key2\n        assert key1 != key3\n        assert key1 != object()\n        with pytest.raises(TypeError):\n            key1 < key2  # type: ignore[operator]\n\n    def test_public_key_copy(self, rsa_key_2048: rsa.RSAPrivateKey):\n        key1 = rsa_key_2048.public_key()\n        key2 = copy.copy(key1)\n\n        assert key1 == key2\n", "tests/hazmat/primitives/test_pbkdf2hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey, _Reasons\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nfrom ...doubles import DummyHashAlgorithm\nfrom ...utils import raises_unsupported_algorithm\n\n\nclass TestPBKDF2HMAC:\n    def test_already_finalized(self, backend):\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        kdf.derive(b\"password\")\n        with pytest.raises(AlreadyFinalized):\n            kdf.derive(b\"password2\")\n\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        key = kdf.derive(b\"password\")\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(b\"password\", key)\n\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        kdf.verify(b\"password\", key)\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(b\"password\", key)\n\n    def test_unsupported_algorithm(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            PBKDF2HMAC(DummyHashAlgorithm(), 20, b\"salt\", 10, backend)\n\n    def test_invalid_key(self, backend):\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        key = kdf.derive(b\"password\")\n\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        with pytest.raises(InvalidKey):\n            kdf.verify(b\"password2\", key)\n\n    def test_unicode_error_with_salt(self, backend):\n        with pytest.raises(TypeError):\n            PBKDF2HMAC(\n                hashes.SHA1(),\n                20,\n                \"salt\",  # type: ignore[arg-type]\n                10,\n                backend,\n            )\n\n    def test_unicode_error_with_key_material(self, backend):\n        kdf = PBKDF2HMAC(hashes.SHA1(), 20, b\"salt\", 10, backend)\n        with pytest.raises(TypeError):\n            kdf.derive(\"unicode here\")  # type: ignore[arg-type]\n\n    def test_buffer_protocol(self, backend):\n        kdf = PBKDF2HMAC(hashes.SHA1(), 10, b\"salt\", 10, backend)\n        data = bytearray(b\"data\")\n        assert kdf.derive(data) == b\"\\xe9n\\xaa\\x81\\xbbt\\xa4\\xf6\\x08\\xce\"\n", "tests/hazmat/primitives/test_x963kdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.x963kdf import X963KDF\n\n\nclass TestX963KDF:\n    def test_length_limit(self, backend):\n        big_length = hashes.SHA256().digest_size * (2**32 - 1) + 1\n\n        with pytest.raises(ValueError):\n            X963KDF(hashes.SHA256(), big_length, None, backend)\n\n    def test_already_finalized(self, backend):\n        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)\n\n        xkdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            xkdf.derive(b\"\\x02\" * 16)\n\n    def test_derive(self, backend):\n        key = binascii.unhexlify(\n            b\"96c05619d56c328ab95fe84b18264b08725b85e33fd34f08\"\n        )\n\n        derivedkey = binascii.unhexlify(b\"443024c3dae66b95e6f5670601558f71\")\n\n        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)\n\n        assert xkdf.derive(key) == derivedkey\n\n    def test_buffer_protocol(self, backend):\n        key = bytearray(\n            binascii.unhexlify(\n                b\"96c05619d56c328ab95fe84b18264b08725b85e33fd34f08\"\n            )\n        )\n\n        derivedkey = binascii.unhexlify(b\"443024c3dae66b95e6f5670601558f71\")\n\n        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)\n\n        assert xkdf.derive(key) == derivedkey\n\n    def test_verify(self, backend):\n        key = binascii.unhexlify(\n            b\"22518b10e70f2a3f243810ae3254139efbee04aa57c7af7d\"\n        )\n\n        sharedinfo = binascii.unhexlify(b\"75eef81aa3041e33b80971203d2c0c52\")\n\n        derivedkey = binascii.unhexlify(\n            b\"c498af77161cc59f2962b9a713e2b215152d139766ce34a776df11866a69bf2e\"\n            b\"52a13d9c7c6fc878c50c5ea0bc7b00e0da2447cfd874f6cf92f30d0097111485\"\n            b\"500c90c3af8b487872d04685d14c8d1dc8d7fa08beb0ce0ababc11f0bd496269\"\n            b\"142d43525a78e5bc79a17f59676a5706dc54d54d4d1f0bd7e386128ec26afc21\"\n        )\n\n        xkdf = X963KDF(hashes.SHA256(), 128, sharedinfo, backend)\n\n        xkdf.verify(key, derivedkey)\n\n    def test_invalid_verify(self, backend):\n        key = binascii.unhexlify(\n            b\"96c05619d56c328ab95fe84b18264b08725b85e33fd34f08\"\n        )\n\n        xkdf = X963KDF(hashes.SHA256(), 16, None, backend)\n\n        with pytest.raises(InvalidKey):\n            xkdf.verify(key, b\"wrong derived key\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            X963KDF(\n                hashes.SHA256(),\n                16,\n                sharedinfo=\"foo\",  # type: ignore[arg-type]\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            xkdf = X963KDF(\n                hashes.SHA256(), 16, sharedinfo=None, backend=backend\n            )\n\n            xkdf.derive(\"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            xkdf = X963KDF(\n                hashes.SHA256(), 16, sharedinfo=None, backend=backend\n            )\n\n            xkdf.verify(\"foo\", b\"bar\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            xkdf = X963KDF(\n                hashes.SHA256(), 16, sharedinfo=None, backend=backend\n            )\n\n            xkdf.verify(b\"foo\", \"bar\")  # type: ignore[arg-type]\n", "tests/hazmat/primitives/test_sm4.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidTag\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\nfrom ...utils import load_nist_vectors, load_vectors_from_file\nfrom .utils import generate_encrypt_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support SM4 ECB\",\n)\nclass TestSM4ModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SM4\"),\n        [\"draft-ribose-cfrg-sm4-10-ecb.txt\"],\n        lambda key, **kwargs: algorithms.SM4(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SM4 CBC\",\n)\nclass TestSM4ModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SM4\"),\n        [\"draft-ribose-cfrg-sm4-10-cbc.txt\"],\n        lambda key, **kwargs: algorithms.SM4(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SM4 OFB\",\n)\nclass TestSM4ModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SM4\"),\n        [\"draft-ribose-cfrg-sm4-10-ofb.txt\"],\n        lambda key, **kwargs: algorithms.SM4(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SM4 CFB\",\n)\nclass TestSM4ModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SM4\"),\n        [\"draft-ribose-cfrg-sm4-10-cfb.txt\"],\n        lambda key, **kwargs: algorithms.SM4(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.CTR(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SM4 CTR\",\n)\nclass TestSM4ModeCTR:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SM4\"),\n        [\"draft-ribose-cfrg-sm4-10-ctr.txt\"],\n        lambda key, **kwargs: algorithms.SM4(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CTR(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.SM4(b\"\\x00\" * 16), modes.GCM(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SM4 GCM\",\n)\nclass TestSM4ModeGCM:\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"ciphers\", \"SM4\", \"rfc8998.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_encryption(self, vector, backend):\n        key = binascii.unhexlify(vector[\"key\"])\n        iv = binascii.unhexlify(vector[\"iv\"])\n        associated_data = binascii.unhexlify(vector[\"aad\"])\n        tag = binascii.unhexlify(vector[\"tag\"])\n        plaintext = binascii.unhexlify(vector[\"plaintext\"])\n        ciphertext = binascii.unhexlify(vector[\"ciphertext\"])\n\n        cipher = base.Cipher(algorithms.SM4(key), modes.GCM(iv))\n        encryptor = cipher.encryptor()\n        encryptor.authenticate_additional_data(associated_data)\n        computed_ct = encryptor.update(plaintext) + encryptor.finalize()\n        assert computed_ct == ciphertext\n        assert encryptor.tag == tag\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"ciphers\", \"SM4\", \"rfc8998.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_decryption(self, vector, backend):\n        key = binascii.unhexlify(vector[\"key\"])\n        iv = binascii.unhexlify(vector[\"iv\"])\n        associated_data = binascii.unhexlify(vector[\"aad\"])\n        tag = binascii.unhexlify(vector[\"tag\"])\n        plaintext = binascii.unhexlify(vector[\"plaintext\"])\n        ciphertext = binascii.unhexlify(vector[\"ciphertext\"])\n\n        cipher = base.Cipher(algorithms.SM4(key), modes.GCM(iv, tag))\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(associated_data)\n        computed_pt = decryptor.update(ciphertext) + decryptor.finalize()\n        assert computed_pt == plaintext\n\n        cipher_no_tag = base.Cipher(algorithms.SM4(key), modes.GCM(iv))\n        decryptor = cipher_no_tag.decryptor()\n        decryptor.authenticate_additional_data(associated_data)\n        computed_pt = decryptor.update(\n            ciphertext\n        ) + decryptor.finalize_with_tag(tag)\n        assert computed_pt == plaintext\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"ciphers\", \"SM4\", \"rfc8998.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_invalid_tag(self, vector, backend):\n        key = binascii.unhexlify(vector[\"key\"])\n        iv = binascii.unhexlify(vector[\"iv\"])\n        associated_data = binascii.unhexlify(vector[\"aad\"])\n        tag = binascii.unhexlify(vector[\"tag\"])\n        ciphertext = binascii.unhexlify(vector[\"ciphertext\"])\n\n        cipher = base.Cipher(algorithms.SM4(key), modes.GCM(iv, tag))\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(associated_data)\n        decryptor.update(ciphertext[:-1])\n        with pytest.raises(InvalidTag):\n            decryptor.finalize()\n\n        cipher_no_tag = base.Cipher(algorithms.SM4(key), modes.GCM(iv))\n        decryptor = cipher_no_tag.decryptor()\n        decryptor.authenticate_additional_data(associated_data)\n        decryptor.update(ciphertext[:-1])\n        with pytest.raises(InvalidTag):\n            decryptor.finalize_with_tag(tag)\n", "tests/hazmat/primitives/test_chacha20.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\nimport struct\n\nimport pytest\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms\n\nfrom ...utils import load_nist_vectors\nfrom .utils import _load_all_params\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.ChaCha20(b\"\\x00\" * 32, b\"0\" * 16), None\n    ),\n    skip_message=\"Does not support ChaCha20\",\n)\nclass TestChaCha20:\n    @pytest.mark.parametrize(\n        \"vector\",\n        _load_all_params(\n            os.path.join(\"ciphers\", \"ChaCha20\"),\n            [\"counter-overflow.txt\", \"rfc7539.txt\"],\n            load_nist_vectors,\n        ),\n    )\n    def test_vectors(self, vector, backend):\n        key = binascii.unhexlify(vector[\"key\"])\n        nonce = binascii.unhexlify(vector[\"nonce\"])\n        ibc = struct.pack(\"<Q\", int(vector[\"initial_block_counter\"]))\n        pt = binascii.unhexlify(vector[\"plaintext\"])\n        encryptor = Cipher(\n            algorithms.ChaCha20(key, ibc + nonce), None, backend\n        ).encryptor()\n        computed_ct = encryptor.update(pt) + encryptor.finalize()\n        assert binascii.hexlify(computed_ct) == vector[\"ciphertext\"]\n\n    def test_buffer_protocol(self, backend):\n        key = bytearray(os.urandom(32))\n        nonce = bytearray(os.urandom(16))\n        cipher = Cipher(algorithms.ChaCha20(key, nonce), None, backend)\n        enc = cipher.encryptor()\n        ct = enc.update(bytearray(b\"hello\")) + enc.finalize()\n        dec = cipher.decryptor()\n        pt = dec.update(ct) + dec.finalize()\n        assert pt == b\"hello\"\n\n    def test_key_size(self):\n        chacha = algorithms.ChaCha20(b\"0\" * 32, b\"0\" * 16)\n        assert chacha.key_size == 256\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            algorithms.ChaCha20(b\"wrongsize\", b\"0\" * 16)\n\n    def test_invalid_nonce(self):\n        with pytest.raises(ValueError):\n            algorithms.ChaCha20(b\"0\" * 32, b\"0\")\n\n        with pytest.raises(TypeError):\n            algorithms.ChaCha20(b\"0\" * 32, object())  # type:ignore[arg-type]\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            algorithms.ChaCha20(\"0\" * 32, b\"0\" * 16)  # type:ignore[arg-type]\n\n    def test_partial_blocks(self, backend):\n        # Test that partial blocks and counter increments are handled\n        # correctly. Successive calls to update should return the same\n        # as if the entire input was passed in a single call:\n        # update(pt[0:n]) + update(pt[n:m]) + update(pt[m:]) == update(pt)\n        key = bytearray(os.urandom(32))\n        nonce = bytearray(os.urandom(16))\n        cipher = Cipher(algorithms.ChaCha20(key, nonce), None, backend)\n        pt = bytearray(os.urandom(96 * 3))\n\n        enc_full = cipher.encryptor()\n        ct_full = enc_full.update(pt)\n\n        enc_partial = cipher.encryptor()\n        len_partial = len(pt) // 3\n        ct_partial_1 = enc_partial.update(pt[:len_partial])\n        ct_partial_2 = enc_partial.update(pt[len_partial : len_partial * 2])\n        ct_partial_3 = enc_partial.update(pt[len_partial * 2 :])\n\n        assert ct_full == ct_partial_1 + ct_partial_2 + ct_partial_3\n", "tests/hazmat/primitives/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    AlreadyUpdated,\n    InvalidSignature,\n    InvalidTag,\n    NotYetFinalized,\n)\nfrom cryptography.hazmat.decrepit.ciphers import (\n    algorithms as decrepit_algorithms,\n)\nfrom cryptography.hazmat.primitives import hashes, hmac, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    Cipher,\n    algorithms,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import GCM\nfrom cryptography.hazmat.primitives.kdf.hkdf import HKDF, HKDFExpand\nfrom cryptography.hazmat.primitives.kdf.kbkdf import (\n    KBKDFCMAC,\n    KBKDFHMAC,\n    CounterLocation,\n    Mode,\n)\n\nfrom ...utils import load_vectors_from_file\n\n\ndef _load_all_params(path, file_names, param_loader):\n    all_params = []\n    for file_name in file_names:\n        all_params.extend(\n            load_vectors_from_file(os.path.join(path, file_name), param_loader)\n        )\n    return all_params\n\n\ndef generate_encrypt_test(\n    param_loader, path, file_names, cipher_factory, mode_factory\n):\n    def test_encryption(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                encrypt_test(backend, cipher_factory, mode_factory, params)\n\n    return test_encryption\n\n\ndef encrypt_test(backend, cipher_factory, mode_factory, params):\n    assert backend.cipher_supported(\n        cipher_factory(**params), mode_factory(**params)\n    )\n\n    plaintext = params[\"plaintext\"]\n    ciphertext = params[\"ciphertext\"]\n    cipher = Cipher(\n        cipher_factory(**params), mode_factory(**params), backend=backend\n    )\n    encryptor = cipher.encryptor()\n    actual_ciphertext = encryptor.update(binascii.unhexlify(plaintext))\n    actual_ciphertext += encryptor.finalize()\n    assert actual_ciphertext == binascii.unhexlify(ciphertext)\n    decryptor = cipher.decryptor()\n    actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))\n    actual_plaintext += decryptor.finalize()\n    assert actual_plaintext == binascii.unhexlify(plaintext)\n\n\ndef generate_aead_test(\n    param_loader, path, file_names, cipher_factory, mode_factory\n):\n    assert mode_factory is GCM\n\n    def test_aead(self, backend, subtests):\n        all_params = _load_all_params(path, file_names, param_loader)\n        # We don't support IVs < 64-bit in GCM mode so just strip them out\n        all_params = [i for i in all_params if len(i[\"iv\"]) >= 16]\n        for params in all_params:\n            with subtests.test():\n                aead_test(backend, cipher_factory, mode_factory, params)\n\n    return test_aead\n\n\ndef aead_test(backend, cipher_factory, mode_factory, params):\n    if (\n        mode_factory is GCM\n        and backend._fips_enabled\n        and len(params[\"iv\"]) != 24\n    ):\n        # Red Hat disables non-96-bit IV support as part of its FIPS\n        # patches. The check is for a byte length of 24 because the value is\n        # hex encoded.\n        pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n\n    tag = binascii.unhexlify(params[\"tag\"])\n    mode = mode_factory(\n        binascii.unhexlify(params[\"iv\"]),\n        tag,\n        len(tag),\n    )\n    assert isinstance(mode, GCM)\n    if params.get(\"pt\") is not None:\n        plaintext = binascii.unhexlify(params[\"pt\"])\n    ciphertext = binascii.unhexlify(params[\"ct\"])\n    aad = binascii.unhexlify(params[\"aad\"])\n    if params.get(\"fail\") is True:\n        cipher = Cipher(\n            cipher_factory(binascii.unhexlify(params[\"key\"])),\n            mode,\n            backend,\n        )\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(aad)\n        actual_plaintext = decryptor.update(ciphertext)\n        with pytest.raises(InvalidTag):\n            decryptor.finalize()\n    else:\n        cipher = Cipher(\n            cipher_factory(binascii.unhexlify(params[\"key\"])),\n            mode_factory(binascii.unhexlify(params[\"iv\"]), None),\n            backend,\n        )\n        encryptor = cipher.encryptor()\n        encryptor.authenticate_additional_data(aad)\n        actual_ciphertext = encryptor.update(plaintext)\n        actual_ciphertext += encryptor.finalize()\n        assert encryptor.tag[: len(tag)] == tag\n        cipher = Cipher(\n            cipher_factory(binascii.unhexlify(params[\"key\"])),\n            mode_factory(\n                binascii.unhexlify(params[\"iv\"]),\n                tag,\n                min_tag_length=len(tag),\n            ),\n            backend,\n        )\n        decryptor = cipher.decryptor()\n        decryptor.authenticate_additional_data(aad)\n        actual_plaintext = decryptor.update(ciphertext)\n        actual_plaintext += decryptor.finalize()\n        assert actual_plaintext == plaintext\n\n\ndef generate_stream_encryption_test(\n    param_loader, path, file_names, cipher_factory\n):\n    def test_stream_encryption(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                stream_encryption_test(backend, cipher_factory, params)\n\n    return test_stream_encryption\n\n\ndef stream_encryption_test(backend, cipher_factory, params):\n    plaintext = params[\"plaintext\"]\n    ciphertext = params[\"ciphertext\"]\n    offset = params[\"offset\"]\n    cipher = Cipher(cipher_factory(**params), None, backend=backend)\n    encryptor = cipher.encryptor()\n    # throw away offset bytes\n    encryptor.update(b\"\\x00\" * int(offset))\n    actual_ciphertext = encryptor.update(binascii.unhexlify(plaintext))\n    actual_ciphertext += encryptor.finalize()\n    assert actual_ciphertext == binascii.unhexlify(ciphertext)\n    decryptor = cipher.decryptor()\n    decryptor.update(b\"\\x00\" * int(offset))\n    actual_plaintext = decryptor.update(binascii.unhexlify(ciphertext))\n    actual_plaintext += decryptor.finalize()\n    assert actual_plaintext == binascii.unhexlify(plaintext)\n\n\ndef generate_hash_test(param_loader, path, file_names, hash_cls):\n    def test_hash(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                hash_test(backend, hash_cls, params)\n\n    return test_hash\n\n\ndef hash_test(backend, algorithm, params):\n    msg, md = params\n    m = hashes.Hash(algorithm, backend=backend)\n    m.update(binascii.unhexlify(msg))\n    expected_md = md.replace(\" \", \"\").lower().encode(\"ascii\")\n    assert m.finalize() == binascii.unhexlify(expected_md)\n\n\ndef generate_base_hash_test(algorithm, digest_size):\n    def test_base_hash(self, backend):\n        base_hash_test(backend, algorithm, digest_size)\n\n    return test_base_hash\n\n\ndef base_hash_test(backend, algorithm, digest_size):\n    m = hashes.Hash(algorithm, backend=backend)\n    assert m.algorithm.digest_size == digest_size\n    m_copy = m.copy()\n    assert m != m_copy\n\n    m.update(b\"abc\")\n    copy = m.copy()\n    copy.update(b\"123\")\n    m.update(b\"123\")\n    assert copy.finalize() == m.finalize()\n\n\ndef generate_base_hmac_test(hash_cls):\n    def test_base_hmac(self, backend):\n        base_hmac_test(backend, hash_cls)\n\n    return test_base_hmac\n\n\ndef base_hmac_test(backend, algorithm):\n    key = b\"ab\"\n    h = hmac.HMAC(binascii.unhexlify(key), algorithm, backend=backend)\n    h_copy = h.copy()\n    assert h != h_copy\n\n\ndef generate_hmac_test(param_loader, path, file_names, algorithm):\n    def test_hmac(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                hmac_test(backend, algorithm, params)\n\n    return test_hmac\n\n\ndef hmac_test(backend, algorithm, params):\n    msg, md, key = params\n    h = hmac.HMAC(binascii.unhexlify(key), algorithm, backend=backend)\n    h.update(binascii.unhexlify(msg))\n    assert h.finalize() == binascii.unhexlify(md.encode(\"ascii\"))\n\n\ndef generate_aead_exception_test(cipher_factory, mode_factory):\n    def test_aead_exception(self, backend):\n        aead_exception_test(backend, cipher_factory, mode_factory)\n\n    return test_aead_exception\n\n\ndef aead_exception_test(backend, cipher_factory, mode_factory):\n    mode = mode_factory(binascii.unhexlify(b\"0\" * 24))\n    assert isinstance(mode, GCM)\n    cipher = Cipher(\n        cipher_factory(binascii.unhexlify(b\"0\" * 32)),\n        mode,\n        backend,\n    )\n    encryptor = cipher.encryptor()\n    encryptor.update(b\"a\" * 16)\n    with pytest.raises(NotYetFinalized):\n        encryptor.tag\n    with pytest.raises(AlreadyUpdated):\n        encryptor.authenticate_additional_data(b\"b\" * 16)\n    encryptor.finalize()\n    with pytest.raises(AlreadyFinalized):\n        encryptor.authenticate_additional_data(b\"b\" * 16)\n    with pytest.raises(AlreadyFinalized):\n        encryptor.update(b\"b\" * 16)\n    with pytest.raises(AlreadyFinalized):\n        encryptor.finalize()\n\n    mode2 = mode_factory(binascii.unhexlify(b\"0\" * 24), b\"0\" * 16)\n    assert isinstance(mode2, GCM)\n    cipher = Cipher(\n        cipher_factory(binascii.unhexlify(b\"0\" * 32)),\n        mode2,\n        backend,\n    )\n    decryptor = cipher.decryptor()\n    decryptor.update(b\"a\" * 16)\n    with pytest.raises(AlreadyUpdated):\n        decryptor.authenticate_additional_data(b\"b\" * 16)\n    with pytest.raises(AttributeError):\n        decryptor.tag  # type: ignore[attr-defined]\n\n\ndef generate_aead_tag_exception_test(cipher_factory, mode_factory):\n    def test_aead_tag_exception(self, backend):\n        aead_tag_exception_test(backend, cipher_factory, mode_factory)\n\n    return test_aead_tag_exception\n\n\ndef aead_tag_exception_test(backend, cipher_factory, mode_factory):\n    cipher = Cipher(\n        cipher_factory(binascii.unhexlify(b\"0\" * 32)),\n        mode_factory(binascii.unhexlify(b\"0\" * 24)),\n        backend,\n    )\n\n    with pytest.raises(ValueError):\n        mode_factory(binascii.unhexlify(b\"0\" * 24), b\"000\")\n\n    with pytest.raises(ValueError):\n        Cipher(\n            cipher_factory(binascii.unhexlify(b\"0\" * 32)),\n            mode_factory(binascii.unhexlify(b\"0\" * 24), b\"toolong\" * 12),\n            backend,\n        )\n\n    with pytest.raises(ValueError):\n        mode_factory(binascii.unhexlify(b\"0\" * 24), b\"000000\", 2)\n\n    cipher = Cipher(\n        cipher_factory(binascii.unhexlify(b\"0\" * 32)),\n        mode_factory(binascii.unhexlify(b\"0\" * 24), b\"0\" * 16),\n        backend,\n    )\n    with pytest.raises(ValueError):\n        cipher.encryptor()\n\n\ndef hkdf_derive_test(backend, algorithm, params):\n    hkdf = HKDF(\n        algorithm,\n        int(params[\"l\"]),\n        salt=binascii.unhexlify(params[\"salt\"]) or None,\n        info=binascii.unhexlify(params[\"info\"]) or None,\n        backend=backend,\n    )\n\n    okm = hkdf.derive(binascii.unhexlify(params[\"ikm\"]))\n\n    assert okm == binascii.unhexlify(params[\"okm\"])\n\n\ndef hkdf_extract_test(backend, algorithm, params):\n    hkdf = HKDF(\n        algorithm,\n        int(params[\"l\"]),\n        salt=binascii.unhexlify(params[\"salt\"]) or None,\n        info=binascii.unhexlify(params[\"info\"]) or None,\n        backend=backend,\n    )\n\n    prk = hkdf._extract(binascii.unhexlify(params[\"ikm\"]))\n\n    assert prk == binascii.unhexlify(params[\"prk\"])\n\n\ndef hkdf_expand_test(backend, algorithm, params):\n    hkdf = HKDFExpand(\n        algorithm,\n        int(params[\"l\"]),\n        info=binascii.unhexlify(params[\"info\"]) or None,\n        backend=backend,\n    )\n\n    okm = hkdf.derive(binascii.unhexlify(params[\"prk\"]))\n\n    assert okm == binascii.unhexlify(params[\"okm\"])\n\n\ndef generate_hkdf_test(param_loader, path, file_names, algorithm):\n    def test_hkdf(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                hkdf_extract_test(backend, algorithm, params)\n            with subtests.test():\n                hkdf_expand_test(backend, algorithm, params)\n            with subtests.test():\n                hkdf_derive_test(backend, algorithm, params)\n\n    return test_hkdf\n\n\ndef generate_kbkdf_counter_mode_test(param_loader, path, file_names):\n    def test_kbkdf(self, backend, subtests):\n        for params in _load_all_params(path, file_names, param_loader):\n            with subtests.test():\n                kbkdf_counter_mode_test(backend, params)\n\n    return test_kbkdf\n\n\ndef _kbkdf_hmac_counter_mode_test(backend, prf, ctr_loc, brk_loc, params):\n    supported_hash_algorithms: typing.Dict[\n        str, typing.Type[hashes.HashAlgorithm]\n    ] = {\n        \"hmac_sha1\": hashes.SHA1,\n        \"hmac_sha224\": hashes.SHA224,\n        \"hmac_sha256\": hashes.SHA256,\n        \"hmac_sha384\": hashes.SHA384,\n        \"hmac_sha512\": hashes.SHA512,\n    }\n\n    algorithm = supported_hash_algorithms.get(prf)\n    assert algorithm is not None\n    assert backend.hmac_supported(algorithm())\n\n    ctrkdf = KBKDFHMAC(\n        algorithm(),\n        Mode.CounterMode,\n        params[\"l\"] // 8,\n        params[\"rlen\"] // 8,\n        None,\n        ctr_loc,\n        None,\n        None,\n        binascii.unhexlify(params[\"fixedinputdata\"]),\n        backend=backend,\n        break_location=brk_loc,\n    )\n\n    ko = ctrkdf.derive(binascii.unhexlify(params[\"ki\"]))\n    assert binascii.hexlify(ko) == params[\"ko\"]\n\n\ndef _kbkdf_cmac_counter_mode_test(backend, prf, ctr_loc, brk_loc, params):\n    supported_cipher_algorithms: typing.Dict[\n        str, typing.Type[BlockCipherAlgorithm]\n    ] = {\n        \"cmac_aes128\": algorithms.AES,\n        \"cmac_aes192\": algorithms.AES,\n        \"cmac_aes256\": algorithms.AES,\n        \"cmac_tdes2\": decrepit_algorithms.TripleDES,\n        \"cmac_tdes3\": decrepit_algorithms.TripleDES,\n    }\n\n    algorithm = supported_cipher_algorithms.get(prf)\n    assert algorithm is not None\n\n    # TripleDES is disallowed in FIPS mode.\n    if backend._fips_enabled and algorithm is decrepit_algorithms.TripleDES:\n        pytest.skip(\"TripleDES is not supported in FIPS mode.\")\n\n    ctrkdf = KBKDFCMAC(\n        algorithm,\n        Mode.CounterMode,\n        params[\"l\"] // 8,\n        params[\"rlen\"] // 8,\n        None,\n        ctr_loc,\n        None,\n        None,\n        binascii.unhexlify(params[\"fixedinputdata\"]),\n        backend=backend,\n        break_location=brk_loc,\n    )\n\n    ko = ctrkdf.derive(binascii.unhexlify(params[\"ki\"]))\n    assert binascii.hexlify(ko) == params[\"ko\"]\n\n\ndef kbkdf_counter_mode_test(backend, params):\n    supported_counter_locations = {\n        \"before_fixed\": CounterLocation.BeforeFixed,\n        \"after_fixed\": CounterLocation.AfterFixed,\n        \"middle_fixed\": CounterLocation.MiddleFixed,\n    }\n\n    ctr_loc = supported_counter_locations[params.pop(\"ctrlocation\")]\n    brk_loc = None\n\n    if ctr_loc == CounterLocation.MiddleFixed:\n        assert \"fixedinputdata\" not in params\n        params[\"fixedinputdata\"] = params.pop(\n            \"databeforectrdata\"\n        ) + params.pop(\"dataafterctrdata\")\n\n        brk_loc = params.pop(\"databeforectrlen\")\n        assert isinstance(brk_loc, int)\n\n    prf = params.get(\"prf\")\n    assert prf is not None\n    assert isinstance(prf, str)\n    del params[\"prf\"]\n    if prf.startswith(\"hmac\"):\n        _kbkdf_hmac_counter_mode_test(backend, prf, ctr_loc, brk_loc, params)\n    else:\n        assert prf.startswith(\"cmac\")\n        _kbkdf_cmac_counter_mode_test(backend, prf, ctr_loc, brk_loc, params)\n\n\ndef generate_rsa_verification_test(\n    param_loader, path, file_names, hash_alg, pad_factory\n):\n    def test_rsa_verification(self, backend, subtests):\n        all_params = _load_all_params(path, file_names, param_loader)\n        all_params = [\n            i for i in all_params if i[\"algorithm\"] == hash_alg.name.upper()\n        ]\n        for params in all_params:\n            with subtests.test():\n                rsa_verification_test(backend, params, hash_alg, pad_factory)\n\n    return test_rsa_verification\n\n\ndef rsa_verification_test(backend, params, hash_alg, pad_factory):\n    public_numbers = rsa.RSAPublicNumbers(\n        e=params[\"public_exponent\"], n=params[\"modulus\"]\n    )\n    public_key = public_numbers.public_key(backend)\n    pad = pad_factory(params, hash_alg)\n    signature = binascii.unhexlify(params[\"s\"])\n    msg = binascii.unhexlify(params[\"msg\"])\n    if params[\"fail\"]:\n        with pytest.raises(InvalidSignature):\n            public_key.verify(signature, msg, pad, hash_alg)\n    else:\n        public_key.verify(signature, msg, pad, hash_alg)\n\n\ndef _check_rsa_private_numbers(skey):\n    assert skey\n    pkey = skey.public_numbers\n    assert pkey\n    assert pkey.e\n    assert pkey.n\n    assert skey.d\n    assert skey.p * skey.q == pkey.n\n    assert skey.dmp1 == rsa.rsa_crt_dmp1(skey.d, skey.p)\n    assert skey.dmq1 == rsa.rsa_crt_dmq1(skey.d, skey.q)\n    assert skey.iqmp == rsa.rsa_crt_iqmp(skey.p, skey.q)\n\n\ndef _check_dsa_private_numbers(skey):\n    assert skey\n    pkey = skey.public_numbers\n    params = pkey.parameter_numbers\n    assert pow(params.g, skey.x, params.p) == pkey.y\n\n\ndef skip_fips_traditional_openssl(backend, fmt):\n    if (\n        fmt is serialization.PrivateFormat.TraditionalOpenSSL\n        and backend._fips_enabled\n    ):\n        pytest.skip(\n            \"Traditional OpenSSL key format is not supported in FIPS mode.\"\n        )\n", "tests/hazmat/primitives/test_ciphers.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport mmap\nimport os\nimport sys\n\nimport pytest\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import modes\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n    Camellia,\n)\n\nfrom ...utils import load_nist_vectors, load_vectors_from_file\n\n\ndef test_deprecated_ciphers_import_with_warning():\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            Blowfish,  # noqa: F401\n        )\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            CAST5,  # noqa: F401\n        )\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            IDEA,  # noqa: F401\n        )\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            SEED,  # noqa: F401\n        )\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            ARC4,  # noqa: F401\n        )\n    with pytest.warns(utils.CryptographyDeprecationWarning):\n        from cryptography.hazmat.primitives.ciphers.algorithms import (\n            TripleDES,  # noqa: F401\n        )\n\n\nclass TestAES:\n    @pytest.mark.parametrize(\n        (\"key\", \"keysize\"),\n        [(b\"0\" * 32, 128), (b\"0\" * 48, 192), (b\"0\" * 64, 256)],\n    )\n    def test_key_size(self, key, keysize):\n        cipher = AES(binascii.unhexlify(key))\n        assert cipher.key_size == keysize\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            AES(binascii.unhexlify(b\"0\" * 12))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            AES(\"0\" * 32)  # type: ignore[arg-type]\n\n\nclass TestAESXTS:\n    @pytest.mark.parametrize(\n        \"mode\", (modes.CBC, modes.CTR, modes.CFB, modes.CFB8, modes.OFB)\n    )\n    def test_invalid_key_size_with_mode(self, mode, backend):\n        with pytest.raises(ValueError):\n            ciphers.Cipher(AES(b\"0\" * 64), mode(b\"0\" * 16), backend)\n\n    def test_xts_tweak_not_bytes(self):\n        with pytest.raises(TypeError):\n            modes.XTS(32)  # type: ignore[arg-type]\n\n    def test_xts_tweak_too_small(self):\n        with pytest.raises(ValueError):\n            modes.XTS(b\"0\")\n\n    def test_xts_wrong_key_size(self, backend):\n        with pytest.raises(ValueError):\n            ciphers.Cipher(AES(b\"0\" * 16), modes.XTS(b\"0\" * 16), backend)\n\n\nclass TestGCM:\n    @pytest.mark.parametrize(\"size\", [7, 129])\n    def test_gcm_min_max(self, size):\n        with pytest.raises(ValueError):\n            modes.GCM(b\"0\" * size)\n\n\nclass TestCamellia:\n    @pytest.mark.parametrize(\n        (\"key\", \"keysize\"),\n        [(b\"0\" * 32, 128), (b\"0\" * 48, 192), (b\"0\" * 64, 256)],\n    )\n    def test_key_size(self, key, keysize):\n        cipher = Camellia(binascii.unhexlify(key))\n        assert cipher.key_size == keysize\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            Camellia(binascii.unhexlify(b\"0\" * 12))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            Camellia(\"0\" * 32)  # type: ignore[arg-type]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        AES(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support AES ECB\",\n)\nclass TestCipherUpdateInto:\n    @pytest.mark.parametrize(\n        \"params\",\n        load_vectors_from_file(\n            os.path.join(\"ciphers\", \"AES\", \"ECB\", \"ECBGFSbox128.rsp\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_update_into(self, params, backend):\n        key = binascii.unhexlify(params[\"key\"])\n        pt = binascii.unhexlify(params[\"plaintext\"])\n        ct = binascii.unhexlify(params[\"ciphertext\"])\n        c = ciphers.Cipher(AES(key), modes.ECB(), backend)\n        encryptor = c.encryptor()\n        buf = bytearray(len(pt) + 15)\n        res = encryptor.update_into(pt, buf)\n        assert res == len(pt)\n        assert bytes(buf)[:res] == ct\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            AES(b\"\\x00\" * 16), modes.GCM(b\"0\" * 12)\n        ),\n        skip_message=\"Does not support AES GCM\",\n    )\n    def test_update_into_gcm(self, backend):\n        key = binascii.unhexlify(b\"e98b72a9881a84ca6b76e0f43e68647a\")\n        iv = binascii.unhexlify(b\"8b23299fde174053f3d652ba\")\n        ct = binascii.unhexlify(b\"5a3c1cf1985dbb8bed818036fdd5ab42\")\n        pt = binascii.unhexlify(b\"28286a321293253c3e0aa2704a278032\")\n        c = ciphers.Cipher(AES(key), modes.GCM(iv), backend)\n        encryptor = c.encryptor()\n        buf = bytearray(len(pt) + 15)\n        res = encryptor.update_into(pt, buf)\n        assert res == len(pt)\n        assert bytes(buf)[:res] == ct\n        encryptor.finalize()\n        c = ciphers.Cipher(AES(key), modes.GCM(iv, encryptor.tag), backend)\n        decryptor = c.decryptor()\n        res = decryptor.update_into(ct, buf)\n        decryptor.finalize()\n        assert res == len(pt)\n        assert bytes(buf)[:res] == pt\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            AES(b\"\\x00\" * 16), modes.GCM(b\"0\" * 12)\n        ),\n        skip_message=\"Does not support AES GCM\",\n    )\n    def test_finalize_with_tag_already_finalized(self, backend):\n        key = binascii.unhexlify(b\"e98b72a9881a84ca6b76e0f43e68647a\")\n        iv = binascii.unhexlify(b\"8b23299fde174053f3d652ba\")\n        encryptor = ciphers.Cipher(\n            AES(key), modes.GCM(iv), backend\n        ).encryptor()\n        ciphertext = encryptor.update(b\"abc\") + encryptor.finalize()\n\n        decryptor = ciphers.Cipher(\n            AES(key), modes.GCM(iv, tag=encryptor.tag), backend\n        ).decryptor()\n        decryptor.update(ciphertext)\n        decryptor.finalize()\n        with pytest.raises(AlreadyFinalized):\n            decryptor.finalize_with_tag(encryptor.tag)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            AES(b\"\\x00\" * 16), modes.GCM(b\"0\" * 12)\n        ),\n        skip_message=\"Does not support AES GCM\",\n    )\n    def test_finalize_with_tag_duplicate_tag(self, backend):\n        decryptor = ciphers.Cipher(\n            AES(b\"\\x00\" * 16),\n            modes.GCM(b\"\\x00\" * 12, tag=b\"\\x00\" * 16),\n            backend,\n        ).decryptor()\n        with pytest.raises(ValueError):\n            decryptor.finalize_with_tag(b\"\\x00\" * 16)\n\n    @pytest.mark.parametrize(\n        \"params\",\n        load_vectors_from_file(\n            os.path.join(\"ciphers\", \"AES\", \"ECB\", \"ECBGFSbox128.rsp\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_update_into_multiple_calls(self, params, backend):\n        key = binascii.unhexlify(params[\"key\"])\n        pt = binascii.unhexlify(params[\"plaintext\"])\n        ct = binascii.unhexlify(params[\"ciphertext\"])\n        c = ciphers.Cipher(AES(key), modes.ECB(), backend)\n        encryptor = c.encryptor()\n        buf = bytearray(len(pt) + 15)\n        res = encryptor.update_into(pt[:3], buf)\n        assert res == 0\n        res = encryptor.update_into(pt[3:], buf)\n        assert res == len(pt)\n        assert bytes(buf)[:res] == ct\n\n    def test_update_into_buffer_too_small(self, backend):\n        key = b\"\\x00\" * 16\n        c = ciphers.Cipher(AES(key), modes.ECB(), backend)\n        encryptor = c.encryptor()\n        buf = bytearray(16)\n        with pytest.raises(ValueError):\n            encryptor.update_into(b\"testing\", buf)\n\n    def test_update_into_immutable(self, backend):\n        key = b\"\\x00\" * 16\n        c = ciphers.Cipher(AES(key), modes.ECB(), backend)\n        encryptor = c.encryptor()\n        buf = b\"\\x00\" * 32\n        with pytest.raises((TypeError, BufferError)):\n            encryptor.update_into(b\"testing\", buf)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            AES(b\"\\x00\" * 16), modes.GCM(b\"\\x00\" * 12)\n        ),\n        skip_message=\"Does not support AES GCM\",\n    )\n    def test_update_into_buffer_too_small_gcm(self, backend):\n        key = b\"\\x00\" * 16\n        c = ciphers.Cipher(AES(key), modes.GCM(b\"\\x00\" * 12), backend)\n        encryptor = c.encryptor()\n        buf = bytearray(5)\n        with pytest.raises(ValueError):\n            encryptor.update_into(b\"testing\", buf)\n\n\n@pytest.mark.skipif(\n    sys.platform not in {\"linux\", \"darwin\"}, reason=\"mmap required\"\n)\ndef test_update_auto_chunking():\n    large_data = mmap.mmap(-1, 2**29 + 2**20, prot=mmap.PROT_READ)\n\n    key = b\"\\x00\" * 16\n    c = ciphers.Cipher(AES(key), modes.ECB())\n    encryptor = c.encryptor()\n\n    result = encryptor.update(memoryview(large_data))\n    assert len(result) == len(large_data)\n\n    decryptor = c.decryptor()\n    result = decryptor.update(result)\n    assert result == large_data[:]\n", "tests/hazmat/primitives/test_kbkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport re\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey, _Reasons\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.ciphers import algorithms\nfrom cryptography.hazmat.primitives.kdf.kbkdf import (\n    KBKDFCMAC,\n    KBKDFHMAC,\n    CounterLocation,\n    Mode,\n)\n\nfrom ...doubles import (\n    DummyBlockCipherAlgorithm,\n    DummyCipherAlgorithm,\n    DummyHashAlgorithm,\n)\nfrom ...utils import raises_unsupported_algorithm\n\n\nclass TestKBKDFHMAC:\n    def test_invalid_key(self, backend):\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(b\"material\")\n\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        with pytest.raises(InvalidKey):\n            kdf.verify(b\"material2\", key)\n\n    def test_already_finalized(self, backend):\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        kdf.derive(b\"material\")\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.derive(b\"material2\")\n\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(b\"material\")\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(b\"material\", key)\n\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n        kdf.verify(b\"material\", key)\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(b\"material\", key)\n\n    def test_key_length(self, backend):\n        kdf = KBKDFHMAC(\n            hashes.SHA1(),\n            Mode.CounterMode,\n            85899345920,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        with pytest.raises(ValueError):\n            kdf.derive(b\"material\")\n\n    def test_rlen(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                5,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_r_type(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA1(),\n                Mode.CounterMode,\n                32,\n                b\"r\",  # type: ignore[arg-type]\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_l_type(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA1(),\n                Mode.CounterMode,\n                32,\n                4,\n                b\"l\",  # type: ignore[arg-type]\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_l(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFHMAC(\n                hashes.SHA1(),\n                Mode.CounterMode,\n                32,\n                4,\n                None,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_mode(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                None,  # type: ignore[arg-type]\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_location(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                None,  # type: ignore[arg-type]\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_parameters(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                b\"fixed\",\n                backend=backend,\n            )\n\n    def test_missing_break_location(self, backend):\n        with pytest.raises(\n            ValueError, match=re.escape(\"Please specify a break_location\")\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n        with pytest.raises(\n            ValueError, match=re.escape(\"Please specify a break_location\")\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=None,\n            )\n\n    def test_keyword_only_break_location(self, backend):\n        with pytest.raises(\n            TypeError, match=r\"\\d+ positional arguments but \\d+ were given\\Z\"\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend,\n                0,  # break_location\n            )  # type: ignore\n\n    def test_invalid_break_location(self, backend):\n        with pytest.raises(\n            TypeError, match=re.escape(\"break_location must be an integer\")\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=\"0\",  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\"break_location must be a positive integer\"),\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=-1,\n            )\n\n        with pytest.raises(\n            ValueError, match=re.escape(\"break_location offset > len(fixed)\")\n        ):\n            kdf = KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=18,\n            )\n            kdf.derive(b\"input key\")\n\n    def test_ignored_break_location_before(self, backend):\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            ),\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=0,\n            )\n\n    def test_ignored_break_location_after(self, backend):\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            ),\n        ):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.AfterFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=0,\n            )\n\n    def test_unsupported_hash(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            KBKDFHMAC(\n                object(),  # type: ignore[arg-type]\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_algorithm(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            KBKDFHMAC(\n                DummyHashAlgorithm(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unicode_error_label(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                \"label\",  # type: ignore[arg-type]\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unicode_error_context(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                \"context\",  # type: ignore[arg-type]\n                None,\n                backend=backend,\n            )\n\n    def test_unicode_error_key_material(self, backend):\n        with pytest.raises(TypeError):\n            kdf = KBKDFHMAC(\n                hashes.SHA256(),\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n            kdf.derive(\"material\")  # type: ignore[arg-type]\n\n    def test_buffer_protocol(self, backend):\n        kdf = KBKDFHMAC(\n            hashes.SHA256(),\n            Mode.CounterMode,\n            10,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(bytearray(b\"material\"))\n        assert key == b\"\\xb7\\x01\\x05\\x98\\xf5\\x1a\\x12L\\xc7.\"\n\n\nclass TestKBKDFCMAC:\n    _KEY_MATERIAL = bytes(32)\n    _KEY_MATERIAL2 = _KEY_MATERIAL.replace(b\"\\x00\", b\"\\x01\", 1)\n\n    def test_invalid_key(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(self._KEY_MATERIAL)\n\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        with pytest.raises(InvalidKey):\n            kdf.verify(self._KEY_MATERIAL2, key)\n\n    def test_already_finalized(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        kdf.derive(self._KEY_MATERIAL)\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.derive(self._KEY_MATERIAL2)\n\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(self._KEY_MATERIAL)\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(self._KEY_MATERIAL, key)\n\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n        kdf.verify(self._KEY_MATERIAL, key)\n\n        with pytest.raises(AlreadyFinalized):\n            kdf.verify(self._KEY_MATERIAL, key)\n\n    def test_key_length(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            85899345920,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        with pytest.raises(ValueError):\n            kdf.derive(self._KEY_MATERIAL)\n\n    def test_rlen(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                5,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_r_type(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                b\"r\",  # type: ignore[arg-type]\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_l_type(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                b\"l\",  # type: ignore[arg-type]\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_l(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                None,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_mode(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                None,  # type: ignore[arg-type]\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_location(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                None,  # type: ignore[arg-type]\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_parameters(self, backend):\n        with pytest.raises(ValueError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                b\"fixed\",\n                backend=backend,\n            )\n\n    def test_missing_break_location(self, backend):\n        with pytest.raises(\n            ValueError, match=re.escape(\"Please specify a break_location\")\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n        with pytest.raises(\n            ValueError, match=re.escape(\"Please specify a break_location\")\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=None,\n            )\n\n    def test_keyword_only_break_location(self, backend):\n        with pytest.raises(\n            TypeError, match=r\"\\d+ positional arguments but \\d+ were given\\Z\"\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend,\n                0,  # break_location\n            )  # type: ignore\n\n    def test_invalid_break_location(self, backend):\n        with pytest.raises(\n            TypeError, match=re.escape(\"break_location must be an integer\")\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=\"0\",  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\"break_location must be a positive integer\"),\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=-1,\n            )\n\n        with pytest.raises(\n            ValueError, match=re.escape(\"break_location offset > len(fixed)\")\n        ):\n            kdf = KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.MiddleFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=18,\n            )\n            kdf.derive(b\"32 bytes long input key material\")\n\n    def test_ignored_break_location_before(self, backend):\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            ),\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=0,\n            )\n\n    def test_ignored_break_location_after(self, backend):\n        with pytest.raises(\n            ValueError,\n            match=re.escape(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            ),\n        ):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.AfterFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n                break_location=0,\n            )\n\n    def test_unsupported_algorithm(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            KBKDFCMAC(\n                object,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            KBKDFCMAC(\n                DummyCipherAlgorithm,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            KBKDFCMAC(\n                algorithms.ChaCha20,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unicode_error_label(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                \"label\",  # type: ignore[arg-type]\n                b\"context\",\n                None,\n                backend=backend,\n            )\n\n    def test_unicode_error_context(self, backend):\n        with pytest.raises(TypeError):\n            KBKDFCMAC(\n                algorithms.AES,\n                Mode.CounterMode,\n                32,\n                4,\n                4,\n                CounterLocation.BeforeFixed,\n                b\"label\",\n                \"context\",  # type: ignore[arg-type]\n                None,\n                backend=backend,\n            )\n\n    def test_unsupported_cipher(self, backend):\n        kdf = KBKDFCMAC(\n            DummyBlockCipherAlgorithm,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            kdf.derive(self._KEY_MATERIAL)\n\n    def test_unicode_error_key_material(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n        with pytest.raises(TypeError):\n            kdf.derive(\"material\")  # type: ignore[arg-type]\n\n    def test_wrong_key_material_length(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            32,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n        with pytest.raises(ValueError):\n            kdf.derive(b\"material\")\n\n    def test_buffer_protocol(self, backend):\n        kdf = KBKDFCMAC(\n            algorithms.AES,\n            Mode.CounterMode,\n            10,\n            4,\n            4,\n            CounterLocation.BeforeFixed,\n            b\"label\",\n            b\"context\",\n            None,\n            backend=backend,\n        )\n\n        key = kdf.derive(bytearray(self._KEY_MATERIAL))\n        assert key == b\"\\x19\\xcd\\xbe\\x17Lb\\x115<\\xd0\"\n", "tests/hazmat/primitives/test_keywrap.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import keywrap\nfrom cryptography.hazmat.primitives.ciphers import algorithms, modes\n\nfrom ...utils import load_nist_vectors\nfrom .utils import _load_all_params\n\n\nclass TestAESKeyWrap:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n        ),\n        skip_message=\"Does not support AES key wrap (RFC 3394) because AES-ECB\"\n        \" is unsupported\",\n    )\n    def test_wrap(self, backend, subtests):\n        params = _load_all_params(\n            os.path.join(\"keywrap\", \"kwtestvectors\"),\n            [\"KW_AE_128.txt\", \"KW_AE_192.txt\", \"KW_AE_256.txt\"],\n            load_nist_vectors,\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"k\"])\n                key_to_wrap = binascii.unhexlify(param[\"p\"])\n                wrapped_key = keywrap.aes_key_wrap(\n                    wrapping_key, key_to_wrap, backend\n                )\n                assert param[\"c\"] == binascii.hexlify(wrapped_key)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n        ),\n        skip_message=\"Does not support AES key wrap (RFC 3394) because AES-ECB\"\n        \" is unsupported\",\n    )\n    def test_unwrap(self, backend, subtests):\n        params = _load_all_params(\n            os.path.join(\"keywrap\", \"kwtestvectors\"),\n            [\"KW_AD_128.txt\", \"KW_AD_192.txt\", \"KW_AD_256.txt\"],\n            load_nist_vectors,\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"k\"])\n                wrapped_key = binascii.unhexlify(param[\"c\"])\n                if param.get(\"fail\") is True:\n                    with pytest.raises(keywrap.InvalidUnwrap):\n                        keywrap.aes_key_unwrap(\n                            wrapping_key, wrapped_key, backend\n                        )\n                else:\n                    unwrapped_key = keywrap.aes_key_unwrap(\n                        wrapping_key, wrapped_key, backend\n                    )\n                    assert param[\"p\"] == binascii.hexlify(unwrapped_key)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n        ),\n        skip_message=\"Does not support AES key wrap (RFC 3394) because AES-ECB\"\n        \" is unsupported\",\n    )\n    def test_wrap_invalid_key_length(self, backend):\n        # The wrapping key must be of length [16, 24, 32]\n        with pytest.raises(ValueError):\n            keywrap.aes_key_wrap(b\"badkey\", b\"sixteen_byte_key\", backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n        ),\n        skip_message=\"Does not support AES key wrap (RFC 3394) because AES-ECB\"\n        \" is unsupported\",\n    )\n    def test_unwrap_invalid_key_length(self, backend):\n        with pytest.raises(ValueError):\n            keywrap.aes_key_unwrap(b\"badkey\", b\"\\x00\" * 24, backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n        ),\n        skip_message=\"Does not support AES key wrap (RFC 3394) because AES-ECB\"\n        \" is unsupported\",\n    )\n    def test_wrap_invalid_key_to_wrap_length(self, backend):\n        # Keys to wrap must be at least 16 bytes long\n        with pytest.raises(ValueError):\n            keywrap.aes_key_wrap(b\"sixteen_byte_key\", b\"\\x00\" * 15, backend)\n\n        # Keys to wrap must be a multiple of 8 bytes\n        with pytest.raises(ValueError):\n            keywrap.aes_key_wrap(b\"sixteen_byte_key\", b\"\\x00\" * 23, backend)\n\n    def test_unwrap_invalid_wrapped_key_length(self, backend):\n        # Keys to unwrap must be at least 24 bytes\n        with pytest.raises(keywrap.InvalidUnwrap):\n            keywrap.aes_key_unwrap(b\"sixteen_byte_key\", b\"\\x00\" * 16, backend)\n\n        # Keys to unwrap must be a multiple of 8 bytes\n        with pytest.raises(keywrap.InvalidUnwrap):\n            keywrap.aes_key_unwrap(b\"sixteen_byte_key\", b\"\\x00\" * 27, backend)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support AES key wrap (RFC 5649) because AES-ECB\"\n    \" is unsupported\",\n)\nclass TestAESKeyWrapWithPadding:\n    def test_wrap(self, backend, subtests):\n        params = _load_all_params(\n            os.path.join(\"keywrap\", \"kwtestvectors\"),\n            [\"KWP_AE_128.txt\", \"KWP_AE_192.txt\", \"KWP_AE_256.txt\"],\n            load_nist_vectors,\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"k\"])\n                key_to_wrap = binascii.unhexlify(param[\"p\"])\n                wrapped_key = keywrap.aes_key_wrap_with_padding(\n                    wrapping_key, key_to_wrap, backend\n                )\n                assert param[\"c\"] == binascii.hexlify(wrapped_key)\n\n    def test_wrap_additional_vectors(self, backend, subtests):\n        params = _load_all_params(\n            \"keywrap\", [\"kwp_botan.txt\"], load_nist_vectors\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"key\"])\n                key_to_wrap = binascii.unhexlify(param[\"input\"])\n                wrapped_key = keywrap.aes_key_wrap_with_padding(\n                    wrapping_key, key_to_wrap, backend\n                )\n                assert wrapped_key == binascii.unhexlify(param[\"output\"])\n\n    def test_unwrap(self, backend, subtests):\n        params = _load_all_params(\n            os.path.join(\"keywrap\", \"kwtestvectors\"),\n            [\"KWP_AD_128.txt\", \"KWP_AD_192.txt\", \"KWP_AD_256.txt\"],\n            load_nist_vectors,\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"k\"])\n                wrapped_key = binascii.unhexlify(param[\"c\"])\n                if param.get(\"fail\") is True:\n                    with pytest.raises(keywrap.InvalidUnwrap):\n                        keywrap.aes_key_unwrap_with_padding(\n                            wrapping_key, wrapped_key, backend\n                        )\n                else:\n                    unwrapped_key = keywrap.aes_key_unwrap_with_padding(\n                        wrapping_key, wrapped_key, backend\n                    )\n                    assert param[\"p\"] == binascii.hexlify(unwrapped_key)\n\n    def test_unwrap_additional_vectors(self, backend, subtests):\n        params = _load_all_params(\n            \"keywrap\", [\"kwp_botan.txt\"], load_nist_vectors\n        )\n        for param in params:\n            with subtests.test():\n                wrapping_key = binascii.unhexlify(param[\"key\"])\n                wrapped_key = binascii.unhexlify(param[\"output\"])\n                unwrapped_key = keywrap.aes_key_unwrap_with_padding(\n                    wrapping_key, wrapped_key, backend\n                )\n                assert unwrapped_key == binascii.unhexlify(param[\"input\"])\n\n    def test_unwrap_invalid_wrapped_key_length(self, backend):\n        # Keys to unwrap must be at least 16 bytes\n        with pytest.raises(\n            keywrap.InvalidUnwrap, match=\"Must be at least 16 bytes\"\n        ):\n            keywrap.aes_key_unwrap_with_padding(\n                b\"sixteen_byte_key\", b\"\\x00\" * 15, backend\n            )\n\n    def test_wrap_invalid_key_length(self, backend):\n        with pytest.raises(ValueError, match=\"must be a valid AES key length\"):\n            keywrap.aes_key_wrap_with_padding(b\"badkey\", b\"\\x00\", backend)\n\n    def test_unwrap_invalid_key_length(self, backend):\n        with pytest.raises(ValueError, match=\"must be a valid AES key length\"):\n            keywrap.aes_key_unwrap_with_padding(\n                b\"badkey\", b\"\\x00\" * 16, backend\n            )\n", "tests/hazmat/primitives/fixtures_dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography.hazmat.primitives.asymmetric.dsa import (\n    DSAParameterNumbers,\n    DSAPrivateNumbers,\n    DSAPublicNumbers,\n)\n\nDSA_KEY_1024 = DSAPrivateNumbers(\n    public_numbers=DSAPublicNumbers(\n        parameter_numbers=DSAParameterNumbers(\n            p=int(\n                \"d38311e2cd388c3ed698e82fdf88eb92b5a9a483dc88005d4b725ef34\"\n                \"1eabb47cf8a7a8a41e792a156b7ce97206c4f9c5ce6fc5ae7912102b6\"\n                \"b502e59050b5b21ce263dddb2044b652236f4d42ab4b5d6aa73189cef\"\n                \"1ace778d7845a5c1c1c7147123188f8dc551054ee162b634d60f097f7\"\n                \"19076640e20980a0093113a8bd73\",\n                16,\n            ),\n            q=int(\"96c5390a8b612c0e422bb2b0ea194a3ec935a281\", 16),\n            g=int(\n                \"06b7861abbd35cc89e79c52f68d20875389b127361ca66822138ce499\"\n                \"1d2b862259d6b4548a6495b195aa0e0b6137ca37eb23b94074d3c3d30\"\n                \"0042bdf15762812b6333ef7b07ceba78607610fcc9ee68491dbc1e34c\"\n                \"d12615474e52b18bc934fb00c61d39e7da8902291c4434a4e2224c3f4\"\n                \"fd9f93cd6f4f17fc076341a7e7d9\",\n                16,\n            ),\n        ),\n        y=int(\n            \"6f26d98d41de7d871b6381851c9d91fa03942092ab6097e76422070edb71d\"\n            \"b44ff568280fdb1709f8fc3feab39f1f824adaeb2a298088156ac31af1aa0\"\n            \"4bf54f475bdcfdcf2f8a2dd973e922d83e76f016558617603129b21c70bf7\"\n            \"d0e5dc9e68fe332e295b65876eb9a12fe6fca9f1a1ce80204646bf99b5771\"\n            \"d249a6fea627\",\n            16,\n        ),\n    ),\n    x=int(\"8185fee9cc7c0e91fd85503274f1cd5a3fd15a49\", 16),\n)\n\nDSA_KEY_2048 = DSAPrivateNumbers(\n    public_numbers=DSAPublicNumbers(\n        parameter_numbers=DSAParameterNumbers(\n            p=int(\n                \"ea1fb1af22881558ef93be8a5f8653c5a559434c49c8c2c12ace5e9c4\"\n                \"1434c9cf0a8e9498acb0f4663c08b4484eace845f6fb17dac62c98e70\"\n                \"6af0fc74e4da1c6c2b3fbf5a1d58ff82fc1a66f3e8b12252c40278fff\"\n                \"9dd7f102eed2cb5b7323ebf1908c234d935414dded7f8d244e54561b0\"\n                \"dca39b301de8c49da9fb23df33c6182e3f983208c560fb5119fbf78eb\"\n                \"e3e6564ee235c6a15cbb9ac247baba5a423bc6582a1a9d8a2b4f0e9e3\"\n                \"d9dbac122f750dd754325135257488b1f6ecabf21bff2947fe0d3b2cb\"\n                \"7ffe67f4e7fcdf1214f6053e72a5bb0dd20a0e9fe6db2df0a908c36e9\"\n                \"5e60bf49ca4368b8b892b9c79f61ef91c47567c40e1f80ac5aa66ef7\",\n                16,\n            ),\n            q=int(\n                \"8ec73f3761caf5fdfe6e4e82098bf10f898740dcb808204bf6b18f507\"\n                \"192c19d\",\n                16,\n            ),\n            g=int(\n                \"e4c4eca88415b23ecf811c96e48cd24200fe916631a68a684e6ccb6b1\"\n                \"913413d344d1d8d84a333839d88eee431521f6e357c16e6a93be111a9\"\n                \"8076739cd401bab3b9d565bf4fb99e9d185b1e14d61c93700133f908b\"\n                \"ae03e28764d107dcd2ea7674217622074bb19efff482f5f5c1a86d555\"\n                \"1b2fc68d1c6e9d8011958ef4b9c2a3a55d0d3c882e6ad7f9f0f3c6156\"\n                \"8f78d0706b10a26f23b4f197c322b825002284a0aca91807bba98ece9\"\n                \"12b80e10cdf180cf99a35f210c1655fbfdd74f13b1b5046591f840387\"\n                \"3d12239834dd6c4eceb42bf7482e1794a1601357b629ddfa971f2ed27\"\n                \"3b146ec1ca06d0adf55dd91d65c37297bda78c6d210c0bc26e558302\",\n                16,\n            ),\n        ),\n        y=int(\n            \"6b32e31ab9031dc4dd0b5039a78d07826687ab087ae6de4736f5b0434e125\"\n            \"3092e8a0b231f9c87f3fc8a4cb5634eb194bf1b638b7a7889620ce6711567\"\n            \"e36aa36cda4604cfaa601a45918371d4ccf68d8b10a50a0460eb1dc0fff62\"\n            \"ef5e6ee4d473e18ea4a66c196fb7e677a49b48241a0b4a97128eff30fa437\"\n            \"050501a584f8771e7280d26d5af30784039159c11ebfea10b692fd0a58215\"\n            \"eeb18bff117e13f08db792ed4151a218e4bed8dddfb0793225bd1e9773505\"\n            \"166f4bd8cedbb286ea28232972da7bae836ba97329ba6b0a36508e50a52a7\"\n            \"675e476d4d4137eae13f22a9d2fefde708ba8f34bf336c6e76331761e4b06\"\n            \"17633fe7ec3f23672fb19d27\",\n            16,\n        ),\n    ),\n    x=int(\n        \"405772da6e90d809e77d5de796562a2dd4dfd10ef00a83a3aba6bd818a0348a1\", 16\n    ),\n)\n\nDSA_KEY_3072 = DSAPrivateNumbers(\n    public_numbers=DSAPublicNumbers(\n        parameter_numbers=DSAParameterNumbers(\n            p=int(\n                \"f335666dd1339165af8b9a5e3835adfe15c158e4c3c7bd53132e7d582\"\n                \"8c352f593a9a787760ce34b789879941f2f01f02319f6ae0b756f1a84\"\n                \"2ba54c85612ed632ee2d79ef17f06b77c641b7b080aff52a03fc2462e\"\n                \"80abc64d223723c236deeb7d201078ec01ca1fbc1763139e25099a84e\"\n                \"c389159c409792080736bd7caa816b92edf23f2c351f90074aa5ea265\"\n                \"1b372f8b58a0a65554db2561d706a63685000ac576b7e4562e262a142\"\n                \"85a9c6370b290e4eb7757527d80b6c0fd5df831d36f3d1d35f12ab060\"\n                \"548de1605fd15f7c7aafed688b146a02c945156e284f5b71282045aba\"\n                \"9844d48b5df2e9e7a5887121eae7d7b01db7cdf6ff917cd8eb50c6bf1\"\n                \"d54f90cce1a491a9c74fea88f7e7230b047d16b5a6027881d6f154818\"\n                \"f06e513faf40c8814630e4e254f17a47bfe9cb519b98289935bf17673\"\n                \"ae4c8033504a20a898d0032ee402b72d5986322f3bdfb27400561f747\"\n                \"6cd715eaabb7338b854e51fc2fa026a5a579b6dcea1b1c0559c13d3c1\"\n                \"136f303f4b4d25ad5b692229957\",\n                16,\n            ),\n            q=int(\n                \"d3eba6521240694015ef94412e08bf3cf8d635a455a398d6f210f6169\"\n                \"041653b\",\n                16,\n            ),\n            g=int(\n                \"ce84b30ddf290a9f787a7c2f1ce92c1cbf4ef400e3cd7ce4978db2104\"\n                \"d7394b493c18332c64cec906a71c3778bd93341165dee8e6cd4ca6f13\"\n                \"afff531191194ada55ecf01ff94d6cf7c4768b82dd29cd131aaf202ae\"\n                \"fd40e564375285c01f3220af4d70b96f1395420d778228f1461f5d0b8\"\n                \"e47357e87b1fe3286223b553e3fc9928f16ae3067ded6721bedf1d1a0\"\n                \"1bfd22b9ae85fce77820d88cdf50a6bde20668ad77a707d1c60fcc5d5\"\n                \"1c9de488610d0285eb8ff721ff141f93a9fb23c1d1f7654c07c46e588\"\n                \"36d1652828f71057b8aff0b0778ef2ca934ea9d0f37daddade2d823a4\"\n                \"d8e362721082e279d003b575ee59fd050d105dfd71cd63154efe431a0\"\n                \"869178d9811f4f231dc5dcf3b0ec0f2b0f9896c32ec6c7ee7d60aa971\"\n                \"09e09224907328d4e6acd10117e45774406c4c947da8020649c3168f6\"\n                \"90e0bd6e91ac67074d1d436b58ae374523deaf6c93c1e6920db4a080b\"\n                \"744804bb073cecfe83fa9398cf150afa286dc7eb7949750cf5001ce10\"\n                \"4e9187f7e16859afa8fd0d775ae\",\n                16,\n            ),\n        ),\n        y=int(\n            \"814824e435e1e6f38daa239aad6dad21033afce6a3ebd35c1359348a0f241\"\n            \"8871968c2babfc2baf47742148828f8612183178f126504da73566b6bab33\"\n            \"ba1f124c15aa461555c2451d86c94ee21c3e3fc24c55527e01b1f03adcdd8\"\n            \"ec5cb08082803a7b6a829c3e99eeb332a2cf5c035b0ce0078d3d414d31fa4\"\n            \"7e9726be2989b8d06da2e6cd363f5a7d1515e3f4925e0b32adeae3025cc5a\"\n            \"996f6fd27494ea408763de48f3bb39f6a06514b019899b312ec570851637b\"\n            \"8865cff3a52bf5d54ad5a19e6e400a2d33251055d0a440b50d53f4791391d\"\n            \"c754ad02b9eab74c46b4903f9d76f824339914db108057af7cde657d41766\"\n            \"a99991ac8787694f4185d6f91d7627048f827b405ec67bf2fe56141c4c581\"\n            \"d8c317333624e073e5879a82437cb0c7b435c0ce434e15965db1315d64895\"\n            \"991e6bbe7dac040c42052408bbc53423fd31098248a58f8a67da3a39895cd\"\n            \"0cc927515d044c1e3cb6a3259c3d0da354cce89ea3552c59609db10ee9899\"\n            \"86527436af21d9485ddf25f90f7dff6d2bae\",\n            16,\n        ),\n    ),\n    x=int(\n        \"b2764c46113983777d3e7e97589f1303806d14ad9f2f1ef033097de954b17706\", 16\n    ),\n)\n", "tests/hazmat/primitives/test_aead.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport mmap\nimport os\nimport sys\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidTag, UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.primitives.ciphers.aead import (\n    AESCCM,\n    AESGCM,\n    AESGCMSIV,\n    AESOCB3,\n    AESSIV,\n    ChaCha20Poly1305,\n)\n\nfrom ...utils import (\n    load_nist_ccm_vectors,\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\nfrom .utils import _load_all_params\n\n\ndef _aead_supported(cls):\n    try:\n        cls(b\"0\" * 32)\n        return True\n    except UnsupportedAlgorithm:\n        return False\n\n\ndef large_mmap():\n    return mmap.mmap(-1, 2**32, prot=mmap.PROT_READ)\n\n\n@pytest.mark.skipif(\n    _aead_supported(ChaCha20Poly1305),\n    reason=\"Requires OpenSSL without ChaCha20Poly1305 support\",\n)\ndef test_chacha20poly1305_unsupported_on_older_openssl(backend):\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n        ChaCha20Poly1305(ChaCha20Poly1305.generate_key())\n\n\n@pytest.mark.skipif(\n    not _aead_supported(ChaCha20Poly1305),\n    reason=\"Does not support ChaCha20Poly1305\",\n)\nclass TestChaCha20Poly1305:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        nonce = b\"0\" * 12\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            chacha.encrypt(nonce, large_data, b\"\")\n\n        with pytest.raises(OverflowError):\n            chacha.encrypt(nonce, b\"\", large_data)\n\n    def test_generate_key(self):\n        key = ChaCha20Poly1305.generate_key()\n        assert len(key) == 32\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            ChaCha20Poly1305(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            ChaCha20Poly1305(b\"0\" * 31)\n\n    @pytest.mark.parametrize(\n        (\"nonce\", \"data\", \"associated_data\"),\n        [\n            [object(), b\"data\", b\"\"],\n            [b\"0\" * 12, object(), b\"\"],\n            [b\"0\" * 12, b\"data\", object()],\n        ],\n    )\n    def test_params_not_bytes_encrypt(\n        self, nonce, data, associated_data, backend\n    ):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        with pytest.raises(TypeError):\n            chacha.encrypt(nonce, data, associated_data)\n\n        with pytest.raises(TypeError):\n            chacha.decrypt(nonce, data, associated_data)\n\n    def test_nonce_not_12_bytes(self, backend):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        with pytest.raises(ValueError):\n            chacha.encrypt(b\"00\", b\"hello\", b\"\")\n\n        with pytest.raises(ValueError):\n            chacha.decrypt(b\"00\", b\"hello\", b\"\")\n\n    def test_decrypt_data_too_short(self, backend):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        with pytest.raises(InvalidTag):\n            chacha.decrypt(b\"0\" * 12, b\"0\", None)\n\n    def test_associated_data_none_equal_to_empty_bytestring(self, backend):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        nonce = os.urandom(12)\n        ct1 = chacha.encrypt(nonce, b\"some_data\", None)\n        ct2 = chacha.encrypt(nonce, b\"some_data\", b\"\")\n        assert ct1 == ct2\n        pt1 = chacha.decrypt(nonce, ct1, None)\n        pt2 = chacha.decrypt(nonce, ct2, b\"\")\n        assert pt1 == pt2\n\n    def test_openssl_vectors(self, subtests, backend):\n        vectors = load_vectors_from_file(\n            os.path.join(\"ciphers\", \"ChaCha20Poly1305\", \"openssl.txt\"),\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                nonce = binascii.unhexlify(vector[\"iv\"])\n                aad = binascii.unhexlify(vector[\"aad\"])\n                tag = binascii.unhexlify(vector[\"tag\"])\n                pt = binascii.unhexlify(vector[\"plaintext\"])\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                chacha = ChaCha20Poly1305(key)\n                if vector.get(\"result\") == b\"CIPHERFINAL_ERROR\":\n                    with pytest.raises(InvalidTag):\n                        chacha.decrypt(nonce, ct + tag, aad)\n                else:\n                    computed_pt = chacha.decrypt(nonce, ct + tag, aad)\n                    assert computed_pt == pt\n                    computed_ct = chacha.encrypt(nonce, pt, aad)\n                    assert computed_ct == ct + tag\n\n    def test_boringssl_vectors(self, subtests, backend):\n        vectors = load_vectors_from_file(\n            os.path.join(\"ciphers\", \"ChaCha20Poly1305\", \"boringssl.txt\"),\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                nonce = binascii.unhexlify(vector[\"nonce\"])\n                if vector[\"ad\"].startswith(b'\"'):\n                    aad = vector[\"ad\"][1:-1]\n                else:\n                    aad = binascii.unhexlify(vector[\"ad\"])\n                tag = binascii.unhexlify(vector[\"tag\"])\n                if vector[\"in\"].startswith(b'\"'):\n                    pt = vector[\"in\"][1:-1]\n                else:\n                    pt = binascii.unhexlify(vector[\"in\"])\n                ct = binascii.unhexlify(vector[\"ct\"].strip(b'\"'))\n                chacha = ChaCha20Poly1305(key)\n                computed_pt = chacha.decrypt(nonce, ct + tag, aad)\n                assert computed_pt == pt\n                computed_ct = chacha.encrypt(nonce, pt, aad)\n                assert computed_ct == ct + tag\n\n    def test_buffer_protocol(self, backend):\n        key = ChaCha20Poly1305.generate_key()\n        chacha = ChaCha20Poly1305(key)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        nonce = os.urandom(12)\n        ct = chacha.encrypt(nonce, pt, ad)\n        computed_pt = chacha.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n        chacha2 = ChaCha20Poly1305(bytearray(key))\n        ct2 = chacha2.encrypt(bytearray(nonce), pt, ad)\n        assert ct2 == ct\n        computed_pt2 = chacha2.decrypt(bytearray(nonce), ct2, ad)\n        assert computed_pt2 == pt\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESCCM),\n    reason=\"Does not support AESCCM\",\n)\nclass TestAESCCM:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        nonce = b\"0\" * 12\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            aesccm.encrypt(nonce, large_data, b\"\")\n\n        with pytest.raises(OverflowError):\n            aesccm.encrypt(nonce, b\"\", large_data)\n\n    def test_default_tag_length(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        nonce = os.urandom(12)\n        pt = b\"hello\"\n        ct = aesccm.encrypt(nonce, pt, None)\n        assert len(ct) == len(pt) + 16\n\n    def test_invalid_tag_length(self, backend):\n        key = AESCCM.generate_key(128)\n        with pytest.raises(ValueError):\n            AESCCM(key, tag_length=7)\n\n        with pytest.raises(ValueError):\n            AESCCM(key, tag_length=2)\n\n        with pytest.raises(TypeError):\n            AESCCM(key, tag_length=\"notanint\")  # type:ignore[arg-type]\n\n    def test_invalid_nonce_length(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        pt = b\"hello\"\n        nonce = os.urandom(14)\n        with pytest.raises(ValueError):\n            aesccm.encrypt(nonce, pt, None)\n\n        with pytest.raises(ValueError):\n            aesccm.encrypt(nonce[:6], pt, None)\n\n    def test_vectors(self, subtests, backend):\n        vectors = _load_all_params(\n            os.path.join(\"ciphers\", \"AES\", \"CCM\"),\n            [\n                \"DVPT128.rsp\",\n                \"DVPT192.rsp\",\n                \"DVPT256.rsp\",\n                \"VADT128.rsp\",\n                \"VADT192.rsp\",\n                \"VADT256.rsp\",\n                \"VNT128.rsp\",\n                \"VNT192.rsp\",\n                \"VNT256.rsp\",\n                \"VPT128.rsp\",\n                \"VPT192.rsp\",\n                \"VPT256.rsp\",\n            ],\n            load_nist_ccm_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                nonce = binascii.unhexlify(vector[\"nonce\"])\n                adata = binascii.unhexlify(vector[\"adata\"])[: vector[\"alen\"]]\n                ct = binascii.unhexlify(vector[\"ct\"])\n                pt = binascii.unhexlify(vector[\"payload\"])[: vector[\"plen\"]]\n                aesccm = AESCCM(key, vector[\"tlen\"])\n                if vector.get(\"fail\"):\n                    with pytest.raises(InvalidTag):\n                        aesccm.decrypt(nonce, ct, adata)\n                else:\n                    computed_pt = aesccm.decrypt(nonce, ct, adata)\n                    assert computed_pt == pt\n                    assert aesccm.encrypt(nonce, pt, adata) == ct\n\n    def test_roundtrip(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        nonce = os.urandom(12)\n        ct = aesccm.encrypt(nonce, pt, ad)\n        computed_pt = aesccm.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n\n    def test_nonce_too_long(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        pt = b\"encrypt me\" * 6600\n        # pt can be no more than 65536 bytes when nonce is 13 bytes\n        nonce = os.urandom(13)\n        with pytest.raises(ValueError):\n            aesccm.encrypt(nonce, pt, None)\n\n        with pytest.raises(ValueError):\n            aesccm.decrypt(nonce, pt, None)\n\n    @pytest.mark.parametrize(\n        (\"nonce\", \"data\", \"associated_data\"),\n        [\n            [object(), b\"data\", b\"\"],\n            [b\"0\" * 12, object(), b\"\"],\n            [b\"0\" * 12, b\"data\", object()],\n        ],\n    )\n    def test_params_not_bytes(self, nonce, data, associated_data, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        with pytest.raises(TypeError):\n            aesccm.encrypt(nonce, data, associated_data)\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            AESCCM(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESCCM(b\"0\" * 31)\n\n    def test_bad_generate_key(self, backend):\n        with pytest.raises(TypeError):\n            AESCCM.generate_key(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESCCM.generate_key(129)\n\n    def test_associated_data_none_equal_to_empty_bytestring(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        nonce = os.urandom(12)\n        ct1 = aesccm.encrypt(nonce, b\"some_data\", None)\n        ct2 = aesccm.encrypt(nonce, b\"some_data\", b\"\")\n        assert ct1 == ct2\n        pt1 = aesccm.decrypt(nonce, ct1, None)\n        pt2 = aesccm.decrypt(nonce, ct2, b\"\")\n        assert pt1 == pt2\n\n    def test_decrypt_data_too_short(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        with pytest.raises(InvalidTag):\n            aesccm.decrypt(b\"0\" * 12, b\"0\", None)\n\n    def test_buffer_protocol(self, backend):\n        key = AESCCM.generate_key(128)\n        aesccm = AESCCM(key)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        nonce = os.urandom(12)\n        ct = aesccm.encrypt(nonce, pt, ad)\n        computed_pt = aesccm.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n        aesccm2 = AESCCM(bytearray(key))\n        ct2 = aesccm2.encrypt(bytearray(nonce), pt, ad)\n        assert ct2 == ct\n        computed_pt2 = aesccm2.decrypt(bytearray(nonce), ct2, ad)\n        assert computed_pt2 == pt\n\n\ndef _load_gcm_vectors():\n    vectors = _load_all_params(\n        os.path.join(\"ciphers\", \"AES\", \"GCM\"),\n        [\n            \"gcmDecrypt128.rsp\",\n            \"gcmDecrypt192.rsp\",\n            \"gcmDecrypt256.rsp\",\n            \"gcmEncryptExtIV128.rsp\",\n            \"gcmEncryptExtIV192.rsp\",\n            \"gcmEncryptExtIV256.rsp\",\n        ],\n        load_nist_vectors,\n    )\n    return [x for x in vectors if len(x[\"tag\"]) == 32 and len(x[\"iv\"]) >= 16]\n\n\nclass TestAESGCM:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        nonce = b\"0\" * 12\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            aesgcm.encrypt(nonce, large_data, b\"\")\n\n        with pytest.raises(OverflowError):\n            aesgcm.encrypt(nonce, b\"\", large_data)\n\n    def test_decrypt_data_too_short(self):\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        with pytest.raises(InvalidTag):\n            aesgcm.decrypt(b\"0\" * 12, b\"0\", None)\n\n    def test_vectors(self, backend, subtests):\n        vectors = _load_gcm_vectors()\n        for vector in vectors:\n            with subtests.test():\n                nonce = binascii.unhexlify(vector[\"iv\"])\n\n                if backend._fips_enabled and len(nonce) != 12:\n                    # Red Hat disables non-96-bit IV support as part of its\n                    # FIPS patches.\n                    pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n\n                key = binascii.unhexlify(vector[\"key\"])\n                aad = binascii.unhexlify(vector[\"aad\"])\n                ct = binascii.unhexlify(vector[\"ct\"])\n                pt = binascii.unhexlify(vector.get(\"pt\", b\"\"))\n                tag = binascii.unhexlify(vector[\"tag\"])\n                aesgcm = AESGCM(key)\n                if vector.get(\"fail\") is True:\n                    with pytest.raises(InvalidTag):\n                        aesgcm.decrypt(nonce, ct + tag, aad)\n                else:\n                    computed_ct = aesgcm.encrypt(nonce, pt, aad)\n                    assert computed_ct[:-16] == ct\n                    assert computed_ct[-16:] == tag\n                    computed_pt = aesgcm.decrypt(nonce, ct + tag, aad)\n                    assert computed_pt == pt\n\n    @pytest.mark.parametrize(\n        (\"nonce\", \"data\", \"associated_data\"),\n        [\n            [object(), b\"data\", b\"\"],\n            [b\"0\" * 12, object(), b\"\"],\n            [b\"0\" * 12, b\"data\", object()],\n        ],\n    )\n    def test_params_not_bytes(self, nonce, data, associated_data, backend):\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        with pytest.raises(TypeError):\n            aesgcm.encrypt(nonce, data, associated_data)\n\n        with pytest.raises(TypeError):\n            aesgcm.decrypt(nonce, data, associated_data)\n\n    @pytest.mark.parametrize(\"length\", [7, 129])\n    def test_invalid_nonce_length(self, length, backend):\n        if backend._fips_enabled:\n            # Red Hat disables non-96-bit IV support as part of its FIPS\n            # patches.\n            pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        with pytest.raises(ValueError):\n            aesgcm.encrypt(b\"\\x00\" * length, b\"hi\", None)\n        with pytest.raises(ValueError):\n            aesgcm.decrypt(b\"\\x00\" * length, b\"hi\", None)\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            AESGCM(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESGCM(b\"0\" * 31)\n\n    def test_bad_generate_key(self, backend):\n        with pytest.raises(TypeError):\n            AESGCM.generate_key(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESGCM.generate_key(129)\n\n    def test_associated_data_none_equal_to_empty_bytestring(self, backend):\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        nonce = os.urandom(12)\n        ct1 = aesgcm.encrypt(nonce, b\"some_data\", None)\n        ct2 = aesgcm.encrypt(nonce, b\"some_data\", b\"\")\n        assert ct1 == ct2\n        pt1 = aesgcm.decrypt(nonce, ct1, None)\n        pt2 = aesgcm.decrypt(nonce, ct2, b\"\")\n        assert pt1 == pt2\n\n    def test_buffer_protocol(self, backend):\n        key = AESGCM.generate_key(128)\n        aesgcm = AESGCM(key)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        nonce = os.urandom(12)\n        ct = aesgcm.encrypt(nonce, pt, ad)\n        computed_pt = aesgcm.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n        aesgcm2 = AESGCM(bytearray(key))\n        ct2 = aesgcm2.encrypt(bytearray(nonce), bytearray(pt), bytearray(ad))\n        assert ct2 == ct\n        b_nonce = bytearray(nonce)\n        b_ct2 = bytearray(ct2)\n        b_ad = bytearray(ad)\n        computed_pt2 = aesgcm2.decrypt(b_nonce, b_ct2, b_ad)\n        assert computed_pt2 == pt\n        aesgcm3 = AESGCM(memoryview(key))\n        m_nonce = memoryview(nonce)\n        m_pt = memoryview(pt)\n        m_ad = memoryview(ad)\n        ct3 = aesgcm3.encrypt(m_nonce, m_pt, m_ad)\n        assert ct3 == ct\n        m_ct3 = memoryview(ct3)\n        computed_pt3 = aesgcm3.decrypt(m_nonce, m_ct3, m_ad)\n        assert computed_pt3 == pt\n\n\n@pytest.mark.skipif(\n    _aead_supported(AESOCB3),\n    reason=\"Requires OpenSSL without AESOCB3 support\",\n)\ndef test_aesocb3_unsupported_on_older_openssl(backend):\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n        AESOCB3(AESOCB3.generate_key(128))\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESOCB3),\n    reason=\"Does not support AESOCB3\",\n)\nclass TestAESOCB3:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = AESOCB3.generate_key(128)\n        aesocb3 = AESOCB3(key)\n        nonce = b\"0\" * 12\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            aesocb3.encrypt(nonce, large_data, b\"\")\n\n        with pytest.raises(OverflowError):\n            aesocb3.encrypt(nonce, b\"\", large_data)\n\n    def test_vectors(self, backend, subtests):\n        vectors = []\n        for f in [\n            \"rfc7253.txt\",\n            \"openssl.txt\",\n            \"test-vector-1-nonce104.txt\",\n            \"test-vector-1-nonce112.txt\",\n            \"test-vector-1-nonce120.txt\",\n        ]:\n            vectors.extend(\n                load_vectors_from_file(\n                    os.path.join(\"ciphers\", \"AES\", \"OCB3\", f),\n                    load_nist_vectors,\n                )\n            )\n\n        for vector in vectors:\n            with subtests.test():\n                nonce = binascii.unhexlify(vector[\"nonce\"])\n                key = binascii.unhexlify(vector[\"key\"])\n                aad = binascii.unhexlify(vector[\"aad\"])\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                pt = binascii.unhexlify(vector.get(\"plaintext\", b\"\"))\n                aesocb3 = AESOCB3(key)\n                computed_ct = aesocb3.encrypt(nonce, pt, aad)\n                assert computed_ct == ct\n                computed_pt = aesocb3.decrypt(nonce, ct, aad)\n                assert computed_pt == pt\n\n    def test_vectors_invalid(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"ciphers\", \"AES\", \"OCB3\", \"rfc7253.txt\"),\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                nonce = binascii.unhexlify(vector[\"nonce\"])\n                key = binascii.unhexlify(vector[\"key\"])\n                aad = binascii.unhexlify(vector[\"aad\"])\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                aesocb3 = AESOCB3(key)\n                with pytest.raises(InvalidTag):\n                    badkey = AESOCB3(AESOCB3.generate_key(128))\n                    badkey.decrypt(nonce, ct, aad)\n                with pytest.raises(InvalidTag):\n                    aesocb3.decrypt(nonce, b\"nonsense\", aad)\n                with pytest.raises(InvalidTag):\n                    aesocb3.decrypt(b\"\\x00\" * 12, ct, aad)\n                with pytest.raises(InvalidTag):\n                    aesocb3.decrypt(nonce, ct, b\"nonsense\")\n\n    @pytest.mark.parametrize(\n        (\"key_len\", \"expected\"),\n        [\n            (128, b\"g\\xe9D\\xd22V\\xc5\\xe0\\xb6\\xc6\\x1f\\xa2/\\xdf\\x1e\\xa2\"),\n            (192, b\"\\xf6s\\xf2\\xc3\\xe7\\x17J\\xae{\\xae\\x98l\\xa9\\xf2\\x9e\\x17\"),\n            (256, b\"\\xd9\\x0e\\xb8\\xe9\\xc9w\\xc8\\x8by\\xddy=\\x7f\\xfa\\x16\\x1c\"),\n        ],\n    )\n    def test_rfc7253(self, backend, key_len, expected):\n        # This is derived from page 18 of RFC 7253, with a tag length of\n        # 128 bits.\n\n        k = AESOCB3(b\"\\x00\" * ((key_len - 8) // 8) + b\"\\x80\")\n\n        c = b\"\"\n\n        for i in range(0, 128):\n            s = b\"\\x00\" * i\n            n = (3 * i + 1).to_bytes(12, \"big\")\n            c += k.encrypt(n, s, s)\n            n = (3 * i + 2).to_bytes(12, \"big\")\n            c += k.encrypt(n, s, b\"\")\n            n = (3 * i + 3).to_bytes(12, \"big\")\n            c += k.encrypt(n, b\"\", s)\n\n        assert len(c) == 22400\n\n        n = (385).to_bytes(12, \"big\")\n        output = k.encrypt(n, b\"\", c)\n\n        assert output == expected\n\n    @pytest.mark.parametrize(\n        (\"nonce\", \"data\", \"associated_data\"),\n        [\n            [object(), b\"data\", b\"\"],\n            [b\"0\" * 12, object(), b\"\"],\n            [b\"0\" * 12, b\"data\", object()],\n        ],\n    )\n    def test_params_not_bytes(self, nonce, data, associated_data, backend):\n        key = AESOCB3.generate_key(128)\n        aesocb3 = AESOCB3(key)\n        with pytest.raises(TypeError):\n            aesocb3.encrypt(nonce, data, associated_data)\n\n        with pytest.raises(TypeError):\n            aesocb3.decrypt(nonce, data, associated_data)\n\n    def test_invalid_nonce_length(self, backend):\n        key = AESOCB3.generate_key(128)\n        aesocb3 = AESOCB3(key)\n        with pytest.raises(ValueError):\n            aesocb3.encrypt(b\"\\x00\" * 11, b\"hi\", None)\n        with pytest.raises(ValueError):\n            aesocb3.encrypt(b\"\\x00\" * 16, b\"hi\", None)\n\n        with pytest.raises(ValueError):\n            aesocb3.decrypt(b\"\\x00\" * 11, b\"hi\", None)\n        with pytest.raises(ValueError):\n            aesocb3.decrypt(b\"\\x00\" * 16, b\"hi\", None)\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            AESOCB3(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESOCB3(b\"0\" * 31)\n\n    def test_bad_generate_key(self, backend):\n        with pytest.raises(TypeError):\n            AESOCB3.generate_key(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESOCB3.generate_key(129)\n\n    def test_associated_data_none_equal_to_empty_bytestring(self, backend):\n        key = AESOCB3.generate_key(128)\n        aesocb3 = AESOCB3(key)\n        nonce = os.urandom(12)\n        ct1 = aesocb3.encrypt(nonce, b\"some_data\", None)\n        ct2 = aesocb3.encrypt(nonce, b\"some_data\", b\"\")\n        assert ct1 == ct2\n        pt1 = aesocb3.decrypt(nonce, ct1, None)\n        pt2 = aesocb3.decrypt(nonce, ct2, b\"\")\n        assert pt1 == pt2\n\n    def test_buffer_protocol(self, backend):\n        key = AESOCB3.generate_key(128)\n        aesocb3 = AESOCB3(key)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        nonce = os.urandom(12)\n        ct = aesocb3.encrypt(nonce, pt, ad)\n        computed_pt = aesocb3.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n        aesocb3_ = AESOCB3(bytearray(key))\n        ct2 = aesocb3_.encrypt(bytearray(nonce), pt, ad)\n        assert ct2 == ct\n        computed_pt2 = aesocb3_.decrypt(bytearray(nonce), ct2, ad)\n        assert computed_pt2 == pt\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESSIV),\n    reason=\"Does not support AESSIV\",\n)\nclass TestAESSIV:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = AESSIV.generate_key(256)\n        aessiv = AESSIV(key)\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            aessiv.encrypt(large_data, None)\n\n        with pytest.raises(OverflowError):\n            aessiv.encrypt(b\"irrelevant\", [large_data])\n\n        with pytest.raises(OverflowError):\n            aessiv.decrypt(b\"very very irrelevant\", [large_data])\n\n    def test_no_empty_encryption(self):\n        key = AESSIV.generate_key(256)\n        aessiv = AESSIV(key)\n\n        with pytest.raises(ValueError):\n            aessiv.encrypt(b\"\", None)\n\n        with pytest.raises(InvalidTag):\n            aessiv.decrypt(b\"\", None)\n\n    def test_vectors(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"ciphers\", \"AES\", \"SIV\", \"openssl.txt\"),\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                aad1 = vector.get(\"aad\", None)\n                aad2 = vector.get(\"aad2\", None)\n                aad3 = vector.get(\"aad3\", None)\n                aad = [\n                    binascii.unhexlify(a)\n                    for a in (aad1, aad2, aad3)\n                    if a is not None\n                ]\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                tag = binascii.unhexlify(vector[\"tag\"])\n                pt = binascii.unhexlify(vector.get(\"plaintext\", b\"\"))\n                aessiv = AESSIV(key)\n                computed_ct = aessiv.encrypt(pt, aad)\n                assert computed_ct[:16] == tag\n                assert computed_ct[16:] == ct\n                computed_pt = aessiv.decrypt(computed_ct, aad)\n                assert computed_pt == pt\n\n    def test_vectors_invalid(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"ciphers\", \"AES\", \"SIV\", \"openssl.txt\"),\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                aad1 = vector.get(\"aad\", None)\n                aad2 = vector.get(\"aad2\", None)\n                aad3 = vector.get(\"aad3\", None)\n                aad = [\n                    binascii.unhexlify(a)\n                    for a in (aad1, aad2, aad3)\n                    if a is not None\n                ]\n\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                aessiv = AESSIV(key)\n                with pytest.raises(InvalidTag):\n                    badkey = AESSIV(AESSIV.generate_key(256))\n                    badkey.decrypt(ct, aad)\n                with pytest.raises(InvalidTag):\n                    aessiv.decrypt(ct, [*aad, b\"\"])\n                with pytest.raises(InvalidTag):\n                    aessiv.decrypt(ct, [b\"nonsense\"])\n                with pytest.raises(InvalidTag):\n                    aessiv.decrypt(b\"nonsense\", aad)\n\n    @pytest.mark.parametrize(\n        (\"data\", \"associated_data\"),\n        [\n            [object(), [b\"\"]],\n            [b\"data\" * 5, [object()]],\n            [b\"data\" * 5, b\"\"],\n        ],\n    )\n    def test_params_not_bytes(self, data, associated_data, backend):\n        key = AESSIV.generate_key(256)\n        aessiv = AESSIV(key)\n        with pytest.raises(TypeError):\n            aessiv.encrypt(data, associated_data)\n\n        with pytest.raises(TypeError):\n            aessiv.decrypt(data, associated_data)\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            AESSIV(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESSIV(b\"0\" * 31)\n\n    def test_bad_generate_key(self, backend):\n        with pytest.raises(TypeError):\n            AESSIV.generate_key(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESSIV.generate_key(128)\n\n    def test_associated_data_none_equal_to_empty_list(self, backend):\n        key = AESSIV.generate_key(256)\n        aessiv = AESSIV(key)\n        ct1 = aessiv.encrypt(b\"some_data\", None)\n        ct2 = aessiv.encrypt(b\"some_data\", [])\n        assert ct1 == ct2\n        pt1 = aessiv.decrypt(ct1, None)\n        pt2 = aessiv.decrypt(ct2, [])\n        assert pt1 == pt2\n\n    def test_buffer_protocol(self, backend):\n        key = AESSIV.generate_key(256)\n        aessiv = AESSIV(key)\n        pt = b\"encrypt me\"\n        ad = [b\"additional\"]\n        ct = aessiv.encrypt(pt, ad)\n        computed_pt = aessiv.decrypt(ct, ad)\n        assert computed_pt == pt\n        aessiv = AESSIV(bytearray(key))\n        ct2 = aessiv.encrypt(pt, ad)\n        assert ct2 == ct\n        computed_pt2 = aessiv.decrypt(ct2, ad)\n        assert computed_pt2 == pt\n\n\n@pytest.mark.skipif(\n    not _aead_supported(AESGCMSIV),\n    reason=\"Does not support AESGCMSIV\",\n)\nclass TestAESGCMSIV:\n    @pytest.mark.skipif(\n        sys.platform not in {\"linux\", \"darwin\"} or sys.maxsize < 2**31,\n        reason=\"mmap and 64-bit platform required\",\n    )\n    def test_data_too_large(self):\n        key = AESGCMSIV.generate_key(256)\n        nonce = os.urandom(12)\n        aesgcmsiv = AESGCMSIV(key)\n\n        large_data = large_mmap()\n\n        with pytest.raises(OverflowError):\n            aesgcmsiv.encrypt(nonce, large_data, None)\n\n        with pytest.raises(OverflowError):\n            aesgcmsiv.encrypt(nonce, b\"irrelevant\", large_data)\n\n        with pytest.raises(OverflowError):\n            aesgcmsiv.decrypt(nonce, b\"very very irrelevant\", large_data)\n\n    def test_invalid_nonce_length(self, backend):\n        key = AESGCMSIV.generate_key(128)\n        aesgcmsiv = AESGCMSIV(key)\n        pt = b\"hello\"\n        nonce = os.urandom(14)\n        with pytest.raises(ValueError):\n            aesgcmsiv.encrypt(nonce, pt, None)\n\n        with pytest.raises(ValueError):\n            aesgcmsiv.decrypt(nonce, pt, None)\n\n    def test_no_empty_encryption(self):\n        key = AESGCMSIV.generate_key(256)\n        aesgcmsiv = AESGCMSIV(key)\n        nonce = os.urandom(12)\n\n        with pytest.raises(ValueError):\n            aesgcmsiv.encrypt(nonce, b\"\", None)\n\n        with pytest.raises(InvalidTag):\n            aesgcmsiv.decrypt(nonce, b\"\", None)\n\n    def test_vectors(self, backend, subtests):\n        vectors = _load_all_params(\n            os.path.join(\"ciphers\", \"AES\", \"GCM-SIV\"),\n            [\n                \"openssl.txt\",\n                \"aes-192-gcm-siv.txt\",\n            ],\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                nonce = binascii.unhexlify(vector[\"iv\"])\n                aad = binascii.unhexlify(vector.get(\"aad\", b\"\"))\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                tag = binascii.unhexlify(vector[\"tag\"])\n                pt = binascii.unhexlify(vector.get(\"plaintext\", b\"\"))\n                aesgcmsiv = AESGCMSIV(key)\n                computed_ct = aesgcmsiv.encrypt(nonce, pt, aad)\n                assert computed_ct[:-16] == ct\n                assert computed_ct[-16:] == tag\n                computed_pt = aesgcmsiv.decrypt(nonce, computed_ct, aad)\n                assert computed_pt == pt\n\n    def test_vectors_invalid(self, backend, subtests):\n        vectors = _load_all_params(\n            os.path.join(\"ciphers\", \"AES\", \"GCM-SIV\"),\n            [\n                \"openssl.txt\",\n                \"aes-192-gcm-siv.txt\",\n            ],\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                key = binascii.unhexlify(vector[\"key\"])\n                nonce = binascii.unhexlify(vector[\"iv\"])\n                aad = binascii.unhexlify(vector.get(\"aad\", b\"\"))\n                ct = binascii.unhexlify(vector[\"ciphertext\"])\n                aesgcmsiv = AESGCMSIV(key)\n                with pytest.raises(InvalidTag):\n                    badkey = AESGCMSIV(AESGCMSIV.generate_key(256))\n                    badkey.decrypt(nonce, ct, aad)\n                with pytest.raises(InvalidTag):\n                    aesgcmsiv.decrypt(nonce, ct, b\"nonsense\")\n                with pytest.raises(InvalidTag):\n                    aesgcmsiv.decrypt(nonce, b\"nonsense\", aad)\n\n    @pytest.mark.parametrize(\n        (\"nonce\", \"data\", \"associated_data\"),\n        [\n            [object(), b\"data\", b\"\"],\n            [b\"0\" * 12, object(), b\"\"],\n            [b\"0\" * 12, b\"data\", object()],\n        ],\n    )\n    def test_params_not_bytes(self, nonce, data, associated_data, backend):\n        key = AESGCMSIV.generate_key(256)\n        aesgcmsiv = AESGCMSIV(key)\n        with pytest.raises(TypeError):\n            aesgcmsiv.encrypt(nonce, data, associated_data)\n\n        with pytest.raises(TypeError):\n            aesgcmsiv.decrypt(nonce, data, associated_data)\n\n    def test_bad_key(self, backend):\n        with pytest.raises(TypeError):\n            AESGCMSIV(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESGCMSIV(b\"0\" * 31)\n\n    def test_bad_generate_key(self, backend):\n        with pytest.raises(TypeError):\n            AESGCMSIV.generate_key(object())  # type:ignore[arg-type]\n\n        with pytest.raises(ValueError):\n            AESGCMSIV.generate_key(129)\n\n    def test_associated_data_none_equal_to_empty_bytestring(self, backend):\n        key = AESGCMSIV.generate_key(256)\n        aesgcmsiv = AESGCMSIV(key)\n        nonce = os.urandom(12)\n        ct1 = aesgcmsiv.encrypt(nonce, b\"some_data\", None)\n        ct2 = aesgcmsiv.encrypt(nonce, b\"some_data\", b\"\")\n        assert ct1 == ct2\n        pt1 = aesgcmsiv.decrypt(nonce, ct1, None)\n        pt2 = aesgcmsiv.decrypt(nonce, ct2, b\"\")\n        assert pt1 == pt2\n\n    def test_buffer_protocol(self, backend):\n        key = AESGCMSIV.generate_key(256)\n        aesgcmsiv = AESGCMSIV(key)\n        nonce = os.urandom(12)\n        pt = b\"encrypt me\"\n        ad = b\"additional\"\n        ct = aesgcmsiv.encrypt(nonce, pt, ad)\n        computed_pt = aesgcmsiv.decrypt(nonce, ct, ad)\n        assert computed_pt == pt\n        aesgcmsiv = AESGCMSIV(bytearray(key))\n        ct2 = aesgcmsiv.encrypt(nonce, pt, ad)\n        assert ct2 == ct\n        computed_pt2 = aesgcmsiv.decrypt(nonce, ct2, ad)\n        assert computed_pt2 == pt\n", "tests/hazmat/primitives/test_block.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, _Reasons\nfrom cryptography.hazmat.primitives.ciphers import (\n    Cipher,\n    algorithms,\n    base,\n    modes,\n)\n\nfrom ...doubles import DummyCipherAlgorithm, DummyMode\nfrom ...utils import raises_unsupported_algorithm\nfrom .utils import (\n    generate_aead_exception_test,\n    generate_aead_tag_exception_test,\n)\n\n\nclass TestCipher:\n    def test_creates_encryptor(self, backend):\n        cipher = Cipher(\n            algorithms.AES(binascii.unhexlify(b\"0\" * 32)),\n            modes.CBC(binascii.unhexlify(b\"0\" * 32)),\n            backend,\n        )\n        assert isinstance(cipher.encryptor(), base.CipherContext)\n\n    def test_creates_decryptor(self, backend):\n        cipher = Cipher(\n            algorithms.AES(binascii.unhexlify(b\"0\" * 32)),\n            modes.CBC(binascii.unhexlify(b\"0\" * 32)),\n            backend,\n        )\n        assert isinstance(cipher.decryptor(), base.CipherContext)\n\n    def test_instantiate_with_non_algorithm(self, backend):\n        algorithm = object()\n        with pytest.raises(TypeError):\n            Cipher(\n                algorithm,  # type: ignore[arg-type]\n                mode=None,\n                backend=backend,\n            )\n\n\nclass TestCipherContext:\n    def test_use_after_finalize(self, backend):\n        cipher = Cipher(\n            algorithms.AES(binascii.unhexlify(b\"0\" * 32)),\n            modes.CBC(binascii.unhexlify(b\"0\" * 32)),\n            backend,\n        )\n        encryptor = cipher.encryptor()\n        encryptor.update(b\"a\" * 16)\n        encryptor.finalize()\n        with pytest.raises(AlreadyFinalized):\n            encryptor.update(b\"b\" * 16)\n        with pytest.raises(AlreadyFinalized):\n            encryptor.finalize()\n        decryptor = cipher.decryptor()\n        decryptor.update(b\"a\" * 16)\n        decryptor.finalize()\n        with pytest.raises(AlreadyFinalized):\n            decryptor.update(b\"b\" * 16)\n        with pytest.raises(AlreadyFinalized):\n            decryptor.finalize()\n\n    def test_use_update_into_after_finalize(self, backend):\n        cipher = Cipher(\n            algorithms.AES(binascii.unhexlify(b\"0\" * 32)),\n            modes.CBC(binascii.unhexlify(b\"0\" * 32)),\n            backend,\n        )\n        encryptor = cipher.encryptor()\n        encryptor.update(b\"a\" * 16)\n        encryptor.finalize()\n        with pytest.raises(AlreadyFinalized):\n            buf = bytearray(31)\n            encryptor.update_into(b\"b\" * 16, buf)\n\n    def test_unaligned_block_encryption(self, backend):\n        cipher = Cipher(\n            algorithms.AES(binascii.unhexlify(b\"0\" * 32)), modes.ECB(), backend\n        )\n        encryptor = cipher.encryptor()\n        ct = encryptor.update(b\"a\" * 15)\n        assert ct == b\"\"\n        ct += encryptor.update(b\"a\" * 65)\n        assert len(ct) == 80\n        ct += encryptor.finalize()\n        decryptor = cipher.decryptor()\n        pt = decryptor.update(ct[:3])\n        assert pt == b\"\"\n        pt += decryptor.update(ct[3:])\n        assert len(pt) == 80\n        assert pt == b\"a\" * 80\n        decryptor.finalize()\n\n    @pytest.mark.parametrize(\"mode\", [DummyMode(), None])\n    def test_nonexistent_cipher(self, backend, mode):\n        cipher = Cipher(DummyCipherAlgorithm(), mode, backend)\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            cipher.encryptor()\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            cipher.decryptor()\n\n    def test_incorrectly_padded(self, backend):\n        cipher = Cipher(\n            algorithms.AES(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 16), backend\n        )\n        encryptor = cipher.encryptor()\n        encryptor.update(b\"1\")\n        with pytest.raises(ValueError):\n            encryptor.finalize()\n\n        decryptor = cipher.decryptor()\n        decryptor.update(b\"1\")\n        with pytest.raises(ValueError):\n            decryptor.finalize()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.GCM(b\"\\x00\" * 12)\n    ),\n    skip_message=\"Does not support AES GCM\",\n)\nclass TestAEADCipherContext:\n    test_aead_exceptions = generate_aead_exception_test(\n        algorithms.AES,\n        modes.GCM,\n    )\n    test_aead_tag_exceptions = generate_aead_tag_exception_test(\n        algorithms.AES,\n        modes.GCM,\n    )\n\n\nclass TestModeValidation:\n    def test_cbc(self, backend):\n        with pytest.raises(ValueError):\n            Cipher(\n                algorithms.AES(b\"\\x00\" * 16),\n                modes.CBC(b\"abc\"),\n                backend,\n            )\n\n    def test_ofb(self, backend):\n        with pytest.raises(ValueError):\n            Cipher(\n                algorithms.AES(b\"\\x00\" * 16),\n                modes.OFB(b\"abc\"),\n                backend,\n            )\n\n    def test_cfb(self, backend):\n        with pytest.raises(ValueError):\n            Cipher(\n                algorithms.AES(b\"\\x00\" * 16),\n                modes.CFB(b\"abc\"),\n                backend,\n            )\n\n    def test_cfb8(self, backend):\n        with pytest.raises(ValueError):\n            Cipher(\n                algorithms.AES(b\"\\x00\" * 16),\n                modes.CFB8(b\"abc\"),\n                backend,\n            )\n\n    def test_ctr(self, backend):\n        with pytest.raises(ValueError):\n            Cipher(\n                algorithms.AES(b\"\\x00\" * 16),\n                modes.CTR(b\"abc\"),\n                backend,\n            )\n\n    def test_gcm(self):\n        with pytest.raises(ValueError):\n            modes.GCM(b\"\")\n\n\nclass TestModesRequireBytes:\n    def test_cbc(self):\n        with pytest.raises(TypeError):\n            modes.CBC([1] * 16)  # type:ignore[arg-type]\n\n    def test_cfb(self):\n        with pytest.raises(TypeError):\n            modes.CFB([1] * 16)  # type:ignore[arg-type]\n\n    def test_cfb8(self):\n        with pytest.raises(TypeError):\n            modes.CFB8([1] * 16)  # type:ignore[arg-type]\n\n    def test_ofb(self):\n        with pytest.raises(TypeError):\n            modes.OFB([1] * 16)  # type:ignore[arg-type]\n\n    def test_ctr(self):\n        with pytest.raises(TypeError):\n            modes.CTR([1] * 16)  # type:ignore[arg-type]\n\n    def test_gcm_iv(self):\n        with pytest.raises(TypeError):\n            modes.GCM([1] * 16)  # type:ignore[arg-type]\n\n    def test_gcm_tag(self):\n        with pytest.raises(TypeError):\n            modes.GCM(b\"\\x00\" * 16, [1] * 16)  # type:ignore[arg-type]\n", "tests/hazmat/primitives/test_aes_gcm.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives.ciphers import algorithms, base, modes\n\nfrom ...utils import load_nist_vectors\nfrom .utils import generate_aead_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.AES(b\"\\x00\" * 16), modes.GCM(b\"\\x00\" * 12)\n    ),\n    skip_message=\"Does not support AES GCM\",\n)\nclass TestAESModeGCM:\n    test_gcm = generate_aead_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"AES\", \"GCM\"),\n        [\n            \"gcmDecrypt128.rsp\",\n            \"gcmDecrypt192.rsp\",\n            \"gcmDecrypt256.rsp\",\n            \"gcmEncryptExtIV128.rsp\",\n            \"gcmEncryptExtIV192.rsp\",\n            \"gcmEncryptExtIV256.rsp\",\n        ],\n        algorithms.AES,\n        modes.GCM,\n    )\n\n    def test_gcm_tag_with_only_aad(self, backend):\n        key = binascii.unhexlify(b\"5211242698bed4774a090620a6ca56f3\")\n        iv = binascii.unhexlify(b\"b1e1349120b6e832ef976f5d\")\n        aad = binascii.unhexlify(b\"b6d729aab8e6416d7002b9faa794c410d8d2f193\")\n        tag = binascii.unhexlify(b\"0f247e7f9c2505de374006738018493b\")\n\n        cipher = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        )\n        encryptor = cipher.encryptor()\n        encryptor.authenticate_additional_data(aad)\n        encryptor.finalize()\n        assert encryptor.tag == tag\n\n    def test_gcm_ciphertext_with_no_aad(self, backend):\n        key = binascii.unhexlify(b\"e98b72a9881a84ca6b76e0f43e68647a\")\n        iv = binascii.unhexlify(b\"8b23299fde174053f3d652ba\")\n        ct = binascii.unhexlify(b\"5a3c1cf1985dbb8bed818036fdd5ab42\")\n        tag = binascii.unhexlify(b\"23c7ab0f952b7091cd324835043b5eb5\")\n        pt = binascii.unhexlify(b\"28286a321293253c3e0aa2704a278032\")\n\n        cipher = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        )\n        encryptor = cipher.encryptor()\n        computed_ct = encryptor.update(pt) + encryptor.finalize()\n        assert computed_ct == ct\n        assert encryptor.tag == tag\n\n    def test_gcm_ciphertext_limit(self, backend):\n        cipher = base.Cipher(\n            algorithms.AES(b\"\\x00\" * 16),\n            modes.GCM(b\"\\x01\" * 16),\n            backend=backend,\n        )\n        encryptor = cipher.encryptor()\n        rust_openssl.ciphers._advance(\n            encryptor, modes.GCM._MAX_ENCRYPTED_BYTES - 16\n        )\n        encryptor.update(b\"0\" * 16)\n        with pytest.raises(ValueError):\n            encryptor.update(b\"0\")\n        with pytest.raises(ValueError):\n            encryptor.update_into(b\"0\", bytearray(1))\n\n        decryptor = cipher.decryptor()\n        rust_openssl.ciphers._advance(\n            decryptor, modes.GCM._MAX_ENCRYPTED_BYTES - 16\n        )\n        decryptor.update(b\"0\" * 16)\n        with pytest.raises(ValueError):\n            decryptor.update(b\"0\")\n        with pytest.raises(ValueError):\n            decryptor.update_into(b\"0\", bytearray(1))\n\n    def test_gcm_aad_limit(self, backend):\n        cipher = base.Cipher(\n            algorithms.AES(b\"\\x00\" * 16),\n            modes.GCM(b\"\\x01\" * 16),\n            backend=backend,\n        )\n        encryptor = cipher.encryptor()\n        rust_openssl.ciphers._advance_aad(\n            encryptor, modes.GCM._MAX_AAD_BYTES - 16\n        )\n        encryptor.authenticate_additional_data(b\"0\" * 16)\n        with pytest.raises(ValueError):\n            encryptor.authenticate_additional_data(b\"0\")\n\n        decryptor = cipher.decryptor()\n        rust_openssl.ciphers._advance_aad(\n            decryptor, modes.GCM._MAX_AAD_BYTES - 16\n        )\n        decryptor.authenticate_additional_data(b\"0\" * 16)\n        with pytest.raises(ValueError):\n            decryptor.authenticate_additional_data(b\"0\")\n\n    def test_gcm_tag_decrypt_none(self, backend):\n        key = binascii.unhexlify(b\"5211242698bed4774a090620a6ca56f3\")\n        iv = binascii.unhexlify(b\"b1e1349120b6e832ef976f5d\")\n        aad = binascii.unhexlify(b\"b6d729aab8e6416d7002b9faa794c410d8d2f193\")\n\n        encryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        ).encryptor()\n        encryptor.authenticate_additional_data(aad)\n        encryptor.finalize()\n\n        decryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        ).decryptor()\n        decryptor.authenticate_additional_data(aad)\n        with pytest.raises(ValueError):\n            decryptor.finalize()\n\n    def test_gcm_tag_decrypt_mode(self, backend):\n        key = binascii.unhexlify(b\"5211242698bed4774a090620a6ca56f3\")\n        iv = binascii.unhexlify(b\"b1e1349120b6e832ef976f5d\")\n        aad = binascii.unhexlify(b\"b6d729aab8e6416d7002b9faa794c410d8d2f193\")\n\n        encryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        ).encryptor()\n        encryptor.authenticate_additional_data(aad)\n        encryptor.finalize()\n        tag = encryptor.tag\n\n        decryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv, tag), backend=backend\n        ).decryptor()\n        decryptor.authenticate_additional_data(aad)\n        decryptor.finalize()\n\n    def test_gcm_tag_decrypt_finalize(self, backend):\n        key = binascii.unhexlify(b\"5211242698bed4774a090620a6ca56f3\")\n        iv = binascii.unhexlify(b\"b1e1349120b6e832ef976f5d\")\n        aad = binascii.unhexlify(b\"b6d729aab8e6416d7002b9faa794c410d8d2f193\")\n\n        encryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        ).encryptor()\n        encryptor.authenticate_additional_data(aad)\n        encryptor.finalize()\n        tag = encryptor.tag\n\n        decryptor = base.Cipher(\n            algorithms.AES(key), modes.GCM(iv), backend=backend\n        ).decryptor()\n        decryptor.authenticate_additional_data(aad)\n\n        decryptor.finalize_with_tag(tag)\n\n    @pytest.mark.parametrize(\"tag\", [b\"tagtooshort\", b\"toolong\" * 12])\n    def test_gcm_tag_decrypt_finalize_tag_length(self, tag, backend):\n        decryptor = base.Cipher(\n            algorithms.AES(b\"0\" * 16), modes.GCM(b\"0\" * 12), backend=backend\n        ).decryptor()\n        with pytest.raises(ValueError):\n            decryptor.finalize_with_tag(tag)\n\n    def test_buffer_protocol(self, backend):\n        data = bytearray(b\"helloworld\")\n        c = base.Cipher(\n            algorithms.AES(bytearray(b\"\\x00\" * 16)),\n            modes.GCM(bytearray(b\"\\x00\" * 12)),\n            backend,\n        )\n        enc = c.encryptor()\n        enc.authenticate_additional_data(bytearray(b\"foo\"))\n        ct = enc.update(data) + enc.finalize()\n\n        dec = c.decryptor()\n        dec.authenticate_additional_data(bytearray(b\"foo\"))\n        pt = dec.update(ct) + dec.finalize_with_tag(enc.tag)\n        assert pt == data\n\n        enc = c.encryptor()\n        with pytest.raises(ValueError):\n            enc.update_into(b\"abc123\", bytearray(0))\n\n    @pytest.mark.parametrize(\"size\", [8, 128])\n    def test_gcm_min_max_iv(self, size, backend):\n        if backend._fips_enabled:\n            # Red Hat disables non-96-bit IV support as part of its FIPS\n            # patches.\n            pytest.skip(\"Non-96-bit IVs unsupported in FIPS mode.\")\n\n        key = os.urandom(16)\n        iv = b\"\\x00\" * size\n\n        payload = b\"data\"\n        encryptor = base.Cipher(algorithms.AES(key), modes.GCM(iv)).encryptor()\n        ct = encryptor.update(payload)\n        encryptor.finalize()\n        tag = encryptor.tag\n\n        decryptor = base.Cipher(algorithms.AES(key), modes.GCM(iv)).decryptor()\n        pt = decryptor.update(ct)\n\n        decryptor.finalize_with_tag(tag)\n        assert pt == payload\n\n    @pytest.mark.parametrize(\"alg\", [algorithms.AES128, algorithms.AES256])\n    def test_alternate_aes_classes(self, alg, backend):\n        data = bytearray(b\"sixteen_byte_msg\")\n        cipher = base.Cipher(\n            alg(b\"0\" * (alg.key_size // 8)), modes.GCM(b\"\\x00\" * 12), backend\n        )\n        enc = cipher.encryptor()\n        ct = enc.update(data) + enc.finalize()\n        dec = cipher.decryptor()\n        pt = dec.update(ct) + dec.finalize_with_tag(enc.tag)\n        assert pt == data\n", "tests/hazmat/primitives/test_ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport copy\nimport itertools\nimport os\nimport textwrap\nimport typing\nfrom binascii import hexlify\n\nimport pytest\n\nfrom cryptography import exceptions, utils, x509\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric.ec import (\n    EllipticCurvePrivateKey,\n    EllipticCurvePublicKey,\n)\nfrom cryptography.hazmat.primitives.asymmetric.utils import (\n    Prehashed,\n    encode_dss_signature,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import (\n    load_fips_ecdsa_key_pair_vectors,\n    load_fips_ecdsa_signing_vectors,\n    load_kasvs_ecdh_vectors,\n    load_nist_vectors,\n    load_rfc6979_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\nfrom .fixtures_ec import EC_KEY_SECP384R1\nfrom .utils import skip_fips_traditional_openssl\n\n_HASH_TYPES: typing.Dict[str, typing.Type[hashes.HashAlgorithm]] = {\n    \"SHA-1\": hashes.SHA1,\n    \"SHA-224\": hashes.SHA224,\n    \"SHA-256\": hashes.SHA256,\n    \"SHA-384\": hashes.SHA384,\n    \"SHA-512\": hashes.SHA512,\n}\n\n\ndef _skip_ecdsa_vector(backend, curve: ec.EllipticCurve, hash_type):\n    if not backend.elliptic_curve_signature_algorithm_supported(\n        ec.ECDSA(hash_type()), curve\n    ):\n        pytest.skip(\n            f\"ECDSA not supported with this hash {hash_type().name} and \"\n            f\"curve {curve.name}.\"\n        )\n\n\ndef _skip_curve_unsupported(backend, curve: ec.EllipticCurve):\n    if not backend.elliptic_curve_supported(curve):\n        pytest.skip(\n            f\"Curve {curve.name} is not supported by this backend {backend}\"\n        )\n\n\ndef _skip_exchange_algorithm_unsupported(backend, algorithm, curve):\n    if not backend.elliptic_curve_exchange_algorithm_supported(\n        algorithm, curve\n    ):\n        pytest.skip(\n            f\"Exchange with {curve.name} curve is not supported by {backend}\"\n        )\n\n\ndef test_get_curve_for_oid():\n    assert ec.get_curve_for_oid(ec.EllipticCurveOID.SECP256R1) == ec.SECP256R1\n    with pytest.raises(LookupError):\n        ec.get_curve_for_oid(x509.ObjectIdentifier(\"1.1.1.1\"))\n\n\nclass DummyCurve(ec.EllipticCurve):\n    name = \"dummy-curve\"\n    key_size = 1\n\n\nclass DummySignatureAlgorithm(ec.EllipticCurveSignatureAlgorithm):\n    algorithm = hashes.SHA256()\n\n\ndef test_skip_curve_unsupported(backend):\n    with pytest.raises(pytest.skip.Exception):\n        _skip_curve_unsupported(backend, DummyCurve())\n\n\ndef test_skip_exchange_algorithm_unsupported(backend):\n    with pytest.raises(pytest.skip.Exception):\n        _skip_exchange_algorithm_unsupported(backend, ec.ECDH(), DummyCurve())\n\n\ndef test_skip_ecdsa_vector(backend):\n    with pytest.raises(pytest.skip.Exception):\n        _skip_ecdsa_vector(backend, DummyCurve(), hashes.SHA256)\n\n\ndef test_derive_private_key_success(backend):\n    curve = ec.SECP256K1()\n    _skip_curve_unsupported(backend, curve)\n\n    private_numbers = ec.generate_private_key(curve, backend).private_numbers()\n\n    derived_key = ec.derive_private_key(\n        private_numbers.private_value, curve, backend\n    )\n\n    assert private_numbers == derived_key.private_numbers()\n\n\ndef test_derive_private_key_errors(backend):\n    curve = ec.SECP256K1()\n    _skip_curve_unsupported(backend, curve)\n\n    with pytest.raises(TypeError):\n        ec.derive_private_key(\"one\", curve, backend)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        ec.derive_private_key(10, \"five\", backend)  # type: ignore[arg-type]\n\n    with pytest.raises(ValueError):\n        ec.derive_private_key(-7, curve, backend)\n\n\ndef test_derive_point_at_infinity(backend):\n    curve = ec.SECP256R1()\n    _skip_curve_unsupported(backend, curve)\n    # order of the curve\n    q = 0xFFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\n    # BoringSSL rejects infinity points before it ever gets to us, so it\n    # uses a more generic error message.\n    match = (\n        \"infinity\" if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL else \"Invalid\"\n    )\n    with pytest.raises(ValueError, match=match):\n        ec.derive_private_key(q, ec.SECP256R1())\n\n\ndef test_ec_numbers():\n    numbers = ec.EllipticCurvePrivateNumbers(\n        1, ec.EllipticCurvePublicNumbers(2, 3, DummyCurve())\n    )\n\n    assert numbers.private_value == 1\n    assert numbers.public_numbers.x == 2\n    assert numbers.public_numbers.y == 3\n    assert isinstance(numbers.public_numbers.curve, DummyCurve)\n\n\n@pytest.mark.parametrize(\n    (\"private_value\", \"x\", \"y\", \"curve\"),\n    [\n        (None, 2, 3, DummyCurve()),\n        (1, None, 3, DummyCurve()),\n        (1, 2, None, DummyCurve()),\n        (1, 2, 3, None),\n    ],\n)\ndef test_invalid_ec_numbers_args(private_value, x, y, curve):\n    with pytest.raises(TypeError):\n        ec.EllipticCurvePrivateNumbers(\n            private_value, ec.EllipticCurvePublicNumbers(x, y, curve)\n        )\n\n\ndef test_invalid_private_numbers_public_numbers():\n    with pytest.raises(TypeError):\n        ec.EllipticCurvePrivateNumbers(1, None)  # type: ignore[arg-type]\n\n\ndef test_ec_public_numbers_repr():\n    pn = ec.EllipticCurvePublicNumbers(2, 3, ec.SECP256R1())\n    assert (\n        repr(pn) == \"<EllipticCurvePublicNumbers(curve=secp256r1, x=2, y=3)>\"\n    )\n\n\ndef test_ec_public_numbers_hash():\n    pn1 = ec.EllipticCurvePublicNumbers(2, 3, ec.SECP256R1())\n    pn2 = ec.EllipticCurvePublicNumbers(2, 3, ec.SECP256R1())\n    pn3 = ec.EllipticCurvePublicNumbers(1, 3, ec.SECP256R1())\n\n    assert hash(pn1) == hash(pn2)\n    assert hash(pn1) != hash(pn3)\n\n\ndef test_ec_private_numbers_hash():\n    numbers1 = ec.EllipticCurvePrivateNumbers(\n        1, ec.EllipticCurvePublicNumbers(2, 3, DummyCurve())\n    )\n    numbers2 = ec.EllipticCurvePrivateNumbers(\n        1, ec.EllipticCurvePublicNumbers(2, 3, DummyCurve())\n    )\n    numbers3 = ec.EllipticCurvePrivateNumbers(\n        2, ec.EllipticCurvePublicNumbers(2, 3, DummyCurve())\n    )\n\n    assert hash(numbers1) == hash(numbers2)\n    assert hash(numbers1) != hash(numbers3)\n\n\ndef test_ec_key_key_size(backend):\n    curve = ec.SECP256R1()\n    _skip_curve_unsupported(backend, curve)\n    key = ec.generate_private_key(curve, backend)\n    assert key.key_size == 256\n    assert key.public_key().key_size == 256\n\n\ndef test_deprecated_generate_private_key_with_curve_class(backend):\n    # This test verifies that if you pass a curve _class_ instead of instance,\n    # you get a warning and then `key.curve` is still an instance.\n    _skip_curve_unsupported(backend, ec.SECP256R1())\n\n    with pytest.warns(utils.DeprecatedIn42):\n        key = ec.generate_private_key(ec.SECP256R1)  # type: ignore[arg-type]\n    assert isinstance(key.curve, ec.SECP256R1)\n\n\nclass TestECWithNumbers:\n    def test_with_numbers(self, backend, subtests):\n        vectors = itertools.product(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"ECDSA\", \"FIPS_186-3\", \"KeyPair.rsp\"\n                ),\n                load_fips_ecdsa_key_pair_vectors,\n            ),\n            _HASH_TYPES.values(),\n        )\n        for vector, hash_type in vectors:\n            with subtests.test():\n                curve = ec._CURVE_TYPES[vector[\"curve\"]]\n\n                _skip_ecdsa_vector(backend, curve, hash_type)\n\n                key = ec.EllipticCurvePrivateNumbers(\n                    vector[\"d\"],\n                    ec.EllipticCurvePublicNumbers(\n                        vector[\"x\"], vector[\"y\"], curve\n                    ),\n                ).private_key(backend)\n                assert key\n\n                priv_num = key.private_numbers()\n                assert priv_num.private_value == vector[\"d\"]\n                assert priv_num.public_numbers.x == vector[\"x\"]\n                assert priv_num.public_numbers.y == vector[\"y\"]\n                assert curve.name == priv_num.public_numbers.curve.name\n\n\nclass TestECDSAVectors:\n    def test_signing_with_example_keys(self, backend, subtests):\n        vectors = itertools.product(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"ECDSA\", \"FIPS_186-3\", \"KeyPair.rsp\"\n                ),\n                load_fips_ecdsa_key_pair_vectors,\n            ),\n            _HASH_TYPES.values(),\n        )\n        for vector, hash_type in vectors:\n            with subtests.test():\n                curve = ec._CURVE_TYPES[vector[\"curve\"]]\n\n                _skip_ecdsa_vector(backend, curve, hash_type)\n\n                key = ec.EllipticCurvePrivateNumbers(\n                    vector[\"d\"],\n                    ec.EllipticCurvePublicNumbers(\n                        vector[\"x\"], vector[\"y\"], curve\n                    ),\n                ).private_key(backend)\n                assert key\n\n                pkey = key.public_key()\n                assert pkey\n\n                signature = key.sign(\n                    b\"YELLOW SUBMARINE\", ec.ECDSA(hash_type())\n                )\n\n                pkey.verify(\n                    signature, b\"YELLOW SUBMARINE\", ec.ECDSA(hash_type())\n                )\n\n    @pytest.mark.parametrize(\"curve\", ec._CURVE_TYPES.values())\n    def test_generate_vector_curves(self, backend, curve):\n        _skip_curve_unsupported(backend, curve)\n\n        key = ec.generate_private_key(curve, backend)\n        assert key\n        assert type(key.curve) is type(curve)\n        assert key.curve.key_size\n\n        pkey = key.public_key()\n        assert pkey\n        assert type(pkey.curve) is type(curve)\n        assert key.curve.key_size == pkey.curve.key_size\n\n    def test_generate_unknown_curve(self, backend):\n        with raises_unsupported_algorithm(\n            exceptions._Reasons.UNSUPPORTED_ELLIPTIC_CURVE\n        ):\n            ec.generate_private_key(DummyCurve(), backend)\n\n        assert (\n            backend.elliptic_curve_signature_algorithm_supported(\n                ec.ECDSA(hashes.SHA256()), DummyCurve()\n            )\n            is False\n        )\n\n    def test_unknown_signature_algoritm(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP192R1())\n\n        key = ec.generate_private_key(ec.SECP192R1(), backend)\n\n        with raises_unsupported_algorithm(\n            exceptions._Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n        ):\n            key.sign(b\"somedata\", DummySignatureAlgorithm())\n\n        with raises_unsupported_algorithm(\n            exceptions._Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n        ):\n            key.public_key().verify(\n                b\"signature\", b\"data\", DummySignatureAlgorithm()\n            )\n\n        assert (\n            backend.elliptic_curve_signature_algorithm_supported(\n                DummySignatureAlgorithm(), ec.SECP192R1()\n            )\n            is False\n        )\n\n    def test_load_invalid_ec_key_from_numbers(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        numbers = ec.EllipticCurvePrivateNumbers(\n            357646505660320080863666618182642070958081774038609089496899025506,\n            ec.EllipticCurvePublicNumbers(\n                47250808410327023131573602008345894927686381772325561185532964,\n                1120253292479243545483756778742719537373113335231773536789915,\n                ec.SECP256R1(),\n            ),\n        )\n        with pytest.raises(ValueError):\n            numbers.private_key(backend)\n\n        numbers = ec.EllipticCurvePrivateNumbers(\n            357646505660320080863666618182642070958081774038609089496899025506,\n            ec.EllipticCurvePublicNumbers(\n                -4725080841032702313157360200834589492768638177232556118553296,\n                1120253292479243545483756778742719537373113335231773536789915,\n                ec.SECP256R1(),\n            ),\n        )\n        with pytest.raises(ValueError):\n            numbers.private_key(backend)\n\n        numbers = ec.EllipticCurvePrivateNumbers(\n            357646505660320080863666618182642070958081774038609089496899025506,\n            ec.EllipticCurvePublicNumbers(\n                47250808410327023131573602008345894927686381772325561185532964,\n                -1120253292479243545483756778742719537373113335231773536789915,\n                ec.SECP256R1(),\n            ),\n        )\n        with pytest.raises(ValueError):\n            numbers.private_key(backend)\n\n    def test_load_invalid_public_ec_key_from_numbers(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP521R1())\n\n        # Bad X coordinate\n        numbers = ec.EllipticCurvePublicNumbers(\n            int(\n                \"000003647356b91f8ace114c7247ecf4f4a622553fc025e04a178f179ef27\"\n                \"9090c184af678a4c78f635483bdd8aa544851c6ef291c1f0d6a241ebfd145\"\n                \"77d1d30d9903ce\",\n                16,\n            ),\n            int(\n                \"000001499bc7e079322ea0fcfbd6b40103fa6a1536c2257b182db0df4b369\"\n                \"6ec643adf100eb4f2025d1b873f82e5a475d6e4400ba777090eeb4563a115\"\n                \"09e4c87319dc26\",\n                16,\n            ),\n            ec.SECP521R1(),\n        )\n        with pytest.raises(ValueError):\n            numbers.public_key(backend)\n\n        # Bad Y coordinate\n        numbers = ec.EllipticCurvePublicNumbers(\n            int(\n                \"0000019aadc221cc0525118ab6d5aa1f64720603de0be128cbfea0b381ad8\"\n                \"02a2facc6370bb58cf88b3f0c692bc654ee19d6cad198f10d4b681b396f20\"\n                \"d2e40603fa945b\",\n                16,\n            ),\n            int(\n                \"0000025da392803a320717a08d4cb3dea932039badff363b71bdb8064e726\"\n                \"6c7f4f4b748d4d425347fc33e3885d34b750fa7fcd5691f4d90c89522ce33\"\n                \"feff5db10088a5\",\n                16,\n            ),\n            ec.SECP521R1(),\n        )\n        with pytest.raises(ValueError):\n            numbers.public_key(backend)\n\n    def test_load_invalid_ec_key_from_pem(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        # BoringSSL rejects infinity points before it ever gets to us, so it\n        # uses a more generic error message.\n        match = (\n            r\"infinity|invalid form\"\n            if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n            else None\n        )\n        with pytest.raises(ValueError, match=match):\n            serialization.load_pem_public_key(\n                textwrap.dedent(\n                    \"\"\"\n            -----BEGIN PUBLIC KEY-----\n            MBkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDAgAA\n            -----END PUBLIC KEY-----\n            \"\"\"\n                ).encode(),\n                backend=backend,\n            )\n        with pytest.raises(ValueError, match=match):\n            serialization.load_pem_private_key(\n                textwrap.dedent(\n                    \"\"\"\n            -----BEGIN PRIVATE KEY-----\n            MEECAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQcEJzAlAgEBBCD/////AAAAAP//////\n            ////vOb6racXnoTzucrC/GMlUQ==\n            -----END PRIVATE KEY-----\n            \"\"\"\n                ).encode(),\n                password=None,\n                backend=backend,\n            )\n\n    def test_signatures(self, backend, subtests):\n        vectors = itertools.chain(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"ECDSA\", \"FIPS_186-3\", \"SigGen.txt\"\n                ),\n                load_fips_ecdsa_signing_vectors,\n            ),\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"ECDSA\", \"SECP256K1\", \"SigGen.txt\"),\n                load_fips_ecdsa_signing_vectors,\n            ),\n        )\n        for vector in vectors:\n            with subtests.test():\n                hash_type = _HASH_TYPES[vector[\"digest_algorithm\"]]\n                curve = ec._CURVE_TYPES[vector[\"curve\"]]\n\n                _skip_ecdsa_vector(backend, curve, hash_type)\n\n                key = ec.EllipticCurvePublicNumbers(\n                    vector[\"x\"], vector[\"y\"], curve\n                ).public_key(backend)\n\n                signature = encode_dss_signature(vector[\"r\"], vector[\"s\"])\n\n                key.verify(signature, vector[\"message\"], ec.ECDSA(hash_type()))\n\n    def test_signature_failures(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"ECDSA\", \"FIPS_186-3\", \"SigVer.rsp\"),\n            load_fips_ecdsa_signing_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                hash_type = _HASH_TYPES[vector[\"digest_algorithm\"]]\n                curve = ec._CURVE_TYPES[vector[\"curve\"]]\n\n                _skip_ecdsa_vector(backend, curve, hash_type)\n\n                key = ec.EllipticCurvePublicNumbers(\n                    vector[\"x\"], vector[\"y\"], curve\n                ).public_key(backend)\n\n                signature = encode_dss_signature(vector[\"r\"], vector[\"s\"])\n\n                if vector[\"fail\"] is True:\n                    with pytest.raises(exceptions.InvalidSignature):\n                        key.verify(\n                            signature, vector[\"message\"], ec.ECDSA(hash_type())\n                        )\n                else:\n                    key.verify(\n                        signature, vector[\"message\"], ec.ECDSA(hash_type())\n                    )\n\n    def test_unsupported_deterministic_nonce(self, backend):\n        if backend.ecdsa_deterministic_supported():\n            pytest.skip(\n                f\"ECDSA deterministic signing is supported by this\"\n                f\" backend {backend}\"\n            )\n        with pytest.raises(exceptions.UnsupportedAlgorithm):\n            ec.ECDSA(hashes.SHA256(), deterministic_signing=True)\n\n    def test_deterministic_nonce(self, backend, subtests):\n        if not backend.ecdsa_deterministic_supported():\n            pytest.skip(\n                f\"ECDSA deterministic signing is not supported by this\"\n                f\" backend {backend}\"\n            )\n\n        supported_hash_algorithms = {\n            \"SHA1\": hashes.SHA1(),\n            \"SHA224\": hashes.SHA224(),\n            \"SHA256\": hashes.SHA256(),\n            \"SHA384\": hashes.SHA384(),\n            \"SHA512\": hashes.SHA512(),\n        }\n        curves = {\n            \"B-163\": ec.SECT163R2(),\n            \"B-233\": ec.SECT233R1(),\n            \"B-283\": ec.SECT283R1(),\n            \"B-409\": ec.SECT409R1(),\n            \"B-571\": ec.SECT571R1(),\n            \"K-163\": ec.SECT163K1(),\n            \"K-233\": ec.SECT233K1(),\n            \"K-283\": ec.SECT283K1(),\n            \"K-409\": ec.SECT409K1(),\n            \"K-571\": ec.SECT571K1(),\n            \"P-192\": ec.SECP192R1(),\n            \"P-224\": ec.SECP224R1(),\n            \"P-256\": ec.SECP256R1(),\n            \"P-384\": ec.SECP384R1(),\n            \"P-521\": ec.SECP521R1(),\n        }\n        vectors = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"ECDSA\", \"RFC6979\", \"evppkey_ecdsa_rfc6979.txt\"\n            ),\n            load_rfc6979_vectors,\n        )\n\n        for vector in vectors:\n            with subtests.test():\n                input = bytes(vector[\"input\"], \"utf-8\")\n                output = bytes.fromhex(vector[\"output\"])\n                key = bytes(\"\\n\".join(vector[\"key\"]), \"utf-8\")\n                curve = curves[vector[\"key_name\"].split(\"_\")[0]]\n                _skip_curve_unsupported(backend, curve)\n\n                if \"digest_sign\" in vector:\n                    algorithm = vector[\"digest_sign\"]\n                    hash_algorithm = supported_hash_algorithms[algorithm]\n                    algorithm = ec.ECDSA(\n                        hash_algorithm,\n                        deterministic_signing=vector[\"deterministic_nonce\"],\n                    )\n                    private_key = serialization.load_pem_private_key(\n                        key, password=None\n                    )\n                    assert isinstance(private_key, EllipticCurvePrivateKey)\n                    signature = private_key.sign(input, algorithm)\n                    assert signature == output\n                else:\n                    assert \"digest_verify\" in vector\n                    algorithm = vector[\"digest_verify\"]\n                    assert algorithm in supported_hash_algorithms\n                    hash_algorithm = supported_hash_algorithms[algorithm]\n                    algorithm = ec.ECDSA(hash_algorithm)\n                    public_key = serialization.load_pem_public_key(key)\n                    assert isinstance(public_key, EllipticCurvePublicKey)\n                    if vector[\"verify_error\"]:\n                        with pytest.raises(exceptions.InvalidSignature):\n                            public_key.verify(output, input, algorithm)\n                    else:\n                        public_key.verify(output, input, algorithm)\n\n    def test_sign(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        algorithm = ec.ECDSA(hashes.SHA256())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, algorithm)\n\n    def test_sign_verify_buffers(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = bytearray(b\"one little message\")\n        algorithm = ec.ECDSA(hashes.SHA256())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(bytearray(signature), message, algorithm)\n\n    def test_sign_prehashed(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        data = h.finalize()\n        algorithm = ec.ECDSA(Prehashed(hashes.SHA256()))\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        signature = private_key.sign(data, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, ec.ECDSA(hashes.SHA256()))\n\n    def test_sign_prehashed_digest_mismatch(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA224(), backend)\n        h.update(message)\n        data = h.finalize()\n        algorithm = ec.ECDSA(Prehashed(hashes.SHA256()))\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        with pytest.raises(ValueError):\n            private_key.sign(data, algorithm)\n\n    def test_verify(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        algorithm = ec.ECDSA(hashes.SHA256())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, algorithm)\n\n    def test_verify_prehashed(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        algorithm = ec.ECDSA(hashes.SHA256())\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        signature = private_key.sign(message, algorithm)\n        h = hashes.Hash(hashes.SHA256(), backend)\n        h.update(message)\n        data = h.finalize()\n        public_key = private_key.public_key()\n        public_key.verify(\n            signature, data, ec.ECDSA(Prehashed(hashes.SHA256()))\n        )\n\n    def test_verify_prehashed_digest_mismatch(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        message = b\"one little message\"\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        h = hashes.Hash(hashes.SHA224(), backend)\n        h.update(message)\n        data = h.finalize()\n        public_key = private_key.public_key()\n        with pytest.raises(ValueError):\n            public_key.verify(\n                b\"\\x00\" * 32, data, ec.ECDSA(Prehashed(hashes.SHA256()))\n            )\n\n\nclass TestECEquality:\n    def test_public_numbers_eq(self):\n        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        assert pub == ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n\n    def test_public_numbers_ne(self):\n        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        assert pub != ec.EllipticCurvePublicNumbers(1, 2, ec.SECP384R1())\n        assert pub != ec.EllipticCurvePublicNumbers(1, 3, ec.SECP192R1())\n        assert pub != ec.EllipticCurvePublicNumbers(2, 2, ec.SECP192R1())\n        assert pub != object()\n\n    def test_private_numbers_eq(self):\n        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        priv = ec.EllipticCurvePrivateNumbers(1, pub)\n        assert priv == ec.EllipticCurvePrivateNumbers(\n            1, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        )\n\n    def test_private_numbers_ne(self):\n        pub = ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        priv = ec.EllipticCurvePrivateNumbers(1, pub)\n        assert priv != ec.EllipticCurvePrivateNumbers(\n            2, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP192R1())\n        )\n        assert priv != ec.EllipticCurvePrivateNumbers(\n            1, ec.EllipticCurvePublicNumbers(2, 2, ec.SECP192R1())\n        )\n        assert priv != ec.EllipticCurvePrivateNumbers(\n            1, ec.EllipticCurvePublicNumbers(1, 3, ec.SECP192R1())\n        )\n        assert priv != ec.EllipticCurvePrivateNumbers(\n            1, ec.EllipticCurvePublicNumbers(1, 2, ec.SECP521R1())\n        )\n        assert priv != object()\n\n    def test_public_key_equality(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key2 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key3 = ec.generate_private_key(ec.SECP256R1()).public_key()\n        assert key1 == key2\n        assert key1 != key3\n        assert key1 != object()\n        with pytest.raises(TypeError):\n            key1 < key2  # type: ignore[operator]\n\n    def test_public_key_copy(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key2 = copy.copy(key1)\n\n        assert key1 == key2\n\n\nclass TestECSerialization:\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        itertools.product(\n            [\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.PrivateFormat.PKCS8,\n            ],\n            [\n                b\"s\",\n                b\"longerpassword\",\n                b\"!*$&(@#$*&($T@%_somesymbols\",\n                b\"\\x01\" * 1000,\n            ],\n        ),\n    )\n    def test_private_bytes_encrypted_pem(self, backend, fmt, password):\n        skip_fips_traditional_openssl(backend, fmt)\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        serialized = key.private_bytes(\n            serialization.Encoding.PEM,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_pem_private_key(\n            serialized, password, backend\n        )\n        assert isinstance(loaded_key, ec.EllipticCurvePrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend._fips_enabled,\n        skip_message=\"Requires FIPS\",\n    )\n    def test_traditional_serialization_fips(self, backend):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.BestAvailableEncryption(b\"password\"),\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (serialization.Encoding.Raw, serialization.PrivateFormat.PKCS8),\n            (serialization.Encoding.DER, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.Raw, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.X962, serialization.PrivateFormat.PKCS8),\n        ],\n    )\n    def test_private_bytes_rejects_invalid(self, encoding, fmt, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = ec.generate_private_key(ec.SECP256R1(), backend)\n        with pytest.raises(ValueError):\n            key.private_bytes(encoding, fmt, serialization.NoEncryption())\n\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        [\n            [serialization.PrivateFormat.PKCS8, b\"s\"],\n            [serialization.PrivateFormat.PKCS8, b\"longerpassword\"],\n            [serialization.PrivateFormat.PKCS8, b\"!*$&(@#$*&($T@%_somesymbol\"],\n            [serialization.PrivateFormat.PKCS8, b\"\\x01\" * 1000],\n        ],\n    )\n    def test_private_bytes_encrypted_der(self, backend, fmt, password):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        serialized = key.private_bytes(\n            serialization.Encoding.DER,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_der_private_key(\n            serialized, password, backend\n        )\n        assert isinstance(loaded_key, ec.EllipticCurvePrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"loader_func\"),\n        [\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_der_private_key,\n            ],\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_unencrypted(\n        self, backend, encoding, fmt, loader_func\n    ):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        serialized = key.private_bytes(\n            encoding, fmt, serialization.NoEncryption()\n        )\n        loaded_key = loader_func(serialized, None, backend)\n        assert isinstance(loaded_key, ec.EllipticCurvePrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.skip_fips(\n        reason=\"Traditional OpenSSL key format is not supported in FIPS mode.\"\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader_func\"),\n        [\n            [\n                os.path.join(\n                    \"asymmetric\", \"PEM_Serialization\", \"ec_private_key.pem\"\n                ),\n                serialization.Encoding.PEM,\n                serialization.load_pem_private_key,\n            ],\n            [\n                os.path.join(\n                    \"asymmetric\", \"DER_Serialization\", \"ec_private_key.der\"\n                ),\n                serialization.Encoding.DER,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_traditional_openssl_unencrypted(\n        self, backend, key_path, encoding, loader_func\n    ):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, None, backend)\n        serialized = key.private_bytes(\n            encoding,\n            serialization.PrivateFormat.TraditionalOpenSSL,\n            serialization.NoEncryption(),\n        )\n        assert serialized == key_bytes\n\n    def test_private_bytes_traditional_der_encrypted_invalid(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.BestAvailableEncryption(b\"password\"),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.SMIME,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encoding(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_format(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encryption_algorithm(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                \"notanencalg\",  # type: ignore[arg-type]\n            )\n\n    def test_private_bytes_unsupported_encryption_type(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                DummyKeySerializationEncryption(),\n            )\n\n    def test_public_bytes_from_derived_public_key(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        public = key.public_key()\n        pem = public.public_bytes(\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        parsed_public = serialization.load_pem_public_key(pem, backend)\n        assert parsed_public\n\n    def test_load_private_key_explicit_parameters(self):\n        with pytest.raises(ValueError, match=\"explicit parameters\"):\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"EC\", \"explicit_parameters_private_key.pem\"\n                ),\n                lambda pemfile: serialization.load_pem_private_key(\n                    pemfile.read(), password=None\n                ),\n                mode=\"rb\",\n            )\n\n        with pytest.raises(ValueError, match=\"explicit parameters\"):\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\",\n                    \"EC\",\n                    \"explicit_parameters_wap_wsg_idm_ecid_wtls11_private_key.pem\",\n                ),\n                lambda pemfile: serialization.load_pem_private_key(\n                    pemfile.read(), password=None\n                ),\n                mode=\"rb\",\n            )\n\n    def test_load_private_key_unsupported_curve(self):\n        with pytest.raises((ValueError, exceptions.UnsupportedAlgorithm)):\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"EC\", \"secp128r1_private_key.pem\"),\n                lambda pemfile: serialization.load_pem_private_key(\n                    pemfile.read(), password=None\n                ),\n                mode=\"rb\",\n            )\n\n    @pytest.mark.parametrize(\n        (\"key_file\", \"curve\"),\n        [\n            (\"sect163k1-spki.pem\", ec.SECT163K1),\n            (\"sect163r2-spki.pem\", ec.SECT163R2),\n            (\"sect233k1-spki.pem\", ec.SECT233K1),\n            (\"sect233r1-spki.pem\", ec.SECT233R1),\n        ],\n    )\n    def test_load_public_keys(self, key_file, curve, backend):\n        _skip_curve_unsupported(backend, curve())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"EC\", key_file),\n            lambda pemfile: serialization.load_pem_public_key(\n                pemfile.read(),\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n        assert isinstance(key.curve, curve)\n\n\nclass TestEllipticCurvePEMPublicKeySerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"encoding\"),\n        [\n            (\n                os.path.join(\n                    \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n                ),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n            ),\n            (\n                os.path.join(\n                    \"asymmetric\", \"DER_Serialization\", \"ec_public_key.der\"\n                ),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, key_path, loader_func, encoding, backend\n    ):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, backend)\n        serialized = key.public_bytes(\n            encoding,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        assert serialized == key_bytes\n\n    def test_public_bytes_openssh(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP192R1())\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        key_bytes = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n            ),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = serialization.load_pem_public_key(key_bytes, backend)\n\n        ssh_bytes = key.public_bytes(\n            serialization.Encoding.OpenSSH, serialization.PublicFormat.OpenSSH\n        )\n        assert ssh_bytes == (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBBCS8827s9rUZyxZTi/um01+oIlWrwLHOjQxRU9CDAndom00zVAw5BRrI\"\n            b\"KtHB+SWD4P+sVJTARSq1mHt8kOIWrPc=\"\n        )\n\n        key = ec.generate_private_key(ec.SECP192R1(), backend).public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.OpenSSH,\n                serialization.PublicFormat.OpenSSH,\n            )\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n            ),\n            lambda pemfile: serialization.load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        list(\n            itertools.product(\n                [\n                    serialization.Encoding.Raw,\n                    serialization.Encoding.X962,\n                    serialization.Encoding.PEM,\n                    serialization.Encoding.DER,\n                ],\n                [serialization.PublicFormat.Raw],\n            )\n        )\n        + list(\n            itertools.product(\n                [serialization.Encoding.Raw],\n                [\n                    serialization.PublicFormat.SubjectPublicKeyInfo,\n                    serialization.PublicFormat.PKCS1,\n                    serialization.PublicFormat.UncompressedPoint,\n                    serialization.PublicFormat.CompressedPoint,\n                ],\n            )\n        ),\n    )\n    def test_public_bytes_rejects_invalid(self, encoding, fmt, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = ec.generate_private_key(ec.SECP256R1(), backend).public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(encoding, fmt)\n\n    def test_public_bytes_invalid_format(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n            ),\n            lambda pemfile: serialization.load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n            )\n\n    def test_public_bytes_pkcs1_unsupported(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n            ),\n            lambda pemfile: serialization.load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"EC\", \"compressed_points.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_from_encoded_point_compressed(self, vector, backend):\n        curve = {b\"SECP256R1\": ec.SECP256R1(), b\"SECP256K1\": ec.SECP256K1()}[\n            vector[\"curve\"]\n        ]\n        _skip_curve_unsupported(backend, curve)\n        point = binascii.unhexlify(vector[\"point\"])\n        pn = ec.EllipticCurvePublicKey.from_encoded_point(curve, point)\n        public_num = pn.public_numbers()\n        assert public_num.x == int(vector[\"x\"], 16)\n        assert public_num.y == int(vector[\"y\"], 16)\n\n    def test_from_encoded_point_notoncurve(self):\n        uncompressed_point = binascii.unhexlify(\n            \"047399336a9edf2197c2f8eb3d39aed9c34a66e45d918a07dc7684c42c9b37ac\"\n            \"686699ececc4f5f0d756d3c450708a0694eb0a07a68b805070b40b058d27271f\"\n            \"6e\"\n        )\n        with pytest.raises(ValueError):\n            ec.EllipticCurvePublicKey.from_encoded_point(\n                ec.SECP256R1(), uncompressed_point\n            )\n\n    def test_from_encoded_point_uncompressed(self):\n        uncompressed_point = binascii.unhexlify(\n            \"047399336a9edf2197c2f8eb3d39aed9c34a66e45d918a07dc7684c42c9b37ac\"\n            \"686699ececc4f5f0d756d3c450708a0694eb0a07a68b805070b40b058d27271f\"\n            \"6d\"\n        )\n        pn = ec.EllipticCurvePublicKey.from_encoded_point(\n            ec.SECP256R1(), uncompressed_point\n        )\n        assert pn.public_numbers().x == int(\n            \"7399336a9edf2197c2f8eb3d39aed9c34a66e45d918a07dc7684c42c9b37ac68\",\n            16,\n        )\n        assert pn.public_numbers().y == int(\n            \"6699ececc4f5f0d756d3c450708a0694eb0a07a68b805070b40b058d27271f6d\",\n            16,\n        )\n\n    def test_from_encoded_point_invalid_length(self):\n        bad_data = binascii.unhexlify(\n            \"047399336a9edf2197c2f8eb3d39aed9c34a66e45d918a07dc7684c42c9b37ac\"\n            \"686699ececc4f5f0d756d3c450708a0694eb0a07a68b805070b40b058d27271f\"\n            \"6d\"\n        )\n        with pytest.raises(ValueError):\n            ec.EllipticCurvePublicKey.from_encoded_point(\n                ec.SECP384R1(), bad_data\n            )\n\n    def test_from_encoded_point_empty_byte_string(self):\n        with pytest.raises(ValueError):\n            ec.EllipticCurvePublicKey.from_encoded_point(ec.SECP384R1(), b\"\")\n\n    def test_from_encoded_point_not_a_curve(self):\n        with pytest.raises(TypeError):\n            ec.EllipticCurvePublicKey.from_encoded_point(\n                \"notacurve\",  # type: ignore[arg-type]\n                b\"\\x04data\",\n            )\n\n    def test_from_encoded_point_unsupported_encoding(self):\n        unsupported_type = binascii.unhexlify(\n            \"057399336a9edf2197c2f8eb3d39aed9c34a66e45d918a07dc7684c42c9b37ac6\"\n            \"8\"\n        )\n        with pytest.raises(ValueError):\n            ec.EllipticCurvePublicKey.from_encoded_point(\n                ec.SECP256R1(), unsupported_type\n            )\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"EC\", \"compressed_points.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_serialize_point(self, vector, backend):\n        curve = {b\"SECP256R1\": ec.SECP256R1(), b\"SECP256K1\": ec.SECP256K1()}[\n            vector[\"curve\"]\n        ]\n        _skip_curve_unsupported(backend, curve)\n        point = binascii.unhexlify(vector[\"point\"])\n        key = ec.EllipticCurvePublicKey.from_encoded_point(curve, point)\n        key2 = ec.EllipticCurvePublicKey.from_encoded_point(\n            curve,\n            key.public_bytes(\n                serialization.Encoding.X962,\n                serialization.PublicFormat.UncompressedPoint,\n            ),\n        )\n        assert (\n            key.public_bytes(\n                serialization.Encoding.X962,\n                serialization.PublicFormat.CompressedPoint,\n            )\n            == point\n        )\n        assert (\n            key2.public_bytes(\n                serialization.Encoding.X962,\n                serialization.PublicFormat.CompressedPoint,\n            )\n            == point\n        )\n\n\nclass TestECDH:\n    def test_key_exchange_with_vectors(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\",\n                \"ECDH\",\n                \"KASValidityTest_ECCStaticUnified_NOKC_ZZOnly_init.fax\",\n            ),\n            load_kasvs_ecdh_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                _skip_exchange_algorithm_unsupported(\n                    backend, ec.ECDH(), ec._CURVE_TYPES[vector[\"curve\"]]\n                )\n\n                key_numbers = vector[\"IUT\"]\n                private_numbers = ec.EllipticCurvePrivateNumbers(\n                    key_numbers[\"d\"],\n                    ec.EllipticCurvePublicNumbers(\n                        key_numbers[\"x\"],\n                        key_numbers[\"y\"],\n                        ec._CURVE_TYPES[vector[\"curve\"]],\n                    ),\n                )\n                # Errno 5-7 indicates a bad public or private key, this\n                # doesn't test the ECDH code at all\n                if vector[\"fail\"] and vector[\"errno\"] in [5, 6, 7]:\n                    with pytest.raises(ValueError):\n                        private_numbers.private_key(backend)\n                    continue\n                else:\n                    private_key = private_numbers.private_key(backend)\n\n                peer_numbers = vector[\"CAVS\"]\n                public_numbers = ec.EllipticCurvePublicNumbers(\n                    peer_numbers[\"x\"],\n                    peer_numbers[\"y\"],\n                    ec._CURVE_TYPES[vector[\"curve\"]],\n                )\n                # Errno 1 and 2 indicates a bad public key, this doesn't test\n                # the ECDH code at all\n                if vector[\"fail\"] and vector[\"errno\"] in [1, 2]:\n                    with pytest.raises(ValueError):\n                        public_numbers.public_key(backend)\n                    continue\n                else:\n                    peer_pubkey = public_numbers.public_key(backend)\n\n                z = private_key.exchange(ec.ECDH(), peer_pubkey)\n                zz = int(hexlify(z).decode(\"ascii\"), 16)\n                # At this point fail indicates that one of the underlying keys\n                # was changed. This results in a non-matching derived key.\n                if vector[\"fail\"]:\n                    # Errno 8 indicates Z should be changed.\n                    assert vector[\"errno\"] == 8\n                    assert zz != vector[\"Z\"]\n                else:\n                    assert zz == vector[\"Z\"]\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"ECDH\", \"brainpool.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_brainpool_kex(self, backend, vector):\n        curve = ec._CURVE_TYPES[vector[\"curve\"].decode(\"ascii\")]\n        _skip_exchange_algorithm_unsupported(backend, ec.ECDH(), curve)\n        key = ec.EllipticCurvePrivateNumbers(\n            int(vector[\"da\"], 16),\n            ec.EllipticCurvePublicNumbers(\n                int(vector[\"x_qa\"], 16), int(vector[\"y_qa\"], 16), curve\n            ),\n        ).private_key(backend)\n        peer = ec.EllipticCurvePrivateNumbers(\n            int(vector[\"db\"], 16),\n            ec.EllipticCurvePublicNumbers(\n                int(vector[\"x_qb\"], 16), int(vector[\"y_qb\"], 16), curve\n            ),\n        ).private_key(backend)\n        shared_secret = key.exchange(ec.ECDH(), peer.public_key())\n        assert shared_secret == binascii.unhexlify(vector[\"x_z\"])\n        shared_secret_2 = peer.exchange(ec.ECDH(), key.public_key())\n        assert shared_secret_2 == binascii.unhexlify(vector[\"x_z\"])\n\n    def test_exchange_unsupported_algorithm(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n\n        with raises_unsupported_algorithm(\n            exceptions._Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM\n        ):\n            key.exchange(None, key.public_key())  # type: ignore[arg-type]\n\n    def test_exchange_non_matching_curve(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"ec_private_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        public_key = EC_KEY_SECP384R1.public_numbers.public_key(backend)\n\n        with pytest.raises(ValueError):\n            key.exchange(ec.ECDH(), public_key)\n", "tests/hazmat/primitives/test_concatkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.concatkdf import (\n    ConcatKDFHash,\n    ConcatKDFHMAC,\n)\n\n\nclass TestConcatKDFHash:\n    def test_length_limit(self, backend):\n        big_length = hashes.SHA256().digest_size * (2**32 - 1) + 1\n\n        with pytest.raises(ValueError):\n            ConcatKDFHash(hashes.SHA256(), big_length, None, backend)\n\n    def test_already_finalized(self, backend):\n        ckdf = ConcatKDFHash(hashes.SHA256(), 16, None, backend)\n\n        ckdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            ckdf.derive(b\"\\x02\" * 16)\n\n    def test_derive(self, backend):\n        prk = binascii.unhexlify(\n            b\"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23\"\n        )\n\n        okm = binascii.unhexlify(b\"1c3bc9e7c4547c5191c0d478cccaed55\")\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2\"\n            b\"46f72971f292badaa2fe4124612cba\"\n        )\n\n        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)\n\n        assert ckdf.derive(prk) == okm\n\n    def test_buffer_protocol(self, backend):\n        prk = binascii.unhexlify(\n            b\"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23\"\n        )\n\n        okm = binascii.unhexlify(b\"1c3bc9e7c4547c5191c0d478cccaed55\")\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2\"\n            b\"46f72971f292badaa2fe4124612cba\"\n        )\n\n        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)\n\n        assert ckdf.derive(bytearray(prk)) == okm\n\n    def test_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23\"\n        )\n\n        okm = binascii.unhexlify(b\"1c3bc9e7c4547c5191c0d478cccaed55\")\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2\"\n            b\"46f72971f292badaa2fe4124612cba\"\n        )\n\n        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)\n\n        ckdf.verify(prk, okm)\n\n    def test_invalid_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"52169af5c485dcc2321eb8d26d5efa21fb9b93c98e38412ee2484cf14f0d0d23\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e53728157e634612c12d6d5223e204aeea4341565369647bd184bcd2\"\n            b\"46f72971f292badaa2fe4124612cba\"\n        )\n\n        ckdf = ConcatKDFHash(hashes.SHA256(), 16, oinfo, backend)\n\n        with pytest.raises(InvalidKey):\n            ckdf.verify(prk, b\"wrong key\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            ConcatKDFHash(\n                hashes.SHA256(),\n                16,\n                otherinfo=\"foo\",  # type: ignore[arg-type]\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHash(\n                hashes.SHA256(), 16, otherinfo=None, backend=backend\n            )\n\n            ckdf.derive(\"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHash(\n                hashes.SHA256(), 16, otherinfo=None, backend=backend\n            )\n\n            ckdf.verify(\"foo\", b\"bar\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHash(\n                hashes.SHA256(), 16, otherinfo=None, backend=backend\n            )\n\n            ckdf.verify(b\"foo\", \"bar\")  # type: ignore[arg-type]\n\n\nclass TestConcatKDFHMAC:\n    def test_length_limit(self, backend):\n        big_length = hashes.SHA256().digest_size * (2**32 - 1) + 1\n\n        with pytest.raises(ValueError):\n            ConcatKDFHMAC(hashes.SHA256(), big_length, None, None, backend)\n\n    def test_already_finalized(self, backend):\n        ckdf = ConcatKDFHMAC(hashes.SHA256(), 16, None, None, backend)\n\n        ckdf.derive(b\"\\x01\" * 16)\n\n        with pytest.raises(AlreadyFinalized):\n            ckdf.derive(b\"\\x02\" * 16)\n\n    def test_derive(self, backend):\n        prk = binascii.unhexlify(\n            b\"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4\"\n            b\"b831cde499dff1ce45f6179f741c728aa733583b02409208\"\n            b\"8f0af7fce1d045edbc5790931e8d5ca79c73\"\n        )\n\n        okm = binascii.unhexlify(\n            b\"64ce901db10d558661f10b6836a122a7\"\n            b\"605323ce2f39bf27eaaac8b34cf89f2f\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c\"\n            b\"9fbd216d12b49160b2ae5157650f43415653696421e68e\"\n        )\n\n        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)\n\n        assert ckdf.derive(prk) == okm\n\n    def test_buffer_protocol(self, backend):\n        prk = binascii.unhexlify(\n            b\"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4\"\n            b\"b831cde499dff1ce45f6179f741c728aa733583b02409208\"\n            b\"8f0af7fce1d045edbc5790931e8d5ca79c73\"\n        )\n\n        okm = binascii.unhexlify(\n            b\"64ce901db10d558661f10b6836a122a7\"\n            b\"605323ce2f39bf27eaaac8b34cf89f2f\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c\"\n            b\"9fbd216d12b49160b2ae5157650f43415653696421e68e\"\n        )\n\n        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)\n\n        assert ckdf.derive(bytearray(prk)) == okm\n\n    def test_derive_explicit_salt(self, backend):\n        prk = binascii.unhexlify(\n            b\"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4\"\n            b\"b831cde499dff1ce45f6179f741c728aa733583b02409208\"\n            b\"8f0af7fce1d045edbc5790931e8d5ca79c73\"\n        )\n\n        okm = binascii.unhexlify(\n            b\"64ce901db10d558661f10b6836a122a7\"\n            b\"605323ce2f39bf27eaaac8b34cf89f2f\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c\"\n            b\"9fbd216d12b49160b2ae5157650f43415653696421e68e\"\n        )\n\n        ckdf = ConcatKDFHMAC(\n            hashes.SHA512(), 32, b\"\\x00\" * 128, oinfo, backend\n        )\n\n        assert ckdf.derive(prk) == okm\n\n    def test_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4\"\n            b\"b831cde499dff1ce45f6179f741c728aa733583b02409208\"\n            b\"8f0af7fce1d045edbc5790931e8d5ca79c73\"\n        )\n\n        okm = binascii.unhexlify(\n            b\"64ce901db10d558661f10b6836a122a7\"\n            b\"605323ce2f39bf27eaaac8b34cf89f2f\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c\"\n            b\"9fbd216d12b49160b2ae5157650f43415653696421e68e\"\n        )\n\n        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)\n\n        ckdf.verify(prk, okm)\n\n    def test_invalid_verify(self, backend):\n        prk = binascii.unhexlify(\n            b\"013951627c1dea63ea2d7702dd24e963eef5faac6b4af7e4\"\n            b\"b831cde499dff1ce45f6179f741c728aa733583b02409208\"\n            b\"8f0af7fce1d045edbc5790931e8d5ca79c73\"\n        )\n\n        oinfo = binascii.unhexlify(\n            b\"a1b2c3d4e55e600be5f367e0e8a465f4bf2704db00c9325c\"\n            b\"9fbd216d12b49160b2ae5157650f43415653696421e68e\"\n        )\n\n        ckdf = ConcatKDFHMAC(hashes.SHA512(), 32, None, oinfo, backend)\n\n        with pytest.raises(InvalidKey):\n            ckdf.verify(prk, b\"wrong key\")\n\n    def test_unicode_typeerror(self, backend):\n        with pytest.raises(TypeError):\n            ConcatKDFHMAC(\n                hashes.SHA256(),\n                16,\n                salt=\"foo\",  # type: ignore[arg-type]\n                otherinfo=None,\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            ConcatKDFHMAC(\n                hashes.SHA256(),\n                16,\n                salt=None,\n                otherinfo=\"foo\",  # type: ignore[arg-type]\n                backend=backend,\n            )\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHMAC(\n                hashes.SHA256(), 16, salt=None, otherinfo=None, backend=backend\n            )\n\n            ckdf.derive(\"foo\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHMAC(\n                hashes.SHA256(), 16, salt=None, otherinfo=None, backend=backend\n            )\n\n            ckdf.verify(\"foo\", b\"bar\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            ckdf = ConcatKDFHMAC(\n                hashes.SHA256(), 16, salt=None, otherinfo=None, backend=backend\n            )\n\n            ckdf.verify(b\"foo\", \"bar\")  # type: ignore[arg-type]\n\n    def test_unsupported_hash_algorithm(self, backend):\n        # ConcatKDF requires a hash algorithm with an internal block size.\n        with pytest.raises(TypeError):\n            ConcatKDFHMAC(\n                hashes.SHA3_256(),\n                16,\n                salt=None,\n                otherinfo=None,\n                backend=backend,\n            )\n", "tests/hazmat/primitives/test_poly1305.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidSignature,\n    _Reasons,\n)\nfrom cryptography.hazmat.primitives.poly1305 import Poly1305\n\nfrom ...utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.poly1305_supported(),\n    skip_message=\"Requires OpenSSL without poly1305 support\",\n)\ndef test_poly1305_unsupported(backend):\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_MAC):\n        Poly1305(b\"0\" * 32)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.poly1305_supported(),\n    skip_message=\"Requires OpenSSL with poly1305 support\",\n)\nclass TestPoly1305:\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"poly1305\", \"rfc7539.txt\"), load_nist_vectors\n        ),\n    )\n    def test_vectors(self, vector, backend):\n        key = binascii.unhexlify(vector[\"key\"])\n        msg = binascii.unhexlify(vector[\"msg\"])\n        tag = binascii.unhexlify(vector[\"tag\"])\n        poly = Poly1305(key)\n        poly.update(msg)\n        assert poly.finalize() == tag\n\n        assert Poly1305.generate_tag(key, msg) == tag\n        Poly1305.verify_tag(key, msg, tag)\n\n    def test_key_with_no_additional_references(self, backend):\n        poly = Poly1305(os.urandom(32))\n        assert len(poly.finalize()) == 16\n\n    def test_raises_after_finalize(self, backend):\n        poly = Poly1305(b\"0\" * 32)\n        poly.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            poly.update(b\"foo\")\n\n        with pytest.raises(AlreadyFinalized):\n            poly.finalize()\n\n    def test_reject_unicode(self, backend):\n        poly = Poly1305(b\"0\" * 32)\n        with pytest.raises(TypeError):\n            poly.update(\"\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            Poly1305.generate_tag(b\"0\" * 32, \"\")  # type:ignore[arg-type]\n\n    def test_verify(self, backend):\n        poly = Poly1305(b\"0\" * 32)\n        poly.update(b\"msg\")\n        tag = poly.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            poly.verify(b\"\")\n\n        poly2 = Poly1305(b\"0\" * 32)\n        poly2.update(b\"msg\")\n        poly2.verify(tag)\n\n        Poly1305.verify_tag(b\"0\" * 32, b\"msg\", tag)\n\n    def test_invalid_verify(self, backend):\n        poly = Poly1305(b\"0\" * 32)\n        poly.update(b\"msg\")\n        with pytest.raises(InvalidSignature):\n            poly.verify(b\"\")\n\n        p2 = Poly1305(b\"0\" * 32)\n        p2.update(b\"msg\")\n        with pytest.raises(InvalidSignature):\n            p2.verify(b\"\\x00\" * 16)\n\n        with pytest.raises(InvalidSignature):\n            Poly1305.verify_tag(b\"0\" * 32, b\"msg\", b\"\\x00\" * 16)\n\n    def test_verify_reject_unicode(self, backend):\n        poly = Poly1305(b\"0\" * 32)\n        with pytest.raises(TypeError):\n            poly.verify(\"\")  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            Poly1305.verify_tag(b\"0\" * 32, b\"msg\", \"\")  # type:ignore[arg-type]\n\n    def test_invalid_key_type(self, backend):\n        with pytest.raises(TypeError):\n            Poly1305(object())  # type:ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            Poly1305.generate_tag(object(), b\"msg\")  # type:ignore[arg-type]\n\n    def test_invalid_key_length(self, backend):\n        with pytest.raises(ValueError):\n            Poly1305(b\"0\" * 31)\n\n        with pytest.raises(ValueError):\n            Poly1305.generate_tag(b\"0\" * 31, b\"msg\")\n\n        with pytest.raises(ValueError):\n            Poly1305(b\"0\" * 33)\n\n        with pytest.raises(ValueError):\n            Poly1305.generate_tag(b\"0\" * 33, b\"msg\")\n\n    def test_buffer_protocol(self, backend):\n        key = binascii.unhexlify(\n            b\"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cb\"\n            b\"c207075c0\"\n        )\n        msg = binascii.unhexlify(\n            b\"2754776173206272696c6c69672c20616e642074686520736c69746\"\n            b\"87920746f7665730a446964206779726520616e642067696d626c65\"\n            b\"20696e2074686520776162653a0a416c6c206d696d7379207765726\"\n            b\"52074686520626f726f676f7665732c0a416e6420746865206d6f6d\"\n            b\"65207261746873206f757467726162652e\"\n        )\n        key = bytearray(key)\n        poly = Poly1305(key)\n        poly.update(bytearray(msg))\n        assert poly.finalize() == binascii.unhexlify(\n            b\"4541669a7eaaee61e708dc7cbcc5eb62\"\n        )\n\n        assert Poly1305.generate_tag(key, msg) == binascii.unhexlify(\n            b\"4541669a7eaaee61e708dc7cbcc5eb62\"\n        )\n", "tests/hazmat/primitives/test_padding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized\nfrom cryptography.hazmat.primitives import padding\n\n\nclass TestPKCS7:\n    @pytest.mark.parametrize(\"size\", [127, 4096, -2])\n    def test_invalid_block_size(self, size):\n        with pytest.raises(ValueError):\n            padding.PKCS7(size)\n\n    @pytest.mark.parametrize(\n        (\"size\", \"padded\"),\n        [\n            (128, b\"1111\"),\n            (128, b\"1111111111111111\"),\n            (128, b\"111111111111111\\x06\"),\n            (128, b\"\"),\n            (128, b\"\\x06\" * 6),\n            (128, b\"\\x00\" * 16),\n        ],\n    )\n    def test_invalid_padding(self, size, padded):\n        unpadder = padding.PKCS7(size).unpadder()\n        with pytest.raises(ValueError):\n            unpadder.update(padded)\n            unpadder.finalize()\n\n    def test_non_bytes(self):\n        padder = padding.PKCS7(128).padder()\n        with pytest.raises(TypeError):\n            padder.update(\"abc\")  # type: ignore[arg-type]\n        unpadder = padding.PKCS7(128).unpadder()\n        with pytest.raises(TypeError):\n            unpadder.update(\"abc\")  # type: ignore[arg-type]\n\n    def test_zany_py2_bytes_subclass(self):\n        class mybytes(bytes):  # noqa: N801\n            def __str__(self):\n                return \"broken\"\n\n        str(mybytes())\n        padder = padding.PKCS7(128).padder()\n        data = padder.update(mybytes(b\"abc\")) + padder.finalize()\n        unpadder = padding.PKCS7(128).unpadder()\n        unpadder.update(mybytes(data))\n        assert unpadder.finalize() == b\"abc\"\n\n    @pytest.mark.parametrize(\n        (\"size\", \"unpadded\", \"padded\"),\n        [\n            (128, b\"1111111111\", b\"1111111111\\x06\\x06\\x06\\x06\\x06\\x06\"),\n            (\n                128,\n                b\"111111111111111122222222222222\",\n                b\"111111111111111122222222222222\\x02\\x02\",\n            ),\n            (128, b\"1\" * 16, b\"1\" * 16 + b\"\\x10\" * 16),\n            (128, b\"1\" * 17, b\"1\" * 17 + b\"\\x0f\" * 15),\n        ],\n    )\n    def test_pad(self, size, unpadded, padded):\n        padder = padding.PKCS7(size).padder()\n        result = padder.update(unpadded)\n        result += padder.finalize()\n        assert result == padded\n\n    @pytest.mark.parametrize(\n        (\"size\", \"unpadded\", \"padded\"),\n        [\n            (128, b\"1111111111\", b\"1111111111\\x06\\x06\\x06\\x06\\x06\\x06\"),\n            (\n                128,\n                b\"111111111111111122222222222222\",\n                b\"111111111111111122222222222222\\x02\\x02\",\n            ),\n        ],\n    )\n    def test_unpad(self, size, unpadded, padded):\n        unpadder = padding.PKCS7(size).unpadder()\n        result = unpadder.update(padded)\n        result += unpadder.finalize()\n        assert result == unpadded\n\n    def test_use_after_finalize(self):\n        padder = padding.PKCS7(128).padder()\n        b = padder.finalize()\n        with pytest.raises(AlreadyFinalized):\n            padder.update(b\"\")\n        with pytest.raises(AlreadyFinalized):\n            padder.finalize()\n\n        unpadder = padding.PKCS7(128).unpadder()\n        unpadder.update(b)\n        unpadder.finalize()\n        with pytest.raises(AlreadyFinalized):\n            unpadder.update(b\"\")\n        with pytest.raises(AlreadyFinalized):\n            unpadder.finalize()\n\n    def test_large_padding(self):\n        padder = padding.PKCS7(2040).padder()\n        padded_data = padder.update(b\"\")\n        padded_data += padder.finalize()\n\n        for i in padded_data:\n            assert i == 255\n\n        unpadder = padding.PKCS7(2040).unpadder()\n        data = unpadder.update(padded_data)\n        data += unpadder.finalize()\n\n        assert data == b\"\"\n\n    def test_bytearray(self):\n        padder = padding.PKCS7(128).padder()\n        unpadded = bytearray(b\"t\" * 38)\n        padded = (\n            padder.update(unpadded)\n            + padder.update(unpadded)\n            + padder.finalize()\n        )\n        unpadder = padding.PKCS7(128).unpadder()\n        final = unpadder.update(padded) + unpadder.finalize()\n        assert final == unpadded + unpadded\n\n\nclass TestANSIX923:\n    @pytest.mark.parametrize(\"size\", [127, 4096, -2])\n    def test_invalid_block_size(self, size):\n        with pytest.raises(ValueError):\n            padding.ANSIX923(size)\n\n    @pytest.mark.parametrize(\n        (\"size\", \"padded\"),\n        [\n            (128, b\"1111\"),\n            (128, b\"1111111111111111\"),\n            (128, b\"111111111111111\\x06\"),\n            (128, b\"1111111111\\x06\\x06\\x06\\x06\\x06\\x06\"),\n            (128, b\"\"),\n            (128, b\"\\x06\" * 6),\n            (128, b\"\\x00\" * 16),\n        ],\n    )\n    def test_invalid_padding(self, size, padded):\n        unpadder = padding.ANSIX923(size).unpadder()\n        with pytest.raises(ValueError):\n            unpadder.update(padded)\n            unpadder.finalize()\n\n    def test_non_bytes(self):\n        padder = padding.ANSIX923(128).padder()\n        with pytest.raises(TypeError):\n            padder.update(\"abc\")  # type: ignore[arg-type]\n        unpadder = padding.ANSIX923(128).unpadder()\n        with pytest.raises(TypeError):\n            unpadder.update(\"abc\")  # type: ignore[arg-type]\n\n    def test_zany_py2_bytes_subclass(self):\n        class mybytes(bytes):  # noqa: N801\n            def __str__(self):\n                return \"broken\"\n\n        str(mybytes())\n        padder = padding.ANSIX923(128).padder()\n        padder.update(mybytes(b\"abc\"))\n        unpadder = padding.ANSIX923(128).unpadder()\n        unpadder.update(mybytes(padder.finalize()))\n        assert unpadder.finalize() == b\"abc\"\n\n    @pytest.mark.parametrize(\n        (\"size\", \"unpadded\", \"padded\"),\n        [\n            (128, b\"1111111111\", b\"1111111111\\x00\\x00\\x00\\x00\\x00\\x06\"),\n            (\n                128,\n                b\"111111111111111122222222222222\",\n                b\"111111111111111122222222222222\\x00\\x02\",\n            ),\n            (128, b\"1\" * 16, b\"1\" * 16 + b\"\\x00\" * 15 + b\"\\x10\"),\n            (128, b\"1\" * 17, b\"1\" * 17 + b\"\\x00\" * 14 + b\"\\x0f\"),\n        ],\n    )\n    def test_pad(self, size, unpadded, padded):\n        padder = padding.ANSIX923(size).padder()\n        result = padder.update(unpadded)\n        result += padder.finalize()\n        assert result == padded\n\n    @pytest.mark.parametrize(\n        (\"size\", \"unpadded\", \"padded\"),\n        [\n            (128, b\"1111111111\", b\"1111111111\\x00\\x00\\x00\\x00\\x00\\x06\"),\n            (\n                128,\n                b\"111111111111111122222222222222\",\n                b\"111111111111111122222222222222\\x00\\x02\",\n            ),\n        ],\n    )\n    def test_unpad(self, size, unpadded, padded):\n        unpadder = padding.ANSIX923(size).unpadder()\n        result = unpadder.update(padded)\n        result += unpadder.finalize()\n        assert result == unpadded\n\n    def test_use_after_finalize(self):\n        padder = padding.ANSIX923(128).padder()\n        b = padder.finalize()\n        with pytest.raises(AlreadyFinalized):\n            padder.update(b\"\")\n        with pytest.raises(AlreadyFinalized):\n            padder.finalize()\n\n        unpadder = padding.ANSIX923(128).unpadder()\n        unpadder.update(b)\n        unpadder.finalize()\n        with pytest.raises(AlreadyFinalized):\n            unpadder.update(b\"\")\n        with pytest.raises(AlreadyFinalized):\n            unpadder.finalize()\n\n    def test_bytearray(self):\n        padder = padding.ANSIX923(128).padder()\n        unpadded = bytearray(b\"t\" * 38)\n        padded = (\n            padder.update(unpadded)\n            + padder.update(unpadded)\n            + padder.finalize()\n        )\n        unpadder = padding.ANSIX923(128).unpadder()\n        final = unpadder.update(padded) + unpadder.finalize()\n        assert final == unpadded + unpadded\n", "tests/hazmat/primitives/test_hkdf_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\n\nfrom ...utils import load_nist_vectors\nfrom .utils import generate_hkdf_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA1.\",\n)\nclass TestHKDFSHA1:\n    test_hkdfsha1 = generate_hkdf_test(\n        load_nist_vectors,\n        os.path.join(\"KDF\"),\n        [\"rfc-5869-HKDF-SHA1.txt\"],\n        hashes.SHA1(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),\n    skip_message=\"Does not support SHA256.\",\n)\nclass TestHKDFSHA256:\n    test_hkdfsha256 = generate_hkdf_test(\n        load_nist_vectors,\n        os.path.join(\"KDF\"),\n        [\"rfc-5869-HKDF-SHA256.txt\"],\n        hashes.SHA256(),\n    )\n", "tests/hazmat/primitives/test_x448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.x448 import (\n    X448PrivateKey,\n    X448PublicKey,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.x448_supported(),\n    skip_message=\"Requires OpenSSL without X448 support\",\n)\ndef test_x448_unsupported(backend):\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X448PublicKey.from_public_bytes(b\"0\" * 56)\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X448PrivateKey.from_private_bytes(b\"0\" * 56)\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X448PrivateKey.generate()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x448_supported(),\n    skip_message=\"Requires OpenSSL with X448 support\",\n)\nclass TestX448Exchange:\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X448\", \"rfc7748.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_rfc7748(self, vector, backend):\n        private = binascii.unhexlify(vector[\"input_scalar\"])\n        public = binascii.unhexlify(vector[\"input_u\"])\n        shared_key = binascii.unhexlify(vector[\"output_u\"])\n        private_key = X448PrivateKey.from_private_bytes(private)\n        public_key = X448PublicKey.from_public_bytes(public)\n        computed_shared_key = private_key.exchange(public_key)\n        assert computed_shared_key == shared_key\n\n    def test_rfc7748_1000_iteration(self, backend):\n        old_private = private = public = binascii.unhexlify(\n            b\"05000000000000000000000000000000000000000000000000000000\"\n            b\"00000000000000000000000000000000000000000000000000000000\"\n        )\n        shared_key = binascii.unhexlify(\n            b\"aa3b4749d55b9daf1e5b00288826c467274ce3ebbdd5c17b975e09d4\"\n            b\"af6c67cf10d087202db88286e2b79fceea3ec353ef54faa26e219f38\"\n        )\n        private_key = X448PrivateKey.from_private_bytes(private)\n        public_key = X448PublicKey.from_public_bytes(public)\n        for _ in range(1000):\n            computed_shared_key = private_key.exchange(public_key)\n            private_key = X448PrivateKey.from_private_bytes(\n                computed_shared_key\n            )\n            public_key = X448PublicKey.from_public_bytes(old_private)\n            old_private = computed_shared_key\n\n        assert computed_shared_key == shared_key\n\n    # These vectors are also from RFC 7748\n    # https://tools.ietf.org/html/rfc7748#section-6.2\n    @pytest.mark.parametrize(\n        (\"private_bytes\", \"public_bytes\"),\n        [\n            (\n                binascii.unhexlify(\n                    b\"9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d\"\n                    b\"d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726b\"\n                ),\n                binascii.unhexlify(\n                    b\"9b08f7cc31b7e3e67d22d5aea121074a273bd2b83de09c63faa73d2c\"\n                    b\"22c5d9bbc836647241d953d40c5b12da88120d53177f80e532c41fa0\"\n                ),\n            ),\n            (\n                binascii.unhexlify(\n                    b\"1c306a7ac2a0e2e0990b294470cba339e6453772b075811d8fad0d1d\"\n                    b\"6927c120bb5ee8972b0d3e21374c9c921b09d1b0366f10b65173992d\"\n                ),\n                binascii.unhexlify(\n                    b\"3eb7a829b0cd20f5bcfc0b599b6feccf6da4627107bdb0d4f345b430\"\n                    b\"27d8b972fc3e34fb4232a13ca706dcb57aec3dae07bdc1c67bf33609\"\n                ),\n            ),\n        ],\n    )\n    def test_pub_priv_bytes_raw(self, private_bytes, public_bytes, backend):\n        private_key = X448PrivateKey.from_private_bytes(private_bytes)\n        assert (\n            private_key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n        assert private_key.private_bytes_raw() == private_bytes\n        assert (\n            private_key.public_key().public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == public_bytes\n        )\n        assert private_key.public_key().public_bytes_raw() == public_bytes\n        public_key = X448PublicKey.from_public_bytes(public_bytes)\n        assert (\n            public_key.public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == public_bytes\n        )\n        assert public_key.public_bytes_raw() == public_bytes\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"encryption\", \"passwd\", \"load_func\"),\n        [\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_der_private_key,\n            ),\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_der_private_key,\n            ),\n        ],\n    )\n    def test_round_trip_private_serialization(\n        self, encoding, fmt, encryption, passwd, load_func, backend\n    ):\n        key = X448PrivateKey.generate()\n        serialized = key.private_bytes(encoding, fmt, encryption)\n        loaded_key = load_func(serialized, passwd, backend)\n        assert isinstance(loaded_key, X448PrivateKey)\n\n    def test_generate(self, backend):\n        key = X448PrivateKey.generate()\n        assert key\n        assert key.public_key()\n\n    def test_invalid_type_exchange(self, backend):\n        key = X448PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.exchange(object())  # type: ignore[arg-type]\n\n    def test_invalid_length_from_public_bytes(self, backend):\n        with pytest.raises(ValueError):\n            X448PublicKey.from_public_bytes(b\"a\" * 55)\n\n        with pytest.raises(ValueError):\n            X448PublicKey.from_public_bytes(b\"a\" * 57)\n\n    def test_invalid_length_from_private_bytes(self, backend):\n        with pytest.raises(ValueError):\n            X448PrivateKey.from_private_bytes(b\"a\" * 55)\n\n        with pytest.raises(ValueError):\n            X448PrivateKey.from_private_bytes(b\"a\" * 57)\n\n    def test_invalid_private_bytes(self, backend):\n        key = X448PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                None,  # type: ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.PKCS8,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n\n    def test_invalid_public_bytes(self, backend):\n        key = X448PrivateKey.generate().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.Raw\n            )\n\n    def test_buffer_protocol(self, backend):\n        private_bytes = binascii.unhexlify(\n            b\"9a8f4925d1519f5775cf46b04b5800d4ee9ee8bae8bc5565d498c28d\"\n            b\"d9c9baf574a9419744897391006382a6f127ab1d9ac2d8c0a598726b\"\n        )\n        key = X448PrivateKey.from_private_bytes(bytearray(private_bytes))\n        assert (\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x448_supported(),\n    skip_message=\"Requires OpenSSL with X448 support\",\n)\ndef test_public_key_equality(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key3 = X448PrivateKey.generate().public_key()\n    assert key1 == key2\n    assert key1 != key3\n    assert key1 != object()\n    with pytest.raises(TypeError):\n        key1 < key2  # type: ignore[operator]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x448_supported(),\n    skip_message=\"Requires OpenSSL with X448 support\",\n)\ndef test_public_key_copy(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = copy.copy(key1)\n\n    assert key1 == key2\n", "tests/hazmat/primitives/test_x963_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.x963kdf import X963KDF\n\nfrom ...doubles import DummyHashAlgorithm\nfrom ...utils import load_vectors_from_file, load_x963_vectors\n\n\ndef _skip_hashfn_unsupported(backend, hashfn):\n    if not backend.hash_supported(hashfn):\n        pytest.skip(\n            f\"Hash {hashfn.name} is not supported by this backend {backend}\"\n        )\n\n\nclass TestX963:\n    _algorithms_dict: typing.ClassVar[\n        typing.Dict[str, typing.Type[hashes.HashAlgorithm]]\n    ] = {\n        \"SHA-1\": hashes.SHA1,\n        \"SHA-224\": hashes.SHA224,\n        \"SHA-256\": hashes.SHA256,\n        \"SHA-384\": hashes.SHA384,\n        \"SHA-512\": hashes.SHA512,\n    }\n\n    def test_x963(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"KDF\", \"ansx963_2001.txt\"), load_x963_vectors\n        )\n        for vector in vectors:\n            with subtests.test():\n                hashfn = self._algorithms_dict[vector[\"hash\"]]\n                _skip_hashfn_unsupported(backend, hashfn())\n\n                key = binascii.unhexlify(vector[\"Z\"])\n                sharedinfo = None\n                if vector[\"sharedinfo_length\"] != 0:\n                    sharedinfo = binascii.unhexlify(vector[\"sharedinfo\"])\n                key_data_len = vector[\"key_data_length\"] // 8\n                key_data = binascii.unhexlify(vector[\"key_data\"])\n\n                xkdf = X963KDF(\n                    algorithm=hashfn(),\n                    length=key_data_len,\n                    sharedinfo=sharedinfo,\n                    backend=backend,\n                )\n                xkdf.verify(key, key_data)\n\n    def test_unsupported_hash(self, backend):\n        with pytest.raises(pytest.skip.Exception):\n            _skip_hashfn_unsupported(backend, DummyHashAlgorithm())\n", "tests/hazmat/primitives/test_x25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.x25519 import (\n    X25519PrivateKey,\n    X25519PublicKey,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL without X25519 support\",\n)\ndef test_x25519_unsupported(backend):\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X25519PublicKey.from_public_bytes(b\"0\" * 32)\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X25519PrivateKey.from_private_bytes(b\"0\" * 32)\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM):\n        X25519PrivateKey.generate()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL with X25519 support\",\n)\nclass TestX25519Exchange:\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X25519\", \"rfc7748.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_rfc7748(self, vector, backend):\n        private = binascii.unhexlify(vector[\"input_scalar\"])\n        public = binascii.unhexlify(vector[\"input_u\"])\n        shared_key = binascii.unhexlify(vector[\"output_u\"])\n        private_key = X25519PrivateKey.from_private_bytes(private)\n        public_key = X25519PublicKey.from_public_bytes(public)\n        computed_shared_key = private_key.exchange(public_key)\n        assert computed_shared_key == shared_key\n\n    def test_rfc7748_1000_iteration(self, backend):\n        old_private = private = public = binascii.unhexlify(\n            b\"090000000000000000000000000000000000000000000000000000000000\"\n            b\"0000\"\n        )\n        shared_key = binascii.unhexlify(\n            b\"684cf59ba83309552800ef566f2f4d3c1c3887c49360e3875f2eb94d9953\"\n            b\"2c51\"\n        )\n        private_key = X25519PrivateKey.from_private_bytes(private)\n        public_key = X25519PublicKey.from_public_bytes(public)\n        for _ in range(1000):\n            computed_shared_key = private_key.exchange(public_key)\n            private_key = X25519PrivateKey.from_private_bytes(\n                computed_shared_key\n            )\n            public_key = X25519PublicKey.from_public_bytes(old_private)\n            old_private = computed_shared_key\n\n        assert computed_shared_key == shared_key\n\n    def test_null_shared_key_raises_error(self, backend):\n        \"\"\"\n        The vector used here is taken from wycheproof's x25519 test vectors\n        \"\"\"\n        public = binascii.unhexlify(\n            \"5f9c95bca3508c24b1d0b1559c83ef5b04445cc4581c8e86d8224eddd09f1157\"\n        )\n        private = binascii.unhexlify(\n            \"78f1e8edf14481b389448dac8f59c70b038e7cf92ef2c7eff57a72466e115296\"\n        )\n        private_key = X25519PrivateKey.from_private_bytes(private)\n        public_key = X25519PublicKey.from_public_bytes(public)\n        with pytest.raises(ValueError):\n            private_key.exchange(public_key)\n\n    def test_public_bytes_bad_args(self, backend):\n        key = X25519PrivateKey.generate().public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                None,  # type: ignore[arg-type]\n                serialization.PublicFormat.Raw,\n            )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.DER, serialization.PublicFormat.Raw\n            )\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                serialization.Encoding.DER,\n                None,  # type: ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.SMIME,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n    # These vectors are also from RFC 7748\n    # https://tools.ietf.org/html/rfc7748#section-6.1\n    @pytest.mark.parametrize(\n        (\"private_bytes\", \"public_bytes\"),\n        [\n            (\n                binascii.unhexlify(\n                    b\"77076d0a7318a57d3c16c17251b26645df4c2f87ebc0992ab177fba\"\n                    b\"51db92c2a\"\n                ),\n                binascii.unhexlify(\n                    b\"8520f0098930a754748b7ddcb43ef75a0dbf3a0d26381af4eba4a98\"\n                    b\"eaa9b4e6a\"\n                ),\n            ),\n            (\n                binascii.unhexlify(\n                    b\"5dab087e624a8a4b79e17f8b83800ee66f3bb1292618b6fd1c2f8b2\"\n                    b\"7ff88e0eb\"\n                ),\n                binascii.unhexlify(\n                    b\"de9edb7d7b7dc1b4d35b61c2ece435373f8343c85b78674dadfc7e1\"\n                    b\"46f882b4f\"\n                ),\n            ),\n        ],\n    )\n    def test_pub_priv_bytes_raw(self, private_bytes, public_bytes, backend):\n        private_key = X25519PrivateKey.from_private_bytes(private_bytes)\n        assert (\n            private_key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n        assert private_key.private_bytes_raw() == private_bytes\n        assert (\n            private_key.public_key().public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == public_bytes\n        )\n        assert private_key.public_key().public_bytes_raw() == public_bytes\n        public_key = X25519PublicKey.from_public_bytes(public_bytes)\n        assert (\n            public_key.public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == public_bytes\n        )\n        assert public_key.public_bytes_raw() == public_bytes\n\n    def test_generate(self, backend):\n        key = X25519PrivateKey.generate()\n        assert key\n        assert key.public_key()\n\n    def test_invalid_type_exchange(self, backend):\n        key = X25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.exchange(object())  # type: ignore[arg-type]\n\n    def test_invalid_length_from_public_bytes(self, backend):\n        with pytest.raises(ValueError):\n            X25519PublicKey.from_public_bytes(b\"a\" * 31)\n\n        with pytest.raises(ValueError):\n            X25519PublicKey.from_public_bytes(b\"a\" * 33)\n\n    def test_invalid_length_from_private_bytes(self, backend):\n        with pytest.raises(ValueError):\n            X25519PrivateKey.from_private_bytes(b\"a\" * 31)\n\n        with pytest.raises(ValueError):\n            X25519PrivateKey.from_private_bytes(b\"a\" * 33)\n\n    def test_invalid_private_bytes(self, backend):\n        key = X25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                None,  # type: ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.PKCS8,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n\n        with pytest.raises(TypeError):\n            key.private_bytes(None, None, None)  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                None,  # type: ignore[arg-type]\n                None,  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                object(),  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"a\" * 1024),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.SMIME,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.NoEncryption(),\n            )\n\n    def test_invalid_public_bytes(self, backend):\n        key = X25519PrivateKey.generate().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.Raw\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"encryption\", \"passwd\", \"load_func\"),\n        [\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_der_private_key,\n            ),\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_der_private_key,\n            ),\n        ],\n    )\n    def test_round_trip_private_serialization(\n        self, encoding, fmt, encryption, passwd, load_func, backend\n    ):\n        key = X25519PrivateKey.generate()\n        serialized = key.private_bytes(encoding, fmt, encryption)\n        loaded_key = load_func(serialized, passwd, backend)\n        assert isinstance(loaded_key, X25519PrivateKey)\n\n    def test_buffer_protocol(self, backend):\n        private_bytes = bytearray(os.urandom(32))\n        key = X25519PrivateKey.from_private_bytes(private_bytes)\n        assert (\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL with X25519 support\",\n)\ndef test_public_key_equality(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key3 = X25519PrivateKey.generate().public_key()\n    assert key1 == key2\n    assert key1 != key3\n    assert key1 != object()\n    with pytest.raises(TypeError):\n        key1 < key2  # type: ignore[operator]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL with X25519 support\",\n)\ndef test_public_key_copy(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = copy.copy(key1)\n\n    assert key1 == key2\n", "tests/hazmat/primitives/test_ed448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature, _Reasons\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.ed448 import (\n    Ed448PrivateKey,\n    Ed448PublicKey,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL without Ed448 support\",\n)\ndef test_ed448_unsupported(backend):\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed448PublicKey.from_public_bytes(b\"0\" * 57)\n\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed448PrivateKey.from_private_bytes(b\"0\" * 57)\n\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed448PrivateKey.generate()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\nclass TestEd448Signing:\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"rfc8032.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_sign_input(self, vector, backend):\n        if vector.get(\"context\") is not None:\n            pytest.skip(\"ed448 contexts are not currently supported\")\n\n        sk = binascii.unhexlify(vector[\"secret\"])\n        pk = binascii.unhexlify(vector[\"public\"])\n        message = binascii.unhexlify(vector[\"message\"])\n        signature = binascii.unhexlify(vector[\"signature\"])\n        private_key = Ed448PrivateKey.from_private_bytes(sk)\n        computed_sig = private_key.sign(message)\n        assert computed_sig == signature\n        public_key = private_key.public_key()\n        assert (\n            public_key.public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == pk\n        )\n        public_key.verify(signature, message)\n\n    def test_invalid_signature(self, backend):\n        key = Ed448PrivateKey.generate()\n        signature = key.sign(b\"test data\")\n        with pytest.raises(InvalidSignature):\n            key.public_key().verify(signature, b\"wrong data\")\n\n        with pytest.raises(InvalidSignature):\n            key.public_key().verify(b\"0\" * 64, b\"test data\")\n\n    def test_sign_verify_buffer(self, backend):\n        key = Ed448PrivateKey.generate()\n        data = bytearray(b\"test data\")\n        signature = key.sign(data)\n        key.public_key().verify(bytearray(signature), data)\n\n    def test_generate(self, backend):\n        key = Ed448PrivateKey.generate()\n        assert key\n        assert key.public_key()\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"rfc8032.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_pub_priv_bytes_raw(self, vector, backend):\n        sk = binascii.unhexlify(vector[\"secret\"])\n        pk = binascii.unhexlify(vector[\"public\"])\n        private_key = Ed448PrivateKey.from_private_bytes(sk)\n        assert (\n            private_key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == sk\n        )\n        assert private_key.private_bytes_raw() == sk\n        assert (\n            private_key.public_key().public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == pk\n        )\n        assert private_key.public_key().public_bytes_raw() == pk\n        public_key = Ed448PublicKey.from_public_bytes(pk)\n        assert (\n            public_key.public_bytes(\n                serialization.Encoding.Raw, serialization.PublicFormat.Raw\n            )\n            == pk\n        )\n        assert public_key.public_bytes_raw() == pk\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"encryption\", \"passwd\", \"load_func\"),\n        [\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_der_private_key,\n            ),\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_der_private_key,\n            ),\n        ],\n    )\n    def test_round_trip_private_serialization(\n        self, encoding, fmt, encryption, passwd, load_func, backend\n    ):\n        key = Ed448PrivateKey.generate()\n        serialized = key.private_bytes(encoding, fmt, encryption)\n        loaded_key = load_func(serialized, passwd, backend)\n        assert isinstance(loaded_key, Ed448PrivateKey)\n\n    def test_invalid_type_public_bytes(self, backend):\n        with pytest.raises(TypeError):\n            Ed448PublicKey.from_public_bytes(\n                object()  # type: ignore[arg-type]\n            )\n\n    def test_invalid_type_private_bytes(self, backend):\n        with pytest.raises(TypeError):\n            Ed448PrivateKey.from_private_bytes(\n                object()  # type: ignore[arg-type]\n            )\n\n    def test_invalid_length_from_public_bytes(self, backend):\n        with pytest.raises(ValueError):\n            Ed448PublicKey.from_public_bytes(b\"a\" * 56)\n        with pytest.raises(ValueError):\n            Ed448PublicKey.from_public_bytes(b\"a\" * 58)\n\n    def test_invalid_length_from_private_bytes(self, backend):\n        with pytest.raises(ValueError):\n            Ed448PrivateKey.from_private_bytes(b\"a\" * 56)\n        with pytest.raises(ValueError):\n            Ed448PrivateKey.from_private_bytes(b\"a\" * 58)\n\n    def test_invalid_private_bytes(self, backend):\n        key = Ed448PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                None,  # type: ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.PKCS8,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n\n    def test_invalid_public_bytes(self, backend):\n        key = Ed448PrivateKey.generate().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.Raw\n            )\n\n    def test_buffer_protocol(self, backend):\n        private_bytes = os.urandom(57)\n        key = Ed448PrivateKey.from_private_bytes(bytearray(private_bytes))\n        assert (\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n\n    def test_malleability(self, backend):\n        # This is a signature where r > the group order. It should be\n        # rejected to prevent signature malleability issues. This test can\n        # be removed when wycheproof grows ed448 vectors\n        public_bytes = binascii.unhexlify(\n            \"fedb02a658d74990244d9d10cf338e977565cbbda6b24c716829ed6ee1e4f28cf\"\n            \"2620c052db8d878f6243bffc22242816c1aaa67d2f3603600\"\n        )\n        signature = binascii.unhexlify(\n            \"0cc16ba24d69277f927c1554b0f08a2a711bbdd20b058ccc660d00ca13542a3ce\"\n            \"f9e5c44c54ab23a2eb14f947e167b990b080863e28b399380f30db6e54d5d1406\"\n            \"d23378ffde11b1fb81b2b438a3b8e8aa7f7f4e1befcc905023fab5a5465053844\"\n            \"f04cf0c1b51d84760f869588687f57500\"\n        )\n        key = Ed448PublicKey.from_public_bytes(public_bytes)\n        with pytest.raises(InvalidSignature):\n            key.verify(signature, b\"8\")\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\ndef test_public_key_equality(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key3 = Ed448PrivateKey.generate().public_key()\n    assert key1 == key2\n    assert key1 != key3\n    assert key1 != object()\n\n    with pytest.raises(TypeError):\n        key1 < key2  # type: ignore[operator]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\ndef test_public_key_copy(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = copy.copy(key1)\n\n    assert key1 == key2\n", "tests/hazmat/primitives/test_cmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidSignature,\n    _Reasons,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import ARC4, TripleDES\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n)\nfrom cryptography.hazmat.primitives.cmac import CMAC\n\nfrom ...doubles import DummyBlockCipherAlgorithm\nfrom ...utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\nvectors_aes128 = load_vectors_from_file(\n    \"CMAC/nist-800-38b-aes128.txt\", load_nist_vectors\n)\n\nvectors_aes192 = load_vectors_from_file(\n    \"CMAC/nist-800-38b-aes192.txt\", load_nist_vectors\n)\n\nvectors_aes256 = load_vectors_from_file(\n    \"CMAC/nist-800-38b-aes256.txt\", load_nist_vectors\n)\n\nvectors_aes = vectors_aes128 + vectors_aes192 + vectors_aes256\n\nvectors_3des = load_vectors_from_file(\n    \"CMAC/nist-800-38b-3des.txt\", load_nist_vectors\n)\n\nfake_key = b\"\\x00\" * 16\n\n\nclass TestCMAC:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    @pytest.mark.parametrize(\"params\", vectors_aes)\n    def test_aes_generate(self, backend, params):\n        key = params[\"key\"]\n        message = params[\"message\"]\n        output = params[\"output\"]\n\n        cmac = CMAC(AES(binascii.unhexlify(key)), backend)\n        cmac.update(binascii.unhexlify(message))\n        assert binascii.hexlify(cmac.finalize()) == output\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    @pytest.mark.parametrize(\"params\", vectors_aes)\n    def test_aes_verify(self, backend, params):\n        key = params[\"key\"]\n        message = params[\"message\"]\n        output = params[\"output\"]\n\n        cmac = CMAC(AES(binascii.unhexlify(key)), backend)\n        cmac.update(binascii.unhexlify(message))\n        cmac.verify(binascii.unhexlify(output))\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            TripleDES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    @pytest.mark.parametrize(\"params\", vectors_3des)\n    def test_3des_generate(self, backend, params):\n        key1 = params[\"key1\"]\n        key2 = params[\"key2\"]\n        key3 = params[\"key3\"]\n\n        key = key1 + key2 + key3\n\n        message = params[\"message\"]\n        output = params[\"output\"]\n\n        cmac = CMAC(TripleDES(binascii.unhexlify(key)), backend)\n        cmac.update(binascii.unhexlify(message))\n        assert binascii.hexlify(cmac.finalize()) == output\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            TripleDES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    @pytest.mark.parametrize(\"params\", vectors_3des)\n    def test_3des_verify(self, backend, params):\n        key1 = params[\"key1\"]\n        key2 = params[\"key2\"]\n        key3 = params[\"key3\"]\n\n        key = key1 + key2 + key3\n\n        message = params[\"message\"]\n        output = params[\"output\"]\n\n        cmac = CMAC(TripleDES(binascii.unhexlify(key)), backend)\n        cmac.update(binascii.unhexlify(message))\n        cmac.verify(binascii.unhexlify(output))\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_invalid_verify(self, backend):\n        key = b\"2b7e151628aed2a6abf7158809cf4f3c\"\n        cmac = CMAC(AES(key), backend)\n        cmac.update(b\"6bc1bee22e409f96e93d7e117393172a\")\n\n        with pytest.raises(InvalidSignature):\n            cmac.verify(b\"foobar\")\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(ARC4(fake_key), None),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_invalid_algorithm(self, backend):\n        key = b\"0102030405\"\n        with pytest.raises(TypeError):\n            CMAC(ARC4(key), backend)  # type: ignore[arg-type]\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n            CMAC(DummyBlockCipherAlgorithm(b\"bad\"), backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_raises_after_finalize(self, backend):\n        key = b\"2b7e151628aed2a6abf7158809cf4f3c\"\n        cmac = CMAC(AES(key), backend)\n        cmac.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            cmac.update(b\"foo\")\n\n        with pytest.raises(AlreadyFinalized):\n            cmac.copy()\n\n        with pytest.raises(AlreadyFinalized):\n            cmac.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            cmac.verify(b\"\")\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_verify_reject_unicode(self, backend):\n        key = b\"2b7e151628aed2a6abf7158809cf4f3c\"\n        cmac = CMAC(AES(key), backend)\n\n        with pytest.raises(TypeError):\n            cmac.update(\"\")  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            cmac.verify(\"\")  # type: ignore[arg-type]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_copy_with_backend(self, backend):\n        key = b\"2b7e151628aed2a6abf7158809cf4f3c\"\n        cmac = CMAC(AES(key), backend)\n        cmac.update(b\"6bc1bee22e409f96e93d7e117393172a\")\n        copy_cmac = cmac.copy()\n        assert cmac.finalize() == copy_cmac.finalize()\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cmac_algorithm_supported(\n            AES(fake_key)\n        ),\n        skip_message=\"Does not support CMAC.\",\n    )\n    def test_buffer_protocol(self, backend):\n        key = bytearray(b\"2b7e151628aed2a6abf7158809cf4f3c\")\n        cmac = CMAC(AES(key), backend)\n        cmac.update(b\"6bc1bee22e409f96e93d7e117393172a\")\n        assert cmac.finalize() == binascii.unhexlify(\n            b\"a21e6e647bfeaf5ca0a5e1bcd957dfad\"\n        )\n", "tests/hazmat/primitives/test_pbkdf2hmac_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC\n\nfrom ...utils import load_nist_vectors, load_vectors_from_file\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pbkdf2_hmac_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA1 for PBKDF2HMAC\",\n)\ndef test_pbkdf2_hmacsha1_vectors(subtests, backend):\n    params = load_vectors_from_file(\n        os.path.join(\"KDF\", \"rfc-6070-PBKDF2-SHA1.txt\"),\n        load_nist_vectors,\n    )\n    for param in params:\n        with subtests.test():\n            iterations = int(param[\"iterations\"])\n            if iterations > 1_000_000:\n                pytest.skip(\"Skipping test due to iteration count\")\n            kdf = PBKDF2HMAC(\n                hashes.SHA1(),\n                int(param[\"length\"]),\n                param[\"salt\"],\n                iterations,\n            )\n            derived_key = kdf.derive(param[\"password\"])\n            assert binascii.hexlify(derived_key) == param[\"derived_key\"]\n", "tests/hazmat/primitives/fixtures_ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nfrom cryptography.hazmat.primitives.asymmetric import ec\n\nEC_KEY_SECT571R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"213997069697108634621868251335076179190383272087548888968788698953\"\n        \"131928375431570122753130054966269038244076049869476736547896549201\"\n        \"7388482714521707824160638375437887802901\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT571R1(),\n        x=int(\n            \"42585672410900520895287019432267514156432686681290164230262278\"\n            \"54789182447139054594501570747809649335533486119017169439209005\"\n            \"883737780433424425566023654583165324498640038089\"\n        ),\n        y=int(\n            \"13822523320209387572500458104799806851658024537477228250738334\"\n            \"46977851514777531296572763848253279034733550774927720436494321\"\n            \"97281333379623823457479233585424800362717541750\"\n        ),\n    ),\n)\n\nEC_KEY_SECT409R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"604993237916498765317587097853603474519114726157206838874832379003\"\n        \"281871982139714656205843929472002062791572217653118715727\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT409R1(),\n        x=int(\n            \"76237701339268928039087238870073679814646664010783544301589269\"\n            \"2272579213400205907766385199643053767195204247826349822350081\"\n        ),\n        y=int(\n            \"10056668929618383045204866060110626563392345494925302478351744\"\n            \"01475129090774493235522729123877384838835703483224447476728811\"\n        ),\n    ),\n)\n\nEC_KEY_SECT283R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"589705077255658434962118789801402573495547207239917043241273753671\"\n        \"0603230261342427657\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT283R1(),\n        x=int(\n            \"10694213430317013187241490088760888472172922291550831393222973\"\n            \"531614941756901942108493\"\n        ),\n        y=int(\n            \"11461553100313943515373601367527399649593366728262918214942116\"\n            \"4359557613202950705170\"\n        ),\n    ),\n)\n\nEC_KEY_SECT233R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"343470067105388144757135261232658742142830154753739648095101899829\"\n        \"8288\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT233R1(),\n        x=int(\n            \"74494951569151557692195071465128140646140765188698294062550374\"\n            \"71118267\"\n        ),\n        y=int(\n            \"48699150823022962508544923825876164485917001162461401797511748\"\n            \"44872205\"\n        ),\n    ),\n)\n\nEC_KEY_SECT163R2 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\"11788436193853888218177032687141056784083668635\"),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT163R2(),\n        x=int(\"5247234453330640212490501030772203801908103222463\"),\n        y=int(\"3172513801099088785224248292142866317754124455206\"),\n    ),\n)\n\nEC_KEY_SECT571K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"592811051234886966121888758661314648311634839499582476726008738218\"\n        \"165015048237934517672316204181933804884636855291118594744334592153\"\n        \"883208936227914544246799490897169723387\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT571K1(),\n        x=int(\n            \"81362471461936552203898455874182916939857774872643607884250052\"\n            \"29301336524105230729653881789373412990921493551253481866317181\"\n            \"50644729351721577822595637058949405764944491655\"\n        ),\n        y=int(\n            \"14058041260812945396067821061063618047896814719828637241661260\"\n            \"31235681542401975593036630733881695595289523801041910183736211\"\n            \"587294494888450327374439795428519848065589000434\"\n        ),\n    ),\n)\n\nEC_KEY_SECT409K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"110321743150399087059465162400463719641470113494908091197354523708\"\n        \"934106732952992153105338671368548199643686444619485307877\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT409K1(),\n        x=int(\n            \"62280214209410363493525178797944995742119600145953755916426161\"\n            \"0790364158569265348038207313261547476506319796469776797725796\"\n        ),\n        y=int(\n            \"46653883749102474289095010108777579907422472804577185369332018\"\n            \"7318642669590280811057512951467298158275464566214288556375885\"\n        ),\n    ),\n)\n\nEC_KEY_SECT283K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"182508394415444014156574733141549331538128234395356466108310015130\"\n        \"3868915489347291850\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT283K1(),\n        x=int(\n            \"31141647206111886426350703123670451554123180910379592764773885\"\n            \"2959123367428352287032\"\n        ),\n        y=int(\n            \"71787460144483665964585187837283963089964760704065205376175384\"\n            \"58957627834444017112582\"\n        ),\n    ),\n)\n\nEC_KEY_SECT233K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"172670089647474613734091436081960550801254775902629891892394471086\"\n        \"2070\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT233K1(),\n        x=int(\n            \"55693911474339510991521579392202889561373678973929426354737048\"\n            \"68129172\"\n        ),\n        y=int(\n            \"11025856248546376145959939911850923631416718241836051344384802\"\n            \"737277815\"\n        ),\n    ),\n)\n\nEC_KEY_SECT163K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\"3699303791425402204035307605170569820290317991287\"),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECT163K1(),\n        x=int(\"4479755902310063321544063130576409926980094120721\"),\n        y=int(\"3051218481937171839039826690648109285113977745779\"),\n    ),\n)\n\nEC_KEY_SECP521R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"662751235215460886290293902658128847495347691199214706697089140769\"\n        \"672273950767961331442265530524063943548846724348048614239791498442\"\n        \"5997823106818915698960565\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP521R1(),\n        x=int(\n            \"12944742826257420846659527752683763193401384271391513286022917\"\n            \"29910013082920512632908350502247952686156279140016049549948975\"\n            \"670668730618745449113644014505462\"\n        ),\n        y=int(\n            \"10784108810271976186737587749436295782985563640368689081052886\"\n            \"16296815984553198866894145509329328086635278430266482551941240\"\n            \"591605833440825557820439734509311\"\n        ),\n    ),\n)\n\nEC_KEY_SECP384R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"280814107134858470598753916394807521398239633534281633982576099083\"\n        \"35787109896602102090002196616273211495718603965098\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP384R1(),\n        x=int(\n            \"10036914308591746758780165503819213553101287571902957054148542\"\n            \"504671046744460374996612408381962208627004841444205030\"\n        ),\n        y=int(\n            \"17337335659928075994560513699823544906448896792102247714689323\"\n            \"575406618073069185107088229463828921069465902299522926\"\n        ),\n    ),\n)\n\nEC_KEY_SECP256R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"271032978511595617649844168316234344656921218699414461240502635010\"\n        \"25776962849\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP256R1(),\n        x=int(\n            \"49325986169170464532722748935508337546545346352733747948730305\"\n            \"442770101441241\"\n        ),\n        y=int(\n            \"51709162888529903487188595007092772817469799707382623884187518\"\n            \"455962250433661\"\n        ),\n    ),\n)\n\nEC_KEY_SECP256K1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"683341569008473593765879222774207677458810362976327530563215318048\"\n        \"64380736732\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP256K1(),\n        x=int(\n            \"59251322975795306609293064274738085741081547489119277536110995\"\n            \"120127593127884\"\n        ),\n        y=int(\n            \"10334192001480392039227801832201340147605940717841294644187071\"\n            \"8261641142297801\"\n        ),\n    ),\n)\n\nEC_KEY_SECP224R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"234854340492774342642505519082413233282383066880756900834047566251\"\n        \"50\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP224R1(),\n        x=int(\n            \"51165676638271204691095081341581621487998422645261573824239666\"\n            \"1214\"\n        ),\n        y=int(\n            \"14936601450555711309158397172719963843891926209168533453717969\"\n            \"1265\"\n        ),\n    ),\n)\n\nEC_KEY_SECP192R1 = ec.EllipticCurvePrivateNumbers(\n    private_value=int(\n        \"4534766128536179420071447168915990251715442361606049349869\"\n    ),\n    public_numbers=ec.EllipticCurvePublicNumbers(\n        curve=ec.SECP192R1(),\n        x=int(\"5415069751170397888083674339683360671310515485781457536999\"),\n        y=int(\"18671605334415960797751252911958331304288357195986572776\"),\n    ),\n)\n", "tests/hazmat/primitives/test_ed25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import InvalidSignature, _Reasons\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric.ed25519 import (\n    Ed25519PrivateKey,\n    Ed25519PublicKey,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import load_vectors_from_file, raises_unsupported_algorithm\n\n\ndef load_ed25519_vectors(vector_data):\n    \"\"\"\n    djb's ed25519 vectors are structured as a colon delimited array:\n        0: secret key (32 bytes) + public key (32 bytes)\n        1: public key (32 bytes)\n        2: message (0+ bytes)\n        3: signature + message (64+ bytes)\n    \"\"\"\n    data = []\n    for line in vector_data:\n        secret_key, public_key, message, signature, _ = line.split(\":\")\n        secret_key = secret_key[0:64]\n        signature = signature[0:128]\n        data.append(\n            {\n                \"secret_key\": secret_key,\n                \"public_key\": public_key,\n                \"message\": message,\n                \"signature\": signature,\n            }\n        )\n    return data\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL without Ed25519 support\",\n)\ndef test_ed25519_unsupported(backend):\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed25519PublicKey.from_public_bytes(b\"0\" * 32)\n\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed25519PrivateKey.from_private_bytes(b\"0\" * 32)\n\n    with raises_unsupported_algorithm(\n        _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM\n    ):\n        Ed25519PrivateKey.generate()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\nclass TestEd25519Signing:\n    def test_sign_verify_input(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"sign.input\"),\n            load_ed25519_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                sk = binascii.unhexlify(vector[\"secret_key\"])\n                pk = binascii.unhexlify(vector[\"public_key\"])\n                message = binascii.unhexlify(vector[\"message\"])\n                signature = binascii.unhexlify(vector[\"signature\"])\n                private_key = Ed25519PrivateKey.from_private_bytes(sk)\n                computed_sig = private_key.sign(message)\n                assert computed_sig == signature\n                public_key = private_key.public_key()\n                assert (\n                    public_key.public_bytes(\n                        serialization.Encoding.Raw,\n                        serialization.PublicFormat.Raw,\n                    )\n                    == pk\n                )\n                public_key.verify(signature, message)\n\n    def test_pub_priv_bytes_raw(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"sign.input\"),\n            load_ed25519_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                sk = binascii.unhexlify(vector[\"secret_key\"])\n                pk = binascii.unhexlify(vector[\"public_key\"])\n                private_key = Ed25519PrivateKey.from_private_bytes(sk)\n                assert private_key.private_bytes_raw() == sk\n                public_key = Ed25519PublicKey.from_public_bytes(pk)\n                assert public_key.public_bytes_raw() == pk\n\n    def test_invalid_signature(self, backend):\n        key = Ed25519PrivateKey.generate()\n        signature = key.sign(b\"test data\")\n        with pytest.raises(InvalidSignature):\n            key.public_key().verify(signature, b\"wrong data\")\n\n        with pytest.raises(InvalidSignature):\n            key.public_key().verify(b\"0\" * 64, b\"test data\")\n\n    def test_sign_verify_buffer(self, backend):\n        key = Ed25519PrivateKey.generate()\n        data = bytearray(b\"test data\")\n        signature = key.sign(data)\n        key.public_key().verify(bytearray(signature), data)\n\n    def test_generate(self, backend):\n        key = Ed25519PrivateKey.generate()\n        assert key\n        assert key.public_key()\n\n    def test_load_public_bytes(self, backend):\n        public_key = Ed25519PrivateKey.generate().public_key()\n        public_bytes = public_key.public_bytes(\n            serialization.Encoding.Raw, serialization.PublicFormat.Raw\n        )\n        public_key2 = Ed25519PublicKey.from_public_bytes(public_bytes)\n        assert public_bytes == public_key2.public_bytes(\n            serialization.Encoding.Raw, serialization.PublicFormat.Raw\n        )\n\n    def test_invalid_type_public_bytes(self, backend):\n        with pytest.raises(TypeError):\n            Ed25519PublicKey.from_public_bytes(\n                object()  # type: ignore[arg-type]\n            )\n\n    def test_invalid_type_private_bytes(self, backend):\n        with pytest.raises(TypeError):\n            Ed25519PrivateKey.from_private_bytes(\n                object()  # type: ignore[arg-type]\n            )\n\n    def test_invalid_length_from_public_bytes(self, backend):\n        with pytest.raises(ValueError):\n            Ed25519PublicKey.from_public_bytes(b\"a\" * 31)\n        with pytest.raises(ValueError):\n            Ed25519PublicKey.from_public_bytes(b\"a\" * 33)\n\n    def test_invalid_length_from_private_bytes(self, backend):\n        with pytest.raises(ValueError):\n            Ed25519PrivateKey.from_private_bytes(b\"a\" * 31)\n        with pytest.raises(ValueError):\n            Ed25519PrivateKey.from_private_bytes(b\"a\" * 33)\n\n    def test_invalid_private_bytes(self, backend):\n        key = Ed25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                None,  # type: ignore[arg-type]\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.PKCS8,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.OpenSSH,\n                serialization.NoEncryption(),\n            )\n\n    def test_invalid_public_bytes(self, backend):\n        key = Ed25519PrivateKey.generate().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.Raw\n            )\n\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.DER, serialization.PublicFormat.OpenSSH\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"encryption\", \"passwd\", \"load_func\"),\n        [\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"password\"),\n                b\"password\",\n                serialization.load_der_private_key,\n            ),\n            (\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_pem_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n                None,\n                serialization.load_der_private_key,\n            ),\n            (\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(b\"\\x00\"),\n                b\"\\x00\",\n                serialization.load_der_private_key,\n            ),\n        ],\n    )\n    def test_round_trip_private_serialization(\n        self, encoding, fmt, encryption, passwd, load_func, backend\n    ):\n        key = Ed25519PrivateKey.generate()\n        serialized = key.private_bytes(encoding, fmt, encryption)\n        loaded_key = load_func(serialized, passwd, backend)\n        assert isinstance(loaded_key, Ed25519PrivateKey)\n\n    def test_buffer_protocol(self, backend):\n        private_bytes = os.urandom(32)\n        key = Ed25519PrivateKey.from_private_bytes(bytearray(private_bytes))\n        assert (\n            key.private_bytes(\n                serialization.Encoding.Raw,\n                serialization.PrivateFormat.Raw,\n                serialization.NoEncryption(),\n            )\n            == private_bytes\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\ndef test_public_key_equality(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key3 = Ed25519PrivateKey.generate().public_key()\n    assert key1 == key2\n    assert key1 != key3\n    assert key1 != object()\n\n    with pytest.raises(TypeError):\n        key1 < key2  # type: ignore[operator]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\ndef test_public_key_copy(backend):\n    key_bytes = load_vectors_from_file(\n        os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8.der\"),\n        lambda derfile: derfile.read(),\n        mode=\"rb\",\n    )\n    key1 = serialization.load_der_private_key(key_bytes, None).public_key()\n    key2 = copy.copy(key1)\n\n    assert key1 == key2\n", "tests/hazmat/primitives/test_dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport copy\nimport itertools\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import dh\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import load_nist_vectors, load_vectors_from_file\nfrom .fixtures_dh import FFDH3072_P\n\n# RFC 3526\nP_1536 = int(\n    \"FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD1\"\n    \"29024E088A67CC74020BBEA63B139B22514A08798E3404DD\"\n    \"EF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245\"\n    \"E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7ED\"\n    \"EE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3D\"\n    \"C2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F\"\n    \"83655D23DCA3AD961C62F356208552BB9ED529077096966D\"\n    \"670C354E4ABC9804F1746C08CA237327FFFFFFFFFFFFFFFF\",\n    16,\n)\n\n\ndef _skip_dhx_unsupported(backend, is_dhx):\n    if not is_dhx:\n        return\n    if not backend.dh_x942_serialization_supported():\n        pytest.skip(\"DH x9.42 serialization is not supported\")\n\n\ndef test_dh_parameternumbers():\n    params = dh.DHParameterNumbers(P_1536, 2)\n\n    assert params.p == P_1536\n    assert params.g == 2\n\n    with pytest.raises(TypeError):\n        dh.DHParameterNumbers(None, 2)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        dh.DHParameterNumbers(P_1536, None)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        dh.DHParameterNumbers(None, None)  # type: ignore[arg-type]\n\n    with pytest.raises(ValueError):\n        dh.DHParameterNumbers(P_1536, 1)\n\n    # p too small\n    with pytest.raises(ValueError):\n        dh.DHParameterNumbers(65537, 2)\n\n    params = dh.DHParameterNumbers(P_1536, 7, 1245)\n\n    assert params.p == P_1536\n    assert params.g == 7\n    assert params.q == 1245\n\n    with pytest.raises(TypeError):\n        dh.DHParameterNumbers(P_1536, 2, \"hello\")  # type: ignore[arg-type]\n\n\ndef test_dh_numbers():\n    params = dh.DHParameterNumbers(P_1536, 2)\n\n    public = dh.DHPublicNumbers(1, params)\n\n    assert public.parameter_numbers is params\n    assert public.y == 1\n\n    with pytest.raises(TypeError):\n        dh.DHPublicNumbers(1, None)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        dh.DHPublicNumbers(None, params)  # type:ignore[arg-type]\n\n    private = dh.DHPrivateNumbers(1, public)\n\n    assert private.public_numbers is public\n    assert private.x == 1\n\n    with pytest.raises(TypeError):\n        dh.DHPrivateNumbers(1, None)  # type: ignore[arg-type]\n\n    with pytest.raises(TypeError):\n        dh.DHPrivateNumbers(None, public)  # type:ignore[arg-type]\n\n\ndef test_dh_parameter_numbers_equality():\n    assert dh.DHParameterNumbers(P_1536, 2) == dh.DHParameterNumbers(P_1536, 2)\n    assert dh.DHParameterNumbers(P_1536, 7, 12345) == dh.DHParameterNumbers(\n        P_1536, 7, 12345\n    )\n    assert dh.DHParameterNumbers(P_1536 + 2, 2) != dh.DHParameterNumbers(\n        P_1536, 2\n    )\n    assert dh.DHParameterNumbers(P_1536, 2, 123) != dh.DHParameterNumbers(\n        P_1536, 2, 456\n    )\n    assert dh.DHParameterNumbers(P_1536, 2, 123) != dh.DHParameterNumbers(\n        P_1536, 2\n    )\n    assert dh.DHParameterNumbers(P_1536, 5) != dh.DHParameterNumbers(P_1536, 2)\n    assert dh.DHParameterNumbers(P_1536, 2) != object()\n\n\ndef test_dh_private_numbers_equality():\n    params = dh.DHParameterNumbers(P_1536, 2)\n    public = dh.DHPublicNumbers(1, params)\n    private = dh.DHPrivateNumbers(2, public)\n\n    assert private == dh.DHPrivateNumbers(2, public)\n    assert private != dh.DHPrivateNumbers(0, public)\n    assert private != dh.DHPrivateNumbers(2, dh.DHPublicNumbers(0, params))\n    assert private != dh.DHPrivateNumbers(\n        2, dh.DHPublicNumbers(1, dh.DHParameterNumbers(P_1536, 5))\n    )\n    assert private != object()\n\n\ndef test_dh_public_numbers_equality():\n    params = dh.DHParameterNumbers(P_1536, 2)\n    public = dh.DHPublicNumbers(1, params)\n\n    assert public == dh.DHPublicNumbers(1, params)\n    assert public != dh.DHPublicNumbers(0, params)\n    assert public != dh.DHPublicNumbers(1, dh.DHParameterNumbers(P_1536, 5))\n    assert public != object()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestDH:\n    def test_small_key_generate_dh(self, backend):\n        with pytest.raises(ValueError):\n            dh.generate_parameters(2, 511, backend)\n\n    def test_unsupported_generator_generate_dh(self, backend):\n        with pytest.raises(ValueError):\n            dh.generate_parameters(7, 512, backend)\n\n    def test_large_key_generate_dh(self, backend):\n        with pytest.raises(ValueError):\n            dh.generate_parameters(2, 1 << 30)\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"rfc3526.txt\"), load_nist_vectors\n        ),\n    )\n    def test_dh_parameters_allows_rfc3526_groups(self, backend, vector):\n        p = int.from_bytes(binascii.unhexlify(vector[\"p\"]), \"big\")\n        if backend._fips_enabled and p < backend._fips_dh_min_modulus:\n            pytest.skip(\"modulus too small for FIPS mode\")\n\n        params = dh.DHParameterNumbers(p, int(vector[\"g\"]))\n        param = params.parameters(backend)\n        key = param.generate_private_key()\n        # In OpenSSL 3.0.0 OpenSSL maps to known groups. This results in\n        # a scenario where loading a known group with p and g returns a\n        # re-serialized form that has q as well (the Sophie Germain prime of\n        # that group). This makes a naive comparison of the parameter numbers\n        # objects fail, so we have to be a bit smarter\n        serialized_params = (\n            key.private_numbers().public_numbers.parameter_numbers\n        )\n        if serialized_params.q is None:\n            # This is the path OpenSSL < 3.0 takes\n            assert serialized_params == params\n        else:\n            assert serialized_params.p == params.p\n            assert serialized_params.g == params.g\n            # p = 2q + 1 since it is a Sophie Germain prime, so we can compute\n            # what we expect OpenSSL to have done here.\n            assert serialized_params.q == (params.p - 1) // 2\n\n    @pytest.mark.skip_fips(reason=\"modulus too small for FIPS\")\n    @pytest.mark.parametrize(\"with_q\", [False, True])\n    def test_convert_to_numbers(self, backend, with_q):\n        if with_q:\n            vector = load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"DH\", \"RFC5114.txt\"),\n                load_nist_vectors,\n            )[0]\n            p = int(vector[\"p\"], 16)\n            g = int(vector[\"g\"], 16)\n            q: typing.Optional[int] = int(vector[\"q\"], 16)\n        else:\n            parameters = dh.generate_parameters(2, 512).generate_private_key()\n\n            private = parameters.private_numbers()\n\n            p = private.public_numbers.parameter_numbers.p\n            g = private.public_numbers.parameter_numbers.g\n            q = None\n\n        params = dh.DHParameterNumbers(p, g, q)\n        public = dh.DHPublicNumbers(1, params)\n        private = dh.DHPrivateNumbers(2, public)\n\n        deserialized_params = params.parameters(backend)\n        deserialized_public = public.public_key(backend)\n        deserialized_private = private.private_key(backend)\n\n        assert isinstance(deserialized_params, dh.DHParameters)\n        assert isinstance(deserialized_public, dh.DHPublicKey)\n        assert isinstance(deserialized_private, dh.DHPrivateKey)\n\n    @pytest.mark.skip_fips(reason=\"FIPS requires specific parameters\")\n    def test_numbers_unsupported_parameters(self, backend):\n        # p is set to P_1536 + 1 because when calling private_key we want it to\n        # fail the DH_check call OpenSSL does, but we specifically want it to\n        # fail such that we don't get a DH_NOT_SUITABLE_GENERATOR. We can cause\n        # this by making sure p is not prime.\n        params = dh.DHParameterNumbers(P_1536 + 1, 2)\n        public = dh.DHPublicNumbers(1, params)\n        private = dh.DHPrivateNumbers(2, public)\n\n        with pytest.raises(ValueError):\n            private.private_key(backend)\n\n    @pytest.mark.skip_fips(reason=\"FIPS requires key size >= 2048\")\n    @pytest.mark.parametrize(\"with_q\", [False, True])\n    def test_generate_dh(self, backend, with_q):\n        if with_q:\n            vector = load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"DH\", \"RFC5114.txt\"),\n                load_nist_vectors,\n            )[0]\n            p = int(vector[\"p\"], 16)\n            g = int(vector[\"g\"], 16)\n            q = int(vector[\"q\"], 16)\n            parameters = dh.DHParameterNumbers(p, g, q).parameters(backend)\n            key_size = 1024\n        else:\n            generator = 2\n            key_size = 512\n\n            parameters = dh.generate_parameters(generator, key_size, backend)\n        assert isinstance(parameters, dh.DHParameters)\n\n        key = parameters.generate_private_key()\n        assert isinstance(key, dh.DHPrivateKey)\n        assert key.key_size == key_size\n\n        public = key.public_key()\n        assert isinstance(public, dh.DHPublicKey)\n        assert public.key_size == key_size\n\n        assert isinstance(parameters, dh.DHParameters)\n        parameter_numbers = parameters.parameter_numbers()\n        assert isinstance(parameter_numbers, dh.DHParameterNumbers)\n        assert parameter_numbers.p.bit_length() == key_size\n\n        assert isinstance(public, dh.DHPublicKey)\n        assert isinstance(public.public_numbers(), dh.DHPublicNumbers)\n        assert isinstance(public.parameters(), dh.DHParameters)\n\n        assert isinstance(key, dh.DHPrivateKey)\n        assert isinstance(key.private_numbers(), dh.DHPrivateNumbers)\n        assert isinstance(key.parameters(), dh.DHParameters)\n\n    def test_exchange_wrong_type(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key1 = parameters.generate_private_key()\n        with pytest.raises(TypeError):\n            key1.exchange(b\"invalidtype\")  # type: ignore[arg-type]\n\n    def test_exchange(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        assert isinstance(parameters, dh.DHParameters)\n\n        key1 = parameters.generate_private_key()\n        key2 = parameters.generate_private_key()\n\n        symkey1 = key1.exchange(key2.public_key())\n        assert symkey1\n        assert len(symkey1) == 3072 // 8\n\n        symkey2 = key2.exchange(key1.public_key())\n        assert symkey1 == symkey2\n\n    def test_exchange_algorithm(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key1 = parameters.generate_private_key()\n        key2 = parameters.generate_private_key()\n\n        shared_key_bytes = key2.exchange(key1.public_key())\n        symkey = int.from_bytes(shared_key_bytes, \"big\")\n\n        symkey_manual = pow(\n            key1.public_key().public_numbers().y,\n            key2.private_numbers().x,\n            parameters.parameter_numbers().p,\n        )\n\n        assert symkey == symkey_manual\n\n    @pytest.mark.skip_fips(reason=\"key_size too small for FIPS\")\n    def test_symmetric_key_padding(self, backend):\n        \"\"\"\n        This test has specific parameters that produce a symmetric key\n        In length 63 bytes instead 64. We make sure here that we add\n        padding to the key.\n        \"\"\"\n        p = int(\n            \"11859949538425015739337467917303613431031019140213666\"\n            \"129025407300654026585086345323066284800963463204246390\"\n            \"256567934582260424238844463330887962689642467123\"\n        )\n        g = 2\n        y = int(\n            \"32155788395534640648739966373159697798396966919821525\"\n            \"72238852825117261342483718574508213761865276905503199\"\n            \"969908098203345481366464874759377454476688391248\"\n        )\n        x = int(\n            \"409364065449673443397833358558926598469347813468816037\"\n            \"268451847116982490733450463194921405069999008617231539\"\n            \"7147035896687401350877308899732826446337707128\"\n        )\n        parameters = dh.DHParameterNumbers(p, g)\n        public = dh.DHPublicNumbers(y, parameters)\n        private = dh.DHPrivateNumbers(x, public)\n        key = private.private_key(backend)\n        symkey = key.exchange(public.public_key(backend))\n        assert len(symkey) == 512 // 8\n        assert symkey[:1] == b\"\\x00\"\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"bad_exchange.txt\"),\n            load_nist_vectors,\n        ),\n    )\n    def test_bad_exchange(self, backend, vector):\n        if (\n            backend._fips_enabled\n            and int(vector[\"p1\"]) < backend._fips_dh_min_modulus\n        ):\n            pytest.skip(\"modulus too small for FIPS mode\")\n        parameters1 = dh.DHParameterNumbers(\n            int(vector[\"p1\"]), int(vector[\"g\"])\n        )\n        public1 = dh.DHPublicNumbers(int(vector[\"y1\"]), parameters1)\n        private1 = dh.DHPrivateNumbers(int(vector[\"x1\"]), public1)\n        key1 = private1.private_key(backend)\n        pub_key1 = key1.public_key()\n\n        parameters2 = dh.DHParameterNumbers(\n            int(vector[\"p2\"]), int(vector[\"g\"])\n        )\n        public2 = dh.DHPublicNumbers(int(vector[\"y2\"]), parameters2)\n        private2 = dh.DHPrivateNumbers(int(vector[\"x2\"]), public2)\n        key2 = private2.private_key(backend)\n        pub_key2 = key2.public_key()\n\n        with pytest.raises(ValueError):\n            key1.exchange(pub_key2)\n\n        with pytest.raises(ValueError):\n            key2.exchange(pub_key1)\n\n    @pytest.mark.skip_fips(reason=\"key_size too small for FIPS\")\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n        ),\n        skip_message=\"256-bit DH keys are not supported in OpenSSL 3.0.0+\",\n    )\n    def test_load_256bit_key_from_pkcs8(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dh_key_256.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = serialization.load_pem_private_key(data, None, backend)\n        assert isinstance(key, dh.DHPrivateKey)\n        assert key.key_size == 256\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"vec.txt\"), load_nist_vectors\n        ),\n    )\n    def test_dh_vectors(self, backend, vector):\n        if (\n            backend._fips_enabled\n            and int(vector[\"p\"]) < backend._fips_dh_min_modulus\n        ):\n            pytest.skip(\"modulus too small for FIPS mode\")\n\n        if int(vector[\"p\"]).bit_length() < 512:\n            pytest.skip(\"DH keys less than 512 bits are unsupported\")\n\n        parameters = dh.DHParameterNumbers(int(vector[\"p\"]), int(vector[\"g\"]))\n        public = dh.DHPublicNumbers(int(vector[\"y\"]), parameters)\n        private = dh.DHPrivateNumbers(int(vector[\"x\"]), public)\n        key = private.private_key(backend)\n        symkey = key.exchange(public.public_key(backend))\n\n        assert int.from_bytes(symkey, \"big\") == int(vector[\"k\"], 16)\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"RFC5114.txt\"), load_nist_vectors\n        ),\n    )\n    def test_dh_vectors_with_q(self, backend, vector):\n        parameters = dh.DHParameterNumbers(\n            int(vector[\"p\"], 16), int(vector[\"g\"], 16), int(vector[\"q\"], 16)\n        )\n        public1 = dh.DHPublicNumbers(int(vector[\"ystatcavs\"], 16), parameters)\n        private1 = dh.DHPrivateNumbers(int(vector[\"xstatcavs\"], 16), public1)\n        public2 = dh.DHPublicNumbers(int(vector[\"ystatiut\"], 16), parameters)\n        private2 = dh.DHPrivateNumbers(int(vector[\"xstatiut\"], 16), public2)\n        key1 = private1.private_key(backend)\n        key2 = private2.private_key(backend)\n        symkey1 = key1.exchange(public2.public_key(backend))\n        symkey2 = key2.exchange(public1.public_key(backend))\n\n        assert int.from_bytes(symkey1, \"big\") == int(vector[\"z\"], 16)\n        assert int.from_bytes(symkey2, \"big\") == int(vector[\"z\"], 16)\n\n    def test_public_key_equality(self, backend):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dhpub.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key_bytes_2 = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dhpub_rfc5114_2.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key1 = serialization.load_pem_public_key(key_bytes)\n        key2 = serialization.load_pem_public_key(key_bytes)\n        key3 = serialization.load_pem_public_key(key_bytes_2)\n        assert key1 == key2\n        assert key1 != key3\n        assert key1 != object()\n\n        with pytest.raises(TypeError):\n            key1 < key2  # type: ignore[operator]\n\n    def test_public_key_copy(self):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dhpub.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key1 = serialization.load_pem_public_key(key_bytes)\n        key2 = copy.copy(key1)\n\n        assert key1 == key2\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestDHPrivateKeySerialization:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader_func\"),\n        [\n            [serialization.Encoding.PEM, serialization.load_pem_private_key],\n            [serialization.Encoding.DER, serialization.load_der_private_key],\n        ],\n    )\n    def test_private_bytes_unencrypted(self, backend, encoding, loader_func):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        serialized = key.private_bytes(\n            encoding,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        loaded_key = loader_func(serialized, None, backend)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (serialization.Encoding.Raw, serialization.PrivateFormat.PKCS8),\n            (serialization.Encoding.DER, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.Raw, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.X962, serialization.PrivateFormat.PKCS8),\n        ],\n    )\n    def test_private_bytes_rejects_invalid(self, encoding, fmt, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(ValueError):\n            key.private_bytes(encoding, fmt, serialization.NoEncryption())\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"encoding\", \"is_dhx\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.pem\"),\n                serialization.load_pem_private_key,\n                serialization.Encoding.PEM,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.der\"),\n                serialization.load_der_private_key,\n                serialization.Encoding.DER,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.pem\"),\n                serialization.load_pem_private_key,\n                serialization.Encoding.PEM,\n                True,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.der\"),\n                serialization.load_der_private_key,\n                serialization.Encoding.DER,\n                True,\n            ),\n        ],\n    )\n    def test_private_bytes_match(\n        self, key_path, loader_func, encoding, is_dhx, backend\n    ):\n        _skip_dhx_unsupported(backend, is_dhx)\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, None, backend)\n        serialized = key.private_bytes(\n            encoding,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        assert serialized == key_bytes\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"vec_path\", \"is_dhx\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.pem\"),\n                serialization.load_pem_private_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.der\"),\n                serialization.load_der_private_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.pem\"),\n                serialization.load_pem_private_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n                True,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.der\"),\n                serialization.load_der_private_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n                True,\n            ),\n        ],\n    )\n    def test_private_bytes_values(\n        self, key_path, loader_func, vec_path, is_dhx, backend\n    ):\n        _skip_dhx_unsupported(backend, is_dhx)\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        vec = load_vectors_from_file(vec_path, load_nist_vectors)[0]\n        key = loader_func(key_bytes, None, backend)\n        private_numbers = key.private_numbers()\n        assert private_numbers.x == int(vec[\"x\"], 16)\n        assert private_numbers.public_numbers.y == int(vec[\"y\"], 16)\n        assert private_numbers.public_numbers.parameter_numbers.g == int(\n            vec[\"g\"], 16\n        )\n        assert private_numbers.public_numbers.parameter_numbers.p == int(\n            vec[\"p\"], 16\n        )\n        if \"q\" in vec:\n            assert private_numbers.public_numbers.parameter_numbers.q == int(\n                vec[\"q\"], 16\n            )\n        else:\n            assert private_numbers.public_numbers.parameter_numbers.q is None\n\n    def test_private_bytes_traditional_openssl_invalid(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encoding(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                \"notencoding\",  # type:ignore[arg-type]\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_format(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type:ignore[arg-type]\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encryption_algorithm(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                \"notanencalg\",  # type:ignore[arg-type]\n            )\n\n    def test_private_bytes_unsupported_encryption_type(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                DummyKeySerializationEncryption(),\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestDHPublicKeySerialization:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader_func\"),\n        [\n            [serialization.Encoding.PEM, serialization.load_pem_public_key],\n            [serialization.Encoding.DER, serialization.load_der_public_key],\n        ],\n    )\n    def test_public_bytes(self, backend, encoding, loader_func):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key().public_key()\n        serialized = key.public_bytes(\n            encoding, serialization.PublicFormat.SubjectPublicKeyInfo\n        )\n        loaded_key = loader_func(serialized, backend)\n        loaded_pub_num = loaded_key.public_numbers()\n        pub_num = key.public_numbers()\n\n        assert loaded_pub_num.y == pub_num.y\n        assert (\n            loaded_pub_num.parameter_numbers.p == pub_num.parameter_numbers.p\n        )\n        assert (\n            loaded_pub_num.parameter_numbers.g == pub_num.parameter_numbers.g\n        )\n        if pub_num.parameter_numbers.q and loaded_pub_num.parameter_numbers.q:\n            assert (\n                loaded_pub_num.parameter_numbers.q\n                == pub_num.parameter_numbers.q\n            )\n        else:\n            # When this branch becomes unreachable by coverage (when support\n            # for RHEL8 is dropped), all this code can be replaced with:\n            #   assert loaded_pub_num == pub_num\n            assert True\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"encoding\", \"is_dhx\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub.pem\"),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub.der\"),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub_rfc5114_2.pem\"),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n                True,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub_rfc5114_2.der\"),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n                True,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, key_path, loader_func, encoding, is_dhx, backend\n    ):\n        _skip_dhx_unsupported(backend, is_dhx)\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        pub_key = loader_func(key_bytes, backend)\n        serialized = pub_key.public_bytes(\n            encoding,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        assert serialized == key_bytes\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"vec_path\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub.pem\"),\n                serialization.load_pem_public_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub.der\"),\n                serialization.load_der_public_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub_rfc5114_2.pem\"),\n                serialization.load_pem_public_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhpub_rfc5114_2.der\"),\n                serialization.load_der_public_key,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n            ),\n        ],\n    )\n    def test_public_bytes_values(\n        self, key_path, loader_func, vec_path, backend\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        vec = load_vectors_from_file(vec_path, load_nist_vectors)[0]\n        pub_key = loader_func(key_bytes, backend)\n        public_numbers = pub_key.public_numbers()\n        assert public_numbers.y == int(vec[\"y\"], 16)\n        assert public_numbers.parameter_numbers.g == int(vec[\"g\"], 16)\n        assert public_numbers.parameter_numbers.p == int(vec[\"p\"], 16)\n        if \"q\" in vec:\n            assert public_numbers.parameter_numbers.q == int(vec[\"q\"], 16)\n        else:\n            assert public_numbers.parameter_numbers.q is None\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key().public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                \"notencoding\",  # type:ignore[arg-type]\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n    def test_public_bytes_pkcs1_unsupported(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestDHParameterSerialization:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader_func\"),\n        [\n            [serialization.Encoding.PEM, serialization.load_pem_parameters],\n            [serialization.Encoding.DER, serialization.load_der_parameters],\n        ],\n    )\n    def test_parameter_bytes(self, backend, encoding, loader_func):\n        parameters = FFDH3072_P.parameters(backend)\n        serialized = parameters.parameter_bytes(\n            encoding, serialization.ParameterFormat.PKCS3\n        )\n        loaded_key = loader_func(serialized, backend)\n        loaded_param_num = loaded_key.parameter_numbers()\n        assert loaded_param_num == parameters.parameter_numbers()\n\n    @pytest.mark.parametrize(\n        (\"param_path\", \"loader_func\", \"encoding\", \"is_dhx\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp.pem\"),\n                serialization.load_pem_parameters,\n                serialization.Encoding.PEM,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp.der\"),\n                serialization.load_der_parameters,\n                serialization.Encoding.DER,\n                False,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp_rfc5114_2.pem\"),\n                serialization.load_pem_parameters,\n                serialization.Encoding.PEM,\n                True,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp_rfc5114_2.der\"),\n                serialization.load_der_parameters,\n                serialization.Encoding.DER,\n                True,\n            ),\n        ],\n    )\n    def test_parameter_bytes_match(\n        self, param_path, loader_func, encoding, backend, is_dhx\n    ):\n        _skip_dhx_unsupported(backend, is_dhx)\n        param_bytes = load_vectors_from_file(\n            param_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        parameters = loader_func(param_bytes, backend)\n        serialized = parameters.parameter_bytes(\n            encoding,\n            serialization.ParameterFormat.PKCS3,\n        )\n        assert serialized == param_bytes\n\n    @pytest.mark.parametrize(\n        (\"param_path\", \"loader_func\", \"vec_path\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp.pem\"),\n                serialization.load_pem_parameters,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp.der\"),\n                serialization.load_der_parameters,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp_rfc5114_2.pem\"),\n                serialization.load_pem_parameters,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhp_rfc5114_2.der\"),\n                serialization.load_der_parameters,\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.txt\"),\n            ),\n        ],\n    )\n    def test_public_bytes_values(\n        self, param_path, loader_func, vec_path, backend\n    ):\n        key_bytes = load_vectors_from_file(\n            param_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        vec = load_vectors_from_file(vec_path, load_nist_vectors)[0]\n        parameters = loader_func(key_bytes, backend)\n        parameter_numbers = parameters.parameter_numbers()\n        assert parameter_numbers.g == int(vec[\"g\"], 16)\n        assert parameter_numbers.p == int(vec[\"p\"], 16)\n        if \"q\" in vec:\n            assert parameter_numbers.q == int(vec[\"q\"], 16)\n        else:\n            assert parameter_numbers.q is None\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ),\n            (serialization.Encoding.Raw, serialization.PublicFormat.PKCS1),\n            *itertools.product(\n                [\n                    serialization.Encoding.Raw,\n                    serialization.Encoding.X962,\n                    serialization.Encoding.PEM,\n                    serialization.Encoding.DER,\n                ],\n                [\n                    serialization.PublicFormat.Raw,\n                    serialization.PublicFormat.UncompressedPoint,\n                    serialization.PublicFormat.CompressedPoint,\n                ],\n            ),\n        ],\n    )\n    def test_public_bytes_rejects_invalid(self, encoding, fmt, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        key = parameters.generate_private_key().public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(encoding, fmt)\n\n    def test_parameter_bytes_invalid_encoding(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        with pytest.raises(TypeError):\n            parameters.parameter_bytes(\n                \"notencoding\",  # type:ignore[arg-type]\n                serialization.ParameterFormat.PKCS3,\n            )\n\n    def test_parameter_bytes_invalid_format(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        with pytest.raises(ValueError):\n            parameters.parameter_bytes(\n                serialization.Encoding.PEM,\n                \"notformat\",  # type: ignore[arg-type]\n            )\n\n    def test_parameter_bytes_openssh_unsupported(self, backend):\n        parameters = FFDH3072_P.parameters(backend)\n        with pytest.raises(TypeError):\n            parameters.parameter_bytes(\n                serialization.Encoding.OpenSSH,\n                serialization.ParameterFormat.PKCS3,\n            )\n", "tests/hazmat/primitives/test_hmac_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes, hmac\n\nfrom ...utils import load_hash_vectors\nfrom .utils import generate_hmac_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.MD5()),\n    skip_message=\"Does not support MD5\",\n)\nclass TestHMACMD5:\n    test_hmac_md5 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-2202-md5.txt\"],\n        hashes.MD5(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA1\",\n)\nclass TestHMACSHA1:\n    test_hmac_sha1 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-2202-sha1.txt\"],\n        hashes.SHA1(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA224()),\n    skip_message=\"Does not support SHA224\",\n)\nclass TestHMACSHA224:\n    test_hmac_sha224 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-4231-sha224.txt\"],\n        hashes.SHA224(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),\n    skip_message=\"Does not support SHA256\",\n)\nclass TestHMACSHA256:\n    test_hmac_sha256 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-4231-sha256.txt\"],\n        hashes.SHA256(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA384()),\n    skip_message=\"Does not support SHA384\",\n)\nclass TestHMACSHA384:\n    test_hmac_sha384 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-4231-sha384.txt\"],\n        hashes.SHA384(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),\n    skip_message=\"Does not support SHA512\",\n)\nclass TestHMACSHA512:\n    test_hmac_sha512 = generate_hmac_test(\n        load_hash_vectors,\n        \"HMAC\",\n        [\"rfc-4231-sha512.txt\"],\n        hashes.SHA512(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(\n        hashes.BLAKE2b(digest_size=64)\n    ),\n    skip_message=\"Does not support BLAKE2\",\n)\nclass TestHMACBLAKE2:\n    def test_blake2b(self, backend):\n        h = hmac.HMAC(b\"0\" * 64, hashes.BLAKE2b(digest_size=64), backend)\n        h.update(b\"test\")\n        digest = h.finalize()\n        assert digest == binascii.unhexlify(\n            b\"b5319122f8a24ba134a0c9851922448104e25be5d1b91265c0c68b22722f0f29\"\n            b\"87dba4aeaa69e6bed7edc44f48d6b1be493a3ce583f9c737c53d6bacc09e2f32\"\n        )\n\n    def test_blake2s(self, backend):\n        h = hmac.HMAC(b\"0\" * 32, hashes.BLAKE2s(digest_size=32), backend)\n        h.update(b\"test\")\n        digest = h.finalize()\n        assert digest == binascii.unhexlify(\n            b\"51477cc5bdf1faf952cf97bb934ee936de1f4d5d7448a84eeb6f98d23b392166\"\n        )\n", "tests/hazmat/primitives/test_ssh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport base64\nimport datetime\nimport os\n\nimport pytest\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidSignature, InvalidTag\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed25519,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.serialization import (\n    BestAvailableEncryption,\n    Encoding,\n    KeySerializationEncryption,\n    NoEncryption,\n    PrivateFormat,\n    PublicFormat,\n    SSHCertificate,\n    SSHCertificateBuilder,\n    SSHCertificateType,\n    load_pem_private_key,\n    load_ssh_private_key,\n    load_ssh_public_identity,\n    load_ssh_public_key,\n    ssh,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import load_vectors_from_file, raises_unsupported_algorithm\nfrom .fixtures_rsa import RSA_KEY_2048\nfrom .test_ec import _skip_curve_unsupported\nfrom .test_rsa import rsa_key_2048\n\n__all__ = [\"rsa_key_2048\"]\n\n\nclass TestOpenSSHSerialization:\n    @pytest.mark.parametrize(\n        (\"key_file\", \"cert_file\"),\n        [\n            (\"rsa-psw.key.pub\", None),\n            (\"rsa-nopsw.key.pub\", \"rsa-nopsw.key-cert.pub\"),\n            (\"dsa-psw.key.pub\", None),\n            (\"dsa-nopsw.key.pub\", \"dsa-nopsw.key-cert.pub\"),\n            (\"ecdsa-psw.key.pub\", None),\n            (\"ecdsa-nopsw.key.pub\", \"ecdsa-nopsw.key-cert.pub\"),\n            (\"ed25519-psw.key.pub\", None),\n            (\"ed25519-nopsw.key.pub\", \"ed25519-nopsw.key-cert.pub\"),\n            (\"sk-ecdsa-psw.key.pub\", None),\n            (\"sk-ecdsa-nopsw.key.pub\", None),\n            (\"sk-ed25519-psw.key.pub\", None),\n            (\"sk-ed25519-nopsw.key.pub\", None),\n        ],\n    )\n    def test_load_ssh_public_key(self, key_file, cert_file, backend):\n        if \"ed25519\" in key_file and not backend.ed25519_supported():\n            pytest.skip(\"Requires OpenSSL with Ed25519 support\")\n\n        # normal public key\n        pub_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", key_file),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        nocomment_data = b\" \".join(pub_data.split()[:2])\n        if key_file.startswith(\"dsa\"):\n            with pytest.warns(utils.DeprecatedIn40):\n                public_key = load_ssh_public_key(pub_data, backend)\n            with pytest.warns(utils.DeprecatedIn40):\n                assert (\n                    public_key.public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n        else:\n            public_key = load_ssh_public_key(pub_data, backend)\n            if not key_file.startswith(\"sk-\"):\n                # SK keys do not round-trip\n                assert (\n                    public_key.public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n\n        self.run_partial_pubkey(pub_data, backend)\n\n        # parse public key with ssh certificate\n        if cert_file:\n            cert_data = load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"OpenSSH\", cert_file),\n                lambda f: f.read(),\n                mode=\"rb\",\n            )\n            if cert_file.startswith(\"dsa\"):\n                with pytest.warns(utils.DeprecatedIn40):\n                    cert_key = load_ssh_public_key(cert_data, backend)\n                with pytest.warns(utils.DeprecatedIn40):\n                    assert (\n                        cert_key.public_bytes(\n                            Encoding.OpenSSH, PublicFormat.OpenSSH\n                        )\n                        == nocomment_data\n                    )\n            else:\n                cert_key = load_ssh_public_key(cert_data, backend)\n                assert (\n                    cert_key.public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n\n            # try with more spaces\n            cert_data = b\" \\t \".join(cert_data.split())\n            if cert_file.startswith(\"dsa\"):\n                with pytest.warns(utils.DeprecatedIn40):\n                    cert_key = load_ssh_public_key(cert_data, backend)\n                with pytest.warns(utils.DeprecatedIn40):\n                    assert (\n                        cert_key.public_bytes(\n                            Encoding.OpenSSH, PublicFormat.OpenSSH\n                        )\n                        == nocomment_data\n                    )\n            else:\n                cert_key = load_ssh_public_key(cert_data, backend)\n                assert (\n                    cert_key.public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n\n            self.run_partial_pubkey(cert_data, backend)\n\n    def run_partial_pubkey(self, pubdata, backend):\n        parts = pubdata.split()\n        raw = base64.b64decode(parts[1])\n        for i in range(1, len(raw)):\n            frag = base64.b64encode(raw[:i])\n            new_pub = b\" \".join([parts[0], frag])\n            with pytest.raises(ValueError):\n                load_ssh_public_key(new_pub, backend)\n\n    @pytest.mark.parametrize(\n        (\"key_file\",),\n        [\n            (\"rsa-nopsw.key\",),\n            (\"rsa-psw.key\",),\n            (\"dsa-nopsw.key\",),\n            (\"dsa-psw.key\",),\n            (\"ecdsa-nopsw.key\",),\n            (\"ecdsa-psw.key\",),\n            (\"ed25519-nopsw.key\",),\n            (\"ed25519-psw.key\",),\n            (\"ed25519-aesgcm-psw.key\",),\n        ],\n    )\n    def test_load_ssh_private_key(self, key_file, backend):\n        if \"ed25519\" in key_file and not backend.ed25519_supported():\n            pytest.skip(\"Requires OpenSSL with Ed25519 support\")\n        if \"-psw\" in key_file and not ssh._bcrypt_supported:\n            pytest.skip(\"Requires bcrypt module\")\n\n        # read public and private key from ssh-keygen\n        priv_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", key_file),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        pub_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", key_file + \".pub\"),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        nocomment_data = b\" \".join(pub_data.split()[:2])\n\n        # load and compare\n        password = None\n        if \"-psw\" in key_file:\n            password = b\"password\"\n        for data in [\n            priv_data,\n            bytearray(priv_data),\n            memoryview(priv_data),\n            memoryview(bytearray(priv_data)),\n        ]:\n            if key_file.startswith(\"dsa\"):\n                with pytest.warns(utils.DeprecatedIn40):\n                    private_key = load_ssh_private_key(data, password, backend)\n                with pytest.warns(utils.DeprecatedIn40):\n                    assert (\n                        private_key.public_key().public_bytes(\n                            Encoding.OpenSSH, PublicFormat.OpenSSH\n                        )\n                        == nocomment_data\n                    )\n            else:\n                private_key = load_ssh_private_key(data, password, backend)\n                assert (\n                    private_key.public_key().public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n\n        # serialize with own code and reload\n        encryption: KeySerializationEncryption = NoEncryption()\n        if password:\n            encryption = BestAvailableEncryption(password)\n        if key_file.startswith(\"dsa\"):\n            with pytest.warns(utils.DeprecatedIn40):\n                priv_data2 = private_key.private_bytes(\n                    Encoding.PEM,\n                    PrivateFormat.OpenSSH,\n                    encryption,\n                )\n            with pytest.warns(utils.DeprecatedIn40):\n                private_key2 = load_ssh_private_key(\n                    priv_data2, password, backend\n                )\n            with pytest.warns(utils.DeprecatedIn40):\n                assert (\n                    private_key2.public_key().public_bytes(\n                        Encoding.OpenSSH, PublicFormat.OpenSSH\n                    )\n                    == nocomment_data\n                )\n        else:\n            priv_data2 = private_key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.OpenSSH,\n                encryption,\n            )\n            private_key2 = load_ssh_private_key(priv_data2, password, backend)\n            assert (\n                private_key2.public_key().public_bytes(\n                    Encoding.OpenSSH, PublicFormat.OpenSSH\n                )\n                == nocomment_data\n            )\n\n        # make sure multi-line base64 is used\n        maxline = max(map(len, priv_data2.split(b\"\\n\")))\n        assert maxline < 80\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires Ed25519 support\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: ssh._bcrypt_supported,\n        skip_message=\"Requires that bcrypt exists\",\n    )\n    def test_load_ssh_private_key_invalid_tag(self, backend):\n        priv_data = bytearray(\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\", \"OpenSSH\", \"ed25519-aesgcm-psw.key\"\n                ),\n                lambda f: f.read(),\n                mode=\"rb\",\n            )\n        )\n        # mutate one byte to break the tag\n        priv_data[-38] = 82\n        with pytest.raises(InvalidTag):\n            load_ssh_private_key(priv_data, b\"password\")\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires Ed25519 support\",\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: ssh._bcrypt_supported,\n        skip_message=\"Requires that bcrypt exists\",\n    )\n    def test_load_ssh_private_key_tag_incorrect_length(self, backend):\n        priv_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"ed25519-aesgcm-psw.key\"),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        # clip out a byte\n        broken_data = priv_data[:-37] + priv_data[-38:]\n        with pytest.raises(ValueError):\n            load_ssh_private_key(broken_data, b\"password\")\n\n    @pytest.mark.supported(\n        only_if=lambda backend: ssh._bcrypt_supported,\n        skip_message=\"Requires that bcrypt exists\",\n    )\n    def test_bcrypt_encryption(self, backend):\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        pub1 = private_key.public_key().public_bytes(\n            Encoding.OpenSSH, PublicFormat.OpenSSH\n        )\n\n        for psw in (\n            b\"1\",\n            b\"1234\",\n            b\"1234\" * 4,\n            b\"x\" * 72,\n        ):\n            # BestAvailableEncryption does not handle bytes-like?\n            best = BestAvailableEncryption(psw)\n            encdata = private_key.private_bytes(\n                Encoding.PEM, PrivateFormat.OpenSSH, best\n            )\n            decoded_key = load_ssh_private_key(encdata, psw, backend)\n            pub2 = decoded_key.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n            assert pub1 == pub2\n\n            # bytearray\n            decoded_key2 = load_ssh_private_key(\n                bytearray(encdata), psw, backend\n            )\n            pub2 = decoded_key2.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n            assert pub1 == pub2\n\n            # memoryview(bytes)\n            decoded_key2 = load_ssh_private_key(\n                memoryview(encdata), psw, backend\n            )\n            pub2 = decoded_key2.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n            assert pub1 == pub2\n\n            # memoryview(bytearray)\n            decoded_key2 = load_ssh_private_key(\n                memoryview(bytearray(encdata)), psw, backend\n            )\n            pub2 = decoded_key2.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n            assert pub1 == pub2\n\n            with pytest.raises(ValueError):\n                decoded_key = load_ssh_private_key(encdata, None, backend)\n            with pytest.raises(ValueError):\n                decoded_key = load_ssh_private_key(encdata, b\"wrong\", backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: not ssh._bcrypt_supported,\n        skip_message=\"Requires that bcrypt is missing\",\n    )\n    def test_missing_bcrypt(self, backend):\n        priv_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"ecdsa-psw.key\"),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        with raises_unsupported_algorithm(None):\n            load_ssh_private_key(priv_data, b\"password\", backend)\n\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        with raises_unsupported_algorithm(None):\n            private_key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.OpenSSH,\n                BestAvailableEncryption(b\"x\"),\n            )\n\n    def test_fraglist_corners(self):\n        f = ssh._FragList()\n        with pytest.raises(ValueError):\n            f.put_mpint(-1)\n        f.put_mpint(0)\n        f.put_mpint(0x80)\n        assert f.tobytes() == b\"\\0\\0\\0\\0\" + b\"\\0\\0\\0\\x02\" + b\"\\0\\x80\"\n\n    def make_file(\n        self,\n        magic=b\"openssh-key-v1\\0\",\n        ciphername=b\"none\",\n        kdfname=b\"none\",\n        kdfoptions=b\"\",\n        nkeys=1,\n        pub_type=b\"ecdsa-sha2-nistp256\",\n        pub_fields=(\n            b\"nistp256\",\n            b\"\\x04\" * 65,\n        ),\n        priv_type=None,\n        priv_fields=(b\"nistp256\", b\"\\x04\" * 65, b\"\\x7f\" * 32),\n        comment=b\"comment\",\n        checkval1=b\"1234\",\n        checkval2=b\"1234\",\n        pad=None,\n        header=b\"-----BEGIN OPENSSH PRIVATE KEY-----\\n\",\n        footer=b\"-----END OPENSSH PRIVATE KEY-----\\n\",\n        cut=8192,\n    ):\n        \"\"\"Create private key file\"\"\"\n        if not priv_type:\n            priv_type = pub_type\n\n        pub = ssh._FragList()\n        for elem in (pub_type, *pub_fields):\n            pub.put_sshstr(elem)\n\n        secret = ssh._FragList([checkval1, checkval2])\n        for i in range(nkeys):\n            for elem in (priv_type, *priv_fields, comment):\n                secret.put_sshstr(elem)\n\n        if pad is None:\n            pad_len = 8 - (secret.size() % 8)\n            pad = bytearray(range(1, 1 + pad_len))\n        secret.put_raw(pad)\n\n        main = ssh._FragList([magic])\n        main.put_sshstr(ciphername)\n        main.put_sshstr(kdfname)\n        main.put_sshstr(kdfoptions)\n        main.put_u32(nkeys)\n        for i in range(nkeys):\n            main.put_sshstr(pub)\n        main.put_sshstr(secret)\n\n        res = main.tobytes()\n        return ssh._ssh_pem_encode(res[:cut], header, footer)\n\n    def test_ssh_make_file(self, backend):\n        # check if works by default\n        data = self.make_file()\n        key = load_ssh_private_key(data, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n\n    def test_load_ssh_private_key_errors(self, backend):\n        # bad kdf\n        data = self.make_file(kdfname=b\"unknown\", ciphername=b\"aes256-ctr\")\n        with raises_unsupported_algorithm(None):\n            load_ssh_private_key(data, None, backend)\n\n        # bad cipher\n        data = self.make_file(ciphername=b\"unknown\", kdfname=b\"bcrypt\")\n        with raises_unsupported_algorithm(None):\n            load_ssh_private_key(data, None, backend)\n\n        # bad magic\n        data = self.make_file(magic=b\"unknown\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # too few keys\n        data = self.make_file(nkeys=0)\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # too many keys\n        data = self.make_file(nkeys=2)\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    def test_ssh_errors_bad_values(self, backend):\n        # bad curve\n        data = self.make_file(pub_type=b\"ecdsa-sha2-nistp444\")\n        with raises_unsupported_algorithm(None):\n            load_ssh_private_key(data, None, backend)\n\n        # curve mismatch\n        data = self.make_file(priv_type=b\"ecdsa-sha2-nistp384\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # invalid bigint\n        data = self.make_file(\n            priv_fields=(b\"nistp256\", b\"\\x04\" * 65, b\"\\x80\" * 32)\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    def test_ssh_errors_pubpriv_mismatch(self, backend):\n        # ecdsa public-private mismatch\n        data = self.make_file(\n            pub_fields=(\n                b\"nistp256\",\n                b\"\\x04\" + b\"\\x05\" * 64,\n            )\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # rsa public-private mismatch\n        data = self.make_file(\n            pub_type=b\"ssh-rsa\",\n            pub_fields=(b\"x\" * 32,) * 2,\n            priv_fields=(b\"z\" * 32,) * 6,\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # dsa public-private mismatch\n        data = self.make_file(\n            pub_type=b\"ssh-dss\",\n            pub_fields=(b\"x\" * 32,) * 4,\n            priv_fields=(b\"z\" * 32,) * 5,\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # ed25519 public-private mismatch\n        sk = b\"x\" * 32\n        pk1 = b\"y\" * 32\n        pk2 = b\"z\" * 32\n        data = self.make_file(\n            pub_type=b\"ssh-ed25519\",\n            pub_fields=(pk1,),\n            priv_fields=(\n                pk1,\n                sk + pk2,\n            ),\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n        data = self.make_file(\n            pub_type=b\"ssh-ed25519\",\n            pub_fields=(pk1,),\n            priv_fields=(\n                pk2,\n                sk + pk1,\n            ),\n        )\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    def test_ssh_errors_bad_wrapper(self, backend):\n        # wrong header\n        data = self.make_file(header=b\"-----BEGIN RSA PRIVATE KEY-----\\n\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # wring footer\n        data = self.make_file(footer=b\"-----END RSA PRIVATE KEY-----\\n\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    def test_ssh_no_padding(self, backend):\n        # no padding must work, if data is on block boundary\n        data = self.make_file(pad=b\"\", comment=b\"\")\n        key = load_ssh_private_key(data, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n\n        # no padding with right last byte\n        data = self.make_file(pad=b\"\", comment=b\"\\x08\" * 8)\n        key = load_ssh_private_key(data, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n\n        # avoid unexpected padding removal\n        data = self.make_file(pad=b\"\", comment=b\"1234\\x01\\x02\\x03\\x04\")\n        key = load_ssh_private_key(data, None, backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n\n        # bad padding with right size\n        data = self.make_file(pad=b\"\\x08\" * 8, comment=b\"\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    def test_ssh_errors_bad_secrets(self, backend):\n        # checkval mismatch\n        data = self.make_file(checkval2=b\"4321\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n        # bad padding, correct=1\n        data = self.make_file(pad=b\"\\x01\\x02\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n        data = self.make_file(pad=b\"\")\n        with pytest.raises(ValueError):\n            load_ssh_private_key(data, None, backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.elliptic_curve_supported(\n            ec.SECP192R1()\n        ),\n        skip_message=\"Requires backend support for ec.SECP192R1\",\n    )\n    def test_serialize_ssh_private_key_errors_bad_curve(self, backend):\n        private_key = ec.generate_private_key(ec.SECP192R1(), backend)\n        with pytest.raises(ValueError):\n            private_key.private_bytes(\n                Encoding.PEM, PrivateFormat.OpenSSH, NoEncryption()\n            )\n\n    def test_serialize_ssh_private_key_errors(\n        self, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        # bad encoding\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n        with pytest.raises(ValueError):\n            private_key.private_bytes(\n                Encoding.DER, PrivateFormat.OpenSSH, NoEncryption()\n            )\n\n        # bad object type\n        with pytest.raises(ValueError):\n            ssh._serialize_ssh_private_key(\n                object(),  # type:ignore[arg-type]\n                b\"\",\n                NoEncryption(),\n            )\n\n        private_key = ec.generate_private_key(ec.SECP256R1(), backend)\n\n        # unknown encryption class\n        with pytest.raises(ValueError):\n            private_key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.OpenSSH,\n                DummyKeySerializationEncryption(),\n            )\n\n        with pytest.raises(ValueError):\n            rsa_key_2048.private_bytes(\n                Encoding.DER, PrivateFormat.OpenSSH, NoEncryption()\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: ssh._bcrypt_supported,\n        skip_message=\"Requires that bcrypt exists\",\n    )\n    @pytest.mark.parametrize(\n        \"password\",\n        (\n            b\"1234\",\n            b\"p@ssw0rd\",\n            b\"x\" * 100,\n        ),\n    )\n    @pytest.mark.parametrize(\n        \"kdf_rounds\",\n        [\n            1,\n            10,\n            30,\n        ],\n    )\n    def test_serialize_ssh_private_key_with_password(\n        self, password, kdf_rounds, rsa_key_2048: rsa.RSAPrivateKey, backend\n    ):\n        for original_key in [\n            ec.generate_private_key(ec.SECP256R1(), backend),\n            rsa_key_2048,\n        ]:\n            assert isinstance(\n                original_key, (ec.EllipticCurvePrivateKey, rsa.RSAPrivateKey)\n            )\n            encoded_key_data = original_key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.OpenSSH,\n                (\n                    PrivateFormat.OpenSSH.encryption_builder()\n                    .kdf_rounds(kdf_rounds)\n                    .build(password)\n                ),\n            )\n\n            decoded_key = load_ssh_private_key(\n                data=encoded_key_data,\n                password=password,\n                backend=backend,\n            )\n\n            original_public_key = original_key.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n\n            decoded_public_key = decoded_key.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n\n            assert original_public_key == decoded_public_key\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"supported\"),\n        [\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.1024.pem\"], True),\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.2048.pem\"], False),\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.3072.pem\"], False),\n        ],\n    )\n    def test_dsa_private_key_sizes(self, key_path, supported, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read(), None, backend\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(key, dsa.DSAPrivateKey)\n        if supported:\n            with pytest.warns(utils.DeprecatedIn40):\n                res = key.private_bytes(\n                    Encoding.PEM, PrivateFormat.OpenSSH, NoEncryption()\n                )\n            assert isinstance(res, bytes)\n        else:\n            with pytest.raises(ValueError):\n                with pytest.warns(utils.DeprecatedIn40):\n                    key.private_bytes(\n                        Encoding.PEM, PrivateFormat.OpenSSH, NoEncryption()\n                    )\n\n\nclass TestRSASSHSerialization:\n    def test_load_ssh_public_key_unsupported(self, backend):\n        ssh_key = b\"ecdsa-sha2-junk AAAAE2VjZHNhLXNoYTItbmlzdHAyNTY=\"\n\n        with raises_unsupported_algorithm(None):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_bad_format(self, backend):\n        ssh_key = b\"ssh-rsa not-a-real-key\"\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_rsa_too_short(self, backend):\n        ssh_key = b\"ssh-rsa\"\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_truncated_int(self, backend):\n        ssh_key = b\"ssh-rsa AAAAB3NzaC1yc2EAAAA=\"\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n        ssh_key = b\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAAACKr+IHXo\"\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_rsa_comment_with_spaces(self, backend):\n        ssh_key = (\n            b\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk\"\n            b\"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll\"\n            b\"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK\"\n            b\"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f\"\n            b\"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy\"\n            b\"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX\"\n            # Extra section appended\n            b\"2MzHvnbv testkey@localhost extra\"\n        )\n\n        load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_rsa_extra_data_after_modulo(self, backend):\n        ssh_key = (\n            b\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk\"\n            b\"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll\"\n            b\"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK\"\n            b\"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f\"\n            b\"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy\"\n            b\"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX\"\n            b\"2MzHvnbvAQ== testkey@localhost\"\n        )\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_rsa_different_string(self, backend):\n        ssh_key = (\n            # \"AAAAB3NzA\" the final A is capitalized here to cause the string\n            # ssh-rsa inside the base64 encoded blob to be incorrect. It should\n            # be a lower case 'a'.\n            b\"ssh-rsa AAAAB3NzAC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk\"\n            b\"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll\"\n            b\"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK\"\n            b\"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f\"\n            b\"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy\"\n            b\"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX\"\n            b\"2MzHvnbvAQ== testkey@localhost\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_rsa(self, backend):\n        ssh_key = (\n            b\"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDDu/XRP1kyK6Cgt36gts9XAk\"\n            b\"FiiuJLW6RU0j3KKVZSs1I7Z3UmU9/9aVh/rZV43WQG8jaR6kkcP4stOR0DEtll\"\n            b\"PDA7ZRBnrfiHpSQYQ874AZaAoIjgkv7DBfsE6gcDQLub0PFjWyrYQUJhtOLQEK\"\n            b\"vY/G0vt2iRL3juawWmCFdTK3W3XvwAdgGk71i6lHt+deOPNEPN2H58E4odrZ2f\"\n            b\"sxn/adpDqfb2sM0kPwQs0aWvrrKGvUaustkivQE4XWiSFnB0oJB/lKK/CKVKuy\"\n            b\"///ImSCGHQRvhwariN2tvZ6CBNSLh3iQgeB0AkyJlng7MXB2qYq/Ci2FUOryCX\"\n            b\"2MzHvnbv testkey@localhost\"\n        )\n\n        key = load_ssh_public_key(ssh_key, backend)\n\n        assert key is not None\n        assert isinstance(key, rsa.RSAPublicKey)\n\n        numbers = key.public_numbers()\n\n        expected_e = 0x10001\n        expected_n = int(\n            \"00C3BBF5D13F59322BA0A0B77EA0B6CF570241628AE24B5BA454D\"\n            \"23DCA295652B3523B67752653DFFD69587FAD9578DD6406F23691\"\n            \"EA491C3F8B2D391D0312D9653C303B651067ADF887A5241843CEF\"\n            \"8019680A088E092FEC305FB04EA070340BB9BD0F1635B2AD84142\"\n            \"61B4E2D010ABD8FC6D2FB768912F78EE6B05A60857532B75B75EF\"\n            \"C007601A4EF58BA947B7E75E38F3443CDD87E7C138A1DAD9D9FB3\"\n            \"19FF69DA43A9F6F6B0CD243F042CD1A5AFAEB286BD46AEB2D922B\"\n            \"D01385D6892167074A0907F94A2BF08A54ABB2FFFFC89920861D0\"\n            \"46F8706AB88DDADBD9E8204D48B87789081E074024C8996783B31\"\n            \"7076A98ABF0A2D8550EAF2097D8CCC7BE76EF\",\n            16,\n        )\n\n        expected = rsa.RSAPublicNumbers(expected_e, expected_n)\n\n        assert numbers == expected\n\n\nclass TestDSSSSHSerialization:\n    def test_load_ssh_public_key_dss_too_short(self, backend):\n        ssh_key = b\"ssh-dss\"\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_dss_comment_with_spaces(self, backend):\n        ssh_key = (\n            b\"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD\"\n            b\"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm\"\n            b\"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ\"\n            b\"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2\"\n            b\"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf\"\n            b\"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J\"\n            b\"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi\"\n            b\"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa\"\n            b\"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr\"\n            b\"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost extra\"\n        )\n\n        with pytest.warns(utils.DeprecatedIn40):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_dss_extra_data_after_modulo(self, backend):\n        ssh_key = (\n            b\"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD\"\n            b\"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm\"\n            b\"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ\"\n            b\"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2\"\n            b\"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf\"\n            b\"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J\"\n            b\"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi\"\n            b\"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa\"\n            b\"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr\"\n            b\"z53N7tPF/IhHTjBHb1Ol7IFu9p9AAwMD== testkey@localhost\"\n        )\n\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_dss_different_string(self, backend):\n        ssh_key = (\n            # \"AAAAB3NzA\" the final A is capitalized here to cause the string\n            # ssh-dss inside the base64 encoded blob to be incorrect. It should\n            # be a lower case 'a'.\n            b\"ssh-dss AAAAB3NzAC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD\"\n            b\"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm\"\n            b\"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ\"\n            b\"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2\"\n            b\"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf\"\n            b\"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J\"\n            b\"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi\"\n            b\"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa\"\n            b\"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr\"\n            b\"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_dss(self, backend):\n        ssh_key = (\n            b\"ssh-dss AAAAB3NzaC1kc3MAAACBALmwUtfwdjAUjU2Dixd5DvT0NDcjjr69UD\"\n            b\"LqSD/Xt5Al7D3GXr1WOrWGpjO0NE9qzRCvMTU7zykRH6XjuNXB6Hvv48Zfm4vm\"\n            b\"nHQHFmmMg2bI75JbnOwdzWnnPZJrVU4rS23dFFPqs5ug+EbhVVrcwzxahjcSjJ\"\n            b\"7WEQSkVQWnSPbbAAAAFQDXmpD3DIkGvLSBf1GdUF4PHKtUrQAAAIB/bJFwss+2\"\n            b\"fngmfG/Li5OyL7A9iVoGdkUaFaxEUROTp7wkm2z49fXFAir+/U31v50Tu98YLf\"\n            b\"WvKlxdHcdgQYV9Ww5LIrhWwwD4UKOwC6w5S3KHVbi3pWUi7vxJFXOWfeu1mC/J\"\n            b\"TWqMKR91j+rmOtdppWIZRyIVIqLcMdGO3m+2VgAAAIANFDz5KQH5NvoljpoRQi\"\n            b\"RgyPjxWXiE7vjLElKj4v8KrpanAywBzdhIW1y/tzpGuwRwj5ihi8iNTHgSsoTa\"\n            b\"j5AG5HPomJf5vJElxpu/2O9pHA52wcNObIQ7j+JA5uWusxNIbl+pF6sSiP8abr\"\n            b\"z53N7tPF/IhHTjBHb1Ol7IFu9p9A== testkey@localhost\"\n        )\n\n        with pytest.warns(utils.DeprecatedIn40):\n            key = load_ssh_public_key(ssh_key, backend)\n\n        assert key is not None\n        assert isinstance(key, dsa.DSAPublicKey)\n\n        numbers = key.public_numbers()\n\n        expected_y = int(\n            \"d143cf92901f936fa258e9a11422460c8f8f1597884eef8cb1252a3e2ff0aae\"\n            \"96a7032c01cdd8485b5cbfb73a46bb04708f98a18bc88d4c7812b284da8f900\"\n            \"6e473e89897f9bc9125c69bbfd8ef691c0e76c1c34e6c843b8fe240e6e5aeb3\"\n            \"13486e5fa917ab1288ff1a6ebcf9dcdeed3c5fc88474e30476f53a5ec816ef6\"\n            \"9f4\",\n            16,\n        )\n        expected_p = int(\n            \"b9b052d7f07630148d4d838b17790ef4f43437238ebebd5032ea483fd7b7902\"\n            \"5ec3dc65ebd563ab586a633b4344f6acd10af31353bcf29111fa5e3b8d5c1e8\"\n            \"7befe3c65f9b8be69c740716698c8366c8ef925b9cec1dcd69e73d926b554e2\"\n            \"b4b6ddd1453eab39ba0f846e1555adcc33c5a8637128c9ed61104a45505a748\"\n            \"f6db\",\n            16,\n        )\n        expected_q = 1230879958723280233885494314531920096931919647917\n        expected_g = int(\n            \"7f6c9170b2cfb67e78267c6fcb8b93b22fb03d895a0676451a15ac44511393a\"\n            \"7bc249b6cf8f5f5c5022afefd4df5bf9d13bbdf182df5af2a5c5d1dc7604185\"\n            \"7d5b0e4b22b856c300f850a3b00bac394b728755b8b7a56522eefc491573967\"\n            \"debb5982fc94d6a8c291f758feae63ad769a5621947221522a2dc31d18ede6f\"\n            \"b656\",\n            16,\n        )\n        expected = dsa.DSAPublicNumbers(\n            expected_y,\n            dsa.DSAParameterNumbers(expected_p, expected_q, expected_g),\n        )\n\n        assert numbers == expected\n\n\nclass TestECDSASSHSerialization:\n    def test_load_ssh_public_key_ecdsa_nist_p256(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        ssh_key = (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01\"\n        )\n        key = load_ssh_public_key(ssh_key, backend)\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n\n        expected_x = int(\n            \"44196257377740326295529888716212621920056478823906609851236662550\"\n            \"785814128027\",\n            10,\n        )\n        expected_y = int(\n            \"12257763433170736656417248739355923610241609728032203358057767672\"\n            \"925775019611\",\n            10,\n        )\n\n        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(\n            expected_x, expected_y, ec.SECP256R1()\n        )\n\n    def test_load_ssh_public_key_byteslike(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n\n        ssh_key = (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01\"\n        )\n        assert load_ssh_public_key(bytearray(ssh_key), backend)\n        assert load_ssh_public_key(memoryview(ssh_key), backend)\n        assert load_ssh_public_key(memoryview(bytearray(ssh_key)), backend)\n\n    def test_load_ssh_public_key_ecdsa_nist_p384(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP384R1())\n        ssh_key = (\n            b\"ecdsa-sha2-nistp384 AAAAE2VjZHNhLXNoYTItbmlzdHAzODQAAAAIbmlzdHAz\"\n            b\"ODQAAABhBMzucOm9wbwg4iMr5QL0ya0XNQGXpw4wM5f12E3tWhdcrzyGHyel71t1\"\n            b\"4bvF9JZ2/WIuSxUr33XDl8jYo+lMQ5N7Vanc7f7i3AR1YydatL3wQfZStQ1I3rBa\"\n            b\"qQtRSEU8Tg== root@cloud-server-01\"\n        )\n        key = load_ssh_public_key(ssh_key, backend)\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n\n        expected_x = int(\n            \"31541830871345183397582554827482786756220448716666815789487537666\"\n            \"592636882822352575507883817901562613492450642523901\",\n            10,\n        )\n        expected_y = int(\n            \"15111413269431823234030344298767984698884955023183354737123929430\"\n            \"995703524272335782455051101616329050844273733614670\",\n            10,\n        )\n\n        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(\n            expected_x, expected_y, ec.SECP384R1()\n        )\n\n    def test_load_ssh_public_key_ecdsa_nist_p521(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP521R1())\n        ssh_key = (\n            b\"ecdsa-sha2-nistp521 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1\"\n            b\"MjEAAACFBAGTrRhMSEgF6Ni+PXNz+5fjS4lw3ypUILVVQ0Av+0hQxOx+MyozELon\"\n            b\"I8NKbrbBjijEs1GuImsmkTmWsMXS1j2A7wB4Kseh7W9KA9IZJ1+TMrzWUEwvOOXi\"\n            b\"wT23pbaWWXG4NaM7vssWfZBnvz3S174TCXnJ+DSccvWBFnKP0KchzLKxbg== \"\n            b\"root@cloud-server-01\"\n        )\n        key = load_ssh_public_key(ssh_key, backend)\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n\n        expected_x = int(\n            \"54124123120178189598842622575230904027376313369742467279346415219\"\n            \"77809037378785192537810367028427387173980786968395921877911964629\"\n            \"142163122798974160187785455\",\n            10,\n        )\n        expected_y = int(\n            \"16111775122845033200938694062381820957441843014849125660011303579\"\n            \"15284560361402515564433711416776946492019498546572162801954089916\"\n            \"006665939539407104638103918\",\n            10,\n        )\n\n        assert key.public_numbers() == ec.EllipticCurvePublicNumbers(\n            expected_x, expected_y, ec.SECP521R1()\n        )\n\n    def test_load_ssh_public_key_ecdsa_nist_p256_trailing_data(self, backend):\n        ssh_key = (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCFPltB= root@cloud-server-01\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_ecdsa_nist_p256_missing_data(self, backend):\n        ssh_key = (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCF= root@cloud-server-01\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_ecdsa_nist_p256_compressed(self, backend):\n        # If we ever implement compressed points, note that this is not a valid\n        # one, it just has the compressed marker in the right place.\n        ssh_key = (\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTYAAABBAWG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01\"\n        )\n        with pytest.raises(NotImplementedError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_ecdsa_nist_p256_bad_curve_name(self, backend):\n        ssh_key = (\n            # The curve name in here is changed to be \"nistp255\".\n            b\"ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAy\"\n            b\"NTUAAABBBGG2MfkHXp0UkxUyllDzWNBAImsvt5t7pFtTXegZK2WbGxml8zMrgWi5\"\n            b\"teIg1TO03/FD9hbpBFgBeix3NrCFPls= root@cloud-server-01\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\nclass TestEd25519SSHSerialization:\n    def test_load_ssh_public_key(self, backend):\n        ssh_key = (\n            b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG2fgpmpYO61qeAxGd0wgRaN/E4\"\n            b\"GR+xWvBmvxjxrB1vG user@chiron.local\"\n        )\n        key = load_ssh_public_key(ssh_key, backend)\n        assert isinstance(key, ed25519.Ed25519PublicKey)\n        assert key.public_bytes(Encoding.Raw, PublicFormat.Raw) == (\n            b\"m\\x9f\\x82\\x99\\xa9`\\xee\\xb5\\xa9\\xe01\\x19\\xdd0\\x81\\x16\\x8d\\xfc\"\n            b\"N\\x06G\\xecV\\xbc\\x19\\xaf\\xc6<k\\x07[\\xc6\"\n        )\n\n    def test_public_bytes_openssh(self, backend):\n        ssh_key = (\n            b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG2fgpmpYO61qeAxGd0wgRaN/E4\"\n            b\"GR+xWvBmvxjxrB1vG\"\n        )\n        key = load_ssh_public_key(ssh_key, backend)\n        assert isinstance(key, ed25519.Ed25519PublicKey)\n        assert (\n            key.public_bytes(Encoding.OpenSSH, PublicFormat.OpenSSH) == ssh_key\n        )\n\n    def test_load_ssh_public_key_not_32_bytes(self, backend):\n        ssh_key = (\n            b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAI22fgpmpYO61qeAxGd0wgRaN/E4\"\n            b\"GR+xWvBmvxjxrB1vGaGVs user@chiron.local\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n    def test_load_ssh_public_key_trailing_data(self, backend):\n        ssh_key = (\n            b\"ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIG2fgpmpYO61qeAxGd0wgRa\"\n            b\"N/E4GR+xWvBmvxjxrB1vGdHJhaWxpbmdkYXRh user@chiron.local\"\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_key(ssh_key, backend)\n\n\nclass TestSSHCertificate:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_loads_ssh_cert(self, backend):\n        # secp256r1 public key, ed25519 signing key\n        cert = load_ssh_public_identity(\n            b\"ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAKGVjZHNhLXNoYTItbm\"\n            b\"lzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAgLfsFv9Gbc6LZSiJFWdYQl\"\n            b\"IMNI50GExXW0fBpgGVf+Y4AAAAIbmlzdHAyNTYAAABBBIzVyRgVLR4F38bIOLBN\"\n            b\"8CNm8Nf+eBHCVkKDKb9WDyLLD61CEmzjK/ORwFuSE4N60eIGbFidBf0D0xh7G6o\"\n            b\"TNxsAAAAAAAAAAAAAAAEAAAAUdGVzdEBjcnlwdG9ncmFwaHkuaW8AAAAaAAAACm\"\n            b\"NyeXB0b3VzZXIAAAAIdGVzdHVzZXIAAAAAY7KyZAAAAAB2frXAAAAAWAAAAA1mb\"\n            b\"3JjZS1jb21tYW5kAAAALAAAAChlY2hvIGFhYWFhYWFhYWFhYWFhYWFhYWFhYWFh\"\n            b\"YWFhYWFhYWFhYWFhAAAAD3ZlcmlmeS1yZXF1aXJlZAAAAAAAAACCAAAAFXBlcm1\"\n            b\"pdC1YMTEtZm9yd2FyZGluZwAAAAAAAAAXcGVybWl0LWFnZW50LWZvcndhcmRpbm\"\n            b\"cAAAAAAAAAFnBlcm1pdC1wb3J0LWZvcndhcmRpbmcAAAAAAAAACnBlcm1pdC1wd\"\n            b\"HkAAAAAAAAADnBlcm1pdC11c2VyLXJjAAAAAAAAAAAAAAAzAAAAC3NzaC1lZDI1\"\n            b\"NTE5AAAAICH6csEOmGbOfT2B/S/FJg3uyPsaPSZUZk2SVYlfs0KLAAAAUwAAAAt\"\n            b\"zc2gtZWQyNTUxOQAAAEDz2u7X5/TFbN7Ms7DP4yArhz1oWWYKkdAk7FGFkHfjtY\"\n            b\"/YfNQ8Oky3dCZRi7PnSzScEEjos7723dhF8/y99WwH reaperhulk@despoina.\"\n            b\"local\"\n        )\n        assert isinstance(cert, SSHCertificate)\n        cert.verify_cert_signature()\n        signature_key = cert.signature_key()\n        assert isinstance(signature_key, ed25519.Ed25519PublicKey)\n        assert cert.nonce == (\n            b'-\\xfb\\x05\\xbf\\xd1\\x9bs\\xa2\\xd9J\"EY\\xd6\\x10\\x94\\x83\\r#\\x9d'\n            b\"\\x06\\x13\\x15\\xd6\\xd1\\xf0i\\x80e_\\xf9\\x8e\"\n        )\n        public_key = cert.public_key()\n        assert isinstance(public_key, ec.EllipticCurvePublicKey)\n        assert isinstance(public_key.curve, ec.SECP256R1)\n        assert cert.serial == 0\n        assert cert.type is SSHCertificateType.USER\n        assert cert.key_id == b\"test@cryptography.io\"\n        assert cert.valid_principals == [b\"cryptouser\", b\"testuser\"]\n        assert cert.valid_before == 1988015552\n        assert cert.valid_after == 1672655460\n        assert cert.critical_options == {\n            b\"force-command\": b\"echo aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n            b\"verify-required\": b\"\",\n        }\n        assert cert.extensions == {\n            b\"permit-X11-forwarding\": b\"\",\n            b\"permit-agent-forwarding\": b\"\",\n            b\"permit-port-forwarding\": b\"\",\n            b\"permit-pty\": b\"\",\n            b\"permit-user-rc\": b\"\",\n        }\n\n    @pytest.mark.parametrize(\n        \"filename\",\n        [\n            \"p256-p384.pub\",\n            \"p256-p521.pub\",\n            \"p256-rsa-sha1.pub\",\n            \"p256-rsa-sha256.pub\",\n            \"p256-rsa-sha512.pub\",\n        ],\n    )\n    def test_verify_cert_signature(self, filename, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"certs\", filename),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        cert = load_ssh_public_identity(data)\n        # we have no public API for getting the hash alg of the sig\n        assert isinstance(cert, SSHCertificate)\n        if backend._fips_enabled and bytes(cert._inner_sig_type) == b\"ssh-rsa\":\n            pytest.skip(\"FIPS does not support RSA SHA1\")\n        cert.verify_cert_signature()\n\n    @pytest.mark.parametrize(\n        \"filename\",\n        [\n            \"p256-p256-empty-principals.pub\",\n            \"p256-p384.pub\",\n            \"p256-p521.pub\",\n            \"p256-rsa-sha1.pub\",\n            \"p256-rsa-sha256.pub\",\n            \"p256-rsa-sha512.pub\",\n        ],\n    )\n    def test_invalid_signature(self, filename, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"certs\", filename),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        data = bytearray(data)\n        # mutate the signature so it's invalid\n        data[-10] = 71\n        cert = load_ssh_public_identity(data)\n        assert isinstance(cert, SSHCertificate)\n        # we have no public API for getting the hash alg of the sig\n        if backend._fips_enabled and bytes(cert._inner_sig_type) == b\"ssh-rsa\":\n            pytest.skip(\"FIPS does not support RSA SHA1\")\n        with pytest.raises(InvalidSignature):\n            cert.verify_cert_signature()\n\n    def test_not_bytes(self):\n        with pytest.raises(TypeError):\n            load_ssh_public_identity(\n                \"these aren't bytes\"  # type:ignore[arg-type]\n            )\n\n    def test_load_ssh_public_key(self, backend):\n        # This test will be removed when we implement load_ssh_public_key\n        # in terms of load_ssh_public_identity. Needed for coverage now.\n        pub_data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"rsa-nopsw.key.pub\"),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        key = load_ssh_public_identity(pub_data)\n        assert isinstance(key, rsa.RSAPublicKey)\n\n    @pytest.mark.parametrize(\"filename\", [\"dsa-p256.pub\", \"p256-dsa.pub\"])\n    def test_dsa_unsupported(self, filename):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"certs\", filename),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        with raises_unsupported_algorithm(None):\n            load_ssh_public_identity(data)\n\n    def test_mismatched_inner_signature_type_and_sig_type(self):\n        data = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\",\n                \"OpenSSH\",\n                \"certs\",\n                \"p256-p256-broken-signature-key-type.pub\",\n            ),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(data)\n\n    def test_invalid_cert_type(self):\n        data = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\",\n                \"OpenSSH\",\n                \"certs\",\n                \"p256-p256-invalid-cert-type.pub\",\n            ),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(data)\n\n    @pytest.mark.parametrize(\n        \"filename\",\n        [\n            \"p256-p256-duplicate-extension.pub\",\n            \"p256-p256-non-lexical-extensions.pub\",\n            \"p256-p256-duplicate-crit-opts.pub\",\n            \"p256-p256-non-lexical-crit-opts.pub\",\n            \"p256-ed25519-non-singular-crit-opt-val.pub\",\n            \"p256-ed25519-non-singular-ext-val.pub\",\n        ],\n    )\n    def test_invalid_encodings(self, filename):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"OpenSSH\", \"certs\", filename),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(data)\n\n    def test_invalid_line_format(self, backend):\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(b\"whaaaaaaaaaaat\")\n\n    def test_invalid_b64(self, backend):\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(b\"ssh-rsa-cert-v01@openssh.com invalid\")\n\n    def test_inner_outer_key_type_mismatch(self):\n        with pytest.raises(ValueError):\n            load_ssh_public_identity(\n                b\"ecdsa-sha2-nistp256-cert-v01@openssh.com AAAAK0VjZHNhLXNoYTI\"\n                b\"tbmlzdHAyNTYtY2VydC12MDFAb3BlbnNzaC5jb20AAAAg/9dq+iibMSMdJ0v\"\n                b\"l6D0SrsazwccWptLQs4sEgJBVnQMAAAAIbmlzdHAyNTYAAABBBAsuVFNNj/m\"\n                b\"MyFm2xB99G4xiaUJE1lZNjcp+S2tXYW5KorcHpusSlSqOkUPZ2l0644dgiNP\"\n                b\"DKR/R+BtYENC8aq8AAAAAAAAAAAAAAAEAAAAUdGVzdEBjcnlwdG9ncmFwaHk\"\n                b\"uaW8AAAAaAAAACmNyeXB0b3VzZXIAAAAIdGVzdHVzZXIAAAAAY7ZXNAAAAAB\"\n                b\"2glqqAAAAAAAAAIIAAAAVcGVybWl0LVgxMS1mb3J3YXJkaW5nAAAAAAAAABd\"\n                b\"wZXJtaXQtYWdlbnQtZm9yd2FyZGluZwAAAAAAAAAWcGVybWl0LXBvcnQtZm9\"\n                b\"yd2FyZGluZwAAAAAAAAAKcGVybWl0LXB0eQAAAAAAAAAOcGVybWl0LXVzZXI\"\n                b\"tcmMAAAAAAAAAAAAAAGgAAAATZWNkc2Etc2hhMi1uaXN0cDI1NgAAAAhuaXN\"\n                b\"0cDI1NgAAAEEEzwNcwptXrrgztCug8ZB82f5OsPWJiO4WP0kjdFz1vbBGQOU\"\n                b\"DcCaabh5EbgfMOf1mg58zw35QrqjTXDiBMjyPhwAAAGQAAAATZWNkc2Etc2h\"\n                b\"hMi1uaXN0cDI1NgAAAEkAAAAhAOaNCEtn0JkFfSygACVZMBUMd5/m7avwqxW\"\n                b\"+FxCje1GpAAAAIGf9opl4YoC5XcO92WMFEwUdE3jUQtBg3GRQlXBqFcoL\"\n            )\n\n    def test_loads_a_cert_empty_principals(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\",\n                \"OpenSSH\",\n                \"certs\",\n                \"p256-p256-empty-principals.pub\",\n            ),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        cert = load_ssh_public_identity(data)\n        assert isinstance(cert, SSHCertificate)\n        assert cert.valid_principals == []\n        assert cert.extensions == {}\n        assert cert.critical_options == {}\n\n    def test_public_bytes(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\",\n                \"OpenSSH\",\n                \"certs\",\n                \"p256-p256-empty-principals.pub\",\n            ),\n            lambda f: f.read(),\n            mode=\"rb\",\n        )\n        cert = load_ssh_public_identity(data)\n        assert isinstance(cert, SSHCertificate)\n        assert data == cert.public_bytes()\n\n\nclass TestSSHCertificateBuilder:\n    def test_signs_a_cert(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        public_key = ec.generate_private_key(ec.SECP256R1()).public_key()\n        valid_after = datetime.datetime(\n            2023, 1, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n        valid_before = datetime.datetime(\n            2023, 6, 1, 1, tzinfo=datetime.timezone.utc\n        ).timestamp()\n        key_id = b\"test\"\n        valid_principals = [b\"eve\", b\"alice\"]\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(public_key)\n            .type(SSHCertificateType.USER)\n            .valid_before(valid_before)\n            .valid_after(valid_after)\n            .key_id(key_id)\n            .valid_principals(valid_principals)\n            .add_critical_option(b\"ordered\", b\"\")\n            .add_critical_option(b\"maybe\", b\"test2\")\n            .add_extension(b\"test\", b\"a value\")\n            .add_extension(b\"allowed\", b\"\")\n        )\n        cert = builder.sign(private_key)\n        cert.verify_cert_signature()\n        cert_public_key = cert.public_key()\n        assert isinstance(cert_public_key, ec.EllipticCurvePublicKey)\n        assert cert_public_key.public_numbers() == public_key.public_numbers()\n        assert cert.serial == 0\n        assert cert.type is SSHCertificateType.USER\n        assert cert.key_id == key_id\n        assert cert.valid_principals == valid_principals\n        assert cert.valid_before == int(valid_before)\n        assert cert.valid_after == int(valid_after)\n        assert cert.critical_options == {b\"ordered\": b\"\", b\"maybe\": b\"test2\"}\n        assert list(cert.critical_options) == [b\"maybe\", b\"ordered\"]\n        assert cert.extensions == {b\"test\": b\"a value\", b\"allowed\": b\"\"}\n        assert list(cert.extensions) == [b\"allowed\", b\"test\"]\n        signature_key = cert.signature_key()\n        assert isinstance(signature_key, ec.EllipticCurvePublicKey)\n        assert (\n            signature_key.public_numbers()\n            == private_key.public_key().public_numbers()\n        )\n\n    def test_public_key_errors(self):\n        public_key = ec.generate_private_key(ec.SECP256R1()).public_key()\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.public_key(\"not a key\")  # type: ignore[arg-type]\n        builder = builder.public_key(public_key)\n        with pytest.raises(ValueError):\n            builder.public_key(public_key)\n\n    def test_serial_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.serial(\"not a serial\")  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            builder.serial(-1)\n        with pytest.raises(ValueError):\n            builder.serial(2**64)\n        builder = builder.serial(1)\n        with pytest.raises(ValueError):\n            builder.serial(1)\n\n    def test_type_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.type(\"not a type\")  # type: ignore[arg-type]\n        builder = builder.type(SSHCertificateType.USER)\n        with pytest.raises(ValueError):\n            builder.type(SSHCertificateType.USER)\n\n    def test_key_id_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.key_id(\"not bytes\")  # type: ignore[arg-type]\n        builder = builder.key_id(b\"test\")\n        with pytest.raises(ValueError):\n            builder.key_id(b\"test\")\n\n    def test_valid_principals_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.valid_principals(\"not a list\")  # type: ignore[arg-type]\n        with pytest.raises(TypeError):\n            builder.valid_principals(\n                [b\"test\", \"not bytes\"]  # type: ignore[list-item]\n            )\n        with pytest.raises(TypeError):\n            builder.valid_principals([])\n        with pytest.raises(ValueError):\n            builder.valid_principals(\n                [b\"test\"] * (ssh._SSHKEY_CERT_MAX_PRINCIPALS + 1)\n            )\n        builder = builder.valid_principals([b\"test\"])\n        with pytest.raises(ValueError):\n            builder.valid_principals([b\"test\"])\n        with pytest.raises(ValueError):\n            builder.valid_for_all_principals()\n\n    def test_valid_for_all_principals_errors(self):\n        builder = SSHCertificateBuilder()\n        builder = builder.valid_for_all_principals()\n        with pytest.raises(ValueError):\n            builder.valid_for_all_principals()\n        with pytest.raises(ValueError):\n            builder.valid_principals([b\"test\"])\n\n    def test_valid_before_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.valid_before(\"not an int\")  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            builder.valid_before(-1)\n        with pytest.raises(ValueError):\n            builder.valid_after(2**64)\n        builder = builder.valid_before(12345)\n        with pytest.raises(ValueError):\n            builder.valid_before(123456)\n\n    def test_valid_after_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.valid_after(\"not an int\")  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            builder.valid_after(-1)\n        with pytest.raises(ValueError):\n            builder.valid_after(2**64)\n        builder = builder.valid_after(1234)\n        with pytest.raises(ValueError):\n            builder.valid_after(12345)\n\n    def test_add_critical_option_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.add_critical_option(\n                \"not bytes\",  # type: ignore[arg-type]\n                b\"test\",\n            )\n        with pytest.raises(TypeError):\n            builder.add_critical_option(\n                b\"test\",\n                object(),  # type: ignore[arg-type]\n            )\n        builder = builder.add_critical_option(b\"test\", b\"test\")\n        with pytest.raises(ValueError):\n            builder.add_critical_option(b\"test\", b\"test\")\n\n    def test_add_extension_errors(self):\n        builder = SSHCertificateBuilder()\n        with pytest.raises(TypeError):\n            builder.add_extension(\n                \"not bytes\",  # type: ignore[arg-type]\n                b\"test\",\n            )\n        with pytest.raises(TypeError):\n            builder.add_extension(b\"test\", object())  # type: ignore[arg-type]\n        builder = builder.add_extension(b\"test\", b\"test\")\n        with pytest.raises(ValueError):\n            builder.add_extension(b\"test\", b\"test\")\n\n    def test_sign_unsupported_key(self):\n        builder = (\n            SSHCertificateBuilder()\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(TypeError):\n            builder.sign(\"not a key\")\n\n    def test_sign_no_public_key(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_no_type(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_no_valid_principals(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_no_valid_after(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_no_valid_before(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_principals([b\"bob\"])\n            .valid_after(0)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_valid_after_after_valid_before(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_principals([b\"eve\"])\n            .valid_after(20)\n            .valid_before(0)\n            .type(SSHCertificateType.USER)\n        )\n        with pytest.raises(ValueError):\n            builder.sign(private_key)\n\n    def test_sign_non_zero_serial(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .serial(123456789)\n            .valid_principals([b\"alice\"])\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        cert = builder.sign(private_key)\n        assert cert.serial == 123456789\n\n    def test_crit_opts_exts_lexically_sorted(self):\n        private_key = ec.generate_private_key(ec.SECP256R1())\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n            .add_critical_option(b\"zebra@cryptography.io\", b\"\")\n            .add_critical_option(b\"apple@cryptography.io\", b\"\")\n            .add_critical_option(b\"banana@cryptography.io\", b\"\")\n            .add_extension(b\"zebra@cryptography.io\", b\"\")\n            .add_extension(b\"apple@cryptography.io\", b\"\")\n            .add_extension(b\"banana@cryptography.io\", b\"\")\n        )\n        cert = builder.sign(private_key)\n        # This returns a dict, but dicts are order preserving in\n        # all our supported versions of Python so we can use\n        # items to confirm the order.\n        assert list(cert.extensions.items()) == [\n            (b\"apple@cryptography.io\", b\"\"),\n            (b\"banana@cryptography.io\", b\"\"),\n            (b\"zebra@cryptography.io\", b\"\"),\n        ]\n        assert list(cert.critical_options.items()) == [\n            (b\"apple@cryptography.io\", b\"\"),\n            (b\"banana@cryptography.io\", b\"\"),\n            (b\"zebra@cryptography.io\", b\"\"),\n        ]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_sign_ed25519(self, backend):\n        private_key = ed25519.Ed25519PrivateKey.generate()\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        cert = builder.sign(private_key)\n        assert isinstance(cert.signature_key(), ed25519.Ed25519PublicKey)\n        cert.verify_cert_signature()\n\n    @pytest.mark.parametrize(\n        \"curve\", [ec.SECP256R1(), ec.SECP384R1(), ec.SECP521R1()]\n    )\n    def test_sign_ec(self, curve):\n        private_key = ec.generate_private_key(curve)\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        cert = builder.sign(private_key)\n        sig_key = cert.signature_key()\n        assert isinstance(sig_key, ec.EllipticCurvePublicKey)\n        assert isinstance(sig_key.curve, type(curve))\n        cert.verify_cert_signature()\n\n    def test_sign_rsa(self):\n        private_key = RSA_KEY_2048.private_key()\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(0)\n            .valid_before(2**64 - 1)\n            .type(SSHCertificateType.USER)\n        )\n        cert = builder.sign(private_key)\n        sig_key = cert.signature_key()\n        assert isinstance(sig_key, rsa.RSAPublicKey)\n        cert.verify_cert_signature()\n\n    def test_sign_and_byte_compare_rsa(self, monkeypatch):\n        # Monkey patch urandom to return a known value so we\n        # get a deterministic signature with RSA.\n        monkeypatch.setattr(os, \"urandom\", lambda _: b\"\\x00\" * 32)\n        private_key = RSA_KEY_2048.private_key()\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(1672531200)\n            .valid_before(1672617600)\n            .type(SSHCertificateType.USER)\n            .add_extension(b\"permit-pty\", b\"\")\n            .add_critical_option(\n                b\"force-command\", b\"echo aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n            )\n            .add_critical_option(b\"verify-required\", b\"\")\n        )\n        cert = builder.sign(private_key)\n        sig_key = cert.signature_key()\n        assert isinstance(sig_key, rsa.RSAPublicKey)\n        cert.verify_cert_signature()\n        assert cert.public_bytes() == (\n            b\"ssh-rsa-cert-v01@openssh.com AAAAHHNzaC1yc2EtY2VydC12MDFAb3Blbn\"\n            b\"NzaC5jb20AAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA\"\n            b\"QABAAABAQDBevx+d0dMqlqoMDYVij/797UhaFG6IjDl1qv8wcbP71npI+oTMLxZ\"\n            b\"O3OAKrYIpuSjMGUjoxFrpao5ZhRRdOE7bEnpt4Bi5EnXLvsQ/UnpH6CLltBR54L\"\n            b\"p9avFtab3mEgnrbjnPaAPIrLv3Nt26rRu2tmO1lZidD/cbA4zal0M26p9wp5TY1\"\n            b\"4kyHpbLEIVloBjzetoqXK6u8Hjz/APuagONypNDCySDR6M7jM85HDcLoFFrbBb8\"\n            b\"pruHSTxQejMeEmJxYf8b7rNl58/IWPB1ymbNlvHL/4oSOlnrtHkjcxRWzpQ7U3g\"\n            b\"T9BThGyhCiI7EMyEHMgP3r7kTzEUwT6IavWDAAAAAAAAAAAAAAABAAAAAAAAAAA\"\n            b\"AAAAAY7DNAAAAAABjsh6AAAAAWAAAAA1mb3JjZS1jb21tYW5kAAAALAAAAChlY2\"\n            b\"hvIGFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhAAAAD3Zlcmlme\"\n            b\"S1yZXF1aXJlZAAAAAAAAAASAAAACnBlcm1pdC1wdHkAAAAAAAAAAAAAARcAAAAH\"\n            b\"c3NoLXJzYQAAAAMBAAEAAAEBAMF6/H53R0yqWqgwNhWKP/v3tSFoUboiMOXWq/z\"\n            b\"Bxs/vWekj6hMwvFk7c4Aqtgim5KMwZSOjEWulqjlmFFF04TtsSem3gGLkSdcu+x\"\n            b\"D9SekfoIuW0FHngun1q8W1pveYSCetuOc9oA8isu/c23bqtG7a2Y7WVmJ0P9xsD\"\n            b\"jNqXQzbqn3CnlNjXiTIelssQhWWgGPN62ipcrq7wePP8A+5qA43Kk0MLJINHozu\"\n            b\"MzzkcNwugUWtsFvymu4dJPFB6Mx4SYnFh/xvus2Xnz8hY8HXKZs2W8cv/ihI6We\"\n            b\"u0eSNzFFbOlDtTeBP0FOEbKEKIjsQzIQcyA/evuRPMRTBPohq9YMAAAEUAAAADH\"\n            b\"JzYS1zaGEyLTUxMgAAAQCYbbNzhflDqZAxyBpdLIX0nLAdnTeFNBudMqgo3KGND\"\n            b\"WlU9N17hqBEmcvIOrtNi+JKuKZW89zZrbORHvdjv6NjGSKzJD/XA25YrX1KgMEO\"\n            b\"wt5pzMZX+100drwrjQo+vZqeIN3FJNmT3wssge73v+JsxQrdIAz7YM2OZrFr5HM\"\n            b\"qZEZ5tMvAf/s5YEMDttEU4zMtmjubQyDM5KyYnZdoDT4sKi2rB8gfaigc4IdI/K\"\n            b\"8oXL/3Y7rHuOtejl3lUK4v6DxeRl4aqGYWmhUJc++Rh0cbDgC2S6Cq7gAfG2tND\"\n            b\"zbwL217Q93R08bJn1hDWuiTiaHGauSy2gPUI+cnkvlEocHM\"\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Requires OpenSSL with Ed25519 support\",\n    )\n    def test_sign_and_byte_compare_ed25519(self, monkeypatch, backend):\n        # Monkey patch urandom to return a known value so we\n        # get a deterministic signature with Ed25519.\n        monkeypatch.setattr(os, \"urandom\", lambda _: b\"\\x00\" * 32)\n        private_key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8.pem\"),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read(), None, backend\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(private_key, ed25519.Ed25519PrivateKey)\n        builder = (\n            SSHCertificateBuilder()\n            .public_key(private_key.public_key())\n            .valid_for_all_principals()\n            .valid_after(1672531200)\n            .valid_before(1672617600)\n            .type(SSHCertificateType.USER)\n            .add_extension(b\"permit-pty\", b\"\")\n            .add_critical_option(\n                b\"force-command\", b\"echo aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n            )\n            .add_critical_option(b\"verify-required\", b\"\")\n        )\n        cert = builder.sign(private_key)\n        sig_key = cert.signature_key()\n        assert isinstance(sig_key, ed25519.Ed25519PublicKey)\n        cert.verify_cert_signature()\n        assert cert.public_bytes() == (\n            b\"ssh-ed25519-cert-v01@openssh.com AAAAIHNzaC1lZDI1NTE5LWNlcnQtdj\"\n            b\"AxQG9wZW5zc2guY29tAAAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n            b\"AAAAAAAINdamAGCsQq31Uv+08lkBzoO4XLz2qYjJa8CGmj3B1EaAAAAAAAAAAAA\"\n            b\"AAABAAAAAAAAAAAAAAAAY7DNAAAAAABjsh6AAAAAWAAAAA1mb3JjZS1jb21tYW5\"\n            b\"kAAAALAAAAChlY2hvIGFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYW\"\n            b\"FhAAAAD3ZlcmlmeS1yZXF1aXJlZAAAAAAAAAASAAAACnBlcm1pdC1wdHkAAAAAA\"\n            b\"AAAAAAAADMAAAALc3NoLWVkMjU1MTkAAAAg11qYAYKxCrfVS/7TyWQHOg7hcvPa\"\n            b\"piMlrwIaaPcHURoAAABTAAAAC3NzaC1lZDI1NTE5AAAAQL2aUjeD60C2FrbgHcN\"\n            b\"t8yRa8IRbxvOyA9TZYDGG1dRE3DiR0fuudU20v6vqfTd1gx0S5QyEdECXLl9ZI3\"\n            b\"AwZgc=\"\n        )\n\n\nclass TestSSHSK:\n    @staticmethod\n    def ssh_str(application):\n        data = (\n            len(application).to_bytes(length=4, byteorder=\"big\")\n            + application.encode()\n        )\n        return memoryview(data)\n\n    def test_load_application(self):\n        ssh.load_application(self.ssh_str(\"ssh:test\"))\n\n    def test_load_application_valueerror(self):\n        with pytest.raises(ValueError):\n            ssh.load_application(self.ssh_str(\"hss:test\"))\n", "tests/hazmat/primitives/test_serialization.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport base64\nimport itertools\nimport os\nimport textwrap\n\nimport pytest\n\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.hashes import SHA1\nfrom cryptography.hazmat.primitives.serialization import (\n    BestAvailableEncryption,\n    Encoding,\n    NoEncryption,\n    PrivateFormat,\n    PublicFormat,\n    load_der_parameters,\n    load_der_private_key,\n    load_der_public_key,\n    load_pem_parameters,\n    load_pem_private_key,\n    load_pem_public_key,\n)\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import PBES\n\nfrom ...utils import load_vectors_from_file\nfrom .test_ec import _skip_curve_unsupported\nfrom .test_rsa import rsa_key_2048\nfrom .utils import _check_dsa_private_numbers, _check_rsa_private_numbers\n\n# Make ruff happy since we're importing fixtures that pytest patches in as\n# func args\n__all__ = [\"rsa_key_2048\"]\n\n\ndef _skip_fips_format(key_path, password, backend):\n    if backend._fips_enabled:\n        if key_path[0] == \"Traditional_OpenSSL_Serialization\":\n            pytest.skip(\"Traditional OpenSSL format blocked in FIPS mode\")\n        if (\n            key_path[0] in (\"PEM_Serialization\", \"PKCS8\")\n            and password is not None\n        ):\n            pytest.skip(\n                \"The encrypted PEM vectors currently have encryption \"\n                \"that is not FIPS approved in the 3.0 provider\"\n            )\n        if key_path[0] == \"DER_Serialization\" and password is not None:\n            pytest.skip(\n                \"The encrypted PKCS8 DER vectors currently have encryption \"\n                \"that is not FIPS approved in the 3.0 provider\"\n            )\n\n\nclass TestBufferProtocolSerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"DER_Serialization\", \"enc-rsa-pkcs8.der\"], bytearray(b\"foobar\")),\n            ([\"DER_Serialization\", \"enc2-rsa-pkcs8.der\"], bytearray(b\"baz\")),\n            ([\"DER_Serialization\", \"unenc-rsa-pkcs8.der\"], None),\n            ([\"DER_Serialization\", \"testrsa.der\"], None),\n        ],\n    )\n    def test_load_der_rsa_private_key(self, key_path, password, backend):\n        _skip_fips_format(key_path, password, backend)\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        key = load_der_private_key(\n            bytearray(data), password, unsafe_skip_rsa_key_validation=True\n        )\n        assert key\n        assert isinstance(key, rsa.RSAPrivateKey)\n        _check_rsa_private_numbers(key.private_numbers())\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            (\n                [\"PEM_Serialization\", \"rsa_private_key.pem\"],\n                bytearray(b\"123456\"),\n            ),\n            ([\"PKCS8\", \"unenc-rsa-pkcs8.pem\"], None),\n            ([\"PKCS8\", \"enc-rsa-pkcs8.pem\"], bytearray(b\"foobar\")),\n            ([\"PKCS8\", \"enc2-rsa-pkcs8.pem\"], bytearray(b\"baz\")),\n            (\n                [\"Traditional_OpenSSL_Serialization\", \"key1.pem\"],\n                bytearray(b\"123456\"),\n            ),\n        ],\n    )\n    def test_load_pem_rsa_private_key(self, key_path, password, backend):\n        _skip_fips_format(key_path, password, backend)\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = load_pem_private_key(\n            bytearray(data), password, unsafe_skip_rsa_key_validation=True\n        )\n        assert key\n        assert isinstance(key, rsa.RSAPrivateKey)\n        _check_rsa_private_numbers(key.private_numbers())\n\n\nclass TestDERSerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"DER_Serialization\", \"enc-rsa-pkcs8.der\"], b\"foobar\"),\n            ([\"DER_Serialization\", \"enc2-rsa-pkcs8.der\"], b\"baz\"),\n            ([\"DER_Serialization\", \"unenc-rsa-pkcs8.der\"], None),\n            ([\"DER_Serialization\", \"testrsa.der\"], None),\n        ],\n    )\n    def test_load_der_rsa_private_key(self, key_path, password, backend):\n        _skip_fips_format(key_path, password, backend)\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda derfile: load_der_private_key(\n                derfile.read(), password, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert key\n        assert isinstance(key, rsa.RSAPrivateKey)\n        _check_rsa_private_numbers(key.private_numbers())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"DER_Serialization\", \"unenc-dsa-pkcs8.der\"], None),\n            ([\"DER_Serialization\", \"dsa.1024.der\"], None),\n            ([\"DER_Serialization\", \"dsa.2048.der\"], None),\n            ([\"DER_Serialization\", \"dsa.3072.der\"], None),\n        ],\n    )\n    def test_load_der_dsa_private_key(self, key_path, password, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda derfile: load_der_private_key(\n                derfile.read(), password, backend\n            ),\n            mode=\"rb\",\n        )\n        assert key\n        assert isinstance(key, dsa.DSAPrivateKey)\n        _check_dsa_private_numbers(key.private_numbers())\n\n    @pytest.mark.parametrize(\n        \"key_path\", [[\"DER_Serialization\", \"enc-rsa-pkcs8.der\"]]\n    )\n    def test_password_not_bytes(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = \"this password is not bytes\"\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda derfile: load_der_private_key(\n                    derfile.read(),\n                    password,  # type:ignore[arg-type]\n                    backend,\n                ),\n                mode=\"rb\",\n            )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"DER_Serialization\", \"ec_private_key.der\"], None),\n            ([\"DER_Serialization\", \"ec_private_key_encrypted.der\"], b\"123456\"),\n        ],\n    )\n    def test_load_der_ec_private_key(self, key_path, password, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda derfile: load_der_private_key(\n                derfile.read(), password, backend\n            ),\n            mode=\"rb\",\n        )\n\n        assert key\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        assert key.curve.name == \"secp256r1\"\n        assert key.curve.key_size == 256\n\n    @pytest.mark.parametrize(\n        \"key_path\", [[\"DER_Serialization\", \"enc-rsa-pkcs8.der\"]]\n    )\n    def test_wrong_password(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = b\"this password is wrong\"\n\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                key_file,\n                lambda derfile: load_der_private_key(\n                    derfile.read(), password, backend\n                ),\n                mode=\"rb\",\n            )\n\n    @pytest.mark.parametrize(\n        \"key_path\", [[\"DER_Serialization\", \"unenc-rsa-pkcs8.der\"]]\n    )\n    def test_unused_password(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = b\"this password will not be used\"\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda derfile: load_der_private_key(\n                    derfile.read(), password, backend\n                ),\n                mode=\"rb\",\n            )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        itertools.product(\n            [[\"DER_Serialization\", \"enc-rsa-pkcs8.der\"]], [b\"\", None]\n        ),\n    )\n    def test_missing_password(self, key_path, password, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda derfile: load_der_private_key(\n                    derfile.read(), password, backend\n                ),\n                mode=\"rb\",\n            )\n\n    def test_wrong_format(self, backend):\n        key_data = b\"---- NOT A KEY ----\\n\"\n\n        with pytest.raises(ValueError):\n            load_der_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_der_private_key(\n                key_data, b\"this password will not be used\", backend\n            )\n\n    def test_invalid_rsa_even_q(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"rsa-bad-1025-q-is-2.pem\"\n            ),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        with pytest.raises(ValueError):\n            load_pem_private_key(data, None)\n\n    def test_corrupt_der_pkcs8(self, backend):\n        # unenc-rsa-pkcs8 with a bunch of data missing.\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        MIICdQIBADALBgkqhkiG9w0BAQEEggJhMIICXQIBAAKBgQC7JHoJfg6yNzLMOWet\n        8Z49a4KD0dCspMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkk\n        FPZk/7x0xmdsTPECSWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAv\n        FiRC0Cgz+frQPFQEBsAV9RuasyQxqzxrR0Ow0qncBeGBWbYE6WZhqtcLAI895b+i\n        +F4lbB4iD7T9QeIDMU/aIMXA81UO4cns1z4qDAHKeyLLrPQrJ/B4X7XC+egUWm5+\n        hr1qmyAMusyXIBECQQDJWZ8piluf4yrYfsJAn6hF5T4RjTztbqvO0GVG2McHY7Uj\n        NPSffhzHx/ll0fQEQji+OgydCCX8o3HZrgw5YfSJAkEA7e+rqdU5nO5ZG//PSEQb\n        tjLnRiTzBH/elQhtdZ5nF7pcpNTi4k13zutmKcWW4GK75azcRGJUhu1kDM7QYAOd\n        SQJAVNkYcifkvna7GmooL5VYEsQsqLbM4v0NF2TIGNfG3z1MGp75KrC5LhL97MNR\n        we2p/bd2k0HYyCKUGnf2nMPDiQJBAI75pwittSoE240EobUGIDTSz8CJsXIxuDmL\n        z+KOpdpPRR5TQmbEMEspjsFpFymMiuYPgmihQbO2cJl1qScY5OkCQQCJ6m5tcN8l\n        Xxg/SNpjEIv+qAyUD96XVlOJlOIeLHQ8kYE0C6ZA+MsqYIzgAreJk88Yn0lU/X0/\n        mu/UpE/BRZmR\n        \"\"\"\n        ).encode()\n        bad_der = base64.b64decode(b\"\".join(key_data.splitlines()))\n\n        with pytest.raises(ValueError):\n            load_der_private_key(bad_der, None, backend)\n\n        with pytest.raises(ValueError):\n            load_der_private_key(\n                bad_der, b\"this password will not be used\", backend\n            )\n\n    def test_corrupt_traditional_format_der(self, backend):\n        # privkey with a bunch of data missing.\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        MIIBPAIBAAJBAKrbeqkuRk8VcRmWFmtP+LviMB3+6dizWW3DwaffznyHGAFwUJ/I\n        Tv0XtbsCyl3QoyKGhrOAy3RvPK5M38iuXT0CAwEAAQJAZ3cnzaHXM/bxGaR5CR1R\n        rD1qFBAVfoQFiOH9uPJgMaoAuoQEisPHVcZDKcOv4wEg6/TInAIXBnEigtqvRzuy\n        mvcpHZwQJdmdHHkGKAs37Dfxi67HbkUCIQCeZGliHXFa071Fp06ZeWlR2ADonTZz\n        rJBhdTe0v5pCeQIhAIZfkiGgGBX4cIuuckzEm43g9WMUjxP/0GlK39vIyihxAiEA\n        mymehFRT0MvqW5xAKAx7Pgkt8HVKwVhc2LwGKHE0DZM=\n        \"\"\"\n        ).encode()\n        bad_der = base64.b64decode(b\"\".join(key_data.splitlines()))\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(bad_der, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(\n                bad_der, b\"this password will not be used\", backend\n            )\n\n    @pytest.mark.parametrize(\n        \"key_file\",\n        [\n            os.path.join(\n                \"asymmetric\", \"DER_Serialization\", \"unenc-rsa-pkcs8.pub.der\"\n            ),\n            os.path.join(\n                \"asymmetric\", \"DER_Serialization\", \"rsa_public_key.der\"\n            ),\n            os.path.join(\"asymmetric\", \"public\", \"PKCS1\", \"rsa.pub.der\"),\n        ],\n    )\n    def test_load_der_rsa_public_key(self, key_file, backend):\n        key = load_vectors_from_file(\n            key_file,\n            lambda derfile: load_der_public_key(derfile.read(), backend),\n            mode=\"rb\",\n        )\n        assert key\n        assert isinstance(key, rsa.RSAPublicKey)\n        numbers = key.public_numbers()\n        assert numbers.e == 65537\n\n    def test_load_der_invalid_public_key(self, backend):\n        with pytest.raises(ValueError):\n            load_der_public_key(b\"invalid data\", backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        \"key_file\",\n        [\n            os.path.join(\n                \"asymmetric\", \"DER_Serialization\", \"unenc-dsa-pkcs8.pub.der\"\n            ),\n            os.path.join(\n                \"asymmetric\", \"DER_Serialization\", \"dsa_public_key.der\"\n            ),\n        ],\n    )\n    def test_load_der_dsa_public_key(self, key_file, backend):\n        key = load_vectors_from_file(\n            key_file,\n            lambda derfile: load_der_public_key(derfile.read(), backend),\n            mode=\"rb\",\n        )\n        assert key\n        assert isinstance(key, dsa.DSAPublicKey)\n\n    def test_load_ec_public_key(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"DER_Serialization\", \"ec_public_key.der\"\n            ),\n            lambda derfile: load_der_public_key(derfile.read(), backend),\n            mode=\"rb\",\n        )\n        assert key\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n        assert key.curve.name == \"secp256r1\"\n        assert key.curve.key_size == 256\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dh_supported(),\n        skip_message=\"DH not supported\",\n    )\n    def test_wrong_parameters_format(self, backend):\n        param_data = b\"---- NOT A KEY ----\\n\"\n\n        with pytest.raises(ValueError):\n            load_der_parameters(param_data, backend)\n\n\nclass TestPEMSerialization:\n    @pytest.mark.parametrize(\n        (\"key_file\", \"password\"),\n        [\n            ([\"PEM_Serialization\", \"rsa_private_key.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"unenc-rsa-pkcs8.pem\"], None),\n            ([\"PKCS8\", \"enc-rsa-pkcs8.pem\"], b\"foobar\"),\n            ([\"PKCS8\", \"enc2-rsa-pkcs8.pem\"], b\"baz\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9607.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9671.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9925.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9926.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9927.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9928.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9929.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9930.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9931.pem\"], b\"123456\"),\n            ([\"PKCS8\", \"pkcs12_s2k_pem-X_9932.pem\"], b\"123456\"),\n            ([\"Traditional_OpenSSL_Serialization\", \"key1.pem\"], b\"123456\"),\n            ([\"Traditional_OpenSSL_Serialization\", \"key2.pem\"], b\"a123456\"),\n            ([\"Traditional_OpenSSL_Serialization\", \"testrsa.pem\"], None),\n            (\n                [\"Traditional_OpenSSL_Serialization\", \"testrsa-encrypted.pem\"],\n                b\"password\",\n            ),\n        ],\n    )\n    def test_load_pem_rsa_private_key(self, key_file, password, backend):\n        _skip_fips_format(key_file, password, backend)\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_file),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(),\n                password,\n                unsafe_skip_rsa_key_validation=True,\n            ),\n        )\n\n        assert key\n        assert isinstance(key, rsa.RSAPrivateKey)\n        _check_rsa_private_numbers(key.private_numbers())\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.1024.pem\"], None),\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.2048.pem\"], None),\n            ([\"Traditional_OpenSSL_Serialization\", \"dsa.3072.pem\"], None),\n            ([\"PKCS8\", \"unenc-dsa-pkcs8.pem\"], None),\n            ([\"PEM_Serialization\", \"dsa_private_key.pem\"], b\"123456\"),\n        ],\n    )\n    def test_load_dsa_private_key(self, key_path, password, backend):\n        _skip_fips_format(key_path, password, backend)\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(), password, backend\n            ),\n        )\n        assert key\n        assert isinstance(key, dsa.DSAPrivateKey)\n        _check_dsa_private_numbers(key.private_numbers())\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        [\n            ([\"PKCS8\", \"ec_private_key.pem\"], None),\n            ([\"PKCS8\", \"ec_private_key_encrypted.pem\"], b\"123456\"),\n            ([\"PEM_Serialization\", \"ec_private_key.pem\"], None),\n            ([\"PEM_Serialization\", \"ec_private_key_encrypted.pem\"], b\"123456\"),\n        ],\n    )\n    def test_load_pem_ec_private_key(self, key_path, password, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        _skip_fips_format(key_path, password, backend)\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(), password, backend\n            ),\n        )\n\n        assert key\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        assert key.curve.name == \"secp256r1\"\n        assert key.curve.key_size == 256\n\n    @pytest.mark.parametrize(\n        (\"key_file\"),\n        [\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-rsa-pkcs8.pub.pem\"),\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"rsa_public_key.pem\"\n            ),\n            os.path.join(\"asymmetric\", \"public\", \"PKCS1\", \"rsa.pub.pem\"),\n            os.path.join(\n                \"asymmetric\",\n                \"PEM_Serialization\",\n                \"rsa_wrong_delimiter_public_key.pem\",\n            ),\n        ],\n    )\n    def test_load_pem_rsa_public_key(self, key_file, backend):\n        key = load_vectors_from_file(\n            key_file,\n            lambda pemfile: load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        assert key\n        assert isinstance(key, rsa.RSAPublicKey)\n        numbers = key.public_numbers()\n        assert numbers.e == 65537\n\n    def test_load_pem_public_fails_with_ec_key_with_rsa_delimiter(self):\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\",\n                    \"PEM_Serialization\",\n                    \"ec_public_key_rsa_delimiter.pem\",\n                ),\n                lambda pemfile: load_pem_public_key(pemfile.read().encode()),\n            )\n\n    def test_load_priv_key_with_public_key_api_fails(\n        self, rsa_key_2048, backend\n    ):\n        # In OpenSSL 3.0.x the PEM_read_bio_PUBKEY function will invoke\n        # the default password callback if you pass an encrypted private\n        # key. This is very, very, very bad as the default callback can\n        # trigger an interactive console prompt, which will hang the\n        # Python process. This test makes sure we don't do that.\n        priv_key_serialized = rsa_key_2048.private_bytes(\n            Encoding.PEM,\n            PrivateFormat.PKCS8,\n            BestAvailableEncryption(b\"password\"),\n        )\n        with pytest.raises(ValueError):\n            load_pem_public_key(priv_key_serialized)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    @pytest.mark.parametrize(\n        (\"key_file\"),\n        [\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pub.pem\"),\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"dsa_public_key.pem\"\n            ),\n        ],\n    )\n    def test_load_pem_dsa_public_key(self, key_file, backend):\n        key = load_vectors_from_file(\n            key_file,\n            lambda pemfile: load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        assert key\n        assert isinstance(key, dsa.DSAPublicKey)\n\n    def test_load_ec_public_key(self, backend):\n        _skip_curve_unsupported(backend, ec.SECP256R1())\n        key = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"PEM_Serialization\", \"ec_public_key.pem\"\n            ),\n            lambda pemfile: load_pem_public_key(\n                pemfile.read().encode(), backend\n            ),\n        )\n        assert key\n        assert isinstance(key, ec.EllipticCurvePublicKey)\n        assert key.curve.name == \"secp256r1\"\n        assert key.curve.key_size == 256\n\n    @pytest.mark.skip_fips(\n        reason=\"Traditional OpenSSL format blocked in FIPS mode\"\n    )\n    def test_rsa_traditional_encrypted_values(self, backend):\n        pkey = load_vectors_from_file(\n            os.path.join(\n                \"asymmetric\", \"Traditional_OpenSSL_Serialization\", \"key1.pem\"\n            ),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(),\n                b\"123456\",\n                unsafe_skip_rsa_key_validation=True,\n            ),\n        )\n        assert isinstance(pkey, rsa.RSAPrivateKey)\n\n        numbers = pkey.private_numbers()\n        assert numbers.p == int(\n            \"fb7d316fc51531b36d93adaefaf52db6ad5beb793d37c4cf9dfc1ddd17cfbafb\",\n            16,\n        )\n        assert numbers.q == int(\n            \"df98264e646de9a0fbeab094e31caad5bc7adceaaae3c800ca0275dd4bb307f5\",\n            16,\n        )\n        assert numbers.d == int(\n            \"db4848c36f478dd5d38f35ae519643b6b810d404bcb76c00e44015e56ca1cab0\"\n            \"7bb7ae91f6b4b43fcfc82a47d7ed55b8c575152116994c2ce5325ec24313b911\",\n            16,\n        )\n        assert numbers.dmp1 == int(\n            \"ce997f967192c2bcc3853186f1559fd355c190c58ddc15cbf5de9b6df954c727\",\n            16,\n        )\n        assert numbers.dmq1 == int(\n            \"b018a57ab20ffaa3862435445d863369b852cf70a67c55058213e3fe10e3848d\",\n            16,\n        )\n        assert numbers.iqmp == int(\n            \"6a8d830616924f5cf2d1bc1973f97fde6b63e052222ac7be06aa2532d10bac76\",\n            16,\n        )\n        assert numbers.public_numbers.e == 65537\n        assert numbers.public_numbers.n == int(\n            \"dba786074f2f0350ce1d99f5aed5b520cfe0deb5429ec8f2a88563763f566e77\"\n            \"9814b7c310e5326edae31198eed439b845dd2db99eaa60f5c16a43f4be6bcf37\",\n            16,\n        )\n\n    @pytest.mark.parametrize(\n        \"key_path\",\n        [\n            [\"Traditional_OpenSSL_Serialization\", \"testrsa.pem\"],\n            [\"PKCS8\", \"unenc-rsa-pkcs8.pem\"],\n        ],\n    )\n    def test_unused_password(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = b\"this password will not be used\"\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(), password, backend\n                ),\n            )\n\n    def test_invalid_encoding_with_traditional(self, backend):\n        key_file = os.path.join(\n            \"asymmetric\", \"Traditional_OpenSSL_Serialization\", \"testrsa.pem\"\n        )\n        key = load_vectors_from_file(\n            key_file,\n            lambda pemfile: load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n\n        for enc in (Encoding.OpenSSH, Encoding.Raw, Encoding.X962):\n            with pytest.raises(ValueError):\n                key.private_bytes(\n                    enc, PrivateFormat.TraditionalOpenSSL, NoEncryption()\n                )\n\n    @pytest.mark.parametrize(\n        \"key_path\",\n        [\n            [\"Traditional_OpenSSL_Serialization\", \"testrsa-encrypted.pem\"],\n            [\"PKCS8\", \"enc-rsa-pkcs8.pem\"],\n        ],\n    )\n    def test_password_not_bytes(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = \"this password is not bytes\"\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(),\n                    password,  # type:ignore[arg-type]\n                    backend,\n                ),\n            )\n\n    @pytest.mark.parametrize(\n        \"key_path\",\n        [\n            [\"Traditional_OpenSSL_Serialization\", \"testrsa-encrypted.pem\"],\n            [\"PKCS8\", \"enc-rsa-pkcs8.pem\"],\n        ],\n    )\n    def test_wrong_password(self, key_path, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n        password = b\"this password is wrong\"\n\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                key_file,\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(), password, backend\n                ),\n            )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"password\"),\n        itertools.product(\n            [\n                [\"Traditional_OpenSSL_Serialization\", \"testrsa-encrypted.pem\"],\n                [\"PKCS8\", \"enc-rsa-pkcs8.pem\"],\n            ],\n            [b\"\", None],\n        ),\n    )\n    def test_missing_password(self, key_path, password, backend):\n        key_file = os.path.join(\"asymmetric\", *key_path)\n\n        with pytest.raises(TypeError):\n            load_vectors_from_file(\n                key_file,\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(), password, backend\n                ),\n            )\n\n    def test_wrong_private_format(self, backend):\n        key_data = b\"---- NOT A KEY ----\\n\"\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(\n                key_data, b\"this password will not be used\", backend\n            )\n\n    def test_wrong_public_format(self, backend):\n        key_data = b\"---- NOT A KEY ----\\n\"\n\n        with pytest.raises(ValueError):\n            load_pem_public_key(key_data, backend)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dh_supported(),\n        skip_message=\"DH not supported\",\n    )\n    def test_wrong_parameters_format(self, backend):\n        param_data = b\"---- NOT A KEY ----\\n\"\n\n        with pytest.raises(ValueError):\n            load_pem_parameters(param_data, backend)\n\n    def test_corrupt_traditional_format(self, backend):\n        # privkey.pem with a bunch of data missing.\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        -----BEGIN RSA PRIVATE KEY-----\n        MIIBPAIBAAJBAKrbeqkuRk8VcRmWFmtP+LviMB3+6dizWW3DwaffznyHGAFwUJ/I\n        Tv0XtbsCyl3QoyKGhrOAy3RvPK5M38iuXT0CAwEAAQJAZ3cnzaHXM/bxGaR5CR1R\n        rD1qFBAVfoQFiOH9uPJgMaoAuoQEisPHVcZDKcOv4wEg6/TInAIXBnEigtqvRzuy\n        mvcpHZwQJdmdHHkGKAs37Dfxi67HbkUCIQCeZGliHXFa071Fp06ZeWlR2ADonTZz\n        rJBhdTe0v5pCeQIhAIZfkiGgGBX4cIuuckzEm43g9WMUjxP/0GlK39vIyihxAiEA\n        mymehFRT0MvqW5xAKAx7Pgkt8HVKwVhc2LwGKHE0DZM=\n        -----END RSA PRIVATE KEY-----\n        \"\"\"\n        ).encode()\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(\n                key_data, b\"this password will not be used\", backend\n            )\n\n    def test_traditional_encrypted_corrupt_format(self, backend):\n        # privkey.pem with a single bit flipped\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        -----BEGIN RSA PRIVATE KEY-----\n        Proc-Type: <,ENCRYPTED\n        DEK-Info: AES-128-CBC,5E22A2BD85A653FB7A3ED20DE84F54CD\n\n        hAqtb5ZkTMGcs4BBDQ1SKZzdQThWRDzEDxM3qBfjvYa35KxZ54aic013mW/lwj2I\n        v5bbpOjrHYHNAiZYZ7RNb+ztbF6F/g5PA5g7mFwEq+LFBY0InIplYBSv9QtE+lot\n        Dy4AlZa/+NzJwgdKDb+JVfk5SddyD4ywnyeORnMPy4xXKvjXwmW+iLibZVKsjIgw\n        H8hSxcD+FhWyJm9h9uLtmpuqhQo0jTUYpnTezZx2xeVPB53Ev7YCxR9Nsgj5GsVf\n        9Z/hqLB7IFgM3pa0z3PQeUIZF/cEf72fISWIOBwwkzVrPUkXWfbuWeJXQXSs3amE\n        5A295jD9BQp9CY0nNFSsy+qiXWToq2xT3y5zVNEStmN0SCGNaIlUnJzL9IHW+oMI\n        kPmXZMnAYBWeeCF1gf3J3aE5lZInegHNfEI0+J0LazC2aNU5Dg/BNqrmRqKWEIo/\n        -----END RSA PRIVATE KEY-----\n        \"\"\"\n        ).encode()\n\n        password = b\"this password is wrong\"\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, password, backend)\n\n    def test_unsupported_key_encryption(self, backend):\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        -----BEGIN RSA PRIVATE KEY-----\n        Proc-Type: 4,ENCRYPTED\n        DEK-Info: FAKE-123,5E22A2BD85A653FB7A3ED20DE84F54CD\n\n        hAqtb5ZkTMGcs4BBDQ1SKZzdQThWRDzEDxM3qBfjvYa35KxZ54aic013mW/lwj2I\n        v5bbpOjrHYHNAiZYZ7RNb+ztbF6F/g5PA5g7mFwEq+LFBY0InIplYBSv9QtE+lot\n        Dy4AlZa/+NzJwgdKDb+JVfk5SddyD4ywnyeORnMPy4xXKvjXwmW+iLibZVKsjIgw\n        H8hSxcD+FhWyJm9h9uLtmpuqhQo0jTUYpnTezZx2xeVPB53Ev7YCxR9Nsgj5GsVf\n        9Z/hqLB7IFgM3pa0z3PQeUIZF/cEf72fISWIOBwwkzVrPUkXWfbuWeJXQXSs3amE\n        5A295jD9BQp9CY0nNFSsy+qiXWToq2xT3y5zVNEStmN0SCGNaIlUnJzL9IHW+oMI\n        kPmXZMnAYBWeeCF1gf3J3aE5lZInegHNfEI0+J0LazC2aNU5Dg/BNqrmRqKWEIo/\n        -----END RSA PRIVATE KEY-----\n        \"\"\"\n        ).encode()\n\n        password = b\"password\"\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, password, backend)\n\n    def test_corrupt_pkcs8_format(self, backend):\n        # unenc-rsa-pkcs8.pem with a bunch of data missing.\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        -----BEGIN PRIVATE KEY-----\n        MIICdQIBADALBgkqhkiG9w0BAQEEggJhMIICXQIBAAKBgQC7JHoJfg6yNzLMOWet\n        8Z49a4KD0dCspMAYvo2YAMB7/wdEycocujbhJ2n/seONi+5XqTqqFkM5VBl8rmkk\n        FPZk/7x0xmdsTPECSWnHK+HhoaNDFPR3j8jQhVo1laxiqcEhAHegi5cwtFosuJAv\n        FiRC0Cgz+frQPFQEBsAV9RuasyQxqzxrR0Ow0qncBeGBWbYE6WZhqtcLAI895b+i\n        +F4lbB4iD7T9QeIDMU/aIMXA81UO4cns1z4qDAHKeyLLrPQrJ/B4X7XC+egUWm5+\n        hr1qmyAMusyXIBECQQDJWZ8piluf4yrYfsJAn6hF5T4RjTztbqvO0GVG2McHY7Uj\n        NPSffhzHx/ll0fQEQji+OgydCCX8o3HZrgw5YfSJAkEA7e+rqdU5nO5ZG//PSEQb\n        tjLnRiTzBH/elQhtdZ5nF7pcpNTi4k13zutmKcWW4GK75azcRGJUhu1kDM7QYAOd\n        SQJAVNkYcifkvna7GmooL5VYEsQsqLbM4v0NF2TIGNfG3z1MGp75KrC5LhL97MNR\n        we2p/bd2k0HYyCKUGnf2nMPDiQJBAI75pwittSoE240EobUGIDTSz8CJsXIxuDmL\n        z+KOpdpPRR5TQmbEMEspjsFpFymMiuYPgmihQbO2cJl1qScY5OkCQQCJ6m5tcN8l\n        Xxg/SNpjEIv+qAyUD96XVlOJlOIeLHQ8kYE0C6ZA+MsqYIzgAreJk88Yn0lU/X0/\n        mu/UpE/BRZmR\n        -----END PRIVATE KEY-----\n        \"\"\"\n        ).encode()\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(\n                key_data, b\"this password will not be used\", backend\n            )\n\n    def test_pks8_encrypted_corrupt_format(self, backend):\n        # enc-rsa-pkcs8.pem with some bits flipped.\n        key_data = textwrap.dedent(\n            \"\"\"\\\n        -----BEGIN ENCRYPTED PRIVATE KEY-----\n        MIICojAcBgoqhkiG9w0BDAEDMA4ECHK0M0+QuEL9AgIBIcSCAoDRq+KRY+0XP0tO\n        lwBTzViiXSXoyNnKAZKt5r5K/fGNntv22g/1s/ZNCetrqsJDC5eMUPPacz06jFq/\n        Ipsep4/OgjQ9UAOzXNrWEoNyrHnWDo7usgD3CW0mKyqER4+wG0adVMbt3N+CJHGB\n        85jzRmQTfkdx1rSWeSx+XyswHn8ER4+hQ+omKWMVm7AFkjjmP/KnhUnLT98J8rhU\n        ArQoFPHz/6HVkypFccNaPPNg6IA4aS2A+TU9vJYOaXSVfFB2yf99hfYYzC+ukmuU\n        5Lun0cysK5s/5uSwDueUmDQKspnaNyiaMGDxvw8hilJc7vg0fGObfnbIpizhxJwq\n        gKBfR7Zt0Hv8OYi1He4MehfMGdbHskztF+yQ40LplBGXQrvAqpU4zShga1BoQ98T\n        0ekbBmqj7hg47VFsppXR7DKhx7G7rpMmdKbFhAZVCjae7rRGpUtD52cpFdPhMyAX\n        huhMkoczwUW8B/rM4272lkHo6Br0yk/TQfTEGkvryflNVu6lniPTV151WV5U1M3o\n        3G3a44eDyt7Ln+WSOpWtbPQMTrpKhur6WXgJvrpa/m02oOGdvOlDsoOCgavgQMWg\n        7xKKL7620pHl7p7f/8tlE8q6vLXVvyNtAOgt/JAr2rgvrHaZSzDE0DwgCjBXEm+7\n        cVMVNkHod7bLQefVanVtWqPzbmr8f7gKeuGwWSG9oew/lN2hxcLEPJHAQlnLgx3P\n        0GdGjK9NvwA0EP2gYIeE4+UtSder7xQ7bVh25VB20R4TTIIs4aXXCVOoQPagnzaT\n        6JLgl8FrvdfjHwIvmSOO1YMNmILBq000Q8WDqyErBDs4hsvtO6VQ4LeqJj6gClX3\n        qeJNaJFu\n        -----END ENCRYPTED PRIVATE KEY-----\n        \"\"\"\n        ).encode()\n\n        password = b\"this password is wrong\"\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, None, backend)\n\n        with pytest.raises(ValueError):\n            load_pem_private_key(key_data, password, backend)\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    def test_rsa_pkcs8_encrypted_values(self, backend):\n        pkey = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"enc-rsa-pkcs8.pem\"),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(),\n                b\"foobar\",\n                unsafe_skip_rsa_key_validation=True,\n            ),\n        )\n        assert isinstance(pkey, rsa.RSAPrivateKey)\n\n        numbers = pkey.private_numbers()\n\n        assert numbers.public_numbers.n == int(\n            \"00beec64d6db5760ac2fd4c971145641b9bd7f5c56558ece608795c79807\"\n            \"376a7fe5b19f95b35ca358ea5c8abd7ae051d49cd2f1e45969a1ae945460\"\n            \"3c14b278664a0e414ebc8913acb6203626985525e17a600611b028542dd0\"\n            \"562aad787fb4f1650aa318cdcff751e1b187cbf6785fbe164e9809491b95\"\n            \"dd68480567c99b1a57\",\n            16,\n        )\n\n        assert numbers.public_numbers.e == 65537\n\n        assert numbers.d == int(\n            \"0cfe316e9dc6b8817f4fcfd5ae38a0886f68f773b8a6db4c9e6d8703c599\"\n            \"f3d9785c3a2c09e4c8090909fb3721e19a3009ec21221523a729265707a5\"\n            \"8f13063671c42a4096cad378ef2510cb59e23071489d8893ac4934dd149f\"\n            \"34f2d094bea57f1c8027c3a77248ac9b91218737d0c3c3dfa7d7829e6977\"\n            \"cf7d995688c86c81\",\n            16,\n        )\n\n        assert numbers.p == int(\n            \"00db122ac857b2c0437d7616daa98e597bb75ca9ad3a47a70bec10c10036\"\n            \"03328794b225c8e3eee6ffd3fd6d2253d28e071fe27d629ab072faa14377\"\n            \"ce6118cb67\",\n            16,\n        )\n\n        assert numbers.q == int(\n            \"00df1b8aa8506fcbbbb9d00257f2975e38b33d2698fd0f37e82d7ef38c56\"\n            \"f21b6ced63c825383782a7115cfcc093300987dbd2853b518d1c8f26382a\"\n            \"2d2586d391\",\n            16,\n        )\n\n        assert numbers.dmp1 == int(\n            \"00be18aca13e60712fdf5daa85421eb10d86d654b269e1255656194fb0c4\"\n            \"2dd01a1070ea12c19f5c39e09587af02f7b1a1030d016a9ffabf3b36d699\"\n            \"ceaf38d9bf\",\n            16,\n        )\n\n        assert numbers.dmq1 == int(\n            \"71aa8978f90a0c050744b77cf1263725b203ac9f730606d8ae1d289dce4a\"\n            \"28b8d534e9ea347aeb808c73107e583eb80c546d2bddadcdb3c82693a4c1\"\n            \"3d863451\",\n            16,\n        )\n\n        assert numbers.iqmp == int(\n            \"136b7b1afac6e6279f71b24217b7083485a5e827d156024609dae39d48a6\"\n            \"bdb55af2f062cc4a3b077434e6fffad5faa29a2b5dba2bed3e4621e478c0\"\n            \"97ccfe7f\",\n            16,\n        )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.dsa_supported(),\n        skip_message=\"Does not support DSA.\",\n    )\n    def test_load_pem_dsa_private_key(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        assert key\n        assert isinstance(key, dsa.DSAPrivateKey)\n\n        params = key.parameters()\n        assert isinstance(params, dsa.DSAParameters)\n\n        num = key.private_numbers()\n        pub = num.public_numbers\n        parameter_numbers = pub.parameter_numbers\n        assert num.x == int(\"00a535a8e1d0d91beafc8bee1d9b2a3a8de3311203\", 16)\n        assert pub.y == int(\n            \"2b260ea97dc6a12ae932c640e7df3d8ff04a8a05a0324f8d5f1b23f15fa1\"\n            \"70ff3f42061124eff2586cb11b49a82dcdc1b90fc6a84fb10109cb67db5d\"\n            \"2da971aeaf17be5e37284563e4c64d9e5fc8480258b319f0de29d54d8350\"\n            \"70d9e287914d77df81491f4423b62da984eb3f45eb2a29fcea5dae525ac6\"\n            \"ab6bcce04bfdf5b6\",\n            16,\n        )\n\n        assert parameter_numbers.p == int(\n            \"00aa0930cc145825221caffa28ac2894196a27833de5ec21270791689420\"\n            \"7774a2e7b238b0d36f1b2499a2c2585083eb01432924418d867faa212dd1\"\n            \"071d4dceb2782794ad393cc08a4d4ada7f68d6e839a5fcd34b4e402d82cb\"\n            \"8a8cb40fec31911bf9bd360b034caacb4c5e947992573c9e90099c1b0f05\"\n            \"940cabe5d2de49a167\",\n            16,\n        )\n\n        assert parameter_numbers.q == int(\n            \"00adc0e869b36f0ac013a681fdf4d4899d69820451\", 16\n        )\n\n        assert parameter_numbers.g == int(\n            \"008c6b4589afa53a4d1048bfc346d1f386ca75521ccf72ddaa251286880e\"\n            \"e13201ff48890bbfc33d79bacaec71e7a778507bd5f1a66422e39415be03\"\n            \"e71141ba324f5b93131929182c88a9fa4062836066cebe74b5c6690c7d10\"\n            \"1106c240ab7ebd54e4e3301fd086ce6adac922fb2713a2b0887cba13b9bc\"\n            \"68ce5cfff241cd3246\",\n            16,\n        )\n\n    @pytest.mark.parametrize(\n        (\"key_file\", \"password\"), [(\"bad-oid-dsa-key.pem\", None)]\n    )\n    def test_load_bad_oid_key(self, key_file, password, backend):\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"PKCS8\", key_file),\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(), password, backend\n                ),\n            )\n\n    @pytest.mark.parametrize(\n        (\"key_file\", \"password\"), [(\"bad-encryption-oid.pem\", b\"password\")]\n    )\n    def test_load_bad_encryption_oid_key(self, key_file, password, backend):\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                os.path.join(\"asymmetric\", \"PKCS8\", key_file),\n                lambda pemfile: load_pem_private_key(\n                    pemfile.read().encode(), password, backend\n                ),\n            )\n\n\nclass TestKeySerializationEncryptionTypes:\n    def test_non_bytes_password(self):\n        with pytest.raises(ValueError):\n            BestAvailableEncryption(object())  # type:ignore[arg-type]\n\n    def test_encryption_with_zero_length_password(self):\n        with pytest.raises(ValueError):\n            BestAvailableEncryption(b\"\")\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed25519_supported(),\n    skip_message=\"Requires OpenSSL with Ed25519 support\",\n)\nclass TestEd25519Serialization:\n    def test_load_der_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8-enc.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        key = load_der_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.DER, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    def test_load_pem_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8-enc.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed25519\", \"ed25519-pkcs8.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = load_pem_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader\"),\n        [\n            (\n                [\"Ed25519\", \"ed25519-pub.pem\"],\n                Encoding.PEM,\n                load_pem_public_key,\n            ),\n            (\n                [\"Ed25519\", \"ed25519-pub.der\"],\n                Encoding.DER,\n                load_der_public_key,\n            ),\n        ],\n    )\n    def test_load_public_key(self, key_path, encoding, loader, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        public_key = loader(data, backend)\n        assert (\n            public_key.public_bytes(\n                encoding, PublicFormat.SubjectPublicKeyInfo\n            )\n            == data\n        )\n\n    def test_openssl_serialization_unsupported(self, backend):\n        key = ed25519.Ed25519PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.DER,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x448_supported(),\n    skip_message=\"Requires OpenSSL with X448 support\",\n)\nclass TestX448Serialization:\n    def test_load_der_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8-enc.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        key = load_der_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.DER, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    def test_load_pem_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8-enc.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X448\", \"x448-pkcs8.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = load_pem_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader\"),\n        [\n            ([\"X448\", \"x448-pub.pem\"], Encoding.PEM, load_pem_public_key),\n            ([\"X448\", \"x448-pub.der\"], Encoding.DER, load_der_public_key),\n        ],\n    )\n    def test_load_public_key(self, key_path, encoding, loader, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        public_key = loader(data, backend)\n        assert (\n            public_key.public_bytes(\n                encoding, PublicFormat.SubjectPublicKeyInfo\n            )\n            == data\n        )\n\n    def test_openssl_serialization_unsupported(self, backend):\n        key = x448.X448PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.DER,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n\n    def test_openssh_serialization_unsupported(self, backend):\n        key = x448.X448PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.OpenSSH, NoEncryption()\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.x25519_supported(),\n    skip_message=\"Requires OpenSSL with X25519 support\",\n)\nclass TestX25519Serialization:\n    def test_load_der_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8-enc.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        key = load_der_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.DER, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    def test_load_pem_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8-enc.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"X25519\", \"x25519-pkcs8.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = load_pem_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader\"),\n        [\n            ([\"X25519\", \"x25519-pub.pem\"], Encoding.PEM, load_pem_public_key),\n            ([\"X25519\", \"x25519-pub.der\"], Encoding.DER, load_der_public_key),\n        ],\n    )\n    def test_load_public_key(self, key_path, encoding, loader, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        public_key = loader(data, backend)\n        assert (\n            public_key.public_bytes(\n                encoding, PublicFormat.SubjectPublicKeyInfo\n            )\n            == data\n        )\n\n    def test_openssl_serialization_unsupported(self, backend):\n        key = x25519.X25519PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.DER,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n\n    def test_openssh_serialization_unsupported(self, backend):\n        key = x25519.X25519PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.public_key().public_bytes(\n                Encoding.OpenSSH, PublicFormat.OpenSSH\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.OpenSSH, NoEncryption()\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.ed448_supported(),\n    skip_message=\"Requires OpenSSL with Ed448 support\",\n)\nclass TestEd448Serialization:\n    def test_load_der_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8-enc.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8.der\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        key = load_der_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.DER, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    def test_load_pem_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8-enc.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        unencrypted = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"Ed448\", \"ed448-pkcs8.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = load_pem_private_key(data, b\"password\", backend)\n        assert (\n            key.private_bytes(\n                Encoding.PEM, PrivateFormat.PKCS8, NoEncryption()\n            )\n            == unencrypted\n        )\n\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader\"),\n        [\n            ([\"Ed448\", \"ed448-pub.pem\"], Encoding.PEM, load_pem_public_key),\n            ([\"Ed448\", \"ed448-pub.der\"], Encoding.DER, load_der_public_key),\n        ],\n    )\n    def test_load_public_key(self, key_path, encoding, loader, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", *key_path),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        public_key = loader(data, backend)\n        assert (\n            public_key.public_bytes(\n                encoding, PublicFormat.SubjectPublicKeyInfo\n            )\n            == data\n        )\n\n    def test_openssl_serialization_unsupported(self, backend):\n        key = ed448.Ed448PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.DER,\n                PrivateFormat.TraditionalOpenSSL,\n                NoEncryption(),\n            )\n\n    def test_openssh_serialization_unsupported(self, backend):\n        key = ed448.Ed448PrivateKey.generate()\n        with pytest.raises(ValueError):\n            key.public_key().public_bytes(\n                Encoding.OpenSSH,\n                PublicFormat.OpenSSH,\n            )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                Encoding.PEM,\n                PrivateFormat.OpenSSH,\n                NoEncryption(),\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"DH not supported\",\n)\nclass TestDHSerialization:\n    \"\"\"Test all options with least-supported key type.\"\"\"\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    def test_dh_public_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dhkey.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        public_key = load_pem_private_key(data, None, backend).public_key()\n        for enc in (\n            Encoding.PEM,\n            Encoding.DER,\n            Encoding.OpenSSH,\n            Encoding.Raw,\n            Encoding.X962,\n        ):\n            for fmt in (\n                PublicFormat.SubjectPublicKeyInfo,\n                PublicFormat.PKCS1,\n                PublicFormat.OpenSSH,\n                PublicFormat.Raw,\n                PublicFormat.CompressedPoint,\n                PublicFormat.UncompressedPoint,\n            ):\n                if (\n                    enc in (Encoding.PEM, Encoding.DER)\n                    and fmt == PublicFormat.SubjectPublicKeyInfo\n                ):\n                    # tested elsewhere\n                    continue\n                with pytest.raises(ValueError):\n                    public_key.public_bytes(enc, fmt)\n\n    @pytest.mark.skip_fips(reason=\"non-FIPS parameters\")\n    def test_dh_private_key(self, backend):\n        data = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DH\", \"dhkey.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        private_key = load_pem_private_key(data, None, backend)\n        for enc in (\n            Encoding.PEM,\n            Encoding.DER,\n            Encoding.OpenSSH,\n            Encoding.Raw,\n            Encoding.X962,\n        ):\n            for fmt in (\n                PrivateFormat.PKCS8,\n                PrivateFormat.TraditionalOpenSSL,\n                PrivateFormat.Raw,\n            ):\n                if (\n                    enc in (Encoding.PEM, Encoding.DER)\n                    and fmt is PrivateFormat.PKCS8\n                ):\n                    # tested elsewhere\n                    continue\n                with pytest.raises(ValueError):\n                    private_key.private_bytes(enc, fmt, NoEncryption())\n\n\nclass TestEncryptionBuilder:\n    def test_unsupported_format(self):\n        f = PrivateFormat.PKCS8\n        with pytest.raises(ValueError):\n            f.encryption_builder()\n\n    def test_duplicate_kdf_rounds(self):\n        b = PrivateFormat.OpenSSH.encryption_builder().kdf_rounds(12)\n        with pytest.raises(ValueError):\n            b.kdf_rounds(12)\n\n    def test_invalid_kdf_rounds(self):\n        b = PrivateFormat.OpenSSH.encryption_builder()\n        with pytest.raises(ValueError):\n            b.kdf_rounds(0)\n        with pytest.raises(ValueError):\n            b.kdf_rounds(-1)\n        with pytest.raises(TypeError):\n            b.kdf_rounds(\"string\")  # type: ignore[arg-type]\n\n    def test_invalid_password(self):\n        b = PrivateFormat.OpenSSH.encryption_builder()\n        with pytest.raises(ValueError):\n            b.build(12)  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            b.build(b\"\")\n\n    def test_unsupported_type_for_methods(self):\n        b = PrivateFormat.OpenSSH.encryption_builder()\n        with pytest.raises(TypeError):\n            b.key_cert_algorithm(PBES.PBESv1SHA1And3KeyTripleDESCBC)\n        with pytest.raises(TypeError):\n            b.hmac_hash(SHA1())\n\n    def test_duplicate_hmac_hash(self):\n        b = PrivateFormat.PKCS12.encryption_builder().hmac_hash(SHA1())\n        with pytest.raises(ValueError):\n            b.hmac_hash(SHA1())\n\n    def test_duplicate_key_cert_algorithm(self):\n        b = PrivateFormat.PKCS12.encryption_builder().key_cert_algorithm(\n            PBES.PBESv1SHA1And3KeyTripleDESCBC\n        )\n        with pytest.raises(ValueError):\n            b.key_cert_algorithm(PBES.PBESv1SHA1And3KeyTripleDESCBC)\n", "tests/hazmat/primitives/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/hazmat/primitives/test_hash_vectors.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\n\nfrom ...utils import load_hash_vectors, load_nist_vectors\nfrom .utils import _load_all_params, generate_hash_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA1()),\n    skip_message=\"Does not support SHA1\",\n)\nclass TestSHA1:\n    test_sha1 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA1\"),\n        [\"SHA1LongMsg.rsp\", \"SHA1ShortMsg.rsp\"],\n        hashes.SHA1(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA224()),\n    skip_message=\"Does not support SHA224\",\n)\nclass TestSHA224:\n    test_sha224 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA224LongMsg.rsp\", \"SHA224ShortMsg.rsp\"],\n        hashes.SHA224(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA256()),\n    skip_message=\"Does not support SHA256\",\n)\nclass TestSHA256:\n    test_sha256 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA256LongMsg.rsp\", \"SHA256ShortMsg.rsp\"],\n        hashes.SHA256(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA384()),\n    skip_message=\"Does not support SHA384\",\n)\nclass TestSHA384:\n    test_sha384 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA384LongMsg.rsp\", \"SHA384ShortMsg.rsp\"],\n        hashes.SHA384(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA512()),\n    skip_message=\"Does not support SHA512\",\n)\nclass TestSHA512:\n    test_sha512 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA512LongMsg.rsp\", \"SHA512ShortMsg.rsp\"],\n        hashes.SHA512(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA512_224()),\n    skip_message=\"Does not support SHA512/224\",\n)\nclass TestSHA512224:\n    test_sha512_224 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA512_224LongMsg.rsp\", \"SHA512_224ShortMsg.rsp\"],\n        hashes.SHA512_224(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA512_256()),\n    skip_message=\"Does not support SHA512/256\",\n)\nclass TestSHA512256:\n    test_sha512_256 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA2\"),\n        [\"SHA512_256LongMsg.rsp\", \"SHA512_256ShortMsg.rsp\"],\n        hashes.SHA512_256(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.MD5()),\n    skip_message=\"Does not support MD5\",\n)\nclass TestMD5:\n    test_md5 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"MD5\"),\n        [\"rfc-1321.txt\"],\n        hashes.MD5(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.BLAKE2b(digest_size=64)\n    ),\n    skip_message=\"Does not support BLAKE2b\",\n)\nclass TestBLAKE2b:\n    test_b2b = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"blake2\"),\n        [\"blake2b.txt\"],\n        hashes.BLAKE2b(digest_size=64),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.BLAKE2s(digest_size=32)\n    ),\n    skip_message=\"Does not support BLAKE2s\",\n)\nclass TestBLAKE2s256:\n    test_b2s = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"blake2\"),\n        [\"blake2s.txt\"],\n        hashes.BLAKE2s(digest_size=32),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA3_224()),\n    skip_message=\"Does not support SHA3_224\",\n)\nclass TestSHA3224:\n    test_sha3_224 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA3\"),\n        [\"SHA3_224LongMsg.rsp\", \"SHA3_224ShortMsg.rsp\"],\n        hashes.SHA3_224(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA3_256()),\n    skip_message=\"Does not support SHA3_256\",\n)\nclass TestSHA3256:\n    test_sha3_256 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA3\"),\n        [\"SHA3_256LongMsg.rsp\", \"SHA3_256ShortMsg.rsp\"],\n        hashes.SHA3_256(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA3_384()),\n    skip_message=\"Does not support SHA3_384\",\n)\nclass TestSHA3384:\n    test_sha3_384 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA3\"),\n        [\"SHA3_384LongMsg.rsp\", \"SHA3_384ShortMsg.rsp\"],\n        hashes.SHA3_384(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SHA3_512()),\n    skip_message=\"Does not support SHA3_512\",\n)\nclass TestSHA3512:\n    test_sha3_512 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHA3\"),\n        [\"SHA3_512LongMsg.rsp\", \"SHA3_512ShortMsg.rsp\"],\n        hashes.SHA3_512(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.SHAKE128(digest_size=16)\n    ),\n    skip_message=\"Does not support SHAKE128\",\n)\nclass TestSHAKE128:\n    test_shake128 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHAKE\"),\n        [\"SHAKE128LongMsg.rsp\", \"SHAKE128ShortMsg.rsp\"],\n        hashes.SHAKE128(digest_size=16),\n    )\n\n    def test_shake128_variable(self, backend, subtests):\n        vectors = _load_all_params(\n            os.path.join(\"hashes\", \"SHAKE\"),\n            [\"SHAKE128VariableOut.rsp\"],\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                output_length = int(vector[\"outputlen\"]) // 8\n                msg = binascii.unhexlify(vector[\"msg\"])\n                shake = hashes.SHAKE128(digest_size=output_length)\n                m = hashes.Hash(shake, backend=backend)\n                m.update(msg)\n                assert m.finalize() == binascii.unhexlify(vector[\"output\"])\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(\n        hashes.SHAKE256(digest_size=32)\n    ),\n    skip_message=\"Does not support SHAKE256\",\n)\nclass TestSHAKE256:\n    test_shake256 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SHAKE\"),\n        [\"SHAKE256LongMsg.rsp\", \"SHAKE256ShortMsg.rsp\"],\n        hashes.SHAKE256(digest_size=32),\n    )\n\n    def test_shake256_variable(self, backend, subtests):\n        vectors = _load_all_params(\n            os.path.join(\"hashes\", \"SHAKE\"),\n            [\"SHAKE256VariableOut.rsp\"],\n            load_nist_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                output_length = int(vector[\"outputlen\"]) // 8\n                msg = binascii.unhexlify(vector[\"msg\"])\n                shake = hashes.SHAKE256(digest_size=output_length)\n                m = hashes.Hash(shake, backend=backend)\n                m.update(msg)\n                assert m.finalize() == binascii.unhexlify(vector[\"output\"])\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hash_supported(hashes.SM3()),\n    skip_message=\"Does not support SM3\",\n)\nclass TestSM3:\n    test_sm3 = generate_hash_test(\n        load_hash_vectors,\n        os.path.join(\"hashes\", \"SM3\"),\n        [\"oscca.txt\"],\n        hashes.SM3(),\n    )\n", "tests/hazmat/primitives/test_hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\n\nimport pytest\n\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidSignature,\n    _Reasons,\n)\nfrom cryptography.hazmat.primitives import hashes, hmac\n\nfrom ...doubles import DummyHashAlgorithm\nfrom ...utils import raises_unsupported_algorithm\nfrom .utils import generate_base_hmac_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.MD5()),\n    skip_message=\"Does not support MD5\",\n)\nclass TestHMACCopy:\n    test_copy = generate_base_hmac_test(\n        hashes.MD5(),\n    )\n\n\nclass TestHMAC:\n    def test_hmac_reject_unicode(self, backend):\n        h = hmac.HMAC(b\"mykey\", hashes.SHA1(), backend=backend)\n        with pytest.raises(TypeError):\n            h.update(\"\\u00fc\")  # type: ignore[arg-type]\n\n    def test_hmac_algorithm_instance(self, backend):\n        with pytest.raises(TypeError):\n            hmac.HMAC(\n                b\"key\",\n                hashes.SHA1,  # type: ignore[arg-type]\n                backend=backend,\n            )\n\n    def test_raises_after_finalize(self, backend):\n        h = hmac.HMAC(b\"key\", hashes.SHA1(), backend=backend)\n        h.finalize()\n\n        with pytest.raises(AlreadyFinalized):\n            h.update(b\"foo\")\n\n        with pytest.raises(AlreadyFinalized):\n            h.copy()\n\n        with pytest.raises(AlreadyFinalized):\n            h.finalize()\n\n    def test_verify(self, backend):\n        h = hmac.HMAC(b\"\", hashes.SHA1(), backend=backend)\n        digest = h.finalize()\n\n        h = hmac.HMAC(b\"\", hashes.SHA1(), backend=backend)\n        h.verify(digest)\n\n        with pytest.raises(AlreadyFinalized):\n            h.verify(b\"\")\n\n    def test_invalid_verify(self, backend):\n        h = hmac.HMAC(b\"\", hashes.SHA1(), backend=backend)\n        with pytest.raises(InvalidSignature):\n            h.verify(b\"\")\n\n        with pytest.raises(AlreadyFinalized):\n            h.verify(b\"\")\n\n    def test_verify_reject_unicode(self, backend):\n        h = hmac.HMAC(b\"\", hashes.SHA1(), backend=backend)\n        with pytest.raises(TypeError):\n            h.verify(\"\")  # type: ignore[arg-type]\n\n    def test_unsupported_hash(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            hmac.HMAC(b\"key\", DummyHashAlgorithm(), backend)\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_HASH):\n            hmac.HMAC(b\"key\", hashes.SHAKE256(digest_size=256), backend)\n\n    def test_buffer_protocol(self, backend):\n        key = bytearray(b\"2b7e151628aed2a6abf7158809cf4f3c\")\n        h = hmac.HMAC(key, hashes.SHA256(), backend)\n        h.update(bytearray(b\"6bc1bee22e409f96e93d7e117393172a\"))\n        assert h.finalize() == binascii.unhexlify(\n            b\"a1bf7169c56a501c6585190ff4f07cad6e492a3ee187c0372614fb444b9fc3f0\"\n        )\n\n    def test_algorithm(self):\n        alg = hashes.SHA256()\n        h = hmac.HMAC(b\"123456\", alg)\n        assert h.algorithm is alg\n", "tests/hazmat/primitives/test_scrypt.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives.kdf.scrypt import _MEM_LIMIT, Scrypt\nfrom tests.utils import (\n    load_nist_vectors,\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\nvectors = load_vectors_from_file(\n    os.path.join(\"KDF\", \"scrypt.txt\"), load_nist_vectors\n)\n\n\ndef _skip_if_memory_limited(memory_limit, params):\n    # Memory calc adapted from OpenSSL (URL split over 2 lines, thanks PEP8)\n    # https://github.com/openssl/openssl/blob/6286757141a8c6e14d647ec733634a\n    # e0c83d9887/crypto/evp/scrypt.c#L189-L221\n    blen = int(params[\"p\"]) * 128 * int(params[\"r\"])\n    vlen = 32 * int(params[\"r\"]) * (int(params[\"n\"]) + 2) * 4\n    memory_required = blen + vlen\n    if memory_limit < memory_required:\n        pytest.skip(\n            \"Test exceeds Scrypt memory limit. \"\n            \"This is likely a 32-bit platform.\"\n        )\n\n\ndef test_memory_limit_skip():\n    with pytest.raises(pytest.skip.Exception):\n        _skip_if_memory_limited(1000, {\"p\": 16, \"r\": 64, \"n\": 1024})\n\n    _skip_if_memory_limited(2**31, {\"p\": 16, \"r\": 64, \"n\": 1024})\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.scrypt_supported(),\n    skip_message=\"Supports scrypt so can't test unsupported path\",\n)\ndef test_unsupported_backend(backend):\n    # This test is currently exercised by LibreSSL, which does\n    # not support scrypt\n    with raises_unsupported_algorithm(None):\n        Scrypt(b\"NaCl\", 64, 1024, 8, 16)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.scrypt_supported(),\n    skip_message=\"Does not support Scrypt\",\n)\nclass TestScrypt:\n    @pytest.mark.parametrize(\"params\", vectors)\n    def test_derive(self, backend, params):\n        _skip_if_memory_limited(_MEM_LIMIT, params)\n        password = params[\"password\"]\n        work_factor = int(params[\"n\"])\n        block_size = int(params[\"r\"])\n        parallelization_factor = int(params[\"p\"])\n        length = int(params[\"length\"])\n        salt = params[\"salt\"]\n        derived_key = params[\"derived_key\"]\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n        assert binascii.hexlify(scrypt.derive(password)) == derived_key\n\n    def test_salt_not_bytes(self, backend):\n        work_factor = 1024\n        block_size = 8\n        parallelization_factor = 16\n        length = 64\n        salt = 1\n\n        with pytest.raises(TypeError):\n            Scrypt(\n                salt,  # type: ignore[arg-type]\n                length,\n                work_factor,\n                block_size,\n                parallelization_factor,\n                backend,\n            )\n\n    def test_scrypt_malloc_failure(self, backend):\n        password = b\"NaCl\"\n        work_factor = 1024**3\n        block_size = 589824\n        parallelization_factor = 16\n        length = 64\n        salt = b\"NaCl\"\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n\n        with pytest.raises(MemoryError):\n            scrypt.derive(password)\n\n    def test_password_not_bytes(self, backend):\n        password = 1\n        work_factor = 1024\n        block_size = 8\n        parallelization_factor = 16\n        length = 64\n        salt = b\"NaCl\"\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n\n        with pytest.raises(TypeError):\n            scrypt.derive(password)  # type: ignore[arg-type]\n\n    def test_buffer_protocol(self, backend):\n        password = bytearray(b\"password\")\n        work_factor = 256\n        block_size = 8\n        parallelization_factor = 16\n        length = 10\n        salt = b\"NaCl\"\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n\n        assert scrypt.derive(password) == b\"\\xf4\\x92\\x86\\xb2\\x06\\x0c\\x848W\\x87\"\n\n    @pytest.mark.parametrize(\"params\", vectors)\n    def test_verify(self, backend, params):\n        _skip_if_memory_limited(_MEM_LIMIT, params)\n        password = params[\"password\"]\n        work_factor = int(params[\"n\"])\n        block_size = int(params[\"r\"])\n        parallelization_factor = int(params[\"p\"])\n        length = int(params[\"length\"])\n        salt = params[\"salt\"]\n        derived_key = params[\"derived_key\"]\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n        scrypt.verify(password, binascii.unhexlify(derived_key))\n\n    def test_invalid_verify(self, backend):\n        password = b\"password\"\n        work_factor = 1024\n        block_size = 8\n        parallelization_factor = 16\n        length = 64\n        salt = b\"NaCl\"\n        derived_key = b\"fdbabe1c9d3472007856e7190d01e9fe7c6ad7cbc8237830e773\"\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n\n        with pytest.raises(InvalidKey):\n            scrypt.verify(password, binascii.unhexlify(derived_key))\n\n    def test_already_finalized(self, backend):\n        password = b\"password\"\n        work_factor = 1024\n        block_size = 8\n        parallelization_factor = 16\n        length = 64\n        salt = b\"NaCl\"\n\n        scrypt = Scrypt(\n            salt,\n            length,\n            work_factor,\n            block_size,\n            parallelization_factor,\n            backend,\n        )\n        scrypt.derive(password)\n        with pytest.raises(AlreadyFinalized):\n            scrypt.derive(password)\n\n    def test_invalid_n(self, backend):\n        # n is less than 2\n        with pytest.raises(ValueError):\n            Scrypt(b\"NaCl\", 64, 1, 8, 16, backend)\n\n        # n is not a power of 2\n        with pytest.raises(ValueError):\n            Scrypt(b\"NaCl\", 64, 3, 8, 16, backend)\n\n    def test_invalid_r(self, backend):\n        with pytest.raises(ValueError):\n            Scrypt(b\"NaCl\", 64, 2, 0, 16, backend)\n\n    def test_invalid_p(self, backend):\n        with pytest.raises(ValueError):\n            Scrypt(b\"NaCl\", 64, 2, 8, 0, backend)\n", "tests/hazmat/primitives/test_pkcs12.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport os\nfrom datetime import datetime, timezone\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import RC2\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import CBC\nfrom cryptography.hazmat.primitives.serialization import (\n    Encoding,\n    PublicFormat,\n    load_pem_private_key,\n)\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import (\n    PBES,\n    PKCS12Certificate,\n    PKCS12KeyAndCertificates,\n    load_key_and_certificates,\n    load_pkcs12,\n    serialize_key_and_certificates,\n)\n\nfrom ...doubles import DummyKeySerializationEncryption\nfrom ...utils import load_vectors_from_file\n\n\ndef _skip_curve_unsupported(backend, curve):\n    if not backend.elliptic_curve_supported(curve):\n        pytest.skip(\n            f\"Curve {curve.name} is not supported by this backend {backend}\"\n        )\n\n\n@pytest.mark.skip_fips(\n    reason=\"PKCS12 unsupported in FIPS mode. So much bad crypto in it.\"\n)\nclass TestPKCS12Loading:\n    def _test_load_pkcs12_ec_keys(self, filename, password, backend):\n        cert, key = _load_ca(backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        parsed_key, parsed_cert, parsed_more_certs = load_vectors_from_file(\n            os.path.join(\"pkcs12\", filename),\n            lambda derfile: load_key_and_certificates(\n                derfile.read(), password, backend\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(parsed_key, ec.EllipticCurvePrivateKey)\n        assert parsed_cert == cert\n        assert parsed_key.private_numbers() == key.private_numbers()\n        assert parsed_more_certs == []\n\n    @pytest.mark.parametrize(\n        (\"filename\", \"password\"),\n        [\n            (\"cert-key-aes256cbc.p12\", b\"cryptography\"),\n            (\"cert-none-key-none.p12\", b\"cryptography\"),\n        ],\n    )\n    def test_load_pkcs12_ec_keys(self, filename, password, backend):\n        self._test_load_pkcs12_ec_keys(filename, password, backend)\n\n    @pytest.mark.parametrize(\n        (\"filename\", \"password\"),\n        [\n            (\"cert-rc2-key-3des.p12\", b\"cryptography\"),\n            (\"no-password.p12\", None),\n        ],\n    )\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.cipher_supported(\n            RC2(b\"0\" * 16), CBC(b\"0\" * 8)\n        ),\n        skip_message=\"Does not support RC2\",\n    )\n    def test_load_pkcs12_ec_keys_rc2(self, filename, password, backend):\n        self._test_load_pkcs12_ec_keys(filename, password, backend)\n\n    def test_load_key_and_cert_cert_only(self, backend):\n        cert, _ = _load_ca(backend)\n        parsed_key, parsed_cert, parsed_more_certs = load_vectors_from_file(\n            os.path.join(\"pkcs12\", \"cert-aes256cbc-no-key.p12\"),\n            lambda data: load_key_and_certificates(\n                data.read(), b\"cryptography\", backend\n            ),\n            mode=\"rb\",\n        )\n        assert parsed_cert is None\n        assert parsed_key is None\n        assert parsed_more_certs == [cert]\n\n    def test_load_key_and_certificates_key_only(self, backend):\n        _, key = _load_ca(backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        parsed_key, parsed_cert, parsed_more_certs = load_vectors_from_file(\n            os.path.join(\"pkcs12\", \"no-cert-key-aes256cbc.p12\"),\n            lambda data: load_key_and_certificates(\n                data.read(), b\"cryptography\", backend\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(parsed_key, ec.EllipticCurvePrivateKey)\n        assert parsed_key.private_numbers() == key.private_numbers()\n        assert parsed_cert is None\n        assert parsed_more_certs == []\n\n    def test_load_pkcs12_key_only(self, backend):\n        _, key = _load_ca(backend)\n        assert isinstance(key, ec.EllipticCurvePrivateKey)\n        p12 = load_vectors_from_file(\n            os.path.join(\"pkcs12\", \"no-cert-key-aes256cbc.p12\"),\n            lambda data: load_pkcs12(data.read(), b\"cryptography\", backend),\n            mode=\"rb\",\n        )\n        assert isinstance(p12.key, ec.EllipticCurvePrivateKey)\n        assert p12.key.private_numbers() == key.private_numbers()\n        assert p12.cert is None\n        assert p12.additional_certs == []\n\n    def test_non_bytes(self, backend):\n        with pytest.raises(TypeError):\n            load_key_and_certificates(\n                b\"irrelevant\",\n                object(),  # type: ignore[arg-type]\n                backend,\n            )\n\n    def test_not_a_pkcs12(self, backend):\n        with pytest.raises(ValueError):\n            load_key_and_certificates(b\"invalid\", b\"pass\", backend)\n\n    def test_invalid_password(self, backend):\n        with pytest.raises(ValueError):\n            load_vectors_from_file(\n                os.path.join(\"pkcs12\", \"cert-key-aes256cbc.p12\"),\n                lambda derfile: load_key_and_certificates(\n                    derfile.read(), b\"invalid\", backend\n                ),\n                mode=\"rb\",\n            )\n\n    def test_buffer_protocol(self, backend):\n        p12 = load_vectors_from_file(\n            os.path.join(\"pkcs12\", \"cert-key-aes256cbc.p12\"),\n            lambda derfile: derfile.read(),\n            mode=\"rb\",\n        )\n        p12buffer = bytearray(p12)\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12buffer, bytearray(b\"cryptography\"), backend\n        )\n        assert parsed_key is not None\n        assert parsed_cert is not None\n        assert parsed_more_certs == []\n\n    @pytest.mark.parametrize(\n        (\"name\", \"name2\", \"name3\", \"filename\", \"password\"),\n        [\n            (None, None, None, \"no-name-no-pwd.p12\", None),\n            (b\"name\", b\"name2\", b\"name3\", \"name-all-no-pwd.p12\", None),\n            (b\"name\", None, None, \"name-1-no-pwd.p12\", None),\n            (None, b\"name2\", b\"name3\", \"name-2-3-no-pwd.p12\", None),\n            (None, b\"name2\", None, \"name-2-no-pwd.p12\", None),\n            (None, None, b\"name3\", \"name-3-no-pwd.p12\", None),\n            (\n                \"\u263a\".encode(),\n                \"\u00e4\".encode(),\n                \"\u00e7\".encode(),\n                \"name-unicode-no-pwd.p12\",\n                None,\n            ),\n            (None, None, None, \"no-name-pwd.p12\", b\"password\"),\n            (b\"name\", b\"name2\", b\"name3\", \"name-all-pwd.p12\", b\"password\"),\n            (b\"name\", None, None, \"name-1-pwd.p12\", b\"password\"),\n            (None, b\"name2\", b\"name3\", \"name-2-3-pwd.p12\", b\"password\"),\n            (None, b\"name2\", None, \"name-2-pwd.p12\", b\"password\"),\n            (None, None, b\"name3\", \"name-3-pwd.p12\", b\"password\"),\n            (\n                \"\u263a\".encode(),\n                \"\u00e4\".encode(),\n                \"\u00e7\".encode(),\n                \"name-unicode-pwd.p12\",\n                b\"password\",\n            ),\n        ],\n    )\n    def test_load_object(\n        self, filename, name, name2, name3, password, backend\n    ):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"cryptography.io.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        pkcs12 = load_vectors_from_file(\n            os.path.join(\"pkcs12\", filename),\n            lambda derfile: load_pkcs12(derfile.read(), password, backend),\n            mode=\"rb\",\n        )\n        assert pkcs12.cert is not None\n        assert pkcs12.cert.certificate == cert\n        assert pkcs12.cert.friendly_name == name\n        assert isinstance(pkcs12.key, ec.EllipticCurvePrivateKey)\n        assert pkcs12.key.private_numbers() == key.private_numbers()\n        assert len(pkcs12.additional_certs) == 2\n        assert pkcs12.additional_certs[0].certificate == cert2\n        assert pkcs12.additional_certs[0].friendly_name == name2\n        assert pkcs12.additional_certs[1].certificate == cert3\n        assert pkcs12.additional_certs[1].friendly_name == name3\n\n    @pytest.mark.parametrize(\n        (\"name2\", \"name3\", \"filename\", \"password\"),\n        [\n            (None, None, \"no-cert-no-name-no-pwd.p12\", None),\n            (b\"name2\", b\"name3\", \"no-cert-name-all-no-pwd.p12\", None),\n            (b\"name2\", None, \"no-cert-name-2-no-pwd.p12\", None),\n            (None, b\"name3\", \"no-cert-name-3-no-pwd.p12\", None),\n            (\n                \"\u2639\".encode(),\n                \"\u00ef\".encode(),\n                \"no-cert-name-unicode-no-pwd.p12\",\n                None,\n            ),\n            (None, None, \"no-cert-no-name-pwd.p12\", b\"password\"),\n            (b\"name2\", b\"name3\", \"no-cert-name-all-pwd.p12\", b\"password\"),\n            (b\"name2\", None, \"no-cert-name-2-pwd.p12\", b\"password\"),\n            (None, b\"name3\", \"no-cert-name-3-pwd.p12\", b\"password\"),\n            (\n                \"\u2639\".encode(),\n                \"\u00ef\".encode(),\n                \"no-cert-name-unicode-pwd.p12\",\n                b\"password\",\n            ),\n        ],\n    )\n    def test_load_object_no_cert_key(\n        self, filename, name2, name3, password, backend\n    ):\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"cryptography.io.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        pkcs12 = load_vectors_from_file(\n            os.path.join(\"pkcs12\", filename),\n            lambda derfile: load_pkcs12(derfile.read(), password, backend),\n            mode=\"rb\",\n        )\n        assert pkcs12.cert is None\n        assert pkcs12.key is None\n        assert len(pkcs12.additional_certs) == 2\n        assert pkcs12.additional_certs[0].certificate == cert2\n        assert pkcs12.additional_certs[0].friendly_name == name2\n        assert pkcs12.additional_certs[1].certificate == cert3\n        assert pkcs12.additional_certs[1].friendly_name == name3\n\n\ndef _load_cert(backend, path):\n    return load_vectors_from_file(\n        path,\n        lambda pemfile: x509.load_pem_x509_certificate(\n            pemfile.read(), backend\n        ),\n        mode=\"rb\",\n    )\n\n\ndef _load_ca(backend):\n    cert = _load_cert(backend, os.path.join(\"pkcs12\", \"ca\", \"ca.pem\"))\n    key = load_vectors_from_file(\n        os.path.join(\"pkcs12\", \"ca\", \"ca_key.pem\"),\n        lambda pemfile: load_pem_private_key(pemfile.read(), None, backend),\n        mode=\"rb\",\n    )\n    return cert, key\n\n\n@pytest.mark.skip_fips(\n    reason=\"PKCS12 unsupported in FIPS mode. So much bad crypto in it.\"\n)\nclass TestPKCS12Creation:\n    @pytest.mark.parametrize(\n        (\n            \"kgenerator\",\n            \"ktype\",\n            \"kparam\",\n        ),\n        [\n            pytest.param(\n                ed448.Ed448PrivateKey.generate,\n                ed448.Ed448PrivateKey,\n                [],\n                marks=pytest.mark.supported(\n                    only_if=lambda backend: backend.ed448_supported(),\n                    skip_message=\"Requires OpenSSL with Ed448 support\",\n                ),\n            ),\n            pytest.param(\n                ed25519.Ed25519PrivateKey.generate,\n                ed25519.Ed25519PrivateKey,\n                [],\n                marks=pytest.mark.supported(\n                    only_if=lambda backend: backend.ed25519_supported(),\n                    skip_message=\"Requires OpenSSL with Ed25519 support\",\n                ),\n            ),\n            (rsa.generate_private_key, rsa.RSAPrivateKey, [65537, 1024]),\n            (dsa.generate_private_key, dsa.DSAPrivateKey, [1024]),\n        ]\n        + [\n            pytest.param(\n                ec.generate_private_key, ec.EllipticCurvePrivateKey, [curve]\n            )\n            for curve in ec._CURVE_TYPES.values()\n        ],\n    )\n    @pytest.mark.parametrize(\"name\", [None, b\"name\"])\n    @pytest.mark.parametrize(\n        (\"algorithm\", \"password\"),\n        [\n            (serialization.BestAvailableEncryption(b\"password\"), b\"password\"),\n            (serialization.NoEncryption(), None),\n        ],\n    )\n    def test_generate_each_supported_keytype(\n        self, backend, kgenerator, ktype, kparam, name, algorithm, password\n    ):\n        if ktype == ec.EllipticCurvePrivateKey:\n            _skip_curve_unsupported(backend, *kparam)\n\n        key = kgenerator(*kparam)\n\n        assert isinstance(key, ktype)\n        cacert, cakey = _load_ca(backend)\n        now = datetime.now(timezone.utc).replace(tzinfo=None)\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(cacert.subject)\n            .issuer_name(cacert.subject)\n            .public_key(key.public_key())\n            .serial_number(x509.random_serial_number())\n            .not_valid_before(now)\n            .not_valid_after(now)\n            .sign(cakey, hashes.SHA256())\n        )\n        assert isinstance(cert, x509.Certificate)\n        p12 = serialize_key_and_certificates(\n            name, key, cert, [cacert], algorithm\n        )\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, password, backend\n        )\n        assert parsed_cert == cert\n        assert isinstance(parsed_key, ktype)\n        assert parsed_key.public_key().public_bytes(\n            Encoding.PEM, PublicFormat.SubjectPublicKeyInfo\n        ) == key.public_key().public_bytes(\n            Encoding.PEM, PublicFormat.SubjectPublicKeyInfo\n        )\n        assert parsed_more_certs == [cacert]\n\n    def test_generate_with_cert_key_ca(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n        encryption = serialization.NoEncryption()\n        p12 = serialize_key_and_certificates(\n            None, key, cert, [cert2, cert3], encryption\n        )\n\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, None, backend\n        )\n        assert parsed_cert == cert\n        assert isinstance(parsed_key, ec.EllipticCurvePrivateKey)\n        assert parsed_key.private_numbers() == key.private_numbers()\n        assert parsed_more_certs == [cert2, cert3]\n\n    def test_generate_cas_friendly_names(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n        encryption = serialization.NoEncryption()\n        p12 = serialize_key_and_certificates(\n            b\"test\",\n            key,\n            cert,\n            [\n                PKCS12Certificate(cert2, b\"cert2\"),\n                PKCS12Certificate(cert3, None),\n            ],\n            encryption,\n        )\n\n        p12_cert = load_pkcs12(p12, None, backend)\n        cas = p12_cert.additional_certs\n        assert cas[0].certificate == cert2\n        assert cas[0].friendly_name == b\"cert2\"\n        assert cas[1].certificate == cert3\n        assert cas[1].friendly_name is None\n\n    @pytest.mark.parametrize(\n        (\"encryption_algorithm\", \"password\"),\n        [\n            (serialization.BestAvailableEncryption(b\"password\"), b\"password\"),\n            (\n                serialization.PrivateFormat.PKCS12.encryption_builder().build(\n                    b\"not a password\"\n                ),\n                b\"not a password\",\n            ),\n            (serialization.NoEncryption(), None),\n        ],\n    )\n    def test_generate_cas_friendly_names_no_key(\n        self, backend, encryption_algorithm, password\n    ):\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n        p12 = serialize_key_and_certificates(\n            None,\n            None,\n            None,\n            [\n                PKCS12Certificate(cert2, b\"cert2\"),\n                PKCS12Certificate(cert3, None),\n            ],\n            encryption_algorithm,\n        )\n\n        p12_cert = load_pkcs12(p12, password, backend)\n        cas = p12_cert.additional_certs\n        assert cas[0].certificate == cert2\n        assert cas[0].friendly_name == b\"cert2\"\n        assert cas[1].certificate == cert3\n        assert cas[1].friendly_name is None\n\n    def test_generate_wrong_types(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n        encryption = serialization.NoEncryption()\n        with pytest.raises(TypeError) as exc:\n            serialize_key_and_certificates(\n                b\"name\", cert, cert, None, encryption\n            )\n        assert str(exc.value) == (\n            \"Key must be RSA, DSA, EllipticCurve, ED25519, or ED448\"\n            \" private key, or None.\"\n        )\n        with pytest.raises(TypeError) as exc:\n            serialize_key_and_certificates(b\"name\", key, key, None, encryption)\n        assert str(exc.value) == \"cert must be a certificate or None\"\n\n        with pytest.raises(TypeError) as exc:\n            serialize_key_and_certificates(b\"name\", key, cert, None, key)\n        assert str(exc.value) == (\n            \"Key encryption algorithm must be a \"\n            \"KeySerializationEncryption instance\"\n        )\n\n        with pytest.raises(TypeError) as exc:\n            serialize_key_and_certificates(None, key, cert, cert2, encryption)\n\n        with pytest.raises(TypeError) as exc:\n            serialize_key_and_certificates(None, key, cert, [key], encryption)\n        assert str(exc.value) == \"all values in cas must be certificates\"\n\n    def test_generate_no_cert(self, backend):\n        _, key = _load_ca(backend)\n        p12 = serialize_key_and_certificates(\n            None, key, None, None, serialization.NoEncryption()\n        )\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, None, backend\n        )\n        assert parsed_cert is None\n        assert isinstance(parsed_key, ec.EllipticCurvePrivateKey)\n        assert parsed_key.private_numbers() == key.private_numbers()\n        assert parsed_more_certs == []\n\n    @pytest.mark.parametrize(\n        (\"encryption_algorithm\", \"password\"),\n        [\n            (serialization.BestAvailableEncryption(b\"password\"), b\"password\"),\n            (serialization.NoEncryption(), None),\n        ],\n    )\n    def test_generate_cas_only(self, encryption_algorithm, password, backend):\n        cert, _ = _load_ca(backend)\n        p12 = serialize_key_and_certificates(\n            None, None, None, [cert], encryption_algorithm\n        )\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, password, backend\n        )\n        assert parsed_cert is None\n        assert parsed_key is None\n        assert parsed_more_certs == [cert]\n\n    @pytest.mark.parametrize(\n        (\"encryption_algorithm\", \"password\"),\n        [\n            (serialization.BestAvailableEncryption(b\"password\"), b\"password\"),\n            (serialization.NoEncryption(), None),\n        ],\n    )\n    def test_generate_cert_only(self, encryption_algorithm, password, backend):\n        # This test is a bit weird, but when passing *just* a cert\n        # with no corresponding key it will be encoded in the cas\n        # list. We have external consumers relying on this behavior\n        # (and the underlying structure makes no real distinction\n        # anyway) so this test ensures we don't break them.\n        cert, _ = _load_ca(backend)\n        p12 = serialize_key_and_certificates(\n            None, None, cert, [], encryption_algorithm\n        )\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, password, backend\n        )\n        assert parsed_cert is None\n        assert parsed_key is None\n        assert parsed_more_certs == [cert]\n\n    def test_generate_cert_only_none_cas(self, backend):\n        # Same as test_generate_cert_only, but passing None instead of an\n        # empty list for cas.\n        cert, _ = _load_ca(backend)\n        p12 = serialize_key_and_certificates(\n            None, None, cert, None, serialization.NoEncryption()\n        )\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, None\n        )\n        assert parsed_cert is None\n        assert parsed_key is None\n        assert parsed_more_certs == [cert]\n\n    def test_invalid_utf8_friendly_name(self, backend):\n        cert, _ = _load_ca(backend)\n        with pytest.raises(ValueError):\n            serialize_key_and_certificates(\n                b\"\\xc9\", None, cert, None, serialization.NoEncryption()\n            )\n\n    def test_must_supply_something(self):\n        with pytest.raises(ValueError) as exc:\n            serialize_key_and_certificates(\n                None, None, None, None, serialization.NoEncryption()\n            )\n        assert str(exc.value) == (\n            \"You must supply at least one of key, cert, or cas\"\n        )\n\n    def test_generate_unsupported_encryption_type(self, backend):\n        cert, key = _load_ca(backend)\n        with pytest.raises(ValueError) as exc:\n            serialize_key_and_certificates(\n                None,\n                key,\n                cert,\n                None,\n                DummyKeySerializationEncryption(),\n            )\n        assert str(exc.value) == \"Unsupported key encryption type\"\n\n    @pytest.mark.parametrize(\n        (\"enc_alg\", \"enc_alg_der\"),\n        [\n            (\n                PBES.PBESv2SHA256AndAES256CBC,\n                [\n                    b\"\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x05\\x0d\",  # PBESv2\n                    b\"\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x01\\x2a\",  # AES\n                ],\n            ),\n            (\n                PBES.PBESv1SHA1And3KeyTripleDESCBC,\n                [b\"\\x06\\x0a\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x0c\\x01\\x03\"],\n            ),\n            (\n                None,\n                [],\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\n        (\"mac_alg\", \"mac_alg_der\"),\n        [\n            (hashes.SHA1(), b\"\\x06\\x05\\x2b\\x0e\\x03\\x02\\x1a\"),\n            (hashes.SHA256(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x01\"),\n            (None, None),\n        ],\n    )\n    @pytest.mark.parametrize(\n        (\"iters\", \"iter_der\"),\n        [\n            (420, b\"\\x02\\x02\\x01\\xa4\"),\n            (22222, b\"\\x02\\x02\\x56\\xce\"),\n            (None, None),\n        ],\n    )\n    def test_key_serialization_encryption(\n        self,\n        backend,\n        enc_alg,\n        enc_alg_der,\n        mac_alg,\n        mac_alg_der,\n        iters,\n        iter_der,\n    ):\n        if (\n            enc_alg is PBES.PBESv2SHA256AndAES256CBC\n        ) and not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n            pytest.skip(\"PBESv2 is not supported on OpenSSL < 3.0\")\n\n        if (\n            mac_alg is not None\n            and not backend._lib.Cryptography_HAS_PKCS12_SET_MAC\n        ):\n            pytest.skip(\"PKCS12_set_mac is not supported (boring)\")\n\n        builder = serialization.PrivateFormat.PKCS12.encryption_builder()\n        if enc_alg is not None:\n            builder = builder.key_cert_algorithm(enc_alg)\n        if mac_alg is not None:\n            builder = builder.hmac_hash(mac_alg)\n        if iters is not None:\n            builder = builder.kdf_rounds(iters)\n\n        encryption = builder.build(b\"password\")\n        key = ec.generate_private_key(ec.SECP256R1())\n        cacert, cakey = _load_ca(backend)\n        now = datetime.now(timezone.utc).replace(tzinfo=None)\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(cacert.subject)\n            .issuer_name(cacert.subject)\n            .public_key(key.public_key())\n            .serial_number(x509.random_serial_number())\n            .not_valid_before(now)\n            .not_valid_after(now)\n            .sign(cakey, hashes.SHA256())\n        )\n        assert isinstance(cert, x509.Certificate)\n        p12 = serialize_key_and_certificates(\n            b\"name\", key, cert, [cacert], encryption\n        )\n        # We want to know if we've serialized something that has the parameters\n        # we expect, so we match on specific byte strings of OIDs & DER values.\n        for der in enc_alg_der:\n            assert der in p12\n        if mac_alg_der is not None:\n            assert mac_alg_der in p12\n        if iter_der is not None:\n            assert iter_der in p12\n        parsed_key, parsed_cert, parsed_more_certs = load_key_and_certificates(\n            p12, b\"password\", backend\n        )\n        assert parsed_cert == cert\n        assert isinstance(parsed_key, ec.EllipticCurvePrivateKey)\n        assert parsed_key.public_key().public_bytes(\n            Encoding.PEM, PublicFormat.SubjectPublicKeyInfo\n        ) == key.public_key().public_bytes(\n            Encoding.PEM, PublicFormat.SubjectPublicKeyInfo\n        )\n        assert parsed_more_certs == [cacert]\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER\n        ),\n        skip_message=\"Requires OpenSSL < 3.0.0 (or Libre/Boring)\",\n    )\n    @pytest.mark.parametrize(\n        (\"algorithm\"),\n        [\n            serialization.PrivateFormat.PKCS12.encryption_builder()\n            .key_cert_algorithm(PBES.PBESv2SHA256AndAES256CBC)\n            .build(b\"password\"),\n        ],\n    )\n    def test_key_serialization_encryption_unsupported(\n        self, algorithm, backend\n    ):\n        cacert, cakey = _load_ca(backend)\n        with pytest.raises(UnsupportedAlgorithm):\n            serialize_key_and_certificates(\n                b\"name\", cakey, cacert, [], algorithm\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: (\n            not backend._lib.Cryptography_HAS_PKCS12_SET_MAC\n        ),\n        skip_message=\"Requires OpenSSL without PKCS12_set_mac (boring only)\",\n    )\n    @pytest.mark.parametrize(\n        \"algorithm\",\n        [\n            serialization.PrivateFormat.PKCS12.encryption_builder()\n            .key_cert_algorithm(PBES.PBESv1SHA1And3KeyTripleDESCBC)\n            .hmac_hash(hashes.SHA256())\n            .build(b\"password\"),\n        ],\n    )\n    def test_key_serialization_encryption_set_mac_unsupported(\n        self, algorithm, backend\n    ):\n        cacert, cakey = _load_ca(backend)\n        with pytest.raises(UnsupportedAlgorithm):\n            serialize_key_and_certificates(\n                b\"name\", cakey, cacert, [], algorithm\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend._lib.Cryptography_HAS_PKCS12_SET_MAC,\n        skip_message=\"Requires OpenSSL with PKCS12_set_mac\",\n    )\n    def test_set_mac_key_certificate_mismatch(self, backend):\n        cacert, _ = _load_ca(backend)\n        key = ec.generate_private_key(ec.SECP256R1())\n        encryption = (\n            serialization.PrivateFormat.PKCS12.encryption_builder()\n            .hmac_hash(hashes.SHA256())\n            .build(b\"password\")\n        )\n\n        with pytest.raises(ValueError):\n            serialize_key_and_certificates(\n                b\"name\", key, cacert, [], encryption\n            )\n\n\n@pytest.mark.skip_fips(\n    reason=\"PKCS12 unsupported in FIPS mode. So much bad crypto in it.\"\n)\ndef test_pkcs12_ordering():\n    \"\"\"\n    In OpenSSL < 3.0.0 PKCS12 parsing reverses the order. However, we\n    accidentally thought it was **encoding** that did it, leading to bug\n    https://github.com/pyca/cryptography/issues/5872\n    This test ensures our ordering is correct going forward.\n    \"\"\"\n\n    def make_cert(name):\n        key = ec.generate_private_key(ec.SECP256R1())\n        subject = x509.Name(\n            [\n                x509.NameAttribute(x509.NameOID.COMMON_NAME, name),\n            ]\n        )\n        now = datetime.now(timezone.utc).replace(tzinfo=None)\n        cert = (\n            x509.CertificateBuilder()\n            .subject_name(subject)\n            .issuer_name(subject)\n            .public_key(key.public_key())\n            .serial_number(x509.random_serial_number())\n            .not_valid_before(now)\n            .not_valid_after(now)\n            .sign(key, hashes.SHA256())\n        )\n        return (key, cert)\n\n    # Make some certificates with distinct names.\n    a_name = \"A\" * 20\n    b_name = \"B\" * 20\n    c_name = \"C\" * 20\n    a_key, a_cert = make_cert(a_name)\n    _, b_cert = make_cert(b_name)\n    _, c_cert = make_cert(c_name)\n\n    # Bundle them in a PKCS#12 file in order A, B, C.\n    p12 = serialize_key_and_certificates(\n        b\"p12\", a_key, a_cert, [b_cert, c_cert], serialization.NoEncryption()\n    )\n\n    # Parse them out. The API should report them in the same order.\n    (_, cert, certs) = load_key_and_certificates(p12, None)\n    assert cert == a_cert\n    assert certs == [b_cert, c_cert]\n\n    # The ordering in the PKCS#12 file itself should also match.\n    a_idx = p12.index(a_name.encode(\"utf-8\"))\n    b_idx = p12.index(b_name.encode(\"utf-8\"))\n    c_idx = p12.index(c_name.encode(\"utf-8\"))\n\n    assert a_idx < b_idx < c_idx\n\n\nclass TestPKCS12Objects:\n    def test_certificate_constructor(self, backend):\n        with pytest.raises(TypeError):\n            PKCS12Certificate(None, None)  # type:ignore[arg-type]\n        with pytest.raises(TypeError):\n            PKCS12Certificate(\"hello\", None)  # type:ignore[arg-type]\n        cert = _load_cert(backend, os.path.join(\"x509\", \"cryptography.io.pem\"))\n        with pytest.raises(TypeError):\n            PKCS12Certificate(cert, \"hello\")  # type:ignore[arg-type]\n        with pytest.raises(TypeError):\n            PKCS12Certificate(cert, 42)  # type:ignore[arg-type]\n\n    def test_certificate_equality(self, backend):\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        c2n = PKCS12Certificate(cert2, None)\n        c2a = PKCS12Certificate(cert2, b\"a\")\n        c2b = PKCS12Certificate(cert2, b\"b\")\n        c3n = PKCS12Certificate(cert3, None)\n        c3a = PKCS12Certificate(cert3, b\"a\")\n\n        assert c2n == c2n\n        assert c2a == c2a\n        assert c2n != c2a\n        assert c2n != c3n\n        assert c2a != c2b\n        assert c2a != c3a\n\n        assert c2n != \"test\"  # type: ignore[comparison-overlap]\n\n    def test_certificate_hash(self, backend):\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        c2n = PKCS12Certificate(cert2, None)\n        c2a = PKCS12Certificate(cert2, b\"a\")\n        c2b = PKCS12Certificate(cert2, b\"b\")\n        c3n = PKCS12Certificate(cert3, None)\n        c3a = PKCS12Certificate(cert3, b\"a\")\n\n        assert hash(c2n) == hash(c2n)\n        assert hash(c2a) == hash(c2a)\n        assert hash(c2n) != hash(c2a)\n        assert hash(c2n) != hash(c3n)\n        assert hash(c2a) != hash(c2b)\n        assert hash(c2a) != hash(c3a)\n\n    def test_certificate_repr(self, backend):\n        cert = _load_cert(backend, os.path.join(\"x509\", \"cryptography.io.pem\"))\n        assert (\n            repr(PKCS12Certificate(cert, None))\n            == f\"<PKCS12Certificate({cert!r}, friendly_name=None)>\"\n        )\n        assert (\n            repr(PKCS12Certificate(cert, b\"a\"))\n            == f\"<PKCS12Certificate({cert!r}, friendly_name=b'a')>\"\n        )\n\n    def test_key_and_certificates_constructor(self, backend):\n        with pytest.raises(TypeError):\n            PKCS12KeyAndCertificates(\n                \"hello\",  # type:ignore[arg-type]\n                None,\n                [],\n            )\n        with pytest.raises(TypeError):\n            PKCS12KeyAndCertificates(\n                None,\n                \"hello\",  # type:ignore[arg-type]\n                [],\n            )\n        with pytest.raises(TypeError):\n            PKCS12KeyAndCertificates(\n                None,\n                None,\n                [\"hello\"],  # type:ignore[list-item]\n            )\n\n    def test_key_and_certificates_equality(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        p12a = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12b = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, b\"name\"),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12c = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert2, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12d = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert3, None), PKCS12Certificate(cert2, None)],\n        )\n        p12e = PKCS12KeyAndCertificates(\n            None,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12f = PKCS12KeyAndCertificates(\n            None,\n            PKCS12Certificate(cert2, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12g = PKCS12KeyAndCertificates(\n            key,\n            None,\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12h = PKCS12KeyAndCertificates(None, None, [])\n\n        assert p12a == p12a\n        assert p12h == p12h\n\n        assert p12a != p12b\n        assert p12a != p12c\n        assert p12a != p12d\n        assert p12a != p12e\n        assert p12a != p12g\n        assert p12a != p12h\n        assert p12e != p12f\n        assert p12e != p12g\n        assert p12e != p12h\n\n        assert p12e != \"test\"\n\n    def test_key_and_certificates_hash(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"custom\", \"dsa_selfsigned_ca.pem\")\n        )\n        cert3 = _load_cert(backend, os.path.join(\"x509\", \"letsencryptx3.pem\"))\n\n        p12a = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12b = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, b\"name\"),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12c = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert2, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12d = PKCS12KeyAndCertificates(\n            key,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert3, None), PKCS12Certificate(cert2, None)],\n        )\n        p12e = PKCS12KeyAndCertificates(\n            None,\n            PKCS12Certificate(cert, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12f = PKCS12KeyAndCertificates(\n            None,\n            PKCS12Certificate(cert2, None),\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12g = PKCS12KeyAndCertificates(\n            key,\n            None,\n            [PKCS12Certificate(cert2, None), PKCS12Certificate(cert3, None)],\n        )\n        p12h = PKCS12KeyAndCertificates(None, None, [])\n\n        assert hash(p12a) == hash(p12a)\n        assert hash(p12h) == hash(p12h)\n\n        assert hash(p12a) != hash(p12b)\n        assert hash(p12a) != hash(p12c)\n        assert hash(p12a) != hash(p12d)\n        assert hash(p12a) != hash(p12e)\n        assert hash(p12a) != hash(p12g)\n        assert hash(p12a) != hash(p12h)\n        assert hash(p12e) != hash(p12f)\n        assert hash(p12e) != hash(p12g)\n        assert hash(p12e) != hash(p12h)\n\n    def test_key_and_certificates_repr(self, backend):\n        cert, key = _load_ca(backend)\n        cert2 = _load_cert(\n            backend, os.path.join(\"x509\", \"cryptography.io.pem\")\n        )\n        assert repr(\n            PKCS12KeyAndCertificates(\n                key,\n                PKCS12Certificate(cert, None),\n                [PKCS12Certificate(cert2, b\"name2\")],\n            )\n        ) == (\n            f\"<PKCS12KeyAndCertificates(key={key}, \"\n            f\"cert=<PKCS12Certificate({cert}, friendly_name=None)>, \"\n            f\"additional_certs=[\"\n            f\"<PKCS12Certificate({cert2}, friendly_name=b'name2')>])>\"\n        )\n", "tests/hazmat/primitives/test_pkcs7.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport email.parser\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography import x509\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ed25519, padding, rsa\nfrom cryptography.hazmat.primitives.serialization import pkcs7\n\nfrom ...utils import load_vectors_from_file, raises_unsupported_algorithm\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Loading:\n    def test_load_invalid_der_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_der_pkcs7_certificates(b\"nonsense\")\n\n    def test_load_invalid_pem_pkcs7(self, backend):\n        with pytest.raises(ValueError):\n            pkcs7.load_pem_pkcs7_certificates(b\"nonsense\")\n\n    def test_not_bytes_der(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_der_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_not_bytes_pem(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.load_pem_pkcs7_certificates(38)  # type: ignore[arg-type]\n\n    def test_load_pkcs7_pem(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda pemfile: pkcs7.load_pem_pkcs7_certificates(pemfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 1\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [x509.NameAttribute(x509.oid.NameOID.COMMON_NAME, \"ISRG Root X1\")]\n\n    @pytest.mark.parametrize(\n        \"filepath\",\n        [\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            os.path.join(\"pkcs7\", \"amazon-roots.p7b\"),\n        ],\n    )\n    def test_load_pkcs7_der(self, filepath, backend):\n        certs = load_vectors_from_file(\n            filepath,\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        assert len(certs) == 2\n        assert certs[0].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 3\"\n            )\n        ]\n        assert certs[1].subject.get_attributes_for_oid(\n            x509.oid.NameOID.COMMON_NAME\n        ) == [\n            x509.NameAttribute(\n                x509.oid.NameOID.COMMON_NAME, \"Amazon Root CA 2\"\n            )\n        ]\n\n    def test_load_pkcs7_unsupported_type(self, backend):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):\n            load_vectors_from_file(\n                os.path.join(\"pkcs7\", \"enveloped.pem\"),\n                lambda pemfile: pkcs7.load_pem_pkcs7_certificates(\n                    pemfile.read()\n                ),\n                mode=\"rb\",\n            )\n\n    def test_load_pkcs7_empty_certificates(self):\n        der = b\"\\x30\\x0b\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x07\\x02\"\n\n        with pytest.raises(ValueError):\n            pkcs7.load_der_pkcs7_certificates(der)\n\n\n# We have no public verification API and won't be adding one until we get\n# some requirements from users so this function exists to give us basic\n# verification for the signing tests.\ndef _pkcs7_verify(encoding, sig, msg, certs, options, backend):\n    sig_bio = backend._bytes_to_bio(sig)\n    if encoding is serialization.Encoding.DER:\n        p7 = backend._lib.d2i_PKCS7_bio(sig_bio.bio, backend._ffi.NULL)\n    elif encoding is serialization.Encoding.PEM:\n        p7 = backend._lib.PEM_read_bio_PKCS7(\n            sig_bio.bio,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n        )\n    else:\n        p7 = backend._lib.SMIME_read_PKCS7(sig_bio.bio, backend._ffi.NULL)\n    backend.openssl_assert(p7 != backend._ffi.NULL)\n    p7 = backend._ffi.gc(p7, backend._lib.PKCS7_free)\n    flags = 0\n    for option in options:\n        if option is pkcs7.PKCS7Options.Text:\n            flags |= backend._lib.PKCS7_TEXT\n    store = backend._lib.X509_STORE_new()\n    backend.openssl_assert(store != backend._ffi.NULL)\n    store = backend._ffi.gc(store, backend._lib.X509_STORE_free)\n    # This list is to keep the x509 values alive until end of function\n    ossl_certs = []\n    for cert in certs:\n        ossl_cert = backend._cert2ossl(cert)\n        ossl_certs.append(ossl_cert)\n        res = backend._lib.X509_STORE_add_cert(store, ossl_cert)\n        backend.openssl_assert(res == 1)\n    if msg is None:\n        res = backend._lib.PKCS7_verify(\n            p7,\n            backend._ffi.NULL,\n            store,\n            backend._ffi.NULL,\n            backend._ffi.NULL,\n            flags,\n        )\n    else:\n        msg_bio = backend._bytes_to_bio(msg)\n        # libressl 3.7.0 has a bug when NULL is passed as an `out_bio`. Work\n        # around it for now.\n        out_bio = backend._create_mem_bio_gc()\n        res = backend._lib.PKCS7_verify(\n            p7, backend._ffi.NULL, store, msg_bio.bio, out_bio, flags\n        )\n    backend.openssl_assert(res == 1)\n    # OpenSSL 3.0 leaves a random bio error on the stack:\n    # https://github.com/openssl/openssl/issues/16681\n    if rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n        backend._consume_errors()\n\n\ndef _load_cert_key():\n    key = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca_key.pem\"),\n        lambda pemfile: serialization.load_pem_private_key(\n            pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n        ),\n        mode=\"rb\",\n    )\n    cert = load_vectors_from_file(\n        os.path.join(\"x509\", \"custom\", \"ca\", \"ca.pem\"),\n        loader=lambda pemfile: x509.load_pem_x509_certificate(pemfile.read()),\n        mode=\"rb\",\n    )\n    return cert, key\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7Builder:\n    def test_invalid_data(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder()\n        with pytest.raises(TypeError):\n            builder.set_data(\"not bytes\")  # type: ignore[arg-type]\n\n    def test_set_data_twice(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.set_data(b\"test\")\n\n    def test_sign_no_signer(self, backend):\n        builder = pkcs7.PKCS7SignatureBuilder().set_data(b\"test\")\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_sign_no_data(self, backend):\n        cert, key = _load_cert_key()\n        builder = pkcs7.PKCS7SignatureBuilder().add_signer(\n            cert, key, hashes.SHA256()\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, [])\n\n    def test_unsupported_hash_alg(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert,\n                key,\n                hashes.SHA512_256(),  # type: ignore[arg-type]\n            )\n\n    def test_not_a_cert(self, backend):\n        _, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                b\"notacert\",  # type: ignore[arg-type]\n                key,\n                hashes.SHA256(),\n            )\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.ed25519_supported(),\n        skip_message=\"Does not support ed25519.\",\n    )\n    def test_unsupported_key_type(self, backend):\n        cert, _ = _load_cert_key()\n        key = ed25519.Ed25519PrivateKey.generate()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert,\n                key,  # type: ignore[arg-type]\n                hashes.SHA256(),\n            )\n\n    def test_sign_invalid_options(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(\n                serialization.Encoding.SMIME,\n                [b\"invalid\"],  # type: ignore[list-item]\n            )\n\n    def test_sign_invalid_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.Raw, [])\n\n    def test_sign_invalid_options_text_no_detached(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [pkcs7.PKCS7Options.Text]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_sign_invalid_options_text_der_encoding(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.DER, options)\n\n    def test_sign_invalid_options_no_attrs_and_no_caps(self, backend):\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(b\"test\")\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options = [\n            pkcs7.PKCS7Options.NoAttributes,\n            pkcs7.PKCS7Options.NoCapabilities,\n        ]\n        with pytest.raises(ValueError):\n            builder.sign(serialization.Encoding.SMIME, options)\n\n    def test_smime_sign_detached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        assert b\"text/plain\" not in sig\n        # We don't have a generic ASN.1 parser available to us so we instead\n        # will assert on specific byte sequences being present based on the\n        # parameters chosen above.\n        assert b\"sha-256\" in sig\n        # Detached signature means that the signed data is *not* embedded into\n        # the PKCS7 structure itself, but is present in the SMIME serialization\n        # as a separate section before the PKCS7 data. So we should expect to\n        # have data in sig but not in sig_binary\n        assert data in sig\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig)\n        payload = message.get_payload()\n        assert isinstance(payload, list)\n        assert isinstance(payload[0], email.message.Message)\n        signed_data = payload[0].get_payload()\n        assert isinstance(signed_data, str)\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            signed_data.encode(),\n            [cert],\n            options,\n            backend,\n        )\n        assert data not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_byteslike(self, backend):\n        data = bytearray(b\"hello world\")\n        cert, key = _load_cert_key()\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        assert bytes(data) in sig\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n        data = bytearray(b\"\")\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig,\n            data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_pem(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig = builder.sign(serialization.Encoding.PEM, options)\n        _pkcs7_verify(\n            serialization.Encoding.PEM,\n            sig,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x01\"),\n            (hashes.SHA384(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\"),\n            (hashes.SHA512(), b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\"),\n        ],\n    )\n    def test_sign_alternate_digests_der(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert expected_value in sig\n        _pkcs7_verify(\n            serialization.Encoding.DER, sig, None, [cert], options, backend\n        )\n\n    @pytest.mark.parametrize(\n        (\"hash_alg\", \"expected_value\"),\n        [\n            (hashes.SHA256(), b\"sha-256\"),\n            (hashes.SHA384(), b\"sha-384\"),\n            (hashes.SHA512(), b\"sha-512\"),\n        ],\n    )\n    def test_sign_alternate_digests_detached(\n        self, hash_alg, expected_value, backend\n    ):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hash_alg)\n        )\n        options = [pkcs7.PKCS7Options.DetachedSignature]\n        sig = builder.sign(serialization.Encoding.SMIME, options)\n        # When in detached signature mode the hash algorithm is stored as a\n        # byte string like \"sha-384\".\n        assert expected_value in sig\n\n    def test_sign_attached(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        options: typing.List[pkcs7.PKCS7Options] = []\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # When not passing detached signature the signed data is embedded into\n        # the PKCS7 structure itself\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_binary(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_no_binary = builder.sign(serialization.Encoding.DER, options)\n        sig_binary = builder.sign(\n            serialization.Encoding.DER, [pkcs7.PKCS7Options.Binary]\n        )\n        # Binary prevents translation of LF to CR+LF (SMIME canonical form)\n        # so data should not be present in sig_no_binary, but should be present\n        # in sig_binary\n        assert data not in sig_no_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_no_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n        assert data in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_smime_canonicalization(self, backend):\n        data = b\"hello\\nworld\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # LF gets converted to CR+LF (SMIME canonical form)\n        # so data should not be present in the sig\n        assert data not in sig_binary\n        assert b\"hello\\r\\nworld\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_text(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [\n            pkcs7.PKCS7Options.Text,\n            pkcs7.PKCS7Options.DetachedSignature,\n        ]\n        sig_pem = builder.sign(serialization.Encoding.SMIME, options)\n        # The text option adds text/plain headers to the S/MIME message\n        # These headers are only relevant in SMIME mode, not binary, which is\n        # just the PKCS7 structure itself.\n        assert sig_pem.count(b\"text/plain\") == 1\n        assert b\"Content-Type: text/plain\\r\\n\\r\\nhello world\\r\\n\" in sig_pem\n        # Parse the message to get the signed data, which is the\n        # first payload in the message\n        message = email.parser.BytesParser().parsebytes(sig_pem)\n        payload = message.get_payload()\n        assert isinstance(payload, list)\n        assert isinstance(payload[0], email.message.Message)\n        signed_data = payload[0].as_bytes(\n            policy=message.policy.clone(linesep=\"\\r\\n\")\n        )\n        _pkcs7_verify(\n            serialization.Encoding.SMIME,\n            sig_pem,\n            signed_data,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_smime_capabilities(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        sig_binary = builder.sign(serialization.Encoding.DER, [])\n\n        # 1.2.840.113549.1.9.15 (SMIMECapabilities) as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" in sig_binary\n\n        # 2.16.840.1.101.3.4.1.42 (aes256-CBC-PAD) as an ASN.1 DER encoded OID\n        aes256_cbc_pad_oid = b\"\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x01\\x2a\"\n        # 2.16.840.1.101.3.4.1.22 (aes192-CBC-PAD) as an ASN.1 DER encoded OID\n        aes192_cbc_pad_oid = b\"\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x01\\x16\"\n        # 2.16.840.1.101.3.4.1.2 (aes128-CBC-PAD) as an ASN.1 DER encoded OID\n        aes128_cbc_pad_oid = b\"\\x06\\x09\\x60\\x86\\x48\\x01\\x65\\x03\\x04\\x01\\x02\"\n\n        # Each algorithm in SMIMECapabilities should be inside its own\n        # SEQUENCE.\n        # This is encoded as SEQUENCE_IDENTIFIER + LENGTH + ALGORITHM_OID.\n        # This tests that each algorithm is indeed encoded inside its own\n        # sequence. See RFC 2633, Appendix A for more details.\n        sequence_identifier = b\"\\x30\"\n        for oid in [\n            aes256_cbc_pad_oid,\n            aes192_cbc_pad_oid,\n            aes128_cbc_pad_oid,\n        ]:\n            len_oid = len(oid).to_bytes(length=1, byteorder=\"big\")\n            assert sequence_identifier + len_oid + oid in sig_binary\n\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            [],\n            backend,\n        )\n\n    def test_sign_no_capabilities(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoCapabilities]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoCapabilities removes the SMIMECapabilities attribute from the\n        # PKCS7 structure. This is an ASN.1 sequence with the\n        # OID 1.2.840.113549.1.9.15. It does NOT remove all authenticated\n        # attributes, so we verify that by looking for the signingTime OID.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_attributes(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options = [pkcs7.PKCS7Options.NoAttributes]\n        sig_binary = builder.sign(serialization.Encoding.DER, options)\n        # NoAttributes removes all authenticated attributes, so we shouldn't\n        # find SMIMECapabilities or signingTime.\n\n        # 1.2.840.113549.1.9.15 SMIMECapabilities as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x0f\" not in sig_binary\n        # 1.2.840.113549.1.9.5 signingTime as an ASN.1 DER encoded OID\n        assert b\"\\x06\\t*\\x86H\\x86\\xf7\\r\\x01\\t\\x05\" not in sig_binary\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig_binary,\n            None,\n            [cert],\n            options,\n            backend,\n        )\n\n    def test_sign_no_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA256())\n        )\n\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert sig.count(cert.public_bytes(serialization.Encoding.DER)) == 1\n\n        options = [pkcs7.PKCS7Options.NoCerts]\n        sig_no = builder.sign(serialization.Encoding.DER, options)\n        assert sig_no.count(cert.public_bytes(serialization.Encoding.DER)) == 0\n\n    @pytest.mark.parametrize(\n        \"pad\",\n        [\n            padding.PKCS1v15(),\n            None,\n            padding.PSS(\n                mgf=padding.MGF1(hashes.SHA512()),\n                salt_length=padding.PSS.DIGEST_LENGTH,\n            ),\n        ],\n    )\n    def test_rsa_pkcs_padding_options(self, pad, backend):\n        data = b\"hello world\"\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512(), rsa_padding=pad)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # This should be a pkcs1 sha512 signature\n        if isinstance(pad, padding.PSS):\n            # PKCS7_verify can't verify a PSS sig and we don't bind CMS so\n            # we instead just check that a few things are present in the\n            # output.\n            # There should be four SHA512 OIDs in this structure\n            assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 4\n            # There should be one MGF1 OID in this structure\n            assert (\n                sig.count(b\"\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x01\\x08\") == 1\n            )\n        else:\n            # This should be a pkcs1 RSA signature, which uses the\n            # `rsaEncryption` OID (1.2.840.113549.1.1.1) no matter which\n            # digest algorithm is used.\n            # See RFC 3370 section 3.2 for more details.\n            # This OID appears twice, once in the certificate itself and\n            # another in the SignerInfo data structure in the\n            # `digest_encryption_algorithm` field.\n            assert (\n                sig.count(b\"\\x06\\x09\\x2a\\x86\\x48\\x86\\xf7\\x0d\\x01\\x01\\x01\") == 2\n            )\n            _pkcs7_verify(\n                serialization.Encoding.DER,\n                sig,\n                None,\n                [rsa_cert],\n                options,\n                backend,\n            )\n\n    def test_not_rsa_key_with_padding(self, backend):\n        cert, key = _load_cert_key()\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                cert, key, hashes.SHA512(), rsa_padding=padding.PKCS1v15()\n            )\n\n    def test_rsa_invalid_padding(self, backend):\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_signer(\n                rsa_cert,\n                rsa_key,\n                hashes.SHA512(),\n                rsa_padding=object(),  # type: ignore[arg-type]\n            )\n\n    def test_multiple_signers(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA512())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be three SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 3\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_multiple_signers_different_hash_algs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_key = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_key.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, unsafe_skip_rsa_key_validation=True\n            ),\n            mode=\"rb\",\n        )\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(rsa_key, rsa.RSAPrivateKey)\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_signer(rsa_cert, rsa_key, hashes.SHA512())\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        # There should be two SHA384 and two SHA512 OIDs in this structure\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x02\") == 2\n        assert sig.count(b\"\\x06\\t`\\x86H\\x01e\\x03\\x04\\x02\\x03\") == 2\n        _pkcs7_verify(\n            serialization.Encoding.DER,\n            sig,\n            None,\n            [cert, rsa_cert],\n            options,\n            backend,\n        )\n\n    def test_add_additional_cert_not_a_cert(self, backend):\n        with pytest.raises(TypeError):\n            pkcs7.PKCS7SignatureBuilder().add_certificate(\n                b\"notacert\"  # type: ignore[arg-type]\n            )\n\n    def test_add_additional_cert(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 1\n        )\n\n    def test_add_multiple_additional_certs(self, backend):\n        data = b\"hello world\"\n        cert, key = _load_cert_key()\n        rsa_cert = load_vectors_from_file(\n            os.path.join(\"x509\", \"custom\", \"ca\", \"rsa_ca.pem\"),\n            loader=lambda pemfile: x509.load_pem_x509_certificate(\n                pemfile.read()\n            ),\n            mode=\"rb\",\n        )\n        builder = (\n            pkcs7.PKCS7SignatureBuilder()\n            .set_data(data)\n            .add_signer(cert, key, hashes.SHA384())\n            .add_certificate(rsa_cert)\n            .add_certificate(rsa_cert)\n        )\n        options: typing.List[pkcs7.PKCS7Options] = []\n        sig = builder.sign(serialization.Encoding.DER, options)\n        assert (\n            sig.count(rsa_cert.public_bytes(serialization.Encoding.DER)) == 2\n        )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL with PKCS7 support\",\n)\nclass TestPKCS7SerializeCerts:\n    @pytest.mark.parametrize(\n        (\"encoding\", \"loader\"),\n        [\n            (serialization.Encoding.PEM, pkcs7.load_pem_pkcs7_certificates),\n            (serialization.Encoding.DER, pkcs7.load_der_pkcs7_certificates),\n        ],\n    )\n    def test_roundtrip(self, encoding, loader, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(certs, encoding)\n        certs2 = loader(p7)\n        assert certs == certs2\n\n    def test_ordering(self, backend):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        p7 = pkcs7.serialize_certificates(\n            list(reversed(certs)), serialization.Encoding.DER\n        )\n        certs2 = pkcs7.load_der_pkcs7_certificates(p7)\n        assert certs == certs2\n\n    def test_pem_matches_vector(self, backend):\n        p7_pem = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"isrg.pem\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_pem_pkcs7_certificates(p7_pem)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.PEM)\n        assert p7 == p7_pem\n\n    def test_der_matches_vector(self, backend):\n        p7_der = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda p: p.read(),\n            mode=\"rb\",\n        )\n        certs = pkcs7.load_der_pkcs7_certificates(p7_der)\n        p7 = pkcs7.serialize_certificates(certs, serialization.Encoding.DER)\n        assert p7 == p7_der\n\n    def test_invalid_types(self):\n        certs = load_vectors_from_file(\n            os.path.join(\"pkcs7\", \"amazon-roots.der\"),\n            lambda derfile: pkcs7.load_der_pkcs7_certificates(derfile.read()),\n            mode=\"rb\",\n        )\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                object(),  # type: ignore[arg-type]\n                serialization.Encoding.PEM,\n            )\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates([], serialization.Encoding.PEM)\n\n        with pytest.raises(TypeError):\n            pkcs7.serialize_certificates(\n                certs,\n                \"not an encoding\",  # type: ignore[arg-type]\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: not backend.pkcs7_supported(),\n    skip_message=\"Requires OpenSSL without PKCS7 support (BoringSSL)\",\n)\nclass TestPKCS7Unsupported:\n    def test_pkcs7_functions_unsupported(self):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):\n            pkcs7.load_der_pkcs7_certificates(b\"nonsense\")\n\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_SERIALIZATION):\n            pkcs7.load_pem_pkcs7_certificates(b\"nonsense\")\n", "tests/hazmat/primitives/test_dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport copy\nimport itertools\nimport os\nimport typing\n\nimport pytest\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import dsa\nfrom cryptography.hazmat.primitives.asymmetric.utils import (\n    Prehashed,\n    encode_dss_signature,\n)\n\nfrom ...doubles import DummyHashAlgorithm, DummyKeySerializationEncryption\nfrom ...utils import (\n    load_fips_dsa_key_pair_vectors,\n    load_fips_dsa_sig_vectors,\n    load_vectors_from_file,\n)\nfrom .fixtures_dsa import DSA_KEY_1024, DSA_KEY_2048, DSA_KEY_3072\nfrom .utils import skip_fips_traditional_openssl\n\n_ALGORITHMS_DICT: typing.Dict[str, hashes.HashAlgorithm] = {\n    \"SHA1\": hashes.SHA1(),\n    \"SHA224\": hashes.SHA224(),\n    \"SHA256\": hashes.SHA256(),\n    \"SHA384\": hashes.SHA384(),\n    \"SHA512\": hashes.SHA512(),\n}\n\n\ndef _skip_if_dsa_not_supported(\n    backend: typing.Any,\n    algorithm: hashes.HashAlgorithm,\n    p: int,\n    q: int,\n    g: int,\n) -> None:\n    if not backend.dsa_hash_supported(algorithm):\n        pytest.skip(\n            f\"{backend} does not support the provided args. \"\n            f\"p: {p.bit_length()}, hash: {algorithm.name}\"\n        )\n\n\ndef test_skip_if_dsa_not_supported(backend):\n    with pytest.raises(pytest.skip.Exception):\n        _skip_if_dsa_not_supported(backend, DummyHashAlgorithm(), 1, 1, 1)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSA:\n    def test_generate_dsa_parameters(self, backend):\n        parameters = dsa.generate_parameters(2048, backend)\n        assert isinstance(parameters, dsa.DSAParameters)\n\n    def test_generate_invalid_dsa_parameters(self, backend):\n        with pytest.raises(ValueError):\n            dsa.generate_parameters(1, backend)\n\n    @pytest.mark.parametrize(\n        \"vector\",\n        load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DSA\", \"FIPS_186-3\", \"KeyPair.rsp\"),\n            load_fips_dsa_key_pair_vectors,\n        ),\n    )\n    def test_generate_dsa_keys(self, vector, backend):\n        parameters = dsa.DSAParameterNumbers(\n            p=vector[\"p\"], q=vector[\"q\"], g=vector[\"g\"]\n        ).parameters(backend)\n        skey = parameters.generate_private_key()\n        numbers = skey.private_numbers()\n        skey_parameters = numbers.public_numbers.parameter_numbers\n        pkey = skey.public_key()\n        parameters = pkey.parameters()\n        parameter_numbers = parameters.parameter_numbers()\n        assert parameter_numbers.p == skey_parameters.p\n        assert parameter_numbers.q == skey_parameters.q\n        assert parameter_numbers.g == skey_parameters.g\n        assert skey_parameters.p == vector[\"p\"]\n        assert skey_parameters.q == vector[\"q\"]\n        assert skey_parameters.g == vector[\"g\"]\n        assert skey.key_size == vector[\"p\"].bit_length()\n        assert pkey.key_size == skey.key_size\n        public_numbers = pkey.public_numbers()\n        assert numbers.public_numbers.y == public_numbers.y\n        assert numbers.public_numbers.y == pow(\n            skey_parameters.g, numbers.x, skey_parameters.p\n        )\n\n    def test_generate_dsa_private_key_and_parameters(self, backend):\n        skey = dsa.generate_private_key(2048, backend)\n        assert skey\n        numbers = skey.private_numbers()\n        skey_parameters = numbers.public_numbers.parameter_numbers\n        assert numbers.public_numbers.y == pow(\n            skey_parameters.g, numbers.x, skey_parameters.p\n        )\n\n    @pytest.mark.parametrize(\n        (\"p\", \"q\", \"g\"),\n        [\n            (\n                2**1000,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n            ),\n            (\n                2**2000,\n                DSA_KEY_2048.public_numbers.parameter_numbers.q,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n            ),\n            (\n                2**3000,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n            ),\n            (\n                2**3100,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                2**150,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n            ),\n            (\n                DSA_KEY_2048.public_numbers.parameter_numbers.p,\n                2**250,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n            ),\n            (\n                DSA_KEY_3072.public_numbers.parameter_numbers.p,\n                2**260,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                0,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                1,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                2**1200,\n            ),\n        ],\n    )\n    def test_invalid_parameters_values(self, p, q, g, backend):\n        with pytest.raises(ValueError):\n            dsa.DSAParameterNumbers(p, q, g).parameters(backend)\n\n    @pytest.mark.parametrize(\n        (\"p\", \"q\", \"g\", \"y\", \"x\"),\n        [\n            (\n                2**1000,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                DSA_KEY_1024.x,\n            ),\n            (\n                2**2000,\n                DSA_KEY_2048.public_numbers.parameter_numbers.q,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n                DSA_KEY_2048.public_numbers.y,\n                DSA_KEY_2048.x,\n            ),\n            (\n                2**3000,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n                DSA_KEY_3072.x,\n            ),\n            (\n                2**3100,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n                DSA_KEY_3072.x,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                2**150,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                DSA_KEY_1024.x,\n            ),\n            (\n                DSA_KEY_2048.public_numbers.parameter_numbers.p,\n                2**250,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n                DSA_KEY_2048.public_numbers.y,\n                DSA_KEY_2048.x,\n            ),\n            (\n                DSA_KEY_3072.public_numbers.parameter_numbers.p,\n                2**260,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n                DSA_KEY_3072.x,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                0,\n                DSA_KEY_1024.public_numbers.y,\n                DSA_KEY_1024.x,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                1,\n                DSA_KEY_1024.public_numbers.y,\n                DSA_KEY_1024.x,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                2**1200,\n                DSA_KEY_1024.public_numbers.y,\n                DSA_KEY_1024.x,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                0,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                -2,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                2**159,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n                2**200,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                2**100,\n                DSA_KEY_1024.x,\n            ),\n        ],\n    )\n    def test_invalid_dsa_private_key_arguments(self, p, q, g, y, x, backend):\n        with pytest.raises(ValueError):\n            dsa.DSAPrivateNumbers(\n                public_numbers=dsa.DSAPublicNumbers(\n                    parameter_numbers=dsa.DSAParameterNumbers(p=p, q=q, g=g),\n                    y=y,\n                ),\n                x=x,\n            ).private_key(backend)\n\n    @pytest.mark.parametrize(\n        (\"p\", \"q\", \"g\", \"y\"),\n        [\n            (\n                2**1000,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n            ),\n            (\n                2**2000,\n                DSA_KEY_2048.public_numbers.parameter_numbers.q,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n                DSA_KEY_2048.public_numbers.y,\n            ),\n            (\n                2**3000,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n            ),\n            (\n                2**3100,\n                DSA_KEY_3072.public_numbers.parameter_numbers.q,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                2**150,\n                DSA_KEY_1024.public_numbers.parameter_numbers.g,\n                DSA_KEY_1024.public_numbers.y,\n            ),\n            (\n                DSA_KEY_2048.public_numbers.parameter_numbers.p,\n                2**250,\n                DSA_KEY_2048.public_numbers.parameter_numbers.g,\n                DSA_KEY_2048.public_numbers.y,\n            ),\n            (\n                DSA_KEY_3072.public_numbers.parameter_numbers.p,\n                2**260,\n                DSA_KEY_3072.public_numbers.parameter_numbers.g,\n                DSA_KEY_3072.public_numbers.y,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                0,\n                DSA_KEY_1024.public_numbers.y,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                1,\n                DSA_KEY_1024.public_numbers.y,\n            ),\n            (\n                DSA_KEY_1024.public_numbers.parameter_numbers.p,\n                DSA_KEY_1024.public_numbers.parameter_numbers.q,\n                2**1200,\n                DSA_KEY_1024.public_numbers.y,\n            ),\n        ],\n    )\n    def test_invalid_dsa_public_key_arguments(self, p, q, g, y, backend):\n        with pytest.raises(ValueError):\n            dsa.DSAPublicNumbers(\n                parameter_numbers=dsa.DSAParameterNumbers(p=p, q=q, g=g), y=y\n            ).public_key(backend)\n\n    def test_large_p(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PEM_Serialization\", \"dsa_4096.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read(), None, backend\n            ),\n            mode=\"rb\",\n        )\n        assert isinstance(key, dsa.DSAPrivateKey)\n        pn = key.private_numbers()\n        assert pn.public_numbers.parameter_numbers.p.bit_length() == 4096\n        # Turn it back into a key to confirm that values this large pass\n        # verification\n        dsa.DSAPrivateNumbers(\n            public_numbers=dsa.DSAPublicNumbers(\n                parameter_numbers=dsa.DSAParameterNumbers(\n                    p=pn.public_numbers.parameter_numbers.p,\n                    q=pn.public_numbers.parameter_numbers.q,\n                    g=pn.public_numbers.parameter_numbers.g,\n                ),\n                y=pn.public_numbers.y,\n            ),\n            x=pn.x,\n        ).private_key(backend)\n\n    def test_public_key_equality(self, backend):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key2 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key3 = DSA_KEY_2048.private_key().public_key()\n        assert key1 == key2\n        assert key1 != key3\n        assert key1 != object()\n        with pytest.raises(TypeError):\n            key1 < key2  # type: ignore[operator]\n\n    def test_public_key_copy(self):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key1 = serialization.load_pem_private_key(key_bytes, None).public_key()\n        key2 = copy.copy(key1)\n\n        assert key1 == key2\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSAVerification:\n    def test_dsa_verification(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DSA\", \"FIPS_186-3\", \"SigVer.rsp\"),\n            load_fips_dsa_sig_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                digest_algorithm = vector[\"digest_algorithm\"].replace(\"-\", \"\")\n                algorithm = _ALGORITHMS_DICT[digest_algorithm]\n\n                _skip_if_dsa_not_supported(\n                    backend, algorithm, vector[\"p\"], vector[\"q\"], vector[\"g\"]\n                )\n\n                public_key = dsa.DSAPublicNumbers(\n                    parameter_numbers=dsa.DSAParameterNumbers(\n                        vector[\"p\"], vector[\"q\"], vector[\"g\"]\n                    ),\n                    y=vector[\"y\"],\n                ).public_key(backend)\n                sig = encode_dss_signature(vector[\"r\"], vector[\"s\"])\n\n                if vector[\"result\"] == \"F\":\n                    with pytest.raises(InvalidSignature):\n                        public_key.verify(sig, vector[\"msg\"], algorithm)\n                else:\n                    public_key.verify(sig, vector[\"msg\"], algorithm)\n\n    def test_dsa_verify_invalid_asn1(self, backend):\n        public_key = DSA_KEY_1024.public_numbers.public_key(backend)\n        with pytest.raises(InvalidSignature):\n            public_key.verify(b\"fakesig\", b\"fakemsg\", hashes.SHA1())\n\n    def test_verify(self, backend):\n        message = b\"one little message\"\n        algorithm = hashes.SHA1()\n        private_key = DSA_KEY_1024.private_key(backend)\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, algorithm)\n\n    def test_prehashed_verify(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA1(), backend)\n        h.update(message)\n        digest = h.finalize()\n        prehashed_alg = Prehashed(hashes.SHA1())\n        signature = private_key.sign(message, hashes.SHA1())\n        public_key = private_key.public_key()\n        public_key.verify(signature, digest, prehashed_alg)\n\n    def test_prehashed_digest_mismatch(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        public_key = private_key.public_key()\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA1(), backend)\n        h.update(message)\n        digest = h.finalize()\n        prehashed_alg = Prehashed(hashes.SHA224())\n        with pytest.raises(ValueError):\n            public_key.verify(b\"\\x00\" * 128, digest, prehashed_alg)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSASignature:\n    def test_dsa_signing(self, backend, subtests):\n        vectors = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"DSA\", \"FIPS_186-3\", \"SigGen.txt\"),\n            load_fips_dsa_sig_vectors,\n        )\n        for vector in vectors:\n            with subtests.test():\n                digest_algorithm = vector[\"digest_algorithm\"].replace(\"-\", \"\")\n                algorithm = _ALGORITHMS_DICT[digest_algorithm]\n\n                _skip_if_dsa_not_supported(\n                    backend, algorithm, vector[\"p\"], vector[\"q\"], vector[\"g\"]\n                )\n\n                private_key = dsa.DSAPrivateNumbers(\n                    public_numbers=dsa.DSAPublicNumbers(\n                        parameter_numbers=dsa.DSAParameterNumbers(\n                            vector[\"p\"], vector[\"q\"], vector[\"g\"]\n                        ),\n                        y=vector[\"y\"],\n                    ),\n                    x=vector[\"x\"],\n                ).private_key(backend)\n                signature = private_key.sign(vector[\"msg\"], algorithm)\n                assert signature\n\n                private_key.public_key().verify(\n                    signature, vector[\"msg\"], algorithm\n                )\n\n    def test_sign(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        message = b\"one little message\"\n        algorithm = hashes.SHA1()\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, algorithm)\n\n    def test_sign_verify_buffer(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        message = bytearray(b\"one little message\")\n        algorithm = hashes.SHA1()\n        signature = private_key.sign(message, algorithm)\n        public_key = private_key.public_key()\n        public_key.verify(bytearray(signature), message, algorithm)\n\n    def test_prehashed_sign(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA1(), backend)\n        h.update(message)\n        digest = h.finalize()\n        prehashed_alg = Prehashed(hashes.SHA1())\n        signature = private_key.sign(digest, prehashed_alg)\n        public_key = private_key.public_key()\n        public_key.verify(signature, message, hashes.SHA1())\n\n    def test_prehashed_digest_mismatch(self, backend):\n        private_key = DSA_KEY_1024.private_key(backend)\n        message = b\"one little message\"\n        h = hashes.Hash(hashes.SHA1(), backend)\n        h.update(message)\n        digest = h.finalize()\n        prehashed_alg = Prehashed(hashes.SHA224())\n        with pytest.raises(ValueError):\n            private_key.sign(digest, prehashed_alg)\n\n\nclass TestDSANumbers:\n    def test_dsa_parameter_numbers(self):\n        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n        assert parameter_numbers.p == 1\n        assert parameter_numbers.q == 2\n        assert parameter_numbers.g == 3\n\n    def test_dsa_parameter_numbers_invalid_types(self):\n        with pytest.raises(TypeError):\n            dsa.DSAParameterNumbers(p=None, q=2, g=3)  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            dsa.DSAParameterNumbers(p=1, q=None, g=3)  # type: ignore[arg-type]\n\n        with pytest.raises(TypeError):\n            dsa.DSAParameterNumbers(p=1, q=2, g=None)  # type: ignore[arg-type]\n\n    def test_dsa_public_numbers(self):\n        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n        public_numbers = dsa.DSAPublicNumbers(\n            y=4, parameter_numbers=parameter_numbers\n        )\n        assert public_numbers.y == 4\n        assert public_numbers.parameter_numbers == parameter_numbers\n\n    def test_dsa_public_numbers_invalid_types(self):\n        with pytest.raises(TypeError):\n            dsa.DSAPublicNumbers(\n                y=4,\n                parameter_numbers=None,  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n            dsa.DSAPublicNumbers(\n                y=None,  # type: ignore[arg-type]\n                parameter_numbers=parameter_numbers,\n            )\n\n    def test_dsa_private_numbers(self):\n        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n        public_numbers = dsa.DSAPublicNumbers(\n            y=4, parameter_numbers=parameter_numbers\n        )\n        private_numbers = dsa.DSAPrivateNumbers(\n            x=5, public_numbers=public_numbers\n        )\n        assert private_numbers.x == 5\n        assert private_numbers.public_numbers == public_numbers\n\n    def test_dsa_private_numbers_invalid_types(self):\n        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n        public_numbers = dsa.DSAPublicNumbers(\n            y=4, parameter_numbers=parameter_numbers\n        )\n        with pytest.raises(TypeError):\n            dsa.DSAPrivateNumbers(\n                x=4,\n                public_numbers=None,  # type: ignore[arg-type]\n            )\n\n        with pytest.raises(TypeError):\n            dsa.DSAPrivateNumbers(\n                x=None,  # type: ignore[arg-type]\n                public_numbers=public_numbers,\n            )\n\n    def test_repr(self):\n        parameter_numbers = dsa.DSAParameterNumbers(p=1, q=2, g=3)\n        assert (\n            repr(parameter_numbers) == \"<DSAParameterNumbers(p=1, q=2, g=3)>\"\n        )\n\n        public_numbers = dsa.DSAPublicNumbers(\n            y=4, parameter_numbers=parameter_numbers\n        )\n        assert repr(public_numbers) == (\n            \"<DSAPublicNumbers(y=4, parameter_numbers=<DSAParameterNumbers(p=1\"\n            \", q=2, g=3)>)>\"\n        )\n\n\nclass TestDSANumberEquality:\n    def test_parameter_numbers_eq(self):\n        param = dsa.DSAParameterNumbers(1, 2, 3)\n        assert param == dsa.DSAParameterNumbers(1, 2, 3)\n\n    def test_parameter_numbers_ne(self):\n        param = dsa.DSAParameterNumbers(1, 2, 3)\n        assert param != dsa.DSAParameterNumbers(1, 2, 4)\n        assert param != dsa.DSAParameterNumbers(1, 1, 3)\n        assert param != dsa.DSAParameterNumbers(2, 2, 3)\n        assert param != object()\n\n    def test_public_numbers_eq(self):\n        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        assert pub == dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n\n    def test_public_numbers_ne(self):\n        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        assert pub != dsa.DSAPublicNumbers(2, dsa.DSAParameterNumbers(1, 2, 3))\n        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(2, 2, 3))\n        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 3, 3))\n        assert pub != dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 4))\n        assert pub != object()\n\n    def test_private_numbers_eq(self):\n        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        priv = dsa.DSAPrivateNumbers(1, pub)\n        assert priv == dsa.DSAPrivateNumbers(\n            1, dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        )\n\n    def test_private_numbers_ne(self):\n        pub = dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        priv = dsa.DSAPrivateNumbers(1, pub)\n        assert priv != dsa.DSAPrivateNumbers(\n            2, dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 3))\n        )\n        assert priv != dsa.DSAPrivateNumbers(\n            1, dsa.DSAPublicNumbers(2, dsa.DSAParameterNumbers(1, 2, 3))\n        )\n        assert priv != dsa.DSAPrivateNumbers(\n            1, dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(2, 2, 3))\n        )\n        assert priv != dsa.DSAPrivateNumbers(\n            1, dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 3, 3))\n        )\n        assert priv != dsa.DSAPrivateNumbers(\n            1, dsa.DSAPublicNumbers(1, dsa.DSAParameterNumbers(1, 2, 4))\n        )\n        assert priv != object()\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSASerialization:\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        itertools.product(\n            [\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.PrivateFormat.PKCS8,\n            ],\n            [\n                b\"s\",\n                b\"longerpassword\",\n                b\"!*$&(@#$*&($T@%_somesymbols\",\n                b\"\\x01\" * 1000,\n            ],\n        ),\n    )\n    def test_private_bytes_encrypted_pem(self, backend, fmt, password):\n        skip_fips_traditional_openssl(backend, fmt)\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, dsa.DSAPrivateKey)\n        serialized = key.private_bytes(\n            serialization.Encoding.PEM,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_pem_private_key(\n            serialized, password, backend\n        )\n        assert isinstance(loaded_key, dsa.DSAPrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (serialization.Encoding.Raw, serialization.PrivateFormat.PKCS8),\n            (serialization.Encoding.DER, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.Raw, serialization.PrivateFormat.Raw),\n            (serialization.Encoding.X962, serialization.PrivateFormat.PKCS8),\n            (\n                serialization.Encoding.SMIME,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n            ),\n        ],\n    )\n    def test_private_bytes_rejects_invalid(self, encoding, fmt, backend):\n        key = DSA_KEY_1024.private_key(backend)\n        with pytest.raises(ValueError):\n            key.private_bytes(encoding, fmt, serialization.NoEncryption())\n\n    @pytest.mark.parametrize(\n        (\"fmt\", \"password\"),\n        [\n            [serialization.PrivateFormat.PKCS8, b\"s\"],\n            [serialization.PrivateFormat.PKCS8, b\"longerpassword\"],\n            [serialization.PrivateFormat.PKCS8, b\"!*$&(@#$*&($T@%_somesymbol\"],\n            [serialization.PrivateFormat.PKCS8, b\"\\x01\" * 1000],\n        ],\n    )\n    def test_private_bytes_encrypted_der(self, backend, fmt, password):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: pemfile.read().encode(),\n        )\n        key = serialization.load_pem_private_key(key_bytes, None, backend)\n        assert isinstance(key, dsa.DSAPrivateKey)\n        serialized = key.private_bytes(\n            serialization.Encoding.DER,\n            fmt,\n            serialization.BestAvailableEncryption(password),\n        )\n        loaded_key = serialization.load_der_private_key(\n            serialized, password, backend\n        )\n        assert isinstance(loaded_key, dsa.DSAPrivateKey)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\", \"loader_func\"),\n        [\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.load_der_private_key,\n            ],\n            [\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_pem_private_key,\n            ],\n            [\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.PKCS8,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_unencrypted(\n        self, backend, encoding, fmt, loader_func\n    ):\n        key = DSA_KEY_1024.private_key(backend)\n        serialized = key.private_bytes(\n            encoding, fmt, serialization.NoEncryption()\n        )\n        loaded_key = loader_func(serialized, None, backend)\n        loaded_priv_num = loaded_key.private_numbers()\n        priv_num = key.private_numbers()\n        assert loaded_priv_num == priv_num\n\n    @pytest.mark.skip_fips(\n        reason=\"Traditional OpenSSL key format is not supported in FIPS mode.\"\n    )\n    @pytest.mark.parametrize(\n        (\"key_path\", \"encoding\", \"loader_func\"),\n        [\n            [\n                os.path.join(\n                    \"asymmetric\",\n                    \"Traditional_OpenSSL_Serialization\",\n                    \"dsa.1024.pem\",\n                ),\n                serialization.Encoding.PEM,\n                serialization.load_pem_private_key,\n            ],\n            [\n                os.path.join(\n                    \"asymmetric\", \"DER_Serialization\", \"dsa.1024.der\"\n                ),\n                serialization.Encoding.DER,\n                serialization.load_der_private_key,\n            ],\n        ],\n    )\n    def test_private_bytes_traditional_openssl_unencrypted(\n        self, backend, key_path, encoding, loader_func\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, None, backend)\n        serialized = key.private_bytes(\n            encoding,\n            serialization.PrivateFormat.TraditionalOpenSSL,\n            serialization.NoEncryption(),\n        )\n        assert serialized == key_bytes\n\n    def test_private_bytes_traditional_der_encrypted_invalid(self, backend):\n        key = DSA_KEY_1024.private_key(backend)\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.DER,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                serialization.BestAvailableEncryption(b\"password\"),\n            )\n\n    def test_private_bytes_invalid_encoding(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PrivateFormat.PKCS8,\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_format(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n                serialization.NoEncryption(),\n            )\n\n    def test_private_bytes_invalid_encryption_algorithm(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(TypeError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                \"notanencalg\",  # type: ignore[arg-type]\n            )\n\n    def test_private_bytes_unsupported_encryption_type(self, backend):\n        key = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pem\"),\n            lambda pemfile: serialization.load_pem_private_key(\n                pemfile.read().encode(), None, backend\n            ),\n        )\n        with pytest.raises(ValueError):\n            key.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.TraditionalOpenSSL,\n                DummyKeySerializationEncryption(),\n            )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dsa_supported(),\n    skip_message=\"Does not support DSA.\",\n)\nclass TestDSAPEMPublicKeySerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\", \"encoding\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pub.pem\"),\n                serialization.load_pem_public_key,\n                serialization.Encoding.PEM,\n            ),\n            (\n                os.path.join(\n                    \"asymmetric\",\n                    \"DER_Serialization\",\n                    \"unenc-dsa-pkcs8.pub.der\",\n                ),\n                serialization.load_der_public_key,\n                serialization.Encoding.DER,\n            ),\n        ],\n    )\n    def test_public_bytes_match(\n        self, key_path, loader_func, encoding, backend\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        key = loader_func(key_bytes, backend)\n        serialized = key.public_bytes(\n            encoding,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        assert serialized == key_bytes\n\n    def test_public_bytes_openssh(self, backend):\n        key_bytes = load_vectors_from_file(\n            os.path.join(\"asymmetric\", \"PKCS8\", \"unenc-dsa-pkcs8.pub.pem\"),\n            lambda pemfile: pemfile.read(),\n            mode=\"rb\",\n        )\n        key = serialization.load_pem_public_key(key_bytes, backend)\n\n        with pytest.warns(utils.DeprecatedIn40):\n            ssh_bytes = key.public_bytes(\n                serialization.Encoding.OpenSSH,\n                serialization.PublicFormat.OpenSSH,\n            )\n        assert ssh_bytes == (\n            b\"ssh-dss AAAAB3NzaC1kc3MAAACBAKoJMMwUWCUiHK/6KKwolBlqJ4M95ewhJweR\"\n            b\"aJQgd3Si57I4sNNvGySZosJYUIPrAUMpJEGNhn+qIS3RBx1NzrJ4J5StOTzAik1K\"\n            b\"2n9o1ug5pfzTS05ALYLLioy0D+wxkRv5vTYLA0yqy0xelHmSVzyekAmcGw8FlAyr\"\n            b\"5dLeSaFnAAAAFQCtwOhps28KwBOmgf301ImdaYIEUQAAAIEAjGtFia+lOk0QSL/D\"\n            b\"RtHzhsp1UhzPct2qJRKGiA7hMgH/SIkLv8M9ebrK7HHnp3hQe9XxpmQi45QVvgPn\"\n            b\"EUG6Mk9bkxMZKRgsiKn6QGKDYGbOvnS1xmkMfRARBsJAq369VOTjMB/Qhs5q2ski\"\n            b\"+ycTorCIfLoTubxozlz/8kHNMkYAAACAKyYOqX3GoSrpMsZA5989j/BKigWgMk+N\"\n            b\"Xxsj8V+hcP8/QgYRJO/yWGyxG0moLc3BuQ/GqE+xAQnLZ9tdLalxrq8Xvl43KEVj\"\n            b\"5MZNnl/ISAJYsxnw3inVTYNQcNnih5FNd9+BSR9EI7YtqYTrP0XrKin86l2uUlrG\"\n            b\"q2vM4Ev99bY=\"\n        )\n\n    def test_public_bytes_invalid_encoding(self, backend):\n        key = DSA_KEY_2048.private_key(backend).public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                \"notencoding\",  # type: ignore[arg-type]\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            )\n\n    def test_public_bytes_invalid_format(self, backend):\n        key = DSA_KEY_2048.private_key(backend).public_key()\n        with pytest.raises(TypeError):\n            key.public_bytes(\n                serialization.Encoding.PEM,\n                \"invalidformat\",  # type: ignore[arg-type]\n            )\n\n    def test_public_bytes_pkcs1_unsupported(self, backend):\n        key = DSA_KEY_2048.private_key(backend).public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(\n                serialization.Encoding.PEM, serialization.PublicFormat.PKCS1\n            )\n\n    @pytest.mark.parametrize(\n        (\"encoding\", \"fmt\"),\n        [\n            (\n                serialization.Encoding.Raw,\n                serialization.PublicFormat.SubjectPublicKeyInfo,\n            ),\n            (serialization.Encoding.Raw, serialization.PublicFormat.PKCS1),\n            *itertools.product(\n                [\n                    serialization.Encoding.Raw,\n                    serialization.Encoding.X962,\n                    serialization.Encoding.PEM,\n                    serialization.Encoding.DER,\n                ],\n                [\n                    serialization.PublicFormat.Raw,\n                    serialization.PublicFormat.UncompressedPoint,\n                    serialization.PublicFormat.CompressedPoint,\n                ],\n            ),\n        ],\n    )\n    def test_public_bytes_rejects_invalid(self, encoding, fmt, backend):\n        key = DSA_KEY_2048.private_key(backend).public_key()\n        with pytest.raises(ValueError):\n            key.public_bytes(encoding, fmt)\n", "tests/hazmat/primitives/twofactor/test_hotp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.hashes import MD5, SHA1\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\nfrom cryptography.hazmat.primitives.twofactor.hotp import HOTP\n\nfrom ....utils import load_nist_vectors, load_vectors_from_file\n\nvectors = load_vectors_from_file(\"twofactor/rfc-4226.txt\", load_nist_vectors)\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),\n    skip_message=\"Does not support HMAC-SHA1.\",\n)\nclass TestHOTP:\n    def test_invalid_key_length(self, backend):\n        secret = os.urandom(10)\n\n        with pytest.raises(ValueError):\n            HOTP(secret, 6, SHA1(), backend)\n\n    def test_unenforced_invalid_kwy_length(self, backend):\n        secret = os.urandom(10)\n        HOTP(secret, 6, SHA1(), backend, enforce_key_length=False)\n\n    def test_invalid_hotp_length(self, backend):\n        secret = os.urandom(16)\n\n        with pytest.raises(ValueError):\n            HOTP(secret, 4, SHA1(), backend)\n\n    def test_invalid_algorithm(self, backend):\n        secret = os.urandom(16)\n\n        with pytest.raises(TypeError):\n            HOTP(secret, 6, MD5(), backend)  # type: ignore[arg-type]\n\n    @pytest.mark.parametrize(\"params\", vectors)\n    def test_truncate(self, backend, params):\n        secret = params[\"secret\"]\n        counter = int(params[\"counter\"])\n        truncated = params[\"truncated\"]\n\n        hotp = HOTP(secret, 6, SHA1(), backend)\n\n        assert hotp._dynamic_truncate(counter) == int(truncated.decode(), 16)\n\n    @pytest.mark.parametrize(\"params\", vectors)\n    def test_generate(self, backend, params):\n        secret = params[\"secret\"]\n        counter = int(params[\"counter\"])\n        hotp_value = params[\"hotp\"]\n\n        hotp = HOTP(secret, 6, SHA1(), backend)\n\n        assert hotp.generate(counter) == hotp_value\n\n    @pytest.mark.parametrize(\"params\", vectors)\n    def test_verify(self, backend, params):\n        secret = params[\"secret\"]\n        counter = int(params[\"counter\"])\n        hotp_value = params[\"hotp\"]\n\n        hotp = HOTP(secret, 6, SHA1(), backend)\n        hotp.verify(hotp_value, counter)\n\n    def test_invalid_verify(self, backend):\n        secret = b\"12345678901234567890\"\n        counter = 0\n\n        hotp = HOTP(secret, 6, SHA1(), backend)\n\n        with pytest.raises(InvalidToken):\n            hotp.verify(b\"123456\", counter)\n\n    def test_length_not_int(self, backend):\n        secret = b\"12345678901234567890\"\n\n        with pytest.raises(TypeError):\n            HOTP(secret, b\"foo\", SHA1(), backend)  # type: ignore[arg-type]\n\n    def test_get_provisioning_uri(self, backend):\n        secret = b\"12345678901234567890\"\n        hotp = HOTP(secret, 6, SHA1(), backend)\n\n        assert hotp.get_provisioning_uri(\"Alice Smith\", 1, None) == (\n            \"otpauth://hotp/Alice%20Smith?digits=6&secret=GEZDGNBV\"\n            \"GY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&counter=1\"\n        )\n\n        assert hotp.get_provisioning_uri(\"Alice Smith\", 1, \"Foo\") == (\n            \"otpauth://hotp/Foo:Alice%20Smith?digits=6&secret=GEZD\"\n            \"GNBVGY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&issuer=Foo\"\n            \"&counter=1\"\n        )\n\n    def test_buffer_protocol(self, backend):\n        key = bytearray(b\"a long key with lots of entropy goes here\")\n        hotp = HOTP(key, 6, SHA1(), backend)\n        assert hotp.generate(10) == b\"559978\"\n", "tests/hazmat/primitives/twofactor/test_totp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport pytest\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\nfrom cryptography.hazmat.primitives.twofactor.totp import TOTP\n\nfrom ....utils import load_nist_vectors, load_vectors_from_file\n\nvectors = load_vectors_from_file(\"twofactor/rfc-6238.txt\", load_nist_vectors)\n\n\nclass TestTOTP:\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),\n        skip_message=\"Does not support HMAC-SHA1.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA1\"]\n    )\n    def test_generate_sha1(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)\n        assert totp.generate(time) == totp_value\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),\n        skip_message=\"Does not support HMAC-SHA256.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA256\"]\n    )\n    def test_generate_sha256(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA256(), 30, backend)\n        assert totp.generate(time) == totp_value\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),\n        skip_message=\"Does not support HMAC-SHA512.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA512\"]\n    )\n    def test_generate_sha512(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA512(), 30, backend)\n        assert totp.generate(time) == totp_value\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA1()),\n        skip_message=\"Does not support HMAC-SHA1.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA1\"]\n    )\n    def test_verify_sha1(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)\n        totp.verify(totp_value, time)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA256()),\n        skip_message=\"Does not support HMAC-SHA256.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA256\"]\n    )\n    def test_verify_sha256(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA256(), 30, backend)\n        totp.verify(totp_value, time)\n\n    @pytest.mark.supported(\n        only_if=lambda backend: backend.hmac_supported(hashes.SHA512()),\n        skip_message=\"Does not support HMAC-SHA512.\",\n    )\n    @pytest.mark.parametrize(\n        \"params\", [i for i in vectors if i[\"mode\"] == b\"SHA512\"]\n    )\n    def test_verify_sha512(self, backend, params):\n        secret = params[\"secret\"]\n        time = int(params[\"time\"])\n        totp_value = params[\"totp\"]\n\n        totp = TOTP(secret, 8, hashes.SHA512(), 30, backend)\n        totp.verify(totp_value, time)\n\n    def test_invalid_verify(self, backend):\n        secret = b\"12345678901234567890\"\n        time = 59\n\n        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)\n\n        with pytest.raises(InvalidToken):\n            totp.verify(b\"12345678\", time)\n\n    def test_floating_point_time_generate(self, backend):\n        secret = b\"12345678901234567890\"\n        time = 59.1\n\n        totp = TOTP(secret, 8, hashes.SHA1(), 30, backend)\n\n        assert totp.generate(time) == b\"94287082\"\n\n    def test_get_provisioning_uri(self, backend):\n        secret = b\"12345678901234567890\"\n        totp = TOTP(secret, 6, hashes.SHA1(), 30, backend=backend)\n\n        assert totp.get_provisioning_uri(\"Alice Smith\", None) == (\n            \"otpauth://totp/Alice%20Smith?digits=6&secret=GEZDGNBVG\"\n            \"Y3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&period=30\"\n        )\n\n        assert totp.get_provisioning_uri(\"Alice Smith\", \"World\") == (\n            \"otpauth://totp/World:Alice%20Smith?digits=6&secret=GEZ\"\n            \"DGNBVGY3TQOJQGEZDGNBVGY3TQOJQ&algorithm=SHA1&issuer=World\"\n            \"&period=30\"\n        )\n\n    def test_buffer_protocol(self, backend):\n        key = bytearray(b\"a long key with lots of entropy goes here\")\n        totp = TOTP(key, 8, hashes.SHA512(), 30, backend)\n        time = 60\n        assert totp.generate(time) == b\"53049576\"\n", "tests/hazmat/primitives/twofactor/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/hazmat/primitives/decrepit/test_3des.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\"\"\"\nTest using the NIST Test Vectors\n\"\"\"\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.decrepit.ciphers import algorithms\nfrom cryptography.hazmat.primitives.ciphers import modes\n\nfrom ....utils import load_nist_vectors\nfrom ..utils import generate_encrypt_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.TripleDES(b\"\\x00\" * 8), modes.CBC(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support TripleDES CBC\",\n)\nclass TestTripleDESModeCBC:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CBC\"),\n        [\n            \"TCBCinvperm.rsp\",\n            \"TCBCpermop.rsp\",\n            \"TCBCsubtab.rsp\",\n            \"TCBCvarkey.rsp\",\n            \"TCBCvartext.rsp\",\n        ],\n        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n    test_mmt = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CBC\"),\n        [\"TCBCMMT1.rsp\", \"TCBCMMT2.rsp\", \"TCBCMMT3.rsp\"],\n        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(\n            binascii.unhexlify(key1 + key2 + key3)\n        ),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.TripleDES(b\"\\x00\" * 8), modes.OFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support TripleDES OFB\",\n)\nclass TestTripleDESModeOFB:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"OFB\"),\n        [\n            \"TOFBpermop.rsp\",\n            \"TOFBsubtab.rsp\",\n            \"TOFBvarkey.rsp\",\n            \"TOFBvartext.rsp\",\n            \"TOFBinvperm.rsp\",\n        ],\n        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n    test_mmt = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"OFB\"),\n        [\"TOFBMMT1.rsp\", \"TOFBMMT2.rsp\", \"TOFBMMT3.rsp\"],\n        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(\n            binascii.unhexlify(key1 + key2 + key3)\n        ),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.TripleDES(b\"\\x00\" * 8), modes.CFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support TripleDES CFB\",\n)\nclass TestTripleDESModeCFB:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CFB\"),\n        [\n            \"TCFB64invperm.rsp\",\n            \"TCFB64permop.rsp\",\n            \"TCFB64subtab.rsp\",\n            \"TCFB64varkey.rsp\",\n            \"TCFB64vartext.rsp\",\n        ],\n        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n    test_mmt = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CFB\"),\n        [\"TCFB64MMT1.rsp\", \"TCFB64MMT2.rsp\", \"TCFB64MMT3.rsp\"],\n        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(\n            binascii.unhexlify(key1 + key2 + key3)\n        ),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.TripleDES(b\"\\x00\" * 8), modes.CFB8(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support TripleDES CFB8\",\n)\nclass TestTripleDESModeCFB8:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CFB\"),\n        [\n            \"TCFB8invperm.rsp\",\n            \"TCFB8permop.rsp\",\n            \"TCFB8subtab.rsp\",\n            \"TCFB8varkey.rsp\",\n            \"TCFB8vartext.rsp\",\n        ],\n        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),\n        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),\n    )\n\n    test_mmt = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"CFB\"),\n        [\"TCFB8MMT1.rsp\", \"TCFB8MMT2.rsp\", \"TCFB8MMT3.rsp\"],\n        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(\n            binascii.unhexlify(key1 + key2 + key3)\n        ),\n        lambda iv, **kwargs: modes.CFB8(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.TripleDES(b\"\\x00\" * 8), modes.ECB()\n    ),\n    skip_message=\"Does not support TripleDES ECB\",\n)\nclass TestTripleDESModeECB:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"ECB\"),\n        [\n            \"TECBinvperm.rsp\",\n            \"TECBpermop.rsp\",\n            \"TECBsubtab.rsp\",\n            \"TECBvarkey.rsp\",\n            \"TECBvartext.rsp\",\n        ],\n        lambda keys, **kwargs: algorithms.TripleDES(binascii.unhexlify(keys)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n    test_mmt = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"3DES\", \"ECB\"),\n        [\"TECBMMT1.rsp\", \"TECBMMT2.rsp\", \"TECBMMT3.rsp\"],\n        lambda key1, key2, key3, **kwargs: algorithms.TripleDES(\n            binascii.unhexlify(key1 + key2 + key3)\n        ),\n        lambda **kwargs: modes.ECB(),\n    )\n", "tests/hazmat/primitives/decrepit/test_algorithms.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import _Reasons\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    ARC4,\n    CAST5,\n    IDEA,\n    SEED,\n    Blowfish,\n    TripleDES,\n)\nfrom cryptography.hazmat.primitives import ciphers\nfrom cryptography.hazmat.primitives.ciphers import modes\n\nfrom ....utils import load_nist_vectors, raises_unsupported_algorithm\nfrom ..utils import generate_encrypt_test\n\n\nclass TestARC4:\n    @pytest.mark.parametrize(\n        (\"key\", \"keysize\"),\n        [\n            (b\"0\" * 10, 40),\n            (b\"0\" * 14, 56),\n            (b\"0\" * 16, 64),\n            (b\"0\" * 20, 80),\n            (b\"0\" * 32, 128),\n            (b\"0\" * 48, 192),\n            (b\"0\" * 64, 256),\n        ],\n    )\n    def test_key_size(self, key, keysize):\n        cipher = ARC4(binascii.unhexlify(key))\n        assert cipher.key_size == keysize\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            ARC4(binascii.unhexlify(b\"0\" * 34))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            ARC4(\"0\" * 10)  # type: ignore[arg-type]\n\n\ndef test_invalid_mode_algorithm():\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n        ciphers.Cipher(\n            ARC4(b\"\\x00\" * 16),\n            modes.GCM(b\"\\x00\" * 12),\n        )\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n        ciphers.Cipher(\n            ARC4(b\"\\x00\" * 16),\n            modes.CBC(b\"\\x00\" * 12),\n        )\n\n    with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_CIPHER):\n        ciphers.Cipher(\n            ARC4(b\"\\x00\" * 16),\n            modes.CTR(b\"\\x00\" * 12),\n        )\n\n\nclass TestTripleDES:\n    @pytest.mark.parametrize(\"key\", [b\"0\" * 16, b\"0\" * 32, b\"0\" * 48])\n    def test_key_size(self, key):\n        cipher = TripleDES(binascii.unhexlify(key))\n        assert cipher.key_size == 192\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            TripleDES(binascii.unhexlify(b\"0\" * 12))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            TripleDES(\"0\" * 16)  # type: ignore[arg-type]\n\n\nclass TestBlowfish:\n    @pytest.mark.parametrize(\n        (\"key\", \"keysize\"),\n        [(b\"0\" * (keysize // 4), keysize) for keysize in range(32, 449, 8)],\n    )\n    def test_key_size(self, key, keysize):\n        cipher = Blowfish(binascii.unhexlify(key))\n        assert cipher.key_size == keysize\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            Blowfish(binascii.unhexlify(b\"0\" * 6))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            Blowfish(\"0\" * 8)  # type: ignore[arg-type]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        Blowfish(b\"\\x00\" * 56), modes.ECB()\n    ),\n    skip_message=\"Does not support Blowfish ECB\",\n)\nclass TestBlowfishModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Blowfish\"),\n        [\"bf-ecb.txt\"],\n        lambda key, **kwargs: Blowfish(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        Blowfish(b\"\\x00\" * 56), modes.CBC(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support Blowfish CBC\",\n)\nclass TestBlowfishModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Blowfish\"),\n        [\"bf-cbc.txt\"],\n        lambda key, **kwargs: Blowfish(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        Blowfish(b\"\\x00\" * 56), modes.OFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support Blowfish OFB\",\n)\nclass TestBlowfishModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Blowfish\"),\n        [\"bf-ofb.txt\"],\n        lambda key, **kwargs: Blowfish(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        Blowfish(b\"\\x00\" * 56), modes.CFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support Blowfish CFB\",\n)\nclass TestBlowfishModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"Blowfish\"),\n        [\"bf-cfb.txt\"],\n        lambda key, **kwargs: Blowfish(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\nclass TestCAST5:\n    @pytest.mark.parametrize(\n        (\"key\", \"keysize\"),\n        [(b\"0\" * (keysize // 4), keysize) for keysize in range(40, 129, 8)],\n    )\n    def test_key_size(self, key, keysize):\n        cipher = CAST5(binascii.unhexlify(key))\n        assert cipher.key_size == keysize\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            CAST5(binascii.unhexlify(b\"0\" * 34))\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            CAST5(\"0\" * 10)  # type: ignore[arg-type]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        CAST5(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support CAST5 ECB\",\n)\nclass TestCAST5ModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"CAST5\"),\n        [\"cast5-ecb.txt\"],\n        lambda key, **kwargs: CAST5(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        CAST5(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support CAST5 CBC\",\n)\nclass TestCAST5ModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"CAST5\"),\n        [\"cast5-cbc.txt\"],\n        lambda key, **kwargs: CAST5(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        CAST5(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support CAST5 OFB\",\n)\nclass TestCAST5ModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"CAST5\"),\n        [\"cast5-ofb.txt\"],\n        lambda key, **kwargs: CAST5(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        CAST5(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support CAST5 CFB\",\n)\nclass TestCAST5ModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"CAST5\"),\n        [\"cast5-cfb.txt\"],\n        lambda key, **kwargs: CAST5(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\nclass TestIDEA:\n    def test_key_size(self):\n        cipher = IDEA(b\"\\x00\" * 16)\n        assert cipher.key_size == 128\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            IDEA(b\"\\x00\" * 17)\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            IDEA(\"0\" * 16)  # type: ignore[arg-type]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        IDEA(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support IDEA ECB\",\n)\nclass TestIDEAModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"IDEA\"),\n        [\"idea-ecb.txt\"],\n        lambda key, **kwargs: IDEA(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        IDEA(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support IDEA CBC\",\n)\nclass TestIDEAModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"IDEA\"),\n        [\"idea-cbc.txt\"],\n        lambda key, **kwargs: IDEA(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        IDEA(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support IDEA OFB\",\n)\nclass TestIDEAModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"IDEA\"),\n        [\"idea-ofb.txt\"],\n        lambda key, **kwargs: IDEA(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        IDEA(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support IDEA CFB\",\n)\nclass TestIDEAModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"IDEA\"),\n        [\"idea-cfb.txt\"],\n        lambda key, **kwargs: IDEA(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n\n\nclass TestSEED:\n    def test_key_size(self):\n        cipher = SEED(b\"\\x00\" * 16)\n        assert cipher.key_size == 128\n\n    def test_invalid_key_size(self):\n        with pytest.raises(ValueError):\n            SEED(b\"\\x00\" * 17)\n\n    def test_invalid_key_type(self):\n        with pytest.raises(TypeError, match=\"key must be bytes\"):\n            SEED(\"0\" * 16)  # type: ignore[arg-type]\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        SEED(b\"\\x00\" * 16), modes.ECB()\n    ),\n    skip_message=\"Does not support SEED ECB\",\n)\nclass TestSEEDModeECB:\n    test_ecb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SEED\"),\n        [\"rfc-4269.txt\"],\n        lambda key, **kwargs: SEED(binascii.unhexlify(key)),\n        lambda **kwargs: modes.ECB(),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        SEED(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SEED CBC\",\n)\nclass TestSEEDModeCBC:\n    test_cbc = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SEED\"),\n        [\"rfc-4196.txt\"],\n        lambda key, **kwargs: SEED(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        SEED(b\"\\x00\" * 16), modes.OFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SEED OFB\",\n)\nclass TestSEEDModeOFB:\n    test_ofb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SEED\"),\n        [\"seed-ofb.txt\"],\n        lambda key, **kwargs: SEED(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.OFB(binascii.unhexlify(iv)),\n    )\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        SEED(b\"\\x00\" * 16), modes.CFB(b\"\\x00\" * 16)\n    ),\n    skip_message=\"Does not support SEED CFB\",\n)\nclass TestSEEDModeCFB:\n    test_cfb = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"SEED\"),\n        [\"seed-cfb.txt\"],\n        lambda key, **kwargs: SEED(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CFB(binascii.unhexlify(iv)),\n    )\n", "tests/hazmat/primitives/decrepit/test_arc4.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.decrepit.ciphers import algorithms\n\nfrom ....utils import load_nist_vectors\nfrom ..utils import generate_stream_encryption_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        algorithms.ARC4(b\"\\x00\" * 16), None\n    ),\n    skip_message=\"Does not support ARC4\",\n)\nclass TestARC4:\n    test_rfc = generate_stream_encryption_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"ARC4\"),\n        [\n            \"rfc-6229-40.txt\",\n            \"rfc-6229-56.txt\",\n            \"rfc-6229-64.txt\",\n            \"rfc-6229-80.txt\",\n            \"rfc-6229-128.txt\",\n            \"rfc-6229-192.txt\",\n            \"rfc-6229-256.txt\",\n            \"arc4.txt\",\n        ],\n        lambda key, **kwargs: algorithms.ARC4(binascii.unhexlify(key)),\n    )\n", "tests/hazmat/primitives/decrepit/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "tests/hazmat/primitives/decrepit/test_rc2.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\"\"\"\nTest using the NIST Test Vectors\n\"\"\"\n\nimport binascii\nimport os\n\nimport pytest\n\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import RC2\nfrom cryptography.hazmat.primitives.ciphers import modes\n\nfrom ....utils import load_nist_vectors\nfrom ..utils import generate_encrypt_test\n\n\n@pytest.mark.supported(\n    only_if=lambda backend: backend.cipher_supported(\n        RC2(b\"\\x00\" * 16), modes.CBC(b\"\\x00\" * 8)\n    ),\n    skip_message=\"Does not support RC2 CBC\",\n)\nclass TestRC2ModeCBC:\n    test_kat = generate_encrypt_test(\n        load_nist_vectors,\n        os.path.join(\"ciphers\", \"RC2\"),\n        [\n            \"rc2-cbc.txt\",\n        ],\n        lambda key, **kwargs: RC2(binascii.unhexlify(key)),\n        lambda iv, **kwargs: modes.CBC(binascii.unhexlify(iv)),\n    )\n", "tests/hazmat/bindings/test_openssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport pytest\n\nfrom cryptography.exceptions import InternalError\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.bindings.openssl.binding import (\n    Binding,\n    _openssl_assert,\n    _verify_package_version,\n)\n\n\nclass TestOpenSSL:\n    def test_binding_loads(self):\n        binding = Binding()\n        assert binding\n        assert binding.lib\n        assert binding.ffi\n\n    def test_ssl_ctx_options(self):\n        # Test that we're properly handling 32-bit unsigned on all platforms.\n        b = Binding()\n        # SSL_OP_ALL is 0 on BoringSSL\n        if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL:\n            assert b.lib.SSL_OP_ALL > 0\n        ctx = b.lib.SSL_CTX_new(b.lib.TLS_method())\n        assert ctx != b.ffi.NULL\n        ctx = b.ffi.gc(ctx, b.lib.SSL_CTX_free)\n        current_options = b.lib.SSL_CTX_get_options(ctx)\n        resp = b.lib.SSL_CTX_set_options(ctx, b.lib.SSL_OP_ALL)\n        expected_options = current_options | b.lib.SSL_OP_ALL\n        assert resp == expected_options\n        assert b.lib.SSL_CTX_get_options(ctx) == expected_options\n\n    def test_ssl_options(self):\n        # Test that we're properly handling 32-bit unsigned on all platforms.\n        b = Binding()\n        # SSL_OP_ALL is 0 on BoringSSL\n        if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL:\n            assert b.lib.SSL_OP_ALL > 0\n        ctx = b.lib.SSL_CTX_new(b.lib.TLS_method())\n        assert ctx != b.ffi.NULL\n        ctx = b.ffi.gc(ctx, b.lib.SSL_CTX_free)\n        ssl = b.lib.SSL_new(ctx)\n        ssl = b.ffi.gc(ssl, b.lib.SSL_free)\n        current_options = b.lib.SSL_get_options(ssl)\n        resp = b.lib.SSL_set_options(ssl, b.lib.SSL_OP_ALL)\n        expected_options = current_options | b.lib.SSL_OP_ALL\n        assert resp == expected_options\n        assert b.lib.SSL_get_options(ssl) == expected_options\n\n    def test_conditional_removal(self):\n        b = Binding()\n\n        if not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL:\n            assert b.lib.TLS_ST_OK\n        else:\n            with pytest.raises(AttributeError):\n                b.lib.TLS_ST_OK\n\n    def test_openssl_assert_error_on_stack(self):\n        b = Binding()\n        b.lib.ERR_put_error(\n            b.lib.ERR_LIB_EVP,\n            b.lib.EVP_F_EVP_ENCRYPTFINAL_EX,\n            b.lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,\n            b\"\",\n            -1,\n        )\n        with pytest.raises(InternalError) as exc_info:\n            _openssl_assert(False)\n\n        error = exc_info.value.err_code[0]\n        assert error.lib == b.lib.ERR_LIB_EVP\n        assert error.reason == b.lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH\n        if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL:\n            assert b\"data not multiple of block length\" in error.reason_text\n\n    def test_version_mismatch(self):\n        with pytest.raises(ImportError):\n            _verify_package_version(\"nottherightversion\")\n\n    def test_rust_internal_error(self):\n        with pytest.raises(InternalError) as exc_info:\n            rust_openssl.raise_openssl_error()\n\n        assert len(exc_info.value.err_code) == 0\n\n        b = Binding()\n        b.lib.ERR_put_error(\n            b.lib.ERR_LIB_EVP,\n            b.lib.EVP_F_EVP_ENCRYPTFINAL_EX,\n            b.lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH,\n            b\"\",\n            -1,\n        )\n        with pytest.raises(InternalError) as exc_info:\n            rust_openssl.raise_openssl_error()\n\n        error = exc_info.value.err_code[0]\n        assert error.lib == b.lib.ERR_LIB_EVP\n        assert error.reason == b.lib.EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH\n        if not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL:\n            assert b\"data not multiple of block length\" in error.reason_text\n", "tests/hazmat/backends/test_openssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n\nimport itertools\nimport os\n\nimport pytest\n\nfrom cryptography.exceptions import InternalError, _Reasons\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.backends.openssl.backend import backend\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\n\nfrom ...doubles import (\n    DummyAsymmetricPadding,\n    DummyCipherAlgorithm,\n    DummyHashAlgorithm,\n    DummyMode,\n)\nfrom ...hazmat.primitives.test_rsa import rsa_key_2048\nfrom ...utils import (\n    load_vectors_from_file,\n    raises_unsupported_algorithm,\n)\n\n# Make ruff happy since we're importing fixtures that pytest patches in as\n# func args\n__all__ = [\"rsa_key_2048\"]\n\n\nclass DummyMGF(padding.MGF):\n    _salt_length = 0\n    _algorithm = hashes.SHA1()\n\n\nclass TestOpenSSL:\n    def test_backend_exists(self):\n        assert backend\n\n    def test_is_default_backend(self):\n        assert backend is default_backend()\n\n    def test_openssl_version_text(self):\n        \"\"\"\n        This test checks the value of OPENSSL_VERSION_TEXT.\n\n        Unfortunately, this define does not appear to have a\n        formal content definition, so for now we'll test to see\n        if it starts with OpenSSL or LibreSSL as that appears\n        to be true for every OpenSSL-alike.\n        \"\"\"\n        version = backend.openssl_version_text()\n        assert version.startswith((\"OpenSSL\", \"LibreSSL\", \"BoringSSL\"))\n\n        # Verify the correspondence between these two. And do it in a way that\n        # ensures coverage.\n        if version.startswith(\"LibreSSL\"):\n            assert rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL\n        if rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL:\n            assert version.startswith(\"LibreSSL\")\n\n        if version.startswith(\"BoringSSL\"):\n            assert rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n        if rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL:\n            assert version.startswith(\"BoringSSL\")\n\n    def test_openssl_version_number(self):\n        assert backend.openssl_version_number() > 0\n\n    def test_supports_cipher(self):\n        assert (\n            backend.cipher_supported(DummyCipherAlgorithm(), DummyMode())\n            is False\n        )\n\n    def test_openssl_assert(self):\n        backend.openssl_assert(True)\n        with pytest.raises(InternalError):\n            backend.openssl_assert(False)\n\n    def test_consume_errors(self):\n        for i in range(10):\n            backend._lib.ERR_put_error(\n                backend._lib.ERR_LIB_EVP, 0, 0, b\"test_openssl.py\", -1\n            )\n\n        assert backend._lib.ERR_peek_error() != 0\n\n        errors = backend._consume_errors()\n\n        assert backend._lib.ERR_peek_error() == 0\n        assert len(errors) == 10\n\n    def test_ssl_ciphers_registered(self):\n        meth = backend._lib.TLS_method()\n        ctx = backend._lib.SSL_CTX_new(meth)\n        assert ctx != backend._ffi.NULL\n        backend._lib.SSL_CTX_free(ctx)\n\n    def test_evp_ciphers_registered(self):\n        cipher = backend._lib.EVP_get_cipherbyname(b\"aes-256-cbc\")\n        assert cipher != backend._ffi.NULL\n\n\nclass TestOpenSSLRSA:\n    def test_rsa_padding_unsupported_pss_mgf1_hash(self):\n        assert (\n            backend.rsa_padding_supported(\n                padding.PSS(\n                    mgf=padding.MGF1(DummyHashAlgorithm()), salt_length=0\n                )\n            )\n            is False\n        )\n\n    def test_rsa_padding_unsupported(self):\n        assert backend.rsa_padding_supported(DummyAsymmetricPadding()) is False\n\n    def test_rsa_padding_supported_pkcs1v15(self):\n        assert backend.rsa_padding_supported(padding.PKCS1v15()) is True\n\n    def test_rsa_padding_supported_pss(self):\n        assert (\n            backend.rsa_padding_supported(\n                padding.PSS(mgf=padding.MGF1(hashes.SHA1()), salt_length=0)\n            )\n            is True\n        )\n\n    def test_rsa_padding_supported_oaep(self):\n        assert (\n            backend.rsa_padding_supported(\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.SHA256()),\n                    algorithm=hashes.SHA256(),\n                    label=None,\n                ),\n            )\n            is True\n        )\n\n    def test_rsa_padding_supported_oaep_sha2_combinations(self):\n        hashalgs = [\n            hashes.SHA1(),\n            hashes.SHA224(),\n            hashes.SHA256(),\n            hashes.SHA384(),\n            hashes.SHA512(),\n        ]\n        for mgf1alg, oaepalg in itertools.product(hashalgs, hashalgs):\n            if backend._fips_enabled and (\n                isinstance(mgf1alg, hashes.SHA1)\n                or isinstance(oaepalg, hashes.SHA1)\n            ):\n                continue\n\n            assert (\n                backend.rsa_padding_supported(\n                    padding.OAEP(\n                        mgf=padding.MGF1(algorithm=mgf1alg),\n                        algorithm=oaepalg,\n                        label=None,\n                    ),\n                )\n                is True\n            )\n\n    def test_rsa_padding_unsupported_mgf(self):\n        assert (\n            backend.rsa_padding_supported(\n                padding.OAEP(\n                    mgf=DummyMGF(),\n                    algorithm=hashes.SHA1(),\n                    label=None,\n                ),\n            )\n            is False\n        )\n\n        assert (\n            backend.rsa_padding_supported(\n                padding.PSS(mgf=DummyMGF(), salt_length=0)\n            )\n            is False\n        )\n\n    def test_unsupported_mgf1_hash_algorithm_md5_decrypt(self, rsa_key_2048):\n        with raises_unsupported_algorithm(_Reasons.UNSUPPORTED_PADDING):\n            rsa_key_2048.decrypt(\n                b\"0\" * 256,\n                padding.OAEP(\n                    mgf=padding.MGF1(algorithm=hashes.MD5()),\n                    algorithm=hashes.MD5(),\n                    label=None,\n                ),\n            )\n\n\nclass TestOpenSSLSerializationWithOpenSSL:\n    def test_very_long_pem_serialization_password(self):\n        password = b\"x\" * 1025\n\n        with pytest.raises(ValueError, match=\"Passwords longer than\"):\n            load_vectors_from_file(\n                os.path.join(\n                    \"asymmetric\",\n                    \"Traditional_OpenSSL_Serialization\",\n                    \"key1.pem\",\n                ),\n                lambda pemfile: (\n                    serialization.load_pem_private_key(\n                        pemfile.read().encode(),\n                        password,\n                        unsafe_skip_rsa_key_validation=False,\n                    )\n                ),\n            )\n\n\nclass TestRSAPEMSerialization:\n    def test_password_length_limit(self, rsa_key_2048):\n        password = b\"x\" * 1024\n        with pytest.raises(ValueError):\n            rsa_key_2048.private_bytes(\n                serialization.Encoding.PEM,\n                serialization.PrivateFormat.PKCS8,\n                serialization.BestAvailableEncryption(password),\n            )\n\n\n@pytest.mark.skipif(\n    backend._lib.Cryptography_HAS_EVP_PKEY_DHX == 1,\n    reason=\"Requires OpenSSL without EVP_PKEY_DHX\",\n)\n@pytest.mark.supported(\n    only_if=lambda backend: backend.dh_supported(),\n    skip_message=\"Requires DH support\",\n)\nclass TestOpenSSLDHSerialization:\n    @pytest.mark.parametrize(\n        (\"key_path\", \"loader_func\"),\n        [\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.pem\"),\n                serialization.load_pem_private_key,\n            ),\n            (\n                os.path.join(\"asymmetric\", \"DH\", \"dhkey_rfc5114_2.der\"),\n                serialization.load_der_private_key,\n            ),\n        ],\n    )\n    def test_private_load_dhx_unsupported(\n        self, key_path, loader_func, backend\n    ):\n        key_bytes = load_vectors_from_file(\n            key_path, lambda pemfile: pemfile.read(), mode=\"rb\"\n        )\n        with pytest.raises(ValueError):\n            loader_func(key_bytes, None, backend)\n", "tests/hazmat/backends/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/_cffi_src/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nfrom cffi import FFI\n\n# Load the cryptography __about__ to get the current package version\nbase_src = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))\nabout: dict = {}\nwith open(os.path.join(base_src, \"cryptography\", \"__about__.py\")) as f:\n    exec(f.read(), about)\n\n\ndef build_ffi_for_binding(\n    module_name: str,\n    module_prefix: str,\n    modules: list[str],\n):\n    \"\"\"\n    Modules listed in ``modules`` should have the following attributes:\n\n    * ``INCLUDES``: A string containing C includes.\n    * ``TYPES``: A string containing C declarations for types.\n    * ``FUNCTIONS``: A string containing C declarations for functions & macros.\n    * ``CUSTOMIZATIONS``: A string containing arbitrary top-level C code, this\n        can be used to do things like test for a define and provide an\n        alternate implementation based on that.\n    \"\"\"\n    types = []\n    includes = []\n    functions = []\n    customizations = []\n    for name in modules:\n        __import__(module_prefix + name)\n        module = sys.modules[module_prefix + name]\n\n        types.append(module.TYPES)\n        functions.append(module.FUNCTIONS)\n        includes.append(module.INCLUDES)\n        customizations.append(module.CUSTOMIZATIONS)\n\n    verify_source = \"\\n\".join(includes + customizations)\n    return build_ffi(\n        module_name,\n        cdef_source=\"\\n\".join(types + functions),\n        verify_source=verify_source,\n    )\n\n\ndef build_ffi(\n    module_name: str,\n    cdef_source: str,\n    verify_source: str,\n):\n    ffi = FFI()\n    # Always add the CRYPTOGRAPHY_PACKAGE_VERSION to the shared object\n    cdef_source += \"\\nstatic const char *const CRYPTOGRAPHY_PACKAGE_VERSION;\"\n    verify_source += '\\n#define CRYPTOGRAPHY_PACKAGE_VERSION \"{}\"'.format(\n        about[\"__version__\"]\n    )\n    if platform.python_implementation() == \"PyPy\":\n        verify_source += r\"\"\"\nint Cryptography_make_openssl_module(void) {\n    int result;\n\n    Py_BEGIN_ALLOW_THREADS\n    result = cffi_start_python();\n    Py_END_ALLOW_THREADS\n\n    return result;\n}\n\"\"\"\n    ffi.cdef(cdef_source)\n    ffi.set_source(\n        module_name,\n        verify_source,\n    )\n    return ffi\n", "src/_cffi_src/__init__.py": "", "src/_cffi_src/build_openssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport pathlib\nimport platform\nimport sys\n\n# Add the src directory to the path so we can import _cffi_src.utils\nsrc_dir = str(pathlib.Path(__file__).parent.parent)\nsys.path.insert(0, src_dir)\n\nfrom _cffi_src.utils import build_ffi_for_binding  # noqa: E402\n\nffi = build_ffi_for_binding(\n    module_name=\"_openssl\",\n    module_prefix=\"_cffi_src.openssl.\",\n    modules=[\n        # This goes first so we can define some cryptography-wide symbols.\n        \"cryptography\",\n        \"asn1\",\n        \"bignum\",\n        \"bio\",\n        \"crypto\",\n        \"dh\",\n        \"dsa\",\n        \"ec\",\n        \"engine\",\n        \"err\",\n        \"evp\",\n        \"nid\",\n        \"objects\",\n        \"opensslv\",\n        \"pem\",\n        \"pkcs12\",\n        \"rand\",\n        \"rsa\",\n        \"ssl\",\n        \"x509\",\n        \"x509name\",\n        \"x509v3\",\n        \"x509_vfy\",\n        \"pkcs7\",\n    ],\n)\n\nif __name__ == \"__main__\":\n    out_dir = os.environ[\"OUT_DIR\"]\n    module_name, source, source_extension, kwds = ffi._assigned_source\n    c_file = os.path.join(out_dir, module_name + source_extension)\n    if platform.python_implementation() == \"PyPy\":\n        # Necessary because CFFI will ignore this if there's no declarations.\n        ffi.embedding_api(\n            \"\"\"\n            extern \"Python\" void Cryptography_unused(void);\n        \"\"\"\n        )\n        ffi.embedding_init_code(\"\")\n    ffi.emit_c_code(c_file)\n", "src/_cffi_src/openssl/engine.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/engine.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... ENGINE;\ntypedef ... UI_METHOD;\n\nstatic const long Cryptography_HAS_ENGINE;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nENGINE *ENGINE_by_id(const char *);\nint ENGINE_init(ENGINE *);\nint ENGINE_finish(ENGINE *);\nENGINE *ENGINE_get_default_RAND(void);\nint ENGINE_set_default_RAND(ENGINE *);\nvoid ENGINE_unregister_RAND(ENGINE *);\nint ENGINE_ctrl_cmd(ENGINE *, const char *, long, void *, void (*)(void), int);\nint ENGINE_free(ENGINE *);\nconst char *ENGINE_get_name(const ENGINE *);\n\n// These bindings are unused by cryptography or pyOpenSSL but are present\n// for advanced users who need them.\nint ENGINE_ctrl_cmd_string(ENGINE *, const char *, const char *, int);\nvoid ENGINE_load_builtin_engines(void);\nEVP_PKEY *ENGINE_load_private_key(ENGINE *, const char *, UI_METHOD *, void *);\nEVP_PKEY *ENGINE_load_public_key(ENGINE *, const char *, UI_METHOD *, void *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef OPENSSL_NO_ENGINE\nstatic const long Cryptography_HAS_ENGINE = 0;\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\ntypedef void UI_METHOD;\n#endif\n\n/* Despite being OPENSSL_NO_ENGINE, BoringSSL/LibreSSL define these symbols. */\n#if !CRYPTOGRAPHY_IS_BORINGSSL && !CRYPTOGRAPHY_IS_LIBRESSL\nint (*ENGINE_free)(ENGINE *) = NULL;\nvoid (*ENGINE_load_builtin_engines)(void) = NULL;\n#endif\n\nENGINE *(*ENGINE_get_default_RAND)(void) = NULL;\nint (*ENGINE_set_default_RAND)(ENGINE *) = NULL;\nvoid (*ENGINE_unregister_RAND)(ENGINE *) = NULL;\n\n#if !CRYPTOGRAPHY_IS_LIBRESSL\nENGINE *(*ENGINE_by_id)(const char *) = NULL;\nint (*ENGINE_init)(ENGINE *) = NULL;\nint (*ENGINE_finish)(ENGINE *) = NULL;\nint (*ENGINE_ctrl_cmd)(ENGINE *, const char *, long, void *,\n                       void (*)(void), int) = NULL;\n\nconst char *(*ENGINE_get_id)(const ENGINE *) = NULL;\nconst char *(*ENGINE_get_name)(const ENGINE *) = NULL;\n\nint (*ENGINE_ctrl_cmd_string)(ENGINE *, const char *, const char *,\n                              int) = NULL;\nEVP_PKEY *(*ENGINE_load_private_key)(ENGINE *, const char *, UI_METHOD *,\n                                     void *) = NULL;\nEVP_PKEY *(*ENGINE_load_public_key)(ENGINE *, const char *,\n                                    UI_METHOD *, void *) = NULL;\n#endif\n\n#else\nstatic const long Cryptography_HAS_ENGINE = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/asn1.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/asn1.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef int... time_t;\n\ntypedef ... ASN1_INTEGER;\n\nstruct asn1_string_st {\n    int length;\n    int type;\n    unsigned char *data;\n    long flags;\n};\n\ntypedef struct asn1_string_st ASN1_OCTET_STRING;\ntypedef struct asn1_string_st ASN1_IA5STRING;\ntypedef struct asn1_string_st ASN1_TIME;\ntypedef ... ASN1_OBJECT;\ntypedef struct asn1_string_st ASN1_STRING;\ntypedef struct asn1_string_st ASN1_UTF8STRING;\ntypedef ... ASN1_GENERALIZEDTIME;\ntypedef ... ASN1_ENUMERATED;\n\nstatic const int V_ASN1_GENERALIZEDTIME;\n\nstatic const int MBSTRING_UTF8;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n/*  ASN1 STRING */\nconst unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *);\n\n/*  ASN1 INTEGER */\nvoid ASN1_INTEGER_free(ASN1_INTEGER *);\nint ASN1_INTEGER_set(ASN1_INTEGER *, long);\n\n/*  ASN1 TIME */\nASN1_TIME *ASN1_TIME_new(void);\nvoid ASN1_TIME_free(ASN1_TIME *);\nint ASN1_TIME_set_string(ASN1_TIME *, const char *);\n\n/*  ASN1 GENERALIZEDTIME */\nvoid ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *);\n\n/*  ASN1 ENUMERATED */\nASN1_ENUMERATED *ASN1_ENUMERATED_new(void);\nvoid ASN1_ENUMERATED_free(ASN1_ENUMERATED *);\nint ASN1_ENUMERATED_set(ASN1_ENUMERATED *, long);\n\nint ASN1_STRING_type(const ASN1_STRING *);\nint ASN1_STRING_to_UTF8(unsigned char **, const ASN1_STRING *);\nint i2a_ASN1_INTEGER(BIO *, const ASN1_INTEGER *);\n\nASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *,\n                                                   ASN1_GENERALIZEDTIME **);\n\nint ASN1_STRING_length(ASN1_STRING *);\n\nBIGNUM *ASN1_INTEGER_to_BN(ASN1_INTEGER *, BIGNUM *);\nASN1_INTEGER *BN_to_ASN1_INTEGER(BIGNUM *, ASN1_INTEGER *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/opensslv.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/opensslv.h>\n\"\"\"\n\nTYPES = \"\"\"\n/* Note that these will be resolved when cryptography is compiled and are NOT\n   guaranteed to be the version that it actually loads. */\nstatic const int OPENSSL_VERSION_NUMBER;\nstatic const char *const OPENSSL_VERSION_TEXT;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/x509.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ssl.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\ntypedef STACK_OF(X509) Cryptography_STACK_OF_X509;\ntypedef STACK_OF(X509_CRL) Cryptography_STACK_OF_X509_CRL;\ntypedef STACK_OF(X509_REVOKED) Cryptography_STACK_OF_X509_REVOKED;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_X509;\ntypedef ... Cryptography_STACK_OF_X509_CRL;\ntypedef ... Cryptography_STACK_OF_X509_REVOKED;\n\ntypedef ... X509_ALGOR;\ntypedef ... X509_ATTRIBUTE;\ntypedef ... X509_EXTENSION;\ntypedef ... X509_EXTENSIONS;\ntypedef ... X509_REQ;\ntypedef ... X509_REVOKED;\ntypedef ... X509_CRL;\ntypedef ... X509;\n\ntypedef ... NETSCAPE_SPKI;\n\ntypedef ... PKCS8_PRIV_KEY_INFO;\n\ntypedef void (*sk_X509_EXTENSION_freefunc)(X509_EXTENSION *);\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509 *X509_new(void);\nvoid X509_free(X509 *);\nX509 *X509_dup(X509 *);\nint X509_up_ref(X509 *);\n\nint X509_print_ex(BIO *, X509 *, unsigned long, unsigned long);\n\nint X509_set_version(X509 *, long);\n\nEVP_PKEY *X509_get_pubkey(X509 *);\nint X509_set_pubkey(X509 *, EVP_PKEY *);\n\nunsigned char *X509_alias_get0(X509 *, int *);\nint X509_alias_set1(X509 *, const unsigned char *, int);\nint X509_sign(X509 *, EVP_PKEY *, const EVP_MD *);\n\nint X509_digest(const X509 *, const EVP_MD *, unsigned char *, unsigned int *);\n\nASN1_TIME *X509_gmtime_adj(ASN1_TIME *, long);\n\nunsigned long X509_subject_name_hash(X509 *);\n\nint X509_set_subject_name(X509 *, X509_NAME *);\n\nint X509_set_issuer_name(X509 *, X509_NAME *);\n\nint X509_add_ext(X509 *, X509_EXTENSION *, int);\nX509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *);\n\nASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *);\nvoid X509_EXTENSION_free(X509_EXTENSION *);\n\nint X509_REQ_set_version(X509_REQ *, long);\nX509_REQ *X509_REQ_new(void);\nvoid X509_REQ_free(X509_REQ *);\nint X509_REQ_set_pubkey(X509_REQ *, EVP_PKEY *);\nint X509_REQ_sign(X509_REQ *, EVP_PKEY *, const EVP_MD *);\nint X509_REQ_verify(X509_REQ *, EVP_PKEY *);\nEVP_PKEY *X509_REQ_get_pubkey(X509_REQ *);\nint X509_REQ_print_ex(BIO *, X509_REQ *, unsigned long, unsigned long);\nint X509_REQ_add_extensions(X509_REQ *, X509_EXTENSIONS *);\nX509_EXTENSIONS *X509_REQ_get_extensions(X509_REQ *);\n\nint X509V3_EXT_print(BIO *, X509_EXTENSION *, unsigned long, int);\nASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *);\n\nX509_REVOKED *X509_REVOKED_new(void);\nvoid X509_REVOKED_free(X509_REVOKED *);\n\nint X509_REVOKED_set_serialNumber(X509_REVOKED *, ASN1_INTEGER *);\n\nint X509_REVOKED_add1_ext_i2d(X509_REVOKED *, int, void *, int, unsigned long);\nX509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *, int);\n\nint X509_REVOKED_set_revocationDate(X509_REVOKED *, ASN1_TIME *);\n\nX509_CRL *X509_CRL_new(void);\nX509_CRL *d2i_X509_CRL_bio(BIO *, X509_CRL **);\nint X509_CRL_add0_revoked(X509_CRL *, X509_REVOKED *);\nint X509_CRL_print(BIO *, X509_CRL *);\nint X509_CRL_set_issuer_name(X509_CRL *, X509_NAME *);\nint X509_CRL_set_version(X509_CRL *, long);\nint X509_CRL_sign(X509_CRL *, EVP_PKEY *, const EVP_MD *);\nint X509_CRL_sort(X509_CRL *);\nint i2d_X509_CRL_bio(BIO *, X509_CRL *);\nvoid X509_CRL_free(X509_CRL *);\n\nint NETSCAPE_SPKI_verify(NETSCAPE_SPKI *, EVP_PKEY *);\nint NETSCAPE_SPKI_sign(NETSCAPE_SPKI *, EVP_PKEY *, const EVP_MD *);\nchar *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *);\nEVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *);\nint NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *, EVP_PKEY *);\nNETSCAPE_SPKI *NETSCAPE_SPKI_new(void);\nvoid NETSCAPE_SPKI_free(NETSCAPE_SPKI *);\n\n/*  ASN1 serialization */\nint i2d_X509_bio(BIO *, X509 *);\nX509 *d2i_X509_bio(BIO *, X509 **);\n\nint i2d_X509_REQ_bio(BIO *, X509_REQ *);\nX509_REQ *d2i_X509_REQ_bio(BIO *, X509_REQ **);\n\nint i2d_PrivateKey_bio(BIO *, EVP_PKEY *);\nEVP_PKEY *d2i_PrivateKey_bio(BIO *, EVP_PKEY **);\nint i2d_PUBKEY_bio(BIO *, EVP_PKEY *);\nEVP_PKEY *d2i_PUBKEY_bio(BIO *, EVP_PKEY **);\n\nASN1_INTEGER *X509_get_serialNumber(X509 *);\nint X509_set_serialNumber(X509 *, ASN1_INTEGER *);\n\nconst char *X509_verify_cert_error_string(long);\n\nconst char *X509_get_default_cert_dir(void);\nconst char *X509_get_default_cert_file(void);\nconst char *X509_get_default_cert_dir_env(void);\nconst char *X509_get_default_cert_file_env(void);\n\nint X509_get_ext_count(const X509 *);\nX509_EXTENSION *X509_get_ext(const X509 *, int);\nX509_NAME *X509_get_subject_name(const X509 *);\nX509_NAME *X509_get_issuer_name(const X509 *);\n\nint X509_EXTENSION_get_critical(const X509_EXTENSION *);\n\nint X509_REVOKED_get_ext_count(const X509_REVOKED *);\nX509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *, int);\n\nX509_REVOKED *X509_REVOKED_dup(X509_REVOKED *);\n\nconst X509_ALGOR *X509_get0_tbs_sigalg(const X509 *);\n\nlong X509_get_version(X509 *);\n\nASN1_TIME *X509_getm_notBefore(const X509 *);\nASN1_TIME *X509_getm_notAfter(const X509 *);\n\nlong X509_REQ_get_version(X509_REQ *);\nX509_NAME *X509_REQ_get_subject_name(X509_REQ *);\n\nCryptography_STACK_OF_X509 *sk_X509_new_null(void);\nvoid sk_X509_free(Cryptography_STACK_OF_X509 *);\nint sk_X509_num(Cryptography_STACK_OF_X509 *);\nint sk_X509_push(Cryptography_STACK_OF_X509 *, X509 *);\nX509 *sk_X509_value(Cryptography_STACK_OF_X509 *, int);\n\nX509_EXTENSIONS *sk_X509_EXTENSION_new_null(void);\nint sk_X509_EXTENSION_num(X509_EXTENSIONS *);\nX509_EXTENSION *sk_X509_EXTENSION_value(X509_EXTENSIONS *, int);\nint sk_X509_EXTENSION_push(X509_EXTENSIONS *, X509_EXTENSION *);\nvoid sk_X509_EXTENSION_free(X509_EXTENSIONS *);\nvoid sk_X509_EXTENSION_pop_free(X509_EXTENSIONS *, sk_X509_EXTENSION_freefunc);\n\nint sk_X509_REVOKED_num(Cryptography_STACK_OF_X509_REVOKED *);\nX509_REVOKED *sk_X509_REVOKED_value(Cryptography_STACK_OF_X509_REVOKED *, int);\n\nX509_NAME *X509_CRL_get_issuer(X509_CRL *);\nCryptography_STACK_OF_X509_REVOKED *X509_CRL_get_REVOKED(X509_CRL *);\n\nint X509_CRL_set1_lastUpdate(X509_CRL *, const ASN1_TIME *);\nint X509_CRL_set1_nextUpdate(X509_CRL *, const ASN1_TIME *);\n\nconst ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *);\nconst ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *);\n\nvoid X509_ALGOR_get0(const ASN1_OBJECT **, int *, const void **,\n                     const X509_ALGOR *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/cryptography.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = r\"\"\"\n/* define our OpenSSL API compatibility level to 1.1.0. Any symbols older than\n   that will raise an error during compilation. */\n#define OPENSSL_API_COMPAT 0x10100000L\n\n#if defined(_WIN32)\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>\n#include <Wincrypt.h>\n#include <Winsock2.h>\n/*\n    undef some macros that are defined by wincrypt.h but are also types in\n    boringssl. openssl has worked around this but boring has not yet. see:\n    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base\n    /win/wincrypt_shim.h\n*/\n#undef X509_NAME\n#undef X509_EXTENSIONS\n#undef PKCS7_SIGNER_INFO\n#endif\n\n#include <openssl/opensslv.h>\n\n\n#if defined(LIBRESSL_VERSION_NUMBER)\n#define CRYPTOGRAPHY_IS_LIBRESSL 1\n#else\n#define CRYPTOGRAPHY_IS_LIBRESSL 0\n#endif\n\n#if defined(OPENSSL_IS_BORINGSSL)\n#define CRYPTOGRAPHY_IS_BORINGSSL 1\n#else\n#define CRYPTOGRAPHY_IS_BORINGSSL 0\n#endif\n\n#if OPENSSL_VERSION_NUMBER < 0x10101050\n    #error \"pyca/cryptography MUST be linked with Openssl 1.1.1e or later\"\n#endif\n\n#define CRYPTOGRAPHY_OPENSSL_300_OR_GREATER \\\n    (OPENSSL_VERSION_NUMBER >= 0x30000000 && !CRYPTOGRAPHY_IS_LIBRESSL)\n#define CRYPTOGRAPHY_OPENSSL_320_OR_GREATER \\\n    (OPENSSL_VERSION_NUMBER >= 0x30200000 && !CRYPTOGRAPHY_IS_LIBRESSL)\n\"\"\"\n\nTYPES = \"\"\"\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/bio.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/bio.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... BIO;\ntypedef ... BIO_METHOD;\ntypedef ... BIO_ADDR;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint BIO_free(BIO *);\nBIO *BIO_new_file(const char *, const char *);\nint BIO_read(BIO *, void *, int);\nint BIO_write(BIO *, const void *, int);\n\nBIO *BIO_new(BIO_METHOD *);\nconst BIO_METHOD *BIO_s_mem(void);\nBIO *BIO_new_mem_buf(const void *, int);\nlong BIO_set_mem_eof_return(BIO *, int);\nlong BIO_get_mem_data(BIO *, char **);\nint BIO_should_read(BIO *);\nint BIO_should_write(BIO *);\nint BIO_should_io_special(BIO *);\nint BIO_should_retry(BIO *);\nint BIO_reset(BIO *);\n\nBIO_ADDR *BIO_ADDR_new(void);\nvoid BIO_ADDR_free(BIO_ADDR *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\n\n#if !defined(_WIN32)\n#include <sys/socket.h>\n#endif\n\n#include <stdlib.h>\ntypedef struct sockaddr BIO_ADDR;\n\nBIO_ADDR *BIO_ADDR_new(void) {\n    return malloc(sizeof(struct sockaddr_storage));\n}\n\nvoid BIO_ADDR_free(BIO_ADDR *ptr) {\n    free(ptr);\n}\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/dh.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... DH;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid DH_free(DH *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/dsa.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... DSA;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint DSA_generate_key(DSA *);\nDSA *DSA_new(void);\nvoid DSA_free(DSA *);\n\nint DSA_generate_parameters_ex(DSA *, int, unsigned char *, int,\n                               int *, unsigned long *, BN_GENCB *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ec.h>\n#include <openssl/obj_mac.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EC_KEY;\ntypedef struct {\n    int nid;\n    const char *comment;\n} EC_builtin_curve;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nsize_t EC_get_builtin_curves(EC_builtin_curve *, size_t);\n\nvoid EC_KEY_free(EC_KEY *);\n\nEC_KEY *EC_KEY_new_by_curve_name(int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/bignum.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/bn.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PRIME_CHECKS;\n\ntypedef ... BN_CTX;\ntypedef ... BIGNUM;\ntypedef int... BN_ULONG;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nBIGNUM *BN_new(void);\nvoid BN_free(BIGNUM *);\n\nint BN_rand_range(BIGNUM *, const BIGNUM *);\n\nint BN_set_word(BIGNUM *, BN_ULONG);\n\nchar *BN_bn2hex(const BIGNUM *);\nint BN_hex2bn(BIGNUM **, const char *);\n\n/* The following 3 prime methods are exposed for Tribler. */\nint BN_generate_prime_ex(BIGNUM *, int, int, const BIGNUM *,\n                         const BIGNUM *, BN_GENCB *);\nint BN_is_prime_ex(const BIGNUM *, int, BN_CTX *, BN_GENCB *);\nconst int BN_prime_checks_for_size(int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PRIME_CHECKS = 0;\nint (*BN_prime_checks_for_size)(int) = NULL;\n#else\nstatic const long Cryptography_HAS_PRIME_CHECKS = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/objects.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/objects.h>\n\"\"\"\n\nTYPES = \"\"\"\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst char *OBJ_nid2ln(int);\nconst char *OBJ_nid2sn(int);\nint OBJ_obj2nid(const ASN1_OBJECT *);\nint OBJ_txt2nid(const char *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/pkcs12.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pkcs12.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PKCS12_SET_MAC;\n\ntypedef ... PKCS12;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid PKCS12_free(PKCS12 *);\n\nPKCS12 *d2i_PKCS12_bio(BIO *, PKCS12 **);\nint i2d_PKCS12_bio(BIO *, PKCS12 *);\nint PKCS12_parse(PKCS12 *, const char *, EVP_PKEY **, X509 **,\n                 Cryptography_STACK_OF_X509 **);\nPKCS12 *PKCS12_create(char *, char *, EVP_PKEY *, X509 *,\n                      Cryptography_STACK_OF_X509 *, int, int, int, int, int);\nint PKCS12_set_mac(PKCS12 *, const char *, int, unsigned char *, int, int,\n                   const EVP_MD *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PKCS12_SET_MAC = 0;\nint (*PKCS12_set_mac)(PKCS12 *, const char *, int, unsigned char *, int, int,\n                      const EVP_MD *) = NULL;\n#else\nstatic const long Cryptography_HAS_PKCS12_SET_MAC = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/rand.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/rand.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... RAND_METHOD;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid RAND_add(const void *, int, double);\nint RAND_status(void);\nint RAND_bytes(unsigned char *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/ssl.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/ssl.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_SSL_ST;\nstatic const long Cryptography_HAS_TLS_ST;\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS;\nstatic const long Cryptography_HAS_SIGALGS;\nstatic const long Cryptography_HAS_PSK;\nstatic const long Cryptography_HAS_PSK_TLSv1_3;\nstatic const long Cryptography_HAS_VERIFIED_CHAIN;\nstatic const long Cryptography_HAS_KEYLOG;\nstatic const long Cryptography_HAS_SSL_COOKIE;\n\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION;\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF;\nstatic const long Cryptography_HAS_ALPN;\nstatic const long Cryptography_HAS_NEXTPROTONEG;\nstatic const long Cryptography_HAS_SET_CERT_CB;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT;\nstatic const long Cryptography_HAS_CUSTOM_EXT;\nstatic const long Cryptography_HAS_SRTP;\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU;\n\nstatic const long SSL_FILETYPE_PEM;\nstatic const long SSL_FILETYPE_ASN1;\nstatic const long SSL_ERROR_NONE;\nstatic const long SSL_ERROR_ZERO_RETURN;\nstatic const long SSL_ERROR_WANT_READ;\nstatic const long SSL_ERROR_WANT_WRITE;\nstatic const long SSL_ERROR_WANT_X509_LOOKUP;\nstatic const long SSL_ERROR_SYSCALL;\nstatic const long SSL_ERROR_SSL;\nstatic const long SSL_SENT_SHUTDOWN;\nstatic const long SSL_RECEIVED_SHUTDOWN;\nstatic const long SSL_OP_NO_SSLv2;\nstatic const long SSL_OP_NO_SSLv3;\nstatic const long SSL_OP_NO_TLSv1;\nstatic const long SSL_OP_NO_TLSv1_1;\nstatic const long SSL_OP_NO_TLSv1_2;\nstatic const long SSL_OP_NO_TLSv1_3;\nstatic const long SSL_OP_NO_RENEGOTIATION;\nstatic const long SSL_OP_NO_COMPRESSION;\nstatic const long SSL_OP_SINGLE_DH_USE;\nstatic const long SSL_OP_EPHEMERAL_RSA;\nstatic const long SSL_OP_MICROSOFT_SESS_ID_BUG;\nstatic const long SSL_OP_NETSCAPE_CHALLENGE_BUG;\nstatic const long SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG;\nstatic const long SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG;\nstatic const long SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER;\nstatic const long SSL_OP_MSIE_SSLV2_RSA_PADDING;\nstatic const long SSL_OP_SSLEAY_080_CLIENT_DH_BUG;\nstatic const long SSL_OP_TLS_D5_BUG;\nstatic const long SSL_OP_TLS_BLOCK_PADDING_BUG;\nstatic const long SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS;\nstatic const long SSL_OP_CIPHER_SERVER_PREFERENCE;\nstatic const long SSL_OP_TLS_ROLLBACK_BUG;\nstatic const long SSL_OP_PKCS1_CHECK_1;\nstatic const long SSL_OP_PKCS1_CHECK_2;\nstatic const long SSL_OP_NETSCAPE_CA_DN_BUG;\nstatic const long SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG;\nstatic const long SSL_OP_NO_QUERY_MTU;\nstatic const long SSL_OP_COOKIE_EXCHANGE;\nstatic const long SSL_OP_NO_TICKET;\nstatic const long SSL_OP_ALL;\nstatic const long SSL_OP_SINGLE_ECDH_USE;\nstatic const long SSL_OP_IGNORE_UNEXPECTED_EOF;\nstatic const long SSL_OP_LEGACY_SERVER_CONNECT;\nstatic const long SSL_VERIFY_PEER;\nstatic const long SSL_VERIFY_FAIL_IF_NO_PEER_CERT;\nstatic const long SSL_VERIFY_CLIENT_ONCE;\nstatic const long SSL_VERIFY_NONE;\nstatic const long SSL_VERIFY_POST_HANDSHAKE;\nstatic const long SSL_SESS_CACHE_OFF;\nstatic const long SSL_SESS_CACHE_CLIENT;\nstatic const long SSL_SESS_CACHE_SERVER;\nstatic const long SSL_SESS_CACHE_BOTH;\nstatic const long SSL_SESS_CACHE_NO_AUTO_CLEAR;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL_LOOKUP;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL_STORE;\nstatic const long SSL_SESS_CACHE_NO_INTERNAL;\nstatic const long SSL_ST_CONNECT;\nstatic const long SSL_ST_ACCEPT;\nstatic const long SSL_ST_MASK;\nstatic const long SSL_ST_INIT;\nstatic const long SSL_ST_BEFORE;\nstatic const long SSL_ST_OK;\nstatic const long SSL_ST_RENEGOTIATE;\nstatic const long SSL_CB_LOOP;\nstatic const long SSL_CB_EXIT;\nstatic const long SSL_CB_READ;\nstatic const long SSL_CB_WRITE;\nstatic const long SSL_CB_ALERT;\nstatic const long SSL_CB_READ_ALERT;\nstatic const long SSL_CB_WRITE_ALERT;\nstatic const long SSL_CB_ACCEPT_LOOP;\nstatic const long SSL_CB_ACCEPT_EXIT;\nstatic const long SSL_CB_CONNECT_LOOP;\nstatic const long SSL_CB_CONNECT_EXIT;\nstatic const long SSL_CB_HANDSHAKE_START;\nstatic const long SSL_CB_HANDSHAKE_DONE;\nstatic const long SSL_MODE_RELEASE_BUFFERS;\nstatic const long SSL_MODE_ENABLE_PARTIAL_WRITE;\nstatic const long SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;\nstatic const long SSL_MODE_AUTO_RETRY;\nstatic const long TLS_ST_BEFORE;\nstatic const long TLS_ST_OK;\n\nstatic const long SSL3_VERSION;\nstatic const long TLS1_VERSION;\nstatic const long TLS1_1_VERSION;\nstatic const long TLS1_2_VERSION;\nstatic const long TLS1_3_VERSION;\n\ntypedef ... SSL_METHOD;\ntypedef ... SSL_CTX;\n\ntypedef ... SSL_SESSION;\n\ntypedef ... SSL;\n\nstatic const long TLSEXT_NAMETYPE_host_name;\nstatic const long TLSEXT_STATUSTYPE_ocsp;\n\ntypedef ... SSL_CIPHER;\n\ntypedef struct {\n    const char *name;\n    unsigned long id;\n} SRTP_PROTECTION_PROFILE;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n/*  SSL */\nconst char *SSL_state_string_long(const SSL *);\nSSL_SESSION *SSL_get1_session(SSL *);\nint SSL_set_session(SSL *, SSL_SESSION *);\nint SSL_session_reused(const SSL *);\nSSL *SSL_new(SSL_CTX *);\nvoid SSL_free(SSL *);\nint SSL_set_fd(SSL *, int);\nSSL_CTX *SSL_set_SSL_CTX(SSL *, SSL_CTX *);\nvoid SSL_set_bio(SSL *, BIO *, BIO *);\nvoid SSL_set_connect_state(SSL *);\nvoid SSL_set_accept_state(SSL *);\nvoid SSL_set_shutdown(SSL *, int);\nint SSL_get_shutdown(const SSL *);\nint SSL_pending(const SSL *);\nint SSL_write(SSL *, const void *, int);\nint SSL_read(SSL *, void *, int);\nint SSL_peek(SSL *, void *, int);\nX509 *SSL_get_certificate(const SSL *);\nX509 *SSL_get_peer_certificate(const SSL *);\nint SSL_get_ex_data_X509_STORE_CTX_idx(void);\nvoid SSL_set_verify(SSL *, int, int (*)(int, X509_STORE_CTX *));\nint SSL_get_verify_mode(const SSL *);\n\nlong SSL_get_extms_support(SSL *);\n\nX509_VERIFY_PARAM *SSL_get0_param(SSL *);\nX509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *);\n\nCryptography_STACK_OF_X509 *SSL_get_peer_cert_chain(const SSL *);\nCryptography_STACK_OF_X509 *SSL_get0_verified_chain(const SSL *);\nCryptography_STACK_OF_X509_NAME *SSL_get_client_CA_list(const SSL *);\n\nint SSL_get_error(const SSL *, int);\nlong SSL_get_verify_result(const SSL *ssl);\nint SSL_do_handshake(SSL *);\nint SSL_shutdown(SSL *);\nint SSL_renegotiate(SSL *);\nint SSL_renegotiate_pending(SSL *);\nconst char *SSL_get_cipher_list(const SSL *, int);\nint SSL_use_certificate(SSL *, X509 *);\nint SSL_use_PrivateKey(SSL *, EVP_PKEY *);\n\n/*  context */\nvoid SSL_CTX_free(SSL_CTX *);\nlong SSL_CTX_set_timeout(SSL_CTX *, long);\nint SSL_CTX_set_default_verify_paths(SSL_CTX *);\nvoid SSL_CTX_set_verify(SSL_CTX *, int, int (*)(int, X509_STORE_CTX *));\nvoid SSL_CTX_set_verify_depth(SSL_CTX *, int);\nint SSL_CTX_get_verify_mode(const SSL_CTX *);\nint SSL_CTX_get_verify_depth(const SSL_CTX *);\nint SSL_CTX_set_cipher_list(SSL_CTX *, const char *);\nint SSL_CTX_load_verify_locations(SSL_CTX *, const char *, const char *);\nvoid SSL_CTX_set_default_passwd_cb(SSL_CTX *, pem_password_cb *);\nint SSL_CTX_use_certificate(SSL_CTX *, X509 *);\nint SSL_CTX_use_certificate_file(SSL_CTX *, const char *, int);\nint SSL_CTX_use_certificate_chain_file(SSL_CTX *, const char *);\nint SSL_CTX_use_PrivateKey(SSL_CTX *, EVP_PKEY *);\nint SSL_CTX_use_PrivateKey_file(SSL_CTX *, const char *, int);\nint SSL_CTX_check_private_key(const SSL_CTX *);\n\nvoid SSL_CTX_set_cookie_generate_cb(SSL_CTX *,\n                                    int (*)(\n                                        SSL *,\n                                        unsigned char *,\n                                        unsigned int *\n                                    ));\nvoid SSL_CTX_set_cookie_verify_cb(SSL_CTX *,\n                                    int (*)(\n                                        SSL *,\n                                        const unsigned char *,\n                                        unsigned int\n                                    ));\n\nint SSL_CTX_use_psk_identity_hint(SSL_CTX *, const char *);\nvoid SSL_CTX_set_psk_server_callback(SSL_CTX *,\n                                     unsigned int (*)(\n                                         SSL *,\n                                         const char *,\n                                         unsigned char *,\n                                         unsigned int\n                                     ));\nvoid SSL_CTX_set_psk_client_callback(SSL_CTX *,\n                                     unsigned int (*)(\n                                         SSL *,\n                                         const char *,\n                                         char *,\n                                         unsigned int,\n                                         unsigned char *,\n                                         unsigned int\n                                     ));\nvoid SSL_CTX_set_psk_find_session_callback(SSL_CTX *,\n                                           int (*)(\n                                               SSL *,\n                                               const unsigned char *,\n                                               size_t,\n                                               SSL_SESSION **\n                                           ));\nvoid SSL_CTX_set_psk_use_session_callback(SSL_CTX *,\n                                          int (*)(\n                                              SSL *,\n                                              const EVP_MD *,\n                                              const unsigned char **,\n                                              size_t *,\n                                              SSL_SESSION **\n                                          ));\nconst SSL_CIPHER *SSL_CIPHER_find(SSL *, const unsigned char *);\n/* Wrap SSL_SESSION_new to avoid namespace collision. */\nSSL_SESSION *Cryptography_SSL_SESSION_new(void);\nint SSL_SESSION_set1_master_key(SSL_SESSION *, const unsigned char *,\n                                 size_t);\nint SSL_SESSION_set_cipher(SSL_SESSION *, const SSL_CIPHER *);\nint SSL_SESSION_set_protocol_version(SSL_SESSION *, int);\n\nint SSL_CTX_set_session_id_context(SSL_CTX *, const unsigned char *,\n                                   unsigned int);\n\nX509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);\nvoid SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);\nint SSL_CTX_add_client_CA(SSL_CTX *, X509 *);\n\nvoid SSL_CTX_set_client_CA_list(SSL_CTX *, Cryptography_STACK_OF_X509_NAME *);\n\nvoid SSL_CTX_set_info_callback(SSL_CTX *, void (*)(const SSL *, int, int));\n\nvoid SSL_CTX_set_msg_callback(SSL_CTX *,\n                              void (*)(\n                                int,\n                                int,\n                                int,\n                                const void *,\n                                size_t,\n                                SSL *,\n                                void *\n                              ));\nvoid SSL_CTX_set_msg_callback_arg(SSL_CTX *, void *);\n\nvoid SSL_CTX_set_keylog_callback(SSL_CTX *,\n                                 void (*)(const SSL *, const char *));\nvoid (*SSL_CTX_get_keylog_callback(SSL_CTX *))(const SSL *, const char *);\n\nlong SSL_CTX_set1_sigalgs_list(SSL_CTX *, const char *);\n\n/*  SSL_SESSION */\nvoid SSL_SESSION_free(SSL_SESSION *);\n\n/* Information about actually used cipher */\nconst char *SSL_CIPHER_get_name(const SSL_CIPHER *);\nint SSL_CIPHER_get_bits(const SSL_CIPHER *, int *);\n\nsize_t SSL_get_finished(const SSL *, void *, size_t);\nsize_t SSL_get_peer_finished(const SSL *, void *, size_t);\nCryptography_STACK_OF_X509_NAME *SSL_load_client_CA_file(const char *);\n\nconst char *SSL_get_servername(const SSL *, const int);\nconst char *SSL_CIPHER_get_version(const SSL_CIPHER *);\n\nSSL_SESSION *SSL_get_session(const SSL *);\n\nuint64_t SSL_set_options(SSL *, uint64_t);\nuint64_t SSL_get_options(SSL *);\n\nint SSL_want_read(const SSL *);\nint SSL_want_write(const SSL *);\n\nlong SSL_total_renegotiations(SSL *);\n\nlong SSL_CTX_set_min_proto_version(SSL_CTX *, int);\nlong SSL_CTX_set_max_proto_version(SSL_CTX *, int);\n\nlong SSL_CTX_set_tmp_ecdh(SSL_CTX *, EC_KEY *);\nlong SSL_CTX_set_tmp_dh(SSL_CTX *, DH *);\nlong SSL_CTX_set_session_cache_mode(SSL_CTX *, long);\nlong SSL_CTX_get_session_cache_mode(SSL_CTX *);\nlong SSL_CTX_add_extra_chain_cert(SSL_CTX *, X509 *);\n\nuint64_t SSL_CTX_set_options(SSL_CTX *, uint64_t);\nuint64_t SSL_CTX_get_options(SSL_CTX *);\n\nlong SSL_CTX_set_mode(SSL_CTX *, long);\nlong SSL_CTX_clear_mode(SSL_CTX *, long);\nlong SSL_set_mode(SSL *, long);\nlong SSL_clear_mode(SSL *, long);\n\nconst SSL_METHOD *DTLS_method(void);\nconst SSL_METHOD *DTLS_server_method(void);\nconst SSL_METHOD *DTLS_client_method(void);\n\nconst SSL_METHOD *TLS_method(void);\nconst SSL_METHOD *TLS_server_method(void);\nconst SSL_METHOD *TLS_client_method(void);\n\n/*- These aren't macros these arguments are all const X on openssl > 1.0.x -*/\nSSL_CTX *SSL_CTX_new(SSL_METHOD *);\nlong SSL_CTX_get_timeout(const SSL_CTX *);\n\nconst SSL_CIPHER *SSL_get_current_cipher(const SSL *);\nconst char *SSL_get_version(const SSL *);\nint SSL_version(const SSL *);\n\nvoid SSL_set_tlsext_host_name(SSL *, char *);\nvoid SSL_CTX_set_tlsext_servername_callback(\n    SSL_CTX *,\n    int (*)(SSL *, int *, void *));\n\nlong SSL_set_tlsext_status_ocsp_resp(SSL *, unsigned char *, int);\nlong SSL_get_tlsext_status_ocsp_resp(SSL *, const unsigned char **);\nlong SSL_set_tlsext_status_type(SSL *, long);\nlong SSL_CTX_set_tlsext_status_cb(SSL_CTX *, int(*)(SSL *, void *));\nlong SSL_CTX_set_tlsext_status_arg(SSL_CTX *, void *);\n\nint SSL_CTX_set_tlsext_use_srtp(SSL_CTX *, const char *);\nint SSL_set_tlsext_use_srtp(SSL *, const char *);\nSRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *);\n\nint SSL_CTX_set_alpn_protos(SSL_CTX *, const unsigned char *, unsigned);\nint SSL_set_alpn_protos(SSL *, const unsigned char *, unsigned);\nvoid SSL_CTX_set_alpn_select_cb(SSL_CTX *,\n                                int (*) (SSL *,\n                                         const unsigned char **,\n                                         unsigned char *,\n                                         const unsigned char *,\n                                         unsigned int,\n                                         void *),\n                                void *);\nvoid SSL_get0_alpn_selected(const SSL *, const unsigned char **, unsigned *);\n\nvoid SSL_CTX_set_cert_cb(SSL_CTX *, int (*)(SSL *, void *), void *);\nvoid SSL_set_cert_cb(SSL *, int (*)(SSL *, void *), void *);\n\nsize_t SSL_SESSION_get_master_key(const SSL_SESSION *, unsigned char *,\n                                  size_t);\nsize_t SSL_get_client_random(const SSL *, unsigned char *, size_t);\nsize_t SSL_get_server_random(const SSL *, unsigned char *, size_t);\nint SSL_export_keying_material(SSL *, unsigned char *, size_t, const char *,\n                               size_t, const unsigned char *, size_t, int);\n\n/* DTLS support */\nlong Cryptography_DTLSv1_get_timeout(SSL *, time_t *, long *);\nlong DTLSv1_handle_timeout(SSL *);\nlong SSL_set_mtu(SSL *, long);\nint DTLSv1_listen(SSL *, BIO_ADDR *);\nsize_t DTLS_get_data_mtu(SSL *);\n\n\n/* Custom extensions. */\ntypedef int (*custom_ext_add_cb)(SSL *, unsigned int,\n                                 const unsigned char **,\n                                 size_t *, int *,\n                                 void *);\n\ntypedef void (*custom_ext_free_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   void *);\n\ntypedef int (*custom_ext_parse_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   size_t, int *,\n                                   void *);\n\nint SSL_CTX_add_client_custom_ext(SSL_CTX *, unsigned int,\n                                  custom_ext_add_cb,\n                                  custom_ext_free_cb, void *,\n                                  custom_ext_parse_cb,\n                                  void *);\n\nint SSL_CTX_add_server_custom_ext(SSL_CTX *, unsigned int,\n                                  custom_ext_add_cb,\n                                  custom_ext_free_cb, void *,\n                                  custom_ext_parse_cb,\n                                  void *);\n\nint SSL_extension_supported(unsigned int);\n\nint SSL_CTX_set_ciphersuites(SSL_CTX *, const char *);\nint SSL_verify_client_post_handshake(SSL *);\nvoid SSL_CTX_set_post_handshake_auth(SSL_CTX *, int);\nvoid SSL_set_post_handshake_auth(SSL *, int);\n\nuint32_t SSL_SESSION_get_max_early_data(const SSL_SESSION *);\nint SSL_write_early_data(SSL *, const void *, size_t, size_t *);\nint SSL_read_early_data(SSL *, void *, size_t, size_t *);\nint SSL_CTX_set_max_early_data(SSL_CTX *, uint32_t);\n\n/*\n  Added as an advanced user escape hatch. This symbol is tied to\n  engine support but is declared in ssl.h\n*/\nint SSL_CTX_set_client_cert_engine(SSL_CTX *, ENGINE *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef OPENSSL_NO_ENGINE\nint (*SSL_CTX_set_client_cert_engine)(SSL_CTX *, ENGINE *) = NULL;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_VERIFIED_CHAIN = 0;\nCryptography_STACK_OF_X509 *(*SSL_get0_verified_chain)(const SSL *) = NULL;\n#else\nstatic const long Cryptography_HAS_VERIFIED_CHAIN = 1;\n#endif\n\nstatic const long Cryptography_HAS_KEYLOG = 1;\n\nstatic const long Cryptography_HAS_NEXTPROTONEG = 0;\nstatic const long Cryptography_HAS_ALPN = 1;\n\n#ifdef SSL_OP_NO_RENEGOTIATION\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION = 1;\n#else\nstatic const long Cryptography_HAS_OP_NO_RENEGOTIATION = 0;\nstatic const long SSL_OP_NO_RENEGOTIATION = 0;\n#endif\n\n#ifdef SSL_OP_IGNORE_UNEXPECTED_EOF\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF = 1;\n#else\nstatic const long Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF = 0;\nstatic const long SSL_OP_IGNORE_UNEXPECTED_EOF = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL\nvoid (*SSL_CTX_set_cert_cb)(SSL_CTX *, int (*)(SSL *, void *), void *) = NULL;\nvoid (*SSL_set_cert_cb)(SSL *, int (*)(SSL *, void *), void *) = NULL;\nstatic const long Cryptography_HAS_SET_CERT_CB = 0;\n\nlong (*SSL_get_extms_support)(SSL *) = NULL;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT = 0;\n#else\nstatic const long Cryptography_HAS_SET_CERT_CB = 1;\nstatic const long Cryptography_HAS_GET_EXTMS_SUPPORT = 1;\n#endif\n\n/* in OpenSSL 1.1.0 the SSL_ST values were renamed to TLS_ST and several were\n   removed */\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_SSL_ST = 1;\n#else\nstatic const long Cryptography_HAS_SSL_ST = 0;\nstatic const long SSL_ST_BEFORE = 0;\nstatic const long SSL_ST_OK = 0;\nstatic const long SSL_ST_INIT = 0;\nstatic const long SSL_ST_RENEGOTIATE = 0;\n#endif\n#if !CRYPTOGRAPHY_IS_LIBRESSL\nstatic const long Cryptography_HAS_TLS_ST = 1;\n#else\nstatic const long Cryptography_HAS_TLS_ST = 0;\nstatic const long TLS_ST_BEFORE = 0;\nstatic const long TLS_ST_OK = 0;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU = 0;\nsize_t (*DTLS_get_data_mtu)(SSL *) = NULL;\n#else\nstatic const long Cryptography_HAS_DTLS_GET_DATA_MTU = 1;\n#endif\n\n/* Wrap DTLSv1_get_timeout to avoid cffi to handle a 'struct timeval'. */\nlong Cryptography_DTLSv1_get_timeout(SSL *ssl, time_t *ptv_sec,\n                                     long *ptv_usec) {\n    struct timeval tv = { 0 };\n    long r = DTLSv1_get_timeout(ssl, &tv);\n\n    if (r == 1) {\n        if (ptv_sec) {\n            *ptv_sec = tv.tv_sec;\n        }\n\n        if (ptv_usec) {\n            *ptv_usec = tv.tv_usec;\n        }\n    }\n\n    return r;\n}\n\n#if CRYPTOGRAPHY_IS_LIBRESSL\nstatic const long Cryptography_HAS_SIGALGS = 0;\nconst long (*SSL_CTX_set1_sigalgs_list)(SSL_CTX *, const char *) = NULL;\n#else\nstatic const long Cryptography_HAS_SIGALGS = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_LIBRESSL || defined(OPENSSL_NO_PSK)\nstatic const long Cryptography_HAS_PSK = 0;\nint (*SSL_CTX_use_psk_identity_hint)(SSL_CTX *, const char *) = NULL;\nvoid (*SSL_CTX_set_psk_server_callback)(SSL_CTX *,\n                                        unsigned int (*)(\n                                            SSL *,\n                                            const char *,\n                                            unsigned char *,\n                                            unsigned int\n                                        )) = NULL;\nvoid (*SSL_CTX_set_psk_client_callback)(SSL_CTX *,\n                                        unsigned int (*)(\n                                            SSL *,\n                                            const char *,\n                                            char *,\n                                            unsigned int,\n                                            unsigned char *,\n                                            unsigned int\n                                        )) = NULL;\n#else\nstatic const long Cryptography_HAS_PSK = 1;\n#endif\n\n#if !CRYPTOGRAPHY_IS_LIBRESSL && !CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_CUSTOM_EXT = 1;\n#else\nstatic const long Cryptography_HAS_CUSTOM_EXT = 0;\ntypedef int (*custom_ext_add_cb)(SSL *, unsigned int,\n                                 const unsigned char **,\n                                 size_t *, int *,\n                                 void *);\ntypedef void (*custom_ext_free_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   void *);\ntypedef int (*custom_ext_parse_cb)(SSL *, unsigned int,\n                                   const unsigned char *,\n                                   size_t, int *,\n                                   void *);\nint (*SSL_CTX_add_client_custom_ext)(SSL_CTX *, unsigned int,\n                                     custom_ext_add_cb,\n                                     custom_ext_free_cb, void *,\n                                     custom_ext_parse_cb,\n                                     void *) = NULL;\nint (*SSL_CTX_add_server_custom_ext)(SSL_CTX *, unsigned int,\n                                     custom_ext_add_cb,\n                                     custom_ext_free_cb, void *,\n                                     custom_ext_parse_cb,\n                                     void *) = NULL;\nint (*SSL_extension_supported)(unsigned int) = NULL;\n#endif\n\n#ifndef OPENSSL_NO_SRTP\nstatic const long Cryptography_HAS_SRTP = 1;\n#else\nstatic const long Cryptography_HAS_SRTP = 0;\nint (*SSL_CTX_set_tlsext_use_srtp)(SSL_CTX *, const char *) = NULL;\nint (*SSL_set_tlsext_use_srtp)(SSL *, const char *) = NULL;\nSRTP_PROTECTION_PROFILE * (*SSL_get_selected_srtp_profile)(SSL *) = NULL;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 0;\n\nstatic const long SSL_VERIFY_POST_HANDSHAKE = 0;\nint (*SSL_CTX_set_ciphersuites)(SSL_CTX *, const char *) = NULL;\nint (*SSL_verify_client_post_handshake)(SSL *) = NULL;\nvoid (*SSL_CTX_set_post_handshake_auth)(SSL_CTX *, int) = NULL;\nvoid (*SSL_set_post_handshake_auth)(SSL *, int) = NULL;\nuint32_t (*SSL_SESSION_get_max_early_data)(const SSL_SESSION *) = NULL;\nint (*SSL_write_early_data)(SSL *, const void *, size_t, size_t *) = NULL;\nint (*SSL_read_early_data)(SSL *, void *, size_t, size_t *) = NULL;\nint (*SSL_CTX_set_max_early_data)(SSL_CTX *, uint32_t) = NULL;\n#else\nstatic const long Cryptography_HAS_TLSv1_3_FUNCTIONS = 1;\n#endif\n\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_SSL_COOKIE = 0;\n\nstatic const long SSL_OP_COOKIE_EXCHANGE = 0;\nint (*DTLSv1_listen)(SSL *, BIO_ADDR *) = NULL;\nvoid (*SSL_CTX_set_cookie_generate_cb)(SSL_CTX *,\n                                       int (*)(\n                                           SSL *,\n                                           unsigned char *,\n                                           unsigned int *\n                                       )) = NULL;\nvoid (*SSL_CTX_set_cookie_verify_cb)(SSL_CTX *,\n                                       int (*)(\n                                           SSL *,\n                                           const unsigned char *,\n                                           unsigned int\n                                       )) = NULL;\n#else\nstatic const long Cryptography_HAS_SSL_COOKIE = 1;\n#endif\n#if CRYPTOGRAPHY_IS_LIBRESSL || CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PSK_TLSv1_3 = 0;\nvoid (*SSL_CTX_set_psk_find_session_callback)(SSL_CTX *,\n                                           int (*)(\n                                               SSL *,\n                                               const unsigned char *,\n                                               size_t,\n                                               SSL_SESSION **\n                                           )) = NULL;\nvoid (*SSL_CTX_set_psk_use_session_callback)(SSL_CTX *,\n                                          int (*)(\n                                              SSL *,\n                                              const EVP_MD *,\n                                              const unsigned char **,\n                                              size_t *,\n                                              SSL_SESSION **\n                                          )) = NULL;\n#if CRYPTOGRAPHY_IS_BORINGSSL\nconst SSL_CIPHER *(*SSL_CIPHER_find)(SSL *, const unsigned char *) = NULL;\n#endif\nint (*SSL_SESSION_set1_master_key)(SSL_SESSION *, const unsigned char *,\n                                   size_t) = NULL;\nint (*SSL_SESSION_set_cipher)(SSL_SESSION *, const SSL_CIPHER *) = NULL;\n#if !CRYPTOGRAPHY_IS_BORINGSSL\nint (*SSL_SESSION_set_protocol_version)(SSL_SESSION *, int) = NULL;\n#endif\nSSL_SESSION *(*Cryptography_SSL_SESSION_new)(void) = NULL;\n#else\nstatic const long Cryptography_HAS_PSK_TLSv1_3 = 1;\nSSL_SESSION *Cryptography_SSL_SESSION_new(void) {\n    return SSL_SESSION_new();\n}\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/pem.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pem.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509 *PEM_read_bio_X509(BIO *, X509 **, pem_password_cb *, void *);\nint PEM_write_bio_X509(BIO *, X509 *);\n\nint PEM_write_bio_PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,\n                             unsigned char *, int, pem_password_cb *, void *);\n\nEVP_PKEY *PEM_read_bio_PrivateKey(BIO *, EVP_PKEY **, pem_password_cb *,\n                                 void *);\n\nPKCS7 *d2i_PKCS7_bio(BIO *, PKCS7 **);\n\nint PEM_write_bio_X509_REQ(BIO *, X509_REQ *);\n\nX509_REQ *PEM_read_bio_X509_REQ(BIO *, X509_REQ **, pem_password_cb *, void *);\n\nX509_CRL *PEM_read_bio_X509_CRL(BIO *, X509_CRL **, pem_password_cb *, void *);\n\nint PEM_write_bio_X509_CRL(BIO *, X509_CRL *);\n\nPKCS7 *PEM_read_bio_PKCS7(BIO *, PKCS7 **, pem_password_cb *, void *);\n\nDH *PEM_read_bio_DHparams(BIO *, DH **, pem_password_cb *, void *);\n\nEVP_PKEY *PEM_read_bio_PUBKEY(BIO *, EVP_PKEY **, pem_password_cb *, void *);\nint PEM_write_bio_PUBKEY(BIO *, EVP_PKEY *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/crypto.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/crypto.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int OPENSSL_VERSION;\nstatic const int OPENSSL_CFLAGS;\nstatic const int OPENSSL_BUILT_ON;\nstatic const int OPENSSL_PLATFORM;\nstatic const int OPENSSL_DIR;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid OPENSSL_cleanup(void);\n\nunsigned long OpenSSL_version_num(void);\nconst char *OpenSSL_version(int);\n\nvoid *OPENSSL_malloc(size_t);\nvoid OPENSSL_free(void *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/pkcs7.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/pkcs7.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const long Cryptography_HAS_PKCS7_FUNCS;\ntypedef ... PKCS7;\nstatic const int PKCS7_TEXT;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nvoid PKCS7_free(PKCS7 *);\n/* Included verify due to external consumer, see\n   https://github.com/pyca/cryptography/issues/5433 */\nint PKCS7_verify(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,\n                 BIO *, int);\nPKCS7 *SMIME_read_PKCS7(BIO *, BIO **);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const long Cryptography_HAS_PKCS7_FUNCS = 0;\n\nint (*PKCS7_verify)(PKCS7 *, Cryptography_STACK_OF_X509 *, X509_STORE *, BIO *,\n                    BIO *, int) = NULL;\nPKCS7 *(*SMIME_read_PKCS7)(BIO *, BIO **) = NULL;\n#else\nstatic const long Cryptography_HAS_PKCS7_FUNCS = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/x509_vfy.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509_vfy.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\ntypedef STACK_OF(ASN1_OBJECT) Cryptography_STACK_OF_ASN1_OBJECT;\ntypedef STACK_OF(X509_OBJECT) Cryptography_STACK_OF_X509_OBJECT;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_ASN1_OBJECT;\ntypedef ... Cryptography_STACK_OF_X509_OBJECT;\n\ntypedef ... X509_OBJECT;\ntypedef ... X509_STORE;\ntypedef ... X509_VERIFY_PARAM;\ntypedef ... X509_STORE_CTX;\n\ntypedef int (*X509_STORE_CTX_get_issuer_fn)(X509 **, X509_STORE_CTX *, X509 *);\n\nstatic const int X509_V_OK;\nstatic const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\nstatic const int X509_V_ERR_UNABLE_TO_GET_CRL;\nstatic const int X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE;\nstatic const int X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE;\nstatic const int X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY;\nstatic const int X509_V_ERR_CERT_SIGNATURE_FAILURE;\nstatic const int X509_V_ERR_CRL_SIGNATURE_FAILURE;\nstatic const int X509_V_ERR_CERT_NOT_YET_VALID;\nstatic const int X509_V_ERR_CERT_HAS_EXPIRED;\nstatic const int X509_V_ERR_CRL_NOT_YET_VALID;\nstatic const int X509_V_ERR_CRL_HAS_EXPIRED;\nstatic const int X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD;\nstatic const int X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD;\nstatic const int X509_V_ERR_OUT_OF_MEM;\nstatic const int X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\nstatic const int X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\nstatic const int X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\nstatic const int X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE;\nstatic const int X509_V_ERR_CERT_CHAIN_TOO_LONG;\nstatic const int X509_V_ERR_CERT_REVOKED;\nstatic const int X509_V_ERR_INVALID_CA;\nstatic const int X509_V_ERR_PATH_LENGTH_EXCEEDED;\nstatic const int X509_V_ERR_INVALID_PURPOSE;\nstatic const int X509_V_ERR_CERT_UNTRUSTED;\nstatic const int X509_V_ERR_CERT_REJECTED;\nstatic const int X509_V_ERR_SUBJECT_ISSUER_MISMATCH;\nstatic const int X509_V_ERR_AKID_SKID_MISMATCH;\nstatic const int X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH;\nstatic const int X509_V_ERR_KEYUSAGE_NO_CERTSIGN;\nstatic const int X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER;\nstatic const int X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION;\nstatic const int X509_V_ERR_KEYUSAGE_NO_CRL_SIGN;\nstatic const int X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION;\nstatic const int X509_V_ERR_INVALID_NON_CA;\nstatic const int X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED;\nstatic const int X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE;\nstatic const int X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED;\nstatic const int X509_V_ERR_INVALID_EXTENSION;\nstatic const int X509_V_ERR_INVALID_POLICY_EXTENSION;\nstatic const int X509_V_ERR_NO_EXPLICIT_POLICY;\nstatic const int X509_V_ERR_DIFFERENT_CRL_SCOPE;\nstatic const int X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE;\nstatic const int X509_V_ERR_UNNESTED_RESOURCE;\nstatic const int X509_V_ERR_PERMITTED_VIOLATION;\nstatic const int X509_V_ERR_EXCLUDED_VIOLATION;\nstatic const int X509_V_ERR_SUBTREE_MINMAX;\nstatic const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE;\nstatic const int X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX;\nstatic const int X509_V_ERR_UNSUPPORTED_NAME_SYNTAX;\nstatic const int X509_V_ERR_CRL_PATH_VALIDATION_ERROR;\nstatic const int X509_V_ERR_HOSTNAME_MISMATCH;\nstatic const int X509_V_ERR_EMAIL_MISMATCH;\nstatic const int X509_V_ERR_IP_ADDRESS_MISMATCH;\nstatic const int X509_V_ERR_APPLICATION_VERIFICATION;\n\n\n/* While these are defined in the source as ints, they're tagged here\n   as longs, just in case they ever grow to large, such as what we saw\n   with OP_ALL. */\n\n/* Verification parameters */\nstatic const long X509_V_FLAG_CRL_CHECK;\nstatic const long X509_V_FLAG_CRL_CHECK_ALL;\nstatic const long X509_V_FLAG_IGNORE_CRITICAL;\nstatic const long X509_V_FLAG_X509_STRICT;\nstatic const long X509_V_FLAG_ALLOW_PROXY_CERTS;\nstatic const long X509_V_FLAG_POLICY_CHECK;\nstatic const long X509_V_FLAG_EXPLICIT_POLICY;\nstatic const long X509_V_FLAG_INHIBIT_MAP;\nstatic const long X509_V_FLAG_CHECK_SS_SIGNATURE;\nstatic const long X509_V_FLAG_PARTIAL_CHAIN;\n\nstatic const long X509_CHECK_FLAG_ALWAYS_CHECK_SUBJECT;\nstatic const long X509_CHECK_FLAG_NO_WILDCARDS;\nstatic const long X509_CHECK_FLAG_NO_PARTIAL_WILDCARDS;\nstatic const long X509_CHECK_FLAG_MULTI_LABEL_WILDCARDS;\nstatic const long X509_CHECK_FLAG_SINGLE_LABEL_SUBDOMAINS;\nstatic const long X509_CHECK_FLAG_NEVER_CHECK_SUBJECT;\n\n/* Included due to external consumer, see\n   https://github.com/pyca/pyopenssl/issues/1031 */\nstatic const long X509_PURPOSE_SSL_CLIENT;\nstatic const long X509_PURPOSE_SSL_SERVER;\nstatic const long X509_PURPOSE_NS_SSL_SERVER;\nstatic const long X509_PURPOSE_SMIME_SIGN;\nstatic const long X509_PURPOSE_SMIME_ENCRYPT;\nstatic const long X509_PURPOSE_CRL_SIGN;\nstatic const long X509_PURPOSE_ANY;\nstatic const long X509_PURPOSE_OCSP_HELPER;\nstatic const long X509_PURPOSE_TIMESTAMP_SIGN;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nint X509_verify_cert(X509_STORE_CTX *);\n\n/* X509_STORE */\nX509_STORE *X509_STORE_new(void);\nint X509_STORE_add_cert(X509_STORE *, X509 *);\nint X509_STORE_add_crl(X509_STORE *, X509_CRL *);\nint X509_STORE_load_locations(X509_STORE *, const char *, const char *);\nint X509_STORE_set1_param(X509_STORE *, X509_VERIFY_PARAM *);\nint X509_STORE_set_default_paths(X509_STORE *);\nint X509_STORE_set_flags(X509_STORE *, unsigned long);\n/* Included due to external consumer, see\n   https://github.com/pyca/pyopenssl/issues/1031 */\nint X509_STORE_set_purpose(X509_STORE *, int);\nint X509_STORE_up_ref(X509_STORE *);\nvoid X509_STORE_free(X509_STORE *);\n\n/* X509_STORE_CTX */\nX509_STORE_CTX *X509_STORE_CTX_new(void);\nvoid X509_STORE_CTX_cleanup(X509_STORE_CTX *);\nvoid X509_STORE_CTX_free(X509_STORE_CTX *);\nint X509_STORE_CTX_init(X509_STORE_CTX *, X509_STORE *, X509 *,\n                        Cryptography_STACK_OF_X509 *);\nCryptography_STACK_OF_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *);\nint X509_STORE_CTX_get_error(X509_STORE_CTX *);\nvoid X509_STORE_CTX_set_error(X509_STORE_CTX *, int);\nint X509_STORE_CTX_get_error_depth(X509_STORE_CTX *);\nX509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *);\nvoid *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *, int);\n\n/* X509_VERIFY_PARAM */\nX509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);\nint X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *, unsigned long);\nvoid X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *, time_t);\nvoid X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *);\n\nint X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *, const char *,\n                                size_t);\nvoid X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *, unsigned int);\nint X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *, const unsigned char *,\n                              size_t);\n\nint sk_X509_OBJECT_num(Cryptography_STACK_OF_X509_OBJECT *);\nCryptography_STACK_OF_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *);\n\nX509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/rsa.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... RSA;\ntypedef ... BN_GENCB;\nstatic const int RSA_F4;\n\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nRSA *RSA_new(void);\nvoid RSA_free(RSA *);\nint RSA_generate_key_ex(RSA *, int, BIGNUM *, BN_GENCB *);\nint RSA_check_key(const RSA *);\nint RSA_print(BIO *, const RSA *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if defined(EVP_PKEY_CTRL_RSA_IMPLICIT_REJECTION)\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION = 1;\n#else\nstatic const int Cryptography_HAS_IMPLICIT_RSA_REJECTION = 0;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/x509name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509.h>\n\n/*\n * See the comment above Cryptography_STACK_OF_X509 in x509.py\n */\ntypedef STACK_OF(X509_NAME) Cryptography_STACK_OF_X509_NAME;\ntypedef STACK_OF(X509_NAME_ENTRY) Cryptography_STACK_OF_X509_NAME_ENTRY;\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... Cryptography_STACK_OF_X509_NAME_ENTRY;\ntypedef ... X509_NAME;\ntypedef ... X509_NAME_ENTRY;\ntypedef ... Cryptography_STACK_OF_X509_NAME;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nX509_NAME *X509_NAME_new(void);\nvoid X509_NAME_free(X509_NAME *);\n\nunsigned long X509_NAME_hash(X509_NAME *);\n\nint i2d_X509_NAME(X509_NAME *, unsigned char **);\nX509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *, int);\nvoid X509_NAME_ENTRY_free(X509_NAME_ENTRY *);\nint X509_NAME_get_index_by_NID(X509_NAME *, int, int);\nint X509_NAME_cmp(const X509_NAME *, const X509_NAME *);\nX509_NAME *X509_NAME_dup(X509_NAME *);\nint X509_NAME_entry_count(const X509_NAME *);\nX509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *, int);\nchar *X509_NAME_oneline(const X509_NAME *, char *, int);\n\nASN1_OBJECT *X509_NAME_ENTRY_get_object(const X509_NAME_ENTRY *);\nASN1_STRING *X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *);\n\nint X509_NAME_add_entry_by_NID(X509_NAME *, int, int, const unsigned char *,\n                               int, int, int);\n\nCryptography_STACK_OF_X509_NAME *sk_X509_NAME_new_null(void);\nint sk_X509_NAME_num(Cryptography_STACK_OF_X509_NAME *);\nint sk_X509_NAME_push(Cryptography_STACK_OF_X509_NAME *, X509_NAME *);\nX509_NAME *sk_X509_NAME_value(Cryptography_STACK_OF_X509_NAME *, int);\nvoid sk_X509_NAME_free(Cryptography_STACK_OF_X509_NAME *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/_cffi_src/openssl/x509v3.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/x509v3.h>\n\n/*\n * This is part of a work-around for the difficulty cffi has in dealing with\n * `STACK_OF(foo)` as the name of a type.  We invent a new, simpler name that\n * will be an alias for this type and use the alias throughout.  This works\n * together with another opaque typedef for the same name in the TYPES section.\n * Note that the result is an opaque type.\n */\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EXTENDED_KEY_USAGE;\ntypedef ... CONF;\n\ntypedef struct {\n    X509 *issuer_cert;\n    X509 *subject_cert;\n    ...;\n} X509V3_CTX;\n\nstatic const int GEN_EMAIL;\nstatic const int GEN_DNS;\nstatic const int GEN_URI;\n\ntypedef ... GENERAL_NAMES;\n\n/* Only include the one union element used by pyOpenSSL. */\ntypedef struct {\n    int type;\n    union {\n        ASN1_IA5STRING *ia5;   /* rfc822Name, dNSName, */\n                               /*   uniformResourceIdentifier */\n    } d;\n    ...;\n} GENERAL_NAME;\n\nstatic const long X509V3_EXT_ERROR_UNKNOWN;\n\"\"\"\n\n\nFUNCTIONS = \"\"\"\nvoid X509V3_set_ctx(X509V3_CTX *, X509 *, X509 *, X509_REQ *, X509_CRL *, int);\nint GENERAL_NAME_print(BIO *, GENERAL_NAME *);\nvoid GENERAL_NAMES_free(GENERAL_NAMES *);\nvoid *X509V3_EXT_d2i(X509_EXTENSION *);\nX509_EXTENSION *X509V3_EXT_nconf(CONF *, X509V3_CTX *, const char *,\n                                 const char *);\n\nvoid X509V3_set_ctx_nodb(X509V3_CTX *);\n\nint sk_GENERAL_NAME_num(GENERAL_NAMES *);\nGENERAL_NAME *sk_GENERAL_NAME_value(GENERAL_NAMES *, int);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n\"\"\"\n", "src/_cffi_src/openssl/err.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/err.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int EVP_F_EVP_ENCRYPTFINAL_EX;\nstatic const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH;\n\nstatic const int ERR_LIB_EVP;\n\nstatic const int SSL_TLSEXT_ERR_OK;\nstatic const int SSL_TLSEXT_ERR_ALERT_FATAL;\nstatic const int SSL_TLSEXT_ERR_NOACK;\n\nstatic const int SSL_R_UNEXPECTED_EOF_WHILE_READING;\n\nstatic const int Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst char *ERR_lib_error_string(unsigned long);\nconst char *ERR_func_error_string(unsigned long);\nconst char *ERR_reason_error_string(unsigned long);\nunsigned long ERR_get_error(void);\nunsigned long ERR_peek_error(void);\nvoid ERR_clear_error(void);\nvoid ERR_put_error(int, int, int, const char *, int);\n\nint ERR_GET_REASON(unsigned long);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#if CRYPTOGRAPHY_IS_BORINGSSL\nstatic const int EVP_F_EVP_ENCRYPTFINAL_EX = 0;\nstatic const int EVP_R_DATA_NOT_MULTIPLE_OF_BLOCK_LENGTH = 0;\n#endif\n\n/* SSL_R_UNEXPECTED_EOF_WHILE_READING is needed for pyOpenSSL\n   with OpenSSL 3+ */\n#if defined(SSL_R_UNEXPECTED_EOF_WHILE_READING)\n#define Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING 1\n#else\n#define Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING 0\n#define SSL_R_UNEXPECTED_EOF_WHILE_READING 0\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/nid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/obj_mac.h>\n\"\"\"\n\nTYPES = \"\"\"\nstatic const int Cryptography_HAS_ED448;\n\nstatic const int NID_undef;\nstatic const int NID_aes_256_cbc;\nstatic const int NID_pbe_WithSHA1And3_Key_TripleDES_CBC;\n\nstatic const int NID_subject_alt_name;\nstatic const int NID_crl_reason;\n\"\"\"\n\nFUNCTIONS = \"\"\"\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifndef NID_ED448\nstatic const long Cryptography_HAS_ED448 = 0;\n#else\nstatic const long Cryptography_HAS_ED448 = 1;\n#endif\n\"\"\"\n", "src/_cffi_src/openssl/evp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nINCLUDES = \"\"\"\n#include <openssl/evp.h>\n\"\"\"\n\nTYPES = \"\"\"\ntypedef ... EVP_CIPHER;\ntypedef ... EVP_MD;\ntypedef ... EVP_MD_CTX;\n\ntypedef ... EVP_PKEY;\ntypedef ... EVP_PKEY_CTX;\nstatic const int EVP_PKEY_RSA;\nstatic const int EVP_PKEY_RSA_PSS;\nstatic const int EVP_PKEY_DSA;\nstatic const int EVP_PKEY_DH;\nstatic const int EVP_PKEY_EC;\nstatic const int EVP_PKEY_X25519;\nstatic const int EVP_PKEY_ED25519;\nstatic const int EVP_MAX_MD_SIZE;\n\nstatic const int Cryptography_HAS_EVP_PKEY_DHX;\n\"\"\"\n\nFUNCTIONS = \"\"\"\nconst EVP_CIPHER *EVP_get_cipherbyname(const char *);\n\nconst EVP_MD *EVP_get_digestbyname(const char *);\n\nEVP_PKEY *EVP_PKEY_new(void);\nvoid EVP_PKEY_free(EVP_PKEY *);\nint EVP_PKEY_type(int);\nint EVP_PKEY_size(EVP_PKEY *);\nRSA *EVP_PKEY_get1_RSA(EVP_PKEY *);\n\nint EVP_SignInit(EVP_MD_CTX *, const EVP_MD *);\nint EVP_SignUpdate(EVP_MD_CTX *, const void *, size_t);\nint EVP_SignFinal(EVP_MD_CTX *, unsigned char *, unsigned int *, EVP_PKEY *);\n\nint EVP_VerifyInit(EVP_MD_CTX *, const EVP_MD *);\nint EVP_VerifyUpdate(EVP_MD_CTX *, const void *, size_t);\nint EVP_VerifyFinal(EVP_MD_CTX *, const unsigned char *, unsigned int,\n                    EVP_PKEY *);\n\n\nint EVP_PKEY_set1_RSA(EVP_PKEY *, RSA *);\nint EVP_PKEY_set1_DSA(EVP_PKEY *, DSA *);\n\nint EVP_PKEY_id(const EVP_PKEY *);\n\nEVP_MD_CTX *EVP_MD_CTX_new(void);\nvoid EVP_MD_CTX_free(EVP_MD_CTX *);\n\nint EVP_PKEY_bits(const EVP_PKEY *);\n\nint EVP_PKEY_assign_RSA(EVP_PKEY *, RSA *);\n\"\"\"\n\nCUSTOMIZATIONS = \"\"\"\n#ifdef EVP_PKEY_DHX\nconst long Cryptography_HAS_EVP_PKEY_DHX = 1;\n#else\nconst long Cryptography_HAS_EVP_PKEY_DHX = 0;\n#endif\n\"\"\"\n", "src/cryptography/exceptions.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import exceptions as rust_exceptions\n\nif typing.TYPE_CHECKING:\n    from cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n_Reasons = rust_exceptions._Reasons\n\n\nclass UnsupportedAlgorithm(Exception):\n    def __init__(self, message: str, reason: _Reasons | None = None) -> None:\n        super().__init__(message)\n        self._reason = reason\n\n\nclass AlreadyFinalized(Exception):\n    pass\n\n\nclass AlreadyUpdated(Exception):\n    pass\n\n\nclass NotYetFinalized(Exception):\n    pass\n\n\nclass InvalidTag(Exception):\n    pass\n\n\nclass InvalidSignature(Exception):\n    pass\n\n\nclass InternalError(Exception):\n    def __init__(\n        self, msg: str, err_code: list[rust_openssl.OpenSSLError]\n    ) -> None:\n        super().__init__(msg)\n        self.err_code = err_code\n\n\nclass InvalidKey(Exception):\n    pass\n", "src/cryptography/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport enum\nimport sys\nimport types\nimport typing\nimport warnings\n\n\n# We use a UserWarning subclass, instead of DeprecationWarning, because CPython\n# decided deprecation warnings should be invisible by default.\nclass CryptographyDeprecationWarning(UserWarning):\n    pass\n\n\n# Several APIs were deprecated with no specific end-of-life date because of the\n# ubiquity of their use. They should not be removed until we agree on when that\n# cycle ends.\nDeprecatedIn36 = CryptographyDeprecationWarning\nDeprecatedIn37 = CryptographyDeprecationWarning\nDeprecatedIn40 = CryptographyDeprecationWarning\nDeprecatedIn41 = CryptographyDeprecationWarning\nDeprecatedIn42 = CryptographyDeprecationWarning\nDeprecatedIn43 = CryptographyDeprecationWarning\n\n\ndef _check_bytes(name: str, value: bytes) -> None:\n    if not isinstance(value, bytes):\n        raise TypeError(f\"{name} must be bytes\")\n\n\ndef _check_byteslike(name: str, value: bytes) -> None:\n    try:\n        memoryview(value)\n    except TypeError:\n        raise TypeError(f\"{name} must be bytes-like\")\n\n\ndef int_to_bytes(integer: int, length: int | None = None) -> bytes:\n    return integer.to_bytes(\n        length or (integer.bit_length() + 7) // 8 or 1, \"big\"\n    )\n\n\nclass InterfaceNotImplemented(Exception):\n    pass\n\n\nclass _DeprecatedValue:\n    def __init__(self, value: object, message: str, warning_class):\n        self.value = value\n        self.message = message\n        self.warning_class = warning_class\n\n\nclass _ModuleWithDeprecations(types.ModuleType):\n    def __init__(self, module: types.ModuleType):\n        super().__init__(module.__name__)\n        self.__dict__[\"_module\"] = module\n\n    def __getattr__(self, attr: str) -> object:\n        obj = getattr(self._module, attr)\n        if isinstance(obj, _DeprecatedValue):\n            warnings.warn(obj.message, obj.warning_class, stacklevel=2)\n            obj = obj.value\n        return obj\n\n    def __setattr__(self, attr: str, value: object) -> None:\n        setattr(self._module, attr, value)\n\n    def __delattr__(self, attr: str) -> None:\n        obj = getattr(self._module, attr)\n        if isinstance(obj, _DeprecatedValue):\n            warnings.warn(obj.message, obj.warning_class, stacklevel=2)\n\n        delattr(self._module, attr)\n\n    def __dir__(self) -> typing.Sequence[str]:\n        return [\"_module\", *dir(self._module)]\n\n\ndef deprecated(\n    value: object,\n    module_name: str,\n    message: str,\n    warning_class: type[Warning],\n    name: str | None = None,\n) -> _DeprecatedValue:\n    module = sys.modules[module_name]\n    if not isinstance(module, _ModuleWithDeprecations):\n        sys.modules[module_name] = module = _ModuleWithDeprecations(module)\n    dv = _DeprecatedValue(value, message, warning_class)\n    # Maintain backwards compatibility with `name is None` for pyOpenSSL.\n    if name is not None:\n        setattr(module, name, dv)\n    return dv\n\n\ndef cached_property(func: typing.Callable) -> property:\n    cached_name = f\"_cached_{func}\"\n    sentinel = object()\n\n    def inner(instance: object):\n        cache = getattr(instance, cached_name, sentinel)\n        if cache is not sentinel:\n            return cache\n        result = func(instance)\n        setattr(instance, cached_name, result)\n        return result\n\n    return property(inner)\n\n\n# Python 3.10 changed representation of enums. We use well-defined object\n# representation and string representation from Python 3.9.\nclass Enum(enum.Enum):\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__}.{self._name_}: {self._value_!r}>\"\n\n    def __str__(self) -> str:\n        return f\"{self.__class__.__name__}.{self._name_}\"\n", "src/cryptography/fernet.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport base64\nimport binascii\nimport os\nimport time\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import InvalidSignature\nfrom cryptography.hazmat.primitives import hashes, padding\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\nfrom cryptography.hazmat.primitives.hmac import HMAC\n\n\nclass InvalidToken(Exception):\n    pass\n\n\n_MAX_CLOCK_SKEW = 60\n\n\nclass Fernet:\n    def __init__(\n        self,\n        key: bytes | str,\n        backend: typing.Any = None,\n    ) -> None:\n        try:\n            key = base64.urlsafe_b64decode(key)\n        except binascii.Error as exc:\n            raise ValueError(\n                \"Fernet key must be 32 url-safe base64-encoded bytes.\"\n            ) from exc\n        if len(key) != 32:\n            raise ValueError(\n                \"Fernet key must be 32 url-safe base64-encoded bytes.\"\n            )\n\n        self._signing_key = key[:16]\n        self._encryption_key = key[16:]\n\n    @classmethod\n    def generate_key(cls) -> bytes:\n        return base64.urlsafe_b64encode(os.urandom(32))\n\n    def encrypt(self, data: bytes) -> bytes:\n        return self.encrypt_at_time(data, int(time.time()))\n\n    def encrypt_at_time(self, data: bytes, current_time: int) -> bytes:\n        iv = os.urandom(16)\n        return self._encrypt_from_parts(data, current_time, iv)\n\n    def _encrypt_from_parts(\n        self, data: bytes, current_time: int, iv: bytes\n    ) -> bytes:\n        utils._check_bytes(\"data\", data)\n\n        padder = padding.PKCS7(algorithms.AES.block_size).padder()\n        padded_data = padder.update(data) + padder.finalize()\n        encryptor = Cipher(\n            algorithms.AES(self._encryption_key),\n            modes.CBC(iv),\n        ).encryptor()\n        ciphertext = encryptor.update(padded_data) + encryptor.finalize()\n\n        basic_parts = (\n            b\"\\x80\"\n            + current_time.to_bytes(length=8, byteorder=\"big\")\n            + iv\n            + ciphertext\n        )\n\n        h = HMAC(self._signing_key, hashes.SHA256())\n        h.update(basic_parts)\n        hmac = h.finalize()\n        return base64.urlsafe_b64encode(basic_parts + hmac)\n\n    def decrypt(self, token: bytes | str, ttl: int | None = None) -> bytes:\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        if ttl is None:\n            time_info = None\n        else:\n            time_info = (ttl, int(time.time()))\n        return self._decrypt_data(data, timestamp, time_info)\n\n    def decrypt_at_time(\n        self, token: bytes | str, ttl: int, current_time: int\n    ) -> bytes:\n        if ttl is None:\n            raise ValueError(\n                \"decrypt_at_time() can only be used with a non-None ttl\"\n            )\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        return self._decrypt_data(data, timestamp, (ttl, current_time))\n\n    def extract_timestamp(self, token: bytes | str) -> int:\n        timestamp, data = Fernet._get_unverified_token_data(token)\n        # Verify the token was not tampered with.\n        self._verify_signature(data)\n        return timestamp\n\n    @staticmethod\n    def _get_unverified_token_data(token: bytes | str) -> tuple[int, bytes]:\n        if not isinstance(token, (str, bytes)):\n            raise TypeError(\"token must be bytes or str\")\n\n        try:\n            data = base64.urlsafe_b64decode(token)\n        except (TypeError, binascii.Error):\n            raise InvalidToken\n\n        if not data or data[0] != 0x80:\n            raise InvalidToken\n\n        if len(data) < 9:\n            raise InvalidToken\n\n        timestamp = int.from_bytes(data[1:9], byteorder=\"big\")\n        return timestamp, data\n\n    def _verify_signature(self, data: bytes) -> None:\n        h = HMAC(self._signing_key, hashes.SHA256())\n        h.update(data[:-32])\n        try:\n            h.verify(data[-32:])\n        except InvalidSignature:\n            raise InvalidToken\n\n    def _decrypt_data(\n        self,\n        data: bytes,\n        timestamp: int,\n        time_info: tuple[int, int] | None,\n    ) -> bytes:\n        if time_info is not None:\n            ttl, current_time = time_info\n            if timestamp + ttl < current_time:\n                raise InvalidToken\n\n            if current_time + _MAX_CLOCK_SKEW < timestamp:\n                raise InvalidToken\n\n        self._verify_signature(data)\n\n        iv = data[9:25]\n        ciphertext = data[25:-32]\n        decryptor = Cipher(\n            algorithms.AES(self._encryption_key), modes.CBC(iv)\n        ).decryptor()\n        plaintext_padded = decryptor.update(ciphertext)\n        try:\n            plaintext_padded += decryptor.finalize()\n        except ValueError:\n            raise InvalidToken\n        unpadder = padding.PKCS7(algorithms.AES.block_size).unpadder()\n\n        unpadded = unpadder.update(plaintext_padded)\n        try:\n            unpadded += unpadder.finalize()\n        except ValueError:\n            raise InvalidToken\n        return unpadded\n\n\nclass MultiFernet:\n    def __init__(self, fernets: typing.Iterable[Fernet]):\n        fernets = list(fernets)\n        if not fernets:\n            raise ValueError(\n                \"MultiFernet requires at least one Fernet instance\"\n            )\n        self._fernets = fernets\n\n    def encrypt(self, msg: bytes) -> bytes:\n        return self.encrypt_at_time(msg, int(time.time()))\n\n    def encrypt_at_time(self, msg: bytes, current_time: int) -> bytes:\n        return self._fernets[0].encrypt_at_time(msg, current_time)\n\n    def rotate(self, msg: bytes | str) -> bytes:\n        timestamp, data = Fernet._get_unverified_token_data(msg)\n        for f in self._fernets:\n            try:\n                p = f._decrypt_data(data, timestamp, None)\n                break\n            except InvalidToken:\n                pass\n        else:\n            raise InvalidToken\n\n        iv = os.urandom(16)\n        return self._fernets[0]._encrypt_from_parts(p, timestamp, iv)\n\n    def decrypt(self, msg: bytes | str, ttl: int | None = None) -> bytes:\n        for f in self._fernets:\n            try:\n                return f.decrypt(msg, ttl)\n            except InvalidToken:\n                pass\n        raise InvalidToken\n\n    def decrypt_at_time(\n        self, msg: bytes | str, ttl: int, current_time: int\n    ) -> bytes:\n        for f in self._fernets:\n            try:\n                return f.decrypt_at_time(msg, ttl, current_time)\n            except InvalidToken:\n                pass\n        raise InvalidToken\n", "src/cryptography/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.__about__ import __author__, __copyright__, __version__\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__version__\",\n]\n", "src/cryptography/__about__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__version__\",\n]\n\n__version__ = \"43.0.0.dev1\"\n\n\n__author__ = \"The Python Cryptographic Authority and individual contributors\"\n__copyright__ = f\"Copyright 2013-2024 {__author__}\"\n", "src/cryptography/x509/general_name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport ipaddress\nimport typing\nfrom email.utils import parseaddr\n\nfrom cryptography.x509.name import Name\nfrom cryptography.x509.oid import ObjectIdentifier\n\n_IPAddressTypes = typing.Union[\n    ipaddress.IPv4Address,\n    ipaddress.IPv6Address,\n    ipaddress.IPv4Network,\n    ipaddress.IPv6Network,\n]\n\n\nclass UnsupportedGeneralNameType(Exception):\n    pass\n\n\nclass GeneralName(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def value(self) -> typing.Any:\n        \"\"\"\n        Return the value of the object\n        \"\"\"\n\n\nclass RFC822Name(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"RFC822Name values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        name, address = parseaddr(value)\n        if name or not address:\n            # parseaddr has found a name (e.g. Name <email>) or the entire\n            # value is an empty string.\n            raise ValueError(\"Invalid rfc822name value\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> RFC822Name:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<RFC822Name(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RFC822Name):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass DNSName(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"DNSName values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> DNSName:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<DNSName(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DNSName):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass UniformResourceIdentifier(GeneralName):\n    def __init__(self, value: str) -> None:\n        if isinstance(value, str):\n            try:\n                value.encode(\"ascii\")\n            except UnicodeEncodeError:\n                raise ValueError(\n                    \"URI values should be passed as an A-label string. \"\n                    \"This means unicode characters should be encoded via \"\n                    \"a library like idna.\"\n                )\n        else:\n            raise TypeError(\"value must be string\")\n\n        self._value = value\n\n    @property\n    def value(self) -> str:\n        return self._value\n\n    @classmethod\n    def _init_without_validation(cls, value: str) -> UniformResourceIdentifier:\n        instance = cls.__new__(cls)\n        instance._value = value\n        return instance\n\n    def __repr__(self) -> str:\n        return f\"<UniformResourceIdentifier(value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UniformResourceIdentifier):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass DirectoryName(GeneralName):\n    def __init__(self, value: Name) -> None:\n        if not isinstance(value, Name):\n            raise TypeError(\"value must be a Name\")\n\n        self._value = value\n\n    @property\n    def value(self) -> Name:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<DirectoryName(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DirectoryName):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass RegisteredID(GeneralName):\n    def __init__(self, value: ObjectIdentifier) -> None:\n        if not isinstance(value, ObjectIdentifier):\n            raise TypeError(\"value must be an ObjectIdentifier\")\n\n        self._value = value\n\n    @property\n    def value(self) -> ObjectIdentifier:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<RegisteredID(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RegisteredID):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass IPAddress(GeneralName):\n    def __init__(self, value: _IPAddressTypes) -> None:\n        if not isinstance(\n            value,\n            (\n                ipaddress.IPv4Address,\n                ipaddress.IPv6Address,\n                ipaddress.IPv4Network,\n                ipaddress.IPv6Network,\n            ),\n        ):\n            raise TypeError(\n                \"value must be an instance of ipaddress.IPv4Address, \"\n                \"ipaddress.IPv6Address, ipaddress.IPv4Network, or \"\n                \"ipaddress.IPv6Network\"\n            )\n\n        self._value = value\n\n    @property\n    def value(self) -> _IPAddressTypes:\n        return self._value\n\n    def _packed(self) -> bytes:\n        if isinstance(\n            self.value, (ipaddress.IPv4Address, ipaddress.IPv6Address)\n        ):\n            return self.value.packed\n        else:\n            return (\n                self.value.network_address.packed + self.value.netmask.packed\n            )\n\n    def __repr__(self) -> str:\n        return f\"<IPAddress(value={self.value})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IPAddress):\n            return NotImplemented\n\n        return self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash(self.value)\n\n\nclass OtherName(GeneralName):\n    def __init__(self, type_id: ObjectIdentifier, value: bytes) -> None:\n        if not isinstance(type_id, ObjectIdentifier):\n            raise TypeError(\"type_id must be an ObjectIdentifier\")\n        if not isinstance(value, bytes):\n            raise TypeError(\"value must be a binary string\")\n\n        self._type_id = type_id\n        self._value = value\n\n    @property\n    def type_id(self) -> ObjectIdentifier:\n        return self._type_id\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<OtherName(type_id={self.type_id}, value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OtherName):\n            return NotImplemented\n\n        return self.type_id == other.type_id and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.type_id, self.value))\n", "src/cryptography/x509/name.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport binascii\nimport re\nimport sys\nimport typing\nimport warnings\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.x509.oid import NameOID, ObjectIdentifier\n\n\nclass _ASN1Type(utils.Enum):\n    BitString = 3\n    OctetString = 4\n    UTF8String = 12\n    NumericString = 18\n    PrintableString = 19\n    T61String = 20\n    IA5String = 22\n    UTCTime = 23\n    GeneralizedTime = 24\n    VisibleString = 26\n    UniversalString = 28\n    BMPString = 30\n\n\n_ASN1_TYPE_TO_ENUM = {i.value: i for i in _ASN1Type}\n_NAMEOID_DEFAULT_TYPE: dict[ObjectIdentifier, _ASN1Type] = {\n    NameOID.COUNTRY_NAME: _ASN1Type.PrintableString,\n    NameOID.JURISDICTION_COUNTRY_NAME: _ASN1Type.PrintableString,\n    NameOID.SERIAL_NUMBER: _ASN1Type.PrintableString,\n    NameOID.DN_QUALIFIER: _ASN1Type.PrintableString,\n    NameOID.EMAIL_ADDRESS: _ASN1Type.IA5String,\n    NameOID.DOMAIN_COMPONENT: _ASN1Type.IA5String,\n}\n\n# Type alias\n_OidNameMap = typing.Mapping[ObjectIdentifier, str]\n_NameOidMap = typing.Mapping[str, ObjectIdentifier]\n\n#: Short attribute names from RFC 4514:\n#: https://tools.ietf.org/html/rfc4514#page-7\n_NAMEOID_TO_NAME: _OidNameMap = {\n    NameOID.COMMON_NAME: \"CN\",\n    NameOID.LOCALITY_NAME: \"L\",\n    NameOID.STATE_OR_PROVINCE_NAME: \"ST\",\n    NameOID.ORGANIZATION_NAME: \"O\",\n    NameOID.ORGANIZATIONAL_UNIT_NAME: \"OU\",\n    NameOID.COUNTRY_NAME: \"C\",\n    NameOID.STREET_ADDRESS: \"STREET\",\n    NameOID.DOMAIN_COMPONENT: \"DC\",\n    NameOID.USER_ID: \"UID\",\n}\n_NAME_TO_NAMEOID = {v: k for k, v in _NAMEOID_TO_NAME.items()}\n\n\ndef _escape_dn_value(val: str | bytes) -> str:\n    \"\"\"Escape special characters in RFC4514 Distinguished Name value.\"\"\"\n\n    if not val:\n        return \"\"\n\n    # RFC 4514 Section 2.4 defines the value as being the # (U+0023) character\n    # followed by the hexadecimal encoding of the octets.\n    if isinstance(val, bytes):\n        return \"#\" + binascii.hexlify(val).decode(\"utf8\")\n\n    # See https://tools.ietf.org/html/rfc4514#section-2.4\n    val = val.replace(\"\\\\\", \"\\\\\\\\\")\n    val = val.replace('\"', '\\\\\"')\n    val = val.replace(\"+\", \"\\\\+\")\n    val = val.replace(\",\", \"\\\\,\")\n    val = val.replace(\";\", \"\\\\;\")\n    val = val.replace(\"<\", \"\\\\<\")\n    val = val.replace(\">\", \"\\\\>\")\n    val = val.replace(\"\\0\", \"\\\\00\")\n\n    if val[0] in (\"#\", \" \"):\n        val = \"\\\\\" + val\n    if val[-1] == \" \":\n        val = val[:-1] + \"\\\\ \"\n\n    return val\n\n\ndef _unescape_dn_value(val: str) -> str:\n    if not val:\n        return \"\"\n\n    # See https://tools.ietf.org/html/rfc4514#section-3\n\n    # special = escaped / SPACE / SHARP / EQUALS\n    # escaped = DQUOTE / PLUS / COMMA / SEMI / LANGLE / RANGLE\n    def sub(m):\n        val = m.group(1)\n        # Regular escape\n        if len(val) == 1:\n            return val\n        # Hex-value scape\n        return chr(int(val, 16))\n\n    return _RFC4514NameParser._PAIR_RE.sub(sub, val)\n\n\nclass NameAttribute:\n    def __init__(\n        self,\n        oid: ObjectIdentifier,\n        value: str | bytes,\n        _type: _ASN1Type | None = None,\n        *,\n        _validate: bool = True,\n    ) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\n                \"oid argument must be an ObjectIdentifier instance.\"\n            )\n        if _type == _ASN1Type.BitString:\n            if oid != NameOID.X500_UNIQUE_IDENTIFIER:\n                raise TypeError(\n                    \"oid must be X500_UNIQUE_IDENTIFIER for BitString type.\"\n                )\n            if not isinstance(value, bytes):\n                raise TypeError(\"value must be bytes for BitString\")\n        else:\n            if not isinstance(value, str):\n                raise TypeError(\"value argument must be a str\")\n\n        if oid in (NameOID.COUNTRY_NAME, NameOID.JURISDICTION_COUNTRY_NAME):\n            assert isinstance(value, str)\n            c_len = len(value.encode(\"utf8\"))\n            if c_len != 2 and _validate is True:\n                raise ValueError(\n                    \"Country name must be a 2 character country code\"\n                )\n            elif c_len != 2:\n                warnings.warn(\n                    \"Country names should be two characters, but the \"\n                    f\"attribute is {c_len} characters in length.\",\n                    stacklevel=2,\n                )\n\n        # The appropriate ASN1 string type varies by OID and is defined across\n        # multiple RFCs including 2459, 3280, and 5280. In general UTF8String\n        # is preferred (2459), but 3280 and 5280 specify several OIDs with\n        # alternate types. This means when we see the sentinel value we need\n        # to look up whether the OID has a non-UTF8 type. If it does, set it\n        # to that. Otherwise, UTF8!\n        if _type is None:\n            _type = _NAMEOID_DEFAULT_TYPE.get(oid, _ASN1Type.UTF8String)\n\n        if not isinstance(_type, _ASN1Type):\n            raise TypeError(\"_type must be from the _ASN1Type enum\")\n\n        self._oid = oid\n        self._value = value\n        self._type = _type\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def value(self) -> str | bytes:\n        return self._value\n\n    @property\n    def rfc4514_attribute_name(self) -> str:\n        \"\"\"\n        The short attribute name (for example \"CN\") if available,\n        otherwise the OID dotted string.\n        \"\"\"\n        return _NAMEOID_TO_NAME.get(self.oid, self.oid.dotted_string)\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n\n        Use short attribute name if available, otherwise fall back to OID\n        dotted string.\n        \"\"\"\n        attr_name = (\n            attr_name_overrides.get(self.oid) if attr_name_overrides else None\n        )\n        if attr_name is None:\n            attr_name = self.rfc4514_attribute_name\n\n        return f\"{attr_name}={_escape_dn_value(self.value)}\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NameAttribute):\n            return NotImplemented\n\n        return self.oid == other.oid and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value))\n\n    def __repr__(self) -> str:\n        return f\"<NameAttribute(oid={self.oid}, value={self.value!r})>\"\n\n\nclass RelativeDistinguishedName:\n    def __init__(self, attributes: typing.Iterable[NameAttribute]):\n        attributes = list(attributes)\n        if not attributes:\n            raise ValueError(\"a relative distinguished name cannot be empty\")\n        if not all(isinstance(x, NameAttribute) for x in attributes):\n            raise TypeError(\"attributes must be an iterable of NameAttribute\")\n\n        # Keep list and frozenset to preserve attribute order where it matters\n        self._attributes = attributes\n        self._attribute_set = frozenset(attributes)\n\n        if len(self._attribute_set) != len(attributes):\n            raise ValueError(\"duplicate attributes are not allowed\")\n\n    def get_attributes_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> list[NameAttribute]:\n        return [i for i in self if i.oid == oid]\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n\n        Within each RDN, attributes are joined by '+', although that is rarely\n        used in certificates.\n        \"\"\"\n        return \"+\".join(\n            attr.rfc4514_string(attr_name_overrides)\n            for attr in self._attributes\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, RelativeDistinguishedName):\n            return NotImplemented\n\n        return self._attribute_set == other._attribute_set\n\n    def __hash__(self) -> int:\n        return hash(self._attribute_set)\n\n    def __iter__(self) -> typing.Iterator[NameAttribute]:\n        return iter(self._attributes)\n\n    def __len__(self) -> int:\n        return len(self._attributes)\n\n    def __repr__(self) -> str:\n        return f\"<RelativeDistinguishedName({self.rfc4514_string()})>\"\n\n\nclass Name:\n    @typing.overload\n    def __init__(self, attributes: typing.Iterable[NameAttribute]) -> None: ...\n\n    @typing.overload\n    def __init__(\n        self, attributes: typing.Iterable[RelativeDistinguishedName]\n    ) -> None: ...\n\n    def __init__(\n        self,\n        attributes: typing.Iterable[NameAttribute | RelativeDistinguishedName],\n    ) -> None:\n        attributes = list(attributes)\n        if all(isinstance(x, NameAttribute) for x in attributes):\n            self._attributes = [\n                RelativeDistinguishedName([typing.cast(NameAttribute, x)])\n                for x in attributes\n            ]\n        elif all(isinstance(x, RelativeDistinguishedName) for x in attributes):\n            self._attributes = typing.cast(\n                typing.List[RelativeDistinguishedName], attributes\n            )\n        else:\n            raise TypeError(\n                \"attributes must be a list of NameAttribute\"\n                \" or a list RelativeDistinguishedName\"\n            )\n\n    @classmethod\n    def from_rfc4514_string(\n        cls,\n        data: str,\n        attr_name_overrides: _NameOidMap | None = None,\n    ) -> Name:\n        return _RFC4514NameParser(data, attr_name_overrides or {}).parse()\n\n    def rfc4514_string(\n        self, attr_name_overrides: _OidNameMap | None = None\n    ) -> str:\n        \"\"\"\n        Format as RFC4514 Distinguished Name string.\n        For example 'CN=foobar.com,O=Foo Corp,C=US'\n\n        An X.509 name is a two-level structure: a list of sets of attributes.\n        Each list element is separated by ',' and within each list element, set\n        elements are separated by '+'. The latter is almost never used in\n        real world certificates. According to RFC4514 section 2.1 the\n        RDNSequence must be reversed when converting to string representation.\n        \"\"\"\n        return \",\".join(\n            attr.rfc4514_string(attr_name_overrides)\n            for attr in reversed(self._attributes)\n        )\n\n    def get_attributes_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> list[NameAttribute]:\n        return [i for i in self if i.oid == oid]\n\n    @property\n    def rdns(self) -> list[RelativeDistinguishedName]:\n        return self._attributes\n\n    def public_bytes(self, backend: typing.Any = None) -> bytes:\n        return rust_x509.encode_name_bytes(self)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Name):\n            return NotImplemented\n\n        return self._attributes == other._attributes\n\n    def __hash__(self) -> int:\n        # TODO: this is relatively expensive, if this looks like a bottleneck\n        # for you, consider optimizing!\n        return hash(tuple(self._attributes))\n\n    def __iter__(self) -> typing.Iterator[NameAttribute]:\n        for rdn in self._attributes:\n            yield from rdn\n\n    def __len__(self) -> int:\n        return sum(len(rdn) for rdn in self._attributes)\n\n    def __repr__(self) -> str:\n        rdns = \",\".join(attr.rfc4514_string() for attr in self._attributes)\n        return f\"<Name({rdns})>\"\n\n\nclass _RFC4514NameParser:\n    _OID_RE = re.compile(r\"(0|([1-9]\\d*))(\\.(0|([1-9]\\d*)))+\")\n    _DESCR_RE = re.compile(r\"[a-zA-Z][a-zA-Z\\d-]*\")\n\n    _PAIR = r\"\\\\([\\\\ #=\\\"\\+,;<>]|[\\da-zA-Z]{2})\"\n    _PAIR_RE = re.compile(_PAIR)\n    _LUTF1 = r\"[\\x01-\\x1f\\x21\\x24-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _SUTF1 = r\"[\\x01-\\x21\\x23-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _TUTF1 = r\"[\\x01-\\x1F\\x21\\x23-\\x2A\\x2D-\\x3A\\x3D\\x3F-\\x5B\\x5D-\\x7F]\"\n    _UTFMB = rf\"[\\x80-{chr(sys.maxunicode)}]\"\n    _LEADCHAR = rf\"{_LUTF1}|{_UTFMB}\"\n    _STRINGCHAR = rf\"{_SUTF1}|{_UTFMB}\"\n    _TRAILCHAR = rf\"{_TUTF1}|{_UTFMB}\"\n    _STRING_RE = re.compile(\n        rf\"\"\"\n        (\n            ({_LEADCHAR}|{_PAIR})\n            (\n                ({_STRINGCHAR}|{_PAIR})*\n                ({_TRAILCHAR}|{_PAIR})\n            )?\n        )?\n        \"\"\",\n        re.VERBOSE,\n    )\n    _HEXSTRING_RE = re.compile(r\"#([\\da-zA-Z]{2})+\")\n\n    def __init__(self, data: str, attr_name_overrides: _NameOidMap) -> None:\n        self._data = data\n        self._idx = 0\n\n        self._attr_name_overrides = attr_name_overrides\n\n    def _has_data(self) -> bool:\n        return self._idx < len(self._data)\n\n    def _peek(self) -> str | None:\n        if self._has_data():\n            return self._data[self._idx]\n        return None\n\n    def _read_char(self, ch: str) -> None:\n        if self._peek() != ch:\n            raise ValueError\n        self._idx += 1\n\n    def _read_re(self, pat) -> str:\n        match = pat.match(self._data, pos=self._idx)\n        if match is None:\n            raise ValueError\n        val = match.group()\n        self._idx += len(val)\n        return val\n\n    def parse(self) -> Name:\n        \"\"\"\n        Parses the `data` string and converts it to a Name.\n\n        According to RFC4514 section 2.1 the RDNSequence must be\n        reversed when converting to string representation. So, when\n        we parse it, we need to reverse again to get the RDNs on the\n        correct order.\n        \"\"\"\n\n        if not self._has_data():\n            return Name([])\n\n        rdns = [self._parse_rdn()]\n\n        while self._has_data():\n            self._read_char(\",\")\n            rdns.append(self._parse_rdn())\n\n        return Name(reversed(rdns))\n\n    def _parse_rdn(self) -> RelativeDistinguishedName:\n        nas = [self._parse_na()]\n        while self._peek() == \"+\":\n            self._read_char(\"+\")\n            nas.append(self._parse_na())\n\n        return RelativeDistinguishedName(nas)\n\n    def _parse_na(self) -> NameAttribute:\n        try:\n            oid_value = self._read_re(self._OID_RE)\n        except ValueError:\n            name = self._read_re(self._DESCR_RE)\n            oid = self._attr_name_overrides.get(\n                name, _NAME_TO_NAMEOID.get(name)\n            )\n            if oid is None:\n                raise ValueError\n        else:\n            oid = ObjectIdentifier(oid_value)\n\n        self._read_char(\"=\")\n        if self._peek() == \"#\":\n            value = self._read_re(self._HEXSTRING_RE)\n            value = binascii.unhexlify(value[1:]).decode()\n        else:\n            raw_value = self._read_re(self._STRING_RE)\n            value = _unescape_dn_value(raw_value)\n\n        return NameAttribute(oid, value)\n", "src/cryptography/x509/certificate_transparency.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives.hashes import HashAlgorithm\n\n\nclass LogEntryType(utils.Enum):\n    X509_CERTIFICATE = 0\n    PRE_CERTIFICATE = 1\n\n\nclass Version(utils.Enum):\n    v1 = 0\n\n\nclass SignatureAlgorithm(utils.Enum):\n    \"\"\"\n    Signature algorithms that are valid for SCTs.\n\n    These are exactly the same as SignatureAlgorithm in RFC 5246 (TLS 1.2).\n\n    See: <https://datatracker.ietf.org/doc/html/rfc5246#section-7.4.1.4.1>\n    \"\"\"\n\n    ANONYMOUS = 0\n    RSA = 1\n    DSA = 2\n    ECDSA = 3\n\n\nclass SignedCertificateTimestamp(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def version(self) -> Version:\n        \"\"\"\n        Returns the SCT version.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def log_id(self) -> bytes:\n        \"\"\"\n        Returns an identifier indicating which log this SCT is for.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def timestamp(self) -> datetime.datetime:\n        \"\"\"\n        Returns the timestamp for this SCT.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def entry_type(self) -> LogEntryType:\n        \"\"\"\n        Returns whether this is an SCT for a certificate or pre-certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(self) -> HashAlgorithm:\n        \"\"\"\n        Returns the hash algorithm used for the SCT's signature.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm(self) -> SignatureAlgorithm:\n        \"\"\"\n        Returns the signing algorithm used for the SCT's signature.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature for this SCT.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extension_bytes(self) -> bytes:\n        \"\"\"\n        Returns the raw bytes of any extensions for this SCT.\n        \"\"\"\n\n\nSignedCertificateTimestamp.register(rust_x509.Sct)\n", "src/cryptography/x509/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport os\nimport typing\nimport warnings\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    padding,\n    rsa,\n    x448,\n    x25519,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPrivateKeyTypes,\n    CertificateIssuerPublicKeyTypes,\n    CertificatePublicKeyTypes,\n)\nfrom cryptography.x509.extensions import (\n    Extension,\n    Extensions,\n    ExtensionType,\n    _make_sequence_methods,\n)\nfrom cryptography.x509.name import Name, _ASN1Type\nfrom cryptography.x509.oid import ObjectIdentifier\n\n_EARLIEST_UTC_TIME = datetime.datetime(1950, 1, 1)\n\n# This must be kept in sync with sign.rs's list of allowable types in\n# identify_hash_type\n_AllowedHashTypes = typing.Union[\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n    hashes.SHA3_224,\n    hashes.SHA3_256,\n    hashes.SHA3_384,\n    hashes.SHA3_512,\n]\n\n\nclass AttributeNotFound(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\ndef _reject_duplicate_extension(\n    extension: Extension[ExtensionType],\n    extensions: list[Extension[ExtensionType]],\n) -> None:\n    # This is quadratic in the number of extensions\n    for e in extensions:\n        if e.oid == extension.oid:\n            raise ValueError(\"This extension has already been set.\")\n\n\ndef _reject_duplicate_attribute(\n    oid: ObjectIdentifier,\n    attributes: list[tuple[ObjectIdentifier, bytes, int | None]],\n) -> None:\n    # This is quadratic in the number of attributes\n    for attr_oid, _, _ in attributes:\n        if attr_oid == oid:\n            raise ValueError(\"This attribute has already been set.\")\n\n\ndef _convert_to_naive_utc_time(time: datetime.datetime) -> datetime.datetime:\n    \"\"\"Normalizes a datetime to a naive datetime in UTC.\n\n    time -- datetime to normalize. Assumed to be in UTC if not timezone\n            aware.\n    \"\"\"\n    if time.tzinfo is not None:\n        offset = time.utcoffset()\n        offset = offset if offset else datetime.timedelta()\n        return time.replace(tzinfo=None) - offset\n    else:\n        return time\n\n\nclass Attribute:\n    def __init__(\n        self,\n        oid: ObjectIdentifier,\n        value: bytes,\n        _type: int = _ASN1Type.UTF8String.value,\n    ) -> None:\n        self._oid = oid\n        self._value = value\n        self._type = _type\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return f\"<Attribute(oid={self.oid}, value={self.value!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Attribute):\n            return NotImplemented\n\n        return (\n            self.oid == other.oid\n            and self.value == other.value\n            and self._type == other._type\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value, self._type))\n\n\nclass Attributes:\n    def __init__(\n        self,\n        attributes: typing.Iterable[Attribute],\n    ) -> None:\n        self._attributes = list(attributes)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_attributes\")\n\n    def __repr__(self) -> str:\n        return f\"<Attributes({self._attributes})>\"\n\n    def get_attribute_for_oid(self, oid: ObjectIdentifier) -> Attribute:\n        for attr in self:\n            if attr.oid == oid:\n                return attr\n\n        raise AttributeNotFound(f\"No {oid} attribute was found\", oid)\n\n\nclass Version(utils.Enum):\n    v1 = 0\n    v3 = 2\n\n\nclass InvalidVersion(Exception):\n    def __init__(self, msg: str, parsed_version: int) -> None:\n        super().__init__(msg)\n        self.parsed_version = parsed_version\n\n\nclass Certificate(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def fingerprint(self, algorithm: hashes.HashAlgorithm) -> bytes:\n        \"\"\"\n        Returns bytes using digest passed.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        Returns certificate serial number\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def version(self) -> Version:\n        \"\"\"\n        Returns the certificate version\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> CertificatePublicKeyTypes:\n        \"\"\"\n        Returns the public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def public_key_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the public key.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_before(self) -> datetime.datetime:\n        \"\"\"\n        Not before time (represented as UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_before_utc(self) -> datetime.datetime:\n        \"\"\"\n        Not before time (represented as a non-naive UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_after(self) -> datetime.datetime:\n        \"\"\"\n        Not after time (represented as UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def not_valid_after_utc(self) -> datetime.datetime:\n        \"\"\"\n        Not after time (represented as a non-naive UTC datetime)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer(self) -> Name:\n        \"\"\"\n        Returns the issuer name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def subject(self) -> Name:\n        \"\"\"\n        Returns the subject name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certificate_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertificate payload bytes as defined in RFC 5280.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_precertificate_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertificate payload bytes with the SCT list extension\n        stripped.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Computes a hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the certificate to PEM or DER format.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify_directly_issued_by(self, issuer: Certificate) -> None:\n        \"\"\"\n        This method verifies that certificate issuer name matches the\n        issuer subject name and that the certificate is signed by the\n        issuer's private key. No other validation is performed.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nCertificate.register(rust_x509.Certificate)\n\n\nclass RevokedCertificate(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        Returns the serial number of the revoked certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_date(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of when this certificate was revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_date_utc(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of when this certificate was revoked as a non-naive\n        UTC datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object containing a list of Revoked extensions.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nRevokedCertificate.register(rust_x509.RevokedCertificate)\n\n\nclass _RawRevokedCertificate(RevokedCertificate):\n    def __init__(\n        self,\n        serial_number: int,\n        revocation_date: datetime.datetime,\n        extensions: Extensions,\n    ):\n        self._serial_number = serial_number\n        self._revocation_date = revocation_date\n        self._extensions = extensions\n\n    @property\n    def serial_number(self) -> int:\n        return self._serial_number\n\n    @property\n    def revocation_date(self) -> datetime.datetime:\n        warnings.warn(\n            \"Properties that return a na\u00efve datetime object have been \"\n            \"deprecated. Please switch to revocation_date_utc.\",\n            utils.DeprecatedIn42,\n            stacklevel=2,\n        )\n        return self._revocation_date\n\n    @property\n    def revocation_date_utc(self) -> datetime.datetime:\n        return self._revocation_date.replace(tzinfo=datetime.timezone.utc)\n\n    @property\n    def extensions(self) -> Extensions:\n        return self._extensions\n\n\nclass CertificateRevocationList(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the CRL to PEM or DER format.\n        \"\"\"\n\n    @abc.abstractmethod\n    def fingerprint(self, algorithm: hashes.HashAlgorithm) -> bytes:\n        \"\"\"\n        Returns bytes using digest passed.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_revoked_certificate_by_serial_number(\n        self, serial_number: int\n    ) -> RevokedCertificate | None:\n        \"\"\"\n        Returns an instance of RevokedCertificate or None if the serial_number\n        is not in the CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer(self) -> Name:\n        \"\"\"\n        Returns the X509Name with the issuer of this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        Returns the date of next update for this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update_utc(self) -> datetime.datetime | None:\n        \"\"\"\n        Returns the date of next update for this CRL as a non-naive UTC\n        datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def last_update(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of last update for this CRL.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def last_update_utc(self) -> datetime.datetime:\n        \"\"\"\n        Returns the date of last update for this CRL as a non-naive UTC\n        datetime.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns an Extensions object containing a list of CRL extensions.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certlist_bytes(self) -> bytes:\n        \"\"\"\n        Returns the tbsCertList payload bytes as defined in RFC 5280.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __len__(self) -> int:\n        \"\"\"\n        Number of revoked certificates in the CRL.\n        \"\"\"\n\n    @typing.overload\n    def __getitem__(self, idx: int) -> RevokedCertificate: ...\n\n    @typing.overload\n    def __getitem__(self, idx: slice) -> list[RevokedCertificate]: ...\n\n    @abc.abstractmethod\n    def __getitem__(\n        self, idx: int | slice\n    ) -> RevokedCertificate | list[RevokedCertificate]:\n        \"\"\"\n        Returns a revoked certificate (or slice of revoked certificates).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __iter__(self) -> typing.Iterator[RevokedCertificate]:\n        \"\"\"\n        Iterator over the revoked certificates\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_signature_valid(\n        self, public_key: CertificateIssuerPublicKeyTypes\n    ) -> bool:\n        \"\"\"\n        Verifies signature of revocation list against given public key.\n        \"\"\"\n\n\nCertificateRevocationList.register(rust_x509.CertificateRevocationList)\n\n\nclass CertificateSigningRequest(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        \"\"\"\n        Computes a hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> CertificatePublicKeyTypes:\n        \"\"\"\n        Returns the public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def subject(self) -> Name:\n        \"\"\"\n        Returns the subject name object.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        in the certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> ObjectIdentifier:\n        \"\"\"\n        Returns the ObjectIdentifier of the signature algorithm.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_parameters(\n        self,\n    ) -> None | padding.PSS | padding.PKCS1v15 | ec.ECDSA:\n        \"\"\"\n        Returns the signature algorithm parameters.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> Extensions:\n        \"\"\"\n        Returns the extensions in the signing request.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def attributes(self) -> Attributes:\n        \"\"\"\n        Returns an Attributes object.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Encodes the request to PEM or DER format.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        Returns the signature bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_certrequest_bytes(self) -> bytes:\n        \"\"\"\n        Returns the PKCS#10 CertificationRequestInfo bytes as defined in RFC\n        2986.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def is_signature_valid(self) -> bool:\n        \"\"\"\n        Verifies signature of signing request.\n        \"\"\"\n\n    @abc.abstractmethod\n    def get_attribute_for_oid(self, oid: ObjectIdentifier) -> bytes:\n        \"\"\"\n        Get the attribute value for a given OID.\n        \"\"\"\n\n\n# Runtime isinstance checks need this since the rust class is not a subclass.\nCertificateSigningRequest.register(rust_x509.CertificateSigningRequest)\n\n\nload_pem_x509_certificate = rust_x509.load_pem_x509_certificate\nload_der_x509_certificate = rust_x509.load_der_x509_certificate\n\nload_pem_x509_certificates = rust_x509.load_pem_x509_certificates\n\nload_pem_x509_csr = rust_x509.load_pem_x509_csr\nload_der_x509_csr = rust_x509.load_der_x509_csr\n\nload_pem_x509_crl = rust_x509.load_pem_x509_crl\nload_der_x509_crl = rust_x509.load_der_x509_crl\n\n\nclass CertificateSigningRequestBuilder:\n    def __init__(\n        self,\n        subject_name: Name | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n        attributes: list[tuple[ObjectIdentifier, bytes, int | None]] = [],\n    ):\n        \"\"\"\n        Creates an empty X.509 certificate request (v1).\n        \"\"\"\n        self._subject_name = subject_name\n        self._extensions = extensions\n        self._attributes = attributes\n\n    def subject_name(self, name: Name) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Sets the certificate requestor's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._subject_name is not None:\n            raise ValueError(\"The subject name may only be set once.\")\n        return CertificateSigningRequestBuilder(\n            name, self._extensions, self._attributes\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate request.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return CertificateSigningRequestBuilder(\n            self._subject_name,\n            [*self._extensions, extension],\n            self._attributes,\n        )\n\n    def add_attribute(\n        self,\n        oid: ObjectIdentifier,\n        value: bytes,\n        *,\n        _tag: _ASN1Type | None = None,\n    ) -> CertificateSigningRequestBuilder:\n        \"\"\"\n        Adds an X.509 attribute with an OID and associated value.\n        \"\"\"\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n\n        if not isinstance(value, bytes):\n            raise TypeError(\"value must be bytes\")\n\n        if _tag is not None and not isinstance(_tag, _ASN1Type):\n            raise TypeError(\"tag must be _ASN1Type\")\n\n        _reject_duplicate_attribute(oid, self._attributes)\n\n        if _tag is not None:\n            tag = _tag.value\n        else:\n            tag = None\n\n        return CertificateSigningRequestBuilder(\n            self._subject_name,\n            self._extensions,\n            [*self._attributes, (oid, value, tag)],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> CertificateSigningRequest:\n        \"\"\"\n        Signs the request using the requestor's private key.\n        \"\"\"\n        if self._subject_name is None:\n            raise ValueError(\"A CertificateSigningRequest must have a subject\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_csr(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass CertificateBuilder:\n    _extensions: list[Extension[ExtensionType]]\n\n    def __init__(\n        self,\n        issuer_name: Name | None = None,\n        subject_name: Name | None = None,\n        public_key: CertificatePublicKeyTypes | None = None,\n        serial_number: int | None = None,\n        not_valid_before: datetime.datetime | None = None,\n        not_valid_after: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n    ) -> None:\n        self._version = Version.v3\n        self._issuer_name = issuer_name\n        self._subject_name = subject_name\n        self._public_key = public_key\n        self._serial_number = serial_number\n        self._not_valid_before = not_valid_before\n        self._not_valid_after = not_valid_after\n        self._extensions = extensions\n\n    def issuer_name(self, name: Name) -> CertificateBuilder:\n        \"\"\"\n        Sets the CA's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._issuer_name is not None:\n            raise ValueError(\"The issuer name may only be set once.\")\n        return CertificateBuilder(\n            name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def subject_name(self, name: Name) -> CertificateBuilder:\n        \"\"\"\n        Sets the requestor's distinguished name.\n        \"\"\"\n        if not isinstance(name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._subject_name is not None:\n            raise ValueError(\"The subject name may only be set once.\")\n        return CertificateBuilder(\n            self._issuer_name,\n            name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def public_key(\n        self,\n        key: CertificatePublicKeyTypes,\n    ) -> CertificateBuilder:\n        \"\"\"\n        Sets the requestor's public key (as found in the signing request).\n        \"\"\"\n        if not isinstance(\n            key,\n            (\n                dsa.DSAPublicKey,\n                rsa.RSAPublicKey,\n                ec.EllipticCurvePublicKey,\n                ed25519.Ed25519PublicKey,\n                ed448.Ed448PublicKey,\n                x25519.X25519PublicKey,\n                x448.X448PublicKey,\n            ),\n        ):\n            raise TypeError(\n                \"Expecting one of DSAPublicKey, RSAPublicKey,\"\n                \" EllipticCurvePublicKey, Ed25519PublicKey,\"\n                \" Ed448PublicKey, X25519PublicKey, or \"\n                \"X448PublicKey.\"\n            )\n        if self._public_key is not None:\n            raise ValueError(\"The public key may only be set once.\")\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def serial_number(self, number: int) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate serial number.\n        \"\"\"\n        if not isinstance(number, int):\n            raise TypeError(\"Serial number must be of integral type.\")\n        if self._serial_number is not None:\n            raise ValueError(\"The serial number may only be set once.\")\n        if number <= 0:\n            raise ValueError(\"The serial number should be positive.\")\n\n        # ASN.1 integers are always signed, so most significant bit must be\n        # zero.\n        if number.bit_length() >= 160:  # As defined in RFC 5280\n            raise ValueError(\n                \"The serial number should not be more than 159 bits.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            number,\n            self._not_valid_before,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def not_valid_before(self, time: datetime.datetime) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate activation time.\n        \"\"\"\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._not_valid_before is not None:\n            raise ValueError(\"The not valid before may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The not valid before date must be on or after\"\n                \" 1950 January 1).\"\n            )\n        if self._not_valid_after is not None and time > self._not_valid_after:\n            raise ValueError(\n                \"The not valid before date must be before the not valid after \"\n                \"date.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            time,\n            self._not_valid_after,\n            self._extensions,\n        )\n\n    def not_valid_after(self, time: datetime.datetime) -> CertificateBuilder:\n        \"\"\"\n        Sets the certificate expiration time.\n        \"\"\"\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._not_valid_after is not None:\n            raise ValueError(\"The not valid after may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The not valid after date must be on or after\"\n                \" 1950 January 1.\"\n            )\n        if (\n            self._not_valid_before is not None\n            and time < self._not_valid_before\n        ):\n            raise ValueError(\n                \"The not valid after date must be after the not valid before \"\n                \"date.\"\n            )\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            time,\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return CertificateBuilder(\n            self._issuer_name,\n            self._subject_name,\n            self._public_key,\n            self._serial_number,\n            self._not_valid_before,\n            self._not_valid_after,\n            [*self._extensions, extension],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> Certificate:\n        \"\"\"\n        Signs the certificate using the CA's private key.\n        \"\"\"\n        if self._subject_name is None:\n            raise ValueError(\"A certificate must have a subject name\")\n\n        if self._issuer_name is None:\n            raise ValueError(\"A certificate must have an issuer name\")\n\n        if self._serial_number is None:\n            raise ValueError(\"A certificate must have a serial number\")\n\n        if self._not_valid_before is None:\n            raise ValueError(\"A certificate must have a not valid before time\")\n\n        if self._not_valid_after is None:\n            raise ValueError(\"A certificate must have a not valid after time\")\n\n        if self._public_key is None:\n            raise ValueError(\"A certificate must have a public key\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_certificate(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass CertificateRevocationListBuilder:\n    _extensions: list[Extension[ExtensionType]]\n    _revoked_certificates: list[RevokedCertificate]\n\n    def __init__(\n        self,\n        issuer_name: Name | None = None,\n        last_update: datetime.datetime | None = None,\n        next_update: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n        revoked_certificates: list[RevokedCertificate] = [],\n    ):\n        self._issuer_name = issuer_name\n        self._last_update = last_update\n        self._next_update = next_update\n        self._extensions = extensions\n        self._revoked_certificates = revoked_certificates\n\n    def issuer_name(\n        self, issuer_name: Name\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(issuer_name, Name):\n            raise TypeError(\"Expecting x509.Name object.\")\n        if self._issuer_name is not None:\n            raise ValueError(\"The issuer name may only be set once.\")\n        return CertificateRevocationListBuilder(\n            issuer_name,\n            self._last_update,\n            self._next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def last_update(\n        self, last_update: datetime.datetime\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(last_update, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._last_update is not None:\n            raise ValueError(\"Last update may only be set once.\")\n        last_update = _convert_to_naive_utc_time(last_update)\n        if last_update < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The last update date must be on or after 1950 January 1.\"\n            )\n        if self._next_update is not None and last_update > self._next_update:\n            raise ValueError(\n                \"The last update date must be before the next update date.\"\n            )\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            last_update,\n            self._next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def next_update(\n        self, next_update: datetime.datetime\n    ) -> CertificateRevocationListBuilder:\n        if not isinstance(next_update, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._next_update is not None:\n            raise ValueError(\"Last update may only be set once.\")\n        next_update = _convert_to_naive_utc_time(next_update)\n        if next_update < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The last update date must be on or after 1950 January 1.\"\n            )\n        if self._last_update is not None and next_update < self._last_update:\n            raise ValueError(\n                \"The next update date must be after the last update date.\"\n            )\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            next_update,\n            self._extensions,\n            self._revoked_certificates,\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> CertificateRevocationListBuilder:\n        \"\"\"\n        Adds an X.509 extension to the certificate revocation list.\n        \"\"\"\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            self._next_update,\n            [*self._extensions, extension],\n            self._revoked_certificates,\n        )\n\n    def add_revoked_certificate(\n        self, revoked_certificate: RevokedCertificate\n    ) -> CertificateRevocationListBuilder:\n        \"\"\"\n        Adds a revoked certificate to the CRL.\n        \"\"\"\n        if not isinstance(revoked_certificate, RevokedCertificate):\n            raise TypeError(\"Must be an instance of RevokedCertificate\")\n\n        return CertificateRevocationListBuilder(\n            self._issuer_name,\n            self._last_update,\n            self._next_update,\n            self._extensions,\n            [*self._revoked_certificates, revoked_certificate],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: _AllowedHashTypes | None,\n        backend: typing.Any = None,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> CertificateRevocationList:\n        if self._issuer_name is None:\n            raise ValueError(\"A CRL must have an issuer name\")\n\n        if self._last_update is None:\n            raise ValueError(\"A CRL must have a last update time\")\n\n        if self._next_update is None:\n            raise ValueError(\"A CRL must have a next update time\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return rust_x509.create_x509_crl(\n            self, private_key, algorithm, rsa_padding\n        )\n\n\nclass RevokedCertificateBuilder:\n    def __init__(\n        self,\n        serial_number: int | None = None,\n        revocation_date: datetime.datetime | None = None,\n        extensions: list[Extension[ExtensionType]] = [],\n    ):\n        self._serial_number = serial_number\n        self._revocation_date = revocation_date\n        self._extensions = extensions\n\n    def serial_number(self, number: int) -> RevokedCertificateBuilder:\n        if not isinstance(number, int):\n            raise TypeError(\"Serial number must be of integral type.\")\n        if self._serial_number is not None:\n            raise ValueError(\"The serial number may only be set once.\")\n        if number <= 0:\n            raise ValueError(\"The serial number should be positive\")\n\n        # ASN.1 integers are always signed, so most significant bit must be\n        # zero.\n        if number.bit_length() >= 160:  # As defined in RFC 5280\n            raise ValueError(\n                \"The serial number should not be more than 159 bits.\"\n            )\n        return RevokedCertificateBuilder(\n            number, self._revocation_date, self._extensions\n        )\n\n    def revocation_date(\n        self, time: datetime.datetime\n    ) -> RevokedCertificateBuilder:\n        if not isinstance(time, datetime.datetime):\n            raise TypeError(\"Expecting datetime object.\")\n        if self._revocation_date is not None:\n            raise ValueError(\"The revocation date may only be set once.\")\n        time = _convert_to_naive_utc_time(time)\n        if time < _EARLIEST_UTC_TIME:\n            raise ValueError(\n                \"The revocation date must be on or after 1950 January 1.\"\n            )\n        return RevokedCertificateBuilder(\n            self._serial_number, time, self._extensions\n        )\n\n    def add_extension(\n        self, extval: ExtensionType, critical: bool\n    ) -> RevokedCertificateBuilder:\n        if not isinstance(extval, ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n        return RevokedCertificateBuilder(\n            self._serial_number,\n            self._revocation_date,\n            [*self._extensions, extension],\n        )\n\n    def build(self, backend: typing.Any = None) -> RevokedCertificate:\n        if self._serial_number is None:\n            raise ValueError(\"A revoked certificate must have a serial number\")\n        if self._revocation_date is None:\n            raise ValueError(\n                \"A revoked certificate must have a revocation date\"\n            )\n        return _RawRevokedCertificate(\n            self._serial_number,\n            self._revocation_date,\n            Extensions(self._extensions),\n        )\n\n\ndef random_serial_number() -> int:\n    return int.from_bytes(os.urandom(20), \"big\") >> 1\n", "src/cryptography/x509/verification.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.x509.general_name import DNSName, IPAddress\n\n__all__ = [\n    \"ClientVerifier\",\n    \"PolicyBuilder\",\n    \"ServerVerifier\",\n    \"Store\",\n    \"Subject\",\n    \"VerificationError\",\n    \"VerifiedClient\",\n]\n\nStore = rust_x509.Store\nSubject = typing.Union[DNSName, IPAddress]\nVerifiedClient = rust_x509.VerifiedClient\nClientVerifier = rust_x509.ClientVerifier\nServerVerifier = rust_x509.ServerVerifier\nPolicyBuilder = rust_x509.PolicyBuilder\nVerificationError = rust_x509.VerificationError\n", "src/cryptography/x509/extensions.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport hashlib\nimport ipaddress\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.hazmat.bindings._rust import asn1\nfrom cryptography.hazmat.bindings._rust import x509 as rust_x509\nfrom cryptography.hazmat.primitives import constant_time, serialization\nfrom cryptography.hazmat.primitives.asymmetric.ec import EllipticCurvePublicKey\nfrom cryptography.hazmat.primitives.asymmetric.rsa import RSAPublicKey\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPublicKeyTypes,\n    CertificatePublicKeyTypes,\n)\nfrom cryptography.x509.certificate_transparency import (\n    SignedCertificateTimestamp,\n)\nfrom cryptography.x509.general_name import (\n    DirectoryName,\n    DNSName,\n    GeneralName,\n    IPAddress,\n    OtherName,\n    RegisteredID,\n    RFC822Name,\n    UniformResourceIdentifier,\n    _IPAddressTypes,\n)\nfrom cryptography.x509.name import Name, RelativeDistinguishedName\nfrom cryptography.x509.oid import (\n    CRLEntryExtensionOID,\n    ExtensionOID,\n    ObjectIdentifier,\n    OCSPExtensionOID,\n)\n\nExtensionTypeVar = typing.TypeVar(\n    \"ExtensionTypeVar\", bound=\"ExtensionType\", covariant=True\n)\n\n\ndef _key_identifier_from_public_key(\n    public_key: CertificatePublicKeyTypes,\n) -> bytes:\n    if isinstance(public_key, RSAPublicKey):\n        data = public_key.public_bytes(\n            serialization.Encoding.DER,\n            serialization.PublicFormat.PKCS1,\n        )\n    elif isinstance(public_key, EllipticCurvePublicKey):\n        data = public_key.public_bytes(\n            serialization.Encoding.X962,\n            serialization.PublicFormat.UncompressedPoint,\n        )\n    else:\n        # This is a very slow way to do this.\n        serialized = public_key.public_bytes(\n            serialization.Encoding.DER,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        data = asn1.parse_spki_for_data(serialized)\n\n    return hashlib.sha1(data).digest()\n\n\ndef _make_sequence_methods(field_name: str):\n    def len_method(self) -> int:\n        return len(getattr(self, field_name))\n\n    def iter_method(self):\n        return iter(getattr(self, field_name))\n\n    def getitem_method(self, idx):\n        return getattr(self, field_name)[idx]\n\n    return len_method, iter_method, getitem_method\n\n\nclass DuplicateExtension(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\nclass ExtensionNotFound(Exception):\n    def __init__(self, msg: str, oid: ObjectIdentifier) -> None:\n        super().__init__(msg)\n        self.oid = oid\n\n\nclass ExtensionType(metaclass=abc.ABCMeta):\n    oid: typing.ClassVar[ObjectIdentifier]\n\n    def public_bytes(self) -> bytes:\n        \"\"\"\n        Serializes the extension type to DER.\n        \"\"\"\n        raise NotImplementedError(\n            f\"public_bytes is not implemented for extension type {self!r}\"\n        )\n\n\nclass Extensions:\n    def __init__(\n        self, extensions: typing.Iterable[Extension[ExtensionType]]\n    ) -> None:\n        self._extensions = list(extensions)\n\n    def get_extension_for_oid(\n        self, oid: ObjectIdentifier\n    ) -> Extension[ExtensionType]:\n        for ext in self:\n            if ext.oid == oid:\n                return ext\n\n        raise ExtensionNotFound(f\"No {oid} extension was found\", oid)\n\n    def get_extension_for_class(\n        self, extclass: type[ExtensionTypeVar]\n    ) -> Extension[ExtensionTypeVar]:\n        if extclass is UnrecognizedExtension:\n            raise TypeError(\n                \"UnrecognizedExtension can't be used with \"\n                \"get_extension_for_class because more than one instance of the\"\n                \" class may be present.\"\n            )\n\n        for ext in self:\n            if isinstance(ext.value, extclass):\n                return ext\n\n        raise ExtensionNotFound(\n            f\"No {extclass} extension was found\", extclass.oid\n        )\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_extensions\")\n\n    def __repr__(self) -> str:\n        return f\"<Extensions({self._extensions})>\"\n\n\nclass CRLNumber(ExtensionType):\n    oid = ExtensionOID.CRL_NUMBER\n\n    def __init__(self, crl_number: int) -> None:\n        if not isinstance(crl_number, int):\n            raise TypeError(\"crl_number must be an integer\")\n\n        self._crl_number = crl_number\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLNumber):\n            return NotImplemented\n\n        return self.crl_number == other.crl_number\n\n    def __hash__(self) -> int:\n        return hash(self.crl_number)\n\n    def __repr__(self) -> str:\n        return f\"<CRLNumber({self.crl_number})>\"\n\n    @property\n    def crl_number(self) -> int:\n        return self._crl_number\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AuthorityKeyIdentifier(ExtensionType):\n    oid = ExtensionOID.AUTHORITY_KEY_IDENTIFIER\n\n    def __init__(\n        self,\n        key_identifier: bytes | None,\n        authority_cert_issuer: typing.Iterable[GeneralName] | None,\n        authority_cert_serial_number: int | None,\n    ) -> None:\n        if (authority_cert_issuer is None) != (\n            authority_cert_serial_number is None\n        ):\n            raise ValueError(\n                \"authority_cert_issuer and authority_cert_serial_number \"\n                \"must both be present or both None\"\n            )\n\n        if authority_cert_issuer is not None:\n            authority_cert_issuer = list(authority_cert_issuer)\n            if not all(\n                isinstance(x, GeneralName) for x in authority_cert_issuer\n            ):\n                raise TypeError(\n                    \"authority_cert_issuer must be a list of GeneralName \"\n                    \"objects\"\n                )\n\n        if authority_cert_serial_number is not None and not isinstance(\n            authority_cert_serial_number, int\n        ):\n            raise TypeError(\"authority_cert_serial_number must be an integer\")\n\n        self._key_identifier = key_identifier\n        self._authority_cert_issuer = authority_cert_issuer\n        self._authority_cert_serial_number = authority_cert_serial_number\n\n    # This takes a subset of CertificatePublicKeyTypes because an issuer\n    # cannot have an X25519/X448 key. This introduces some unfortunate\n    # asymmetry that requires typing users to explicitly\n    # narrow their type, but we should make this accurate and not just\n    # convenient.\n    @classmethod\n    def from_issuer_public_key(\n        cls, public_key: CertificateIssuerPublicKeyTypes\n    ) -> AuthorityKeyIdentifier:\n        digest = _key_identifier_from_public_key(public_key)\n        return cls(\n            key_identifier=digest,\n            authority_cert_issuer=None,\n            authority_cert_serial_number=None,\n        )\n\n    @classmethod\n    def from_issuer_subject_key_identifier(\n        cls, ski: SubjectKeyIdentifier\n    ) -> AuthorityKeyIdentifier:\n        return cls(\n            key_identifier=ski.digest,\n            authority_cert_issuer=None,\n            authority_cert_serial_number=None,\n        )\n\n    def __repr__(self) -> str:\n        return (\n            f\"<AuthorityKeyIdentifier(key_identifier={self.key_identifier!r}, \"\n            f\"authority_cert_issuer={self.authority_cert_issuer}, \"\n            f\"authority_cert_serial_number={self.authority_cert_serial_number}\"\n            \")>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AuthorityKeyIdentifier):\n            return NotImplemented\n\n        return (\n            self.key_identifier == other.key_identifier\n            and self.authority_cert_issuer == other.authority_cert_issuer\n            and self.authority_cert_serial_number\n            == other.authority_cert_serial_number\n        )\n\n    def __hash__(self) -> int:\n        if self.authority_cert_issuer is None:\n            aci = None\n        else:\n            aci = tuple(self.authority_cert_issuer)\n        return hash(\n            (self.key_identifier, aci, self.authority_cert_serial_number)\n        )\n\n    @property\n    def key_identifier(self) -> bytes | None:\n        return self._key_identifier\n\n    @property\n    def authority_cert_issuer(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._authority_cert_issuer\n\n    @property\n    def authority_cert_serial_number(self) -> int | None:\n        return self._authority_cert_serial_number\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SubjectKeyIdentifier(ExtensionType):\n    oid = ExtensionOID.SUBJECT_KEY_IDENTIFIER\n\n    def __init__(self, digest: bytes) -> None:\n        self._digest = digest\n\n    @classmethod\n    def from_public_key(\n        cls, public_key: CertificatePublicKeyTypes\n    ) -> SubjectKeyIdentifier:\n        return cls(_key_identifier_from_public_key(public_key))\n\n    @property\n    def digest(self) -> bytes:\n        return self._digest\n\n    @property\n    def key_identifier(self) -> bytes:\n        return self._digest\n\n    def __repr__(self) -> str:\n        return f\"<SubjectKeyIdentifier(digest={self.digest!r})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectKeyIdentifier):\n            return NotImplemented\n\n        return constant_time.bytes_eq(self.digest, other.digest)\n\n    def __hash__(self) -> int:\n        return hash(self.digest)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AuthorityInformationAccess(ExtensionType):\n    oid = ExtensionOID.AUTHORITY_INFORMATION_ACCESS\n\n    def __init__(\n        self, descriptions: typing.Iterable[AccessDescription]\n    ) -> None:\n        descriptions = list(descriptions)\n        if not all(isinstance(x, AccessDescription) for x in descriptions):\n            raise TypeError(\n                \"Every item in the descriptions list must be an \"\n                \"AccessDescription\"\n            )\n\n        self._descriptions = descriptions\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_descriptions\")\n\n    def __repr__(self) -> str:\n        return f\"<AuthorityInformationAccess({self._descriptions})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AuthorityInformationAccess):\n            return NotImplemented\n\n        return self._descriptions == other._descriptions\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._descriptions))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SubjectInformationAccess(ExtensionType):\n    oid = ExtensionOID.SUBJECT_INFORMATION_ACCESS\n\n    def __init__(\n        self, descriptions: typing.Iterable[AccessDescription]\n    ) -> None:\n        descriptions = list(descriptions)\n        if not all(isinstance(x, AccessDescription) for x in descriptions):\n            raise TypeError(\n                \"Every item in the descriptions list must be an \"\n                \"AccessDescription\"\n            )\n\n        self._descriptions = descriptions\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_descriptions\")\n\n    def __repr__(self) -> str:\n        return f\"<SubjectInformationAccess({self._descriptions})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectInformationAccess):\n            return NotImplemented\n\n        return self._descriptions == other._descriptions\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._descriptions))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass AccessDescription:\n    def __init__(\n        self, access_method: ObjectIdentifier, access_location: GeneralName\n    ) -> None:\n        if not isinstance(access_method, ObjectIdentifier):\n            raise TypeError(\"access_method must be an ObjectIdentifier\")\n\n        if not isinstance(access_location, GeneralName):\n            raise TypeError(\"access_location must be a GeneralName\")\n\n        self._access_method = access_method\n        self._access_location = access_location\n\n    def __repr__(self) -> str:\n        return (\n            f\"<AccessDescription(access_method={self.access_method}, \"\n            f\"access_location={self.access_location})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, AccessDescription):\n            return NotImplemented\n\n        return (\n            self.access_method == other.access_method\n            and self.access_location == other.access_location\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.access_method, self.access_location))\n\n    @property\n    def access_method(self) -> ObjectIdentifier:\n        return self._access_method\n\n    @property\n    def access_location(self) -> GeneralName:\n        return self._access_location\n\n\nclass BasicConstraints(ExtensionType):\n    oid = ExtensionOID.BASIC_CONSTRAINTS\n\n    def __init__(self, ca: bool, path_length: int | None) -> None:\n        if not isinstance(ca, bool):\n            raise TypeError(\"ca must be a boolean value\")\n\n        if path_length is not None and not ca:\n            raise ValueError(\"path_length must be None when ca is False\")\n\n        if path_length is not None and (\n            not isinstance(path_length, int) or path_length < 0\n        ):\n            raise TypeError(\n                \"path_length must be a non-negative integer or None\"\n            )\n\n        self._ca = ca\n        self._path_length = path_length\n\n    @property\n    def ca(self) -> bool:\n        return self._ca\n\n    @property\n    def path_length(self) -> int | None:\n        return self._path_length\n\n    def __repr__(self) -> str:\n        return (\n            f\"<BasicConstraints(ca={self.ca}, \"\n            f\"path_length={self.path_length})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, BasicConstraints):\n            return NotImplemented\n\n        return self.ca == other.ca and self.path_length == other.path_length\n\n    def __hash__(self) -> int:\n        return hash((self.ca, self.path_length))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass DeltaCRLIndicator(ExtensionType):\n    oid = ExtensionOID.DELTA_CRL_INDICATOR\n\n    def __init__(self, crl_number: int) -> None:\n        if not isinstance(crl_number, int):\n            raise TypeError(\"crl_number must be an integer\")\n\n        self._crl_number = crl_number\n\n    @property\n    def crl_number(self) -> int:\n        return self._crl_number\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DeltaCRLIndicator):\n            return NotImplemented\n\n        return self.crl_number == other.crl_number\n\n    def __hash__(self) -> int:\n        return hash(self.crl_number)\n\n    def __repr__(self) -> str:\n        return f\"<DeltaCRLIndicator(crl_number={self.crl_number})>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CRLDistributionPoints(ExtensionType):\n    oid = ExtensionOID.CRL_DISTRIBUTION_POINTS\n\n    def __init__(\n        self, distribution_points: typing.Iterable[DistributionPoint]\n    ) -> None:\n        distribution_points = list(distribution_points)\n        if not all(\n            isinstance(x, DistributionPoint) for x in distribution_points\n        ):\n            raise TypeError(\n                \"distribution_points must be a list of DistributionPoint \"\n                \"objects\"\n            )\n\n        self._distribution_points = distribution_points\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_distribution_points\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<CRLDistributionPoints({self._distribution_points})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLDistributionPoints):\n            return NotImplemented\n\n        return self._distribution_points == other._distribution_points\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._distribution_points))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass FreshestCRL(ExtensionType):\n    oid = ExtensionOID.FRESHEST_CRL\n\n    def __init__(\n        self, distribution_points: typing.Iterable[DistributionPoint]\n    ) -> None:\n        distribution_points = list(distribution_points)\n        if not all(\n            isinstance(x, DistributionPoint) for x in distribution_points\n        ):\n            raise TypeError(\n                \"distribution_points must be a list of DistributionPoint \"\n                \"objects\"\n            )\n\n        self._distribution_points = distribution_points\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_distribution_points\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<FreshestCRL({self._distribution_points})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, FreshestCRL):\n            return NotImplemented\n\n        return self._distribution_points == other._distribution_points\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._distribution_points))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass DistributionPoint:\n    def __init__(\n        self,\n        full_name: typing.Iterable[GeneralName] | None,\n        relative_name: RelativeDistinguishedName | None,\n        reasons: frozenset[ReasonFlags] | None,\n        crl_issuer: typing.Iterable[GeneralName] | None,\n    ) -> None:\n        if full_name and relative_name:\n            raise ValueError(\n                \"You cannot provide both full_name and relative_name, at \"\n                \"least one must be None.\"\n            )\n        if not full_name and not relative_name and not crl_issuer:\n            raise ValueError(\n                \"Either full_name, relative_name or crl_issuer must be \"\n                \"provided.\"\n            )\n\n        if full_name is not None:\n            full_name = list(full_name)\n            if not all(isinstance(x, GeneralName) for x in full_name):\n                raise TypeError(\n                    \"full_name must be a list of GeneralName objects\"\n                )\n\n        if relative_name:\n            if not isinstance(relative_name, RelativeDistinguishedName):\n                raise TypeError(\n                    \"relative_name must be a RelativeDistinguishedName\"\n                )\n\n        if crl_issuer is not None:\n            crl_issuer = list(crl_issuer)\n            if not all(isinstance(x, GeneralName) for x in crl_issuer):\n                raise TypeError(\n                    \"crl_issuer must be None or a list of general names\"\n                )\n\n        if reasons and (\n            not isinstance(reasons, frozenset)\n            or not all(isinstance(x, ReasonFlags) for x in reasons)\n        ):\n            raise TypeError(\"reasons must be None or frozenset of ReasonFlags\")\n\n        if reasons and (\n            ReasonFlags.unspecified in reasons\n            or ReasonFlags.remove_from_crl in reasons\n        ):\n            raise ValueError(\n                \"unspecified and remove_from_crl are not valid reasons in a \"\n                \"DistributionPoint\"\n            )\n\n        self._full_name = full_name\n        self._relative_name = relative_name\n        self._reasons = reasons\n        self._crl_issuer = crl_issuer\n\n    def __repr__(self) -> str:\n        return (\n            \"<DistributionPoint(full_name={0.full_name}, relative_name={0.rela\"\n            \"tive_name}, reasons={0.reasons}, \"\n            \"crl_issuer={0.crl_issuer})>\".format(self)\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, DistributionPoint):\n            return NotImplemented\n\n        return (\n            self.full_name == other.full_name\n            and self.relative_name == other.relative_name\n            and self.reasons == other.reasons\n            and self.crl_issuer == other.crl_issuer\n        )\n\n    def __hash__(self) -> int:\n        if self.full_name is not None:\n            fn: tuple[GeneralName, ...] | None = tuple(self.full_name)\n        else:\n            fn = None\n\n        if self.crl_issuer is not None:\n            crl_issuer: tuple[GeneralName, ...] | None = tuple(self.crl_issuer)\n        else:\n            crl_issuer = None\n\n        return hash((fn, self.relative_name, self.reasons, crl_issuer))\n\n    @property\n    def full_name(self) -> list[GeneralName] | None:\n        return self._full_name\n\n    @property\n    def relative_name(self) -> RelativeDistinguishedName | None:\n        return self._relative_name\n\n    @property\n    def reasons(self) -> frozenset[ReasonFlags] | None:\n        return self._reasons\n\n    @property\n    def crl_issuer(self) -> list[GeneralName] | None:\n        return self._crl_issuer\n\n\nclass ReasonFlags(utils.Enum):\n    unspecified = \"unspecified\"\n    key_compromise = \"keyCompromise\"\n    ca_compromise = \"cACompromise\"\n    affiliation_changed = \"affiliationChanged\"\n    superseded = \"superseded\"\n    cessation_of_operation = \"cessationOfOperation\"\n    certificate_hold = \"certificateHold\"\n    privilege_withdrawn = \"privilegeWithdrawn\"\n    aa_compromise = \"aACompromise\"\n    remove_from_crl = \"removeFromCRL\"\n\n\n# These are distribution point bit string mappings. Not to be confused with\n# CRLReason reason flags bit string mappings.\n# ReasonFlags ::= BIT STRING {\n#      unused                  (0),\n#      keyCompromise           (1),\n#      cACompromise            (2),\n#      affiliationChanged      (3),\n#      superseded              (4),\n#      cessationOfOperation    (5),\n#      certificateHold         (6),\n#      privilegeWithdrawn      (7),\n#      aACompromise            (8) }\n_REASON_BIT_MAPPING = {\n    1: ReasonFlags.key_compromise,\n    2: ReasonFlags.ca_compromise,\n    3: ReasonFlags.affiliation_changed,\n    4: ReasonFlags.superseded,\n    5: ReasonFlags.cessation_of_operation,\n    6: ReasonFlags.certificate_hold,\n    7: ReasonFlags.privilege_withdrawn,\n    8: ReasonFlags.aa_compromise,\n}\n\n_CRLREASONFLAGS = {\n    ReasonFlags.key_compromise: 1,\n    ReasonFlags.ca_compromise: 2,\n    ReasonFlags.affiliation_changed: 3,\n    ReasonFlags.superseded: 4,\n    ReasonFlags.cessation_of_operation: 5,\n    ReasonFlags.certificate_hold: 6,\n    ReasonFlags.privilege_withdrawn: 7,\n    ReasonFlags.aa_compromise: 8,\n}\n\n#    CRLReason ::= ENUMERATED {\n#        unspecified             (0),\n#        keyCompromise           (1),\n#        cACompromise            (2),\n#        affiliationChanged      (3),\n#        superseded              (4),\n#        cessationOfOperation    (5),\n#        certificateHold         (6),\n#             -- value 7 is not used\n#        removeFromCRL           (8),\n#        privilegeWithdrawn      (9),\n#        aACompromise           (10) }\n_CRL_ENTRY_REASON_ENUM_TO_CODE = {\n    ReasonFlags.unspecified: 0,\n    ReasonFlags.key_compromise: 1,\n    ReasonFlags.ca_compromise: 2,\n    ReasonFlags.affiliation_changed: 3,\n    ReasonFlags.superseded: 4,\n    ReasonFlags.cessation_of_operation: 5,\n    ReasonFlags.certificate_hold: 6,\n    ReasonFlags.remove_from_crl: 8,\n    ReasonFlags.privilege_withdrawn: 9,\n    ReasonFlags.aa_compromise: 10,\n}\n\n\nclass PolicyConstraints(ExtensionType):\n    oid = ExtensionOID.POLICY_CONSTRAINTS\n\n    def __init__(\n        self,\n        require_explicit_policy: int | None,\n        inhibit_policy_mapping: int | None,\n    ) -> None:\n        if require_explicit_policy is not None and not isinstance(\n            require_explicit_policy, int\n        ):\n            raise TypeError(\n                \"require_explicit_policy must be a non-negative integer or \"\n                \"None\"\n            )\n\n        if inhibit_policy_mapping is not None and not isinstance(\n            inhibit_policy_mapping, int\n        ):\n            raise TypeError(\n                \"inhibit_policy_mapping must be a non-negative integer or None\"\n            )\n\n        if inhibit_policy_mapping is None and require_explicit_policy is None:\n            raise ValueError(\n                \"At least one of require_explicit_policy and \"\n                \"inhibit_policy_mapping must not be None\"\n            )\n\n        self._require_explicit_policy = require_explicit_policy\n        self._inhibit_policy_mapping = inhibit_policy_mapping\n\n    def __repr__(self) -> str:\n        return (\n            \"<PolicyConstraints(require_explicit_policy={0.require_explicit\"\n            \"_policy}, inhibit_policy_mapping={0.inhibit_policy_\"\n            \"mapping})>\".format(self)\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PolicyConstraints):\n            return NotImplemented\n\n        return (\n            self.require_explicit_policy == other.require_explicit_policy\n            and self.inhibit_policy_mapping == other.inhibit_policy_mapping\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (self.require_explicit_policy, self.inhibit_policy_mapping)\n        )\n\n    @property\n    def require_explicit_policy(self) -> int | None:\n        return self._require_explicit_policy\n\n    @property\n    def inhibit_policy_mapping(self) -> int | None:\n        return self._inhibit_policy_mapping\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CertificatePolicies(ExtensionType):\n    oid = ExtensionOID.CERTIFICATE_POLICIES\n\n    def __init__(self, policies: typing.Iterable[PolicyInformation]) -> None:\n        policies = list(policies)\n        if not all(isinstance(x, PolicyInformation) for x in policies):\n            raise TypeError(\n                \"Every item in the policies list must be a \"\n                \"PolicyInformation\"\n            )\n\n        self._policies = policies\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_policies\")\n\n    def __repr__(self) -> str:\n        return f\"<CertificatePolicies({self._policies})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CertificatePolicies):\n            return NotImplemented\n\n        return self._policies == other._policies\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._policies))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PolicyInformation:\n    def __init__(\n        self,\n        policy_identifier: ObjectIdentifier,\n        policy_qualifiers: typing.Iterable[str | UserNotice] | None,\n    ) -> None:\n        if not isinstance(policy_identifier, ObjectIdentifier):\n            raise TypeError(\"policy_identifier must be an ObjectIdentifier\")\n\n        self._policy_identifier = policy_identifier\n\n        if policy_qualifiers is not None:\n            policy_qualifiers = list(policy_qualifiers)\n            if not all(\n                isinstance(x, (str, UserNotice)) for x in policy_qualifiers\n            ):\n                raise TypeError(\n                    \"policy_qualifiers must be a list of strings and/or \"\n                    \"UserNotice objects or None\"\n                )\n\n        self._policy_qualifiers = policy_qualifiers\n\n    def __repr__(self) -> str:\n        return (\n            f\"<PolicyInformation(policy_identifier={self.policy_identifier}, \"\n            f\"policy_qualifiers={self.policy_qualifiers})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PolicyInformation):\n            return NotImplemented\n\n        return (\n            self.policy_identifier == other.policy_identifier\n            and self.policy_qualifiers == other.policy_qualifiers\n        )\n\n    def __hash__(self) -> int:\n        if self.policy_qualifiers is not None:\n            pq: tuple[str | UserNotice, ...] | None = tuple(\n                self.policy_qualifiers\n            )\n        else:\n            pq = None\n\n        return hash((self.policy_identifier, pq))\n\n    @property\n    def policy_identifier(self) -> ObjectIdentifier:\n        return self._policy_identifier\n\n    @property\n    def policy_qualifiers(\n        self,\n    ) -> list[str | UserNotice] | None:\n        return self._policy_qualifiers\n\n\nclass UserNotice:\n    def __init__(\n        self,\n        notice_reference: NoticeReference | None,\n        explicit_text: str | None,\n    ) -> None:\n        if notice_reference and not isinstance(\n            notice_reference, NoticeReference\n        ):\n            raise TypeError(\n                \"notice_reference must be None or a NoticeReference\"\n            )\n\n        self._notice_reference = notice_reference\n        self._explicit_text = explicit_text\n\n    def __repr__(self) -> str:\n        return (\n            f\"<UserNotice(notice_reference={self.notice_reference}, \"\n            f\"explicit_text={self.explicit_text!r})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UserNotice):\n            return NotImplemented\n\n        return (\n            self.notice_reference == other.notice_reference\n            and self.explicit_text == other.explicit_text\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.notice_reference, self.explicit_text))\n\n    @property\n    def notice_reference(self) -> NoticeReference | None:\n        return self._notice_reference\n\n    @property\n    def explicit_text(self) -> str | None:\n        return self._explicit_text\n\n\nclass NoticeReference:\n    def __init__(\n        self,\n        organization: str | None,\n        notice_numbers: typing.Iterable[int],\n    ) -> None:\n        self._organization = organization\n        notice_numbers = list(notice_numbers)\n        if not all(isinstance(x, int) for x in notice_numbers):\n            raise TypeError(\"notice_numbers must be a list of integers\")\n\n        self._notice_numbers = notice_numbers\n\n    def __repr__(self) -> str:\n        return (\n            f\"<NoticeReference(organization={self.organization!r}, \"\n            f\"notice_numbers={self.notice_numbers})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NoticeReference):\n            return NotImplemented\n\n        return (\n            self.organization == other.organization\n            and self.notice_numbers == other.notice_numbers\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.organization, tuple(self.notice_numbers)))\n\n    @property\n    def organization(self) -> str | None:\n        return self._organization\n\n    @property\n    def notice_numbers(self) -> list[int]:\n        return self._notice_numbers\n\n\nclass ExtendedKeyUsage(ExtensionType):\n    oid = ExtensionOID.EXTENDED_KEY_USAGE\n\n    def __init__(self, usages: typing.Iterable[ObjectIdentifier]) -> None:\n        usages = list(usages)\n        if not all(isinstance(x, ObjectIdentifier) for x in usages):\n            raise TypeError(\n                \"Every item in the usages list must be an ObjectIdentifier\"\n            )\n\n        self._usages = usages\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_usages\")\n\n    def __repr__(self) -> str:\n        return f\"<ExtendedKeyUsage({self._usages})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, ExtendedKeyUsage):\n            return NotImplemented\n\n        return self._usages == other._usages\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._usages))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPNoCheck(ExtensionType):\n    oid = ExtensionOID.OCSP_NO_CHECK\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPNoCheck):\n            return NotImplemented\n\n        return True\n\n    def __hash__(self) -> int:\n        return hash(OCSPNoCheck)\n\n    def __repr__(self) -> str:\n        return \"<OCSPNoCheck()>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PrecertPoison(ExtensionType):\n    oid = ExtensionOID.PRECERT_POISON\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PrecertPoison):\n            return NotImplemented\n\n        return True\n\n    def __hash__(self) -> int:\n        return hash(PrecertPoison)\n\n    def __repr__(self) -> str:\n        return \"<PrecertPoison()>\"\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass TLSFeature(ExtensionType):\n    oid = ExtensionOID.TLS_FEATURE\n\n    def __init__(self, features: typing.Iterable[TLSFeatureType]) -> None:\n        features = list(features)\n        if (\n            not all(isinstance(x, TLSFeatureType) for x in features)\n            or len(features) == 0\n        ):\n            raise TypeError(\n                \"features must be a list of elements from the TLSFeatureType \"\n                \"enum\"\n            )\n\n        self._features = features\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_features\")\n\n    def __repr__(self) -> str:\n        return f\"<TLSFeature(features={self._features})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, TLSFeature):\n            return NotImplemented\n\n        return self._features == other._features\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._features))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass TLSFeatureType(utils.Enum):\n    # status_request is defined in RFC 6066 and is used for what is commonly\n    # called OCSP Must-Staple when present in the TLS Feature extension in an\n    # X.509 certificate.\n    status_request = 5\n    # status_request_v2 is defined in RFC 6961 and allows multiple OCSP\n    # responses to be provided. It is not currently in use by clients or\n    # servers.\n    status_request_v2 = 17\n\n\n_TLS_FEATURE_TYPE_TO_ENUM = {x.value: x for x in TLSFeatureType}\n\n\nclass InhibitAnyPolicy(ExtensionType):\n    oid = ExtensionOID.INHIBIT_ANY_POLICY\n\n    def __init__(self, skip_certs: int) -> None:\n        if not isinstance(skip_certs, int):\n            raise TypeError(\"skip_certs must be an integer\")\n\n        if skip_certs < 0:\n            raise ValueError(\"skip_certs must be a non-negative integer\")\n\n        self._skip_certs = skip_certs\n\n    def __repr__(self) -> str:\n        return f\"<InhibitAnyPolicy(skip_certs={self.skip_certs})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, InhibitAnyPolicy):\n            return NotImplemented\n\n        return self.skip_certs == other.skip_certs\n\n    def __hash__(self) -> int:\n        return hash(self.skip_certs)\n\n    @property\n    def skip_certs(self) -> int:\n        return self._skip_certs\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass KeyUsage(ExtensionType):\n    oid = ExtensionOID.KEY_USAGE\n\n    def __init__(\n        self,\n        digital_signature: bool,\n        content_commitment: bool,\n        key_encipherment: bool,\n        data_encipherment: bool,\n        key_agreement: bool,\n        key_cert_sign: bool,\n        crl_sign: bool,\n        encipher_only: bool,\n        decipher_only: bool,\n    ) -> None:\n        if not key_agreement and (encipher_only or decipher_only):\n            raise ValueError(\n                \"encipher_only and decipher_only can only be true when \"\n                \"key_agreement is true\"\n            )\n\n        self._digital_signature = digital_signature\n        self._content_commitment = content_commitment\n        self._key_encipherment = key_encipherment\n        self._data_encipherment = data_encipherment\n        self._key_agreement = key_agreement\n        self._key_cert_sign = key_cert_sign\n        self._crl_sign = crl_sign\n        self._encipher_only = encipher_only\n        self._decipher_only = decipher_only\n\n    @property\n    def digital_signature(self) -> bool:\n        return self._digital_signature\n\n    @property\n    def content_commitment(self) -> bool:\n        return self._content_commitment\n\n    @property\n    def key_encipherment(self) -> bool:\n        return self._key_encipherment\n\n    @property\n    def data_encipherment(self) -> bool:\n        return self._data_encipherment\n\n    @property\n    def key_agreement(self) -> bool:\n        return self._key_agreement\n\n    @property\n    def key_cert_sign(self) -> bool:\n        return self._key_cert_sign\n\n    @property\n    def crl_sign(self) -> bool:\n        return self._crl_sign\n\n    @property\n    def encipher_only(self) -> bool:\n        if not self.key_agreement:\n            raise ValueError(\n                \"encipher_only is undefined unless key_agreement is true\"\n            )\n        else:\n            return self._encipher_only\n\n    @property\n    def decipher_only(self) -> bool:\n        if not self.key_agreement:\n            raise ValueError(\n                \"decipher_only is undefined unless key_agreement is true\"\n            )\n        else:\n            return self._decipher_only\n\n    def __repr__(self) -> str:\n        try:\n            encipher_only = self.encipher_only\n            decipher_only = self.decipher_only\n        except ValueError:\n            # Users found None confusing because even though encipher/decipher\n            # have no meaning unless key_agreement is true, to construct an\n            # instance of the class you still need to pass False.\n            encipher_only = False\n            decipher_only = False\n\n        return (\n            f\"<KeyUsage(digital_signature={self.digital_signature}, \"\n            f\"content_commitment={self.content_commitment}, \"\n            f\"key_encipherment={self.key_encipherment}, \"\n            f\"data_encipherment={self.data_encipherment}, \"\n            f\"key_agreement={self.key_agreement}, \"\n            f\"key_cert_sign={self.key_cert_sign}, crl_sign={self.crl_sign}, \"\n            f\"encipher_only={encipher_only}, decipher_only={decipher_only})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, KeyUsage):\n            return NotImplemented\n\n        return (\n            self.digital_signature == other.digital_signature\n            and self.content_commitment == other.content_commitment\n            and self.key_encipherment == other.key_encipherment\n            and self.data_encipherment == other.data_encipherment\n            and self.key_agreement == other.key_agreement\n            and self.key_cert_sign == other.key_cert_sign\n            and self.crl_sign == other.crl_sign\n            and self._encipher_only == other._encipher_only\n            and self._decipher_only == other._decipher_only\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.digital_signature,\n                self.content_commitment,\n                self.key_encipherment,\n                self.data_encipherment,\n                self.key_agreement,\n                self.key_cert_sign,\n                self.crl_sign,\n                self._encipher_only,\n                self._decipher_only,\n            )\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass NameConstraints(ExtensionType):\n    oid = ExtensionOID.NAME_CONSTRAINTS\n\n    def __init__(\n        self,\n        permitted_subtrees: typing.Iterable[GeneralName] | None,\n        excluded_subtrees: typing.Iterable[GeneralName] | None,\n    ) -> None:\n        if permitted_subtrees is not None:\n            permitted_subtrees = list(permitted_subtrees)\n            if not permitted_subtrees:\n                raise ValueError(\n                    \"permitted_subtrees must be a non-empty list or None\"\n                )\n            if not all(isinstance(x, GeneralName) for x in permitted_subtrees):\n                raise TypeError(\n                    \"permitted_subtrees must be a list of GeneralName objects \"\n                    \"or None\"\n                )\n\n            self._validate_tree(permitted_subtrees)\n\n        if excluded_subtrees is not None:\n            excluded_subtrees = list(excluded_subtrees)\n            if not excluded_subtrees:\n                raise ValueError(\n                    \"excluded_subtrees must be a non-empty list or None\"\n                )\n            if not all(isinstance(x, GeneralName) for x in excluded_subtrees):\n                raise TypeError(\n                    \"excluded_subtrees must be a list of GeneralName objects \"\n                    \"or None\"\n                )\n\n            self._validate_tree(excluded_subtrees)\n\n        if permitted_subtrees is None and excluded_subtrees is None:\n            raise ValueError(\n                \"At least one of permitted_subtrees and excluded_subtrees \"\n                \"must not be None\"\n            )\n\n        self._permitted_subtrees = permitted_subtrees\n        self._excluded_subtrees = excluded_subtrees\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, NameConstraints):\n            return NotImplemented\n\n        return (\n            self.excluded_subtrees == other.excluded_subtrees\n            and self.permitted_subtrees == other.permitted_subtrees\n        )\n\n    def _validate_tree(self, tree: typing.Iterable[GeneralName]) -> None:\n        self._validate_ip_name(tree)\n        self._validate_dns_name(tree)\n\n    def _validate_ip_name(self, tree: typing.Iterable[GeneralName]) -> None:\n        if any(\n            isinstance(name, IPAddress)\n            and not isinstance(\n                name.value, (ipaddress.IPv4Network, ipaddress.IPv6Network)\n            )\n            for name in tree\n        ):\n            raise TypeError(\n                \"IPAddress name constraints must be an IPv4Network or\"\n                \" IPv6Network object\"\n            )\n\n    def _validate_dns_name(self, tree: typing.Iterable[GeneralName]) -> None:\n        if any(\n            isinstance(name, DNSName) and \"*\" in name.value for name in tree\n        ):\n            raise ValueError(\n                \"DNSName name constraints must not contain the '*' wildcard\"\n                \" character\"\n            )\n\n    def __repr__(self) -> str:\n        return (\n            f\"<NameConstraints(permitted_subtrees={self.permitted_subtrees}, \"\n            f\"excluded_subtrees={self.excluded_subtrees})>\"\n        )\n\n    def __hash__(self) -> int:\n        if self.permitted_subtrees is not None:\n            ps: tuple[GeneralName, ...] | None = tuple(self.permitted_subtrees)\n        else:\n            ps = None\n\n        if self.excluded_subtrees is not None:\n            es: tuple[GeneralName, ...] | None = tuple(self.excluded_subtrees)\n        else:\n            es = None\n\n        return hash((ps, es))\n\n    @property\n    def permitted_subtrees(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._permitted_subtrees\n\n    @property\n    def excluded_subtrees(\n        self,\n    ) -> list[GeneralName] | None:\n        return self._excluded_subtrees\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass Extension(typing.Generic[ExtensionTypeVar]):\n    def __init__(\n        self, oid: ObjectIdentifier, critical: bool, value: ExtensionTypeVar\n    ) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\n                \"oid argument must be an ObjectIdentifier instance.\"\n            )\n\n        if not isinstance(critical, bool):\n            raise TypeError(\"critical must be a boolean value\")\n\n        self._oid = oid\n        self._critical = critical\n        self._value = value\n\n    @property\n    def oid(self) -> ObjectIdentifier:\n        return self._oid\n\n    @property\n    def critical(self) -> bool:\n        return self._critical\n\n    @property\n    def value(self) -> ExtensionTypeVar:\n        return self._value\n\n    def __repr__(self) -> str:\n        return (\n            f\"<Extension(oid={self.oid}, critical={self.critical}, \"\n            f\"value={self.value})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, Extension):\n            return NotImplemented\n\n        return (\n            self.oid == other.oid\n            and self.critical == other.critical\n            and self.value == other.value\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.critical, self.value))\n\n\nclass GeneralNames:\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        general_names = list(general_names)\n        if not all(isinstance(x, GeneralName) for x in general_names):\n            raise TypeError(\n                \"Every item in the general_names list must be an \"\n                \"object conforming to the GeneralName interface\"\n            )\n\n        self._general_names = general_names\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        # Return the value of each GeneralName, except for OtherName instances\n        # which we return directly because it has two important properties not\n        # just one value.\n        objs = (i for i in self if isinstance(i, type))\n        if type != OtherName:\n            return [i.value for i in objs]\n        return list(objs)\n\n    def __repr__(self) -> str:\n        return f\"<GeneralNames({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, GeneralNames):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._general_names))\n\n\nclass SubjectAlternativeName(ExtensionType):\n    oid = ExtensionOID.SUBJECT_ALTERNATIVE_NAME\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<SubjectAlternativeName({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SubjectAlternativeName):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass IssuerAlternativeName(ExtensionType):\n    oid = ExtensionOID.ISSUER_ALTERNATIVE_NAME\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<IssuerAlternativeName({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IssuerAlternativeName):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CertificateIssuer(ExtensionType):\n    oid = CRLEntryExtensionOID.CERTIFICATE_ISSUER\n\n    def __init__(self, general_names: typing.Iterable[GeneralName]) -> None:\n        self._general_names = GeneralNames(general_names)\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\"_general_names\")\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[UniformResourceIdentifier]\n        | type[RFC822Name],\n    ) -> list[str]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[DirectoryName],\n    ) -> list[Name]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self,\n        type: type[RegisteredID],\n    ) -> list[ObjectIdentifier]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[IPAddress]\n    ) -> list[_IPAddressTypes]: ...\n\n    @typing.overload\n    def get_values_for_type(\n        self, type: type[OtherName]\n    ) -> list[OtherName]: ...\n\n    def get_values_for_type(\n        self,\n        type: type[DNSName]\n        | type[DirectoryName]\n        | type[IPAddress]\n        | type[OtherName]\n        | type[RFC822Name]\n        | type[RegisteredID]\n        | type[UniformResourceIdentifier],\n    ) -> (\n        list[_IPAddressTypes]\n        | list[str]\n        | list[OtherName]\n        | list[Name]\n        | list[ObjectIdentifier]\n    ):\n        return self._general_names.get_values_for_type(type)\n\n    def __repr__(self) -> str:\n        return f\"<CertificateIssuer({self._general_names})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CertificateIssuer):\n            return NotImplemented\n\n        return self._general_names == other._general_names\n\n    def __hash__(self) -> int:\n        return hash(self._general_names)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass CRLReason(ExtensionType):\n    oid = CRLEntryExtensionOID.CRL_REASON\n\n    def __init__(self, reason: ReasonFlags) -> None:\n        if not isinstance(reason, ReasonFlags):\n            raise TypeError(\"reason must be an element from ReasonFlags\")\n\n        self._reason = reason\n\n    def __repr__(self) -> str:\n        return f\"<CRLReason(reason={self._reason})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CRLReason):\n            return NotImplemented\n\n        return self.reason == other.reason\n\n    def __hash__(self) -> int:\n        return hash(self.reason)\n\n    @property\n    def reason(self) -> ReasonFlags:\n        return self._reason\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass InvalidityDate(ExtensionType):\n    oid = CRLEntryExtensionOID.INVALIDITY_DATE\n\n    def __init__(self, invalidity_date: datetime.datetime) -> None:\n        if not isinstance(invalidity_date, datetime.datetime):\n            raise TypeError(\"invalidity_date must be a datetime.datetime\")\n\n        self._invalidity_date = invalidity_date\n\n    def __repr__(self) -> str:\n        return f\"<InvalidityDate(invalidity_date={self._invalidity_date})>\"\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, InvalidityDate):\n            return NotImplemented\n\n        return self.invalidity_date == other.invalidity_date\n\n    def __hash__(self) -> int:\n        return hash(self.invalidity_date)\n\n    @property\n    def invalidity_date(self) -> datetime.datetime:\n        return self._invalidity_date\n\n    @property\n    def invalidity_date_utc(self) -> datetime.datetime:\n        if self._invalidity_date.tzinfo is None:\n            return self._invalidity_date.replace(tzinfo=datetime.timezone.utc)\n        else:\n            return self._invalidity_date.astimezone(tz=datetime.timezone.utc)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass PrecertificateSignedCertificateTimestamps(ExtensionType):\n    oid = ExtensionOID.PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS\n\n    def __init__(\n        self,\n        signed_certificate_timestamps: typing.Iterable[\n            SignedCertificateTimestamp\n        ],\n    ) -> None:\n        signed_certificate_timestamps = list(signed_certificate_timestamps)\n        if not all(\n            isinstance(sct, SignedCertificateTimestamp)\n            for sct in signed_certificate_timestamps\n        ):\n            raise TypeError(\n                \"Every item in the signed_certificate_timestamps list must be \"\n                \"a SignedCertificateTimestamp\"\n            )\n        self._signed_certificate_timestamps = signed_certificate_timestamps\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_signed_certificate_timestamps\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<PrecertificateSignedCertificateTimestamps({list(self)})>\"\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._signed_certificate_timestamps))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PrecertificateSignedCertificateTimestamps):\n            return NotImplemented\n\n        return (\n            self._signed_certificate_timestamps\n            == other._signed_certificate_timestamps\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass SignedCertificateTimestamps(ExtensionType):\n    oid = ExtensionOID.SIGNED_CERTIFICATE_TIMESTAMPS\n\n    def __init__(\n        self,\n        signed_certificate_timestamps: typing.Iterable[\n            SignedCertificateTimestamp\n        ],\n    ) -> None:\n        signed_certificate_timestamps = list(signed_certificate_timestamps)\n        if not all(\n            isinstance(sct, SignedCertificateTimestamp)\n            for sct in signed_certificate_timestamps\n        ):\n            raise TypeError(\n                \"Every item in the signed_certificate_timestamps list must be \"\n                \"a SignedCertificateTimestamp\"\n            )\n        self._signed_certificate_timestamps = signed_certificate_timestamps\n\n    __len__, __iter__, __getitem__ = _make_sequence_methods(\n        \"_signed_certificate_timestamps\"\n    )\n\n    def __repr__(self) -> str:\n        return f\"<SignedCertificateTimestamps({list(self)})>\"\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._signed_certificate_timestamps))\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, SignedCertificateTimestamps):\n            return NotImplemented\n\n        return (\n            self._signed_certificate_timestamps\n            == other._signed_certificate_timestamps\n        )\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPNonce(ExtensionType):\n    oid = OCSPExtensionOID.NONCE\n\n    def __init__(self, nonce: bytes) -> None:\n        if not isinstance(nonce, bytes):\n            raise TypeError(\"nonce must be bytes\")\n\n        self._nonce = nonce\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPNonce):\n            return NotImplemented\n\n        return self.nonce == other.nonce\n\n    def __hash__(self) -> int:\n        return hash(self.nonce)\n\n    def __repr__(self) -> str:\n        return f\"<OCSPNonce(nonce={self.nonce!r})>\"\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass OCSPAcceptableResponses(ExtensionType):\n    oid = OCSPExtensionOID.ACCEPTABLE_RESPONSES\n\n    def __init__(self, responses: typing.Iterable[ObjectIdentifier]) -> None:\n        responses = list(responses)\n        if any(not isinstance(r, ObjectIdentifier) for r in responses):\n            raise TypeError(\"All responses must be ObjectIdentifiers\")\n\n        self._responses = responses\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, OCSPAcceptableResponses):\n            return NotImplemented\n\n        return self._responses == other._responses\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._responses))\n\n    def __repr__(self) -> str:\n        return f\"<OCSPAcceptableResponses(responses={self._responses})>\"\n\n    def __iter__(self) -> typing.Iterator[ObjectIdentifier]:\n        return iter(self._responses)\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass IssuingDistributionPoint(ExtensionType):\n    oid = ExtensionOID.ISSUING_DISTRIBUTION_POINT\n\n    def __init__(\n        self,\n        full_name: typing.Iterable[GeneralName] | None,\n        relative_name: RelativeDistinguishedName | None,\n        only_contains_user_certs: bool,\n        only_contains_ca_certs: bool,\n        only_some_reasons: frozenset[ReasonFlags] | None,\n        indirect_crl: bool,\n        only_contains_attribute_certs: bool,\n    ) -> None:\n        if full_name is not None:\n            full_name = list(full_name)\n\n        if only_some_reasons and (\n            not isinstance(only_some_reasons, frozenset)\n            or not all(isinstance(x, ReasonFlags) for x in only_some_reasons)\n        ):\n            raise TypeError(\n                \"only_some_reasons must be None or frozenset of ReasonFlags\"\n            )\n\n        if only_some_reasons and (\n            ReasonFlags.unspecified in only_some_reasons\n            or ReasonFlags.remove_from_crl in only_some_reasons\n        ):\n            raise ValueError(\n                \"unspecified and remove_from_crl are not valid reasons in an \"\n                \"IssuingDistributionPoint\"\n            )\n\n        if not (\n            isinstance(only_contains_user_certs, bool)\n            and isinstance(only_contains_ca_certs, bool)\n            and isinstance(indirect_crl, bool)\n            and isinstance(only_contains_attribute_certs, bool)\n        ):\n            raise TypeError(\n                \"only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl and only_contains_attribute_certs \"\n                \"must all be boolean.\"\n            )\n\n        crl_constraints = [\n            only_contains_user_certs,\n            only_contains_ca_certs,\n            indirect_crl,\n            only_contains_attribute_certs,\n        ]\n\n        if len([x for x in crl_constraints if x]) > 1:\n            raise ValueError(\n                \"Only one of the following can be set to True: \"\n                \"only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl, only_contains_attribute_certs\"\n            )\n\n        if not any(\n            [\n                only_contains_user_certs,\n                only_contains_ca_certs,\n                indirect_crl,\n                only_contains_attribute_certs,\n                full_name,\n                relative_name,\n                only_some_reasons,\n            ]\n        ):\n            raise ValueError(\n                \"Cannot create empty extension: \"\n                \"if only_contains_user_certs, only_contains_ca_certs, \"\n                \"indirect_crl, and only_contains_attribute_certs are all False\"\n                \", then either full_name, relative_name, or only_some_reasons \"\n                \"must have a value.\"\n            )\n\n        self._only_contains_user_certs = only_contains_user_certs\n        self._only_contains_ca_certs = only_contains_ca_certs\n        self._indirect_crl = indirect_crl\n        self._only_contains_attribute_certs = only_contains_attribute_certs\n        self._only_some_reasons = only_some_reasons\n        self._full_name = full_name\n        self._relative_name = relative_name\n\n    def __repr__(self) -> str:\n        return (\n            f\"<IssuingDistributionPoint(full_name={self.full_name}, \"\n            f\"relative_name={self.relative_name}, \"\n            f\"only_contains_user_certs={self.only_contains_user_certs}, \"\n            f\"only_contains_ca_certs={self.only_contains_ca_certs}, \"\n            f\"only_some_reasons={self.only_some_reasons}, \"\n            f\"indirect_crl={self.indirect_crl}, \"\n            \"only_contains_attribute_certs=\"\n            f\"{self.only_contains_attribute_certs})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, IssuingDistributionPoint):\n            return NotImplemented\n\n        return (\n            self.full_name == other.full_name\n            and self.relative_name == other.relative_name\n            and self.only_contains_user_certs == other.only_contains_user_certs\n            and self.only_contains_ca_certs == other.only_contains_ca_certs\n            and self.only_some_reasons == other.only_some_reasons\n            and self.indirect_crl == other.indirect_crl\n            and self.only_contains_attribute_certs\n            == other.only_contains_attribute_certs\n        )\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.full_name,\n                self.relative_name,\n                self.only_contains_user_certs,\n                self.only_contains_ca_certs,\n                self.only_some_reasons,\n                self.indirect_crl,\n                self.only_contains_attribute_certs,\n            )\n        )\n\n    @property\n    def full_name(self) -> list[GeneralName] | None:\n        return self._full_name\n\n    @property\n    def relative_name(self) -> RelativeDistinguishedName | None:\n        return self._relative_name\n\n    @property\n    def only_contains_user_certs(self) -> bool:\n        return self._only_contains_user_certs\n\n    @property\n    def only_contains_ca_certs(self) -> bool:\n        return self._only_contains_ca_certs\n\n    @property\n    def only_some_reasons(\n        self,\n    ) -> frozenset[ReasonFlags] | None:\n        return self._only_some_reasons\n\n    @property\n    def indirect_crl(self) -> bool:\n        return self._indirect_crl\n\n    @property\n    def only_contains_attribute_certs(self) -> bool:\n        return self._only_contains_attribute_certs\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass MSCertificateTemplate(ExtensionType):\n    oid = ExtensionOID.MS_CERTIFICATE_TEMPLATE\n\n    def __init__(\n        self,\n        template_id: ObjectIdentifier,\n        major_version: int | None,\n        minor_version: int | None,\n    ) -> None:\n        if not isinstance(template_id, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n        self._template_id = template_id\n        if (\n            major_version is not None and not isinstance(major_version, int)\n        ) or (\n            minor_version is not None and not isinstance(minor_version, int)\n        ):\n            raise TypeError(\n                \"major_version and minor_version must be integers or None\"\n            )\n        self._major_version = major_version\n        self._minor_version = minor_version\n\n    @property\n    def template_id(self) -> ObjectIdentifier:\n        return self._template_id\n\n    @property\n    def major_version(self) -> int | None:\n        return self._major_version\n\n    @property\n    def minor_version(self) -> int | None:\n        return self._minor_version\n\n    def __repr__(self) -> str:\n        return (\n            f\"<MSCertificateTemplate(template_id={self.template_id}, \"\n            f\"major_version={self.major_version}, \"\n            f\"minor_version={self.minor_version})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, MSCertificateTemplate):\n            return NotImplemented\n\n        return (\n            self.template_id == other.template_id\n            and self.major_version == other.major_version\n            and self.minor_version == other.minor_version\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.template_id, self.major_version, self.minor_version))\n\n    def public_bytes(self) -> bytes:\n        return rust_x509.encode_extension_value(self)\n\n\nclass UnrecognizedExtension(ExtensionType):\n    def __init__(self, oid: ObjectIdentifier, value: bytes) -> None:\n        if not isinstance(oid, ObjectIdentifier):\n            raise TypeError(\"oid must be an ObjectIdentifier\")\n        self._oid = oid\n        self._value = value\n\n    @property\n    def oid(self) -> ObjectIdentifier:  # type: ignore[override]\n        return self._oid\n\n    @property\n    def value(self) -> bytes:\n        return self._value\n\n    def __repr__(self) -> str:\n        return (\n            f\"<UnrecognizedExtension(oid={self.oid}, \"\n            f\"value={self.value!r})>\"\n        )\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, UnrecognizedExtension):\n            return NotImplemented\n\n        return self.oid == other.oid and self.value == other.value\n\n    def __hash__(self) -> int:\n        return hash((self.oid, self.value))\n\n    def public_bytes(self) -> bytes:\n        return self.value\n", "src/cryptography/x509/ocsp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport datetime\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.hazmat.bindings._rust import ocsp\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric.types import (\n    CertificateIssuerPrivateKeyTypes,\n)\nfrom cryptography.x509.base import (\n    _EARLIEST_UTC_TIME,\n    _convert_to_naive_utc_time,\n    _reject_duplicate_extension,\n)\n\n\nclass OCSPResponderEncoding(utils.Enum):\n    HASH = \"By Hash\"\n    NAME = \"By Name\"\n\n\nclass OCSPResponseStatus(utils.Enum):\n    SUCCESSFUL = 0\n    MALFORMED_REQUEST = 1\n    INTERNAL_ERROR = 2\n    TRY_LATER = 3\n    SIG_REQUIRED = 5\n    UNAUTHORIZED = 6\n\n\n_ALLOWED_HASHES = (\n    hashes.SHA1,\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n)\n\n\ndef _verify_algorithm(algorithm: hashes.HashAlgorithm) -> None:\n    if not isinstance(algorithm, _ALLOWED_HASHES):\n        raise ValueError(\n            \"Algorithm must be SHA1, SHA224, SHA256, SHA384, or SHA512\"\n        )\n\n\nclass OCSPCertStatus(utils.Enum):\n    GOOD = 0\n    REVOKED = 1\n    UNKNOWN = 2\n\n\nclass _SingleResponse:\n    def __init__(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n        cert_status: OCSPCertStatus,\n        this_update: datetime.datetime,\n        next_update: datetime.datetime | None,\n        revocation_time: datetime.datetime | None,\n        revocation_reason: x509.ReasonFlags | None,\n    ):\n        if not isinstance(cert, x509.Certificate) or not isinstance(\n            issuer, x509.Certificate\n        ):\n            raise TypeError(\"cert and issuer must be a Certificate\")\n\n        _verify_algorithm(algorithm)\n        if not isinstance(this_update, datetime.datetime):\n            raise TypeError(\"this_update must be a datetime object\")\n        if next_update is not None and not isinstance(\n            next_update, datetime.datetime\n        ):\n            raise TypeError(\"next_update must be a datetime object or None\")\n\n        self._cert = cert\n        self._issuer = issuer\n        self._algorithm = algorithm\n        self._this_update = this_update\n        self._next_update = next_update\n\n        if not isinstance(cert_status, OCSPCertStatus):\n            raise TypeError(\n                \"cert_status must be an item from the OCSPCertStatus enum\"\n            )\n        if cert_status is not OCSPCertStatus.REVOKED:\n            if revocation_time is not None:\n                raise ValueError(\n                    \"revocation_time can only be provided if the certificate \"\n                    \"is revoked\"\n                )\n            if revocation_reason is not None:\n                raise ValueError(\n                    \"revocation_reason can only be provided if the certificate\"\n                    \" is revoked\"\n                )\n        else:\n            if not isinstance(revocation_time, datetime.datetime):\n                raise TypeError(\"revocation_time must be a datetime object\")\n\n            revocation_time = _convert_to_naive_utc_time(revocation_time)\n            if revocation_time < _EARLIEST_UTC_TIME:\n                raise ValueError(\n                    \"The revocation_time must be on or after\"\n                    \" 1950 January 1.\"\n                )\n\n            if revocation_reason is not None and not isinstance(\n                revocation_reason, x509.ReasonFlags\n            ):\n                raise TypeError(\n                    \"revocation_reason must be an item from the ReasonFlags \"\n                    \"enum or None\"\n                )\n\n        self._cert_status = cert_status\n        self._revocation_time = revocation_time\n        self._revocation_reason = revocation_reason\n\n\nclass OCSPRequest(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the request to DER\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of request extensions. Not single request extensions.\n        \"\"\"\n\n\nclass OCSPSingleResponse(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def certificate_status(self) -> OCSPCertStatus:\n        \"\"\"\n        The status of the certificate (an element from the OCSPCertStatus enum)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_time(self) -> datetime.datetime | None:\n        \"\"\"\n        The date of when the certificate was revoked or None if not\n        revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_reason(self) -> x509.ReasonFlags | None:\n        \"\"\"\n        The reason the certificate was revoked or None if not specified or\n        not revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def this_update(self) -> datetime.datetime:\n        \"\"\"\n        The most recent time at which the status being indicated is known by\n        the responder to have been correct\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        The time when newer information will be available\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n\nclass OCSPResponse(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def responses(self) -> typing.Iterator[OCSPSingleResponse]:\n        \"\"\"\n        An iterator over the individual SINGLERESP structures in the\n        response\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def response_status(self) -> OCSPResponseStatus:\n        \"\"\"\n        The status of the response. This is a value from the OCSPResponseStatus\n        enumeration\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_algorithm_oid(self) -> x509.ObjectIdentifier:\n        \"\"\"\n        The ObjectIdentifier of the signature algorithm\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature_hash_algorithm(\n        self,\n    ) -> hashes.HashAlgorithm | None:\n        \"\"\"\n        Returns a HashAlgorithm corresponding to the type of the digest signed\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def signature(self) -> bytes:\n        \"\"\"\n        The signature bytes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def tbs_response_bytes(self) -> bytes:\n        \"\"\"\n        The tbsResponseData bytes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def certificates(self) -> list[x509.Certificate]:\n        \"\"\"\n        A list of certificates used to help build a chain to verify the OCSP\n        response. This situation occurs when the OCSP responder uses a delegate\n        certificate.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def responder_key_hash(self) -> bytes | None:\n        \"\"\"\n        The responder's key hash or None\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def responder_name(self) -> x509.Name | None:\n        \"\"\"\n        The responder's Name or None\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def produced_at(self) -> datetime.datetime:\n        \"\"\"\n        The time the response was produced\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def certificate_status(self) -> OCSPCertStatus:\n        \"\"\"\n        The status of the certificate (an element from the OCSPCertStatus enum)\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_time(self) -> datetime.datetime | None:\n        \"\"\"\n        The date of when the certificate was revoked or None if not\n        revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def revocation_reason(self) -> x509.ReasonFlags | None:\n        \"\"\"\n        The reason the certificate was revoked or None if not specified or\n        not revoked.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def this_update(self) -> datetime.datetime:\n        \"\"\"\n        The most recent time at which the status being indicated is known by\n        the responder to have been correct\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def next_update(self) -> datetime.datetime | None:\n        \"\"\"\n        The time when newer information will be available\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_key_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer public key\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def issuer_name_hash(self) -> bytes:\n        \"\"\"\n        The hash of the issuer name\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def hash_algorithm(self) -> hashes.HashAlgorithm:\n        \"\"\"\n        The hash algorithm used in the issuer name and key hashes\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def serial_number(self) -> int:\n        \"\"\"\n        The serial number of the cert whose status is being checked\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of response extensions. Not single response extensions.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def single_extensions(self) -> x509.Extensions:\n        \"\"\"\n        The list of single response extensions. Not response extensions.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(self, encoding: serialization.Encoding) -> bytes:\n        \"\"\"\n        Serializes the response to DER\n        \"\"\"\n\n\nOCSPRequest.register(ocsp.OCSPRequest)\nOCSPResponse.register(ocsp.OCSPResponse)\nOCSPSingleResponse.register(ocsp.OCSPSingleResponse)\n\n\nclass OCSPRequestBuilder:\n    def __init__(\n        self,\n        request: tuple[\n            x509.Certificate, x509.Certificate, hashes.HashAlgorithm\n        ]\n        | None = None,\n        request_hash: tuple[bytes, bytes, int, hashes.HashAlgorithm]\n        | None = None,\n        extensions: list[x509.Extension[x509.ExtensionType]] = [],\n    ) -> None:\n        self._request = request\n        self._request_hash = request_hash\n        self._extensions = extensions\n\n    def add_certificate(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n    ) -> OCSPRequestBuilder:\n        if self._request is not None or self._request_hash is not None:\n            raise ValueError(\"Only one certificate can be added to a request\")\n\n        _verify_algorithm(algorithm)\n        if not isinstance(cert, x509.Certificate) or not isinstance(\n            issuer, x509.Certificate\n        ):\n            raise TypeError(\"cert and issuer must be a Certificate\")\n\n        return OCSPRequestBuilder(\n            (cert, issuer, algorithm), self._request_hash, self._extensions\n        )\n\n    def add_certificate_by_hash(\n        self,\n        issuer_name_hash: bytes,\n        issuer_key_hash: bytes,\n        serial_number: int,\n        algorithm: hashes.HashAlgorithm,\n    ) -> OCSPRequestBuilder:\n        if self._request is not None or self._request_hash is not None:\n            raise ValueError(\"Only one certificate can be added to a request\")\n\n        if not isinstance(serial_number, int):\n            raise TypeError(\"serial_number must be an integer\")\n\n        _verify_algorithm(algorithm)\n        utils._check_bytes(\"issuer_name_hash\", issuer_name_hash)\n        utils._check_bytes(\"issuer_key_hash\", issuer_key_hash)\n        if algorithm.digest_size != len(\n            issuer_name_hash\n        ) or algorithm.digest_size != len(issuer_key_hash):\n            raise ValueError(\n                \"issuer_name_hash and issuer_key_hash must be the same length \"\n                \"as the digest size of the algorithm\"\n            )\n\n        return OCSPRequestBuilder(\n            self._request,\n            (issuer_name_hash, issuer_key_hash, serial_number, algorithm),\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: x509.ExtensionType, critical: bool\n    ) -> OCSPRequestBuilder:\n        if not isinstance(extval, x509.ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = x509.Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return OCSPRequestBuilder(\n            self._request, self._request_hash, [*self._extensions, extension]\n        )\n\n    def build(self) -> OCSPRequest:\n        if self._request is None and self._request_hash is None:\n            raise ValueError(\"You must add a certificate before building\")\n\n        return ocsp.create_ocsp_request(self)\n\n\nclass OCSPResponseBuilder:\n    def __init__(\n        self,\n        response: _SingleResponse | None = None,\n        responder_id: tuple[x509.Certificate, OCSPResponderEncoding]\n        | None = None,\n        certs: list[x509.Certificate] | None = None,\n        extensions: list[x509.Extension[x509.ExtensionType]] = [],\n    ):\n        self._response = response\n        self._responder_id = responder_id\n        self._certs = certs\n        self._extensions = extensions\n\n    def add_response(\n        self,\n        cert: x509.Certificate,\n        issuer: x509.Certificate,\n        algorithm: hashes.HashAlgorithm,\n        cert_status: OCSPCertStatus,\n        this_update: datetime.datetime,\n        next_update: datetime.datetime | None,\n        revocation_time: datetime.datetime | None,\n        revocation_reason: x509.ReasonFlags | None,\n    ) -> OCSPResponseBuilder:\n        if self._response is not None:\n            raise ValueError(\"Only one response per OCSPResponse.\")\n\n        singleresp = _SingleResponse(\n            cert,\n            issuer,\n            algorithm,\n            cert_status,\n            this_update,\n            next_update,\n            revocation_time,\n            revocation_reason,\n        )\n        return OCSPResponseBuilder(\n            singleresp,\n            self._responder_id,\n            self._certs,\n            self._extensions,\n        )\n\n    def responder_id(\n        self, encoding: OCSPResponderEncoding, responder_cert: x509.Certificate\n    ) -> OCSPResponseBuilder:\n        if self._responder_id is not None:\n            raise ValueError(\"responder_id can only be set once\")\n        if not isinstance(responder_cert, x509.Certificate):\n            raise TypeError(\"responder_cert must be a Certificate\")\n        if not isinstance(encoding, OCSPResponderEncoding):\n            raise TypeError(\n                \"encoding must be an element from OCSPResponderEncoding\"\n            )\n\n        return OCSPResponseBuilder(\n            self._response,\n            (responder_cert, encoding),\n            self._certs,\n            self._extensions,\n        )\n\n    def certificates(\n        self, certs: typing.Iterable[x509.Certificate]\n    ) -> OCSPResponseBuilder:\n        if self._certs is not None:\n            raise ValueError(\"certificates may only be set once\")\n        certs = list(certs)\n        if len(certs) == 0:\n            raise ValueError(\"certs must not be an empty list\")\n        if not all(isinstance(x, x509.Certificate) for x in certs):\n            raise TypeError(\"certs must be a list of Certificates\")\n        return OCSPResponseBuilder(\n            self._response,\n            self._responder_id,\n            certs,\n            self._extensions,\n        )\n\n    def add_extension(\n        self, extval: x509.ExtensionType, critical: bool\n    ) -> OCSPResponseBuilder:\n        if not isinstance(extval, x509.ExtensionType):\n            raise TypeError(\"extension must be an ExtensionType\")\n\n        extension = x509.Extension(extval.oid, critical, extval)\n        _reject_duplicate_extension(extension, self._extensions)\n\n        return OCSPResponseBuilder(\n            self._response,\n            self._responder_id,\n            self._certs,\n            [*self._extensions, extension],\n        )\n\n    def sign(\n        self,\n        private_key: CertificateIssuerPrivateKeyTypes,\n        algorithm: hashes.HashAlgorithm | None,\n    ) -> OCSPResponse:\n        if self._response is None:\n            raise ValueError(\"You must add a response before signing\")\n        if self._responder_id is None:\n            raise ValueError(\"You must add a responder_id before signing\")\n\n        return ocsp.create_ocsp_response(\n            OCSPResponseStatus.SUCCESSFUL, self, private_key, algorithm\n        )\n\n    @classmethod\n    def build_unsuccessful(\n        cls, response_status: OCSPResponseStatus\n    ) -> OCSPResponse:\n        if not isinstance(response_status, OCSPResponseStatus):\n            raise TypeError(\n                \"response_status must be an item from OCSPResponseStatus\"\n            )\n        if response_status is OCSPResponseStatus.SUCCESSFUL:\n            raise ValueError(\"response_status cannot be SUCCESSFUL\")\n\n        return ocsp.create_ocsp_response(response_status, None, None, None)\n\n\nload_der_ocsp_request = ocsp.load_der_ocsp_request\nload_der_ocsp_response = ocsp.load_der_ocsp_response\n", "src/cryptography/x509/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.x509 import certificate_transparency, verification\nfrom cryptography.x509.base import (\n    Attribute,\n    AttributeNotFound,\n    Attributes,\n    Certificate,\n    CertificateBuilder,\n    CertificateRevocationList,\n    CertificateRevocationListBuilder,\n    CertificateSigningRequest,\n    CertificateSigningRequestBuilder,\n    InvalidVersion,\n    RevokedCertificate,\n    RevokedCertificateBuilder,\n    Version,\n    load_der_x509_certificate,\n    load_der_x509_crl,\n    load_der_x509_csr,\n    load_pem_x509_certificate,\n    load_pem_x509_certificates,\n    load_pem_x509_crl,\n    load_pem_x509_csr,\n    random_serial_number,\n)\nfrom cryptography.x509.extensions import (\n    AccessDescription,\n    AuthorityInformationAccess,\n    AuthorityKeyIdentifier,\n    BasicConstraints,\n    CertificateIssuer,\n    CertificatePolicies,\n    CRLDistributionPoints,\n    CRLNumber,\n    CRLReason,\n    DeltaCRLIndicator,\n    DistributionPoint,\n    DuplicateExtension,\n    ExtendedKeyUsage,\n    Extension,\n    ExtensionNotFound,\n    Extensions,\n    ExtensionType,\n    FreshestCRL,\n    GeneralNames,\n    InhibitAnyPolicy,\n    InvalidityDate,\n    IssuerAlternativeName,\n    IssuingDistributionPoint,\n    KeyUsage,\n    MSCertificateTemplate,\n    NameConstraints,\n    NoticeReference,\n    OCSPAcceptableResponses,\n    OCSPNoCheck,\n    OCSPNonce,\n    PolicyConstraints,\n    PolicyInformation,\n    PrecertificateSignedCertificateTimestamps,\n    PrecertPoison,\n    ReasonFlags,\n    SignedCertificateTimestamps,\n    SubjectAlternativeName,\n    SubjectInformationAccess,\n    SubjectKeyIdentifier,\n    TLSFeature,\n    TLSFeatureType,\n    UnrecognizedExtension,\n    UserNotice,\n)\nfrom cryptography.x509.general_name import (\n    DirectoryName,\n    DNSName,\n    GeneralName,\n    IPAddress,\n    OtherName,\n    RegisteredID,\n    RFC822Name,\n    UniformResourceIdentifier,\n    UnsupportedGeneralNameType,\n)\nfrom cryptography.x509.name import (\n    Name,\n    NameAttribute,\n    RelativeDistinguishedName,\n)\nfrom cryptography.x509.oid import (\n    AuthorityInformationAccessOID,\n    CertificatePoliciesOID,\n    CRLEntryExtensionOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    ObjectIdentifier,\n    PublicKeyAlgorithmOID,\n    SignatureAlgorithmOID,\n)\n\nOID_AUTHORITY_INFORMATION_ACCESS = ExtensionOID.AUTHORITY_INFORMATION_ACCESS\nOID_AUTHORITY_KEY_IDENTIFIER = ExtensionOID.AUTHORITY_KEY_IDENTIFIER\nOID_BASIC_CONSTRAINTS = ExtensionOID.BASIC_CONSTRAINTS\nOID_CERTIFICATE_POLICIES = ExtensionOID.CERTIFICATE_POLICIES\nOID_CRL_DISTRIBUTION_POINTS = ExtensionOID.CRL_DISTRIBUTION_POINTS\nOID_EXTENDED_KEY_USAGE = ExtensionOID.EXTENDED_KEY_USAGE\nOID_FRESHEST_CRL = ExtensionOID.FRESHEST_CRL\nOID_INHIBIT_ANY_POLICY = ExtensionOID.INHIBIT_ANY_POLICY\nOID_ISSUER_ALTERNATIVE_NAME = ExtensionOID.ISSUER_ALTERNATIVE_NAME\nOID_KEY_USAGE = ExtensionOID.KEY_USAGE\nOID_NAME_CONSTRAINTS = ExtensionOID.NAME_CONSTRAINTS\nOID_OCSP_NO_CHECK = ExtensionOID.OCSP_NO_CHECK\nOID_POLICY_CONSTRAINTS = ExtensionOID.POLICY_CONSTRAINTS\nOID_POLICY_MAPPINGS = ExtensionOID.POLICY_MAPPINGS\nOID_SUBJECT_ALTERNATIVE_NAME = ExtensionOID.SUBJECT_ALTERNATIVE_NAME\nOID_SUBJECT_DIRECTORY_ATTRIBUTES = ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES\nOID_SUBJECT_INFORMATION_ACCESS = ExtensionOID.SUBJECT_INFORMATION_ACCESS\nOID_SUBJECT_KEY_IDENTIFIER = ExtensionOID.SUBJECT_KEY_IDENTIFIER\n\nOID_DSA_WITH_SHA1 = SignatureAlgorithmOID.DSA_WITH_SHA1\nOID_DSA_WITH_SHA224 = SignatureAlgorithmOID.DSA_WITH_SHA224\nOID_DSA_WITH_SHA256 = SignatureAlgorithmOID.DSA_WITH_SHA256\nOID_ECDSA_WITH_SHA1 = SignatureAlgorithmOID.ECDSA_WITH_SHA1\nOID_ECDSA_WITH_SHA224 = SignatureAlgorithmOID.ECDSA_WITH_SHA224\nOID_ECDSA_WITH_SHA256 = SignatureAlgorithmOID.ECDSA_WITH_SHA256\nOID_ECDSA_WITH_SHA384 = SignatureAlgorithmOID.ECDSA_WITH_SHA384\nOID_ECDSA_WITH_SHA512 = SignatureAlgorithmOID.ECDSA_WITH_SHA512\nOID_RSA_WITH_MD5 = SignatureAlgorithmOID.RSA_WITH_MD5\nOID_RSA_WITH_SHA1 = SignatureAlgorithmOID.RSA_WITH_SHA1\nOID_RSA_WITH_SHA224 = SignatureAlgorithmOID.RSA_WITH_SHA224\nOID_RSA_WITH_SHA256 = SignatureAlgorithmOID.RSA_WITH_SHA256\nOID_RSA_WITH_SHA384 = SignatureAlgorithmOID.RSA_WITH_SHA384\nOID_RSA_WITH_SHA512 = SignatureAlgorithmOID.RSA_WITH_SHA512\nOID_RSASSA_PSS = SignatureAlgorithmOID.RSASSA_PSS\n\nOID_COMMON_NAME = NameOID.COMMON_NAME\nOID_COUNTRY_NAME = NameOID.COUNTRY_NAME\nOID_DOMAIN_COMPONENT = NameOID.DOMAIN_COMPONENT\nOID_DN_QUALIFIER = NameOID.DN_QUALIFIER\nOID_EMAIL_ADDRESS = NameOID.EMAIL_ADDRESS\nOID_GENERATION_QUALIFIER = NameOID.GENERATION_QUALIFIER\nOID_GIVEN_NAME = NameOID.GIVEN_NAME\nOID_LOCALITY_NAME = NameOID.LOCALITY_NAME\nOID_ORGANIZATIONAL_UNIT_NAME = NameOID.ORGANIZATIONAL_UNIT_NAME\nOID_ORGANIZATION_NAME = NameOID.ORGANIZATION_NAME\nOID_PSEUDONYM = NameOID.PSEUDONYM\nOID_SERIAL_NUMBER = NameOID.SERIAL_NUMBER\nOID_STATE_OR_PROVINCE_NAME = NameOID.STATE_OR_PROVINCE_NAME\nOID_SURNAME = NameOID.SURNAME\nOID_TITLE = NameOID.TITLE\n\nOID_CLIENT_AUTH = ExtendedKeyUsageOID.CLIENT_AUTH\nOID_CODE_SIGNING = ExtendedKeyUsageOID.CODE_SIGNING\nOID_EMAIL_PROTECTION = ExtendedKeyUsageOID.EMAIL_PROTECTION\nOID_OCSP_SIGNING = ExtendedKeyUsageOID.OCSP_SIGNING\nOID_SERVER_AUTH = ExtendedKeyUsageOID.SERVER_AUTH\nOID_TIME_STAMPING = ExtendedKeyUsageOID.TIME_STAMPING\n\nOID_ANY_POLICY = CertificatePoliciesOID.ANY_POLICY\nOID_CPS_QUALIFIER = CertificatePoliciesOID.CPS_QUALIFIER\nOID_CPS_USER_NOTICE = CertificatePoliciesOID.CPS_USER_NOTICE\n\nOID_CERTIFICATE_ISSUER = CRLEntryExtensionOID.CERTIFICATE_ISSUER\nOID_CRL_REASON = CRLEntryExtensionOID.CRL_REASON\nOID_INVALIDITY_DATE = CRLEntryExtensionOID.INVALIDITY_DATE\n\nOID_CA_ISSUERS = AuthorityInformationAccessOID.CA_ISSUERS\nOID_OCSP = AuthorityInformationAccessOID.OCSP\n\n__all__ = [\n    \"OID_CA_ISSUERS\",\n    \"OID_OCSP\",\n    \"AccessDescription\",\n    \"Attribute\",\n    \"AttributeNotFound\",\n    \"Attributes\",\n    \"AuthorityInformationAccess\",\n    \"AuthorityKeyIdentifier\",\n    \"BasicConstraints\",\n    \"CRLDistributionPoints\",\n    \"CRLNumber\",\n    \"CRLReason\",\n    \"Certificate\",\n    \"CertificateBuilder\",\n    \"CertificateIssuer\",\n    \"CertificatePolicies\",\n    \"CertificateRevocationList\",\n    \"CertificateRevocationListBuilder\",\n    \"CertificateSigningRequest\",\n    \"CertificateSigningRequestBuilder\",\n    \"DNSName\",\n    \"DeltaCRLIndicator\",\n    \"DirectoryName\",\n    \"DistributionPoint\",\n    \"DuplicateExtension\",\n    \"ExtendedKeyUsage\",\n    \"Extension\",\n    \"ExtensionNotFound\",\n    \"ExtensionType\",\n    \"Extensions\",\n    \"FreshestCRL\",\n    \"GeneralName\",\n    \"GeneralNames\",\n    \"IPAddress\",\n    \"InhibitAnyPolicy\",\n    \"InvalidVersion\",\n    \"InvalidityDate\",\n    \"IssuerAlternativeName\",\n    \"IssuingDistributionPoint\",\n    \"KeyUsage\",\n    \"MSCertificateTemplate\",\n    \"Name\",\n    \"NameAttribute\",\n    \"NameConstraints\",\n    \"NameOID\",\n    \"NoticeReference\",\n    \"OCSPAcceptableResponses\",\n    \"OCSPNoCheck\",\n    \"OCSPNonce\",\n    \"ObjectIdentifier\",\n    \"OtherName\",\n    \"PolicyConstraints\",\n    \"PolicyInformation\",\n    \"PrecertPoison\",\n    \"PrecertificateSignedCertificateTimestamps\",\n    \"PublicKeyAlgorithmOID\",\n    \"RFC822Name\",\n    \"ReasonFlags\",\n    \"RegisteredID\",\n    \"RelativeDistinguishedName\",\n    \"RevokedCertificate\",\n    \"RevokedCertificateBuilder\",\n    \"SignatureAlgorithmOID\",\n    \"SignedCertificateTimestamps\",\n    \"SubjectAlternativeName\",\n    \"SubjectInformationAccess\",\n    \"SubjectKeyIdentifier\",\n    \"TLSFeature\",\n    \"TLSFeatureType\",\n    \"UniformResourceIdentifier\",\n    \"UnrecognizedExtension\",\n    \"UnsupportedGeneralNameType\",\n    \"UserNotice\",\n    \"Version\",\n    \"certificate_transparency\",\n    \"load_der_x509_certificate\",\n    \"load_der_x509_crl\",\n    \"load_der_x509_csr\",\n    \"load_pem_x509_certificate\",\n    \"load_pem_x509_certificates\",\n    \"load_pem_x509_crl\",\n    \"load_pem_x509_csr\",\n    \"random_serial_number\",\n    \"verification\",\n    \"verification\",\n]\n", "src/cryptography/x509/oid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat._oid import (\n    AttributeOID,\n    AuthorityInformationAccessOID,\n    CertificatePoliciesOID,\n    CRLEntryExtensionOID,\n    ExtendedKeyUsageOID,\n    ExtensionOID,\n    NameOID,\n    ObjectIdentifier,\n    OCSPExtensionOID,\n    PublicKeyAlgorithmOID,\n    SignatureAlgorithmOID,\n    SubjectInformationAccessOID,\n)\n\n__all__ = [\n    \"AttributeOID\",\n    \"AuthorityInformationAccessOID\",\n    \"CRLEntryExtensionOID\",\n    \"CertificatePoliciesOID\",\n    \"ExtendedKeyUsageOID\",\n    \"ExtensionOID\",\n    \"NameOID\",\n    \"OCSPExtensionOID\",\n    \"ObjectIdentifier\",\n    \"PublicKeyAlgorithmOID\",\n    \"SignatureAlgorithmOID\",\n    \"SubjectInformationAccessOID\",\n]\n", "src/cryptography/hazmat/_oid.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import (\n    ObjectIdentifier as ObjectIdentifier,\n)\nfrom cryptography.hazmat.primitives import hashes\n\n\nclass ExtensionOID:\n    SUBJECT_DIRECTORY_ATTRIBUTES = ObjectIdentifier(\"2.5.29.9\")\n    SUBJECT_KEY_IDENTIFIER = ObjectIdentifier(\"2.5.29.14\")\n    KEY_USAGE = ObjectIdentifier(\"2.5.29.15\")\n    SUBJECT_ALTERNATIVE_NAME = ObjectIdentifier(\"2.5.29.17\")\n    ISSUER_ALTERNATIVE_NAME = ObjectIdentifier(\"2.5.29.18\")\n    BASIC_CONSTRAINTS = ObjectIdentifier(\"2.5.29.19\")\n    NAME_CONSTRAINTS = ObjectIdentifier(\"2.5.29.30\")\n    CRL_DISTRIBUTION_POINTS = ObjectIdentifier(\"2.5.29.31\")\n    CERTIFICATE_POLICIES = ObjectIdentifier(\"2.5.29.32\")\n    POLICY_MAPPINGS = ObjectIdentifier(\"2.5.29.33\")\n    AUTHORITY_KEY_IDENTIFIER = ObjectIdentifier(\"2.5.29.35\")\n    POLICY_CONSTRAINTS = ObjectIdentifier(\"2.5.29.36\")\n    EXTENDED_KEY_USAGE = ObjectIdentifier(\"2.5.29.37\")\n    FRESHEST_CRL = ObjectIdentifier(\"2.5.29.46\")\n    INHIBIT_ANY_POLICY = ObjectIdentifier(\"2.5.29.54\")\n    ISSUING_DISTRIBUTION_POINT = ObjectIdentifier(\"2.5.29.28\")\n    AUTHORITY_INFORMATION_ACCESS = ObjectIdentifier(\"1.3.6.1.5.5.7.1.1\")\n    SUBJECT_INFORMATION_ACCESS = ObjectIdentifier(\"1.3.6.1.5.5.7.1.11\")\n    OCSP_NO_CHECK = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.5\")\n    TLS_FEATURE = ObjectIdentifier(\"1.3.6.1.5.5.7.1.24\")\n    CRL_NUMBER = ObjectIdentifier(\"2.5.29.20\")\n    DELTA_CRL_INDICATOR = ObjectIdentifier(\"2.5.29.27\")\n    PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS = ObjectIdentifier(\n        \"1.3.6.1.4.1.11129.2.4.2\"\n    )\n    PRECERT_POISON = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.3\")\n    SIGNED_CERTIFICATE_TIMESTAMPS = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.5\")\n    MS_CERTIFICATE_TEMPLATE = ObjectIdentifier(\"1.3.6.1.4.1.311.21.7\")\n\n\nclass OCSPExtensionOID:\n    NONCE = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.2\")\n    ACCEPTABLE_RESPONSES = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1.4\")\n\n\nclass CRLEntryExtensionOID:\n    CERTIFICATE_ISSUER = ObjectIdentifier(\"2.5.29.29\")\n    CRL_REASON = ObjectIdentifier(\"2.5.29.21\")\n    INVALIDITY_DATE = ObjectIdentifier(\"2.5.29.24\")\n\n\nclass NameOID:\n    COMMON_NAME = ObjectIdentifier(\"2.5.4.3\")\n    COUNTRY_NAME = ObjectIdentifier(\"2.5.4.6\")\n    LOCALITY_NAME = ObjectIdentifier(\"2.5.4.7\")\n    STATE_OR_PROVINCE_NAME = ObjectIdentifier(\"2.5.4.8\")\n    STREET_ADDRESS = ObjectIdentifier(\"2.5.4.9\")\n    ORGANIZATION_IDENTIFIER = ObjectIdentifier(\"2.5.4.97\")\n    ORGANIZATION_NAME = ObjectIdentifier(\"2.5.4.10\")\n    ORGANIZATIONAL_UNIT_NAME = ObjectIdentifier(\"2.5.4.11\")\n    SERIAL_NUMBER = ObjectIdentifier(\"2.5.4.5\")\n    SURNAME = ObjectIdentifier(\"2.5.4.4\")\n    GIVEN_NAME = ObjectIdentifier(\"2.5.4.42\")\n    TITLE = ObjectIdentifier(\"2.5.4.12\")\n    INITIALS = ObjectIdentifier(\"2.5.4.43\")\n    GENERATION_QUALIFIER = ObjectIdentifier(\"2.5.4.44\")\n    X500_UNIQUE_IDENTIFIER = ObjectIdentifier(\"2.5.4.45\")\n    DN_QUALIFIER = ObjectIdentifier(\"2.5.4.46\")\n    PSEUDONYM = ObjectIdentifier(\"2.5.4.65\")\n    USER_ID = ObjectIdentifier(\"0.9.2342.19200300.100.1.1\")\n    DOMAIN_COMPONENT = ObjectIdentifier(\"0.9.2342.19200300.100.1.25\")\n    EMAIL_ADDRESS = ObjectIdentifier(\"1.2.840.113549.1.9.1\")\n    JURISDICTION_COUNTRY_NAME = ObjectIdentifier(\"1.3.6.1.4.1.311.60.2.1.3\")\n    JURISDICTION_LOCALITY_NAME = ObjectIdentifier(\"1.3.6.1.4.1.311.60.2.1.1\")\n    JURISDICTION_STATE_OR_PROVINCE_NAME = ObjectIdentifier(\n        \"1.3.6.1.4.1.311.60.2.1.2\"\n    )\n    BUSINESS_CATEGORY = ObjectIdentifier(\"2.5.4.15\")\n    POSTAL_ADDRESS = ObjectIdentifier(\"2.5.4.16\")\n    POSTAL_CODE = ObjectIdentifier(\"2.5.4.17\")\n    INN = ObjectIdentifier(\"1.2.643.3.131.1.1\")\n    OGRN = ObjectIdentifier(\"1.2.643.100.1\")\n    SNILS = ObjectIdentifier(\"1.2.643.100.3\")\n    UNSTRUCTURED_NAME = ObjectIdentifier(\"1.2.840.113549.1.9.2\")\n\n\nclass SignatureAlgorithmOID:\n    RSA_WITH_MD5 = ObjectIdentifier(\"1.2.840.113549.1.1.4\")\n    RSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.113549.1.1.5\")\n    # This is an alternate OID for RSA with SHA1 that is occasionally seen\n    _RSA_WITH_SHA1 = ObjectIdentifier(\"1.3.14.3.2.29\")\n    RSA_WITH_SHA224 = ObjectIdentifier(\"1.2.840.113549.1.1.14\")\n    RSA_WITH_SHA256 = ObjectIdentifier(\"1.2.840.113549.1.1.11\")\n    RSA_WITH_SHA384 = ObjectIdentifier(\"1.2.840.113549.1.1.12\")\n    RSA_WITH_SHA512 = ObjectIdentifier(\"1.2.840.113549.1.1.13\")\n    RSA_WITH_SHA3_224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.13\")\n    RSA_WITH_SHA3_256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.14\")\n    RSA_WITH_SHA3_384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.15\")\n    RSA_WITH_SHA3_512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.16\")\n    RSASSA_PSS = ObjectIdentifier(\"1.2.840.113549.1.1.10\")\n    ECDSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.10045.4.1\")\n    ECDSA_WITH_SHA224 = ObjectIdentifier(\"1.2.840.10045.4.3.1\")\n    ECDSA_WITH_SHA256 = ObjectIdentifier(\"1.2.840.10045.4.3.2\")\n    ECDSA_WITH_SHA384 = ObjectIdentifier(\"1.2.840.10045.4.3.3\")\n    ECDSA_WITH_SHA512 = ObjectIdentifier(\"1.2.840.10045.4.3.4\")\n    ECDSA_WITH_SHA3_224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.9\")\n    ECDSA_WITH_SHA3_256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.10\")\n    ECDSA_WITH_SHA3_384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.11\")\n    ECDSA_WITH_SHA3_512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.12\")\n    DSA_WITH_SHA1 = ObjectIdentifier(\"1.2.840.10040.4.3\")\n    DSA_WITH_SHA224 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.1\")\n    DSA_WITH_SHA256 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.2\")\n    DSA_WITH_SHA384 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.3\")\n    DSA_WITH_SHA512 = ObjectIdentifier(\"2.16.840.1.101.3.4.3.4\")\n    ED25519 = ObjectIdentifier(\"1.3.101.112\")\n    ED448 = ObjectIdentifier(\"1.3.101.113\")\n    GOSTR3411_94_WITH_3410_2001 = ObjectIdentifier(\"1.2.643.2.2.3\")\n    GOSTR3410_2012_WITH_3411_2012_256 = ObjectIdentifier(\"1.2.643.7.1.1.3.2\")\n    GOSTR3410_2012_WITH_3411_2012_512 = ObjectIdentifier(\"1.2.643.7.1.1.3.3\")\n\n\n_SIG_OIDS_TO_HASH: dict[ObjectIdentifier, hashes.HashAlgorithm | None] = {\n    SignatureAlgorithmOID.RSA_WITH_MD5: hashes.MD5(),\n    SignatureAlgorithmOID.RSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID._RSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.RSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.RSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.RSA_WITH_SHA384: hashes.SHA384(),\n    SignatureAlgorithmOID.RSA_WITH_SHA512: hashes.SHA512(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_224: hashes.SHA3_224(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_256: hashes.SHA3_256(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_384: hashes.SHA3_384(),\n    SignatureAlgorithmOID.RSA_WITH_SHA3_512: hashes.SHA3_512(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA384: hashes.SHA384(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA512: hashes.SHA512(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_224: hashes.SHA3_224(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_256: hashes.SHA3_256(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_384: hashes.SHA3_384(),\n    SignatureAlgorithmOID.ECDSA_WITH_SHA3_512: hashes.SHA3_512(),\n    SignatureAlgorithmOID.DSA_WITH_SHA1: hashes.SHA1(),\n    SignatureAlgorithmOID.DSA_WITH_SHA224: hashes.SHA224(),\n    SignatureAlgorithmOID.DSA_WITH_SHA256: hashes.SHA256(),\n    SignatureAlgorithmOID.ED25519: None,\n    SignatureAlgorithmOID.ED448: None,\n    SignatureAlgorithmOID.GOSTR3411_94_WITH_3410_2001: None,\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_256: None,\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_512: None,\n}\n\n\nclass PublicKeyAlgorithmOID:\n    DSA = ObjectIdentifier(\"1.2.840.10040.4.1\")\n    EC_PUBLIC_KEY = ObjectIdentifier(\"1.2.840.10045.2.1\")\n    RSAES_PKCS1_v1_5 = ObjectIdentifier(\"1.2.840.113549.1.1.1\")\n    RSASSA_PSS = ObjectIdentifier(\"1.2.840.113549.1.1.10\")\n    X25519 = ObjectIdentifier(\"1.3.101.110\")\n    X448 = ObjectIdentifier(\"1.3.101.111\")\n    ED25519 = ObjectIdentifier(\"1.3.101.112\")\n    ED448 = ObjectIdentifier(\"1.3.101.113\")\n\n\nclass ExtendedKeyUsageOID:\n    SERVER_AUTH = ObjectIdentifier(\"1.3.6.1.5.5.7.3.1\")\n    CLIENT_AUTH = ObjectIdentifier(\"1.3.6.1.5.5.7.3.2\")\n    CODE_SIGNING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.3\")\n    EMAIL_PROTECTION = ObjectIdentifier(\"1.3.6.1.5.5.7.3.4\")\n    TIME_STAMPING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.8\")\n    OCSP_SIGNING = ObjectIdentifier(\"1.3.6.1.5.5.7.3.9\")\n    ANY_EXTENDED_KEY_USAGE = ObjectIdentifier(\"2.5.29.37.0\")\n    SMARTCARD_LOGON = ObjectIdentifier(\"1.3.6.1.4.1.311.20.2.2\")\n    KERBEROS_PKINIT_KDC = ObjectIdentifier(\"1.3.6.1.5.2.3.5\")\n    IPSEC_IKE = ObjectIdentifier(\"1.3.6.1.5.5.7.3.17\")\n    CERTIFICATE_TRANSPARENCY = ObjectIdentifier(\"1.3.6.1.4.1.11129.2.4.4\")\n\n\nclass AuthorityInformationAccessOID:\n    CA_ISSUERS = ObjectIdentifier(\"1.3.6.1.5.5.7.48.2\")\n    OCSP = ObjectIdentifier(\"1.3.6.1.5.5.7.48.1\")\n\n\nclass SubjectInformationAccessOID:\n    CA_REPOSITORY = ObjectIdentifier(\"1.3.6.1.5.5.7.48.5\")\n\n\nclass CertificatePoliciesOID:\n    CPS_QUALIFIER = ObjectIdentifier(\"1.3.6.1.5.5.7.2.1\")\n    CPS_USER_NOTICE = ObjectIdentifier(\"1.3.6.1.5.5.7.2.2\")\n    ANY_POLICY = ObjectIdentifier(\"2.5.29.32.0\")\n\n\nclass AttributeOID:\n    CHALLENGE_PASSWORD = ObjectIdentifier(\"1.2.840.113549.1.9.7\")\n    UNSTRUCTURED_NAME = ObjectIdentifier(\"1.2.840.113549.1.9.2\")\n\n\n_OID_NAMES = {\n    NameOID.COMMON_NAME: \"commonName\",\n    NameOID.COUNTRY_NAME: \"countryName\",\n    NameOID.LOCALITY_NAME: \"localityName\",\n    NameOID.STATE_OR_PROVINCE_NAME: \"stateOrProvinceName\",\n    NameOID.STREET_ADDRESS: \"streetAddress\",\n    NameOID.ORGANIZATION_NAME: \"organizationName\",\n    NameOID.ORGANIZATIONAL_UNIT_NAME: \"organizationalUnitName\",\n    NameOID.SERIAL_NUMBER: \"serialNumber\",\n    NameOID.SURNAME: \"surname\",\n    NameOID.GIVEN_NAME: \"givenName\",\n    NameOID.TITLE: \"title\",\n    NameOID.GENERATION_QUALIFIER: \"generationQualifier\",\n    NameOID.X500_UNIQUE_IDENTIFIER: \"x500UniqueIdentifier\",\n    NameOID.DN_QUALIFIER: \"dnQualifier\",\n    NameOID.PSEUDONYM: \"pseudonym\",\n    NameOID.USER_ID: \"userID\",\n    NameOID.DOMAIN_COMPONENT: \"domainComponent\",\n    NameOID.EMAIL_ADDRESS: \"emailAddress\",\n    NameOID.JURISDICTION_COUNTRY_NAME: \"jurisdictionCountryName\",\n    NameOID.JURISDICTION_LOCALITY_NAME: \"jurisdictionLocalityName\",\n    NameOID.JURISDICTION_STATE_OR_PROVINCE_NAME: (\n        \"jurisdictionStateOrProvinceName\"\n    ),\n    NameOID.BUSINESS_CATEGORY: \"businessCategory\",\n    NameOID.POSTAL_ADDRESS: \"postalAddress\",\n    NameOID.POSTAL_CODE: \"postalCode\",\n    NameOID.INN: \"INN\",\n    NameOID.OGRN: \"OGRN\",\n    NameOID.SNILS: \"SNILS\",\n    NameOID.UNSTRUCTURED_NAME: \"unstructuredName\",\n    SignatureAlgorithmOID.RSA_WITH_MD5: \"md5WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA1: \"sha1WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA224: \"sha224WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA256: \"sha256WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA384: \"sha384WithRSAEncryption\",\n    SignatureAlgorithmOID.RSA_WITH_SHA512: \"sha512WithRSAEncryption\",\n    SignatureAlgorithmOID.RSASSA_PSS: \"RSASSA-PSS\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA1: \"ecdsa-with-SHA1\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA224: \"ecdsa-with-SHA224\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA256: \"ecdsa-with-SHA256\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA384: \"ecdsa-with-SHA384\",\n    SignatureAlgorithmOID.ECDSA_WITH_SHA512: \"ecdsa-with-SHA512\",\n    SignatureAlgorithmOID.DSA_WITH_SHA1: \"dsa-with-sha1\",\n    SignatureAlgorithmOID.DSA_WITH_SHA224: \"dsa-with-sha224\",\n    SignatureAlgorithmOID.DSA_WITH_SHA256: \"dsa-with-sha256\",\n    SignatureAlgorithmOID.ED25519: \"ed25519\",\n    SignatureAlgorithmOID.ED448: \"ed448\",\n    SignatureAlgorithmOID.GOSTR3411_94_WITH_3410_2001: (\n        \"GOST R 34.11-94 with GOST R 34.10-2001\"\n    ),\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_256: (\n        \"GOST R 34.10-2012 with GOST R 34.11-2012 (256 bit)\"\n    ),\n    SignatureAlgorithmOID.GOSTR3410_2012_WITH_3411_2012_512: (\n        \"GOST R 34.10-2012 with GOST R 34.11-2012 (512 bit)\"\n    ),\n    PublicKeyAlgorithmOID.DSA: \"dsaEncryption\",\n    PublicKeyAlgorithmOID.EC_PUBLIC_KEY: \"id-ecPublicKey\",\n    PublicKeyAlgorithmOID.RSAES_PKCS1_v1_5: \"rsaEncryption\",\n    PublicKeyAlgorithmOID.RSASSA_PSS: \"rsassaPss\",\n    PublicKeyAlgorithmOID.X25519: \"X25519\",\n    PublicKeyAlgorithmOID.X448: \"X448\",\n    ExtendedKeyUsageOID.SERVER_AUTH: \"serverAuth\",\n    ExtendedKeyUsageOID.CLIENT_AUTH: \"clientAuth\",\n    ExtendedKeyUsageOID.CODE_SIGNING: \"codeSigning\",\n    ExtendedKeyUsageOID.EMAIL_PROTECTION: \"emailProtection\",\n    ExtendedKeyUsageOID.TIME_STAMPING: \"timeStamping\",\n    ExtendedKeyUsageOID.OCSP_SIGNING: \"OCSPSigning\",\n    ExtendedKeyUsageOID.SMARTCARD_LOGON: \"msSmartcardLogin\",\n    ExtendedKeyUsageOID.KERBEROS_PKINIT_KDC: \"pkInitKDC\",\n    ExtensionOID.SUBJECT_DIRECTORY_ATTRIBUTES: \"subjectDirectoryAttributes\",\n    ExtensionOID.SUBJECT_KEY_IDENTIFIER: \"subjectKeyIdentifier\",\n    ExtensionOID.KEY_USAGE: \"keyUsage\",\n    ExtensionOID.SUBJECT_ALTERNATIVE_NAME: \"subjectAltName\",\n    ExtensionOID.ISSUER_ALTERNATIVE_NAME: \"issuerAltName\",\n    ExtensionOID.BASIC_CONSTRAINTS: \"basicConstraints\",\n    ExtensionOID.PRECERT_SIGNED_CERTIFICATE_TIMESTAMPS: (\n        \"signedCertificateTimestampList\"\n    ),\n    ExtensionOID.SIGNED_CERTIFICATE_TIMESTAMPS: (\n        \"signedCertificateTimestampList\"\n    ),\n    ExtensionOID.PRECERT_POISON: \"ctPoison\",\n    ExtensionOID.MS_CERTIFICATE_TEMPLATE: \"msCertificateTemplate\",\n    CRLEntryExtensionOID.CRL_REASON: \"cRLReason\",\n    CRLEntryExtensionOID.INVALIDITY_DATE: \"invalidityDate\",\n    CRLEntryExtensionOID.CERTIFICATE_ISSUER: \"certificateIssuer\",\n    ExtensionOID.NAME_CONSTRAINTS: \"nameConstraints\",\n    ExtensionOID.CRL_DISTRIBUTION_POINTS: \"cRLDistributionPoints\",\n    ExtensionOID.CERTIFICATE_POLICIES: \"certificatePolicies\",\n    ExtensionOID.POLICY_MAPPINGS: \"policyMappings\",\n    ExtensionOID.AUTHORITY_KEY_IDENTIFIER: \"authorityKeyIdentifier\",\n    ExtensionOID.POLICY_CONSTRAINTS: \"policyConstraints\",\n    ExtensionOID.EXTENDED_KEY_USAGE: \"extendedKeyUsage\",\n    ExtensionOID.FRESHEST_CRL: \"freshestCRL\",\n    ExtensionOID.INHIBIT_ANY_POLICY: \"inhibitAnyPolicy\",\n    ExtensionOID.ISSUING_DISTRIBUTION_POINT: \"issuingDistributionPoint\",\n    ExtensionOID.AUTHORITY_INFORMATION_ACCESS: \"authorityInfoAccess\",\n    ExtensionOID.SUBJECT_INFORMATION_ACCESS: \"subjectInfoAccess\",\n    ExtensionOID.OCSP_NO_CHECK: \"OCSPNoCheck\",\n    ExtensionOID.CRL_NUMBER: \"cRLNumber\",\n    ExtensionOID.DELTA_CRL_INDICATOR: \"deltaCRLIndicator\",\n    ExtensionOID.TLS_FEATURE: \"TLSFeature\",\n    AuthorityInformationAccessOID.OCSP: \"OCSP\",\n    AuthorityInformationAccessOID.CA_ISSUERS: \"caIssuers\",\n    SubjectInformationAccessOID.CA_REPOSITORY: \"caRepository\",\n    CertificatePoliciesOID.CPS_QUALIFIER: \"id-qt-cps\",\n    CertificatePoliciesOID.CPS_USER_NOTICE: \"id-qt-unotice\",\n    OCSPExtensionOID.NONCE: \"OCSPNonce\",\n    AttributeOID.CHALLENGE_PASSWORD: \"challengePassword\",\n}\n", "src/cryptography/hazmat/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\"\"\"\nHazardous Materials\n\nThis is a \"Hazardous Materials\" module. You should ONLY use it if you're\n100% absolutely sure that you know what you're doing because this module\nis full of land mines, dragons, and dinosaurs with laser guns.\n\"\"\"\n", "src/cryptography/hazmat/primitives/constant_time.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport hmac\n\n\ndef bytes_eq(a: bytes, b: bytes) -> bool:\n    if not isinstance(a, bytes) or not isinstance(b, bytes):\n        raise TypeError(\"a and b must be bytes.\")\n\n    return hmac.compare_digest(a, b)\n", "src/cryptography/hazmat/primitives/hashes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\n    \"MD5\",\n    \"SHA1\",\n    \"SHA3_224\",\n    \"SHA3_256\",\n    \"SHA3_384\",\n    \"SHA3_512\",\n    \"SHA224\",\n    \"SHA256\",\n    \"SHA384\",\n    \"SHA512\",\n    \"SHA512_224\",\n    \"SHA512_256\",\n    \"SHAKE128\",\n    \"SHAKE256\",\n    \"SM3\",\n    \"BLAKE2b\",\n    \"BLAKE2s\",\n    \"ExtendableOutputFunction\",\n    \"Hash\",\n    \"HashAlgorithm\",\n    \"HashContext\",\n]\n\n\nclass HashAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this algorithm (e.g. \"sha256\", \"md5\").\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def digest_size(self) -> int:\n        \"\"\"\n        The size of the resulting digest in bytes.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def block_size(self) -> int | None:\n        \"\"\"\n        The internal block size of the hash function, or None if the hash\n        function does not use blocks internally (e.g. SHA3).\n        \"\"\"\n\n\nclass HashContext(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def algorithm(self) -> HashAlgorithm:\n        \"\"\"\n        A HashAlgorithm that will be used by this context.\n        \"\"\"\n\n    @abc.abstractmethod\n    def update(self, data: bytes) -> None:\n        \"\"\"\n        Processes the provided bytes through the hash.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Finalizes the hash context and returns the hash digest as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def copy(self) -> HashContext:\n        \"\"\"\n        Return a HashContext that is a copy of the current context.\n        \"\"\"\n\n\nHash = rust_openssl.hashes.Hash\nHashContext.register(Hash)\n\n\nclass ExtendableOutputFunction(metaclass=abc.ABCMeta):\n    \"\"\"\n    An interface for extendable output functions.\n    \"\"\"\n\n\nclass SHA1(HashAlgorithm):\n    name = \"sha1\"\n    digest_size = 20\n    block_size = 64\n\n\nclass SHA512_224(HashAlgorithm):  # noqa: N801\n    name = \"sha512-224\"\n    digest_size = 28\n    block_size = 128\n\n\nclass SHA512_256(HashAlgorithm):  # noqa: N801\n    name = \"sha512-256\"\n    digest_size = 32\n    block_size = 128\n\n\nclass SHA224(HashAlgorithm):\n    name = \"sha224\"\n    digest_size = 28\n    block_size = 64\n\n\nclass SHA256(HashAlgorithm):\n    name = \"sha256\"\n    digest_size = 32\n    block_size = 64\n\n\nclass SHA384(HashAlgorithm):\n    name = \"sha384\"\n    digest_size = 48\n    block_size = 128\n\n\nclass SHA512(HashAlgorithm):\n    name = \"sha512\"\n    digest_size = 64\n    block_size = 128\n\n\nclass SHA3_224(HashAlgorithm):  # noqa: N801\n    name = \"sha3-224\"\n    digest_size = 28\n    block_size = None\n\n\nclass SHA3_256(HashAlgorithm):  # noqa: N801\n    name = \"sha3-256\"\n    digest_size = 32\n    block_size = None\n\n\nclass SHA3_384(HashAlgorithm):  # noqa: N801\n    name = \"sha3-384\"\n    digest_size = 48\n    block_size = None\n\n\nclass SHA3_512(HashAlgorithm):  # noqa: N801\n    name = \"sha3-512\"\n    digest_size = 64\n    block_size = None\n\n\nclass SHAKE128(HashAlgorithm, ExtendableOutputFunction):\n    name = \"shake128\"\n    block_size = None\n\n    def __init__(self, digest_size: int):\n        if not isinstance(digest_size, int):\n            raise TypeError(\"digest_size must be an integer\")\n\n        if digest_size < 1:\n            raise ValueError(\"digest_size must be a positive integer\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass SHAKE256(HashAlgorithm, ExtendableOutputFunction):\n    name = \"shake256\"\n    block_size = None\n\n    def __init__(self, digest_size: int):\n        if not isinstance(digest_size, int):\n            raise TypeError(\"digest_size must be an integer\")\n\n        if digest_size < 1:\n            raise ValueError(\"digest_size must be a positive integer\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass MD5(HashAlgorithm):\n    name = \"md5\"\n    digest_size = 16\n    block_size = 64\n\n\nclass BLAKE2b(HashAlgorithm):\n    name = \"blake2b\"\n    _max_digest_size = 64\n    _min_digest_size = 1\n    block_size = 128\n\n    def __init__(self, digest_size: int):\n        if digest_size != 64:\n            raise ValueError(\"Digest size must be 64\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass BLAKE2s(HashAlgorithm):\n    name = \"blake2s\"\n    block_size = 64\n    _max_digest_size = 32\n    _min_digest_size = 1\n\n    def __init__(self, digest_size: int):\n        if digest_size != 32:\n            raise ValueError(\"Digest size must be 32\")\n\n        self._digest_size = digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n\n\nclass SM3(HashAlgorithm):\n    name = \"sm3\"\n    digest_size = 32\n    block_size = 64\n", "src/cryptography/hazmat/primitives/keywrap.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.primitives.ciphers import Cipher\nfrom cryptography.hazmat.primitives.ciphers.algorithms import AES\nfrom cryptography.hazmat.primitives.ciphers.modes import ECB\nfrom cryptography.hazmat.primitives.constant_time import bytes_eq\n\n\ndef _wrap_core(\n    wrapping_key: bytes,\n    a: bytes,\n    r: list[bytes],\n) -> bytes:\n    # RFC 3394 Key Wrap - 2.2.1 (index method)\n    encryptor = Cipher(AES(wrapping_key), ECB()).encryptor()\n    n = len(r)\n    for j in range(6):\n        for i in range(n):\n            # every encryption operation is a discrete 16 byte chunk (because\n            # AES has a 128-bit block size) and since we're using ECB it is\n            # safe to reuse the encryptor for the entire operation\n            b = encryptor.update(a + r[i])\n            a = (\n                int.from_bytes(b[:8], byteorder=\"big\") ^ ((n * j) + i + 1)\n            ).to_bytes(length=8, byteorder=\"big\")\n            r[i] = b[-8:]\n\n    assert encryptor.finalize() == b\"\"\n\n    return a + b\"\".join(r)\n\n\ndef aes_key_wrap(\n    wrapping_key: bytes,\n    key_to_wrap: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    if len(key_to_wrap) < 16:\n        raise ValueError(\"The key to wrap must be at least 16 bytes\")\n\n    if len(key_to_wrap) % 8 != 0:\n        raise ValueError(\"The key to wrap must be a multiple of 8 bytes\")\n\n    a = b\"\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\"\n    r = [key_to_wrap[i : i + 8] for i in range(0, len(key_to_wrap), 8)]\n    return _wrap_core(wrapping_key, a, r)\n\n\ndef _unwrap_core(\n    wrapping_key: bytes,\n    a: bytes,\n    r: list[bytes],\n) -> tuple[bytes, list[bytes]]:\n    # Implement RFC 3394 Key Unwrap - 2.2.2 (index method)\n    decryptor = Cipher(AES(wrapping_key), ECB()).decryptor()\n    n = len(r)\n    for j in reversed(range(6)):\n        for i in reversed(range(n)):\n            atr = (\n                int.from_bytes(a, byteorder=\"big\") ^ ((n * j) + i + 1)\n            ).to_bytes(length=8, byteorder=\"big\") + r[i]\n            # every decryption operation is a discrete 16 byte chunk so\n            # it is safe to reuse the decryptor for the entire operation\n            b = decryptor.update(atr)\n            a = b[:8]\n            r[i] = b[-8:]\n\n    assert decryptor.finalize() == b\"\"\n    return a, r\n\n\ndef aes_key_wrap_with_padding(\n    wrapping_key: bytes,\n    key_to_wrap: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    aiv = b\"\\xa6\\x59\\x59\\xa6\" + len(key_to_wrap).to_bytes(\n        length=4, byteorder=\"big\"\n    )\n    # pad the key to wrap if necessary\n    pad = (8 - (len(key_to_wrap) % 8)) % 8\n    key_to_wrap = key_to_wrap + b\"\\x00\" * pad\n    if len(key_to_wrap) == 8:\n        # RFC 5649 - 4.1 - exactly 8 octets after padding\n        encryptor = Cipher(AES(wrapping_key), ECB()).encryptor()\n        b = encryptor.update(aiv + key_to_wrap)\n        assert encryptor.finalize() == b\"\"\n        return b\n    else:\n        r = [key_to_wrap[i : i + 8] for i in range(0, len(key_to_wrap), 8)]\n        return _wrap_core(wrapping_key, aiv, r)\n\n\ndef aes_key_unwrap_with_padding(\n    wrapping_key: bytes,\n    wrapped_key: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapped_key) < 16:\n        raise InvalidUnwrap(\"Must be at least 16 bytes\")\n\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    if len(wrapped_key) == 16:\n        # RFC 5649 - 4.2 - exactly two 64-bit blocks\n        decryptor = Cipher(AES(wrapping_key), ECB()).decryptor()\n        out = decryptor.update(wrapped_key)\n        assert decryptor.finalize() == b\"\"\n        a = out[:8]\n        data = out[8:]\n        n = 1\n    else:\n        r = [wrapped_key[i : i + 8] for i in range(0, len(wrapped_key), 8)]\n        encrypted_aiv = r.pop(0)\n        n = len(r)\n        a, r = _unwrap_core(wrapping_key, encrypted_aiv, r)\n        data = b\"\".join(r)\n\n    # 1) Check that MSB(32,A) = A65959A6.\n    # 2) Check that 8*(n-1) < LSB(32,A) <= 8*n.  If so, let\n    #    MLI = LSB(32,A).\n    # 3) Let b = (8*n)-MLI, and then check that the rightmost b octets of\n    #    the output data are zero.\n    mli = int.from_bytes(a[4:], byteorder=\"big\")\n    b = (8 * n) - mli\n    if (\n        not bytes_eq(a[:4], b\"\\xa6\\x59\\x59\\xa6\")\n        or not 8 * (n - 1) < mli <= 8 * n\n        or (b != 0 and not bytes_eq(data[-b:], b\"\\x00\" * b))\n    ):\n        raise InvalidUnwrap()\n\n    if b == 0:\n        return data\n    else:\n        return data[:-b]\n\n\ndef aes_key_unwrap(\n    wrapping_key: bytes,\n    wrapped_key: bytes,\n    backend: typing.Any = None,\n) -> bytes:\n    if len(wrapped_key) < 24:\n        raise InvalidUnwrap(\"Must be at least 24 bytes\")\n\n    if len(wrapped_key) % 8 != 0:\n        raise InvalidUnwrap(\"The wrapped key must be a multiple of 8 bytes\")\n\n    if len(wrapping_key) not in [16, 24, 32]:\n        raise ValueError(\"The wrapping key must be a valid AES key length\")\n\n    aiv = b\"\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\\xa6\"\n    r = [wrapped_key[i : i + 8] for i in range(0, len(wrapped_key), 8)]\n    a = r.pop(0)\n    a, r = _unwrap_core(wrapping_key, a, r)\n    if not bytes_eq(a, aiv):\n        raise InvalidUnwrap()\n\n    return b\"\".join(r)\n\n\nclass InvalidUnwrap(Exception):\n    pass\n", "src/cryptography/hazmat/primitives/cmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\"CMAC\"]\nCMAC = rust_openssl.cmac.CMAC\n", "src/cryptography/hazmat/primitives/_serialization.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\nfrom cryptography.hazmat.primitives.hashes import HashAlgorithm\n\n# This exists to break an import cycle. These classes are normally accessible\n# from the serialization module.\n\n\nclass PBES(utils.Enum):\n    PBESv1SHA1And3KeyTripleDESCBC = \"PBESv1 using SHA1 and 3-Key TripleDES\"\n    PBESv2SHA256AndAES256CBC = \"PBESv2 using SHA256 PBKDF2 and AES256 CBC\"\n\n\nclass Encoding(utils.Enum):\n    PEM = \"PEM\"\n    DER = \"DER\"\n    OpenSSH = \"OpenSSH\"\n    Raw = \"Raw\"\n    X962 = \"ANSI X9.62\"\n    SMIME = \"S/MIME\"\n\n\nclass PrivateFormat(utils.Enum):\n    PKCS8 = \"PKCS8\"\n    TraditionalOpenSSL = \"TraditionalOpenSSL\"\n    Raw = \"Raw\"\n    OpenSSH = \"OpenSSH\"\n    PKCS12 = \"PKCS12\"\n\n    def encryption_builder(self) -> KeySerializationEncryptionBuilder:\n        if self not in (PrivateFormat.OpenSSH, PrivateFormat.PKCS12):\n            raise ValueError(\n                \"encryption_builder only supported with PrivateFormat.OpenSSH\"\n                \" and PrivateFormat.PKCS12\"\n            )\n        return KeySerializationEncryptionBuilder(self)\n\n\nclass PublicFormat(utils.Enum):\n    SubjectPublicKeyInfo = \"X.509 subjectPublicKeyInfo with PKCS#1\"\n    PKCS1 = \"Raw PKCS#1\"\n    OpenSSH = \"OpenSSH\"\n    Raw = \"Raw\"\n    CompressedPoint = \"X9.62 Compressed Point\"\n    UncompressedPoint = \"X9.62 Uncompressed Point\"\n\n\nclass ParameterFormat(utils.Enum):\n    PKCS3 = \"PKCS3\"\n\n\nclass KeySerializationEncryption(metaclass=abc.ABCMeta):\n    pass\n\n\nclass BestAvailableEncryption(KeySerializationEncryption):\n    def __init__(self, password: bytes):\n        if not isinstance(password, bytes) or len(password) == 0:\n            raise ValueError(\"Password must be 1 or more bytes.\")\n\n        self.password = password\n\n\nclass NoEncryption(KeySerializationEncryption):\n    pass\n\n\nclass KeySerializationEncryptionBuilder:\n    def __init__(\n        self,\n        format: PrivateFormat,\n        *,\n        _kdf_rounds: int | None = None,\n        _hmac_hash: HashAlgorithm | None = None,\n        _key_cert_algorithm: PBES | None = None,\n    ) -> None:\n        self._format = format\n\n        self._kdf_rounds = _kdf_rounds\n        self._hmac_hash = _hmac_hash\n        self._key_cert_algorithm = _key_cert_algorithm\n\n    def kdf_rounds(self, rounds: int) -> KeySerializationEncryptionBuilder:\n        if self._kdf_rounds is not None:\n            raise ValueError(\"kdf_rounds already set\")\n\n        if not isinstance(rounds, int):\n            raise TypeError(\"kdf_rounds must be an integer\")\n\n        if rounds < 1:\n            raise ValueError(\"kdf_rounds must be a positive integer\")\n\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=rounds,\n            _hmac_hash=self._hmac_hash,\n            _key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n    def hmac_hash(\n        self, algorithm: HashAlgorithm\n    ) -> KeySerializationEncryptionBuilder:\n        if self._format is not PrivateFormat.PKCS12:\n            raise TypeError(\n                \"hmac_hash only supported with PrivateFormat.PKCS12\"\n            )\n\n        if self._hmac_hash is not None:\n            raise ValueError(\"hmac_hash already set\")\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=self._kdf_rounds,\n            _hmac_hash=algorithm,\n            _key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n    def key_cert_algorithm(\n        self, algorithm: PBES\n    ) -> KeySerializationEncryptionBuilder:\n        if self._format is not PrivateFormat.PKCS12:\n            raise TypeError(\n                \"key_cert_algorithm only supported with \"\n                \"PrivateFormat.PKCS12\"\n            )\n        if self._key_cert_algorithm is not None:\n            raise ValueError(\"key_cert_algorithm already set\")\n        return KeySerializationEncryptionBuilder(\n            self._format,\n            _kdf_rounds=self._kdf_rounds,\n            _hmac_hash=self._hmac_hash,\n            _key_cert_algorithm=algorithm,\n        )\n\n    def build(self, password: bytes) -> KeySerializationEncryption:\n        if not isinstance(password, bytes) or len(password) == 0:\n            raise ValueError(\"Password must be 1 or more bytes.\")\n\n        return _KeySerializationEncryption(\n            self._format,\n            password,\n            kdf_rounds=self._kdf_rounds,\n            hmac_hash=self._hmac_hash,\n            key_cert_algorithm=self._key_cert_algorithm,\n        )\n\n\nclass _KeySerializationEncryption(KeySerializationEncryption):\n    def __init__(\n        self,\n        format: PrivateFormat,\n        password: bytes,\n        *,\n        kdf_rounds: int | None,\n        hmac_hash: HashAlgorithm | None,\n        key_cert_algorithm: PBES | None,\n    ):\n        self._format = format\n        self.password = password\n\n        self._kdf_rounds = kdf_rounds\n        self._hmac_hash = hmac_hash\n        self._key_cert_algorithm = key_cert_algorithm\n", "src/cryptography/hazmat/primitives/padding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized\nfrom cryptography.hazmat.bindings._rust import (\n    PKCS7PaddingContext,\n    check_ansix923_padding,\n    check_pkcs7_padding,\n)\n\n\nclass PaddingContext(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def update(self, data: bytes) -> bytes:\n        \"\"\"\n        Pads the provided bytes and returns any available data as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Finalize the padding, returns bytes.\n        \"\"\"\n\n\ndef _byte_padding_check(block_size: int) -> None:\n    if not (0 <= block_size <= 2040):\n        raise ValueError(\"block_size must be in range(0, 2041).\")\n\n    if block_size % 8 != 0:\n        raise ValueError(\"block_size must be a multiple of 8.\")\n\n\ndef _byte_padding_update(\n    buffer_: bytes | None, data: bytes, block_size: int\n) -> tuple[bytes, bytes]:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    utils._check_byteslike(\"data\", data)\n\n    buffer_ += bytes(data)\n\n    finished_blocks = len(buffer_) // (block_size // 8)\n\n    result = buffer_[: finished_blocks * (block_size // 8)]\n    buffer_ = buffer_[finished_blocks * (block_size // 8) :]\n\n    return buffer_, result\n\n\ndef _byte_padding_pad(\n    buffer_: bytes | None,\n    block_size: int,\n    paddingfn: typing.Callable[[int], bytes],\n) -> bytes:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    pad_size = block_size // 8 - len(buffer_)\n    return buffer_ + paddingfn(pad_size)\n\n\ndef _byte_unpadding_update(\n    buffer_: bytes | None, data: bytes, block_size: int\n) -> tuple[bytes, bytes]:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    utils._check_byteslike(\"data\", data)\n\n    buffer_ += bytes(data)\n\n    finished_blocks = max(len(buffer_) // (block_size // 8) - 1, 0)\n\n    result = buffer_[: finished_blocks * (block_size // 8)]\n    buffer_ = buffer_[finished_blocks * (block_size // 8) :]\n\n    return buffer_, result\n\n\ndef _byte_unpadding_check(\n    buffer_: bytes | None,\n    block_size: int,\n    checkfn: typing.Callable[[bytes], int],\n) -> bytes:\n    if buffer_ is None:\n        raise AlreadyFinalized(\"Context was already finalized.\")\n\n    if len(buffer_) != block_size // 8:\n        raise ValueError(\"Invalid padding bytes.\")\n\n    valid = checkfn(buffer_)\n\n    if not valid:\n        raise ValueError(\"Invalid padding bytes.\")\n\n    pad_size = buffer_[-1]\n    return buffer_[:-pad_size]\n\n\nclass PKCS7:\n    def __init__(self, block_size: int):\n        _byte_padding_check(block_size)\n        self.block_size = block_size\n\n    def padder(self) -> PaddingContext:\n        return PKCS7PaddingContext(self.block_size)\n\n    def unpadder(self) -> PaddingContext:\n        return _PKCS7UnpaddingContext(self.block_size)\n\n\nclass _PKCS7UnpaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_unpadding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def finalize(self) -> bytes:\n        result = _byte_unpadding_check(\n            self._buffer, self.block_size, check_pkcs7_padding\n        )\n        self._buffer = None\n        return result\n\n\nPaddingContext.register(PKCS7PaddingContext)\n\n\nclass ANSIX923:\n    def __init__(self, block_size: int):\n        _byte_padding_check(block_size)\n        self.block_size = block_size\n\n    def padder(self) -> PaddingContext:\n        return _ANSIX923PaddingContext(self.block_size)\n\n    def unpadder(self) -> PaddingContext:\n        return _ANSIX923UnpaddingContext(self.block_size)\n\n\nclass _ANSIX923PaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_padding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def _padding(self, size: int) -> bytes:\n        return bytes([0]) * (size - 1) + bytes([size])\n\n    def finalize(self) -> bytes:\n        result = _byte_padding_pad(\n            self._buffer, self.block_size, self._padding\n        )\n        self._buffer = None\n        return result\n\n\nclass _ANSIX923UnpaddingContext(PaddingContext):\n    _buffer: bytes | None\n\n    def __init__(self, block_size: int):\n        self.block_size = block_size\n        # TODO: more copies than necessary, we should use zero-buffer (#193)\n        self._buffer = b\"\"\n\n    def update(self, data: bytes) -> bytes:\n        self._buffer, result = _byte_unpadding_update(\n            self._buffer, data, self.block_size\n        )\n        return result\n\n    def finalize(self) -> bytes:\n        result = _byte_unpadding_check(\n            self._buffer,\n            self.block_size,\n            check_ansix923_padding,\n        )\n        self._buffer = None\n        return result\n", "src/cryptography/hazmat/primitives/_cipheralgorithm.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\n\n# This exists to break an import cycle. It is normally accessible from the\n# ciphers module.\n\n\nclass CipherAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this mode (e.g. \"AES\", \"Camellia\").\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_sizes(self) -> frozenset[int]:\n        \"\"\"\n        Valid key sizes for this algorithm in bits\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The size of the key being used as an integer in bits (e.g. 128, 256).\n        \"\"\"\n\n\nclass BlockCipherAlgorithm(CipherAlgorithm):\n    key: bytes\n\n    @property\n    @abc.abstractmethod\n    def block_size(self) -> int:\n        \"\"\"\n        The size of a block as an integer in bits (e.g. 64, 128).\n        \"\"\"\n\n\ndef _verify_key_size(algorithm: CipherAlgorithm, key: bytes) -> bytes:\n    # Verify that the key is instance of bytes\n    utils._check_byteslike(\"key\", key)\n\n    # Verify that the key size matches the expected key size\n    if len(key) * 8 not in algorithm.key_sizes:\n        raise ValueError(\n            f\"Invalid key size ({len(key) * 8}) for {algorithm.name}.\"\n        )\n    return key\n", "src/cryptography/hazmat/primitives/poly1305.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\"Poly1305\"]\n\nPoly1305 = rust_openssl.poly1305.Poly1305\n", "src/cryptography/hazmat/primitives/hmac.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import hashes\n\n__all__ = [\"HMAC\"]\n\nHMAC = rust_openssl.hmac.HMAC\nhashes.HashContext.register(HMAC)\n", "src/cryptography/hazmat/primitives/_asymmetric.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\n# This exists to break an import cycle. It is normally accessible from the\n# asymmetric padding module.\n\n\nclass AsymmetricPadding(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this padding (e.g. \"PSS\", \"PKCS1\").\n        \"\"\"\n", "src/cryptography/hazmat/primitives/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/primitives/twofactor/totp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\nfrom cryptography.hazmat.primitives.twofactor.hotp import (\n    HOTP,\n    HOTPHashTypes,\n    _generate_uri,\n)\n\n\nclass TOTP:\n    def __init__(\n        self,\n        key: bytes,\n        length: int,\n        algorithm: HOTPHashTypes,\n        time_step: int,\n        backend: typing.Any = None,\n        enforce_key_length: bool = True,\n    ):\n        self._time_step = time_step\n        self._hotp = HOTP(\n            key, length, algorithm, enforce_key_length=enforce_key_length\n        )\n\n    def generate(self, time: int | float) -> bytes:\n        counter = int(time / self._time_step)\n        return self._hotp.generate(counter)\n\n    def verify(self, totp: bytes, time: int) -> None:\n        if not constant_time.bytes_eq(self.generate(time), totp):\n            raise InvalidToken(\"Supplied TOTP value does not match.\")\n\n    def get_provisioning_uri(\n        self, account_name: str, issuer: str | None\n    ) -> str:\n        return _generate_uri(\n            self._hotp,\n            \"totp\",\n            account_name,\n            issuer,\n            [(\"period\", int(self._time_step))],\n        )\n", "src/cryptography/hazmat/primitives/twofactor/hotp.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport base64\nimport typing\nfrom urllib.parse import quote, urlencode\n\nfrom cryptography.hazmat.primitives import constant_time, hmac\nfrom cryptography.hazmat.primitives.hashes import SHA1, SHA256, SHA512\nfrom cryptography.hazmat.primitives.twofactor import InvalidToken\n\nHOTPHashTypes = typing.Union[SHA1, SHA256, SHA512]\n\n\ndef _generate_uri(\n    hotp: HOTP,\n    type_name: str,\n    account_name: str,\n    issuer: str | None,\n    extra_parameters: list[tuple[str, int]],\n) -> str:\n    parameters = [\n        (\"digits\", hotp._length),\n        (\"secret\", base64.b32encode(hotp._key)),\n        (\"algorithm\", hotp._algorithm.name.upper()),\n    ]\n\n    if issuer is not None:\n        parameters.append((\"issuer\", issuer))\n\n    parameters.extend(extra_parameters)\n\n    label = (\n        f\"{quote(issuer)}:{quote(account_name)}\"\n        if issuer\n        else quote(account_name)\n    )\n    return f\"otpauth://{type_name}/{label}?{urlencode(parameters)}\"\n\n\nclass HOTP:\n    def __init__(\n        self,\n        key: bytes,\n        length: int,\n        algorithm: HOTPHashTypes,\n        backend: typing.Any = None,\n        enforce_key_length: bool = True,\n    ) -> None:\n        if len(key) < 16 and enforce_key_length is True:\n            raise ValueError(\"Key length has to be at least 128 bits.\")\n\n        if not isinstance(length, int):\n            raise TypeError(\"Length parameter must be an integer type.\")\n\n        if length < 6 or length > 8:\n            raise ValueError(\"Length of HOTP has to be between 6 and 8.\")\n\n        if not isinstance(algorithm, (SHA1, SHA256, SHA512)):\n            raise TypeError(\"Algorithm must be SHA1, SHA256 or SHA512.\")\n\n        self._key = key\n        self._length = length\n        self._algorithm = algorithm\n\n    def generate(self, counter: int) -> bytes:\n        truncated_value = self._dynamic_truncate(counter)\n        hotp = truncated_value % (10**self._length)\n        return \"{0:0{1}}\".format(hotp, self._length).encode()\n\n    def verify(self, hotp: bytes, counter: int) -> None:\n        if not constant_time.bytes_eq(self.generate(counter), hotp):\n            raise InvalidToken(\"Supplied HOTP value does not match.\")\n\n    def _dynamic_truncate(self, counter: int) -> int:\n        ctx = hmac.HMAC(self._key, self._algorithm)\n        ctx.update(counter.to_bytes(length=8, byteorder=\"big\"))\n        hmac_value = ctx.finalize()\n\n        offset = hmac_value[len(hmac_value) - 1] & 0b1111\n        p = hmac_value[offset : offset + 4]\n        return int.from_bytes(p, byteorder=\"big\") & 0x7FFFFFFF\n\n    def get_provisioning_uri(\n        self, account_name: str, counter: int, issuer: str | None\n    ) -> str:\n        return _generate_uri(\n            self, \"hotp\", account_name, issuer, [(\"counter\", int(counter))]\n        )\n", "src/cryptography/hazmat/primitives/twofactor/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\nclass InvalidToken(Exception):\n    pass\n", "src/cryptography/hazmat/primitives/asymmetric/dh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\ngenerate_parameters = rust_openssl.dh.generate_parameters\n\n\nDHPrivateNumbers = rust_openssl.dh.DHPrivateNumbers\nDHPublicNumbers = rust_openssl.dh.DHPublicNumbers\nDHParameterNumbers = rust_openssl.dh.DHParameterNumbers\n\n\nclass DHParameters(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def generate_private_key(self) -> DHPrivateKey:\n        \"\"\"\n        Generates and returns a DHPrivateKey.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.ParameterFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the parameters serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_numbers(self) -> DHParameterNumbers:\n        \"\"\"\n        Returns a DHParameterNumbers.\n        \"\"\"\n\n\nDHParametersWithSerialization = DHParameters\nDHParameters.register(rust_openssl.dh.DHParameters)\n\n\nclass DHPublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DHParameters:\n        \"\"\"\n        The DHParameters object associated with this public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> DHPublicNumbers:\n        \"\"\"\n        Returns a DHPublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nDHPublicKeyWithSerialization = DHPublicKey\nDHPublicKey.register(rust_openssl.dh.DHPublicKey)\n\n\nclass DHPrivateKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> DHPublicKey:\n        \"\"\"\n        The DHPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DHParameters:\n        \"\"\"\n        The DHParameters object associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: DHPublicKey) -> bytes:\n        \"\"\"\n        Given peer's DHPublicKey, carry out the key exchange and\n        return shared key as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> DHPrivateNumbers:\n        \"\"\"\n        Returns a DHPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nDHPrivateKeyWithSerialization = DHPrivateKey\nDHPrivateKey.register(rust_openssl.dh.DHPrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/dsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass DSAParameters(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def generate_private_key(self) -> DSAPrivateKey:\n        \"\"\"\n        Generates and returns a DSAPrivateKey.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameter_numbers(self) -> DSAParameterNumbers:\n        \"\"\"\n        Returns a DSAParameterNumbers.\n        \"\"\"\n\n\nDSAParametersWithNumbers = DSAParameters\nDSAParameters.register(rust_openssl.dsa.DSAParameters)\n\n\nclass DSAPrivateKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> DSAPublicKey:\n        \"\"\"\n        The DSAPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DSAParameters:\n        \"\"\"\n        The DSAParameters object associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> DSAPrivateNumbers:\n        \"\"\"\n        Returns a DSAPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nDSAPrivateKeyWithSerialization = DSAPrivateKey\nDSAPrivateKey.register(rust_openssl.dsa.DSAPrivateKey)\n\n\nclass DSAPublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the prime modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def parameters(self) -> DSAParameters:\n        \"\"\"\n        The DSAParameters object associated with this public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> DSAPublicNumbers:\n        \"\"\"\n        Returns a DSAPublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nDSAPublicKeyWithSerialization = DSAPublicKey\nDSAPublicKey.register(rust_openssl.dsa.DSAPublicKey)\n\nDSAPrivateNumbers = rust_openssl.dsa.DSAPrivateNumbers\nDSAPublicNumbers = rust_openssl.dsa.DSAPublicNumbers\nDSAParameterNumbers = rust_openssl.dsa.DSAParameterNumbers\n\n\ndef generate_parameters(\n    key_size: int, backend: typing.Any = None\n) -> DSAParameters:\n    if key_size not in (1024, 2048, 3072, 4096):\n        raise ValueError(\"Key size must be 1024, 2048, 3072, or 4096 bits.\")\n\n    return rust_openssl.dsa.generate_parameters(key_size)\n\n\ndef generate_private_key(\n    key_size: int, backend: typing.Any = None\n) -> DSAPrivateKey:\n    parameters = generate_parameters(key_size)\n    return parameters.generate_private_key()\n", "src/cryptography/hazmat/primitives/asymmetric/ec.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat._oid import ObjectIdentifier\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass EllipticCurveOID:\n    SECP192R1 = ObjectIdentifier(\"1.2.840.10045.3.1.1\")\n    SECP224R1 = ObjectIdentifier(\"1.3.132.0.33\")\n    SECP256K1 = ObjectIdentifier(\"1.3.132.0.10\")\n    SECP256R1 = ObjectIdentifier(\"1.2.840.10045.3.1.7\")\n    SECP384R1 = ObjectIdentifier(\"1.3.132.0.34\")\n    SECP521R1 = ObjectIdentifier(\"1.3.132.0.35\")\n    BRAINPOOLP256R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.7\")\n    BRAINPOOLP384R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.11\")\n    BRAINPOOLP512R1 = ObjectIdentifier(\"1.3.36.3.3.2.8.1.1.13\")\n    SECT163K1 = ObjectIdentifier(\"1.3.132.0.1\")\n    SECT163R2 = ObjectIdentifier(\"1.3.132.0.15\")\n    SECT233K1 = ObjectIdentifier(\"1.3.132.0.26\")\n    SECT233R1 = ObjectIdentifier(\"1.3.132.0.27\")\n    SECT283K1 = ObjectIdentifier(\"1.3.132.0.16\")\n    SECT283R1 = ObjectIdentifier(\"1.3.132.0.17\")\n    SECT409K1 = ObjectIdentifier(\"1.3.132.0.36\")\n    SECT409R1 = ObjectIdentifier(\"1.3.132.0.37\")\n    SECT571K1 = ObjectIdentifier(\"1.3.132.0.38\")\n    SECT571R1 = ObjectIdentifier(\"1.3.132.0.39\")\n\n\nclass EllipticCurve(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The name of the curve. e.g. secp256r1.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n\nclass EllipticCurveSignatureAlgorithm(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def algorithm(\n        self,\n    ) -> asym_utils.Prehashed | hashes.HashAlgorithm:\n        \"\"\"\n        The digest algorithm used with this signature.\n        \"\"\"\n\n\nclass EllipticCurvePrivateKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def exchange(\n        self, algorithm: ECDH, peer_public_key: EllipticCurvePublicKey\n    ) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided algorithm with the\n        provided peer's public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> EllipticCurvePublicKey:\n        \"\"\"\n        The EllipticCurvePublicKey for this private key.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def curve(self) -> EllipticCurve:\n        \"\"\"\n        The EllipticCurve that this key is on.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        signature_algorithm: EllipticCurveSignatureAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> EllipticCurvePrivateNumbers:\n        \"\"\"\n        Returns an EllipticCurvePrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nEllipticCurvePrivateKeyWithSerialization = EllipticCurvePrivateKey\nEllipticCurvePrivateKey.register(rust_openssl.ec.ECPrivateKey)\n\n\nclass EllipticCurvePublicKey(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def curve(self) -> EllipticCurve:\n        \"\"\"\n        The EllipticCurve that this key is on.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        Bit size of a secret scalar for the curve.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> EllipticCurvePublicNumbers:\n        \"\"\"\n        Returns an EllipticCurvePublicNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        signature_algorithm: EllipticCurveSignatureAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @classmethod\n    def from_encoded_point(\n        cls, curve: EllipticCurve, data: bytes\n    ) -> EllipticCurvePublicKey:\n        utils._check_bytes(\"data\", data)\n\n        if len(data) == 0:\n            raise ValueError(\"data must not be an empty byte string\")\n\n        if data[0] not in [0x02, 0x03, 0x04]:\n            raise ValueError(\"Unsupported elliptic curve point type\")\n\n        return rust_openssl.ec.from_public_bytes(curve, data)\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nEllipticCurvePublicKeyWithSerialization = EllipticCurvePublicKey\nEllipticCurvePublicKey.register(rust_openssl.ec.ECPublicKey)\n\nEllipticCurvePrivateNumbers = rust_openssl.ec.EllipticCurvePrivateNumbers\nEllipticCurvePublicNumbers = rust_openssl.ec.EllipticCurvePublicNumbers\n\n\nclass SECT571R1(EllipticCurve):\n    name = \"sect571r1\"\n    key_size = 570\n\n\nclass SECT409R1(EllipticCurve):\n    name = \"sect409r1\"\n    key_size = 409\n\n\nclass SECT283R1(EllipticCurve):\n    name = \"sect283r1\"\n    key_size = 283\n\n\nclass SECT233R1(EllipticCurve):\n    name = \"sect233r1\"\n    key_size = 233\n\n\nclass SECT163R2(EllipticCurve):\n    name = \"sect163r2\"\n    key_size = 163\n\n\nclass SECT571K1(EllipticCurve):\n    name = \"sect571k1\"\n    key_size = 571\n\n\nclass SECT409K1(EllipticCurve):\n    name = \"sect409k1\"\n    key_size = 409\n\n\nclass SECT283K1(EllipticCurve):\n    name = \"sect283k1\"\n    key_size = 283\n\n\nclass SECT233K1(EllipticCurve):\n    name = \"sect233k1\"\n    key_size = 233\n\n\nclass SECT163K1(EllipticCurve):\n    name = \"sect163k1\"\n    key_size = 163\n\n\nclass SECP521R1(EllipticCurve):\n    name = \"secp521r1\"\n    key_size = 521\n\n\nclass SECP384R1(EllipticCurve):\n    name = \"secp384r1\"\n    key_size = 384\n\n\nclass SECP256R1(EllipticCurve):\n    name = \"secp256r1\"\n    key_size = 256\n\n\nclass SECP256K1(EllipticCurve):\n    name = \"secp256k1\"\n    key_size = 256\n\n\nclass SECP224R1(EllipticCurve):\n    name = \"secp224r1\"\n    key_size = 224\n\n\nclass SECP192R1(EllipticCurve):\n    name = \"secp192r1\"\n    key_size = 192\n\n\nclass BrainpoolP256R1(EllipticCurve):\n    name = \"brainpoolP256r1\"\n    key_size = 256\n\n\nclass BrainpoolP384R1(EllipticCurve):\n    name = \"brainpoolP384r1\"\n    key_size = 384\n\n\nclass BrainpoolP512R1(EllipticCurve):\n    name = \"brainpoolP512r1\"\n    key_size = 512\n\n\n_CURVE_TYPES: dict[str, EllipticCurve] = {\n    \"prime192v1\": SECP192R1(),\n    \"prime256v1\": SECP256R1(),\n    \"secp192r1\": SECP192R1(),\n    \"secp224r1\": SECP224R1(),\n    \"secp256r1\": SECP256R1(),\n    \"secp384r1\": SECP384R1(),\n    \"secp521r1\": SECP521R1(),\n    \"secp256k1\": SECP256K1(),\n    \"sect163k1\": SECT163K1(),\n    \"sect233k1\": SECT233K1(),\n    \"sect283k1\": SECT283K1(),\n    \"sect409k1\": SECT409K1(),\n    \"sect571k1\": SECT571K1(),\n    \"sect163r2\": SECT163R2(),\n    \"sect233r1\": SECT233R1(),\n    \"sect283r1\": SECT283R1(),\n    \"sect409r1\": SECT409R1(),\n    \"sect571r1\": SECT571R1(),\n    \"brainpoolP256r1\": BrainpoolP256R1(),\n    \"brainpoolP384r1\": BrainpoolP384R1(),\n    \"brainpoolP512r1\": BrainpoolP512R1(),\n}\n\n\nclass ECDSA(EllipticCurveSignatureAlgorithm):\n    def __init__(\n        self,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n        deterministic_signing: bool = False,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if (\n            deterministic_signing\n            and not backend.ecdsa_deterministic_supported()\n        ):\n            raise UnsupportedAlgorithm(\n                \"ECDSA with deterministic signature (RFC 6979) is not \"\n                \"supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n        self._algorithm = algorithm\n        self._deterministic_signing = deterministic_signing\n\n    @property\n    def algorithm(\n        self,\n    ) -> asym_utils.Prehashed | hashes.HashAlgorithm:\n        return self._algorithm\n\n    @property\n    def deterministic_signing(\n        self,\n    ) -> bool:\n        return self._deterministic_signing\n\n\ngenerate_private_key = rust_openssl.ec.generate_private_key\n\n\ndef derive_private_key(\n    private_value: int,\n    curve: EllipticCurve,\n    backend: typing.Any = None,\n) -> EllipticCurvePrivateKey:\n    if not isinstance(private_value, int):\n        raise TypeError(\"private_value must be an integer type.\")\n\n    if private_value <= 0:\n        raise ValueError(\"private_value must be a positive integer.\")\n\n    return rust_openssl.ec.derive_private_key(private_value, curve)\n\n\nclass ECDH:\n    pass\n\n\n_OID_TO_CURVE = {\n    EllipticCurveOID.SECP192R1: SECP192R1,\n    EllipticCurveOID.SECP224R1: SECP224R1,\n    EllipticCurveOID.SECP256K1: SECP256K1,\n    EllipticCurveOID.SECP256R1: SECP256R1,\n    EllipticCurveOID.SECP384R1: SECP384R1,\n    EllipticCurveOID.SECP521R1: SECP521R1,\n    EllipticCurveOID.BRAINPOOLP256R1: BrainpoolP256R1,\n    EllipticCurveOID.BRAINPOOLP384R1: BrainpoolP384R1,\n    EllipticCurveOID.BRAINPOOLP512R1: BrainpoolP512R1,\n    EllipticCurveOID.SECT163K1: SECT163K1,\n    EllipticCurveOID.SECT163R2: SECT163R2,\n    EllipticCurveOID.SECT233K1: SECT233K1,\n    EllipticCurveOID.SECT233R1: SECT233R1,\n    EllipticCurveOID.SECT283K1: SECT283K1,\n    EllipticCurveOID.SECT283R1: SECT283R1,\n    EllipticCurveOID.SECT409K1: SECT409K1,\n    EllipticCurveOID.SECT409R1: SECT409R1,\n    EllipticCurveOID.SECT571K1: SECT571K1,\n    EllipticCurveOID.SECT571R1: SECT571R1,\n}\n\n\ndef get_curve_for_oid(oid: ObjectIdentifier) -> type[EllipticCurve]:\n    try:\n        return _OID_TO_CURVE[oid]\n    except KeyError:\n        raise LookupError(\n            \"The provided object identifier has no matching elliptic \"\n            \"curve class\"\n        )\n", "src/cryptography/hazmat/primitives/asymmetric/utils.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import asn1\nfrom cryptography.hazmat.primitives import hashes\n\ndecode_dss_signature = asn1.decode_dss_signature\nencode_dss_signature = asn1.encode_dss_signature\n\n\nclass Prehashed:\n    def __init__(self, algorithm: hashes.HashAlgorithm):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of HashAlgorithm.\")\n\n        self._algorithm = algorithm\n        self._digest_size = algorithm.digest_size\n\n    @property\n    def digest_size(self) -> int:\n        return self._digest_size\n", "src/cryptography/hazmat/primitives/asymmetric/padding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives._asymmetric import (\n    AsymmetricPadding as AsymmetricPadding,\n)\nfrom cryptography.hazmat.primitives.asymmetric import rsa\n\n\nclass PKCS1v15(AsymmetricPadding):\n    name = \"EMSA-PKCS1-v1_5\"\n\n\nclass _MaxLength:\n    \"Sentinel value for `MAX_LENGTH`.\"\n\n\nclass _Auto:\n    \"Sentinel value for `AUTO`.\"\n\n\nclass _DigestLength:\n    \"Sentinel value for `DIGEST_LENGTH`.\"\n\n\nclass PSS(AsymmetricPadding):\n    MAX_LENGTH = _MaxLength()\n    AUTO = _Auto()\n    DIGEST_LENGTH = _DigestLength()\n    name = \"EMSA-PSS\"\n    _salt_length: int | _MaxLength | _Auto | _DigestLength\n\n    def __init__(\n        self,\n        mgf: MGF,\n        salt_length: int | _MaxLength | _Auto | _DigestLength,\n    ) -> None:\n        self._mgf = mgf\n\n        if not isinstance(\n            salt_length, (int, _MaxLength, _Auto, _DigestLength)\n        ):\n            raise TypeError(\n                \"salt_length must be an integer, MAX_LENGTH, \"\n                \"DIGEST_LENGTH, or AUTO\"\n            )\n\n        if isinstance(salt_length, int) and salt_length < 0:\n            raise ValueError(\"salt_length must be zero or greater.\")\n\n        self._salt_length = salt_length\n\n    @property\n    def mgf(self) -> MGF:\n        return self._mgf\n\n\nclass OAEP(AsymmetricPadding):\n    name = \"EME-OAEP\"\n\n    def __init__(\n        self,\n        mgf: MGF,\n        algorithm: hashes.HashAlgorithm,\n        label: bytes | None,\n    ):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of hashes.HashAlgorithm.\")\n\n        self._mgf = mgf\n        self._algorithm = algorithm\n        self._label = label\n\n    @property\n    def algorithm(self) -> hashes.HashAlgorithm:\n        return self._algorithm\n\n    @property\n    def mgf(self) -> MGF:\n        return self._mgf\n\n\nclass MGF(metaclass=abc.ABCMeta):\n    _algorithm: hashes.HashAlgorithm\n\n\nclass MGF1(MGF):\n    MAX_LENGTH = _MaxLength()\n\n    def __init__(self, algorithm: hashes.HashAlgorithm):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise TypeError(\"Expected instance of hashes.HashAlgorithm.\")\n\n        self._algorithm = algorithm\n\n\ndef calculate_max_pss_salt_length(\n    key: rsa.RSAPrivateKey | rsa.RSAPublicKey,\n    hash_algorithm: hashes.HashAlgorithm,\n) -> int:\n    if not isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):\n        raise TypeError(\"key must be an RSA public or private key\")\n    # bit length - 1 per RFC 3447\n    emlen = (key.key_size + 6) // 8\n    salt_length = emlen - hash_algorithm.digest_size - 2\n    assert salt_length >= 0\n    return salt_length\n", "src/cryptography/hazmat/primitives/asymmetric/ed448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass Ed448PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> Ed448PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, signature: bytes, data: bytes) -> None:\n        \"\"\"\n        Verify the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"ed448\"):\n    Ed448PublicKey.register(rust_openssl.ed448.Ed448PublicKey)\n\n\nclass Ed448PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> Ed448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> Ed448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed448_supported():\n            raise UnsupportedAlgorithm(\n                \"ed448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed448.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> Ed448PublicKey:\n        \"\"\"\n        The Ed448PublicKey derived from the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(self, data: bytes) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    Ed448PrivateKey.register(rust_openssl.ed448.Ed448PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/x25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass X25519PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> X25519PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x25519.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nX25519PublicKey.register(rust_openssl.x25519.X25519PublicKey)\n\n\nclass X25519PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> X25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n        return rust_openssl.x25519.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> X25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x25519_supported():\n            raise UnsupportedAlgorithm(\n                \"X25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x25519.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> X25519PublicKey:\n        \"\"\"\n        Returns the public key associated with this private key\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: X25519PublicKey) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided peer's public key.\n        \"\"\"\n\n\nX25519PrivateKey.register(rust_openssl.x25519.X25519PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/ed25519.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass Ed25519PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> Ed25519PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, signature: bytes, data: bytes) -> None:\n        \"\"\"\n        Verify the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nEd25519PublicKey.register(rust_openssl.ed25519.Ed25519PublicKey)\n\n\nclass Ed25519PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> Ed25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> Ed25519PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.ed25519_supported():\n            raise UnsupportedAlgorithm(\n                \"ed25519 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_PUBLIC_KEY_ALGORITHM,\n            )\n\n        return rust_openssl.ed25519.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> Ed25519PublicKey:\n        \"\"\"\n        The Ed25519PublicKey derived from the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(self, data: bytes) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n\nEd25519PrivateKey.register(rust_openssl.ed25519.Ed25519PrivateKey)\n", "src/cryptography/hazmat/primitives/asymmetric/types.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dh,\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n    x448,\n    x25519,\n)\n\n# Every asymmetric key type\nPublicKeyTypes = typing.Union[\n    dh.DHPublicKey,\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n    x25519.X25519PublicKey,\n    x448.X448PublicKey,\n]\nPUBLIC_KEY_TYPES = PublicKeyTypes\nutils.deprecated(\n    PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use PublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"PUBLIC_KEY_TYPES\",\n)\n# Every asymmetric key type\nPrivateKeyTypes = typing.Union[\n    dh.DHPrivateKey,\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n    x25519.X25519PrivateKey,\n    x448.X448PrivateKey,\n]\nPRIVATE_KEY_TYPES = PrivateKeyTypes\nutils.deprecated(\n    PRIVATE_KEY_TYPES,\n    __name__,\n    \"Use PrivateKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"PRIVATE_KEY_TYPES\",\n)\n# Just the key types we allow to be used for x509 signing. This mirrors\n# the certificate public key types\nCertificateIssuerPrivateKeyTypes = typing.Union[\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n]\nCERTIFICATE_PRIVATE_KEY_TYPES = CertificateIssuerPrivateKeyTypes\nutils.deprecated(\n    CERTIFICATE_PRIVATE_KEY_TYPES,\n    __name__,\n    \"Use CertificateIssuerPrivateKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_PRIVATE_KEY_TYPES\",\n)\n# Just the key types we allow to be used for x509 signing. This mirrors\n# the certificate private key types\nCertificateIssuerPublicKeyTypes = typing.Union[\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n]\nCERTIFICATE_ISSUER_PUBLIC_KEY_TYPES = CertificateIssuerPublicKeyTypes\nutils.deprecated(\n    CERTIFICATE_ISSUER_PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use CertificateIssuerPublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_ISSUER_PUBLIC_KEY_TYPES\",\n)\n# This type removes DHPublicKey. x448/x25519 can be a public key\n# but cannot be used in signing so they are allowed here.\nCertificatePublicKeyTypes = typing.Union[\n    dsa.DSAPublicKey,\n    rsa.RSAPublicKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PublicKey,\n    x25519.X25519PublicKey,\n    x448.X448PublicKey,\n]\nCERTIFICATE_PUBLIC_KEY_TYPES = CertificatePublicKeyTypes\nutils.deprecated(\n    CERTIFICATE_PUBLIC_KEY_TYPES,\n    __name__,\n    \"Use CertificatePublicKeyTypes instead\",\n    utils.DeprecatedIn40,\n    name=\"CERTIFICATE_PUBLIC_KEY_TYPES\",\n)\n", "src/cryptography/hazmat/primitives/asymmetric/rsa.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\nfrom math import gcd\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization, hashes\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\n\n\nclass RSAPrivateKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def decrypt(self, ciphertext: bytes, padding: AsymmetricPadding) -> bytes:\n        \"\"\"\n        Decrypts the provided ciphertext.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the public modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_key(self) -> RSAPublicKey:\n        \"\"\"\n        The RSAPublicKey associated with this private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def sign(\n        self,\n        data: bytes,\n        padding: AsymmetricPadding,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> bytes:\n        \"\"\"\n        Signs the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_numbers(self) -> RSAPrivateNumbers:\n        \"\"\"\n        Returns an RSAPrivateNumbers.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n\nRSAPrivateKeyWithSerialization = RSAPrivateKey\nRSAPrivateKey.register(rust_openssl.rsa.RSAPrivateKey)\n\n\nclass RSAPublicKey(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def encrypt(self, plaintext: bytes, padding: AsymmetricPadding) -> bytes:\n        \"\"\"\n        Encrypts the given plaintext.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def key_size(self) -> int:\n        \"\"\"\n        The bit length of the public modulus.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_numbers(self) -> RSAPublicNumbers:\n        \"\"\"\n        Returns an RSAPublicNumbers\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        Returns the key serialized as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(\n        self,\n        signature: bytes,\n        data: bytes,\n        padding: AsymmetricPadding,\n        algorithm: asym_utils.Prehashed | hashes.HashAlgorithm,\n    ) -> None:\n        \"\"\"\n        Verifies the signature of the data.\n        \"\"\"\n\n    @abc.abstractmethod\n    def recover_data_from_signature(\n        self,\n        signature: bytes,\n        padding: AsymmetricPadding,\n        algorithm: hashes.HashAlgorithm | None,\n    ) -> bytes:\n        \"\"\"\n        Recovers the original data from the signature.\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nRSAPublicKeyWithSerialization = RSAPublicKey\nRSAPublicKey.register(rust_openssl.rsa.RSAPublicKey)\n\nRSAPrivateNumbers = rust_openssl.rsa.RSAPrivateNumbers\nRSAPublicNumbers = rust_openssl.rsa.RSAPublicNumbers\n\n\ndef generate_private_key(\n    public_exponent: int,\n    key_size: int,\n    backend: typing.Any = None,\n) -> RSAPrivateKey:\n    _verify_rsa_parameters(public_exponent, key_size)\n    return rust_openssl.rsa.generate_private_key(public_exponent, key_size)\n\n\ndef _verify_rsa_parameters(public_exponent: int, key_size: int) -> None:\n    if public_exponent not in (3, 65537):\n        raise ValueError(\n            \"public_exponent must be either 3 (for legacy compatibility) or \"\n            \"65537. Almost everyone should choose 65537 here!\"\n        )\n\n    if key_size < 1024:\n        raise ValueError(\"key_size must be at least 1024-bits.\")\n\n\ndef _modinv(e: int, m: int) -> int:\n    \"\"\"\n    Modular Multiplicative Inverse. Returns x such that: (x*e) mod m == 1\n    \"\"\"\n    x1, x2 = 1, 0\n    a, b = e, m\n    while b > 0:\n        q, r = divmod(a, b)\n        xn = x1 - q * x2\n        a, b, x1, x2 = b, r, x2, xn\n    return x1 % m\n\n\ndef rsa_crt_iqmp(p: int, q: int) -> int:\n    \"\"\"\n    Compute the CRT (q ** -1) % p value from RSA primes p and q.\n    \"\"\"\n    return _modinv(q, p)\n\n\ndef rsa_crt_dmp1(private_exponent: int, p: int) -> int:\n    \"\"\"\n    Compute the CRT private_exponent % (p - 1) value from the RSA\n    private_exponent (d) and p.\n    \"\"\"\n    return private_exponent % (p - 1)\n\n\ndef rsa_crt_dmq1(private_exponent: int, q: int) -> int:\n    \"\"\"\n    Compute the CRT private_exponent % (q - 1) value from the RSA\n    private_exponent (d) and q.\n    \"\"\"\n    return private_exponent % (q - 1)\n\n\n# Controls the number of iterations rsa_recover_prime_factors will perform\n# to obtain the prime factors. Each iteration increments by 2 so the actual\n# maximum attempts is half this number.\n_MAX_RECOVERY_ATTEMPTS = 1000\n\n\ndef rsa_recover_prime_factors(n: int, e: int, d: int) -> tuple[int, int]:\n    \"\"\"\n    Compute factors p and q from the private exponent d. We assume that n has\n    no more than two factors. This function is adapted from code in PyCrypto.\n    \"\"\"\n    # See 8.2.2(i) in Handbook of Applied Cryptography.\n    ktot = d * e - 1\n    # The quantity d*e-1 is a multiple of phi(n), even,\n    # and can be represented as t*2^s.\n    t = ktot\n    while t % 2 == 0:\n        t = t // 2\n    # Cycle through all multiplicative inverses in Zn.\n    # The algorithm is non-deterministic, but there is a 50% chance\n    # any candidate a leads to successful factoring.\n    # See \"Digitalized Signatures and Public Key Functions as Intractable\n    # as Factorization\", M. Rabin, 1979\n    spotted = False\n    a = 2\n    while not spotted and a < _MAX_RECOVERY_ATTEMPTS:\n        k = t\n        # Cycle through all values a^{t*2^i}=a^k\n        while k < ktot:\n            cand = pow(a, k, n)\n            # Check if a^k is a non-trivial root of unity (mod n)\n            if cand != 1 and cand != (n - 1) and pow(cand, 2, n) == 1:\n                # We have found a number such that (cand-1)(cand+1)=0 (mod n).\n                # Either of the terms divides n.\n                p = gcd(cand + 1, n)\n                spotted = True\n                break\n            k *= 2\n        # This value was not any good... let's try another!\n        a += 2\n    if not spotted:\n        raise ValueError(\"Unable to compute factors p and q from exponent d.\")\n    # Found !\n    q, r = divmod(n, p)\n    assert r == 0\n    p, q = sorted((p, q), reverse=True)\n    return (p, q)\n", "src/cryptography/hazmat/primitives/asymmetric/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/primitives/asymmetric/x448.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import _serialization\n\n\nclass X448PublicKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def from_public_bytes(cls, data: bytes) -> X448PublicKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.from_public_bytes(data)\n\n    @abc.abstractmethod\n    def public_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PublicFormat,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the public key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def public_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the public key.\n        Equivalent to public_bytes(Raw, Raw).\n        \"\"\"\n\n    @abc.abstractmethod\n    def __eq__(self, other: object) -> bool:\n        \"\"\"\n        Checks equality.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    X448PublicKey.register(rust_openssl.x448.X448PublicKey)\n\n\nclass X448PrivateKey(metaclass=abc.ABCMeta):\n    @classmethod\n    def generate(cls) -> X448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.generate_key()\n\n    @classmethod\n    def from_private_bytes(cls, data: bytes) -> X448PrivateKey:\n        from cryptography.hazmat.backends.openssl.backend import backend\n\n        if not backend.x448_supported():\n            raise UnsupportedAlgorithm(\n                \"X448 is not supported by this version of OpenSSL.\",\n                _Reasons.UNSUPPORTED_EXCHANGE_ALGORITHM,\n            )\n\n        return rust_openssl.x448.from_private_bytes(data)\n\n    @abc.abstractmethod\n    def public_key(self) -> X448PublicKey:\n        \"\"\"\n        Returns the public key associated with this private key\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes(\n        self,\n        encoding: _serialization.Encoding,\n        format: _serialization.PrivateFormat,\n        encryption_algorithm: _serialization.KeySerializationEncryption,\n    ) -> bytes:\n        \"\"\"\n        The serialized bytes of the private key.\n        \"\"\"\n\n    @abc.abstractmethod\n    def private_bytes_raw(self) -> bytes:\n        \"\"\"\n        The raw bytes of the private key.\n        Equivalent to private_bytes(Raw, Raw, NoEncryption()).\n        \"\"\"\n\n    @abc.abstractmethod\n    def exchange(self, peer_public_key: X448PublicKey) -> bytes:\n        \"\"\"\n        Performs a key exchange operation using the provided peer's public key.\n        \"\"\"\n\n\nif hasattr(rust_openssl, \"x448\"):\n    X448PrivateKey.register(rust_openssl.x448.X448PrivateKey)\n", "src/cryptography/hazmat/primitives/serialization/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\nload_pem_private_key = rust_openssl.keys.load_pem_private_key\nload_der_private_key = rust_openssl.keys.load_der_private_key\n\nload_pem_public_key = rust_openssl.keys.load_pem_public_key\nload_der_public_key = rust_openssl.keys.load_der_public_key\n\nload_pem_parameters = rust_openssl.dh.from_pem_parameters\nload_der_parameters = rust_openssl.dh.from_der_parameters\n", "src/cryptography/hazmat/primitives/serialization/pkcs12.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import x509\nfrom cryptography.hazmat.bindings._rust import pkcs12 as rust_pkcs12\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives._serialization import PBES as PBES\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.asymmetric.types import PrivateKeyTypes\n\n__all__ = [\n    \"PBES\",\n    \"PKCS12Certificate\",\n    \"PKCS12KeyAndCertificates\",\n    \"PKCS12PrivateKeyTypes\",\n    \"load_key_and_certificates\",\n    \"load_pkcs12\",\n    \"serialize_key_and_certificates\",\n]\n\nPKCS12PrivateKeyTypes = typing.Union[\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ec.EllipticCurvePrivateKey,\n    ed25519.Ed25519PrivateKey,\n    ed448.Ed448PrivateKey,\n]\n\n\nPKCS12Certificate = rust_pkcs12.PKCS12Certificate\n\n\nclass PKCS12KeyAndCertificates:\n    def __init__(\n        self,\n        key: PrivateKeyTypes | None,\n        cert: PKCS12Certificate | None,\n        additional_certs: list[PKCS12Certificate],\n    ):\n        if key is not None and not isinstance(\n            key,\n            (\n                rsa.RSAPrivateKey,\n                dsa.DSAPrivateKey,\n                ec.EllipticCurvePrivateKey,\n                ed25519.Ed25519PrivateKey,\n                ed448.Ed448PrivateKey,\n            ),\n        ):\n            raise TypeError(\n                \"Key must be RSA, DSA, EllipticCurve, ED25519, or ED448\"\n                \" private key, or None.\"\n            )\n        if cert is not None and not isinstance(cert, PKCS12Certificate):\n            raise TypeError(\"cert must be a PKCS12Certificate object or None\")\n        if not all(\n            isinstance(add_cert, PKCS12Certificate)\n            for add_cert in additional_certs\n        ):\n            raise TypeError(\n                \"all values in additional_certs must be PKCS12Certificate\"\n                \" objects\"\n            )\n        self._key = key\n        self._cert = cert\n        self._additional_certs = additional_certs\n\n    @property\n    def key(self) -> PrivateKeyTypes | None:\n        return self._key\n\n    @property\n    def cert(self) -> PKCS12Certificate | None:\n        return self._cert\n\n    @property\n    def additional_certs(self) -> list[PKCS12Certificate]:\n        return self._additional_certs\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, PKCS12KeyAndCertificates):\n            return NotImplemented\n\n        return (\n            self.key == other.key\n            and self.cert == other.cert\n            and self.additional_certs == other.additional_certs\n        )\n\n    def __hash__(self) -> int:\n        return hash((self.key, self.cert, tuple(self.additional_certs)))\n\n    def __repr__(self) -> str:\n        fmt = (\n            \"<PKCS12KeyAndCertificates(key={}, cert={}, additional_certs={})>\"\n        )\n        return fmt.format(self.key, self.cert, self.additional_certs)\n\n\nload_key_and_certificates = rust_pkcs12.load_key_and_certificates\nload_pkcs12 = rust_pkcs12.load_pkcs12\n\n\n_PKCS12CATypes = typing.Union[\n    x509.Certificate,\n    PKCS12Certificate,\n]\n\n\ndef serialize_key_and_certificates(\n    name: bytes | None,\n    key: PKCS12PrivateKeyTypes | None,\n    cert: x509.Certificate | None,\n    cas: typing.Iterable[_PKCS12CATypes] | None,\n    encryption_algorithm: serialization.KeySerializationEncryption,\n) -> bytes:\n    if key is not None and not isinstance(\n        key,\n        (\n            rsa.RSAPrivateKey,\n            dsa.DSAPrivateKey,\n            ec.EllipticCurvePrivateKey,\n            ed25519.Ed25519PrivateKey,\n            ed448.Ed448PrivateKey,\n        ),\n    ):\n        raise TypeError(\n            \"Key must be RSA, DSA, EllipticCurve, ED25519, or ED448\"\n            \" private key, or None.\"\n        )\n    if cert is not None and not isinstance(cert, x509.Certificate):\n        raise TypeError(\"cert must be a certificate or None\")\n\n    if cas is not None:\n        cas = list(cas)\n        if not all(\n            isinstance(\n                val,\n                (\n                    x509.Certificate,\n                    PKCS12Certificate,\n                ),\n            )\n            for val in cas\n        ):\n            raise TypeError(\"all values in cas must be certificates\")\n\n    if not isinstance(\n        encryption_algorithm, serialization.KeySerializationEncryption\n    ):\n        raise TypeError(\n            \"Key encryption algorithm must be a \"\n            \"KeySerializationEncryption instance\"\n        )\n\n    if key is None and cert is None and not cas:\n        raise ValueError(\"You must supply at least one of key, cert, or cas\")\n\n    if isinstance(encryption_algorithm, serialization.NoEncryption):\n        return rust_pkcs12.serialize_key_and_certificates(\n            name, key, cert, cas, encryption_algorithm\n        )\n\n    from cryptography.hazmat.backends.openssl.backend import backend\n\n    return backend.serialize_key_and_certificates_to_pkcs12(\n        name, key, cert, cas, encryption_algorithm\n    )\n", "src/cryptography/hazmat/primitives/serialization/ssh.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport binascii\nimport enum\nimport os\nimport re\nimport typing\nimport warnings\nfrom base64 import encodebytes as _base64_encode\nfrom dataclasses import dataclass\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed25519,\n    padding,\n    rsa,\n)\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\nfrom cryptography.hazmat.primitives.ciphers import (\n    AEADDecryptionContext,\n    Cipher,\n    algorithms,\n    modes,\n)\nfrom cryptography.hazmat.primitives.serialization import (\n    Encoding,\n    KeySerializationEncryption,\n    NoEncryption,\n    PrivateFormat,\n    PublicFormat,\n    _KeySerializationEncryption,\n)\n\ntry:\n    from bcrypt import kdf as _bcrypt_kdf\n\n    _bcrypt_supported = True\nexcept ImportError:\n    _bcrypt_supported = False\n\n    def _bcrypt_kdf(\n        password: bytes,\n        salt: bytes,\n        desired_key_bytes: int,\n        rounds: int,\n        ignore_few_rounds: bool = False,\n    ) -> bytes:\n        raise UnsupportedAlgorithm(\"Need bcrypt module\")\n\n\n_SSH_ED25519 = b\"ssh-ed25519\"\n_SSH_RSA = b\"ssh-rsa\"\n_SSH_DSA = b\"ssh-dss\"\n_ECDSA_NISTP256 = b\"ecdsa-sha2-nistp256\"\n_ECDSA_NISTP384 = b\"ecdsa-sha2-nistp384\"\n_ECDSA_NISTP521 = b\"ecdsa-sha2-nistp521\"\n_CERT_SUFFIX = b\"-cert-v01@openssh.com\"\n\n# U2F application string suffixed pubkey\n_SK_SSH_ED25519 = b\"sk-ssh-ed25519@openssh.com\"\n_SK_SSH_ECDSA_NISTP256 = b\"sk-ecdsa-sha2-nistp256@openssh.com\"\n\n# These are not key types, only algorithms, so they cannot appear\n# as a public key type\n_SSH_RSA_SHA256 = b\"rsa-sha2-256\"\n_SSH_RSA_SHA512 = b\"rsa-sha2-512\"\n\n_SSH_PUBKEY_RC = re.compile(rb\"\\A(\\S+)[ \\t]+(\\S+)\")\n_SK_MAGIC = b\"openssh-key-v1\\0\"\n_SK_START = b\"-----BEGIN OPENSSH PRIVATE KEY-----\"\n_SK_END = b\"-----END OPENSSH PRIVATE KEY-----\"\n_BCRYPT = b\"bcrypt\"\n_NONE = b\"none\"\n_DEFAULT_CIPHER = b\"aes256-ctr\"\n_DEFAULT_ROUNDS = 16\n\n# re is only way to work on bytes-like data\n_PEM_RC = re.compile(_SK_START + b\"(.*?)\" + _SK_END, re.DOTALL)\n\n# padding for max blocksize\n_PADDING = memoryview(bytearray(range(1, 1 + 16)))\n\n\n@dataclass\nclass _SSHCipher:\n    alg: type[algorithms.AES]\n    key_len: int\n    mode: type[modes.CTR] | type[modes.CBC] | type[modes.GCM]\n    block_len: int\n    iv_len: int\n    tag_len: int | None\n    is_aead: bool\n\n\n# ciphers that are actually used in key wrapping\n_SSH_CIPHERS: dict[bytes, _SSHCipher] = {\n    b\"aes256-ctr\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.CTR,\n        block_len=16,\n        iv_len=16,\n        tag_len=None,\n        is_aead=False,\n    ),\n    b\"aes256-cbc\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.CBC,\n        block_len=16,\n        iv_len=16,\n        tag_len=None,\n        is_aead=False,\n    ),\n    b\"aes256-gcm@openssh.com\": _SSHCipher(\n        alg=algorithms.AES,\n        key_len=32,\n        mode=modes.GCM,\n        block_len=16,\n        iv_len=12,\n        tag_len=16,\n        is_aead=True,\n    ),\n}\n\n# map local curve name to key type\n_ECDSA_KEY_TYPE = {\n    \"secp256r1\": _ECDSA_NISTP256,\n    \"secp384r1\": _ECDSA_NISTP384,\n    \"secp521r1\": _ECDSA_NISTP521,\n}\n\n\ndef _get_ssh_key_type(key: SSHPrivateKeyTypes | SSHPublicKeyTypes) -> bytes:\n    if isinstance(key, ec.EllipticCurvePrivateKey):\n        key_type = _ecdsa_key_type(key.public_key())\n    elif isinstance(key, ec.EllipticCurvePublicKey):\n        key_type = _ecdsa_key_type(key)\n    elif isinstance(key, (rsa.RSAPrivateKey, rsa.RSAPublicKey)):\n        key_type = _SSH_RSA\n    elif isinstance(key, (dsa.DSAPrivateKey, dsa.DSAPublicKey)):\n        key_type = _SSH_DSA\n    elif isinstance(\n        key, (ed25519.Ed25519PrivateKey, ed25519.Ed25519PublicKey)\n    ):\n        key_type = _SSH_ED25519\n    else:\n        raise ValueError(\"Unsupported key type\")\n\n    return key_type\n\n\ndef _ecdsa_key_type(public_key: ec.EllipticCurvePublicKey) -> bytes:\n    \"\"\"Return SSH key_type and curve_name for private key.\"\"\"\n    curve = public_key.curve\n    if curve.name not in _ECDSA_KEY_TYPE:\n        raise ValueError(\n            f\"Unsupported curve for ssh private key: {curve.name!r}\"\n        )\n    return _ECDSA_KEY_TYPE[curve.name]\n\n\ndef _ssh_pem_encode(\n    data: bytes,\n    prefix: bytes = _SK_START + b\"\\n\",\n    suffix: bytes = _SK_END + b\"\\n\",\n) -> bytes:\n    return b\"\".join([prefix, _base64_encode(data), suffix])\n\n\ndef _check_block_size(data: bytes, block_len: int) -> None:\n    \"\"\"Require data to be full blocks\"\"\"\n    if not data or len(data) % block_len != 0:\n        raise ValueError(\"Corrupt data: missing padding\")\n\n\ndef _check_empty(data: bytes) -> None:\n    \"\"\"All data should have been parsed.\"\"\"\n    if data:\n        raise ValueError(\"Corrupt data: unparsed data\")\n\n\ndef _init_cipher(\n    ciphername: bytes,\n    password: bytes | None,\n    salt: bytes,\n    rounds: int,\n) -> Cipher[modes.CBC | modes.CTR | modes.GCM]:\n    \"\"\"Generate key + iv and return cipher.\"\"\"\n    if not password:\n        raise ValueError(\"Key is password-protected.\")\n\n    ciph = _SSH_CIPHERS[ciphername]\n    seed = _bcrypt_kdf(\n        password, salt, ciph.key_len + ciph.iv_len, rounds, True\n    )\n    return Cipher(\n        ciph.alg(seed[: ciph.key_len]),\n        ciph.mode(seed[ciph.key_len :]),\n    )\n\n\ndef _get_u32(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Uint32\"\"\"\n    if len(data) < 4:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(data[:4], byteorder=\"big\"), data[4:]\n\n\ndef _get_u64(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Uint64\"\"\"\n    if len(data) < 8:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(data[:8], byteorder=\"big\"), data[8:]\n\n\ndef _get_sshstr(data: memoryview) -> tuple[memoryview, memoryview]:\n    \"\"\"Bytes with u32 length prefix\"\"\"\n    n, data = _get_u32(data)\n    if n > len(data):\n        raise ValueError(\"Invalid data\")\n    return data[:n], data[n:]\n\n\ndef _get_mpint(data: memoryview) -> tuple[int, memoryview]:\n    \"\"\"Big integer.\"\"\"\n    val, data = _get_sshstr(data)\n    if val and val[0] > 0x7F:\n        raise ValueError(\"Invalid data\")\n    return int.from_bytes(val, \"big\"), data\n\n\ndef _to_mpint(val: int) -> bytes:\n    \"\"\"Storage format for signed bigint.\"\"\"\n    if val < 0:\n        raise ValueError(\"negative mpint not allowed\")\n    if not val:\n        return b\"\"\n    nbytes = (val.bit_length() + 8) // 8\n    return utils.int_to_bytes(val, nbytes)\n\n\nclass _FragList:\n    \"\"\"Build recursive structure without data copy.\"\"\"\n\n    flist: list[bytes]\n\n    def __init__(self, init: list[bytes] | None = None) -> None:\n        self.flist = []\n        if init:\n            self.flist.extend(init)\n\n    def put_raw(self, val: bytes) -> None:\n        \"\"\"Add plain bytes\"\"\"\n        self.flist.append(val)\n\n    def put_u32(self, val: int) -> None:\n        \"\"\"Big-endian uint32\"\"\"\n        self.flist.append(val.to_bytes(length=4, byteorder=\"big\"))\n\n    def put_u64(self, val: int) -> None:\n        \"\"\"Big-endian uint64\"\"\"\n        self.flist.append(val.to_bytes(length=8, byteorder=\"big\"))\n\n    def put_sshstr(self, val: bytes | _FragList) -> None:\n        \"\"\"Bytes prefixed with u32 length\"\"\"\n        if isinstance(val, (bytes, memoryview, bytearray)):\n            self.put_u32(len(val))\n            self.flist.append(val)\n        else:\n            self.put_u32(val.size())\n            self.flist.extend(val.flist)\n\n    def put_mpint(self, val: int) -> None:\n        \"\"\"Big-endian bigint prefixed with u32 length\"\"\"\n        self.put_sshstr(_to_mpint(val))\n\n    def size(self) -> int:\n        \"\"\"Current number of bytes\"\"\"\n        return sum(map(len, self.flist))\n\n    def render(self, dstbuf: memoryview, pos: int = 0) -> int:\n        \"\"\"Write into bytearray\"\"\"\n        for frag in self.flist:\n            flen = len(frag)\n            start, pos = pos, pos + flen\n            dstbuf[start:pos] = frag\n        return pos\n\n    def tobytes(self) -> bytes:\n        \"\"\"Return as bytes\"\"\"\n        buf = memoryview(bytearray(self.size()))\n        self.render(buf)\n        return buf.tobytes()\n\n\nclass _SSHFormatRSA:\n    \"\"\"Format for RSA keys.\n\n    Public:\n        mpint e, n\n    Private:\n        mpint n, e, d, iqmp, p, q\n    \"\"\"\n\n    def get_public(self, data: memoryview):\n        \"\"\"RSA public fields\"\"\"\n        e, data = _get_mpint(data)\n        n, data = _get_mpint(data)\n        return (e, n), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[rsa.RSAPublicKey, memoryview]:\n        \"\"\"Make RSA public key from data.\"\"\"\n        (e, n), data = self.get_public(data)\n        public_numbers = rsa.RSAPublicNumbers(e, n)\n        public_key = public_numbers.public_key()\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[rsa.RSAPrivateKey, memoryview]:\n        \"\"\"Make RSA private key from data.\"\"\"\n        n, data = _get_mpint(data)\n        e, data = _get_mpint(data)\n        d, data = _get_mpint(data)\n        iqmp, data = _get_mpint(data)\n        p, data = _get_mpint(data)\n        q, data = _get_mpint(data)\n\n        if (e, n) != pubfields:\n            raise ValueError(\"Corrupt data: rsa field mismatch\")\n        dmp1 = rsa.rsa_crt_dmp1(d, p)\n        dmq1 = rsa.rsa_crt_dmq1(d, q)\n        public_numbers = rsa.RSAPublicNumbers(e, n)\n        private_numbers = rsa.RSAPrivateNumbers(\n            p, q, d, dmp1, dmq1, iqmp, public_numbers\n        )\n        private_key = private_numbers.private_key()\n        return private_key, data\n\n    def encode_public(\n        self, public_key: rsa.RSAPublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write RSA public key\"\"\"\n        pubn = public_key.public_numbers()\n        f_pub.put_mpint(pubn.e)\n        f_pub.put_mpint(pubn.n)\n\n    def encode_private(\n        self, private_key: rsa.RSAPrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write RSA private key\"\"\"\n        private_numbers = private_key.private_numbers()\n        public_numbers = private_numbers.public_numbers\n\n        f_priv.put_mpint(public_numbers.n)\n        f_priv.put_mpint(public_numbers.e)\n\n        f_priv.put_mpint(private_numbers.d)\n        f_priv.put_mpint(private_numbers.iqmp)\n        f_priv.put_mpint(private_numbers.p)\n        f_priv.put_mpint(private_numbers.q)\n\n\nclass _SSHFormatDSA:\n    \"\"\"Format for DSA keys.\n\n    Public:\n        mpint p, q, g, y\n    Private:\n        mpint p, q, g, y, x\n    \"\"\"\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"DSA public fields\"\"\"\n        p, data = _get_mpint(data)\n        q, data = _get_mpint(data)\n        g, data = _get_mpint(data)\n        y, data = _get_mpint(data)\n        return (p, q, g, y), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[dsa.DSAPublicKey, memoryview]:\n        \"\"\"Make DSA public key from data.\"\"\"\n        (p, q, g, y), data = self.get_public(data)\n        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)\n        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)\n        self._validate(public_numbers)\n        public_key = public_numbers.public_key()\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[dsa.DSAPrivateKey, memoryview]:\n        \"\"\"Make DSA private key from data.\"\"\"\n        (p, q, g, y), data = self.get_public(data)\n        x, data = _get_mpint(data)\n\n        if (p, q, g, y) != pubfields:\n            raise ValueError(\"Corrupt data: dsa field mismatch\")\n        parameter_numbers = dsa.DSAParameterNumbers(p, q, g)\n        public_numbers = dsa.DSAPublicNumbers(y, parameter_numbers)\n        self._validate(public_numbers)\n        private_numbers = dsa.DSAPrivateNumbers(x, public_numbers)\n        private_key = private_numbers.private_key()\n        return private_key, data\n\n    def encode_public(\n        self, public_key: dsa.DSAPublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write DSA public key\"\"\"\n        public_numbers = public_key.public_numbers()\n        parameter_numbers = public_numbers.parameter_numbers\n        self._validate(public_numbers)\n\n        f_pub.put_mpint(parameter_numbers.p)\n        f_pub.put_mpint(parameter_numbers.q)\n        f_pub.put_mpint(parameter_numbers.g)\n        f_pub.put_mpint(public_numbers.y)\n\n    def encode_private(\n        self, private_key: dsa.DSAPrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write DSA private key\"\"\"\n        self.encode_public(private_key.public_key(), f_priv)\n        f_priv.put_mpint(private_key.private_numbers().x)\n\n    def _validate(self, public_numbers: dsa.DSAPublicNumbers) -> None:\n        parameter_numbers = public_numbers.parameter_numbers\n        if parameter_numbers.p.bit_length() != 1024:\n            raise ValueError(\"SSH supports only 1024 bit DSA keys\")\n\n\nclass _SSHFormatECDSA:\n    \"\"\"Format for ECDSA keys.\n\n    Public:\n        str curve\n        bytes point\n    Private:\n        str curve\n        bytes point\n        mpint secret\n    \"\"\"\n\n    def __init__(self, ssh_curve_name: bytes, curve: ec.EllipticCurve):\n        self.ssh_curve_name = ssh_curve_name\n        self.curve = curve\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"ECDSA public fields\"\"\"\n        curve, data = _get_sshstr(data)\n        point, data = _get_sshstr(data)\n        if curve != self.ssh_curve_name:\n            raise ValueError(\"Curve name mismatch\")\n        if point[0] != 4:\n            raise NotImplementedError(\"Need uncompressed point\")\n        return (curve, point), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ec.EllipticCurvePublicKey, memoryview]:\n        \"\"\"Make ECDSA public key from data.\"\"\"\n        (_, point), data = self.get_public(data)\n        public_key = ec.EllipticCurvePublicKey.from_encoded_point(\n            self.curve, point.tobytes()\n        )\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[ec.EllipticCurvePrivateKey, memoryview]:\n        \"\"\"Make ECDSA private key from data.\"\"\"\n        (curve_name, point), data = self.get_public(data)\n        secret, data = _get_mpint(data)\n\n        if (curve_name, point) != pubfields:\n            raise ValueError(\"Corrupt data: ecdsa field mismatch\")\n        private_key = ec.derive_private_key(secret, self.curve)\n        return private_key, data\n\n    def encode_public(\n        self, public_key: ec.EllipticCurvePublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write ECDSA public key\"\"\"\n        point = public_key.public_bytes(\n            Encoding.X962, PublicFormat.UncompressedPoint\n        )\n        f_pub.put_sshstr(self.ssh_curve_name)\n        f_pub.put_sshstr(point)\n\n    def encode_private(\n        self, private_key: ec.EllipticCurvePrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write ECDSA private key\"\"\"\n        public_key = private_key.public_key()\n        private_numbers = private_key.private_numbers()\n\n        self.encode_public(public_key, f_priv)\n        f_priv.put_mpint(private_numbers.private_value)\n\n\nclass _SSHFormatEd25519:\n    \"\"\"Format for Ed25519 keys.\n\n    Public:\n        bytes point\n    Private:\n        bytes point\n        bytes secret_and_point\n    \"\"\"\n\n    def get_public(self, data: memoryview) -> tuple[tuple, memoryview]:\n        \"\"\"Ed25519 public fields\"\"\"\n        point, data = _get_sshstr(data)\n        return (point,), data\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ed25519.Ed25519PublicKey, memoryview]:\n        \"\"\"Make Ed25519 public key from data.\"\"\"\n        (point,), data = self.get_public(data)\n        public_key = ed25519.Ed25519PublicKey.from_public_bytes(\n            point.tobytes()\n        )\n        return public_key, data\n\n    def load_private(\n        self, data: memoryview, pubfields\n    ) -> tuple[ed25519.Ed25519PrivateKey, memoryview]:\n        \"\"\"Make Ed25519 private key from data.\"\"\"\n        (point,), data = self.get_public(data)\n        keypair, data = _get_sshstr(data)\n\n        secret = keypair[:32]\n        point2 = keypair[32:]\n        if point != point2 or (point,) != pubfields:\n            raise ValueError(\"Corrupt data: ed25519 field mismatch\")\n        private_key = ed25519.Ed25519PrivateKey.from_private_bytes(secret)\n        return private_key, data\n\n    def encode_public(\n        self, public_key: ed25519.Ed25519PublicKey, f_pub: _FragList\n    ) -> None:\n        \"\"\"Write Ed25519 public key\"\"\"\n        raw_public_key = public_key.public_bytes(\n            Encoding.Raw, PublicFormat.Raw\n        )\n        f_pub.put_sshstr(raw_public_key)\n\n    def encode_private(\n        self, private_key: ed25519.Ed25519PrivateKey, f_priv: _FragList\n    ) -> None:\n        \"\"\"Write Ed25519 private key\"\"\"\n        public_key = private_key.public_key()\n        raw_private_key = private_key.private_bytes(\n            Encoding.Raw, PrivateFormat.Raw, NoEncryption()\n        )\n        raw_public_key = public_key.public_bytes(\n            Encoding.Raw, PublicFormat.Raw\n        )\n        f_keypair = _FragList([raw_private_key, raw_public_key])\n\n        self.encode_public(public_key, f_priv)\n        f_priv.put_sshstr(f_keypair)\n\n\ndef load_application(data) -> tuple[memoryview, memoryview]:\n    \"\"\"\n    U2F application strings\n    \"\"\"\n    application, data = _get_sshstr(data)\n    if not application.tobytes().startswith(b\"ssh:\"):\n        raise ValueError(\n            \"U2F application string does not start with b'ssh:' \"\n            f\"({application})\"\n        )\n    return application, data\n\n\nclass _SSHFormatSKEd25519:\n    \"\"\"\n    The format of a sk-ssh-ed25519@openssh.com public key is:\n\n        string\t\t\"sk-ssh-ed25519@openssh.com\"\n        string\t\tpublic key\n        string\t\tapplication (user-specified, but typically \"ssh:\")\n    \"\"\"\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ed25519.Ed25519PublicKey, memoryview]:\n        \"\"\"Make Ed25519 public key from data.\"\"\"\n        public_key, data = _lookup_kformat(_SSH_ED25519).load_public(data)\n        _, data = load_application(data)\n        return public_key, data\n\n\nclass _SSHFormatSKECDSA:\n    \"\"\"\n    The format of a sk-ecdsa-sha2-nistp256@openssh.com public key is:\n\n        string\t\t\"sk-ecdsa-sha2-nistp256@openssh.com\"\n        string\t\tcurve name\n        ec_point\tQ\n        string\t\tapplication (user-specified, but typically \"ssh:\")\n    \"\"\"\n\n    def load_public(\n        self, data: memoryview\n    ) -> tuple[ec.EllipticCurvePublicKey, memoryview]:\n        \"\"\"Make ECDSA public key from data.\"\"\"\n        public_key, data = _lookup_kformat(_ECDSA_NISTP256).load_public(data)\n        _, data = load_application(data)\n        return public_key, data\n\n\n_KEY_FORMATS = {\n    _SSH_RSA: _SSHFormatRSA(),\n    _SSH_DSA: _SSHFormatDSA(),\n    _SSH_ED25519: _SSHFormatEd25519(),\n    _ECDSA_NISTP256: _SSHFormatECDSA(b\"nistp256\", ec.SECP256R1()),\n    _ECDSA_NISTP384: _SSHFormatECDSA(b\"nistp384\", ec.SECP384R1()),\n    _ECDSA_NISTP521: _SSHFormatECDSA(b\"nistp521\", ec.SECP521R1()),\n    _SK_SSH_ED25519: _SSHFormatSKEd25519(),\n    _SK_SSH_ECDSA_NISTP256: _SSHFormatSKECDSA(),\n}\n\n\ndef _lookup_kformat(key_type: bytes):\n    \"\"\"Return valid format or throw error\"\"\"\n    if not isinstance(key_type, bytes):\n        key_type = memoryview(key_type).tobytes()\n    if key_type in _KEY_FORMATS:\n        return _KEY_FORMATS[key_type]\n    raise UnsupportedAlgorithm(f\"Unsupported key type: {key_type!r}\")\n\n\nSSHPrivateKeyTypes = typing.Union[\n    ec.EllipticCurvePrivateKey,\n    rsa.RSAPrivateKey,\n    dsa.DSAPrivateKey,\n    ed25519.Ed25519PrivateKey,\n]\n\n\ndef load_ssh_private_key(\n    data: bytes,\n    password: bytes | None,\n    backend: typing.Any = None,\n) -> SSHPrivateKeyTypes:\n    \"\"\"Load private key from OpenSSH custom encoding.\"\"\"\n    utils._check_byteslike(\"data\", data)\n    if password is not None:\n        utils._check_bytes(\"password\", password)\n\n    m = _PEM_RC.search(data)\n    if not m:\n        raise ValueError(\"Not OpenSSH private key format\")\n    p1 = m.start(1)\n    p2 = m.end(1)\n    data = binascii.a2b_base64(memoryview(data)[p1:p2])\n    if not data.startswith(_SK_MAGIC):\n        raise ValueError(\"Not OpenSSH private key format\")\n    data = memoryview(data)[len(_SK_MAGIC) :]\n\n    # parse header\n    ciphername, data = _get_sshstr(data)\n    kdfname, data = _get_sshstr(data)\n    kdfoptions, data = _get_sshstr(data)\n    nkeys, data = _get_u32(data)\n    if nkeys != 1:\n        raise ValueError(\"Only one key supported\")\n\n    # load public key data\n    pubdata, data = _get_sshstr(data)\n    pub_key_type, pubdata = _get_sshstr(pubdata)\n    kformat = _lookup_kformat(pub_key_type)\n    pubfields, pubdata = kformat.get_public(pubdata)\n    _check_empty(pubdata)\n\n    if (ciphername, kdfname) != (_NONE, _NONE):\n        ciphername_bytes = ciphername.tobytes()\n        if ciphername_bytes not in _SSH_CIPHERS:\n            raise UnsupportedAlgorithm(\n                f\"Unsupported cipher: {ciphername_bytes!r}\"\n            )\n        if kdfname != _BCRYPT:\n            raise UnsupportedAlgorithm(f\"Unsupported KDF: {kdfname!r}\")\n        blklen = _SSH_CIPHERS[ciphername_bytes].block_len\n        tag_len = _SSH_CIPHERS[ciphername_bytes].tag_len\n        # load secret data\n        edata, data = _get_sshstr(data)\n        # see https://bugzilla.mindrot.org/show_bug.cgi?id=3553 for\n        # information about how OpenSSH handles AEAD tags\n        if _SSH_CIPHERS[ciphername_bytes].is_aead:\n            tag = bytes(data)\n            if len(tag) != tag_len:\n                raise ValueError(\"Corrupt data: invalid tag length for cipher\")\n        else:\n            _check_empty(data)\n        _check_block_size(edata, blklen)\n        salt, kbuf = _get_sshstr(kdfoptions)\n        rounds, kbuf = _get_u32(kbuf)\n        _check_empty(kbuf)\n        ciph = _init_cipher(ciphername_bytes, password, salt.tobytes(), rounds)\n        dec = ciph.decryptor()\n        edata = memoryview(dec.update(edata))\n        if _SSH_CIPHERS[ciphername_bytes].is_aead:\n            assert isinstance(dec, AEADDecryptionContext)\n            _check_empty(dec.finalize_with_tag(tag))\n        else:\n            # _check_block_size requires data to be a full block so there\n            # should be no output from finalize\n            _check_empty(dec.finalize())\n    else:\n        # load secret data\n        edata, data = _get_sshstr(data)\n        _check_empty(data)\n        blklen = 8\n        _check_block_size(edata, blklen)\n    ck1, edata = _get_u32(edata)\n    ck2, edata = _get_u32(edata)\n    if ck1 != ck2:\n        raise ValueError(\"Corrupt data: broken checksum\")\n\n    # load per-key struct\n    key_type, edata = _get_sshstr(edata)\n    if key_type != pub_key_type:\n        raise ValueError(\"Corrupt data: key type mismatch\")\n    private_key, edata = kformat.load_private(edata, pubfields)\n    # We don't use the comment\n    _, edata = _get_sshstr(edata)\n\n    # yes, SSH does padding check *after* all other parsing is done.\n    # need to follow as it writes zero-byte padding too.\n    if edata != _PADDING[: len(edata)]:\n        raise ValueError(\"Corrupt data: invalid padding\")\n\n    if isinstance(private_key, dsa.DSAPrivateKey):\n        warnings.warn(\n            \"SSH DSA keys are deprecated and will be removed in a future \"\n            \"release.\",\n            utils.DeprecatedIn40,\n            stacklevel=2,\n        )\n\n    return private_key\n\n\ndef _serialize_ssh_private_key(\n    private_key: SSHPrivateKeyTypes,\n    password: bytes,\n    encryption_algorithm: KeySerializationEncryption,\n) -> bytes:\n    \"\"\"Serialize private key with OpenSSH custom encoding.\"\"\"\n    utils._check_bytes(\"password\", password)\n    if isinstance(private_key, dsa.DSAPrivateKey):\n        warnings.warn(\n            \"SSH DSA key support is deprecated and will be \"\n            \"removed in a future release\",\n            utils.DeprecatedIn40,\n            stacklevel=4,\n        )\n\n    key_type = _get_ssh_key_type(private_key)\n    kformat = _lookup_kformat(key_type)\n\n    # setup parameters\n    f_kdfoptions = _FragList()\n    if password:\n        ciphername = _DEFAULT_CIPHER\n        blklen = _SSH_CIPHERS[ciphername].block_len\n        kdfname = _BCRYPT\n        rounds = _DEFAULT_ROUNDS\n        if (\n            isinstance(encryption_algorithm, _KeySerializationEncryption)\n            and encryption_algorithm._kdf_rounds is not None\n        ):\n            rounds = encryption_algorithm._kdf_rounds\n        salt = os.urandom(16)\n        f_kdfoptions.put_sshstr(salt)\n        f_kdfoptions.put_u32(rounds)\n        ciph = _init_cipher(ciphername, password, salt, rounds)\n    else:\n        ciphername = kdfname = _NONE\n        blklen = 8\n        ciph = None\n    nkeys = 1\n    checkval = os.urandom(4)\n    comment = b\"\"\n\n    # encode public and private parts together\n    f_public_key = _FragList()\n    f_public_key.put_sshstr(key_type)\n    kformat.encode_public(private_key.public_key(), f_public_key)\n\n    f_secrets = _FragList([checkval, checkval])\n    f_secrets.put_sshstr(key_type)\n    kformat.encode_private(private_key, f_secrets)\n    f_secrets.put_sshstr(comment)\n    f_secrets.put_raw(_PADDING[: blklen - (f_secrets.size() % blklen)])\n\n    # top-level structure\n    f_main = _FragList()\n    f_main.put_raw(_SK_MAGIC)\n    f_main.put_sshstr(ciphername)\n    f_main.put_sshstr(kdfname)\n    f_main.put_sshstr(f_kdfoptions)\n    f_main.put_u32(nkeys)\n    f_main.put_sshstr(f_public_key)\n    f_main.put_sshstr(f_secrets)\n\n    # copy result info bytearray\n    slen = f_secrets.size()\n    mlen = f_main.size()\n    buf = memoryview(bytearray(mlen + blklen))\n    f_main.render(buf)\n    ofs = mlen - slen\n\n    # encrypt in-place\n    if ciph is not None:\n        ciph.encryptor().update_into(buf[ofs:mlen], buf[ofs:])\n\n    return _ssh_pem_encode(buf[:mlen])\n\n\nSSHPublicKeyTypes = typing.Union[\n    ec.EllipticCurvePublicKey,\n    rsa.RSAPublicKey,\n    dsa.DSAPublicKey,\n    ed25519.Ed25519PublicKey,\n]\n\nSSHCertPublicKeyTypes = typing.Union[\n    ec.EllipticCurvePublicKey,\n    rsa.RSAPublicKey,\n    ed25519.Ed25519PublicKey,\n]\n\n\nclass SSHCertificateType(enum.Enum):\n    USER = 1\n    HOST = 2\n\n\nclass SSHCertificate:\n    def __init__(\n        self,\n        _nonce: memoryview,\n        _public_key: SSHPublicKeyTypes,\n        _serial: int,\n        _cctype: int,\n        _key_id: memoryview,\n        _valid_principals: list[bytes],\n        _valid_after: int,\n        _valid_before: int,\n        _critical_options: dict[bytes, bytes],\n        _extensions: dict[bytes, bytes],\n        _sig_type: memoryview,\n        _sig_key: memoryview,\n        _inner_sig_type: memoryview,\n        _signature: memoryview,\n        _tbs_cert_body: memoryview,\n        _cert_key_type: bytes,\n        _cert_body: memoryview,\n    ):\n        self._nonce = _nonce\n        self._public_key = _public_key\n        self._serial = _serial\n        try:\n            self._type = SSHCertificateType(_cctype)\n        except ValueError:\n            raise ValueError(\"Invalid certificate type\")\n        self._key_id = _key_id\n        self._valid_principals = _valid_principals\n        self._valid_after = _valid_after\n        self._valid_before = _valid_before\n        self._critical_options = _critical_options\n        self._extensions = _extensions\n        self._sig_type = _sig_type\n        self._sig_key = _sig_key\n        self._inner_sig_type = _inner_sig_type\n        self._signature = _signature\n        self._cert_key_type = _cert_key_type\n        self._cert_body = _cert_body\n        self._tbs_cert_body = _tbs_cert_body\n\n    @property\n    def nonce(self) -> bytes:\n        return bytes(self._nonce)\n\n    def public_key(self) -> SSHCertPublicKeyTypes:\n        # make mypy happy until we remove DSA support entirely and\n        # the underlying union won't have a disallowed type\n        return typing.cast(SSHCertPublicKeyTypes, self._public_key)\n\n    @property\n    def serial(self) -> int:\n        return self._serial\n\n    @property\n    def type(self) -> SSHCertificateType:\n        return self._type\n\n    @property\n    def key_id(self) -> bytes:\n        return bytes(self._key_id)\n\n    @property\n    def valid_principals(self) -> list[bytes]:\n        return self._valid_principals\n\n    @property\n    def valid_before(self) -> int:\n        return self._valid_before\n\n    @property\n    def valid_after(self) -> int:\n        return self._valid_after\n\n    @property\n    def critical_options(self) -> dict[bytes, bytes]:\n        return self._critical_options\n\n    @property\n    def extensions(self) -> dict[bytes, bytes]:\n        return self._extensions\n\n    def signature_key(self) -> SSHCertPublicKeyTypes:\n        sigformat = _lookup_kformat(self._sig_type)\n        signature_key, sigkey_rest = sigformat.load_public(self._sig_key)\n        _check_empty(sigkey_rest)\n        return signature_key\n\n    def public_bytes(self) -> bytes:\n        return (\n            bytes(self._cert_key_type)\n            + b\" \"\n            + binascii.b2a_base64(bytes(self._cert_body), newline=False)\n        )\n\n    def verify_cert_signature(self) -> None:\n        signature_key = self.signature_key()\n        if isinstance(signature_key, ed25519.Ed25519PublicKey):\n            signature_key.verify(\n                bytes(self._signature), bytes(self._tbs_cert_body)\n            )\n        elif isinstance(signature_key, ec.EllipticCurvePublicKey):\n            # The signature is encoded as a pair of big-endian integers\n            r, data = _get_mpint(self._signature)\n            s, data = _get_mpint(data)\n            _check_empty(data)\n            computed_sig = asym_utils.encode_dss_signature(r, s)\n            hash_alg = _get_ec_hash_alg(signature_key.curve)\n            signature_key.verify(\n                computed_sig, bytes(self._tbs_cert_body), ec.ECDSA(hash_alg)\n            )\n        else:\n            assert isinstance(signature_key, rsa.RSAPublicKey)\n            if self._inner_sig_type == _SSH_RSA:\n                hash_alg = hashes.SHA1()\n            elif self._inner_sig_type == _SSH_RSA_SHA256:\n                hash_alg = hashes.SHA256()\n            else:\n                assert self._inner_sig_type == _SSH_RSA_SHA512\n                hash_alg = hashes.SHA512()\n            signature_key.verify(\n                bytes(self._signature),\n                bytes(self._tbs_cert_body),\n                padding.PKCS1v15(),\n                hash_alg,\n            )\n\n\ndef _get_ec_hash_alg(curve: ec.EllipticCurve) -> hashes.HashAlgorithm:\n    if isinstance(curve, ec.SECP256R1):\n        return hashes.SHA256()\n    elif isinstance(curve, ec.SECP384R1):\n        return hashes.SHA384()\n    else:\n        assert isinstance(curve, ec.SECP521R1)\n        return hashes.SHA512()\n\n\ndef _load_ssh_public_identity(\n    data: bytes,\n    _legacy_dsa_allowed=False,\n) -> SSHCertificate | SSHPublicKeyTypes:\n    utils._check_byteslike(\"data\", data)\n\n    m = _SSH_PUBKEY_RC.match(data)\n    if not m:\n        raise ValueError(\"Invalid line format\")\n    key_type = orig_key_type = m.group(1)\n    key_body = m.group(2)\n    with_cert = False\n    if key_type.endswith(_CERT_SUFFIX):\n        with_cert = True\n        key_type = key_type[: -len(_CERT_SUFFIX)]\n    if key_type == _SSH_DSA and not _legacy_dsa_allowed:\n        raise UnsupportedAlgorithm(\n            \"DSA keys aren't supported in SSH certificates\"\n        )\n    kformat = _lookup_kformat(key_type)\n\n    try:\n        rest = memoryview(binascii.a2b_base64(key_body))\n    except (TypeError, binascii.Error):\n        raise ValueError(\"Invalid format\")\n\n    if with_cert:\n        cert_body = rest\n    inner_key_type, rest = _get_sshstr(rest)\n    if inner_key_type != orig_key_type:\n        raise ValueError(\"Invalid key format\")\n    if with_cert:\n        nonce, rest = _get_sshstr(rest)\n    public_key, rest = kformat.load_public(rest)\n    if with_cert:\n        serial, rest = _get_u64(rest)\n        cctype, rest = _get_u32(rest)\n        key_id, rest = _get_sshstr(rest)\n        principals, rest = _get_sshstr(rest)\n        valid_principals = []\n        while principals:\n            principal, principals = _get_sshstr(principals)\n            valid_principals.append(bytes(principal))\n        valid_after, rest = _get_u64(rest)\n        valid_before, rest = _get_u64(rest)\n        crit_options, rest = _get_sshstr(rest)\n        critical_options = _parse_exts_opts(crit_options)\n        exts, rest = _get_sshstr(rest)\n        extensions = _parse_exts_opts(exts)\n        # Get the reserved field, which is unused.\n        _, rest = _get_sshstr(rest)\n        sig_key_raw, rest = _get_sshstr(rest)\n        sig_type, sig_key = _get_sshstr(sig_key_raw)\n        if sig_type == _SSH_DSA and not _legacy_dsa_allowed:\n            raise UnsupportedAlgorithm(\n                \"DSA signatures aren't supported in SSH certificates\"\n            )\n        # Get the entire cert body and subtract the signature\n        tbs_cert_body = cert_body[: -len(rest)]\n        signature_raw, rest = _get_sshstr(rest)\n        _check_empty(rest)\n        inner_sig_type, sig_rest = _get_sshstr(signature_raw)\n        # RSA certs can have multiple algorithm types\n        if (\n            sig_type == _SSH_RSA\n            and inner_sig_type\n            not in [_SSH_RSA_SHA256, _SSH_RSA_SHA512, _SSH_RSA]\n        ) or (sig_type != _SSH_RSA and inner_sig_type != sig_type):\n            raise ValueError(\"Signature key type does not match\")\n        signature, sig_rest = _get_sshstr(sig_rest)\n        _check_empty(sig_rest)\n        return SSHCertificate(\n            nonce,\n            public_key,\n            serial,\n            cctype,\n            key_id,\n            valid_principals,\n            valid_after,\n            valid_before,\n            critical_options,\n            extensions,\n            sig_type,\n            sig_key,\n            inner_sig_type,\n            signature,\n            tbs_cert_body,\n            orig_key_type,\n            cert_body,\n        )\n    else:\n        _check_empty(rest)\n        return public_key\n\n\ndef load_ssh_public_identity(\n    data: bytes,\n) -> SSHCertificate | SSHPublicKeyTypes:\n    return _load_ssh_public_identity(data)\n\n\ndef _parse_exts_opts(exts_opts: memoryview) -> dict[bytes, bytes]:\n    result: dict[bytes, bytes] = {}\n    last_name = None\n    while exts_opts:\n        name, exts_opts = _get_sshstr(exts_opts)\n        bname: bytes = bytes(name)\n        if bname in result:\n            raise ValueError(\"Duplicate name\")\n        if last_name is not None and bname < last_name:\n            raise ValueError(\"Fields not lexically sorted\")\n        value, exts_opts = _get_sshstr(exts_opts)\n        if len(value) > 0:\n            value, extra = _get_sshstr(value)\n            if len(extra) > 0:\n                raise ValueError(\"Unexpected extra data after value\")\n        result[bname] = bytes(value)\n        last_name = bname\n    return result\n\n\ndef load_ssh_public_key(\n    data: bytes, backend: typing.Any = None\n) -> SSHPublicKeyTypes:\n    cert_or_key = _load_ssh_public_identity(data, _legacy_dsa_allowed=True)\n    public_key: SSHPublicKeyTypes\n    if isinstance(cert_or_key, SSHCertificate):\n        public_key = cert_or_key.public_key()\n    else:\n        public_key = cert_or_key\n\n    if isinstance(public_key, dsa.DSAPublicKey):\n        warnings.warn(\n            \"SSH DSA keys are deprecated and will be removed in a future \"\n            \"release.\",\n            utils.DeprecatedIn40,\n            stacklevel=2,\n        )\n    return public_key\n\n\ndef serialize_ssh_public_key(public_key: SSHPublicKeyTypes) -> bytes:\n    \"\"\"One-line public key format for OpenSSH\"\"\"\n    if isinstance(public_key, dsa.DSAPublicKey):\n        warnings.warn(\n            \"SSH DSA key support is deprecated and will be \"\n            \"removed in a future release\",\n            utils.DeprecatedIn40,\n            stacklevel=4,\n        )\n    key_type = _get_ssh_key_type(public_key)\n    kformat = _lookup_kformat(key_type)\n\n    f_pub = _FragList()\n    f_pub.put_sshstr(key_type)\n    kformat.encode_public(public_key, f_pub)\n\n    pub = binascii.b2a_base64(f_pub.tobytes()).strip()\n    return b\"\".join([key_type, b\" \", pub])\n\n\nSSHCertPrivateKeyTypes = typing.Union[\n    ec.EllipticCurvePrivateKey,\n    rsa.RSAPrivateKey,\n    ed25519.Ed25519PrivateKey,\n]\n\n\n# This is an undocumented limit enforced in the openssh codebase for sshd and\n# ssh-keygen, but it is undefined in the ssh certificates spec.\n_SSHKEY_CERT_MAX_PRINCIPALS = 256\n\n\nclass SSHCertificateBuilder:\n    def __init__(\n        self,\n        _public_key: SSHCertPublicKeyTypes | None = None,\n        _serial: int | None = None,\n        _type: SSHCertificateType | None = None,\n        _key_id: bytes | None = None,\n        _valid_principals: list[bytes] = [],\n        _valid_for_all_principals: bool = False,\n        _valid_before: int | None = None,\n        _valid_after: int | None = None,\n        _critical_options: list[tuple[bytes, bytes]] = [],\n        _extensions: list[tuple[bytes, bytes]] = [],\n    ):\n        self._public_key = _public_key\n        self._serial = _serial\n        self._type = _type\n        self._key_id = _key_id\n        self._valid_principals = _valid_principals\n        self._valid_for_all_principals = _valid_for_all_principals\n        self._valid_before = _valid_before\n        self._valid_after = _valid_after\n        self._critical_options = _critical_options\n        self._extensions = _extensions\n\n    def public_key(\n        self, public_key: SSHCertPublicKeyTypes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(\n            public_key,\n            (\n                ec.EllipticCurvePublicKey,\n                rsa.RSAPublicKey,\n                ed25519.Ed25519PublicKey,\n            ),\n        ):\n            raise TypeError(\"Unsupported key type\")\n        if self._public_key is not None:\n            raise ValueError(\"public_key already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def serial(self, serial: int) -> SSHCertificateBuilder:\n        if not isinstance(serial, int):\n            raise TypeError(\"serial must be an integer\")\n        if not 0 <= serial < 2**64:\n            raise ValueError(\"serial must be between 0 and 2**64\")\n        if self._serial is not None:\n            raise ValueError(\"serial already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def type(self, type: SSHCertificateType) -> SSHCertificateBuilder:\n        if not isinstance(type, SSHCertificateType):\n            raise TypeError(\"type must be an SSHCertificateType\")\n        if self._type is not None:\n            raise ValueError(\"type already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def key_id(self, key_id: bytes) -> SSHCertificateBuilder:\n        if not isinstance(key_id, bytes):\n            raise TypeError(\"key_id must be bytes\")\n        if self._key_id is not None:\n            raise ValueError(\"key_id already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_principals(\n        self, valid_principals: list[bytes]\n    ) -> SSHCertificateBuilder:\n        if self._valid_for_all_principals:\n            raise ValueError(\n                \"Principals can't be set because the cert is valid \"\n                \"for all principals\"\n            )\n        if (\n            not all(isinstance(x, bytes) for x in valid_principals)\n            or not valid_principals\n        ):\n            raise TypeError(\n                \"principals must be a list of bytes and can't be empty\"\n            )\n        if self._valid_principals:\n            raise ValueError(\"valid_principals already set\")\n\n        if len(valid_principals) > _SSHKEY_CERT_MAX_PRINCIPALS:\n            raise ValueError(\n                \"Reached or exceeded the maximum number of valid_principals\"\n            )\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_for_all_principals(self):\n        if self._valid_principals:\n            raise ValueError(\n                \"valid_principals already set, can't set \"\n                \"valid_for_all_principals\"\n            )\n        if self._valid_for_all_principals:\n            raise ValueError(\"valid_for_all_principals already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=True,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_before(self, valid_before: int | float) -> SSHCertificateBuilder:\n        if not isinstance(valid_before, (int, float)):\n            raise TypeError(\"valid_before must be an int or float\")\n        valid_before = int(valid_before)\n        if valid_before < 0 or valid_before >= 2**64:\n            raise ValueError(\"valid_before must [0, 2**64)\")\n        if self._valid_before is not None:\n            raise ValueError(\"valid_before already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def valid_after(self, valid_after: int | float) -> SSHCertificateBuilder:\n        if not isinstance(valid_after, (int, float)):\n            raise TypeError(\"valid_after must be an int or float\")\n        valid_after = int(valid_after)\n        if valid_after < 0 or valid_after >= 2**64:\n            raise ValueError(\"valid_after must [0, 2**64)\")\n        if self._valid_after is not None:\n            raise ValueError(\"valid_after already set\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=valid_after,\n            _critical_options=self._critical_options,\n            _extensions=self._extensions,\n        )\n\n    def add_critical_option(\n        self, name: bytes, value: bytes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(name, bytes) or not isinstance(value, bytes):\n            raise TypeError(\"name and value must be bytes\")\n        # This is O(n**2)\n        if name in [name for name, _ in self._critical_options]:\n            raise ValueError(\"Duplicate critical option name\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=[*self._critical_options, (name, value)],\n            _extensions=self._extensions,\n        )\n\n    def add_extension(\n        self, name: bytes, value: bytes\n    ) -> SSHCertificateBuilder:\n        if not isinstance(name, bytes) or not isinstance(value, bytes):\n            raise TypeError(\"name and value must be bytes\")\n        # This is O(n**2)\n        if name in [name for name, _ in self._extensions]:\n            raise ValueError(\"Duplicate extension name\")\n\n        return SSHCertificateBuilder(\n            _public_key=self._public_key,\n            _serial=self._serial,\n            _type=self._type,\n            _key_id=self._key_id,\n            _valid_principals=self._valid_principals,\n            _valid_for_all_principals=self._valid_for_all_principals,\n            _valid_before=self._valid_before,\n            _valid_after=self._valid_after,\n            _critical_options=self._critical_options,\n            _extensions=[*self._extensions, (name, value)],\n        )\n\n    def sign(self, private_key: SSHCertPrivateKeyTypes) -> SSHCertificate:\n        if not isinstance(\n            private_key,\n            (\n                ec.EllipticCurvePrivateKey,\n                rsa.RSAPrivateKey,\n                ed25519.Ed25519PrivateKey,\n            ),\n        ):\n            raise TypeError(\"Unsupported private key type\")\n\n        if self._public_key is None:\n            raise ValueError(\"public_key must be set\")\n\n        # Not required\n        serial = 0 if self._serial is None else self._serial\n\n        if self._type is None:\n            raise ValueError(\"type must be set\")\n\n        # Not required\n        key_id = b\"\" if self._key_id is None else self._key_id\n\n        # A zero length list is valid, but means the certificate\n        # is valid for any principal of the specified type. We require\n        # the user to explicitly set valid_for_all_principals to get\n        # that behavior.\n        if not self._valid_principals and not self._valid_for_all_principals:\n            raise ValueError(\n                \"valid_principals must be set if valid_for_all_principals \"\n                \"is False\"\n            )\n\n        if self._valid_before is None:\n            raise ValueError(\"valid_before must be set\")\n\n        if self._valid_after is None:\n            raise ValueError(\"valid_after must be set\")\n\n        if self._valid_after > self._valid_before:\n            raise ValueError(\"valid_after must be earlier than valid_before\")\n\n        # lexically sort our byte strings\n        self._critical_options.sort(key=lambda x: x[0])\n        self._extensions.sort(key=lambda x: x[0])\n\n        key_type = _get_ssh_key_type(self._public_key)\n        cert_prefix = key_type + _CERT_SUFFIX\n\n        # Marshal the bytes to be signed\n        nonce = os.urandom(32)\n        kformat = _lookup_kformat(key_type)\n        f = _FragList()\n        f.put_sshstr(cert_prefix)\n        f.put_sshstr(nonce)\n        kformat.encode_public(self._public_key, f)\n        f.put_u64(serial)\n        f.put_u32(self._type.value)\n        f.put_sshstr(key_id)\n        fprincipals = _FragList()\n        for p in self._valid_principals:\n            fprincipals.put_sshstr(p)\n        f.put_sshstr(fprincipals.tobytes())\n        f.put_u64(self._valid_after)\n        f.put_u64(self._valid_before)\n        fcrit = _FragList()\n        for name, value in self._critical_options:\n            fcrit.put_sshstr(name)\n            if len(value) > 0:\n                foptval = _FragList()\n                foptval.put_sshstr(value)\n                fcrit.put_sshstr(foptval.tobytes())\n            else:\n                fcrit.put_sshstr(value)\n        f.put_sshstr(fcrit.tobytes())\n        fext = _FragList()\n        for name, value in self._extensions:\n            fext.put_sshstr(name)\n            if len(value) > 0:\n                fextval = _FragList()\n                fextval.put_sshstr(value)\n                fext.put_sshstr(fextval.tobytes())\n            else:\n                fext.put_sshstr(value)\n        f.put_sshstr(fext.tobytes())\n        f.put_sshstr(b\"\")  # RESERVED FIELD\n        # encode CA public key\n        ca_type = _get_ssh_key_type(private_key)\n        caformat = _lookup_kformat(ca_type)\n        caf = _FragList()\n        caf.put_sshstr(ca_type)\n        caformat.encode_public(private_key.public_key(), caf)\n        f.put_sshstr(caf.tobytes())\n        # Sigs according to the rules defined for the CA's public key\n        # (RFC4253 section 6.6 for ssh-rsa, RFC5656 for ECDSA,\n        # and RFC8032 for Ed25519).\n        if isinstance(private_key, ed25519.Ed25519PrivateKey):\n            signature = private_key.sign(f.tobytes())\n            fsig = _FragList()\n            fsig.put_sshstr(ca_type)\n            fsig.put_sshstr(signature)\n            f.put_sshstr(fsig.tobytes())\n        elif isinstance(private_key, ec.EllipticCurvePrivateKey):\n            hash_alg = _get_ec_hash_alg(private_key.curve)\n            signature = private_key.sign(f.tobytes(), ec.ECDSA(hash_alg))\n            r, s = asym_utils.decode_dss_signature(signature)\n            fsig = _FragList()\n            fsig.put_sshstr(ca_type)\n            fsigblob = _FragList()\n            fsigblob.put_mpint(r)\n            fsigblob.put_mpint(s)\n            fsig.put_sshstr(fsigblob.tobytes())\n            f.put_sshstr(fsig.tobytes())\n\n        else:\n            assert isinstance(private_key, rsa.RSAPrivateKey)\n            # Just like Golang, we're going to use SHA512 for RSA\n            # https://cs.opensource.google/go/x/crypto/+/refs/tags/\n            # v0.4.0:ssh/certs.go;l=445\n            # RFC 8332 defines SHA256 and 512 as options\n            fsig = _FragList()\n            fsig.put_sshstr(_SSH_RSA_SHA512)\n            signature = private_key.sign(\n                f.tobytes(), padding.PKCS1v15(), hashes.SHA512()\n            )\n            fsig.put_sshstr(signature)\n            f.put_sshstr(fsig.tobytes())\n\n        cert_data = binascii.b2a_base64(f.tobytes()).strip()\n        # load_ssh_public_identity returns a union, but this is\n        # guaranteed to be an SSHCertificate, so we cast to make\n        # mypy happy.\n        return typing.cast(\n            SSHCertificate,\n            load_ssh_public_identity(b\"\".join([cert_prefix, b\" \", cert_data])),\n        )\n", "src/cryptography/hazmat/primitives/serialization/pkcs7.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport email.base64mime\nimport email.generator\nimport email.message\nimport email.policy\nimport io\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.hazmat.bindings._rust import pkcs7 as rust_pkcs7\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec, padding, rsa\nfrom cryptography.utils import _check_byteslike\n\nload_pem_pkcs7_certificates = rust_pkcs7.load_pem_pkcs7_certificates\n\nload_der_pkcs7_certificates = rust_pkcs7.load_der_pkcs7_certificates\n\nserialize_certificates = rust_pkcs7.serialize_certificates\n\nPKCS7HashTypes = typing.Union[\n    hashes.SHA224,\n    hashes.SHA256,\n    hashes.SHA384,\n    hashes.SHA512,\n]\n\nPKCS7PrivateKeyTypes = typing.Union[\n    rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey\n]\n\n\nclass PKCS7Options(utils.Enum):\n    Text = \"Add text/plain MIME type\"\n    Binary = \"Don't translate input data into canonical MIME format\"\n    DetachedSignature = \"Don't embed data in the PKCS7 structure\"\n    NoCapabilities = \"Don't embed SMIME capabilities\"\n    NoAttributes = \"Don't embed authenticatedAttributes\"\n    NoCerts = \"Don't embed signer certificate\"\n\n\nclass PKCS7SignatureBuilder:\n    def __init__(\n        self,\n        data: bytes | None = None,\n        signers: list[\n            tuple[\n                x509.Certificate,\n                PKCS7PrivateKeyTypes,\n                PKCS7HashTypes,\n                padding.PSS | padding.PKCS1v15 | None,\n            ]\n        ] = [],\n        additional_certs: list[x509.Certificate] = [],\n    ):\n        self._data = data\n        self._signers = signers\n        self._additional_certs = additional_certs\n\n    def set_data(self, data: bytes) -> PKCS7SignatureBuilder:\n        _check_byteslike(\"data\", data)\n        if self._data is not None:\n            raise ValueError(\"data may only be set once\")\n\n        return PKCS7SignatureBuilder(data, self._signers)\n\n    def add_signer(\n        self,\n        certificate: x509.Certificate,\n        private_key: PKCS7PrivateKeyTypes,\n        hash_algorithm: PKCS7HashTypes,\n        *,\n        rsa_padding: padding.PSS | padding.PKCS1v15 | None = None,\n    ) -> PKCS7SignatureBuilder:\n        if not isinstance(\n            hash_algorithm,\n            (\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        ):\n            raise TypeError(\n                \"hash_algorithm must be one of hashes.SHA224, \"\n                \"SHA256, SHA384, or SHA512\"\n            )\n        if not isinstance(certificate, x509.Certificate):\n            raise TypeError(\"certificate must be a x509.Certificate\")\n\n        if not isinstance(\n            private_key, (rsa.RSAPrivateKey, ec.EllipticCurvePrivateKey)\n        ):\n            raise TypeError(\"Only RSA & EC keys are supported at this time.\")\n\n        if rsa_padding is not None:\n            if not isinstance(rsa_padding, (padding.PSS, padding.PKCS1v15)):\n                raise TypeError(\"Padding must be PSS or PKCS1v15\")\n            if not isinstance(private_key, rsa.RSAPrivateKey):\n                raise TypeError(\"Padding is only supported for RSA keys\")\n\n        return PKCS7SignatureBuilder(\n            self._data,\n            [\n                *self._signers,\n                (certificate, private_key, hash_algorithm, rsa_padding),\n            ],\n        )\n\n    def add_certificate(\n        self, certificate: x509.Certificate\n    ) -> PKCS7SignatureBuilder:\n        if not isinstance(certificate, x509.Certificate):\n            raise TypeError(\"certificate must be a x509.Certificate\")\n\n        return PKCS7SignatureBuilder(\n            self._data, self._signers, [*self._additional_certs, certificate]\n        )\n\n    def sign(\n        self,\n        encoding: serialization.Encoding,\n        options: typing.Iterable[PKCS7Options],\n        backend: typing.Any = None,\n    ) -> bytes:\n        if len(self._signers) == 0:\n            raise ValueError(\"Must have at least one signer\")\n        if self._data is None:\n            raise ValueError(\"You must add data to sign\")\n        options = list(options)\n        if not all(isinstance(x, PKCS7Options) for x in options):\n            raise ValueError(\"options must be from the PKCS7Options enum\")\n        if encoding not in (\n            serialization.Encoding.PEM,\n            serialization.Encoding.DER,\n            serialization.Encoding.SMIME,\n        ):\n            raise ValueError(\n                \"Must be PEM, DER, or SMIME from the Encoding enum\"\n            )\n\n        # Text is a meaningless option unless it is accompanied by\n        # DetachedSignature\n        if (\n            PKCS7Options.Text in options\n            and PKCS7Options.DetachedSignature not in options\n        ):\n            raise ValueError(\n                \"When passing the Text option you must also pass \"\n                \"DetachedSignature\"\n            )\n\n        if PKCS7Options.Text in options and encoding in (\n            serialization.Encoding.DER,\n            serialization.Encoding.PEM,\n        ):\n            raise ValueError(\n                \"The Text option is only available for SMIME serialization\"\n            )\n\n        # No attributes implies no capabilities so we'll error if you try to\n        # pass both.\n        if (\n            PKCS7Options.NoAttributes in options\n            and PKCS7Options.NoCapabilities in options\n        ):\n            raise ValueError(\n                \"NoAttributes is a superset of NoCapabilities. Do not pass \"\n                \"both values.\"\n            )\n\n        return rust_pkcs7.sign_and_serialize(self, encoding, options)\n\n\ndef _smime_encode(\n    data: bytes, signature: bytes, micalg: str, text_mode: bool\n) -> bytes:\n    # This function works pretty hard to replicate what OpenSSL does\n    # precisely. For good and for ill.\n\n    m = email.message.Message()\n    m.add_header(\"MIME-Version\", \"1.0\")\n    m.add_header(\n        \"Content-Type\",\n        \"multipart/signed\",\n        protocol=\"application/x-pkcs7-signature\",\n        micalg=micalg,\n    )\n\n    m.preamble = \"This is an S/MIME signed message\\n\"\n\n    msg_part = OpenSSLMimePart()\n    msg_part.set_payload(data)\n    if text_mode:\n        msg_part.add_header(\"Content-Type\", \"text/plain\")\n    m.attach(msg_part)\n\n    sig_part = email.message.MIMEPart()\n    sig_part.add_header(\n        \"Content-Type\", \"application/x-pkcs7-signature\", name=\"smime.p7s\"\n    )\n    sig_part.add_header(\"Content-Transfer-Encoding\", \"base64\")\n    sig_part.add_header(\n        \"Content-Disposition\", \"attachment\", filename=\"smime.p7s\"\n    )\n    sig_part.set_payload(\n        email.base64mime.body_encode(signature, maxlinelen=65)\n    )\n    del sig_part[\"MIME-Version\"]\n    m.attach(sig_part)\n\n    fp = io.BytesIO()\n    g = email.generator.BytesGenerator(\n        fp,\n        maxheaderlen=0,\n        mangle_from_=False,\n        policy=m.policy.clone(linesep=\"\\r\\n\"),\n    )\n    g.flatten(m)\n    return fp.getvalue()\n\n\nclass OpenSSLMimePart(email.message.MIMEPart):\n    # A MIMEPart subclass that replicates OpenSSL's behavior of not including\n    # a newline if there are no headers.\n    def _write_headers(self, generator) -> None:\n        if list(self.raw_items()):\n            generator._write_headers(self)\n", "src/cryptography/hazmat/primitives/serialization/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._serialization import (\n    BestAvailableEncryption,\n    Encoding,\n    KeySerializationEncryption,\n    NoEncryption,\n    ParameterFormat,\n    PrivateFormat,\n    PublicFormat,\n    _KeySerializationEncryption,\n)\nfrom cryptography.hazmat.primitives.serialization.base import (\n    load_der_parameters,\n    load_der_private_key,\n    load_der_public_key,\n    load_pem_parameters,\n    load_pem_private_key,\n    load_pem_public_key,\n)\nfrom cryptography.hazmat.primitives.serialization.ssh import (\n    SSHCertificate,\n    SSHCertificateBuilder,\n    SSHCertificateType,\n    SSHCertPrivateKeyTypes,\n    SSHCertPublicKeyTypes,\n    SSHPrivateKeyTypes,\n    SSHPublicKeyTypes,\n    load_ssh_private_key,\n    load_ssh_public_identity,\n    load_ssh_public_key,\n)\n\n__all__ = [\n    \"BestAvailableEncryption\",\n    \"Encoding\",\n    \"KeySerializationEncryption\",\n    \"NoEncryption\",\n    \"ParameterFormat\",\n    \"PrivateFormat\",\n    \"PublicFormat\",\n    \"SSHCertPrivateKeyTypes\",\n    \"SSHCertPublicKeyTypes\",\n    \"SSHCertificate\",\n    \"SSHCertificateBuilder\",\n    \"SSHCertificateType\",\n    \"SSHPrivateKeyTypes\",\n    \"SSHPublicKeyTypes\",\n    \"_KeySerializationEncryption\",\n    \"load_der_parameters\",\n    \"load_der_private_key\",\n    \"load_der_public_key\",\n    \"load_pem_parameters\",\n    \"load_pem_private_key\",\n    \"load_pem_public_key\",\n    \"load_ssh_private_key\",\n    \"load_ssh_public_identity\",\n    \"load_ssh_public_key\",\n]\n", "src/cryptography/hazmat/primitives/ciphers/algorithms.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography import utils\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    ARC4 as ARC4,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    CAST5 as CAST5,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    IDEA as IDEA,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    SEED as SEED,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    Blowfish as Blowfish,\n)\nfrom cryptography.hazmat.decrepit.ciphers.algorithms import (\n    TripleDES as TripleDES,\n)\nfrom cryptography.hazmat.primitives._cipheralgorithm import _verify_key_size\nfrom cryptography.hazmat.primitives.ciphers import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\n\n\nclass AES(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    # 512 added to support AES-256-XTS, which uses 512-bit keys\n    key_sizes = frozenset([128, 192, 256, 512])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass AES128(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    key_sizes = frozenset([128])\n    key_size = 128\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n\nclass AES256(BlockCipherAlgorithm):\n    name = \"AES\"\n    block_size = 128\n    key_sizes = frozenset([256])\n    key_size = 256\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n\nclass Camellia(BlockCipherAlgorithm):\n    name = \"camellia\"\n    block_size = 128\n    key_sizes = frozenset([128, 192, 256])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nutils.deprecated(\n    ARC4,\n    __name__,\n    \"ARC4 has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.ARC4 and \"\n    \"will be removed from this module in 48.0.0.\",\n    utils.DeprecatedIn43,\n    name=\"ARC4\",\n)\n\n\nutils.deprecated(\n    TripleDES,\n    __name__,\n    \"TripleDES has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.TripleDES and \"\n    \"will be removed from this module in 48.0.0.\",\n    utils.DeprecatedIn43,\n    name=\"TripleDES\",\n)\n\nutils.deprecated(\n    Blowfish,\n    __name__,\n    \"Blowfish has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.Blowfish and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"Blowfish\",\n)\n\n\nutils.deprecated(\n    CAST5,\n    __name__,\n    \"CAST5 has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.CAST5 and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"CAST5\",\n)\n\n\nutils.deprecated(\n    IDEA,\n    __name__,\n    \"IDEA has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.IDEA and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"IDEA\",\n)\n\n\nutils.deprecated(\n    SEED,\n    __name__,\n    \"SEED has been moved to \"\n    \"cryptography.hazmat.decrepit.ciphers.algorithms.SEED and \"\n    \"will be removed from this module in 45.0.0.\",\n    utils.DeprecatedIn37,\n    name=\"SEED\",\n)\n\n\nclass ChaCha20(CipherAlgorithm):\n    name = \"ChaCha20\"\n    key_sizes = frozenset([256])\n\n    def __init__(self, key: bytes, nonce: bytes):\n        self.key = _verify_key_size(self, key)\n        utils._check_byteslike(\"nonce\", nonce)\n\n        if len(nonce) != 16:\n            raise ValueError(\"nonce must be 128-bits (16 bytes)\")\n\n        self._nonce = nonce\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass SM4(BlockCipherAlgorithm):\n    name = \"SM4\"\n    block_size = 128\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n", "src/cryptography/hazmat/primitives/ciphers/aead.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\n\n__all__ = [\n    \"AESCCM\",\n    \"AESGCM\",\n    \"AESGCMSIV\",\n    \"AESOCB3\",\n    \"AESSIV\",\n    \"ChaCha20Poly1305\",\n]\n\nAESGCM = rust_openssl.aead.AESGCM\nChaCha20Poly1305 = rust_openssl.aead.ChaCha20Poly1305\nAESCCM = rust_openssl.aead.AESCCM\nAESSIV = rust_openssl.aead.AESSIV\nAESOCB3 = rust_openssl.aead.AESOCB3\nAESGCMSIV = rust_openssl.aead.AESGCMSIV\n", "src/cryptography/hazmat/primitives/ciphers/modes.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\nfrom cryptography import utils\nfrom cryptography.exceptions import UnsupportedAlgorithm, _Reasons\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers import algorithms\n\n\nclass Mode(metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        A string naming this mode (e.g. \"ECB\", \"CBC\").\n        \"\"\"\n\n    @abc.abstractmethod\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        \"\"\"\n        Checks that all the necessary invariants of this (mode, algorithm)\n        combination are met.\n        \"\"\"\n\n\nclass ModeWithInitializationVector(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def initialization_vector(self) -> bytes:\n        \"\"\"\n        The value of the initialization vector for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithTweak(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tweak(self) -> bytes:\n        \"\"\"\n        The value of the tweak for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithNonce(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def nonce(self) -> bytes:\n        \"\"\"\n        The value of the nonce for this mode as bytes.\n        \"\"\"\n\n\nclass ModeWithAuthenticationTag(Mode, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tag(self) -> bytes | None:\n        \"\"\"\n        The value of the tag supplied to the constructor of this mode.\n        \"\"\"\n\n\ndef _check_aes_key_length(self: Mode, algorithm: CipherAlgorithm) -> None:\n    if algorithm.key_size > 256 and algorithm.name == \"AES\":\n        raise ValueError(\n            \"Only 128, 192, and 256 bit keys are allowed for this AES mode\"\n        )\n\n\ndef _check_iv_length(\n    self: ModeWithInitializationVector, algorithm: BlockCipherAlgorithm\n) -> None:\n    iv_len = len(self.initialization_vector)\n    if iv_len * 8 != algorithm.block_size:\n        raise ValueError(f\"Invalid IV size ({iv_len}) for {self.name}.\")\n\n\ndef _check_nonce_length(\n    nonce: bytes, name: str, algorithm: CipherAlgorithm\n) -> None:\n    if not isinstance(algorithm, BlockCipherAlgorithm):\n        raise UnsupportedAlgorithm(\n            f\"{name} requires a block cipher algorithm\",\n            _Reasons.UNSUPPORTED_CIPHER,\n        )\n    if len(nonce) * 8 != algorithm.block_size:\n        raise ValueError(f\"Invalid nonce size ({len(nonce)}) for {name}.\")\n\n\ndef _check_iv_and_key_length(\n    self: ModeWithInitializationVector, algorithm: CipherAlgorithm\n) -> None:\n    if not isinstance(algorithm, BlockCipherAlgorithm):\n        raise UnsupportedAlgorithm(\n            f\"{self} requires a block cipher algorithm\",\n            _Reasons.UNSUPPORTED_CIPHER,\n        )\n    _check_aes_key_length(self, algorithm)\n    _check_iv_length(self, algorithm)\n\n\nclass CBC(ModeWithInitializationVector):\n    name = \"CBC\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass XTS(ModeWithTweak):\n    name = \"XTS\"\n\n    def __init__(self, tweak: bytes):\n        utils._check_byteslike(\"tweak\", tweak)\n\n        if len(tweak) != 16:\n            raise ValueError(\"tweak must be 128-bits (16 bytes)\")\n\n        self._tweak = tweak\n\n    @property\n    def tweak(self) -> bytes:\n        return self._tweak\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        if isinstance(algorithm, (algorithms.AES128, algorithms.AES256)):\n            raise TypeError(\n                \"The AES128 and AES256 classes do not support XTS, please use \"\n                \"the standard AES class instead.\"\n            )\n\n        if algorithm.key_size not in (256, 512):\n            raise ValueError(\n                \"The XTS specification requires a 256-bit key for AES-128-XTS\"\n                \" and 512-bit key for AES-256-XTS\"\n            )\n\n\nclass ECB(Mode):\n    name = \"ECB\"\n\n    validate_for_algorithm = _check_aes_key_length\n\n\nclass OFB(ModeWithInitializationVector):\n    name = \"OFB\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CFB(ModeWithInitializationVector):\n    name = \"CFB\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CFB8(ModeWithInitializationVector):\n    name = \"CFB8\"\n\n    def __init__(self, initialization_vector: bytes):\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        self._initialization_vector = initialization_vector\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    validate_for_algorithm = _check_iv_and_key_length\n\n\nclass CTR(ModeWithNonce):\n    name = \"CTR\"\n\n    def __init__(self, nonce: bytes):\n        utils._check_byteslike(\"nonce\", nonce)\n        self._nonce = nonce\n\n    @property\n    def nonce(self) -> bytes:\n        return self._nonce\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        _check_aes_key_length(self, algorithm)\n        _check_nonce_length(self.nonce, self.name, algorithm)\n\n\nclass GCM(ModeWithInitializationVector, ModeWithAuthenticationTag):\n    name = \"GCM\"\n    _MAX_ENCRYPTED_BYTES = (2**39 - 256) // 8\n    _MAX_AAD_BYTES = (2**64) // 8\n\n    def __init__(\n        self,\n        initialization_vector: bytes,\n        tag: bytes | None = None,\n        min_tag_length: int = 16,\n    ):\n        # OpenSSL 3.0.0 constrains GCM IVs to [64, 1024] bits inclusive\n        # This is a sane limit anyway so we'll enforce it here.\n        utils._check_byteslike(\"initialization_vector\", initialization_vector)\n        if len(initialization_vector) < 8 or len(initialization_vector) > 128:\n            raise ValueError(\n                \"initialization_vector must be between 8 and 128 bytes (64 \"\n                \"and 1024 bits).\"\n            )\n        self._initialization_vector = initialization_vector\n        if tag is not None:\n            utils._check_bytes(\"tag\", tag)\n            if min_tag_length < 4:\n                raise ValueError(\"min_tag_length must be >= 4\")\n            if len(tag) < min_tag_length:\n                raise ValueError(\n                    f\"Authentication tag must be {min_tag_length} bytes or \"\n                    \"longer.\"\n                )\n        self._tag = tag\n        self._min_tag_length = min_tag_length\n\n    @property\n    def tag(self) -> bytes | None:\n        return self._tag\n\n    @property\n    def initialization_vector(self) -> bytes:\n        return self._initialization_vector\n\n    def validate_for_algorithm(self, algorithm: CipherAlgorithm) -> None:\n        _check_aes_key_length(self, algorithm)\n        if not isinstance(algorithm, BlockCipherAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"GCM requires a block cipher algorithm\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n        block_size_bytes = algorithm.block_size // 8\n        if self._tag is not None and len(self._tag) > block_size_bytes:\n            raise ValueError(\n                f\"Authentication tag cannot be more than {block_size_bytes} \"\n                \"bytes.\"\n            )\n", "src/cryptography/hazmat/primitives/ciphers/base.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\nimport typing\n\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives._cipheralgorithm import CipherAlgorithm\nfrom cryptography.hazmat.primitives.ciphers import modes\n\n\nclass CipherContext(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def update(self, data: bytes) -> bytes:\n        \"\"\"\n        Processes the provided bytes through the cipher and returns the results\n        as bytes.\n        \"\"\"\n\n    @abc.abstractmethod\n    def update_into(self, data: bytes, buf: bytes) -> int:\n        \"\"\"\n        Processes the provided bytes and writes the resulting data into the\n        provided buffer. Returns the number of bytes written.\n        \"\"\"\n\n    @abc.abstractmethod\n    def finalize(self) -> bytes:\n        \"\"\"\n        Returns the results of processing the final block as bytes.\n        \"\"\"\n\n\nclass AEADCipherContext(CipherContext, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def authenticate_additional_data(self, data: bytes) -> None:\n        \"\"\"\n        Authenticates the provided bytes.\n        \"\"\"\n\n\nclass AEADDecryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def finalize_with_tag(self, tag: bytes) -> bytes:\n        \"\"\"\n        Returns the results of processing the final block as bytes and allows\n        delayed passing of the authentication tag.\n        \"\"\"\n\n\nclass AEADEncryptionContext(AEADCipherContext, metaclass=abc.ABCMeta):\n    @property\n    @abc.abstractmethod\n    def tag(self) -> bytes:\n        \"\"\"\n        Returns tag bytes. This is only available after encryption is\n        finalized.\n        \"\"\"\n\n\nMode = typing.TypeVar(\n    \"Mode\", bound=typing.Optional[modes.Mode], covariant=True\n)\n\n\nclass Cipher(typing.Generic[Mode]):\n    def __init__(\n        self,\n        algorithm: CipherAlgorithm,\n        mode: Mode,\n        backend: typing.Any = None,\n    ) -> None:\n        if not isinstance(algorithm, CipherAlgorithm):\n            raise TypeError(\"Expected interface of CipherAlgorithm.\")\n\n        if mode is not None:\n            # mypy needs this assert to narrow the type from our generic\n            # type. Maybe it won't some time in the future.\n            assert isinstance(mode, modes.Mode)\n            mode.validate_for_algorithm(algorithm)\n\n        self.algorithm = algorithm\n        self.mode = mode\n\n    @typing.overload\n    def encryptor(\n        self: Cipher[modes.ModeWithAuthenticationTag],\n    ) -> AEADEncryptionContext: ...\n\n    @typing.overload\n    def encryptor(\n        self: _CIPHER_TYPE,\n    ) -> CipherContext: ...\n\n    def encryptor(self):\n        if isinstance(self.mode, modes.ModeWithAuthenticationTag):\n            if self.mode.tag is not None:\n                raise ValueError(\n                    \"Authentication tag must be None when encrypting.\"\n                )\n\n        return rust_openssl.ciphers.create_encryption_ctx(\n            self.algorithm, self.mode\n        )\n\n    @typing.overload\n    def decryptor(\n        self: Cipher[modes.ModeWithAuthenticationTag],\n    ) -> AEADDecryptionContext: ...\n\n    @typing.overload\n    def decryptor(\n        self: _CIPHER_TYPE,\n    ) -> CipherContext: ...\n\n    def decryptor(self):\n        return rust_openssl.ciphers.create_decryption_ctx(\n            self.algorithm, self.mode\n        )\n\n\n_CIPHER_TYPE = Cipher[\n    typing.Union[\n        modes.ModeWithNonce,\n        modes.ModeWithTweak,\n        None,\n        modes.ECB,\n        modes.ModeWithInitializationVector,\n    ]\n]\n\nCipherContext.register(rust_openssl.ciphers.CipherContext)\nAEADEncryptionContext.register(rust_openssl.ciphers.AEADEncryptionContext)\nAEADDecryptionContext.register(rust_openssl.ciphers.AEADDecryptionContext)\n", "src/cryptography/hazmat/primitives/ciphers/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.base import (\n    AEADCipherContext,\n    AEADDecryptionContext,\n    AEADEncryptionContext,\n    Cipher,\n    CipherContext,\n)\n\n__all__ = [\n    \"AEADCipherContext\",\n    \"AEADDecryptionContext\",\n    \"AEADEncryptionContext\",\n    \"BlockCipherAlgorithm\",\n    \"Cipher\",\n    \"CipherAlgorithm\",\n    \"CipherContext\",\n]\n", "src/cryptography/hazmat/primitives/kdf/concatkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\ndef _int_to_u32be(n: int) -> bytes:\n    return n.to_bytes(length=4, byteorder=\"big\")\n\n\ndef _common_args_checks(\n    algorithm: hashes.HashAlgorithm,\n    length: int,\n    otherinfo: bytes | None,\n) -> None:\n    max_length = algorithm.digest_size * (2**32 - 1)\n    if length > max_length:\n        raise ValueError(f\"Cannot derive keys larger than {max_length} bits.\")\n    if otherinfo is not None:\n        utils._check_bytes(\"otherinfo\", otherinfo)\n\n\ndef _concatkdf_derive(\n    key_material: bytes,\n    length: int,\n    auxfn: typing.Callable[[], hashes.HashContext],\n    otherinfo: bytes,\n) -> bytes:\n    utils._check_byteslike(\"key_material\", key_material)\n    output = [b\"\"]\n    outlen = 0\n    counter = 1\n\n    while length > outlen:\n        h = auxfn()\n        h.update(_int_to_u32be(counter))\n        h.update(key_material)\n        h.update(otherinfo)\n        output.append(h.finalize())\n        outlen += len(output[-1])\n        counter += 1\n\n    return b\"\".join(output)[:length]\n\n\nclass ConcatKDFHash(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        otherinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        _common_args_checks(algorithm, length, otherinfo)\n        self._algorithm = algorithm\n        self._length = length\n        self._otherinfo: bytes = otherinfo if otherinfo is not None else b\"\"\n\n        self._used = False\n\n    def _hash(self) -> hashes.Hash:\n        return hashes.Hash(self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        return _concatkdf_derive(\n            key_material, self._length, self._hash, self._otherinfo\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass ConcatKDFHMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes | None,\n        otherinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        _common_args_checks(algorithm, length, otherinfo)\n        self._algorithm = algorithm\n        self._length = length\n        self._otherinfo: bytes = otherinfo if otherinfo is not None else b\"\"\n\n        if algorithm.block_size is None:\n            raise TypeError(f\"{algorithm.name} is unsupported for ConcatKDF\")\n\n        if salt is None:\n            salt = b\"\\x00\" * algorithm.block_size\n        else:\n            utils._check_bytes(\"salt\", salt)\n\n        self._salt = salt\n\n        self._used = False\n\n    def _hmac(self) -> hmac.HMAC:\n        return hmac.HMAC(self._salt, self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        return _concatkdf_derive(\n            key_material, self._length, self._hmac, self._otherinfo\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/x963kdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\ndef _int_to_u32be(n: int) -> bytes:\n    return n.to_bytes(length=4, byteorder=\"big\")\n\n\nclass X963KDF(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        sharedinfo: bytes | None,\n        backend: typing.Any = None,\n    ):\n        max_len = algorithm.digest_size * (2**32 - 1)\n        if length > max_len:\n            raise ValueError(f\"Cannot derive keys larger than {max_len} bits.\")\n        if sharedinfo is not None:\n            utils._check_bytes(\"sharedinfo\", sharedinfo)\n\n        self._algorithm = algorithm\n        self._length = length\n        self._sharedinfo = sharedinfo\n        self._used = False\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n        self._used = True\n        utils._check_byteslike(\"key_material\", key_material)\n        output = [b\"\"]\n        outlen = 0\n        counter = 1\n\n        while self._length > outlen:\n            h = hashes.Hash(self._algorithm)\n            h.update(key_material)\n            h.update(_int_to_u32be(counter))\n            if self._sharedinfo is not None:\n                h.update(self._sharedinfo)\n            output.append(h.finalize())\n            outlen += len(output[-1])\n            counter += 1\n\n        return b\"\".join(output)[: self._length]\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/pbkdf2.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n    _Reasons,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import constant_time, hashes\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass PBKDF2HMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes,\n        iterations: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.pbkdf2_hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                f\"{algorithm.name} is not supported for PBKDF2.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n        self._used = False\n        self._algorithm = algorithm\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        self._salt = salt\n        self._iterations = iterations\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"PBKDF2 instances can only be used once.\")\n        self._used = True\n\n        return rust_openssl.kdf.derive_pbkdf2_hmac(\n            key_material,\n            self._algorithm,\n            self._salt,\n            self._iterations,\n            self._length,\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")\n", "src/cryptography/hazmat/primitives/kdf/kbkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n    _Reasons,\n)\nfrom cryptography.hazmat.primitives import (\n    ciphers,\n    cmac,\n    constant_time,\n    hashes,\n    hmac,\n)\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass Mode(utils.Enum):\n    CounterMode = \"ctr\"\n\n\nclass CounterLocation(utils.Enum):\n    BeforeFixed = \"before_fixed\"\n    AfterFixed = \"after_fixed\"\n    MiddleFixed = \"middle_fixed\"\n\n\nclass _KBKDFDeriver:\n    def __init__(\n        self,\n        prf: typing.Callable,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        break_location: int | None,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n    ):\n        assert callable(prf)\n\n        if not isinstance(mode, Mode):\n            raise TypeError(\"mode must be of type Mode\")\n\n        if not isinstance(location, CounterLocation):\n            raise TypeError(\"location must be of type CounterLocation\")\n\n        if break_location is None and location is CounterLocation.MiddleFixed:\n            raise ValueError(\"Please specify a break_location\")\n\n        if (\n            break_location is not None\n            and location != CounterLocation.MiddleFixed\n        ):\n            raise ValueError(\n                \"break_location is ignored when location is not\"\n                \" CounterLocation.MiddleFixed\"\n            )\n\n        if break_location is not None and not isinstance(break_location, int):\n            raise TypeError(\"break_location must be an integer\")\n\n        if break_location is not None and break_location < 0:\n            raise ValueError(\"break_location must be a positive integer\")\n\n        if (label or context) and fixed:\n            raise ValueError(\n                \"When supplying fixed data, label and context are ignored.\"\n            )\n\n        if rlen is None or not self._valid_byte_length(rlen):\n            raise ValueError(\"rlen must be between 1 and 4\")\n\n        if llen is None and fixed is None:\n            raise ValueError(\"Please specify an llen\")\n\n        if llen is not None and not isinstance(llen, int):\n            raise TypeError(\"llen must be an integer\")\n\n        if label is None:\n            label = b\"\"\n\n        if context is None:\n            context = b\"\"\n\n        utils._check_bytes(\"label\", label)\n        utils._check_bytes(\"context\", context)\n        self._prf = prf\n        self._mode = mode\n        self._length = length\n        self._rlen = rlen\n        self._llen = llen\n        self._location = location\n        self._break_location = break_location\n        self._label = label\n        self._context = context\n        self._used = False\n        self._fixed_data = fixed\n\n    @staticmethod\n    def _valid_byte_length(value: int) -> bool:\n        if not isinstance(value, int):\n            raise TypeError(\"value must be of type int\")\n\n        value_bin = utils.int_to_bytes(1, value)\n        if not 1 <= len(value_bin) <= 4:\n            return False\n        return True\n\n    def derive(self, key_material: bytes, prf_output_size: int) -> bytes:\n        if self._used:\n            raise AlreadyFinalized\n\n        utils._check_byteslike(\"key_material\", key_material)\n        self._used = True\n\n        # inverse floor division (equivalent to ceiling)\n        rounds = -(-self._length // prf_output_size)\n\n        output = [b\"\"]\n\n        # For counter mode, the number of iterations shall not be\n        # larger than 2^r-1, where r <= 32 is the binary length of the counter\n        # This ensures that the counter values used as an input to the\n        # PRF will not repeat during a particular call to the KDF function.\n        r_bin = utils.int_to_bytes(1, self._rlen)\n        if rounds > pow(2, len(r_bin) * 8) - 1:\n            raise ValueError(\"There are too many iterations.\")\n\n        fixed = self._generate_fixed_input()\n\n        if self._location == CounterLocation.BeforeFixed:\n            data_before_ctr = b\"\"\n            data_after_ctr = fixed\n        elif self._location == CounterLocation.AfterFixed:\n            data_before_ctr = fixed\n            data_after_ctr = b\"\"\n        else:\n            if isinstance(\n                self._break_location, int\n            ) and self._break_location > len(fixed):\n                raise ValueError(\"break_location offset > len(fixed)\")\n            data_before_ctr = fixed[: self._break_location]\n            data_after_ctr = fixed[self._break_location :]\n\n        for i in range(1, rounds + 1):\n            h = self._prf(key_material)\n\n            counter = utils.int_to_bytes(i, self._rlen)\n            input_data = data_before_ctr + counter + data_after_ctr\n\n            h.update(input_data)\n\n            output.append(h.finalize())\n\n        return b\"\".join(output)[: self._length]\n\n    def _generate_fixed_input(self) -> bytes:\n        if self._fixed_data and isinstance(self._fixed_data, bytes):\n            return self._fixed_data\n\n        l_val = utils.int_to_bytes(self._length * 8, self._llen)\n\n        return b\"\".join([self._label, b\"\\x00\", self._context, l_val])\n\n\nclass KBKDFHMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n        backend: typing.Any = None,\n        *,\n        break_location: int | None = None,\n    ):\n        if not isinstance(algorithm, hashes.HashAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported hash algorithm.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.hmac_supported(algorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported hmac algorithm.\",\n                _Reasons.UNSUPPORTED_HASH,\n            )\n\n        self._algorithm = algorithm\n\n        self._deriver = _KBKDFDeriver(\n            self._prf,\n            mode,\n            length,\n            rlen,\n            llen,\n            location,\n            break_location,\n            label,\n            context,\n            fixed,\n        )\n\n    def _prf(self, key_material: bytes) -> hmac.HMAC:\n        return hmac.HMAC(key_material, self._algorithm)\n\n    def derive(self, key_material: bytes) -> bytes:\n        return self._deriver.derive(key_material, self._algorithm.digest_size)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass KBKDFCMAC(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm,\n        mode: Mode,\n        length: int,\n        rlen: int,\n        llen: int | None,\n        location: CounterLocation,\n        label: bytes | None,\n        context: bytes | None,\n        fixed: bytes | None,\n        backend: typing.Any = None,\n        *,\n        break_location: int | None = None,\n    ):\n        if not issubclass(\n            algorithm, ciphers.BlockCipherAlgorithm\n        ) or not issubclass(algorithm, ciphers.CipherAlgorithm):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported cipher algorithm.\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        self._algorithm = algorithm\n        self._cipher: ciphers.BlockCipherAlgorithm | None = None\n\n        self._deriver = _KBKDFDeriver(\n            self._prf,\n            mode,\n            length,\n            rlen,\n            llen,\n            location,\n            break_location,\n            label,\n            context,\n            fixed,\n        )\n\n    def _prf(self, _: bytes) -> cmac.CMAC:\n        assert self._cipher is not None\n\n        return cmac.CMAC(self._cipher)\n\n    def derive(self, key_material: bytes) -> bytes:\n        self._cipher = self._algorithm(key_material)\n\n        assert self._cipher is not None\n\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.cmac_algorithm_supported(self._cipher):\n            raise UnsupportedAlgorithm(\n                \"Algorithm supplied is not a supported cipher algorithm.\",\n                _Reasons.UNSUPPORTED_CIPHER,\n            )\n\n        return self._deriver.derive(key_material, self._cipher.block_size // 8)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/primitives/kdf/scrypt.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport sys\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import (\n    AlreadyFinalized,\n    InvalidKey,\n    UnsupportedAlgorithm,\n)\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.primitives import constant_time\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n# This is used by the scrypt tests to skip tests that require more memory\n# than the MEM_LIMIT\n_MEM_LIMIT = sys.maxsize // 2\n\n\nclass Scrypt(KeyDerivationFunction):\n    def __init__(\n        self,\n        salt: bytes,\n        length: int,\n        n: int,\n        r: int,\n        p: int,\n        backend: typing.Any = None,\n    ):\n        from cryptography.hazmat.backends.openssl.backend import (\n            backend as ossl,\n        )\n\n        if not ossl.scrypt_supported():\n            raise UnsupportedAlgorithm(\n                \"This version of OpenSSL does not support scrypt\"\n            )\n        self._length = length\n        utils._check_bytes(\"salt\", salt)\n        if n < 2 or (n & (n - 1)) != 0:\n            raise ValueError(\"n must be greater than 1 and be a power of 2.\")\n\n        if r < 1:\n            raise ValueError(\"r must be greater than or equal to 1.\")\n\n        if p < 1:\n            raise ValueError(\"p must be greater than or equal to 1.\")\n\n        self._used = False\n        self._salt = salt\n        self._n = n\n        self._r = r\n        self._p = p\n\n    def derive(self, key_material: bytes) -> bytes:\n        if self._used:\n            raise AlreadyFinalized(\"Scrypt instances can only be used once.\")\n        self._used = True\n\n        utils._check_byteslike(\"key_material\", key_material)\n\n        return rust_openssl.kdf.derive_scrypt(\n            key_material,\n            self._salt,\n            self._n,\n            self._r,\n            self._p,\n            _MEM_LIMIT,\n            self._length,\n        )\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        derived_key = self.derive(key_material)\n        if not constant_time.bytes_eq(derived_key, expected_key):\n            raise InvalidKey(\"Keys do not match.\")\n", "src/cryptography/hazmat/primitives/kdf/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport abc\n\n\nclass KeyDerivationFunction(metaclass=abc.ABCMeta):\n    @abc.abstractmethod\n    def derive(self, key_material: bytes) -> bytes:\n        \"\"\"\n        Deterministically generates and returns a new key based on the existing\n        key material.\n        \"\"\"\n\n    @abc.abstractmethod\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        \"\"\"\n        Checks whether the key generated by the key material matches the\n        expected derived key. Raises an exception if they do not match.\n        \"\"\"\n", "src/cryptography/hazmat/primitives/kdf/hkdf.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport typing\n\nfrom cryptography import utils\nfrom cryptography.exceptions import AlreadyFinalized, InvalidKey\nfrom cryptography.hazmat.primitives import constant_time, hashes, hmac\nfrom cryptography.hazmat.primitives.kdf import KeyDerivationFunction\n\n\nclass HKDF(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        salt: bytes | None,\n        info: bytes | None,\n        backend: typing.Any = None,\n    ):\n        self._algorithm = algorithm\n\n        if salt is None:\n            salt = b\"\\x00\" * self._algorithm.digest_size\n        else:\n            utils._check_bytes(\"salt\", salt)\n\n        self._salt = salt\n\n        self._hkdf_expand = HKDFExpand(self._algorithm, length, info)\n\n    def _extract(self, key_material: bytes) -> bytes:\n        h = hmac.HMAC(self._salt, self._algorithm)\n        h.update(key_material)\n        return h.finalize()\n\n    def derive(self, key_material: bytes) -> bytes:\n        utils._check_byteslike(\"key_material\", key_material)\n        return self._hkdf_expand.derive(self._extract(key_material))\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n\n\nclass HKDFExpand(KeyDerivationFunction):\n    def __init__(\n        self,\n        algorithm: hashes.HashAlgorithm,\n        length: int,\n        info: bytes | None,\n        backend: typing.Any = None,\n    ):\n        self._algorithm = algorithm\n\n        max_length = 255 * algorithm.digest_size\n\n        if length > max_length:\n            raise ValueError(\n                f\"Cannot derive keys larger than {max_length} octets.\"\n            )\n\n        self._length = length\n\n        if info is None:\n            info = b\"\"\n        else:\n            utils._check_bytes(\"info\", info)\n\n        self._info = info\n\n        self._used = False\n\n    def _expand(self, key_material: bytes) -> bytes:\n        output = [b\"\"]\n        counter = 1\n\n        while self._algorithm.digest_size * (len(output) - 1) < self._length:\n            h = hmac.HMAC(key_material, self._algorithm)\n            h.update(output[-1])\n            h.update(self._info)\n            h.update(bytes([counter]))\n            output.append(h.finalize())\n            counter += 1\n\n        return b\"\".join(output)[: self._length]\n\n    def derive(self, key_material: bytes) -> bytes:\n        utils._check_byteslike(\"key_material\", key_material)\n        if self._used:\n            raise AlreadyFinalized\n\n        self._used = True\n        return self._expand(key_material)\n\n    def verify(self, key_material: bytes, expected_key: bytes) -> None:\n        if not constant_time.bytes_eq(self.derive(key_material), expected_key):\n            raise InvalidKey\n", "src/cryptography/hazmat/decrepit/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n", "src/cryptography/hazmat/decrepit/ciphers/algorithms.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.primitives._cipheralgorithm import (\n    BlockCipherAlgorithm,\n    CipherAlgorithm,\n    _verify_key_size,\n)\n\n\nclass ARC4(CipherAlgorithm):\n    name = \"RC4\"\n    key_sizes = frozenset([40, 56, 64, 80, 128, 160, 192, 256])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass TripleDES(BlockCipherAlgorithm):\n    name = \"3DES\"\n    block_size = 64\n    key_sizes = frozenset([64, 128, 192])\n\n    def __init__(self, key: bytes):\n        if len(key) == 8:\n            key += key + key\n        elif len(key) == 16:\n            key += key[:8]\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass Blowfish(BlockCipherAlgorithm):\n    name = \"Blowfish\"\n    block_size = 64\n    key_sizes = frozenset(range(32, 449, 8))\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass CAST5(BlockCipherAlgorithm):\n    name = \"CAST5\"\n    block_size = 64\n    key_sizes = frozenset(range(40, 129, 8))\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass SEED(BlockCipherAlgorithm):\n    name = \"SEED\"\n    block_size = 128\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\nclass IDEA(BlockCipherAlgorithm):\n    name = \"IDEA\"\n    block_size = 64\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n\n\n# This class only allows RC2 with a 128-bit key. No support for\n# effective key bits or other key sizes is provided.\nclass RC2(BlockCipherAlgorithm):\n    name = \"RC2\"\n    block_size = 64\n    key_sizes = frozenset([128])\n\n    def __init__(self, key: bytes):\n        self.key = _verify_key_size(self, key)\n\n    @property\n    def key_size(self) -> int:\n        return len(self.key) * 8\n", "src/cryptography/hazmat/decrepit/ciphers/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n", "src/cryptography/hazmat/bindings/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/bindings/openssl/_conditional.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\n\ndef cryptography_has_set_cert_cb() -> list[str]:\n    return [\n        \"SSL_CTX_set_cert_cb\",\n        \"SSL_set_cert_cb\",\n    ]\n\n\ndef cryptography_has_ssl_st() -> list[str]:\n    return [\n        \"SSL_ST_BEFORE\",\n        \"SSL_ST_OK\",\n        \"SSL_ST_INIT\",\n        \"SSL_ST_RENEGOTIATE\",\n    ]\n\n\ndef cryptography_has_tls_st() -> list[str]:\n    return [\n        \"TLS_ST_BEFORE\",\n        \"TLS_ST_OK\",\n    ]\n\n\ndef cryptography_has_ssl_sigalgs() -> list[str]:\n    return [\n        \"SSL_CTX_set1_sigalgs_list\",\n    ]\n\n\ndef cryptography_has_psk() -> list[str]:\n    return [\n        \"SSL_CTX_use_psk_identity_hint\",\n        \"SSL_CTX_set_psk_server_callback\",\n        \"SSL_CTX_set_psk_client_callback\",\n    ]\n\n\ndef cryptography_has_psk_tlsv13() -> list[str]:\n    return [\n        \"SSL_CTX_set_psk_find_session_callback\",\n        \"SSL_CTX_set_psk_use_session_callback\",\n        \"Cryptography_SSL_SESSION_new\",\n        \"SSL_CIPHER_find\",\n        \"SSL_SESSION_set1_master_key\",\n        \"SSL_SESSION_set_cipher\",\n        \"SSL_SESSION_set_protocol_version\",\n    ]\n\n\ndef cryptography_has_custom_ext() -> list[str]:\n    return [\n        \"SSL_CTX_add_client_custom_ext\",\n        \"SSL_CTX_add_server_custom_ext\",\n        \"SSL_extension_supported\",\n    ]\n\n\ndef cryptography_has_tlsv13_functions() -> list[str]:\n    return [\n        \"SSL_VERIFY_POST_HANDSHAKE\",\n        \"SSL_CTX_set_ciphersuites\",\n        \"SSL_verify_client_post_handshake\",\n        \"SSL_CTX_set_post_handshake_auth\",\n        \"SSL_set_post_handshake_auth\",\n        \"SSL_SESSION_get_max_early_data\",\n        \"SSL_write_early_data\",\n        \"SSL_read_early_data\",\n        \"SSL_CTX_set_max_early_data\",\n    ]\n\n\ndef cryptography_has_engine() -> list[str]:\n    return [\n        \"ENGINE_by_id\",\n        \"ENGINE_init\",\n        \"ENGINE_finish\",\n        \"ENGINE_get_default_RAND\",\n        \"ENGINE_set_default_RAND\",\n        \"ENGINE_unregister_RAND\",\n        \"ENGINE_ctrl_cmd\",\n        \"ENGINE_free\",\n        \"ENGINE_get_name\",\n        \"ENGINE_ctrl_cmd_string\",\n        \"ENGINE_load_builtin_engines\",\n        \"ENGINE_load_private_key\",\n        \"ENGINE_load_public_key\",\n        \"SSL_CTX_set_client_cert_engine\",\n    ]\n\n\ndef cryptography_has_verified_chain() -> list[str]:\n    return [\n        \"SSL_get0_verified_chain\",\n    ]\n\n\ndef cryptography_has_srtp() -> list[str]:\n    return [\n        \"SSL_CTX_set_tlsext_use_srtp\",\n        \"SSL_set_tlsext_use_srtp\",\n        \"SSL_get_selected_srtp_profile\",\n    ]\n\n\ndef cryptography_has_op_no_renegotiation() -> list[str]:\n    return [\n        \"SSL_OP_NO_RENEGOTIATION\",\n    ]\n\n\ndef cryptography_has_dtls_get_data_mtu() -> list[str]:\n    return [\n        \"DTLS_get_data_mtu\",\n    ]\n\n\ndef cryptography_has_ssl_cookie() -> list[str]:\n    return [\n        \"SSL_OP_COOKIE_EXCHANGE\",\n        \"DTLSv1_listen\",\n        \"SSL_CTX_set_cookie_generate_cb\",\n        \"SSL_CTX_set_cookie_verify_cb\",\n    ]\n\n\ndef cryptography_has_pkcs7_funcs() -> list[str]:\n    return [\n        \"PKCS7_verify\",\n        \"SMIME_read_PKCS7\",\n    ]\n\n\ndef cryptography_has_prime_checks() -> list[str]:\n    return [\n        \"BN_prime_checks_for_size\",\n    ]\n\n\ndef cryptography_has_unexpected_eof_while_reading() -> list[str]:\n    return [\"SSL_R_UNEXPECTED_EOF_WHILE_READING\"]\n\n\ndef cryptography_has_pkcs12_set_mac() -> list[str]:\n    return [\"PKCS12_set_mac\"]\n\n\ndef cryptography_has_ssl_op_ignore_unexpected_eof() -> list[str]:\n    return [\n        \"SSL_OP_IGNORE_UNEXPECTED_EOF\",\n    ]\n\n\ndef cryptography_has_get_extms_support() -> list[str]:\n    return [\"SSL_get_extms_support\"]\n\n\n# This is a mapping of\n# {condition: function-returning-names-dependent-on-that-condition} so we can\n# loop over them and delete unsupported names at runtime. It will be removed\n# when cffi supports #if in cdef. We use functions instead of just a dict of\n# lists so we can use coverage to measure which are used.\nCONDITIONAL_NAMES = {\n    \"Cryptography_HAS_SET_CERT_CB\": cryptography_has_set_cert_cb,\n    \"Cryptography_HAS_SSL_ST\": cryptography_has_ssl_st,\n    \"Cryptography_HAS_TLS_ST\": cryptography_has_tls_st,\n    \"Cryptography_HAS_SIGALGS\": cryptography_has_ssl_sigalgs,\n    \"Cryptography_HAS_PSK\": cryptography_has_psk,\n    \"Cryptography_HAS_PSK_TLSv1_3\": cryptography_has_psk_tlsv13,\n    \"Cryptography_HAS_CUSTOM_EXT\": cryptography_has_custom_ext,\n    \"Cryptography_HAS_TLSv1_3_FUNCTIONS\": cryptography_has_tlsv13_functions,\n    \"Cryptography_HAS_ENGINE\": cryptography_has_engine,\n    \"Cryptography_HAS_VERIFIED_CHAIN\": cryptography_has_verified_chain,\n    \"Cryptography_HAS_SRTP\": cryptography_has_srtp,\n    \"Cryptography_HAS_OP_NO_RENEGOTIATION\": (\n        cryptography_has_op_no_renegotiation\n    ),\n    \"Cryptography_HAS_DTLS_GET_DATA_MTU\": cryptography_has_dtls_get_data_mtu,\n    \"Cryptography_HAS_SSL_COOKIE\": cryptography_has_ssl_cookie,\n    \"Cryptography_HAS_PKCS7_FUNCS\": cryptography_has_pkcs7_funcs,\n    \"Cryptography_HAS_PRIME_CHECKS\": cryptography_has_prime_checks,\n    \"Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING\": (\n        cryptography_has_unexpected_eof_while_reading\n    ),\n    \"Cryptography_HAS_PKCS12_SET_MAC\": cryptography_has_pkcs12_set_mac,\n    \"Cryptography_HAS_SSL_OP_IGNORE_UNEXPECTED_EOF\": (\n        cryptography_has_ssl_op_ignore_unexpected_eof\n    ),\n    \"Cryptography_HAS_GET_EXTMS_SUPPORT\": cryptography_has_get_extms_support,\n}\n", "src/cryptography/hazmat/bindings/openssl/binding.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport os\nimport sys\nimport threading\nimport types\nimport typing\nimport warnings\n\nimport cryptography\nfrom cryptography.exceptions import InternalError\nfrom cryptography.hazmat.bindings._rust import _openssl, openssl\nfrom cryptography.hazmat.bindings.openssl._conditional import CONDITIONAL_NAMES\n\n\ndef _openssl_assert(ok: bool) -> None:\n    if not ok:\n        errors = openssl.capture_error_stack()\n\n        raise InternalError(\n            \"Unknown OpenSSL error. This error is commonly encountered when \"\n            \"another library is not cleaning up the OpenSSL error stack. If \"\n            \"you are using cryptography with another library that uses \"\n            \"OpenSSL try disabling it before reporting a bug. Otherwise \"\n            \"please file an issue at https://github.com/pyca/cryptography/\"\n            \"issues with information on how to reproduce \"\n            f\"this. ({errors!r})\",\n            errors,\n        )\n\n\ndef build_conditional_library(\n    lib: typing.Any,\n    conditional_names: dict[str, typing.Callable[[], list[str]]],\n) -> typing.Any:\n    conditional_lib = types.ModuleType(\"lib\")\n    conditional_lib._original_lib = lib  # type: ignore[attr-defined]\n    excluded_names = set()\n    for condition, names_cb in conditional_names.items():\n        if not getattr(lib, condition):\n            excluded_names.update(names_cb())\n\n    for attr in dir(lib):\n        if attr not in excluded_names:\n            setattr(conditional_lib, attr, getattr(lib, attr))\n\n    return conditional_lib\n\n\nclass Binding:\n    \"\"\"\n    OpenSSL API wrapper.\n    \"\"\"\n\n    lib: typing.ClassVar = None\n    ffi = _openssl.ffi\n    _lib_loaded = False\n    _init_lock = threading.Lock()\n\n    def __init__(self) -> None:\n        self._ensure_ffi_initialized()\n\n    @classmethod\n    def _ensure_ffi_initialized(cls) -> None:\n        with cls._init_lock:\n            if not cls._lib_loaded:\n                cls.lib = build_conditional_library(\n                    _openssl.lib, CONDITIONAL_NAMES\n                )\n                cls._lib_loaded = True\n\n    @classmethod\n    def init_static_locks(cls) -> None:\n        cls._ensure_ffi_initialized()\n\n\ndef _verify_package_version(version: str) -> None:\n    # Occasionally we run into situations where the version of the Python\n    # package does not match the version of the shared object that is loaded.\n    # This may occur in environments where multiple versions of cryptography\n    # are installed and available in the python path. To avoid errors cropping\n    # up later this code checks that the currently imported package and the\n    # shared object that were loaded have the same version and raise an\n    # ImportError if they do not\n    so_package_version = _openssl.ffi.string(\n        _openssl.lib.CRYPTOGRAPHY_PACKAGE_VERSION\n    )\n    if version.encode(\"ascii\") != so_package_version:\n        raise ImportError(\n            \"The version of cryptography does not match the loaded \"\n            \"shared object. This can happen if you have multiple copies of \"\n            \"cryptography installed in your Python path. Please try creating \"\n            \"a new virtual environment to resolve this issue. \"\n            f\"Loaded python version: {version}, \"\n            f\"shared object version: {so_package_version}\"\n        )\n\n    _openssl_assert(\n        _openssl.lib.OpenSSL_version_num() == openssl.openssl_version(),\n    )\n\n\n_verify_package_version(cryptography.__version__)\n\nBinding.init_static_locks()\n\nif (\n    sys.platform == \"win32\"\n    and os.environ.get(\"PROCESSOR_ARCHITEW6432\") is not None\n):\n    warnings.warn(\n        \"You are using cryptography on a 32-bit Python on a 64-bit Windows \"\n        \"Operating System. Cryptography will be significantly faster if you \"\n        \"switch to using a 64-bit Python.\",\n        UserWarning,\n        stacklevel=2,\n    )\n", "src/cryptography/hazmat/bindings/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n", "src/cryptography/hazmat/backends/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom typing import Any\n\n\ndef default_backend() -> Any:\n    from cryptography.hazmat.backends.openssl.backend import backend\n\n    return backend\n", "src/cryptography/hazmat/backends/openssl/backend.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nimport collections\nimport contextlib\nimport typing\n\nfrom cryptography import utils, x509\nfrom cryptography.exceptions import UnsupportedAlgorithm\nfrom cryptography.hazmat.bindings._rust import openssl as rust_openssl\nfrom cryptography.hazmat.bindings.openssl import binding\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives._asymmetric import AsymmetricPadding\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import utils as asym_utils\nfrom cryptography.hazmat.primitives.asymmetric.padding import (\n    MGF1,\n    OAEP,\n    PSS,\n    PKCS1v15,\n)\nfrom cryptography.hazmat.primitives.ciphers import (\n    CipherAlgorithm,\n)\nfrom cryptography.hazmat.primitives.ciphers.algorithms import (\n    AES,\n)\nfrom cryptography.hazmat.primitives.ciphers.modes import (\n    CBC,\n    Mode,\n)\nfrom cryptography.hazmat.primitives.serialization.pkcs12 import (\n    PBES,\n    PKCS12Certificate,\n    PKCS12PrivateKeyTypes,\n    _PKCS12CATypes,\n)\n\n_MemoryBIO = collections.namedtuple(\"_MemoryBIO\", [\"bio\", \"char_ptr\"])\n\n\nclass Backend:\n    \"\"\"\n    OpenSSL API binding interfaces.\n    \"\"\"\n\n    name = \"openssl\"\n\n    # TripleDES encryption is disallowed/deprecated throughout 2023 in\n    # FIPS 140-3. To keep it simple we denylist any use of TripleDES (TDEA).\n    _fips_ciphers = (AES,)\n    # Sometimes SHA1 is still permissible. That logic is contained\n    # within the various *_supported methods.\n    _fips_hashes = (\n        hashes.SHA224,\n        hashes.SHA256,\n        hashes.SHA384,\n        hashes.SHA512,\n        hashes.SHA512_224,\n        hashes.SHA512_256,\n        hashes.SHA3_224,\n        hashes.SHA3_256,\n        hashes.SHA3_384,\n        hashes.SHA3_512,\n        hashes.SHAKE128,\n        hashes.SHAKE256,\n    )\n    _fips_ecdh_curves = (\n        ec.SECP224R1,\n        ec.SECP256R1,\n        ec.SECP384R1,\n        ec.SECP521R1,\n    )\n    _fips_rsa_min_key_size = 2048\n    _fips_rsa_min_public_exponent = 65537\n    _fips_dsa_min_modulus = 1 << 2048\n    _fips_dh_min_key_size = 2048\n    _fips_dh_min_modulus = 1 << _fips_dh_min_key_size\n\n    def __init__(self) -> None:\n        self._binding = binding.Binding()\n        self._ffi = self._binding.ffi\n        self._lib = self._binding.lib\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def __repr__(self) -> str:\n        return (\n            f\"<OpenSSLBackend(version: {self.openssl_version_text()}, \"\n            f\"FIPS: {self._fips_enabled}, \"\n            f\"Legacy: {rust_openssl._legacy_provider_loaded})>\"\n        )\n\n    def openssl_assert(self, ok: bool) -> None:\n        return binding._openssl_assert(ok)\n\n    def _enable_fips(self) -> None:\n        # This function enables FIPS mode for OpenSSL 3.0.0 on installs that\n        # have the FIPS provider installed properly.\n        rust_openssl.enable_fips(rust_openssl._providers)\n        assert rust_openssl.is_fips_enabled()\n        self._fips_enabled = rust_openssl.is_fips_enabled()\n\n    def openssl_version_text(self) -> str:\n        \"\"\"\n        Friendly string name of the loaded OpenSSL library. This is not\n        necessarily the same version as it was compiled against.\n\n        Example: OpenSSL 3.2.1 30 Jan 2024\n        \"\"\"\n        return rust_openssl.openssl_version_text()\n\n    def openssl_version_number(self) -> int:\n        return rust_openssl.openssl_version()\n\n    def _evp_md_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        if algorithm.name in (\"blake2b\", \"blake2s\"):\n            alg = f\"{algorithm.name}{algorithm.digest_size * 8}\".encode(\n                \"ascii\"\n            )\n        else:\n            alg = algorithm.name.encode(\"ascii\")\n\n        evp_md = self._lib.EVP_get_digestbyname(alg)\n        return evp_md\n\n    def _evp_md_non_null_from_algorithm(self, algorithm: hashes.HashAlgorithm):\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        self.openssl_assert(evp_md != self._ffi.NULL)\n        return evp_md\n\n    def hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and not isinstance(algorithm, self._fips_hashes):\n            return False\n\n        evp_md = self._evp_md_from_algorithm(algorithm)\n        return evp_md != self._ffi.NULL\n\n    def signature_hash_supported(\n        self, algorithm: hashes.HashAlgorithm\n    ) -> bool:\n        # Dedicated check for hashing algorithm use in message digest for\n        # signatures, e.g. RSA PKCS#1 v1.5 SHA1 (sha1WithRSAEncryption).\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n        return self.hash_supported(algorithm)\n\n    def scrypt_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        else:\n            return hasattr(rust_openssl.kdf, \"derive_scrypt\")\n\n    def hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        # FIPS mode still allows SHA1 for HMAC\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return True\n\n        return self.hash_supported(algorithm)\n\n    def cipher_supported(self, cipher: CipherAlgorithm, mode: Mode) -> bool:\n        if self._fips_enabled:\n            # FIPS mode requires AES. TripleDES is disallowed/deprecated in\n            # FIPS 140-3.\n            if not isinstance(cipher, self._fips_ciphers):\n                return False\n\n        return rust_openssl.ciphers.cipher_supported(cipher, mode)\n\n    def pbkdf2_hmac_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        return self.hmac_supported(algorithm)\n\n    def _consume_errors(self) -> list[rust_openssl.OpenSSLError]:\n        return rust_openssl.capture_error_stack()\n\n    def _bytes_to_bio(self, data: bytes) -> _MemoryBIO:\n        \"\"\"\n        Return a _MemoryBIO namedtuple of (BIO, char*).\n\n        The char* is the storage for the BIO and it must stay alive until the\n        BIO is finished with.\n        \"\"\"\n        data_ptr = self._ffi.from_buffer(data)\n        bio = self._lib.BIO_new_mem_buf(data_ptr, len(data))\n        self.openssl_assert(bio != self._ffi.NULL)\n\n        return _MemoryBIO(self._ffi.gc(bio, self._lib.BIO_free), data_ptr)\n\n    def _create_mem_bio_gc(self):\n        \"\"\"\n        Creates an empty memory BIO.\n        \"\"\"\n        bio_method = self._lib.BIO_s_mem()\n        self.openssl_assert(bio_method != self._ffi.NULL)\n        bio = self._lib.BIO_new(bio_method)\n        self.openssl_assert(bio != self._ffi.NULL)\n        bio = self._ffi.gc(bio, self._lib.BIO_free)\n        return bio\n\n    def _read_mem_bio(self, bio) -> bytes:\n        \"\"\"\n        Reads a memory BIO. This only works on memory BIOs.\n        \"\"\"\n        buf = self._ffi.new(\"char **\")\n        buf_len = self._lib.BIO_get_mem_data(bio, buf)\n        self.openssl_assert(buf_len > 0)\n        self.openssl_assert(buf[0] != self._ffi.NULL)\n        bio_data = self._ffi.buffer(buf[0], buf_len)[:]\n        return bio_data\n\n    def _oaep_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if self._fips_enabled and isinstance(algorithm, hashes.SHA1):\n            return False\n\n        return isinstance(\n            algorithm,\n            (\n                hashes.SHA1,\n                hashes.SHA224,\n                hashes.SHA256,\n                hashes.SHA384,\n                hashes.SHA512,\n            ),\n        )\n\n    def rsa_padding_supported(self, padding: AsymmetricPadding) -> bool:\n        if isinstance(padding, PKCS1v15):\n            return True\n        elif isinstance(padding, PSS) and isinstance(padding._mgf, MGF1):\n            # SHA1 is permissible in MGF1 in FIPS even when SHA1 is blocked\n            # as signature algorithm.\n            if self._fips_enabled and isinstance(\n                padding._mgf._algorithm, hashes.SHA1\n            ):\n                return True\n            else:\n                return self.hash_supported(padding._mgf._algorithm)\n        elif isinstance(padding, OAEP) and isinstance(padding._mgf, MGF1):\n            return self._oaep_hash_supported(\n                padding._mgf._algorithm\n            ) and self._oaep_hash_supported(padding._algorithm)\n        else:\n            return False\n\n    def rsa_encryption_supported(self, padding: AsymmetricPadding) -> bool:\n        if self._fips_enabled and isinstance(padding, PKCS1v15):\n            return False\n        else:\n            return self.rsa_padding_supported(padding)\n\n    def dsa_supported(self) -> bool:\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n            and not self._fips_enabled\n        )\n\n    def dsa_hash_supported(self, algorithm: hashes.HashAlgorithm) -> bool:\n        if not self.dsa_supported():\n            return False\n        return self.signature_hash_supported(algorithm)\n\n    def cmac_algorithm_supported(self, algorithm) -> bool:\n        return self.cipher_supported(\n            algorithm, CBC(b\"\\x00\" * algorithm.block_size)\n        )\n\n    def _cert2ossl(self, cert: x509.Certificate) -> typing.Any:\n        data = cert.public_bytes(serialization.Encoding.DER)\n        mem_bio = self._bytes_to_bio(data)\n        x509 = self._lib.d2i_X509_bio(mem_bio.bio, self._ffi.NULL)\n        self.openssl_assert(x509 != self._ffi.NULL)\n        x509 = self._ffi.gc(x509, self._lib.X509_free)\n        return x509\n\n    def _key2ossl(self, key: PKCS12PrivateKeyTypes) -> typing.Any:\n        data = key.private_bytes(\n            serialization.Encoding.DER,\n            serialization.PrivateFormat.PKCS8,\n            serialization.NoEncryption(),\n        )\n        mem_bio = self._bytes_to_bio(data)\n\n        evp_pkey = self._lib.d2i_PrivateKey_bio(\n            mem_bio.bio,\n            self._ffi.NULL,\n        )\n        self.openssl_assert(evp_pkey != self._ffi.NULL)\n        return self._ffi.gc(evp_pkey, self._lib.EVP_PKEY_free)\n\n    def elliptic_curve_supported(self, curve: ec.EllipticCurve) -> bool:\n        if self._fips_enabled and not isinstance(\n            curve, self._fips_ecdh_curves\n        ):\n            return False\n\n        return rust_openssl.ec.curve_supported(curve)\n\n    def elliptic_curve_signature_algorithm_supported(\n        self,\n        signature_algorithm: ec.EllipticCurveSignatureAlgorithm,\n        curve: ec.EllipticCurve,\n    ) -> bool:\n        # We only support ECDSA right now.\n        if not isinstance(signature_algorithm, ec.ECDSA):\n            return False\n\n        return self.elliptic_curve_supported(curve) and (\n            isinstance(signature_algorithm.algorithm, asym_utils.Prehashed)\n            or self.hash_supported(signature_algorithm.algorithm)\n        )\n\n    def elliptic_curve_exchange_algorithm_supported(\n        self, algorithm: ec.ECDH, curve: ec.EllipticCurve\n    ) -> bool:\n        return self.elliptic_curve_supported(curve) and isinstance(\n            algorithm, ec.ECDH\n        )\n\n    def dh_supported(self) -> bool:\n        return not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n\n    def dh_x942_serialization_supported(self) -> bool:\n        return self._lib.Cryptography_HAS_EVP_PKEY_DHX == 1\n\n    def x25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def x448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL\n            and not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ed25519_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def ed448_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return (\n            not rust_openssl.CRYPTOGRAPHY_IS_LIBRESSL\n            and not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n        )\n\n    def ecdsa_deterministic_supported(self) -> bool:\n        return (\n            rust_openssl.CRYPTOGRAPHY_OPENSSL_320_OR_GREATER\n            and not self._fips_enabled\n        )\n\n    def _zero_data(self, data, length: int) -> None:\n        # We clear things this way because at the moment we're not\n        # sure of a better way that can guarantee it overwrites the\n        # memory of a bytearray and doesn't just replace the underlying char *.\n        for i in range(length):\n            data[i] = 0\n\n    @contextlib.contextmanager\n    def _zeroed_null_terminated_buf(self, data):\n        \"\"\"\n        This method takes bytes, which can be a bytestring or a mutable\n        buffer like a bytearray, and yields a null-terminated version of that\n        data. This is required because PKCS12_parse doesn't take a length with\n        its password char * and ffi.from_buffer doesn't provide null\n        termination. So, to support zeroing the data via bytearray we\n        need to build this ridiculous construct that copies the memory, but\n        zeroes it after use.\n        \"\"\"\n        if data is None:\n            yield self._ffi.NULL\n        else:\n            data_len = len(data)\n            buf = self._ffi.new(\"char[]\", data_len + 1)\n            self._ffi.memmove(buf, data, data_len)\n            try:\n                yield buf\n            finally:\n                # Cast to a uint8_t * so we can assign by integer\n                self._zero_data(self._ffi.cast(\"uint8_t *\", buf), data_len)\n\n    def serialize_key_and_certificates_to_pkcs12(\n        self,\n        name: bytes | None,\n        key: PKCS12PrivateKeyTypes | None,\n        cert: x509.Certificate | None,\n        cas: list[_PKCS12CATypes] | None,\n        encryption_algorithm: serialization.KeySerializationEncryption,\n    ) -> bytes:\n        password = None\n        if name is not None:\n            utils._check_bytes(\"name\", name)\n\n        assert not isinstance(encryption_algorithm, serialization.NoEncryption)\n        if isinstance(\n            encryption_algorithm, serialization.BestAvailableEncryption\n        ):\n            # PKCS12 encryption is hopeless trash and can never be fixed.\n            # OpenSSL 3 supports PBESv2, but Libre and Boring do not, so\n            # we use PBESv1 with 3DES on the older paths.\n            if rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            # At least we can set this higher than OpenSSL's default\n            pkcs12_iter = 20000\n            mac_iter = 0\n            # MAC algorithm can only be set on OpenSSL 3.0.0+\n            mac_alg = self._ffi.NULL\n            password = encryption_algorithm.password\n        elif (\n            isinstance(\n                encryption_algorithm, serialization._KeySerializationEncryption\n            )\n            and encryption_algorithm._format\n            is serialization.PrivateFormat.PKCS12\n        ):\n            # Default to OpenSSL's defaults. Behavior will vary based on the\n            # version of OpenSSL cryptography is compiled against.\n            nid_cert = 0\n            nid_key = 0\n            # Use the default iters we use in best available\n            pkcs12_iter = 20000\n            mac_iter = 0\n            password = encryption_algorithm.password\n            keycertalg = encryption_algorithm._key_cert_algorithm\n            if keycertalg is PBES.PBESv1SHA1And3KeyTripleDESCBC:\n                nid_cert = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n                nid_key = self._lib.NID_pbe_WithSHA1And3_Key_TripleDES_CBC\n            elif keycertalg is PBES.PBESv2SHA256AndAES256CBC:\n                if not rust_openssl.CRYPTOGRAPHY_OPENSSL_300_OR_GREATER:\n                    raise UnsupportedAlgorithm(\n                        \"PBESv2 is not supported by this version of OpenSSL\"\n                    )\n                nid_cert = self._lib.NID_aes_256_cbc\n                nid_key = self._lib.NID_aes_256_cbc\n            else:\n                assert keycertalg is None\n                # We use OpenSSL's defaults\n\n            if encryption_algorithm._hmac_hash is not None:\n                if not self._lib.Cryptography_HAS_PKCS12_SET_MAC:\n                    raise UnsupportedAlgorithm(\n                        \"Setting MAC algorithm is not supported by this \"\n                        \"version of OpenSSL.\"\n                    )\n                mac_alg = self._evp_md_non_null_from_algorithm(\n                    encryption_algorithm._hmac_hash\n                )\n                self.openssl_assert(mac_alg != self._ffi.NULL)\n            else:\n                mac_alg = self._ffi.NULL\n\n            if encryption_algorithm._kdf_rounds is not None:\n                pkcs12_iter = encryption_algorithm._kdf_rounds\n\n        else:\n            raise ValueError(\"Unsupported key encryption type\")\n\n        if cas is None or len(cas) == 0:\n            sk_x509 = self._ffi.NULL\n        else:\n            sk_x509 = self._lib.sk_X509_new_null()\n            sk_x509 = self._ffi.gc(sk_x509, self._lib.sk_X509_free)\n\n            # This list is to keep the x509 values alive until end of function\n            ossl_cas = []\n            for ca in cas:\n                if isinstance(ca, PKCS12Certificate):\n                    ca_alias = ca.friendly_name\n                    ossl_ca = self._cert2ossl(ca.certificate)\n                    if ca_alias is None:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, self._ffi.NULL, -1\n                        )\n                    else:\n                        res = self._lib.X509_alias_set1(\n                            ossl_ca, ca_alias, len(ca_alias)\n                        )\n                    self.openssl_assert(res == 1)\n                else:\n                    ossl_ca = self._cert2ossl(ca)\n                ossl_cas.append(ossl_ca)\n                res = self._lib.sk_X509_push(sk_x509, ossl_ca)\n                backend.openssl_assert(res >= 1)\n\n        with self._zeroed_null_terminated_buf(password) as password_buf:\n            with self._zeroed_null_terminated_buf(name) as name_buf:\n                ossl_cert = self._cert2ossl(cert) if cert else self._ffi.NULL\n                ossl_pkey = (\n                    self._key2ossl(key) if key is not None else self._ffi.NULL\n                )\n\n                p12 = self._lib.PKCS12_create(\n                    password_buf,\n                    name_buf,\n                    ossl_pkey,\n                    ossl_cert,\n                    sk_x509,\n                    nid_key,\n                    nid_cert,\n                    pkcs12_iter,\n                    mac_iter,\n                    0,\n                )\n                if p12 == self._ffi.NULL:\n                    errors = self._consume_errors()\n                    raise ValueError(\n                        (\n                            \"Failed to create PKCS12 (does the key match the \"\n                            \"certificate?)\"\n                        ),\n                        errors,\n                    )\n\n            if (\n                self._lib.Cryptography_HAS_PKCS12_SET_MAC\n                and mac_alg != self._ffi.NULL\n            ):\n                self._lib.PKCS12_set_mac(\n                    p12,\n                    password_buf,\n                    -1,\n                    self._ffi.NULL,\n                    0,\n                    mac_iter,\n                    mac_alg,\n                )\n\n        self.openssl_assert(p12 != self._ffi.NULL)\n        p12 = self._ffi.gc(p12, self._lib.PKCS12_free)\n\n        bio = self._create_mem_bio_gc()\n        res = self._lib.i2d_PKCS12_bio(bio, p12)\n        self.openssl_assert(res > 0)\n        return self._read_mem_bio(bio)\n\n    def poly1305_supported(self) -> bool:\n        if self._fips_enabled:\n            return False\n        return True\n\n    def pkcs7_supported(self) -> bool:\n        return not rust_openssl.CRYPTOGRAPHY_IS_BORINGSSL\n\n\nbackend = Backend()\n", "src/cryptography/hazmat/backends/openssl/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nfrom __future__ import annotations\n\nfrom cryptography.hazmat.backends.openssl.backend import backend\n\n__all__ = [\"backend\"]\n", "vectors/cryptography_vectors/__init__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\nimport os\nimport typing\n\nfrom cryptography_vectors.__about__ import __version__\n\n__all__ = [\n    \"__version__\",\n]\n\n\ndef open_vector_file(filename: str, mode: str) -> typing.IO:\n    base = os.path.dirname(__file__)\n    return open(os.path.join(base, filename), mode)\n", "vectors/cryptography_vectors/__about__.py": "# This file is dual licensed under the terms of the Apache License, Version\n# 2.0, and the BSD License. See the LICENSE file in the root of this repository\n# for complete details.\n\n__all__ = [\n    \"__version__\",\n]\n\n__version__ = \"43.0.0.dev1\"\n"}