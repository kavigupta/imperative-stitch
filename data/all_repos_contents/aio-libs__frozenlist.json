{"docs/conf.py": "#!/usr/bin/env python3\n#\n# frozenlist documentation build configuration file, created by\n# sphinx-quickstart on Wed Mar  5 12:35:35 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport os\nimport re\nfrom contextlib import suppress\nfrom pathlib import Path\n\nPROJECT_ROOT_DIR = Path(__file__).parents[1].resolve()\nIS_RELEASE_ON_RTD = (\n    os.getenv(\"READTHEDOCS\", \"False\") == \"True\"\n    and os.environ[\"READTHEDOCS_VERSION_TYPE\"] == \"tag\"\n)\nif IS_RELEASE_ON_RTD:\n    tags.add(\"is_release\")\n\n\n_docs_path = Path(__file__).parent\n_version_path = _docs_path / \"..\" / \"frozenlist\" / \"__init__.py\"\n\n\nwith _version_path.open(encoding=\"utf-8\") as fp:\n    try:\n        _version_info = re.search(\n            r'^__version__ = \"'\n            r\"(?P<major>\\d+)\"\n            r\"\\.(?P<minor>\\d+)\"\n            r\"\\.(?P<patch>\\d+)\"\n            r'(?P<tag>.*)?\"$',\n            fp.read(),\n            re.M,\n        ).groupdict()\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    # stdlib-party extensions:\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx.ext.intersphinx\",\n    # Third-party extensions:\n    \"sphinxcontrib.towncrier.ext\",  # provides `towncrier-draft-entries` directive\n]\n\n\nwith suppress(ImportError):\n    # spelling extension is optional, only add it when installed\n    import sphinxcontrib.spelling  # noqa # type: ignore\n\n    extensions.append(\"sphinxcontrib.spelling\")\n\n\nintersphinx_mapping = {\n    \"python\": (\"http://docs.python.org/3\", None),\n    \"aiohttp\": (\"https://docs.aiohttp.org/en/stable/\", None),\n}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\n\ngithub_url = \"https://github.com\"\ngithub_repo_org = \"aio-libs\"\ngithub_repo_name = \"frozenlist\"\ngithub_repo_slug = f\"{github_repo_org}/{github_repo_name}\"\ngithub_repo_url = f\"{github_url}/{github_repo_slug}\"\ngithub_sponsors_url = f\"{github_url}/sponsors\"\n\nproject = github_repo_name\ncopyright = \"2013, frozenlist contributors\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \"{major}.{minor}\".format(**_version_info)\n# The full version, including alpha/beta/rc tags.\nrelease = \"{major}.{minor}.{patch}{tag}\".format(**_version_info)\n\nrst_epilog = f\"\"\"\n.. |project| replace:: {project}\n\"\"\"  # pylint: disable=invalid-name\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\n# pygments_style = 'sphinx'\n\n# The default language to highlight source code in.\nhighlight_language = \"python3\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for extlinks extension ---------------------------------------\nextlinks = {\n    \"issue\": (f\"{github_repo_url}/issues/%s\", \"#%s\"),\n    \"pr\": (f\"{github_repo_url}/pull/%s\", \"PR #%s\"),\n    \"commit\": (f\"{github_repo_url}/commit/%s\", \"%s\"),\n    \"gh\": (f\"{github_url}/%s\", \"GitHub: %s\"),\n    \"user\": (f\"{github_sponsors_url}/%s\", \"@%s\"),\n}\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"aiohttp_theme\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \"logo\": None,\n    \"description\": (\n        \"A list-like structure which implements collections.abc.MutableSequence\"\n    ),\n    \"canonical_url\": \"https://frozenlist.aio-libs.org/en/stable/\",\n    \"github_user\": github_repo_org,\n    \"github_repo\": github_repo_name,\n    \"github_button\": True,\n    \"github_type\": \"star\",\n    \"github_banner\": True,\n    \"badges\": [\n        {\n            \"image\": f\"{github_repo_url}/workflows/CI/badge.svg\",\n            \"target\": f\"{github_repo_url}/actions\",\n            \"height\": \"20\",\n            \"alt\": \"Github CI status for master branch\",\n        },\n        {\n            \"image\": (\n                f\"https://codecov.io/github/{github_repo_slug}/coverage.svg\"\n                \"?branch=master\"\n            ),\n            \"target\": f\"https://codecov.io/github/{github_repo_slug}\",\n            \"height\": \"20\",\n            \"alt\": \"Code coverage status\",\n        },\n        {\n            \"image\": f\"https://badge.fury.io/py/{github_repo_name}.svg\",\n            \"target\": f\"https://badge.fury.io/py/{github_repo_name}\",\n            \"height\": \"20\",\n            \"alt\": \"Latest PyPI package version\",\n        },\n        {\n            \"image\": \"https://img.shields.io/matrix/aio-libs-space:matrix.org?label=Discuss%20on%20Matrix%20at%20%23aio-libs-space%3Amatrix.org&logo=matrix&server_fqdn=matrix.org&style=flat\",\n            \"target\": \"https://matrix.to/#/%23aio-libs-space:matrix.org\",\n            \"height\": \"20\",\n            \"alt\": \"Matrix Space\",\n        },\n    ],\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = [alabaster.get_path()]\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = 'frozenlist-icon.svg'\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = 'favicon.ico'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = []\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n# html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \"**\": [\n        \"about.html\",\n        \"navigation.html\",\n        \"searchbox.html\",\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = f\"{github_repo_name}doc\"\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    # 'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        \"index\",\n        f\"{github_repo_name}.tex\",\n        f\"{github_repo_name} Documentation\",\n        f\"{github_repo_name} contributors\",\n        \"manual\",\n    ),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\n        \"index\",\n        github_repo_name,\n        f\"{github_repo_name} Documentation\",\n        [github_repo_name],\n        1,\n    )\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        github_repo_name,\n        f\"{github_repo_name} Documentation\",\n        f\"{github_repo_name} contributors\",\n        github_repo_name,\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n\n# -- Strictness options --------------------------------------------------\nnitpicky = True\nnitpick_ignore = []\n\n# -- Options for towncrier_draft extension -----------------------------------\n\ntowncrier_draft_autoversion_mode = \"draft\"  # or: 'sphinx-version', 'sphinx-release'\ntowncrier_draft_include_empty = True\ntowncrier_draft_working_directory = PROJECT_ROOT_DIR\ntowncrier_draft_config_path = \"pyproject.toml\"  # relative to cwd\n", "tests/conftest.py": "", "tests/test_frozenlist.py": "# FIXME:\n# mypy: disable-error-code=\"misc\"\n\nfrom collections.abc import MutableSequence\n\nimport pytest\n\nfrom frozenlist import FrozenList, PyFrozenList\n\n\nclass FrozenListMixin:\n    FrozenList = NotImplemented\n\n    SKIP_METHODS = {\"__abstractmethods__\", \"__slots__\"}\n\n    def test___class_getitem__(self) -> None:\n        assert self.FrozenList[str] is not None\n\n    def test_subclass(self) -> None:\n        assert issubclass(self.FrozenList, MutableSequence)\n\n    def test_iface(self) -> None:\n        for name in set(dir(MutableSequence)) - self.SKIP_METHODS:\n            if name.startswith(\"_\") and not name.endswith(\"_\"):\n                continue\n            assert hasattr(self.FrozenList, name)\n\n    def test_ctor_default(self) -> None:\n        _list = self.FrozenList([])\n        assert not _list.frozen\n\n    def test_ctor(self) -> None:\n        _list = self.FrozenList([1])\n        assert not _list.frozen\n\n    def test_ctor_copy_list(self) -> None:\n        orig = [1]\n        _list = self.FrozenList(orig)\n        del _list[0]\n        assert _list != orig\n\n    def test_freeze(self) -> None:\n        _list = self.FrozenList()\n        _list.freeze()\n        assert _list.frozen\n\n    def test_repr(self) -> None:\n        _list = self.FrozenList([1])\n        assert repr(_list) == \"<FrozenList(frozen=False, [1])>\"\n        _list.freeze()\n        assert repr(_list) == \"<FrozenList(frozen=True, [1])>\"\n\n    def test_getitem(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert _list[1] == 2\n\n    def test_setitem(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list[1] = 3\n        assert _list[1] == 3\n\n    def test_delitem(self) -> None:\n        _list = self.FrozenList([1, 2])\n        del _list[0]\n        assert len(_list) == 1\n        assert _list[0] == 2\n\n    def test_len(self) -> None:\n        _list = self.FrozenList([1])\n        assert len(_list) == 1\n\n    def test_iter(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert list(iter(_list)) == [1, 2]\n\n    def test_reversed(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert list(reversed(_list)) == [2, 1]\n\n    def test_eq(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list == [1]\n\n    def test_ne(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list != [2]\n\n    def test_le(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list <= [1]\n\n    def test_lt(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list < [3]\n\n    def test_ge(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list >= [1]\n\n    def test_gt(self) -> None:\n        _list = self.FrozenList([2])\n        assert _list > [1]\n\n    def test_insert(self) -> None:\n        _list = self.FrozenList([2])\n        _list.insert(0, 1)\n        assert _list == [1, 2]\n\n    def test_frozen_setitem(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list[0] = 2\n\n    def test_frozen_delitem(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            del _list[0]\n\n    def test_frozen_insert(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.insert(0, 2)\n\n    def test_contains(self) -> None:\n        _list = self.FrozenList([2])\n        assert 2 in _list\n\n    def test_iadd(self) -> None:\n        _list = self.FrozenList([1])\n        _list += [2]\n        assert _list == [1, 2]\n\n    def test_iadd_frozen(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list += [2]\n        assert _list == [1]\n\n    def test_index(self) -> None:\n        _list = self.FrozenList([1])\n        assert _list.index(1) == 0\n\n    def test_remove(self) -> None:\n        _list = self.FrozenList([1])\n        _list.remove(1)\n        assert len(_list) == 0\n\n    def test_remove_frozen(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.remove(1)\n        assert _list == [1]\n\n    def test_clear(self) -> None:\n        _list = self.FrozenList([1])\n        _list.clear()\n        assert len(_list) == 0\n\n    def test_clear_frozen(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.clear()\n        assert _list == [1]\n\n    def test_extend(self) -> None:\n        _list = self.FrozenList([1])\n        _list.extend([2])\n        assert _list == [1, 2]\n\n    def test_extend_frozen(self) -> None:\n        _list = self.FrozenList([1])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.extend([2])\n        assert _list == [1]\n\n    def test_reverse(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.reverse()\n        assert _list == [2, 1]\n\n    def test_reverse_frozen(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.reverse()\n        assert _list == [1, 2]\n\n    def test_pop(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert _list.pop(0) == 1\n        assert _list == [2]\n\n    def test_pop_default(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert _list.pop() == 2\n        assert _list == [1]\n\n    def test_pop_frozen(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.pop()\n        assert _list == [1, 2]\n\n    def test_append(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.append(3)\n        assert _list == [1, 2, 3]\n\n    def test_append_frozen(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.freeze()\n        with pytest.raises(RuntimeError):\n            _list.append(3)\n        assert _list == [1, 2]\n\n    def test_hash(self) -> None:\n        _list = self.FrozenList([1, 2])\n        with pytest.raises(RuntimeError):\n            hash(_list)\n\n    def test_hash_frozen(self) -> None:\n        _list = self.FrozenList([1, 2])\n        _list.freeze()\n        h = hash(_list)\n        assert h == hash((1, 2))\n\n    def test_dict_key(self) -> None:\n        _list = self.FrozenList([1, 2])\n        with pytest.raises(RuntimeError):\n            {_list: \"hello\"}\n        _list.freeze()\n        {_list: \"hello\"}\n\n    def test_count(self) -> None:\n        _list = self.FrozenList([1, 2])\n        assert _list.count(1) == 1\n\n\nclass TestFrozenList(FrozenListMixin):\n    FrozenList = FrozenList  # type: ignore[assignment]  # FIXME\n\n\nclass TestFrozenListPy(FrozenListMixin):\n    FrozenList = PyFrozenList  # type: ignore[assignment]  # FIXME\n", "frozenlist/__init__.py": "import os\nimport sys\nimport types\nfrom collections.abc import MutableSequence\nfrom functools import total_ordering\nfrom typing import Any, Type\n\n__version__ = \"1.4.2.dev0\"\n\n__all__ = (\"FrozenList\", \"PyFrozenList\")  # type: Tuple[str, ...]\n\n\nNO_EXTENSIONS = bool(os.environ.get(\"FROZENLIST_NO_EXTENSIONS\"))  # type: bool\n\n\n@total_ordering\nclass FrozenList(MutableSequence):\n    __slots__ = (\"_frozen\", \"_items\")\n\n    if sys.version_info >= (3, 9):\n        __class_getitem__ = classmethod(types.GenericAlias)\n    else:\n\n        @classmethod\n        def __class_getitem__(\n            cls: Type[\"FrozenList\"],\n            cls_item: Any,\n        ) -> Type[\"FrozenList\"]:\n            return cls\n\n    def __init__(self, items=None):\n        self._frozen = False\n        if items is not None:\n            items = list(items)\n        else:\n            items = []\n        self._items = items\n\n    @property\n    def frozen(self):\n        return self._frozen\n\n    def freeze(self):\n        self._frozen = True\n\n    def __getitem__(self, index):\n        return self._items[index]\n\n    def __setitem__(self, index, value):\n        if self._frozen:\n            raise RuntimeError(\"Cannot modify frozen list.\")\n        self._items[index] = value\n\n    def __delitem__(self, index):\n        if self._frozen:\n            raise RuntimeError(\"Cannot modify frozen list.\")\n        del self._items[index]\n\n    def __len__(self):\n        return self._items.__len__()\n\n    def __iter__(self):\n        return self._items.__iter__()\n\n    def __reversed__(self):\n        return self._items.__reversed__()\n\n    def __eq__(self, other):\n        return list(self) == other\n\n    def __le__(self, other):\n        return list(self) <= other\n\n    def insert(self, pos, item):\n        if self._frozen:\n            raise RuntimeError(\"Cannot modify frozen list.\")\n        self._items.insert(pos, item)\n\n    def __repr__(self):\n        return f\"<FrozenList(frozen={self._frozen}, {self._items!r})>\"\n\n    def __hash__(self):\n        if self._frozen:\n            return hash(tuple(self))\n        else:\n            raise RuntimeError(\"Cannot hash unfrozen list.\")\n\n\nPyFrozenList = FrozenList\n\n\nif not NO_EXTENSIONS:\n    try:\n        from ._frozenlist import FrozenList as CFrozenList  # type: ignore\n    except ImportError:  # pragma: no cover\n        pass\n    else:\n        FrozenList = CFrozenList  # type: ignore\n", "packaging/pep517_backend/_backend.py": "# fmt: off\n\"\"\"PEP 517 build backend wrapper for pre-building Cython for wheel.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager, nullcontext, suppress\nfrom pathlib import Path\nfrom shutil import copytree\nfrom sys import implementation as _system_implementation\nfrom sys import stderr as _standard_error_stream\nfrom sys import version_info as _python_version_tuple\nfrom tempfile import TemporaryDirectory\nfrom warnings import warn as _warn_that\n\nfrom setuptools.build_meta import build_sdist as _setuptools_build_sdist\nfrom setuptools.build_meta import build_wheel as _setuptools_build_wheel\nfrom setuptools.build_meta import (\n    get_requires_for_build_wheel as _setuptools_get_requires_for_build_wheel,\n)\nfrom setuptools.build_meta import (\n    prepare_metadata_for_build_wheel as _setuptools_prepare_metadata_for_build_wheel,\n)\n\ntry:\n    from setuptools.build_meta import build_editable as _setuptools_build_editable\nexcept ImportError:\n    _setuptools_build_editable = None  # type: ignore[assignment]\n\n\n# isort: split\nfrom distutils.command.install import install as _distutils_install_cmd\nfrom distutils.core import Distribution as _DistutilsDistribution\nfrom distutils.dist import DistributionMetadata as _DistutilsDistributionMetadata\n\nwith suppress(ImportError):\n    # NOTE: Only available for wheel builds that bundle C-extensions. Declared\n    # NOTE: by `get_requires_for_build_wheel()` and\n    # NOTE: `get_requires_for_build_editable()`, when `pure-python`\n    # NOTE: is not passed.\n    from Cython.Build.Cythonize import main as _cythonize_cli_cmd\n\nfrom ._compat import chdir_cm\nfrom ._cython_configuration import (  # noqa: WPS436\n    get_local_cython_config as _get_local_cython_config,\n)\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\nfrom ._transformers import sanitize_rst_roles  # noqa: WPS436\n\n__all__ = (  # noqa: WPS410\n    'build_sdist',\n    'build_wheel',\n    'get_requires_for_build_wheel',\n    'prepare_metadata_for_build_wheel',\n    *(\n        () if _setuptools_build_editable is None\n        else (\n            'build_editable',\n            'get_requires_for_build_editable',\n            'prepare_metadata_for_build_editable',\n        )\n    ),\n)\n\n\nCYTHON_TRACING_CONFIG_SETTING = 'with-cython-tracing'\n\"\"\"Config setting name toggle to include line tracing to C-exts.\"\"\"\n\nCYTHON_TRACING_ENV_VAR = 'FROZENLIST_CYTHON_TRACING'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_CONFIG_SETTING = 'pure-python'\n\"\"\"Config setting name toggle that is used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_ENV_VAR = 'FROZENLIST_NO_EXTENSIONS'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nIS_PY3_12_PLUS = _python_version_tuple[:2] >= (3, 12)\n\"\"\"A flag meaning that the current runtime is Python 3.12 or higher.\"\"\"\n\nIS_CPYTHON = _system_implementation.name == \"cpython\"\n\"\"\"A flag meaning that the current interpreter implementation is CPython.\"\"\"\n\nPURE_PYTHON_MODE_CLI_FALLBACK = not IS_CPYTHON\n\"\"\"A fallback for ``pure-python`` is not set.\"\"\"\n\n\ndef _is_truthy_setting_value(setting_value) -> bool:\n    truthy_values = {'', None, 'true', '1', 'on'}\n    return setting_value.lower() in truthy_values\n\n\ndef _get_setting_value(\n        config_settings: dict[str, str] | None = None,\n        config_setting_name: str | None = None,\n        env_var_name: str | None = None,\n        *,\n        default: bool = False,\n) -> bool:\n    user_provided_setting_sources = (\n        (config_settings, config_setting_name, (KeyError, TypeError)),\n        (os.environ, env_var_name, KeyError),\n    )\n    for src_mapping, src_key, lookup_errors in user_provided_setting_sources:\n        if src_key is None:\n            continue\n\n        with suppress(lookup_errors):  # type: ignore[arg-type]\n            return _is_truthy_setting_value(src_mapping[src_key])  # type: ignore[index]\n\n    return default\n\n\ndef _make_pure_python(config_settings: dict[str, str] | None = None) -> bool:\n    return _get_setting_value(\n        config_settings,\n        PURE_PYTHON_CONFIG_SETTING,\n        PURE_PYTHON_ENV_VAR,\n        default=PURE_PYTHON_MODE_CLI_FALLBACK,\n    )\n\n\ndef _include_cython_line_tracing(\n        config_settings: dict[str, str] | None = None,\n        *,\n        default=False,\n) -> bool:\n    return _get_setting_value(\n        config_settings,\n        CYTHON_TRACING_CONFIG_SETTING,\n        CYTHON_TRACING_ENV_VAR,\n        default=default,\n    )\n\n\n@contextmanager\ndef patched_distutils_cmd_install():\n    \"\"\"Make `install_lib` of `install` cmd always use `platlib`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/purelib/` folder\n    orig_finalize = _distutils_install_cmd.finalize_options\n\n    def new_finalize_options(self):  # noqa: WPS430\n        self.install_lib = self.install_platlib\n        orig_finalize(self)\n\n    _distutils_install_cmd.finalize_options = new_finalize_options\n    try:\n        yield\n    finally:\n        _distutils_install_cmd.finalize_options = orig_finalize\n\n\n@contextmanager\ndef patched_dist_has_ext_modules():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    orig_func = _DistutilsDistribution.has_ext_modules\n\n    _DistutilsDistribution.has_ext_modules = lambda *args, **kwargs: True\n    try:\n        yield\n    finally:\n        _DistutilsDistribution.has_ext_modules = orig_func\n\n\n@contextmanager\ndef patched_dist_get_long_description():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    _orig_func = _DistutilsDistributionMetadata.get_long_description\n\n    def _get_sanitized_long_description(self):\n        return sanitize_rst_roles(self.long_description)\n\n    _DistutilsDistributionMetadata.get_long_description = (\n        _get_sanitized_long_description\n    )\n    try:\n        yield\n    finally:\n        _DistutilsDistributionMetadata.get_long_description = _orig_func\n\n\n@contextmanager\ndef _in_temporary_directory(src_dir: Path) -> t.Iterator[None]:\n    with TemporaryDirectory(prefix='.tmp-frozenlist-pep517-') as tmp_dir:\n        with chdir_cm(tmp_dir):\n            tmp_src_dir = Path(tmp_dir) / 'src'\n            copytree(src_dir, tmp_src_dir, symlinks=True)\n            os.chdir(tmp_src_dir)\n            yield\n\n\n@contextmanager\ndef maybe_prebuild_c_extensions(\n        line_trace_cython_when_unset: bool = False,\n        build_inplace: bool = False,\n        config_settings: dict[str, str] | None = None,\n) -> t.Generator[None, t.Any, t.Any]:\n    \"\"\"Pre-build C-extensions in a temporary directory, when needed.\n\n    This context manager also patches metadata, setuptools and distutils.\n\n    :param build_inplace: Whether to copy and chdir to a temporary location.\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    cython_line_tracing_requested = _include_cython_line_tracing(\n        config_settings,\n        default=line_trace_cython_when_unset,\n    )\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if is_pure_python_build:\n        print(\"*********************\", file=_standard_error_stream)\n        print(\"* Pure Python build *\", file=_standard_error_stream)\n        print(\"*********************\", file=_standard_error_stream)\n\n        if cython_line_tracing_requested:\n            _warn_that(\n                f'The `{CYTHON_TRACING_CONFIG_SETTING !s}` setting requesting '\n                'Cython line tracing is set, but building C-extensions is not. '\n                'This option will not have any effect for in the pure-python '\n                'build mode.',\n                RuntimeWarning,\n                stacklevel=999,\n            )\n\n        yield\n        return\n\n    print(\"**********************\", file=_standard_error_stream)\n    print(\"* Accelerated build *\", file=_standard_error_stream)\n    print(\"**********************\", file=_standard_error_stream)\n    if not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    build_dir_ctx = (\n        nullcontext() if build_inplace\n        else _in_temporary_directory(src_dir=Path.cwd().resolve())\n    )\n    with build_dir_ctx:\n        config = _get_local_cython_config()\n\n        cythonize_args = _make_cythonize_cli_args_from_config(config)\n        with _patched_cython_env(config['env'], cython_line_tracing_requested):\n            _cythonize_cli_cmd(cythonize_args)\n        with patched_distutils_cmd_install():\n            with patched_dist_has_ext_modules():\n                yield\n\n\n@patched_dist_get_long_description()\ndef build_wheel(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=False,\n            build_inplace=False,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_wheel(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\n@patched_dist_get_long_description()\ndef build_editable(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel for editable installs.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=True,\n            build_inplace=True,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_editable(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\ndef get_requires_for_build_wheel(\n        config_settings: dict[str, str] | None = None,\n) -> list[str]:\n    \"\"\"Determine additional requirements for building wheels.\n\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if not is_pure_python_build and not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    c_ext_build_deps = [] if is_pure_python_build else [\n        'Cython >= 3.0.0b3' if IS_PY3_12_PLUS  # Only Cython 3+ is compatible\n        else 'Cython',\n    ]\n\n    return _setuptools_get_requires_for_build_wheel(\n        config_settings=config_settings,\n    ) + c_ext_build_deps\n\n\nbuild_sdist = patched_dist_get_long_description()(_setuptools_build_sdist)\nget_requires_for_build_editable = get_requires_for_build_wheel\nprepare_metadata_for_build_wheel = patched_dist_get_long_description()(\n    _setuptools_prepare_metadata_for_build_wheel,\n)\nprepare_metadata_for_build_editable = prepare_metadata_for_build_wheel\n", "packaging/pep517_backend/cli.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport sys\nfrom itertools import chain\nfrom pathlib import Path\n\nfrom Cython.Compiler.Main import compile as _translate_cython_cli_cmd\nfrom Cython.Compiler.Main import parse_command_line as _split_cython_cli_args\n\nfrom ._cython_configuration import get_local_cython_config as _get_local_cython_config\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\n\n_PROJECT_PATH = Path(__file__).parents[2]\n\n\ndef run_main_program(argv) -> int | str:\n    \"\"\"Invoke ``translate-cython`` or fail.\"\"\"\n    if len(argv) != 2:\n        return 'This program only accepts one argument -- \"translate-cython\"'\n\n    if argv[1] != 'translate-cython':\n        return 'This program only implements the \"translate-cython\" subcommand'\n\n    config = _get_local_cython_config()\n    config['flags'] = {'keep-going': config['flags']['keep-going']}\n    config['src'] = list(\n        map(\n            str,\n            chain.from_iterable(\n                map(_PROJECT_PATH.glob, config['src']),\n            ),\n        ),\n    )\n    translate_cython_cli_args = _make_cythonize_cli_args_from_config(config)\n\n    cython_options, cython_sources = _split_cython_cli_args(\n        translate_cython_cli_args,\n    )\n\n    with _patched_cython_env(config['env'], cython_line_tracing_requested=True):\n        return _translate_cython_cli_cmd(\n            cython_sources,\n            cython_options,\n        ).num_errors\n\n\nif __name__ == '__main__':\n    sys.exit(run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_transformers.py": "\"\"\"Data conversion helpers for the in-tree PEP 517 build backend.\"\"\"\n\nfrom itertools import chain\nfrom re import sub as _substitute_with_regexp\n\n\ndef _emit_opt_pairs(opt_pair):\n    flag, flag_value = opt_pair\n    flag_opt = f\"--{flag!s}\"\n    if isinstance(flag_value, dict):\n        sub_pairs = flag_value.items()\n    else:\n        sub_pairs = ((flag_value,),)\n\n    yield from (\"=\".join(map(str, (flag_opt,) + pair)) for pair in sub_pairs)\n\n\ndef get_cli_kwargs_from_config(kwargs_map):\n    \"\"\"Make a list of options with values from config.\"\"\"\n    return list(chain.from_iterable(map(_emit_opt_pairs, kwargs_map.items())))\n\n\ndef get_enabled_cli_flags_from_config(flags_map):\n    \"\"\"Make a list of enabled boolean flags from config.\"\"\"\n    return [f\"--{flag}\" for flag, is_enabled in flags_map.items() if is_enabled]\n\n\ndef sanitize_rst_roles(rst_source_text: str) -> str:\n    \"\"\"Replace RST roles with inline highlighting.\"\"\"\n    pep_role_regex = r\"\"\"(?x)\n        :pep:`(?P<pep_number>\\d+)`\n    \"\"\"\n    pep_substitution_pattern = (\n        r\"`PEP \\g<pep_number> <https://peps.python.org/pep-\\g<pep_number>>`__\"\n    )\n\n    user_role_regex = r\"\"\"(?x)\n        :user:`(?P<github_username>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    user_substitution_pattern = (\n        r\"`@\\g<github_username> \"\n        r\"<https://github.com/sponsors/\\g<github_username>>`__\"\n    )\n\n    issue_role_regex = r\"\"\"(?x)\n        :issue:`(?P<issue_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    issue_substitution_pattern = (\n        r\"`#\\g<issue_number> \"\n        r\"<https://github.com/aio-libs/frozenlist/issues/\\g<issue_number>>`__\"\n    )\n\n    pr_role_regex = r\"\"\"(?x)\n        :pr:`(?P<pr_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    pr_substitution_pattern = (\n        r\"`PR #\\g<pr_number> \"\n        r\"<https://github.com/aio-libs/frozenlist/pull/\\g<pr_number>>`__\"\n    )\n\n    commit_role_regex = r\"\"\"(?x)\n        :commit:`(?P<commit_sha>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    commit_substitution_pattern = (\n        r\"`\\g<commit_sha> \"\n        r\"<https://github.com/aio-libs/frozenlist/commit/\\g<commit_sha>>`__\"\n    )\n\n    gh_role_regex = r\"\"\"(?x)\n        :gh:`(?P<gh_slug>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    gh_substitution_pattern = (\n        r\"`GitHub: \\g<gh_slug> <https://github.com/\\g<gh_slug>>`__\"\n    )\n\n    meth_role_regex = r\"\"\"(?x)\n        (?::py)?:meth:`~?(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    meth_substitution_pattern = r\"``\\g<rendered_text>()``\"\n\n    role_regex = r\"\"\"(?x)\n        (?::\\w+)?:\\w+:`(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    substitution_pattern = r\"``\\g<rendered_text>``\"\n\n    substitutions = (\n        (pep_role_regex, pep_substitution_pattern),\n        (user_role_regex, user_substitution_pattern),\n        (issue_role_regex, issue_substitution_pattern),\n        (pr_role_regex, pr_substitution_pattern),\n        (commit_role_regex, commit_substitution_pattern),\n        (gh_role_regex, gh_substitution_pattern),\n        (meth_role_regex, meth_substitution_pattern),\n        (role_regex, substitution_pattern),\n    )\n\n    rst_source_normalized_text = rst_source_text\n    for regex, substitution in substitutions:\n        rst_source_normalized_text = _substitute_with_regexp(\n            regex,\n            substitution,\n            rst_source_normalized_text,\n        )\n\n    return rst_source_normalized_text\n", "packaging/pep517_backend/_cython_configuration.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport os\nfrom contextlib import contextmanager\nfrom pathlib import Path\nfrom sys import version_info as _python_version_tuple\n\nfrom expandvars import expandvars\n\nfrom ._compat import load_toml_from_string  # noqa: WPS436\nfrom ._transformers import (  # noqa: WPS436\n    get_cli_kwargs_from_config,\n    get_enabled_cli_flags_from_config,\n)\n\n\ndef get_local_cython_config() -> dict:\n    \"\"\"Grab optional build dependencies from pyproject.toml config.\n\n    :returns: config section from ``pyproject.toml``\n    :rtype: dict\n\n    This basically reads entries from::\n\n        [tool.local.cythonize]\n        # Env vars provisioned during cythonize call\n        src = [\"src/**/*.pyx\"]\n\n        [tool.local.cythonize.env]\n        # Env vars provisioned during cythonize call\n        LDFLAGS = \"-lssh\"\n\n        [tool.local.cythonize.flags]\n        # This section can contain the following booleans:\n        # * annotate \u2014 generate annotated HTML page for source files\n        # * build \u2014 build extension modules using distutils\n        # * inplace \u2014 build extension modules in place using distutils (implies -b)\n        # * force \u2014 force recompilation\n        # * quiet \u2014 be less verbose during compilation\n        # * lenient \u2014 increase Python compat by ignoring some compile time errors\n        # * keep-going \u2014 compile as much as possible, ignore compilation failures\n        annotate = false\n        build = false\n        inplace = true\n        force = true\n        quiet = false\n        lenient = false\n        keep-going = false\n\n        [tool.local.cythonize.kwargs]\n        # This section can contain args that have values:\n        # * exclude=PATTERN      exclude certain file patterns from the compilation\n        # * parallel=N    run builds in N parallel jobs (default: calculated per system)\n        exclude = \"**.py\"\n        parallel = 12\n\n        [tool.local.cythonize.kwargs.directives]\n        # This section can contain compiler directives\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.compile-time-env]\n        # This section can contain compile time env vars\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.options]\n        # This section can contain cythonize options\n        # NAME = \"VALUE\"\n    \"\"\"\n    config_toml_txt = (Path.cwd().resolve() / 'pyproject.toml').read_text()\n    config_mapping = load_toml_from_string(config_toml_txt)\n    return config_mapping['tool']['local']['cythonize']\n\n\ndef make_cythonize_cli_args_from_config(config) -> list[str]:\n    py_ver_arg = f'-{_python_version_tuple.major!s}'\n\n    cli_flags = get_enabled_cli_flags_from_config(config['flags'])\n    cli_kwargs = get_cli_kwargs_from_config(config['kwargs'])\n\n    return cli_flags + [py_ver_arg] + cli_kwargs + ['--'] + config['src']\n\n\n@contextmanager\ndef patched_env(env: dict[str, str], cython_line_tracing_requested: bool):\n    \"\"\"Temporary set given env vars.\n\n    :param env: tmp env vars to set\n    :type env: dict\n\n    :yields: None\n    \"\"\"\n    orig_env = os.environ.copy()\n    expanded_env = {name: expandvars(var_val) for name, var_val in env.items()}\n    os.environ.update(expanded_env)\n\n    if cython_line_tracing_requested:\n        os.environ['CFLAGS'] = ' '.join((\n            os.getenv('CFLAGS', ''),\n            '-DCYTHON_TRACE_NOGIL=1',  # Implies CYTHON_TRACE=1\n        )).strip()\n    try:\n        yield\n    finally:\n        os.environ.clear()\n        os.environ.update(orig_env)\n", "packaging/pep517_backend/__main__.py": "import sys\n\nfrom . import cli\n\nif __name__ == \"__main__\":\n    sys.exit(cli.run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_compat.py": "\"\"\"Cross-python stdlib shims.\"\"\"\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\ntry:\n    from contextlib import chdir as chdir_cm  # type: ignore[attr-defined]\nexcept ImportError:\n\n    @contextmanager  # type: ignore[no-redef]\n    def chdir_cm(path: os.PathLike) -> t.Iterator[None]:\n        \"\"\"Temporarily change the current directory, recovering on exit.\"\"\"\n        original_wd = Path.cwd()\n        os.chdir(path)\n        try:\n            yield\n        finally:\n            os.chdir(original_wd)\n\n\ntry:\n    from tomllib import loads as load_toml_from_string\nexcept ImportError:\n    from tomli import loads as load_toml_from_string  # type: ignore[no-redef]\n\n\n__all__ = (\"chdir_cm\", \"load_toml_from_string\")  # noqa: WPS410\n", "packaging/pep517_backend/__init__.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n", "packaging/pep517_backend/hooks.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n\nfrom contextlib import suppress as _suppress\n\nfrom setuptools.build_meta import *  # Re-exporting PEP 517 hooks  # pylint: disable=unused-wildcard-import,wildcard-import  # noqa: E501, F401, F403\n\n# Re-exporting PEP 517 hooks\nfrom ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n    build_sdist,\n    build_wheel,\n    get_requires_for_build_wheel,\n    prepare_metadata_for_build_wheel,\n)\n\nwith _suppress(ImportError):  # Only succeeds w/ setuptools implementing PEP 660\n    # Re-exporting PEP 660 hooks\n    from ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n        build_editable,\n        get_requires_for_build_editable,\n        prepare_metadata_for_build_editable,\n    )\n"}