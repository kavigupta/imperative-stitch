{"setup.py": "#!/usr/bin/env python\n#\n# Copyright (C) Jean-Paul Calderone 2008-2015, All rights reserved\n#\n\n\"\"\"\nInstallation script for the OpenSSL package.\n\"\"\"\n\nimport os\nimport re\n\nfrom setuptools import find_packages, setup\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nMETA_PATH = os.path.join(\"src\", \"OpenSSL\", \"version.py\")\n\n\ndef read_file(*parts):\n    \"\"\"\n    Build an absolute path from *parts* and return the contents of the\n    resulting file.  Assume UTF-8 encoding.\n    \"\"\"\n    with open(os.path.join(HERE, *parts), encoding=\"utf-8\", newline=None) as f:\n        return f.read()\n\n\nMETA_FILE = read_file(META_PATH)\n\n\ndef find_meta(meta):\n    \"\"\"\n    Extract __*meta*__ from META_FILE.\n    \"\"\"\n    meta_match = re.search(\n        rf\"^__{meta}__ = ['\\\"]([^'\\\"]*)['\\\"]\", META_FILE, re.M\n    )\n    if meta_match:\n        return meta_match.group(1)\n    raise RuntimeError(f\"Unable to find __{meta}__ string.\")\n\n\nURI = find_meta(\"uri\")\nLONG = (\n    read_file(\"README.rst\")\n    + \"\\n\\n\"\n    + \"Release Information\\n\"\n    + \"===================\\n\\n\"\n    + re.search(\n        r\"(\\d{2}.\\d.\\d \\(.*?\\)\\n.*?)\\n\\n\\n----\\n\",\n        read_file(\"CHANGELOG.rst\"),\n        re.S,\n    ).group(1)\n    + \"\\n\\n`Full changelog \"\n    + \"<{uri}en/stable/changelog.html>`_.\\n\\n\"\n).format(uri=URI)\n\n\nif __name__ == \"__main__\":\n    setup(\n        name=find_meta(\"title\"),\n        version=find_meta(\"version\"),\n        description=find_meta(\"summary\"),\n        long_description=LONG,\n        author=find_meta(\"author\"),\n        author_email=find_meta(\"email\"),\n        url=URI,\n        project_urls={\n            \"Source\": \"https://github.com/pyca/pyopenssl\",\n        },\n        license=find_meta(\"license\"),\n        classifiers=[\n            \"Development Status :: 6 - Mature\",\n            \"Intended Audience :: Developers\",\n            \"License :: OSI Approved :: Apache Software License\",\n            \"Operating System :: MacOS :: MacOS X\",\n            \"Operating System :: Microsoft :: Windows\",\n            \"Operating System :: POSIX\",\n            \"Programming Language :: Python :: 3\",\n            \"Programming Language :: Python :: 3.7\",\n            \"Programming Language :: Python :: 3.8\",\n            \"Programming Language :: Python :: 3.9\",\n            \"Programming Language :: Python :: 3.10\",\n            \"Programming Language :: Python :: 3.11\",\n            \"Programming Language :: Python :: 3.12\",\n            \"Programming Language :: Python :: Implementation :: CPython\",\n            \"Programming Language :: Python :: Implementation :: PyPy\",\n            \"Topic :: Security :: Cryptography\",\n            \"Topic :: Software Development :: Libraries :: Python Modules\",\n            \"Topic :: System :: Networking\",\n        ],\n        python_requires=\">=3.7\",\n        packages=find_packages(where=\"src\"),\n        package_dir={\"\": \"src\"},\n        install_requires=[\n            \"cryptography>=41.0.5,<43\",\n        ],\n        extras_require={\n            \"test\": [\"pytest-rerunfailures\", \"pretend\", \"pytest>=3.0.1\"],\n            \"docs\": [\n                \"sphinx!=5.2.0,!=5.2.0.post0,!=7.2.5\",\n                \"sphinx_rtd_theme\",\n            ],\n        },\n    )\n", "doc/conf.py": "#\n# pyOpenSSL documentation build configuration file, created by\n# sphinx-quickstart on Sat Jul 16 07:12:22 2011.\n#\n# This file is execfile()d with the current directory set to its parent dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport codecs\nimport os\nimport re\nimport sys\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n\ndef read_file(*parts):\n    \"\"\"\n    Build an absolute path from *parts* and return the contents of the\n    resulting file.  Assume UTF-8 encoding.\n    \"\"\"\n    with codecs.open(os.path.join(HERE, *parts), \"rb\", \"ascii\") as f:\n        return f.read()\n\n\ndef find_version(*file_paths):\n    version_file = read_file(*file_paths)\n    version_match = re.search(\n        r\"^__version__ = ['\\\"]([^'\\\"]*)['\\\"]\", version_file, re.M\n    )\n    if version_match:\n        return version_match.group(1)\n    raise RuntimeError(\"Unable to find version string.\")\n\n\nDOC_DIR = os.path.abspath(os.path.dirname(__file__))\nsys.path.insert(0, os.path.abspath(os.path.join(DOC_DIR, \"..\")))\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \"1.0\"\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.intersphinx\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"pyOpenSSL\"\nauthors = \"The pyOpenSSL developers\"\ncopyright = \"2001 \" + authors\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = find_version(\"..\", \"src\", \"OpenSSL\", \"version.py\")\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup `text`) to use for all documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output --------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\non_rtd = os.environ.get(\"READTHEDOCS\", None) == \"True\"\n\nif not on_rtd:  # only import and set the theme if we're building docs locally\n    import sphinx_rtd_theme\n\n    html_theme = \"sphinx_rtd_theme\"\n    html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"pyOpenSSLdoc\"\n\n\n# -- Options for LaTeX output -------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n# latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n# latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual])\nlatex_documents = [\n    (\"index\", \"pyOpenSSL.tex\", \"pyOpenSSL Documentation\", authors, \"manual\"),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Additional stuff for the LaTeX preamble.\n# latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output -------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", \"pyopenssl\", \"pyOpenSSL Documentation\", [authors], 1)]\n\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"cryptography\": (\"https://cryptography.io/en/latest/\", None),\n}\n", "tests/test_util.py": "import pytest\n\nfrom OpenSSL._util import exception_from_error_queue, lib\n\n\nclass TestErrors:\n    \"\"\"\n    Tests for handling of certain OpenSSL error cases.\n    \"\"\"\n\n    def test_exception_from_error_queue_nonexistent_reason(self):\n        \"\"\"\n        :func:`exception_from_error_queue` raises ``ValueError`` when it\n        encounters an OpenSSL error code which does not have a reason string.\n        \"\"\"\n        lib.ERR_put_error(lib.ERR_LIB_EVP, 0, 1112, b\"\", 10)\n        with pytest.raises(ValueError) as exc:\n            exception_from_error_queue(ValueError)\n        assert exc.value.args[0][0][2] == \"\"\n", "tests/test_rand.py": "# Copyright (c) Frederick Dean\n# See LICENSE for details.\n\n\"\"\"\nUnit tests for `OpenSSL.rand`.\n\"\"\"\n\nimport pytest\n\nfrom OpenSSL import rand\n\n\nclass TestRand:\n    @pytest.mark.parametrize(\"args\", [(b\"foo\", None), (None, 3)])\n    def test_add_wrong_args(self, args):\n        \"\"\"\n        `OpenSSL.rand.add` raises `TypeError` if called with arguments not of\n        type `str` and `int`.\n        \"\"\"\n        with pytest.raises(TypeError):\n            rand.add(*args)\n\n    def test_add(self):\n        \"\"\"\n        `OpenSSL.rand.add` adds entropy to the PRNG.\n        \"\"\"\n        rand.add(b\"hamburger\", 3)\n\n    def test_status(self):\n        \"\"\"\n        `OpenSSL.rand.status` returns `1` if the PRNG has sufficient entropy,\n        `0` otherwise.\n        \"\"\"\n        assert rand.status() == 1\n", "tests/test_debug.py": "from OpenSSL import version\nfrom OpenSSL.debug import _env_info\n\n\ndef test_debug_info():\n    \"\"\"\n    Debug info contains correct data.\n    \"\"\"\n    # Just check a sample we control.\n    assert version.__version__ in _env_info\n", "tests/util.py": "# Copyright (C) Jean-Paul Calderone\n# Copyright (C) Twisted Matrix Laboratories.\n# See LICENSE for details.\n\"\"\"\nHelpers for the OpenSSL test suite, largely copied from\nU{Twisted<http://twistedmatrix.com/>}.\n\"\"\"\n\n# This is the UTF-8 encoding of the SNOWMAN unicode code point.\nNON_ASCII = b\"\\xe2\\x98\\x83\".decode(\"utf-8\")\n\n\ndef is_consistent_type(theType, name, *constructionArgs):\n    \"\"\"\n    Perform various assertions about *theType* to ensure that it is a\n    well-defined type.  This is useful for extension types, where it's\n    pretty easy to do something wacky.  If something about the type is\n    unusual, an exception will be raised.\n\n    :param theType: The type object about which to make assertions.\n    :param name: A string giving the name of the type.\n    :param constructionArgs: Positional arguments to use with\n        *theType* to create an instance of it.\n    \"\"\"\n    assert theType.__name__ == name\n    assert isinstance(theType, type)\n    instance = theType(*constructionArgs)\n    assert type(instance) is theType\n    return True\n\n\nclass EqualityTestsMixin:\n    \"\"\"\n    A mixin defining tests for the standard implementation of C{==} and C{!=}.\n    \"\"\"\n\n    def anInstance(self):\n        \"\"\"\n        Return an instance of the class under test.  Each call to this method\n        must return a different object.  All objects returned must be equal to\n        each other.\n        \"\"\"\n        raise NotImplementedError()\n\n    def anotherInstance(self):\n        \"\"\"\n        Return an instance of the class under test.  Each call to this method\n        must return a different object.  The objects must not be equal to the\n        objects returned by C{anInstance}.  They may or may not be equal to\n        each other (they will not be compared against each other).\n        \"\"\"\n        raise NotImplementedError()\n\n    def test_identicalEq(self):\n        \"\"\"\n        An object compares equal to itself using the C{==} operator.\n        \"\"\"\n        o = self.anInstance()\n        assert o == o\n\n    def test_identicalNe(self):\n        \"\"\"\n        An object doesn't compare not equal to itself using the C{!=} operator.\n        \"\"\"\n        o = self.anInstance()\n        assert not (o != o)\n\n    def test_sameEq(self):\n        \"\"\"\n        Two objects that are equal to each other compare equal to each other\n        using the C{==} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = self.anInstance()\n        assert a == b\n\n    def test_sameNe(self):\n        \"\"\"\n        Two objects that are equal to each other do not compare not equal to\n        each other using the C{!=} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = self.anInstance()\n        assert not (a != b)\n\n    def test_differentEq(self):\n        \"\"\"\n        Two objects that are not equal to each other do not compare equal to\n        each other using the C{==} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = self.anotherInstance()\n        assert not (a == b)\n\n    def test_differentNe(self):\n        \"\"\"\n        Two objects that are not equal to each other compare not equal to each\n        other using the C{!=} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = self.anotherInstance()\n        assert a != b\n\n    def test_anotherTypeEq(self):\n        \"\"\"\n        The object does not compare equal to an object of an unrelated type\n        (which does not implement the comparison) using the C{==} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = object()\n        assert not (a == b)\n\n    def test_anotherTypeNe(self):\n        \"\"\"\n        The object compares not equal to an object of an unrelated type (which\n        does not implement the comparison) using the C{!=} operator.\n        \"\"\"\n        a = self.anInstance()\n        b = object()\n        assert a != b\n\n    def test_delegatedEq(self):\n        \"\"\"\n        The result of comparison using C{==} is delegated to the right-hand\n        operand if it is of an unrelated type.\n        \"\"\"\n\n        class Delegate:\n            def __eq__(self, other):\n                # Do something crazy and obvious.\n                return [self]\n\n        a = self.anInstance()\n        b = Delegate()\n        assert (a == b) == [b]\n\n    def test_delegateNe(self):\n        \"\"\"\n        The result of comparison using C{!=} is delegated to the right-hand\n        operand if it is of an unrelated type.\n        \"\"\"\n\n        class Delegate:\n            def __ne__(self, other):\n                # Do something crazy and obvious.\n                return [self]\n\n        a = self.anInstance()\n        b = Delegate()\n        assert (a != b) == [b]\n\n\n# The type name expected in warnings about using the wrong string type.\nWARNING_TYPE_EXPECTED = \"str\"\n", "tests/memdbg.py": "import sys\nimport traceback\n\nfrom cffi import api as _api\n\nsys.modules[\"ssl\"] = None\nsys.modules[\"_hashlib\"] = None\n\n\n_ffi = _api.FFI()\n_ffi.cdef(\n    \"\"\"\n    void *malloc(size_t size);\n    void free(void *ptr);\n    void *realloc(void *ptr, size_t size);\n\n    int  CRYPTO_set_mem_functions(\n        void *(*m)(size_t),void *(*r)(void *,size_t), void (*f)(void *));\n\n    int backtrace(void **buffer, int size);\n    char **backtrace_symbols(void *const *buffer, int size);\n    void backtrace_symbols_fd(void *const *buffer, int size, int fd);\n    \"\"\"\n)\n_api = _ffi.verify(\n    \"\"\"\n    #include <openssl/crypto.h>\n    #include <stdlib.h>\n    #include <execinfo.h>\n    \"\"\",\n    libraries=[\"crypto\"],\n)\nC = _ffi.dlopen(None)\n\nverbose = False\n\n\ndef log(s):\n    if verbose:\n        print(s)\n\n\ndef _backtrace():\n    buf = _ffi.new(\"void*[]\", 64)\n    result = _api.backtrace(buf, len(buf))\n    strings = _api.backtrace_symbols(buf, result)\n    stack = [_ffi.string(strings[i]) for i in range(result)]\n    C.free(strings)\n    return stack\n\n\n@_ffi.callback(\"void*(*)(size_t)\")\ndef malloc(n):\n    memory = C.malloc(n)\n    python_stack = traceback.extract_stack(limit=3)\n    c_stack = _backtrace()\n    heap[memory] = [(n, python_stack, c_stack)]\n    log(\"malloc(%d) -> %s\" % (n, memory))\n    return memory\n\n\n@_ffi.callback(\"void*(*)(void*, size_t)\")\ndef realloc(p, n):\n    memory = C.realloc(p, n)\n    old = heap.pop(p)\n\n    python_stack = traceback.extract_stack(limit=3)\n    c_stack = _backtrace()\n\n    old.append((n, python_stack, c_stack))\n    heap[memory] = old\n    log(\"realloc(0x%x, %d) -> %s\" % (int(_ffi.cast(\"int\", p)), n, memory))\n    return memory\n\n\n@_ffi.callback(\"void(*)(void*)\")\ndef free(p):\n    if p != _ffi.NULL:\n        C.free(p)\n        del heap[p]\n        log(\"free(0x{:x})\".format(int(_ffi.cast(\"int\", p))))\n\n\nif _api.CRYPTO_set_mem_functions(malloc, realloc, free):\n    log(\"Enabled memory debugging\")\n    heap = {}\nelse:\n    log(\"Failed to enable memory debugging\")\n    heap = None\n", "tests/test_crypto.py": "# Copyright (c) Jean-Paul Calderone\n# See LICENSE file for details.\n\n\"\"\"\nUnit tests for :py:mod:`OpenSSL.crypto`.\n\"\"\"\n\nimport base64\nimport sys\nimport warnings\nfrom datetime import datetime, timedelta, timezone\nfrom subprocess import PIPE, Popen\n\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n)\n\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import (\n    FILETYPE_ASN1,\n    FILETYPE_PEM,\n    FILETYPE_TEXT,\n    TYPE_DSA,\n    TYPE_RSA,\n    X509,\n    Error,\n    PKey,\n    X509Name,\n    X509Req,\n    X509Store,\n    X509StoreContext,\n    X509StoreContextError,\n    X509StoreFlags,\n    dump_certificate,\n    dump_certificate_request,\n    dump_privatekey,\n    dump_publickey,\n    get_elliptic_curve,\n    get_elliptic_curves,\n    load_certificate,\n    load_certificate_request,\n    load_privatekey,\n    load_publickey,\n    sign,\n    verify,\n)\n\nwith pytest.warns(DeprecationWarning):\n    from OpenSSL.crypto import (\n        CRL,\n        Revoked,\n        X509Extension,\n        dump_crl,\n        load_crl,\n    )\n\nfrom .util import (\n    NON_ASCII,\n    WARNING_TYPE_EXPECTED,\n    EqualityTestsMixin,\n    is_consistent_type,\n)\n\n\ndef normalize_privatekey_pem(pem):\n    return dump_privatekey(FILETYPE_PEM, load_privatekey(FILETYPE_PEM, pem))\n\n\ndef utcnow():\n    return datetime.now(timezone.utc).replace(tzinfo=None)\n\n\nGOOD_CIPHER = \"blowfish\"\nBAD_CIPHER = \"zippers\"\n\nGOOD_DIGEST = \"SHA256\"\nBAD_DIGEST = \"monkeys\"\n\nold_root_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIC7TCCAlagAwIBAgIIPQzE4MbeufQwDQYJKoZIhvcNAQEFBQAwWDELMAkGA1UE\nBhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQHEwdDaGljYWdvMRAwDgYDVQQKEwdU\nZXN0aW5nMRgwFgYDVQQDEw9UZXN0aW5nIFJvb3QgQ0EwIhgPMjAwOTAzMjUxMjM2\nNThaGA8yMDE3MDYxMTEyMzY1OFowWDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAklM\nMRAwDgYDVQQHEwdDaGljYWdvMRAwDgYDVQQKEwdUZXN0aW5nMRgwFgYDVQQDEw9U\nZXN0aW5nIFJvb3QgQ0EwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAPmaQumL\nurpE527uSEHdL1pqcDRmWzu+98Y6YHzT/J7KWEamyMCNZ6fRW1JCR782UQ8a07fy\n2xXsKy4WdKaxyG8CcatwmXvpvRQ44dSANMihHELpANTdyVp6DCysED6wkQFurHlF\n1dshEaJw8b/ypDhmbVIo6Ci1xvCJqivbLFnbAgMBAAGjgbswgbgwHQYDVR0OBBYE\nFINVdy1eIfFJDAkk51QJEo3IfgSuMIGIBgNVHSMEgYAwfoAUg1V3LV4h8UkMCSTn\nVAkSjch+BK6hXKRaMFgxCzAJBgNVBAYTAlVTMQswCQYDVQQIEwJJTDEQMA4GA1UE\nBxMHQ2hpY2FnbzEQMA4GA1UEChMHVGVzdGluZzEYMBYGA1UEAxMPVGVzdGluZyBS\nb290IENBggg9DMTgxt659DAMBgNVHRMEBTADAQH/MA0GCSqGSIb3DQEBBQUAA4GB\nAGGCDazMJGoWNBpc03u6+smc95dEead2KlZXBATOdFT1VesY3+nUOqZhEhTGlDMi\nhkgaZnzoIq/Uamidegk4hirsCT/R+6vsKAAxNTcBjUeZjlykCJWy5ojShGftXIKY\nw/njVbKMXrvc83qmTdGl3TAM0fxQIpqgcglFLveEBgzn\n-----END CERTIFICATE-----\n\"\"\"\n\nroot_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIE7jCCA1agAwIBAgIIPQzE4MbeufQwDQYJKoZIhvcNAQELBQAwWDELMAkGA1UE\nBhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQHEwdDaGljYWdvMRAwDgYDVQQKEwdU\nZXN0aW5nMRgwFgYDVQQDEw9UZXN0aW5nIFJvb3QgQ0EwHhcNMjAwODAyMTcxMTE5\nWhcNNDcxMjIwMTcxMTE5WjBYMQswCQYDVQQGEwJVUzELMAkGA1UECBMCSUwxEDAO\nBgNVBAcTB0NoaWNhZ28xEDAOBgNVBAoTB1Rlc3RpbmcxGDAWBgNVBAMTD1Rlc3Rp\nbmcgUm9vdCBDQTCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBALpY5jb+\nS7AUbx9gzN06wkqUeb+eNLTjCOKofiMTn8Y0TqCA2ZyY3XMcNBMaIS7hdFTgmmqt\nfFntYobxLAl/twfbz9AnRaVDh2HyUvHvMBxKn1HSDLALLtqdF0pcXIjP04S7NKPQ\nUmgkv2H0KwcUpYlgjTFtXRiP+7wDSiQeP1YVSriEoE0TXK14F8np6ZKK0oQ+u16d\nWn3MGQwFzS+Ipgoz0jbi5D2KzmK2dzHdxY8M2Dktkz/W3DUfUwaTohYed2DG39LP\nNUFOxekgXdIZ3vQbDfsEQt27TUzOztbo/BqK7YkRLzzOQFz+dKAxH6Hy6Bu9op7e\nDWS9TfD/+UmDxr3IeoLMpmUBKxmzTC4qpej+W1UuCE12dMo4LoadlkG+/l1oABqd\nUcf45WgaFk3xpyEuGnDxjs6rqYPoEapIichxN2fgN+jkgH9ed44r0yOoVeG2pmwD\nYFCCxzkmiuzLADlfM1LUzqUNKVFcOakD3iujHEalnDIJsc/znYsqaRvCkQIDAQAB\no4G7MIG4MB0GA1UdDgQWBBSDVXctXiHxSQwJJOdUCRKNyH4ErjCBiAYDVR0jBIGA\nMH6AFINVdy1eIfFJDAkk51QJEo3IfgSuoVykWjBYMQswCQYDVQQGEwJVUzELMAkG\nA1UECBMCSUwxEDAOBgNVBAcTB0NoaWNhZ28xEDAOBgNVBAoTB1Rlc3RpbmcxGDAW\nBgNVBAMTD1Rlc3RpbmcgUm9vdCBDQYIIPQzE4MbeufQwDAYDVR0TBAUwAwEB/zAN\nBgkqhkiG9w0BAQsFAAOCAYEAFIMFxLHaVDY/nsbYzI7+zxe4GJeUqRIj2g4XK/nF\n6lHLRFL2YP5yJ+Jm4JDkoZqKq/tcEQLIssQS++s6tBSdvFwdY6imfpEZgFPuodrZ\nKbYm4Xuouw09EQCEjPxBOQ1NEcPuwuDtvD6/BOfm3SRFRTq/gQwxKlZ7C/4l8b1+\nOQPIUryqdlFBpyE/M95GzaNdmkQx41PevEih2nqWnbTsXLeiSXLGoubMTxKEK4T+\nJ7Ci2KTRJ3SYMgTNU6MNcl7b9Tpw9/KVG80IbpzNQ1LDh3ZtkOfqoou1lmBTeNPu\ng2C/oiW6lVAmZx1TL9gbUtkJ0Q2iW4D9TF+zuYi2qpbVU3RvoqK25x3AuIWf4JOL\n3cTNjJ/3zmGSORRJvcGyvVnL30R+vwpaxvyuqMjz3kBjkK2Z2pvElZMJiZhbGG7k\nMHZQ5A26v0/iQVno6FRv3cQb9EeAZtNHcIEgsNhPZ53XVnwZ58ByvATMLKNN8dWF\nQ+8Bbr7QFxeWvQfHYX2yaQZ/\n-----END CERTIFICATE-----\n\"\"\"\n\nroot_key_pem = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIG5AIBAAKCAYEAuljmNv5LsBRvH2DM3TrCSpR5v540tOMI4qh+IxOfxjROoIDZ\nnJjdcxw0ExohLuF0VOCaaq18We1ihvEsCX+3B9vP0CdFpUOHYfJS8e8wHEqfUdIM\nsAsu2p0XSlxciM/ThLs0o9BSaCS/YfQrBxSliWCNMW1dGI/7vANKJB4/VhVKuISg\nTRNcrXgXyenpkorShD67Xp1afcwZDAXNL4imCjPSNuLkPYrOYrZ3Md3FjwzYOS2T\nP9bcNR9TBpOiFh53YMbf0s81QU7F6SBd0hne9BsN+wRC3btNTM7O1uj8GortiREv\nPM5AXP50oDEfofLoG72int4NZL1N8P/5SYPGvch6gsymZQErGbNMLiql6P5bVS4I\nTXZ0yjguhp2WQb7+XWgAGp1Rx/jlaBoWTfGnIS4acPGOzqupg+gRqkiJyHE3Z+A3\n6OSAf153jivTI6hV4bambANgUILHOSaK7MsAOV8zUtTOpQ0pUVw5qQPeK6McRqWc\nMgmxz/OdiyppG8KRAgMBAAECggGAGi6Tafagu8SjOE1pe0veMIxb7shTr3aWsQHr\ndxIyyK5gvbxc1tvDgYDc8DIjp2qV5bcI+yQU7K2lwj/waAVBuiDwOdbKukWap/Bc\nJxHsOI1jhSN2FOX9V0nrE8+WUMKifWuwIbQLYAaJvUGJKh2EhKDENcWf5uuT+v6b\nVCfLzlR/gx1fSHUH+Hd/ICd1YdmPanVF7i09oZ8jhcTq51rTuWs+heerGdp+1O++\nH4uBTnAHkUEOB1Iw7mXQTIRBqcntzob/TJrDKycdbFHEeRR0L1hALGEVftq7zI6F\nBA9caO1W7HkcVmeT6HATIEIGG5H7QAwSfZflJ/82ZXtDemqhBRVwQ2Fx/99wW3r9\npuUvJyLbba7NCwL1+P9w8ebr00kFyYoy6rE1JjqlE+9ZHwakZUWTA1lMOGWNEkRS\nbKZNHgrngs2zk5qCYRllmsBZ3obdufnP/wyag+BFVniAIN3a08y46SYmgYTeLdBX\n/DHSZIKWI9rBiNg6Qw49N+06XwiBAoHBAOMZQbRT8hEffRFbxcsRdJ4dUCM1RAXV\n/IMLeVQgKEWETX3pCydpQ2v65fJPACfLLwwRMq4BX4YpJVHCk6BZh/2zx8T1spmJ\nuBkHH6+VYgB9JVU0hv/APAjTZxdBjdhkaXVxccpmBBJqKKwOGf3nRVhmMsItBx2x\nZCz+x50+buRMTKsF+FeK2Dr2e9WrfMkOJ3nQFwbGvOBIQeXKmu0wYUVyebnCdZW5\npKI0Co7wp9soCa02YvTFR8n2kxMe9Y91jQKBwQDSD/xSsRfgDT0uiEwazVQ2D/42\n96U2MYe+k+p1GHBnjIX4eRPcWOnQNUd/QVy1UK4bQg1dVZi+NQJ1YS3mKNCpqOaK\novrgHHmYC1YIn8Xmq2YGzrm/JLwXw0BkPhHp/1yQVPVgyFKeNa3fSa0tkqCed5rs\nerM8090IIzWPzKtXId8Db4i0xHkDzP7xDThb6pPNx5bvAaempJRDLtN9xP/hQRyh\nxZ/MECKGRgyAVfndIZaI82kuUQFlnPMqk4FxFhUCgcAhnMdgzVvytNpqC09HMxoz\nnNsTmvqqcnWhX71hejD7uQ1PKYMBHk9gWA5YwuCfAy+/dXwuzP06ejSP2WDIRvgd\n0NIskMESgJPDAI7sCgwrTlqMNe4VRHqeQ8vqYUWBVbtWKqhQ8LCBmTzT2nJ2ZhiZ\ncObqXofDGVJeZodc+rSnDbP7TDLpoh9G+txxT6R0jafCG86MrjWebJN0U3yCxrpe\n8QabO/DzbDq110YIyg3OHirwfDBBUkHB3sD9/4MQ7LECgcEAs2UFhxVIn4aO5ott\n+0G5lkYIQ6cwx9x64i3ugDvz2uruiunUJU0luTOXML2AUDRrzEmXokr0nBQnWlk4\n2qOmuA3PfTx85iJLUab0vX69gyaDhnLLvMrBe8W62yELKXx076ouuI27yPNs3xFL\nvWzIkSzx+N0870i8LjPrjTgsZ8g8bfG1nTNhafaLDw/MPutReN7oLouKQs2w9MMr\nyPAR2qxBqIJe2uY4pdVy3bMPJWOG7MR74hs6By6HmKfKVuqVAoHBAMRSefX1QtfS\n3wWpQhkE7Sooco4LI8kfNncZ2gzNDbYf6aOkgzv0/SWJh+CdcKep9xk12O02Lpsm\nSsPYeYlPDCCvyJYGpR19QocYp6JCaemb7uMd6FuPHSHUgyoR4GS8PUuIbiRnpPxN\n4ta7VzmIZOCFu5e+vOq1NwTd0hR6sy5uNsTHV5ezOOqz2SB+yTRMDPr7cW0dMSJ8\njsvxvqVnkIhWeuP9GIb6XUhq74huGZ0Hpaxe6xG34QYiBpr/O3O/ew==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\nroot_key_der = base64.b64decode(\n    \"\"\"\nMIIG5AIBAAKCAYEAuljmNv5LsBRvH2DM3TrCSpR5v540tOMI4qh+IxOfxjROoIDZ\nnJjdcxw0ExohLuF0VOCaaq18We1ihvEsCX+3B9vP0CdFpUOHYfJS8e8wHEqfUdIM\nsAsu2p0XSlxciM/ThLs0o9BSaCS/YfQrBxSliWCNMW1dGI/7vANKJB4/VhVKuISg\nTRNcrXgXyenpkorShD67Xp1afcwZDAXNL4imCjPSNuLkPYrOYrZ3Md3FjwzYOS2T\nP9bcNR9TBpOiFh53YMbf0s81QU7F6SBd0hne9BsN+wRC3btNTM7O1uj8GortiREv\nPM5AXP50oDEfofLoG72int4NZL1N8P/5SYPGvch6gsymZQErGbNMLiql6P5bVS4I\nTXZ0yjguhp2WQb7+XWgAGp1Rx/jlaBoWTfGnIS4acPGOzqupg+gRqkiJyHE3Z+A3\n6OSAf153jivTI6hV4bambANgUILHOSaK7MsAOV8zUtTOpQ0pUVw5qQPeK6McRqWc\nMgmxz/OdiyppG8KRAgMBAAECggGAGi6Tafagu8SjOE1pe0veMIxb7shTr3aWsQHr\ndxIyyK5gvbxc1tvDgYDc8DIjp2qV5bcI+yQU7K2lwj/waAVBuiDwOdbKukWap/Bc\nJxHsOI1jhSN2FOX9V0nrE8+WUMKifWuwIbQLYAaJvUGJKh2EhKDENcWf5uuT+v6b\nVCfLzlR/gx1fSHUH+Hd/ICd1YdmPanVF7i09oZ8jhcTq51rTuWs+heerGdp+1O++\nH4uBTnAHkUEOB1Iw7mXQTIRBqcntzob/TJrDKycdbFHEeRR0L1hALGEVftq7zI6F\nBA9caO1W7HkcVmeT6HATIEIGG5H7QAwSfZflJ/82ZXtDemqhBRVwQ2Fx/99wW3r9\npuUvJyLbba7NCwL1+P9w8ebr00kFyYoy6rE1JjqlE+9ZHwakZUWTA1lMOGWNEkRS\nbKZNHgrngs2zk5qCYRllmsBZ3obdufnP/wyag+BFVniAIN3a08y46SYmgYTeLdBX\n/DHSZIKWI9rBiNg6Qw49N+06XwiBAoHBAOMZQbRT8hEffRFbxcsRdJ4dUCM1RAXV\n/IMLeVQgKEWETX3pCydpQ2v65fJPACfLLwwRMq4BX4YpJVHCk6BZh/2zx8T1spmJ\nuBkHH6+VYgB9JVU0hv/APAjTZxdBjdhkaXVxccpmBBJqKKwOGf3nRVhmMsItBx2x\nZCz+x50+buRMTKsF+FeK2Dr2e9WrfMkOJ3nQFwbGvOBIQeXKmu0wYUVyebnCdZW5\npKI0Co7wp9soCa02YvTFR8n2kxMe9Y91jQKBwQDSD/xSsRfgDT0uiEwazVQ2D/42\n96U2MYe+k+p1GHBnjIX4eRPcWOnQNUd/QVy1UK4bQg1dVZi+NQJ1YS3mKNCpqOaK\novrgHHmYC1YIn8Xmq2YGzrm/JLwXw0BkPhHp/1yQVPVgyFKeNa3fSa0tkqCed5rs\nerM8090IIzWPzKtXId8Db4i0xHkDzP7xDThb6pPNx5bvAaempJRDLtN9xP/hQRyh\nxZ/MECKGRgyAVfndIZaI82kuUQFlnPMqk4FxFhUCgcAhnMdgzVvytNpqC09HMxoz\nnNsTmvqqcnWhX71hejD7uQ1PKYMBHk9gWA5YwuCfAy+/dXwuzP06ejSP2WDIRvgd\n0NIskMESgJPDAI7sCgwrTlqMNe4VRHqeQ8vqYUWBVbtWKqhQ8LCBmTzT2nJ2ZhiZ\ncObqXofDGVJeZodc+rSnDbP7TDLpoh9G+txxT6R0jafCG86MrjWebJN0U3yCxrpe\n8QabO/DzbDq110YIyg3OHirwfDBBUkHB3sD9/4MQ7LECgcEAs2UFhxVIn4aO5ott\n+0G5lkYIQ6cwx9x64i3ugDvz2uruiunUJU0luTOXML2AUDRrzEmXokr0nBQnWlk4\n2qOmuA3PfTx85iJLUab0vX69gyaDhnLLvMrBe8W62yELKXx076ouuI27yPNs3xFL\nvWzIkSzx+N0870i8LjPrjTgsZ8g8bfG1nTNhafaLDw/MPutReN7oLouKQs2w9MMr\nyPAR2qxBqIJe2uY4pdVy3bMPJWOG7MR74hs6By6HmKfKVuqVAoHBAMRSefX1QtfS\n3wWpQhkE7Sooco4LI8kfNncZ2gzNDbYf6aOkgzv0/SWJh+CdcKep9xk12O02Lpsm\nSsPYeYlPDCCvyJYGpR19QocYp6JCaemb7uMd6FuPHSHUgyoR4GS8PUuIbiRnpPxN\n4ta7VzmIZOCFu5e+vOq1NwTd0hR6sy5uNsTHV5ezOOqz2SB+yTRMDPr7cW0dMSJ8\njsvxvqVnkIhWeuP9GIb6XUhq74huGZ0Hpaxe6xG34QYiBpr/O3O/ew=='\n\"\"\"\n)\n\nnormalized_root_key_pem = normalize_privatekey_pem(root_key_pem)\n\nintermediate_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIEXDCCAsSgAwIBAgIRAMPzhm6//0Y/g2pmnHR2C4cwDQYJKoZIhvcNAQELBQAw\nWDELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQHEwdDaGljYWdvMRAw\nDgYDVQQKEwdUZXN0aW5nMRgwFgYDVQQDEw9UZXN0aW5nIFJvb3QgQ0EwHhcNMjAw\nODAyMTcxMTIwWhcNNDcxMjIwMTcxMTIwWjBmMRUwEwYDVQQDEwxpbnRlcm1lZGlh\ndGUxDDAKBgNVBAoTA29yZzERMA8GA1UECxMIb3JnLXVuaXQxCzAJBgNVBAYTAlVT\nMQswCQYDVQQIEwJDQTESMBAGA1UEBxMJU2FuIERpZWdvMIIBojANBgkqhkiG9w0B\nAQEFAAOCAY8AMIIBigKCAYEAo3rOxOVrdLdRsR1o0+JG7MRpCtMoafA63TM/DczL\nQ4jURv5MzyTE7FFdXq4xNJRYgD16vUavZluQGj30+5Lkt07CuO/BK3itl8UW+dsH\np95gzBvgnj5AVZGkNOQ0Y4CbXO087Ywep7tpBfZ5fzURLeH+OHQGseEFZ5e0w8Az\nAarWu+Ez5RGpkaZ61iiJa53mAgkrjw+o83UrpDT2nrXiyR6Fx4K4eb1rarodWqGv\njSkdT5MA4i0gDhsIBnTarPB+0KM8M7od8DkLsTHBt4rYYCHgCX1bWavzGlqPEw9h\nksK+LAbQKD9J2AxYDkL0PAeUuvWMhxEmN6hXePiw63sJzukRunAvut5A2+42JMkW\nguDyqIvAjlCYcIyBvUbphP3qSFqww/hpZ2wh5UZOc1mzYJKR9MgI8/UhRJEJ7NyY\npF24EJbisjNE30ot8aM2/5cI5KevclcuPJWH8PjT/i1VnNpM4S8MqoPw6F+d75d/\nCtfI+LLfns4k3G9I+Qgxmpa5AgMBAAGjEzARMA8GA1UdEwEB/wQFMAMBAf8wDQYJ\nKoZIhvcNAQELBQADggGBAFVQ3Dmljrnbjys9ZIqcTs/B5ktKUAU2KNMO9TmoFymE\nYhHKbCb5u/CnWq3jtBW6jgkQHrhfY9leUlH87BkB2o16BcSKjHknHZ2MCdEvQvOM\n/nkkMDkOEoRn8mfCCxxgt8Kxf07wHDcnKoeJ3h9BXIl6nyJqJAcVWEJm1d75ayDG\n0Kr0z+LcqMtQqYI0csK/XDQkunlE95qti1HzxW+JeAf6nRkr7RNZLtGmUGAMfyBK\n9A0Db8QLR7O92YEmwoXtp+euN6uDdjw4A7KHjNXMdvqZoRfbZEA9c6XJTBj22h87\ngYUFRVpkNDrC/c9u6WgA943yMgFCwjrlTsmi+uoweT9U5r4TA+dVCDAv943aWCNm\nA+TiuIXlJAHl2PlH7Umu/oMQKDEt+0n4QcQLBZyK3CYU5kg+ms9vOvE19Lhp8HeS\nxqm6dwKpdm7/8EfGNW3s8Gm4KM26mb7dtSdHJFuR/BQ5y/cn4qIMyeGfHvsVew+2\nneyFR2Oc/nUlZMKfyHI+pA==\n-----END CERTIFICATE-----\n\"\"\"\n\nintermediate_key_pem = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIG4gIBAAKCAYEAo3rOxOVrdLdRsR1o0+JG7MRpCtMoafA63TM/DczLQ4jURv5M\nzyTE7FFdXq4xNJRYgD16vUavZluQGj30+5Lkt07CuO/BK3itl8UW+dsHp95gzBvg\nnj5AVZGkNOQ0Y4CbXO087Ywep7tpBfZ5fzURLeH+OHQGseEFZ5e0w8AzAarWu+Ez\n5RGpkaZ61iiJa53mAgkrjw+o83UrpDT2nrXiyR6Fx4K4eb1rarodWqGvjSkdT5MA\n4i0gDhsIBnTarPB+0KM8M7od8DkLsTHBt4rYYCHgCX1bWavzGlqPEw9hksK+LAbQ\nKD9J2AxYDkL0PAeUuvWMhxEmN6hXePiw63sJzukRunAvut5A2+42JMkWguDyqIvA\njlCYcIyBvUbphP3qSFqww/hpZ2wh5UZOc1mzYJKR9MgI8/UhRJEJ7NyYpF24EJbi\nsjNE30ot8aM2/5cI5KevclcuPJWH8PjT/i1VnNpM4S8MqoPw6F+d75d/CtfI+LLf\nns4k3G9I+Qgxmpa5AgMBAAECggGAc0i/V4qR5JUCPuyGaCVB7uXzTXbrIQoP+L2S\n0aCCFvX+/LGIaOt9E0mtln8wo+uZHZY9YAzg1EXtsRPQFzjXoY0hNFme15EamdSb\nB0e2dmMTz9w44l7z72PtcH8dkq224ilKthoB5Db9MP9HXrWFj9228QihT/9nWE5b\nY0++qIZZN9TwS7HQ6q2EIlIj1ohbE0R0O0bH1ifixsGyyOlrLHkhzjgY74Dspy7o\nVGmA6wL7cIoyLU21NT1Kw4LUUvCk3MTd62gIg43qLsoLJ1AVZg9AmLmhZn4HiGZa\ntiE1+Iz70E+qxIXDQTip/EY4qe9HHYM2VccjlMQsLLCw5Y2CJL0xbRUSPkKev+Us\nPyasHgxPP6s5sHTKm0fee+riJrR+CqODGT45CirJr+WjDznlJETgVDW5DmtTWGVW\n2WeBarXdYOn4S+uK3Pe3aTAiE9Uw7KrOdJqrWg89YFnMWw4HlMz0369HCUv5BqSg\nqtrJ7iPJhN5MMhA4Te2Rnc5onqEhAoHBANKmZP4/g5RoYy6Gjkwe9PSgp9URxCJt\nVHiE5r33jXxOMw2lJQD8JVLmWuNTbKEClj6Rd/5OzM2q2icYDu0k/wcX+BgXg5b2\nozyfjzgnqddKs8SlNd9oc2xiFRLgBkdHI5XFQlcp6vpEM+m47azEw72RtsKObN0g\nPZwSK8RWTj4zCXTdYMdr+gbdOA3fzUztckHLJQeS42JT3XJVSrSzFyXuVgXmdnS9\nbQ2dUfPT+JzwHy/HMmaBDM7fodDgv/XUywKBwQDGrLTomybbfc3ilZv+CZMW7bTy\npX8ydj6GSIBWLd+7gduQHYqam5gNK2v4BKPVHXMMcRZNIIId3FZztMaP3vkWQXIG\n/bNBnL4Aa8mZFUle1VGoPZxMt1aaVLv3UqWi47ptciA6uZCuc/6si3THTsNr/7kR\nk6A7UmA0CRYWzuezRsbEGRXZCCFGwJm2WCfewjNRqH/I+Kvfj06AddKkwByujfc6\nzQDH/m0QFNAKgEZYvFOL/Yd2cuFhU2OPUO4jFgsCgcBXRbjx3T6WbekpjXXG88xo\nzWa7T/ECkmk8xVMTwUxNA9kC/jimf9C219kv9ZA75OZ6ZaphIiSX0QEw0Tbd6UX/\nml6fHJ7YHLbklvavPT+QgtKX1hrLxGqNrNUuTMJNJZwIoQErO6KurTMU0hkmSx8N\nmyEs2fUgaAsebijT3y3rdxmj4VQHSyT7Uwu2M9LK3FVKDO/6g1DRnA1TISMiWlBs\n1qGtMB5Dn3de/J7Hdjq6SoGhOdYXwb+ctepEr9jX8KECgcAE2nk86XVkjUk3TNJX\nvWIjgEEYYGSgFfVnEGRaNpqtmPmFJsOZDU4EnFfx4iMidKq31hdmYPHsytIt12+2\nWgsZuRWRCCeV5b9agUeWfsehEnMBOigUU7JA6OsCmrlDJm8Kd2xEIv5e1KSXEH0U\n1V6+x6t8u2+Bo3yIKOSqP/m3DnaSmc5H1AQEF3Zp1vN6ZKIeT5B3l2OTfYu8ZaR0\ns+C/fuZYQGPRfuypJOkEKKgPSOJ9m/7wLNRGrWPUP3Th1IsCgcBb2O9ROv793a3x\nPtW4qzkqF69KKc2O/vT819NBQjGopQetOcsY3VHp0eJMv85ut4cCeqScAfdtFIiC\nScnrBO4JtdE6FkTY1k8el1DrctrUR3PZ2rt3m5k2XfPDGEypH3BReD3dHUe2M99D\n+dceH46rKyMXQ2lLA3iyzGE6NyWUTZ6co35/Qm2n8lV9IG1CuX5HVAVrr2osLG93\nzZvFSeTrN2MZvmelhS6aUJCV/PxiQPHlou8vLU6zzfPMSERTjOI=\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\nserver_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIEKTCCApGgAwIBAgIJAJn/HpR21r/8MA0GCSqGSIb3DQEBCwUAMFgxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJJTDEQMA4GA1UEBwwHQ2hpY2FnbzEQMA4GA1UECgwH\nVGVzdGluZzEYMBYGA1UEAwwPVGVzdGluZyBSb290IENBMB4XDTIwMDgwMjE3MTEy\nMFoXDTQ3MTIyMDE3MTEyMFowGDEWMBQGA1UEAwwNbG92ZWx5IHNlcnZlcjCCAaIw\nDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAKU9txhKg6Nc0dVK9Vv4MYuYP6Hs\noR483+wC53V8axkfy2TynrBSug8HapeSFW5jwdwcsjaDwEIAugZfRoz0N1vR/Q6T\nOFAYn2hRwlAgUXVk3NXpDNV/QRliGvxhLAVpvu1a4ExfVZoOQyPa8pogDgrUdB3e\ntYmmFHNa09Lv1nyMZWi6t7zH2weq6/Dxpm0BWf+THFcunv9TNfAqmDV5qbxvaUPh\nuvRpN+X2N3tejB8WKt+UmzAXUi3P3OgYimWXwq8Rmorc1rk5j+ksl6qYwZvi7rRV\ng1ZAH7bGhXC9eEU/1Z9q26OhAPdTyJD0pc+G9vMz6VijLRXcgHBUP09lSeqxnNxc\npWoX6nRdGn6PkDhewHM05iqAE3ZHnc8kSBcRX85SoW5dGOhvvUTs4ePVNTo3vHdQ\nvftTDD+I3rbFnYTKUAzHTPSWGE7LVEiWJ94RKSADXgve0qq8o377UMnY7W3UygSY\nodyUZ29B5EfZ88EpIs/h5NomDv5VcQEoCWN1owIDAQABozYwNDAdBgNVHQ4EFgQU\ng1V3LV4h8UkMCSTnVAkSjch+BK4wEwYDVR0lBAwwCgYIKwYBBQUHAwEwDQYJKoZI\nhvcNAQELBQADggGBACn0LsqO94tk8i+RbG5hryNduem9n8b8doYD97iaux6QLvY/\nA8DFduJtUevZ3OCsRYQSGa3V/ysMzN7/DIUkpRLevZmdw+1L6PGR7peR2xIQ+yEW\nbL88vLjezaYIzMKHJRmN8oP3DQtGJm6U2fMMiEHWqRtULIVpnFppzPI2z7+tDeyg\nPFD2YeiFWoq5lmXStrK+KYPJbhTn0gz4QlGBs7PLY2JMDRSVj6ctkvrpXbC3Rb3m\nqo2FY/y51ACg77Txc6NAmNE6tCknwaUjRQP2MuoYFm5/Z6O9/g49AEVIE101zHqV\nN6SkcTUaXAuQIyZaqwdndfOB4rrFyAkoxTM5OamIQl80hZKf4R5rM7D7Sz8kAWJi\nBPIcewN0XnI6lm+zPAVUAE8dZfgJmJR5ifZHYCuv96EX0RpYsddeik8UmjkZ2/ch\nvRzvRSNNxVC6Zoe6vKNUb89XMtJZqY80WxfWG3Z2Hwf9KvS+2KAH/6MiSMj0RI5F\nSCB2PMQm6DYXwM1EyA==\n-----END CERTIFICATE-----\n\"\"\"\n\nserver_key_pem = normalize_privatekey_pem(\n    b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIG5AIBAAKCAYEApT23GEqDo1zR1Ur1W/gxi5g/oeyhHjzf7ALndXxrGR/LZPKe\nsFK6Dwdql5IVbmPB3ByyNoPAQgC6Bl9GjPQ3W9H9DpM4UBifaFHCUCBRdWTc1ekM\n1X9BGWIa/GEsBWm+7VrgTF9Vmg5DI9rymiAOCtR0Hd61iaYUc1rT0u/WfIxlaLq3\nvMfbB6rr8PGmbQFZ/5McVy6e/1M18CqYNXmpvG9pQ+G69Gk35fY3e16MHxYq35Sb\nMBdSLc/c6BiKZZfCrxGaitzWuTmP6SyXqpjBm+LutFWDVkAftsaFcL14RT/Vn2rb\no6EA91PIkPSlz4b28zPpWKMtFdyAcFQ/T2VJ6rGc3FylahfqdF0afo+QOF7AczTm\nKoATdkedzyRIFxFfzlKhbl0Y6G+9ROzh49U1Oje8d1C9+1MMP4jetsWdhMpQDMdM\n9JYYTstUSJYn3hEpIANeC97SqryjfvtQydjtbdTKBJih3JRnb0HkR9nzwSkiz+Hk\n2iYO/lVxASgJY3WjAgMBAAECggGAJST2X5OAe9yFnri25vGn0YVr6G5U2YM9osQU\nW6iYOpGXGx4e5evyvyYfo+rGvoXWMjCRLwf2099t8bjBFzZeq1lM1VXqtraSPtUC\nJRjettDxg3Rb2jI85APVpR4C00SuEpT3DrPvfi3ukcTJ/DNwdKbFY2GI1WRr/HJS\nY3xebqjwstYmL12Nsu+NEiCAFMjU/kqHeGGWhDakTVSF2p96tE0nEIdRi1eLpTnv\nxt++B87n3FJ/gBP9+SZcth+uHKA8Wr42CqJR3z8b/blICYCd2LABFdZjL4aHfce9\nXe7UyVoySYC6N0YSbLLfsVu/w/qsYitcTvWCyekX4eT2U9Sdje46LGN4MFJSYy8K\nQw4hzz6JhUrAiwxPb2MLkq6q7AvdFwVAFl7xuH9J13yuN9x+w4NL9h3hzr4iC7nk\nxVrmme279h1hfuCR1+1Bb0fLvdl5VevT9SZYCg5BCL7JxHGofcBZ3ZE9R9Q7QYVv\nrCKHFZ5tIOkVJk2mcR5NvK6r7ethAoHBAM7BFvBPHgJ5xtny7M9xvaMQD9PZ3zzb\nPUD83lh+DlmLyzKLw2/OblyJgO8ECWUDNR1QkL5khq5Z2t1Kj77Hak7mUUlICbIc\nLKZLiAosuKBo/ps6emRRhIf9NNYR2G1k9GWyk3KicD/htllPl10j64vgBg2M/LQJ\n2Oh95oWMck7RRdWHCwfBjND3YsYoN0hY9GXgr+ByDRQgAacvnpHlFCRmSPqiAJGh\nkPKIRfjLgVFbL1cIj7oHpcModgZr7Dgc/wKBwQDMmVhsmiefTscZSCoCIqXVsJJ0\nedDmIvAl3cFozf9/+5JADjnp/9zcdANNN/oMfynOPx+0R2CygxooZaRKbnHPcVlu\nSCxwaloagNSFVt8lZ2PwybutfdMN8YbU431ypNLJjInI3Z66eHBRDZZZviu5AtoL\n5WYAvFzN502P1IVrJBo0lht7ftQMwM4NAhRaaFrUCrycREwUl0u9PxswmDhignWs\n+fyJ93D5aVC1wHjUN9WYTEOM66goZTuSDD8mE10CgcAbl3UiOMy+c9XvvBWSUZGH\nM1uJYCgEjRWNmLFridcMaDWD11cLkrbzrn4AZ7+BNX5fHSNT5UJ7/g3RPmQUh7RO\nNzpd1zlEBbKHtsi+4tz4u0pPGOzAeoh/RXFJqDQD1VcwQzaeM8NbIxocrRx8F5EV\np53nLQuEU1QZIsQiym1uy0rQhicYr+HE+V67Jx7JjuV+uw99mnrYVrUhxJ8axUF8\n4hGXMQt2Y+NeGoWMAEyPuOWGbeQQZXjfpISrsrdhfa0CgcEAxqbdRBUpA3Tpu5Jl\nt00M1z5p9M2SFuE1ao61i5z3xrvsdGVbtefH+gRqcD85eYi+fpKrpc7oBGtmqnKF\n4f76YgAcZQeOnlekxLbxocWHRDnuv4wfvYO9uHwZ/fojg3ylbSwXXABSbZsi8o/O\nu7P5n9k0/Pfu4igBs6oxlMU0BaM4DnbwmCe8m+VYKykpud440kjaeJ+XfyanU0hC\njhw+Iueoehr/KLYn6wJmaxJGP0c3DHh/3gOxcgdYn6VkawPBAoHBAMJ7jfxZJfBO\ni0gDsD9Kz3EkGI8HbBpgC2Cd9DGQR9qTZy1/l/ObM2jwNumJjoHsN8fkha1d6/3n\n01hA4LwLB/SLQHx+7k1749sH7m1FaczWa9eUxNkwFiVTBYIyvbekNfJogLX9pVow\nvEuNe+J8vxLt3gQJ1DUz+2Air8v//OIqQ+akDnPkwiqHDqynNNWO+jq708aUunVT\nTTvknsoT3qT8H/N1FwbCZ14eKV+bXHcv1lVrLdW/DnjDZRpMFa3LSg==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n)\n\nintermediate_server_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIEXTCCAsWgAwIBAgIRAPQFY9jfskSihdiNSNdt6GswDQYJKoZIhvcNAQELBQAw\nZjEVMBMGA1UEAxMMaW50ZXJtZWRpYXRlMQwwCgYDVQQKEwNvcmcxETAPBgNVBAsT\nCG9yZy11bml0MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVNh\nbiBEaWVnbzAeFw0yMDA4MDIxNzExMjBaFw00NzEyMjAxNzExMjBaMG4xHTAbBgNV\nBAMTFGludGVybWVkaWF0ZS1zZXJ2aWNlMQwwCgYDVQQKEwNvcmcxETAPBgNVBAsT\nCG9yZy11bml0MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVNh\nbiBEaWVnbzCCAaIwDQYJKoZIhvcNAQEBBQADggGPADCCAYoCggGBAL3UcTxwCsMZ\nqIE+7lolm8t6lT0IYZkE4L7u2qI64m9CvztudqqKYZcrprZobZxqPhqc8IO3CFR2\nnVzwZWxrHCcm6nAzJjVXUFrc4TLsVYYJL1QvKXxr97VIiySU7x6xWrQQsqDtlrb0\njH59EYFbM2eMk2fBT2X4h6YMXlqyrDjZF6apClXtkdxGJGqR5PCTs4cvrYW7TpIm\ncuJq0S+MRBguZpriM+wOK7cXrqfRPFRzZtPXskpQPSAMDDAOGKl8OZfoVFYzG8KG\nomOa0hcHtgYX2GCDs1g1maY6Haw9bgs041BoApH9aQxehy5dfU39DcFoKSE3dCjR\nFaR6ryCA+f8L1F3xVaHsvX443CYF0/holfsptTjNd1T1z8WR5h1jtY0gJ/ERgcJZ\nUgDRE3lEkTLExS/nuGVfdwnlkxny9jbtYp2YcjYjUkChLtTgz4ommeIdBdDvSu8M\nwWHMtQNxECs5qA5J384cLh11Nd9exWUjiQ9yAZ0qTOzTkdH7VPHfxQIDAQABMA0G\nCSqGSIb3DQEBCwUAA4IBgQA2jC5hJ/+46RLBuaZiJhBawiY+HqybEAZWM/IBGZO4\nUKcRotovU+sb1jg+vpXwePSBPEtQoZce0jN0TKiCdlLM4/9lybAvc6qBLJ0d4VS5\nBU5QsCs9IKyvswAFVipQZi0szYwHk8T145SH/fPao8oznf5ae4a6rK9PyZqT7Ix1\nnnKGffbJs0dY+jlxmx/BPlbsGfTwPL6LexghjvbpbXWUdVLP3gAW6DPCtRd6lhWj\nJvgCkF2SnbQ7GgnPEYi8h09j0c6/sK6jLoNAatJyIlRGE1cdGYZVUlVW/xP6lYM0\nMi1KKl0ZXOne4vPTtnTBBqrpjdLydH3WM1IxdwSRbmF15OD6BWzzKV4IYUJ21GDh\nYrVrcIeN49pUoKVTTn0Sql8f8mXxJhJ54wo9TKdIGZeuwTZrfWjcjWghXgghXGoP\nRI/I5fk/OMu0Oc06/+xdwCBHCSge0/vxK6fhTu7PxmJhQcZF0sDZyb6LXm2feVkG\n6FsxnsvstVNO3oJdpa8daLs=\n-----END CERTIFICATE-----\n\"\"\"\n\nintermediate_server_key_pem = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIG5AIBAAKCAYEAvdRxPHAKwxmogT7uWiWby3qVPQhhmQTgvu7aojrib0K/O252\nqophlyumtmhtnGo+Gpzwg7cIVHadXPBlbGscJybqcDMmNVdQWtzhMuxVhgkvVC8p\nfGv3tUiLJJTvHrFatBCyoO2WtvSMfn0RgVszZ4yTZ8FPZfiHpgxeWrKsONkXpqkK\nVe2R3EYkapHk8JOzhy+thbtOkiZy4mrRL4xEGC5mmuIz7A4rtxeup9E8VHNm09ey\nSlA9IAwMMA4YqXw5l+hUVjMbwoaiY5rSFwe2BhfYYIOzWDWZpjodrD1uCzTjUGgC\nkf1pDF6HLl19Tf0NwWgpITd0KNEVpHqvIID5/wvUXfFVoey9fjjcJgXT+GiV+ym1\nOM13VPXPxZHmHWO1jSAn8RGBwllSANETeUSRMsTFL+e4ZV93CeWTGfL2Nu1inZhy\nNiNSQKEu1ODPiiaZ4h0F0O9K7wzBYcy1A3EQKzmoDknfzhwuHXU1317FZSOJD3IB\nnSpM7NOR0ftU8d/FAgMBAAECggGAYNwla1FALIzLDieuNxE5jXne7GV6Zzm187as\nmFqzb1H/gbO7mQlDAn+jcS+Xvlf3mFy73HloJrDfWqzPE6MTmmag+N8gf9ctiS9r\nOTCd8uZ839ews2vj2PxLAz97Q437WiWq/7I7VN8zUNdAN2DxucRg8nAQs1c8390v\nx9ejSN580u0t+OpfoqWnrzkCOD8lO7V4NOR+EtTLifw3AKvxkuUaNa12ENyqMaJD\n3B1HS1AXB8DnmEOY7OE41sxaiSB44M7tsr31ldUCbEf/A5OZWeCfloP2c2g+Td8s\n+sl+AzoGa1HsFOqiqdDw8lKynfT1VukaaCtOr0pGeh6XW65aHRGI0B+mHIEM7yR0\nf2NjfvgejqNekWyJ+XeTcmrPPcSH72F9ansLRpUullAi+6OkPFIiwyKCP/S2sLwh\ncqe3NITfMweWDt7GqgOhz1yWaewXgdruWiFAYAh2JDBtgMWTUwWgkKyFCb4mrI6r\nzqiBpA8Mjm/H17h/dQqF3iRuaZOBAoHBAPDvVseeiGwZjDXuQD9acCBZU23xwevR\n6NVe/FLY1bybgsOBQCApQIWKH72eIHo12ULRMe/uZUo3su9JSCc8Gt8DsQpiZ2a+\nz8rS6uEw/UZGMWeLjcIVK5IeeD7OJ/BXEbwoxVvWLYYgWHpYwY9eqppsMlVqmIHY\nlfRAaepEkU/4euRl1VTFxkU0sYw7Tj+gbFQDydB0NSLIU/x10tlHblT+O5tgBLJh\nkL7II9tyoGaCUjNnACErmi1FA+lNsx1eAwKBwQDJsw+sIhujRHrajCV5dqq5cx3h\nZQNfamoX6xfXYjNHjkeFnFpHB2w6ffe00q2Kt5+0AaSA295n1vPx6IKzKYMr8kpD\n0Kiv+mlKK5w7lZzdCeoJb8Co2t9viZXrN9lNetXiSZldrg5nlG8Gmi2RKn65vIfp\nZFc8CExXpQWNMSLJlu2qM8Sjt4h8M880khuTggCeIDbw7YfyanlNhsNpOGv/r+Hd\n3i0BP0Qd1sZWkZ+hp/JJFdvyEh5vINgSABfNJJcCgcEA8LqioVcEBcZM8oG3jdVF\n3PyDQIHieUXFdpOuVvSyMf3LXJ3ivX+aKRNF/YZl+tWc24b7dzhh2hLm5PD6d8E1\nNAiTNsX1fJJAOe4dopz5IuL1b/jezcGrRBbPnCkNfLTyUmcGMmlAGRhubugJlb9H\nhH2AmRmlgW8u/NnzOZADBL1HxLb+vPHS1cj9cRi8aRRXyGX0miPSB4vTZpcu8cvO\nMHvIgMkiSDz1i7mbIiNYorOpgBR066+OH5cqfkwVH82TAoHAO3dZdYyQzXARMIIF\nQmxkJUz1UFCxz93V7btYSh4ftEcUeyX/z9U2aYBeGafLloxQv4eEcqFgTwkm3vmI\nHz5r9/b1Qk0wjsGrbTyyUTbpCpozsBiMmrv9CCtuUe0jWh6PFKpSVzZL9OnkWfP2\n30fCGQymnX8B4ScpKuXyXxBPi1O+OmIM5Z/k04mK25sAGltHx1cEG8BMRoJxxROo\nZUtHPBkk5H7ukeGPOaTq0PcaM1UKr9WMBTCmXGk4iwYP/mF9AoHBAOTlFVgGbbjk\nCp/Wd7IrYCBKlnkIyBUMx5icLcsFmgXWx+Gx1HualD2aZ7kctYOfo+zLEyA6roni\nbSFLrxT4Od4uqwb51iZoJWxO+C3H1i9NoieU5JOnw5Osyl7OMXm3DkaS/N+ipP/b\n3bx1y8/WnGgqWWguXKt2lmgOItaEKrXYr6VZ1Z4upnLtkbxLANnqkQcL9287tXaW\nGPVXEteEXrtPj1f+9QYsMKuTWfaw6XfnBkBHxEZgWR+2hAN2z3c/Eg==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\nclient_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIEJzCCAo+gAwIBAgIJAKxpFI5lODkjMA0GCSqGSIb3DQEBCwUAMFgxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJJTDEQMA4GA1UEBwwHQ2hpY2FnbzEQMA4GA1UECgwH\nVGVzdGluZzEYMBYGA1UEAwwPVGVzdGluZyBSb290IENBMB4XDTIwMDgwMjE3MTEy\nMVoXDTQ3MTIyMDE3MTEyMVowFjEUMBIGA1UEAwwLdWdseSBjbGllbnQwggGiMA0G\nCSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQDGChdOMY164FScJqfiJ5LEtjYOKEg4\nnmMAMGuHIT8wZZEfzaaHhBbypzKq2cPP1qtyHgvtUMM6KOFEj4y9AonqzzdlVxbM\ni6+AvYLWlPoB5r/G1GdslUvXbc7F02B/6sB/+iFXmcdjOjAQcLWxVgUL+1CoeoY1\nawNYmzQueK/T82a/6AYTdrx7XRX4wfxjYb1o3bnnRD/jGSakIylXeUGFsiSNkBs/\ndJMkUONxizAdAE2tW6NhPuE2O0UipzUhdgFnH6WPfJ0J1S7jZ3eQTUrLkFpWSp/Z\nhx/l/Ql9vO0wagHaT2wOiZdKVT8S6V6OPzJ7/H1evCoM6EuSPBC5DDP1nPetCK1v\nuC9kb7Dg6yFPt1CKrVFt0Y6W5Y5/GzisUtvYV/OGtX4DOwL9It68D04Qrvun1t/a\nDh/c5gKqfqIGHUvUucFmOi6DrRpadfraLZMRGN2ysPjoVwhMgwwSmSWhziQIUfxK\noyz1CUsyr5Gh5gdifbe1AOYwu6YdtlmhqCsCAwEAAaM2MDQwHQYDVR0OBBYEFINV\ndy1eIfFJDAkk51QJEo3IfgSuMBMGA1UdJQQMMAoGCCsGAQUFBwMCMA0GCSqGSIb3\nDQEBCwUAA4IBgQAhAEACc1j6EYoSfVJD8N/FlYfHRizdfVJyrmMnC8ID1vtfrU2z\nS2q+49ja2NyM4Sq+Cf+i+sFfzFG92LayZt9Mc1BnHZMdNzQL7Ynr2nDLxHsHzuYa\nN21/ucTpHEFGLmvQ/eWBMxQQ9TbiNXn+tnnqg46dRzN3vHJp+g5+ijtMcuh007z2\nniiO8F07wlb960XviejWejMC8hBLWlA7i3EjAkDO8RFQnG2Py5cQX9GgmWH1sDy3\nrIsWlU+e46ysSWK/bnudnAlzZMB9KJATVZu5+xmCumH2hLJv5vz+jnKcgU9MBZMO\ncKgNdFUbtRlU/gfTaohmLIuSquunCCrXLsLD8ygbKKXfSPGVo2XkvX3oxqUo6dmA\nLvU4N4sCQGiSzW+a13HBtk3TBZFsJSWUGSW/H7TVFiAonumJKRqRxMOkkB9JxX+V\n9LZBYuBLpOeK4wZ8BUSNlHKnGpDzl0DzdYrGlzWz0jXlLGZ8KMfXAn9h0mOZ+IyK\neUlgMBYyAspCQzM=\n-----END CERTIFICATE-----\n\"\"\"\n\nclient_key_pem = normalize_privatekey_pem(\n    b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIG5AIBAAKCAYEAxgoXTjGNeuBUnCan4ieSxLY2DihIOJ5jADBrhyE/MGWRH82m\nh4QW8qcyqtnDz9arch4L7VDDOijhRI+MvQKJ6s83ZVcWzIuvgL2C1pT6Aea/xtRn\nbJVL123OxdNgf+rAf/ohV5nHYzowEHC1sVYFC/tQqHqGNWsDWJs0Lniv0/Nmv+gG\nE3a8e10V+MH8Y2G9aN2550Q/4xkmpCMpV3lBhbIkjZAbP3STJFDjcYswHQBNrVuj\nYT7hNjtFIqc1IXYBZx+lj3ydCdUu42d3kE1Ky5BaVkqf2Ycf5f0JfbztMGoB2k9s\nDomXSlU/Eulejj8ye/x9XrwqDOhLkjwQuQwz9Zz3rQitb7gvZG+w4OshT7dQiq1R\nbdGOluWOfxs4rFLb2FfzhrV+AzsC/SLevA9OEK77p9bf2g4f3OYCqn6iBh1L1LnB\nZjoug60aWnX62i2TERjdsrD46FcITIMMEpkloc4kCFH8SqMs9QlLMq+RoeYHYn23\ntQDmMLumHbZZoagrAgMBAAECggGAAXA5UxwRBv9yHeA5/+6BpmQcaGXqgF7GIU44\nubaIGvXh4/U+bGWNNR35xDvorC3G+QE23PZlNJrvZ+wS/ZxzG/19TYMga0Podmrp\n9F0Io9LlObB5P9SlxF7LzawHW2Z9F3DdpSE8zX+ysavf5fXV+4xLva2GJAUu9QnL\nizrdLBDsgiBRSvrly4+VhUUDbEVddtGFdCSOwjuAiFipCDWdQDdXBKAzUnaqSu07\neaulIdDKv6OWwDIQuLAdhG7qd9+/h5MB/rAG8v4bgbHz1H/RZw5VIOuOhfCodzJx\n3Smfh5td21jwJ2RfZYEPNOMtFa9eRFtH2/uRa5jbJiZb8YWIzWy0xCNQpKheSoBO\nwiuMDBS2HCYm2SgEYDdJiE2OkRAk0UwTiUmlmZd0a3NfJ/rfQE+JiDQ28Arj3EZl\nSY/V3KdviM4MbaoX7f9j9sjAe5Rk1M+yI8OsnM/hf77m0CSiJJpLpvgqhMjjT+NI\naBm1FyTq6qu506d0YUZy+Wr2DRsBAoHBAPfshuOiDXo9UmJxM1mSJQ0rQlxWSWmX\nbIAsPrpKslTFYHk7xbcCbJCqMbHmCsyvYy3oW3SpJs6Vi2wQWuUQmsm0YC7qdkXF\nFyo2f7vF7roQcXLxVmQRo0OxZ9JpLAZ9DKMEcNfYyUiQiqJmZuIyWKngqBl6OoL2\n8EJSFjTY1tR/nDxGLpZSsqoZJWQGd9B2bK4y6NktDF1GkexCpKaSyXZT612JGPG2\n0gSIwRq1OgZH3SPHevhVMjJtxGue2XARywKBwQDMfZHtdJI9RuurM9UuULZ72SmW\noLzki3LwFQ/QoS9wrHK+OqQDWH2ddON1PoB4LOCpwB4CC83pMyfxurgLHut6saHL\nhQ5N+h0jUC2pSJOXZSfF2Hx8YHCT7Dga5kmgEy89c1TF48IL2LdUZQQIGZt8+FxM\n4nxT9NFlu/UWY2oftT+ZwFsIock/DYYUKxDXw9YkOmt1lO5u1SKte0NdQ4RhBeqK\nnRADMSS9oKZkSUxkwaDJH2GkUVTyBsF/kmh+dyECgcEA6jy3yRQPxcFwOAAZ8vOo\nPAP2I8WGgNQHOCYVce8nA/6jwocdq2YH6rpST3E4HOFMRFB3MAas2pvh6UyehDOm\n+xGHmmv9KLgoxcJN9rvwbC0i8uVfqRYc+dUAcYTaiprVOKP2dYilzAB8ayly5R2K\nNZ5DVCbuZ1Ql9ZMW1gFVH9odY7kvROmHUjyF3jZaN0PcNM12v9HXD72gGudwJs0i\nuMBa7LmeLql7TbtjLvewhcSaA7bx0PS1g33ACapAZ6j3AoHAN2PsGz3wPtjvDTjF\nDf6e730rXrm7cMy1HYMW/ZQrnYGYsx5/PsjBfd0jn6aGdgbx9AkuF6/K3tgUgc3p\n/Fkrv9hN0yr/bO/K5L3bIHegQuoLk/PIBIi69daOe/rVBp8rtKGA3PmMnljdj+as\n6OTG0VsU5V6T/snZzozTHnVfUaduyt7nybbJJGMtZlkj/s31O2r3oKnuy+a/te4l\nmSWovf80QMe6hqLRKOxTJecU4lXwj4oIkNHXCJf74epuk5MBAoHBALyvg90KzMFX\nZEjdPIXULR6/3rub8yD7LVYbNhhYWGo8GybzsBUC0kczRpRXFnmbq1GDIXQf5A+2\n3ZaGsWzAxLjvL3KwH1LUaXVWwFMOM2n6zTk18XEXrNvp+E5QtPwpO5c4VlPr0cAC\ntTPAmbu6kVPlQ6mKiqlPAsfh0BD2mRVo2cTjZgDotKshb5uCHD8/PnCfOjCXFxOf\nDWjBuR73/r5Bj+ktRoD4V2SFdO6loJwH6B8rsBjD0NbAGs9otKvy+Q==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n)\n\ncleartextCertificateRequestPEM = b\"\"\"-----BEGIN CERTIFICATE REQUEST-----\nMIIBnjCCAQcCAQAwXjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAklMMRAwDgYDVQQH\nEwdDaGljYWdvMRcwFQYDVQQKEw5NeSBDb21wYW55IEx0ZDEXMBUGA1UEAxMORnJl\nZGVyaWNrIERlYW4wgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBANp6Y17WzKSw\nBsUWkXdqg6tnXy8H8hA1msCMWpc+/2KJ4mbv5NyD6UD+/SqagQqulPbF/DFea9nA\nE0zhmHJELcM8gUTIlXv/cgDWnmK4xj8YkjVUiCdqKRAKeuzLG1pGmwwF5lGeJpXN\nxQn5ecR0UYSOWj6TTGXB9VyUMQzCClcBAgMBAAGgADANBgkqhkiG9w0BAQUFAAOB\ngQAAJGuF/R/GGbeC7FbFW+aJgr9ee0Xbl6nlhu7pTe67k+iiKT2dsl2ti68MVTnu\nVrb3HUNqOkiwsJf6kCtq5oPn3QVYzTa76Dt2y3Rtzv6boRSlmlfrgS92GNma8JfR\noICQk3nAudi6zl1Dix3BCv1pUp5KMtGn3MeDEi6QFGy2rA==\n-----END CERTIFICATE REQUEST-----\n\"\"\"\n\nencryptedPrivateKeyPEM = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nProc-Type: 4,ENCRYPTED\nDEK-Info: DES-EDE3-CBC,9573604A18579E9E\n\nSHOho56WxDkT0ht10UTeKc0F5u8cqIa01kzFAmETw0MAs8ezYtK15NPdCXUm3X/2\na17G7LSF5bkxOgZ7vpXyMzun/owrj7CzvLxyncyEFZWvtvzaAhPhvTJtTIB3kf8B\n8+qRcpTGK7NgXEgYBW5bj1y4qZkD4zCL9o9NQzsKI3Ie8i0239jsDOWR38AxjXBH\nmGwAQ4Z6ZN5dnmM4fhMIWsmFf19sNyAML4gHenQCHhmXbjXeVq47aC2ProInJbrm\n+00TcisbAQ40V9aehVbcDKtS4ZbMVDwncAjpXpcncC54G76N6j7F7wL7L/FuXa3A\nfvSVy9n2VfF/pJ3kYSflLHH2G/DFxjF7dl0GxhKPxJjp3IJi9VtuvmN9R2jZWLQF\ntfC8dXgy/P9CfFQhlinqBTEwgH0oZ/d4k4NVFDSdEMaSdmBAjlHpc+Vfdty3HVnV\nrKXj//wslsFNm9kIwJGIgKUa/n2jsOiydrsk1mgH7SmNCb3YHgZhbbnq0qLat/HC\ngHDt3FHpNQ31QzzL3yrenFB2L9osIsnRsDTPFNi4RX4SpDgNroxOQmyzCCV6H+d4\no1mcnNiZSdxLZxVKccq0AfRpHqpPAFnJcQHP6xyT9MZp6fBa0XkxDnt9kNU8H3Qw\n7SJWZ69VXjBUzMlQViLuaWMgTnL+ZVyFZf9hTF7U/ef4HMLMAVNdiaGG+G+AjCV/\nMbzjS007Oe4qqBnCWaFPSnJX6uLApeTbqAxAeyCql56ULW5x6vDMNC3dwjvS/CEh\n11n8RkgFIQA0AhuKSIg3CbuartRsJnWOLwgLTzsrKYL4yRog1RJrtw==\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\nencryptedPrivateKeyPEMPassphrase = b\"foobar\"\n\ncleartextPrivateKeyPEM = \"\"\"-----BEGIN PRIVATE KEY-----\nMIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBAMcRMugJ4kvkOEuT\nAvMFr9+3A6+HAB6nKYcXXZz93ube8rJpBZQEfWn73H10dQiQR/a+rhxYEeLy8dPc\nUkFcGR9miVkukJ59zex7iySJY76bdBD8gyx1LTKrkCstP2XHKEYqgbj+tm7VzJnY\nsQLqoaa5NeyWJnUC3MJympkAS7p3AgMBAAECgYAoBAcNqd75jnjaiETRgVUnTWzK\nPgMCJmwsob/JrSa/lhWHU6Exbe2f/mcGOQDFpesxaIcrX3DJBDkkc2d9h/vsfo5v\nJLk/rbHoItWxwuY5n5raAPeQPToKpTDxDrL6Ejhgcxd19wNht7/XSrYZ+dq3iU6G\nmOEvU2hrnfIW3kwVYQJBAP62G6R0gucNfaKGtHzfR3TN9G/DnCItchF+TxGTtpdh\nCz32MG+7pirT/0xunekmUIp15QHdRy496sVxWTCooLkCQQDIEwXTAwhLNRGFEs5S\njSkxNfTVeNiOzlG8jPBJJDAdlLt1gUqjZWnk9yU+itMSGi/6eeuH2n04FFk+SV/T\n7ryvAkB0y0ZDk5VOozX/p2rtc2iNm77A3N4kIdiTQuq4sZXhNgN0pwWwxke8jbcb\n8gEAnqwBwWt//locTxHu9TmjgT8pAkEAlbF16B0atXptM02QxT8MlN8z4gxaqu4/\nRX2FwpOq1FcVsqMbvwj/o+ouGY8wwRiK0TMrQCf/DFhdNTcc1aqHzQJBAKWtq4LI\nuVZjCAuyrqEnt7R1bOiLrar+/ezJPY2z+f2rb1TGr31ztPeFvO3edLw+QdhzwJGp\nQKImYzqMe+zkIOQ=\n-----END PRIVATE KEY-----\n\"\"\"\n\ncleartextPublicKeyPEM = b\"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxszlc+b71LvlLS0ypt/l\ngT/JzSVJtnEqw9WUNGeiChywX2mmQLHEt7KP0JikqUFZOtPclNY823Q4pErMTSWC\n90qlUxI47vNJbXGRfmO2q6Zfw6SE+E9iUb74xezbOJLjBuUIkQzEKEFV+8taiRV+\nceg1v01yCT2+OjhQW3cxG42zxyRFmqesbQAUWgS3uhPrUQqYQUEiTmVhh4FBUKZ5\nXIneGUpX1S7mXRxTLH6YzRoGFqRoc9A0BBNcoXHTWnxV215k4TeHMFYE5RG0KYAS\n8Xk5iKICEXwnZreIt3jyygqoOKsKZMK/Zl2VhMGhJR6HXRpQCyASzEG7bgtROLhL\nywIDAQAB\n-----END PUBLIC KEY-----\n\"\"\"\n\ncrlData = b\"\"\"\\\n-----BEGIN X509 CRL-----\nMIIBWzCBxTANBgkqhkiG9w0BAQQFADBYMQswCQYDVQQGEwJVUzELMAkGA1UECBMC\nSUwxEDAOBgNVBAcTB0NoaWNhZ28xEDAOBgNVBAoTB1Rlc3RpbmcxGDAWBgNVBAMT\nD1Rlc3RpbmcgUm9vdCBDQRcNMDkwNzI2MDQzNDU2WhcNMTIwOTI3MDI0MTUyWjA8\nMBUCAgOrGA8yMDA5MDcyNTIzMzQ1NlowIwICAQAYDzIwMDkwNzI1MjMzNDU2WjAM\nMAoGA1UdFQQDCgEEMA0GCSqGSIb3DQEBBAUAA4GBAEBt7xTs2htdD3d4ErrcGAw1\n4dKcVnIWTutoI7xxen26Wwvh8VCsT7i/UeP+rBl9rC/kfjWjzQk3/zleaarGTpBT\n0yp4HXRFFoRhhSE/hP+eteaPXRgrsNRLHe9ZDd69wmh7J1wMDb0m81RG7kqcbsid\nvrzEeLDRiiPl92dyyWmu\n-----END X509 CRL-----\n\"\"\"\n\n# The signature on this CRL is invalid.\ncrlDataUnsupportedExtension = b\"\"\"\\\n-----BEGIN X509 CRL-----\nMIIGRzCCBS8CAQEwDQYJKoZIhvcNAQELBQAwJzELMAkGA1UEBhMCVVMxGDAWBgNV\nBAMMD2NyeXB0b2dyYXBoeS5pbxgPMjAxNTAxMDEwMDAwMDBaGA8yMDE2MDEwMTAw\nMDAwMFowggTOMBQCAQAYDzIwMTUwMTAxMDAwMDAwWjByAgEBGA8yMDE1MDEwMTAw\nMDAwMFowXDAYBgNVHRgEERgPMjAxNTAxMDEwMDAwMDBaMDQGA1UdHQQtMCukKTAn\nMQswCQYDVQQGEwJVUzEYMBYGA1UEAwwPY3J5cHRvZ3JhcGh5LmlvMAoGA1UdFQQD\nCgEAMHICAQIYDzIwMTUwMTAxMDAwMDAwWjBcMBgGA1UdGAQRGA8yMDE1MDEwMTAw\nMDAwMFowNAYDVR0dBC0wK6QpMCcxCzAJBgNVBAYTAlVTMRgwFgYDVQQDDA9jcnlw\ndG9ncmFwaHkuaW8wCgYDVR0VBAMKAQEwcgIBAxgPMjAxNTAxMDEwMDAwMDBaMFww\nGAYDVR0YBBEYDzIwMTUwMTAxMDAwMDAwWjA0BgNVHR0ELTArpCkwJzELMAkGA1UE\nBhMCVVMxGDAWBgNVBAMMD2NyeXB0b2dyYXBoeS5pbzAKBgNVHRUEAwoBAjByAgEE\nGA8yMDE1MDEwMTAwMDAwMFowXDAYBgNVHRgEERgPMjAxNTAxMDEwMDAwMDBaMDQG\nA1UdHQQtMCukKTAnMQswCQYDVQQGEwJVUzEYMBYGA1UEAwwPY3J5cHRvZ3JhcGh5\nLmlvMAoGA1UdFQQDCgEDMHICAQUYDzIwMTUwMTAxMDAwMDAwWjBcMBgGA1UdGAQR\nGA8yMDE1MDEwMTAwMDAwMFowNAYDVR0dBC0wK6QpMCcxCzAJBgNVBAYTAlVTMRgw\nFgYDVQQDDA9jcnlwdG9ncmFwaHkuaW8wCgYDVR0VBAMKAQQwcgIBBhgPMjAxNTAx\nMDEwMDAwMDBaMFwwGAYDVR0YBBEYDzIwMTUwMTAxMDAwMDAwWjA0BgNVHR0ELTAr\npCkwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD2NyeXB0b2dyYXBoeS5pbzAKBgNV\nHRUEAwoBBTByAgEHGA8yMDE1MDEwMTAwMDAwMFowXDAYBgNVHRgEERgPMjAxNTAx\nMDEwMDAwMDBaMDQGA1UdHQQtMCukKTAnMQswCQYDVQQGEwJVUzEYMBYGA1UEAwwP\nY3J5cHRvZ3JhcGh5LmlvMAoGA1UdFQQDCgEGMHICAQgYDzIwMTUwMTAxMDAwMDAw\nWjBcMBgGA1UdGAQRGA8yMDE1MDEwMTAwMDAwMFowNAYDVR0dBC0wK6QpMCcxCzAJ\nBgNVBAYTAlVTMRgwFgYDVQQDDA9jcnlwdG9ncmFwaHkuaW8wCgYDVR0VBAMKAQgw\ncgIBCRgPMjAxNTAxMDEwMDAwMDBaMFwwGAYDVR0YBBEYDzIwMTUwMTAxMDAwMDAw\nWjA0BgNVHR0ELTArpCkwJzELMAkGA1UEBhMCVVMxGDAWBgNVBAMMD2NyeXB0b2dy\nYXBoeS5pbzAKBgNVHRUEAwoBCTByAgEKGA8yMDE1MDEwMTAwMDAwMFowXDAYBgNV\nHRgEERgPMjAxNTAxMDEwMDAwMDBaMDQGA1UdHQQtMCukKTAnMQswCQYDVQQGEwJV\nUzEYMBYGA1UEAwwPY3J5cHRvZ3JhcGh5LmlvMAoGA1UdFQQDCgEKMC4CAQsYDzIw\nMTUwMTAxMDAwMDAwWjAYMAoGA1UdFQQDCgEBMAoGAyoDBAQDCgEAMA0GCSqGSIb3\nDQEBCwUAA4IBAQBTaloHlPaCZzYee8LxkWej5meiqxQVNWFoVdjesroa+f1FRrH+\ndrRU60Nq97KCKf7f9GNN/J3ZIlQmYhmuDqh12f+XLpotoj1ZRfBz2hjFCkJlv+2c\noWWGNHgA70ndFoVtcmX088SYpX8E3ARATivS4q2h9WlwV6rO93mhg3HGIe3JpcK4\n7BcW6Poi/ut/zsDOkVbI00SqaujRpdmdCTht82MH3ztjyDkI9KYaD/YEweKSrWOz\nSdEILd164bfBeLuplVI+xpmTEMVNpXBlSXl7+xIw9Vk7p7Q1Pa3k/SvhOldYCm6y\nC1xAg/AAq6w78yzYt18j5Mj0s6eeHi1YpHKw\n-----END X509 CRL-----\n\"\"\"\n\n\n# A broken RSA private key which can be used to test the error path through\n# PKey.check.\ninconsistentPrivateKeyPEM = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIBPAIBAAJBAKy+e3dulvXzV7zoTZWc5TzgApr8DmeQHTYC8ydfzH7EECe4R1Xh\n5kwIzOuuFfn178FBiS84gngaNcrFi0Z5fAkCAwEaAQJBAIqm/bz4NA1H++Vx5Ewx\nOcKp3w19QSaZAwlGRtsUxrP7436QjnREM3Bm8ygU11BjkPVmtrKm6AayQfCHqJoT\nzIECIQDW0BoMoL0HOYM/mrTLhaykYAVqgIeJsPjvkEhTFXWBuQIhAM3deFAvWNu4\nnklUQ37XsCT2c9tmNt1LAT+slG2JOTTRAiAuXDtC/m3NYVwyHfFm+zKHRzHkClk2\nHjubeEgjpj32AQIhAJqMGTaZVOwevTXvvHwNeH+vRWsAYU/gbx+OQB+7VOcBAiEA\noolb6NMg/R3enNPvS1O4UU1H8wpaF77L4yiSWlE0p4w=\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\n# certificate with NULL bytes in subjectAltName and common name\n\nnulbyteSubjectAltNamePEM = b\"\"\"-----BEGIN CERTIFICATE-----\nMIIE2DCCA8CgAwIBAgIBADANBgkqhkiG9w0BAQUFADCBxTELMAkGA1UEBhMCVVMx\nDzANBgNVBAgMBk9yZWdvbjESMBAGA1UEBwwJQmVhdmVydG9uMSMwIQYDVQQKDBpQ\neXRob24gU29mdHdhcmUgRm91bmRhdGlvbjEgMB4GA1UECwwXUHl0aG9uIENvcmUg\nRGV2ZWxvcG1lbnQxJDAiBgNVBAMMG251bGwucHl0aG9uLm9yZwBleGFtcGxlLm9y\nZzEkMCIGCSqGSIb3DQEJARYVcHl0aG9uLWRldkBweXRob24ub3JnMB4XDTEzMDgw\nNzEzMTE1MloXDTEzMDgwNzEzMTI1MlowgcUxCzAJBgNVBAYTAlVTMQ8wDQYDVQQI\nDAZPcmVnb24xEjAQBgNVBAcMCUJlYXZlcnRvbjEjMCEGA1UECgwaUHl0aG9uIFNv\nZnR3YXJlIEZvdW5kYXRpb24xIDAeBgNVBAsMF1B5dGhvbiBDb3JlIERldmVsb3Bt\nZW50MSQwIgYDVQQDDBtudWxsLnB5dGhvbi5vcmcAZXhhbXBsZS5vcmcxJDAiBgkq\nhkiG9w0BCQEWFXB5dGhvbi1kZXZAcHl0aG9uLm9yZzCCASIwDQYJKoZIhvcNAQEB\nBQADggEPADCCAQoCggEBALXq7cn7Rn1vO3aA3TrzA5QLp6bb7B3f/yN0CJ2XFj+j\npHs+Gw6WWSUDpybiiKnPec33BFawq3kyblnBMjBU61ioy5HwQqVkJ8vUVjGIUq3P\nvX/wBmQfzCe4o4uM89gpHyUL9UYGG8oCRa17dgqcv7u5rg0Wq2B1rgY+nHwx3JIv\nKRrgSwyRkGzpN8WQ1yrXlxWjgI9de0mPVDDUlywcWze1q2kwaEPTM3hLAmD1PESA\noY/n8A/RXoeeRs9i/Pm/DGUS8ZPINXk/yOzsR/XvvkTVroIeLZqfmFpnZeF0cHzL\n08LODkVJJ9zjLdT7SA4vnne4FEbAxDbKAq5qkYzaL4UCAwEAAaOB0DCBzTAMBgNV\nHRMBAf8EAjAAMB0GA1UdDgQWBBSIWlXAUv9hzVKjNQ/qWpwkOCL3XDALBgNVHQ8E\nBAMCBeAwgZAGA1UdEQSBiDCBhYIeYWx0bnVsbC5weXRob24ub3JnAGV4YW1wbGUu\nY29tgSBudWxsQHB5dGhvbi5vcmcAdXNlckBleGFtcGxlLm9yZ4YpaHR0cDovL251\nbGwucHl0aG9uLm9yZwBodHRwOi8vZXhhbXBsZS5vcmeHBMAAAgGHECABDbgAAAAA\nAAAAAAAAAAEwDQYJKoZIhvcNAQEFBQADggEBAKxPRe99SaghcI6IWT7UNkJw9aO9\ni9eo0Fj2MUqxpKbdb9noRDy2CnHWf7EIYZ1gznXPdwzSN4YCjV5d+Q9xtBaowT0j\nHPERs1ZuytCNNJTmhyqZ8q6uzMLoht4IqH/FBfpvgaeC5tBTnTT0rD5A/olXeimk\nkX4LxlEx5RAvpGB2zZVRGr6LobD9rVK91xuHYNIxxxfEGE8tCCWjp0+3ksri9SXx\nVHWBnbM9YaL32u3hxm8sYB/Yb8WSBavJCWJJqRStVRHM1koZlJmXNx2BX4vPo6iW\nRFEIPQsFZRLrtnCAiEhyT8bC2s/Njlu6ly9gtJZWSV46Q3ZjBL4q9sHKqZQ=\n-----END CERTIFICATE-----\"\"\"\n\nlarge_key_pem = b\"\"\"-----BEGIN RSA PRIVATE KEY-----\nMIIJYgIBAAKCAg4AtRua8eIeevRfsj+fkcHr1vmse7Kgb+oX1ssJAvCb1R7JQMnH\nhNDjDP6b3vEkZuPUzlDHymP+cNkXvvi4wJ4miVbO3+SeU4Sh+jmsHeHzGIXat9xW\n9PFtuPM5FQq8zvkY8aDeRYmYwN9JKu4/neMBCBqostYlTEWg+bSytO/qWnyHTHKh\ng0GfaDdqUQPsGQw+J0MgaYIjQOCVASHAPlzbDQLCtuOb587rwTLkZA2GwoHB/LyJ\nBwT0HHgBaiObE12Vs6wi2en0Uu11CiwEuK1KIBcZ2XbE6eApaZa6VH9ysEmUxPt7\nTqyZ4E2oMIYaLPNRxuvozdwTlj1svI1k1FrkaXGc5MTjbgigPMKjIb0T7b/4GNzt\nDhP1LvAeUMnrEi3hJJrcJPXHPqS8/RiytR9xQQW6Sdh4LaA3f9MQm3WSevWage3G\nP8YcCLssOVKsArDjuA52NF5LmYuAeUzXprm4ITDi2oO+0iFBpFW6VPEK4A9vO0Yk\nM/6Wt6tG8zyWhaSH1zFUTwfQ9Yvjyt5w1lrUaAJuoTpwbMVZaDJaEhjOaXU0dyPQ\njOsePDOQcU6dkeTWsQ3LsHPEEug/X6819TLG5mb3V7bvV9nPFBfTJSCEG794kr90\nXgZfIN71FrdByxLerlbuJI21pPs/nZi9SXi9jAWeiS45/azUxMsyYgJArui+gjq7\nsV1pWiBm6/orAgMBAAECggINQp5L6Yu+oIXBqcSjgq8tfF9M5hd30pLuf/EheHZf\nLA7uAqn2fVGFI2OInIJhXIOT5OxsAXO0xXfltzawZxIFpOFMqajj4F7aYjvSpw9V\nJ4EdSiJ/zgv8y1qUdbwEZbHVThRZjoSlrtSzilonBoHZAE0mHtqMz7iRFSk1zz6t\nGunRrvo/lROPentf3TsvHquVNUYI5yaapyO1S7xJhecMIIYSb8nbsHI54FBDGNas\n6mFmpPwI/47/6HTwOEWupnn3NicsjrHzUInOUpaMig4cRR+aP5bjqg/ty8xI8AoN\nevEmCytiWTc+Rvbp1ieN+1jpjN18PjUk80/W7qioHUDt4ieLic8uxWH2VD9SCEnX\nMpi9tA/FqoZ+2A/3m1OfrY6jiZVE2g+asi9lCK7QVWL39eK82H4rPvtp0/dyo1/i\nZZz68TXg+m8IgEZcp88hngbkuoTTzpGE73QuPKhGA1uMIimDdqPPB5WP76q+03Oi\nIRR5DfZnqPERed49by0enJ7tKa/gFPZizOV8ALKr0Dp+vfAkxGDLPLBLd2A3//tw\nxg0Q/wltihHSBujv4nYlDXdc5oYyMYZ+Lhc/VuOghHfBq3tgEQ1ECM/ofqXEIdy7\nnVcpZn3Eeq8Jl5CrqxE1ee3NxlzsJHn99yGQpr7mOhW/psJF3XNz80Meg3L4m1T8\nsMBK0GbaassuJhdzb5whAoIBBw48sx1b1WR4XxQc5O/HjHva+l16i2pjUnOUTcDF\nRWmSbIhBm2QQ2rVhO8+fak0tkl6ZnMWW4i0U/X5LOEBbC7+IS8bO3j3Revi+Vw5x\nj96LMlIe9XEub5i/saEWgiz7maCvfzLFU08e1OpT4qPDpP293V400ubA6R7WQTCv\npBkskGwHeu0l/TuKkVqBFFUTu7KEbps8Gjg7MkJaFriAOv1zis/umK8pVS3ZAM6e\n8w5jfpRccn8Xzta2fRwTB5kCmfxdDsY0oYGxPLRAbW72bORoLGuyyPp/ojeGwoik\nJX9RttErc6FjyZtks370Pa8UL5QskyhMbDhrZW2jFD+RXYM1BrvmZRjbAoIBBwy4\niFJpuDfytJfz1MWtaL5DqEL/kmiZYAXl6hifNhGu5GAipVIIGsDqEYW4i+VC15aa\n7kOCwz/I5zsB3vSDW96IRs4wXtqEZSibc2W/bqfVi+xcvPPl1ZhQ2EAwa4D/x035\nkyf20ffWOU+1yf2cnijzqs3IzlveUm+meLw5s3Rc+iG7DPWWeCoe1hVwANI1euNc\npqKwKY905yFyjOje2OgiEU2kS4YME4zGeBys8yo7E42hNnN2EPK6xkkUqzdudLLQ\n8OUlKRTc8AbIf3XG1rpA4VUpTv3hhxGGwCRy6If8zgZQsNYchgNztRGk72Gcb8Dm\nvFSEN3ZtwxU64G3YZzntdcr2WPzxAoIBBw30g6Fgdb/gmVnOpL0//T0ePNDKIMPs\njVJLaRduhoZgB1Bb9qPUPX0SzRzLZtg1tkZSDjBDoHmOHJfhxUaXt+FLCPPbrE4t\n+nq9n/nBaMM779w9ClqhqLOyGrwKoxjSmhi+TVEHyIxCbXMvPHVHfX9WzxjbcGrN\nZvRaEVZWo+QlIX8yqdSwqxLk1WtAIRzvlcj7NKum8xBxPed6BNFep/PtgIAmoLT5\nL8wb7EWb2iUdc2KbZ4OaY51lDScqpATgXu3WjXfM+Q52G0mX6Wyd0cjlL711Zrjb\nyLbiueZT94lgIHHRRKtKc8CEqcjkQV5OzABS3P/gQSfgZXBdLKjOpTnKDUq7IBeH\nAoIBBweAOEIAPLQg1QRUrr3xRrYKRwlakgZDii9wJt1l5AgBTICzbTA1vzDJ1JM5\nAqSpCV6w9JWyYVcXK+HLdKBRZLaPPNEQDJ5lOxD6uMziWGl2rg8tj+1xNMWfxiPz\naTCjoe4EoBUMoTq2gwzRcM2usEQNikXVhnj9Wzaivsaeb4bJ3GRPW5DkrO6JSEtT\nw+gvyMqQM2Hy5k7E7BT46sXVwaj/jZxuqGnebRixXtnp0WixdRIqYWUr1UqLf6hQ\nG7WP2BgoxCMaCmNW8+HMD/xuxucEotoIhZ+GgJKBFoNnjl3BX+qxYdSe9RbL/5Tr\n4It6Jxtj8uETJXEbv9Cg6v1agWPS9YY8RLTBAoIBBwrU2AsAUts6h1LgGLKK3UWZ\noLH5E+4o+7HqSGRcRodVeN9NBXIYdHHOLeEG6YNGJiJ3bFP5ZQEu9iDsyoFVKJ9O\nMw/y6dKZuxOCZ+X8FopSROg3yWfdOpAm6cnQZp3WqLNX4n/Q6WvKojfyEiPphjwT\n0ymrUJELXLWJmjUyPoAk6HgC0Gs28ZnEXbyhx7CSbZNFyCU/PNUDZwto3GisIPD3\nle7YjqHugezmjMGlA0sDw5aCXjfbl74vowRFYMO6e3ItApfSRgNV86CDoX74WI/5\nAYU/QVM4wGt8XGT2KwDFJaxYGKsGDMWmXY04dS+WPuetCbouWUusyFwRb9SzFave\nvYeU7Ab/\n-----END RSA PRIVATE KEY-----\"\"\"\n\nec_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgYirTZSx+5O8Y6tlG\ncka6W6btJiocdrdolfcukSoTEk+hRANCAAQkvPNu7Pa1GcsWU4v7ptNfqCJVq8Cx\nzo0MUVPQgwJ3aJtNM1QMOQUayCrRwfklg+D/rFSUwEUqtZh7fJDiFqz3\n-----END PRIVATE KEY-----\n\"\"\"\nec_public_key_pem = b\"\"\"-----BEGIN PUBLIC KEY-----\nMFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEJLzzbuz2tRnLFlOL+6bTX6giVavA\nsc6NDFFT0IMCd2ibTTNUDDkFGsgq0cH5JYPg/6xUlMBFKrWYe3yQ4has9w==\n-----END PUBLIC KEY-----\n\"\"\"\n\nec_root_key_pem = b\"\"\"-----BEGIN EC PRIVATE KEY-----\nMIGlAgEBBDEAz/HOBFPYLB0jLWeTpJn4Yc4m/C4mdWymVHBjOmnwiPHKT326iYN/\nZhmSs+RM94RsoAcGBSuBBAAioWQDYgAEwE5vDdla/nLpWAPAQ0yFGqwLuw4BcN2r\nU+sKab5EAEHzLeceRa8ffncYdCXNoVsBcdob1y66CFZMEWLetPTmGapyWkBAs6/L\n8kUlkU9OsE+7IVo4QQJkgV5gM+Dim1XE\n-----END EC PRIVATE KEY-----\n\"\"\"\n\nec_root_cert_pem = b\"\"\"-----BEGIN CERTIFICATE-----\nMIICLTCCAbKgAwIBAgIMWW/hwTl6ufz6/WkCMAoGCCqGSM49BAMDMFgxGDAWBgNV\nBAMTD1Rlc3RpbmcgUm9vdCBDQTEQMA4GA1UEChMHVGVzdGluZzEQMA4GA1UEBxMH\nQ2hpY2FnbzELMAkGA1UECBMCSUwxCzAJBgNVBAYTAlVTMCAXDTE3MDcxOTIyNDgz\nM1oYDzk5OTkxMjMxMjM1OTU5WjBYMRgwFgYDVQQDEw9UZXN0aW5nIFJvb3QgQ0Ex\nEDAOBgNVBAoTB1Rlc3RpbmcxEDAOBgNVBAcTB0NoaWNhZ28xCzAJBgNVBAgTAklM\nMQswCQYDVQQGEwJVUzB2MBAGByqGSM49AgEGBSuBBAAiA2IABMBObw3ZWv5y6VgD\nwENMhRqsC7sOAXDdq1PrCmm+RABB8y3nHkWvH353GHQlzaFbAXHaG9cuughWTBFi\n3rT05hmqclpAQLOvy/JFJZFPTrBPuyFaOEECZIFeYDPg4ptVxKNDMEEwDwYDVR0T\nAQH/BAUwAwEB/zAPBgNVHQ8BAf8EBQMDBwQAMB0GA1UdDgQWBBSoTrF0H2m8RDzB\nMnY2KReEPfz7ZjAKBggqhkjOPQQDAwNpADBmAjEA3+G1oVCxGjYX4iUN93QYcNHe\ne3fJQJwX9+KsHRut6qNZDUbvRbtO1YIAwB4UJZjwAjEAtXCPURS5A4McZHnSwgTi\nTd8GMrwKz0557OxxtKN6uVVy4ACFMqEw0zN/KJI1vxc9\n-----END CERTIFICATE-----\"\"\"\n\nrsa_p_not_prime_pem = \"\"\"\n-----BEGIN RSA PRIVATE KEY-----\nMBsCAQACAS0CAQcCAQACAQ8CAQMCAQACAQACAQA=\n-----END RSA PRIVATE KEY-----\n\"\"\"\n\ndsa_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMIICZAIBADCCAjkGByqGSM44BAEwggIsAoIBAQD7UzdlshSCIIuntch43VmfCX1+\nWQDTvGw83sRZcN+B7nwFn4dm2PU8cby17oCjX7buBvalVqofnUokrSIDA6Rozm/f\n2wpGR9oVpd0xh9cI50pw1G3RZ4lcNWTP8C8O20eIzJoCH1KElcWLCHLAa3XoGOMv\np4XnbVgMdc9/ydt4qttzIVPV4cZoVObzixoKCgwHyVPDxe0JaCe2cIwxyQY0IwAI\nPfaUWEAo+bf7pOosdnatJYm9MkKe8bEgKGQcUl9S8FXLhRejMo+oobcRjuBHTAmY\nfuV1iGlLrkFNrc2O6M1CRZhOoddoy53IeHcSjfzKET1biE3tCOUdHjUnABqfAiEA\n1llvauVKMLvFCDatVKRY+zNGJaa5dwff4qDtodz6sa8CggEAd+btod0di21mqFaf\nvc1ddmLK74PddMseT8DmoN/YduJaGLAOOVJ61rdG+KPXIar+8X5yqXfzP0MiYGkE\nA+xpNIImC3rzHElYNa8imA7ud8f+oC5jQijp0GhzVIS4UW83rZwakX7LITNE9Oj9\nFkETH1ZskHpp5BNlNoaSIW2+T7n/a+lq+tN60gP3f6FPBv5obB0pjqh+OAzEil/4\nYs0dtCB0022cCUCqThMhWewlE2W2JioDLV5QkD91NMQNQwljDONNcs94AaWeVONK\nRaBQXlFsJPHzS8uKpsFeusFTrHIeEJW/8GQp/tfXP1ajEdg5EGxOhXFkem4ZMIus\nYFTbWwQiAiBFtgi8aNV0Jz2o8T+cxjVqVEgGdYNQqmpzqqBsM5AEOw==\n-----END PRIVATE KEY-----\n\"\"\"\ndsa_public_key_pem = b\"\"\"-----BEGIN PUBLIC KEY-----\nMIIDRjCCAjkGByqGSM44BAEwggIsAoIBAQD7UzdlshSCIIuntch43VmfCX1+WQDT\nvGw83sRZcN+B7nwFn4dm2PU8cby17oCjX7buBvalVqofnUokrSIDA6Rozm/f2wpG\nR9oVpd0xh9cI50pw1G3RZ4lcNWTP8C8O20eIzJoCH1KElcWLCHLAa3XoGOMvp4Xn\nbVgMdc9/ydt4qttzIVPV4cZoVObzixoKCgwHyVPDxe0JaCe2cIwxyQY0IwAIPfaU\nWEAo+bf7pOosdnatJYm9MkKe8bEgKGQcUl9S8FXLhRejMo+oobcRjuBHTAmYfuV1\niGlLrkFNrc2O6M1CRZhOoddoy53IeHcSjfzKET1biE3tCOUdHjUnABqfAiEA1llv\nauVKMLvFCDatVKRY+zNGJaa5dwff4qDtodz6sa8CggEAd+btod0di21mqFafvc1d\ndmLK74PddMseT8DmoN/YduJaGLAOOVJ61rdG+KPXIar+8X5yqXfzP0MiYGkEA+xp\nNIImC3rzHElYNa8imA7ud8f+oC5jQijp0GhzVIS4UW83rZwakX7LITNE9Oj9FkET\nH1ZskHpp5BNlNoaSIW2+T7n/a+lq+tN60gP3f6FPBv5obB0pjqh+OAzEil/4Ys0d\ntCB0022cCUCqThMhWewlE2W2JioDLV5QkD91NMQNQwljDONNcs94AaWeVONKRaBQ\nXlFsJPHzS8uKpsFeusFTrHIeEJW/8GQp/tfXP1ajEdg5EGxOhXFkem4ZMIusYFTb\nWwOCAQUAAoIBAEe6z5ud1k4EDD9mLP7UYALWrgc1NXUlDynoYkjr+T/NVf1eaMdq\n0vFbGcEmz05UPUNXOhDH0szUDxQam3IE9C27ZO4SOquc0/rIhPY6i75SJW13P+cg\ngdXhDMTW5JOlyV6CPUoCWKOtn1ds3pTDuuWlZ89UzOWQUbC1si6vvz43zDyhfu6U\nowgIusPxowErm2sH66+MPa8fYxVX7ZJL0mEfubejrloAbo5unYI/bUYIhx4mtpP/\nh/isFRifEAwG3yX6F9X/ZOYL53Z93EFPLJGRGMmQbkmXRA6lyvHdsC+OC/OCvPjW\nWfTXW9NHtUqpEks+OXBkyV971Hk5NvdLLr8=\n-----END PUBLIC KEY-----\n\"\"\"\n\ned25519_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMC4CAQAwBQYDK2VwBCIEIKlxBbhVsSURoLTmsu9uTqYH6oF7zpxmp1ZQCAPhDmI2\n-----END PRIVATE KEY-----\n\"\"\"\ned25519_public_key_pem = b\"\"\"-----BEGIN PUBLIC KEY-----\nMCowBQYDK2VwAyEAq+FrpdwI1oTPytx8kGzuLVc+78zJE7hjYG4E9hwXoKI=\n-----END PUBLIC KEY-----\n\"\"\"\n\ned448_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMEcCAQAwBQYDK2VxBDsEOcqZ7a3k6JwrJbYO8CNTPT/d7dlWCo5vCf0EYDj79ZvA\\nhD8u9EPHlYJw5Y8ZQdH4WmVEfpKA23xkdQ==\n-----END PRIVATE KEY-----\n\"\"\"\ned448_public_key_pem = b\"\"\"-----BEGIN PUBLIC KEY-----\nMEMwBQYDK2VxAzoAKFfWGCuqIaxgR9GmEXLRciYDyEjTnF56kr0sOVfwHEj+bHSU\\neMJTZJR8qFSg8hNsHY1iZh9PIXcA\n-----END PUBLIC KEY-----\n\"\"\"\n\nrsa_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMIIEuwIBADANBgkqhkiG9w0BAQEFAASCBKUwggShAgEAAoIBAQDZ5FaSaXKn/RTF\nxyNr+GRvYnMvLz5XxSDD4JzVRKXxKGFzKKXMJAeXJkvPlho7Ta/HgMNXhMPAe8TT\nwcIRnHJqAfmSOnka1ks3Kl6EGQBTevKzyJy8MaUhzZsL4FUUgWUETFQQT8Dwcghf\nJobV0k+bWT4mrKHzIquw5y+NTsaZl4jSB1labhImsU16Vj66fHp7w9+c501tOxQO\nM4CQNWioGm8tgPT/43QUs9e+L2HFBI+cDQbEC68l+7VM8YY8NZ/fGypoML2QMVnU\nY6zneoOLJTMUulOubrL+J6DkuuhxBsIOcyxMnqwgKm4pUGlPxfPSS7+Mo3JC969k\nwgUHerXZAgMBAAECgf9qAzz/VMCQwnV1UxkhxH/8zgYgYL+fERFuPC/ZWv7wOicv\nxAjm9KC8zVb44fLE586CCc7IN+zNK9y0gB9eAGr/04RhEvWgbmoqF6wdtdNyynuE\nUt4oQKn7AUc1uPAeCfM4slw0Pie98YSS/9ZhwH/eh3C10iwWA1aiLWeDrnryPuJN\nmNB0d/ZsaL+arhR/nU2sJixx5LDI6AG0GJrw3DBHEKb4vZPIUM3wZNs7qnuG5W17\nJbZDQYnkApByZu2UMWI2YUkpJC246mFPWSWMa6sAl7sTWTkUIR21lJiqyTGG3ljY\nC2QjHoHrrzs+pwtlLBa1a4FgbaJmnL+VzWD/FQECgYEA8r3Y2oGcY5cQPb00TE0t\nekXAXiHz9sX76nzE6BMZ8cwP/cVoWtIABpdaimKUoFML8CdjOi9Ti9OoNVGWm4Pk\nfT/GOUdysXWIw2Z/VOLM47nDwJb3fWwxsxph+x3gWJG/Vct/1NxmCCEendM63dy7\n/uR8RgX+0nxvn6Y6auQfpnkCgYEA5csHboa14Favx8aHTlITWOm46ugzdbARdfWz\n13Ewb7m4mm/3gKtA/m+yGdQFwmtBVkmwtdCeDj0aKH3Sfvg9WCQK1x/dUkPMr//r\noGUGeJU9r3ZKVJTeSJ0lKX4h3u3+1TdpnAgtuWGI4AK9fEdulfHKArxyIdbsdwRr\nljaBMmECgYATpEcCz1APQu7+f+vWbLxMU46QT2EFS9npjHUGbl1AEooMt8eM6cc0\nwVSDNBzgqDekFBvUXnX9L4BB6DsulEqN0/Y/NkfSkjch0I5nGP8JQkPTtqOKE5Il\n8vGQt0crA4ge8huC5t6es8ddb/UodK8FnglsRRnsgEMsAPBjK9hfyQKBgDHD23Mr\nR14zR9Q7AXiLu9bonvx4lxRosg9ay7zfrX60uO7xSqeZ7vRrWiXPzgOB2N+IC/YE\nHQa2YuDcBucqeZaKD7LxGqxDNKP1B6Fv34vjvj0uoABbURxms/Kdd1ZhMmwYmQ2K\nk+Ru5AancUPl8GQWvgoDp6/+bK2Fzor0eNxhAoGBANcJ6mGvgw3px/H2MPBjRBsf\ntUbZ39UH3c4siLa2Rry/Pm0Fgly8CUmu1IcFQDITKbyhaGPuHGtXglBOZqXid0VL\n01ReWISyKwWyuRjUuscdq2m684hXHYZCq2eJroqon1nMq4C0aqr696ra0cgCfbK3\n5yscAByxKd+64JZziDkZ\n-----END PRIVATE KEY-----\n\"\"\"\nrsa_public_key_pem = b\"\"\"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2eRWkmlyp/0Uxccja/hk\nb2JzLy8+V8Ugw+Cc1USl8ShhcyilzCQHlyZLz5YaO02vx4DDV4TDwHvE08HCEZxy\nagH5kjp5GtZLNypehBkAU3rys8icvDGlIc2bC+BVFIFlBExUEE/A8HIIXyaG1dJP\nm1k+Jqyh8yKrsOcvjU7GmZeI0gdZWm4SJrFNelY+unx6e8PfnOdNbTsUDjOAkDVo\nqBpvLYD0/+N0FLPXvi9hxQSPnA0GxAuvJfu1TPGGPDWf3xsqaDC9kDFZ1GOs53qD\niyUzFLpTrm6y/ieg5LrocQbCDnMsTJ6sICpuKVBpT8Xz0ku/jKNyQvevZMIFB3q1\n2QIDAQAB\n-----END PUBLIC KEY-----\n\"\"\"\n\nx25519_private_key_pem = b\"\"\"-----BEGIN PRIVATE KEY-----\nMC4CAQAwBQYDK2VuBCIEIPAjVfPNTm25VxtBRg+JjjFx9tA3M8aaBdVhjb92iBts\n-----END PRIVATE KEY-----\n\"\"\"\n\n\n@pytest.fixture\ndef x509_data():\n    \"\"\"\n    Create a new private key and start a certificate request (for a test\n    to finish in one way or another).\n    \"\"\"\n    # Basic setup stuff to generate a certificate\n    pkey = PKey()\n    pkey.generate_key(TYPE_RSA, 2048)\n    req = X509Req()\n    req.set_pubkey(pkey)\n    # Authority good you have.\n    req.get_subject().commonName = \"Yoda root CA\"\n    x509 = X509()\n    subject = x509.get_subject()\n    subject.commonName = req.get_subject().commonName\n    x509.set_issuer(subject)\n    x509.set_pubkey(pkey)\n    now = datetime.now()\n    expire = datetime.now() + timedelta(days=100)\n    x509.set_notBefore(now.strftime(\"%Y%m%d%H%M%SZ\").encode())\n    x509.set_notAfter(expire.strftime(\"%Y%m%d%H%M%SZ\").encode())\n    yield pkey, x509\n\n\nclass TestX509Ext:\n    \"\"\"\n    Tests for `OpenSSL.crypto.X509Extension`.\n    \"\"\"\n\n    def test_str(self):\n        \"\"\"\n        The string representation of `X509Extension` instances as\n        returned by `str` includes stuff.\n        \"\"\"\n        # This isn't necessarily the best string representation.  Perhaps it\n        # will be changed/improved in the future.\n        assert (\n            str(X509Extension(b\"basicConstraints\", True, b\"CA:false\"))\n            == \"CA:FALSE\"\n        )\n\n    def test_type(self):\n        \"\"\"\n        `X509Extension` can be used to create instances of that type.\n        \"\"\"\n        assert is_consistent_type(\n            X509Extension,\n            \"X509Extension\",\n            b\"basicConstraints\",\n            True,\n            b\"CA:true\",\n        )\n\n    def test_construction(self):\n        \"\"\"\n        `X509Extension` accepts an extension type name, a critical flag,\n        and an extension value and returns an `X509Extension` instance.\n        \"\"\"\n        basic = X509Extension(b\"basicConstraints\", True, b\"CA:true\")\n        assert isinstance(basic, X509Extension)\n\n        comment = X509Extension(b\"nsComment\", False, b\"pyOpenSSL unit test\")\n        assert isinstance(comment, X509Extension)\n\n    @pytest.mark.parametrize(\n        \"type_name, critical, value\",\n        [\n            (b\"thisIsMadeUp\", False, b\"hi\"),\n            (b\"basicConstraints\", False, b\"blah blah\"),\n            # Exercise a weird one (an extension which uses the r2i method).\n            # This exercises the codepath that requires a non-NULL ctx to be\n            # passed to X509V3_EXT_nconf. It can't work now because we provide\n            # no configuration database. It might be made to work in the\n            # future.\n            (\n                b\"proxyCertInfo\",\n                True,\n                b\"language:id-ppl-anyLanguage,pathlen:1,policy:text:AB\",\n            ),\n        ],\n    )\n    def test_invalid_extension(self, type_name, critical, value):\n        \"\"\"\n        `X509Extension` raises something if it is passed a bad\n        extension name or value.\n        \"\"\"\n        with pytest.raises(Error):\n            X509Extension(type_name, critical, value)\n\n    @pytest.mark.parametrize(\"critical_flag\", [True, False])\n    def test_get_critical(self, critical_flag):\n        \"\"\"\n        `X509ExtensionType.get_critical` returns the value of the\n        extension's critical flag.\n        \"\"\"\n        ext = X509Extension(b\"basicConstraints\", critical_flag, b\"CA:true\")\n        assert ext.get_critical() == critical_flag\n\n    @pytest.mark.parametrize(\n        \"short_name, value\",\n        [(b\"basicConstraints\", b\"CA:true\"), (b\"nsComment\", b\"foo bar\")],\n    )\n    def test_get_short_name(self, short_name, value):\n        \"\"\"\n        `X509ExtensionType.get_short_name` returns a string giving the\n        short type name of the extension.\n        \"\"\"\n        ext = X509Extension(short_name, True, value)\n        assert ext.get_short_name() == short_name\n\n    def test_get_data(self):\n        \"\"\"\n        `X509Extension.get_data` returns a string giving the data of\n        the extension.\n        \"\"\"\n        ext = X509Extension(b\"basicConstraints\", True, b\"CA:true\")\n        # Expect to get back the DER encoded form of CA:true.\n        assert ext.get_data() == b\"0\\x03\\x01\\x01\\xff\"\n\n    def test_unused_subject(self, x509_data):\n        \"\"\"\n        The `subject` parameter to `X509Extension` may be provided for an\n        extension which does not use it and is ignored in this case.\n        \"\"\"\n        pkey, x509 = x509_data\n        ext1 = X509Extension(\n            b\"basicConstraints\", False, b\"CA:TRUE\", subject=x509\n        )\n        x509.add_extensions([ext1])\n        x509.sign(pkey, \"sha256\")\n        # This is a little lame.  Can we think of a better way?\n        text = dump_certificate(FILETYPE_TEXT, x509)\n        assert b\"X509v3 Basic Constraints:\" in text\n        assert b\"CA:TRUE\" in text\n\n    def test_subject(self, x509_data):\n        \"\"\"\n        If an extension requires a subject, the `subject` parameter to\n        `X509Extension` provides its value.\n        \"\"\"\n        pkey, x509 = x509_data\n        ext3 = X509Extension(\n            b\"subjectKeyIdentifier\", False, b\"hash\", subject=x509\n        )\n        x509.add_extensions([ext3])\n        x509.sign(pkey, \"sha256\")\n        text = dump_certificate(FILETYPE_TEXT, x509)\n        assert b\"X509v3 Subject Key Identifier:\" in text\n\n    def test_missing_subject(self):\n        \"\"\"\n        If an extension requires a subject and the `subject` parameter\n        is given no value, something happens.\n        \"\"\"\n        with pytest.raises(Error):\n            X509Extension(b\"subjectKeyIdentifier\", False, b\"hash\")\n\n    @pytest.mark.parametrize(\"bad_obj\", [True, object(), \"hello\", []])\n    def test_invalid_subject(self, bad_obj):\n        \"\"\"\n        If the `subject` parameter is given a value which is not an\n        `X509` instance, `TypeError` is raised.\n        \"\"\"\n        with pytest.raises(TypeError):\n            X509Extension(\n                \"basicConstraints\", False, \"CA:TRUE\", subject=bad_obj\n            )\n\n    def test_unused_issuer(self, x509_data):\n        \"\"\"\n        The `issuer` parameter to `X509Extension` may be provided for an\n        extension which does not use it and is ignored in this case.\n        \"\"\"\n        pkey, x509 = x509_data\n        ext1 = X509Extension(\n            b\"basicConstraints\", False, b\"CA:TRUE\", issuer=x509\n        )\n        x509.add_extensions([ext1])\n        x509.sign(pkey, \"sha256\")\n        text = dump_certificate(FILETYPE_TEXT, x509)\n        assert b\"X509v3 Basic Constraints:\" in text\n        assert b\"CA:TRUE\" in text\n\n    def test_issuer(self, x509_data):\n        \"\"\"\n        If an extension requires an issuer, the `issuer` parameter to\n        `X509Extension` provides its value.\n        \"\"\"\n        pkey, x509 = x509_data\n        ext2 = X509Extension(\n            b\"authorityKeyIdentifier\", False, b\"issuer:always\", issuer=x509\n        )\n        x509.add_extensions([ext2])\n        x509.sign(pkey, \"sha256\")\n        text = dump_certificate(FILETYPE_TEXT, x509)\n        assert b\"X509v3 Authority Key Identifier:\" in text\n        assert b\"DirName:/CN=Yoda root CA\" in text\n\n    def test_missing_issuer(self):\n        \"\"\"\n        If an extension requires an issue and the `issuer` parameter is\n        given no value, something happens.\n        \"\"\"\n        with pytest.raises(Error):\n            X509Extension(\n                b\"authorityKeyIdentifier\", False, b\"keyid:always,issuer:always\"\n            )\n\n    @pytest.mark.parametrize(\"bad_obj\", [True, object(), \"hello\", []])\n    def test_invalid_issuer(self, bad_obj):\n        \"\"\"\n        If the `issuer` parameter is given a value which is not an\n        `X509` instance, `TypeError` is raised.\n        \"\"\"\n        with pytest.raises(TypeError):\n            X509Extension(\n                \"basicConstraints\",\n                False,\n                \"keyid:always,issuer:always\",\n                issuer=bad_obj,\n            )\n\n\nclass TestPKey:\n    \"\"\"\n    Tests for `OpenSSL.crypto.PKey`.\n    \"\"\"\n\n    @pytest.mark.parametrize(\n        (\"key_string\", \"key_type\"),\n        [\n            (dsa_private_key_pem, dsa.DSAPrivateKey),\n            (ec_private_key_pem, ec.EllipticCurvePrivateKey),\n            (ed25519_private_key_pem, ed25519.Ed25519PrivateKey),\n            (ed448_private_key_pem, ed448.Ed448PrivateKey),\n            (rsa_private_key_pem, rsa.RSAPrivateKey),\n        ],\n    )\n    def test_convert_roundtrip_cryptography_private_key(\n        self, key_string, key_type\n    ):\n        \"\"\"\n        PKey.from_cryptography_key creates a proper private PKey.\n        PKey.to_cryptography_key creates a proper cryptography private key.\n        \"\"\"\n        key = serialization.load_pem_private_key(key_string, None)\n        assert isinstance(key, key_type)\n        pkey = PKey.from_cryptography_key(key)\n\n        assert isinstance(pkey, PKey)\n        parsed_key = pkey.to_cryptography_key()\n        assert isinstance(parsed_key, key_type)\n        assert parsed_key.public_key().public_bytes(\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        ) == key.public_key().public_bytes(\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        assert pkey._only_public is False\n        assert pkey._initialized is True\n\n    @pytest.mark.parametrize(\n        (\"key_string\", \"key_type\"),\n        [\n            (dsa_public_key_pem, dsa.DSAPublicKey),\n            (ec_public_key_pem, ec.EllipticCurvePublicKey),\n            (ed25519_public_key_pem, ed25519.Ed25519PublicKey),\n            (ed448_public_key_pem, ed448.Ed448PublicKey),\n            (rsa_public_key_pem, rsa.RSAPublicKey),\n        ],\n    )\n    def test_convert_roundtrip_cryptography_public_key(\n        self, key_string, key_type\n    ):\n        \"\"\"\n        PKey.from_cryptography_key creates a proper public PKey.\n        PKey.to_cryptography_key creates a proper cryptography public key.\n        \"\"\"\n        key = serialization.load_pem_public_key(key_string, None)\n        assert isinstance(key, key_type)\n        pkey = PKey.from_cryptography_key(key)\n\n        assert isinstance(pkey, PKey)\n        parsed_key = pkey.to_cryptography_key()\n        assert isinstance(parsed_key, key_type)\n        assert parsed_key.public_bytes(\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        ) == key.public_bytes(\n            serialization.Encoding.PEM,\n            serialization.PublicFormat.SubjectPublicKeyInfo,\n        )\n        assert pkey._only_public is True\n        assert pkey._initialized is True\n\n    def test_convert_from_cryptography_public_key(self):\n        \"\"\"\n        PKey.from_cryptography_key creates a proper public PKey.\n        \"\"\"\n        key = serialization.load_pem_public_key(cleartextPublicKeyPEM)\n        pkey = PKey.from_cryptography_key(key)\n\n        assert isinstance(pkey, PKey)\n        assert pkey.bits() == key.key_size\n        assert pkey._only_public is True\n        assert pkey._initialized is True\n\n    def test_convert_from_cryptography_unsupported_type(self):\n        \"\"\"\n        PKey.from_cryptography_key raises TypeError with an unsupported type.\n        \"\"\"\n        key = serialization.load_pem_private_key(x25519_private_key_pem, None)\n        with pytest.raises(TypeError):\n            PKey.from_cryptography_key(key)\n\n    def test_convert_public_pkey_to_cryptography_key(self):\n        \"\"\"\n        PKey.to_cryptography_key creates a proper cryptography public key.\n        \"\"\"\n        pkey = load_publickey(FILETYPE_PEM, cleartextPublicKeyPEM)\n        key = pkey.to_cryptography_key()\n\n        assert isinstance(key, rsa.RSAPublicKey)\n        assert pkey.bits() == key.key_size\n\n    def test_type(self):\n        \"\"\"\n        `PKey` can be used to create instances of that type.\n        \"\"\"\n        assert is_consistent_type(PKey, \"PKey\")\n\n    def test_construction(self):\n        \"\"\"\n        `PKey` takes no arguments and returns a new `PKey` instance.\n        \"\"\"\n        key = PKey()\n        assert isinstance(key, PKey)\n\n    def test_pregeneration(self):\n        \"\"\"\n        `PKey.bits` and `PKey.type` return `0` before the key is generated.\n        `PKey.check` raises `TypeError` before the key is generated.\n        \"\"\"\n        key = PKey()\n        assert key.type() == 0\n        assert key.bits() == 0\n        with pytest.raises(TypeError):\n            key.check()\n\n    def test_failed_generation(self):\n        \"\"\"\n        `PKey.generate_key` takes two arguments, the first giving the key type\n        as one of `TYPE_RSA` or `TYPE_DSA` and the second giving the number of\n        bits to generate.  If an invalid type is specified or generation fails,\n        `Error` is raised.  If an invalid number of bits is specified,\n        `ValueError` or `Error` is raised.\n        \"\"\"\n        key = PKey()\n        with pytest.raises(TypeError):\n            key.generate_key(\"foo\", \"bar\")\n        with pytest.raises(Error):\n            key.generate_key(-1, 0)\n\n        with pytest.raises(ValueError):\n            key.generate_key(TYPE_RSA, -1)\n        with pytest.raises(ValueError):\n            key.generate_key(TYPE_RSA, 0)\n\n        with pytest.raises(TypeError):\n            key.generate_key(TYPE_RSA, object())\n\n        # XXX RSA generation for small values of bits is fairly buggy in a wide\n        # range of OpenSSL versions.  I need to figure out what the safe lower\n        # bound for a reasonable number of OpenSSL versions is and explicitly\n        # check for that in the wrapper.  The failure behavior is typically an\n        # infinite loop inside OpenSSL.\n\n        # with pytest.raises(Error):\n        #     key.generate_key(TYPE_RSA, 2)\n\n        # XXX DSA generation seems happy with any number of bits.  The DSS\n        # says bits must be between 512 and 1024 inclusive.  OpenSSL's DSA\n        # generator doesn't seem to care about the upper limit at all.  For\n        # the lower limit, it uses 512 if anything smaller is specified.\n        # So, it doesn't seem possible to make generate_key fail for\n        # TYPE_DSA with a bits argument which is at least an int.\n\n        # with pytest.raises(Error):\n        #     key.generate_key(TYPE_DSA, -7)\n\n    def test_rsa_generation(self):\n        \"\"\"\n        `PKey.generate_key` generates an RSA key when passed `TYPE_RSA` as a\n        type and a reasonable number of bits.\n        \"\"\"\n        bits = 2048\n        key = PKey()\n        key.generate_key(TYPE_RSA, bits)\n        assert key.type() == TYPE_RSA\n        assert key.bits() == bits\n        assert key.check()\n\n    def test_dsa_generation(self):\n        \"\"\"\n        `PKey.generate_key` generates a DSA key when passed `TYPE_DSA` as a\n        type and a reasonable number of bits.\n        \"\"\"\n        # 512 is a magic number.  The DSS (Digital Signature Standard)\n        # allows a minimum of 512 bits for DSA.  DSA_generate_parameters\n        # will silently promote any value below 512 to 512.\n        bits = 512\n        key = PKey()\n        key.generate_key(TYPE_DSA, bits)\n        assert key.type() == TYPE_DSA\n        assert key.bits() == bits\n        with pytest.raises(TypeError):\n            key.check()\n\n    def test_regeneration(self):\n        \"\"\"\n        `PKey.generate_key` can be called multiple times on the same key to\n        generate new keys.\n        \"\"\"\n        key = PKey()\n        for type, bits in [(TYPE_RSA, 2048), (TYPE_DSA, 576)]:\n            key.generate_key(type, bits)\n            assert key.type() == type\n            assert key.bits() == bits\n\n    def test_inconsistent_key(self):\n        \"\"\"\n        Either `load_privatekey` or `PKey.check` returns `Error` if the key is\n        not consistent.\n        \"\"\"\n        with pytest.raises(Error):\n            key = load_privatekey(FILETYPE_PEM, inconsistentPrivateKeyPEM)\n            key.check()\n\n    def test_check_public_key(self):\n        \"\"\"\n        `PKey.check` raises `TypeError` if only the public part of the key\n        is available.\n        \"\"\"\n        # A trick to get a public-only key\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        cert = X509()\n        cert.set_pubkey(key)\n        pub = cert.get_pubkey()\n        with pytest.raises(TypeError):\n            pub.check()\n\n    def test_check_pr_897(self):\n        \"\"\"\n        Either `load_privatekey` or `PKey.check` raises `OpenSSL.crypto.Error`\n        if provided with broken key\n        \"\"\"\n        with pytest.raises(Error):\n            pkey = load_privatekey(FILETYPE_PEM, rsa_p_not_prime_pem)\n            pkey.check()\n\n\ndef x509_name(**attrs):\n    \"\"\"\n    Return a new X509Name with the given attributes.\n    \"\"\"\n    # XXX There's no other way to get a new X509Name yet.\n    name = X509().get_subject()\n    attrs = list(attrs.items())\n\n    # Make the order stable - order matters!\n    def key(attr):\n        return attr[1]\n\n    attrs.sort(key=key)\n    for k, v in attrs:\n        setattr(name, k, v)\n    return name\n\n\nclass TestX509Name:\n    \"\"\"\n    Unit tests for `OpenSSL.crypto.X509Name`.\n    \"\"\"\n\n    def test_type(self):\n        \"\"\"\n        The type of X509Name objects is `X509Name`.\n        \"\"\"\n        name = x509_name()\n        assert isinstance(name, X509Name)\n\n    def test_only_string_attributes(self):\n        \"\"\"\n        Attempting to set a non-`str` attribute name on an `X509Name` instance\n        causes `TypeError` to be raised.\n        \"\"\"\n        name = x509_name()\n        # Beyond these cases, you may also think that unicode should be\n        # rejected.  Sorry, you're wrong.  unicode is automatically converted\n        # to str outside of the control of X509Name, so there's no way to\n        # reject it.\n\n        # Also, this used to test str subclasses, but that test is less\n        # relevant now that the implementation is in Python instead of C.  Also\n        # PyPy automatically converts str subclasses to str when they are\n        # passed to setattr, so we can't test it on PyPy.  Apparently CPython\n        # does this sometimes as well.\n        with pytest.raises(TypeError):\n            setattr(name, None, \"hello\")\n        with pytest.raises(TypeError):\n            setattr(name, 30, \"hello\")\n\n    def test_set_invalid_attribute(self):\n        \"\"\"\n        Attempting to set any attribute name on an `X509Name` instance for\n        which no corresponding NID is defined causes `AttributeError` to be\n        raised.\n        \"\"\"\n        name = x509_name()\n        with pytest.raises(AttributeError):\n            setattr(name, \"no such thing\", None)\n\n    def test_attributes(self):\n        \"\"\"\n        `X509Name` instances have attributes for each standard (?)\n        X509Name field.\n        \"\"\"\n        name = x509_name()\n        name.commonName = \"foo\"\n        assert name.commonName == \"foo\"\n        assert name.CN == \"foo\"\n\n        name.CN = \"baz\"\n        assert name.commonName == \"baz\"\n        assert name.CN == \"baz\"\n\n        name.commonName = \"bar\"\n        assert name.commonName == \"bar\"\n        assert name.CN == \"bar\"\n\n        name.CN = \"quux\"\n        assert name.commonName == \"quux\"\n        assert name.CN == \"quux\"\n\n        assert name.OU is None\n\n        with pytest.raises(AttributeError):\n            name.foobar\n\n    def test_copy(self):\n        \"\"\"\n        `X509Name` creates a new `X509Name` instance with all the same\n        attributes as an existing `X509Name` instance when called with one.\n        \"\"\"\n        name = x509_name(commonName=\"foo\", emailAddress=\"bar@example.com\")\n\n        copy = X509Name(name)\n        assert copy.commonName == \"foo\"\n        assert copy.emailAddress == \"bar@example.com\"\n\n        # Mutate the copy and ensure the original is unmodified.\n        copy.commonName = \"baz\"\n        assert name.commonName == \"foo\"\n\n        # Mutate the original and ensure the copy is unmodified.\n        name.emailAddress = \"quux@example.com\"\n        assert copy.emailAddress == \"bar@example.com\"\n\n    def test_repr(self):\n        \"\"\"\n        `repr` passed an `X509Name` instance should return a string containing\n        a description of the type and the NIDs which have been set on it.\n        \"\"\"\n        name = x509_name(commonName=\"foo\", emailAddress=\"bar\")\n        assert repr(name) == \"<X509Name object '/emailAddress=bar/CN=foo'>\"\n\n    def test_comparison(self):\n        \"\"\"\n        `X509Name` instances should compare based on their NIDs.\n        \"\"\"\n\n        def _equality(a, b, assert_true, assert_false):\n            assert_true(a == b)\n            assert_false(a != b)\n            assert_true(b == a)\n            assert_false(b != a)\n\n        def assert_true(x):\n            assert x\n\n        def assert_false(x):\n            assert not x\n\n        def assert_equal(a, b):\n            _equality(a, b, assert_true, assert_false)\n\n        # Instances compare equal to themselves.\n        name = x509_name()\n        assert_equal(name, name)\n\n        # Empty instances should compare equal to each other.\n        assert_equal(x509_name(), x509_name())\n\n        # Instances with equal NIDs should compare equal to each other.\n        assert_equal(x509_name(commonName=\"foo\"), x509_name(commonName=\"foo\"))\n\n        # Instance with equal NIDs set using different aliases should compare\n        # equal to each other.\n        assert_equal(x509_name(commonName=\"foo\"), x509_name(CN=\"foo\"))\n\n        # Instances with more than one NID with the same values should compare\n        # equal to each other.\n        assert_equal(\n            x509_name(CN=\"foo\", organizationalUnitName=\"bar\"),\n            x509_name(commonName=\"foo\", OU=\"bar\"),\n        )\n\n        def assert_not_equal(a, b):\n            _equality(a, b, assert_false, assert_true)\n\n        # Instances with different values for the same NID should not compare\n        # equal to each other.\n        assert_not_equal(x509_name(CN=\"foo\"), x509_name(CN=\"bar\"))\n\n        # Instances with different NIDs should not compare equal to each other.\n        assert_not_equal(x509_name(CN=\"foo\"), x509_name(OU=\"foo\"))\n\n        assert_not_equal(x509_name(), object())\n\n        def _inequality(a, b, assert_true, assert_false):\n            assert_true(a < b)\n            assert_true(a <= b)\n            assert_true(b > a)\n            assert_true(b >= a)\n            assert_false(a > b)\n            assert_false(a >= b)\n            assert_false(b < a)\n            assert_false(b <= a)\n\n        def assert_less_than(a, b):\n            _inequality(a, b, assert_true, assert_false)\n\n        # An X509Name with a NID with a value which sorts less than the value\n        # of the same NID on another X509Name compares less than the other\n        # X509Name.\n        assert_less_than(x509_name(CN=\"abc\"), x509_name(CN=\"def\"))\n\n        def assert_greater_than(a, b):\n            _inequality(a, b, assert_false, assert_true)\n\n        # An X509Name with a NID with a value which sorts greater than the\n        # value of the same NID on another X509Name compares greater than the\n        # other X509Name.\n        assert_greater_than(x509_name(CN=\"def\"), x509_name(CN=\"abc\"))\n\n        def assert_raises(a, b):\n            with pytest.raises(TypeError):\n                a < b\n            with pytest.raises(TypeError):\n                a <= b\n            with pytest.raises(TypeError):\n                a > b\n            with pytest.raises(TypeError):\n                a >= b\n\n        # Only X509Name objects can be compared with lesser than / greater than\n        assert_raises(x509_name(), object())\n\n    def test_hash(self):\n        \"\"\"\n        `X509Name.hash` returns an integer hash based on the value of the name.\n        \"\"\"\n        a = x509_name(CN=\"foo\")\n        b = x509_name(CN=\"foo\")\n        assert a.hash() == b.hash()\n        a.CN = \"bar\"\n        assert a.hash() != b.hash()\n\n    def test_der(self):\n        \"\"\"\n        `X509Name.der` returns the DER encoded form of the name.\n        \"\"\"\n        a = x509_name(CN=\"foo\", C=\"US\")\n        assert (\n            a.der() == b\"0\\x1b1\\x0b0\\t\\x06\\x03U\\x04\\x06\\x13\\x02US\"\n            b\"1\\x0c0\\n\\x06\\x03U\\x04\\x03\\x0c\\x03foo\"\n        )\n\n    def test_get_components(self):\n        \"\"\"\n        `X509Name.get_components` returns a `list` of two-tuples of `str`\n        giving the NIDs and associated values which make up the name.\n        \"\"\"\n        a = x509_name()\n        assert a.get_components() == []\n        a.CN = \"foo\"\n        assert a.get_components() == [(b\"CN\", b\"foo\")]\n        a.organizationalUnitName = \"bar\"\n        assert a.get_components() == [(b\"CN\", b\"foo\"), (b\"OU\", b\"bar\")]\n\n    def test_load_nul_byte_attribute(self):\n        \"\"\"\n        An `X509Name` from an `X509` instance loaded from a file can have a\n        NUL byte in the value of one of its attributes.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, nulbyteSubjectAltNamePEM)\n        subject = cert.get_subject()\n        assert \"null.python.org\\x00example.org\" == subject.commonName\n\n    def test_load_nul_byte_components(self):\n        \"\"\"\n        An `X509Name` from an `X509` instance loaded from a file can have a\n        NUL byte in the value of its components\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, nulbyteSubjectAltNamePEM)\n        subject = cert.get_subject()\n        components = subject.get_components()\n        ccn = [value for name, value in components if name == b\"CN\"]\n        assert ccn[0] == b\"null.python.org\\x00example.org\"\n\n    def test_set_attribute_failure(self):\n        \"\"\"\n        If the value of an attribute cannot be set for some reason then\n        `Error` is raised.\n        \"\"\"\n        name = x509_name()\n        # This value is too long\n        with pytest.raises(Error):\n            setattr(name, \"O\", b\"x\" * 512)\n\n\nclass _PKeyInteractionTestsMixin:\n    \"\"\"\n    Tests which involve another thing and a PKey.\n    \"\"\"\n\n    def signable(self):\n        \"\"\"\n        Return something with `set_pubkey` and `sign` methods.\n        \"\"\"\n        raise NotImplementedError()\n\n    def test_sign_with_ungenerated(self):\n        \"\"\"\n        `X509Req.sign` raises `ValueError` when passed a `PKey` with no parts.\n        \"\"\"\n        request = self.signable()\n        key = PKey()\n        with pytest.raises(ValueError):\n            request.sign(key, GOOD_DIGEST)\n\n    def test_sign_with_public_key(self):\n        \"\"\"\n        `X509Req.sign` raises `ValueError` when passed a `PKey` with no private\n        part as the signing key.\n        \"\"\"\n        request = self.signable()\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        request.set_pubkey(key)\n        pub = request.get_pubkey()\n        with pytest.raises(ValueError):\n            request.sign(pub, GOOD_DIGEST)\n\n    def test_sign_with_unknown_digest(self):\n        \"\"\"\n        `X509Req.sign` raises `ValueError` when passed a digest name which is\n        not known.\n        \"\"\"\n        request = self.signable()\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        with pytest.raises(ValueError):\n            request.sign(key, BAD_DIGEST)\n\n    def test_sign(self):\n        \"\"\"\n        `X509Req.sign` succeeds when passed a private key object and a\n        valid digest function. `X509Req.verify` can be used to check\n        the signature.\n        \"\"\"\n        request = self.signable()\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        request.set_pubkey(key)\n        request.sign(key, GOOD_DIGEST)\n        # If the type has a verify method, cover that too.\n        if getattr(request, \"verify\", None) is not None:\n            pub = request.get_pubkey()\n            assert request.verify(pub)\n            # Make another key that won't verify.\n            key = PKey()\n            key.generate_key(TYPE_RSA, 2048)\n            with pytest.raises(Error):\n                request.verify(key)\n\n\nclass TestX509Req(_PKeyInteractionTestsMixin):\n    \"\"\"\n    Tests for `OpenSSL.crypto.X509Req`.\n    \"\"\"\n\n    def signable(self):\n        \"\"\"\n        Create and return a new `X509Req`.\n        \"\"\"\n        return X509Req()\n\n    def test_type(self):\n        \"\"\"\n        `X509Req` can be used to create instances of that type.\n        \"\"\"\n        assert is_consistent_type(X509Req, \"X509Req\")\n\n    def test_construction(self):\n        \"\"\"\n        `X509Req` takes no arguments and returns an `X509Req` instance.\n        \"\"\"\n        request = X509Req()\n        assert isinstance(request, X509Req)\n\n    def test_version(self):\n        \"\"\"\n        `X509Req.set_version` sets the X.509 version of the certificate\n        request. `X509Req.get_version` returns the X.509 version of the\n        certificate request. The only defined version is 0.\n        \"\"\"\n        request = X509Req()\n        assert request.get_version() == 0\n        request.set_version(0)\n        assert request.get_version() == 0\n\n    def test_version_wrong_args(self):\n        \"\"\"\n        `X509Req.set_version` raises `TypeError` if called with a non-`int`\n        argument.\n        \"\"\"\n        request = X509Req()\n        with pytest.raises(TypeError):\n            request.set_version(\"foo\")\n        with pytest.raises(ValueError):\n            request.set_version(2)\n\n    def test_get_subject(self):\n        \"\"\"\n        `X509Req.get_subject` returns an `X509Name` for the subject of the\n        request and which is valid even after the request object is\n        otherwise dead.\n        \"\"\"\n        request = X509Req()\n        subject = request.get_subject()\n        assert isinstance(subject, X509Name)\n        subject.commonName = \"foo\"\n        assert request.get_subject().commonName == \"foo\"\n        del request\n        subject.commonName = \"bar\"\n        assert subject.commonName == \"bar\"\n\n    def test_add_extensions(self):\n        \"\"\"\n        `X509Req.add_extensions` accepts a `list` of `X509Extension` instances\n        and adds them to the X509 request.\n        \"\"\"\n        request = X509Req()\n        request.add_extensions(\n            [X509Extension(b\"basicConstraints\", True, b\"CA:false\")]\n        )\n        exts = request.get_extensions()\n        assert len(exts) == 1\n        assert exts[0].get_short_name() == b\"basicConstraints\"\n        assert exts[0].get_critical() == 1\n        assert exts[0].get_data() == b\"0\\x00\"\n\n    def test_get_extensions(self):\n        \"\"\"\n        `X509Req.get_extensions` returns a `list` of extensions added to this\n        X509 request.\n        \"\"\"\n        request = X509Req()\n        exts = request.get_extensions()\n        assert exts == []\n        request.add_extensions(\n            [\n                X509Extension(b\"basicConstraints\", True, b\"CA:true\"),\n                X509Extension(b\"keyUsage\", False, b\"digitalSignature\"),\n            ]\n        )\n        exts = request.get_extensions()\n        assert len(exts) == 2\n        assert exts[0].get_short_name() == b\"basicConstraints\"\n        assert exts[0].get_critical() == 1\n        assert exts[0].get_data() == b\"0\\x03\\x01\\x01\\xff\"\n        assert exts[1].get_short_name() == b\"keyUsage\"\n        assert exts[1].get_critical() == 0\n        assert exts[1].get_data() == b\"\\x03\\x02\\x07\\x80\"\n        # Requesting it a second time should return the same list\n        exts = request.get_extensions()\n        assert len(exts) == 2\n\n    def test_undef_oid(self):\n        assert (\n            X509Extension(\n                b\"1.2.3.4.5.6.7\", False, b\"DER:05:00\"\n            ).get_short_name()\n            == b\"UNDEF\"\n        )\n\n    def test_add_extensions_wrong_args(self):\n        \"\"\"\n        `X509Req.add_extensions` raises `TypeError` if called with a\n        non-`list`.  Or it raises `ValueError` if called with a `list`\n        containing objects other than `X509Extension` instances.\n        \"\"\"\n        request = X509Req()\n        with pytest.raises(TypeError):\n            request.add_extensions(object())\n        with pytest.raises(ValueError):\n            request.add_extensions([object()])\n\n    def test_verify_wrong_args(self):\n        \"\"\"\n        `X509Req.verify` raises `TypeError` if passed anything other than a\n        `PKey` instance as its single argument.\n        \"\"\"\n        request = X509Req()\n        with pytest.raises(TypeError):\n            request.verify(object())\n\n    def test_verify_uninitialized_key(self):\n        \"\"\"\n        `X509Req.verify` raises `OpenSSL.crypto.Error` if called with a\n        `OpenSSL.crypto.PKey` which contains no key data.\n        \"\"\"\n        request = X509Req()\n        pkey = PKey()\n        with pytest.raises(Error):\n            request.verify(pkey)\n\n    def test_verify_wrong_key(self):\n        \"\"\"\n        `X509Req.verify` raises `OpenSSL.crypto.Error` if called with a\n        `OpenSSL.crypto.PKey` which does not represent the public part of the\n        key which signed the request.\n        \"\"\"\n        request = X509Req()\n        pkey = load_privatekey(FILETYPE_PEM, root_key_pem)\n        request.set_pubkey(pkey)\n        request.sign(pkey, GOOD_DIGEST)\n        another_pkey = load_privatekey(FILETYPE_PEM, client_key_pem)\n        with pytest.raises(Error):\n            request.verify(another_pkey)\n\n    def test_verify_success(self):\n        \"\"\"\n        `X509Req.verify` returns `True` if called with a `OpenSSL.crypto.PKey`\n        which represents the public part of the key which signed the request.\n        \"\"\"\n        request = X509Req()\n        pkey = load_privatekey(FILETYPE_PEM, root_key_pem)\n        request.set_pubkey(pkey)\n        request.sign(pkey, GOOD_DIGEST)\n        assert request.verify(pkey)\n\n    def test_convert_from_cryptography(self):\n        crypto_req = x509.load_pem_x509_csr(cleartextCertificateRequestPEM)\n        req = X509Req.from_cryptography(crypto_req)\n        assert isinstance(req, X509Req)\n\n    def test_convert_from_cryptography_unsupported_type(self):\n        with pytest.raises(TypeError):\n            X509Req.from_cryptography(object())\n\n    def test_convert_to_cryptography_key(self):\n        req = load_certificate_request(\n            FILETYPE_PEM, cleartextCertificateRequestPEM\n        )\n        crypto_req = req.to_cryptography()\n        assert isinstance(crypto_req, x509.CertificateSigningRequest)\n\n\nclass TestX509(_PKeyInteractionTestsMixin):\n    \"\"\"\n    Tests for `OpenSSL.crypto.X509`.\n    \"\"\"\n\n    pemData = root_cert_pem + root_key_pem\n\n    def signable(self):\n        \"\"\"\n        Create and return a new `X509`.\n        \"\"\"\n        certificate = X509()\n        # Fill in placeholder validity values. signable only expects to call\n        # set_pubkey and sign.\n        certificate.gmtime_adj_notBefore(-24 * 60 * 60)\n        certificate.gmtime_adj_notAfter(24 * 60 * 60)\n        return certificate\n\n    def test_type(self):\n        \"\"\"\n        `X509` can be used to create instances of that type.\n        \"\"\"\n        assert is_consistent_type(X509, \"X509\")\n\n    def test_construction(self):\n        \"\"\"\n        `X509` takes no arguments and returns an instance of `X509`.\n        \"\"\"\n        certificate = X509()\n        assert isinstance(certificate, X509)\n        assert type(certificate).__name__ == \"X509\"\n        assert type(certificate) is X509\n\n    def test_set_version_wrong_args(self):\n        \"\"\"\n        `X509.set_version` raises `TypeError` if invoked with an argument\n        not of type `int`.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.set_version(None)\n\n    def test_version(self):\n        \"\"\"\n        `X509.set_version` sets the certificate version number.\n        `X509.get_version` retrieves it.\n        \"\"\"\n        cert = X509()\n        cert.set_version(2)\n        assert cert.get_version() == 2\n\n    def test_serial_number(self):\n        \"\"\"\n        The serial number of an `X509` can be retrieved and\n        modified with `X509.get_serial_number` and\n        `X509.set_serial_number`.\n        \"\"\"\n        certificate = X509()\n        with pytest.raises(TypeError):\n            certificate.set_serial_number(\"1\")\n        assert certificate.get_serial_number() == 0\n        certificate.set_serial_number(1)\n        assert certificate.get_serial_number() == 1\n        certificate.set_serial_number(2**32 + 1)\n        assert certificate.get_serial_number() == 2**32 + 1\n        certificate.set_serial_number(2**64 + 1)\n        assert certificate.get_serial_number() == 2**64 + 1\n        certificate.set_serial_number(2**128 + 1)\n        assert certificate.get_serial_number() == 2**128 + 1\n\n    def _setBoundTest(self, which):\n        \"\"\"\n        `X509.set_notBefore` takes a string in the format of an\n        ASN1 GENERALIZEDTIME and sets the beginning of the certificate's\n        validity period to it.\n        \"\"\"\n        certificate = X509()\n        set = getattr(certificate, \"set_not\" + which)\n        get = getattr(certificate, \"get_not\" + which)\n\n        # Starts with no value.\n        assert get() is None\n\n        # GMT (Or is it UTC?) -exarkun\n        when = b\"20040203040506Z\"\n        set(when)\n        assert get() == when\n\n        # A plus two hours and thirty minutes offset\n        when = b\"20040203040506+0530\"\n        set(when)\n        assert get() == when\n\n        # A minus one hour fifteen minutes offset\n        when = b\"20040203040506-0115\"\n        set(when)\n        assert get() == when\n\n        # An invalid string results in a ValueError\n        with pytest.raises(ValueError):\n            set(b\"foo bar\")\n\n        # The wrong number of arguments results in a TypeError.\n        with pytest.raises(TypeError):\n            set()\n        with pytest.raises(TypeError):\n            set(b\"20040203040506Z\", b\"20040203040506Z\")\n        with pytest.raises(TypeError):\n            get(b\"foo bar\")\n\n    # XXX ASN1_TIME (not GENERALIZEDTIME)\n\n    def test_set_notBefore(self):\n        \"\"\"\n        `X509.set_notBefore` takes a string in the format of an\n        ASN1 GENERALIZEDTIME and sets the beginning of the certificate's\n        validity period to it.\n        \"\"\"\n        self._setBoundTest(\"Before\")\n\n    def test_set_notAfter(self):\n        \"\"\"\n        `X509.set_notAfter` takes a string in the format of an ASN1\n        GENERALIZEDTIME and sets the end of the certificate's validity period\n        to it.\n        \"\"\"\n        self._setBoundTest(\"After\")\n\n    def test_get_notBefore(self):\n        \"\"\"\n        `X509.get_notBefore` returns a string in the format of an\n        ASN1 GENERALIZEDTIME even for certificates which store it as UTCTIME\n        internally.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, old_root_cert_pem)\n        assert cert.get_notBefore() == b\"20090325123658Z\"\n\n    def test_get_notAfter(self):\n        \"\"\"\n        `X509.get_notAfter` returns a string in the format of an\n        ASN1 GENERALIZEDTIME even for certificates which store it as UTCTIME\n        internally.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, old_root_cert_pem)\n        assert cert.get_notAfter() == b\"20170611123658Z\"\n\n    def test_gmtime_adj_notBefore_wrong_args(self):\n        \"\"\"\n        `X509.gmtime_adj_notBefore` raises `TypeError` if called with a\n        non-`int` argument.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.gmtime_adj_notBefore(None)\n\n    @pytest.mark.flaky(reruns=2)\n    def test_gmtime_adj_notBefore(self):\n        \"\"\"\n        `X509.gmtime_adj_notBefore` changes the not-before timestamp to be the\n        current time plus the number of seconds passed in.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        not_before_min = utcnow().replace(microsecond=0) + timedelta(\n            seconds=100\n        )\n        cert.gmtime_adj_notBefore(100)\n        not_before = datetime.strptime(\n            cert.get_notBefore().decode(), \"%Y%m%d%H%M%SZ\"\n        )\n        not_before_max = utcnow() + timedelta(seconds=100)\n        assert not_before_min <= not_before <= not_before_max\n\n    def test_gmtime_adj_notAfter_wrong_args(self):\n        \"\"\"\n        `X509.gmtime_adj_notAfter` raises `TypeError` if called with a\n        non-`int` argument.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.gmtime_adj_notAfter(None)\n\n    @pytest.mark.flaky(reruns=2)\n    def test_gmtime_adj_notAfter(self):\n        \"\"\"\n        `X509.gmtime_adj_notAfter` changes the not-after timestamp\n        to be the current time plus the number of seconds passed in.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        not_after_min = utcnow().replace(microsecond=0) + timedelta(\n            seconds=100\n        )\n        cert.gmtime_adj_notAfter(100)\n        not_after = datetime.strptime(\n            cert.get_notAfter().decode(), \"%Y%m%d%H%M%SZ\"\n        )\n        not_after_max = utcnow() + timedelta(seconds=100)\n        assert not_after_min <= not_after <= not_after_max\n\n    def test_has_expired(self):\n        \"\"\"\n        `X509.has_expired` returns `True` if the certificate's not-after time\n        is in the past.\n        \"\"\"\n        cert = X509()\n        cert.gmtime_adj_notAfter(-1)\n        assert cert.has_expired()\n\n    def test_has_not_expired(self):\n        \"\"\"\n        `X509.has_expired` returns `False` if the certificate's not-after time\n        is in the future.\n        \"\"\"\n        cert = X509()\n        cert.gmtime_adj_notAfter(2)\n        assert not cert.has_expired()\n\n    def test_has_expired_exception(self):\n        \"\"\"\n        `X509.has_expired` throws ValueError if not-after time is not set\n        \"\"\"\n        cert = X509()\n        with pytest.raises(ValueError):\n            cert.has_expired()\n\n    def test_root_has_not_expired(self):\n        \"\"\"\n        `X509.has_expired` returns `False` if the certificate's not-after time\n        is in the future.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        assert not cert.has_expired()\n\n    def test_digest(self):\n        \"\"\"\n        `X509.digest` returns a string giving \":\"-separated hex-encoded\n        words of the digest of the certificate.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, old_root_cert_pem)\n        assert (\n            # Digest verified with the command:\n            # openssl x509 -in root_cert.pem -noout -fingerprint -sha256\n            cert.digest(\"SHA256\")\n            == (\n                b\"3E:0F:16:39:6B:B1:3E:4F:08:85:C6:5F:10:0D:CB:2C:\"\n                b\"25:C2:91:4E:D0:4A:C2:29:06:BD:55:E3:A7:B3:B7:06\"\n            )\n        )\n\n    def _extcert(self, pkey, extensions):\n        cert = X509()\n        # Certificates with extensions must be X.509v3, which is encoded with a\n        # version of two.\n        cert.set_version(2)\n        cert.set_pubkey(pkey)\n        cert.get_subject().commonName = \"Unit Tests\"\n        cert.get_issuer().commonName = \"Unit Tests\"\n        when = datetime.now().strftime(\"%Y%m%d%H%M%SZ\").encode(\"ascii\")\n        cert.set_notBefore(when)\n        cert.set_notAfter(when)\n\n        cert.add_extensions(extensions)\n        cert.sign(pkey, \"sha256\")\n        return load_certificate(\n            FILETYPE_PEM, dump_certificate(FILETYPE_PEM, cert)\n        )\n\n    def test_extension_count(self):\n        \"\"\"\n        `X509.get_extension_count` returns the number of extensions\n        that are present in the certificate.\n        \"\"\"\n        pkey = load_privatekey(FILETYPE_PEM, client_key_pem)\n        ca = X509Extension(b\"basicConstraints\", True, b\"CA:FALSE\")\n        key = X509Extension(b\"keyUsage\", True, b\"digitalSignature\")\n        subjectAltName = X509Extension(\n            b\"subjectAltName\", True, b\"DNS:example.com\"\n        )\n\n        # Try a certificate with no extensions at all.\n        c = self._extcert(pkey, [])\n        assert c.get_extension_count() == 0\n\n        # And a certificate with one\n        c = self._extcert(pkey, [ca])\n        assert c.get_extension_count() == 1\n\n        # And a certificate with several\n        c = self._extcert(pkey, [ca, key, subjectAltName])\n        assert c.get_extension_count() == 3\n\n    def test_get_extension(self):\n        \"\"\"\n        `X509.get_extension` takes an integer and returns an\n        `X509Extension` corresponding to the extension at that index.\n        \"\"\"\n        pkey = load_privatekey(FILETYPE_PEM, client_key_pem)\n        ca = X509Extension(b\"basicConstraints\", True, b\"CA:FALSE\")\n        key = X509Extension(b\"keyUsage\", True, b\"digitalSignature\")\n        subjectAltName = X509Extension(\n            b\"subjectAltName\", False, b\"DNS:example.com\"\n        )\n\n        cert = self._extcert(pkey, [ca, key, subjectAltName])\n\n        ext = cert.get_extension(0)\n        assert isinstance(ext, X509Extension)\n        assert ext.get_critical()\n        assert ext.get_short_name() == b\"basicConstraints\"\n\n        ext = cert.get_extension(1)\n        assert isinstance(ext, X509Extension)\n        assert ext.get_critical()\n        assert ext.get_short_name() == b\"keyUsage\"\n\n        ext = cert.get_extension(2)\n        assert isinstance(ext, X509Extension)\n        assert not ext.get_critical()\n        assert ext.get_short_name() == b\"subjectAltName\"\n\n        with pytest.raises(IndexError):\n            cert.get_extension(-1)\n        with pytest.raises(IndexError):\n            cert.get_extension(4)\n        with pytest.raises(TypeError):\n            cert.get_extension(\"hello\")\n\n    def test_nullbyte_subjectAltName(self):\n        \"\"\"\n        The fields of a `subjectAltName` extension on an X509 may contain NUL\n        bytes and this value is reflected in the string representation of the\n        extension object.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, nulbyteSubjectAltNamePEM)\n\n        ext = cert.get_extension(3)\n        assert ext.get_short_name() == b\"subjectAltName\"\n        assert (\n            b\"DNS:altnull.python.org\\x00example.com, \"\n            b\"email:null@python.org\\x00user@example.org, \"\n            b\"URI:http://null.python.org\\x00http://example.org, \"\n            b\"IP Address:192.0.2.1, IP Address:2001:DB8:0:0:0:0:0:1\"\n            == str(ext).encode(\"ascii\").strip()\n        )\n\n    def test_invalid_digest_algorithm(self):\n        \"\"\"\n        `X509.digest` raises `ValueError` if called with an unrecognized hash\n        algorithm.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(ValueError):\n            cert.digest(BAD_DIGEST)\n\n    def test_get_subject(self):\n        \"\"\"\n        `X509.get_subject` returns an `X509Name` instance.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        subj = cert.get_subject()\n        assert isinstance(subj, X509Name)\n        assert subj.get_components() == [\n            (b\"C\", b\"US\"),\n            (b\"ST\", b\"IL\"),\n            (b\"L\", b\"Chicago\"),\n            (b\"O\", b\"Testing\"),\n            (b\"CN\", b\"Testing Root CA\"),\n        ]\n\n    def test_set_subject_wrong_args(self):\n        \"\"\"\n        `X509.set_subject` raises a `TypeError` if called with an argument not\n        of type `X509Name`.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.set_subject(None)\n\n    def test_set_subject(self):\n        \"\"\"\n        `X509.set_subject` changes the subject of the certificate to the one\n        passed in.\n        \"\"\"\n        cert = X509()\n        name = cert.get_subject()\n        name.C = \"AU\"\n        name.OU = \"Unit Tests\"\n        cert.set_subject(name)\n        assert cert.get_subject().get_components() == [\n            (b\"C\", b\"AU\"),\n            (b\"OU\", b\"Unit Tests\"),\n        ]\n\n    def test_get_issuer(self):\n        \"\"\"\n        `X509.get_issuer` returns an `X509Name` instance.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        subj = cert.get_issuer()\n        assert isinstance(subj, X509Name)\n        comp = subj.get_components()\n        assert comp == [\n            (b\"C\", b\"US\"),\n            (b\"ST\", b\"IL\"),\n            (b\"L\", b\"Chicago\"),\n            (b\"O\", b\"Testing\"),\n            (b\"CN\", b\"Testing Root CA\"),\n        ]\n\n    def test_set_issuer_wrong_args(self):\n        \"\"\"\n        `X509.set_issuer` raises a `TypeError` if called with an argument not\n        of type `X509Name`.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.set_issuer(None)\n\n    def test_set_issuer(self):\n        \"\"\"\n        `X509.set_issuer` changes the issuer of the certificate to the\n        one passed in.\n        \"\"\"\n        cert = X509()\n        name = cert.get_issuer()\n        name.C = \"AU\"\n        name.OU = \"Unit Tests\"\n        cert.set_issuer(name)\n        assert cert.get_issuer().get_components() == [\n            (b\"C\", b\"AU\"),\n            (b\"OU\", b\"Unit Tests\"),\n        ]\n\n    def test_get_pubkey_uninitialized(self):\n        \"\"\"\n        When called on a certificate with no public key, `X509.get_pubkey`\n        raises `OpenSSL.crypto.Error`.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(Error):\n            cert.get_pubkey()\n\n    def test_set_pubkey_wrong_type(self):\n        \"\"\"\n        `X509.set_pubkey` raises `TypeError` when given an object of the\n        wrong type.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.set_pubkey(object())\n\n    def test_subject_name_hash(self):\n        \"\"\"\n        `X509.subject_name_hash` returns the hash of the certificate's\n        subject name.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        # SHA1\n        assert cert.subject_name_hash() == 3278919224\n\n    def test_get_signature_algorithm(self):\n        \"\"\"\n        `X509.get_signature_algorithm` returns a string which means\n        the algorithm used to sign the certificate.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, self.pemData)\n        assert b\"sha256WithRSAEncryption\" == cert.get_signature_algorithm()\n\n    def test_get_undefined_signature_algorithm(self):\n        \"\"\"\n        `X509.get_signature_algorithm` raises `ValueError` if the signature\n        algorithm is undefined or unknown.\n        \"\"\"\n        # This certificate has been modified to indicate a bogus OID in the\n        # signature algorithm field so that OpenSSL does not recognize it.\n        certPEM = b\"\"\"\\\n-----BEGIN CERTIFICATE-----\nMIIC/zCCAmigAwIBAgIBATAGBgJ8BQUAMHsxCzAJBgNVBAYTAlNHMREwDwYDVQQK\nEwhNMkNyeXB0bzEUMBIGA1UECxMLTTJDcnlwdG8gQ0ExJDAiBgNVBAMTG00yQ3J5\ncHRvIENlcnRpZmljYXRlIE1hc3RlcjEdMBsGCSqGSIb3DQEJARYObmdwc0Bwb3N0\nMS5jb20wHhcNMDAwOTEwMDk1MTMwWhcNMDIwOTEwMDk1MTMwWjBTMQswCQYDVQQG\nEwJTRzERMA8GA1UEChMITTJDcnlwdG8xEjAQBgNVBAMTCWxvY2FsaG9zdDEdMBsG\nCSqGSIb3DQEJARYObmdwc0Bwb3N0MS5jb20wXDANBgkqhkiG9w0BAQEFAANLADBI\nAkEArL57d26W9fNXvOhNlZzlPOACmvwOZ5AdNgLzJ1/MfsQQJ7hHVeHmTAjM664V\n+fXvwUGJLziCeBo1ysWLRnl8CQIDAQABo4IBBDCCAQAwCQYDVR0TBAIwADAsBglg\nhkgBhvhCAQ0EHxYdT3BlblNTTCBHZW5lcmF0ZWQgQ2VydGlmaWNhdGUwHQYDVR0O\nBBYEFM+EgpK+eyZiwFU1aOPSbczbPSpVMIGlBgNVHSMEgZ0wgZqAFPuHI2nrnDqT\nFeXFvylRT/7tKDgBoX+kfTB7MQswCQYDVQQGEwJTRzERMA8GA1UEChMITTJDcnlw\ndG8xFDASBgNVBAsTC00yQ3J5cHRvIENBMSQwIgYDVQQDExtNMkNyeXB0byBDZXJ0\naWZpY2F0ZSBNYXN0ZXIxHTAbBgkqhkiG9w0BCQEWDm5ncHNAcG9zdDEuY29tggEA\nMA0GCSqGSIb3DQEBBAUAA4GBADv8KpPo+gfJxN2ERK1Y1l17sz/ZhzoGgm5XCdbx\njEY7xKfpQngV599k1xhl11IMqizDwu0855agrckg2MCTmOI9DZzDD77tAYb+Dk0O\nPEVk0Mk/V0aIsDE9bolfCi/i/QWZ3N8s5nTWMNyBBBmoSliWCm4jkkRZRD0ejgTN\ntgI5\n-----END CERTIFICATE-----\n\"\"\"\n        cert = load_certificate(FILETYPE_PEM, certPEM)\n        with pytest.raises(ValueError):\n            cert.get_signature_algorithm()\n\n    def test_sign_bad_pubkey_type(self):\n        \"\"\"\n        `X509.sign` raises `TypeError` when called with the wrong type.\n        \"\"\"\n        cert = X509()\n        with pytest.raises(TypeError):\n            cert.sign(object(), b\"sha256\")\n\n    def test_convert_from_cryptography(self):\n        crypto_cert = x509.load_pem_x509_certificate(intermediate_cert_pem)\n        cert = X509.from_cryptography(crypto_cert)\n\n        assert isinstance(cert, X509)\n        assert cert.get_version() == crypto_cert.version.value\n\n    def test_convert_from_cryptography_unsupported_type(self):\n        with pytest.raises(TypeError):\n            X509.from_cryptography(object())\n\n    def test_convert_to_cryptography_key(self):\n        cert = load_certificate(FILETYPE_PEM, intermediate_cert_pem)\n        crypto_cert = cert.to_cryptography()\n\n        assert isinstance(crypto_cert, x509.Certificate)\n        assert crypto_cert.version.value == cert.get_version()\n\n\nclass TestX509Store:\n    \"\"\"\n    Test for `OpenSSL.crypto.X509Store`.\n    \"\"\"\n\n    def test_type(self):\n        \"\"\"\n        `X509Store` is a type object.\n        \"\"\"\n        assert is_consistent_type(X509Store, \"X509Store\")\n\n    def test_add_cert(self):\n        \"\"\"\n        `X509Store.add_cert` adds a `X509` instance to the certificate store.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        store = X509Store()\n        store.add_cert(cert)\n\n    @pytest.mark.parametrize(\"cert\", [None, 1.0, \"cert\", object()])\n    def test_add_cert_wrong_args(self, cert):\n        \"\"\"\n        `X509Store.add_cert` raises `TypeError` if passed a non-X509 object\n        as its first argument.\n        \"\"\"\n        store = X509Store()\n        with pytest.raises(TypeError):\n            store.add_cert(cert)\n\n    def test_add_cert_accepts_duplicate(self):\n        \"\"\"\n        `X509Store.add_cert` doesn't raise `OpenSSL.crypto.Error` if an attempt\n        is made to add the same certificate to the store more than once.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        store = X509Store()\n        store.add_cert(cert)\n        store.add_cert(cert)\n\n    @pytest.mark.parametrize(\n        \"cafile, capath, call_cafile, call_capath\",\n        [\n            (\n                \"/cafile\" + NON_ASCII,\n                None,\n                b\"/cafile\" + NON_ASCII.encode(sys.getfilesystemencoding()),\n                _ffi.NULL,\n            ),\n            (\n                b\"/cafile\" + NON_ASCII.encode(\"utf-8\"),\n                None,\n                b\"/cafile\" + NON_ASCII.encode(\"utf-8\"),\n                _ffi.NULL,\n            ),\n            (\n                None,\n                \"/capath\" + NON_ASCII,\n                _ffi.NULL,\n                b\"/capath\" + NON_ASCII.encode(sys.getfilesystemencoding()),\n            ),\n            (\n                None,\n                b\"/capath\" + NON_ASCII.encode(\"utf-8\"),\n                _ffi.NULL,\n                b\"/capath\" + NON_ASCII.encode(\"utf-8\"),\n            ),\n        ],\n    )\n    def test_load_locations_parameters(\n        self, cafile, capath, call_cafile, call_capath, monkeypatch\n    ):\n        class LibMock:\n            def load_locations(self, store, cafile, capath):\n                self.cafile = cafile\n                self.capath = capath\n                return 1\n\n        lib_mock = LibMock()\n        monkeypatch.setattr(\n            _lib, \"X509_STORE_load_locations\", lib_mock.load_locations\n        )\n\n        store = X509Store()\n        store.load_locations(cafile=cafile, capath=capath)\n\n        assert call_cafile == lib_mock.cafile\n        assert call_capath == lib_mock.capath\n\n    def test_load_locations_fails_when_all_args_are_none(self):\n        store = X509Store()\n        with pytest.raises(Error):\n            store.load_locations(None, None)\n\n    def test_load_locations_raises_error_on_failure(self, tmpdir):\n        invalid_ca_file = tmpdir.join(\"invalid.pem\")\n        invalid_ca_file.write(\"This is not a certificate\")\n\n        store = X509Store()\n        with pytest.raises(Error):\n            store.load_locations(cafile=str(invalid_ca_file))\n\n\ndef _runopenssl(pem, *args):\n    \"\"\"\n    Run the command line openssl tool with the given arguments and write\n    the given PEM to its stdin.  Not safe for quotes.\n    \"\"\"\n    proc = Popen([b\"openssl\", *list(args)], stdin=PIPE, stdout=PIPE)\n    proc.stdin.write(pem)\n    proc.stdin.close()\n    output = proc.stdout.read()\n    proc.stdout.close()\n    proc.wait()\n    return output\n\n\nclass TestLoadPublicKey:\n    \"\"\"\n    Tests for :func:`load_publickey`.\n    \"\"\"\n\n    def test_loading_works(self):\n        \"\"\"\n        load_publickey loads public keys and sets correct attributes.\n        \"\"\"\n        key = load_publickey(FILETYPE_PEM, cleartextPublicKeyPEM)\n\n        assert True is key._only_public\n        assert 2048 == key.bits()\n        assert TYPE_RSA == key.type()\n\n    def test_invalid_type(self):\n        \"\"\"\n        load_publickey doesn't support FILETYPE_TEXT.\n        \"\"\"\n        with pytest.raises(ValueError):\n            load_publickey(FILETYPE_TEXT, cleartextPublicKeyPEM)\n\n    def test_invalid_key_format(self):\n        \"\"\"\n        load_publickey explodes on incorrect keys.\n        \"\"\"\n        with pytest.raises(Error):\n            load_publickey(FILETYPE_ASN1, cleartextPublicKeyPEM)\n\n    def test_tolerates_unicode_strings(self):\n        \"\"\"\n        load_publickey works with text strings, not just bytes.\n        \"\"\"\n        serialized = cleartextPublicKeyPEM.decode(\"ascii\")\n        key = load_publickey(FILETYPE_PEM, serialized)\n        dumped_pem = dump_publickey(FILETYPE_PEM, key)\n\n        assert dumped_pem == cleartextPublicKeyPEM\n\n\nclass TestFunction:\n    \"\"\"\n    Tests for free-functions in the `OpenSSL.crypto` module.\n    \"\"\"\n\n    def test_load_privatekey_invalid_format(self):\n        \"\"\"\n        `load_privatekey` raises `ValueError` if passed an unknown filetype.\n        \"\"\"\n        with pytest.raises(ValueError):\n            load_privatekey(100, root_key_pem)\n\n    def test_load_privatekey_invalid_passphrase_type(self):\n        \"\"\"\n        `load_privatekey` raises `TypeError` if passed a passphrase that is\n        neither a `str` nor a callable.\n        \"\"\"\n        with pytest.raises(TypeError):\n            load_privatekey(\n                FILETYPE_PEM, encryptedPrivateKeyPEMPassphrase, object()\n            )\n\n    def test_load_privatekey_wrongPassphrase(self):\n        \"\"\"\n        `load_privatekey` raises `OpenSSL.crypto.Error` when it is passed an\n        encrypted PEM and an incorrect passphrase.\n        \"\"\"\n        with pytest.raises(Error) as err:\n            load_privatekey(FILETYPE_PEM, encryptedPrivateKeyPEM, b\"quack\")\n        assert err.value.args[0] != []\n\n    def test_load_privatekey_passphraseWrongType(self):\n        \"\"\"\n        `load_privatekey` raises `ValueError` when it is passeda passphrase\n        with a private key encoded in a format, that doesn't support\n        encryption.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        blob = dump_privatekey(FILETYPE_ASN1, key)\n        with pytest.raises(ValueError):\n            load_privatekey(FILETYPE_ASN1, blob, \"secret\")\n\n    def test_load_privatekey_passphrase(self):\n        \"\"\"\n        `load_privatekey` can create a `PKey` object from an encrypted PEM\n        string if given the passphrase.\n        \"\"\"\n        key = load_privatekey(\n            FILETYPE_PEM,\n            encryptedPrivateKeyPEM,\n            encryptedPrivateKeyPEMPassphrase,\n        )\n        assert isinstance(key, PKey)\n\n    def test_load_privatekey_passphrase_exception(self):\n        \"\"\"\n        If the passphrase callback raises an exception, that exception is\n        raised by `load_privatekey`.\n        \"\"\"\n\n        def cb(ignored):\n            raise ArithmeticError\n\n        with pytest.raises(ArithmeticError):\n            load_privatekey(FILETYPE_PEM, encryptedPrivateKeyPEM, cb)\n\n    def test_load_privatekey_wrongPassphraseCallback(self):\n        \"\"\"\n        `load_privatekey` raises `OpenSSL.crypto.Error` when it\n        is passed an encrypted PEM and a passphrase callback which returns an\n        incorrect passphrase.\n        \"\"\"\n        called = []\n\n        def cb(*a):\n            called.append(None)\n            return b\"quack\"\n\n        with pytest.raises(Error) as err:\n            load_privatekey(FILETYPE_PEM, encryptedPrivateKeyPEM, cb)\n        assert called\n        assert err.value.args[0] != []\n\n    def test_load_privatekey_passphraseCallback(self):\n        \"\"\"\n        `load_privatekey` can create a `PKey` object from an encrypted PEM\n        string if given a passphrase callback which returns the correct\n        password.\n        \"\"\"\n        called = []\n\n        def cb(writing):\n            called.append(writing)\n            return encryptedPrivateKeyPEMPassphrase\n\n        key = load_privatekey(FILETYPE_PEM, encryptedPrivateKeyPEM, cb)\n        assert isinstance(key, PKey)\n        assert called == [False]\n\n    def test_load_privatekey_passphrase_wrong_return_type(self):\n        \"\"\"\n        `load_privatekey` raises `ValueError` if the passphrase callback\n        returns something other than a byte string.\n        \"\"\"\n        with pytest.raises(ValueError):\n            load_privatekey(\n                FILETYPE_PEM, encryptedPrivateKeyPEM, lambda *args: 3\n            )\n\n    def test_dump_privatekey_wrong_args(self):\n        \"\"\"\n        `dump_privatekey` raises `TypeError` if called with a `cipher`\n        argument but no `passphrase` argument.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        with pytest.raises(TypeError):\n            dump_privatekey(FILETYPE_PEM, key, cipher=GOOD_CIPHER)\n\n    def test_dump_privatekey_not_rsa_key(self):\n        \"\"\"\n        `dump_privatekey` raises `TypeError` if called with a key that is\n        not RSA.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_DSA, 512)\n        with pytest.raises(TypeError):\n            dump_privatekey(FILETYPE_TEXT, key)\n\n    def test_dump_privatekey_invalid_pkey(self):\n        with pytest.raises(TypeError):\n            dump_privatekey(FILETYPE_TEXT, object())\n\n    def test_dump_privatekey_unknown_cipher(self):\n        \"\"\"\n        `dump_privatekey` raises `ValueError` if called with an unrecognized\n        cipher name.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        with pytest.raises(ValueError):\n            dump_privatekey(FILETYPE_PEM, key, BAD_CIPHER, \"passphrase\")\n\n    def test_dump_privatekey_invalid_passphrase_type(self):\n        \"\"\"\n        `dump_privatekey` raises `TypeError` if called with a passphrase which\n        is neither a `str` nor a callable.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        with pytest.raises(TypeError):\n            dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, object())\n\n    def test_dump_privatekey_invalid_filetype(self):\n        \"\"\"\n        `dump_privatekey` raises `ValueError` if called with an unrecognized\n        filetype.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 2048)\n        with pytest.raises(ValueError):\n            dump_privatekey(100, key)\n\n    def test_load_privatekey_passphrase_callback_length(self):\n        \"\"\"\n        `crypto.load_privatekey` should raise an error when the passphrase\n        provided by the callback is too long, not silently truncate it.\n        \"\"\"\n\n        def cb(ignored):\n            return \"a\" * 1025\n\n        with pytest.raises(ValueError):\n            load_privatekey(FILETYPE_PEM, encryptedPrivateKeyPEM, cb)\n\n    def test_dump_privatekey_passphrase(self):\n        \"\"\"\n        `dump_privatekey` writes an encrypted PEM when given a passphrase.\n        \"\"\"\n        passphrase = b\"foo\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        pem = dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, passphrase)\n        assert isinstance(pem, bytes)\n        loadedKey = load_privatekey(FILETYPE_PEM, pem, passphrase)\n        assert isinstance(loadedKey, PKey)\n        assert loadedKey.type() == key.type()\n        assert loadedKey.bits() == key.bits()\n\n    def test_dump_privatekey_passphrase_wrong_type(self):\n        \"\"\"\n        `dump_privatekey` raises `ValueError` when it is passed a passphrase\n        with a private key encoded in a format, that doesn't support\n        encryption.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        with pytest.raises(ValueError):\n            dump_privatekey(FILETYPE_ASN1, key, GOOD_CIPHER, \"secret\")\n\n    def test_dump_certificate(self):\n        \"\"\"\n        `dump_certificate` writes PEM, DER, and text.\n        \"\"\"\n        pemData = root_cert_pem + root_key_pem\n        cert = load_certificate(FILETYPE_PEM, pemData)\n        dumped_pem = dump_certificate(FILETYPE_PEM, cert)\n        assert dumped_pem == root_cert_pem\n        dumped_der = dump_certificate(FILETYPE_ASN1, cert)\n        good_der = _runopenssl(dumped_pem, b\"x509\", b\"-outform\", b\"DER\")\n        assert dumped_der == good_der\n        cert2 = load_certificate(FILETYPE_ASN1, dumped_der)\n        dumped_pem2 = dump_certificate(FILETYPE_PEM, cert2)\n        assert dumped_pem2 == root_cert_pem\n        dumped_text = dump_certificate(FILETYPE_TEXT, cert)\n        assert len(dumped_text) > 500\n\n    def test_dump_certificate_bad_type(self):\n        \"\"\"\n        `dump_certificate` raises a `ValueError` if it's called with\n        a bad type.\n        \"\"\"\n        cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        with pytest.raises(ValueError):\n            dump_certificate(object(), cert)\n\n    def test_dump_privatekey_pem(self):\n        \"\"\"\n        `dump_privatekey` writes a PEM\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        assert key.check()\n        dumped_pem = dump_privatekey(FILETYPE_PEM, key)\n        assert dumped_pem == normalized_root_key_pem\n\n    def test_dump_privatekey_asn1(self):\n        \"\"\"\n        `dump_privatekey` writes a DER\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n\n        dumped_der = dump_privatekey(FILETYPE_ASN1, key)\n        assert dumped_der == root_key_der\n\n    def test_load_privatekey_asn1(self):\n        \"\"\"\n        `dump_privatekey` writes a DER\n        \"\"\"\n        key = load_privatekey(FILETYPE_ASN1, root_key_der)\n        assert key.bits() == 3072\n        assert key.type() == TYPE_RSA\n\n    def test_dump_privatekey_text(self):\n        \"\"\"\n        `dump_privatekey` writes a text\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        dumped_text = dump_privatekey(FILETYPE_TEXT, key)\n        assert len(dumped_text) > 500\n\n    def test_dump_publickey_pem(self):\n        \"\"\"\n        dump_publickey writes a PEM.\n        \"\"\"\n        key = load_publickey(FILETYPE_PEM, cleartextPublicKeyPEM)\n        dumped_pem = dump_publickey(FILETYPE_PEM, key)\n        assert dumped_pem == cleartextPublicKeyPEM\n\n    def test_dump_publickey_asn1(self):\n        \"\"\"\n        dump_publickey writes a DER.\n        \"\"\"\n        key = load_publickey(FILETYPE_PEM, cleartextPublicKeyPEM)\n        dumped_der = dump_publickey(FILETYPE_ASN1, key)\n        key2 = load_publickey(FILETYPE_ASN1, dumped_der)\n        dumped_pem2 = dump_publickey(FILETYPE_PEM, key2)\n        assert dumped_pem2 == cleartextPublicKeyPEM\n\n    def test_dump_publickey_invalid_type(self):\n        \"\"\"\n        dump_publickey doesn't support FILETYPE_TEXT.\n        \"\"\"\n        key = load_publickey(FILETYPE_PEM, cleartextPublicKeyPEM)\n\n        with pytest.raises(ValueError):\n            dump_publickey(FILETYPE_TEXT, key)\n\n    def test_dump_certificate_request(self):\n        \"\"\"\n        `dump_certificate_request` writes a PEM, DER, and text.\n        \"\"\"\n        req = load_certificate_request(\n            FILETYPE_PEM, cleartextCertificateRequestPEM\n        )\n        dumped_pem = dump_certificate_request(FILETYPE_PEM, req)\n        assert dumped_pem == cleartextCertificateRequestPEM\n        dumped_der = dump_certificate_request(FILETYPE_ASN1, req)\n        good_der = _runopenssl(dumped_pem, b\"req\", b\"-outform\", b\"DER\")\n        assert dumped_der == good_der\n        req2 = load_certificate_request(FILETYPE_ASN1, dumped_der)\n        dumped_pem2 = dump_certificate_request(FILETYPE_PEM, req2)\n        assert dumped_pem2 == cleartextCertificateRequestPEM\n        dumped_text = dump_certificate_request(FILETYPE_TEXT, req)\n        assert len(dumped_text) > 500\n        with pytest.raises(ValueError):\n            dump_certificate_request(100, req)\n\n    def test_dump_privatekey_passphrase_callback(self):\n        \"\"\"\n        `dump_privatekey` writes an encrypted PEM when given a callback\n        which returns the correct passphrase.\n        \"\"\"\n        passphrase = b\"foo\"\n        called = []\n\n        def cb(writing):\n            called.append(writing)\n            return passphrase\n\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        pem = dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, cb)\n        assert isinstance(pem, bytes)\n        assert called == [True]\n        loadedKey = load_privatekey(FILETYPE_PEM, pem, passphrase)\n        assert isinstance(loadedKey, PKey)\n        assert loadedKey.type() == key.type()\n        assert loadedKey.bits() == key.bits()\n\n    def test_dump_privatekey_passphrase_exception(self):\n        \"\"\"\n        `dump_privatekey` should not overwrite the exception raised\n        by the passphrase callback.\n        \"\"\"\n\n        def cb(ignored):\n            raise ArithmeticError\n\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        with pytest.raises(ArithmeticError):\n            dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, cb)\n\n    def test_dump_privatekey_passphraseCallbackLength(self):\n        \"\"\"\n        `crypto.dump_privatekey` should raise an error when the passphrase\n        provided by the callback is too long, not silently truncate it.\n        \"\"\"\n\n        def cb(ignored):\n            return \"a\" * 1025\n\n        key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        with pytest.raises(ValueError):\n            dump_privatekey(FILETYPE_PEM, key, GOOD_CIPHER, cb)\n\n    def test_dump_privatekey_truncated(self):\n        \"\"\"\n        `crypto.dump_privatekey` should not truncate a passphrase that contains\n        a null byte.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)\n        passphrase = b\"foo\\x00bar\"\n        truncated_passphrase = passphrase.split(b\"\\x00\", 1)[0]\n\n        # By dumping with the full passphrase load should raise an error if we\n        # try to load using the truncated passphrase. If dump truncated the\n        # passphrase, then we WILL load the privatekey and the test fails\n        encrypted_key_pem = dump_privatekey(\n            FILETYPE_PEM, key, \"AES-256-CBC\", passphrase\n        )\n        with pytest.raises(Error):\n            load_privatekey(\n                FILETYPE_PEM, encrypted_key_pem, truncated_passphrase\n            )\n\n    def test_load_privatekey_truncated(self):\n        \"\"\"\n        `crypto.load_privatekey` should not truncate a passphrase that contains\n        a null byte.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, cleartextPrivateKeyPEM)\n        passphrase = b\"foo\\x00bar\"\n        truncated_passphrase = passphrase.split(b\"\\x00\", 1)[0]\n\n        # By dumping using the truncated passphrase load should raise an error\n        # if we try to load using the full passphrase. If load truncated the\n        # passphrase, then we WILL load the privatekey and the test fails\n        encrypted_key_pem = dump_privatekey(\n            FILETYPE_PEM, key, \"AES-256-CBC\", truncated_passphrase\n        )\n        with pytest.raises(Error):\n            load_privatekey(FILETYPE_PEM, encrypted_key_pem, passphrase)\n\n\nclass TestLoadCertificate:\n    \"\"\"\n    Tests for `load_certificate_request`.\n    \"\"\"\n\n    def test_bad_file_type(self):\n        \"\"\"\n        If the file type passed to `load_certificate_request` is neither\n        `FILETYPE_PEM` nor `FILETYPE_ASN1` then `ValueError` is raised.\n        \"\"\"\n        with pytest.raises(ValueError):\n            load_certificate_request(object(), b\"\")\n        with pytest.raises(ValueError):\n            load_certificate(object(), b\"\")\n\n    def test_bad_certificate(self):\n        \"\"\"\n        If the bytes passed to `load_certificate` are not a valid certificate,\n        an exception is raised.\n        \"\"\"\n        with pytest.raises(Error):\n            load_certificate(FILETYPE_ASN1, b\"lol\")\n\n\nclass TestRevoked:\n    \"\"\"\n    Tests for `OpenSSL.crypto.Revoked`.\n    \"\"\"\n\n    def test_ignores_unsupported_revoked_cert_extension_get_reason(self):\n        \"\"\"\n        The get_reason method on the Revoked class checks to see if the\n        extension is NID_crl_reason and should skip it otherwise. This test\n        loads a CRL with extensions it should ignore.\n        \"\"\"\n        crl = load_crl(FILETYPE_PEM, crlDataUnsupportedExtension)\n        revoked = crl.get_revoked()\n        reason = revoked[1].get_reason()\n        assert reason == b\"Unspecified\"\n\n    def test_ignores_unsupported_revoked_cert_extension_set_new_reason(self):\n        crl = load_crl(FILETYPE_PEM, crlDataUnsupportedExtension)\n        revoked = crl.get_revoked()\n        revoked[1].set_reason(None)\n        reason = revoked[1].get_reason()\n        assert reason is None\n\n    def test_construction(self):\n        \"\"\"\n        Confirm we can create `OpenSSL.crypto.Revoked`.  Check that it is\n        empty.\n        \"\"\"\n        revoked = Revoked()\n        assert isinstance(revoked, Revoked)\n        assert type(revoked) is Revoked\n        assert revoked.get_serial() == b\"00\"\n        assert revoked.get_rev_date() is None\n        assert revoked.get_reason() is None\n\n    def test_serial(self):\n        \"\"\"\n        Confirm we can set and get serial numbers from\n        `OpenSSL.crypto.Revoked`.  Confirm errors are handled with grace.\n        \"\"\"\n        revoked = Revoked()\n        ret = revoked.set_serial(b\"10b\")\n        assert ret is None\n        ser = revoked.get_serial()\n        assert ser == b\"010B\"\n\n        revoked.set_serial(b\"31ppp\")  # a type error would be nice\n        ser = revoked.get_serial()\n        assert ser == b\"31\"\n\n        with pytest.raises(ValueError):\n            revoked.set_serial(b\"pqrst\")\n        with pytest.raises(TypeError):\n            revoked.set_serial(100)\n\n    def test_date(self):\n        \"\"\"\n        Confirm we can set and get revocation dates from\n        `OpenSSL.crypto.Revoked`.  Confirm errors are handled with grace.\n        \"\"\"\n        revoked = Revoked()\n        date = revoked.get_rev_date()\n        assert date is None\n\n        now = datetime.now().strftime(\"%Y%m%d%H%M%SZ\").encode(\"ascii\")\n        ret = revoked.set_rev_date(now)\n        assert ret is None\n        date = revoked.get_rev_date()\n        assert date == now\n\n    def test_reason(self):\n        \"\"\"\n        Confirm we can set and get revocation reasons from\n        `OpenSSL.crypto.Revoked`.  The \"get\" need to work as \"set\".\n        Likewise, each reason of all_reasons() must work.\n        \"\"\"\n        revoked = Revoked()\n        for r in revoked.all_reasons():\n            for x in range(2):\n                ret = revoked.set_reason(r)\n                assert ret is None\n                reason = revoked.get_reason()\n                assert reason.lower().replace(b\" \", b\"\") == r.lower().replace(\n                    b\" \", b\"\"\n                )\n                r = reason  # again with the resp of get\n\n        revoked.set_reason(None)\n        assert revoked.get_reason() is None\n\n    @pytest.mark.parametrize(\"reason\", [object(), 1.0, \"foo\"])\n    def test_set_reason_wrong_args(self, reason):\n        \"\"\"\n        `Revoked.set_reason` raises `TypeError` if called with an argument\n        which is neither `None` nor a byte string.\n        \"\"\"\n        revoked = Revoked()\n        with pytest.raises(TypeError):\n            revoked.set_reason(reason)\n\n    def test_set_reason_invalid_reason(self):\n        \"\"\"\n        Calling `OpenSSL.crypto.Revoked.set_reason` with an argument which\n        isn't a valid reason results in `ValueError` being raised.\n        \"\"\"\n        revoked = Revoked()\n        with pytest.raises(ValueError):\n            revoked.set_reason(b\"blue\")\n\n\nclass TestCRL:\n    \"\"\"\n    Tests for `OpenSSL.crypto.CRL`.\n    \"\"\"\n\n    cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n    pkey = load_privatekey(FILETYPE_PEM, root_key_pem)\n\n    root_cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n    root_key = load_privatekey(FILETYPE_PEM, root_key_pem)\n    intermediate_cert = load_certificate(FILETYPE_PEM, intermediate_cert_pem)\n    intermediate_key = load_privatekey(FILETYPE_PEM, intermediate_key_pem)\n    intermediate_server_cert = load_certificate(\n        FILETYPE_PEM, intermediate_server_cert_pem\n    )\n    intermediate_server_key = load_privatekey(\n        FILETYPE_PEM, intermediate_server_key_pem\n    )\n\n    def test_construction(self):\n        \"\"\"\n        Confirm we can create `OpenSSL.crypto.CRL`.  Check\n        that it is empty\n        \"\"\"\n        crl = CRL()\n        assert isinstance(crl, CRL)\n        assert crl.get_revoked() is None\n\n    def _get_crl(self):\n        \"\"\"\n        Get a new ``CRL`` with a revocation.\n        \"\"\"\n        crl = CRL()\n        revoked = Revoked()\n        now = datetime.now().strftime(\"%Y%m%d%H%M%SZ\").encode(\"ascii\")\n        revoked.set_rev_date(now)\n        revoked.set_serial(b\"3ab\")\n        revoked.set_reason(b\"sUpErSeDEd\")\n        crl.add_revoked(revoked)\n        return crl\n\n    def test_export_pem(self):\n        \"\"\"\n        If not passed a format, ``CRL.export`` returns a \"PEM\" format string\n        representing a serial number, a revoked reason, and certificate issuer\n        information.\n        \"\"\"\n        # PEM format\n        dumped_crl = self._get_crl().export(\n            self.cert, self.pkey, days=20, digest=b\"sha256\"\n        )\n        crl = x509.load_pem_x509_crl(dumped_crl)\n        revoked = crl.get_revoked_certificate_by_serial_number(0x03AB)\n        assert revoked is not None\n        assert crl.issuer == x509.Name(\n            [\n                x509.NameAttribute(x509.NameOID.COUNTRY_NAME, \"US\"),\n                x509.NameAttribute(x509.NameOID.STATE_OR_PROVINCE_NAME, \"IL\"),\n                x509.NameAttribute(x509.NameOID.LOCALITY_NAME, \"Chicago\"),\n                x509.NameAttribute(x509.NameOID.ORGANIZATION_NAME, \"Testing\"),\n                x509.NameAttribute(\n                    x509.NameOID.COMMON_NAME, \"Testing Root CA\"\n                ),\n            ]\n        )\n\n    def test_export_der(self):\n        \"\"\"\n        If passed ``FILETYPE_ASN1`` for the format, ``CRL.export`` returns a\n        \"DER\" format string representing a serial number, a revoked reason, and\n        certificate issuer information.\n        \"\"\"\n        crl = self._get_crl()\n\n        # DER format\n        dumped_crl = self._get_crl().export(\n            self.cert, self.pkey, FILETYPE_ASN1, digest=b\"sha256\"\n        )\n        crl = x509.load_der_x509_crl(dumped_crl)\n        revoked = crl.get_revoked_certificate_by_serial_number(0x03AB)\n        assert revoked is not None\n        assert crl.issuer == x509.Name(\n            [\n                x509.NameAttribute(x509.NameOID.COUNTRY_NAME, \"US\"),\n                x509.NameAttribute(x509.NameOID.STATE_OR_PROVINCE_NAME, \"IL\"),\n                x509.NameAttribute(x509.NameOID.LOCALITY_NAME, \"Chicago\"),\n                x509.NameAttribute(x509.NameOID.ORGANIZATION_NAME, \"Testing\"),\n                x509.NameAttribute(\n                    x509.NameOID.COMMON_NAME, \"Testing Root CA\"\n                ),\n            ]\n        )\n\n    def test_export_text(self):\n        \"\"\"\n        If passed ``FILETYPE_TEXT`` for the format, ``CRL.export`` returns a\n        text format string like the one produced by the openssl command line\n        tool.\n        \"\"\"\n        crl = self._get_crl()\n\n        # text format\n        dumped_text = crl.export(\n            self.cert, self.pkey, type=FILETYPE_TEXT, digest=b\"sha256\"\n        )\n        assert len(dumped_text) > 500\n\n    def test_export_custom_digest(self):\n        \"\"\"\n        If passed the name of a digest function, ``CRL.export`` uses a\n        signature algorithm based on that digest function.\n        \"\"\"\n        crl = self._get_crl()\n        dumped_crl = crl.export(self.cert, self.pkey, digest=b\"sha384\")\n        text = _runopenssl(dumped_crl, b\"crl\", b\"-noout\", b\"-text\")\n        text.index(b\"Signature Algorithm: sha384\")\n\n    def test_export_md5_digest(self):\n        \"\"\"\n        If passed md5 as the digest function, ``CRL.export`` uses md5 and does\n        not emit a deprecation warning.\n        \"\"\"\n        crl = self._get_crl()\n        with warnings.catch_warnings(record=True) as catcher:\n            warnings.simplefilter(\"always\")\n        assert 0 == len(catcher)\n        dumped_crl = crl.export(self.cert, self.pkey, digest=b\"md5\")\n        text = _runopenssl(dumped_crl, b\"crl\", b\"-noout\", b\"-text\")\n        text.index(b\"Signature Algorithm: md5\")\n\n    def test_export_default_digest(self):\n        \"\"\"\n        If not passed the name of a digest function, ``CRL.export`` raises a\n        ``TypeError``.\n        \"\"\"\n        crl = self._get_crl()\n        with pytest.raises(TypeError):\n            crl.export(self.cert, self.pkey)\n\n    def test_export_invalid(self):\n        \"\"\"\n        If `CRL.export` is used with an uninitialized `X509` instance,\n        `OpenSSL.crypto.Error` is raised.\n        \"\"\"\n        crl = CRL()\n        with pytest.raises(Error):\n            crl.export(X509(), PKey(), digest=b\"sha256\")\n\n    def test_add_revoked_keyword(self):\n        \"\"\"\n        `OpenSSL.CRL.add_revoked` accepts its single argument as the\n        ``revoked`` keyword argument.\n        \"\"\"\n        crl = CRL()\n        revoked = Revoked()\n        revoked.set_serial(b\"01\")\n        revoked.set_rev_date(b\"20160310020145Z\")\n        crl.add_revoked(revoked=revoked)\n        assert isinstance(crl.get_revoked()[0], Revoked)\n\n    def test_export_wrong_args(self):\n        \"\"\"\n        Calling `OpenSSL.CRL.export` with arguments other than the certificate,\n        private key, integer file type, and integer number of days it\n        expects, results in a `TypeError` being raised.\n        \"\"\"\n        crl = CRL()\n        with pytest.raises(TypeError):\n            crl.export(None, self.pkey, FILETYPE_PEM, 10)\n        with pytest.raises(TypeError):\n            crl.export(self.cert, None, FILETYPE_PEM, 10)\n        with pytest.raises(TypeError):\n            crl.export(self.cert, self.pkey, None, 10)\n        with pytest.raises(TypeError):\n            crl.export(self.cert, FILETYPE_PEM, None)\n\n    def test_export_unknown_filetype(self):\n        \"\"\"\n        Calling `OpenSSL.CRL.export` with a file type other than\n        `FILETYPE_PEM`, `FILETYPE_ASN1`, or\n        `FILETYPE_TEXT` results in a `ValueError` being raised.\n        \"\"\"\n        crl = CRL()\n        with pytest.raises(ValueError):\n            crl.export(self.cert, self.pkey, 100, 10, digest=b\"sha256\")\n\n    def test_export_unknown_digest(self):\n        \"\"\"\n        Calling `OpenSSL.CRL.export` with an unsupported digest results\n        in a `ValueError` being raised.\n        \"\"\"\n        crl = CRL()\n        with pytest.raises(ValueError):\n            crl.export(\n                self.cert, self.pkey, FILETYPE_PEM, 10, b\"strange-digest\"\n            )\n\n    def test_get_revoked(self):\n        \"\"\"\n        Use python to create a simple CRL with two revocations. Get back the\n        `Revoked` using `OpenSSL.CRL.get_revoked` and verify them.\n        \"\"\"\n        crl = CRL()\n\n        revoked = Revoked()\n        now = datetime.now().strftime(\"%Y%m%d%H%M%SZ\").encode(\"ascii\")\n        revoked.set_rev_date(now)\n        revoked.set_serial(b\"3ab\")\n        crl.add_revoked(revoked)\n        revoked.set_serial(b\"100\")\n        revoked.set_reason(b\"sUpErSeDEd\")\n        crl.add_revoked(revoked)\n\n        revs = crl.get_revoked()\n        assert len(revs) == 2\n        assert type(revs[0]) is Revoked\n        assert type(revs[1]) is Revoked\n        assert revs[0].get_serial() == b\"03AB\"\n        assert revs[1].get_serial() == b\"0100\"\n        assert revs[0].get_rev_date() == now\n        assert revs[1].get_rev_date() == now\n\n    def test_load_crl(self):\n        \"\"\"\n        Load a known CRL and inspect its revocations.  Both EM and DER formats\n        are loaded.\n        \"\"\"\n        crl = load_crl(FILETYPE_PEM, crlData)\n        revs = crl.get_revoked()\n        assert len(revs) == 2\n        assert revs[0].get_serial() == b\"03AB\"\n        assert revs[0].get_reason() is None\n        assert revs[1].get_serial() == b\"0100\"\n        assert revs[1].get_reason() == b\"Superseded\"\n\n        der = _runopenssl(crlData, b\"crl\", b\"-outform\", b\"DER\")\n        crl = load_crl(FILETYPE_ASN1, der)\n        revs = crl.get_revoked()\n        assert len(revs) == 2\n        assert revs[0].get_serial() == b\"03AB\"\n        assert revs[0].get_reason() is None\n        assert revs[1].get_serial() == b\"0100\"\n        assert revs[1].get_reason() == b\"Superseded\"\n\n    def test_load_crl_bad_filetype(self):\n        \"\"\"\n        Calling `OpenSSL.crypto.load_crl` with an unknown file type raises a\n        `ValueError`.\n        \"\"\"\n        with pytest.raises(ValueError):\n            load_crl(100, crlData)\n\n    def test_load_crl_bad_data(self):\n        \"\"\"\n        Calling `OpenSSL.crypto.load_crl` with file data which can't be loaded\n        raises a `OpenSSL.crypto.Error`.\n        \"\"\"\n        with pytest.raises(Error):\n            load_crl(FILETYPE_PEM, b\"hello, world\")\n\n    def test_get_issuer(self):\n        \"\"\"\n        Load a known CRL and assert its issuer's common name is what we expect\n        from the encoded crlData string.\n        \"\"\"\n        crl = load_crl(FILETYPE_PEM, crlData)\n        assert isinstance(crl.get_issuer(), X509Name)\n        assert crl.get_issuer().CN == \"Testing Root CA\"\n\n    def test_dump_crl(self):\n        \"\"\"\n        The dumped CRL matches the original input.\n        \"\"\"\n        crl = load_crl(FILETYPE_PEM, crlData)\n        buf = dump_crl(FILETYPE_PEM, crl)\n        assert buf == crlData\n\n    @staticmethod\n    def _make_test_crl(issuer_cert, issuer_key, certs=()):\n        \"\"\"\n        Create a CRL.\n\n        :param list[X509] certs: A list of certificates to revoke.\n        :rtype: CRL\n        \"\"\"\n        crl = CRL()\n        for cert in certs:\n            revoked = Revoked()\n            # FIXME: This string splicing is an unfortunate implementation\n            # detail that has been reported in\n            # https://github.com/pyca/pyopenssl/issues/258\n            serial = hex(cert.get_serial_number())[2:].encode(\"utf-8\")\n            revoked.set_serial(serial)\n            revoked.set_reason(b\"unspecified\")\n            revoked.set_rev_date(b\"20140601000000Z\")\n            crl.add_revoked(revoked)\n        crl.set_version(1)\n        crl.set_lastUpdate(b\"20140601000000Z\")\n        # The year 5000 is far into the future so that this CRL isn't\n        # considered to have expired.\n        crl.set_nextUpdate(b\"50000601000000Z\")\n        crl.sign(issuer_cert, issuer_key, digest=b\"sha512\")\n        return crl\n\n    @staticmethod\n    def _make_test_crl_cryptography(issuer_cert, issuer_key, certs=()):\n        \"\"\"\n        Create a CRL using cryptography's API.\n\n        :param list[X509] certs: A list of certificates to revoke.\n        :rtype: ``cryptography.x509.CertificateRevocationList``\n        \"\"\"\n        from cryptography.x509.extensions import CRLReason, ReasonFlags\n\n        builder = x509.CertificateRevocationListBuilder()\n        builder = builder.issuer_name(\n            X509.to_cryptography(issuer_cert).subject\n        )\n        for cert in certs:\n            revoked = (\n                x509.RevokedCertificateBuilder()\n                .serial_number(cert.get_serial_number())\n                .revocation_date(datetime(2014, 6, 1, 0, 0, 0))\n                .add_extension(CRLReason(ReasonFlags.unspecified), False)\n                .build()\n            )\n            builder = builder.add_revoked_certificate(revoked)\n\n        builder = builder.last_update(datetime(2014, 6, 1, 0, 0, 0))\n        # The year 5000 is far into the future so that this CRL isn't\n        # considered to have expired.\n        builder = builder.next_update(datetime(5000, 6, 1, 0, 0, 0))\n\n        crl = builder.sign(\n            private_key=PKey.to_cryptography_key(issuer_key),\n            algorithm=hashes.SHA512(),\n        )\n        return crl\n\n    @pytest.mark.parametrize(\n        \"create_crl\",\n        [\n            pytest.param(\n                _make_test_crl.__func__,\n                id=\"pyOpenSSL CRL\",\n            ),\n            pytest.param(\n                _make_test_crl_cryptography.__func__,\n                id=\"cryptography CRL\",\n            ),\n        ],\n    )\n    def test_verify_with_revoked(self, create_crl):\n        \"\"\"\n        `verify_certificate` raises error when an intermediate certificate is\n        revoked.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n        root_crl = create_crl(\n            self.root_cert, self.root_key, certs=[self.intermediate_cert]\n        )\n        intermediate_crl = create_crl(\n            self.intermediate_cert, self.intermediate_key, certs=[]\n        )\n        store.add_crl(root_crl)\n        store.add_crl(intermediate_crl)\n        store.set_flags(\n            X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL\n        )\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        with pytest.raises(X509StoreContextError) as err:\n            store_ctx.verify_certificate()\n        assert str(err.value) == \"certificate revoked\"\n\n    @pytest.mark.parametrize(\n        \"create_crl\",\n        [\n            pytest.param(\n                _make_test_crl.__func__,\n                id=\"pyOpenSSL CRL\",\n            ),\n            pytest.param(\n                _make_test_crl_cryptography.__func__,\n                id=\"cryptography CRL\",\n            ),\n        ],\n    )\n    def test_verify_with_missing_crl(self, create_crl):\n        \"\"\"\n        `verify_certificate` raises error when an intermediate certificate's\n        CRL is missing.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n        root_crl = create_crl(\n            self.root_cert, self.root_key, certs=[self.intermediate_cert]\n        )\n        store.add_crl(root_crl)\n        store.set_flags(\n            X509StoreFlags.CRL_CHECK | X509StoreFlags.CRL_CHECK_ALL\n        )\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        with pytest.raises(X509StoreContextError) as err:\n            store_ctx.verify_certificate()\n        assert str(err.value) == \"unable to get certificate CRL\"\n        assert err.value.certificate.get_subject().CN == \"intermediate-service\"\n\n    def test_convert_from_cryptography(self):\n        crypto_crl = x509.load_pem_x509_crl(crlData)\n        crl = CRL.from_cryptography(crypto_crl)\n        assert isinstance(crl, CRL)\n\n    def test_convert_from_cryptography_unsupported_type(self):\n        with pytest.raises(TypeError):\n            CRL.from_cryptography(object())\n\n    def test_convert_to_cryptography_key(self):\n        crl = load_crl(FILETYPE_PEM, crlData)\n        crypto_crl = crl.to_cryptography()\n        assert isinstance(crypto_crl, x509.CertificateRevocationList)\n\n\nclass TestX509StoreContext:\n    \"\"\"\n    Tests for `OpenSSL.crypto.X509StoreContext`.\n    \"\"\"\n\n    root_cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n    intermediate_cert = load_certificate(FILETYPE_PEM, intermediate_cert_pem)\n    intermediate_server_cert = load_certificate(\n        FILETYPE_PEM, intermediate_server_cert_pem\n    )\n\n    def test_valid(self):\n        \"\"\"\n        `verify_certificate` returns ``None`` when called with a certificate\n        and valid chain.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        assert store_ctx.verify_certificate() is None\n\n    def test_reuse(self):\n        \"\"\"\n        `verify_certificate` can be called multiple times with the same\n        ``X509StoreContext`` instance to produce the same result.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        assert store_ctx.verify_certificate() is None\n        assert store_ctx.verify_certificate() is None\n\n    @pytest.mark.parametrize(\n        \"root_cert, chain, verified_cert\",\n        [\n            pytest.param(\n                root_cert,\n                [intermediate_cert],\n                intermediate_server_cert,\n                id=\"intermediate in chain\",\n            ),\n            pytest.param(\n                root_cert,\n                [],\n                intermediate_cert,\n                id=\"empty chain\",\n            ),\n            pytest.param(\n                root_cert,\n                [root_cert, intermediate_server_cert, intermediate_cert],\n                intermediate_server_cert,\n                id=\"extra certs in chain\",\n            ),\n        ],\n    )\n    def test_verify_success_with_chain(self, root_cert, chain, verified_cert):\n        store = X509Store()\n        store.add_cert(root_cert)\n        store_ctx = X509StoreContext(store, verified_cert, chain=chain)\n        assert store_ctx.verify_certificate() is None\n\n    def test_valid_untrusted_chain_reuse(self):\n        \"\"\"\n        `verify_certificate` using an untrusted chain can be called multiple\n        times with the same ``X509StoreContext`` instance to produce the same\n        result.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        chain = [self.intermediate_cert]\n\n        store_ctx = X509StoreContext(\n            store, self.intermediate_server_cert, chain=chain\n        )\n        assert store_ctx.verify_certificate() is None\n        assert store_ctx.verify_certificate() is None\n\n    def test_chain_reference(self):\n        \"\"\"\n        ``X509StoreContext`` properly keeps references to the untrusted chain\n        certificates.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        chain = [load_certificate(FILETYPE_PEM, intermediate_cert_pem)]\n\n        store_ctx = X509StoreContext(\n            store, self.intermediate_server_cert, chain=chain\n        )\n\n        del chain\n        assert store_ctx.verify_certificate() is None\n\n    @pytest.mark.parametrize(\n        \"root_cert, chain, verified_cert\",\n        [\n            pytest.param(\n                root_cert,\n                [],\n                intermediate_server_cert,\n                id=\"intermediate missing\",\n            ),\n            pytest.param(\n                None,\n                [intermediate_cert],\n                intermediate_server_cert,\n                id=\"no trusted root\",\n            ),\n            pytest.param(\n                None,\n                [root_cert, intermediate_cert],\n                intermediate_server_cert,\n                id=\"untrusted root, full chain is available\",\n            ),\n            pytest.param(\n                intermediate_cert,\n                [root_cert, intermediate_cert],\n                intermediate_server_cert,\n                id=\"untrusted root, intermediate is trusted and in chain\",\n            ),\n        ],\n    )\n    def test_verify_fail_with_chain(self, root_cert, chain, verified_cert):\n        store = X509Store()\n        if root_cert:\n            store.add_cert(root_cert)\n\n        store_ctx = X509StoreContext(store, verified_cert, chain=chain)\n\n        with pytest.raises(X509StoreContextError):\n            store_ctx.verify_certificate()\n\n    @pytest.mark.parametrize(\n        \"chain, expected_error\",\n        [\n            pytest.param(\n                [intermediate_cert, \"This is not a certificate\"],\n                TypeError,\n                id=\"non-certificate in chain\",\n            ),\n            pytest.param(\n                42,\n                TypeError,\n                id=\"non-list chain\",\n            ),\n        ],\n    )\n    def test_untrusted_chain_wrong_args(self, chain, expected_error):\n        \"\"\"\n        Creating ``X509StoreContext`` with wrong chain raises an exception.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n\n        with pytest.raises(expected_error):\n            X509StoreContext(store, self.intermediate_server_cert, chain=chain)\n\n    def test_failure_building_untrusted_chain_raises(self, monkeypatch):\n        \"\"\"\n        Creating ``X509StoreContext`` raises ``OpenSSL.crypto.Error`` when\n        the underlying lib fails to add the certificate to the stack.\n        \"\"\"\n        monkeypatch.setattr(_lib, \"sk_X509_push\", lambda _stack, _x509: -1)\n\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        chain = [self.intermediate_cert]\n\n        with pytest.raises(Error):\n            X509StoreContext(store, self.intermediate_server_cert, chain=chain)\n\n    def test_trusted_self_signed(self):\n        \"\"\"\n        `verify_certificate` returns ``None`` when called with a self-signed\n        certificate and itself in the chain.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store_ctx = X509StoreContext(store, self.root_cert)\n        assert store_ctx.verify_certificate() is None\n\n    def test_untrusted_self_signed(self):\n        \"\"\"\n        `verify_certificate` raises error when a self-signed certificate is\n        verified without itself in the chain.\n        \"\"\"\n        store = X509Store()\n        store_ctx = X509StoreContext(store, self.root_cert)\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        # OpenSSL 1.1.x and 3.0.x have different error messages\n        assert str(exc.value) in [\n            \"self signed certificate\",\n            \"self-signed certificate\",\n        ]\n        assert exc.value.certificate.get_subject().CN == \"Testing Root CA\"\n\n    def test_invalid_chain_no_root(self):\n        \"\"\"\n        `verify_certificate` raises error when a root certificate is missing\n        from the chain.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        assert str(exc.value) == \"unable to get issuer certificate\"\n        assert exc.value.certificate.get_subject().CN == \"intermediate\"\n\n    def test_invalid_chain_no_intermediate(self):\n        \"\"\"\n        `verify_certificate` raises error when an intermediate certificate is\n        missing from the chain.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        assert str(exc.value) == \"unable to get local issuer certificate\"\n        assert exc.value.certificate.get_subject().CN == \"intermediate-service\"\n\n    def test_modification_pre_verify(self):\n        \"\"\"\n        `verify_certificate` can use a store context modified after\n        instantiation.\n        \"\"\"\n        store_bad = X509Store()\n        store_bad.add_cert(self.intermediate_cert)\n        store_good = X509Store()\n        store_good.add_cert(self.root_cert)\n        store_good.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store_bad, self.intermediate_server_cert)\n\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        assert str(exc.value) == \"unable to get issuer certificate\"\n        assert exc.value.certificate.get_subject().CN == \"intermediate\"\n\n        store_ctx.set_store(store_good)\n        assert store_ctx.verify_certificate() is None\n\n    def test_verify_with_time(self):\n        \"\"\"\n        `verify_certificate` raises error when the verification time is\n        set at notAfter.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n\n        expire_time = self.intermediate_server_cert.get_notAfter()\n        expire_datetime = datetime.strptime(\n            expire_time.decode(\"utf-8\"), \"%Y%m%d%H%M%SZ\"\n        )\n        store.set_time(expire_datetime)\n\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        assert str(exc.value) == \"certificate has expired\"\n\n    def test_get_verified_chain(self):\n        \"\"\"\n        `get_verified_chain` returns the verified chain.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.root_cert)\n        store.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        chain = store_ctx.get_verified_chain()\n        assert len(chain) == 3\n        intermediate_subject = self.intermediate_server_cert.get_subject()\n        assert chain[0].get_subject() == intermediate_subject\n        assert chain[1].get_subject() == self.intermediate_cert.get_subject()\n        assert chain[2].get_subject() == self.root_cert.get_subject()\n        # Test reuse\n        chain = store_ctx.get_verified_chain()\n        assert len(chain) == 3\n        assert chain[0].get_subject() == intermediate_subject\n        assert chain[1].get_subject() == self.intermediate_cert.get_subject()\n        assert chain[2].get_subject() == self.root_cert.get_subject()\n\n    def test_get_verified_chain_invalid_chain_no_root(self):\n        \"\"\"\n        `get_verified_chain` raises error when cert verification fails.\n        \"\"\"\n        store = X509Store()\n        store.add_cert(self.intermediate_cert)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.get_verified_chain()\n\n        assert str(exc.value) == \"unable to get issuer certificate\"\n        assert exc.value.certificate.get_subject().CN == \"intermediate\"\n\n    @pytest.fixture\n    def root_ca_file(self, tmpdir):\n        return self._create_ca_file(tmpdir, \"root_ca_hash_dir\", self.root_cert)\n\n    @pytest.fixture\n    def intermediate_ca_file(self, tmpdir):\n        return self._create_ca_file(\n            tmpdir, \"intermediate_ca_hash_dir\", self.intermediate_cert\n        )\n\n    @staticmethod\n    def _create_ca_file(base_path, hash_directory, cacert):\n        ca_hash = f\"{cacert.subject_name_hash():08x}.0\"\n        cafile = base_path.join(hash_directory, ca_hash)\n        cafile.write_binary(\n            dump_certificate(FILETYPE_PEM, cacert), ensure=True\n        )\n        return cafile\n\n    def test_verify_with_ca_file_location(self, root_ca_file):\n        store = X509Store()\n        store.load_locations(str(root_ca_file))\n\n        store_ctx = X509StoreContext(store, self.intermediate_cert)\n        store_ctx.verify_certificate()\n\n    def test_verify_with_ca_path_location(self, root_ca_file):\n        store = X509Store()\n        store.load_locations(None, str(root_ca_file.dirname))\n\n        store_ctx = X509StoreContext(store, self.intermediate_cert)\n        store_ctx.verify_certificate()\n\n    def test_verify_with_cafile_and_capath(\n        self, root_ca_file, intermediate_ca_file\n    ):\n        store = X509Store()\n        store.load_locations(\n            cafile=str(root_ca_file), capath=str(intermediate_ca_file.dirname)\n        )\n\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        store_ctx.verify_certificate()\n\n    def test_verify_with_multiple_ca_files(\n        self, root_ca_file, intermediate_ca_file\n    ):\n        store = X509Store()\n        store.load_locations(str(root_ca_file))\n        store.load_locations(str(intermediate_ca_file))\n\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        store_ctx.verify_certificate()\n\n    def test_verify_failure_with_empty_ca_directory(self, tmpdir):\n        store = X509Store()\n        store.load_locations(None, str(tmpdir))\n\n        store_ctx = X509StoreContext(store, self.intermediate_cert)\n        with pytest.raises(X509StoreContextError) as exc:\n            store_ctx.verify_certificate()\n\n        assert str(exc.value) == \"unable to get local issuer certificate\"\n\n    def test_verify_with_partial_chain(self):\n        store = X509Store()\n        store.add_cert(self.intermediate_cert)\n\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        with pytest.raises(X509StoreContextError):\n            store_ctx.verify_certificate()\n\n        # Now set the partial verification flag for verification.\n        store.set_flags(X509StoreFlags.PARTIAL_CHAIN)\n        store_ctx = X509StoreContext(store, self.intermediate_server_cert)\n        assert store_ctx.verify_certificate() is None\n\n\nclass TestSignVerify:\n    \"\"\"\n    Tests for `OpenSSL.crypto.sign` and `OpenSSL.crypto.verify`.\n    \"\"\"\n\n    def test_sign_verify(self):\n        \"\"\"\n        `sign` generates a cryptographic signature which `verify` can check.\n        \"\"\"\n        content = (\n            b\"It was a bright cold day in April, and the clocks were striking \"\n            b\"thirteen. Winston Smith, his chin nuzzled into his breast in an \"\n            b\"effort to escape the vile wind, slipped quickly through the \"\n            b\"glass doors of Victory Mansions, though not quickly enough to \"\n            b\"prevent a swirl of gritty dust from entering along with him.\"\n        )\n\n        # sign the content with this private key\n        priv_key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        # verify the content with this cert\n        good_cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        # certificate unrelated to priv_key, used to trigger an error\n        bad_cert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        for digest in [\"md5\", \"sha1\", \"sha256\"]:\n            sig = sign(priv_key, content, digest)\n\n            # Verify the signature of content, will throw an exception if\n            # error.\n            verify(good_cert, sig, content, digest)\n\n            # This should fail because the certificate doesn't match the\n            # private key that was used to sign the content.\n            with pytest.raises(Error):\n                verify(bad_cert, sig, content, digest)\n\n            # This should fail because we've \"tainted\" the content after\n            # signing it.\n            with pytest.raises(Error):\n                verify(good_cert, sig, content + b\"tainted\", digest)\n\n        # test that unknown digest types fail\n        with pytest.raises(ValueError):\n            sign(priv_key, content, \"strange-digest\")\n        with pytest.raises(ValueError):\n            verify(good_cert, sig, content, \"strange-digest\")\n\n    def test_sign_verify_with_text(self):\n        \"\"\"\n        `sign` generates a cryptographic signature which\n        `verify` can check. Deprecation warnings raised because using\n        text instead of bytes as content\n        \"\"\"\n        content = (\n            b\"It was a bright cold day in April, and the clocks were striking \"\n            b\"thirteen. Winston Smith, his chin nuzzled into his breast in an \"\n            b\"effort to escape the vile wind, slipped quickly through the \"\n            b\"glass doors of Victory Mansions, though not quickly enough to \"\n            b\"prevent a swirl of gritty dust from entering along with him.\"\n        ).decode(\"ascii\")\n\n        priv_key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        for digest in [\"md5\", \"sha1\", \"sha256\"]:\n            with pytest.warns(DeprecationWarning) as w:\n                warnings.simplefilter(\"always\")\n                sig = sign(priv_key, content, digest)\n            assert (\n                f\"{WARNING_TYPE_EXPECTED} for data is no longer accepted, \"\n                f\"use bytes\"\n            ) == str(w[-1].message)\n\n            with pytest.warns(DeprecationWarning) as w:\n                warnings.simplefilter(\"always\")\n                verify(cert, sig, content, digest)\n            assert (\n                f\"{WARNING_TYPE_EXPECTED} for data is no longer accepted, \"\n                f\"use bytes\"\n            ) == str(w[-1].message)\n\n    def test_sign_verify_ecdsa(self):\n        \"\"\"\n        `sign` generates a cryptographic signature which `verify` can check.\n        ECDSA Signatures in the X9.62 format may have variable length,\n        different from the length of the private key.\n        \"\"\"\n        content = (\n            b\"It was a bright cold day in April, and the clocks were striking \"\n            b\"thirteen. Winston Smith, his chin nuzzled into his breast in an \"\n            b\"effort to escape the vile wind, slipped quickly through the \"\n            b\"glass doors of Victory Mansions, though not quickly enough to \"\n            b\"prevent a swirl of gritty dust from entering along with him.\"\n        )\n        priv_key = load_privatekey(FILETYPE_PEM, ec_root_key_pem)\n        cert = load_certificate(FILETYPE_PEM, ec_root_cert_pem)\n        sig = sign(priv_key, content, \"sha256\")\n        verify(cert, sig, content, \"sha256\")\n\n    def test_sign_nulls(self):\n        \"\"\"\n        `sign` produces a signature for a string with embedded nulls.\n        \"\"\"\n        content = b\"Watch out!  \\0  Did you see it?\"\n        priv_key = load_privatekey(FILETYPE_PEM, root_key_pem)\n        good_cert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        sig = sign(priv_key, content, \"sha256\")\n        verify(good_cert, sig, content, \"sha256\")\n\n    def test_sign_with_large_key(self):\n        \"\"\"\n        `sign` produces a signature for a string when using a long key.\n        \"\"\"\n        content = (\n            b\"It was a bright cold day in April, and the clocks were striking \"\n            b\"thirteen. Winston Smith, his chin nuzzled into his breast in an \"\n            b\"effort to escape the vile wind, slipped quickly through the \"\n            b\"glass doors of Victory Mansions, though not quickly enough to \"\n            b\"prevent a swirl of gritty dust from entering along with him.\"\n        )\n\n        priv_key = load_privatekey(FILETYPE_PEM, large_key_pem)\n        sign(priv_key, content, \"sha256\")\n\n\nclass TestEllipticCurve:\n    \"\"\"\n    Tests for `_EllipticCurve`, `get_elliptic_curve`, and\n    `get_elliptic_curves`.\n    \"\"\"\n\n    def test_set(self):\n        \"\"\"\n        `get_elliptic_curves` returns a `set`.\n        \"\"\"\n        assert isinstance(get_elliptic_curves(), set)\n\n    def test_a_curve(self):\n        \"\"\"\n        `get_elliptic_curve` can be used to retrieve a particular supported\n        curve.\n        \"\"\"\n        curves = get_elliptic_curves()\n        curve = next(iter(curves))\n        assert curve.name == get_elliptic_curve(curve.name).name\n\n    def test_not_a_curve(self):\n        \"\"\"\n        `get_elliptic_curve` raises `ValueError` if called with a name which\n        does not identify a supported curve.\n        \"\"\"\n        with pytest.raises(ValueError):\n            get_elliptic_curve(\"this curve was just invented\")\n\n    def test_repr(self):\n        \"\"\"\n        The string representation of a curve object includes simply states the\n        object is a curve and what its name is.\n        \"\"\"\n        curves = get_elliptic_curves()\n        curve = next(iter(curves))\n        assert f\"<Curve {curve.name!r}>\" == repr(curve)\n\n    def test_to_EC_KEY(self):\n        \"\"\"\n        The curve object can export a version of itself as an EC_KEY* via the\n        private `_EllipticCurve._to_EC_KEY`.\n        \"\"\"\n        curves = get_elliptic_curves()\n        curve = next(iter(curves))\n        # It's not easy to assert anything about this object.  However, see\n        # leakcheck/crypto.py for a test that demonstrates it at least does\n        # not leak memory.\n        curve._to_EC_KEY()\n\n\nclass EllipticCurveFactory:\n    \"\"\"\n    A helper to get the names of two curves.\n    \"\"\"\n\n    def __init__(self):\n        curves = iter(get_elliptic_curves())\n        self.curve_name = next(curves).name\n        self.another_curve_name = next(curves).name\n\n\nclass TestEllipticCurveEquality(EqualityTestsMixin):\n    \"\"\"\n    Tests `_EllipticCurve`'s implementation of ``==`` and ``!=``.\n    \"\"\"\n\n    curve_factory = EllipticCurveFactory()\n\n    if curve_factory.curve_name is None:\n        skip = \"There are no curves available there can be no curve objects.\"\n\n    def anInstance(self):\n        \"\"\"\n        Get the curve object for an arbitrary curve supported by the system.\n        \"\"\"\n        return get_elliptic_curve(self.curve_factory.curve_name)\n\n    def anotherInstance(self):\n        \"\"\"\n        Get the curve object for an arbitrary curve supported by the system -\n        but not the one returned by C{anInstance}.\n        \"\"\"\n        return get_elliptic_curve(self.curve_factory.another_curve_name)\n\n\nclass TestEllipticCurveHash:\n    \"\"\"\n    Tests for `_EllipticCurve`'s implementation of hashing (thus use as\n    an item in a `dict` or `set`).\n    \"\"\"\n\n    curve_factory = EllipticCurveFactory()\n\n    if curve_factory.curve_name is None:\n        skip = \"There are no curves available there can be no curve objects.\"\n\n    def test_contains(self):\n        \"\"\"\n        The ``in`` operator reports that a `set` containing a curve does\n        contain that curve.\n        \"\"\"\n        curve = get_elliptic_curve(self.curve_factory.curve_name)\n        curves = set([curve])\n        assert curve in curves\n\n    def test_does_not_contain(self):\n        \"\"\"\n        The ``in`` operator reports that a `set` not containing a curve\n        does not contain that curve.\n        \"\"\"\n        curve = get_elliptic_curve(self.curve_factory.curve_name)\n        curves = set(\n            [get_elliptic_curve(self.curve_factory.another_curve_name)]\n        )\n        assert curve not in curves\n", "tests/conftest.py": "# Copyright (c) The pyOpenSSL developers\n# See LICENSE for details.\n\nfrom tempfile import mktemp\n\nimport pytest\n\n\ndef pytest_report_header(config):\n    import cryptography\n\n    import OpenSSL.SSL\n\n    return (\n        f\"OpenSSL: {OpenSSL.SSL.SSLeay_version(OpenSSL.SSL.SSLEAY_VERSION)}\\n\"\n        f\"cryptography: {cryptography.__version__}\"\n    )\n\n\n@pytest.fixture\ndef tmpfile(tmpdir):\n    \"\"\"\n    Return UTF-8-encoded bytes of a path to a tmp file.\n\n    The file will be cleaned up after the test run.\n    \"\"\"\n    return mktemp(dir=tmpdir.dirname).encode(\"utf-8\")\n", "tests/test_ssl.py": "# Copyright (C) Jean-Paul Calderone\n# See LICENSE for details.\n\n\"\"\"\nUnit tests for :mod:`OpenSSL.SSL`.\n\"\"\"\n\nimport datetime\nimport gc\nimport select\nimport sys\nimport time\nimport uuid\nfrom errno import (\n    EAFNOSUPPORT,\n    ECONNREFUSED,\n    EINPROGRESS,\n    EPIPE,\n    ESHUTDOWN,\n    EWOULDBLOCK,\n)\nfrom gc import collect, get_referrers\nfrom os import makedirs\nfrom os.path import join\nfrom socket import (\n    AF_INET,\n    AF_INET6,\n    MSG_PEEK,\n    SHUT_RDWR,\n    gaierror,\n    socket,\n)\nfrom sys import getfilesystemencoding, platform\nfrom typing import Union\nfrom weakref import ref\n\nimport pytest\nfrom cryptography import x509\nfrom cryptography.hazmat.primitives import hashes, serialization\nfrom cryptography.hazmat.primitives.asymmetric import rsa\nfrom cryptography.x509.oid import NameOID\nfrom pretend import raiser\n\nfrom OpenSSL import SSL\nfrom OpenSSL._util import ffi as _ffi\nfrom OpenSSL._util import lib as _lib\nfrom OpenSSL.crypto import (\n    FILETYPE_PEM,\n    TYPE_RSA,\n    X509,\n    PKey,\n    X509Store,\n    dump_certificate,\n    dump_privatekey,\n    get_elliptic_curves,\n    load_certificate,\n    load_privatekey,\n)\n\nwith pytest.warns(DeprecationWarning):\n    from OpenSSL.crypto import X509Extension\n\nfrom OpenSSL.SSL import (\n    DTLS_METHOD,\n    MODE_RELEASE_BUFFERS,\n    NO_OVERLAPPING_PROTOCOLS,\n    OP_COOKIE_EXCHANGE,\n    OP_NO_COMPRESSION,\n    OP_NO_QUERY_MTU,\n    OP_NO_TICKET,\n    OP_SINGLE_DH_USE,\n    OPENSSL_VERSION_NUMBER,\n    RECEIVED_SHUTDOWN,\n    SENT_SHUTDOWN,\n    SESS_CACHE_BOTH,\n    SESS_CACHE_CLIENT,\n    SESS_CACHE_NO_AUTO_CLEAR,\n    SESS_CACHE_NO_INTERNAL,\n    SESS_CACHE_NO_INTERNAL_LOOKUP,\n    SESS_CACHE_NO_INTERNAL_STORE,\n    SESS_CACHE_OFF,\n    SESS_CACHE_SERVER,\n    SSL_CB_ACCEPT_EXIT,\n    SSL_CB_ACCEPT_LOOP,\n    SSL_CB_ALERT,\n    SSL_CB_CONNECT_EXIT,\n    SSL_CB_CONNECT_LOOP,\n    SSL_CB_EXIT,\n    SSL_CB_HANDSHAKE_DONE,\n    SSL_CB_HANDSHAKE_START,\n    SSL_CB_LOOP,\n    SSL_CB_READ,\n    SSL_CB_READ_ALERT,\n    SSL_CB_WRITE,\n    SSL_CB_WRITE_ALERT,\n    SSL_ST_ACCEPT,\n    SSL_ST_CONNECT,\n    SSL_ST_MASK,\n    SSLEAY_BUILT_ON,\n    SSLEAY_CFLAGS,\n    SSLEAY_DIR,\n    SSLEAY_PLATFORM,\n    SSLEAY_VERSION,\n    TLS1_1_VERSION,\n    TLS1_2_VERSION,\n    TLS1_3_VERSION,\n    TLS_METHOD,\n    VERIFY_CLIENT_ONCE,\n    VERIFY_FAIL_IF_NO_PEER_CERT,\n    VERIFY_NONE,\n    VERIFY_PEER,\n    Connection,\n    Context,\n    Error,\n    OP_NO_SSLv2,\n    OP_NO_SSLv3,\n    Session,\n    SSLeay_version,\n    SSLv23_METHOD,\n    SysCallError,\n    TLSv1_1_METHOD,\n    TLSv1_2_METHOD,\n    TLSv1_METHOD,\n    WantReadError,\n    WantWriteError,\n    ZeroReturnError,\n    _make_requires,\n)\n\ntry:\n    from OpenSSL.SSL import (\n        SSL_ST_BEFORE,\n        SSL_ST_INIT,\n        SSL_ST_OK,\n        SSL_ST_RENEGOTIATE,\n    )\nexcept ImportError:\n    SSL_ST_INIT = SSL_ST_BEFORE = SSL_ST_OK = SSL_ST_RENEGOTIATE = None\n\ntry:\n    from OpenSSL.SSL import OP_NO_TLSv1_3\nexcept ImportError:\n    OP_NO_TLSv1_3 = None\n\nfrom .test_crypto import (\n    client_cert_pem,\n    client_key_pem,\n    root_cert_pem,\n    root_key_pem,\n    server_cert_pem,\n    server_key_pem,\n)\nfrom .util import NON_ASCII, WARNING_TYPE_EXPECTED, is_consistent_type\n\n# openssl dhparam 2048 -out dh-2048.pem\ndhparam = \"\"\"\\\n-----BEGIN DH PARAMETERS-----\nMIIBCAKCAQEA2F5e976d/GjsaCdKv5RMWL/YV7fq1UUWpPAer5fDXflLMVUuYXxE\n3m3ayZob9lbpgEU0jlPAsXHfQPGxpKmvhv+xV26V/DEoukED8JeZUY/z4pigoptl\n+8+TYdNNE/rFSZQFXIp+v2D91IEgmHBnZlKFSbKR+p8i0KjExXGjU6ji3S5jkOku\nogikc7df1Ui0hWNJCmTjExq07aXghk97PsdFSxjdawuG3+vos5bnNoUwPLYlFc/z\nITYG0KXySiCLi4UDlXTZTz7u/+OYczPEgqa/JPUddbM/kfvaRAnjY38cfQ7qXf8Y\ni5s5yYK7a/0eWxxRr2qraYaUj8RwDpH9CwIBAg==\n-----END DH PARAMETERS-----\n\"\"\"\n\n\ndef socket_any_family():\n    try:\n        return socket(AF_INET)\n    except OSError as e:\n        if e.errno == EAFNOSUPPORT:\n            return socket(AF_INET6)\n        raise\n\n\ndef loopback_address(socket):\n    if socket.family == AF_INET:\n        return \"127.0.0.1\"\n    else:\n        assert socket.family == AF_INET6\n        return \"::1\"\n\n\ndef join_bytes_or_unicode(prefix, suffix):\n    \"\"\"\n    Join two path components of either ``bytes`` or ``unicode``.\n\n    The return type is the same as the type of ``prefix``.\n    \"\"\"\n    # If the types are the same, nothing special is necessary.\n    if type(prefix) is type(suffix):\n        return join(prefix, suffix)\n\n    # Otherwise, coerce suffix to the type of prefix.\n    if isinstance(prefix, str):\n        return join(prefix, suffix.decode(getfilesystemencoding()))\n    else:\n        return join(prefix, suffix.encode(getfilesystemencoding()))\n\n\ndef verify_cb(conn, cert, errnum, depth, ok):\n    return ok\n\n\ndef socket_pair():\n    \"\"\"\n    Establish and return a pair of network sockets connected to each other.\n    \"\"\"\n    # Connect a pair of sockets\n    port = socket_any_family()\n    port.bind((\"\", 0))\n    port.listen(1)\n    client = socket(port.family)\n    client.setblocking(False)\n    client.connect_ex((loopback_address(port), port.getsockname()[1]))\n    client.setblocking(True)\n    server = port.accept()[0]\n\n    port.close()\n\n    # Let's pass some unencrypted data to make sure our socket connection is\n    # fine.  Just one byte, so we don't have to worry about buffers getting\n    # filled up or fragmentation.\n    server.send(b\"x\")\n    assert client.recv(1024) == b\"x\"\n    client.send(b\"y\")\n    assert server.recv(1024) == b\"y\"\n\n    # Most of our callers want non-blocking sockets, make it easy for them.\n    server.setblocking(False)\n    client.setblocking(False)\n\n    return (server, client)\n\n\ndef handshake(client, server):\n    conns = [client, server]\n    while conns:\n        for conn in conns:\n            try:\n                conn.do_handshake()\n            except WantReadError:\n                pass\n            else:\n                conns.remove(conn)\n\n\ndef _create_certificate_chain():\n    \"\"\"\n    Construct and return a chain of certificates.\n\n        1. A new self-signed certificate authority certificate (cacert)\n        2. A new intermediate certificate signed by cacert (icert)\n        3. A new server certificate signed by icert (scert)\n    \"\"\"\n    caext = X509Extension(b\"basicConstraints\", False, b\"CA:true\")\n    not_after_date = datetime.date.today() + datetime.timedelta(days=365)\n    not_after = not_after_date.strftime(\"%Y%m%d%H%M%SZ\").encode(\"ascii\")\n\n    # Step 1\n    cakey = PKey()\n    cakey.generate_key(TYPE_RSA, 2048)\n    cacert = X509()\n    cacert.set_version(2)\n    cacert.get_subject().commonName = \"Authority Certificate\"\n    cacert.set_issuer(cacert.get_subject())\n    cacert.set_pubkey(cakey)\n    cacert.set_notBefore(b\"20000101000000Z\")\n    cacert.set_notAfter(not_after)\n    cacert.add_extensions([caext])\n    cacert.set_serial_number(0)\n    cacert.sign(cakey, \"sha256\")\n\n    # Step 2\n    ikey = PKey()\n    ikey.generate_key(TYPE_RSA, 2048)\n    icert = X509()\n    icert.set_version(2)\n    icert.get_subject().commonName = \"Intermediate Certificate\"\n    icert.set_issuer(cacert.get_subject())\n    icert.set_pubkey(ikey)\n    icert.set_notBefore(b\"20000101000000Z\")\n    icert.set_notAfter(not_after)\n    icert.add_extensions([caext])\n    icert.set_serial_number(0)\n    icert.sign(cakey, \"sha256\")\n\n    # Step 3\n    skey = PKey()\n    skey.generate_key(TYPE_RSA, 2048)\n    scert = X509()\n    scert.set_version(2)\n    scert.get_subject().commonName = \"Server Certificate\"\n    scert.set_issuer(icert.get_subject())\n    scert.set_pubkey(skey)\n    scert.set_notBefore(b\"20000101000000Z\")\n    scert.set_notAfter(not_after)\n    scert.add_extensions(\n        [X509Extension(b\"basicConstraints\", True, b\"CA:false\")]\n    )\n    scert.set_serial_number(0)\n    scert.sign(ikey, \"sha256\")\n\n    return [(cakey, cacert), (ikey, icert), (skey, scert)]\n\n\ndef loopback_client_factory(socket, version=SSLv23_METHOD):\n    client = Connection(Context(version), socket)\n    client.set_connect_state()\n    return client\n\n\ndef loopback_server_factory(socket, version=SSLv23_METHOD):\n    ctx = Context(version)\n    ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n    ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n    server = Connection(ctx, socket)\n    server.set_accept_state()\n    return server\n\n\ndef loopback(server_factory=None, client_factory=None):\n    \"\"\"\n    Create a connected socket pair and force two connected SSL sockets\n    to talk to each other via memory BIOs.\n    \"\"\"\n    if server_factory is None:\n        server_factory = loopback_server_factory\n    if client_factory is None:\n        client_factory = loopback_client_factory\n\n    (server, client) = socket_pair()\n    server = server_factory(server)\n    client = client_factory(client)\n\n    handshake(client, server)\n\n    server.setblocking(True)\n    client.setblocking(True)\n    return server, client\n\n\ndef interact_in_memory(client_conn, server_conn):\n    \"\"\"\n    Try to read application bytes from each of the two `Connection` objects.\n    Copy bytes back and forth between their send/receive buffers for as long\n    as there is anything to copy.  When there is nothing more to copy,\n    return `None`.  If one of them actually manages to deliver some application\n    bytes, return a two-tuple of the connection from which the bytes were read\n    and the bytes themselves.\n    \"\"\"\n    wrote = True\n    while wrote:\n        # Loop until neither side has anything to say\n        wrote = False\n\n        # Copy stuff from each side's send buffer to the other side's\n        # receive buffer.\n        for read, write in [\n            (client_conn, server_conn),\n            (server_conn, client_conn),\n        ]:\n            # Give the side a chance to generate some more bytes, or succeed.\n            try:\n                data = read.recv(2**16)\n            except WantReadError:\n                # It didn't succeed, so we'll hope it generated some output.\n                pass\n            else:\n                # It did succeed, so we'll stop now and let the caller deal\n                # with it.\n                return (read, data)\n\n            while True:\n                # Keep copying as long as there's more stuff there.\n                try:\n                    dirty = read.bio_read(4096)\n                except WantReadError:\n                    # Okay, nothing more waiting to be sent.  Stop\n                    # processing this send buffer.\n                    break\n                else:\n                    # Keep track of the fact that someone generated some\n                    # output.\n                    wrote = True\n                    write.bio_write(dirty)\n\n\ndef handshake_in_memory(client_conn, server_conn):\n    \"\"\"\n    Perform the TLS handshake between two `Connection` instances connected to\n    each other via memory BIOs.\n    \"\"\"\n    client_conn.set_connect_state()\n    server_conn.set_accept_state()\n\n    for conn in [client_conn, server_conn]:\n        try:\n            conn.do_handshake()\n        except WantReadError:\n            pass\n\n    interact_in_memory(client_conn, server_conn)\n\n\nclass TestVersion:\n    \"\"\"\n    Tests for version information exposed by `OpenSSL.SSL.SSLeay_version` and\n    `OpenSSL.SSL.OPENSSL_VERSION_NUMBER`.\n    \"\"\"\n\n    def test_OPENSSL_VERSION_NUMBER(self):\n        \"\"\"\n        `OPENSSL_VERSION_NUMBER` is an integer with status in the low byte and\n        the patch, fix, minor, and major versions in the nibbles above that.\n        \"\"\"\n        assert isinstance(OPENSSL_VERSION_NUMBER, int)\n\n    def test_SSLeay_version(self):\n        \"\"\"\n        `SSLeay_version` takes a version type indicator and returns one of a\n        number of version strings based on that indicator.\n        \"\"\"\n        versions = {}\n        for t in [\n            SSLEAY_VERSION,\n            SSLEAY_CFLAGS,\n            SSLEAY_BUILT_ON,\n            SSLEAY_PLATFORM,\n            SSLEAY_DIR,\n        ]:\n            version = SSLeay_version(t)\n            versions[version] = t\n            assert isinstance(version, bytes)\n        assert len(versions) == 5\n\n\n@pytest.fixture\ndef ca_file(tmpdir):\n    \"\"\"\n    Create a valid PEM file with CA certificates and return the path.\n    \"\"\"\n    key = rsa.generate_private_key(public_exponent=65537, key_size=2048)\n    public_key = key.public_key()\n\n    builder = x509.CertificateBuilder()\n    builder = builder.subject_name(\n        x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"pyopenssl.org\")])\n    )\n    builder = builder.issuer_name(\n        x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, \"pyopenssl.org\")])\n    )\n    one_day = datetime.timedelta(1, 0, 0)\n    builder = builder.not_valid_before(datetime.datetime.today() - one_day)\n    builder = builder.not_valid_after(datetime.datetime.today() + one_day)\n    builder = builder.serial_number(int(uuid.uuid4()))\n    builder = builder.public_key(public_key)\n    builder = builder.add_extension(\n        x509.BasicConstraints(ca=True, path_length=None),\n        critical=True,\n    )\n\n    certificate = builder.sign(private_key=key, algorithm=hashes.SHA256())\n\n    ca_file = tmpdir.join(\"test.pem\")\n    ca_file.write_binary(\n        certificate.public_bytes(\n            encoding=serialization.Encoding.PEM,\n        )\n    )\n\n    return str(ca_file).encode(\"ascii\")\n\n\n@pytest.fixture\ndef context():\n    \"\"\"\n    A simple \"best TLS you can get\" context. TLS 1.2+ in any reasonable OpenSSL\n    \"\"\"\n    return Context(SSLv23_METHOD)\n\n\nclass TestContext:\n    \"\"\"\n    Unit tests for `OpenSSL.SSL.Context`.\n    \"\"\"\n\n    @pytest.mark.parametrize(\n        \"cipher_string\",\n        [b\"hello world:AES128-SHA\", \"hello world:AES128-SHA\"],\n    )\n    def test_set_cipher_list(self, context, cipher_string):\n        \"\"\"\n        `Context.set_cipher_list` accepts both byte and unicode strings\n        for naming the ciphers which connections created with the context\n        object will be able to choose from.\n        \"\"\"\n        context.set_cipher_list(cipher_string)\n        conn = Connection(context, None)\n\n        assert \"AES128-SHA\" in conn.get_cipher_list()\n\n    def test_set_cipher_list_wrong_type(self, context):\n        \"\"\"\n        `Context.set_cipher_list` raises `TypeError` when passed a non-string\n        argument.\n        \"\"\"\n        with pytest.raises(TypeError):\n            context.set_cipher_list(object())\n\n    @pytest.mark.flaky(reruns=2)\n    def test_set_cipher_list_no_cipher_match(self, context):\n        \"\"\"\n        `Context.set_cipher_list` raises `OpenSSL.SSL.Error` with a\n        `\"no cipher match\"` reason string regardless of the TLS\n        version.\n        \"\"\"\n        with pytest.raises(Error) as excinfo:\n            context.set_cipher_list(b\"imaginary-cipher\")\n        assert excinfo.value.args[0][0] in [\n            # 1.1.x\n            (\n                \"SSL routines\",\n                \"SSL_CTX_set_cipher_list\",\n                \"no cipher match\",\n            ),\n            # 3.0.x\n            (\n                \"SSL routines\",\n                \"\",\n                \"no cipher match\",\n            ),\n        ]\n\n    def test_load_client_ca(self, context, ca_file):\n        \"\"\"\n        `Context.load_client_ca` works as far as we can tell.\n        \"\"\"\n        context.load_client_ca(ca_file)\n\n    def test_load_client_ca_invalid(self, context, tmpdir):\n        \"\"\"\n        `Context.load_client_ca` raises an Error if the ca file is invalid.\n        \"\"\"\n        ca_file = tmpdir.join(\"test.pem\")\n        ca_file.write(\"\")\n\n        with pytest.raises(Error) as e:\n            context.load_client_ca(str(ca_file).encode(\"ascii\"))\n\n        assert \"PEM routines\" == e.value.args[0][0][0]\n\n    def test_load_client_ca_unicode(self, context, ca_file):\n        \"\"\"\n        Passing the path as unicode raises a warning but works.\n        \"\"\"\n        pytest.deprecated_call(context.load_client_ca, ca_file.decode(\"ascii\"))\n\n    def test_set_session_id(self, context):\n        \"\"\"\n        `Context.set_session_id` works as far as we can tell.\n        \"\"\"\n        context.set_session_id(b\"abc\")\n\n    def test_set_session_id_fail(self, context):\n        \"\"\"\n        `Context.set_session_id` errors are propagated.\n        \"\"\"\n        with pytest.raises(Error) as e:\n            context.set_session_id(b\"abc\" * 1000)\n\n        assert e.value.args[0][0] in [\n            # 1.1.x\n            (\n                \"SSL routines\",\n                \"SSL_CTX_set_session_id_context\",\n                \"ssl session id context too long\",\n            ),\n            # 3.0.x\n            (\n                \"SSL routines\",\n                \"\",\n                \"ssl session id context too long\",\n            ),\n        ]\n\n    def test_set_session_id_unicode(self, context):\n        \"\"\"\n        `Context.set_session_id` raises a warning if a unicode string is\n        passed.\n        \"\"\"\n        pytest.deprecated_call(context.set_session_id, \"abc\")\n\n    def test_method(self):\n        \"\"\"\n        `Context` can be instantiated with one of `SSLv2_METHOD`,\n        `SSLv3_METHOD`, `SSLv23_METHOD`, `TLSv1_METHOD`, `TLSv1_1_METHOD`,\n        or `TLSv1_2_METHOD`.\n        \"\"\"\n        methods = [SSLv23_METHOD, TLSv1_METHOD]\n        for meth in methods:\n            Context(meth)\n\n        maybe = [TLSv1_1_METHOD, TLSv1_2_METHOD]\n        for meth in maybe:\n            try:\n                Context(meth)\n            except (Error, ValueError):\n                # Some versions of OpenSSL have SSLv2 / TLSv1.1 / TLSv1.2, some\n                # don't.  Difficult to say in advance.\n                pass\n\n        with pytest.raises(TypeError):\n            Context(\"\")\n        with pytest.raises(ValueError):\n            Context(13)\n\n    def test_type(self):\n        \"\"\"\n        `Context` can be used to create instances of that type.\n        \"\"\"\n        assert is_consistent_type(Context, \"Context\", TLSv1_METHOD)\n\n    def test_use_privatekey_file_missing(self, tmpfile):\n        \"\"\"\n        `Context.use_privatekey_file` raises `OpenSSL.SSL.Error` when passed\n        the name of a file which does not exist.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            ctx.use_privatekey_file(tmpfile)\n\n    def _use_privatekey_file_test(self, pemfile, filetype):\n        \"\"\"\n        Verify that calling ``Context.use_privatekey_file`` with the given\n        arguments does not raise an exception.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 1024)\n\n        with open(pemfile, \"w\") as pem:\n            pem.write(dump_privatekey(FILETYPE_PEM, key).decode(\"ascii\"))\n\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_privatekey_file(pemfile, filetype)\n\n    @pytest.mark.parametrize(\"filetype\", [object(), \"\", None, 1.0])\n    def test_wrong_privatekey_file_wrong_args(self, tmpfile, filetype):\n        \"\"\"\n        `Context.use_privatekey_file` raises `TypeError` when called with\n        a `filetype` which is not a valid file encoding.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            ctx.use_privatekey_file(tmpfile, filetype)\n\n    def test_use_privatekey_file_bytes(self, tmpfile):\n        \"\"\"\n        A private key can be specified from a file by passing a ``bytes``\n        instance giving the file name to ``Context.use_privatekey_file``.\n        \"\"\"\n        self._use_privatekey_file_test(\n            tmpfile + NON_ASCII.encode(getfilesystemencoding()),\n            FILETYPE_PEM,\n        )\n\n    def test_use_privatekey_file_unicode(self, tmpfile):\n        \"\"\"\n        A private key can be specified from a file by passing a ``unicode``\n        instance giving the file name to ``Context.use_privatekey_file``.\n        \"\"\"\n        self._use_privatekey_file_test(\n            tmpfile.decode(getfilesystemencoding()) + NON_ASCII,\n            FILETYPE_PEM,\n        )\n\n    def test_use_certificate_file_wrong_args(self):\n        \"\"\"\n        `Context.use_certificate_file` raises `TypeError` if the first\n        argument is not a byte string or the second argument is not an integer.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            ctx.use_certificate_file(object(), FILETYPE_PEM)\n        with pytest.raises(TypeError):\n            ctx.use_certificate_file(b\"somefile\", object())\n        with pytest.raises(TypeError):\n            ctx.use_certificate_file(object(), FILETYPE_PEM)\n\n    def test_use_certificate_file_missing(self, tmpfile):\n        \"\"\"\n        `Context.use_certificate_file` raises `OpenSSL.SSL.Error` if passed\n        the name of a file which does not exist.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            ctx.use_certificate_file(tmpfile)\n\n    def _use_certificate_file_test(self, certificate_file):\n        \"\"\"\n        Verify that calling ``Context.use_certificate_file`` with the given\n        filename doesn't raise an exception.\n        \"\"\"\n        # TODO\n        # Hard to assert anything.  But we could set a privatekey then ask\n        # OpenSSL if the cert and key agree using check_privatekey.  Then as\n        # long as check_privatekey works right we're good...\n        with open(certificate_file, \"wb\") as pem_file:\n            pem_file.write(root_cert_pem)\n\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_certificate_file(certificate_file)\n\n    def test_use_certificate_file_bytes(self, tmpfile):\n        \"\"\"\n        `Context.use_certificate_file` sets the certificate (given as a\n        `bytes` filename) which will be used to identify connections created\n        using the context.\n        \"\"\"\n        filename = tmpfile + NON_ASCII.encode(getfilesystemencoding())\n        self._use_certificate_file_test(filename)\n\n    def test_use_certificate_file_unicode(self, tmpfile):\n        \"\"\"\n        `Context.use_certificate_file` sets the certificate (given as a\n        `bytes` filename) which will be used to identify connections created\n        using the context.\n        \"\"\"\n        filename = tmpfile.decode(getfilesystemencoding()) + NON_ASCII\n        self._use_certificate_file_test(filename)\n\n    def test_check_privatekey_valid(self):\n        \"\"\"\n        `Context.check_privatekey` returns `None` if the `Context` instance\n        has been configured to use a matched key and certificate pair.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, client_key_pem)\n        cert = load_certificate(FILETYPE_PEM, client_cert_pem)\n        context = Context(SSLv23_METHOD)\n        context.use_privatekey(key)\n        context.use_certificate(cert)\n        assert None is context.check_privatekey()\n\n    def test_check_privatekey_invalid(self):\n        \"\"\"\n        `Context.check_privatekey` raises `Error` if the `Context` instance\n        has been configured to use a key and certificate pair which don't\n        relate to each other.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, client_key_pem)\n        cert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        context = Context(SSLv23_METHOD)\n        context.use_privatekey(key)\n        context.use_certificate(cert)\n        with pytest.raises(Error):\n            context.check_privatekey()\n\n    def test_app_data(self):\n        \"\"\"\n        `Context.set_app_data` stores an object for later retrieval\n        using `Context.get_app_data`.\n        \"\"\"\n        app_data = object()\n        context = Context(SSLv23_METHOD)\n        context.set_app_data(app_data)\n        assert context.get_app_data() is app_data\n\n    def test_set_options_wrong_args(self):\n        \"\"\"\n        `Context.set_options` raises `TypeError` if called with\n        a non-`int` argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_options(None)\n\n    def test_set_options(self):\n        \"\"\"\n        `Context.set_options` returns the new options value.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        options = context.set_options(OP_NO_SSLv2)\n        assert options & OP_NO_SSLv2 == OP_NO_SSLv2\n\n    def test_set_mode_wrong_args(self):\n        \"\"\"\n        `Context.set_mode` raises `TypeError` if called with\n        a non-`int` argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_mode(None)\n\n    def test_set_mode(self):\n        \"\"\"\n        `Context.set_mode` accepts a mode bitvector and returns the\n        newly set mode.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        assert MODE_RELEASE_BUFFERS & context.set_mode(MODE_RELEASE_BUFFERS)\n\n    def test_set_timeout_wrong_args(self):\n        \"\"\"\n        `Context.set_timeout` raises `TypeError` if called with\n        a non-`int` argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_timeout(None)\n\n    def test_timeout(self):\n        \"\"\"\n        `Context.set_timeout` sets the session timeout for all connections\n        created using the context object. `Context.get_timeout` retrieves\n        this value.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        context.set_timeout(1234)\n        assert context.get_timeout() == 1234\n\n    def test_set_verify_depth_wrong_args(self):\n        \"\"\"\n        `Context.set_verify_depth` raises `TypeError` if called with a\n        non-`int` argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_verify_depth(None)\n\n    def test_verify_depth(self):\n        \"\"\"\n        `Context.set_verify_depth` sets the number of certificates in\n        a chain to follow before giving up.  The value can be retrieved with\n        `Context.get_verify_depth`.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        context.set_verify_depth(11)\n        assert context.get_verify_depth() == 11\n\n    def _write_encrypted_pem(self, passphrase, tmpfile):\n        \"\"\"\n        Write a new private key out to a new file, encrypted using the given\n        passphrase.  Return the path to the new file.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 1024)\n        pem = dump_privatekey(FILETYPE_PEM, key, \"blowfish\", passphrase)\n        with open(tmpfile, \"w\") as fObj:\n            fObj.write(pem.decode(\"ascii\"))\n        return tmpfile\n\n    def test_set_passwd_cb_wrong_args(self):\n        \"\"\"\n        `Context.set_passwd_cb` raises `TypeError` if called with a\n        non-callable first argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_passwd_cb(None)\n\n    def test_set_passwd_cb(self, tmpfile):\n        \"\"\"\n        `Context.set_passwd_cb` accepts a callable which will be invoked when\n        a private key is loaded from an encrypted PEM.\n        \"\"\"\n        passphrase = b\"foobar\"\n        pemFile = self._write_encrypted_pem(passphrase, tmpfile)\n        calledWith = []\n\n        def passphraseCallback(maxlen, verify, extra):\n            calledWith.append((maxlen, verify, extra))\n            return passphrase\n\n        context = Context(SSLv23_METHOD)\n        context.set_passwd_cb(passphraseCallback)\n        context.use_privatekey_file(pemFile)\n        assert len(calledWith) == 1\n        assert isinstance(calledWith[0][0], int)\n        assert isinstance(calledWith[0][1], int)\n        assert calledWith[0][2] is None\n\n    def test_passwd_callback_exception(self, tmpfile):\n        \"\"\"\n        `Context.use_privatekey_file` propagates any exception raised\n        by the passphrase callback.\n        \"\"\"\n        pemFile = self._write_encrypted_pem(b\"monkeys are nice\", tmpfile)\n\n        def passphraseCallback(maxlen, verify, extra):\n            raise RuntimeError(\"Sorry, I am a fail.\")\n\n        context = Context(SSLv23_METHOD)\n        context.set_passwd_cb(passphraseCallback)\n        with pytest.raises(RuntimeError):\n            context.use_privatekey_file(pemFile)\n\n    def test_passwd_callback_false(self, tmpfile):\n        \"\"\"\n        `Context.use_privatekey_file` raises `OpenSSL.SSL.Error` if the\n        passphrase callback returns a false value.\n        \"\"\"\n        pemFile = self._write_encrypted_pem(b\"monkeys are nice\", tmpfile)\n\n        def passphraseCallback(maxlen, verify, extra):\n            return b\"\"\n\n        context = Context(SSLv23_METHOD)\n        context.set_passwd_cb(passphraseCallback)\n        with pytest.raises(Error):\n            context.use_privatekey_file(pemFile)\n\n    def test_passwd_callback_non_string(self, tmpfile):\n        \"\"\"\n        `Context.use_privatekey_file` raises `OpenSSL.SSL.Error` if the\n        passphrase callback returns a true non-string value.\n        \"\"\"\n        pemFile = self._write_encrypted_pem(b\"monkeys are nice\", tmpfile)\n\n        def passphraseCallback(maxlen, verify, extra):\n            return 10\n\n        context = Context(SSLv23_METHOD)\n        context.set_passwd_cb(passphraseCallback)\n        # TODO: Surely this is the wrong error?\n        with pytest.raises(ValueError):\n            context.use_privatekey_file(pemFile)\n\n    def test_passwd_callback_too_long(self, tmpfile):\n        \"\"\"\n        If the passphrase returned by the passphrase callback returns a string\n        longer than the indicated maximum length, it is truncated.\n        \"\"\"\n        # A priori knowledge!\n        passphrase = b\"x\" * 1024\n        pemFile = self._write_encrypted_pem(passphrase, tmpfile)\n\n        def passphraseCallback(maxlen, verify, extra):\n            assert maxlen == 1024\n            return passphrase + b\"y\"\n\n        context = Context(SSLv23_METHOD)\n        context.set_passwd_cb(passphraseCallback)\n        # This shall succeed because the truncated result is the correct\n        # passphrase.\n        context.use_privatekey_file(pemFile)\n\n    def test_set_info_callback(self):\n        \"\"\"\n        `Context.set_info_callback` accepts a callable which will be\n        invoked when certain information about an SSL connection is available.\n        \"\"\"\n        (server, client) = socket_pair()\n\n        clientSSL = Connection(Context(SSLv23_METHOD), client)\n        clientSSL.set_connect_state()\n\n        called = []\n\n        def info(conn, where, ret):\n            called.append((conn, where, ret))\n\n        context = Context(SSLv23_METHOD)\n        context.set_info_callback(info)\n        context.use_certificate(load_certificate(FILETYPE_PEM, root_cert_pem))\n        context.use_privatekey(load_privatekey(FILETYPE_PEM, root_key_pem))\n\n        serverSSL = Connection(context, server)\n        serverSSL.set_accept_state()\n\n        handshake(clientSSL, serverSSL)\n\n        # The callback must always be called with a Connection instance as the\n        # first argument.  It would probably be better to split this into\n        # separate tests for client and server side info callbacks so we could\n        # assert it is called with the right Connection instance.  It would\n        # also be good to assert *something* about `where` and `ret`.\n        notConnections = [\n            conn\n            for (conn, where, ret) in called\n            if not isinstance(conn, Connection)\n        ]\n        assert (\n            [] == notConnections\n        ), \"Some info callback arguments were not Connection instances.\"\n\n    @pytest.mark.skipif(\n        not getattr(_lib, \"Cryptography_HAS_KEYLOG\", None),\n        reason=\"SSL_CTX_set_keylog_callback unavailable\",\n    )\n    def test_set_keylog_callback(self):\n        \"\"\"\n        `Context.set_keylog_callback` accepts a callable which will be\n        invoked when key material is generated or received.\n        \"\"\"\n        called = []\n\n        def keylog(conn, line):\n            called.append((conn, line))\n\n        server_context = Context(TLSv1_2_METHOD)\n        server_context.set_keylog_callback(keylog)\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n\n        client_context = Context(SSLv23_METHOD)\n\n        self._handshake_test(server_context, client_context)\n\n        assert called\n        assert all(isinstance(conn, Connection) for conn, line in called)\n        assert all(b\"CLIENT_RANDOM\" in line for conn, line in called)\n\n    def test_set_proto_version(self):\n        if OP_NO_TLSv1_3 is None:\n            high_version = TLS1_2_VERSION\n            low_version = TLS1_1_VERSION\n        else:\n            high_version = TLS1_3_VERSION\n            low_version = TLS1_2_VERSION\n\n        server_context = Context(TLS_METHOD)\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        server_context.set_min_proto_version(high_version)\n\n        client_context = Context(TLS_METHOD)\n        client_context.set_max_proto_version(low_version)\n\n        with pytest.raises(Error, match=\"unsupported protocol\"):\n            self._handshake_test(server_context, client_context)\n\n        client_context.set_max_proto_version(0)\n        self._handshake_test(server_context, client_context)\n\n    def _load_verify_locations_test(self, *args):\n        \"\"\"\n        Create a client context which will verify the peer certificate and call\n        its `load_verify_locations` method with the given arguments.\n        Then connect it to a server and ensure that the handshake succeeds.\n        \"\"\"\n        (server, client) = socket_pair()\n\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.load_verify_locations(*args)\n        # Require that the server certificate verify properly or the\n        # connection will fail.\n        clientContext.set_verify(\n            VERIFY_PEER,\n            lambda conn, cert, errno, depth, preverify_ok: preverify_ok,\n        )\n\n        clientSSL = Connection(clientContext, client)\n        clientSSL.set_connect_state()\n\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n\n        serverSSL = Connection(serverContext, server)\n        serverSSL.set_accept_state()\n\n        # Without load_verify_locations above, the handshake\n        # will fail:\n        # Error: [('SSL routines', 'SSL3_GET_SERVER_CERTIFICATE',\n        #          'certificate verify failed')]\n        handshake(clientSSL, serverSSL)\n\n        cert = clientSSL.get_peer_certificate()\n        assert cert.get_subject().CN == \"Testing Root CA\"\n\n    def _load_verify_cafile(self, cafile):\n        \"\"\"\n        Verify that if path to a file containing a certificate is passed to\n        `Context.load_verify_locations` for the ``cafile`` parameter, that\n        certificate is used as a trust root for the purposes of verifying\n        connections created using that `Context`.\n        \"\"\"\n        with open(cafile, \"w\") as fObj:\n            fObj.write(root_cert_pem.decode(\"ascii\"))\n\n        self._load_verify_locations_test(cafile)\n\n    def test_load_verify_bytes_cafile(self, tmpfile):\n        \"\"\"\n        `Context.load_verify_locations` accepts a file name as a `bytes`\n        instance and uses the certificates within for verification purposes.\n        \"\"\"\n        cafile = tmpfile + NON_ASCII.encode(getfilesystemencoding())\n        self._load_verify_cafile(cafile)\n\n    def test_load_verify_unicode_cafile(self, tmpfile):\n        \"\"\"\n        `Context.load_verify_locations` accepts a file name as a `unicode`\n        instance and uses the certificates within for verification purposes.\n        \"\"\"\n        self._load_verify_cafile(\n            tmpfile.decode(getfilesystemencoding()) + NON_ASCII\n        )\n\n    def test_load_verify_invalid_file(self, tmpfile):\n        \"\"\"\n        `Context.load_verify_locations` raises `Error` when passed a\n        non-existent cafile.\n        \"\"\"\n        clientContext = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            clientContext.load_verify_locations(tmpfile)\n\n    def _load_verify_directory_locations_capath(self, capath):\n        \"\"\"\n        Verify that if path to a directory containing certificate files is\n        passed to ``Context.load_verify_locations`` for the ``capath``\n        parameter, those certificates are used as trust roots for the purposes\n        of verifying connections created using that ``Context``.\n        \"\"\"\n        makedirs(capath)\n        # Hash values computed manually with c_rehash to avoid depending on\n        # c_rehash in the test suite.  One is from OpenSSL 0.9.8, the other\n        # from OpenSSL 1.0.0.\n        for name in [b\"c7adac82.0\", b\"c3705638.0\"]:\n            cafile = join_bytes_or_unicode(capath, name)\n            with open(cafile, \"w\") as fObj:\n                fObj.write(root_cert_pem.decode(\"ascii\"))\n\n        self._load_verify_locations_test(None, capath)\n\n    @pytest.mark.parametrize(\n        \"pathtype\",\n        [\n            \"ascii_path\",\n            pytest.param(\n                \"unicode_path\",\n                marks=pytest.mark.skipif(\n                    platform == \"win32\",\n                    reason=\"Unicode paths not supported on Windows\",\n                ),\n            ),\n        ],\n    )\n    @pytest.mark.parametrize(\"argtype\", [\"bytes_arg\", \"unicode_arg\"])\n    def test_load_verify_directory_capath(self, pathtype, argtype, tmpfile):\n        \"\"\"\n        `Context.load_verify_locations` accepts a directory name as a `bytes`\n        instance and uses the certificates within for verification purposes.\n        \"\"\"\n        if pathtype == \"unicode_path\":\n            tmpfile += NON_ASCII.encode(getfilesystemencoding())\n        if argtype == \"unicode_arg\":\n            tmpfile = tmpfile.decode(getfilesystemencoding())\n        self._load_verify_directory_locations_capath(tmpfile)\n\n    def test_load_verify_locations_wrong_args(self):\n        \"\"\"\n        `Context.load_verify_locations` raises `TypeError` if with non-`str`\n        arguments.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.load_verify_locations(object())\n        with pytest.raises(TypeError):\n            context.load_verify_locations(object(), object())\n\n    @pytest.mark.skipif(\n        not platform.startswith(\"linux\"),\n        reason=\"Loading fallback paths is a linux-specific behavior to \"\n        \"accommodate pyca/cryptography manylinux wheels\",\n    )\n    def test_fallback_default_verify_paths(self, monkeypatch):\n        \"\"\"\n        Test that we load certificates successfully on linux from the fallback\n        path. To do this we set the _CRYPTOGRAPHY_MANYLINUX_CA_FILE and\n        _CRYPTOGRAPHY_MANYLINUX_CA_DIR vars to be equal to whatever the\n        current OpenSSL default is and we disable\n        SSL_CTX_SET_default_verify_paths so that it can't find certs unless\n        it loads via fallback.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        monkeypatch.setattr(\n            _lib, \"SSL_CTX_set_default_verify_paths\", lambda x: 1\n        )\n        monkeypatch.setattr(\n            SSL,\n            \"_CRYPTOGRAPHY_MANYLINUX_CA_FILE\",\n            _ffi.string(_lib.X509_get_default_cert_file()),\n        )\n        monkeypatch.setattr(\n            SSL,\n            \"_CRYPTOGRAPHY_MANYLINUX_CA_DIR\",\n            _ffi.string(_lib.X509_get_default_cert_dir()),\n        )\n        context.set_default_verify_paths()\n        store = context.get_cert_store()\n        sk_obj = _lib.X509_STORE_get0_objects(store._store)\n        assert sk_obj != _ffi.NULL\n        num = _lib.sk_X509_OBJECT_num(sk_obj)\n        assert num != 0\n\n    def test_check_env_vars(self, monkeypatch):\n        \"\"\"\n        Test that we return True/False appropriately if the env vars are set.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        dir_var = \"CUSTOM_DIR_VAR\"\n        file_var = \"CUSTOM_FILE_VAR\"\n        assert context._check_env_vars_set(dir_var, file_var) is False\n        monkeypatch.setenv(dir_var, \"value\")\n        monkeypatch.setenv(file_var, \"value\")\n        assert context._check_env_vars_set(dir_var, file_var) is True\n        assert context._check_env_vars_set(dir_var, file_var) is True\n\n    def test_verify_no_fallback_if_env_vars_set(self, monkeypatch):\n        \"\"\"\n        Test that we don't use the fallback path if env vars are set.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        monkeypatch.setattr(\n            _lib, \"SSL_CTX_set_default_verify_paths\", lambda x: 1\n        )\n        dir_env_var = _ffi.string(_lib.X509_get_default_cert_dir_env()).decode(\n            \"ascii\"\n        )\n        file_env_var = _ffi.string(\n            _lib.X509_get_default_cert_file_env()\n        ).decode(\"ascii\")\n        monkeypatch.setenv(dir_env_var, \"value\")\n        monkeypatch.setenv(file_env_var, \"value\")\n        context.set_default_verify_paths()\n\n        monkeypatch.setattr(\n            context, \"_fallback_default_verify_paths\", raiser(SystemError)\n        )\n        context.set_default_verify_paths()\n\n    @pytest.mark.skipif(\n        platform == \"win32\",\n        reason=\"set_default_verify_paths appears not to work on Windows.  \"\n        \"See LP#404343 and LP#404344.\",\n    )\n    def test_set_default_verify_paths(self):\n        \"\"\"\n        `Context.set_default_verify_paths` causes the platform-specific CA\n        certificate locations to be used for verification purposes.\n        \"\"\"\n        # Testing this requires a server with a certificate signed by one\n        # of the CAs in the platform CA location.  Getting one of those\n        # costs money.  Fortunately (or unfortunately, depending on your\n        # perspective), it's easy to think of a public server on the\n        # internet which has such a certificate.  Connecting to the network\n        # in a unit test is bad, but it's the only way I can think of to\n        # really test this. -exarkun\n        context = Context(SSLv23_METHOD)\n        context.set_default_verify_paths()\n        context.set_verify(\n            VERIFY_PEER,\n            lambda conn, cert, errno, depth, preverify_ok: preverify_ok,\n        )\n\n        client = socket_any_family()\n        try:\n            client.connect((\"encrypted.google.com\", 443))\n        except gaierror:\n            pytest.skip(\"cannot connect to encrypted.google.com\")\n        clientSSL = Connection(context, client)\n        clientSSL.set_connect_state()\n        clientSSL.set_tlsext_host_name(b\"encrypted.google.com\")\n        clientSSL.do_handshake()\n        clientSSL.send(b\"GET / HTTP/1.0\\r\\n\\r\\n\")\n        assert clientSSL.recv(1024)\n\n    def test_fallback_path_is_not_file_or_dir(self):\n        \"\"\"\n        Test that when passed empty arrays or paths that do not exist no\n        errors are raised.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        context._fallback_default_verify_paths([], [])\n        context._fallback_default_verify_paths([\"/not/a/file\"], [\"/not/a/dir\"])\n\n    def test_add_extra_chain_cert_invalid_cert(self):\n        \"\"\"\n        `Context.add_extra_chain_cert` raises `TypeError` if called with an\n        object which is not an instance of `X509`.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.add_extra_chain_cert(object())\n\n    def _handshake_test(self, serverContext, clientContext):\n        \"\"\"\n        Verify that a client and server created with the given contexts can\n        successfully handshake and communicate.\n        \"\"\"\n        serverSocket, clientSocket = socket_pair()\n\n        with serverSocket, clientSocket:\n            server = Connection(serverContext, serverSocket)\n            server.set_accept_state()\n\n            client = Connection(clientContext, clientSocket)\n            client.set_connect_state()\n\n            # Make them talk to each other.\n            for _ in range(3):\n                for s in [client, server]:\n                    try:\n                        s.do_handshake()\n                    except WantReadError:\n                        select.select([client, server], [], [])\n\n    def test_set_verify_callback_connection_argument(self):\n        \"\"\"\n        The first argument passed to the verify callback is the\n        `Connection` instance for which verification is taking place.\n        \"\"\"\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        serverConnection = Connection(serverContext, None)\n\n        class VerifyCallback:\n            def callback(self, connection, *args):\n                self.connection = connection\n                return 1\n\n        verify = VerifyCallback()\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(VERIFY_PEER, verify.callback)\n        clientConnection = Connection(clientContext, None)\n        clientConnection.set_connect_state()\n\n        handshake_in_memory(clientConnection, serverConnection)\n\n        assert verify.connection is clientConnection\n\n    def test_x509_in_verify_works(self):\n        \"\"\"\n        We had a bug where the X509 cert instantiated in the callback wrapper\n        didn't __init__ so it was missing objects needed when calling\n        get_subject. This test sets up a handshake where we call get_subject\n        on the cert provided to the verify callback.\n        \"\"\"\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        serverConnection = Connection(serverContext, None)\n\n        def verify_cb_get_subject(conn, cert, errnum, depth, ok):\n            assert cert.get_subject()\n            return 1\n\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(VERIFY_PEER, verify_cb_get_subject)\n        clientConnection = Connection(clientContext, None)\n        clientConnection.set_connect_state()\n\n        handshake_in_memory(clientConnection, serverConnection)\n\n    def test_set_verify_callback_exception(self):\n        \"\"\"\n        If the verify callback passed to `Context.set_verify` raises an\n        exception, verification fails and the exception is propagated to the\n        caller of `Connection.do_handshake`.\n        \"\"\"\n        serverContext = Context(TLSv1_2_METHOD)\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n\n        clientContext = Context(TLSv1_2_METHOD)\n\n        def verify_callback(*args):\n            raise Exception(\"silly verify failure\")\n\n        clientContext.set_verify(VERIFY_PEER, verify_callback)\n\n        with pytest.raises(Exception) as exc:\n            self._handshake_test(serverContext, clientContext)\n\n        assert \"silly verify failure\" == str(exc.value)\n\n    def test_set_verify_callback_reference(self):\n        \"\"\"\n        If the verify callback passed to `Context.set_verify` is set multiple\n        times, the pointers to the old call functions should not be dangling\n        and trigger a segfault.\n        \"\"\"\n        serverContext = Context(TLSv1_2_METHOD)\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n\n        clientContext = Context(TLSv1_2_METHOD)\n\n        clients = []\n\n        for i in range(5):\n\n            def verify_callback(*args):\n                return True\n\n            serverSocket, clientSocket = socket_pair()\n            client = Connection(clientContext, clientSocket)\n\n            clients.append((serverSocket, client))\n\n            clientContext.set_verify(VERIFY_PEER, verify_callback)\n\n        gc.collect()\n\n        # Make them talk to each other.\n        for serverSocket, client in clients:\n            server = Connection(serverContext, serverSocket)\n            server.set_accept_state()\n            client.set_connect_state()\n\n            for _ in range(5):\n                for s in [client, server]:\n                    try:\n                        s.do_handshake()\n                    except WantReadError:\n                        pass\n\n    @pytest.mark.parametrize(\"mode\", [SSL.VERIFY_PEER, SSL.VERIFY_NONE])\n    def test_set_verify_default_callback(self, mode):\n        \"\"\"\n        If the verify callback is omitted, the preverify value is used.\n        \"\"\"\n        serverContext = Context(TLSv1_2_METHOD)\n        serverContext.use_privatekey(\n            load_privatekey(FILETYPE_PEM, root_key_pem)\n        )\n        serverContext.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n\n        clientContext = Context(TLSv1_2_METHOD)\n        clientContext.set_verify(mode, None)\n\n        if mode == SSL.VERIFY_PEER:\n            with pytest.raises(Exception) as exc:\n                self._handshake_test(serverContext, clientContext)\n            assert \"certificate verify failed\" in str(exc.value)\n        else:\n            self._handshake_test(serverContext, clientContext)\n\n    def test_add_extra_chain_cert(self, tmpdir):\n        \"\"\"\n        `Context.add_extra_chain_cert` accepts an `X509`\n        instance to add to the certificate chain.\n\n        See `_create_certificate_chain` for the details of the\n        certificate chain tested.\n\n        The chain is tested by starting a server with scert and connecting\n        to it with a client which trusts cacert and requires verification to\n        succeed.\n        \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n\n        # Dump the CA certificate to a file because that's the only way to load\n        # it as a trusted CA in the client context.\n        for cert, name in [\n            (cacert, \"ca.pem\"),\n            (icert, \"i.pem\"),\n            (scert, \"s.pem\"),\n        ]:\n            with tmpdir.join(name).open(\"w\") as f:\n                f.write(dump_certificate(FILETYPE_PEM, cert).decode(\"ascii\"))\n\n        for key, name in [(cakey, \"ca.key\"), (ikey, \"i.key\"), (skey, \"s.key\")]:\n            with tmpdir.join(name).open(\"w\") as f:\n                f.write(dump_privatekey(FILETYPE_PEM, key).decode(\"ascii\"))\n\n        # Create the server context\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        # The client already has cacert, we only need to give them icert.\n        serverContext.add_extra_chain_cert(icert)\n\n        # Create the client\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(\n            VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, verify_cb\n        )\n        clientContext.load_verify_locations(str(tmpdir.join(\"ca.pem\")))\n\n        # Try it out.\n        self._handshake_test(serverContext, clientContext)\n\n    def _use_certificate_chain_file_test(self, certdir):\n        \"\"\"\n        Verify that `Context.use_certificate_chain_file` reads a\n        certificate chain from a specified file.\n\n        The chain is tested by starting a server with scert and connecting to\n        it with a client which trusts cacert and requires verification to\n        succeed.\n        \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n\n        makedirs(certdir)\n\n        chainFile = join_bytes_or_unicode(certdir, \"chain.pem\")\n        caFile = join_bytes_or_unicode(certdir, \"ca.pem\")\n\n        # Write out the chain file.\n        with open(chainFile, \"wb\") as fObj:\n            # Most specific to least general.\n            fObj.write(dump_certificate(FILETYPE_PEM, scert))\n            fObj.write(dump_certificate(FILETYPE_PEM, icert))\n            fObj.write(dump_certificate(FILETYPE_PEM, cacert))\n\n        with open(caFile, \"w\") as fObj:\n            fObj.write(dump_certificate(FILETYPE_PEM, cacert).decode(\"ascii\"))\n\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_certificate_chain_file(chainFile)\n        serverContext.use_privatekey(skey)\n\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(\n            VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, verify_cb\n        )\n        clientContext.load_verify_locations(caFile)\n\n        self._handshake_test(serverContext, clientContext)\n\n    def test_use_certificate_chain_file_bytes(self, tmpfile):\n        \"\"\"\n        ``Context.use_certificate_chain_file`` accepts the name of a file (as\n        an instance of ``bytes``) to specify additional certificates to use to\n        construct and verify a trust chain.\n        \"\"\"\n        self._use_certificate_chain_file_test(\n            tmpfile + NON_ASCII.encode(getfilesystemencoding())\n        )\n\n    def test_use_certificate_chain_file_unicode(self, tmpfile):\n        \"\"\"\n        ``Context.use_certificate_chain_file`` accepts the name of a file (as\n        an instance of ``unicode``) to specify additional certificates to use\n        to construct and verify a trust chain.\n        \"\"\"\n        self._use_certificate_chain_file_test(\n            tmpfile.decode(getfilesystemencoding()) + NON_ASCII\n        )\n\n    def test_use_certificate_chain_file_wrong_args(self):\n        \"\"\"\n        `Context.use_certificate_chain_file` raises `TypeError` if passed a\n        non-byte string single argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.use_certificate_chain_file(object())\n\n    def test_use_certificate_chain_file_missing_file(self, tmpfile):\n        \"\"\"\n        `Context.use_certificate_chain_file` raises `OpenSSL.SSL.Error` when\n        passed a bad chain file name (for example, the name of a file which\n        does not exist).\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            context.use_certificate_chain_file(tmpfile)\n\n    def test_set_verify_mode(self):\n        \"\"\"\n        `Context.get_verify_mode` returns the verify mode flags previously\n        passed to `Context.set_verify`.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        assert context.get_verify_mode() == 0\n        context.set_verify(VERIFY_PEER | VERIFY_CLIENT_ONCE)\n        assert context.get_verify_mode() == (VERIFY_PEER | VERIFY_CLIENT_ONCE)\n\n    @pytest.mark.parametrize(\"mode\", [None, 1.0, object(), \"mode\"])\n    def test_set_verify_wrong_mode_arg(self, mode):\n        \"\"\"\n        `Context.set_verify` raises `TypeError` if the first argument is\n        not an integer.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_verify(mode=mode)\n\n    @pytest.mark.parametrize(\"callback\", [1.0, \"mode\", (\"foo\", \"bar\")])\n    def test_set_verify_wrong_callable_arg(self, callback):\n        \"\"\"\n        `Context.set_verify` raises `TypeError` if the second argument\n        is not callable.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_verify(mode=VERIFY_PEER, callback=callback)\n\n    def test_load_tmp_dh_wrong_args(self):\n        \"\"\"\n        `Context.load_tmp_dh` raises `TypeError` if called with a\n        non-`str` argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.load_tmp_dh(object())\n\n    def test_load_tmp_dh_missing_file(self):\n        \"\"\"\n        `Context.load_tmp_dh` raises `OpenSSL.SSL.Error` if the\n        specified file does not exist.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            context.load_tmp_dh(b\"hello\")\n\n    def _load_tmp_dh_test(self, dhfilename):\n        \"\"\"\n        Verify that calling ``Context.load_tmp_dh`` with the given filename\n        does not raise an exception.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with open(dhfilename, \"w\") as dhfile:\n            dhfile.write(dhparam)\n\n        context.load_tmp_dh(dhfilename)\n\n    def test_load_tmp_dh_bytes(self, tmpfile):\n        \"\"\"\n        `Context.load_tmp_dh` loads Diffie-Hellman parameters from the\n        specified file (given as ``bytes``).\n        \"\"\"\n        self._load_tmp_dh_test(\n            tmpfile + NON_ASCII.encode(getfilesystemencoding()),\n        )\n\n    def test_load_tmp_dh_unicode(self, tmpfile):\n        \"\"\"\n        `Context.load_tmp_dh` loads Diffie-Hellman parameters from the\n        specified file (given as ``unicode``).\n        \"\"\"\n        self._load_tmp_dh_test(\n            tmpfile.decode(getfilesystemencoding()) + NON_ASCII,\n        )\n\n    def test_set_tmp_ecdh(self):\n        \"\"\"\n        `Context.set_tmp_ecdh` sets the elliptic curve for Diffie-Hellman to\n        the specified curve.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        for curve in get_elliptic_curves():\n            if curve.name.startswith(\"Oakley-\"):\n                # Setting Oakley-EC2N-4 and Oakley-EC2N-3 adds\n                # ('bignum routines', 'BN_mod_inverse', 'no inverse') to the\n                # error queue on OpenSSL 1.0.2.\n                continue\n            # The only easily \"assertable\" thing is that it does not raise an\n            # exception.\n            context.set_tmp_ecdh(curve)\n\n    def test_set_session_cache_mode_wrong_args(self):\n        \"\"\"\n        `Context.set_session_cache_mode` raises `TypeError` if called with\n        a non-integer argument.\n        called with other than one integer argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_session_cache_mode(object())\n\n    def test_session_cache_mode(self):\n        \"\"\"\n        `Context.set_session_cache_mode` specifies how sessions are cached.\n        The setting can be retrieved via `Context.get_session_cache_mode`.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        context.set_session_cache_mode(SESS_CACHE_OFF)\n        off = context.set_session_cache_mode(SESS_CACHE_BOTH)\n        assert SESS_CACHE_OFF == off\n        assert SESS_CACHE_BOTH == context.get_session_cache_mode()\n\n    def test_get_cert_store(self):\n        \"\"\"\n        `Context.get_cert_store` returns a `X509Store` instance.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        store = context.get_cert_store()\n        assert isinstance(store, X509Store)\n\n    def test_set_tlsext_use_srtp_not_bytes(self):\n        \"\"\"\n        `Context.set_tlsext_use_srtp' enables negotiating SRTP keying material.\n\n        It raises a TypeError if the list of profiles is not a byte string.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            context.set_tlsext_use_srtp(\"SRTP_AES128_CM_SHA1_80\")\n\n    def test_set_tlsext_use_srtp_invalid_profile(self):\n        \"\"\"\n        `Context.set_tlsext_use_srtp' enables negotiating SRTP keying material.\n\n        It raises an Error if the call to OpenSSL fails.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(Error):\n            context.set_tlsext_use_srtp(b\"SRTP_BOGUS\")\n\n    def test_set_tlsext_use_srtp_valid(self):\n        \"\"\"\n        `Context.set_tlsext_use_srtp' enables negotiating SRTP keying material.\n\n        It does not return anything.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        assert context.set_tlsext_use_srtp(b\"SRTP_AES128_CM_SHA1_80\") is None\n\n\nclass TestServerNameCallback:\n    \"\"\"\n    Tests for `Context.set_tlsext_servername_callback` and its\n    interaction with `Connection`.\n    \"\"\"\n\n    def test_old_callback_forgotten(self):\n        \"\"\"\n        If `Context.set_tlsext_servername_callback` is used to specify\n        a new callback, the one it replaces is dereferenced.\n        \"\"\"\n\n        def callback(connection):  # pragma: no cover\n            pass\n\n        def replacement(connection):  # pragma: no cover\n            pass\n\n        context = Context(SSLv23_METHOD)\n        context.set_tlsext_servername_callback(callback)\n\n        tracker = ref(callback)\n        del callback\n\n        context.set_tlsext_servername_callback(replacement)\n\n        # One run of the garbage collector happens to work on CPython.  PyPy\n        # doesn't collect the underlying object until a second run for whatever\n        # reason.  That's fine, it still demonstrates our code has properly\n        # dropped the reference.\n        collect()\n        collect()\n\n        callback = tracker()\n        if callback is not None:\n            referrers = get_referrers(callback)\n            if len(referrers) > 1:  # pragma: nocover\n                pytest.fail(f\"Some references remain: {referrers!r}\")\n\n    def test_no_servername(self):\n        \"\"\"\n        When a client specifies no server name, the callback passed to\n        `Context.set_tlsext_servername_callback` is invoked and the\n        result of `Connection.get_servername` is `None`.\n        \"\"\"\n        args = []\n\n        def servername(conn):\n            args.append((conn, conn.get_servername()))\n\n        context = Context(SSLv23_METHOD)\n        context.set_tlsext_servername_callback(servername)\n\n        # Lose our reference to it.  The Context is responsible for keeping it\n        # alive now.\n        del servername\n        collect()\n\n        # Necessary to actually accept the connection\n        context.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(context, None)\n        server.set_accept_state()\n\n        client = Connection(Context(SSLv23_METHOD), None)\n        client.set_connect_state()\n\n        interact_in_memory(server, client)\n\n        assert args == [(server, None)]\n\n    def test_servername(self):\n        \"\"\"\n        When a client specifies a server name in its hello message, the\n        callback passed to `Contexts.set_tlsext_servername_callback` is\n        invoked and the result of `Connection.get_servername` is that\n        server name.\n        \"\"\"\n        args = []\n\n        def servername(conn):\n            args.append((conn, conn.get_servername()))\n\n        context = Context(SSLv23_METHOD)\n        context.set_tlsext_servername_callback(servername)\n\n        # Necessary to actually accept the connection\n        context.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(context, None)\n        server.set_accept_state()\n\n        client = Connection(Context(SSLv23_METHOD), None)\n        client.set_connect_state()\n        client.set_tlsext_host_name(b\"foo1.example.com\")\n\n        interact_in_memory(server, client)\n\n        assert args == [(server, b\"foo1.example.com\")]\n\n\nclass TestApplicationLayerProtoNegotiation:\n    \"\"\"\n    Tests for ALPN in PyOpenSSL.\n    \"\"\"\n\n    def test_alpn_success(self):\n        \"\"\"\n        Clients and servers that agree on the negotiated ALPN protocol can\n        correct establish a connection, and the agreed protocol is reported\n        by the connections.\n        \"\"\"\n        select_args = []\n\n        def select(conn, options):\n            select_args.append((conn, options))\n            return b\"spdy/2\"\n\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(select)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        interact_in_memory(server, client)\n\n        assert select_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n        assert server.get_alpn_proto_negotiated() == b\"spdy/2\"\n        assert client.get_alpn_proto_negotiated() == b\"spdy/2\"\n\n    def test_alpn_call_failure(self):\n        \"\"\"\n        SSL_CTX_set_alpn_protos does not like to be called with an empty\n        protocols list. Ensure that we produce a user-visible error.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        with pytest.raises(ValueError):\n            context.set_alpn_protos([])\n\n    def test_alpn_set_on_connection(self):\n        \"\"\"\n        The same as test_alpn_success, but setting the ALPN protocols on\n        the connection rather than the context.\n        \"\"\"\n        select_args = []\n\n        def select(conn, options):\n            select_args.append((conn, options))\n            return b\"spdy/2\"\n\n        # Setup the client context but don't set any ALPN protocols.\n        client_context = Context(SSLv23_METHOD)\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(select)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        # Set the ALPN protocols on the client connection.\n        client = Connection(client_context, None)\n        client.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n        client.set_connect_state()\n\n        interact_in_memory(server, client)\n\n        assert select_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n        assert server.get_alpn_proto_negotiated() == b\"spdy/2\"\n        assert client.get_alpn_proto_negotiated() == b\"spdy/2\"\n\n    def test_alpn_server_fail(self):\n        \"\"\"\n        When clients and servers cannot agree on what protocol to use next\n        the TLS connection does not get established.\n        \"\"\"\n        select_args = []\n\n        def select(conn, options):\n            select_args.append((conn, options))\n            return b\"\"\n\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(select)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        # If the client doesn't return anything, the connection will fail.\n        with pytest.raises(Error):\n            interact_in_memory(server, client)\n\n        assert select_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n    def test_alpn_no_server_overlap(self):\n        \"\"\"\n        A server can allow a TLS handshake to complete without\n        agreeing to an application protocol by returning\n        ``NO_OVERLAPPING_PROTOCOLS``.\n        \"\"\"\n        refusal_args = []\n\n        def refusal(conn, options):\n            refusal_args.append((conn, options))\n            return NO_OVERLAPPING_PROTOCOLS\n\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(refusal)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        # Do the dance.\n        interact_in_memory(server, client)\n\n        assert refusal_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n        assert client.get_alpn_proto_negotiated() == b\"\"\n\n    def test_alpn_select_cb_returns_invalid_value(self):\n        \"\"\"\n        If the ALPN selection callback returns anything other than\n        a bytestring or ``NO_OVERLAPPING_PROTOCOLS``, a\n        :py:exc:`TypeError` is raised.\n        \"\"\"\n        invalid_cb_args = []\n\n        def invalid_cb(conn, options):\n            invalid_cb_args.append((conn, options))\n            return \"can't return unicode\"\n\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(invalid_cb)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        # Do the dance.\n        with pytest.raises(TypeError):\n            interact_in_memory(server, client)\n\n        assert invalid_cb_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n        assert client.get_alpn_proto_negotiated() == b\"\"\n\n    def test_alpn_no_server(self):\n        \"\"\"\n        When clients and servers cannot agree on what protocol to use next\n        because the server doesn't offer ALPN, no protocol is negotiated.\n        \"\"\"\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        # Do the dance.\n        interact_in_memory(server, client)\n\n        assert client.get_alpn_proto_negotiated() == b\"\"\n\n    def test_alpn_callback_exception(self):\n        \"\"\"\n        We can handle exceptions in the ALPN select callback.\n        \"\"\"\n        select_args = []\n\n        def select(conn, options):\n            select_args.append((conn, options))\n            raise TypeError()\n\n        client_context = Context(SSLv23_METHOD)\n        client_context.set_alpn_protos([b\"http/1.1\", b\"spdy/2\"])\n\n        server_context = Context(SSLv23_METHOD)\n        server_context.set_alpn_select_callback(select)\n\n        # Necessary to actually accept the connection\n        server_context.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_context.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n\n        # Do a little connection to trigger the logic\n        server = Connection(server_context, None)\n        server.set_accept_state()\n\n        client = Connection(client_context, None)\n        client.set_connect_state()\n\n        with pytest.raises(TypeError):\n            interact_in_memory(server, client)\n        assert select_args == [(server, [b\"http/1.1\", b\"spdy/2\"])]\n\n\nclass TestSession:\n    \"\"\"\n    Unit tests for :py:obj:`OpenSSL.SSL.Session`.\n    \"\"\"\n\n    def test_construction(self):\n        \"\"\"\n        :py:class:`Session` can be constructed with no arguments, creating\n        a new instance of that type.\n        \"\"\"\n        new_session = Session()\n        assert isinstance(new_session, Session)\n\n\n@pytest.fixture(params=[\"context\", \"connection\"])\ndef ctx_or_conn(request) -> Union[Context, Connection]:\n    ctx = Context(SSLv23_METHOD)\n    if request.param == \"context\":\n        return ctx\n    else:\n        return Connection(ctx, None)\n\n\nclass TestContextConnection:\n    \"\"\"\n    Unit test for methods that are exposed both by Connection and Context\n    objects.\n    \"\"\"\n\n    def test_use_privatekey(self, ctx_or_conn):\n        \"\"\"\n        `use_privatekey` takes an `OpenSSL.crypto.PKey` instance.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 1024)\n\n        ctx_or_conn.use_privatekey(key)\n        with pytest.raises(TypeError):\n            ctx_or_conn.use_privatekey(\"\")\n\n    def test_use_privatekey_wrong_key(self, ctx_or_conn):\n        \"\"\"\n        `use_privatekey` raises `OpenSSL.SSL.Error` when passed a\n        `OpenSSL.crypto.PKey` instance which has not been initialized.\n        \"\"\"\n        key = PKey()\n        key.generate_key(TYPE_RSA, 1024)\n        ctx_or_conn.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n        with pytest.raises(Error):\n            ctx_or_conn.use_privatekey(key)\n\n    def test_use_certificate(self, ctx_or_conn):\n        \"\"\"\n        `use_certificate` sets the certificate which will be\n        used to identify connections created using the context.\n        \"\"\"\n        # TODO\n        # Hard to assert anything.  But we could set a privatekey then ask\n        # OpenSSL if the cert and key agree using check_privatekey.  Then as\n        # long as check_privatekey works right we're good...\n        ctx_or_conn.use_certificate(\n            load_certificate(FILETYPE_PEM, root_cert_pem)\n        )\n\n    def test_use_certificate_wrong_args(self, ctx_or_conn):\n        \"\"\"\n        `use_certificate_wrong_args` raises `TypeError` when not passed\n        exactly one `OpenSSL.crypto.X509` instance as an argument.\n        \"\"\"\n        with pytest.raises(TypeError):\n            ctx_or_conn.use_certificate(\"hello, world\")\n\n    def test_use_certificate_uninitialized(self, ctx_or_conn):\n        \"\"\"\n        `use_certificate` raises `OpenSSL.SSL.Error` when passed a\n        `OpenSSL.crypto.X509` instance which has not been initialized\n        (ie, which does not actually have any certificate data).\n        \"\"\"\n        with pytest.raises(Error):\n            ctx_or_conn.use_certificate(X509())\n\n\nclass TestConnection:\n    \"\"\"\n    Unit tests for `OpenSSL.SSL.Connection`.\n    \"\"\"\n\n    # XXX get_peer_certificate -> None\n    # XXX sock_shutdown\n    # XXX master_key -> TypeError\n    # XXX server_random -> TypeError\n    # XXX connect -> TypeError\n    # XXX connect_ex -> TypeError\n    # XXX set_connect_state -> TypeError\n    # XXX set_accept_state -> TypeError\n    # XXX do_handshake -> TypeError\n    # XXX bio_read -> TypeError\n    # XXX recv -> TypeError\n    # XXX send -> TypeError\n    # XXX bio_write -> TypeError\n\n    def test_type(self):\n        \"\"\"\n        `Connection` can be used to create instances of that type.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        assert is_consistent_type(Connection, \"Connection\", ctx, None)\n\n    @pytest.mark.parametrize(\"bad_context\", [object(), \"context\", None, 1])\n    def test_wrong_args(self, bad_context):\n        \"\"\"\n        `Connection.__init__` raises `TypeError` if called with a non-`Context`\n        instance argument.\n        \"\"\"\n        with pytest.raises(TypeError):\n            Connection(bad_context)\n\n    @pytest.mark.parametrize(\"bad_bio\", [object(), None, 1, [1, 2, 3]])\n    def test_bio_write_wrong_args(self, bad_bio):\n        \"\"\"\n        `Connection.bio_write` raises `TypeError` if called with a non-bytes\n        (or text) argument.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        connection = Connection(context, None)\n        with pytest.raises(TypeError):\n            connection.bio_write(bad_bio)\n\n    def test_bio_write(self):\n        \"\"\"\n        `Connection.bio_write` does not raise if called with bytes or\n        bytearray, warns if called with text.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        connection = Connection(context, None)\n        connection.bio_write(b\"xy\")\n        connection.bio_write(bytearray(b\"za\"))\n        with pytest.warns(DeprecationWarning):\n            connection.bio_write(\"deprecated\")\n\n    def test_get_context(self):\n        \"\"\"\n        `Connection.get_context` returns the `Context` instance used to\n        construct the `Connection` instance.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        connection = Connection(context, None)\n        assert connection.get_context() is context\n\n    def test_set_context_wrong_args(self):\n        \"\"\"\n        `Connection.set_context` raises `TypeError` if called with a\n        non-`Context` instance argument.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        connection = Connection(ctx, None)\n        with pytest.raises(TypeError):\n            connection.set_context(object())\n        with pytest.raises(TypeError):\n            connection.set_context(\"hello\")\n        with pytest.raises(TypeError):\n            connection.set_context(1)\n        assert ctx is connection.get_context()\n\n    def test_set_context(self):\n        \"\"\"\n        `Connection.set_context` specifies a new `Context` instance to be\n        used for the connection.\n        \"\"\"\n        original = Context(SSLv23_METHOD)\n        replacement = Context(SSLv23_METHOD)\n        connection = Connection(original, None)\n        connection.set_context(replacement)\n        assert replacement is connection.get_context()\n        # Lose our references to the contexts, just in case the Connection\n        # isn't properly managing its own contributions to their reference\n        # counts.\n        del original, replacement\n        collect()\n\n    def test_set_tlsext_host_name_wrong_args(self):\n        \"\"\"\n        If `Connection.set_tlsext_host_name` is called with a non-byte string\n        argument or a byte string with an embedded NUL, `TypeError` is raised.\n        \"\"\"\n        conn = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(TypeError):\n            conn.set_tlsext_host_name(object())\n        with pytest.raises(TypeError):\n            conn.set_tlsext_host_name(b\"with\\0null\")\n\n        with pytest.raises(TypeError):\n            conn.set_tlsext_host_name(b\"example.com\".decode(\"ascii\"))\n\n    def test_pending(self):\n        \"\"\"\n        `Connection.pending` returns the number of bytes available for\n        immediate read.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        assert connection.pending() == 0\n\n    def test_peek(self):\n        \"\"\"\n        `Connection.recv` peeks into the connection if `socket.MSG_PEEK` is\n        passed.\n        \"\"\"\n        server, client = loopback()\n        server.send(b\"xy\")\n        assert client.recv(2, MSG_PEEK) == b\"xy\"\n        assert client.recv(2, MSG_PEEK) == b\"xy\"\n        assert client.recv(2) == b\"xy\"\n\n    def test_connect_wrong_args(self):\n        \"\"\"\n        `Connection.connect` raises `TypeError` if called with a non-address\n        argument.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), socket_any_family())\n        with pytest.raises(TypeError):\n            connection.connect(None)\n\n    def test_connect_refused(self):\n        \"\"\"\n        `Connection.connect` raises `socket.error` if the underlying socket\n        connect method raises it.\n        \"\"\"\n        client = socket_any_family()\n        context = Context(SSLv23_METHOD)\n        clientSSL = Connection(context, client)\n        # pytest.raises here doesn't work because of a bug in py.test on Python\n        # 2.6: https://github.com/pytest-dev/pytest/issues/988\n        try:\n            clientSSL.connect((loopback_address(client), 1))\n        except OSError as e:\n            exc = e\n        assert exc.args[0] == ECONNREFUSED\n\n    def test_connect(self):\n        \"\"\"\n        `Connection.connect` establishes a connection to the specified address.\n        \"\"\"\n        port = socket_any_family()\n        port.bind((\"\", 0))\n        port.listen(3)\n\n        clientSSL = Connection(Context(SSLv23_METHOD), socket(port.family))\n        clientSSL.connect((loopback_address(port), port.getsockname()[1]))\n        # XXX An assertion?  Or something?\n\n    def test_connect_ex(self):\n        \"\"\"\n        If there is a connection error, `Connection.connect_ex` returns the\n        errno instead of raising an exception.\n        \"\"\"\n        port = socket_any_family()\n        port.bind((\"\", 0))\n        port.listen(3)\n\n        clientSSL = Connection(Context(SSLv23_METHOD), socket(port.family))\n        clientSSL.setblocking(False)\n        result = clientSSL.connect_ex(port.getsockname())\n        expected = (EINPROGRESS, EWOULDBLOCK)\n        assert result in expected\n\n    def test_accept(self):\n        \"\"\"\n        `Connection.accept` accepts a pending connection attempt and returns a\n        tuple of a new `Connection` (the accepted client) and the address the\n        connection originated from.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n        port = socket_any_family()\n        portSSL = Connection(ctx, port)\n        portSSL.bind((\"\", 0))\n        portSSL.listen(3)\n\n        clientSSL = Connection(Context(SSLv23_METHOD), socket(port.family))\n\n        # Calling portSSL.getsockname() here to get the server IP address\n        # sounds great, but frequently fails on Windows.\n        clientSSL.connect((loopback_address(port), portSSL.getsockname()[1]))\n\n        serverSSL, address = portSSL.accept()\n\n        assert isinstance(serverSSL, Connection)\n        assert serverSSL.get_context() is ctx\n        assert address == clientSSL.getsockname()\n\n    def test_shutdown_wrong_args(self):\n        \"\"\"\n        `Connection.set_shutdown` raises `TypeError` if called with arguments\n        other than integers.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(TypeError):\n            connection.set_shutdown(None)\n\n    def test_shutdown(self):\n        \"\"\"\n        `Connection.shutdown` performs an SSL-level connection shutdown.\n        \"\"\"\n        server, client = loopback()\n        assert not server.shutdown()\n        assert server.get_shutdown() == SENT_SHUTDOWN\n        with pytest.raises(ZeroReturnError):\n            client.recv(1024)\n        assert client.get_shutdown() == RECEIVED_SHUTDOWN\n        client.shutdown()\n        assert client.get_shutdown() == (SENT_SHUTDOWN | RECEIVED_SHUTDOWN)\n        with pytest.raises(ZeroReturnError):\n            server.recv(1024)\n        assert server.get_shutdown() == (SENT_SHUTDOWN | RECEIVED_SHUTDOWN)\n\n    def test_shutdown_closed(self):\n        \"\"\"\n        If the underlying socket is closed, `Connection.shutdown` propagates\n        the write error from the low level write call.\n        \"\"\"\n        server, client = loopback()\n        server.sock_shutdown(2)\n        with pytest.raises(SysCallError) as exc:\n            server.shutdown()\n        if platform == \"win32\":\n            assert exc.value.args[0] == ESHUTDOWN\n        else:\n            assert exc.value.args[0] == EPIPE\n\n    def test_shutdown_truncated(self):\n        \"\"\"\n        If the underlying connection is truncated, `Connection.shutdown`\n        raises an `Error`.\n        \"\"\"\n        server_ctx = Context(SSLv23_METHOD)\n        client_ctx = Context(SSLv23_METHOD)\n        server_ctx.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_ctx.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n        server = Connection(server_ctx, None)\n        client = Connection(client_ctx, None)\n        handshake_in_memory(client, server)\n        assert not server.shutdown()\n        with pytest.raises(WantReadError):\n            server.shutdown()\n        server.bio_shutdown()\n        with pytest.raises(Error):\n            server.shutdown()\n\n    def test_set_shutdown(self):\n        \"\"\"\n        `Connection.set_shutdown` sets the state of the SSL connection\n        shutdown process.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), socket_any_family())\n        connection.set_shutdown(RECEIVED_SHUTDOWN)\n        assert connection.get_shutdown() == RECEIVED_SHUTDOWN\n\n    def test_state_string(self):\n        \"\"\"\n        `Connection.state_string` verbosely describes the current state of\n        the `Connection`.\n        \"\"\"\n        server, client = socket_pair()\n        server = loopback_server_factory(server)\n        client = loopback_client_factory(client)\n\n        assert server.get_state_string() in [\n            b\"before/accept initialization\",\n            b\"before SSL initialization\",\n        ]\n        assert client.get_state_string() in [\n            b\"before/connect initialization\",\n            b\"before SSL initialization\",\n        ]\n\n    def test_app_data(self):\n        \"\"\"\n        Any object can be set as app data by passing it to\n        `Connection.set_app_data` and later retrieved with\n        `Connection.get_app_data`.\n        \"\"\"\n        conn = Connection(Context(SSLv23_METHOD), None)\n        assert None is conn.get_app_data()\n        app_data = object()\n        conn.set_app_data(app_data)\n        assert conn.get_app_data() is app_data\n\n    def test_makefile(self):\n        \"\"\"\n        `Connection.makefile` is not implemented and calling that\n        method raises `NotImplementedError`.\n        \"\"\"\n        conn = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(NotImplementedError):\n            conn.makefile()\n\n    def test_get_certificate(self):\n        \"\"\"\n        `Connection.get_certificate` returns the local certificate.\n        \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n\n        context = Context(SSLv23_METHOD)\n        context.use_certificate(scert)\n        client = Connection(context, None)\n        cert = client.get_certificate()\n        assert cert is not None\n        assert \"Server Certificate\" == cert.get_subject().CN\n\n    def test_get_certificate_none(self):\n        \"\"\"\n        `Connection.get_certificate` returns the local certificate.\n\n        If there is no certificate, it returns None.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        client = Connection(context, None)\n        cert = client.get_certificate()\n        assert cert is None\n\n    def test_get_peer_cert_chain(self):\n        \"\"\"\n        `Connection.get_peer_cert_chain` returns a list of certificates\n        which the connected server returned for the certification verification.\n        \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n\n        # Create the client\n        clientContext = Context(SSLv23_METHOD)\n        clientContext.set_verify(VERIFY_NONE, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n\n        interact_in_memory(client, server)\n\n        chain = client.get_peer_cert_chain()\n        assert len(chain) == 3\n        assert \"Server Certificate\" == chain[0].get_subject().CN\n        assert \"Intermediate Certificate\" == chain[1].get_subject().CN\n        assert \"Authority Certificate\" == chain[2].get_subject().CN\n\n    def test_get_peer_cert_chain_none(self):\n        \"\"\"\n        `Connection.get_peer_cert_chain` returns `None` if the peer sends\n        no certificate chain.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n        server = Connection(ctx, None)\n        server.set_accept_state()\n        client = Connection(Context(SSLv23_METHOD), None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        assert None is server.get_peer_cert_chain()\n\n    def test_get_verified_chain(self):\n        \"\"\"\n        `Connection.get_verified_chain` returns a list of certificates\n        which the connected server returned for the certification verification.\n        \"\"\"\n        chain = _create_certificate_chain()\n        [(cakey, cacert), (ikey, icert), (skey, scert)] = chain\n\n        serverContext = Context(SSLv23_METHOD)\n        serverContext.use_privatekey(skey)\n        serverContext.use_certificate(scert)\n        serverContext.add_extra_chain_cert(icert)\n        serverContext.add_extra_chain_cert(cacert)\n        server = Connection(serverContext, None)\n        server.set_accept_state()\n\n        # Create the client\n        clientContext = Context(SSLv23_METHOD)\n        # cacert is self-signed so the client must trust it for verification\n        # to succeed.\n        clientContext.get_cert_store().add_cert(cacert)\n        clientContext.set_verify(VERIFY_PEER, verify_cb)\n        client = Connection(clientContext, None)\n        client.set_connect_state()\n\n        interact_in_memory(client, server)\n\n        chain = client.get_verified_chain()\n        assert len(chain) == 3\n        assert \"Server Certificate\" == chain[0].get_subject().CN\n        assert \"Intermediate Certificate\" == chain[1].get_subject().CN\n        assert \"Authority Certificate\" == chain[2].get_subject().CN\n\n    def test_get_verified_chain_none(self):\n        \"\"\"\n        `Connection.get_verified_chain` returns `None` if the peer sends\n        no certificate chain.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n        server = Connection(ctx, None)\n        server.set_accept_state()\n        client = Connection(Context(SSLv23_METHOD), None)\n        client.set_connect_state()\n        interact_in_memory(client, server)\n        assert None is server.get_verified_chain()\n\n    def test_get_verified_chain_unconnected(self):\n        \"\"\"\n        `Connection.get_verified_chain` returns `None` when used with an object\n        which has not been connected.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        server = Connection(ctx, None)\n        assert None is server.get_verified_chain()\n\n    def test_set_verify_overrides_context(self):\n        context = Context(SSLv23_METHOD)\n        context.set_verify(VERIFY_PEER)\n        conn = Connection(context, None)\n        conn.set_verify(VERIFY_NONE)\n\n        assert context.get_verify_mode() == VERIFY_PEER\n        assert conn.get_verify_mode() == VERIFY_NONE\n\n        with pytest.raises(TypeError):\n            conn.set_verify(None)\n\n        with pytest.raises(TypeError):\n            conn.set_verify(VERIFY_PEER, \"not a callable\")\n\n    def test_set_verify_callback_reference(self):\n        \"\"\"\n        The callback for certificate verification should only be forgotten if\n        the context and all connections created by it do not use it anymore.\n        \"\"\"\n\n        def callback(conn, cert, errnum, depth, ok):  # pragma: no cover\n            return ok\n\n        tracker = ref(callback)\n\n        context = Context(SSLv23_METHOD)\n        context.set_verify(VERIFY_PEER, callback)\n        del callback\n\n        conn = Connection(context, None)\n        context.set_verify(VERIFY_NONE)\n\n        collect()\n        collect()\n        assert tracker()\n\n        conn.set_verify(VERIFY_PEER, lambda conn, cert, errnum, depth, ok: ok)\n        collect()\n        collect()\n        callback = tracker()\n        if callback is not None:  # pragma: nocover\n            referrers = get_referrers(callback)\n            if len(referrers) > 1:\n                pytest.fail(f\"Some references remain: {referrers!r}\")\n\n    def test_get_session_unconnected(self):\n        \"\"\"\n        `Connection.get_session` returns `None` when used with an object\n        which has not been connected.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        server = Connection(ctx, None)\n        session = server.get_session()\n        assert None is session\n\n    def test_server_get_session(self):\n        \"\"\"\n        On the server side of a connection, `Connection.get_session` returns a\n        `Session` instance representing the SSL session for that connection.\n        \"\"\"\n        server, client = loopback()\n        session = server.get_session()\n        assert isinstance(session, Session)\n\n    def test_client_get_session(self):\n        \"\"\"\n        On the client side of a connection, `Connection.get_session`\n        returns a `Session` instance representing the SSL session for\n        that connection.\n        \"\"\"\n        server, client = loopback()\n        session = client.get_session()\n        assert isinstance(session, Session)\n\n    def test_set_session_wrong_args(self):\n        \"\"\"\n        `Connection.set_session` raises `TypeError` if called with an object\n        that is not an instance of `Session`.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        connection = Connection(ctx, None)\n        with pytest.raises(TypeError):\n            connection.set_session(123)\n        with pytest.raises(TypeError):\n            connection.set_session(\"hello\")\n        with pytest.raises(TypeError):\n            connection.set_session(object())\n\n    def test_client_set_session(self):\n        \"\"\"\n        `Connection.set_session`, when used prior to a connection being\n        established, accepts a `Session` instance and causes an attempt to\n        re-use the session it represents when the SSL handshake is performed.\n        \"\"\"\n        key = load_privatekey(FILETYPE_PEM, server_key_pem)\n        cert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        ctx = Context(TLSv1_2_METHOD)\n        ctx.use_privatekey(key)\n        ctx.use_certificate(cert)\n        ctx.set_session_id(b\"unity-test\")\n\n        def makeServer(socket):\n            server = Connection(ctx, socket)\n            server.set_accept_state()\n            return server\n\n        originalServer, originalClient = loopback(server_factory=makeServer)\n        originalSession = originalClient.get_session()\n\n        def makeClient(socket):\n            client = loopback_client_factory(socket)\n            client.set_session(originalSession)\n            return client\n\n        resumedServer, resumedClient = loopback(\n            server_factory=makeServer, client_factory=makeClient\n        )\n\n        # This is a proxy: in general, we have no access to any unique\n        # identifier for the session (new enough versions of OpenSSL expose\n        # a hash which could be usable, but \"new enough\" is very, very new).\n        # Instead, exploit the fact that the master key is re-used if the\n        # session is re-used.  As long as the master key for the two\n        # connections is the same, the session was re-used!\n        assert originalServer.master_key() == resumedServer.master_key()\n\n    def test_set_session_wrong_method(self):\n        \"\"\"\n        If `Connection.set_session` is passed a `Session` instance associated\n        with a context using a different SSL method than the `Connection`\n        is using, a `OpenSSL.SSL.Error` is raised.\n        \"\"\"\n        v1 = TLSv1_2_METHOD\n        v2 = TLSv1_METHOD\n\n        key = load_privatekey(FILETYPE_PEM, server_key_pem)\n        cert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        ctx = Context(v1)\n        ctx.use_privatekey(key)\n        ctx.use_certificate(cert)\n        ctx.set_session_id(b\"unity-test\")\n\n        def makeServer(socket):\n            server = Connection(ctx, socket)\n            server.set_accept_state()\n            return server\n\n        def makeOriginalClient(socket):\n            client = Connection(Context(v1), socket)\n            client.set_connect_state()\n            return client\n\n        originalServer, originalClient = loopback(\n            server_factory=makeServer, client_factory=makeOriginalClient\n        )\n        originalSession = originalClient.get_session()\n\n        def makeClient(socket):\n            # Intentionally use a different, incompatible method here.\n            client = Connection(Context(v2), socket)\n            client.set_connect_state()\n            client.set_session(originalSession)\n            return client\n\n        with pytest.raises(Error):\n            loopback(client_factory=makeClient, server_factory=makeServer)\n\n    def test_wantWriteError(self):\n        \"\"\"\n        `Connection` methods which generate output raise\n        `OpenSSL.SSL.WantWriteError` if writing to the connection's BIO\n        fail indicating a should-write state.\n        \"\"\"\n        client_socket, server_socket = socket_pair()\n        # Fill up the client's send buffer so Connection won't be able to write\n        # anything. Start by sending larger chunks (Windows Socket I/O is slow)\n        # and continue by writing a single byte at a time so we can be sure we\n        # completely fill the buffer.  Even though the socket API is allowed to\n        # signal a short write via its return value it seems this doesn't\n        # always happen on all platforms (FreeBSD and OS X particular) for the\n        # very last bit of available buffer space.\n        for msg in [b\"x\" * 65536, b\"x\"]:\n            for i in range(1024 * 1024 * 64):\n                try:\n                    client_socket.send(msg)\n                except OSError as e:\n                    if e.errno == EWOULDBLOCK:\n                        break\n                    raise  # pragma: no cover\n            else:  # pragma: no cover\n                pytest.fail(\n                    \"Failed to fill socket buffer, cannot test BIO want write\"\n                )\n\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, client_socket)\n        # Client's speak first, so make it an SSL client\n        conn.set_connect_state()\n        with pytest.raises(WantWriteError):\n            conn.do_handshake()\n\n    # XXX want_read\n\n    def test_get_finished_before_connect(self):\n        \"\"\"\n        `Connection.get_finished` returns `None` before TLS handshake\n        is completed.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        connection = Connection(ctx, None)\n        assert connection.get_finished() is None\n\n    def test_get_peer_finished_before_connect(self):\n        \"\"\"\n        `Connection.get_peer_finished` returns `None` before TLS handshake\n        is completed.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        connection = Connection(ctx, None)\n        assert connection.get_peer_finished() is None\n\n    def test_get_finished(self):\n        \"\"\"\n        `Connection.get_finished` method returns the TLS Finished message send\n        from client, or server. Finished messages are send during\n        TLS handshake.\n        \"\"\"\n        server, client = loopback()\n\n        assert server.get_finished() is not None\n        assert len(server.get_finished()) > 0\n\n    def test_get_peer_finished(self):\n        \"\"\"\n        `Connection.get_peer_finished` method returns the TLS Finished\n        message received from client, or server. Finished messages are send\n        during TLS handshake.\n        \"\"\"\n        server, client = loopback()\n\n        assert server.get_peer_finished() is not None\n        assert len(server.get_peer_finished()) > 0\n\n    def test_tls_finished_message_symmetry(self):\n        \"\"\"\n        The TLS Finished message send by server must be the TLS Finished\n        message received by client.\n\n        The TLS Finished message send by client must be the TLS Finished\n        message received by server.\n        \"\"\"\n        server, client = loopback()\n\n        assert server.get_finished() == client.get_peer_finished()\n        assert client.get_finished() == server.get_peer_finished()\n\n    def test_get_cipher_name_before_connect(self):\n        \"\"\"\n        `Connection.get_cipher_name` returns `None` if no connection\n        has been established.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        assert conn.get_cipher_name() is None\n\n    def test_get_cipher_name(self):\n        \"\"\"\n        `Connection.get_cipher_name` returns a `unicode` string giving the\n        name of the currently used cipher.\n        \"\"\"\n        server, client = loopback()\n        server_cipher_name, client_cipher_name = (\n            server.get_cipher_name(),\n            client.get_cipher_name(),\n        )\n\n        assert isinstance(server_cipher_name, str)\n        assert isinstance(client_cipher_name, str)\n\n        assert server_cipher_name == client_cipher_name\n\n    def test_get_cipher_version_before_connect(self):\n        \"\"\"\n        `Connection.get_cipher_version` returns `None` if no connection\n        has been established.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        assert conn.get_cipher_version() is None\n\n    def test_get_cipher_version(self):\n        \"\"\"\n        `Connection.get_cipher_version` returns a `unicode` string giving\n        the protocol name of the currently used cipher.\n        \"\"\"\n        server, client = loopback()\n        server_cipher_version, client_cipher_version = (\n            server.get_cipher_version(),\n            client.get_cipher_version(),\n        )\n\n        assert isinstance(server_cipher_version, str)\n        assert isinstance(client_cipher_version, str)\n\n        assert server_cipher_version == client_cipher_version\n\n    def test_get_cipher_bits_before_connect(self):\n        \"\"\"\n        `Connection.get_cipher_bits` returns `None` if no connection has\n        been established.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        assert conn.get_cipher_bits() is None\n\n    def test_get_cipher_bits(self):\n        \"\"\"\n        `Connection.get_cipher_bits` returns the number of secret bits\n        of the currently used cipher.\n        \"\"\"\n        server, client = loopback()\n        server_cipher_bits, client_cipher_bits = (\n            server.get_cipher_bits(),\n            client.get_cipher_bits(),\n        )\n\n        assert isinstance(server_cipher_bits, int)\n        assert isinstance(client_cipher_bits, int)\n\n        assert server_cipher_bits == client_cipher_bits\n\n    def test_get_protocol_version_name(self):\n        \"\"\"\n        `Connection.get_protocol_version_name()` returns a string giving the\n        protocol version of the current connection.\n        \"\"\"\n        server, client = loopback()\n        client_protocol_version_name = client.get_protocol_version_name()\n        server_protocol_version_name = server.get_protocol_version_name()\n\n        assert isinstance(server_protocol_version_name, str)\n        assert isinstance(client_protocol_version_name, str)\n\n        assert server_protocol_version_name == client_protocol_version_name\n\n    def test_get_protocol_version(self):\n        \"\"\"\n        `Connection.get_protocol_version()` returns an integer\n        giving the protocol version of the current connection.\n        \"\"\"\n        server, client = loopback()\n        client_protocol_version = client.get_protocol_version()\n        server_protocol_version = server.get_protocol_version()\n\n        assert isinstance(server_protocol_version, int)\n        assert isinstance(client_protocol_version, int)\n\n        assert server_protocol_version == client_protocol_version\n\n    def test_wantReadError(self):\n        \"\"\"\n        `Connection.bio_read` raises `OpenSSL.SSL.WantReadError` if there are\n        no bytes available to be read from the BIO.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        with pytest.raises(WantReadError):\n            conn.bio_read(1024)\n\n    @pytest.mark.parametrize(\"bufsize\", [1.0, None, object(), \"bufsize\"])\n    def test_bio_read_wrong_args(self, bufsize):\n        \"\"\"\n        `Connection.bio_read` raises `TypeError` if passed a non-integer\n        argument.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        with pytest.raises(TypeError):\n            conn.bio_read(bufsize)\n\n    def test_buffer_size(self):\n        \"\"\"\n        `Connection.bio_read` accepts an integer giving the maximum number\n        of bytes to read and return.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        conn = Connection(ctx, None)\n        conn.set_connect_state()\n        try:\n            conn.do_handshake()\n        except WantReadError:\n            pass\n        data = conn.bio_read(2)\n        assert 2 == len(data)\n\n\nclass TestConnectionGetCipherList:\n    \"\"\"\n    Tests for `Connection.get_cipher_list`.\n    \"\"\"\n\n    def test_result(self):\n        \"\"\"\n        `Connection.get_cipher_list` returns a list of `bytes` giving the\n        names of the ciphers which might be used.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        ciphers = connection.get_cipher_list()\n        assert isinstance(ciphers, list)\n        for cipher in ciphers:\n            assert isinstance(cipher, str)\n\n\nclass VeryLarge(bytes):\n    \"\"\"\n    Mock object so that we don't have to allocate 2**31 bytes\n    \"\"\"\n\n    def __len__(self):\n        return 2**31\n\n\nclass TestConnectionSend:\n    \"\"\"\n    Tests for `Connection.send`.\n    \"\"\"\n\n    def test_wrong_args(self):\n        \"\"\"\n        When called with arguments other than string argument for its first\n        parameter, `Connection.send` raises `TypeError`.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(TypeError):\n            connection.send(object())\n        with pytest.raises(TypeError):\n            connection.send([1, 2, 3])\n\n    def test_short_bytes(self):\n        \"\"\"\n        When passed a short byte string, `Connection.send` transmits all of it\n        and returns the number of bytes sent.\n        \"\"\"\n        server, client = loopback()\n        count = server.send(b\"xy\")\n        assert count == 2\n        assert client.recv(2) == b\"xy\"\n\n    def test_text(self):\n        \"\"\"\n        When passed a text, `Connection.send` transmits all of it and\n        returns the number of bytes sent. It also raises a DeprecationWarning.\n        \"\"\"\n        server, client = loopback()\n        with pytest.warns(DeprecationWarning) as w:\n            count = server.send(b\"xy\".decode(\"ascii\"))\n            assert (\n                f\"{WARNING_TYPE_EXPECTED} for buf is no longer accepted, \"\n                f\"use bytes\"\n            ) == str(w[-1].message)\n        assert count == 2\n        assert client.recv(2) == b\"xy\"\n\n    def test_short_memoryview(self):\n        \"\"\"\n        When passed a memoryview onto a small number of bytes,\n        `Connection.send` transmits all of them and returns the number\n        of bytes sent.\n        \"\"\"\n        server, client = loopback()\n        count = server.send(memoryview(b\"xy\"))\n        assert count == 2\n        assert client.recv(2) == b\"xy\"\n\n    def test_short_bytearray(self):\n        \"\"\"\n        When passed a short bytearray, `Connection.send` transmits all of\n        it and returns the number of bytes sent.\n        \"\"\"\n        server, client = loopback()\n        count = server.send(bytearray(b\"xy\"))\n        assert count == 2\n        assert client.recv(2) == b\"xy\"\n\n    @pytest.mark.skipif(\n        sys.maxsize < 2**31,\n        reason=\"sys.maxsize < 2**31 - test requires 64 bit\",\n    )\n    def test_buf_too_large(self):\n        \"\"\"\n        When passed a buffer containing >= 2**31 bytes,\n        `Connection.send` bails out as SSL_write only\n        accepts an int for the buffer length.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(ValueError) as exc_info:\n            connection.send(VeryLarge())\n        exc_info.match(r\"Cannot send more than .+ bytes at once\")\n\n\ndef _make_memoryview(size):\n    \"\"\"\n    Create a new ``memoryview`` wrapped around a ``bytearray`` of the given\n    size.\n    \"\"\"\n    return memoryview(bytearray(size))\n\n\nclass TestConnectionRecvInto:\n    \"\"\"\n    Tests for `Connection.recv_into`.\n    \"\"\"\n\n    def _no_length_test(self, factory):\n        \"\"\"\n        Assert that when the given buffer is passed to `Connection.recv_into`,\n        whatever bytes are available to be received that fit into that buffer\n        are written into that buffer.\n        \"\"\"\n        output_buffer = factory(5)\n\n        server, client = loopback()\n        server.send(b\"xy\")\n\n        assert client.recv_into(output_buffer) == 2\n        assert output_buffer == bytearray(b\"xy\\x00\\x00\\x00\")\n\n    def test_bytearray_no_length(self):\n        \"\"\"\n        `Connection.recv_into` can be passed a `bytearray` instance and data\n        in the receive buffer is written to it.\n        \"\"\"\n        self._no_length_test(bytearray)\n\n    def _respects_length_test(self, factory):\n        \"\"\"\n        Assert that when the given buffer is passed to `Connection.recv_into`\n        along with a value for `nbytes` that is less than the size of that\n        buffer, only `nbytes` bytes are written into the buffer.\n        \"\"\"\n        output_buffer = factory(10)\n\n        server, client = loopback()\n        server.send(b\"abcdefghij\")\n\n        assert client.recv_into(output_buffer, 5) == 5\n        assert output_buffer == bytearray(b\"abcde\\x00\\x00\\x00\\x00\\x00\")\n\n    def test_bytearray_respects_length(self):\n        \"\"\"\n        When called with a `bytearray` instance, `Connection.recv_into`\n        respects the `nbytes` parameter and doesn't copy in more than that\n        number of bytes.\n        \"\"\"\n        self._respects_length_test(bytearray)\n\n    def _doesnt_overfill_test(self, factory):\n        \"\"\"\n        Assert that if there are more bytes available to be read from the\n        receive buffer than would fit into the buffer passed to\n        `Connection.recv_into`, only as many as fit are written into it.\n        \"\"\"\n        output_buffer = factory(5)\n\n        server, client = loopback()\n        server.send(b\"abcdefghij\")\n\n        assert client.recv_into(output_buffer) == 5\n        assert output_buffer == bytearray(b\"abcde\")\n        rest = client.recv(5)\n        assert b\"fghij\" == rest\n\n    def test_bytearray_doesnt_overfill(self):\n        \"\"\"\n        When called with a `bytearray` instance, `Connection.recv_into`\n        respects the size of the array and doesn't write more bytes into it\n        than will fit.\n        \"\"\"\n        self._doesnt_overfill_test(bytearray)\n\n    def test_bytearray_really_doesnt_overfill(self):\n        \"\"\"\n        When called with a `bytearray` instance and an `nbytes` value that is\n        too large, `Connection.recv_into` respects the size of the array and\n        not the `nbytes` value and doesn't write more bytes into the buffer\n        than will fit.\n        \"\"\"\n        self._doesnt_overfill_test(bytearray)\n\n    def test_peek(self):\n        server, client = loopback()\n        server.send(b\"xy\")\n\n        for _ in range(2):\n            output_buffer = bytearray(5)\n            assert client.recv_into(output_buffer, flags=MSG_PEEK) == 2\n            assert output_buffer == bytearray(b\"xy\\x00\\x00\\x00\")\n\n    def test_memoryview_no_length(self):\n        \"\"\"\n        `Connection.recv_into` can be passed a `memoryview` instance and data\n        in the receive buffer is written to it.\n        \"\"\"\n        self._no_length_test(_make_memoryview)\n\n    def test_memoryview_respects_length(self):\n        \"\"\"\n        When called with a `memoryview` instance, `Connection.recv_into`\n        respects the ``nbytes`` parameter and doesn't copy more than that\n        number of bytes in.\n        \"\"\"\n        self._respects_length_test(_make_memoryview)\n\n    def test_memoryview_doesnt_overfill(self):\n        \"\"\"\n        When called with a `memoryview` instance, `Connection.recv_into`\n        respects the size of the array and doesn't write more bytes into it\n        than will fit.\n        \"\"\"\n        self._doesnt_overfill_test(_make_memoryview)\n\n    def test_memoryview_really_doesnt_overfill(self):\n        \"\"\"\n        When called with a `memoryview` instance and an `nbytes` value that is\n        too large, `Connection.recv_into` respects the size of the array and\n        not the `nbytes` value and doesn't write more bytes into the buffer\n        than will fit.\n        \"\"\"\n        self._doesnt_overfill_test(_make_memoryview)\n\n\nclass TestConnectionSendall:\n    \"\"\"\n    Tests for `Connection.sendall`.\n    \"\"\"\n\n    def test_wrong_args(self):\n        \"\"\"\n        When called with arguments other than a string argument for its first\n        parameter, `Connection.sendall` raises `TypeError`.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        with pytest.raises(TypeError):\n            connection.sendall(object())\n        with pytest.raises(TypeError):\n            connection.sendall([1, 2, 3])\n\n    def test_short(self):\n        \"\"\"\n        `Connection.sendall` transmits all of the bytes in the string\n        passed to it.\n        \"\"\"\n        server, client = loopback()\n        server.sendall(b\"x\")\n        assert client.recv(1) == b\"x\"\n\n    def test_text(self):\n        \"\"\"\n        `Connection.sendall` transmits all the content in the string passed\n        to it, raising a DeprecationWarning in case of this being a text.\n        \"\"\"\n        server, client = loopback()\n        with pytest.warns(DeprecationWarning) as w:\n            server.sendall(b\"x\".decode(\"ascii\"))\n            assert (\n                f\"{WARNING_TYPE_EXPECTED} for buf is no longer accepted, \"\n                f\"use bytes\"\n            ) == str(w[-1].message)\n        assert client.recv(1) == b\"x\"\n\n    def test_short_memoryview(self):\n        \"\"\"\n        When passed a memoryview onto a small number of bytes,\n        `Connection.sendall` transmits all of them.\n        \"\"\"\n        server, client = loopback()\n        server.sendall(memoryview(b\"x\"))\n        assert client.recv(1) == b\"x\"\n\n    def test_long(self):\n        \"\"\"\n        `Connection.sendall` transmits all the bytes in the string passed to it\n        even if this requires multiple calls of an underlying write function.\n        \"\"\"\n        server, client = loopback()\n        # Should be enough, underlying SSL_write should only do 16k at a time.\n        # On Windows, after 32k of bytes the write will block (forever\n        # - because no one is yet reading).\n        message = b\"x\" * (1024 * 32 - 1) + b\"y\"\n        server.sendall(message)\n        accum = []\n        received = 0\n        while received < len(message):\n            data = client.recv(1024)\n            accum.append(data)\n            received += len(data)\n        assert message == b\"\".join(accum)\n\n    def test_closed(self):\n        \"\"\"\n        If the underlying socket is closed, `Connection.sendall` propagates the\n        write error from the low level write call.\n        \"\"\"\n        server, client = loopback()\n        server.sock_shutdown(2)\n        with pytest.raises(SysCallError) as err:\n            server.sendall(b\"hello, world\")\n        if platform == \"win32\":\n            assert err.value.args[0] == ESHUTDOWN\n        else:\n            assert err.value.args[0] == EPIPE\n\n\nclass TestConnectionRenegotiate:\n    \"\"\"\n    Tests for SSL renegotiation APIs.\n    \"\"\"\n\n    def test_total_renegotiations(self):\n        \"\"\"\n        `Connection.total_renegotiations` returns `0` before any renegotiations\n        have happened.\n        \"\"\"\n        connection = Connection(Context(SSLv23_METHOD), None)\n        assert connection.total_renegotiations() == 0\n\n    def test_renegotiate(self):\n        \"\"\"\n        Go through a complete renegotiation cycle.\n        \"\"\"\n        server, client = loopback(\n            lambda s: loopback_server_factory(s, TLSv1_2_METHOD),\n            lambda s: loopback_client_factory(s, TLSv1_2_METHOD),\n        )\n\n        server.send(b\"hello world\")\n\n        assert b\"hello world\" == client.recv(len(b\"hello world\"))\n\n        assert 0 == server.total_renegotiations()\n        assert False is server.renegotiate_pending()\n\n        assert True is server.renegotiate()\n\n        assert True is server.renegotiate_pending()\n\n        server.setblocking(False)\n        client.setblocking(False)\n\n        client.do_handshake()\n        server.do_handshake()\n\n        assert 1 == server.total_renegotiations()\n        while False is server.renegotiate_pending():\n            pass\n\n\nclass TestError:\n    \"\"\"\n    Unit tests for `OpenSSL.SSL.Error`.\n    \"\"\"\n\n    def test_type(self):\n        \"\"\"\n        `Error` is an exception type.\n        \"\"\"\n        assert issubclass(Error, Exception)\n        assert Error.__name__ == \"Error\"\n\n\nclass TestConstants:\n    \"\"\"\n    Tests for the values of constants exposed in `OpenSSL.SSL`.\n\n    These are values defined by OpenSSL intended only to be used as flags to\n    OpenSSL APIs.  The only assertions it seems can be made about them is\n    their values.\n    \"\"\"\n\n    @pytest.mark.skipif(\n        OP_NO_QUERY_MTU is None,\n        reason=\"OP_NO_QUERY_MTU unavailable - OpenSSL version may be too old\",\n    )\n    def test_op_no_query_mtu(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.OP_NO_QUERY_MTU` is 0x1000, the value\n        of `SSL_OP_NO_QUERY_MTU` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert OP_NO_QUERY_MTU == 0x1000\n\n    @pytest.mark.skipif(\n        OP_COOKIE_EXCHANGE is None,\n        reason=\"OP_COOKIE_EXCHANGE unavailable - \"\n        \"OpenSSL version may be too old\",\n    )\n    def test_op_cookie_exchange(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.OP_COOKIE_EXCHANGE` is 0x2000, the\n        value of `SSL_OP_COOKIE_EXCHANGE` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert OP_COOKIE_EXCHANGE == 0x2000\n\n    @pytest.mark.skipif(\n        OP_NO_TICKET is None,\n        reason=\"OP_NO_TICKET unavailable - OpenSSL version may be too old\",\n    )\n    def test_op_no_ticket(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.OP_NO_TICKET` is 0x4000, the value of\n        `SSL_OP_NO_TICKET` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert OP_NO_TICKET == 0x4000\n\n    @pytest.mark.skipif(\n        OP_NO_COMPRESSION is None,\n        reason=(\n            \"OP_NO_COMPRESSION unavailable - OpenSSL version may be too old\"\n        ),\n    )\n    def test_op_no_compression(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.OP_NO_COMPRESSION` is 0x20000, the\n        value of `SSL_OP_NO_COMPRESSION` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert OP_NO_COMPRESSION == 0x20000\n\n    def test_sess_cache_off(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_OFF` 0x0, the value of\n        `SSL_SESS_CACHE_OFF` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert 0x0 == SESS_CACHE_OFF\n\n    def test_sess_cache_client(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_CLIENT` 0x1, the value of\n        `SSL_SESS_CACHE_CLIENT` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert 0x1 == SESS_CACHE_CLIENT\n\n    def test_sess_cache_server(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_SERVER` 0x2, the value of\n        `SSL_SESS_CACHE_SERVER` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert 0x2 == SESS_CACHE_SERVER\n\n    def test_sess_cache_both(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_BOTH` 0x3, the value of\n        `SSL_SESS_CACHE_BOTH` defined by `openssl/ssl.h`.\n        \"\"\"\n        assert 0x3 == SESS_CACHE_BOTH\n\n    def test_sess_cache_no_auto_clear(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_NO_AUTO_CLEAR` 0x80, the\n        value of `SSL_SESS_CACHE_NO_AUTO_CLEAR` defined by\n        `openssl/ssl.h`.\n        \"\"\"\n        assert 0x80 == SESS_CACHE_NO_AUTO_CLEAR\n\n    def test_sess_cache_no_internal_lookup(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_NO_INTERNAL_LOOKUP` 0x100,\n        the value of `SSL_SESS_CACHE_NO_INTERNAL_LOOKUP` defined by\n        `openssl/ssl.h`.\n        \"\"\"\n        assert 0x100 == SESS_CACHE_NO_INTERNAL_LOOKUP\n\n    def test_sess_cache_no_internal_store(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_NO_INTERNAL_STORE` 0x200,\n        the value of `SSL_SESS_CACHE_NO_INTERNAL_STORE` defined by\n        `openssl/ssl.h`.\n        \"\"\"\n        assert 0x200 == SESS_CACHE_NO_INTERNAL_STORE\n\n    def test_sess_cache_no_internal(self):\n        \"\"\"\n        The value of `OpenSSL.SSL.SESS_CACHE_NO_INTERNAL` 0x300, the\n        value of `SSL_SESS_CACHE_NO_INTERNAL` defined by\n        `openssl/ssl.h`.\n        \"\"\"\n        assert 0x300 == SESS_CACHE_NO_INTERNAL\n\n\nclass TestMemoryBIO:\n    \"\"\"\n    Tests for `OpenSSL.SSL.Connection` using a memory BIO.\n    \"\"\"\n\n    def _server(self, sock):\n        \"\"\"\n        Create a new server-side SSL `Connection` object wrapped around `sock`.\n        \"\"\"\n        # Create the server side Connection.  This is mostly setup boilerplate\n        # - use TLSv1, use a particular certificate, etc.\n        server_ctx = Context(SSLv23_METHOD)\n        server_ctx.set_options(OP_NO_SSLv2 | OP_NO_SSLv3 | OP_SINGLE_DH_USE)\n        server_ctx.set_verify(\n            VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT | VERIFY_CLIENT_ONCE,\n            verify_cb,\n        )\n        server_store = server_ctx.get_cert_store()\n        server_ctx.use_privatekey(\n            load_privatekey(FILETYPE_PEM, server_key_pem)\n        )\n        server_ctx.use_certificate(\n            load_certificate(FILETYPE_PEM, server_cert_pem)\n        )\n        server_ctx.check_privatekey()\n        server_store.add_cert(load_certificate(FILETYPE_PEM, root_cert_pem))\n        # Here the Connection is actually created.  If None is passed as the\n        # 2nd parameter, it indicates a memory BIO should be created.\n        server_conn = Connection(server_ctx, sock)\n        server_conn.set_accept_state()\n        return server_conn\n\n    def _client(self, sock):\n        \"\"\"\n        Create a new client-side SSL `Connection` object wrapped around `sock`.\n        \"\"\"\n        # Now create the client side Connection.  Similar boilerplate to the\n        # above.\n        client_ctx = Context(SSLv23_METHOD)\n        client_ctx.set_options(OP_NO_SSLv2 | OP_NO_SSLv3 | OP_SINGLE_DH_USE)\n        client_ctx.set_verify(\n            VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT | VERIFY_CLIENT_ONCE,\n            verify_cb,\n        )\n        client_store = client_ctx.get_cert_store()\n        client_ctx.use_privatekey(\n            load_privatekey(FILETYPE_PEM, client_key_pem)\n        )\n        client_ctx.use_certificate(\n            load_certificate(FILETYPE_PEM, client_cert_pem)\n        )\n        client_ctx.check_privatekey()\n        client_store.add_cert(load_certificate(FILETYPE_PEM, root_cert_pem))\n        client_conn = Connection(client_ctx, sock)\n        client_conn.set_connect_state()\n        return client_conn\n\n    def test_memory_connect(self):\n        \"\"\"\n        Two `Connection`s which use memory BIOs can be manually connected by\n        reading from the output of each and writing those bytes to the input of\n        the other and in this way establish a connection and exchange\n        application-level bytes with each other.\n        \"\"\"\n        server_conn = self._server(None)\n        client_conn = self._client(None)\n\n        # There should be no key or nonces yet.\n        assert server_conn.master_key() is None\n        assert server_conn.client_random() is None\n        assert server_conn.server_random() is None\n\n        # First, the handshake needs to happen.  We'll deliver bytes back and\n        # forth between the client and server until neither of them feels like\n        # speaking any more.\n        assert interact_in_memory(client_conn, server_conn) is None\n\n        # Now that the handshake is done, there should be a key and nonces.\n        assert server_conn.master_key() is not None\n        assert server_conn.client_random() is not None\n        assert server_conn.server_random() is not None\n        assert server_conn.client_random() == client_conn.client_random()\n        assert server_conn.server_random() == client_conn.server_random()\n        assert server_conn.client_random() != server_conn.server_random()\n        assert client_conn.client_random() != client_conn.server_random()\n\n        # Export key material for other uses.\n        cekm = client_conn.export_keying_material(b\"LABEL\", 32)\n        sekm = server_conn.export_keying_material(b\"LABEL\", 32)\n        assert cekm is not None\n        assert sekm is not None\n        assert cekm == sekm\n        assert len(sekm) == 32\n\n        # Export key material for other uses with additional context.\n        cekmc = client_conn.export_keying_material(b\"LABEL\", 32, b\"CONTEXT\")\n        sekmc = server_conn.export_keying_material(b\"LABEL\", 32, b\"CONTEXT\")\n        assert cekmc is not None\n        assert sekmc is not None\n        assert cekmc == sekmc\n        assert cekmc != cekm\n        assert sekmc != sekm\n        # Export with alternate label\n        cekmt = client_conn.export_keying_material(b\"test\", 32, b\"CONTEXT\")\n        sekmt = server_conn.export_keying_material(b\"test\", 32, b\"CONTEXT\")\n        assert cekmc != cekmt\n        assert sekmc != sekmt\n\n        # Here are the bytes we'll try to send.\n        important_message = b\"One if by land, two if by sea.\"\n\n        server_conn.write(important_message)\n        assert interact_in_memory(client_conn, server_conn) == (\n            client_conn,\n            important_message,\n        )\n\n        client_conn.write(important_message[::-1])\n        assert interact_in_memory(client_conn, server_conn) == (\n            server_conn,\n            important_message[::-1],\n        )\n\n    def test_socket_connect(self):\n        \"\"\"\n        Just like `test_memory_connect` but with an actual socket.\n\n        This is primarily to rule out the memory BIO code as the source of any\n        problems encountered while passing data over a `Connection` (if\n        this test fails, there must be a problem outside the memory BIO code,\n        as no memory BIO is involved here).  Even though this isn't a memory\n        BIO test, it's convenient to have it here.\n        \"\"\"\n        server_conn, client_conn = loopback()\n\n        important_message = b\"Help me Obi Wan Kenobi, you're my only hope.\"\n        client_conn.send(important_message)\n        msg = server_conn.recv(1024)\n        assert msg == important_message\n\n        # Again in the other direction, just for fun.\n        important_message = important_message[::-1]\n        server_conn.send(important_message)\n        msg = client_conn.recv(1024)\n        assert msg == important_message\n\n    def test_socket_overrides_memory(self):\n        \"\"\"\n        Test that `OpenSSL.SSL.bio_read` and `OpenSSL.SSL.bio_write` don't\n        work on `OpenSSL.SSL.Connection`() that use sockets.\n        \"\"\"\n        context = Context(SSLv23_METHOD)\n        client = socket_any_family()\n        clientSSL = Connection(context, client)\n        with pytest.raises(TypeError):\n            clientSSL.bio_read(100)\n        with pytest.raises(TypeError):\n            clientSSL.bio_write(b\"foo\")\n        with pytest.raises(TypeError):\n            clientSSL.bio_shutdown()\n\n    def test_outgoing_overflow(self):\n        \"\"\"\n        If more bytes than can be written to the memory BIO are passed to\n        `Connection.send` at once, the number of bytes which were written is\n        returned and that many bytes from the beginning of the input can be\n        read from the other end of the connection.\n        \"\"\"\n        server = self._server(None)\n        client = self._client(None)\n\n        interact_in_memory(client, server)\n\n        size = 2**15\n        sent = client.send(b\"x\" * size)\n        # Sanity check.  We're trying to test what happens when the entire\n        # input can't be sent.  If the entire input was sent, this test is\n        # meaningless.\n        assert sent < size\n\n        receiver, received = interact_in_memory(client, server)\n        assert receiver is server\n\n        # We can rely on all of these bytes being received at once because\n        # loopback passes 2 ** 16 to recv - more than 2 ** 15.\n        assert len(received) == sent\n\n    def test_shutdown(self):\n        \"\"\"\n        `Connection.bio_shutdown` signals the end of the data stream\n        from which the `Connection` reads.\n        \"\"\"\n        server = self._server(None)\n        server.bio_shutdown()\n        with pytest.raises(Error) as err:\n            server.recv(1024)\n        # We don't want WantReadError or ZeroReturnError or anything - it's a\n        # handshake failure.\n        assert type(err.value) in [Error, SysCallError]\n\n    def test_unexpected_EOF(self):\n        \"\"\"\n        If the connection is lost before an orderly SSL shutdown occurs,\n        `OpenSSL.SSL.SysCallError` is raised with a message of\n        \"Unexpected EOF\" (or WSAECONNRESET on Windows).\n        \"\"\"\n        server_conn, client_conn = loopback()\n        client_conn.sock_shutdown(SHUT_RDWR)\n        with pytest.raises(SysCallError) as err:\n            server_conn.recv(1024)\n        if platform == \"win32\":\n            assert err.value.args == (10054, \"WSAECONNRESET\")\n        else:\n            assert err.value.args == (-1, \"Unexpected EOF\")\n\n    def _check_client_ca_list(self, func):\n        \"\"\"\n        Verify the return value of the `get_client_ca_list` method for\n        server and client connections.\n\n        :param func: A function which will be called with the server context\n            before the client and server are connected to each other.  This\n            function should specify a list of CAs for the server to send to the\n            client and return that same list.  The list will be used to verify\n            that `get_client_ca_list` returns the proper value at\n            various times.\n        \"\"\"\n        server = self._server(None)\n        client = self._client(None)\n        assert client.get_client_ca_list() == []\n        assert server.get_client_ca_list() == []\n        ctx = server.get_context()\n        expected = func(ctx)\n        assert client.get_client_ca_list() == []\n        assert server.get_client_ca_list() == expected\n        interact_in_memory(client, server)\n        assert client.get_client_ca_list() == expected\n        assert server.get_client_ca_list() == expected\n\n    def test_set_client_ca_list_errors(self):\n        \"\"\"\n        `Context.set_client_ca_list` raises a `TypeError` if called with a\n        non-list or a list that contains objects other than X509Names.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            ctx.set_client_ca_list(\"spam\")\n        with pytest.raises(TypeError):\n            ctx.set_client_ca_list([\"spam\"])\n\n    def test_set_empty_ca_list(self):\n        \"\"\"\n        If passed an empty list, `Context.set_client_ca_list` configures the\n        context to send no CA names to the client and, on both the server and\n        client sides, `Connection.get_client_ca_list` returns an empty list\n        after the connection is set up.\n        \"\"\"\n\n        def no_ca(ctx):\n            ctx.set_client_ca_list([])\n            return []\n\n        self._check_client_ca_list(no_ca)\n\n    def test_set_one_ca_list(self):\n        \"\"\"\n        If passed a list containing a single X509Name,\n        `Context.set_client_ca_list` configures the context to send\n        that CA name to the client and, on both the server and client sides,\n        `Connection.get_client_ca_list` returns a list containing that\n        X509Name after the connection is set up.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        cadesc = cacert.get_subject()\n\n        def single_ca(ctx):\n            ctx.set_client_ca_list([cadesc])\n            return [cadesc]\n\n        self._check_client_ca_list(single_ca)\n\n    def test_set_multiple_ca_list(self):\n        \"\"\"\n        If passed a list containing multiple X509Name objects,\n        `Context.set_client_ca_list` configures the context to send\n        those CA names to the client and, on both the server and client sides,\n        `Connection.get_client_ca_list` returns a list containing those\n        X509Names after the connection is set up.\n        \"\"\"\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        clcert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        sedesc = secert.get_subject()\n        cldesc = clcert.get_subject()\n\n        def multiple_ca(ctx):\n            L = [sedesc, cldesc]\n            ctx.set_client_ca_list(L)\n            return L\n\n        self._check_client_ca_list(multiple_ca)\n\n    def test_reset_ca_list(self):\n        \"\"\"\n        If called multiple times, only the X509Names passed to the final call\n        of `Context.set_client_ca_list` are used to configure the CA\n        names sent to the client.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        clcert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        cadesc = cacert.get_subject()\n        sedesc = secert.get_subject()\n        cldesc = clcert.get_subject()\n\n        def changed_ca(ctx):\n            ctx.set_client_ca_list([sedesc, cldesc])\n            ctx.set_client_ca_list([cadesc])\n            return [cadesc]\n\n        self._check_client_ca_list(changed_ca)\n\n    def test_mutated_ca_list(self):\n        \"\"\"\n        If the list passed to `Context.set_client_ca_list` is mutated\n        afterwards, this does not affect the list of CA names sent to the\n        client.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        cadesc = cacert.get_subject()\n        sedesc = secert.get_subject()\n\n        def mutated_ca(ctx):\n            L = [cadesc]\n            ctx.set_client_ca_list([cadesc])\n            L.append(sedesc)\n            return [cadesc]\n\n        self._check_client_ca_list(mutated_ca)\n\n    def test_add_client_ca_wrong_args(self):\n        \"\"\"\n        `Context.add_client_ca` raises `TypeError` if called with\n        a non-X509 object.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        with pytest.raises(TypeError):\n            ctx.add_client_ca(\"spam\")\n\n    def test_one_add_client_ca(self):\n        \"\"\"\n        A certificate's subject can be added as a CA to be sent to the client\n        with `Context.add_client_ca`.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        cadesc = cacert.get_subject()\n\n        def single_ca(ctx):\n            ctx.add_client_ca(cacert)\n            return [cadesc]\n\n        self._check_client_ca_list(single_ca)\n\n    def test_multiple_add_client_ca(self):\n        \"\"\"\n        Multiple CA names can be sent to the client by calling\n        `Context.add_client_ca` with multiple X509 objects.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        cadesc = cacert.get_subject()\n        sedesc = secert.get_subject()\n\n        def multiple_ca(ctx):\n            ctx.add_client_ca(cacert)\n            ctx.add_client_ca(secert)\n            return [cadesc, sedesc]\n\n        self._check_client_ca_list(multiple_ca)\n\n    def test_set_and_add_client_ca(self):\n        \"\"\"\n        A call to `Context.set_client_ca_list` followed by a call to\n        `Context.add_client_ca` results in using the CA names from the\n        first call and the CA name from the second call.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        clcert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        cadesc = cacert.get_subject()\n        sedesc = secert.get_subject()\n        cldesc = clcert.get_subject()\n\n        def mixed_set_add_ca(ctx):\n            ctx.set_client_ca_list([cadesc, sedesc])\n            ctx.add_client_ca(clcert)\n            return [cadesc, sedesc, cldesc]\n\n        self._check_client_ca_list(mixed_set_add_ca)\n\n    def test_set_after_add_client_ca(self):\n        \"\"\"\n        A call to `Context.set_client_ca_list` after a call to\n        `Context.add_client_ca` replaces the CA name specified by the\n        former call with the names specified by the latter call.\n        \"\"\"\n        cacert = load_certificate(FILETYPE_PEM, root_cert_pem)\n        secert = load_certificate(FILETYPE_PEM, server_cert_pem)\n        clcert = load_certificate(FILETYPE_PEM, server_cert_pem)\n\n        cadesc = cacert.get_subject()\n        sedesc = secert.get_subject()\n\n        def set_replaces_add_ca(ctx):\n            ctx.add_client_ca(clcert)\n            ctx.set_client_ca_list([cadesc])\n            ctx.add_client_ca(secert)\n            return [cadesc, sedesc]\n\n        self._check_client_ca_list(set_replaces_add_ca)\n\n\nclass TestInfoConstants:\n    \"\"\"\n    Tests for assorted constants exposed for use in info callbacks.\n    \"\"\"\n\n    def test_integers(self):\n        \"\"\"\n        All of the info constants are integers.\n\n        This is a very weak test.  It would be nice to have one that actually\n        verifies that as certain info events happen, the value passed to the\n        info callback matches up with the constant exposed by OpenSSL.SSL.\n        \"\"\"\n        for const in [\n            SSL_ST_CONNECT,\n            SSL_ST_ACCEPT,\n            SSL_ST_MASK,\n            SSL_CB_LOOP,\n            SSL_CB_EXIT,\n            SSL_CB_READ,\n            SSL_CB_WRITE,\n            SSL_CB_ALERT,\n            SSL_CB_READ_ALERT,\n            SSL_CB_WRITE_ALERT,\n            SSL_CB_ACCEPT_LOOP,\n            SSL_CB_ACCEPT_EXIT,\n            SSL_CB_CONNECT_LOOP,\n            SSL_CB_CONNECT_EXIT,\n            SSL_CB_HANDSHAKE_START,\n            SSL_CB_HANDSHAKE_DONE,\n        ]:\n            assert isinstance(const, int)\n\n        # These constants don't exist on OpenSSL 1.1.0\n        for const in [\n            SSL_ST_INIT,\n            SSL_ST_BEFORE,\n            SSL_ST_OK,\n            SSL_ST_RENEGOTIATE,\n        ]:\n            assert const is None or isinstance(const, int)\n\n\nclass TestRequires:\n    \"\"\"\n    Tests for the decorator factory used to conditionally raise\n    NotImplementedError when older OpenSSLs are used.\n    \"\"\"\n\n    def test_available(self):\n        \"\"\"\n        When the OpenSSL functionality is available the decorated functions\n        work appropriately.\n        \"\"\"\n        feature_guard = _make_requires(True, \"Error text\")\n        results = []\n\n        @feature_guard\n        def inner():\n            results.append(True)\n            return True\n\n        assert inner() is True\n        assert [True] == results\n\n    def test_unavailable(self):\n        \"\"\"\n        When the OpenSSL functionality is not available the decorated function\n        does not execute and NotImplementedError is raised.\n        \"\"\"\n        feature_guard = _make_requires(False, \"Error text\")\n\n        @feature_guard\n        def inner():  # pragma: nocover\n            pytest.fail(\"Should not be called\")\n\n        with pytest.raises(NotImplementedError) as e:\n            inner()\n\n        assert \"Error text\" in str(e.value)\n\n\nclass TestOCSP:\n    \"\"\"\n    Tests for PyOpenSSL's OCSP stapling support.\n    \"\"\"\n\n    sample_ocsp_data = b\"this is totally ocsp data\"\n\n    def _client_connection(self, callback, data, request_ocsp=True):\n        \"\"\"\n        Builds a client connection suitable for using OCSP.\n\n        :param callback: The callback to register for OCSP.\n        :param data: The opaque data object that will be handed to the\n            OCSP callback.\n        :param request_ocsp: Whether the client will actually ask for OCSP\n            stapling. Useful for testing only.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        ctx.set_ocsp_client_callback(callback, data)\n        client = Connection(ctx)\n\n        if request_ocsp:\n            client.request_ocsp()\n\n        client.set_connect_state()\n        return client\n\n    def _server_connection(self, callback, data):\n        \"\"\"\n        Builds a server connection suitable for using OCSP.\n\n        :param callback: The callback to register for OCSP.\n        :param data: The opaque data object that will be handed to the\n            OCSP callback.\n        \"\"\"\n        ctx = Context(SSLv23_METHOD)\n        ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n        ctx.set_ocsp_server_callback(callback, data)\n        server = Connection(ctx)\n        server.set_accept_state()\n        return server\n\n    def test_callbacks_arent_called_by_default(self):\n        \"\"\"\n        If both the client and the server have registered OCSP callbacks, but\n        the client does not send the OCSP request, neither callback gets\n        called.\n        \"\"\"\n\n        def ocsp_callback(*args, **kwargs):  # pragma: nocover\n            pytest.fail(\"Should not be called\")\n\n        client = self._client_connection(\n            callback=ocsp_callback, data=None, request_ocsp=False\n        )\n        server = self._server_connection(callback=ocsp_callback, data=None)\n        handshake_in_memory(client, server)\n\n    def test_client_negotiates_without_server(self):\n        \"\"\"\n        If the client wants to do OCSP but the server does not, the handshake\n        succeeds, and the client callback fires with an empty byte string.\n        \"\"\"\n        called = []\n\n        def ocsp_callback(conn, ocsp_data, ignored):\n            called.append(ocsp_data)\n            return True\n\n        client = self._client_connection(callback=ocsp_callback, data=None)\n        server = loopback_server_factory(socket=None)\n        handshake_in_memory(client, server)\n\n        assert len(called) == 1\n        assert called[0] == b\"\"\n\n    def test_client_receives_servers_data(self):\n        \"\"\"\n        The data the server sends in its callback is received by the client.\n        \"\"\"\n        calls = []\n\n        def server_callback(*args, **kwargs):\n            return self.sample_ocsp_data\n\n        def client_callback(conn, ocsp_data, ignored):\n            calls.append(ocsp_data)\n            return True\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n        handshake_in_memory(client, server)\n\n        assert len(calls) == 1\n        assert calls[0] == self.sample_ocsp_data\n\n    def test_callbacks_are_invoked_with_connections(self):\n        \"\"\"\n        The first arguments to both callbacks are their respective connections.\n        \"\"\"\n        client_calls = []\n        server_calls = []\n\n        def client_callback(conn, *args, **kwargs):\n            client_calls.append(conn)\n            return True\n\n        def server_callback(conn, *args, **kwargs):\n            server_calls.append(conn)\n            return self.sample_ocsp_data\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n        handshake_in_memory(client, server)\n\n        assert len(client_calls) == 1\n        assert len(server_calls) == 1\n        assert client_calls[0] is client\n        assert server_calls[0] is server\n\n    def test_opaque_data_is_passed_through(self):\n        \"\"\"\n        Both callbacks receive an opaque, user-provided piece of data in their\n        callbacks as the final argument.\n        \"\"\"\n        calls = []\n\n        def server_callback(*args):\n            calls.append(args)\n            return self.sample_ocsp_data\n\n        def client_callback(*args):\n            calls.append(args)\n            return True\n\n        sentinel = object()\n\n        client = self._client_connection(\n            callback=client_callback, data=sentinel\n        )\n        server = self._server_connection(\n            callback=server_callback, data=sentinel\n        )\n        handshake_in_memory(client, server)\n\n        assert len(calls) == 2\n        assert calls[0][-1] is sentinel\n        assert calls[1][-1] is sentinel\n\n    def test_server_returns_empty_string(self):\n        \"\"\"\n        If the server returns an empty bytestring from its callback, the\n        client callback is called with the empty bytestring.\n        \"\"\"\n        client_calls = []\n\n        def server_callback(*args):\n            return b\"\"\n\n        def client_callback(conn, ocsp_data, ignored):\n            client_calls.append(ocsp_data)\n            return True\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n        handshake_in_memory(client, server)\n\n        assert len(client_calls) == 1\n        assert client_calls[0] == b\"\"\n\n    def test_client_returns_false_terminates_handshake(self):\n        \"\"\"\n        If the client returns False from its callback, the handshake fails.\n        \"\"\"\n\n        def server_callback(*args):\n            return self.sample_ocsp_data\n\n        def client_callback(*args):\n            return False\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n\n        with pytest.raises(Error):\n            handshake_in_memory(client, server)\n\n    def test_exceptions_in_client_bubble_up(self):\n        \"\"\"\n        The callbacks thrown in the client callback bubble up to the caller.\n        \"\"\"\n\n        class SentinelException(Exception):\n            pass\n\n        def server_callback(*args):\n            return self.sample_ocsp_data\n\n        def client_callback(*args):\n            raise SentinelException()\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n\n        with pytest.raises(SentinelException):\n            handshake_in_memory(client, server)\n\n    def test_exceptions_in_server_bubble_up(self):\n        \"\"\"\n        The callbacks thrown in the server callback bubble up to the caller.\n        \"\"\"\n\n        class SentinelException(Exception):\n            pass\n\n        def server_callback(*args):\n            raise SentinelException()\n\n        def client_callback(*args):  # pragma: nocover\n            pytest.fail(\"Should not be called\")\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n\n        with pytest.raises(SentinelException):\n            handshake_in_memory(client, server)\n\n    def test_server_must_return_bytes(self):\n        \"\"\"\n        The server callback must return a bytestring, or a TypeError is thrown.\n        \"\"\"\n\n        def server_callback(*args):\n            return self.sample_ocsp_data.decode(\"ascii\")\n\n        def client_callback(*args):  # pragma: nocover\n            pytest.fail(\"Should not be called\")\n\n        client = self._client_connection(callback=client_callback, data=None)\n        server = self._server_connection(callback=server_callback, data=None)\n\n        with pytest.raises(TypeError):\n            handshake_in_memory(client, server)\n\n\nclass TestDTLS:\n    # The way you would expect DTLSv1_listen to work is:\n    #\n    # - it reads packets in a loop\n    # - when it finds a valid ClientHello, it returns\n    # - now the handshake can proceed\n    #\n    # However, on older versions of OpenSSL, it did something \"cleverer\". The\n    # way it worked is:\n    #\n    # - it \"peeks\" into the BIO to see the next packet without consuming it\n    # - if *not* a valid ClientHello, then it reads the packet to consume it\n    #   and loops around\n    # - if it *is* a valid ClientHello, it *leaves the packet in the BIO*, and\n    #   returns\n    # - then the handshake finds the ClientHello in the BIO and reads it a\n    #   second time.\n    #\n    # I'm not sure exactly when this switched over. The OpenSSL v1.1.1 in\n    # Ubuntu 18.04 has the old behavior. The OpenSSL v1.1.1 in Ubuntu 20.04 has\n    # the new behavior. There doesn't seem to be any mention of this change in\n    # the OpenSSL v1.1.1 changelog, but presumably it changed in some point\n    # release or another. Presumably in 2025 or so there will be only new\n    # OpenSSLs around we can delete this whole comment and the weird\n    # workaround. If anyone is still using this library by then, which seems\n    # both depressing and inevitable.\n    #\n    # Anyway, why do we care? The reason is that the old strategy has a\n    # problem: the \"peek\" operation is only defined on \"DGRAM BIOs\", which are\n    # a special type of object that is different from the more familiar \"socket\n    # BIOs\" and \"memory BIOs\". If you *don't* have a DGRAM BIO, and you try to\n    # peek into the BIO... then it silently degrades to a full-fledged \"read\"\n    # operation that consumes the packet. Which is a problem if your algorithm\n    # depends on leaving the packet in the BIO to be read again later.\n    #\n    # So on old OpenSSL, we have a problem:\n    #\n    # - we can't use a DGRAM BIO, because cryptography/pyopenssl don't wrap the\n    #   relevant APIs, nor should they.\n    #\n    # - if we use a socket BIO, then the first time DTLSv1_listen sees an\n    #   invalid packet (like for example... the challenge packet that *every\n    #   DTLS handshake starts with before the real ClientHello!*), it tries to\n    #   first \"peek\" it, and then \"read\" it. But since the first \"peek\"\n    #   consumes the packet, the second \"read\" ends up hanging or consuming\n    #   some unrelated packet, which is undesirable. So you can't even get to\n    #   the handshake stage successfully.\n    #\n    # - if we use a memory BIO, then DTLSv1_listen works OK on invalid packets\n    #   -- first the \"peek\" consumes them, and then it tries to \"read\" again to\n    #   consume them, which fails immediately, and OpenSSL ignores the failure.\n    #   So it works by accident. BUT, when we get a valid ClientHello, we have\n    #   a problem: DTLSv1_listen tries to \"peek\" it and then leave it in the\n    #   read BIO for do_handshake to consume. But instead \"peek\" consumes the\n    #   packet, so it's not there where do_handshake is expecting it, and the\n    #   handshake fails.\n    #\n    # Fortunately (if that's the word), we can work around the memory BIO\n    # problem. (Which is good, because in real life probably all our users will\n    # be using memory BIOs.) All we have to do is to save the valid ClientHello\n    # before calling DTLSv1_listen, and then after it returns we push *a second\n    # copy of it* of the packet memory BIO before calling do_handshake. This\n    # fakes out OpenSSL and makes it think the \"peek\" operation worked\n    # correctly, and we can go on with our lives.\n    #\n    # In fact, we push the second copy of the ClientHello unconditionally. On\n    # new versions of OpenSSL, this is unnecessary, but harmless, because the\n    # DTLS state machine treats it like a network hiccup that duplicated a\n    # packet, which DTLS is robust against.\n\n    # Arbitrary number larger than any conceivable handshake volley.\n    LARGE_BUFFER = 65536\n\n    def _test_handshake_and_data(self, srtp_profile):\n        s_ctx = Context(DTLS_METHOD)\n\n        def generate_cookie(ssl):\n            return b\"xyzzy\"\n\n        def verify_cookie(ssl, cookie):\n            return cookie == b\"xyzzy\"\n\n        s_ctx.set_cookie_generate_callback(generate_cookie)\n        s_ctx.set_cookie_verify_callback(verify_cookie)\n        s_ctx.use_privatekey(load_privatekey(FILETYPE_PEM, server_key_pem))\n        s_ctx.use_certificate(load_certificate(FILETYPE_PEM, server_cert_pem))\n        s_ctx.set_options(OP_NO_QUERY_MTU)\n        if srtp_profile is not None:\n            s_ctx.set_tlsext_use_srtp(srtp_profile)\n        s = Connection(s_ctx)\n        s.set_accept_state()\n\n        c_ctx = Context(DTLS_METHOD)\n        c_ctx.set_options(OP_NO_QUERY_MTU)\n        if srtp_profile is not None:\n            c_ctx.set_tlsext_use_srtp(srtp_profile)\n        c = Connection(c_ctx)\n        c.set_connect_state()\n\n        # These are mandatory, because openssl can't guess the MTU for a memory\n        # bio and will produce a mysterious error if you make it try.\n        c.set_ciphertext_mtu(1500)\n        s.set_ciphertext_mtu(1500)\n\n        latest_client_hello = None\n\n        def pump_membio(label, source, sink):\n            try:\n                chunk = source.bio_read(self.LARGE_BUFFER)\n            except WantReadError:\n                return False\n            # I'm not sure this check is needed, but I'm not sure it's *not*\n            # needed either:\n            if not chunk:  # pragma: no cover\n                return False\n            # Gross hack: if this is a ClientHello, save it so we can find it\n            # later. See giant comment above.\n            try:\n                # if ContentType == handshake and HandshakeType ==\n                # client_hello:\n                if chunk[0] == 22 and chunk[13] == 1:\n                    nonlocal latest_client_hello\n                    latest_client_hello = chunk\n            except IndexError:  # pragma: no cover\n                pass\n            print(f\"{label}: {chunk.hex()}\")\n            sink.bio_write(chunk)\n            return True\n\n        def pump():\n            # Raises if there was no data to pump, to avoid infinite loops if\n            # we aren't making progress.\n            assert pump_membio(\"s -> c\", s, c) or pump_membio(\"c -> s\", c, s)\n\n        c_handshaking = True\n        s_listening = True\n        s_handshaking = False\n        first = True\n        while c_handshaking or s_listening or s_handshaking:\n            if not first:\n                pump()\n            first = False\n\n            if c_handshaking:\n                try:\n                    c.do_handshake()\n                except WantReadError:\n                    pass\n                else:\n                    c_handshaking = False\n\n            if s_listening:\n                try:\n                    s.DTLSv1_listen()\n                except WantReadError:\n                    pass\n                else:\n                    s_listening = False\n                    s_handshaking = True\n                    # Write the duplicate ClientHello. See giant comment above.\n                    s.bio_write(latest_client_hello)\n\n            if s_handshaking:\n                try:\n                    s.do_handshake()\n                except WantReadError:\n                    pass\n                else:\n                    s_handshaking = False\n\n        s.write(b\"hello\")\n        pump()\n        assert c.read(100) == b\"hello\"\n        c.write(b\"goodbye\")\n        pump()\n        assert s.read(100) == b\"goodbye\"\n\n        # Check whether SRTP was negotiated\n        if srtp_profile is not None:\n            assert s.get_selected_srtp_profile() == srtp_profile\n            assert c.get_selected_srtp_profile() == srtp_profile\n        else:\n            assert s.get_selected_srtp_profile() == b\"\"\n            assert c.get_selected_srtp_profile() == b\"\"\n\n        # Check that the MTU set/query functions are doing *something*\n        c.set_ciphertext_mtu(1000)\n        try:\n            assert 500 < c.get_cleartext_mtu() < 1000\n        except NotImplementedError:  # OpenSSL 1.1.0 and earlier\n            pass\n        c.set_ciphertext_mtu(500)\n        try:\n            assert 0 < c.get_cleartext_mtu() < 500\n        except NotImplementedError:  # OpenSSL 1.1.0 and earlier\n            pass\n\n    def test_it_works_at_all(self):\n        self._test_handshake_and_data(srtp_profile=None)\n\n    def test_it_works_with_srtp(self):\n        self._test_handshake_and_data(srtp_profile=b\"SRTP_AES128_CM_SHA1_80\")\n\n    def test_timeout(self, monkeypatch):\n        c_ctx = Context(DTLS_METHOD)\n        c = Connection(c_ctx)\n\n        # No timeout before the handshake starts.\n        assert c.DTLSv1_get_timeout() is None\n        assert c.DTLSv1_handle_timeout() is False\n\n        # Start handshake and check there is data to send.\n        c.set_connect_state()\n        try:\n            c.do_handshake()\n        except SSL.WantReadError:\n            pass\n        assert c.bio_read(self.LARGE_BUFFER)\n\n        # There should now be an active timeout.\n        seconds = c.DTLSv1_get_timeout()\n        assert seconds is not None\n\n        # Handle the timeout and check there is data to send.\n        time.sleep(seconds)\n        assert c.DTLSv1_handle_timeout() is True\n        assert c.bio_read(self.LARGE_BUFFER)\n\n        # After the maximum number of allowed timeouts is reached,\n        # DTLSv1_handle_timeout will return -1.\n        #\n        # Testing this directly is prohibitively time consuming as the timeout\n        # duration is doubled on each retry, so the best we can do is to mock\n        # this condition.\n        monkeypatch.setattr(_lib, \"DTLSv1_handle_timeout\", lambda x: -1)\n\n        with pytest.raises(Error):\n            c.DTLSv1_handle_timeout()\n", "tests/__init__.py": "# Copyright (C) Jean-Paul Calderone\n# See LICENSE for details.\n\n\"\"\"\nPackage containing unit tests for :py:mod:`OpenSSL`.\n\"\"\"\n", "src/OpenSSL/debug.py": "import ssl\nimport sys\n\nimport cffi\nimport cryptography\n\nimport OpenSSL.SSL\n\nfrom . import version\n\n_env_info = \"\"\"\\\npyOpenSSL: {pyopenssl}\ncryptography: {cryptography}\ncffi: {cffi}\ncryptography's compiled against OpenSSL: {crypto_openssl_compile}\ncryptography's linked OpenSSL: {crypto_openssl_link}\nPython's OpenSSL: {python_openssl}\nPython executable: {python}\nPython version: {python_version}\nPlatform: {platform}\nsys.path: {sys_path}\"\"\".format(\n    pyopenssl=version.__version__,\n    crypto_openssl_compile=OpenSSL._util.ffi.string(\n        OpenSSL._util.lib.OPENSSL_VERSION_TEXT,\n    ).decode(\"ascii\"),\n    crypto_openssl_link=OpenSSL.SSL.SSLeay_version(\n        OpenSSL.SSL.SSLEAY_VERSION\n    ).decode(\"ascii\"),\n    python_openssl=getattr(ssl, \"OPENSSL_VERSION\", \"n/a\"),\n    cryptography=cryptography.__version__,\n    cffi=cffi.__version__,\n    python=sys.executable,\n    python_version=sys.version,\n    platform=sys.platform,\n    sys_path=sys.path,\n)\n\n\nif __name__ == \"__main__\":\n    print(_env_info)\n", "src/OpenSSL/version.py": "# Copyright (C) AB Strakt\n# Copyright (C) Jean-Paul Calderone\n# See LICENSE for details.\n\n\"\"\"\npyOpenSSL - A simple wrapper around the OpenSSL library\n\"\"\"\n\n__all__ = [\n    \"__author__\",\n    \"__copyright__\",\n    \"__email__\",\n    \"__license__\",\n    \"__summary__\",\n    \"__title__\",\n    \"__uri__\",\n    \"__version__\",\n]\n\n__version__ = \"24.1.0\"\n\n__title__ = \"pyOpenSSL\"\n__uri__ = \"https://pyopenssl.org/\"\n__summary__ = \"Python wrapper module around the OpenSSL library\"\n__author__ = \"The pyOpenSSL developers\"\n__email__ = \"cryptography-dev@python.org\"\n__license__ = \"Apache License, Version 2.0\"\n__copyright__ = f\"Copyright 2001-2024 {__author__}\"\n", "src/OpenSSL/rand.py": "\"\"\"\nPRNG management routines, thin wrappers.\n\"\"\"\n\nfrom OpenSSL._util import lib as _lib\n\n\ndef add(buffer: bytes, entropy: int) -> None:\n    \"\"\"\n    Mix bytes from *string* into the PRNG state.\n\n    The *entropy* argument is (the lower bound of) an estimate of how much\n    randomness is contained in *string*, measured in bytes.\n\n    For more information, see e.g. :rfc:`1750`.\n\n    This function is only relevant if you are forking Python processes and\n    need to reseed the CSPRNG after fork.\n\n    :param buffer: Buffer with random data.\n    :param entropy: The entropy (in bytes) measurement of the buffer.\n\n    :return: :obj:`None`\n    \"\"\"\n    if not isinstance(buffer, bytes):\n        raise TypeError(\"buffer must be a byte string\")\n\n    if not isinstance(entropy, int):\n        raise TypeError(\"entropy must be an integer\")\n\n    _lib.RAND_add(buffer, len(buffer), entropy)\n\n\ndef status() -> int:\n    \"\"\"\n    Check whether the PRNG has been seeded with enough data.\n\n    :return: 1 if the PRNG is seeded enough, 0 otherwise.\n    \"\"\"\n    return _lib.RAND_status()\n", "src/OpenSSL/crypto.py": "import calendar\nimport datetime\nimport functools\nimport typing\nfrom base64 import b16encode\nfrom functools import partial\nfrom os import PathLike\nfrom typing import (\n    Any,\n    Callable,\n    Iterable,\n    List,\n    NoReturn,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    Union,\n)\n\nfrom cryptography import utils, x509\nfrom cryptography.hazmat.primitives.asymmetric import (\n    dsa,\n    ec,\n    ed448,\n    ed25519,\n    rsa,\n)\n\nfrom OpenSSL._util import (\n    UNSPECIFIED as _UNSPECIFIED,\n)\nfrom OpenSSL._util import (\n    byte_string as _byte_string,\n)\nfrom OpenSSL._util import (\n    exception_from_error_queue as _exception_from_error_queue,\n)\nfrom OpenSSL._util import (\n    ffi as _ffi,\n)\nfrom OpenSSL._util import (\n    lib as _lib,\n)\nfrom OpenSSL._util import (\n    make_assert as _make_assert,\n)\nfrom OpenSSL._util import (\n    path_bytes as _path_bytes,\n)\nfrom OpenSSL._util import (\n    text_to_bytes_and_warn as _text_to_bytes_and_warn,\n)\n\n__all__ = [\n    \"FILETYPE_PEM\",\n    \"FILETYPE_ASN1\",\n    \"FILETYPE_TEXT\",\n    \"TYPE_RSA\",\n    \"TYPE_DSA\",\n    \"Error\",\n    \"PKey\",\n    \"get_elliptic_curves\",\n    \"get_elliptic_curve\",\n    \"X509Name\",\n    \"X509Extension\",\n    \"X509Req\",\n    \"X509\",\n    \"X509StoreFlags\",\n    \"X509Store\",\n    \"X509StoreContextError\",\n    \"X509StoreContext\",\n    \"load_certificate\",\n    \"dump_certificate\",\n    \"dump_publickey\",\n    \"dump_privatekey\",\n    \"Revoked\",\n    \"CRL\",\n    \"load_publickey\",\n    \"load_privatekey\",\n    \"dump_certificate_request\",\n    \"load_certificate_request\",\n    \"sign\",\n    \"verify\",\n    \"dump_crl\",\n    \"load_crl\",\n]\n\n\n_Key = Union[\n    dsa.DSAPrivateKey,\n    dsa.DSAPublicKey,\n    ec.EllipticCurvePrivateKey,\n    ec.EllipticCurvePublicKey,\n    ed25519.Ed25519PrivateKey,\n    ed25519.Ed25519PublicKey,\n    ed448.Ed448PrivateKey,\n    ed448.Ed448PublicKey,\n    rsa.RSAPrivateKey,\n    rsa.RSAPublicKey,\n]\nStrOrBytesPath = Union[str, bytes, PathLike]\nPassphraseCallableT = Union[bytes, Callable[..., bytes]]\n\n\nFILETYPE_PEM: int = _lib.SSL_FILETYPE_PEM\nFILETYPE_ASN1: int = _lib.SSL_FILETYPE_ASN1\n\n# TODO This was an API mistake.  OpenSSL has no such constant.\nFILETYPE_TEXT = 2**16 - 1\n\nTYPE_RSA: int = _lib.EVP_PKEY_RSA\nTYPE_DSA: int = _lib.EVP_PKEY_DSA\nTYPE_DH: int = _lib.EVP_PKEY_DH\nTYPE_EC: int = _lib.EVP_PKEY_EC\n\n\nclass Error(Exception):\n    \"\"\"\n    An error occurred in an `OpenSSL.crypto` API.\n    \"\"\"\n\n\n_raise_current_error = partial(_exception_from_error_queue, Error)\n_openssl_assert = _make_assert(Error)\n\n\ndef _untested_error(where: str) -> NoReturn:\n    \"\"\"\n    An OpenSSL API failed somehow.  Additionally, the failure which was\n    encountered isn't one that's exercised by the test suite so future behavior\n    of pyOpenSSL is now somewhat less predictable.\n    \"\"\"\n    raise RuntimeError(f\"Unknown {where} failure\")\n\n\ndef _new_mem_buf(buffer: Optional[bytes] = None) -> Any:\n    \"\"\"\n    Allocate a new OpenSSL memory BIO.\n\n    Arrange for the garbage collector to clean it up automatically.\n\n    :param buffer: None or some bytes to use to put into the BIO so that they\n        can be read out.\n    \"\"\"\n    if buffer is None:\n        bio = _lib.BIO_new(_lib.BIO_s_mem())\n        free = _lib.BIO_free\n    else:\n        data = _ffi.new(\"char[]\", buffer)\n        bio = _lib.BIO_new_mem_buf(data, len(buffer))\n\n        # Keep the memory alive as long as the bio is alive!\n        def free(bio: Any, ref: Any = data) -> Any:\n            return _lib.BIO_free(bio)\n\n    _openssl_assert(bio != _ffi.NULL)\n\n    bio = _ffi.gc(bio, free)\n    return bio\n\n\ndef _bio_to_string(bio: Any) -> bytes:\n    \"\"\"\n    Copy the contents of an OpenSSL BIO object into a Python byte string.\n    \"\"\"\n    result_buffer = _ffi.new(\"char**\")\n    buffer_length = _lib.BIO_get_mem_data(bio, result_buffer)\n    return _ffi.buffer(result_buffer[0], buffer_length)[:]\n\n\ndef _set_asn1_time(boundary: Any, when: bytes) -> None:\n    \"\"\"\n    The the time value of an ASN1 time object.\n\n    @param boundary: An ASN1_TIME pointer (or an object safely\n        castable to that type) which will have its value set.\n    @param when: A string representation of the desired time value.\n\n    @raise TypeError: If C{when} is not a L{bytes} string.\n    @raise ValueError: If C{when} does not represent a time in the required\n        format.\n    @raise RuntimeError: If the time value cannot be set for some other\n        (unspecified) reason.\n    \"\"\"\n    if not isinstance(when, bytes):\n        raise TypeError(\"when must be a byte string\")\n    # ASN1_TIME_set_string validates the string without writing anything\n    # when the destination is NULL.\n    _openssl_assert(boundary != _ffi.NULL)\n\n    set_result = _lib.ASN1_TIME_set_string(boundary, when)\n    if set_result == 0:\n        raise ValueError(\"Invalid string\")\n\n\ndef _new_asn1_time(when: bytes) -> Any:\n    \"\"\"\n    Behaves like _set_asn1_time but returns a new ASN1_TIME object.\n\n    @param when: A string representation of the desired time value.\n\n    @raise TypeError: If C{when} is not a L{bytes} string.\n    @raise ValueError: If C{when} does not represent a time in the required\n        format.\n    @raise RuntimeError: If the time value cannot be set for some other\n        (unspecified) reason.\n    \"\"\"\n    ret = _lib.ASN1_TIME_new()\n    _openssl_assert(ret != _ffi.NULL)\n    ret = _ffi.gc(ret, _lib.ASN1_TIME_free)\n    _set_asn1_time(ret, when)\n    return ret\n\n\ndef _get_asn1_time(timestamp: Any) -> Optional[bytes]:\n    \"\"\"\n    Retrieve the time value of an ASN1 time object.\n\n    @param timestamp: An ASN1_GENERALIZEDTIME* (or an object safely castable to\n        that type) from which the time value will be retrieved.\n\n    @return: The time value from C{timestamp} as a L{bytes} string in a certain\n        format.  Or C{None} if the object contains no time value.\n    \"\"\"\n    string_timestamp = _ffi.cast(\"ASN1_STRING*\", timestamp)\n    if _lib.ASN1_STRING_length(string_timestamp) == 0:\n        return None\n    elif (\n        _lib.ASN1_STRING_type(string_timestamp) == _lib.V_ASN1_GENERALIZEDTIME\n    ):\n        return _ffi.string(_lib.ASN1_STRING_get0_data(string_timestamp))\n    else:\n        generalized_timestamp = _ffi.new(\"ASN1_GENERALIZEDTIME**\")\n        _lib.ASN1_TIME_to_generalizedtime(timestamp, generalized_timestamp)\n        if generalized_timestamp[0] == _ffi.NULL:\n            # This may happen:\n            #   - if timestamp was not an ASN1_TIME\n            #   - if allocating memory for the ASN1_GENERALIZEDTIME failed\n            #   - if a copy of the time data from timestamp cannot be made for\n            #     the newly allocated ASN1_GENERALIZEDTIME\n            #\n            # These are difficult to test.  cffi enforces the ASN1_TIME type.\n            # Memory allocation failures are a pain to trigger\n            # deterministically.\n            _untested_error(\"ASN1_TIME_to_generalizedtime\")\n        else:\n            string_timestamp = _ffi.cast(\n                \"ASN1_STRING*\", generalized_timestamp[0]\n            )\n            string_data = _lib.ASN1_STRING_get0_data(string_timestamp)\n            string_result = _ffi.string(string_data)\n            _lib.ASN1_GENERALIZEDTIME_free(generalized_timestamp[0])\n            return string_result\n\n\nclass _X509NameInvalidator:\n    def __init__(self) -> None:\n        self._names: List[X509Name] = []\n\n    def add(self, name: \"X509Name\") -> None:\n        self._names.append(name)\n\n    def clear(self) -> None:\n        for name in self._names:\n            # Breaks the object, but also prevents UAF!\n            del name._name\n\n\nclass PKey:\n    \"\"\"\n    A class representing an DSA or RSA public key or key pair.\n    \"\"\"\n\n    _only_public = False\n    _initialized = True\n\n    def __init__(self) -> None:\n        pkey = _lib.EVP_PKEY_new()\n        self._pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)\n        self._initialized = False\n\n    def to_cryptography_key(self) -> _Key:\n        \"\"\"\n        Export as a ``cryptography`` key.\n\n        :rtype: One of ``cryptography``'s `key interfaces`_.\n\n        .. _key interfaces: https://cryptography.io/en/latest/hazmat/\\\n            primitives/asymmetric/rsa/#key-interfaces\n\n        .. versionadded:: 16.1.0\n        \"\"\"\n        from cryptography.hazmat.primitives.serialization import (\n            load_der_private_key,\n            load_der_public_key,\n        )\n\n        if self._only_public:\n            der = dump_publickey(FILETYPE_ASN1, self)\n            return load_der_public_key(der)\n        else:\n            der = dump_privatekey(FILETYPE_ASN1, self)\n            return load_der_private_key(der, None)\n\n    @classmethod\n    def from_cryptography_key(cls, crypto_key: _Key) -> \"PKey\":\n        \"\"\"\n        Construct based on a ``cryptography`` *crypto_key*.\n\n        :param crypto_key: A ``cryptography`` key.\n        :type crypto_key: One of ``cryptography``'s `key interfaces`_.\n\n        :rtype: PKey\n\n        .. versionadded:: 16.1.0\n        \"\"\"\n        if not isinstance(\n            crypto_key,\n            (\n                dsa.DSAPrivateKey,\n                dsa.DSAPublicKey,\n                ec.EllipticCurvePrivateKey,\n                ec.EllipticCurvePublicKey,\n                ed25519.Ed25519PrivateKey,\n                ed25519.Ed25519PublicKey,\n                ed448.Ed448PrivateKey,\n                ed448.Ed448PublicKey,\n                rsa.RSAPrivateKey,\n                rsa.RSAPublicKey,\n            ),\n        ):\n            raise TypeError(\"Unsupported key type\")\n\n        from cryptography.hazmat.primitives.serialization import (\n            Encoding,\n            NoEncryption,\n            PrivateFormat,\n            PublicFormat,\n        )\n\n        if isinstance(\n            crypto_key,\n            (\n                dsa.DSAPublicKey,\n                ec.EllipticCurvePublicKey,\n                ed25519.Ed25519PublicKey,\n                ed448.Ed448PublicKey,\n                rsa.RSAPublicKey,\n            ),\n        ):\n            return load_publickey(\n                FILETYPE_ASN1,\n                crypto_key.public_bytes(\n                    Encoding.DER, PublicFormat.SubjectPublicKeyInfo\n                ),\n            )\n        else:\n            der = crypto_key.private_bytes(\n                Encoding.DER, PrivateFormat.PKCS8, NoEncryption()\n            )\n            return load_privatekey(FILETYPE_ASN1, der)\n\n    def generate_key(self, type: int, bits: int) -> None:\n        \"\"\"\n        Generate a key pair of the given type, with the given number of bits.\n\n        This generates a key \"into\" the this object.\n\n        :param type: The key type.\n        :type type: :py:data:`TYPE_RSA` or :py:data:`TYPE_DSA`\n        :param bits: The number of bits.\n        :type bits: :py:data:`int` ``>= 0``\n        :raises TypeError: If :py:data:`type` or :py:data:`bits` isn't\n            of the appropriate type.\n        :raises ValueError: If the number of bits isn't an integer of\n            the appropriate size.\n        :return: ``None``\n        \"\"\"\n        if not isinstance(type, int):\n            raise TypeError(\"type must be an integer\")\n\n        if not isinstance(bits, int):\n            raise TypeError(\"bits must be an integer\")\n\n        if type == TYPE_RSA:\n            if bits <= 0:\n                raise ValueError(\"Invalid number of bits\")\n\n            # TODO Check error return\n            exponent = _lib.BN_new()\n            exponent = _ffi.gc(exponent, _lib.BN_free)\n            _lib.BN_set_word(exponent, _lib.RSA_F4)\n\n            rsa = _lib.RSA_new()\n\n            result = _lib.RSA_generate_key_ex(rsa, bits, exponent, _ffi.NULL)\n            _openssl_assert(result == 1)\n\n            result = _lib.EVP_PKEY_assign_RSA(self._pkey, rsa)\n            _openssl_assert(result == 1)\n\n        elif type == TYPE_DSA:\n            dsa = _lib.DSA_new()\n            _openssl_assert(dsa != _ffi.NULL)\n\n            dsa = _ffi.gc(dsa, _lib.DSA_free)\n            res = _lib.DSA_generate_parameters_ex(\n                dsa, bits, _ffi.NULL, 0, _ffi.NULL, _ffi.NULL, _ffi.NULL\n            )\n            _openssl_assert(res == 1)\n\n            _openssl_assert(_lib.DSA_generate_key(dsa) == 1)\n            _openssl_assert(_lib.EVP_PKEY_set1_DSA(self._pkey, dsa) == 1)\n        else:\n            raise Error(\"No such key type\")\n\n        self._initialized = True\n\n    def check(self) -> bool:\n        \"\"\"\n        Check the consistency of an RSA private key.\n\n        This is the Python equivalent of OpenSSL's ``RSA_check_key``.\n\n        :return: ``True`` if key is consistent.\n\n        :raise OpenSSL.crypto.Error: if the key is inconsistent.\n\n        :raise TypeError: if the key is of a type which cannot be checked.\n            Only RSA keys can currently be checked.\n        \"\"\"\n        if self._only_public:\n            raise TypeError(\"public key only\")\n\n        if _lib.EVP_PKEY_type(self.type()) != _lib.EVP_PKEY_RSA:\n            raise TypeError(\"Only RSA keys can currently be checked.\")\n\n        rsa = _lib.EVP_PKEY_get1_RSA(self._pkey)\n        rsa = _ffi.gc(rsa, _lib.RSA_free)\n        result = _lib.RSA_check_key(rsa)\n        if result == 1:\n            return True\n        _raise_current_error()\n\n    def type(self) -> int:\n        \"\"\"\n        Returns the type of the key\n\n        :return: The type of the key.\n        \"\"\"\n        return _lib.EVP_PKEY_id(self._pkey)\n\n    def bits(self) -> int:\n        \"\"\"\n        Returns the number of bits of the key\n\n        :return: The number of bits of the key.\n        \"\"\"\n        return _lib.EVP_PKEY_bits(self._pkey)\n\n\nclass _EllipticCurve:\n    \"\"\"\n    A representation of a supported elliptic curve.\n\n    @cvar _curves: :py:obj:`None` until an attempt is made to load the curves.\n        Thereafter, a :py:type:`set` containing :py:type:`_EllipticCurve`\n        instances each of which represents one curve supported by the system.\n    @type _curves: :py:type:`NoneType` or :py:type:`set`\n    \"\"\"\n\n    _curves = None\n\n    def __ne__(self, other: Any) -> bool:\n        \"\"\"\n        Implement cooperation with the right-hand side argument of ``!=``.\n\n        Python 3 seems to have dropped this cooperation in this very narrow\n        circumstance.\n        \"\"\"\n        if isinstance(other, _EllipticCurve):\n            return super().__ne__(other)\n        return NotImplemented\n\n    @classmethod\n    def _load_elliptic_curves(cls, lib: Any) -> Set[\"_EllipticCurve\"]:\n        \"\"\"\n        Get the curves supported by OpenSSL.\n\n        :param lib: The OpenSSL library binding object.\n\n        :return: A :py:type:`set` of ``cls`` instances giving the names of the\n            elliptic curves the underlying library supports.\n        \"\"\"\n        num_curves = lib.EC_get_builtin_curves(_ffi.NULL, 0)\n        builtin_curves = _ffi.new(\"EC_builtin_curve[]\", num_curves)\n        # The return value on this call should be num_curves again.  We\n        # could check it to make sure but if it *isn't* then.. what could\n        # we do? Abort the whole process, I suppose...?  -exarkun\n        lib.EC_get_builtin_curves(builtin_curves, num_curves)\n        return set(cls.from_nid(lib, c.nid) for c in builtin_curves)\n\n    @classmethod\n    def _get_elliptic_curves(cls, lib: Any) -> Set[\"_EllipticCurve\"]:\n        \"\"\"\n        Get, cache, and return the curves supported by OpenSSL.\n\n        :param lib: The OpenSSL library binding object.\n\n        :return: A :py:type:`set` of ``cls`` instances giving the names of the\n            elliptic curves the underlying library supports.\n        \"\"\"\n        if cls._curves is None:\n            cls._curves = cls._load_elliptic_curves(lib)\n        return cls._curves\n\n    @classmethod\n    def from_nid(cls, lib: Any, nid: int) -> \"_EllipticCurve\":\n        \"\"\"\n        Instantiate a new :py:class:`_EllipticCurve` associated with the given\n        OpenSSL NID.\n\n        :param lib: The OpenSSL library binding object.\n\n        :param nid: The OpenSSL NID the resulting curve object will represent.\n            This must be a curve NID (and not, for example, a hash NID) or\n            subsequent operations will fail in unpredictable ways.\n        :type nid: :py:class:`int`\n\n        :return: The curve object.\n        \"\"\"\n        return cls(lib, nid, _ffi.string(lib.OBJ_nid2sn(nid)).decode(\"ascii\"))\n\n    def __init__(self, lib: Any, nid: int, name: str) -> None:\n        \"\"\"\n        :param _lib: The :py:mod:`cryptography` binding instance used to\n            interface with OpenSSL.\n\n        :param _nid: The OpenSSL NID identifying the curve this object\n            represents.\n        :type _nid: :py:class:`int`\n\n        :param name: The OpenSSL short name identifying the curve this object\n            represents.\n        :type name: :py:class:`unicode`\n        \"\"\"\n        self._lib = lib\n        self._nid = nid\n        self.name = name\n\n    def __repr__(self) -> str:\n        return f\"<Curve {self.name!r}>\"\n\n    def _to_EC_KEY(self) -> Any:\n        \"\"\"\n        Create a new OpenSSL EC_KEY structure initialized to use this curve.\n\n        The structure is automatically garbage collected when the Python object\n        is garbage collected.\n        \"\"\"\n        key = self._lib.EC_KEY_new_by_curve_name(self._nid)\n        return _ffi.gc(key, _lib.EC_KEY_free)\n\n\ndef get_elliptic_curves() -> Set[\"_EllipticCurve\"]:\n    \"\"\"\n    Return a set of objects representing the elliptic curves supported in the\n    OpenSSL build in use.\n\n    The curve objects have a :py:class:`unicode` ``name`` attribute by which\n    they identify themselves.\n\n    The curve objects are useful as values for the argument accepted by\n    :py:meth:`Context.set_tmp_ecdh` to specify which elliptical curve should be\n    used for ECDHE key exchange.\n    \"\"\"\n    return _EllipticCurve._get_elliptic_curves(_lib)\n\n\ndef get_elliptic_curve(name: str) -> _EllipticCurve:\n    \"\"\"\n    Return a single curve object selected by name.\n\n    See :py:func:`get_elliptic_curves` for information about curve objects.\n\n    :param name: The OpenSSL short name identifying the curve object to\n        retrieve.\n    :type name: :py:class:`unicode`\n\n    If the named curve is not supported then :py:class:`ValueError` is raised.\n    \"\"\"\n    for curve in get_elliptic_curves():\n        if curve.name == name:\n            return curve\n    raise ValueError(\"unknown curve name\", name)\n\n\n@functools.total_ordering\nclass X509Name:\n    \"\"\"\n    An X.509 Distinguished Name.\n\n    :ivar countryName: The country of the entity.\n    :ivar C: Alias for  :py:attr:`countryName`.\n\n    :ivar stateOrProvinceName: The state or province of the entity.\n    :ivar ST: Alias for :py:attr:`stateOrProvinceName`.\n\n    :ivar localityName: The locality of the entity.\n    :ivar L: Alias for :py:attr:`localityName`.\n\n    :ivar organizationName: The organization name of the entity.\n    :ivar O: Alias for :py:attr:`organizationName`.\n\n    :ivar organizationalUnitName: The organizational unit of the entity.\n    :ivar OU: Alias for :py:attr:`organizationalUnitName`\n\n    :ivar commonName: The common name of the entity.\n    :ivar CN: Alias for :py:attr:`commonName`.\n\n    :ivar emailAddress: The e-mail address of the entity.\n    \"\"\"\n\n    def __init__(self, name: \"X509Name\") -> None:\n        \"\"\"\n        Create a new X509Name, copying the given X509Name instance.\n\n        :param name: The name to copy.\n        :type name: :py:class:`X509Name`\n        \"\"\"\n        name = _lib.X509_NAME_dup(name._name)\n        self._name: Any = _ffi.gc(name, _lib.X509_NAME_free)\n\n    def __setattr__(self, name: str, value: Any) -> None:\n        if name.startswith(\"_\"):\n            return super().__setattr__(name, value)\n\n        # Note: we really do not want str subclasses here, so we do not use\n        # isinstance.\n        if type(name) is not str:  # noqa: E721\n            raise TypeError(\n                f\"attribute name must be string, not \"\n                f\"'{type(value).__name__:.200}'\"\n            )\n\n        nid = _lib.OBJ_txt2nid(_byte_string(name))\n        if nid == _lib.NID_undef:\n            try:\n                _raise_current_error()\n            except Error:\n                pass\n            raise AttributeError(\"No such attribute\")\n\n        # If there's an old entry for this NID, remove it\n        for i in range(_lib.X509_NAME_entry_count(self._name)):\n            ent = _lib.X509_NAME_get_entry(self._name, i)\n            ent_obj = _lib.X509_NAME_ENTRY_get_object(ent)\n            ent_nid = _lib.OBJ_obj2nid(ent_obj)\n            if nid == ent_nid:\n                ent = _lib.X509_NAME_delete_entry(self._name, i)\n                _lib.X509_NAME_ENTRY_free(ent)\n                break\n\n        if isinstance(value, str):\n            value = value.encode(\"utf-8\")\n\n        add_result = _lib.X509_NAME_add_entry_by_NID(\n            self._name, nid, _lib.MBSTRING_UTF8, value, -1, -1, 0\n        )\n        if not add_result:\n            _raise_current_error()\n\n    def __getattr__(self, name: str) -> Optional[str]:\n        \"\"\"\n        Find attribute. An X509Name object has the following attributes:\n        countryName (alias C), stateOrProvince (alias ST), locality (alias L),\n        organization (alias O), organizationalUnit (alias OU), commonName\n        (alias CN) and more...\n        \"\"\"\n        nid = _lib.OBJ_txt2nid(_byte_string(name))\n        if nid == _lib.NID_undef:\n            # This is a bit weird.  OBJ_txt2nid indicated failure, but it seems\n            # a lower level function, a2d_ASN1_OBJECT, also feels the need to\n            # push something onto the error queue.  If we don't clean that up\n            # now, someone else will bump into it later and be quite confused.\n            # See lp#314814.\n            try:\n                _raise_current_error()\n            except Error:\n                pass\n            raise AttributeError(\"No such attribute\")\n\n        entry_index = _lib.X509_NAME_get_index_by_NID(self._name, nid, -1)\n        if entry_index == -1:\n            return None\n\n        entry = _lib.X509_NAME_get_entry(self._name, entry_index)\n        data = _lib.X509_NAME_ENTRY_get_data(entry)\n\n        result_buffer = _ffi.new(\"unsigned char**\")\n        data_length = _lib.ASN1_STRING_to_UTF8(result_buffer, data)\n        _openssl_assert(data_length >= 0)\n\n        try:\n            result = _ffi.buffer(result_buffer[0], data_length)[:].decode(\n                \"utf-8\"\n            )\n        finally:\n            # XXX untested\n            _lib.OPENSSL_free(result_buffer[0])\n        return result\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, X509Name):\n            return NotImplemented\n\n        return _lib.X509_NAME_cmp(self._name, other._name) == 0\n\n    def __lt__(self, other: Any) -> bool:\n        if not isinstance(other, X509Name):\n            return NotImplemented\n\n        return _lib.X509_NAME_cmp(self._name, other._name) < 0\n\n    def __repr__(self) -> str:\n        \"\"\"\n        String representation of an X509Name\n        \"\"\"\n        result_buffer = _ffi.new(\"char[]\", 512)\n        format_result = _lib.X509_NAME_oneline(\n            self._name, result_buffer, len(result_buffer)\n        )\n        _openssl_assert(format_result != _ffi.NULL)\n\n        return \"<X509Name object '{}'>\".format(\n            _ffi.string(result_buffer).decode(\"utf-8\"),\n        )\n\n    def hash(self) -> int:\n        \"\"\"\n        Return an integer representation of the first four bytes of the\n        MD5 digest of the DER representation of the name.\n\n        This is the Python equivalent of OpenSSL's ``X509_NAME_hash``.\n\n        :return: The (integer) hash of this name.\n        :rtype: :py:class:`int`\n        \"\"\"\n        return _lib.X509_NAME_hash(self._name)\n\n    def der(self) -> bytes:\n        \"\"\"\n        Return the DER encoding of this name.\n\n        :return: The DER encoded form of this name.\n        :rtype: :py:class:`bytes`\n        \"\"\"\n        result_buffer = _ffi.new(\"unsigned char**\")\n        encode_result = _lib.i2d_X509_NAME(self._name, result_buffer)\n        _openssl_assert(encode_result >= 0)\n\n        string_result = _ffi.buffer(result_buffer[0], encode_result)[:]\n        _lib.OPENSSL_free(result_buffer[0])\n        return string_result\n\n    def get_components(self) -> List[Tuple[bytes, bytes]]:\n        \"\"\"\n        Returns the components of this name, as a sequence of 2-tuples.\n\n        :return: The components of this name.\n        :rtype: :py:class:`list` of ``name, value`` tuples.\n        \"\"\"\n        result = []\n        for i in range(_lib.X509_NAME_entry_count(self._name)):\n            ent = _lib.X509_NAME_get_entry(self._name, i)\n\n            fname = _lib.X509_NAME_ENTRY_get_object(ent)\n            fval = _lib.X509_NAME_ENTRY_get_data(ent)\n\n            nid = _lib.OBJ_obj2nid(fname)\n            name = _lib.OBJ_nid2sn(nid)\n\n            # ffi.string does not handle strings containing NULL bytes\n            # (which may have been generated by old, broken software)\n            value = _ffi.buffer(\n                _lib.ASN1_STRING_get0_data(fval), _lib.ASN1_STRING_length(fval)\n            )[:]\n            result.append((_ffi.string(name), value))\n\n        return result\n\n\nclass X509Extension:\n    \"\"\"\n    An X.509 v3 certificate extension.\n    \"\"\"\n\n    def __init__(\n        self,\n        type_name: bytes,\n        critical: bool,\n        value: bytes,\n        subject: Optional[\"X509\"] = None,\n        issuer: Optional[\"X509\"] = None,\n    ) -> None:\n        \"\"\"\n        Initializes an X509 extension.\n\n        :param type_name: The name of the type of extension_ to create.\n        :type type_name: :py:data:`bytes`\n\n        :param bool critical: A flag indicating whether this is a critical\n            extension.\n\n        :param value: The OpenSSL textual representation of the extension's\n            value.\n        :type value: :py:data:`bytes`\n\n        :param subject: Optional X509 certificate to use as subject.\n        :type subject: :py:class:`X509`\n\n        :param issuer: Optional X509 certificate to use as issuer.\n        :type issuer: :py:class:`X509`\n\n        .. _extension: https://www.openssl.org/docs/manmaster/man5/\n            x509v3_config.html#STANDARD-EXTENSIONS\n        \"\"\"\n        ctx = _ffi.new(\"X509V3_CTX*\")\n\n        # A context is necessary for any extension which uses the r2i\n        # conversion method.  That is, X509V3_EXT_nconf may segfault if passed\n        # a NULL ctx. Start off by initializing most of the fields to NULL.\n        _lib.X509V3_set_ctx(ctx, _ffi.NULL, _ffi.NULL, _ffi.NULL, _ffi.NULL, 0)\n\n        # We have no configuration database - but perhaps we should (some\n        # extensions may require it).\n        _lib.X509V3_set_ctx_nodb(ctx)\n\n        # Initialize the subject and issuer, if appropriate.  ctx is a local,\n        # and as far as I can tell none of the X509V3_* APIs invoked here steal\n        # any references, so no need to mess with reference counts or\n        # duplicates.\n        if issuer is not None:\n            if not isinstance(issuer, X509):\n                raise TypeError(\"issuer must be an X509 instance\")\n            ctx.issuer_cert = issuer._x509\n        if subject is not None:\n            if not isinstance(subject, X509):\n                raise TypeError(\"subject must be an X509 instance\")\n            ctx.subject_cert = subject._x509\n\n        if critical:\n            # There are other OpenSSL APIs which would let us pass in critical\n            # separately, but they're harder to use, and since value is already\n            # a pile of crappy junk smuggling a ton of utterly important\n            # structured data, what's the point of trying to avoid nasty stuff\n            # with strings? (However, X509V3_EXT_i2d in particular seems like\n            # it would be a better API to invoke.  I do not know where to get\n            # the ext_struc it desires for its last parameter, though.)\n            value = b\"critical,\" + value\n\n        extension = _lib.X509V3_EXT_nconf(_ffi.NULL, ctx, type_name, value)\n        if extension == _ffi.NULL:\n            _raise_current_error()\n        self._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)\n\n    @property\n    def _nid(self) -> Any:\n        return _lib.OBJ_obj2nid(\n            _lib.X509_EXTENSION_get_object(self._extension)\n        )\n\n    _prefixes: typing.ClassVar[typing.Dict[int, str]] = {\n        _lib.GEN_EMAIL: \"email\",\n        _lib.GEN_DNS: \"DNS\",\n        _lib.GEN_URI: \"URI\",\n    }\n\n    def _subjectAltNameString(self) -> str:\n        names = _ffi.cast(\n            \"GENERAL_NAMES*\", _lib.X509V3_EXT_d2i(self._extension)\n        )\n\n        names = _ffi.gc(names, _lib.GENERAL_NAMES_free)\n        parts = []\n        for i in range(_lib.sk_GENERAL_NAME_num(names)):\n            name = _lib.sk_GENERAL_NAME_value(names, i)\n            try:\n                label = self._prefixes[name.type]\n            except KeyError:\n                bio = _new_mem_buf()\n                _lib.GENERAL_NAME_print(bio, name)\n                parts.append(_bio_to_string(bio).decode(\"utf-8\"))\n            else:\n                value = _ffi.buffer(name.d.ia5.data, name.d.ia5.length)[\n                    :\n                ].decode(\"utf-8\")\n                parts.append(label + \":\" + value)\n        return \", \".join(parts)\n\n    def __str__(self) -> str:\n        \"\"\"\n        :return: a nice text representation of the extension\n        \"\"\"\n        if _lib.NID_subject_alt_name == self._nid:\n            return self._subjectAltNameString()\n\n        bio = _new_mem_buf()\n        print_result = _lib.X509V3_EXT_print(bio, self._extension, 0, 0)\n        _openssl_assert(print_result != 0)\n\n        return _bio_to_string(bio).decode(\"utf-8\")\n\n    def get_critical(self) -> bool:\n        \"\"\"\n        Returns the critical field of this X.509 extension.\n\n        :return: The critical field.\n        \"\"\"\n        return _lib.X509_EXTENSION_get_critical(self._extension)\n\n    def get_short_name(self) -> bytes:\n        \"\"\"\n        Returns the short type name of this X.509 extension.\n\n        The result is a byte string such as :py:const:`b\"basicConstraints\"`.\n\n        :return: The short type name.\n        :rtype: :py:data:`bytes`\n\n        .. versionadded:: 0.12\n        \"\"\"\n        obj = _lib.X509_EXTENSION_get_object(self._extension)\n        nid = _lib.OBJ_obj2nid(obj)\n        # OpenSSL 3.1.0 has a bug where nid2sn returns NULL for NIDs that\n        # previously returned UNDEF. This is a workaround for that issue.\n        # https://github.com/openssl/openssl/commit/908ba3ed9adbb3df90f76\n        buf = _lib.OBJ_nid2sn(nid)\n        if buf != _ffi.NULL:\n            return _ffi.string(buf)\n        else:\n            return b\"UNDEF\"\n\n    def get_data(self) -> bytes:\n        \"\"\"\n        Returns the data of the X509 extension, encoded as ASN.1.\n\n        :return: The ASN.1 encoded data of this X509 extension.\n        :rtype: :py:data:`bytes`\n\n        .. versionadded:: 0.12\n        \"\"\"\n        octet_result = _lib.X509_EXTENSION_get_data(self._extension)\n        string_result = _ffi.cast(\"ASN1_STRING*\", octet_result)\n        char_result = _lib.ASN1_STRING_get0_data(string_result)\n        result_length = _lib.ASN1_STRING_length(string_result)\n        return _ffi.buffer(char_result, result_length)[:]\n\n\n_X509ExtensionInternal = X509Extension\nutils.deprecated(\n    X509Extension,\n    __name__,\n    (\n        \"X509Extension support in pyOpenSSL is deprecated. You should use the \"\n        \"APIs in cryptography.\"\n    ),\n    DeprecationWarning,\n    name=\"X509Extension\",\n)\n\n\nclass X509Req:\n    \"\"\"\n    An X.509 certificate signing requests.\n    \"\"\"\n\n    def __init__(self) -> None:\n        req = _lib.X509_REQ_new()\n        self._req = _ffi.gc(req, _lib.X509_REQ_free)\n        # Default to version 0.\n        self.set_version(0)\n\n    def to_cryptography(self) -> x509.CertificateSigningRequest:\n        \"\"\"\n        Export as a ``cryptography`` certificate signing request.\n\n        :rtype: ``cryptography.x509.CertificateSigningRequest``\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        from cryptography.x509 import load_der_x509_csr\n\n        der = dump_certificate_request(FILETYPE_ASN1, self)\n\n        return load_der_x509_csr(der)\n\n    @classmethod\n    def from_cryptography(\n        cls, crypto_req: x509.CertificateSigningRequest\n    ) -> \"X509Req\":\n        \"\"\"\n        Construct based on a ``cryptography`` *crypto_req*.\n\n        :param crypto_req: A ``cryptography`` X.509 certificate signing request\n        :type crypto_req: ``cryptography.x509.CertificateSigningRequest``\n\n        :rtype: X509Req\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if not isinstance(crypto_req, x509.CertificateSigningRequest):\n            raise TypeError(\"Must be a certificate signing request\")\n\n        from cryptography.hazmat.primitives.serialization import Encoding\n\n        der = crypto_req.public_bytes(Encoding.DER)\n        return load_certificate_request(FILETYPE_ASN1, der)\n\n    def set_pubkey(self, pkey: PKey) -> None:\n        \"\"\"\n        Set the public key of the certificate signing request.\n\n        :param pkey: The public key to use.\n        :type pkey: :py:class:`PKey`\n\n        :return: ``None``\n        \"\"\"\n        set_result = _lib.X509_REQ_set_pubkey(self._req, pkey._pkey)\n        _openssl_assert(set_result == 1)\n\n    def get_pubkey(self) -> PKey:\n        \"\"\"\n        Get the public key of the certificate signing request.\n\n        :return: The public key.\n        :rtype: :py:class:`PKey`\n        \"\"\"\n        pkey = PKey.__new__(PKey)\n        pkey._pkey = _lib.X509_REQ_get_pubkey(self._req)\n        _openssl_assert(pkey._pkey != _ffi.NULL)\n        pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)\n        pkey._only_public = True\n        return pkey\n\n    def set_version(self, version: int) -> None:\n        \"\"\"\n        Set the version subfield (RFC 2986, section 4.1) of the certificate\n        request.\n\n        :param int version: The version number.\n        :return: ``None``\n        \"\"\"\n        if not isinstance(version, int):\n            raise TypeError(\"version must be an int\")\n        if version != 0:\n            raise ValueError(\n                \"Invalid version. The only valid version for X509Req is 0.\"\n            )\n        set_result = _lib.X509_REQ_set_version(self._req, version)\n        _openssl_assert(set_result == 1)\n\n    def get_version(self) -> int:\n        \"\"\"\n        Get the version subfield (RFC 2459, section 4.1.2.1) of the certificate\n        request.\n\n        :return: The value of the version subfield.\n        :rtype: :py:class:`int`\n        \"\"\"\n        return _lib.X509_REQ_get_version(self._req)\n\n    def get_subject(self) -> X509Name:\n        \"\"\"\n        Return the subject of this certificate signing request.\n\n        This creates a new :class:`X509Name` that wraps the underlying subject\n        name field on the certificate signing request. Modifying it will modify\n        the underlying signing request, and will have the effect of modifying\n        any other :class:`X509Name` that refers to this subject.\n\n        :return: The subject of this certificate signing request.\n        :rtype: :class:`X509Name`\n        \"\"\"\n        name = X509Name.__new__(X509Name)\n        name._name = _lib.X509_REQ_get_subject_name(self._req)\n        _openssl_assert(name._name != _ffi.NULL)\n\n        # The name is owned by the X509Req structure.  As long as the X509Name\n        # Python object is alive, keep the X509Req Python object alive.\n        name._owner = self\n\n        return name\n\n    def add_extensions(\n        self, extensions: Iterable[_X509ExtensionInternal]\n    ) -> None:\n        \"\"\"\n        Add extensions to the certificate signing request.\n\n        :param extensions: The X.509 extensions to add.\n        :type extensions: iterable of :py:class:`X509Extension`\n        :return: ``None``\n        \"\"\"\n        stack = _lib.sk_X509_EXTENSION_new_null()\n        _openssl_assert(stack != _ffi.NULL)\n\n        stack = _ffi.gc(stack, _lib.sk_X509_EXTENSION_free)\n\n        for ext in extensions:\n            if not isinstance(ext, _X509ExtensionInternal):\n                raise ValueError(\"One of the elements is not an X509Extension\")\n\n            # TODO push can fail (here and elsewhere)\n            _lib.sk_X509_EXTENSION_push(stack, ext._extension)\n\n        add_result = _lib.X509_REQ_add_extensions(self._req, stack)\n        _openssl_assert(add_result == 1)\n\n    def get_extensions(self) -> List[_X509ExtensionInternal]:\n        \"\"\"\n        Get X.509 extensions in the certificate signing request.\n\n        :return: The X.509 extensions in this request.\n        :rtype: :py:class:`list` of :py:class:`X509Extension` objects.\n\n        .. versionadded:: 0.15\n        \"\"\"\n        exts = []\n        native_exts_obj = _lib.X509_REQ_get_extensions(self._req)\n        native_exts_obj = _ffi.gc(\n            native_exts_obj,\n            lambda x: _lib.sk_X509_EXTENSION_pop_free(\n                x,\n                _ffi.addressof(_lib._original_lib, \"X509_EXTENSION_free\"),\n            ),\n        )\n\n        for i in range(_lib.sk_X509_EXTENSION_num(native_exts_obj)):\n            ext = _X509ExtensionInternal.__new__(_X509ExtensionInternal)\n            extension = _lib.X509_EXTENSION_dup(\n                _lib.sk_X509_EXTENSION_value(native_exts_obj, i)\n            )\n            ext._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)\n            exts.append(ext)\n        return exts\n\n    def sign(self, pkey: PKey, digest: str) -> None:\n        \"\"\"\n        Sign the certificate signing request with this key and digest type.\n\n        :param pkey: The key pair to sign with.\n        :type pkey: :py:class:`PKey`\n        :param digest: The name of the message digest to use for the signature,\n            e.g. :py:data:`\"sha256\"`.\n        :type digest: :py:class:`str`\n        :return: ``None``\n        \"\"\"\n        if pkey._only_public:\n            raise ValueError(\"Key has only public part\")\n\n        if not pkey._initialized:\n            raise ValueError(\"Key is uninitialized\")\n\n        digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))\n        if digest_obj == _ffi.NULL:\n            raise ValueError(\"No such digest method\")\n\n        sign_result = _lib.X509_REQ_sign(self._req, pkey._pkey, digest_obj)\n        _openssl_assert(sign_result > 0)\n\n    def verify(self, pkey: PKey) -> bool:\n        \"\"\"\n        Verifies the signature on this certificate signing request.\n\n        :param PKey key: A public key.\n\n        :return: ``True`` if the signature is correct.\n        :rtype: bool\n\n        :raises OpenSSL.crypto.Error: If the signature is invalid or there is a\n            problem verifying the signature.\n        \"\"\"\n        if not isinstance(pkey, PKey):\n            raise TypeError(\"pkey must be a PKey instance\")\n\n        result = _lib.X509_REQ_verify(self._req, pkey._pkey)\n        if result <= 0:\n            _raise_current_error()\n\n        return result\n\n\nclass X509:\n    \"\"\"\n    An X.509 certificate.\n    \"\"\"\n\n    def __init__(self) -> None:\n        x509 = _lib.X509_new()\n        _openssl_assert(x509 != _ffi.NULL)\n        self._x509 = _ffi.gc(x509, _lib.X509_free)\n\n        self._issuer_invalidator = _X509NameInvalidator()\n        self._subject_invalidator = _X509NameInvalidator()\n\n    @classmethod\n    def _from_raw_x509_ptr(cls, x509: Any) -> \"X509\":\n        cert = cls.__new__(cls)\n        cert._x509 = _ffi.gc(x509, _lib.X509_free)\n        cert._issuer_invalidator = _X509NameInvalidator()\n        cert._subject_invalidator = _X509NameInvalidator()\n        return cert\n\n    def to_cryptography(self) -> x509.Certificate:\n        \"\"\"\n        Export as a ``cryptography`` certificate.\n\n        :rtype: ``cryptography.x509.Certificate``\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        from cryptography.x509 import load_der_x509_certificate\n\n        der = dump_certificate(FILETYPE_ASN1, self)\n        return load_der_x509_certificate(der)\n\n    @classmethod\n    def from_cryptography(cls, crypto_cert: x509.Certificate) -> \"X509\":\n        \"\"\"\n        Construct based on a ``cryptography`` *crypto_cert*.\n\n        :param crypto_key: A ``cryptography`` X.509 certificate.\n        :type crypto_key: ``cryptography.x509.Certificate``\n\n        :rtype: X509\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if not isinstance(crypto_cert, x509.Certificate):\n            raise TypeError(\"Must be a certificate\")\n\n        from cryptography.hazmat.primitives.serialization import Encoding\n\n        der = crypto_cert.public_bytes(Encoding.DER)\n        return load_certificate(FILETYPE_ASN1, der)\n\n    def set_version(self, version: int) -> None:\n        \"\"\"\n        Set the version number of the certificate. Note that the\n        version value is zero-based, eg. a value of 0 is V1.\n\n        :param version: The version number of the certificate.\n        :type version: :py:class:`int`\n\n        :return: ``None``\n        \"\"\"\n        if not isinstance(version, int):\n            raise TypeError(\"version must be an integer\")\n\n        _openssl_assert(_lib.X509_set_version(self._x509, version) == 1)\n\n    def get_version(self) -> int:\n        \"\"\"\n        Return the version number of the certificate.\n\n        :return: The version number of the certificate.\n        :rtype: :py:class:`int`\n        \"\"\"\n        return _lib.X509_get_version(self._x509)\n\n    def get_pubkey(self) -> PKey:\n        \"\"\"\n        Get the public key of the certificate.\n\n        :return: The public key.\n        :rtype: :py:class:`PKey`\n        \"\"\"\n        pkey = PKey.__new__(PKey)\n        pkey._pkey = _lib.X509_get_pubkey(self._x509)\n        if pkey._pkey == _ffi.NULL:\n            _raise_current_error()\n        pkey._pkey = _ffi.gc(pkey._pkey, _lib.EVP_PKEY_free)\n        pkey._only_public = True\n        return pkey\n\n    def set_pubkey(self, pkey: PKey) -> None:\n        \"\"\"\n        Set the public key of the certificate.\n\n        :param pkey: The public key.\n        :type pkey: :py:class:`PKey`\n\n        :return: :py:data:`None`\n        \"\"\"\n        if not isinstance(pkey, PKey):\n            raise TypeError(\"pkey must be a PKey instance\")\n\n        set_result = _lib.X509_set_pubkey(self._x509, pkey._pkey)\n        _openssl_assert(set_result == 1)\n\n    def sign(self, pkey: PKey, digest: str) -> None:\n        \"\"\"\n        Sign the certificate with this key and digest type.\n\n        :param pkey: The key to sign with.\n        :type pkey: :py:class:`PKey`\n\n        :param digest: The name of the message digest to use.\n        :type digest: :py:class:`str`\n\n        :return: :py:data:`None`\n        \"\"\"\n        if not isinstance(pkey, PKey):\n            raise TypeError(\"pkey must be a PKey instance\")\n\n        if pkey._only_public:\n            raise ValueError(\"Key only has public part\")\n\n        if not pkey._initialized:\n            raise ValueError(\"Key is uninitialized\")\n\n        evp_md = _lib.EVP_get_digestbyname(_byte_string(digest))\n        if evp_md == _ffi.NULL:\n            raise ValueError(\"No such digest method\")\n\n        sign_result = _lib.X509_sign(self._x509, pkey._pkey, evp_md)\n        _openssl_assert(sign_result > 0)\n\n    def get_signature_algorithm(self) -> bytes:\n        \"\"\"\n        Return the signature algorithm used in the certificate.\n\n        :return: The name of the algorithm.\n        :rtype: :py:class:`bytes`\n\n        :raises ValueError: If the signature algorithm is undefined.\n\n        .. versionadded:: 0.13\n        \"\"\"\n        sig_alg = _lib.X509_get0_tbs_sigalg(self._x509)\n        alg = _ffi.new(\"ASN1_OBJECT **\")\n        _lib.X509_ALGOR_get0(alg, _ffi.NULL, _ffi.NULL, sig_alg)\n        nid = _lib.OBJ_obj2nid(alg[0])\n        if nid == _lib.NID_undef:\n            raise ValueError(\"Undefined signature algorithm\")\n        return _ffi.string(_lib.OBJ_nid2ln(nid))\n\n    def digest(self, digest_name: str) -> bytes:\n        \"\"\"\n        Return the digest of the X509 object.\n\n        :param digest_name: The name of the digest algorithm to use.\n        :type digest_name: :py:class:`str`\n\n        :return: The digest of the object, formatted as\n            :py:const:`b\":\"`-delimited hex pairs.\n        :rtype: :py:class:`bytes`\n        \"\"\"\n        digest = _lib.EVP_get_digestbyname(_byte_string(digest_name))\n        if digest == _ffi.NULL:\n            raise ValueError(\"No such digest method\")\n\n        result_buffer = _ffi.new(\"unsigned char[]\", _lib.EVP_MAX_MD_SIZE)\n        result_length = _ffi.new(\"unsigned int[]\", 1)\n        result_length[0] = len(result_buffer)\n\n        digest_result = _lib.X509_digest(\n            self._x509, digest, result_buffer, result_length\n        )\n        _openssl_assert(digest_result == 1)\n\n        return b\":\".join(\n            [\n                b16encode(ch).upper()\n                for ch in _ffi.buffer(result_buffer, result_length[0])\n            ]\n        )\n\n    def subject_name_hash(self) -> bytes:\n        \"\"\"\n        Return the hash of the X509 subject.\n\n        :return: The hash of the subject.\n        :rtype: :py:class:`bytes`\n        \"\"\"\n        return _lib.X509_subject_name_hash(self._x509)\n\n    def set_serial_number(self, serial: int) -> None:\n        \"\"\"\n        Set the serial number of the certificate.\n\n        :param serial: The new serial number.\n        :type serial: :py:class:`int`\n\n        :return: :py:data`None`\n        \"\"\"\n        if not isinstance(serial, int):\n            raise TypeError(\"serial must be an integer\")\n\n        hex_serial = hex(serial)[2:]\n        hex_serial_bytes = hex_serial.encode(\"ascii\")\n\n        bignum_serial = _ffi.new(\"BIGNUM**\")\n\n        # BN_hex2bn stores the result in &bignum.  Unless it doesn't feel like\n        # it.  If bignum is still NULL after this call, then the return value\n        # is actually the result.  I hope.  -exarkun\n        small_serial = _lib.BN_hex2bn(bignum_serial, hex_serial_bytes)\n\n        if bignum_serial[0] == _ffi.NULL:\n            set_result = _lib.ASN1_INTEGER_set(\n                _lib.X509_get_serialNumber(self._x509), small_serial\n            )\n            if set_result:\n                # TODO Not tested\n                _raise_current_error()\n        else:\n            asn1_serial = _lib.BN_to_ASN1_INTEGER(bignum_serial[0], _ffi.NULL)\n            _lib.BN_free(bignum_serial[0])\n            if asn1_serial == _ffi.NULL:\n                # TODO Not tested\n                _raise_current_error()\n            asn1_serial = _ffi.gc(asn1_serial, _lib.ASN1_INTEGER_free)\n            set_result = _lib.X509_set_serialNumber(self._x509, asn1_serial)\n            _openssl_assert(set_result == 1)\n\n    def get_serial_number(self) -> int:\n        \"\"\"\n        Return the serial number of this certificate.\n\n        :return: The serial number.\n        :rtype: int\n        \"\"\"\n        asn1_serial = _lib.X509_get_serialNumber(self._x509)\n        bignum_serial = _lib.ASN1_INTEGER_to_BN(asn1_serial, _ffi.NULL)\n        try:\n            hex_serial = _lib.BN_bn2hex(bignum_serial)\n            try:\n                hexstring_serial = _ffi.string(hex_serial)\n                serial = int(hexstring_serial, 16)\n                return serial\n            finally:\n                _lib.OPENSSL_free(hex_serial)\n        finally:\n            _lib.BN_free(bignum_serial)\n\n    def gmtime_adj_notAfter(self, amount: int) -> None:\n        \"\"\"\n        Adjust the time stamp on which the certificate stops being valid.\n\n        :param int amount: The number of seconds by which to adjust the\n            timestamp.\n        :return: ``None``\n        \"\"\"\n        if not isinstance(amount, int):\n            raise TypeError(\"amount must be an integer\")\n\n        notAfter = _lib.X509_getm_notAfter(self._x509)\n        _lib.X509_gmtime_adj(notAfter, amount)\n\n    def gmtime_adj_notBefore(self, amount: int) -> None:\n        \"\"\"\n        Adjust the timestamp on which the certificate starts being valid.\n\n        :param amount: The number of seconds by which to adjust the timestamp.\n        :return: ``None``\n        \"\"\"\n        if not isinstance(amount, int):\n            raise TypeError(\"amount must be an integer\")\n\n        notBefore = _lib.X509_getm_notBefore(self._x509)\n        _lib.X509_gmtime_adj(notBefore, amount)\n\n    def has_expired(self) -> bool:\n        \"\"\"\n        Check whether the certificate has expired.\n\n        :return: ``True`` if the certificate has expired, ``False`` otherwise.\n        :rtype: bool\n        \"\"\"\n        time_bytes = self.get_notAfter()\n        if time_bytes is None:\n            raise ValueError(\"Unable to determine notAfter\")\n        time_string = time_bytes.decode(\"utf-8\")\n        not_after = datetime.datetime.strptime(time_string, \"%Y%m%d%H%M%SZ\")\n\n        UTC = datetime.timezone.utc\n        utcnow = datetime.datetime.now(UTC).replace(tzinfo=None)\n        return not_after < utcnow\n\n    def _get_boundary_time(self, which: Any) -> Optional[bytes]:\n        return _get_asn1_time(which(self._x509))\n\n    def get_notBefore(self) -> Optional[bytes]:\n        \"\"\"\n        Get the timestamp at which the certificate starts being valid.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        :return: A timestamp string, or ``None`` if there is none.\n        :rtype: bytes or NoneType\n        \"\"\"\n        return self._get_boundary_time(_lib.X509_getm_notBefore)\n\n    def _set_boundary_time(\n        self, which: Callable[..., Any], when: bytes\n    ) -> None:\n        return _set_asn1_time(which(self._x509), when)\n\n    def set_notBefore(self, when: bytes) -> None:\n        \"\"\"\n        Set the timestamp at which the certificate starts being valid.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        :param bytes when: A timestamp string.\n        :return: ``None``\n        \"\"\"\n        return self._set_boundary_time(_lib.X509_getm_notBefore, when)\n\n    def get_notAfter(self) -> Optional[bytes]:\n        \"\"\"\n        Get the timestamp at which the certificate stops being valid.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        :return: A timestamp string, or ``None`` if there is none.\n        :rtype: bytes or NoneType\n        \"\"\"\n        return self._get_boundary_time(_lib.X509_getm_notAfter)\n\n    def set_notAfter(self, when: bytes) -> None:\n        \"\"\"\n        Set the timestamp at which the certificate stops being valid.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        :param bytes when: A timestamp string.\n        :return: ``None``\n        \"\"\"\n        return self._set_boundary_time(_lib.X509_getm_notAfter, when)\n\n    def _get_name(self, which: Any) -> X509Name:\n        name = X509Name.__new__(X509Name)\n        name._name = which(self._x509)\n        _openssl_assert(name._name != _ffi.NULL)\n\n        # The name is owned by the X509 structure.  As long as the X509Name\n        # Python object is alive, keep the X509 Python object alive.\n        name._owner = self\n\n        return name\n\n    def _set_name(self, which: Any, name: X509Name) -> None:\n        if not isinstance(name, X509Name):\n            raise TypeError(\"name must be an X509Name\")\n        set_result = which(self._x509, name._name)\n        _openssl_assert(set_result == 1)\n\n    def get_issuer(self) -> X509Name:\n        \"\"\"\n        Return the issuer of this certificate.\n\n        This creates a new :class:`X509Name` that wraps the underlying issuer\n        name field on the certificate. Modifying it will modify the underlying\n        certificate, and will have the effect of modifying any other\n        :class:`X509Name` that refers to this issuer.\n\n        :return: The issuer of this certificate.\n        :rtype: :class:`X509Name`\n        \"\"\"\n        name = self._get_name(_lib.X509_get_issuer_name)\n        self._issuer_invalidator.add(name)\n        return name\n\n    def set_issuer(self, issuer: X509Name) -> None:\n        \"\"\"\n        Set the issuer of this certificate.\n\n        :param issuer: The issuer.\n        :type issuer: :py:class:`X509Name`\n\n        :return: ``None``\n        \"\"\"\n        self._set_name(_lib.X509_set_issuer_name, issuer)\n        self._issuer_invalidator.clear()\n\n    def get_subject(self) -> X509Name:\n        \"\"\"\n        Return the subject of this certificate.\n\n        This creates a new :class:`X509Name` that wraps the underlying subject\n        name field on the certificate. Modifying it will modify the underlying\n        certificate, and will have the effect of modifying any other\n        :class:`X509Name` that refers to this subject.\n\n        :return: The subject of this certificate.\n        :rtype: :class:`X509Name`\n        \"\"\"\n        name = self._get_name(_lib.X509_get_subject_name)\n        self._subject_invalidator.add(name)\n        return name\n\n    def set_subject(self, subject: X509Name) -> None:\n        \"\"\"\n        Set the subject of this certificate.\n\n        :param subject: The subject.\n        :type subject: :py:class:`X509Name`\n\n        :return: ``None``\n        \"\"\"\n        self._set_name(_lib.X509_set_subject_name, subject)\n        self._subject_invalidator.clear()\n\n    def get_extension_count(self) -> int:\n        \"\"\"\n        Get the number of extensions on this certificate.\n\n        :return: The number of extensions.\n        :rtype: :py:class:`int`\n\n        .. versionadded:: 0.12\n        \"\"\"\n        return _lib.X509_get_ext_count(self._x509)\n\n    def add_extensions(\n        self, extensions: Iterable[_X509ExtensionInternal]\n    ) -> None:\n        \"\"\"\n        Add extensions to the certificate.\n\n        :param extensions: The extensions to add.\n        :type extensions: An iterable of :py:class:`X509Extension` objects.\n        :return: ``None``\n        \"\"\"\n        for ext in extensions:\n            if not isinstance(ext, _X509ExtensionInternal):\n                raise ValueError(\"One of the elements is not an X509Extension\")\n\n            add_result = _lib.X509_add_ext(self._x509, ext._extension, -1)\n            if not add_result:\n                _raise_current_error()\n\n    def get_extension(self, index: int) -> _X509ExtensionInternal:\n        \"\"\"\n        Get a specific extension of the certificate by index.\n\n        Extensions on a certificate are kept in order. The index\n        parameter selects which extension will be returned.\n\n        :param int index: The index of the extension to retrieve.\n        :return: The extension at the specified index.\n        :rtype: :py:class:`X509Extension`\n        :raises IndexError: If the extension index was out of bounds.\n\n        .. versionadded:: 0.12\n        \"\"\"\n        ext = _X509ExtensionInternal.__new__(_X509ExtensionInternal)\n        ext._extension = _lib.X509_get_ext(self._x509, index)\n        if ext._extension == _ffi.NULL:\n            raise IndexError(\"extension index out of bounds\")\n\n        extension = _lib.X509_EXTENSION_dup(ext._extension)\n        ext._extension = _ffi.gc(extension, _lib.X509_EXTENSION_free)\n        return ext\n\n\nclass X509StoreFlags:\n    \"\"\"\n    Flags for X509 verification, used to change the behavior of\n    :class:`X509Store`.\n\n    See `OpenSSL Verification Flags`_ for details.\n\n    .. _OpenSSL Verification Flags:\n        https://www.openssl.org/docs/manmaster/man3/X509_VERIFY_PARAM_set_flags.html\n    \"\"\"\n\n    CRL_CHECK: int = _lib.X509_V_FLAG_CRL_CHECK\n    CRL_CHECK_ALL: int = _lib.X509_V_FLAG_CRL_CHECK_ALL\n    IGNORE_CRITICAL: int = _lib.X509_V_FLAG_IGNORE_CRITICAL\n    X509_STRICT: int = _lib.X509_V_FLAG_X509_STRICT\n    ALLOW_PROXY_CERTS: int = _lib.X509_V_FLAG_ALLOW_PROXY_CERTS\n    POLICY_CHECK: int = _lib.X509_V_FLAG_POLICY_CHECK\n    EXPLICIT_POLICY: int = _lib.X509_V_FLAG_EXPLICIT_POLICY\n    INHIBIT_MAP: int = _lib.X509_V_FLAG_INHIBIT_MAP\n    CHECK_SS_SIGNATURE: int = _lib.X509_V_FLAG_CHECK_SS_SIGNATURE\n    PARTIAL_CHAIN: int = _lib.X509_V_FLAG_PARTIAL_CHAIN\n\n\nclass X509Store:\n    \"\"\"\n    An X.509 store.\n\n    An X.509 store is used to describe a context in which to verify a\n    certificate. A description of a context may include a set of certificates\n    to trust, a set of certificate revocation lists, verification flags and\n    more.\n\n    An X.509 store, being only a description, cannot be used by itself to\n    verify a certificate. To carry out the actual verification process, see\n    :class:`X509StoreContext`.\n    \"\"\"\n\n    def __init__(self) -> None:\n        store = _lib.X509_STORE_new()\n        self._store = _ffi.gc(store, _lib.X509_STORE_free)\n\n    def add_cert(self, cert: X509) -> None:\n        \"\"\"\n        Adds a trusted certificate to this store.\n\n        Adding a certificate with this method adds this certificate as a\n        *trusted* certificate.\n\n        :param X509 cert: The certificate to add to this store.\n\n        :raises TypeError: If the certificate is not an :class:`X509`.\n\n        :raises OpenSSL.crypto.Error: If OpenSSL was unhappy with your\n            certificate.\n\n        :return: ``None`` if the certificate was added successfully.\n        \"\"\"\n        if not isinstance(cert, X509):\n            raise TypeError()\n\n        res = _lib.X509_STORE_add_cert(self._store, cert._x509)\n        _openssl_assert(res == 1)\n\n    def add_crl(\n        self, crl: Union[\"_CRLInternal\", x509.CertificateRevocationList]\n    ) -> None:\n        \"\"\"\n        Add a certificate revocation list to this store.\n\n        The certificate revocation lists added to a store will only be used if\n        the associated flags are configured to check certificate revocation\n        lists.\n\n        .. versionadded:: 16.1.0\n\n        :param crl: The certificate revocation list to add to this store.\n        :type crl: ``Union[CRL, cryptography.x509.CertificateRevocationList]``\n        :return: ``None`` if the certificate revocation list was added\n            successfully.\n        \"\"\"\n        if isinstance(crl, x509.CertificateRevocationList):\n            from cryptography.hazmat.primitives.serialization import Encoding\n\n            bio = _new_mem_buf(crl.public_bytes(Encoding.DER))\n            openssl_crl = _lib.d2i_X509_CRL_bio(bio, _ffi.NULL)\n            if openssl_crl == _ffi.NULL:\n                _raise_current_error()\n\n            crl = _ffi.gc(openssl_crl, _lib.X509_CRL_free)\n        elif isinstance(crl, _CRLInternal):\n            crl = crl._crl\n        else:\n            raise TypeError(\n                \"CRL must be of type OpenSSL.crypto.CRL or \"\n                \"cryptography.x509.CertificateRevocationList\"\n            )\n\n        _openssl_assert(_lib.X509_STORE_add_crl(self._store, crl) != 0)\n\n    def set_flags(self, flags: int) -> None:\n        \"\"\"\n        Set verification flags to this store.\n\n        Verification flags can be combined by oring them together.\n\n        .. note::\n\n          Setting a verification flag sometimes requires clients to add\n          additional information to the store, otherwise a suitable error will\n          be raised.\n\n          For example, in setting flags to enable CRL checking a\n          suitable CRL must be added to the store otherwise an error will be\n          raised.\n\n        .. versionadded:: 16.1.0\n\n        :param int flags: The verification flags to set on this store.\n            See :class:`X509StoreFlags` for available constants.\n        :return: ``None`` if the verification flags were successfully set.\n        \"\"\"\n        _openssl_assert(_lib.X509_STORE_set_flags(self._store, flags) != 0)\n\n    def set_time(self, vfy_time: datetime.datetime) -> None:\n        \"\"\"\n        Set the time against which the certificates are verified.\n\n        Normally the current time is used.\n\n        .. note::\n\n          For example, you can determine if a certificate was valid at a given\n          time.\n\n        .. versionadded:: 17.0.0\n\n        :param datetime vfy_time: The verification time to set on this store.\n        :return: ``None`` if the verification time was successfully set.\n        \"\"\"\n        param = _lib.X509_VERIFY_PARAM_new()\n        param = _ffi.gc(param, _lib.X509_VERIFY_PARAM_free)\n\n        _lib.X509_VERIFY_PARAM_set_time(\n            param, calendar.timegm(vfy_time.timetuple())\n        )\n        _openssl_assert(_lib.X509_STORE_set1_param(self._store, param) != 0)\n\n    def load_locations(\n        self, cafile: StrOrBytesPath, capath: Optional[StrOrBytesPath] = None\n    ) -> None:\n        \"\"\"\n        Let X509Store know where we can find trusted certificates for the\n        certificate chain.  Note that the certificates have to be in PEM\n        format.\n\n        If *capath* is passed, it must be a directory prepared using the\n        ``c_rehash`` tool included with OpenSSL.  Either, but not both, of\n        *cafile* or *capath* may be ``None``.\n\n        .. note::\n\n          Both *cafile* and *capath* may be set simultaneously.\n\n          Call this method multiple times to add more than one location.\n          For example, CA certificates, and certificate revocation list bundles\n          may be passed in *cafile* in subsequent calls to this method.\n\n        .. versionadded:: 20.0\n\n        :param cafile: In which file we can find the certificates (``bytes`` or\n                       ``unicode``).\n        :param capath: In which directory we can find the certificates\n                       (``bytes`` or ``unicode``).\n\n        :return: ``None`` if the locations were set successfully.\n\n        :raises OpenSSL.crypto.Error: If both *cafile* and *capath* is ``None``\n            or the locations could not be set for any reason.\n\n        \"\"\"\n        if cafile is None:\n            cafile = _ffi.NULL\n        else:\n            cafile = _path_bytes(cafile)\n\n        if capath is None:\n            capath = _ffi.NULL\n        else:\n            capath = _path_bytes(capath)\n\n        load_result = _lib.X509_STORE_load_locations(\n            self._store, cafile, capath\n        )\n        if not load_result:\n            _raise_current_error()\n\n\nclass X509StoreContextError(Exception):\n    \"\"\"\n    An exception raised when an error occurred while verifying a certificate\n    using `OpenSSL.X509StoreContext.verify_certificate`.\n\n    :ivar certificate: The certificate which caused verificate failure.\n    :type certificate: :class:`X509`\n    \"\"\"\n\n    def __init__(\n        self, message: str, errors: List[Any], certificate: X509\n    ) -> None:\n        super().__init__(message)\n        self.errors = errors\n        self.certificate = certificate\n\n\nclass X509StoreContext:\n    \"\"\"\n    An X.509 store context.\n\n    An X.509 store context is used to carry out the actual verification process\n    of a certificate in a described context. For describing such a context, see\n    :class:`X509Store`.\n\n    :param X509Store store: The certificates which will be trusted for the\n        purposes of any verifications.\n    :param X509 certificate: The certificate to be verified.\n    :param chain: List of untrusted certificates that may be used for building\n        the certificate chain. May be ``None``.\n    :type chain: :class:`list` of :class:`X509`\n    \"\"\"\n\n    def __init__(\n        self,\n        store: X509Store,\n        certificate: X509,\n        chain: Optional[Sequence[X509]] = None,\n    ) -> None:\n        self._store = store\n        self._cert = certificate\n        self._chain = self._build_certificate_stack(chain)\n\n    @staticmethod\n    def _build_certificate_stack(\n        certificates: Optional[Sequence[X509]],\n    ) -> None:\n        def cleanup(s: Any) -> None:\n            # Equivalent to sk_X509_pop_free, but we don't\n            # currently have a CFFI binding for that available\n            for i in range(_lib.sk_X509_num(s)):\n                x = _lib.sk_X509_value(s, i)\n                _lib.X509_free(x)\n            _lib.sk_X509_free(s)\n\n        if certificates is None or len(certificates) == 0:\n            return _ffi.NULL\n\n        stack = _lib.sk_X509_new_null()\n        _openssl_assert(stack != _ffi.NULL)\n        stack = _ffi.gc(stack, cleanup)\n\n        for cert in certificates:\n            if not isinstance(cert, X509):\n                raise TypeError(\"One of the elements is not an X509 instance\")\n\n            _openssl_assert(_lib.X509_up_ref(cert._x509) > 0)\n            if _lib.sk_X509_push(stack, cert._x509) <= 0:\n                _lib.X509_free(cert._x509)\n                _raise_current_error()\n\n        return stack\n\n    @staticmethod\n    def _exception_from_context(store_ctx: Any) -> X509StoreContextError:\n        \"\"\"\n        Convert an OpenSSL native context error failure into a Python\n        exception.\n\n        When a call to native OpenSSL X509_verify_cert fails, additional\n        information about the failure can be obtained from the store context.\n        \"\"\"\n        message = _ffi.string(\n            _lib.X509_verify_cert_error_string(\n                _lib.X509_STORE_CTX_get_error(store_ctx)\n            )\n        ).decode(\"utf-8\")\n        errors = [\n            _lib.X509_STORE_CTX_get_error(store_ctx),\n            _lib.X509_STORE_CTX_get_error_depth(store_ctx),\n            message,\n        ]\n        # A context error should always be associated with a certificate, so we\n        # expect this call to never return :class:`None`.\n        _x509 = _lib.X509_STORE_CTX_get_current_cert(store_ctx)\n        _cert = _lib.X509_dup(_x509)\n        pycert = X509._from_raw_x509_ptr(_cert)\n        return X509StoreContextError(message, errors, pycert)\n\n    def _verify_certificate(self) -> Any:\n        \"\"\"\n        Verifies the certificate and runs an X509_STORE_CTX containing the\n        results.\n\n        :raises X509StoreContextError: If an error occurred when validating a\n          certificate in the context. Sets ``certificate`` attribute to\n          indicate which certificate caused the error.\n        \"\"\"\n        store_ctx = _lib.X509_STORE_CTX_new()\n        _openssl_assert(store_ctx != _ffi.NULL)\n        store_ctx = _ffi.gc(store_ctx, _lib.X509_STORE_CTX_free)\n\n        ret = _lib.X509_STORE_CTX_init(\n            store_ctx, self._store._store, self._cert._x509, self._chain\n        )\n        _openssl_assert(ret == 1)\n\n        ret = _lib.X509_verify_cert(store_ctx)\n        if ret <= 0:\n            raise self._exception_from_context(store_ctx)\n\n        return store_ctx\n\n    def set_store(self, store: X509Store) -> None:\n        \"\"\"\n        Set the context's X.509 store.\n\n        .. versionadded:: 0.15\n\n        :param X509Store store: The store description which will be used for\n            the purposes of any *future* verifications.\n        \"\"\"\n        self._store = store\n\n    def verify_certificate(self) -> None:\n        \"\"\"\n        Verify a certificate in a context.\n\n        .. versionadded:: 0.15\n\n        :raises X509StoreContextError: If an error occurred when validating a\n          certificate in the context. Sets ``certificate`` attribute to\n          indicate which certificate caused the error.\n        \"\"\"\n        self._verify_certificate()\n\n    def get_verified_chain(self) -> List[X509]:\n        \"\"\"\n        Verify a certificate in a context and return the complete validated\n        chain.\n\n        :raises X509StoreContextError: If an error occurred when validating a\n          certificate in the context. Sets ``certificate`` attribute to\n          indicate which certificate caused the error.\n\n        .. versionadded:: 20.0\n        \"\"\"\n        store_ctx = self._verify_certificate()\n\n        # Note: X509_STORE_CTX_get1_chain returns a deep copy of the chain.\n        cert_stack = _lib.X509_STORE_CTX_get1_chain(store_ctx)\n        _openssl_assert(cert_stack != _ffi.NULL)\n\n        result = []\n        for i in range(_lib.sk_X509_num(cert_stack)):\n            cert = _lib.sk_X509_value(cert_stack, i)\n            _openssl_assert(cert != _ffi.NULL)\n            pycert = X509._from_raw_x509_ptr(cert)\n            result.append(pycert)\n\n        # Free the stack but not the members which are freed by the X509 class.\n        _lib.sk_X509_free(cert_stack)\n        return result\n\n\ndef load_certificate(type: int, buffer: bytes) -> X509:\n    \"\"\"\n    Load a certificate (X509) from the string *buffer* encoded with the\n    type *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n\n    :param bytes buffer: The buffer the certificate is stored in\n\n    :return: The X509 object\n    \"\"\"\n    if isinstance(buffer, str):\n        buffer = buffer.encode(\"ascii\")\n\n    bio = _new_mem_buf(buffer)\n\n    if type == FILETYPE_PEM:\n        x509 = _lib.PEM_read_bio_X509(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)\n    elif type == FILETYPE_ASN1:\n        x509 = _lib.d2i_X509_bio(bio, _ffi.NULL)\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    if x509 == _ffi.NULL:\n        _raise_current_error()\n\n    return X509._from_raw_x509_ptr(x509)\n\n\ndef dump_certificate(type: int, cert: X509) -> bytes:\n    \"\"\"\n    Dump the certificate *cert* into a buffer string encoded with the type\n    *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1, or\n        FILETYPE_TEXT)\n    :param cert: The certificate to dump\n    :return: The buffer with the dumped certificate in\n    \"\"\"\n    bio = _new_mem_buf()\n\n    if type == FILETYPE_PEM:\n        result_code = _lib.PEM_write_bio_X509(bio, cert._x509)\n    elif type == FILETYPE_ASN1:\n        result_code = _lib.i2d_X509_bio(bio, cert._x509)\n    elif type == FILETYPE_TEXT:\n        result_code = _lib.X509_print_ex(bio, cert._x509, 0, 0)\n    else:\n        raise ValueError(\n            \"type argument must be FILETYPE_PEM, FILETYPE_ASN1, or \"\n            \"FILETYPE_TEXT\"\n        )\n\n    _openssl_assert(result_code == 1)\n    return _bio_to_string(bio)\n\n\ndef dump_publickey(type: int, pkey: PKey) -> bytes:\n    \"\"\"\n    Dump a public key to a buffer.\n\n    :param type: The file type (one of :data:`FILETYPE_PEM` or\n        :data:`FILETYPE_ASN1`).\n    :param PKey pkey: The public key to dump\n    :return: The buffer with the dumped key in it.\n    :rtype: bytes\n    \"\"\"\n    bio = _new_mem_buf()\n    if type == FILETYPE_PEM:\n        write_bio = _lib.PEM_write_bio_PUBKEY\n    elif type == FILETYPE_ASN1:\n        write_bio = _lib.i2d_PUBKEY_bio\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    result_code = write_bio(bio, pkey._pkey)\n    if result_code != 1:  # pragma: no cover\n        _raise_current_error()\n\n    return _bio_to_string(bio)\n\n\ndef dump_privatekey(\n    type: int,\n    pkey: PKey,\n    cipher: Optional[str] = None,\n    passphrase: Optional[PassphraseCallableT] = None,\n) -> bytes:\n    \"\"\"\n    Dump the private key *pkey* into a buffer string encoded with the type\n    *type*.  Optionally (if *type* is :const:`FILETYPE_PEM`) encrypting it\n    using *cipher* and *passphrase*.\n\n    :param type: The file type (one of :const:`FILETYPE_PEM`,\n        :const:`FILETYPE_ASN1`, or :const:`FILETYPE_TEXT`)\n    :param PKey pkey: The PKey to dump\n    :param cipher: (optional) if encrypted PEM format, the cipher to use\n    :param passphrase: (optional) if encrypted PEM format, this can be either\n        the passphrase to use, or a callback for providing the passphrase.\n\n    :return: The buffer with the dumped key in\n    :rtype: bytes\n    \"\"\"\n    bio = _new_mem_buf()\n\n    if not isinstance(pkey, PKey):\n        raise TypeError(\"pkey must be a PKey\")\n\n    if cipher is not None:\n        if passphrase is None:\n            raise TypeError(\n                \"if a value is given for cipher \"\n                \"one must also be given for passphrase\"\n            )\n        cipher_obj = _lib.EVP_get_cipherbyname(_byte_string(cipher))\n        if cipher_obj == _ffi.NULL:\n            raise ValueError(\"Invalid cipher name\")\n    else:\n        cipher_obj = _ffi.NULL\n\n    helper = _PassphraseHelper(type, passphrase)\n    if type == FILETYPE_PEM:\n        result_code = _lib.PEM_write_bio_PrivateKey(\n            bio,\n            pkey._pkey,\n            cipher_obj,\n            _ffi.NULL,\n            0,\n            helper.callback,\n            helper.callback_args,\n        )\n        helper.raise_if_problem()\n    elif type == FILETYPE_ASN1:\n        result_code = _lib.i2d_PrivateKey_bio(bio, pkey._pkey)\n    elif type == FILETYPE_TEXT:\n        if _lib.EVP_PKEY_id(pkey._pkey) != _lib.EVP_PKEY_RSA:\n            raise TypeError(\"Only RSA keys are supported for FILETYPE_TEXT\")\n\n        rsa = _ffi.gc(_lib.EVP_PKEY_get1_RSA(pkey._pkey), _lib.RSA_free)\n        result_code = _lib.RSA_print(bio, rsa, 0)\n    else:\n        raise ValueError(\n            \"type argument must be FILETYPE_PEM, FILETYPE_ASN1, or \"\n            \"FILETYPE_TEXT\"\n        )\n\n    _openssl_assert(result_code != 0)\n\n    return _bio_to_string(bio)\n\n\nclass Revoked:\n    \"\"\"\n    A certificate revocation.\n    \"\"\"\n\n    # https://www.openssl.org/docs/manmaster/man5/x509v3_config.html#CRL-distribution-points\n    # which differs from crl_reasons of crypto/x509v3/v3_enum.c that matches\n    # OCSP_crl_reason_str.  We use the latter, just like the command line\n    # program.\n    _crl_reasons: typing.ClassVar[typing.List[bytes]] = [\n        b\"unspecified\",\n        b\"keyCompromise\",\n        b\"CACompromise\",\n        b\"affiliationChanged\",\n        b\"superseded\",\n        b\"cessationOfOperation\",\n        b\"certificateHold\",\n        # b\"removeFromCRL\",\n    ]\n\n    def __init__(self) -> None:\n        revoked = _lib.X509_REVOKED_new()\n        self._revoked = _ffi.gc(revoked, _lib.X509_REVOKED_free)\n\n    def set_serial(self, hex_str: bytes) -> None:\n        \"\"\"\n        Set the serial number.\n\n        The serial number is formatted as a hexadecimal number encoded in\n        ASCII.\n\n        :param bytes hex_str: The new serial number.\n\n        :return: ``None``\n        \"\"\"\n        bignum_serial = _ffi.gc(_lib.BN_new(), _lib.BN_free)\n        bignum_ptr = _ffi.new(\"BIGNUM**\")\n        bignum_ptr[0] = bignum_serial\n        bn_result = _lib.BN_hex2bn(bignum_ptr, hex_str)\n        if not bn_result:\n            raise ValueError(\"bad hex string\")\n\n        asn1_serial = _ffi.gc(\n            _lib.BN_to_ASN1_INTEGER(bignum_serial, _ffi.NULL),\n            _lib.ASN1_INTEGER_free,\n        )\n        _lib.X509_REVOKED_set_serialNumber(self._revoked, asn1_serial)\n\n    def get_serial(self) -> bytes:\n        \"\"\"\n        Get the serial number.\n\n        The serial number is formatted as a hexadecimal number encoded in\n        ASCII.\n\n        :return: The serial number.\n        :rtype: bytes\n        \"\"\"\n        bio = _new_mem_buf()\n\n        asn1_int = _lib.X509_REVOKED_get0_serialNumber(self._revoked)\n        _openssl_assert(asn1_int != _ffi.NULL)\n        result = _lib.i2a_ASN1_INTEGER(bio, asn1_int)\n        _openssl_assert(result >= 0)\n        return _bio_to_string(bio)\n\n    def _delete_reason(self) -> None:\n        for i in range(_lib.X509_REVOKED_get_ext_count(self._revoked)):\n            ext = _lib.X509_REVOKED_get_ext(self._revoked, i)\n            obj = _lib.X509_EXTENSION_get_object(ext)\n            if _lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:\n                _lib.X509_EXTENSION_free(ext)\n                _lib.X509_REVOKED_delete_ext(self._revoked, i)\n                break\n\n    def set_reason(self, reason: Optional[bytes]) -> None:\n        \"\"\"\n        Set the reason of this revocation.\n\n        If :data:`reason` is ``None``, delete the reason instead.\n\n        :param reason: The reason string.\n        :type reason: :class:`bytes` or :class:`NoneType`\n\n        :return: ``None``\n\n        .. seealso::\n\n            :meth:`all_reasons`, which gives you a list of all supported\n            reasons which you might pass to this method.\n        \"\"\"\n        if reason is None:\n            self._delete_reason()\n        elif not isinstance(reason, bytes):\n            raise TypeError(\"reason must be None or a byte string\")\n        else:\n            reason = reason.lower().replace(b\" \", b\"\")\n            reason_code = [r.lower() for r in self._crl_reasons].index(reason)\n\n            new_reason_ext = _lib.ASN1_ENUMERATED_new()\n            _openssl_assert(new_reason_ext != _ffi.NULL)\n            new_reason_ext = _ffi.gc(new_reason_ext, _lib.ASN1_ENUMERATED_free)\n\n            set_result = _lib.ASN1_ENUMERATED_set(new_reason_ext, reason_code)\n            _openssl_assert(set_result != _ffi.NULL)\n\n            self._delete_reason()\n            add_result = _lib.X509_REVOKED_add1_ext_i2d(\n                self._revoked, _lib.NID_crl_reason, new_reason_ext, 0, 0\n            )\n            _openssl_assert(add_result == 1)\n\n    def get_reason(self) -> Optional[bytes]:\n        \"\"\"\n        Get the reason of this revocation.\n\n        :return: The reason, or ``None`` if there is none.\n        :rtype: bytes or NoneType\n\n        .. seealso::\n\n            :meth:`all_reasons`, which gives you a list of all supported\n            reasons this method might return.\n        \"\"\"\n        for i in range(_lib.X509_REVOKED_get_ext_count(self._revoked)):\n            ext = _lib.X509_REVOKED_get_ext(self._revoked, i)\n            obj = _lib.X509_EXTENSION_get_object(ext)\n            if _lib.OBJ_obj2nid(obj) == _lib.NID_crl_reason:\n                bio = _new_mem_buf()\n\n                print_result = _lib.X509V3_EXT_print(bio, ext, 0, 0)\n                if not print_result:\n                    print_result = _lib.M_ASN1_OCTET_STRING_print(\n                        bio, _lib.X509_EXTENSION_get_data(ext)\n                    )\n                    _openssl_assert(print_result != 0)\n\n                return _bio_to_string(bio)\n        return None\n\n    def all_reasons(self) -> List[bytes]:\n        \"\"\"\n        Return a list of all the supported reason strings.\n\n        This list is a copy; modifying it does not change the supported reason\n        strings.\n\n        :return: A list of reason strings.\n        :rtype: :class:`list` of :class:`bytes`\n        \"\"\"\n        return self._crl_reasons[:]\n\n    def set_rev_date(self, when: bytes) -> None:\n        \"\"\"\n        Set the revocation timestamp.\n\n        :param bytes when: The timestamp of the revocation,\n            as ASN.1 TIME.\n        :return: ``None``\n        \"\"\"\n        revocationDate = _new_asn1_time(when)\n        ret = _lib.X509_REVOKED_set_revocationDate(\n            self._revoked, revocationDate\n        )\n        _openssl_assert(ret == 1)\n\n    def get_rev_date(self) -> Optional[bytes]:\n        \"\"\"\n        Get the revocation timestamp.\n\n        :return: The timestamp of the revocation, as ASN.1 TIME.\n        :rtype: bytes\n        \"\"\"\n        dt = _lib.X509_REVOKED_get0_revocationDate(self._revoked)\n        return _get_asn1_time(dt)\n\n\n_RevokedInternal = Revoked\nutils.deprecated(\n    Revoked,\n    __name__,\n    (\n        \"CRL support in pyOpenSSL is deprecated. You should use the APIs \"\n        \"in cryptography.\"\n    ),\n    DeprecationWarning,\n    name=\"Revoked\",\n)\n\n\nclass CRL:\n    \"\"\"\n    A certificate revocation list.\n    \"\"\"\n\n    def __init__(self) -> None:\n        crl = _lib.X509_CRL_new()\n        self._crl = _ffi.gc(crl, _lib.X509_CRL_free)\n\n    def to_cryptography(self) -> x509.CertificateRevocationList:\n        \"\"\"\n        Export as a ``cryptography`` CRL.\n\n        :rtype: ``cryptography.x509.CertificateRevocationList``\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        from cryptography.x509 import load_der_x509_crl\n\n        der = _dump_crl_internal(FILETYPE_ASN1, self)\n        return load_der_x509_crl(der)\n\n    @classmethod\n    def from_cryptography(\n        cls, crypto_crl: x509.CertificateRevocationList\n    ) -> \"_CRLInternal\":\n        \"\"\"\n        Construct based on a ``cryptography`` *crypto_crl*.\n\n        :param crypto_crl: A ``cryptography`` certificate revocation list\n        :type crypto_crl: ``cryptography.x509.CertificateRevocationList``\n\n        :rtype: CRL\n\n        .. versionadded:: 17.1.0\n        \"\"\"\n        if not isinstance(crypto_crl, x509.CertificateRevocationList):\n            raise TypeError(\"Must be a certificate revocation list\")\n\n        from cryptography.hazmat.primitives.serialization import Encoding\n\n        der = crypto_crl.public_bytes(Encoding.DER)\n        return _load_crl_internal(FILETYPE_ASN1, der)\n\n    def get_revoked(self) -> Optional[Tuple[_RevokedInternal, ...]]:\n        \"\"\"\n        Return the revocations in this certificate revocation list.\n\n        These revocations will be provided by value, not by reference.\n        That means it's okay to mutate them: it won't affect this CRL.\n\n        :return: The revocations in this CRL.\n        :rtype: :class:`tuple` of :class:`Revocation`\n        \"\"\"\n        results = []\n        revoked_stack = _lib.X509_CRL_get_REVOKED(self._crl)\n        for i in range(_lib.sk_X509_REVOKED_num(revoked_stack)):\n            revoked = _lib.sk_X509_REVOKED_value(revoked_stack, i)\n            revoked_copy = _lib.X509_REVOKED_dup(revoked)\n            pyrev = _RevokedInternal.__new__(_RevokedInternal)\n            pyrev._revoked = _ffi.gc(revoked_copy, _lib.X509_REVOKED_free)\n            results.append(pyrev)\n        if results:\n            return tuple(results)\n        return None\n\n    def add_revoked(self, revoked: _RevokedInternal) -> None:\n        \"\"\"\n        Add a revoked (by value not reference) to the CRL structure\n\n        This revocation will be added by value, not by reference. That\n        means it's okay to mutate it after adding: it won't affect\n        this CRL.\n\n        :param Revoked revoked: The new revocation.\n        :return: ``None``\n        \"\"\"\n        copy = _lib.X509_REVOKED_dup(revoked._revoked)\n        _openssl_assert(copy != _ffi.NULL)\n\n        add_result = _lib.X509_CRL_add0_revoked(self._crl, copy)\n        _openssl_assert(add_result != 0)\n\n    def get_issuer(self) -> X509Name:\n        \"\"\"\n        Get the CRL's issuer.\n\n        .. versionadded:: 16.1.0\n\n        :rtype: X509Name\n        \"\"\"\n        _issuer = _lib.X509_NAME_dup(_lib.X509_CRL_get_issuer(self._crl))\n        _openssl_assert(_issuer != _ffi.NULL)\n        _issuer = _ffi.gc(_issuer, _lib.X509_NAME_free)\n        issuer = X509Name.__new__(X509Name)\n        issuer._name = _issuer\n        return issuer\n\n    def set_version(self, version: int) -> None:\n        \"\"\"\n        Set the CRL version.\n\n        .. versionadded:: 16.1.0\n\n        :param int version: The version of the CRL.\n        :return: ``None``\n        \"\"\"\n        _openssl_assert(_lib.X509_CRL_set_version(self._crl, version) != 0)\n\n    def set_lastUpdate(self, when: bytes) -> None:\n        \"\"\"\n        Set when the CRL was last updated.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        .. versionadded:: 16.1.0\n\n        :param bytes when: A timestamp string.\n        :return: ``None``\n        \"\"\"\n        lastUpdate = _new_asn1_time(when)\n        ret = _lib.X509_CRL_set1_lastUpdate(self._crl, lastUpdate)\n        _openssl_assert(ret == 1)\n\n    def set_nextUpdate(self, when: bytes) -> None:\n        \"\"\"\n        Set when the CRL will next be updated.\n\n        The timestamp is formatted as an ASN.1 TIME::\n\n            YYYYMMDDhhmmssZ\n\n        .. versionadded:: 16.1.0\n\n        :param bytes when: A timestamp string.\n        :return: ``None``\n        \"\"\"\n        nextUpdate = _new_asn1_time(when)\n        ret = _lib.X509_CRL_set1_nextUpdate(self._crl, nextUpdate)\n        _openssl_assert(ret == 1)\n\n    def sign(self, issuer_cert: X509, issuer_key: PKey, digest: bytes) -> None:\n        \"\"\"\n        Sign the CRL.\n\n        Signing a CRL enables clients to associate the CRL itself with an\n        issuer. Before a CRL is meaningful to other OpenSSL functions, it must\n        be signed by an issuer.\n\n        This method implicitly sets the issuer's name based on the issuer\n        certificate and private key used to sign the CRL.\n\n        .. versionadded:: 16.1.0\n\n        :param X509 issuer_cert: The issuer's certificate.\n        :param PKey issuer_key: The issuer's private key.\n        :param bytes digest: The digest method to sign the CRL with.\n        \"\"\"\n        digest_obj = _lib.EVP_get_digestbyname(digest)\n        _openssl_assert(digest_obj != _ffi.NULL)\n        _lib.X509_CRL_set_issuer_name(\n            self._crl, _lib.X509_get_subject_name(issuer_cert._x509)\n        )\n        _lib.X509_CRL_sort(self._crl)\n        result = _lib.X509_CRL_sign(self._crl, issuer_key._pkey, digest_obj)\n        _openssl_assert(result != 0)\n\n    def export(\n        self,\n        cert: X509,\n        key: PKey,\n        type: int = FILETYPE_PEM,\n        days: int = 100,\n        digest: bytes = _UNSPECIFIED,  # type: ignore\n    ) -> bytes:\n        \"\"\"\n        Export the CRL as a string.\n\n        :param X509 cert: The certificate used to sign the CRL.\n        :param PKey key: The key used to sign the CRL.\n        :param int type: The export format, either :data:`FILETYPE_PEM`,\n            :data:`FILETYPE_ASN1`, or :data:`FILETYPE_TEXT`.\n        :param int days: The number of days until the next update of this CRL.\n        :param bytes digest: The name of the message digest to use (eg\n            ``b\"sha256\"``).\n        :rtype: bytes\n        \"\"\"\n\n        if not isinstance(cert, X509):\n            raise TypeError(\"cert must be an X509 instance\")\n        if not isinstance(key, PKey):\n            raise TypeError(\"key must be a PKey instance\")\n        if not isinstance(type, int):\n            raise TypeError(\"type must be an integer\")\n\n        if digest is _UNSPECIFIED:\n            raise TypeError(\"digest must be provided\")\n\n        digest_obj = _lib.EVP_get_digestbyname(digest)\n        if digest_obj == _ffi.NULL:\n            raise ValueError(\"No such digest method\")\n\n        # A scratch time object to give different values to different CRL\n        # fields\n        sometime = _lib.ASN1_TIME_new()\n        _openssl_assert(sometime != _ffi.NULL)\n        sometime = _ffi.gc(sometime, _lib.ASN1_TIME_free)\n\n        ret = _lib.X509_gmtime_adj(sometime, 0)\n        _openssl_assert(ret != _ffi.NULL)\n        ret = _lib.X509_CRL_set1_lastUpdate(self._crl, sometime)\n        _openssl_assert(ret == 1)\n\n        ret = _lib.X509_gmtime_adj(sometime, days * 24 * 60 * 60)\n        _openssl_assert(ret != _ffi.NULL)\n        ret = _lib.X509_CRL_set1_nextUpdate(self._crl, sometime)\n        _openssl_assert(ret == 1)\n\n        ret = _lib.X509_CRL_set_issuer_name(\n            self._crl, _lib.X509_get_subject_name(cert._x509)\n        )\n        _openssl_assert(ret == 1)\n\n        sign_result = _lib.X509_CRL_sign(self._crl, key._pkey, digest_obj)\n        if not sign_result:\n            _raise_current_error()\n\n        return _dump_crl_internal(type, self)\n\n\n_CRLInternal = CRL\nutils.deprecated(\n    CRL,\n    __name__,\n    (\n        \"CRL support in pyOpenSSL is deprecated. You should use the APIs \"\n        \"in cryptography.\"\n    ),\n    DeprecationWarning,\n    name=\"CRL\",\n)\n\n\nclass _PassphraseHelper:\n    def __init__(\n        self,\n        type: int,\n        passphrase: Optional[PassphraseCallableT],\n        more_args: bool = False,\n        truncate: bool = False,\n    ) -> None:\n        if type != FILETYPE_PEM and passphrase is not None:\n            raise ValueError(\n                \"only FILETYPE_PEM key format supports encryption\"\n            )\n        self._passphrase = passphrase\n        self._more_args = more_args\n        self._truncate = truncate\n        self._problems: List[Exception] = []\n\n    @property\n    def callback(self) -> Any:\n        if self._passphrase is None:\n            return _ffi.NULL\n        elif isinstance(self._passphrase, bytes) or callable(self._passphrase):\n            return _ffi.callback(\"pem_password_cb\", self._read_passphrase)\n        else:\n            raise TypeError(\n                \"Last argument must be a byte string or a callable.\"\n            )\n\n    @property\n    def callback_args(self) -> Any:\n        if self._passphrase is None:\n            return _ffi.NULL\n        elif isinstance(self._passphrase, bytes) or callable(self._passphrase):\n            return _ffi.NULL\n        else:\n            raise TypeError(\n                \"Last argument must be a byte string or a callable.\"\n            )\n\n    def raise_if_problem(self, exceptionType: Type[Exception] = Error) -> None:\n        if self._problems:\n            # Flush the OpenSSL error queue\n            try:\n                _exception_from_error_queue(exceptionType)\n            except exceptionType:\n                pass\n\n            raise self._problems.pop(0)\n\n    def _read_passphrase(\n        self, buf: Any, size: int, rwflag: Any, userdata: Any\n    ) -> int:\n        try:\n            if callable(self._passphrase):\n                if self._more_args:\n                    result = self._passphrase(size, rwflag, userdata)\n                else:\n                    result = self._passphrase(rwflag)\n            else:\n                assert self._passphrase is not None\n                result = self._passphrase\n            if not isinstance(result, bytes):\n                raise ValueError(\"Bytes expected\")\n            if len(result) > size:\n                if self._truncate:\n                    result = result[:size]\n                else:\n                    raise ValueError(\n                        \"passphrase returned by callback is too long\"\n                    )\n            for i in range(len(result)):\n                buf[i] = result[i : i + 1]\n            return len(result)\n        except Exception as e:\n            self._problems.append(e)\n            return 0\n\n\ndef load_publickey(type: int, buffer: Union[str, bytes]) -> PKey:\n    \"\"\"\n    Load a public key from a buffer.\n\n    :param type: The file type (one of :data:`FILETYPE_PEM`,\n        :data:`FILETYPE_ASN1`).\n    :param buffer: The buffer the key is stored in.\n    :type buffer: A Python string object, either unicode or bytestring.\n    :return: The PKey object.\n    :rtype: :class:`PKey`\n    \"\"\"\n    if isinstance(buffer, str):\n        buffer = buffer.encode(\"ascii\")\n\n    bio = _new_mem_buf(buffer)\n\n    if type == FILETYPE_PEM:\n        evp_pkey = _lib.PEM_read_bio_PUBKEY(\n            bio, _ffi.NULL, _ffi.NULL, _ffi.NULL\n        )\n    elif type == FILETYPE_ASN1:\n        evp_pkey = _lib.d2i_PUBKEY_bio(bio, _ffi.NULL)\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    if evp_pkey == _ffi.NULL:\n        _raise_current_error()\n\n    pkey = PKey.__new__(PKey)\n    pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free)\n    pkey._only_public = True\n    return pkey\n\n\ndef load_privatekey(\n    type: int,\n    buffer: Union[str, bytes],\n    passphrase: Optional[PassphraseCallableT] = None,\n) -> PKey:\n    \"\"\"\n    Load a private key (PKey) from the string *buffer* encoded with the type\n    *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n    :param buffer: The buffer the key is stored in\n    :param passphrase: (optional) if encrypted PEM format, this can be\n                       either the passphrase to use, or a callback for\n                       providing the passphrase.\n\n    :return: The PKey object\n    \"\"\"\n    if isinstance(buffer, str):\n        buffer = buffer.encode(\"ascii\")\n\n    bio = _new_mem_buf(buffer)\n\n    helper = _PassphraseHelper(type, passphrase)\n    if type == FILETYPE_PEM:\n        evp_pkey = _lib.PEM_read_bio_PrivateKey(\n            bio, _ffi.NULL, helper.callback, helper.callback_args\n        )\n        helper.raise_if_problem()\n    elif type == FILETYPE_ASN1:\n        evp_pkey = _lib.d2i_PrivateKey_bio(bio, _ffi.NULL)\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    if evp_pkey == _ffi.NULL:\n        _raise_current_error()\n\n    pkey = PKey.__new__(PKey)\n    pkey._pkey = _ffi.gc(evp_pkey, _lib.EVP_PKEY_free)\n    return pkey\n\n\ndef dump_certificate_request(type: int, req: X509Req) -> bytes:\n    \"\"\"\n    Dump the certificate request *req* into a buffer string encoded with the\n    type *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n    :param req: The certificate request to dump\n    :return: The buffer with the dumped certificate request in\n    \"\"\"\n    bio = _new_mem_buf()\n\n    if type == FILETYPE_PEM:\n        result_code = _lib.PEM_write_bio_X509_REQ(bio, req._req)\n    elif type == FILETYPE_ASN1:\n        result_code = _lib.i2d_X509_REQ_bio(bio, req._req)\n    elif type == FILETYPE_TEXT:\n        result_code = _lib.X509_REQ_print_ex(bio, req._req, 0, 0)\n    else:\n        raise ValueError(\n            \"type argument must be FILETYPE_PEM, FILETYPE_ASN1, or \"\n            \"FILETYPE_TEXT\"\n        )\n\n    _openssl_assert(result_code != 0)\n\n    return _bio_to_string(bio)\n\n\ndef load_certificate_request(type: int, buffer: bytes) -> X509Req:\n    \"\"\"\n    Load a certificate request (X509Req) from the string *buffer* encoded with\n    the type *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n    :param buffer: The buffer the certificate request is stored in\n    :return: The X509Req object\n    \"\"\"\n    if isinstance(buffer, str):\n        buffer = buffer.encode(\"ascii\")\n\n    bio = _new_mem_buf(buffer)\n\n    if type == FILETYPE_PEM:\n        req = _lib.PEM_read_bio_X509_REQ(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)\n    elif type == FILETYPE_ASN1:\n        req = _lib.d2i_X509_REQ_bio(bio, _ffi.NULL)\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    _openssl_assert(req != _ffi.NULL)\n\n    x509req = X509Req.__new__(X509Req)\n    x509req._req = _ffi.gc(req, _lib.X509_REQ_free)\n    return x509req\n\n\ndef sign(pkey: PKey, data: Union[str, bytes], digest: str) -> bytes:\n    \"\"\"\n    Sign a data string using the given key and message digest.\n\n    :param pkey: PKey to sign with\n    :param data: data to be signed\n    :param digest: message digest to use\n    :return: signature\n\n    .. versionadded:: 0.11\n    \"\"\"\n    data = _text_to_bytes_and_warn(\"data\", data)\n\n    digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))\n    if digest_obj == _ffi.NULL:\n        raise ValueError(\"No such digest method\")\n\n    md_ctx = _lib.EVP_MD_CTX_new()\n    md_ctx = _ffi.gc(md_ctx, _lib.EVP_MD_CTX_free)\n\n    _lib.EVP_SignInit(md_ctx, digest_obj)\n    _lib.EVP_SignUpdate(md_ctx, data, len(data))\n\n    length = _lib.EVP_PKEY_size(pkey._pkey)\n    _openssl_assert(length > 0)\n    signature_buffer = _ffi.new(\"unsigned char[]\", length)\n    signature_length = _ffi.new(\"unsigned int *\")\n    final_result = _lib.EVP_SignFinal(\n        md_ctx, signature_buffer, signature_length, pkey._pkey\n    )\n    _openssl_assert(final_result == 1)\n\n    return _ffi.buffer(signature_buffer, signature_length[0])[:]\n\n\nutils.deprecated(\n    sign,\n    __name__,\n    \"sign() is deprecated. Use the equivalent APIs in cryptography.\",\n    DeprecationWarning,\n    name=\"sign\",\n)\n\n\ndef verify(\n    cert: X509, signature: bytes, data: Union[str, bytes], digest: str\n) -> None:\n    \"\"\"\n    Verify the signature for a data string.\n\n    :param cert: signing certificate (X509 object) corresponding to the\n        private key which generated the signature.\n    :param signature: signature returned by sign function\n    :param data: data to be verified\n    :param digest: message digest to use\n    :return: ``None`` if the signature is correct, raise exception otherwise.\n\n    .. versionadded:: 0.11\n    \"\"\"\n    data = _text_to_bytes_and_warn(\"data\", data)\n\n    digest_obj = _lib.EVP_get_digestbyname(_byte_string(digest))\n    if digest_obj == _ffi.NULL:\n        raise ValueError(\"No such digest method\")\n\n    pkey = _lib.X509_get_pubkey(cert._x509)\n    _openssl_assert(pkey != _ffi.NULL)\n    pkey = _ffi.gc(pkey, _lib.EVP_PKEY_free)\n\n    md_ctx = _lib.EVP_MD_CTX_new()\n    md_ctx = _ffi.gc(md_ctx, _lib.EVP_MD_CTX_free)\n\n    _lib.EVP_VerifyInit(md_ctx, digest_obj)\n    _lib.EVP_VerifyUpdate(md_ctx, data, len(data))\n    verify_result = _lib.EVP_VerifyFinal(\n        md_ctx, signature, len(signature), pkey\n    )\n\n    if verify_result != 1:\n        _raise_current_error()\n\n\nutils.deprecated(\n    verify,\n    __name__,\n    \"verify() is deprecated. Use the equivalent APIs in cryptography.\",\n    DeprecationWarning,\n    name=\"verify\",\n)\n\n\ndef dump_crl(type: int, crl: _CRLInternal) -> bytes:\n    \"\"\"\n    Dump a certificate revocation list to a buffer.\n\n    :param type: The file type (one of ``FILETYPE_PEM``, ``FILETYPE_ASN1``, or\n        ``FILETYPE_TEXT``).\n    :param CRL crl: The CRL to dump.\n\n    :return: The buffer with the CRL.\n    :rtype: bytes\n    \"\"\"\n    bio = _new_mem_buf()\n\n    if type == FILETYPE_PEM:\n        ret = _lib.PEM_write_bio_X509_CRL(bio, crl._crl)\n    elif type == FILETYPE_ASN1:\n        ret = _lib.i2d_X509_CRL_bio(bio, crl._crl)\n    elif type == FILETYPE_TEXT:\n        ret = _lib.X509_CRL_print(bio, crl._crl)\n    else:\n        raise ValueError(\n            \"type argument must be FILETYPE_PEM, FILETYPE_ASN1, or \"\n            \"FILETYPE_TEXT\"\n        )\n\n    _openssl_assert(ret == 1)\n    return _bio_to_string(bio)\n\n\n_dump_crl_internal = dump_crl\nutils.deprecated(\n    dump_crl,\n    __name__,\n    (\n        \"CRL support in pyOpenSSL is deprecated. You should use the APIs \"\n        \"in cryptography.\"\n    ),\n    DeprecationWarning,\n    name=\"dump_crl\",\n)\n\n\ndef load_crl(type: int, buffer: Union[str, bytes]) -> _CRLInternal:\n    \"\"\"\n    Load Certificate Revocation List (CRL) data from a string *buffer*.\n    *buffer* encoded with the type *type*.\n\n    :param type: The file type (one of FILETYPE_PEM, FILETYPE_ASN1)\n    :param buffer: The buffer the CRL is stored in\n\n    :return: The CRL object\n    \"\"\"\n    if isinstance(buffer, str):\n        buffer = buffer.encode(\"ascii\")\n\n    bio = _new_mem_buf(buffer)\n\n    if type == FILETYPE_PEM:\n        crl = _lib.PEM_read_bio_X509_CRL(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)\n    elif type == FILETYPE_ASN1:\n        crl = _lib.d2i_X509_CRL_bio(bio, _ffi.NULL)\n    else:\n        raise ValueError(\"type argument must be FILETYPE_PEM or FILETYPE_ASN1\")\n\n    if crl == _ffi.NULL:\n        _raise_current_error()\n\n    result = _CRLInternal.__new__(_CRLInternal)\n    result._crl = _ffi.gc(crl, _lib.X509_CRL_free)\n    return result\n\n\n_load_crl_internal = load_crl\nutils.deprecated(\n    load_crl,\n    __name__,\n    (\n        \"CRL support in pyOpenSSL is deprecated. You should use the APIs \"\n        \"in cryptography.\"\n    ),\n    DeprecationWarning,\n    name=\"load_crl\",\n)\n", "src/OpenSSL/_util.py": "import os\nimport sys\nimport warnings\nfrom typing import Any, Callable, NoReturn, Type, Union\n\nfrom cryptography.hazmat.bindings.openssl.binding import Binding\n\nStrOrBytesPath = Union[str, bytes, os.PathLike]\n\nbinding = Binding()\nffi = binding.ffi\nlib = binding.lib\n\n\n# This is a special CFFI allocator that does not bother to zero its memory\n# after allocation. This has vastly better performance on large allocations and\n# so should be used whenever we don't need the memory zeroed out.\nno_zero_allocator = ffi.new_allocator(should_clear_after_alloc=False)\n\n\ndef text(charp: Any) -> str:\n    \"\"\"\n    Get a native string type representing of the given CFFI ``char*`` object.\n\n    :param charp: A C-style string represented using CFFI.\n\n    :return: :class:`str`\n    \"\"\"\n    if not charp:\n        return \"\"\n    return ffi.string(charp).decode(\"utf-8\")\n\n\ndef exception_from_error_queue(exception_type: Type[Exception]) -> NoReturn:\n    \"\"\"\n    Convert an OpenSSL library failure into a Python exception.\n\n    When a call to the native OpenSSL library fails, this is usually signalled\n    by the return value, and an error code is stored in an error queue\n    associated with the current thread. The err library provides functions to\n    obtain these error codes and textual error messages.\n    \"\"\"\n    errors = []\n\n    while True:\n        error = lib.ERR_get_error()\n        if error == 0:\n            break\n        errors.append(\n            (\n                text(lib.ERR_lib_error_string(error)),\n                text(lib.ERR_func_error_string(error)),\n                text(lib.ERR_reason_error_string(error)),\n            )\n        )\n\n    raise exception_type(errors)\n\n\ndef make_assert(error: Type[Exception]) -> Callable[[bool], Any]:\n    \"\"\"\n    Create an assert function that uses :func:`exception_from_error_queue` to\n    raise an exception wrapped by *error*.\n    \"\"\"\n\n    def openssl_assert(ok: bool) -> None:\n        \"\"\"\n        If *ok* is not True, retrieve the error from OpenSSL and raise it.\n        \"\"\"\n        if ok is not True:\n            exception_from_error_queue(error)\n\n    return openssl_assert\n\n\ndef path_bytes(s: StrOrBytesPath) -> bytes:\n    \"\"\"\n    Convert a Python path to a :py:class:`bytes` for the path which can be\n    passed into an OpenSSL API accepting a filename.\n\n    :param s: A path (valid for os.fspath).\n\n    :return: An instance of :py:class:`bytes`.\n    \"\"\"\n    b = os.fspath(s)\n\n    if isinstance(b, str):\n        return b.encode(sys.getfilesystemencoding())\n    else:\n        return b\n\n\ndef byte_string(s: str) -> bytes:\n    return s.encode(\"charmap\")\n\n\n# A marker object to observe whether some optional arguments are passed any\n# value or not.\nUNSPECIFIED = object()\n\n_TEXT_WARNING = \"str for {0} is no longer accepted, use bytes\"\n\n\ndef text_to_bytes_and_warn(label: str, obj: Any) -> Any:\n    \"\"\"\n    If ``obj`` is text, emit a warning that it should be bytes instead and try\n    to convert it to bytes automatically.\n\n    :param str label: The name of the parameter from which ``obj`` was taken\n        (so a developer can easily find the source of the problem and correct\n        it).\n\n    :return: If ``obj`` is the text string type, a ``bytes`` object giving the\n        UTF-8 encoding of that text is returned.  Otherwise, ``obj`` itself is\n        returned.\n    \"\"\"\n    if isinstance(obj, str):\n        warnings.warn(\n            _TEXT_WARNING.format(label),\n            category=DeprecationWarning,\n            stacklevel=3,\n        )\n        return obj.encode(\"utf-8\")\n    return obj\n", "src/OpenSSL/__init__.py": "# Copyright (C) AB Strakt\n# See LICENSE for details.\n\n\"\"\"\npyOpenSSL - A simple wrapper around the OpenSSL library\n\"\"\"\n\nfrom OpenSSL import SSL, crypto\nfrom OpenSSL.version import (\n    __author__,\n    __copyright__,\n    __email__,\n    __license__,\n    __summary__,\n    __title__,\n    __uri__,\n    __version__,\n)\n\n__all__ = [\n    \"SSL\",\n    \"crypto\",\n    \"__author__\",\n    \"__copyright__\",\n    \"__email__\",\n    \"__license__\",\n    \"__summary__\",\n    \"__title__\",\n    \"__uri__\",\n    \"__version__\",\n]\n", "src/OpenSSL/SSL.py": "import os\nimport socket\nimport typing\nfrom errno import errorcode\nfrom functools import partial, wraps\nfrom itertools import chain, count\nfrom sys import platform\nfrom typing import Any, Callable, List, Optional, Sequence, Tuple, TypeVar\nfrom weakref import WeakValueDictionary\n\nfrom OpenSSL._util import (\n    StrOrBytesPath as _StrOrBytesPath,\n)\nfrom OpenSSL._util import (\n    exception_from_error_queue as _exception_from_error_queue,\n)\nfrom OpenSSL._util import (\n    ffi as _ffi,\n)\nfrom OpenSSL._util import (\n    lib as _lib,\n)\nfrom OpenSSL._util import (\n    make_assert as _make_assert,\n)\nfrom OpenSSL._util import (\n    no_zero_allocator as _no_zero_allocator,\n)\nfrom OpenSSL._util import (\n    path_bytes as _path_bytes,\n)\nfrom OpenSSL._util import (\n    text_to_bytes_and_warn as _text_to_bytes_and_warn,\n)\nfrom OpenSSL.crypto import (\n    FILETYPE_PEM,\n    X509,\n    PKey,\n    X509Name,\n    X509Store,\n    _EllipticCurve,\n    _PassphraseHelper,\n)\n\n__all__ = [\n    \"OPENSSL_VERSION_NUMBER\",\n    \"SSLEAY_VERSION\",\n    \"SSLEAY_CFLAGS\",\n    \"SSLEAY_PLATFORM\",\n    \"SSLEAY_DIR\",\n    \"SSLEAY_BUILT_ON\",\n    \"OPENSSL_VERSION\",\n    \"OPENSSL_CFLAGS\",\n    \"OPENSSL_PLATFORM\",\n    \"OPENSSL_DIR\",\n    \"OPENSSL_BUILT_ON\",\n    \"SENT_SHUTDOWN\",\n    \"RECEIVED_SHUTDOWN\",\n    \"SSLv23_METHOD\",\n    \"TLSv1_METHOD\",\n    \"TLSv1_1_METHOD\",\n    \"TLSv1_2_METHOD\",\n    \"TLS_METHOD\",\n    \"TLS_SERVER_METHOD\",\n    \"TLS_CLIENT_METHOD\",\n    \"DTLS_METHOD\",\n    \"DTLS_SERVER_METHOD\",\n    \"DTLS_CLIENT_METHOD\",\n    \"SSL3_VERSION\",\n    \"TLS1_VERSION\",\n    \"TLS1_1_VERSION\",\n    \"TLS1_2_VERSION\",\n    \"TLS1_3_VERSION\",\n    \"OP_NO_SSLv2\",\n    \"OP_NO_SSLv3\",\n    \"OP_NO_TLSv1\",\n    \"OP_NO_TLSv1_1\",\n    \"OP_NO_TLSv1_2\",\n    \"MODE_RELEASE_BUFFERS\",\n    \"OP_SINGLE_DH_USE\",\n    \"OP_SINGLE_ECDH_USE\",\n    \"OP_EPHEMERAL_RSA\",\n    \"OP_MICROSOFT_SESS_ID_BUG\",\n    \"OP_NETSCAPE_CHALLENGE_BUG\",\n    \"OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\",\n    \"OP_SSLREF2_REUSE_CERT_TYPE_BUG\",\n    \"OP_MICROSOFT_BIG_SSLV3_BUFFER\",\n    \"OP_MSIE_SSLV2_RSA_PADDING\",\n    \"OP_SSLEAY_080_CLIENT_DH_BUG\",\n    \"OP_TLS_D5_BUG\",\n    \"OP_TLS_BLOCK_PADDING_BUG\",\n    \"OP_DONT_INSERT_EMPTY_FRAGMENTS\",\n    \"OP_CIPHER_SERVER_PREFERENCE\",\n    \"OP_TLS_ROLLBACK_BUG\",\n    \"OP_PKCS1_CHECK_1\",\n    \"OP_PKCS1_CHECK_2\",\n    \"OP_NETSCAPE_CA_DN_BUG\",\n    \"OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG\",\n    \"OP_NO_COMPRESSION\",\n    \"OP_NO_QUERY_MTU\",\n    \"OP_COOKIE_EXCHANGE\",\n    \"OP_NO_TICKET\",\n    \"OP_ALL\",\n    \"VERIFY_PEER\",\n    \"VERIFY_FAIL_IF_NO_PEER_CERT\",\n    \"VERIFY_CLIENT_ONCE\",\n    \"VERIFY_NONE\",\n    \"SESS_CACHE_OFF\",\n    \"SESS_CACHE_CLIENT\",\n    \"SESS_CACHE_SERVER\",\n    \"SESS_CACHE_BOTH\",\n    \"SESS_CACHE_NO_AUTO_CLEAR\",\n    \"SESS_CACHE_NO_INTERNAL_LOOKUP\",\n    \"SESS_CACHE_NO_INTERNAL_STORE\",\n    \"SESS_CACHE_NO_INTERNAL\",\n    \"SSL_ST_CONNECT\",\n    \"SSL_ST_ACCEPT\",\n    \"SSL_ST_MASK\",\n    \"SSL_CB_LOOP\",\n    \"SSL_CB_EXIT\",\n    \"SSL_CB_READ\",\n    \"SSL_CB_WRITE\",\n    \"SSL_CB_ALERT\",\n    \"SSL_CB_READ_ALERT\",\n    \"SSL_CB_WRITE_ALERT\",\n    \"SSL_CB_ACCEPT_LOOP\",\n    \"SSL_CB_ACCEPT_EXIT\",\n    \"SSL_CB_CONNECT_LOOP\",\n    \"SSL_CB_CONNECT_EXIT\",\n    \"SSL_CB_HANDSHAKE_START\",\n    \"SSL_CB_HANDSHAKE_DONE\",\n    \"Error\",\n    \"WantReadError\",\n    \"WantWriteError\",\n    \"WantX509LookupError\",\n    \"ZeroReturnError\",\n    \"SysCallError\",\n    \"NO_OVERLAPPING_PROTOCOLS\",\n    \"SSLeay_version\",\n    \"Session\",\n    \"Context\",\n    \"Connection\",\n    \"X509VerificationCodes\",\n]\n\n\nOPENSSL_VERSION_NUMBER: int = _lib.OPENSSL_VERSION_NUMBER\nOPENSSL_VERSION: int = _lib.OPENSSL_VERSION\nOPENSSL_CFLAGS: int = _lib.OPENSSL_CFLAGS\nOPENSSL_PLATFORM: int = _lib.OPENSSL_PLATFORM\nOPENSSL_DIR: int = _lib.OPENSSL_DIR\nOPENSSL_BUILT_ON: int = _lib.OPENSSL_BUILT_ON\n\nSSLEAY_VERSION = OPENSSL_VERSION\nSSLEAY_CFLAGS = OPENSSL_CFLAGS\nSSLEAY_PLATFORM = OPENSSL_PLATFORM\nSSLEAY_DIR = OPENSSL_DIR\nSSLEAY_BUILT_ON = OPENSSL_BUILT_ON\n\nSENT_SHUTDOWN = _lib.SSL_SENT_SHUTDOWN\nRECEIVED_SHUTDOWN = _lib.SSL_RECEIVED_SHUTDOWN\n\nSSLv23_METHOD = 3\nTLSv1_METHOD = 4\nTLSv1_1_METHOD = 5\nTLSv1_2_METHOD = 6\nTLS_METHOD = 7\nTLS_SERVER_METHOD = 8\nTLS_CLIENT_METHOD = 9\nDTLS_METHOD = 10\nDTLS_SERVER_METHOD = 11\nDTLS_CLIENT_METHOD = 12\n\nSSL3_VERSION: int = _lib.SSL3_VERSION\nTLS1_VERSION: int = _lib.TLS1_VERSION\nTLS1_1_VERSION: int = _lib.TLS1_1_VERSION\nTLS1_2_VERSION: int = _lib.TLS1_2_VERSION\nTLS1_3_VERSION: int = _lib.TLS1_3_VERSION\n\nOP_NO_SSLv2: int = _lib.SSL_OP_NO_SSLv2\nOP_NO_SSLv3: int = _lib.SSL_OP_NO_SSLv3\nOP_NO_TLSv1: int = _lib.SSL_OP_NO_TLSv1\nOP_NO_TLSv1_1: int = _lib.SSL_OP_NO_TLSv1_1\nOP_NO_TLSv1_2: int = _lib.SSL_OP_NO_TLSv1_2\ntry:\n    OP_NO_TLSv1_3: int = _lib.SSL_OP_NO_TLSv1_3\n    __all__.append(\"OP_NO_TLSv1_3\")\nexcept AttributeError:\n    pass\n\nMODE_RELEASE_BUFFERS: int = _lib.SSL_MODE_RELEASE_BUFFERS\n\nOP_SINGLE_DH_USE: int = _lib.SSL_OP_SINGLE_DH_USE\nOP_SINGLE_ECDH_USE: int = _lib.SSL_OP_SINGLE_ECDH_USE\nOP_EPHEMERAL_RSA: int = _lib.SSL_OP_EPHEMERAL_RSA\nOP_MICROSOFT_SESS_ID_BUG: int = _lib.SSL_OP_MICROSOFT_SESS_ID_BUG\nOP_NETSCAPE_CHALLENGE_BUG: int = _lib.SSL_OP_NETSCAPE_CHALLENGE_BUG\nOP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: int = (\n    _lib.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG\n)\nOP_SSLREF2_REUSE_CERT_TYPE_BUG: int = _lib.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG\nOP_MICROSOFT_BIG_SSLV3_BUFFER: int = _lib.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER\nOP_MSIE_SSLV2_RSA_PADDING: int = _lib.SSL_OP_MSIE_SSLV2_RSA_PADDING\nOP_SSLEAY_080_CLIENT_DH_BUG: int = _lib.SSL_OP_SSLEAY_080_CLIENT_DH_BUG\nOP_TLS_D5_BUG: int = _lib.SSL_OP_TLS_D5_BUG\nOP_TLS_BLOCK_PADDING_BUG: int = _lib.SSL_OP_TLS_BLOCK_PADDING_BUG\nOP_DONT_INSERT_EMPTY_FRAGMENTS: int = _lib.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS\nOP_CIPHER_SERVER_PREFERENCE: int = _lib.SSL_OP_CIPHER_SERVER_PREFERENCE\nOP_TLS_ROLLBACK_BUG: int = _lib.SSL_OP_TLS_ROLLBACK_BUG\nOP_PKCS1_CHECK_1 = _lib.SSL_OP_PKCS1_CHECK_1\nOP_PKCS1_CHECK_2: int = _lib.SSL_OP_PKCS1_CHECK_2\nOP_NETSCAPE_CA_DN_BUG: int = _lib.SSL_OP_NETSCAPE_CA_DN_BUG\nOP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: int = (\n    _lib.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG\n)\nOP_NO_COMPRESSION: int = _lib.SSL_OP_NO_COMPRESSION\n\nOP_NO_QUERY_MTU: int = _lib.SSL_OP_NO_QUERY_MTU\nOP_COOKIE_EXCHANGE: int = _lib.SSL_OP_COOKIE_EXCHANGE\nOP_NO_TICKET: int = _lib.SSL_OP_NO_TICKET\n\ntry:\n    OP_NO_RENEGOTIATION: int = _lib.SSL_OP_NO_RENEGOTIATION\n    __all__.append(\"OP_NO_RENEGOTIATION\")\nexcept AttributeError:\n    pass\n\ntry:\n    OP_IGNORE_UNEXPECTED_EOF: int = _lib.SSL_OP_IGNORE_UNEXPECTED_EOF\n    __all__.append(\"OP_IGNORE_UNEXPECTED_EOF\")\nexcept AttributeError:\n    pass\n\ntry:\n    OP_LEGACY_SERVER_CONNECT: int = _lib.SSL_OP_LEGACY_SERVER_CONNECT\n    __all__.append(\"OP_LEGACY_SERVER_CONNECT\")\nexcept AttributeError:\n    pass\n\nOP_ALL: int = _lib.SSL_OP_ALL\n\nVERIFY_PEER: int = _lib.SSL_VERIFY_PEER\nVERIFY_FAIL_IF_NO_PEER_CERT: int = _lib.SSL_VERIFY_FAIL_IF_NO_PEER_CERT\nVERIFY_CLIENT_ONCE: int = _lib.SSL_VERIFY_CLIENT_ONCE\nVERIFY_NONE: int = _lib.SSL_VERIFY_NONE\n\nSESS_CACHE_OFF: int = _lib.SSL_SESS_CACHE_OFF\nSESS_CACHE_CLIENT: int = _lib.SSL_SESS_CACHE_CLIENT\nSESS_CACHE_SERVER: int = _lib.SSL_SESS_CACHE_SERVER\nSESS_CACHE_BOTH: int = _lib.SSL_SESS_CACHE_BOTH\nSESS_CACHE_NO_AUTO_CLEAR: int = _lib.SSL_SESS_CACHE_NO_AUTO_CLEAR\nSESS_CACHE_NO_INTERNAL_LOOKUP: int = _lib.SSL_SESS_CACHE_NO_INTERNAL_LOOKUP\nSESS_CACHE_NO_INTERNAL_STORE: int = _lib.SSL_SESS_CACHE_NO_INTERNAL_STORE\nSESS_CACHE_NO_INTERNAL: int = _lib.SSL_SESS_CACHE_NO_INTERNAL\n\nSSL_ST_CONNECT: int = _lib.SSL_ST_CONNECT\nSSL_ST_ACCEPT: int = _lib.SSL_ST_ACCEPT\nSSL_ST_MASK: int = _lib.SSL_ST_MASK\n\nSSL_CB_LOOP: int = _lib.SSL_CB_LOOP\nSSL_CB_EXIT: int = _lib.SSL_CB_EXIT\nSSL_CB_READ: int = _lib.SSL_CB_READ\nSSL_CB_WRITE: int = _lib.SSL_CB_WRITE\nSSL_CB_ALERT: int = _lib.SSL_CB_ALERT\nSSL_CB_READ_ALERT: int = _lib.SSL_CB_READ_ALERT\nSSL_CB_WRITE_ALERT: int = _lib.SSL_CB_WRITE_ALERT\nSSL_CB_ACCEPT_LOOP: int = _lib.SSL_CB_ACCEPT_LOOP\nSSL_CB_ACCEPT_EXIT: int = _lib.SSL_CB_ACCEPT_EXIT\nSSL_CB_CONNECT_LOOP: int = _lib.SSL_CB_CONNECT_LOOP\nSSL_CB_CONNECT_EXIT: int = _lib.SSL_CB_CONNECT_EXIT\nSSL_CB_HANDSHAKE_START: int = _lib.SSL_CB_HANDSHAKE_START\nSSL_CB_HANDSHAKE_DONE: int = _lib.SSL_CB_HANDSHAKE_DONE\n\n_T = TypeVar(\"_T\")\n_SetVerifyCallback = Callable[[\"Connection\", X509, int, int, int], bool]\n\n\nclass X509VerificationCodes:\n    \"\"\"\n    Success and error codes for X509 verification, as returned by the\n    underlying ``X509_STORE_CTX_get_error()`` function and passed by pyOpenSSL\n    to verification callback functions.\n\n    See `OpenSSL Verification Errors\n    <https://www.openssl.org/docs/manmaster/man3/X509_verify_cert_error_string.html#ERROR-CODES>`_\n    for details.\n    \"\"\"\n\n    OK = _lib.X509_V_OK\n    ERR_UNABLE_TO_GET_ISSUER_CERT = _lib.X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT\n    ERR_UNABLE_TO_GET_CRL = _lib.X509_V_ERR_UNABLE_TO_GET_CRL\n    ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE = (\n        _lib.X509_V_ERR_UNABLE_TO_DECRYPT_CERT_SIGNATURE\n    )\n    ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE = (\n        _lib.X509_V_ERR_UNABLE_TO_DECRYPT_CRL_SIGNATURE\n    )\n    ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY = (\n        _lib.X509_V_ERR_UNABLE_TO_DECODE_ISSUER_PUBLIC_KEY\n    )\n    ERR_CERT_SIGNATURE_FAILURE = _lib.X509_V_ERR_CERT_SIGNATURE_FAILURE\n    ERR_CRL_SIGNATURE_FAILURE = _lib.X509_V_ERR_CRL_SIGNATURE_FAILURE\n    ERR_CERT_NOT_YET_VALID = _lib.X509_V_ERR_CERT_NOT_YET_VALID\n    ERR_CERT_HAS_EXPIRED = _lib.X509_V_ERR_CERT_HAS_EXPIRED\n    ERR_CRL_NOT_YET_VALID = _lib.X509_V_ERR_CRL_NOT_YET_VALID\n    ERR_CRL_HAS_EXPIRED = _lib.X509_V_ERR_CRL_HAS_EXPIRED\n    ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD = (\n        _lib.X509_V_ERR_ERROR_IN_CERT_NOT_BEFORE_FIELD\n    )\n    ERR_ERROR_IN_CERT_NOT_AFTER_FIELD = (\n        _lib.X509_V_ERR_ERROR_IN_CERT_NOT_AFTER_FIELD\n    )\n    ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD = (\n        _lib.X509_V_ERR_ERROR_IN_CRL_LAST_UPDATE_FIELD\n    )\n    ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD = (\n        _lib.X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD\n    )\n    ERR_OUT_OF_MEM = _lib.X509_V_ERR_OUT_OF_MEM\n    ERR_DEPTH_ZERO_SELF_SIGNED_CERT = (\n        _lib.X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT\n    )\n    ERR_SELF_SIGNED_CERT_IN_CHAIN = _lib.X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN\n    ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY = (\n        _lib.X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY\n    )\n    ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE = (\n        _lib.X509_V_ERR_UNABLE_TO_VERIFY_LEAF_SIGNATURE\n    )\n    ERR_CERT_CHAIN_TOO_LONG = _lib.X509_V_ERR_CERT_CHAIN_TOO_LONG\n    ERR_CERT_REVOKED = _lib.X509_V_ERR_CERT_REVOKED\n    ERR_INVALID_CA = _lib.X509_V_ERR_INVALID_CA\n    ERR_PATH_LENGTH_EXCEEDED = _lib.X509_V_ERR_PATH_LENGTH_EXCEEDED\n    ERR_INVALID_PURPOSE = _lib.X509_V_ERR_INVALID_PURPOSE\n    ERR_CERT_UNTRUSTED = _lib.X509_V_ERR_CERT_UNTRUSTED\n    ERR_CERT_REJECTED = _lib.X509_V_ERR_CERT_REJECTED\n    ERR_SUBJECT_ISSUER_MISMATCH = _lib.X509_V_ERR_SUBJECT_ISSUER_MISMATCH\n    ERR_AKID_SKID_MISMATCH = _lib.X509_V_ERR_AKID_SKID_MISMATCH\n    ERR_AKID_ISSUER_SERIAL_MISMATCH = (\n        _lib.X509_V_ERR_AKID_ISSUER_SERIAL_MISMATCH\n    )\n    ERR_KEYUSAGE_NO_CERTSIGN = _lib.X509_V_ERR_KEYUSAGE_NO_CERTSIGN\n    ERR_UNABLE_TO_GET_CRL_ISSUER = _lib.X509_V_ERR_UNABLE_TO_GET_CRL_ISSUER\n    ERR_UNHANDLED_CRITICAL_EXTENSION = (\n        _lib.X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION\n    )\n    ERR_KEYUSAGE_NO_CRL_SIGN = _lib.X509_V_ERR_KEYUSAGE_NO_CRL_SIGN\n    ERR_UNHANDLED_CRITICAL_CRL_EXTENSION = (\n        _lib.X509_V_ERR_UNHANDLED_CRITICAL_CRL_EXTENSION\n    )\n    ERR_INVALID_NON_CA = _lib.X509_V_ERR_INVALID_NON_CA\n    ERR_PROXY_PATH_LENGTH_EXCEEDED = _lib.X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED\n    ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE = (\n        _lib.X509_V_ERR_KEYUSAGE_NO_DIGITAL_SIGNATURE\n    )\n    ERR_PROXY_CERTIFICATES_NOT_ALLOWED = (\n        _lib.X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED\n    )\n    ERR_INVALID_EXTENSION = _lib.X509_V_ERR_INVALID_EXTENSION\n    ERR_INVALID_POLICY_EXTENSION = _lib.X509_V_ERR_INVALID_POLICY_EXTENSION\n    ERR_NO_EXPLICIT_POLICY = _lib.X509_V_ERR_NO_EXPLICIT_POLICY\n    ERR_DIFFERENT_CRL_SCOPE = _lib.X509_V_ERR_DIFFERENT_CRL_SCOPE\n    ERR_UNSUPPORTED_EXTENSION_FEATURE = (\n        _lib.X509_V_ERR_UNSUPPORTED_EXTENSION_FEATURE\n    )\n    ERR_UNNESTED_RESOURCE = _lib.X509_V_ERR_UNNESTED_RESOURCE\n    ERR_PERMITTED_VIOLATION = _lib.X509_V_ERR_PERMITTED_VIOLATION\n    ERR_EXCLUDED_VIOLATION = _lib.X509_V_ERR_EXCLUDED_VIOLATION\n    ERR_SUBTREE_MINMAX = _lib.X509_V_ERR_SUBTREE_MINMAX\n    ERR_UNSUPPORTED_CONSTRAINT_TYPE = (\n        _lib.X509_V_ERR_UNSUPPORTED_CONSTRAINT_TYPE\n    )\n    ERR_UNSUPPORTED_CONSTRAINT_SYNTAX = (\n        _lib.X509_V_ERR_UNSUPPORTED_CONSTRAINT_SYNTAX\n    )\n    ERR_UNSUPPORTED_NAME_SYNTAX = _lib.X509_V_ERR_UNSUPPORTED_NAME_SYNTAX\n    ERR_CRL_PATH_VALIDATION_ERROR = _lib.X509_V_ERR_CRL_PATH_VALIDATION_ERROR\n    ERR_HOSTNAME_MISMATCH = _lib.X509_V_ERR_HOSTNAME_MISMATCH\n    ERR_EMAIL_MISMATCH = _lib.X509_V_ERR_EMAIL_MISMATCH\n    ERR_IP_ADDRESS_MISMATCH = _lib.X509_V_ERR_IP_ADDRESS_MISMATCH\n    ERR_APPLICATION_VERIFICATION = _lib.X509_V_ERR_APPLICATION_VERIFICATION\n\n\n# Taken from https://golang.org/src/crypto/x509/root_linux.go\n_CERTIFICATE_FILE_LOCATIONS = [\n    \"/etc/ssl/certs/ca-certificates.crt\",  # Debian/Ubuntu/Gentoo etc.\n    \"/etc/pki/tls/certs/ca-bundle.crt\",  # Fedora/RHEL 6\n    \"/etc/ssl/ca-bundle.pem\",  # OpenSUSE\n    \"/etc/pki/tls/cacert.pem\",  # OpenELEC\n    \"/etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem\",  # CentOS/RHEL 7\n]\n\n_CERTIFICATE_PATH_LOCATIONS = [\n    \"/etc/ssl/certs\",  # SLES10/SLES11\n]\n\n# These values are compared to output from cffi's ffi.string so they must be\n# byte strings.\n_CRYPTOGRAPHY_MANYLINUX_CA_DIR = b\"/opt/pyca/cryptography/openssl/certs\"\n_CRYPTOGRAPHY_MANYLINUX_CA_FILE = b\"/opt/pyca/cryptography/openssl/cert.pem\"\n\n\nclass Error(Exception):\n    \"\"\"\n    An error occurred in an `OpenSSL.SSL` API.\n    \"\"\"\n\n\n_raise_current_error = partial(_exception_from_error_queue, Error)\n_openssl_assert = _make_assert(Error)\n\n\nclass WantReadError(Error):\n    pass\n\n\nclass WantWriteError(Error):\n    pass\n\n\nclass WantX509LookupError(Error):\n    pass\n\n\nclass ZeroReturnError(Error):\n    pass\n\n\nclass SysCallError(Error):\n    pass\n\n\nclass _CallbackExceptionHelper:\n    \"\"\"\n    A base class for wrapper classes that allow for intelligent exception\n    handling in OpenSSL callbacks.\n\n    :ivar list _problems: Any exceptions that occurred while executing in a\n        context where they could not be raised in the normal way.  Typically\n        this is because OpenSSL has called into some Python code and requires a\n        return value.  The exceptions are saved to be raised later when it is\n        possible to do so.\n    \"\"\"\n\n    def __init__(self) -> None:\n        self._problems: List[Exception] = []\n\n    def raise_if_problem(self) -> None:\n        \"\"\"\n        Raise an exception from the OpenSSL error queue or that was previously\n        captured whe running a callback.\n        \"\"\"\n        if self._problems:\n            try:\n                _raise_current_error()\n            except Error:\n                pass\n            raise self._problems.pop(0)\n\n\nclass _VerifyHelper(_CallbackExceptionHelper):\n    \"\"\"\n    Wrap a callback such that it can be used as a certificate verification\n    callback.\n    \"\"\"\n\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ok, store_ctx):\n            x509 = _lib.X509_STORE_CTX_get_current_cert(store_ctx)\n            _lib.X509_up_ref(x509)\n            cert = X509._from_raw_x509_ptr(x509)\n            error_number = _lib.X509_STORE_CTX_get_error(store_ctx)\n            error_depth = _lib.X509_STORE_CTX_get_error_depth(store_ctx)\n\n            index = _lib.SSL_get_ex_data_X509_STORE_CTX_idx()\n            ssl = _lib.X509_STORE_CTX_get_ex_data(store_ctx, index)\n            connection = Connection._reverse_mapping[ssl]\n\n            try:\n                result = callback(\n                    connection, cert, error_number, error_depth, ok\n                )\n            except Exception as e:\n                self._problems.append(e)\n                return 0\n            else:\n                if result:\n                    _lib.X509_STORE_CTX_set_error(store_ctx, _lib.X509_V_OK)\n                    return 1\n                else:\n                    return 0\n\n        self.callback = _ffi.callback(\n            \"int (*)(int, X509_STORE_CTX *)\", wrapper\n        )\n\n\nNO_OVERLAPPING_PROTOCOLS = object()\n\n\nclass _ALPNSelectHelper(_CallbackExceptionHelper):\n    \"\"\"\n    Wrap a callback such that it can be used as an ALPN selection callback.\n    \"\"\"\n\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ssl, out, outlen, in_, inlen, arg):\n            try:\n                conn = Connection._reverse_mapping[ssl]\n\n                # The string passed to us is made up of multiple\n                # length-prefixed bytestrings. We need to split that into a\n                # list.\n                instr = _ffi.buffer(in_, inlen)[:]\n                protolist = []\n                while instr:\n                    encoded_len = instr[0]\n                    proto = instr[1 : encoded_len + 1]\n                    protolist.append(proto)\n                    instr = instr[encoded_len + 1 :]\n\n                # Call the callback\n                outbytes = callback(conn, protolist)\n                any_accepted = True\n                if outbytes is NO_OVERLAPPING_PROTOCOLS:\n                    outbytes = b\"\"\n                    any_accepted = False\n                elif not isinstance(outbytes, bytes):\n                    raise TypeError(\n                        \"ALPN callback must return a bytestring or the \"\n                        \"special NO_OVERLAPPING_PROTOCOLS sentinel value.\"\n                    )\n\n                # Save our callback arguments on the connection object to make\n                # sure that they don't get freed before OpenSSL can use them.\n                # Then, return them in the appropriate output parameters.\n                conn._alpn_select_callback_args = [\n                    _ffi.new(\"unsigned char *\", len(outbytes)),\n                    _ffi.new(\"unsigned char[]\", outbytes),\n                ]\n                outlen[0] = conn._alpn_select_callback_args[0][0]\n                out[0] = conn._alpn_select_callback_args[1]\n                if not any_accepted:\n                    return _lib.SSL_TLSEXT_ERR_NOACK\n                return _lib.SSL_TLSEXT_ERR_OK\n            except Exception as e:\n                self._problems.append(e)\n                return _lib.SSL_TLSEXT_ERR_ALERT_FATAL\n\n        self.callback = _ffi.callback(\n            (\n                \"int (*)(SSL *, unsigned char **, unsigned char *, \"\n                \"const unsigned char *, unsigned int, void *)\"\n            ),\n            wrapper,\n        )\n\n\nclass _OCSPServerCallbackHelper(_CallbackExceptionHelper):\n    \"\"\"\n    Wrap a callback such that it can be used as an OCSP callback for the server\n    side.\n\n    Annoyingly, OpenSSL defines one OCSP callback but uses it in two different\n    ways. For servers, that callback is expected to retrieve some OCSP data and\n    hand it to OpenSSL, and may return only SSL_TLSEXT_ERR_OK,\n    SSL_TLSEXT_ERR_FATAL, and SSL_TLSEXT_ERR_NOACK. For clients, that callback\n    is expected to check the OCSP data, and returns a negative value on error,\n    0 if the response is not acceptable, or positive if it is. These are\n    mutually exclusive return code behaviours, and they mean that we need two\n    helpers so that we always return an appropriate error code if the user's\n    code throws an exception.\n\n    Given that we have to have two helpers anyway, these helpers are a bit more\n    helpery than most: specifically, they hide a few more of the OpenSSL\n    functions so that the user has an easier time writing these callbacks.\n\n    This helper implements the server side.\n    \"\"\"\n\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ssl, cdata):\n            try:\n                conn = Connection._reverse_mapping[ssl]\n\n                # Extract the data if any was provided.\n                if cdata != _ffi.NULL:\n                    data = _ffi.from_handle(cdata)\n                else:\n                    data = None\n\n                # Call the callback.\n                ocsp_data = callback(conn, data)\n\n                if not isinstance(ocsp_data, bytes):\n                    raise TypeError(\"OCSP callback must return a bytestring.\")\n\n                # If the OCSP data was provided, we will pass it to OpenSSL.\n                # However, we have an early exit here: if no OCSP data was\n                # provided we will just exit out and tell OpenSSL that there\n                # is nothing to do.\n                if not ocsp_data:\n                    return 3  # SSL_TLSEXT_ERR_NOACK\n\n                # OpenSSL takes ownership of this data and expects it to have\n                # been allocated by OPENSSL_malloc.\n                ocsp_data_length = len(ocsp_data)\n                data_ptr = _lib.OPENSSL_malloc(ocsp_data_length)\n                _ffi.buffer(data_ptr, ocsp_data_length)[:] = ocsp_data\n\n                _lib.SSL_set_tlsext_status_ocsp_resp(\n                    ssl, data_ptr, ocsp_data_length\n                )\n\n                return 0\n            except Exception as e:\n                self._problems.append(e)\n                return 2  # SSL_TLSEXT_ERR_ALERT_FATAL\n\n        self.callback = _ffi.callback(\"int (*)(SSL *, void *)\", wrapper)\n\n\nclass _OCSPClientCallbackHelper(_CallbackExceptionHelper):\n    \"\"\"\n    Wrap a callback such that it can be used as an OCSP callback for the client\n    side.\n\n    Annoyingly, OpenSSL defines one OCSP callback but uses it in two different\n    ways. For servers, that callback is expected to retrieve some OCSP data and\n    hand it to OpenSSL, and may return only SSL_TLSEXT_ERR_OK,\n    SSL_TLSEXT_ERR_FATAL, and SSL_TLSEXT_ERR_NOACK. For clients, that callback\n    is expected to check the OCSP data, and returns a negative value on error,\n    0 if the response is not acceptable, or positive if it is. These are\n    mutually exclusive return code behaviours, and they mean that we need two\n    helpers so that we always return an appropriate error code if the user's\n    code throws an exception.\n\n    Given that we have to have two helpers anyway, these helpers are a bit more\n    helpery than most: specifically, they hide a few more of the OpenSSL\n    functions so that the user has an easier time writing these callbacks.\n\n    This helper implements the client side.\n    \"\"\"\n\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ssl, cdata):\n            try:\n                conn = Connection._reverse_mapping[ssl]\n\n                # Extract the data if any was provided.\n                if cdata != _ffi.NULL:\n                    data = _ffi.from_handle(cdata)\n                else:\n                    data = None\n\n                # Get the OCSP data.\n                ocsp_ptr = _ffi.new(\"unsigned char **\")\n                ocsp_len = _lib.SSL_get_tlsext_status_ocsp_resp(ssl, ocsp_ptr)\n                if ocsp_len < 0:\n                    # No OCSP data.\n                    ocsp_data = b\"\"\n                else:\n                    # Copy the OCSP data, then pass it to the callback.\n                    ocsp_data = _ffi.buffer(ocsp_ptr[0], ocsp_len)[:]\n\n                valid = callback(conn, ocsp_data, data)\n\n                # Return 1 on success or 0 on error.\n                return int(bool(valid))\n\n            except Exception as e:\n                self._problems.append(e)\n                # Return negative value if an exception is hit.\n                return -1\n\n        self.callback = _ffi.callback(\"int (*)(SSL *, void *)\", wrapper)\n\n\nclass _CookieGenerateCallbackHelper(_CallbackExceptionHelper):\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ssl, out, outlen):\n            try:\n                conn = Connection._reverse_mapping[ssl]\n                cookie = callback(conn)\n                out[0 : len(cookie)] = cookie\n                outlen[0] = len(cookie)\n                return 1\n            except Exception as e:\n                self._problems.append(e)\n                # \"a zero return value can be used to abort the handshake\"\n                return 0\n\n        self.callback = _ffi.callback(\n            \"int (*)(SSL *, unsigned char *, unsigned int *)\",\n            wrapper,\n        )\n\n\nclass _CookieVerifyCallbackHelper(_CallbackExceptionHelper):\n    def __init__(self, callback):\n        _CallbackExceptionHelper.__init__(self)\n\n        @wraps(callback)\n        def wrapper(ssl, c_cookie, cookie_len):\n            try:\n                conn = Connection._reverse_mapping[ssl]\n                return callback(conn, bytes(c_cookie[0:cookie_len]))\n            except Exception as e:\n                self._problems.append(e)\n                return 0\n\n        self.callback = _ffi.callback(\n            \"int (*)(SSL *, unsigned char *, unsigned int)\",\n            wrapper,\n        )\n\n\ndef _asFileDescriptor(obj):\n    fd = None\n    if not isinstance(obj, int):\n        meth = getattr(obj, \"fileno\", None)\n        if meth is not None:\n            obj = meth()\n\n    if isinstance(obj, int):\n        fd = obj\n\n    if not isinstance(fd, int):\n        raise TypeError(\"argument must be an int, or have a fileno() method.\")\n    elif fd < 0:\n        raise ValueError(\n            \"file descriptor cannot be a negative integer (%i)\" % (fd,)\n        )\n\n    return fd\n\n\ndef OpenSSL_version(type: int) -> bytes:\n    \"\"\"\n    Return a string describing the version of OpenSSL in use.\n\n    :param type: One of the :const:`OPENSSL_` constants defined in this module.\n    \"\"\"\n    return _ffi.string(_lib.OpenSSL_version(type))\n\n\nSSLeay_version = OpenSSL_version\n\n\ndef _make_requires(flag: int, error: str) -> Callable[[_T], _T]:\n    \"\"\"\n    Builds a decorator that ensures that functions that rely on OpenSSL\n    functions that are not present in this build raise NotImplementedError,\n    rather than AttributeError coming out of cryptography.\n\n    :param flag: A cryptography flag that guards the functions, e.g.\n        ``Cryptography_HAS_NEXTPROTONEG``.\n    :param error: The string to be used in the exception if the flag is false.\n    \"\"\"\n\n    def _requires_decorator(func):\n        if not flag:\n\n            @wraps(func)\n            def explode(*args, **kwargs):\n                raise NotImplementedError(error)\n\n            return explode\n        else:\n            return func\n\n    return _requires_decorator\n\n\n_requires_alpn = _make_requires(\n    _lib.Cryptography_HAS_ALPN, \"ALPN not available\"\n)\n\n\n_requires_keylog = _make_requires(\n    getattr(_lib, \"Cryptography_HAS_KEYLOG\", 0), \"Key logging not available\"\n)\n\n\nclass Session:\n    \"\"\"\n    A class representing an SSL session.  A session defines certain connection\n    parameters which may be re-used to speed up the setup of subsequent\n    connections.\n\n    .. versionadded:: 0.14\n    \"\"\"\n\n    pass\n\n\nclass Context:\n    \"\"\"\n    :class:`OpenSSL.SSL.Context` instances define the parameters for setting\n    up new SSL connections.\n\n    :param method: One of TLS_METHOD, TLS_CLIENT_METHOD, TLS_SERVER_METHOD,\n                   DTLS_METHOD, DTLS_CLIENT_METHOD, or DTLS_SERVER_METHOD.\n                   SSLv23_METHOD, TLSv1_METHOD, etc. are deprecated and should\n                   not be used.\n    \"\"\"\n\n    _methods: typing.ClassVar[typing.Dict] = {\n        SSLv23_METHOD: (_lib.TLS_method, None),\n        TLSv1_METHOD: (_lib.TLS_method, TLS1_VERSION),\n        TLSv1_1_METHOD: (_lib.TLS_method, TLS1_1_VERSION),\n        TLSv1_2_METHOD: (_lib.TLS_method, TLS1_2_VERSION),\n        TLS_METHOD: (_lib.TLS_method, None),\n        TLS_SERVER_METHOD: (_lib.TLS_server_method, None),\n        TLS_CLIENT_METHOD: (_lib.TLS_client_method, None),\n        DTLS_METHOD: (_lib.DTLS_method, None),\n        DTLS_SERVER_METHOD: (_lib.DTLS_server_method, None),\n        DTLS_CLIENT_METHOD: (_lib.DTLS_client_method, None),\n    }\n\n    def __init__(self, method: int) -> None:\n        if not isinstance(method, int):\n            raise TypeError(\"method must be an integer\")\n\n        try:\n            method_func, version = self._methods[method]\n        except KeyError:\n            raise ValueError(\"No such protocol\")\n\n        method_obj = method_func()\n        _openssl_assert(method_obj != _ffi.NULL)\n\n        context = _lib.SSL_CTX_new(method_obj)\n        _openssl_assert(context != _ffi.NULL)\n        context = _ffi.gc(context, _lib.SSL_CTX_free)\n\n        self._context = context\n        self._passphrase_helper = None\n        self._passphrase_callback = None\n        self._passphrase_userdata = None\n        self._verify_helper = None\n        self._verify_callback = None\n        self._info_callback = None\n        self._keylog_callback = None\n        self._tlsext_servername_callback = None\n        self._app_data = None\n        self._alpn_select_helper = None\n        self._alpn_select_callback = None\n        self._ocsp_helper = None\n        self._ocsp_callback = None\n        self._ocsp_data = None\n        self._cookie_generate_helper = None\n        self._cookie_verify_helper = None\n\n        self.set_mode(_lib.SSL_MODE_ENABLE_PARTIAL_WRITE)\n        if version is not None:\n            self.set_min_proto_version(version)\n            self.set_max_proto_version(version)\n\n    def set_min_proto_version(self, version: int) -> None:\n        \"\"\"\n        Set the minimum supported protocol version. Setting the minimum\n        version to 0 will enable protocol versions down to the lowest version\n        supported by the library.\n\n        If the underlying OpenSSL build is missing support for the selected\n        version, this method will raise an exception.\n        \"\"\"\n        _openssl_assert(\n            _lib.SSL_CTX_set_min_proto_version(self._context, version) == 1\n        )\n\n    def set_max_proto_version(self, version: int) -> None:\n        \"\"\"\n        Set the maximum supported protocol version. Setting the maximum\n        version to 0 will enable protocol versions up to the highest version\n        supported by the library.\n\n        If the underlying OpenSSL build is missing support for the selected\n        version, this method will raise an exception.\n        \"\"\"\n        _openssl_assert(\n            _lib.SSL_CTX_set_max_proto_version(self._context, version) == 1\n        )\n\n    def load_verify_locations(\n        self,\n        cafile: Optional[_StrOrBytesPath],\n        capath: Optional[_StrOrBytesPath] = None,\n    ) -> None:\n        \"\"\"\n        Let SSL know where we can find trusted certificates for the certificate\n        chain.  Note that the certificates have to be in PEM format.\n\n        If capath is passed, it must be a directory prepared using the\n        ``c_rehash`` tool included with OpenSSL.  Either, but not both, of\n        *pemfile* or *capath* may be :data:`None`.\n\n        :param cafile: In which file we can find the certificates (``bytes`` or\n            ``str``).\n        :param capath: In which directory we can find the certificates\n            (``bytes`` or ``str``).\n\n        :return: None\n        \"\"\"\n        if cafile is None:\n            cafile = _ffi.NULL\n        else:\n            cafile = _path_bytes(cafile)\n\n        if capath is None:\n            capath = _ffi.NULL\n        else:\n            capath = _path_bytes(capath)\n\n        load_result = _lib.SSL_CTX_load_verify_locations(\n            self._context, cafile, capath\n        )\n        if not load_result:\n            _raise_current_error()\n\n    def _wrap_callback(self, callback):\n        @wraps(callback)\n        def wrapper(size, verify, userdata):\n            return callback(size, verify, self._passphrase_userdata)\n\n        return _PassphraseHelper(\n            FILETYPE_PEM, wrapper, more_args=True, truncate=True\n        )\n\n    def set_passwd_cb(\n        self,\n        callback: Callable[[int, bool, Optional[_T]], bytes],\n        userdata: Optional[_T] = None,\n    ) -> None:\n        \"\"\"\n        Set the passphrase callback.  This function will be called\n        when a private key with a passphrase is loaded.\n\n        :param callback: The Python callback to use.  This must accept three\n            positional arguments.  First, an integer giving the maximum length\n            of the passphrase it may return.  If the returned passphrase is\n            longer than this, it will be truncated.  Second, a boolean value\n            which will be true if the user should be prompted for the\n            passphrase twice and the callback should verify that the two values\n            supplied are equal. Third, the value given as the *userdata*\n            parameter to :meth:`set_passwd_cb`.  The *callback* must return\n            a byte string. If an error occurs, *callback* should return a false\n            value (e.g. an empty string).\n        :param userdata: (optional) A Python object which will be given as\n                         argument to the callback\n        :return: None\n        \"\"\"\n        if not callable(callback):\n            raise TypeError(\"callback must be callable\")\n\n        self._passphrase_helper = self._wrap_callback(callback)\n        self._passphrase_callback = self._passphrase_helper.callback\n        _lib.SSL_CTX_set_default_passwd_cb(\n            self._context, self._passphrase_callback\n        )\n        self._passphrase_userdata = userdata\n\n    def set_default_verify_paths(self) -> None:\n        \"\"\"\n        Specify that the platform provided CA certificates are to be used for\n        verification purposes. This method has some caveats related to the\n        binary wheels that cryptography (pyOpenSSL's primary dependency) ships:\n\n        *   macOS will only load certificates using this method if the user has\n            the ``openssl@1.1`` `Homebrew <https://brew.sh>`_ formula installed\n            in the default location.\n        *   Windows will not work.\n        *   manylinux cryptography wheels will work on most common Linux\n            distributions in pyOpenSSL 17.1.0 and above.  pyOpenSSL detects the\n            manylinux wheel and attempts to load roots via a fallback path.\n\n        :return: None\n        \"\"\"\n        # SSL_CTX_set_default_verify_paths will attempt to load certs from\n        # both a cafile and capath that are set at compile time. However,\n        # it will first check environment variables and, if present, load\n        # those paths instead\n        set_result = _lib.SSL_CTX_set_default_verify_paths(self._context)\n        _openssl_assert(set_result == 1)\n        # After attempting to set default_verify_paths we need to know whether\n        # to go down the fallback path.\n        # First we'll check to see if any env vars have been set. If so,\n        # we won't try to do anything else because the user has set the path\n        # themselves.\n        dir_env_var = _ffi.string(_lib.X509_get_default_cert_dir_env()).decode(\n            \"ascii\"\n        )\n        file_env_var = _ffi.string(\n            _lib.X509_get_default_cert_file_env()\n        ).decode(\"ascii\")\n        if not self._check_env_vars_set(dir_env_var, file_env_var):\n            default_dir = _ffi.string(_lib.X509_get_default_cert_dir())\n            default_file = _ffi.string(_lib.X509_get_default_cert_file())\n            # Now we check to see if the default_dir and default_file are set\n            # to the exact values we use in our manylinux builds. If they are\n            # then we know to load the fallbacks\n            if (\n                default_dir == _CRYPTOGRAPHY_MANYLINUX_CA_DIR\n                and default_file == _CRYPTOGRAPHY_MANYLINUX_CA_FILE\n            ):\n                # This is manylinux, let's load our fallback paths\n                self._fallback_default_verify_paths(\n                    _CERTIFICATE_FILE_LOCATIONS, _CERTIFICATE_PATH_LOCATIONS\n                )\n\n    def _check_env_vars_set(self, dir_env_var, file_env_var):\n        \"\"\"\n        Check to see if the default cert dir/file environment vars are present.\n\n        :return: bool\n        \"\"\"\n        return (\n            os.environ.get(file_env_var) is not None\n            or os.environ.get(dir_env_var) is not None\n        )\n\n    def _fallback_default_verify_paths(self, file_path, dir_path):\n        \"\"\"\n        Default verify paths are based on the compiled version of OpenSSL.\n        However, when pyca/cryptography is compiled as a manylinux wheel\n        that compiled location can potentially be wrong. So, like Go, we\n        will try a predefined set of paths and attempt to load roots\n        from there.\n\n        :return: None\n        \"\"\"\n        for cafile in file_path:\n            if os.path.isfile(cafile):\n                self.load_verify_locations(cafile)\n                break\n\n        for capath in dir_path:\n            if os.path.isdir(capath):\n                self.load_verify_locations(None, capath)\n                break\n\n    def use_certificate_chain_file(self, certfile: _StrOrBytesPath) -> None:\n        \"\"\"\n        Load a certificate chain from a file.\n\n        :param certfile: The name of the certificate chain file (``bytes`` or\n            ``str``).  Must be PEM encoded.\n\n        :return: None\n        \"\"\"\n        certfile = _path_bytes(certfile)\n\n        result = _lib.SSL_CTX_use_certificate_chain_file(\n            self._context, certfile\n        )\n        if not result:\n            _raise_current_error()\n\n    def use_certificate_file(\n        self, certfile: _StrOrBytesPath, filetype: int = FILETYPE_PEM\n    ) -> None:\n        \"\"\"\n        Load a certificate from a file\n\n        :param certfile: The name of the certificate file (``bytes`` or\n            ``str``).\n        :param filetype: (optional) The encoding of the file, which is either\n            :const:`FILETYPE_PEM` or :const:`FILETYPE_ASN1`.  The default is\n            :const:`FILETYPE_PEM`.\n\n        :return: None\n        \"\"\"\n        certfile = _path_bytes(certfile)\n        if not isinstance(filetype, int):\n            raise TypeError(\"filetype must be an integer\")\n\n        use_result = _lib.SSL_CTX_use_certificate_file(\n            self._context, certfile, filetype\n        )\n        if not use_result:\n            _raise_current_error()\n\n    def use_certificate(self, cert: X509) -> None:\n        \"\"\"\n        Load a certificate from a X509 object\n\n        :param cert: The X509 object\n        :return: None\n        \"\"\"\n        # Mirrored at Connection.use_certificate\n        if not isinstance(cert, X509):\n            raise TypeError(\"cert must be an X509 instance\")\n\n        use_result = _lib.SSL_CTX_use_certificate(self._context, cert._x509)\n        if not use_result:\n            _raise_current_error()\n\n    def add_extra_chain_cert(self, certobj: X509) -> None:\n        \"\"\"\n        Add certificate to chain\n\n        :param certobj: The X509 certificate object to add to the chain\n        :return: None\n        \"\"\"\n        if not isinstance(certobj, X509):\n            raise TypeError(\"certobj must be an X509 instance\")\n\n        copy = _lib.X509_dup(certobj._x509)\n        add_result = _lib.SSL_CTX_add_extra_chain_cert(self._context, copy)\n        if not add_result:\n            # TODO: This is untested.\n            _lib.X509_free(copy)\n            _raise_current_error()\n\n    def _raise_passphrase_exception(self) -> None:\n        if self._passphrase_helper is not None:\n            self._passphrase_helper.raise_if_problem(Error)\n\n        _raise_current_error()\n\n    def use_privatekey_file(\n        self, keyfile: _StrOrBytesPath, filetype: int = FILETYPE_PEM\n    ) -> None:\n        \"\"\"\n        Load a private key from a file\n\n        :param keyfile: The name of the key file (``bytes`` or ``str``)\n        :param filetype: (optional) The encoding of the file, which is either\n            :const:`FILETYPE_PEM` or :const:`FILETYPE_ASN1`.  The default is\n            :const:`FILETYPE_PEM`.\n\n        :return: None\n        \"\"\"\n        keyfile = _path_bytes(keyfile)\n\n        if not isinstance(filetype, int):\n            raise TypeError(\"filetype must be an integer\")\n\n        use_result = _lib.SSL_CTX_use_PrivateKey_file(\n            self._context, keyfile, filetype\n        )\n        if not use_result:\n            self._raise_passphrase_exception()\n\n    def use_privatekey(self, pkey: PKey) -> None:\n        \"\"\"\n        Load a private key from a PKey object\n\n        :param pkey: The PKey object\n        :return: None\n        \"\"\"\n        # Mirrored at Connection.use_privatekey\n        if not isinstance(pkey, PKey):\n            raise TypeError(\"pkey must be a PKey instance\")\n\n        use_result = _lib.SSL_CTX_use_PrivateKey(self._context, pkey._pkey)\n        if not use_result:\n            self._raise_passphrase_exception()\n\n    def check_privatekey(self) -> None:\n        \"\"\"\n        Check if the private key (loaded with :meth:`use_privatekey`) matches\n        the certificate (loaded with :meth:`use_certificate`)\n\n        :return: :data:`None` (raises :exc:`Error` if something's wrong)\n        \"\"\"\n        if not _lib.SSL_CTX_check_private_key(self._context):\n            _raise_current_error()\n\n    def load_client_ca(self, cafile: bytes) -> None:\n        \"\"\"\n        Load the trusted certificates that will be sent to the client.  Does\n        not actually imply any of the certificates are trusted; that must be\n        configured separately.\n\n        :param bytes cafile: The path to a certificates file in PEM format.\n        :return: None\n        \"\"\"\n        ca_list = _lib.SSL_load_client_CA_file(\n            _text_to_bytes_and_warn(\"cafile\", cafile)\n        )\n        _openssl_assert(ca_list != _ffi.NULL)\n        _lib.SSL_CTX_set_client_CA_list(self._context, ca_list)\n\n    def set_session_id(self, buf: bytes) -> None:\n        \"\"\"\n        Set the session id to *buf* within which a session can be reused for\n        this Context object.  This is needed when doing session resumption,\n        because there is no way for a stored session to know which Context\n        object it is associated with.\n\n        :param bytes buf: The session id.\n\n        :returns: None\n        \"\"\"\n        buf = _text_to_bytes_and_warn(\"buf\", buf)\n        _openssl_assert(\n            _lib.SSL_CTX_set_session_id_context(self._context, buf, len(buf))\n            == 1\n        )\n\n    def set_session_cache_mode(self, mode: int) -> None:\n        \"\"\"\n        Set the behavior of the session cache used by all connections using\n        this Context.  The previously set mode is returned.  See\n        :const:`SESS_CACHE_*` for details about particular modes.\n\n        :param mode: One or more of the SESS_CACHE_* flags (combine using\n            bitwise or)\n        :returns: The previously set caching mode.\n\n        .. versionadded:: 0.14\n        \"\"\"\n        if not isinstance(mode, int):\n            raise TypeError(\"mode must be an integer\")\n\n        return _lib.SSL_CTX_set_session_cache_mode(self._context, mode)\n\n    def get_session_cache_mode(self) -> int:\n        \"\"\"\n        Get the current session cache mode.\n\n        :returns: The currently used cache mode.\n\n        .. versionadded:: 0.14\n        \"\"\"\n        return _lib.SSL_CTX_get_session_cache_mode(self._context)\n\n    def set_verify(\n        self, mode: int, callback: Optional[_SetVerifyCallback] = None\n    ) -> None:\n        \"\"\"\n        Set the verification flags for this Context object to *mode* and\n        specify that *callback* should be used for verification callbacks.\n\n        :param mode: The verify mode, this should be one of\n            :const:`VERIFY_NONE` and :const:`VERIFY_PEER`. If\n            :const:`VERIFY_PEER` is used, *mode* can be OR:ed with\n            :const:`VERIFY_FAIL_IF_NO_PEER_CERT` and\n            :const:`VERIFY_CLIENT_ONCE` to further control the behaviour.\n        :param callback: The optional Python verification callback to use.\n            This should take five arguments: A Connection object, an X509\n            object, and three integer variables, which are in turn potential\n            error number, error depth and return code. *callback* should\n            return True if verification passes and False otherwise.\n            If omitted, OpenSSL's default verification is used.\n        :return: None\n\n        See SSL_CTX_set_verify(3SSL) for further details.\n        \"\"\"\n        if not isinstance(mode, int):\n            raise TypeError(\"mode must be an integer\")\n\n        if callback is None:\n            self._verify_helper = None\n            self._verify_callback = None\n            _lib.SSL_CTX_set_verify(self._context, mode, _ffi.NULL)\n        else:\n            if not callable(callback):\n                raise TypeError(\"callback must be callable\")\n\n            self._verify_helper = _VerifyHelper(callback)\n            self._verify_callback = self._verify_helper.callback\n            _lib.SSL_CTX_set_verify(self._context, mode, self._verify_callback)\n\n    def set_verify_depth(self, depth: int) -> None:\n        \"\"\"\n        Set the maximum depth for the certificate chain verification that shall\n        be allowed for this Context object.\n\n        :param depth: An integer specifying the verify depth\n        :return: None\n        \"\"\"\n        if not isinstance(depth, int):\n            raise TypeError(\"depth must be an integer\")\n\n        _lib.SSL_CTX_set_verify_depth(self._context, depth)\n\n    def get_verify_mode(self) -> int:\n        \"\"\"\n        Retrieve the Context object's verify mode, as set by\n        :meth:`set_verify`.\n\n        :return: The verify mode\n        \"\"\"\n        return _lib.SSL_CTX_get_verify_mode(self._context)\n\n    def get_verify_depth(self) -> int:\n        \"\"\"\n        Retrieve the Context object's verify depth, as set by\n        :meth:`set_verify_depth`.\n\n        :return: The verify depth\n        \"\"\"\n        return _lib.SSL_CTX_get_verify_depth(self._context)\n\n    def load_tmp_dh(self, dhfile: _StrOrBytesPath) -> None:\n        \"\"\"\n        Load parameters for Ephemeral Diffie-Hellman\n\n        :param dhfile: The file to load EDH parameters from (``bytes`` or\n            ``str``).\n\n        :return: None\n        \"\"\"\n        dhfile = _path_bytes(dhfile)\n\n        bio = _lib.BIO_new_file(dhfile, b\"r\")\n        if bio == _ffi.NULL:\n            _raise_current_error()\n        bio = _ffi.gc(bio, _lib.BIO_free)\n\n        dh = _lib.PEM_read_bio_DHparams(bio, _ffi.NULL, _ffi.NULL, _ffi.NULL)\n        dh = _ffi.gc(dh, _lib.DH_free)\n        res = _lib.SSL_CTX_set_tmp_dh(self._context, dh)\n        _openssl_assert(res == 1)\n\n    def set_tmp_ecdh(self, curve: _EllipticCurve) -> None:\n        \"\"\"\n        Select a curve to use for ECDHE key exchange.\n\n        :param curve: A curve object to use as returned by either\n            :meth:`OpenSSL.crypto.get_elliptic_curve` or\n            :meth:`OpenSSL.crypto.get_elliptic_curves`.\n\n        :return: None\n        \"\"\"\n        _lib.SSL_CTX_set_tmp_ecdh(self._context, curve._to_EC_KEY())\n\n    def set_cipher_list(self, cipher_list: bytes) -> None:\n        \"\"\"\n        Set the list of ciphers to be used in this context.\n\n        See the OpenSSL manual for more information (e.g.\n        :manpage:`ciphers(1)`).\n\n        :param bytes cipher_list: An OpenSSL cipher string.\n        :return: None\n        \"\"\"\n        cipher_list = _text_to_bytes_and_warn(\"cipher_list\", cipher_list)\n\n        if not isinstance(cipher_list, bytes):\n            raise TypeError(\"cipher_list must be a byte string.\")\n\n        _openssl_assert(\n            _lib.SSL_CTX_set_cipher_list(self._context, cipher_list) == 1\n        )\n        # In OpenSSL 1.1.1 setting the cipher list will always return TLS 1.3\n        # ciphers even if you pass an invalid cipher. Applications (like\n        # Twisted) have tests that depend on an error being raised if an\n        # invalid cipher string is passed, but without the following check\n        # for the TLS 1.3 specific cipher suites it would never error.\n        tmpconn = Connection(self, None)\n        if tmpconn.get_cipher_list() == [\n            \"TLS_AES_256_GCM_SHA384\",\n            \"TLS_CHACHA20_POLY1305_SHA256\",\n            \"TLS_AES_128_GCM_SHA256\",\n        ]:\n            raise Error(\n                [\n                    (\n                        \"SSL routines\",\n                        \"SSL_CTX_set_cipher_list\",\n                        \"no cipher match\",\n                    ),\n                ],\n            )\n\n    def set_client_ca_list(\n        self, certificate_authorities: Sequence[X509Name]\n    ) -> None:\n        \"\"\"\n        Set the list of preferred client certificate signers for this server\n        context.\n\n        This list of certificate authorities will be sent to the client when\n        the server requests a client certificate.\n\n        :param certificate_authorities: a sequence of X509Names.\n        :return: None\n\n        .. versionadded:: 0.10\n        \"\"\"\n        name_stack = _lib.sk_X509_NAME_new_null()\n        _openssl_assert(name_stack != _ffi.NULL)\n\n        try:\n            for ca_name in certificate_authorities:\n                if not isinstance(ca_name, X509Name):\n                    raise TypeError(\n                        f\"client CAs must be X509Name objects, not \"\n                        f\"{type(ca_name).__name__} objects\"\n                    )\n                copy = _lib.X509_NAME_dup(ca_name._name)\n                _openssl_assert(copy != _ffi.NULL)\n                push_result = _lib.sk_X509_NAME_push(name_stack, copy)\n                if not push_result:\n                    _lib.X509_NAME_free(copy)\n                    _raise_current_error()\n        except Exception:\n            _lib.sk_X509_NAME_free(name_stack)\n            raise\n\n        _lib.SSL_CTX_set_client_CA_list(self._context, name_stack)\n\n    def add_client_ca(self, certificate_authority: X509) -> None:\n        \"\"\"\n        Add the CA certificate to the list of preferred signers for this\n        context.\n\n        The list of certificate authorities will be sent to the client when the\n        server requests a client certificate.\n\n        :param certificate_authority: certificate authority's X509 certificate.\n        :return: None\n\n        .. versionadded:: 0.10\n        \"\"\"\n        if not isinstance(certificate_authority, X509):\n            raise TypeError(\"certificate_authority must be an X509 instance\")\n\n        add_result = _lib.SSL_CTX_add_client_CA(\n            self._context, certificate_authority._x509\n        )\n        _openssl_assert(add_result == 1)\n\n    def set_timeout(self, timeout: int) -> None:\n        \"\"\"\n        Set the timeout for newly created sessions for this Context object to\n        *timeout*.  The default value is 300 seconds. See the OpenSSL manual\n        for more information (e.g. :manpage:`SSL_CTX_set_timeout(3)`).\n\n        :param timeout: The timeout in (whole) seconds\n        :return: The previous session timeout\n        \"\"\"\n        if not isinstance(timeout, int):\n            raise TypeError(\"timeout must be an integer\")\n\n        return _lib.SSL_CTX_set_timeout(self._context, timeout)\n\n    def get_timeout(self) -> int:\n        \"\"\"\n        Retrieve session timeout, as set by :meth:`set_timeout`. The default\n        is 300 seconds.\n\n        :return: The session timeout\n        \"\"\"\n        return _lib.SSL_CTX_get_timeout(self._context)\n\n    def set_info_callback(\n        self, callback: Callable[[\"Connection\", int, int], None]\n    ) -> None:\n        \"\"\"\n        Set the information callback to *callback*. This function will be\n        called from time to time during SSL handshakes.\n\n        :param callback: The Python callback to use.  This should take three\n            arguments: a Connection object and two integers.  The first integer\n            specifies where in the SSL handshake the function was called, and\n            the other the return code from a (possibly failed) internal\n            function call.\n        :return: None\n        \"\"\"\n\n        @wraps(callback)\n        def wrapper(ssl, where, return_code):\n            callback(Connection._reverse_mapping[ssl], where, return_code)\n\n        self._info_callback = _ffi.callback(\n            \"void (*)(const SSL *, int, int)\", wrapper\n        )\n        _lib.SSL_CTX_set_info_callback(self._context, self._info_callback)\n\n    @_requires_keylog\n    def set_keylog_callback(\n        self, callback: Callable[[\"Connection\", bytes], None]\n    ) -> None:\n        \"\"\"\n        Set the TLS key logging callback to *callback*. This function will be\n        called whenever TLS key material is generated or received, in order\n        to allow applications to store this keying material for debugging\n        purposes.\n\n        :param callback: The Python callback to use.  This should take two\n            arguments: a Connection object and a bytestring that contains\n            the key material in the format used by NSS for its SSLKEYLOGFILE\n            debugging output.\n        :return: None\n        \"\"\"\n\n        @wraps(callback)\n        def wrapper(ssl, line):\n            line = _ffi.string(line)\n            callback(Connection._reverse_mapping[ssl], line)\n\n        self._keylog_callback = _ffi.callback(\n            \"void (*)(const SSL *, const char *)\", wrapper\n        )\n        _lib.SSL_CTX_set_keylog_callback(self._context, self._keylog_callback)\n\n    def get_app_data(self) -> Any:\n        \"\"\"\n        Get the application data (supplied via :meth:`set_app_data()`)\n\n        :return: The application data\n        \"\"\"\n        return self._app_data\n\n    def set_app_data(self, data: Any) -> None:\n        \"\"\"\n        Set the application data (will be returned from get_app_data())\n\n        :param data: Any Python object\n        :return: None\n        \"\"\"\n        self._app_data = data\n\n    def get_cert_store(self) -> X509Store:\n        \"\"\"\n        Get the certificate store for the context.  This can be used to add\n        \"trusted\" certificates without using the\n        :meth:`load_verify_locations` method.\n\n        :return: A X509Store object or None if it does not have one.\n        \"\"\"\n        store = _lib.SSL_CTX_get_cert_store(self._context)\n        if store == _ffi.NULL:\n            # TODO: This is untested.\n            return None\n\n        pystore = X509Store.__new__(X509Store)\n        pystore._store = store\n        return pystore\n\n    def set_options(self, options: int) -> None:\n        \"\"\"\n        Add options. Options set before are not cleared!\n        This method should be used with the :const:`OP_*` constants.\n\n        :param options: The options to add.\n        :return: The new option bitmask.\n        \"\"\"\n        if not isinstance(options, int):\n            raise TypeError(\"options must be an integer\")\n\n        return _lib.SSL_CTX_set_options(self._context, options)\n\n    def set_mode(self, mode: int) -> None:\n        \"\"\"\n        Add modes via bitmask. Modes set before are not cleared!  This method\n        should be used with the :const:`MODE_*` constants.\n\n        :param mode: The mode to add.\n        :return: The new mode bitmask.\n        \"\"\"\n        if not isinstance(mode, int):\n            raise TypeError(\"mode must be an integer\")\n\n        return _lib.SSL_CTX_set_mode(self._context, mode)\n\n    def set_tlsext_servername_callback(\n        self, callback: Callable[[\"Connection\"], None]\n    ) -> None:\n        \"\"\"\n        Specify a callback function to be called when clients specify a server\n        name.\n\n        :param callback: The callback function.  It will be invoked with one\n            argument, the Connection instance.\n\n        .. versionadded:: 0.13\n        \"\"\"\n\n        @wraps(callback)\n        def wrapper(ssl, alert, arg):\n            callback(Connection._reverse_mapping[ssl])\n            return 0\n\n        self._tlsext_servername_callback = _ffi.callback(\n            \"int (*)(SSL *, int *, void *)\", wrapper\n        )\n        _lib.SSL_CTX_set_tlsext_servername_callback(\n            self._context, self._tlsext_servername_callback\n        )\n\n    def set_tlsext_use_srtp(self, profiles: bytes) -> None:\n        \"\"\"\n        Enable support for negotiating SRTP keying material.\n\n        :param bytes profiles: A colon delimited list of protection profile\n            names, like ``b'SRTP_AES128_CM_SHA1_80:SRTP_AES128_CM_SHA1_32'``.\n        :return: None\n        \"\"\"\n        if not isinstance(profiles, bytes):\n            raise TypeError(\"profiles must be a byte string.\")\n\n        _openssl_assert(\n            _lib.SSL_CTX_set_tlsext_use_srtp(self._context, profiles) == 0\n        )\n\n    @_requires_alpn\n    def set_alpn_protos(self, protos: List[bytes]) -> None:\n        \"\"\"\n        Specify the protocols that the client is prepared to speak after the\n        TLS connection has been negotiated using Application Layer Protocol\n        Negotiation.\n\n        :param protos: A list of the protocols to be offered to the server.\n            This list should be a Python list of bytestrings representing the\n            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.\n        \"\"\"\n        # Different versions of OpenSSL are inconsistent about how they handle\n        # empty proto lists (see #1043), so we avoid the problem entirely by\n        # rejecting them ourselves.\n        if not protos:\n            raise ValueError(\"at least one protocol must be specified\")\n\n        # Take the list of protocols and join them together, prefixing them\n        # with their lengths.\n        protostr = b\"\".join(\n            chain.from_iterable((bytes((len(p),)), p) for p in protos)\n        )\n\n        # Build a C string from the list. We don't need to save this off\n        # because OpenSSL immediately copies the data out.\n        input_str = _ffi.new(\"unsigned char[]\", protostr)\n\n        # https://www.openssl.org/docs/man1.1.0/man3/SSL_CTX_set_alpn_protos.html:\n        # SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos()\n        # return 0 on success, and non-0 on failure.\n        # WARNING: these functions reverse the return value convention.\n        _openssl_assert(\n            _lib.SSL_CTX_set_alpn_protos(\n                self._context, input_str, len(protostr)\n            )\n            == 0\n        )\n\n    @_requires_alpn\n    def set_alpn_select_callback(\n        self, callback: Callable[[\"Connection\", List[bytes]], None]\n    ) -> None:\n        \"\"\"\n        Specify a callback function that will be called on the server when a\n        client offers protocols using ALPN.\n\n        :param callback: The callback function.  It will be invoked with two\n            arguments: the Connection, and a list of offered protocols as\n            bytestrings, e.g ``[b'http/1.1', b'spdy/2']``.  It can return\n            one of those bytestrings to indicate the chosen protocol, the\n            empty bytestring to terminate the TLS connection, or the\n            :py:obj:`NO_OVERLAPPING_PROTOCOLS` to indicate that no offered\n            protocol was selected, but that the connection should not be\n            aborted.\n        \"\"\"\n        self._alpn_select_helper = _ALPNSelectHelper(callback)\n        self._alpn_select_callback = self._alpn_select_helper.callback\n        _lib.SSL_CTX_set_alpn_select_cb(\n            self._context, self._alpn_select_callback, _ffi.NULL\n        )\n\n    def _set_ocsp_callback(self, helper, data):\n        \"\"\"\n        This internal helper does the common work for\n        ``set_ocsp_server_callback`` and ``set_ocsp_client_callback``, which is\n        almost all of it.\n        \"\"\"\n        self._ocsp_helper = helper\n        self._ocsp_callback = helper.callback\n        if data is None:\n            self._ocsp_data = _ffi.NULL\n        else:\n            self._ocsp_data = _ffi.new_handle(data)\n\n        rc = _lib.SSL_CTX_set_tlsext_status_cb(\n            self._context, self._ocsp_callback\n        )\n        _openssl_assert(rc == 1)\n        rc = _lib.SSL_CTX_set_tlsext_status_arg(self._context, self._ocsp_data)\n        _openssl_assert(rc == 1)\n\n    def set_ocsp_server_callback(\n        self,\n        callback: Callable[[\"Connection\", Optional[_T]], bytes],\n        data: Optional[_T] = None,\n    ) -> None:\n        \"\"\"\n        Set a callback to provide OCSP data to be stapled to the TLS handshake\n        on the server side.\n\n        :param callback: The callback function. It will be invoked with two\n            arguments: the Connection, and the optional arbitrary data you have\n            provided. The callback must return a bytestring that contains the\n            OCSP data to staple to the handshake. If no OCSP data is available\n            for this connection, return the empty bytestring.\n        :param data: Some opaque data that will be passed into the callback\n            function when called. This can be used to avoid needing to do\n            complex data lookups or to keep track of what context is being\n            used. This parameter is optional.\n        \"\"\"\n        helper = _OCSPServerCallbackHelper(callback)\n        self._set_ocsp_callback(helper, data)\n\n    def set_ocsp_client_callback(\n        self,\n        callback: Callable[[\"Connection\", bytes, Optional[_T]], bool],\n        data: Optional[_T] = None,\n    ) -> None:\n        \"\"\"\n        Set a callback to validate OCSP data stapled to the TLS handshake on\n        the client side.\n\n        :param callback: The callback function. It will be invoked with three\n            arguments: the Connection, a bytestring containing the stapled OCSP\n            assertion, and the optional arbitrary data you have provided. The\n            callback must return a boolean that indicates the result of\n            validating the OCSP data: ``True`` if the OCSP data is valid and\n            the certificate can be trusted, or ``False`` if either the OCSP\n            data is invalid or the certificate has been revoked.\n        :param data: Some opaque data that will be passed into the callback\n            function when called. This can be used to avoid needing to do\n            complex data lookups or to keep track of what context is being\n            used. This parameter is optional.\n        \"\"\"\n        helper = _OCSPClientCallbackHelper(callback)\n        self._set_ocsp_callback(helper, data)\n\n    def set_cookie_generate_callback(self, callback):\n        self._cookie_generate_helper = _CookieGenerateCallbackHelper(callback)\n        _lib.SSL_CTX_set_cookie_generate_cb(\n            self._context,\n            self._cookie_generate_helper.callback,\n        )\n\n    def set_cookie_verify_callback(self, callback):\n        self._cookie_verify_helper = _CookieVerifyCallbackHelper(callback)\n        _lib.SSL_CTX_set_cookie_verify_cb(\n            self._context,\n            self._cookie_verify_helper.callback,\n        )\n\n\nclass Connection:\n    _reverse_mapping = WeakValueDictionary()\n\n    def __init__(\n        self, context: Context, socket: Optional[socket.socket] = None\n    ) -> None:\n        \"\"\"\n        Create a new Connection object, using the given OpenSSL.SSL.Context\n        instance and socket.\n\n        :param context: An SSL Context to use for this connection\n        :param socket: The socket to use for transport layer\n        \"\"\"\n        if not isinstance(context, Context):\n            raise TypeError(\"context must be a Context instance\")\n\n        ssl = _lib.SSL_new(context._context)\n        self._ssl = _ffi.gc(ssl, _lib.SSL_free)\n        # We set SSL_MODE_AUTO_RETRY to handle situations where OpenSSL returns\n        # an SSL_ERROR_WANT_READ when processing a non-application data packet\n        # even though there is still data on the underlying transport.\n        # See https://github.com/openssl/openssl/issues/6234 for more details.\n        _lib.SSL_set_mode(self._ssl, _lib.SSL_MODE_AUTO_RETRY)\n        self._context = context\n        self._app_data = None\n\n        # References to strings used for Application Layer Protocol\n        # Negotiation. These strings get copied at some point but it's well\n        # after the callback returns, so we have to hang them somewhere to\n        # avoid them getting freed.\n        self._alpn_select_callback_args = None\n\n        # Reference the verify_callback of the Context. This ensures that if\n        # set_verify is called again after the SSL object has been created we\n        # do not point to a dangling reference\n        self._verify_helper = context._verify_helper\n        self._verify_callback = context._verify_callback\n\n        # And likewise for the cookie callbacks\n        self._cookie_generate_helper = context._cookie_generate_helper\n        self._cookie_verify_helper = context._cookie_verify_helper\n\n        self._reverse_mapping[self._ssl] = self\n\n        if socket is None:\n            self._socket = None\n            # Don't set up any gc for these, SSL_free will take care of them.\n            self._into_ssl = _lib.BIO_new(_lib.BIO_s_mem())\n            _openssl_assert(self._into_ssl != _ffi.NULL)\n\n            self._from_ssl = _lib.BIO_new(_lib.BIO_s_mem())\n            _openssl_assert(self._from_ssl != _ffi.NULL)\n\n            _lib.SSL_set_bio(self._ssl, self._into_ssl, self._from_ssl)\n        else:\n            self._into_ssl = None\n            self._from_ssl = None\n            self._socket = socket\n            set_result = _lib.SSL_set_fd(\n                self._ssl, _asFileDescriptor(self._socket)\n            )\n            _openssl_assert(set_result == 1)\n\n    def __getattr__(self, name):\n        \"\"\"\n        Look up attributes on the wrapped socket object if they are not found\n        on the Connection object.\n        \"\"\"\n        if self._socket is None:\n            raise AttributeError(\n                f\"'{self.__class__.__name__}' object has no attribute '{name}'\"\n            )\n        else:\n            return getattr(self._socket, name)\n\n    def _raise_ssl_error(self, ssl, result):\n        if self._context._verify_helper is not None:\n            self._context._verify_helper.raise_if_problem()\n        if self._context._alpn_select_helper is not None:\n            self._context._alpn_select_helper.raise_if_problem()\n        if self._context._ocsp_helper is not None:\n            self._context._ocsp_helper.raise_if_problem()\n\n        error = _lib.SSL_get_error(ssl, result)\n        if error == _lib.SSL_ERROR_WANT_READ:\n            raise WantReadError()\n        elif error == _lib.SSL_ERROR_WANT_WRITE:\n            raise WantWriteError()\n        elif error == _lib.SSL_ERROR_ZERO_RETURN:\n            raise ZeroReturnError()\n        elif error == _lib.SSL_ERROR_WANT_X509_LOOKUP:\n            # TODO: This is untested.\n            raise WantX509LookupError()\n        elif error == _lib.SSL_ERROR_SYSCALL:\n            if _lib.ERR_peek_error() == 0:\n                if result < 0:\n                    if platform == \"win32\":\n                        errno = _ffi.getwinerror()[0]\n                    else:\n                        errno = _ffi.errno\n\n                    if errno != 0:\n                        raise SysCallError(errno, errorcode.get(errno))\n                raise SysCallError(-1, \"Unexpected EOF\")\n            else:\n                # TODO: This is untested.\n                _raise_current_error()\n        elif error == _lib.SSL_ERROR_SSL and _lib.ERR_peek_error() != 0:\n            # In 3.0.x an unexpected EOF no longer triggers syscall error\n            # but we want to maintain compatibility so we check here and\n            # raise syscall if it is an EOF. Since we're not actually sure\n            # what else could raise SSL_ERROR_SSL we check for the presence\n            # of the OpenSSL 3 constant SSL_R_UNEXPECTED_EOF_WHILE_READING\n            # and if it's not present we just raise an error, which matches\n            # the behavior before we added this elif section\n            peeked_error = _lib.ERR_peek_error()\n            reason = _lib.ERR_GET_REASON(peeked_error)\n            if _lib.Cryptography_HAS_UNEXPECTED_EOF_WHILE_READING:\n                _openssl_assert(\n                    reason == _lib.SSL_R_UNEXPECTED_EOF_WHILE_READING\n                )\n                _lib.ERR_clear_error()\n                raise SysCallError(-1, \"Unexpected EOF\")\n            else:\n                _raise_current_error()\n        elif error == _lib.SSL_ERROR_NONE:\n            pass\n        else:\n            _raise_current_error()\n\n    def get_context(self) -> Context:\n        \"\"\"\n        Retrieve the :class:`Context` object associated with this\n        :class:`Connection`.\n        \"\"\"\n        return self._context\n\n    def set_context(self, context: Context) -> None:\n        \"\"\"\n        Switch this connection to a new session context.\n\n        :param context: A :class:`Context` instance giving the new session\n            context to use.\n        \"\"\"\n        if not isinstance(context, Context):\n            raise TypeError(\"context must be a Context instance\")\n\n        _lib.SSL_set_SSL_CTX(self._ssl, context._context)\n        self._context = context\n\n    def get_servername(self) -> Optional[bytes]:\n        \"\"\"\n        Retrieve the servername extension value if provided in the client hello\n        message, or None if there wasn't one.\n\n        :return: A byte string giving the server name or :data:`None`.\n\n        .. versionadded:: 0.13\n        \"\"\"\n        name = _lib.SSL_get_servername(\n            self._ssl, _lib.TLSEXT_NAMETYPE_host_name\n        )\n        if name == _ffi.NULL:\n            return None\n\n        return _ffi.string(name)\n\n    def set_verify(\n        self, mode: int, callback: Optional[_SetVerifyCallback] = None\n    ) -> None:\n        \"\"\"\n        Override the Context object's verification flags for this specific\n        connection. See :py:meth:`Context.set_verify` for details.\n        \"\"\"\n        if not isinstance(mode, int):\n            raise TypeError(\"mode must be an integer\")\n\n        if callback is None:\n            self._verify_helper = None\n            self._verify_callback = None\n            _lib.SSL_set_verify(self._ssl, mode, _ffi.NULL)\n        else:\n            if not callable(callback):\n                raise TypeError(\"callback must be callable\")\n\n            self._verify_helper = _VerifyHelper(callback)\n            self._verify_callback = self._verify_helper.callback\n            _lib.SSL_set_verify(self._ssl, mode, self._verify_callback)\n\n    def get_verify_mode(self) -> int:\n        \"\"\"\n        Retrieve the Connection object's verify mode, as set by\n        :meth:`set_verify`.\n\n        :return: The verify mode\n        \"\"\"\n        return _lib.SSL_get_verify_mode(self._ssl)\n\n    def use_certificate(self, cert: X509) -> None:\n        \"\"\"\n        Load a certificate from a X509 object\n\n        :param cert: The X509 object\n        :return: None\n        \"\"\"\n        # Mirrored from Context.use_certificate\n        if not isinstance(cert, X509):\n            raise TypeError(\"cert must be an X509 instance\")\n\n        use_result = _lib.SSL_use_certificate(self._ssl, cert._x509)\n        if not use_result:\n            _raise_current_error()\n\n    def use_privatekey(self, pkey: PKey) -> None:\n        \"\"\"\n        Load a private key from a PKey object\n\n        :param pkey: The PKey object\n        :return: None\n        \"\"\"\n        # Mirrored from Context.use_privatekey\n        if not isinstance(pkey, PKey):\n            raise TypeError(\"pkey must be a PKey instance\")\n\n        use_result = _lib.SSL_use_PrivateKey(self._ssl, pkey._pkey)\n        if not use_result:\n            self._context._raise_passphrase_exception()\n\n    def set_ciphertext_mtu(self, mtu: int) -> None:\n        \"\"\"\n        For DTLS, set the maximum UDP payload size (*not* including IP/UDP\n        overhead).\n\n        Note that you might have to set :data:`OP_NO_QUERY_MTU` to prevent\n        OpenSSL from spontaneously clearing this.\n\n        :param mtu: An integer giving the maximum transmission unit.\n\n        .. versionadded:: 21.1\n        \"\"\"\n        _lib.SSL_set_mtu(self._ssl, mtu)\n\n    def get_cleartext_mtu(self) -> int:\n        \"\"\"\n        For DTLS, get the maximum size of unencrypted data you can pass to\n        :meth:`write` without exceeding the MTU (as passed to\n        :meth:`set_ciphertext_mtu`).\n\n        :return: The effective MTU as an integer.\n\n        .. versionadded:: 21.1\n        \"\"\"\n\n        if not hasattr(_lib, \"DTLS_get_data_mtu\"):\n            raise NotImplementedError(\"requires OpenSSL 1.1.1 or better\")\n        return _lib.DTLS_get_data_mtu(self._ssl)\n\n    def set_tlsext_host_name(self, name: bytes) -> None:\n        \"\"\"\n        Set the value of the servername extension to send in the client hello.\n\n        :param name: A byte string giving the name.\n\n        .. versionadded:: 0.13\n        \"\"\"\n        if not isinstance(name, bytes):\n            raise TypeError(\"name must be a byte string\")\n        elif b\"\\0\" in name:\n            raise TypeError(\"name must not contain NUL byte\")\n\n        # XXX I guess this can fail sometimes?\n        _lib.SSL_set_tlsext_host_name(self._ssl, name)\n\n    def pending(self) -> int:\n        \"\"\"\n        Get the number of bytes that can be safely read from the SSL buffer\n        (**not** the underlying transport buffer).\n\n        :return: The number of bytes available in the receive buffer.\n        \"\"\"\n        return _lib.SSL_pending(self._ssl)\n\n    def send(self, buf: bytes, flags: int = 0) -> int:\n        \"\"\"\n        Send data on the connection. NOTE: If you get one of the WantRead,\n        WantWrite or WantX509Lookup exceptions on this, you have to call the\n        method again with the SAME buffer.\n\n        :param buf: The string, buffer or memoryview to send\n        :param flags: (optional) Included for compatibility with the socket\n                      API, the value is ignored\n        :return: The number of bytes written\n        \"\"\"\n        # Backward compatibility\n        buf = _text_to_bytes_and_warn(\"buf\", buf)\n\n        with _ffi.from_buffer(buf) as data:\n            # check len(buf) instead of len(data) for testability\n            if len(buf) > 2147483647:\n                raise ValueError(\n                    \"Cannot send more than 2**31-1 bytes at once.\"\n                )\n\n            result = _lib.SSL_write(self._ssl, data, len(data))\n            self._raise_ssl_error(self._ssl, result)\n\n            return result\n\n    write = send\n\n    def sendall(self, buf: bytes, flags: int = 0) -> int:\n        \"\"\"\n        Send \"all\" data on the connection. This calls send() repeatedly until\n        all data is sent. If an error occurs, it's impossible to tell how much\n        data has been sent.\n\n        :param buf: The string, buffer or memoryview to send\n        :param flags: (optional) Included for compatibility with the socket\n                      API, the value is ignored\n        :return: The number of bytes written\n        \"\"\"\n        buf = _text_to_bytes_and_warn(\"buf\", buf)\n\n        with _ffi.from_buffer(buf) as data:\n            left_to_send = len(buf)\n            total_sent = 0\n\n            while left_to_send:\n                # SSL_write's num arg is an int,\n                # so we cannot send more than 2**31-1 bytes at once.\n                result = _lib.SSL_write(\n                    self._ssl, data + total_sent, min(left_to_send, 2147483647)\n                )\n                self._raise_ssl_error(self._ssl, result)\n                total_sent += result\n                left_to_send -= result\n\n            return total_sent\n\n    def recv(self, bufsiz: int, flags: Optional[int] = None) -> bytes:\n        \"\"\"\n        Receive data on the connection.\n\n        :param bufsiz: The maximum number of bytes to read\n        :param flags: (optional) The only supported flag is ``MSG_PEEK``,\n            all other flags are ignored.\n        :return: The string read from the Connection\n        \"\"\"\n        buf = _no_zero_allocator(\"char[]\", bufsiz)\n        if flags is not None and flags & socket.MSG_PEEK:\n            result = _lib.SSL_peek(self._ssl, buf, bufsiz)\n        else:\n            result = _lib.SSL_read(self._ssl, buf, bufsiz)\n        self._raise_ssl_error(self._ssl, result)\n        return _ffi.buffer(buf, result)[:]\n\n    read = recv\n\n    def recv_into(\n        self, buffer, nbytes: Optional[int] = None, flags: Optional[int] = None\n    ) -> int:\n        \"\"\"\n        Receive data on the connection and copy it directly into the provided\n        buffer, rather than creating a new string.\n\n        :param buffer: The buffer to copy into.\n        :param nbytes: (optional) The maximum number of bytes to read into the\n            buffer. If not present, defaults to the size of the buffer. If\n            larger than the size of the buffer, is reduced to the size of the\n            buffer.\n        :param flags: (optional) The only supported flag is ``MSG_PEEK``,\n            all other flags are ignored.\n        :return: The number of bytes read into the buffer.\n        \"\"\"\n        if nbytes is None:\n            nbytes = len(buffer)\n        else:\n            nbytes = min(nbytes, len(buffer))\n\n        # We need to create a temporary buffer. This is annoying, it would be\n        # better if we could pass memoryviews straight into the SSL_read call,\n        # but right now we can't. Revisit this if CFFI gets that ability.\n        buf = _no_zero_allocator(\"char[]\", nbytes)\n        if flags is not None and flags & socket.MSG_PEEK:\n            result = _lib.SSL_peek(self._ssl, buf, nbytes)\n        else:\n            result = _lib.SSL_read(self._ssl, buf, nbytes)\n        self._raise_ssl_error(self._ssl, result)\n\n        # This strange line is all to avoid a memory copy. The buffer protocol\n        # should allow us to assign a CFFI buffer to the LHS of this line, but\n        # on CPython 3.3+ that segfaults. As a workaround, we can temporarily\n        # wrap it in a memoryview.\n        buffer[:result] = memoryview(_ffi.buffer(buf, result))\n\n        return result\n\n    def _handle_bio_errors(self, bio, result):\n        if _lib.BIO_should_retry(bio):\n            if _lib.BIO_should_read(bio):\n                raise WantReadError()\n            elif _lib.BIO_should_write(bio):\n                # TODO: This is untested.\n                raise WantWriteError()\n            elif _lib.BIO_should_io_special(bio):\n                # TODO: This is untested.  I think io_special means the socket\n                # BIO has a not-yet connected socket.\n                raise ValueError(\"BIO_should_io_special\")\n            else:\n                # TODO: This is untested.\n                raise ValueError(\"unknown bio failure\")\n        else:\n            # TODO: This is untested.\n            _raise_current_error()\n\n    def bio_read(self, bufsiz: int) -> bytes:\n        \"\"\"\n        If the Connection was created with a memory BIO, this method can be\n        used to read bytes from the write end of that memory BIO.  Many\n        Connection methods will add bytes which must be read in this manner or\n        the buffer will eventually fill up and the Connection will be able to\n        take no further actions.\n\n        :param bufsiz: The maximum number of bytes to read\n        :return: The string read.\n        \"\"\"\n        if self._from_ssl is None:\n            raise TypeError(\"Connection sock was not None\")\n\n        if not isinstance(bufsiz, int):\n            raise TypeError(\"bufsiz must be an integer\")\n\n        buf = _no_zero_allocator(\"char[]\", bufsiz)\n        result = _lib.BIO_read(self._from_ssl, buf, bufsiz)\n        if result <= 0:\n            self._handle_bio_errors(self._from_ssl, result)\n\n        return _ffi.buffer(buf, result)[:]\n\n    def bio_write(self, buf: bytes) -> int:\n        \"\"\"\n        If the Connection was created with a memory BIO, this method can be\n        used to add bytes to the read end of that memory BIO.  The Connection\n        can then read the bytes (for example, in response to a call to\n        :meth:`recv`).\n\n        :param buf: The string to put into the memory BIO.\n        :return: The number of bytes written\n        \"\"\"\n        buf = _text_to_bytes_and_warn(\"buf\", buf)\n\n        if self._into_ssl is None:\n            raise TypeError(\"Connection sock was not None\")\n\n        with _ffi.from_buffer(buf) as data:\n            result = _lib.BIO_write(self._into_ssl, data, len(data))\n            if result <= 0:\n                self._handle_bio_errors(self._into_ssl, result)\n            return result\n\n    def renegotiate(self) -> bool:\n        \"\"\"\n        Renegotiate the session.\n\n        :return: True if the renegotiation can be started, False otherwise\n        :rtype: bool\n        \"\"\"\n        if not self.renegotiate_pending():\n            _openssl_assert(_lib.SSL_renegotiate(self._ssl) == 1)\n            return True\n        return False\n\n    def do_handshake(self) -> None:\n        \"\"\"\n        Perform an SSL handshake (usually called after :meth:`renegotiate` or\n        one of :meth:`set_accept_state` or :meth:`set_connect_state`). This can\n        raise the same exceptions as :meth:`send` and :meth:`recv`.\n\n        :return: None.\n        \"\"\"\n        result = _lib.SSL_do_handshake(self._ssl)\n        self._raise_ssl_error(self._ssl, result)\n\n    def renegotiate_pending(self) -> bool:\n        \"\"\"\n        Check if there's a renegotiation in progress, it will return False once\n        a renegotiation is finished.\n\n        :return: Whether there's a renegotiation in progress\n        :rtype: bool\n        \"\"\"\n        return _lib.SSL_renegotiate_pending(self._ssl) == 1\n\n    def total_renegotiations(self) -> int:\n        \"\"\"\n        Find out the total number of renegotiations.\n\n        :return: The number of renegotiations.\n        :rtype: int\n        \"\"\"\n        return _lib.SSL_total_renegotiations(self._ssl)\n\n    def connect(self, addr):\n        \"\"\"\n        Call the :meth:`connect` method of the underlying socket and set up SSL\n        on the socket, using the :class:`Context` object supplied to this\n        :class:`Connection` object at creation.\n\n        :param addr: A remote address\n        :return: What the socket's connect method returns\n        \"\"\"\n        _lib.SSL_set_connect_state(self._ssl)\n        return self._socket.connect(addr)\n\n    def connect_ex(self, addr) -> int:\n        \"\"\"\n        Call the :meth:`connect_ex` method of the underlying socket and set up\n        SSL on the socket, using the Context object supplied to this Connection\n        object at creation. Note that if the :meth:`connect_ex` method of the\n        socket doesn't return 0, SSL won't be initialized.\n\n        :param addr: A remove address\n        :return: What the socket's connect_ex method returns\n        \"\"\"\n        connect_ex = self._socket.connect_ex\n        self.set_connect_state()\n        return connect_ex(addr)\n\n    def accept(self) -> Tuple[\"Connection\", Any]:\n        \"\"\"\n        Call the :meth:`accept` method of the underlying socket and set up SSL\n        on the returned socket, using the Context object supplied to this\n        :class:`Connection` object at creation.\n\n        :return: A *(conn, addr)* pair where *conn* is the new\n            :class:`Connection` object created, and *address* is as returned by\n            the socket's :meth:`accept`.\n        \"\"\"\n        client, addr = self._socket.accept()\n        conn = Connection(self._context, client)\n        conn.set_accept_state()\n        return (conn, addr)\n\n    def DTLSv1_listen(self) -> None:\n        \"\"\"\n        Call the OpenSSL function DTLSv1_listen on this connection. See the\n        OpenSSL manual for more details.\n\n        :return: None\n        \"\"\"\n        # Possible future extension: return the BIO_ADDR in some form.\n        bio_addr = _lib.BIO_ADDR_new()\n        try:\n            result = _lib.DTLSv1_listen(self._ssl, bio_addr)\n        finally:\n            _lib.BIO_ADDR_free(bio_addr)\n        # DTLSv1_listen is weird. A zero return value means 'didn't find a\n        # ClientHello with valid cookie, but keep trying'. So basically\n        # WantReadError. But it doesn't work correctly with _raise_ssl_error.\n        # So we raise it manually instead.\n        if self._cookie_generate_helper is not None:\n            self._cookie_generate_helper.raise_if_problem()\n        if self._cookie_verify_helper is not None:\n            self._cookie_verify_helper.raise_if_problem()\n        if result == 0:\n            raise WantReadError()\n        if result < 0:\n            self._raise_ssl_error(self._ssl, result)\n\n    def DTLSv1_get_timeout(self) -> Optional[int]:\n        \"\"\"\n        Determine when the DTLS SSL object next needs to perform internal\n        processing due to the passage of time.\n\n        When the returned number of seconds have passed, the\n        :meth:`DTLSv1_handle_timeout` method needs to be called.\n\n        :return: The time left in seconds before the next timeout or `None`\n            if no timeout is currently active.\n        \"\"\"\n        ptv_sec = _ffi.new(\"time_t *\")\n        ptv_usec = _ffi.new(\"long *\")\n        if _lib.Cryptography_DTLSv1_get_timeout(self._ssl, ptv_sec, ptv_usec):\n            return ptv_sec[0] + (ptv_usec[0] / 1000000)\n        else:\n            return None\n\n    def DTLSv1_handle_timeout(self) -> bool:\n        \"\"\"\n        Handles any timeout events which have become pending on a DTLS SSL\n        object.\n\n        :return: `True` if there was a pending timeout, `False` otherwise.\n        \"\"\"\n        result = _lib.DTLSv1_handle_timeout(self._ssl)\n        if result < 0:\n            self._raise_ssl_error(self._ssl, result)\n        else:\n            return bool(result)\n\n    def bio_shutdown(self) -> None:\n        \"\"\"\n        If the Connection was created with a memory BIO, this method can be\n        used to indicate that *end of file* has been reached on the read end of\n        that memory BIO.\n\n        :return: None\n        \"\"\"\n        if self._from_ssl is None:\n            raise TypeError(\"Connection sock was not None\")\n\n        _lib.BIO_set_mem_eof_return(self._into_ssl, 0)\n\n    def shutdown(self) -> bool:\n        \"\"\"\n        Send the shutdown message to the Connection.\n\n        :return: True if the shutdown completed successfully (i.e. both sides\n                 have sent closure alerts), False otherwise (in which case you\n                 call :meth:`recv` or :meth:`send` when the connection becomes\n                 readable/writeable).\n        \"\"\"\n        result = _lib.SSL_shutdown(self._ssl)\n        if result < 0:\n            self._raise_ssl_error(self._ssl, result)\n        elif result > 0:\n            return True\n        else:\n            return False\n\n    def get_cipher_list(self) -> List[str]:\n        \"\"\"\n        Retrieve the list of ciphers used by the Connection object.\n\n        :return: A list of native cipher strings.\n        \"\"\"\n        ciphers = []\n        for i in count():\n            result = _lib.SSL_get_cipher_list(self._ssl, i)\n            if result == _ffi.NULL:\n                break\n            ciphers.append(_ffi.string(result).decode(\"utf-8\"))\n        return ciphers\n\n    def get_client_ca_list(self) -> List[X509Name]:\n        \"\"\"\n        Get CAs whose certificates are suggested for client authentication.\n\n        :return: If this is a server connection, the list of certificate\n            authorities that will be sent or has been sent to the client, as\n            controlled by this :class:`Connection`'s :class:`Context`.\n\n            If this is a client connection, the list will be empty until the\n            connection with the server is established.\n\n        .. versionadded:: 0.10\n        \"\"\"\n        ca_names = _lib.SSL_get_client_CA_list(self._ssl)\n        if ca_names == _ffi.NULL:\n            # TODO: This is untested.\n            return []\n\n        result = []\n        for i in range(_lib.sk_X509_NAME_num(ca_names)):\n            name = _lib.sk_X509_NAME_value(ca_names, i)\n            copy = _lib.X509_NAME_dup(name)\n            _openssl_assert(copy != _ffi.NULL)\n\n            pyname = X509Name.__new__(X509Name)\n            pyname._name = _ffi.gc(copy, _lib.X509_NAME_free)\n            result.append(pyname)\n        return result\n\n    def makefile(self, *args, **kwargs) -> None:\n        \"\"\"\n        The makefile() method is not implemented, since there is no dup\n        semantics for SSL connections\n\n        :raise: NotImplementedError\n        \"\"\"\n        raise NotImplementedError(\n            \"Cannot make file object of OpenSSL.SSL.Connection\"\n        )\n\n    def get_app_data(self) -> Any:\n        \"\"\"\n        Retrieve application data as set by :meth:`set_app_data`.\n\n        :return: The application data\n        \"\"\"\n        return self._app_data\n\n    def set_app_data(self, data: Any) -> None:\n        \"\"\"\n        Set application data\n\n        :param data: The application data\n        :return: None\n        \"\"\"\n        self._app_data = data\n\n    def get_shutdown(self) -> int:\n        \"\"\"\n        Get the shutdown state of the Connection.\n\n        :return: The shutdown state, a bitvector of SENT_SHUTDOWN,\n            RECEIVED_SHUTDOWN.\n        \"\"\"\n        return _lib.SSL_get_shutdown(self._ssl)\n\n    def set_shutdown(self, state: int) -> None:\n        \"\"\"\n        Set the shutdown state of the Connection.\n\n        :param state: bitvector of SENT_SHUTDOWN, RECEIVED_SHUTDOWN.\n        :return: None\n        \"\"\"\n        if not isinstance(state, int):\n            raise TypeError(\"state must be an integer\")\n\n        _lib.SSL_set_shutdown(self._ssl, state)\n\n    def get_state_string(self) -> bytes:\n        \"\"\"\n        Retrieve a verbose string detailing the state of the Connection.\n\n        :return: A string representing the state\n        :rtype: bytes\n        \"\"\"\n        return _ffi.string(_lib.SSL_state_string_long(self._ssl))\n\n    def server_random(self) -> Optional[bytes]:\n        \"\"\"\n        Retrieve the random value used with the server hello message.\n\n        :return: A string representing the state\n        \"\"\"\n        session = _lib.SSL_get_session(self._ssl)\n        if session == _ffi.NULL:\n            return None\n        length = _lib.SSL_get_server_random(self._ssl, _ffi.NULL, 0)\n        _openssl_assert(length > 0)\n        outp = _no_zero_allocator(\"unsigned char[]\", length)\n        _lib.SSL_get_server_random(self._ssl, outp, length)\n        return _ffi.buffer(outp, length)[:]\n\n    def client_random(self) -> Optional[bytes]:\n        \"\"\"\n        Retrieve the random value used with the client hello message.\n\n        :return: A string representing the state\n        \"\"\"\n        session = _lib.SSL_get_session(self._ssl)\n        if session == _ffi.NULL:\n            return None\n\n        length = _lib.SSL_get_client_random(self._ssl, _ffi.NULL, 0)\n        _openssl_assert(length > 0)\n        outp = _no_zero_allocator(\"unsigned char[]\", length)\n        _lib.SSL_get_client_random(self._ssl, outp, length)\n        return _ffi.buffer(outp, length)[:]\n\n    def master_key(self) -> Optional[bytes]:\n        \"\"\"\n        Retrieve the value of the master key for this session.\n\n        :return: A string representing the state\n        \"\"\"\n        session = _lib.SSL_get_session(self._ssl)\n        if session == _ffi.NULL:\n            return None\n\n        length = _lib.SSL_SESSION_get_master_key(session, _ffi.NULL, 0)\n        _openssl_assert(length > 0)\n        outp = _no_zero_allocator(\"unsigned char[]\", length)\n        _lib.SSL_SESSION_get_master_key(session, outp, length)\n        return _ffi.buffer(outp, length)[:]\n\n    def export_keying_material(\n        self, label: bytes, olen: int, context: Optional[bytes] = None\n    ) -> bytes:\n        \"\"\"\n        Obtain keying material for application use.\n\n        :param: label - a disambiguating label string as described in RFC 5705\n        :param: olen - the length of the exported key material in bytes\n        :param: context - a per-association context value\n        :return: the exported key material bytes or None\n        \"\"\"\n        outp = _no_zero_allocator(\"unsigned char[]\", olen)\n        context_buf = _ffi.NULL\n        context_len = 0\n        use_context = 0\n        if context is not None:\n            context_buf = context\n            context_len = len(context)\n            use_context = 1\n        success = _lib.SSL_export_keying_material(\n            self._ssl,\n            outp,\n            olen,\n            label,\n            len(label),\n            context_buf,\n            context_len,\n            use_context,\n        )\n        _openssl_assert(success == 1)\n        return _ffi.buffer(outp, olen)[:]\n\n    def sock_shutdown(self, *args, **kwargs):\n        \"\"\"\n        Call the :meth:`shutdown` method of the underlying socket.\n        See :manpage:`shutdown(2)`.\n\n        :return: What the socket's shutdown() method returns\n        \"\"\"\n        return self._socket.shutdown(*args, **kwargs)\n\n    def get_certificate(self) -> Optional[X509]:\n        \"\"\"\n        Retrieve the local certificate (if any)\n\n        :return: The local certificate\n        \"\"\"\n        cert = _lib.SSL_get_certificate(self._ssl)\n        if cert != _ffi.NULL:\n            _lib.X509_up_ref(cert)\n            return X509._from_raw_x509_ptr(cert)\n        return None\n\n    def get_peer_certificate(self) -> Optional[X509]:\n        \"\"\"\n        Retrieve the other side's certificate (if any)\n\n        :return: The peer's certificate\n        \"\"\"\n        cert = _lib.SSL_get_peer_certificate(self._ssl)\n        if cert != _ffi.NULL:\n            return X509._from_raw_x509_ptr(cert)\n        return None\n\n    @staticmethod\n    def _cert_stack_to_list(cert_stack) -> List[X509]:\n        \"\"\"\n        Internal helper to convert a STACK_OF(X509) to a list of X509\n        instances.\n        \"\"\"\n        result = []\n        for i in range(_lib.sk_X509_num(cert_stack)):\n            cert = _lib.sk_X509_value(cert_stack, i)\n            _openssl_assert(cert != _ffi.NULL)\n            res = _lib.X509_up_ref(cert)\n            _openssl_assert(res >= 1)\n            pycert = X509._from_raw_x509_ptr(cert)\n            result.append(pycert)\n        return result\n\n    def get_peer_cert_chain(self) -> Optional[List[X509]]:\n        \"\"\"\n        Retrieve the other side's certificate (if any)\n\n        :return: A list of X509 instances giving the peer's certificate chain,\n                 or None if it does not have one.\n        \"\"\"\n        cert_stack = _lib.SSL_get_peer_cert_chain(self._ssl)\n        if cert_stack == _ffi.NULL:\n            return None\n\n        return self._cert_stack_to_list(cert_stack)\n\n    def get_verified_chain(self) -> Optional[List[X509]]:\n        \"\"\"\n        Retrieve the verified certificate chain of the peer including the\n        peer's end entity certificate. It must be called after a session has\n        been successfully established. If peer verification was not successful\n        the chain may be incomplete, invalid, or None.\n\n        :return: A list of X509 instances giving the peer's verified\n                 certificate chain, or None if it does not have one.\n\n        .. versionadded:: 20.0\n        \"\"\"\n        # OpenSSL 1.1+\n        cert_stack = _lib.SSL_get0_verified_chain(self._ssl)\n        if cert_stack == _ffi.NULL:\n            return None\n\n        return self._cert_stack_to_list(cert_stack)\n\n    def want_read(self) -> bool:\n        \"\"\"\n        Checks if more data has to be read from the transport layer to complete\n        an operation.\n\n        :return: True iff more data has to be read\n        \"\"\"\n        return _lib.SSL_want_read(self._ssl)\n\n    def want_write(self) -> bool:\n        \"\"\"\n        Checks if there is data to write to the transport layer to complete an\n        operation.\n\n        :return: True iff there is data to write\n        \"\"\"\n        return _lib.SSL_want_write(self._ssl)\n\n    def set_accept_state(self) -> None:\n        \"\"\"\n        Set the connection to work in server mode. The handshake will be\n        handled automatically by read/write.\n\n        :return: None\n        \"\"\"\n        _lib.SSL_set_accept_state(self._ssl)\n\n    def set_connect_state(self) -> None:\n        \"\"\"\n        Set the connection to work in client mode. The handshake will be\n        handled automatically by read/write.\n\n        :return: None\n        \"\"\"\n        _lib.SSL_set_connect_state(self._ssl)\n\n    def get_session(self) -> Optional[Session]:\n        \"\"\"\n        Returns the Session currently used.\n\n        :return: An instance of :class:`OpenSSL.SSL.Session` or\n            :obj:`None` if no session exists.\n\n        .. versionadded:: 0.14\n        \"\"\"\n        session = _lib.SSL_get1_session(self._ssl)\n        if session == _ffi.NULL:\n            return None\n\n        pysession = Session.__new__(Session)\n        pysession._session = _ffi.gc(session, _lib.SSL_SESSION_free)\n        return pysession\n\n    def set_session(self, session: Session) -> None:\n        \"\"\"\n        Set the session to be used when the TLS/SSL connection is established.\n\n        :param session: A Session instance representing the session to use.\n        :returns: None\n\n        .. versionadded:: 0.14\n        \"\"\"\n        if not isinstance(session, Session):\n            raise TypeError(\"session must be a Session instance\")\n\n        result = _lib.SSL_set_session(self._ssl, session._session)\n        _openssl_assert(result == 1)\n\n    def _get_finished_message(self, function) -> Optional[bytes]:\n        \"\"\"\n        Helper to implement :meth:`get_finished` and\n        :meth:`get_peer_finished`.\n\n        :param function: Either :data:`SSL_get_finished`: or\n            :data:`SSL_get_peer_finished`.\n\n        :return: :data:`None` if the desired message has not yet been\n            received, otherwise the contents of the message.\n        :rtype: :class:`bytes` or :class:`NoneType`\n        \"\"\"\n        # The OpenSSL documentation says nothing about what might happen if the\n        # count argument given is zero.  Specifically, it doesn't say whether\n        # the output buffer may be NULL in that case or not.  Inspection of the\n        # implementation reveals that it calls memcpy() unconditionally.\n        # Section 7.1.4, paragraph 1 of the C standard suggests that\n        # memcpy(NULL, source, 0) is not guaranteed to produce defined (let\n        # alone desirable) behavior (though it probably does on just about\n        # every implementation...)\n        #\n        # Allocate a tiny buffer to pass in (instead of just passing NULL as\n        # one might expect) for the initial call so as to be safe against this\n        # potentially undefined behavior.\n        empty = _ffi.new(\"char[]\", 0)\n        size = function(self._ssl, empty, 0)\n        if size == 0:\n            # No Finished message so far.\n            return None\n\n        buf = _no_zero_allocator(\"char[]\", size)\n        function(self._ssl, buf, size)\n        return _ffi.buffer(buf, size)[:]\n\n    def get_finished(self) -> Optional[bytes]:\n        \"\"\"\n        Obtain the latest TLS Finished message that we sent.\n\n        :return: The contents of the message or :obj:`None` if the TLS\n            handshake has not yet completed.\n        :rtype: :class:`bytes` or :class:`NoneType`\n\n        .. versionadded:: 0.15\n        \"\"\"\n        return self._get_finished_message(_lib.SSL_get_finished)\n\n    def get_peer_finished(self) -> Optional[bytes]:\n        \"\"\"\n        Obtain the latest TLS Finished message that we received from the peer.\n\n        :return: The contents of the message or :obj:`None` if the TLS\n            handshake has not yet completed.\n        :rtype: :class:`bytes` or :class:`NoneType`\n\n        .. versionadded:: 0.15\n        \"\"\"\n        return self._get_finished_message(_lib.SSL_get_peer_finished)\n\n    def get_cipher_name(self) -> Optional[str]:\n        \"\"\"\n        Obtain the name of the currently used cipher.\n\n        :returns: The name of the currently used cipher or :obj:`None`\n            if no connection has been established.\n        :rtype: :class:`str` or :class:`NoneType`\n\n        .. versionadded:: 0.15\n        \"\"\"\n        cipher = _lib.SSL_get_current_cipher(self._ssl)\n        if cipher == _ffi.NULL:\n            return None\n        else:\n            name = _ffi.string(_lib.SSL_CIPHER_get_name(cipher))\n            return name.decode(\"utf-8\")\n\n    def get_cipher_bits(self) -> Optional[int]:\n        \"\"\"\n        Obtain the number of secret bits of the currently used cipher.\n\n        :returns: The number of secret bits of the currently used cipher\n            or :obj:`None` if no connection has been established.\n        :rtype: :class:`int` or :class:`NoneType`\n\n        .. versionadded:: 0.15\n        \"\"\"\n        cipher = _lib.SSL_get_current_cipher(self._ssl)\n        if cipher == _ffi.NULL:\n            return None\n        else:\n            return _lib.SSL_CIPHER_get_bits(cipher, _ffi.NULL)\n\n    def get_cipher_version(self) -> Optional[str]:\n        \"\"\"\n        Obtain the protocol version of the currently used cipher.\n\n        :returns: The protocol name of the currently used cipher\n            or :obj:`None` if no connection has been established.\n        :rtype: :class:`str` or :class:`NoneType`\n\n        .. versionadded:: 0.15\n        \"\"\"\n        cipher = _lib.SSL_get_current_cipher(self._ssl)\n        if cipher == _ffi.NULL:\n            return None\n        else:\n            version = _ffi.string(_lib.SSL_CIPHER_get_version(cipher))\n            return version.decode(\"utf-8\")\n\n    def get_protocol_version_name(self) -> str:\n        \"\"\"\n        Retrieve the protocol version of the current connection.\n\n        :returns: The TLS version of the current connection, for example\n            the value for TLS 1.2 would be ``TLSv1.2``or ``Unknown``\n            for connections that were not successfully established.\n        :rtype: :class:`str`\n        \"\"\"\n        version = _ffi.string(_lib.SSL_get_version(self._ssl))\n        return version.decode(\"utf-8\")\n\n    def get_protocol_version(self) -> int:\n        \"\"\"\n        Retrieve the SSL or TLS protocol version of the current connection.\n\n        :returns: The TLS version of the current connection.  For example,\n            it will return ``0x769`` for connections made over TLS version 1.\n        :rtype: :class:`int`\n        \"\"\"\n        version = _lib.SSL_version(self._ssl)\n        return version\n\n    @_requires_alpn\n    def set_alpn_protos(self, protos: List[bytes]) -> None:\n        \"\"\"\n        Specify the client's ALPN protocol list.\n\n        These protocols are offered to the server during protocol negotiation.\n\n        :param protos: A list of the protocols to be offered to the server.\n            This list should be a Python list of bytestrings representing the\n            protocols to offer, e.g. ``[b'http/1.1', b'spdy/2']``.\n        \"\"\"\n        # Different versions of OpenSSL are inconsistent about how they handle\n        # empty proto lists (see #1043), so we avoid the problem entirely by\n        # rejecting them ourselves.\n        if not protos:\n            raise ValueError(\"at least one protocol must be specified\")\n\n        # Take the list of protocols and join them together, prefixing them\n        # with their lengths.\n        protostr = b\"\".join(\n            chain.from_iterable((bytes((len(p),)), p) for p in protos)\n        )\n\n        # Build a C string from the list. We don't need to save this off\n        # because OpenSSL immediately copies the data out.\n        input_str = _ffi.new(\"unsigned char[]\", protostr)\n\n        # https://www.openssl.org/docs/man1.1.0/man3/SSL_CTX_set_alpn_protos.html:\n        # SSL_CTX_set_alpn_protos() and SSL_set_alpn_protos()\n        # return 0 on success, and non-0 on failure.\n        # WARNING: these functions reverse the return value convention.\n        _openssl_assert(\n            _lib.SSL_set_alpn_protos(self._ssl, input_str, len(protostr)) == 0\n        )\n\n    @_requires_alpn\n    def get_alpn_proto_negotiated(self) -> bytes:\n        \"\"\"\n        Get the protocol that was negotiated by ALPN.\n\n        :returns: A bytestring of the protocol name.  If no protocol has been\n            negotiated yet, returns an empty bytestring.\n        \"\"\"\n        data = _ffi.new(\"unsigned char **\")\n        data_len = _ffi.new(\"unsigned int *\")\n\n        _lib.SSL_get0_alpn_selected(self._ssl, data, data_len)\n\n        if not data_len:\n            return b\"\"\n\n        return _ffi.buffer(data[0], data_len[0])[:]\n\n    def get_selected_srtp_profile(self) -> bytes:\n        \"\"\"\n        Get the SRTP protocol which was negotiated.\n\n        :returns: A bytestring of the SRTP profile name. If no profile has been\n            negotiated yet, returns an empty bytestring.\n        \"\"\"\n        profile = _lib.SSL_get_selected_srtp_profile(self._ssl)\n        if not profile:\n            return b\"\"\n\n        return _ffi.string(profile.name)\n\n    def request_ocsp(self) -> None:\n        \"\"\"\n        Called to request that the server sends stapled OCSP data, if\n        available. If this is not called on the client side then the server\n        will not send OCSP data. Should be used in conjunction with\n        :meth:`Context.set_ocsp_client_callback`.\n        \"\"\"\n        rc = _lib.SSL_set_tlsext_status_type(\n            self._ssl, _lib.TLSEXT_STATUSTYPE_ocsp\n        )\n        _openssl_assert(rc == 1)\n"}