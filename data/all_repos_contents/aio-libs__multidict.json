{"setup.py": "import os\nimport platform\nimport sys\n\nfrom setuptools import Extension, setup\n\nNO_EXTENSIONS = bool(os.environ.get(\"MULTIDICT_NO_EXTENSIONS\"))\n\nif sys.implementation.name != \"cpython\":\n    NO_EXTENSIONS = True\n\nCFLAGS = [\"-O2\"]\n# CFLAGS = ['-g']\nif platform.system() != \"Windows\":\n    CFLAGS.extend(\n        [\n            \"-std=c99\",\n            \"-Wall\",\n            \"-Wsign-compare\",\n            \"-Wconversion\",\n            \"-fno-strict-aliasing\",\n            \"-pedantic\",\n        ]\n    )\n\nextensions = [\n    Extension(\n        \"multidict._multidict\",\n        [\"multidict/_multidict.c\"],\n        extra_compile_args=CFLAGS,\n    ),\n]\n\n\nif not NO_EXTENSIONS:\n    print(\"*********************\")\n    print(\"* Accelerated build *\")\n    print(\"*********************\")\n    setup(ext_modules=extensions)\nelse:\n    print(\"*********************\")\n    print(\"* Pure Python build *\")\n    print(\"*********************\")\n    setup()\n", "multidict/_abc.py": "import abc\nimport sys\nimport types\nfrom collections.abc import Mapping, MutableMapping\n\n\nclass _TypingMeta(abc.ABCMeta):\n    # A fake metaclass to satisfy typing deps in runtime\n    # basically MultiMapping[str] and other generic-like type instantiations\n    # are emulated.\n    # Note: real type hints are provided by __init__.pyi stub file\n    if sys.version_info >= (3, 9):\n\n        def __getitem__(self, key):\n            return types.GenericAlias(self, key)\n\n    else:\n\n        def __getitem__(self, key):\n            return self\n\n\nclass MultiMapping(Mapping, metaclass=_TypingMeta):\n    @abc.abstractmethod\n    def getall(self, key, default=None):\n        raise KeyError\n\n    @abc.abstractmethod\n    def getone(self, key, default=None):\n        raise KeyError\n\n\nclass MutableMultiMapping(MultiMapping, MutableMapping):\n    @abc.abstractmethod\n    def add(self, key, value):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def extend(self, *args, **kwargs):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def popone(self, key, default=None):\n        raise KeyError\n\n    @abc.abstractmethod\n    def popall(self, key, default=None):\n        raise KeyError\n", "multidict/_compat.py": "import os\nimport platform\n\nNO_EXTENSIONS = bool(os.environ.get(\"MULTIDICT_NO_EXTENSIONS\"))\n\nPYPY = platform.python_implementation() == \"PyPy\"\n\nUSE_EXTENSIONS = not NO_EXTENSIONS and not PYPY\n\nif USE_EXTENSIONS:\n    try:\n        from . import _multidict  # type: ignore[attr-defined]  # noqa: F401\n    except ImportError:\n        USE_EXTENSIONS = False\n", "multidict/__init__.py": "\"\"\"Multidict implementation.\n\nHTTP Headers and URL query string require specific data structure:\nmultidict. It behaves mostly like a dict but it can have\nseveral values for the same key.\n\"\"\"\n\nfrom ._abc import MultiMapping, MutableMultiMapping\nfrom ._compat import USE_EXTENSIONS\n\n__all__ = (\n    \"MultiMapping\",\n    \"MutableMultiMapping\",\n    \"MultiDictProxy\",\n    \"CIMultiDictProxy\",\n    \"MultiDict\",\n    \"CIMultiDict\",\n    \"upstr\",\n    \"istr\",\n    \"getversion\",\n)\n\n__version__ = \"6.0.6.dev0\"\n\n\ntry:\n    if not USE_EXTENSIONS:\n        raise ImportError\n    from ._multidict import (\n        CIMultiDict,\n        CIMultiDictProxy,\n        MultiDict,\n        MultiDictProxy,\n        getversion,\n        istr,\n    )\nexcept ImportError:  # pragma: no cover\n    from ._multidict_py import (\n        CIMultiDict,\n        CIMultiDictProxy,\n        MultiDict,\n        MultiDictProxy,\n        getversion,\n        istr,\n    )\n\n\nupstr = istr\n", "multidict/_multidict_base.py": "import sys\nfrom collections.abc import ItemsView, Iterable, KeysView, Set, ValuesView\n\nif sys.version_info >= (3, 11):\n    from typing import assert_never\nelse:\n    from typing_extensions import assert_never\n\n\ndef _abc_itemsview_register(view_cls):\n    ItemsView.register(view_cls)\n\n\ndef _abc_keysview_register(view_cls):\n    KeysView.register(view_cls)\n\n\ndef _abc_valuesview_register(view_cls):\n    ValuesView.register(view_cls)\n\n\ndef _viewbaseset_richcmp(view, other, op):\n    if op == 0:  # <\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) < len(other) and view <= other\n    elif op == 1:  # <=\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(view) > len(other):\n            return False\n        for elem in view:\n            if elem not in other:\n                return False\n        return True\n    elif op == 2:  # ==\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) == len(other) and view <= other\n    elif op == 3:  # !=\n        return not view == other\n    elif op == 4:  # >\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) > len(other) and view >= other\n    elif op == 5:  # >=\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(view) < len(other):\n            return False\n        for elem in other:\n            if elem not in view:\n                return False\n        return True\n    else:  # pragma: no cover\n        assert_never(op)\n\n\ndef _viewbaseset_and(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view & other\n\n\ndef _viewbaseset_or(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view | other\n\n\ndef _viewbaseset_sub(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view - other\n\n\ndef _viewbaseset_xor(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view ^ other\n\n\ndef _itemsview_isdisjoint(view, other):\n    \"Return True if two sets have a null intersection.\"\n    for v in other:\n        if v in view:\n            return False\n    return True\n\n\ndef _itemsview_repr(view):\n    lst = []\n    for k, v in view:\n        lst.append(\"{!r}: {!r}\".format(k, v))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _keysview_isdisjoint(view, other):\n    \"Return True if two sets have a null intersection.\"\n    for k in other:\n        if k in view:\n            return False\n    return True\n\n\ndef _keysview_repr(view):\n    lst = []\n    for k in view:\n        lst.append(\"{!r}\".format(k))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _valuesview_repr(view):\n    lst = []\n    for v in view:\n        lst.append(\"{!r}\".format(v))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _mdrepr(md):\n    lst = []\n    for k, v in md.items():\n        lst.append(\"'{}': {!r}\".format(k, v))\n    body = \", \".join(lst)\n    return \"<{}({})>\".format(md.__class__.__name__, body)\n", "multidict/_multidict_py.py": "import sys\nimport types\nfrom array import array\nfrom collections import abc\n\nfrom ._abc import MultiMapping, MutableMultiMapping\n\n_marker = object()\n\nif sys.version_info >= (3, 9):\n    GenericAlias = types.GenericAlias\nelse:\n\n    def GenericAlias(cls):\n        return cls\n\n\nclass istr(str):\n\n    \"\"\"Case insensitive str.\"\"\"\n\n    __is_istr__ = True\n\n\nupstr = istr  # for relaxing backward compatibility problems\n\n\ndef getversion(md):\n    if not isinstance(md, _Base):\n        raise TypeError(\"Parameter should be multidict or proxy\")\n    return md._impl._version\n\n\n_version = array(\"Q\", [0])\n\n\nclass _Impl:\n    __slots__ = (\"_items\", \"_version\")\n\n    def __init__(self):\n        self._items = []\n        self.incr_version()\n\n    def incr_version(self):\n        global _version\n        v = _version\n        v[0] += 1\n        self._version = v[0]\n\n    if sys.implementation.name != \"pypy\":\n\n        def __sizeof__(self):\n            return object.__sizeof__(self) + sys.getsizeof(self._items)\n\n\nclass _Base:\n    def _title(self, key):\n        return key\n\n    def getall(self, key, default=_marker):\n        \"\"\"Return a list of all values matching the key.\"\"\"\n        identity = self._title(key)\n        res = [v for i, k, v in self._impl._items if i == identity]\n        if res:\n            return res\n        if not res and default is not _marker:\n            return default\n        raise KeyError(\"Key not found: %r\" % key)\n\n    def getone(self, key, default=_marker):\n        \"\"\"Get first value matching the key.\n\n        Raises KeyError if the key is not found and no default is provided.\n        \"\"\"\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return v\n        if default is not _marker:\n            return default\n        raise KeyError(\"Key not found: %r\" % key)\n\n    # Mapping interface #\n\n    def __getitem__(self, key):\n        return self.getone(key)\n\n    def get(self, key, default=None):\n        \"\"\"Get first value matching the key.\n\n        If the key is not found, returns the default (or None if no default is provided)\n        \"\"\"\n        return self.getone(key, default)\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def __len__(self):\n        return len(self._impl._items)\n\n    def keys(self):\n        \"\"\"Return a new view of the dictionary's keys.\"\"\"\n        return _KeysView(self._impl)\n\n    def items(self):\n        \"\"\"Return a new view of the dictionary's items *(key, value) pairs).\"\"\"\n        return _ItemsView(self._impl)\n\n    def values(self):\n        \"\"\"Return a new view of the dictionary's values.\"\"\"\n        return _ValuesView(self._impl)\n\n    def __eq__(self, other):\n        if not isinstance(other, abc.Mapping):\n            return NotImplemented\n        if isinstance(other, _Base):\n            lft = self._impl._items\n            rht = other._impl._items\n            if len(lft) != len(rht):\n                return False\n            for (i1, k2, v1), (i2, k2, v2) in zip(lft, rht):\n                if i1 != i2 or v1 != v2:\n                    return False\n            return True\n        if len(self._impl._items) != len(other):\n            return False\n        for k, v in self.items():\n            nv = other.get(k, _marker)\n            if v != nv:\n                return False\n        return True\n\n    def __contains__(self, key):\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return True\n        return False\n\n    def __repr__(self):\n        body = \", \".join(\"'{}': {!r}\".format(k, v) for k, v in self.items())\n        return \"<{}({})>\".format(self.__class__.__name__, body)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass MultiDictProxy(_Base, MultiMapping):\n    \"\"\"Read-only proxy for MultiDict instance.\"\"\"\n\n    def __init__(self, arg):\n        if not isinstance(arg, (MultiDict, MultiDictProxy)):\n            raise TypeError(\n                \"ctor requires MultiDict or MultiDictProxy instance\"\n                \", not {}\".format(type(arg))\n            )\n\n        self._impl = arg._impl\n\n    def __reduce__(self):\n        raise TypeError(\"can't pickle {} objects\".format(self.__class__.__name__))\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        return MultiDict(self.items())\n\n\nclass CIMultiDictProxy(MultiDictProxy):\n    \"\"\"Read-only proxy for CIMultiDict instance.\"\"\"\n\n    def __init__(self, arg):\n        if not isinstance(arg, (CIMultiDict, CIMultiDictProxy)):\n            raise TypeError(\n                \"ctor requires CIMultiDict or CIMultiDictProxy instance\"\n                \", not {}\".format(type(arg))\n            )\n\n        self._impl = arg._impl\n\n    def _title(self, key):\n        return key.title()\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        return CIMultiDict(self.items())\n\n\nclass MultiDict(_Base, MutableMultiMapping):\n    \"\"\"Dictionary with the support for duplicate keys.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._impl = _Impl()\n\n        self._extend(args, kwargs, self.__class__.__name__, self._extend_items)\n\n    if sys.implementation.name != \"pypy\":\n\n        def __sizeof__(self):\n            return object.__sizeof__(self) + sys.getsizeof(self._impl)\n\n    def __reduce__(self):\n        return (self.__class__, (list(self.items()),))\n\n    def _title(self, key):\n        return key\n\n    def _key(self, key):\n        if isinstance(key, str):\n            return key\n        else:\n            raise TypeError(\n                \"MultiDict keys should be either str \" \"or subclasses of str\"\n            )\n\n    def add(self, key, value):\n        identity = self._title(key)\n        self._impl._items.append((identity, self._key(key), value))\n        self._impl.incr_version()\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        cls = self.__class__\n        return cls(self.items())\n\n    __copy__ = copy\n\n    def extend(self, *args, **kwargs):\n        \"\"\"Extend current MultiDict with more values.\n\n        This method must be used instead of update.\n        \"\"\"\n        self._extend(args, kwargs, \"extend\", self._extend_items)\n\n    def _extend(self, args, kwargs, name, method):\n        if len(args) > 1:\n            raise TypeError(\n                \"{} takes at most 1 positional argument\"\n                \" ({} given)\".format(name, len(args))\n            )\n        if args:\n            arg = args[0]\n            if isinstance(args[0], (MultiDict, MultiDictProxy)) and not kwargs:\n                items = arg._impl._items\n            else:\n                if hasattr(arg, \"items\"):\n                    arg = arg.items()\n                if kwargs:\n                    arg = list(arg)\n                    arg.extend(list(kwargs.items()))\n                items = []\n                for item in arg:\n                    if not len(item) == 2:\n                        raise TypeError(\n                            \"{} takes either dict or list of (key, value) \"\n                            \"tuples\".format(name)\n                        )\n                    items.append((self._title(item[0]), self._key(item[0]), item[1]))\n\n            method(items)\n        else:\n            method(\n                [\n                    (self._title(key), self._key(key), value)\n                    for key, value in kwargs.items()\n                ]\n            )\n\n    def _extend_items(self, items):\n        for identity, key, value in items:\n            self.add(key, value)\n\n    def clear(self):\n        \"\"\"Remove all items from MultiDict.\"\"\"\n        self._impl._items.clear()\n        self._impl.incr_version()\n\n    # Mapping interface #\n\n    def __setitem__(self, key, value):\n        self._replace(key, value)\n\n    def __delitem__(self, key):\n        identity = self._title(key)\n        items = self._impl._items\n        found = False\n        for i in range(len(items) - 1, -1, -1):\n            if items[i][0] == identity:\n                del items[i]\n                found = True\n        if not found:\n            raise KeyError(key)\n        else:\n            self._impl.incr_version()\n\n    def setdefault(self, key, default=None):\n        \"\"\"Return value for key, set value to default if key is not present.\"\"\"\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return v\n        self.add(key, default)\n        return default\n\n    def popone(self, key, default=_marker):\n        \"\"\"Remove specified key and return the corresponding value.\n\n        If key is not found, d is returned if given, otherwise\n        KeyError is raised.\n\n        \"\"\"\n        identity = self._title(key)\n        for i in range(len(self._impl._items)):\n            if self._impl._items[i][0] == identity:\n                value = self._impl._items[i][2]\n                del self._impl._items[i]\n                self._impl.incr_version()\n                return value\n        if default is _marker:\n            raise KeyError(key)\n        else:\n            return default\n\n    pop = popone  # type: ignore\n\n    def popall(self, key, default=_marker):\n        \"\"\"Remove all occurrences of key and return the list of corresponding\n        values.\n\n        If key is not found, default is returned if given, otherwise\n        KeyError is raised.\n\n        \"\"\"\n        found = False\n        identity = self._title(key)\n        ret = []\n        for i in range(len(self._impl._items) - 1, -1, -1):\n            item = self._impl._items[i]\n            if item[0] == identity:\n                ret.append(item[2])\n                del self._impl._items[i]\n                self._impl.incr_version()\n                found = True\n        if not found:\n            if default is _marker:\n                raise KeyError(key)\n            else:\n                return default\n        else:\n            ret.reverse()\n            return ret\n\n    def popitem(self):\n        \"\"\"Remove and return an arbitrary (key, value) pair.\"\"\"\n        if self._impl._items:\n            i = self._impl._items.pop(0)\n            self._impl.incr_version()\n            return i[1], i[2]\n        else:\n            raise KeyError(\"empty multidict\")\n\n    def update(self, *args, **kwargs):\n        \"\"\"Update the dictionary from *other*, overwriting existing keys.\"\"\"\n        self._extend(args, kwargs, \"update\", self._update_items)\n\n    def _update_items(self, items):\n        if not items:\n            return\n        used_keys = {}\n        for identity, key, value in items:\n            start = used_keys.get(identity, 0)\n            for i in range(start, len(self._impl._items)):\n                item = self._impl._items[i]\n                if item[0] == identity:\n                    used_keys[identity] = i + 1\n                    self._impl._items[i] = (identity, key, value)\n                    break\n            else:\n                self._impl._items.append((identity, key, value))\n                used_keys[identity] = len(self._impl._items)\n\n        # drop tails\n        i = 0\n        while i < len(self._impl._items):\n            item = self._impl._items[i]\n            identity = item[0]\n            pos = used_keys.get(identity)\n            if pos is None:\n                i += 1\n                continue\n            if i >= pos:\n                del self._impl._items[i]\n            else:\n                i += 1\n\n        self._impl.incr_version()\n\n    def _replace(self, key, value):\n        key = self._key(key)\n        identity = self._title(key)\n        items = self._impl._items\n\n        for i in range(len(items)):\n            item = items[i]\n            if item[0] == identity:\n                items[i] = (identity, key, value)\n                # i points to last found item\n                rgt = i\n                self._impl.incr_version()\n                break\n        else:\n            self._impl._items.append((identity, key, value))\n            self._impl.incr_version()\n            return\n\n        # remove all tail items\n        i = rgt + 1\n        while i < len(items):\n            item = items[i]\n            if item[0] == identity:\n                del items[i]\n            else:\n                i += 1\n\n\nclass CIMultiDict(MultiDict):\n    \"\"\"Dictionary with the support for duplicate case-insensitive keys.\"\"\"\n\n    def _title(self, key):\n        return key.title()\n\n\nclass _Iter:\n    __slots__ = (\"_size\", \"_iter\")\n\n    def __init__(self, size, iterator):\n        self._size = size\n        self._iter = iterator\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iter)\n\n    def __length_hint__(self):\n        return self._size\n\n\nclass _ViewBase:\n    def __init__(self, impl):\n        self._impl = impl\n\n    def __len__(self):\n        return len(self._impl._items)\n\n\nclass _ItemsView(_ViewBase, abc.ItemsView):\n    def __contains__(self, item):\n        assert isinstance(item, tuple) or isinstance(item, list)\n        assert len(item) == 2\n        for i, k, v in self._impl._items:\n            if item[0] == k and item[1] == v:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for i, k, v in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield k, v\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}: {!r}\".format(item[1], item[2]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n\n\nclass _ValuesView(_ViewBase, abc.ValuesView):\n    def __contains__(self, value):\n        for item in self._impl._items:\n            if item[2] == value:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for item in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield item[2]\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}\".format(item[2]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n\n\nclass _KeysView(_ViewBase, abc.KeysView):\n    def __contains__(self, key):\n        for item in self._impl._items:\n            if item[1] == key:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for item in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield item[1]\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}\".format(item[1]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n", "docs/conf.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n#\n# multidict documentation build configuration file, created by\n# sphinx-quickstart on Wed Mar  5 12:35:35 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nfrom __future__ import annotations\n\nimport os\nimport re\nfrom contextlib import suppress\nfrom pathlib import Path\n\nimport alabaster\nfrom sphinx.addnodes import pending_xref\nfrom sphinx.application import Sphinx\nfrom sphinx.environment import BuildEnvironment\n\n# isort: split\n\n\nfrom docutils.nodes import literal, reference\n\nPROJECT_ROOT_DIR = Path(__file__).parents[1].resolve()\nIS_RELEASE_ON_RTD = (\n    os.getenv(\"READTHEDOCS\", \"False\") == \"True\"\n    and os.environ[\"READTHEDOCS_VERSION_TYPE\"] == \"tag\"\n)\nif IS_RELEASE_ON_RTD:\n    tags: set[str]\n    tags.add(\"is_release\")\n\n\n_docs_path = Path(__file__).parent\n_version_path = _docs_path / \"..\" / \"multidict\" / \"__init__.py\"\n\n\nwith _version_path.open(encoding=\"utf-8\") as fp:\n    _version_search_result = re.search(\n        r'^__version__ = \"'\n        r\"(?P<major>\\d+)\"\n        r\"\\.(?P<minor>\\d+)\"\n        r\"\\.(?P<patch>\\d+)\"\n        r'(?P<tag>.*)?\"$',\n        fp.read(),\n        re.M,\n    )\n    if _version_search_result is None:\n        raise RuntimeError(\"Unable to determine version.\")\n    try:\n        _version_info = _version_search_result.groupdict()\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    # stdlib-party extensions:\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.viewcode\",\n    # Third-party extensions:\n    \"alabaster\",\n    \"sphinxcontrib.towncrier.ext\",  # provides `towncrier-draft-entries` directive\n]\n\n\nwith suppress(ImportError):\n    # spelling extension is optional, only add it when installed\n    import sphinxcontrib.spelling  # noqa\n\n    extensions.append(\"sphinxcontrib.spelling\")\n\nintersphinx_mapping = {\n    \"pyperf\": (\"https://pyperf.readthedocs.io/en/latest\", None),\n    \"python\": (\"http://docs.python.org/3\", None),\n    \"aiohttp\": (\"https://aiohttp.readthedocs.io/en/stable/\", None),\n}\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# The suffix of source filenames.\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\n\ngithub_url = \"https://github.com\"\ngithub_repo_org = \"aio-libs\"\ngithub_repo_name = \"multidict\"\ngithub_repo_slug = f\"{github_repo_org}/{github_repo_name}\"\ngithub_repo_url = f\"{github_url}/{github_repo_slug}\"\ngithub_sponsors_url = f\"{github_url}/sponsors\"\n\nproject = github_repo_name\ncopyright = \"2016, Andrew Svetlov and aio-libs contributors\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \"{major}.{minor}\".format(**_version_info)\n# The full version, including alpha/beta/rc tags.\nrelease = \"{major}.{minor}.{patch}{tag}\".format_map(_version_info)\n\nrst_epilog = f\"\"\"\n.. |project| replace:: {project}\n\"\"\"  # pylint: disable=invalid-name\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\ndefault_role = \"any\"\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# The default language to highlight source code in.\nhighlight_language = \"python\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for extlinks extension ---------------------------------------\nextlinks = {\n    \"issue\": (f\"{github_repo_url}/issues/%s\", \"#%s\"),\n    \"pr\": (f\"{github_repo_url}/pull/%s\", \"PR #%s\"),\n    \"commit\": (f\"{github_repo_url}/commit/%s\", \"%s\"),\n    \"gh\": (f\"{github_url}/%s\", \"GitHub: %s\"),\n    \"user\": (f\"{github_sponsors_url}/%s\", \"@%s\"),\n}\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = \"alabaster\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    # 'logo': 'aiohttp-icon-128x128.png',\n    \"description\": project,\n    \"github_user\": github_repo_org,\n    \"github_repo\": github_repo_name,\n    \"github_button\": True,\n    \"github_type\": \"star\",\n    \"github_banner\": True,\n    \"codecov_button\": True,\n    \"pre_bg\": \"#FFF6E5\",\n    \"note_bg\": \"#E5ECD1\",\n    \"note_border\": \"#BFCF8C\",\n    \"body_text\": \"#482C0A\",\n    \"sidebar_text\": \"#49443E\",\n    \"sidebar_header\": \"#4B4032\",\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\nhtml_theme_path = [alabaster.get_path()]\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = 'aiohttp-icon.svg'\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = 'aiohttp-icon.ico'\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n# html_static_path = ['_static']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n# html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\nhtml_sidebars = {\n    \"**\": [\n        \"about.html\",\n        \"navigation.html\",\n        \"searchbox.html\",\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"multidictdoc\"\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements: dict[str, str] = {\n    # The paper size ('letterpaper' or 'a4paper').\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    # 'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\"index\", \"multidict.tex\", \"multidict Documentation\", \"Andrew Svetlov\", \"manual\"),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(\"index\", project, \"multidict Documentation\", [\"Andrew Svetlov\"], 1)]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        \"index\",\n        project,\n        \"multidict Documentation\",\n        \"Andrew Svetlov\",\n        project,\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n\n# -- Strictness options --------------------------------------------------\nnitpicky = True\nnitpick_ignore: list[str] = []\n\n# -- Options for towncrier_draft extension -----------------------------------\n\ntowncrier_draft_autoversion_mode = \"draft\"  # or: 'sphinx-version', 'sphinx-release'\ntowncrier_draft_include_empty = True\ntowncrier_draft_working_directory = PROJECT_ROOT_DIR\ntowncrier_draft_config_path = \"pyproject.toml\"  # relative to cwd\n\n\ndef _replace_missing_aiohttp_hdrs_reference(\n    app: Sphinx,\n    env: BuildEnvironment,\n    node: pending_xref,\n    contnode: literal,\n) -> \"reference | None\":\n    if (node.get('refdomain'), node.get('reftype')) != (\"py\", \"mod\"):\n        return None\n\n    ref_target = node.get(\"reftarget\", \"\")\n    if ref_target != \"aiohttp:aiohttp.hdrs\":\n        return None\n\n    normalized_ref_target = \"aiohttp:aiohttp.hdrs\".split(\":\", 1)[-1]\n\n    return reference(\n        normalized_ref_target,\n        normalized_ref_target,\n        internal=False,\n        refuri=\"https://github.com/aio-libs/aiohttp/blob/43f3e23/aiohttp/hdrs.py\",\n    )\n\n\ndef setup(app: Sphinx) -> dict[str, bool | str]:\n    app.connect('missing-reference', _replace_missing_aiohttp_hdrs_reference)\n\n    return {\n        \"version\": \"builtin\",\n        \"parallel_read_safe\": True,\n        \"parallel_write_safe\": True,\n    }\n", "tests/test_circular_imports.py": "\"\"\"Tests for circular imports in all local packages and modules.\n\nThis ensures all internal packages can be imported right away without\nany need to import some other module before doing so.\n\nThis module is based on the idea that pytest uses for self-testing:\n* https://github.com/sanitizers/octomachinery/blob/be18b54/tests/circular_imports_test.py  # noqa: E501\n* https://github.com/pytest-dev/pytest/blob/d18c75b/testing/test_meta.py\n* https://twitter.com/codewithanthony/status/1229445110510735361\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport pkgutil\nimport subprocess\nimport sys\nfrom itertools import chain\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Generator\n\nimport pytest\n\nimport multidict\n\n\ndef _find_all_importables(pkg: ModuleType) -> list[str]:\n    \"\"\"Find all importables in the project.\n\n    Return them in order.\n    \"\"\"\n    return sorted(\n        set(\n            chain.from_iterable(\n                _discover_path_importables(Path(p), pkg.__name__) for p in pkg.__path__\n            ),\n        ),\n    )\n\n\ndef _discover_path_importables(\n    pkg_pth: Path,\n    pkg_name: str,\n) -> Generator[str, None, None]:\n    \"\"\"Yield all importables under a given path and package.\"\"\"\n    yield pkg_name\n    for dir_path, _d, file_names in os.walk(pkg_pth):\n        pkg_dir_path = Path(dir_path)\n\n        if pkg_dir_path.parts[-1] == \"__pycache__\":\n            continue\n\n        if all(Path(_).suffix != \".py\" for _ in file_names):\n            continue\n\n        rel_pt = pkg_dir_path.relative_to(pkg_pth)\n        pkg_pref = \".\".join((pkg_name,) + rel_pt.parts)\n        yield from (\n            pkg_path\n            for _, pkg_path, _ in pkgutil.walk_packages(\n                (str(pkg_dir_path),),\n                prefix=f\"{pkg_pref}.\",\n            )\n        )\n\n\n@pytest.fixture(params=_find_all_importables(multidict))\ndef import_path(request: pytest.FixtureRequest) -> str:\n    \"\"\"Return an importable from the multidict package.\"\"\"\n    importable_module: str = request.param\n    if importable_module == \"multidict._multidict\":\n        request.applymarker(pytest.mark.c_extension)\n\n    return importable_module\n\n\ndef test_no_warnings(import_path: str) -> None:\n    \"\"\"Verify that importing modules and packages doesn't explode.\n\n    This is seeking for any import errors including ones caused\n    by circular imports.\n    \"\"\"\n    imp_cmd = (\n        # fmt: off\n        sys.executable,\n        \"-I\",\n        \"-W\", \"error\",\n        \"-c\", f\"import {import_path!s}\",\n        # fmt: on\n    )\n\n    subprocess.check_call(imp_cmd)\n\n\n@pytest.mark.c_extension\ndef test_c_extension_preferred_by_default(monkeypatch: pytest.MonkeyPatch) -> None:\n    \"\"\"Verify that the C-extension is exposed by default.\"\"\"\n    monkeypatch.delenv(\"MULTIDICT_NO_EXTENSIONS\", raising=False)\n\n    imp_cmd = (\n        # fmt: off\n        sys.executable,\n        \"-I\",\n        \"-W\", \"error\",\n        \"-c\", \"import multidict; raise SystemExit(int(\"\n        \"multidict.istr.__module__ != 'multidict._multidict' \"\n        \"or multidict.USE_EXTENSIONS is not True))\",\n        # fmt: on\n    )\n\n    subprocess.check_call(imp_cmd)\n", "tests/test_update.py": "from collections import deque\nfrom typing import Type\n\nfrom multidict import MultiMapping\n\n\ndef test_update_replace(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = any_multidict_class([(\"a\", 4), (\"b\", 5), (\"a\", 6)])\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 5), (\"a\", 6), (\"c\", 10)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_append(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = any_multidict_class([(\"a\", 4), (\"a\", 5), (\"a\", 6)])\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 2), (\"a\", 5), (\"c\", 10), (\"a\", 6)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_remove(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = any_multidict_class([(\"a\", 4)])\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 2), (\"c\", 10)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_replace_seq(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = [(\"a\", 4), (\"b\", 5), (\"a\", 6)]\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 5), (\"a\", 6), (\"c\", 10)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_replace_seq2(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj1.update([(\"a\", 4)], b=5, a=6)\n    expected = [(\"a\", 4), (\"b\", 5), (\"a\", 6), (\"c\", 10)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_append_seq(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = [(\"a\", 4), (\"a\", 5), (\"a\", 6)]\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 2), (\"a\", 5), (\"c\", 10), (\"a\", 6)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_remove_seq(any_multidict_class: Type[MultiMapping[str]]) -> None:\n    obj1 = any_multidict_class([(\"a\", 1), (\"b\", 2), (\"a\", 3), (\"c\", 10)])\n    obj2 = [(\"a\", 4)]\n    obj1.update(obj2)\n    expected = [(\"a\", 4), (\"b\", 2), (\"c\", 10)]\n    assert list(obj1.items()) == expected\n\n\ndef test_update_md(\n    case_sensitive_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    d = case_sensitive_multidict_class()\n    d.add(\"key\", \"val1\")\n    d.add(\"key\", \"val2\")\n    d.add(\"key2\", \"val3\")\n\n    d.update(key=\"val\")\n\n    assert [(\"key\", \"val\"), (\"key2\", \"val3\")] == list(d.items())\n\n\ndef test_update_istr_ci_md(\n    case_insensitive_multidict_class: Type[MultiMapping[str]],\n    case_insensitive_str_class: str,\n) -> None:\n    d = case_insensitive_multidict_class()\n    d.add(case_insensitive_str_class(\"KEY\"), \"val1\")\n    d.add(\"key\", \"val2\")\n    d.add(\"key2\", \"val3\")\n\n    d.update({case_insensitive_str_class(\"key\"): \"val\"})\n\n    assert [(\"key\", \"val\"), (\"key2\", \"val3\")] == list(d.items())\n\n\ndef test_update_ci_md(\n    case_insensitive_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    d = case_insensitive_multidict_class()\n    d.add(\"KEY\", \"val1\")\n    d.add(\"key\", \"val2\")\n    d.add(\"key2\", \"val3\")\n\n    d.update(Key=\"val\")\n\n    assert [(\"Key\", \"val\"), (\"key2\", \"val3\")] == list(d.items())\n\n\ndef test_update_list_arg_and_kwds(\n    any_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    obj = any_multidict_class()\n    arg = [(\"a\", 1)]\n    obj.update(arg, b=2)\n    assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n    assert arg == [(\"a\", 1)]\n\n\ndef test_update_tuple_arg_and_kwds(\n    any_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    obj = any_multidict_class()\n    arg = ((\"a\", 1),)\n    obj.update(arg, b=2)\n    assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n    assert arg == ((\"a\", 1),)\n\n\ndef test_update_deque_arg_and_kwds(\n    any_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    obj = any_multidict_class()\n    arg = deque([(\"a\", 1)])\n    obj.update(arg, b=2)\n    assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n    assert arg == deque([(\"a\", 1)])\n", "tests/test_guard.py": "from typing import Type\n\nimport pytest\n\nfrom multidict import MultiMapping\n\n\ndef test_guard_items(\n    case_sensitive_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    md = case_sensitive_multidict_class({\"a\": \"b\"})\n    it = iter(md.items())\n    md[\"a\"] = \"c\"\n    with pytest.raises(RuntimeError):\n        next(it)\n\n\ndef test_guard_keys(\n    case_sensitive_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    md = case_sensitive_multidict_class({\"a\": \"b\"})\n    it = iter(md.keys())\n    md[\"a\"] = \"c\"\n    with pytest.raises(RuntimeError):\n        next(it)\n\n\ndef test_guard_values(\n    case_sensitive_multidict_class: Type[MultiMapping[str]],\n) -> None:\n    md = case_sensitive_multidict_class({\"a\": \"b\"})\n    it = iter(md.values())\n    md[\"a\"] = \"c\"\n    with pytest.raises(RuntimeError):\n        next(it)\n", "tests/test_mypy.py": "# This file doesn't use test parametrization because mypy doesn't nothing about it.\n# Concrete types are required\n\nimport multidict\n\n\ndef test_classes_not_abstract() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    multidict.MultiDictProxy(d1)\n    multidict.CIMultiDictProxy(d2)\n\n\ndef test_getitem() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"a\")\n\n    assert d1[\"a\"] == \"b\"\n    assert d2[\"a\"] == \"b\"\n    assert d3[\"a\"] == \"b\"\n    assert d4[\"a\"] == \"b\"\n\n    assert d1[key] == \"b\"\n    assert d2[key] == \"b\"\n    assert d3[key] == \"b\"\n    assert d4[key] == \"b\"\n\n\ndef test_get() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"a\")\n\n    assert d1.get(\"a\") == \"b\"\n    assert d2.get(\"a\") == \"b\"\n    assert d3.get(\"a\") == \"b\"\n    assert d4.get(\"a\") == \"b\"\n\n    assert d1.get(key) == \"b\"\n    assert d2.get(key) == \"b\"\n    assert d3.get(key) == \"b\"\n    assert d4.get(key) == \"b\"\n\n\ndef test_get_default() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"b\")\n\n    assert d1.get(\"b\", \"d\") == \"d\"\n    assert d2.get(\"b\", \"d\") == \"d\"\n    assert d3.get(\"b\", \"d\") == \"d\"\n    assert d4.get(\"b\", \"d\") == \"d\"\n\n    assert d1.get(key, \"d\") == \"d\"\n    assert d2.get(key, \"d\") == \"d\"\n    assert d3.get(key, \"d\") == \"d\"\n    assert d4.get(key, \"d\") == \"d\"\n\n\ndef test_getone() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"a\")\n\n    assert d1.getone(\"a\") == \"b\"\n    assert d2.getone(\"a\") == \"b\"\n    assert d3.getone(\"a\") == \"b\"\n    assert d4.getone(\"a\") == \"b\"\n\n    assert d1.getone(key) == \"b\"\n    assert d2.getone(key) == \"b\"\n    assert d3.getone(key) == \"b\"\n    assert d4.getone(key) == \"b\"\n\n\ndef test_getone_default() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"b\")\n\n    assert d1.getone(\"b\", 1) == 1\n    assert d2.getone(\"b\", 1) == 1\n    assert d3.getone(\"b\", 1) == 1\n    assert d4.getone(\"b\", 1) == 1\n\n    assert d1.getone(key, 1) == 1\n    assert d2.getone(key, 1) == 1\n    assert d3.getone(key, 1) == 1\n    assert d4.getone(key, 1) == 1\n\n\ndef test_getall() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"a\")\n\n    assert d1.getall(\"a\") == [\"b\"]\n    assert d2.getall(\"a\") == [\"b\"]\n    assert d3.getall(\"a\") == [\"b\"]\n    assert d4.getall(\"a\") == [\"b\"]\n\n    assert d1.getall(key) == [\"b\"]\n    assert d2.getall(key) == [\"b\"]\n    assert d3.getall(key) == [\"b\"]\n    assert d4.getall(key) == [\"b\"]\n\n\ndef test_getall_default() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    key = multidict.istr(\"b\")\n\n    assert d1.getall(\"b\", 1) == 1\n    assert d2.getall(\"b\", 1) == 1\n    assert d3.getall(\"b\", 1) == 1\n    assert d4.getall(\"b\", 1) == 1\n\n    assert d1.getall(key, 1) == 1\n    assert d2.getall(key, 1) == 1\n    assert d3.getall(key, 1) == 1\n    assert d4.getall(key, 1) == 1\n\n\ndef test_copy() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    assert d1.copy() == d1\n    assert d2.copy() == d2\n    assert d3.copy() == d1\n    assert d4.copy() == d2\n\n\ndef test_iter() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    d3 = multidict.MultiDictProxy(d1)\n    d4 = multidict.CIMultiDictProxy(d2)\n\n    for i in d1:\n        i.lower()  # str-specific class\n    for i in d2:\n        i.lower()  # str-specific class\n    for i in d3:\n        i.lower()  # str-specific class\n    for i in d4:\n        i.lower()  # str-specific class\n\n\ndef test_setitem() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    key = multidict.istr(\"a\")\n\n    d1[\"a\"] = \"b\"\n    d2[\"a\"] = \"b\"\n\n    d1[key] = \"b\"\n    d2[key] = \"b\"\n\n\ndef test_delitem() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    del d1[\"a\"]\n    del d2[\"a\"]\n\n    key = multidict.istr(\"a\")\n\n    d3: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d4: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    del d3[key]\n    del d4[key]\n\n\ndef test_additem() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    key = multidict.istr(\"a\")\n\n    d1.add(\"a\", \"b\")\n    d2.add(\"a\", \"b\")\n\n    d1.add(key, \"b\")\n    d2.add(key, \"b\")\n\n\ndef test_extend_mapping() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    key = multidict.istr(\"a\")\n\n    d1.extend({\"a\": \"b\"})\n    d2.extend({\"a\": \"b\"})\n\n    d1.extend({key: \"b\"})\n    d2.extend({key: \"b\"})\n\n\ndef test_update_mapping() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    key = multidict.istr(\"a\")\n\n    d1.update({\"a\": \"b\"})\n    d2.update({\"a\": \"b\"})\n\n    d1.update({key: \"b\"})\n    d2.update({key: \"b\"})\n\n\ndef test_popone() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    assert d1.popone(\"a\") == \"b\"\n    assert d2.popone(\"a\") == \"b\"\n\n    key = multidict.istr(\"a\")\n    d1 = multidict.MultiDict({\"a\": \"b\"})\n    d2 = multidict.CIMultiDict({\"a\": \"b\"})\n\n    assert d1.popone(key) == \"b\"\n    assert d2.popone(key) == \"b\"\n\n\ndef test_popall() -> None:\n    d1: multidict.MultiDict[str] = multidict.MultiDict({\"a\": \"b\"})\n    d2: multidict.CIMultiDict[str] = multidict.CIMultiDict({\"a\": \"b\"})\n\n    assert d1.popall(\"a\") == [\"b\"]\n    assert d2.popall(\"a\") == [\"b\"]\n\n    key = multidict.istr(\"a\")\n    d1 = multidict.MultiDict({\"a\": \"b\"})\n    d2 = multidict.CIMultiDict({\"a\": \"b\"})\n\n    assert d1.popall(key) == [\"b\"]\n    assert d2.popall(key) == [\"b\"]\n", "tests/gen_pickles.py": "import pickle\nfrom importlib import import_module\nfrom pathlib import Path\n\nTESTS_DIR = Path(__file__).parent.resolve()\n\n\ndef write(tag, cls, proto):\n    d = cls([(\"a\", 1), (\"a\", 2)])\n    file_basename = f\"{cls.__name__.lower()}-{tag}\"\n    with (TESTS_DIR / f\"{file_basename}.pickle.{proto}\").open(\"wb\") as f:\n        pickle.dump(d, f, proto)\n\n\ndef generate():\n    _impl_map = {\n        \"c-extension\": \"_multidict\",\n        \"pure-python\": \"_multidict_py\",\n    }\n    for proto in range(pickle.HIGHEST_PROTOCOL + 1):\n        for tag, impl_name in _impl_map.items():\n            impl = import_module(f\"multidict.{impl_name}\")\n            for cls in impl.CIMultiDict, impl.MultiDict:\n                write(tag, cls, proto)\n\n\nif __name__ == \"__main__\":\n    generate()\n", "tests/test_abc.py": "from collections.abc import Mapping, MutableMapping\n\nimport pytest\n\nfrom multidict import MultiMapping, MutableMultiMapping\n\n\ndef test_abc_inheritance():\n    assert issubclass(MultiMapping, Mapping)\n    assert not issubclass(MultiMapping, MutableMapping)\n    assert issubclass(MutableMultiMapping, Mapping)\n    assert issubclass(MutableMultiMapping, MutableMapping)\n\n\nclass A(MultiMapping):\n    def __getitem__(self, key):\n        pass\n\n    def __iter__(self):\n        pass\n\n    def __len__(self):\n        pass\n\n    def getall(self, key, default=None):\n        super().getall(key, default)\n\n    def getone(self, key, default=None):\n        super().getone(key, default)\n\n\ndef test_abc_getall():\n    with pytest.raises(KeyError):\n        A().getall(\"key\")\n\n\ndef test_abc_getone():\n    with pytest.raises(KeyError):\n        A().getone(\"key\")\n\n\nclass B(A, MutableMultiMapping):\n    def __setitem__(self, key, value):\n        pass\n\n    def __delitem__(self, key):\n        pass\n\n    def add(self, key, value):\n        super().add(key, value)\n\n    def extend(self, *args, **kwargs):\n        super().extend(*args, **kwargs)\n\n    def popall(self, key, default=None):\n        super().popall(key, default)\n\n    def popone(self, key, default=None):\n        super().popone(key, default)\n\n\ndef test_abc_add():\n    with pytest.raises(NotImplementedError):\n        B().add(\"key\", \"val\")\n\n\ndef test_abc_extend():\n    with pytest.raises(NotImplementedError):\n        B().extend()\n\n\ndef test_abc_popone():\n    with pytest.raises(KeyError):\n        B().popone(\"key\")\n\n\ndef test_abc_popall():\n    with pytest.raises(KeyError):\n        B().popall(\"key\")\n\n\ndef test_multidict_inheritance(any_multidict_class):\n    assert issubclass(any_multidict_class, MultiMapping)\n    assert issubclass(any_multidict_class, MutableMultiMapping)\n\n\ndef test_proxy_inheritance(any_multidict_proxy_class):\n    assert issubclass(any_multidict_proxy_class, MultiMapping)\n    assert not issubclass(any_multidict_proxy_class, MutableMultiMapping)\n\n\ndef test_generic_type_in_runtime():\n    MultiMapping[str]\n    MutableMultiMapping[str]\n", "tests/test_pickle.py": "import pickle\nfrom pathlib import Path\n\nimport pytest\n\nhere = Path(__file__).resolve().parent\n\n\ndef test_pickle(any_multidict_class, pickle_protocol):\n    d = any_multidict_class([(\"a\", 1), (\"a\", 2)])\n    pbytes = pickle.dumps(d, pickle_protocol)\n    obj = pickle.loads(pbytes)\n    assert d == obj\n    assert isinstance(obj, any_multidict_class)\n\n\ndef test_pickle_proxy(any_multidict_class, any_multidict_proxy_class):\n    d = any_multidict_class([(\"a\", 1), (\"a\", 2)])\n    proxy = any_multidict_proxy_class(d)\n    with pytest.raises(TypeError):\n        pickle.dumps(proxy)\n\n\ndef test_load_from_file(any_multidict_class, multidict_implementation, pickle_protocol):\n    multidict_class_name = any_multidict_class.__name__\n    pickle_file_basename = \"-\".join(\n        (\n            multidict_class_name.lower(),\n            multidict_implementation.tag,\n        )\n    )\n    d = any_multidict_class([(\"a\", 1), (\"a\", 2)])\n    fname = f\"{pickle_file_basename}.pickle.{pickle_protocol}\"\n    p = here / fname\n    with p.open(\"rb\") as f:\n        obj = pickle.load(f)\n    assert d == obj\n    assert isinstance(obj, any_multidict_class)\n", "tests/test_version.py": "from typing import Callable, Type\n\nimport pytest\n\nfrom multidict import MultiMapping\n\n\ndef test_getversion_bad_param(multidict_getversion_callable):\n    with pytest.raises(TypeError):\n        multidict_getversion_callable(1)\n\n\ndef test_ctor(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m1 = any_multidict_class()\n    v1 = multidict_getversion_callable(m1)\n    m2 = any_multidict_class()\n    v2 = multidict_getversion_callable(m2)\n    assert v1 != v2\n\n\ndef test_add(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    v = multidict_getversion_callable(m)\n    m.add(\"key\", \"val\")\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_delitem(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    del m[\"key\"]\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_delitem_not_found(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    with pytest.raises(KeyError):\n        del m[\"notfound\"]\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_setitem(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m[\"key\"] = \"val2\"\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_setitem_not_found(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m[\"notfound\"] = \"val2\"\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_clear(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.clear()\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_setdefault(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.setdefault(\"key2\", \"val2\")\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_popone(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.popone(\"key\")\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_popone_default(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.popone(\"key2\", \"default\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_popone_key_error(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    with pytest.raises(KeyError):\n        m.popone(\"key2\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_pop(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.pop(\"key\")\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_pop_default(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.pop(\"key2\", \"default\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_pop_key_error(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    with pytest.raises(KeyError):\n        m.pop(\"key2\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_popall(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.popall(\"key\")\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_popall_default(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.popall(\"key2\", \"default\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_popall_key_error(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    with pytest.raises(KeyError):\n        m.popall(\"key2\")\n    assert multidict_getversion_callable(m) == v\n\n\ndef test_popitem(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    m.add(\"key\", \"val\")\n    v = multidict_getversion_callable(m)\n    m.popitem()\n    assert multidict_getversion_callable(m) > v\n\n\ndef test_popitem_key_error(\n    any_multidict_class: Type[MultiMapping[str]],\n    multidict_getversion_callable: Callable,\n) -> None:\n    m = any_multidict_class()\n    v = multidict_getversion_callable(m)\n    with pytest.raises(KeyError):\n        m.popitem()\n    assert multidict_getversion_callable(m) == v\n", "tests/test_copy.py": "import copy\n\n\ndef test_copy(any_multidict_class):\n    d = any_multidict_class()\n    d[\"foo\"] = 6\n    d2 = d.copy()\n    d2[\"foo\"] = 7\n    assert d[\"foo\"] == 6\n    assert d2[\"foo\"] == 7\n\n\ndef test_copy_proxy(any_multidict_class, any_multidict_proxy_class):\n    d = any_multidict_class()\n    d[\"foo\"] = 6\n    p = any_multidict_proxy_class(d)\n    d2 = p.copy()\n    d2[\"foo\"] = 7\n    assert d[\"foo\"] == 6\n    assert p[\"foo\"] == 6\n    assert d2[\"foo\"] == 7\n\n\ndef test_copy_std_copy(any_multidict_class):\n    d = any_multidict_class()\n    d[\"foo\"] = 6\n    d2 = copy.copy(d)\n    d2[\"foo\"] = 7\n    assert d[\"foo\"] == 6\n    assert d2[\"foo\"] == 7\n\n\ndef test_ci_multidict_clone(any_multidict_class):\n    d = any_multidict_class(foo=6)\n    d2 = any_multidict_class(d)\n    d2[\"foo\"] = 7\n    assert d[\"foo\"] == 6\n    assert d2[\"foo\"] == 7\n", "tests/conftest.py": "from __future__ import annotations\n\nimport argparse\nimport pickle\nfrom dataclasses import dataclass\nfrom importlib import import_module\nfrom sys import version_info as _version_info\nfrom types import ModuleType\nfrom typing import Callable, Type\n\ntry:\n    from functools import cached_property  # Python 3.8+\nexcept ImportError:\n    from functools import lru_cache as _lru_cache\n\n    def cached_property(func):\n        return property(_lru_cache()(func))\n\n\nimport pytest\n\nfrom multidict import MultiMapping, MutableMultiMapping\n\nC_EXT_MARK = pytest.mark.c_extension\nPY_38_AND_BELOW = _version_info < (3, 9)\n\n\n@dataclass(frozen=True)\nclass MultidictImplementation:\n    \"\"\"A facade for accessing importable multidict module variants.\n\n    An instance essentially represents a c-extension or a pure-python module.\n    The actual underlying module is accessed dynamically through a property and\n    is cached.\n\n    It also has a text tag depending on what variant it is, and a string\n    representation suitable for use in Pytest's test IDs via parametrization.\n    \"\"\"\n\n    is_pure_python: bool\n    \"\"\"A flag showing whether this is a pure-python module or a C-extension.\"\"\"\n\n    @cached_property\n    def tag(self) -> str:\n        \"\"\"Return a text representation of the pure-python attribute.\"\"\"\n        return \"pure-python\" if self.is_pure_python else \"c-extension\"\n\n    @cached_property\n    def imported_module(self) -> ModuleType:\n        \"\"\"Return a loaded importable containing a multidict variant.\"\"\"\n        importable_module = \"_multidict_py\" if self.is_pure_python else \"_multidict\"\n        return import_module(f\"multidict.{importable_module}\")\n\n    def __str__(self):\n        \"\"\"Render the implementation facade instance as a string.\"\"\"\n        return f\"{self.tag}-module\"\n\n\n@pytest.fixture(\n    scope=\"session\",\n    params=(\n        pytest.param(\n            MultidictImplementation(is_pure_python=False),\n            marks=C_EXT_MARK,\n        ),\n        MultidictImplementation(is_pure_python=True),\n    ),\n    ids=str,\n)\ndef multidict_implementation(request: pytest.FixtureRequest) -> MultidictImplementation:\n    \"\"\"Return a multidict variant facade.\"\"\"\n    return request.param\n\n\n@pytest.fixture(scope=\"session\")\ndef multidict_module(\n    multidict_implementation: MultidictImplementation,\n) -> ModuleType:\n    \"\"\"Return a pre-imported module containing a multidict variant.\"\"\"\n    return multidict_implementation.imported_module\n\n\n@pytest.fixture(\n    scope=\"session\",\n    params=(\"MultiDict\", \"CIMultiDict\"),\n    ids=(\"case-sensitive\", \"case-insensitive\"),\n)\ndef any_multidict_class_name(request: pytest.FixtureRequest) -> str:\n    \"\"\"Return a class name of a mutable multidict implementation.\"\"\"\n    return request.param\n\n\n@pytest.fixture(scope=\"session\")\ndef any_multidict_class(\n    any_multidict_class_name: str,\n    multidict_module: ModuleType,\n) -> Type[MutableMultiMapping[str]]:\n    \"\"\"Return a class object of a mutable multidict implementation.\"\"\"\n    return getattr(multidict_module, any_multidict_class_name)\n\n\n@pytest.fixture(scope=\"session\")\ndef case_sensitive_multidict_class(\n    multidict_module: ModuleType,\n) -> Type[MutableMultiMapping[str]]:\n    \"\"\"Return a case-sensitive mutable multidict class.\"\"\"\n    return multidict_module.MultiDict\n\n\n@pytest.fixture(scope=\"session\")\ndef case_insensitive_multidict_class(\n    multidict_module: ModuleType,\n) -> Type[MutableMultiMapping[str]]:\n    \"\"\"Return a case-insensitive mutable multidict class.\"\"\"\n    return multidict_module.CIMultiDict\n\n\n@pytest.fixture(scope=\"session\")\ndef case_insensitive_str_class(multidict_module: ModuleType) -> Type[str]:\n    \"\"\"Return a case-insensitive string class.\"\"\"\n    return multidict_module.istr\n\n\n@pytest.fixture(scope=\"session\")\ndef any_multidict_proxy_class_name(any_multidict_class_name: str) -> str:\n    \"\"\"Return a class name of an immutable multidict implementation.\"\"\"\n    return f\"{any_multidict_class_name}Proxy\"\n\n\n@pytest.fixture(scope=\"session\")\ndef any_multidict_proxy_class(\n    any_multidict_proxy_class_name: str,\n    multidict_module: ModuleType,\n) -> Type[MultiMapping[str]]:\n    \"\"\"Return an immutable multidict implementation class object.\"\"\"\n    return getattr(multidict_module, any_multidict_proxy_class_name)\n\n\n@pytest.fixture(scope=\"session\")\ndef case_sensitive_multidict_proxy_class(\n    multidict_module: ModuleType,\n) -> Type[MutableMultiMapping[str]]:\n    \"\"\"Return a case-sensitive immutable multidict class.\"\"\"\n    return multidict_module.MultiDictProxy\n\n\n@pytest.fixture(scope=\"session\")\ndef case_insensitive_multidict_proxy_class(\n    multidict_module: ModuleType,\n) -> Type[MutableMultiMapping[str]]:\n    \"\"\"Return a case-insensitive immutable multidict class.\"\"\"\n    return multidict_module.CIMultiDictProxy\n\n\n@pytest.fixture(scope=\"session\")\ndef multidict_getversion_callable(multidict_module: ModuleType) -> Callable:\n    \"\"\"Return a ``getversion()`` function for current implementation.\"\"\"\n    return multidict_module.getversion\n\n\ndef pytest_addoption(\n    parser: pytest.Parser,\n    pluginmanager: pytest.PytestPluginManager,\n) -> None:\n    \"\"\"Define a new ``--c-extensions`` flag.\n\n    This lets the callers deselect tests executed against the C-extension\n    version of the ``multidict`` implementation.\n    \"\"\"\n    del pluginmanager\n\n    parser.addoption(\n        \"--c-extensions\",  # disabled with `--no-c-extensions`\n        action=\"store_true\" if PY_38_AND_BELOW else argparse.BooleanOptionalAction,\n        default=True,\n        dest=\"c_extensions\",\n        help=\"Test C-extensions (on by default)\",\n    )\n\n    if PY_38_AND_BELOW:\n        parser.addoption(\n            \"--no-c-extensions\",\n            action=\"store_false\",\n            dest=\"c_extensions\",\n            help=\"Skip testing C-extensions (on by default)\",\n        )\n\n\ndef pytest_collection_modifyitems(\n    session: pytest.Session,\n    config: pytest.Config,\n    items: list[pytest.Item],\n) -> None:\n    \"\"\"Deselect tests against C-extensions when requested via CLI.\"\"\"\n    test_c_extensions = config.getoption(\"--c-extensions\") is True\n\n    if test_c_extensions:\n        return\n\n    selected_tests = []\n    deselected_tests = []\n\n    for item in items:\n        c_ext = item.get_closest_marker(C_EXT_MARK.name) is not None\n\n        target_items_list = deselected_tests if c_ext else selected_tests\n        target_items_list.append(item)\n\n    config.hook.pytest_deselected(items=deselected_tests)\n    items[:] = selected_tests\n\n\ndef pytest_configure(config: pytest.Config) -> None:\n    \"\"\"Declare the C-extension marker in config.\"\"\"\n    config.addinivalue_line(\n        \"markers\",\n        f\"{C_EXT_MARK.name}: tests running against the C-extension implementation.\",\n    )\n\n\ndef pytest_generate_tests(metafunc):\n    if \"pickle_protocol\" in metafunc.fixturenames:\n        metafunc.parametrize(\n            \"pickle_protocol\", list(range(pickle.HIGHEST_PROTOCOL + 1)), scope=\"session\"\n        )\n", "tests/test_mutable_multidict.py": "import string\nimport sys\nfrom typing import Type\n\nimport pytest\n\nfrom multidict import MultiMapping, MutableMultiMapping\n\n\nclass TestMutableMultiDict:\n    def test_copy(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d1 = case_sensitive_multidict_class(key=\"value\", a=\"b\")\n\n        d2 = d1.copy()\n        assert d1 == d2\n        assert d1 is not d2\n\n    def test__repr__(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        assert str(d) == \"<%s()>\" % case_sensitive_multidict_class.__name__\n\n        d = case_sensitive_multidict_class([(\"key\", \"one\"), (\"key\", \"two\")])\n\n        expected = (\n            f\"<{case_sensitive_multidict_class.__name__}\"\n            \"('key': 'one', 'key': 'two')>\"\n        )\n        assert str(d) == expected\n\n    def test_getall(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class([(\"key\", \"value1\")], key=\"value2\")\n        assert len(d) == 2\n\n        assert d.getall(\"key\") == [\"value1\", \"value2\"]\n\n        with pytest.raises(KeyError, match=\"some_key\"):\n            d.getall(\"some_key\")\n\n        default = object()\n        assert d.getall(\"some_key\", default) is default\n\n    def test_add(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n\n        assert d == {}\n        d[\"key\"] = \"one\"\n        assert d == {\"key\": \"one\"}\n        assert d.getall(\"key\") == [\"one\"]\n\n        d[\"key\"] = \"two\"\n        assert d == {\"key\": \"two\"}\n        assert d.getall(\"key\") == [\"two\"]\n\n        d.add(\"key\", \"one\")\n        assert 2 == len(d)\n        assert d.getall(\"key\") == [\"two\", \"one\"]\n\n        d.add(\"foo\", \"bar\")\n        assert 3 == len(d)\n        assert d.getall(\"foo\") == [\"bar\"]\n\n    def test_extend(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        assert d == {}\n\n        d.extend([(\"key\", \"one\"), (\"key\", \"two\")], key=3, foo=\"bar\")\n        assert d != {\"key\": \"one\", \"foo\": \"bar\"}\n        assert 4 == len(d)\n        itms = d.items()\n        # we can't guarantee order of kwargs\n        assert (\"key\", \"one\") in itms\n        assert (\"key\", \"two\") in itms\n        assert (\"key\", 3) in itms\n        assert (\"foo\", \"bar\") in itms\n\n        other = case_sensitive_multidict_class(bar=\"baz\")\n        assert other == {\"bar\": \"baz\"}\n\n        d.extend(other)\n        assert (\"bar\", \"baz\") in d.items()\n\n        d.extend({\"foo\": \"moo\"})\n        assert (\"foo\", \"moo\") in d.items()\n\n        d.extend()\n        assert 6 == len(d)\n\n        with pytest.raises(TypeError):\n            d.extend(\"foo\", \"bar\")\n\n    def test_extend_from_proxy(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_sensitive_multidict_proxy_class: Type[MultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class([(\"a\", \"a\"), (\"b\", \"b\")])\n        proxy = case_sensitive_multidict_proxy_class(d)\n\n        d2 = case_sensitive_multidict_class()\n        d2.extend(proxy)\n\n        assert [(\"a\", \"a\"), (\"b\", \"b\")] == list(d2.items())\n\n    def test_clear(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class([(\"key\", \"one\")], key=\"two\", foo=\"bar\")\n\n        d.clear()\n        assert d == {}\n        assert list(d.items()) == []\n\n    def test_del(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class([(\"key\", \"one\"), (\"key\", \"two\")], foo=\"bar\")\n        assert list(d.keys()) == [\"key\", \"key\", \"foo\"]\n\n        del d[\"key\"]\n        assert d == {\"foo\": \"bar\"}\n        assert list(d.items()) == [(\"foo\", \"bar\")]\n\n        with pytest.raises(KeyError, match=\"key\"):\n            del d[\"key\"]\n\n    def test_set_default(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class([(\"key\", \"one\"), (\"key\", \"two\")], foo=\"bar\")\n        assert \"one\" == d.setdefault(\"key\", \"three\")\n        assert \"three\" == d.setdefault(\"otherkey\", \"three\")\n        assert \"otherkey\" in d\n        assert \"three\" == d[\"otherkey\"]\n\n    def test_popitem(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(\"key\", \"val1\")\n        d.add(\"key\", \"val2\")\n\n        assert (\"key\", \"val1\") == d.popitem()\n        assert [(\"key\", \"val2\")] == list(d.items())\n\n    def test_popitem_empty_multidict(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n\n        with pytest.raises(KeyError):\n            d.popitem()\n\n    def test_pop(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(\"key\", \"val1\")\n        d.add(\"key\", \"val2\")\n\n        assert \"val1\" == d.pop(\"key\")\n        assert {\"key\": \"val2\"} == d\n\n    def test_pop2(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(\"key\", \"val1\")\n        d.add(\"key2\", \"val2\")\n        d.add(\"key\", \"val3\")\n\n        assert \"val1\" == d.pop(\"key\")\n        assert [(\"key2\", \"val2\"), (\"key\", \"val3\")] == list(d.items())\n\n    def test_pop_default(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class(other=\"val\")\n\n        assert \"default\" == d.pop(\"key\", \"default\")\n        assert \"other\" in d\n\n    def test_pop_raises(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class(other=\"val\")\n\n        with pytest.raises(KeyError, match=\"key\"):\n            d.pop(\"key\")\n\n        assert \"other\" in d\n\n    def test_replacement_order(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(\"key1\", \"val1\")\n        d.add(\"key2\", \"val2\")\n        d.add(\"key1\", \"val3\")\n        d.add(\"key2\", \"val4\")\n\n        d[\"key1\"] = \"val\"\n\n        expected = [(\"key1\", \"val\"), (\"key2\", \"val2\"), (\"key2\", \"val4\")]\n\n        assert expected == list(d.items())\n\n    def test_nonstr_key(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        with pytest.raises(TypeError):\n            d[1] = \"val\"\n\n    def test_istr_key(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_insensitive_str_class: Type[str],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d[case_insensitive_str_class(\"1\")] = \"val\"\n        assert type(list(d.keys())[0]) is case_insensitive_str_class\n\n    def test_str_derived_key(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        class A(str):\n            pass\n\n        d = case_sensitive_multidict_class()\n        d[A(\"1\")] = \"val\"\n        assert type(list(d.keys())[0]) is A\n\n    def test_istr_key_add(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_insensitive_str_class: Type[str],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(case_insensitive_str_class(\"1\"), \"val\")\n        assert type(list(d.keys())[0]) is case_insensitive_str_class\n\n    def test_str_derived_key_add(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        class A(str):\n            pass\n\n        d = case_sensitive_multidict_class()\n        d.add(A(\"1\"), \"val\")\n        assert type(list(d.keys())[0]) is A\n\n    def test_popall(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        d.add(\"key1\", \"val1\")\n        d.add(\"key2\", \"val2\")\n        d.add(\"key1\", \"val3\")\n        ret = d.popall(\"key1\")\n        assert [\"val1\", \"val3\"] == ret\n        assert {\"key2\": \"val2\"} == d\n\n    def test_popall_default(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        assert \"val\" == d.popall(\"key\", \"val\")\n\n    def test_popall_key_error(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_sensitive_multidict_class()\n        with pytest.raises(KeyError, match=\"key\"):\n            d.popall(\"key\")\n\n    def test_large_multidict_resizing(\n        self,\n        case_sensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        SIZE = 1024\n        d = case_sensitive_multidict_class()\n        for i in range(SIZE):\n            d[\"key\" + str(i)] = i\n\n        for i in range(SIZE - 1):\n            del d[\"key\" + str(i)]\n\n        assert {\"key\" + str(SIZE - 1): SIZE - 1} == d\n\n\nclass TestCIMutableMultiDict:\n    def test_getall(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class([(\"KEY\", \"value1\")], KEY=\"value2\")\n\n        assert d != {\"KEY\": \"value1\"}\n        assert len(d) == 2\n\n        assert d.getall(\"key\") == [\"value1\", \"value2\"]\n\n        with pytest.raises(KeyError, match=\"some_key\"):\n            d.getall(\"some_key\")\n\n    def test_ctor(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class(k1=\"v1\")\n        assert \"v1\" == d[\"K1\"]\n        assert (\"k1\", \"v1\") in d.items()\n\n    def test_setitem(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        d[\"k1\"] = \"v1\"\n        assert \"v1\" == d[\"K1\"]\n        assert (\"k1\", \"v1\") in d.items()\n\n    def test_delitem(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        d[\"k1\"] = \"v1\"\n        assert \"K1\" in d\n        del d[\"k1\"]\n        assert \"K1\" not in d\n\n    def test_copy(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d1 = case_insensitive_multidict_class(key=\"KEY\", a=\"b\")\n\n        d2 = d1.copy()\n        assert d1 == d2\n        assert d1.items() == d2.items()\n        assert d1 is not d2\n\n    def test__repr__(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        assert str(d) == \"<%s()>\" % case_insensitive_multidict_class.__name__\n\n        d = case_insensitive_multidict_class([(\"KEY\", \"one\"), (\"KEY\", \"two\")])\n\n        expected = (\n            f\"<{case_insensitive_multidict_class.__name__}\"\n            \"('KEY': 'one', 'KEY': 'two')>\"\n        )\n        assert str(d) == expected\n\n    def test_add(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n\n        assert d == {}\n        d[\"KEY\"] = \"one\"\n        assert (\"KEY\", \"one\") in d.items()\n        assert d == case_insensitive_multidict_class({\"Key\": \"one\"})\n        assert d.getall(\"key\") == [\"one\"]\n\n        d[\"KEY\"] = \"two\"\n        assert (\"KEY\", \"two\") in d.items()\n        assert d == case_insensitive_multidict_class({\"Key\": \"two\"})\n        assert d.getall(\"key\") == [\"two\"]\n\n        d.add(\"KEY\", \"one\")\n        assert (\"KEY\", \"one\") in d.items()\n        assert 2 == len(d)\n        assert d.getall(\"key\") == [\"two\", \"one\"]\n\n        d.add(\"FOO\", \"bar\")\n        assert (\"FOO\", \"bar\") in d.items()\n        assert 3 == len(d)\n        assert d.getall(\"foo\") == [\"bar\"]\n\n        d.add(key=\"test\", value=\"test\")\n        assert (\"test\", \"test\") in d.items()\n        assert 4 == len(d)\n        assert d.getall(\"test\") == [\"test\"]\n\n    def test_extend(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        assert d == {}\n\n        d.extend([(\"KEY\", \"one\"), (\"key\", \"two\")], key=3, foo=\"bar\")\n        assert 4 == len(d)\n        itms = d.items()\n        # we can't guarantee order of kwargs\n        assert (\"KEY\", \"one\") in itms\n        assert (\"key\", \"two\") in itms\n        assert (\"key\", 3) in itms\n        assert (\"foo\", \"bar\") in itms\n\n        other = case_insensitive_multidict_class(Bar=\"baz\")\n        assert other == {\"Bar\": \"baz\"}\n\n        d.extend(other)\n        assert (\"Bar\", \"baz\") in d.items()\n        assert \"bar\" in d\n\n        d.extend({\"Foo\": \"moo\"})\n        assert (\"Foo\", \"moo\") in d.items()\n        assert \"foo\" in d\n\n        d.extend()\n        assert 6 == len(d)\n\n        with pytest.raises(TypeError):\n            d.extend(\"foo\", \"bar\")\n\n    def test_extend_from_proxy(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_insensitive_multidict_proxy_class: Type[MultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class([(\"a\", \"a\"), (\"b\", \"b\")])\n        proxy = case_insensitive_multidict_proxy_class(d)\n\n        d2 = case_insensitive_multidict_class()\n        d2.extend(proxy)\n\n        assert [(\"a\", \"a\"), (\"b\", \"b\")] == list(d2.items())\n\n    def test_clear(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class([(\"KEY\", \"one\")], key=\"two\", foo=\"bar\")\n\n        d.clear()\n        assert d == {}\n        assert list(d.items()) == []\n\n    def test_del(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class(\n            [(\"KEY\", \"one\"), (\"key\", \"two\")],\n            foo=\"bar\",\n        )\n\n        del d[\"key\"]\n        assert d == {\"foo\": \"bar\"}\n        assert list(d.items()) == [(\"foo\", \"bar\")]\n\n        with pytest.raises(KeyError, match=\"key\"):\n            del d[\"key\"]\n\n    def test_set_default(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class(\n            [(\"KEY\", \"one\"), (\"key\", \"two\")],\n            foo=\"bar\",\n        )\n        assert \"one\" == d.setdefault(\"key\", \"three\")\n        assert \"three\" == d.setdefault(\"otherkey\", \"three\")\n        assert \"otherkey\" in d\n        assert (\"otherkey\", \"three\") in d.items()\n        assert \"three\" == d[\"OTHERKEY\"]\n\n    def test_popitem(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        d.add(\"KEY\", \"val1\")\n        d.add(\"key\", \"val2\")\n\n        pair = d.popitem()\n        assert (\"KEY\", \"val1\") == pair\n        assert isinstance(pair[0], str)\n        assert [(\"key\", \"val2\")] == list(d.items())\n\n    def test_popitem_empty_multidict(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n\n        with pytest.raises(KeyError):\n            d.popitem()\n\n    def test_pop(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        d.add(\"KEY\", \"val1\")\n        d.add(\"key\", \"val2\")\n\n        assert \"val1\" == d.pop(\"KEY\")\n        assert {\"key\": \"val2\"} == d\n\n    def test_pop_lowercase(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class()\n        d.add(\"KEY\", \"val1\")\n        d.add(\"key\", \"val2\")\n\n        assert \"val1\" == d.pop(\"key\")\n        assert {\"key\": \"val2\"} == d\n\n    def test_pop_default(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class(OTHER=\"val\")\n\n        assert \"default\" == d.pop(\"key\", \"default\")\n        assert \"other\" in d\n\n    def test_pop_raises(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = case_insensitive_multidict_class(OTHER=\"val\")\n\n        with pytest.raises(KeyError, match=\"KEY\"):\n            d.pop(\"KEY\")\n\n        assert \"other\" in d\n\n    def test_extend_with_istr(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_insensitive_str_class: Type[str],\n    ) -> None:\n        us = case_insensitive_str_class(\"aBc\")\n        d = case_insensitive_multidict_class()\n\n        d.extend([(us, \"val\")])\n        assert [(\"aBc\", \"val\")] == list(d.items())\n\n    def test_copy_istr(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n        case_insensitive_str_class: Type[str],\n    ) -> None:\n        d = case_insensitive_multidict_class({case_insensitive_str_class(\"Foo\"): \"bar\"})\n        d2 = d.copy()\n        assert d == d2\n\n    def test_eq(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d1 = case_insensitive_multidict_class(Key=\"val\")\n        d2 = case_insensitive_multidict_class(KEY=\"val\")\n\n        assert d1 == d2\n\n    @pytest.mark.skipif(\n        sys.implementation.name == \"pypy\",\n        reason=\"getsizeof() is not implemented on PyPy\",\n    )\n    def test_sizeof(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        md = case_insensitive_multidict_class()\n        s1 = sys.getsizeof(md)\n        for i in string.ascii_lowercase:\n            for j in string.ascii_uppercase:\n                md[i + j] = i + j\n        # multidict should be resized\n        s2 = sys.getsizeof(md)\n        assert s2 > s1\n\n    @pytest.mark.skipif(\n        sys.implementation.name == \"pypy\",\n        reason=\"getsizeof() is not implemented on PyPy\",\n    )\n    def test_min_sizeof(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        md = case_insensitive_multidict_class()\n        assert sys.getsizeof(md) < 1024\n\n    def test_issue_620_items(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        # https://github.com/aio-libs/multidict/issues/620\n        d = case_insensitive_multidict_class({\"a\": \"123, 456\", \"b\": \"789\"})\n        before_mutation_items = d.items()\n        d[\"c\"] = \"000\"\n        # This causes an error on pypy.\n        list(before_mutation_items)\n\n    def test_issue_620_keys(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        # https://github.com/aio-libs/multidict/issues/620\n        d = case_insensitive_multidict_class({\"a\": \"123, 456\", \"b\": \"789\"})\n        before_mutation_keys = d.keys()\n        d[\"c\"] = \"000\"\n        # This causes an error on pypy.\n        list(before_mutation_keys)\n\n    def test_issue_620_values(\n        self,\n        case_insensitive_multidict_class: Type[MutableMultiMapping[str]],\n    ) -> None:\n        # https://github.com/aio-libs/multidict/issues/620\n        d = case_insensitive_multidict_class({\"a\": \"123, 456\", \"b\": \"789\"})\n        before_mutation_values = d.values()\n        d[\"c\"] = \"000\"\n        # This causes an error on pypy.\n        list(before_mutation_values)\n", "tests/test_multidict.py": "from __future__ import annotations\n\nimport gc\nimport operator\nimport sys\nimport weakref\nfrom collections import deque\nfrom collections.abc import Mapping\nfrom types import ModuleType\nfrom typing import (\n    Callable,\n    Dict,\n    Iterable,\n    Iterator,\n    KeysView,\n    List,\n    Mapping,\n    Set,\n    Tuple,\n    Type,\n    Union,\n    cast,\n)\n\nimport pytest\n\nimport multidict\nfrom multidict import CIMultiDict, MultiDict, MultiMapping, MutableMultiMapping\n\n\ndef chained_callable(\n    module: ModuleType,\n    callables: Iterable[str],\n) -> Callable[..., MultiMapping[int | str] | MutableMultiMapping[int | str]]:\n    \"\"\"\n    Return callable that will get and call all given objects in module in\n    exact order.\n    \"\"\"\n\n    def chained_call(\n        *args: object,\n        **kwargs: object,\n    ) -> MultiMapping[int | str] | MutableMultiMapping[int | str]:\n        nonlocal callables\n\n        callable_chain = (getattr(module, name) for name in callables)\n        first_callable = next(callable_chain)\n\n        value = first_callable(*args, **kwargs)\n        for element in callable_chain:\n            value = element(value)\n\n        return cast(\n            Union[\n                MultiMapping[Union[int, str]],\n                MutableMultiMapping[Union[int, str]],\n            ],\n            value,\n        )\n\n    return chained_call\n\n\n@pytest.fixture\ndef cls(  # type: ignore[misc]\n    request: pytest.FixtureRequest,\n    multidict_module: ModuleType,\n) -> Callable[..., MultiMapping[int | str] | MutableMultiMapping[int | str]]:\n    \"\"\"Make a callable from multidict module, requested by name.\"\"\"\n    return chained_callable(multidict_module, request.param)\n\n\ndef test_exposed_names(any_multidict_class_name: str) -> None:\n    assert any_multidict_class_name in multidict.__all__  # type: ignore[attr-defined]\n\n\n@pytest.mark.parametrize(\n    (\"cls\", \"key_cls\"),\n    (\n        ((\"MultiDict\",), str),\n        (\n            (\"MultiDict\", \"MultiDictProxy\"),\n            str,\n        ),\n    ),\n    indirect=[\"cls\"],\n)\ndef test__iter__types(\n    cls: Type[MultiDict[Union[str, int]]],\n    key_cls: Type[object],\n) -> None:\n    d = cls([(\"key\", \"one\"), (\"key2\", \"two\"), (\"key\", 3)])\n    for i in d:\n        assert type(i) is key_cls, (type(i), key_cls)\n\n\ndef test_proxy_copy(\n    any_multidict_class: Type[MutableMultiMapping[str]],\n    any_multidict_proxy_class: Type[MultiMapping[str]],\n) -> None:\n    d1 = any_multidict_class(key=\"value\", a=\"b\")\n    p1 = any_multidict_proxy_class(d1)\n\n    d2 = p1.copy()  # type: ignore[attr-defined]\n    assert d1 == d2\n    assert d1 is not d2\n\n\ndef test_multidict_subclassing(\n    any_multidict_class: Type[MutableMultiMapping[str]],\n) -> None:\n    class DummyMultidict(any_multidict_class):  # type: ignore[valid-type,misc]\n        pass\n\n\ndef test_multidict_proxy_subclassing(\n    any_multidict_proxy_class: Type[MultiMapping[str]],\n) -> None:\n    class DummyMultidictProxy(\n        any_multidict_proxy_class,  # type: ignore[valid-type,misc]\n    ):\n        pass\n\n\nclass BaseMultiDictTest:\n    def test_instantiate__empty(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls()\n        empty: Mapping[str, str] = {}\n        assert d == empty\n        assert len(d) == 0\n        assert list(d.keys()) == []\n        assert list(d.values()) == []\n        assert list(d.items()) == []\n\n        assert cls() != list()  # type: ignore[comparison-overlap]\n        with pytest.raises(TypeError, match=r\"(2 given)\"):\n            cls((\"key1\", \"value1\"), (\"key2\", \"value2\"))  # type: ignore[call-arg]  # noqa: E501\n\n    @pytest.mark.parametrize(\"arg0\", ([(\"key\", \"value1\")], {\"key\": \"value1\"}))\n    def test_instantiate__from_arg0(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n        arg0: Union[List[Tuple[str, str]], Dict[str, str]],\n    ) -> None:\n        d = cls(arg0)\n\n        assert d == {\"key\": \"value1\"}\n        assert len(d) == 1\n        assert list(d.keys()) == [\"key\"]\n        assert list(d.values()) == [\"value1\"]\n        assert list(d.items()) == [(\"key\", \"value1\")]\n\n    def test_instantiate__with_kwargs(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d = cls([(\"key\", \"value1\")], key2=\"value2\")\n\n        assert d == {\"key\": \"value1\", \"key2\": \"value2\"}\n        assert len(d) == 2\n        assert sorted(d.keys()) == [\"key\", \"key2\"]\n        assert sorted(d.values()) == [\"value1\", \"value2\"]\n        assert sorted(d.items()) == [(\"key\", \"value1\"), (\"key2\", \"value2\")]\n\n    def test_instantiate__from_generator(\n        self, cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]]\n    ) -> None:\n        d = cls((str(i), i) for i in range(2))\n\n        assert d == {\"0\": 0, \"1\": 1}\n        assert len(d) == 2\n        assert sorted(d.keys()) == [\"0\", \"1\"]\n        assert sorted(d.values()) == [0, 1]\n        assert sorted(d.items()) == [(\"0\", 0), (\"1\", 1)]\n\n    def test_instantiate__from_list_of_lists(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n    ) -> None:\n        # Should work at runtime, but won't type check.\n        d = cls([[\"key\", \"value1\"]])  # type: ignore[call-arg]\n        assert d == {\"key\": \"value1\"}\n\n    def test_instantiate__from_list_of_custom_pairs(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n    ) -> None:\n        class Pair:\n            def __len__(self) -> int:\n                return 2\n\n            def __getitem__(self, pos: int) -> str:\n                return (\"key\", \"value1\")[pos]\n\n        # Works at runtime, but won't type check.\n        d = cls([Pair()])\n        assert d == {\"key\": \"value1\"}\n\n    def test_getone(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")], key=\"value2\")\n\n        assert d.getone(\"key\") == \"value1\"\n        assert d.get(\"key\") == \"value1\"\n        assert d[\"key\"] == \"value1\"\n\n        with pytest.raises(KeyError, match=\"key2\"):\n            d[\"key2\"]\n        with pytest.raises(KeyError, match=\"key2\"):\n            d.getone(\"key2\")\n\n        assert d.getone(\"key2\", \"default\") == \"default\"\n\n    def test_call_with_kwargs(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls([(\"present\", \"value\")])\n        assert d.getall(default=\"missing\", key=\"notfound\") == \"missing\"\n\n    def test__iter__(\n        self,\n        cls: Union[\n            Type[MultiDict[Union[str, int]]],\n            Type[CIMultiDict[Union[str, int]]],\n        ],\n    ) -> None:\n        d = cls([(\"key\", \"one\"), (\"key2\", \"two\"), (\"key\", 3)])\n        assert list(d) == [\"key\", \"key2\", \"key\"]\n\n    def test_keys__contains(\n        self,\n        cls: Union[\n            Type[MultiDict[Union[str, int]]],\n            Type[CIMultiDict[Union[str, int]]],\n        ],\n    ) -> None:\n        d = cls([(\"key\", \"one\"), (\"key2\", \"two\"), (\"key\", 3)])\n\n        assert list(d.keys()) == [\"key\", \"key2\", \"key\"]\n\n        assert \"key\" in d.keys()\n        assert \"key2\" in d.keys()\n\n        assert \"foo\" not in d.keys()\n\n    def test_values__contains(\n        self,\n        cls: Union[\n            Type[MultiDict[Union[str, int]]],\n            Type[CIMultiDict[Union[str, int]]],\n        ],\n    ) -> None:\n        d = cls([(\"key\", \"one\"), (\"key\", \"two\"), (\"key\", 3)])\n\n        assert list(d.values()) == [\"one\", \"two\", 3]\n\n        assert \"one\" in d.values()\n        assert \"two\" in d.values()\n        assert 3 in d.values()\n\n        assert \"foo\" not in d.values()\n\n    def test_items__contains(\n        self,\n        cls: Union[\n            Type[MultiDict[Union[str, int]]],\n            Type[CIMultiDict[Union[str, int]]],\n        ],\n    ) -> None:\n        d = cls([(\"key\", \"one\"), (\"key\", \"two\"), (\"key\", 3)])\n\n        assert list(d.items()) == [(\"key\", \"one\"), (\"key\", \"two\"), (\"key\", 3)]\n\n        assert (\"key\", \"one\") in d.items()\n        assert (\"key\", \"two\") in d.items()\n        assert (\"key\", 3) in d.items()\n\n        assert (\"foo\", \"bar\") not in d.items()\n\n    def test_cannot_create_from_unaccepted(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n    ) -> None:\n        with pytest.raises(TypeError):\n            cls([(1, 2, 3)])  # type: ignore[call-arg]\n\n    def test_keys_is_set_less(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert d.keys() < {\"key\", \"key2\"}\n\n    @pytest.mark.parametrize(\n        (\"contents\", \"expected\"),\n        (\n            ([(\"key\", \"value1\")], True),\n            ([(\"key\", \"value1\"), (\"key2\", \"value2\")], True),\n            ([(\"key\", \"value1\"), (\"key2\", \"value2\"), (\"key3\", \"value3\")], False),\n            ([(\"key\", \"value1\"), (\"key3\", \"value3\")], False),\n        ),\n    )\n    def test_keys_is_set_less_equal(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n        contents: List[Tuple[str, str]],\n        expected: bool,\n    ) -> None:\n        d = cls(contents)\n\n        result = d.keys() <= {\"key\", \"key2\"}\n        assert result is expected\n\n    def test_keys_is_set_equal(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert d.keys() == {\"key\"}\n\n    def test_keys_is_set_greater(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert d.keys() > {\"key\"}\n\n    @pytest.mark.parametrize(\n        (\"set_\", \"expected\"),\n        (\n            ({\"key\"}, True),\n            ({\"key\", \"key2\"}, True),\n            ({\"key\", \"key2\", \"key3\"}, False),\n            ({\"key3\"}, False),\n        ),\n    )\n    def test_keys_is_set_greater_equal(\n        self, cls: Type[MutableMultiMapping[str]], set_: Set[str], expected: bool\n    ) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        result = d.keys() >= set_\n        assert result is expected\n\n    def test_keys_less_than_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __gt__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert (d.keys() < RightOperand()) is sentinel_operation_result\n\n    def test_keys_less_than_or_equal_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __ge__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert (d.keys() <= RightOperand()) is sentinel_operation_result\n\n    def test_keys_greater_than_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __lt__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert (d.keys() > RightOperand()) is sentinel_operation_result\n\n    def test_keys_greater_than_or_equal_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __le__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert (d.keys() >= RightOperand()) is sentinel_operation_result\n\n    def test_keys_is_set_not_equal(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert d.keys() != {\"key2\"}\n\n    def test_keys_not_equal_unrelated_type(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert d.keys() != \"other\"\n\n    def test_eq(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\": \"value1\"} == d\n\n    def test_eq2(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d1 = cls([(\"key\", \"value1\")])\n        d2 = cls([(\"key2\", \"value1\")])\n\n        assert d1 != d2\n\n    def test_eq3(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d1 = cls([(\"key\", \"value1\")])\n        d2 = cls()\n\n        assert d1 != d2\n\n    def test_eq_other_mapping_contains_more_keys(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n    ) -> None:\n        d1 = cls(foo=\"bar\")\n        d2 = dict(foo=\"bar\", bar=\"baz\")\n\n        assert d1 != d2\n\n    def test_eq_bad_mapping_len(\n        self, cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]]\n    ) -> None:\n        class BadMapping(Mapping[str, int]):\n            def __getitem__(self, key: str) -> int:\n                return 1  # pragma: no cover  # `len()` fails earlier\n\n            def __iter__(self) -> Iterator[str]:\n                yield \"a\"  # pragma: no cover  # `len()` fails earlier\n\n            def __len__(self) -> int:  # type: ignore[return]\n                1 / 0\n\n        d1 = cls(a=1)\n        d2 = BadMapping()\n        with pytest.raises(ZeroDivisionError):\n            d1 == d2\n\n    def test_eq_bad_mapping_getitem(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        class BadMapping(Mapping[str, int]):\n            def __getitem__(self, key: str) -> int:  # type: ignore[return]\n                1 / 0\n\n            def __iter__(self) -> Iterator[str]:\n                yield \"a\"  # pragma: no cover  # foreign objects no iterated\n\n            def __len__(self) -> int:\n                return 1\n\n        d1 = cls(a=1)\n        d2 = BadMapping()\n        with pytest.raises(ZeroDivisionError):\n            d1 == d2\n\n    def test_ne(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert d != {\"key\": \"another_value\"}\n\n    def test_and(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\"} == d.keys() & {\"key\", \"key2\"}\n\n    def test_and2(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\"} == {\"key\", \"key2\"} & d.keys()\n\n    def test_bitwise_and_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __rand__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert d.keys() & RightOperand() is sentinel_operation_result\n\n    def test_bitwise_and_iterable_not_set(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\"} == d.keys() & [\"key\", \"key2\"]\n\n    def test_or(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\", \"key2\"} == d.keys() | {\"key2\"}\n\n    def test_or2(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\", \"key2\"} == {\"key2\"} | d.keys()\n\n    def test_bitwise_or_not_implemented(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __ror__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert d.keys() | RightOperand() is sentinel_operation_result\n\n    def test_bitwise_or_iterable_not_set(\n        self, cls: Type[MutableMultiMapping[str]]\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n\n        assert {\"key\", \"key2\"} == d.keys() | [\"key2\"]\n\n    def test_sub(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key\"} == d.keys() - {\"key2\"}\n\n    def test_sub2(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key3\"} == {\"key\", \"key2\", \"key3\"} - d.keys()\n\n    def test_sub_not_implemented(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __rsub__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert d.keys() - RightOperand() is sentinel_operation_result\n\n    def test_sub_iterable_not_set(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key\"} == d.keys() - [\"key2\"]\n\n    def test_xor(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key\", \"key3\"} == d.keys() ^ {\"key2\", \"key3\"}\n\n    def test_xor2(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key\", \"key3\"} == {\"key2\", \"key3\"} ^ d.keys()\n\n    def test_xor_not_implemented(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        sentinel_operation_result = object()\n\n        class RightOperand:\n            def __rxor__(self, other: KeysView[str]) -> object:\n                assert isinstance(other, KeysView)\n                return sentinel_operation_result\n\n        assert d.keys() ^ RightOperand() is sentinel_operation_result\n\n    def test_xor_iterable_not_set(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls([(\"key\", \"value1\"), (\"key2\", \"value2\")])\n\n        assert {\"key\", \"key3\"} == d.keys() ^ [\"key2\", \"key3\"]\n\n    @pytest.mark.parametrize(\n        (\"key\", \"value\", \"expected\"),\n        ((\"key2\", \"v\", True), (\"key\", \"value1\", False)),\n    )\n    def test_isdisjoint(\n        self, cls: Type[MutableMultiMapping[str]], key: str, value: str, expected: bool\n    ) -> None:\n        d = cls([(\"key\", \"value1\")])\n        assert d.items().isdisjoint({(key, value)}) is expected\n        assert d.keys().isdisjoint({key}) is expected\n\n    def test_repr_aiohttp_issue_410(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        d = cls()\n\n        try:\n            raise Exception\n            pytest.fail(\"Should never happen\")  # pragma: no cover\n        except Exception as e:\n            repr(d)\n\n            assert sys.exc_info()[1] == e  # noqa: PT017\n\n    @pytest.mark.parametrize(\n        \"op\",\n        (operator.or_, operator.and_, operator.sub, operator.xor),\n    )\n    @pytest.mark.parametrize(\"other\", ({\"other\"},))\n    def test_op_issue_aiohttp_issue_410(\n        self,\n        cls: Type[MutableMultiMapping[str]],\n        op: Callable[[object, object], object],\n        other: Set[str],\n    ) -> None:\n        d = cls([(\"key\", \"value\")])\n\n        try:\n            raise Exception\n            pytest.fail(\"Should never happen\")  # pragma: no cover\n        except Exception as e:\n            op(d.keys(), other)\n\n            assert sys.exc_info()[1] == e  # noqa: PT017\n\n    def test_weakref(self, cls: Type[MutableMultiMapping[str]]) -> None:\n        called = False\n\n        def cb(wr: object) -> None:\n            nonlocal called\n            called = True\n\n        d = cls()\n        wr = weakref.ref(d, cb)\n        del d\n        gc.collect()\n        assert called\n        del wr\n\n    def test_iter_length_hint_keys(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        md = cls(a=1, b=2)\n        it = iter(md.keys())\n        assert it.__length_hint__() == 2  # type: ignore[attr-defined]\n\n    def test_iter_length_hint_items(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        md = cls(a=1, b=2)\n        it = iter(md.items())\n        assert it.__length_hint__() == 2  # type: ignore[attr-defined]\n\n    def test_iter_length_hint_values(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        md = cls(a=1, b=2)\n        it = iter(md.values())\n        assert it.__length_hint__() == 2  # type: ignore[attr-defined]\n\n    def test_ctor_list_arg_and_kwds(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        arg = [(\"a\", 1)]\n        obj = cls(arg, b=2)\n        assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n        assert arg == [(\"a\", 1)]\n\n    def test_ctor_tuple_arg_and_kwds(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        arg = ((\"a\", 1),)\n        obj = cls(arg, b=2)\n        assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n        assert arg == ((\"a\", 1),)\n\n    def test_ctor_deque_arg_and_kwds(\n        self,\n        cls: Union[Type[MultiDict[int]], Type[CIMultiDict[int]]],\n    ) -> None:\n        arg = deque([(\"a\", 1)])\n        obj = cls(arg, b=2)\n        assert list(obj.items()) == [(\"a\", 1), (\"b\", 2)]\n        assert arg == deque([(\"a\", 1)])\n\n\nclass TestMultiDict(BaseMultiDictTest):\n    @pytest.fixture(\n        params=[\n            (\"MultiDict\",),\n            (\"MultiDict\", \"MultiDictProxy\"),\n        ],\n    )\n    def cls(  # type: ignore[misc]\n        self,\n        request: pytest.FixtureRequest,\n        multidict_module: ModuleType,\n    ) -> Callable[..., MultiMapping[int | str] | MutableMultiMapping[int | str]]:\n        \"\"\"Make a case-sensitive multidict class/proxy constructor.\"\"\"\n        return chained_callable(multidict_module, request.param)\n\n    def test__repr__(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls()\n        _cls = type(d)\n\n        assert str(d) == \"<%s()>\" % _cls.__name__\n\n        d = cls([(\"key\", \"one\"), (\"key\", \"two\")])\n\n        assert str(d) == \"<%s('key': 'one', 'key': 'two')>\" % _cls.__name__\n\n    def test_getall(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls([(\"key\", \"value1\")], key=\"value2\")\n\n        assert d != {\"key\": \"value1\"}\n        assert len(d) == 2\n\n        assert d.getall(\"key\") == [\"value1\", \"value2\"]\n\n        with pytest.raises(KeyError, match=\"some_key\"):\n            d.getall(\"some_key\")\n\n        default = object()\n        assert d.getall(\"some_key\", default) is default\n\n    def test_preserve_stable_ordering(\n        self,\n        cls: Type[MultiDict[Union[str, int]]],\n    ) -> None:\n        d = cls([(\"a\", 1), (\"b\", \"2\"), (\"a\", 3)])\n        s = \"&\".join(\"{}={}\".format(k, v) for k, v in d.items())\n\n        assert s == \"a=1&b=2&a=3\"\n\n    def test_get(self, cls: Type[MultiDict[int]]) -> None:\n        d = cls([(\"a\", 1), (\"a\", 2)])\n        assert d[\"a\"] == 1\n\n    def test_items__repr__(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls([(\"key\", \"value1\")], key=\"value2\")\n        expected = \"_ItemsView('key': 'value1', 'key': 'value2')\"\n        assert repr(d.items()) == expected\n\n    def test_keys__repr__(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls([(\"key\", \"value1\")], key=\"value2\")\n        assert repr(d.keys()) == \"_KeysView('key', 'key')\"\n\n    def test_values__repr__(self, cls: Type[MultiDict[str]]) -> None:\n        d = cls([(\"key\", \"value1\")], key=\"value2\")\n        assert repr(d.values()) == \"_ValuesView('value1', 'value2')\"\n\n\nclass TestCIMultiDict(BaseMultiDictTest):\n    @pytest.fixture(\n        params=[\n            (\"CIMultiDict\",),\n            (\"CIMultiDict\", \"CIMultiDictProxy\"),\n        ],\n    )\n    def cls(  # type: ignore[misc]\n        self,\n        request: pytest.FixtureRequest,\n        multidict_module: ModuleType,\n    ) -> Callable[..., MultiMapping[int | str] | MutableMultiMapping[int | str]]:\n        \"\"\"Make a case-insensitive multidict class/proxy constructor.\"\"\"\n        return chained_callable(multidict_module, request.param)\n\n    def test_basics(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], KEY=\"value2\")\n\n        assert d.getone(\"key\") == \"value1\"\n        assert d.get(\"key\") == \"value1\"\n        assert d.get(\"key2\", \"val\") == \"val\"\n        assert d[\"key\"] == \"value1\"\n        assert \"key\" in d\n\n        with pytest.raises(KeyError, match=\"key2\"):\n            d[\"key2\"]\n        with pytest.raises(KeyError, match=\"key2\"):\n            d.getone(\"key2\")\n\n    def test_getall(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], KEY=\"value2\")\n\n        assert not d == {\"KEY\": \"value1\"}\n        assert len(d) == 2\n\n        assert d.getall(\"key\") == [\"value1\", \"value2\"]\n\n        with pytest.raises(KeyError, match=\"some_key\"):\n            d.getall(\"some_key\")\n\n    def test_get(self, cls: Type[CIMultiDict[int]]) -> None:\n        d = cls([(\"A\", 1), (\"a\", 2)])\n        assert 1 == d[\"a\"]\n\n    def test__repr__(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], key=\"value2\")\n        _cls = type(d)\n\n        expected = \"<%s('KEY': 'value1', 'key': 'value2')>\" % _cls.__name__\n        assert str(d) == expected\n\n    def test_items__repr__(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], key=\"value2\")\n        expected = \"_ItemsView('KEY': 'value1', 'key': 'value2')\"\n        assert repr(d.items()) == expected\n\n    def test_keys__repr__(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], key=\"value2\")\n        assert repr(d.keys()) == \"_KeysView('KEY', 'key')\"\n\n    def test_values__repr__(self, cls: Type[CIMultiDict[str]]) -> None:\n        d = cls([(\"KEY\", \"value1\")], key=\"value2\")\n        assert repr(d.values()) == \"_ValuesView('value1', 'value2')\"\n", "tests/test_istr.py": "import gc\nimport sys\nfrom typing import Callable, Type\n\nimport pytest\n\nIMPLEMENTATION = getattr(sys, \"implementation\")  # to suppress mypy error\n\n\ndef test_ctor(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class()\n    assert \"\" == s\n\n\ndef test_ctor_str(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class(\"aBcD\")\n    assert \"aBcD\" == s\n\n\ndef test_ctor_istr(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class(\"A\")\n    s2 = case_insensitive_str_class(s)\n    assert \"A\" == s\n    assert s == s2\n\n\ndef test_ctor_buffer(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class(b\"aBc\")\n    assert \"b'aBc'\" == s\n\n\ndef test_ctor_repr(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class(None)\n    assert \"None\" == s\n\n\ndef test_str(case_insensitive_str_class: Type[str]) -> None:\n    s = case_insensitive_str_class(\"aBcD\")\n    s1 = str(s)\n    assert s1 == \"aBcD\"\n    assert type(s1) is str\n\n\ndef test_eq(case_insensitive_str_class: Type[str]) -> None:\n    s1 = \"Abc\"\n    s2 = case_insensitive_str_class(s1)\n    assert s1 == s2\n\n\n@pytest.fixture\ndef create_istrs(case_insensitive_str_class: Type[str]) -> Callable[[], None]:\n    \"\"\"Make a callable populating memory with a few ``istr`` objects.\"\"\"\n\n    def _create_strs() -> None:\n        case_insensitive_str_class(\"foobarbaz\")\n        istr2 = case_insensitive_str_class()\n        case_insensitive_str_class(istr2)\n\n    return _create_strs\n\n\n@pytest.mark.skipif(\n    IMPLEMENTATION.name != \"cpython\",\n    reason=\"PyPy has different GC implementation\",\n)\ndef test_leak(create_istrs: Callable[[], None]) -> None:\n    gc.collect()\n    cnt = len(gc.get_objects())\n    for _ in range(10000):\n        create_istrs()\n\n    gc.collect()\n    cnt2 = len(gc.get_objects())\n    assert abs(cnt - cnt2) < 10  # on PyPy these numbers are not equal\n", "tests/test_types.py": "import sys\nimport types\n\nimport pytest\n\n\ndef test_proxies(multidict_module):\n    assert issubclass(\n        multidict_module.CIMultiDictProxy,\n        multidict_module.MultiDictProxy,\n    )\n\n\ndef test_dicts(multidict_module):\n    assert issubclass(multidict_module.CIMultiDict, multidict_module.MultiDict)\n\n\ndef test_proxy_not_inherited_from_dict(multidict_module):\n    assert not issubclass(multidict_module.MultiDictProxy, multidict_module.MultiDict)\n\n\ndef test_dict_not_inherited_from_proxy(multidict_module):\n    assert not issubclass(multidict_module.MultiDict, multidict_module.MultiDictProxy)\n\n\ndef test_multidict_proxy_copy_type(multidict_module):\n    d = multidict_module.MultiDict(key=\"val\")\n    p = multidict_module.MultiDictProxy(d)\n    assert isinstance(p.copy(), multidict_module.MultiDict)\n\n\ndef test_cimultidict_proxy_copy_type(multidict_module):\n    d = multidict_module.CIMultiDict(key=\"val\")\n    p = multidict_module.CIMultiDictProxy(d)\n    assert isinstance(p.copy(), multidict_module.CIMultiDict)\n\n\ndef test_create_multidict_proxy_from_nonmultidict(multidict_module):\n    with pytest.raises(TypeError):\n        multidict_module.MultiDictProxy({})\n\n\ndef test_create_multidict_proxy_from_cimultidict(multidict_module):\n    d = multidict_module.CIMultiDict(key=\"val\")\n    p = multidict_module.MultiDictProxy(d)\n    assert p == d\n\n\ndef test_create_multidict_proxy_from_multidict_proxy_from_mdict(multidict_module):\n    d = multidict_module.MultiDict(key=\"val\")\n    p = multidict_module.MultiDictProxy(d)\n    assert p == d\n    p2 = multidict_module.MultiDictProxy(p)\n    assert p2 == p\n\n\ndef test_create_cimultidict_proxy_from_cimultidict_proxy_from_ci(multidict_module):\n    d = multidict_module.CIMultiDict(key=\"val\")\n    p = multidict_module.CIMultiDictProxy(d)\n    assert p == d\n    p2 = multidict_module.CIMultiDictProxy(p)\n    assert p2 == p\n\n\ndef test_create_cimultidict_proxy_from_nonmultidict(multidict_module):\n    with pytest.raises(\n        TypeError,\n        match=(\n            \"ctor requires CIMultiDict or CIMultiDictProxy instance, \"\n            \"not <class 'dict'>\"\n        ),\n    ):\n        multidict_module.CIMultiDictProxy({})\n\n\ndef test_create_ci_multidict_proxy_from_multidict(multidict_module):\n    d = multidict_module.MultiDict(key=\"val\")\n    with pytest.raises(\n        TypeError,\n        match=(\n            \"ctor requires CIMultiDict or CIMultiDictProxy instance, \"\n            \"not <class 'multidict._multidict.*.MultiDict'>\"\n        ),\n    ):\n        multidict_module.CIMultiDictProxy(d)\n\n\n@pytest.mark.skipif(\n    sys.version_info >= (3, 9), reason=\"Python 3.9 uses GenericAlias which is different\"\n)\ndef test_generic_exists(multidict_module) -> None:\n    assert multidict_module.MultiDict[int] is multidict_module.MultiDict\n    assert multidict_module.MultiDictProxy[int] is multidict_module.MultiDictProxy\n    assert multidict_module.CIMultiDict[int] is multidict_module.CIMultiDict\n    assert multidict_module.CIMultiDictProxy[int] is multidict_module.CIMultiDictProxy\n\n\n@pytest.mark.skipif(\n    sys.version_info < (3, 9), reason=\"Python 3.9 is required for GenericAlias\"\n)\ndef test_generic_alias(multidict_module) -> None:\n    assert multidict_module.MultiDict[int] == types.GenericAlias(\n        multidict_module.MultiDict, (int,)\n    )\n    assert multidict_module.MultiDictProxy[int] == types.GenericAlias(\n        multidict_module.MultiDictProxy, (int,)\n    )\n    assert multidict_module.CIMultiDict[int] == types.GenericAlias(\n        multidict_module.CIMultiDict, (int,)\n    )\n    assert multidict_module.CIMultiDictProxy[int] == types.GenericAlias(\n        multidict_module.CIMultiDictProxy, (int,)\n    )\n", "benchmarks/istr.py": "import functools\nimport textwrap\n\nimport perf\n\n\nIMPLEMENTATIONS = {\n    \"c\": \"\"\"\\\n    from multidict._multidict import istr\n    \"\"\",\n    \"python\": \"\"\"\\\n    from multidict._multidict_py import istr\n    \"\"\",\n}\n\nINIT = \"\"\"\\\nval = istr('VaLuE')\n\"\"\"\n\n\nISTR_TO_ISTR = \"\"\"\\\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\n\"\"\"\n\n\ndef benchmark_name(name, ctx, prefix=None, use_prefix=False):\n    if use_prefix:\n        return \"%s%s\" % (prefix % ctx, name)\n\n    return name\n\n\ndef add_impl_option(cmd, args):\n    if args.impl:\n        cmd.extend([\"--impl\", args.impl])\n\n\nif __name__ == \"__main__\":\n    runner = perf.Runner(add_cmdline_args=add_impl_option)\n\n    parser = runner.argparser\n    parser.description = \"Allows to measure performance of \" \"istr implementations\"\n    parser.add_argument(\n        \"--impl\",\n        choices=sorted(IMPLEMENTATIONS),\n        help=\"specific implementation to benchmark\",\n    )\n\n    options = parser.parse_args()\n    implementations = (options.impl,) if options.impl else IMPLEMENTATIONS\n\n    for name in implementations:\n        imports = textwrap.dedent(IMPLEMENTATIONS[name])\n        name = functools.partial(\n            benchmark_name,\n            ctx=dict(impl=name),\n            prefix=\"(impl = %(impl)s) \",\n            use_prefix=len(implementations) > 1,\n        )\n\n        runner.timeit(name(\"istr->istr\"), ISTR_TO_ISTR, imports + INIT, inner_loops=10)\n", "benchmarks/becnhmark.py": "import functools\nimport textwrap\n\nimport pyperf\n\n\nIMPLEMENTATIONS = {\n    \"dict\": \"\"\"\\\n    cls = dict\n    \"\"\",\n    \"multidict_c\": \"\"\"\\\n    from multidict._multidict import MultiDict as cls, istr\n    \"\"\",\n    \"cimultidict_c\": \"\"\"\\\n    from multidict._multidict import CIMultiDict as cls, istr\n    \"\"\",\n    \"multidict_py\": \"\"\"\\\n    from multidict._multidict_py import MultiDict as cls, istr\n    \"\"\",\n    \"cimultidict_py\": \"\"\"\\\n    from multidict._multidict_py import CIMultiDict as cls, istr\n    \"\"\",\n}\n\nINIT = \"\"\"\\\ndct = cls()\n\"\"\"\n\nFILL = \"\"\"\\\nfor i in range(20):\n    dct['key'+str(i)] = str(i)\n\nkey = 'key10'\n\"\"\"\n\n\nFILL_ISTR = \"\"\"\\\nfor i in range(20):\n    key = istr('key'+str(i))\n    dct[key] = str(i)\n\nkey = istr('key10')\n\"\"\"\n\n\nSET_ITEM = (\n    \"\"\"\\\ndct[key] = '1'\ndct[key] = '2'\ndct[key] = '3'\ndct[key] = '4'\ndct[key] = '5'\ndct[key] = '6'\ndct[key] = '7'\ndct[key] = '8'\ndct[key] = '9'\ndct[key] = '10'\n\"\"\"\n    * 10\n)\n\n\nGET_ITEM = (\n    \"\"\"\\\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\n\"\"\"\n    * 10\n)\n\n\nADD = (\n    \"\"\"\\\nadd(key, '1')\nadd(key, '2')\nadd(key, '3')\nadd(key, '4')\nadd(key, '5')\nadd(key, '6')\nadd(key, '7')\nadd(key, '8')\nadd(key, '9')\nadd(key, '10')\n\"\"\"\n    * 10\n)\n\nSETUP_ADD = \"\"\"\\\nadd = dct.add\n\"\"\"\n\n\ndef benchmark_name(name, ctx, prefix=None, use_prefix=False):\n    if use_prefix:\n        return \"%s%s\" % (prefix % ctx, name)\n\n    return name\n\n\ndef add_impl_option(cmd, args):\n    if args.impl:\n        cmd.extend([\"--impl\", args.impl])\n\n\nif __name__ == \"__main__\":\n    runner = pyperf.Runner(add_cmdline_args=add_impl_option)\n\n    parser = runner.argparser\n    parser.description = (\n        \"Allows to measure performance of MultiMapping and \"\n        \"MutableMultiMapping implementations\"\n    )\n    parser.add_argument(\n        \"--impl\",\n        choices=sorted(IMPLEMENTATIONS),\n        help=\"specific implementation to benchmark\",\n    )\n\n    options = parser.parse_args()\n    implementations = (options.impl,) if options.impl else IMPLEMENTATIONS\n    inner_loops = 50\n\n    for impl in implementations:\n        # print(\"=======================\", impl, \"======================\")\n        imports = textwrap.dedent(IMPLEMENTATIONS[impl])\n        name = functools.partial(\n            benchmark_name,\n            ctx=dict(impl=impl),\n            prefix=\"(impl = %(impl)s) \",\n            use_prefix=len(implementations) > 1,\n        )\n\n        runner.timeit(\n            name(\"setitem str\"),\n            SET_ITEM,\n            imports + INIT + FILL,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"getitem str\"),\n            GET_ITEM,\n            imports + INIT + FILL,\n            inner_loops=inner_loops,\n        )\n\n        # MultiDict specific\n        if impl == \"dict\":\n            continue\n\n        runner.timeit(\n            name(\"setitem istr\"),\n            SET_ITEM,\n            imports + INIT + FILL_ISTR,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"getitem istr\"),\n            GET_ITEM,\n            imports + INIT + FILL_ISTR,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"add str\"),\n            ADD,\n            imports + INIT + FILL + SETUP_ADD,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"add istr\"),\n            ADD,\n            imports + INIT + FILL_ISTR + SETUP_ADD,\n            inner_loops=inner_loops,\n        )\n"}