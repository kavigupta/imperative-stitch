{"setup.py": "import os\nimport platform\nimport sys\n\nfrom setuptools import Extension, setup\n\nNO_EXTENSIONS = bool(os.environ.get(\"MULTIDICT_NO_EXTENSIONS\"))\n\nif sys.implementation.name != \"cpython\":\n    NO_EXTENSIONS = True\n\nCFLAGS = [\"-O2\"]\n# CFLAGS = ['-g']\nif platform.system() != \"Windows\":\n    CFLAGS.extend(\n        [\n            \"-std=c99\",\n            \"-Wall\",\n            \"-Wsign-compare\",\n            \"-Wconversion\",\n            \"-fno-strict-aliasing\",\n            \"-pedantic\",\n        ]\n    )\n\nextensions = [\n    Extension(\n        \"multidict._multidict\",\n        [\"multidict/_multidict.c\"],\n        extra_compile_args=CFLAGS,\n    ),\n]\n\n\nif not NO_EXTENSIONS:\n    print(\"*********************\")\n    print(\"* Accelerated build *\")\n    print(\"*********************\")\n    setup(ext_modules=extensions)\nelse:\n    print(\"*********************\")\n    print(\"* Pure Python build *\")\n    print(\"*********************\")\n    setup()\n", "multidict/_abc.py": "import abc\nimport sys\nimport types\nfrom collections.abc import Mapping, MutableMapping\n\n\nclass _TypingMeta(abc.ABCMeta):\n    # A fake metaclass to satisfy typing deps in runtime\n    # basically MultiMapping[str] and other generic-like type instantiations\n    # are emulated.\n    # Note: real type hints are provided by __init__.pyi stub file\n    if sys.version_info >= (3, 9):\n\n        def __getitem__(self, key):\n            return types.GenericAlias(self, key)\n\n    else:\n\n        def __getitem__(self, key):\n            return self\n\n\nclass MultiMapping(Mapping, metaclass=_TypingMeta):\n    @abc.abstractmethod\n    def getall(self, key, default=None):\n        raise KeyError\n\n    @abc.abstractmethod\n    def getone(self, key, default=None):\n        raise KeyError\n\n\nclass MutableMultiMapping(MultiMapping, MutableMapping):\n    @abc.abstractmethod\n    def add(self, key, value):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def extend(self, *args, **kwargs):\n        raise NotImplementedError\n\n    @abc.abstractmethod\n    def popone(self, key, default=None):\n        raise KeyError\n\n    @abc.abstractmethod\n    def popall(self, key, default=None):\n        raise KeyError\n", "multidict/_compat.py": "import os\nimport platform\n\nNO_EXTENSIONS = bool(os.environ.get(\"MULTIDICT_NO_EXTENSIONS\"))\n\nPYPY = platform.python_implementation() == \"PyPy\"\n\nUSE_EXTENSIONS = not NO_EXTENSIONS and not PYPY\n\nif USE_EXTENSIONS:\n    try:\n        from . import _multidict  # type: ignore[attr-defined]  # noqa: F401\n    except ImportError:\n        USE_EXTENSIONS = False\n", "multidict/__init__.py": "\"\"\"Multidict implementation.\n\nHTTP Headers and URL query string require specific data structure:\nmultidict. It behaves mostly like a dict but it can have\nseveral values for the same key.\n\"\"\"\n\nfrom ._abc import MultiMapping, MutableMultiMapping\nfrom ._compat import USE_EXTENSIONS\n\n__all__ = (\n    \"MultiMapping\",\n    \"MutableMultiMapping\",\n    \"MultiDictProxy\",\n    \"CIMultiDictProxy\",\n    \"MultiDict\",\n    \"CIMultiDict\",\n    \"upstr\",\n    \"istr\",\n    \"getversion\",\n)\n\n__version__ = \"6.0.6.dev0\"\n\n\ntry:\n    if not USE_EXTENSIONS:\n        raise ImportError\n    from ._multidict import (\n        CIMultiDict,\n        CIMultiDictProxy,\n        MultiDict,\n        MultiDictProxy,\n        getversion,\n        istr,\n    )\nexcept ImportError:  # pragma: no cover\n    from ._multidict_py import (\n        CIMultiDict,\n        CIMultiDictProxy,\n        MultiDict,\n        MultiDictProxy,\n        getversion,\n        istr,\n    )\n\n\nupstr = istr\n", "multidict/_multidict_base.py": "import sys\nfrom collections.abc import ItemsView, Iterable, KeysView, Set, ValuesView\n\nif sys.version_info >= (3, 11):\n    from typing import assert_never\nelse:\n    from typing_extensions import assert_never\n\n\ndef _abc_itemsview_register(view_cls):\n    ItemsView.register(view_cls)\n\n\ndef _abc_keysview_register(view_cls):\n    KeysView.register(view_cls)\n\n\ndef _abc_valuesview_register(view_cls):\n    ValuesView.register(view_cls)\n\n\ndef _viewbaseset_richcmp(view, other, op):\n    if op == 0:  # <\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) < len(other) and view <= other\n    elif op == 1:  # <=\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(view) > len(other):\n            return False\n        for elem in view:\n            if elem not in other:\n                return False\n        return True\n    elif op == 2:  # ==\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) == len(other) and view <= other\n    elif op == 3:  # !=\n        return not view == other\n    elif op == 4:  # >\n        if not isinstance(other, Set):\n            return NotImplemented\n        return len(view) > len(other) and view >= other\n    elif op == 5:  # >=\n        if not isinstance(other, Set):\n            return NotImplemented\n        if len(view) < len(other):\n            return False\n        for elem in other:\n            if elem not in view:\n                return False\n        return True\n    else:  # pragma: no cover\n        assert_never(op)\n\n\ndef _viewbaseset_and(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view & other\n\n\ndef _viewbaseset_or(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view | other\n\n\ndef _viewbaseset_sub(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view - other\n\n\ndef _viewbaseset_xor(view, other):\n    if not isinstance(other, Iterable):\n        return NotImplemented\n    if isinstance(view, Set):\n        view = set(iter(view))\n    if isinstance(other, Set):\n        other = set(iter(other))\n    if not isinstance(other, Set):\n        other = set(iter(other))\n    return view ^ other\n\n\ndef _itemsview_isdisjoint(view, other):\n    \"Return True if two sets have a null intersection.\"\n    for v in other:\n        if v in view:\n            return False\n    return True\n\n\ndef _itemsview_repr(view):\n    lst = []\n    for k, v in view:\n        lst.append(\"{!r}: {!r}\".format(k, v))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _keysview_isdisjoint(view, other):\n    \"Return True if two sets have a null intersection.\"\n    for k in other:\n        if k in view:\n            return False\n    return True\n\n\ndef _keysview_repr(view):\n    lst = []\n    for k in view:\n        lst.append(\"{!r}\".format(k))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _valuesview_repr(view):\n    lst = []\n    for v in view:\n        lst.append(\"{!r}\".format(v))\n    body = \", \".join(lst)\n    return \"{}({})\".format(view.__class__.__name__, body)\n\n\ndef _mdrepr(md):\n    lst = []\n    for k, v in md.items():\n        lst.append(\"'{}': {!r}\".format(k, v))\n    body = \", \".join(lst)\n    return \"<{}({})>\".format(md.__class__.__name__, body)\n", "multidict/_multidict_py.py": "import sys\nimport types\nfrom array import array\nfrom collections import abc\n\nfrom ._abc import MultiMapping, MutableMultiMapping\n\n_marker = object()\n\nif sys.version_info >= (3, 9):\n    GenericAlias = types.GenericAlias\nelse:\n\n    def GenericAlias(cls):\n        return cls\n\n\nclass istr(str):\n\n    \"\"\"Case insensitive str.\"\"\"\n\n    __is_istr__ = True\n\n\nupstr = istr  # for relaxing backward compatibility problems\n\n\ndef getversion(md):\n    if not isinstance(md, _Base):\n        raise TypeError(\"Parameter should be multidict or proxy\")\n    return md._impl._version\n\n\n_version = array(\"Q\", [0])\n\n\nclass _Impl:\n    __slots__ = (\"_items\", \"_version\")\n\n    def __init__(self):\n        self._items = []\n        self.incr_version()\n\n    def incr_version(self):\n        global _version\n        v = _version\n        v[0] += 1\n        self._version = v[0]\n\n    if sys.implementation.name != \"pypy\":\n\n        def __sizeof__(self):\n            return object.__sizeof__(self) + sys.getsizeof(self._items)\n\n\nclass _Base:\n    def _title(self, key):\n        return key\n\n    def getall(self, key, default=_marker):\n        \"\"\"Return a list of all values matching the key.\"\"\"\n        identity = self._title(key)\n        res = [v for i, k, v in self._impl._items if i == identity]\n        if res:\n            return res\n        if not res and default is not _marker:\n            return default\n        raise KeyError(\"Key not found: %r\" % key)\n\n    def getone(self, key, default=_marker):\n        \"\"\"Get first value matching the key.\n\n        Raises KeyError if the key is not found and no default is provided.\n        \"\"\"\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return v\n        if default is not _marker:\n            return default\n        raise KeyError(\"Key not found: %r\" % key)\n\n    # Mapping interface #\n\n    def __getitem__(self, key):\n        return self.getone(key)\n\n    def get(self, key, default=None):\n        \"\"\"Get first value matching the key.\n\n        If the key is not found, returns the default (or None if no default is provided)\n        \"\"\"\n        return self.getone(key, default)\n\n    def __iter__(self):\n        return iter(self.keys())\n\n    def __len__(self):\n        return len(self._impl._items)\n\n    def keys(self):\n        \"\"\"Return a new view of the dictionary's keys.\"\"\"\n        return _KeysView(self._impl)\n\n    def items(self):\n        \"\"\"Return a new view of the dictionary's items *(key, value) pairs).\"\"\"\n        return _ItemsView(self._impl)\n\n    def values(self):\n        \"\"\"Return a new view of the dictionary's values.\"\"\"\n        return _ValuesView(self._impl)\n\n    def __eq__(self, other):\n        if not isinstance(other, abc.Mapping):\n            return NotImplemented\n        if isinstance(other, _Base):\n            lft = self._impl._items\n            rht = other._impl._items\n            if len(lft) != len(rht):\n                return False\n            for (i1, k2, v1), (i2, k2, v2) in zip(lft, rht):\n                if i1 != i2 or v1 != v2:\n                    return False\n            return True\n        if len(self._impl._items) != len(other):\n            return False\n        for k, v in self.items():\n            nv = other.get(k, _marker)\n            if v != nv:\n                return False\n        return True\n\n    def __contains__(self, key):\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return True\n        return False\n\n    def __repr__(self):\n        body = \", \".join(\"'{}': {!r}\".format(k, v) for k, v in self.items())\n        return \"<{}({})>\".format(self.__class__.__name__, body)\n\n    __class_getitem__ = classmethod(GenericAlias)\n\n\nclass MultiDictProxy(_Base, MultiMapping):\n    \"\"\"Read-only proxy for MultiDict instance.\"\"\"\n\n    def __init__(self, arg):\n        if not isinstance(arg, (MultiDict, MultiDictProxy)):\n            raise TypeError(\n                \"ctor requires MultiDict or MultiDictProxy instance\"\n                \", not {}\".format(type(arg))\n            )\n\n        self._impl = arg._impl\n\n    def __reduce__(self):\n        raise TypeError(\"can't pickle {} objects\".format(self.__class__.__name__))\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        return MultiDict(self.items())\n\n\nclass CIMultiDictProxy(MultiDictProxy):\n    \"\"\"Read-only proxy for CIMultiDict instance.\"\"\"\n\n    def __init__(self, arg):\n        if not isinstance(arg, (CIMultiDict, CIMultiDictProxy)):\n            raise TypeError(\n                \"ctor requires CIMultiDict or CIMultiDictProxy instance\"\n                \", not {}\".format(type(arg))\n            )\n\n        self._impl = arg._impl\n\n    def _title(self, key):\n        return key.title()\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        return CIMultiDict(self.items())\n\n\nclass MultiDict(_Base, MutableMultiMapping):\n    \"\"\"Dictionary with the support for duplicate keys.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        self._impl = _Impl()\n\n        self._extend(args, kwargs, self.__class__.__name__, self._extend_items)\n\n    if sys.implementation.name != \"pypy\":\n\n        def __sizeof__(self):\n            return object.__sizeof__(self) + sys.getsizeof(self._impl)\n\n    def __reduce__(self):\n        return (self.__class__, (list(self.items()),))\n\n    def _title(self, key):\n        return key\n\n    def _key(self, key):\n        if isinstance(key, str):\n            return key\n        else:\n            raise TypeError(\n                \"MultiDict keys should be either str \" \"or subclasses of str\"\n            )\n\n    def add(self, key, value):\n        identity = self._title(key)\n        self._impl._items.append((identity, self._key(key), value))\n        self._impl.incr_version()\n\n    def copy(self):\n        \"\"\"Return a copy of itself.\"\"\"\n        cls = self.__class__\n        return cls(self.items())\n\n    __copy__ = copy\n\n    def extend(self, *args, **kwargs):\n        \"\"\"Extend current MultiDict with more values.\n\n        This method must be used instead of update.\n        \"\"\"\n        self._extend(args, kwargs, \"extend\", self._extend_items)\n\n    def _extend(self, args, kwargs, name, method):\n        if len(args) > 1:\n            raise TypeError(\n                \"{} takes at most 1 positional argument\"\n                \" ({} given)\".format(name, len(args))\n            )\n        if args:\n            arg = args[0]\n            if isinstance(args[0], (MultiDict, MultiDictProxy)) and not kwargs:\n                items = arg._impl._items\n            else:\n                if hasattr(arg, \"items\"):\n                    arg = arg.items()\n                if kwargs:\n                    arg = list(arg)\n                    arg.extend(list(kwargs.items()))\n                items = []\n                for item in arg:\n                    if not len(item) == 2:\n                        raise TypeError(\n                            \"{} takes either dict or list of (key, value) \"\n                            \"tuples\".format(name)\n                        )\n                    items.append((self._title(item[0]), self._key(item[0]), item[1]))\n\n            method(items)\n        else:\n            method(\n                [\n                    (self._title(key), self._key(key), value)\n                    for key, value in kwargs.items()\n                ]\n            )\n\n    def _extend_items(self, items):\n        for identity, key, value in items:\n            self.add(key, value)\n\n    def clear(self):\n        \"\"\"Remove all items from MultiDict.\"\"\"\n        self._impl._items.clear()\n        self._impl.incr_version()\n\n    # Mapping interface #\n\n    def __setitem__(self, key, value):\n        self._replace(key, value)\n\n    def __delitem__(self, key):\n        identity = self._title(key)\n        items = self._impl._items\n        found = False\n        for i in range(len(items) - 1, -1, -1):\n            if items[i][0] == identity:\n                del items[i]\n                found = True\n        if not found:\n            raise KeyError(key)\n        else:\n            self._impl.incr_version()\n\n    def setdefault(self, key, default=None):\n        \"\"\"Return value for key, set value to default if key is not present.\"\"\"\n        identity = self._title(key)\n        for i, k, v in self._impl._items:\n            if i == identity:\n                return v\n        self.add(key, default)\n        return default\n\n    def popone(self, key, default=_marker):\n        \"\"\"Remove specified key and return the corresponding value.\n\n        If key is not found, d is returned if given, otherwise\n        KeyError is raised.\n\n        \"\"\"\n        identity = self._title(key)\n        for i in range(len(self._impl._items)):\n            if self._impl._items[i][0] == identity:\n                value = self._impl._items[i][2]\n                del self._impl._items[i]\n                self._impl.incr_version()\n                return value\n        if default is _marker:\n            raise KeyError(key)\n        else:\n            return default\n\n    pop = popone  # type: ignore\n\n    def popall(self, key, default=_marker):\n        \"\"\"Remove all occurrences of key and return the list of corresponding\n        values.\n\n        If key is not found, default is returned if given, otherwise\n        KeyError is raised.\n\n        \"\"\"\n        found = False\n        identity = self._title(key)\n        ret = []\n        for i in range(len(self._impl._items) - 1, -1, -1):\n            item = self._impl._items[i]\n            if item[0] == identity:\n                ret.append(item[2])\n                del self._impl._items[i]\n                self._impl.incr_version()\n                found = True\n        if not found:\n            if default is _marker:\n                raise KeyError(key)\n            else:\n                return default\n        else:\n            ret.reverse()\n            return ret\n\n    def popitem(self):\n        \"\"\"Remove and return an arbitrary (key, value) pair.\"\"\"\n        if self._impl._items:\n            i = self._impl._items.pop(0)\n            self._impl.incr_version()\n            return i[1], i[2]\n        else:\n            raise KeyError(\"empty multidict\")\n\n    def update(self, *args, **kwargs):\n        \"\"\"Update the dictionary from *other*, overwriting existing keys.\"\"\"\n        self._extend(args, kwargs, \"update\", self._update_items)\n\n    def _update_items(self, items):\n        if not items:\n            return\n        used_keys = {}\n        for identity, key, value in items:\n            start = used_keys.get(identity, 0)\n            for i in range(start, len(self._impl._items)):\n                item = self._impl._items[i]\n                if item[0] == identity:\n                    used_keys[identity] = i + 1\n                    self._impl._items[i] = (identity, key, value)\n                    break\n            else:\n                self._impl._items.append((identity, key, value))\n                used_keys[identity] = len(self._impl._items)\n\n        # drop tails\n        i = 0\n        while i < len(self._impl._items):\n            item = self._impl._items[i]\n            identity = item[0]\n            pos = used_keys.get(identity)\n            if pos is None:\n                i += 1\n                continue\n            if i >= pos:\n                del self._impl._items[i]\n            else:\n                i += 1\n\n        self._impl.incr_version()\n\n    def _replace(self, key, value):\n        key = self._key(key)\n        identity = self._title(key)\n        items = self._impl._items\n\n        for i in range(len(items)):\n            item = items[i]\n            if item[0] == identity:\n                items[i] = (identity, key, value)\n                # i points to last found item\n                rgt = i\n                self._impl.incr_version()\n                break\n        else:\n            self._impl._items.append((identity, key, value))\n            self._impl.incr_version()\n            return\n\n        # remove all tail items\n        i = rgt + 1\n        while i < len(items):\n            item = items[i]\n            if item[0] == identity:\n                del items[i]\n            else:\n                i += 1\n\n\nclass CIMultiDict(MultiDict):\n    \"\"\"Dictionary with the support for duplicate case-insensitive keys.\"\"\"\n\n    def _title(self, key):\n        return key.title()\n\n\nclass _Iter:\n    __slots__ = (\"_size\", \"_iter\")\n\n    def __init__(self, size, iterator):\n        self._size = size\n        self._iter = iterator\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iter)\n\n    def __length_hint__(self):\n        return self._size\n\n\nclass _ViewBase:\n    def __init__(self, impl):\n        self._impl = impl\n\n    def __len__(self):\n        return len(self._impl._items)\n\n\nclass _ItemsView(_ViewBase, abc.ItemsView):\n    def __contains__(self, item):\n        assert isinstance(item, tuple) or isinstance(item, list)\n        assert len(item) == 2\n        for i, k, v in self._impl._items:\n            if item[0] == k and item[1] == v:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for i, k, v in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield k, v\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}: {!r}\".format(item[1], item[2]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n\n\nclass _ValuesView(_ViewBase, abc.ValuesView):\n    def __contains__(self, value):\n        for item in self._impl._items:\n            if item[2] == value:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for item in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield item[2]\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}\".format(item[2]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n\n\nclass _KeysView(_ViewBase, abc.KeysView):\n    def __contains__(self, key):\n        for item in self._impl._items:\n            if item[1] == key:\n                return True\n        return False\n\n    def __iter__(self):\n        return _Iter(len(self), self._iter(self._impl._version))\n\n    def _iter(self, version):\n        for item in self._impl._items:\n            if version != self._impl._version:\n                raise RuntimeError(\"Dictionary changed during iteration\")\n            yield item[1]\n\n    def __repr__(self):\n        lst = []\n        for item in self._impl._items:\n            lst.append(\"{!r}\".format(item[1]))\n        body = \", \".join(lst)\n        return \"{}({})\".format(self.__class__.__name__, body)\n", "benchmarks/istr.py": "import functools\nimport textwrap\n\nimport perf\n\n\nIMPLEMENTATIONS = {\n    \"c\": \"\"\"\\\n    from multidict._multidict import istr\n    \"\"\",\n    \"python\": \"\"\"\\\n    from multidict._multidict_py import istr\n    \"\"\",\n}\n\nINIT = \"\"\"\\\nval = istr('VaLuE')\n\"\"\"\n\n\nISTR_TO_ISTR = \"\"\"\\\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\nistr(val)\n\"\"\"\n\n\ndef benchmark_name(name, ctx, prefix=None, use_prefix=False):\n    if use_prefix:\n        return \"%s%s\" % (prefix % ctx, name)\n\n    return name\n\n\ndef add_impl_option(cmd, args):\n    if args.impl:\n        cmd.extend([\"--impl\", args.impl])\n\n\nif __name__ == \"__main__\":\n    runner = perf.Runner(add_cmdline_args=add_impl_option)\n\n    parser = runner.argparser\n    parser.description = \"Allows to measure performance of \" \"istr implementations\"\n    parser.add_argument(\n        \"--impl\",\n        choices=sorted(IMPLEMENTATIONS),\n        help=\"specific implementation to benchmark\",\n    )\n\n    options = parser.parse_args()\n    implementations = (options.impl,) if options.impl else IMPLEMENTATIONS\n\n    for name in implementations:\n        imports = textwrap.dedent(IMPLEMENTATIONS[name])\n        name = functools.partial(\n            benchmark_name,\n            ctx=dict(impl=name),\n            prefix=\"(impl = %(impl)s) \",\n            use_prefix=len(implementations) > 1,\n        )\n\n        runner.timeit(name(\"istr->istr\"), ISTR_TO_ISTR, imports + INIT, inner_loops=10)\n", "benchmarks/becnhmark.py": "import functools\nimport textwrap\n\nimport pyperf\n\n\nIMPLEMENTATIONS = {\n    \"dict\": \"\"\"\\\n    cls = dict\n    \"\"\",\n    \"multidict_c\": \"\"\"\\\n    from multidict._multidict import MultiDict as cls, istr\n    \"\"\",\n    \"cimultidict_c\": \"\"\"\\\n    from multidict._multidict import CIMultiDict as cls, istr\n    \"\"\",\n    \"multidict_py\": \"\"\"\\\n    from multidict._multidict_py import MultiDict as cls, istr\n    \"\"\",\n    \"cimultidict_py\": \"\"\"\\\n    from multidict._multidict_py import CIMultiDict as cls, istr\n    \"\"\",\n}\n\nINIT = \"\"\"\\\ndct = cls()\n\"\"\"\n\nFILL = \"\"\"\\\nfor i in range(20):\n    dct['key'+str(i)] = str(i)\n\nkey = 'key10'\n\"\"\"\n\n\nFILL_ISTR = \"\"\"\\\nfor i in range(20):\n    key = istr('key'+str(i))\n    dct[key] = str(i)\n\nkey = istr('key10')\n\"\"\"\n\n\nSET_ITEM = (\n    \"\"\"\\\ndct[key] = '1'\ndct[key] = '2'\ndct[key] = '3'\ndct[key] = '4'\ndct[key] = '5'\ndct[key] = '6'\ndct[key] = '7'\ndct[key] = '8'\ndct[key] = '9'\ndct[key] = '10'\n\"\"\"\n    * 10\n)\n\n\nGET_ITEM = (\n    \"\"\"\\\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\ndct[key]\n\"\"\"\n    * 10\n)\n\n\nADD = (\n    \"\"\"\\\nadd(key, '1')\nadd(key, '2')\nadd(key, '3')\nadd(key, '4')\nadd(key, '5')\nadd(key, '6')\nadd(key, '7')\nadd(key, '8')\nadd(key, '9')\nadd(key, '10')\n\"\"\"\n    * 10\n)\n\nSETUP_ADD = \"\"\"\\\nadd = dct.add\n\"\"\"\n\n\ndef benchmark_name(name, ctx, prefix=None, use_prefix=False):\n    if use_prefix:\n        return \"%s%s\" % (prefix % ctx, name)\n\n    return name\n\n\ndef add_impl_option(cmd, args):\n    if args.impl:\n        cmd.extend([\"--impl\", args.impl])\n\n\nif __name__ == \"__main__\":\n    runner = pyperf.Runner(add_cmdline_args=add_impl_option)\n\n    parser = runner.argparser\n    parser.description = (\n        \"Allows to measure performance of MultiMapping and \"\n        \"MutableMultiMapping implementations\"\n    )\n    parser.add_argument(\n        \"--impl\",\n        choices=sorted(IMPLEMENTATIONS),\n        help=\"specific implementation to benchmark\",\n    )\n\n    options = parser.parse_args()\n    implementations = (options.impl,) if options.impl else IMPLEMENTATIONS\n    inner_loops = 50\n\n    for impl in implementations:\n        # print(\"=======================\", impl, \"======================\")\n        imports = textwrap.dedent(IMPLEMENTATIONS[impl])\n        name = functools.partial(\n            benchmark_name,\n            ctx=dict(impl=impl),\n            prefix=\"(impl = %(impl)s) \",\n            use_prefix=len(implementations) > 1,\n        )\n\n        runner.timeit(\n            name(\"setitem str\"),\n            SET_ITEM,\n            imports + INIT + FILL,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"getitem str\"),\n            GET_ITEM,\n            imports + INIT + FILL,\n            inner_loops=inner_loops,\n        )\n\n        # MultiDict specific\n        if impl == \"dict\":\n            continue\n\n        runner.timeit(\n            name(\"setitem istr\"),\n            SET_ITEM,\n            imports + INIT + FILL_ISTR,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"getitem istr\"),\n            GET_ITEM,\n            imports + INIT + FILL_ISTR,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"add str\"),\n            ADD,\n            imports + INIT + FILL + SETUP_ADD,\n            inner_loops=inner_loops,\n        )\n        runner.timeit(\n            name(\"add istr\"),\n            ADD,\n            imports + INIT + FILL_ISTR + SETUP_ADD,\n            inner_loops=inner_loops,\n        )\n"}