{"docs/conf.py": "# Configuration file for the Sphinx documentation builder.\n#\n# This file only contains a selection of the most common options. For a full\n# list see the documentation:\n# https://www.sphinx-doc.org/en/master/usage/configuration.html\n\n# -- Path setup --------------------------------------------------------------\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\nimport os\nimport sys\n\n\nsys.path.insert(0, os.path.dirname(os.path.dirname(__file__)))\n\nfrom tomlkit import __version__\n\n\n# -- Project information -----------------------------------------------------\n\nproject = \"TOML Kit\"\ncopyright = \"2021, S\u00e9bastien Eustace\"\nauthor = \"S\u00e9bastien Eustace\"\n\n# The full version, including alpha/beta/rc tags\nrelease = __version__\n\n\n# -- General configuration ---------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"sphinx.ext.autodoc\",\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = [\"_templates\"]\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This pattern also affects html_static_path and html_extra_path.\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n\n# -- Options for HTML output -------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"furo\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = []\n", "tests/test_write.py": "from tomlkit import dumps\nfrom tomlkit import loads\n\n\ndef test_write_backslash():\n    d = {\"foo\": \"\\\\e\\u25e6\\r\"}\n\n    expected = \"\"\"foo = \"\\\\\\\\e\\u25e6\\\\r\"\n\"\"\"\n\n    assert expected == dumps(d)\n    assert loads(dumps(d))[\"foo\"] == \"\\\\e\\u25e6\\r\"\n\n\ndef test_escape_special_characters_in_key():\n    d = {\"foo\\nbar\": \"baz\"}\n    expected = '\"foo\\\\nbar\" = \"baz\"\\n'\n    assert expected == dumps(d)\n    assert loads(dumps(d))[\"foo\\nbar\"] == \"baz\"\n\n\ndef test_write_inline_table_in_nested_arrays():\n    d = {\"foo\": [[{\"a\": 1}]]}\n    expected = \"foo = [[{a = 1}]]\\n\"\n    assert expected == dumps(d)\n    assert loads(dumps(d))[\"foo\"] == [[{\"a\": 1}]]\n\n\ndef test_serialize_aot_with_nested_tables():\n    doc = {\"a\": [{\"b\": {\"c\": 1}}]}\n    expected = \"\"\"\\\n[[a]]\n[a.b]\nc = 1\n\"\"\"\n    assert dumps(doc) == expected\n    assert loads(expected) == doc\n", "tests/test_parser.py": "import pytest\n\nfrom tomlkit.exceptions import EmptyTableNameError\nfrom tomlkit.exceptions import InternalParserError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.items import StringType\nfrom tomlkit.parser import Parser\n\n\ndef test_parser_should_raise_an_internal_error_if_parsing_wrong_type_of_string():\n    parser = Parser('\"foo\"')\n\n    with pytest.raises(InternalParserError) as e:\n        parser._parse_string(StringType.SLL)\n\n    assert e.value.line == 1\n    assert e.value.col == 0\n\n\ndef test_parser_should_raise_an_error_for_empty_tables():\n    content = \"\"\"\n[one]\n[]\n\"\"\"\n\n    parser = Parser(content)\n\n    with pytest.raises(EmptyTableNameError) as e:\n        parser.parse()\n\n    assert e.value.line == 3\n    assert e.value.col == 1\n\n\ndef test_parser_should_raise_an_error_if_equal_not_found():\n    content = \"\"\"[foo]\na {c = 1, d = 2}\n\"\"\"\n    parser = Parser(content)\n    with pytest.raises(UnexpectedCharError):\n        parser.parse()\n\n\ndef test_parse_multiline_string_ignore_the_first_newline():\n    content = 'a = \"\"\"\\nfoo\\n\"\"\"'\n    parser = Parser(content)\n    assert parser.parse() == {\"a\": \"foo\\n\"}\n\n    content = 'a = \"\"\"\\r\\nfoo\\n\"\"\"'\n    parser = Parser(content)\n    assert parser.parse() == {\"a\": \"foo\\n\"}\n", "tests/test_toml_spec_tests.py": "import json\nimport os\nimport re\n\nimport pytest\nimport yaml\n\nfrom tomlkit import parse\nfrom tomlkit._compat import decode\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.exceptions import TOMLKitError\n\n\nIGNORED_TESTS = []\n# The following tests trigger a RecursionError\nIGNORED_TESTS += [\"qa-array-inline-nested-1000\", \"qa-table-inline-nested-1000\"]\n# The following tests don't work due to time microseconds precision of the tests\nIGNORED_TESTS += [\"spec-date-time-6\", \"spec-date-time-local-2\", \"spec-time-2\"]\n# The following tests don't work due to nan always comparing to False\nIGNORED_TESTS += [\"spec-float-13\", \"spec-float-14\", \"spec-float-15\"]\n# The following tests don't work due to issues with th epyyaml library\nIGNORED_TESTS += [\"spec-key-value-pair-9\"]\nSPEC_TEST_DIR = os.path.join(os.path.dirname(__file__), \"toml-spec-tests\")\nVALID_TESTS = sorted(\n    os.path.basename(f).rsplit(\".\", 1)[0]\n    for f in os.listdir(os.path.join(SPEC_TEST_DIR, \"values\"))\n    if os.path.basename(f).rsplit(\".\", 1)[0] not in IGNORED_TESTS\n)\nERROR_TESTS = sorted(\n    os.path.basename(f).rsplit(\".\", 1)[0]\n    for f in os.listdir(os.path.join(SPEC_TEST_DIR, \"errors\"))\n    if os.path.basename(f).rsplit(\".\", 1)[0] not in IGNORED_TESTS\n)\n\n\ndef to_bool(s):\n    assert s in [\"true\", \"false\"]\n\n    return s == \"true\"\n\n\nstypes = {\n    \"string\": str,\n    \"bool\": to_bool,\n    \"integer\": int,\n    \"float\": float,\n    \"datetime\": parse_rfc3339,\n    \"datetime-local\": parse_rfc3339,\n    \"date\": parse_rfc3339,\n    \"time\": parse_rfc3339,\n}\n\nloader = yaml.SafeLoader\nloader.add_implicit_resolver(\n    \"tag:yaml.org,2002:float\",\n    re.compile(\n        \"\"\"^(?:\n     [-+]?(?:[0-9][0-9_]*)\\\\.[0-9_]*(?:[eE][-+]?[0-9]+)?\n    |[-+]?(?:[0-9][0-9_]*)(?:[eE][-+]?[0-9]+)\n    |\\\\.[0-9_]+(?:[eE][-+][0-9]+)?\n    |[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\\\.[0-9_]*\n    |[-+]?\\\\.(?:inf|Inf|INF)\n    |\\\\.(?:nan|NaN|NAN))$\"\"\",\n        re.X,\n    ),\n    list(\"-+0123456789.\"),\n)\n\n\ndef untag(value):\n    if isinstance(value, list):\n        return [untag(i) for i in value]\n    elif \"type\" in value and \"value\" in value and len(value) == 2:\n        if value[\"type\"] in stypes:\n            val = decode(value[\"value\"])\n\n            return stypes[value[\"type\"]](val)\n        elif value[\"type\"] == \"array\":\n            return [untag(i) for i in value[\"value\"]]\n        else:\n            raise Exception(f'Unsupported type {value[\"type\"]}')\n    else:\n        return {k: untag(v) for k, v in value.items()}\n\n\n@pytest.mark.parametrize(\"test\", VALID_TESTS)\ndef test_valid_decode(test):\n    toml_file = os.path.join(SPEC_TEST_DIR, \"values\", test + \".toml\")\n    yaml_file = os.path.join(SPEC_TEST_DIR, \"values\", test + \".yaml\")\n    with open(toml_file, encoding=\"utf-8\") as f:\n        toml_content = f.read()\n        toml_val = parse(toml_content)\n\n    if os.path.exists(yaml_file):\n        with open(yaml_file, encoding=\"utf-8\") as f:\n            yaml_val = yaml.load(f.read(), Loader=loader)\n    else:\n        with open(\n            os.path.join(SPEC_TEST_DIR, \"values\", test + \".json\"), encoding=\"utf-8\"\n        ) as f:\n            yaml_val = untag(json.loads(f.read()))\n\n    assert toml_val == yaml_val\n    assert toml_val.as_string() == toml_content\n\n\n@pytest.mark.parametrize(\"test\", ERROR_TESTS)\ndef test_invalid_decode(test):\n    toml_file = os.path.join(SPEC_TEST_DIR, \"errors\", test + \".toml\")\n    with pytest.raises(TOMLKitError), open(toml_file, encoding=\"utf-8\") as f:\n        parse(f.read())\n", "tests/util.py": "from tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item\nfrom tomlkit.items import KeyType\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey as Key\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.items import Trivia\nfrom tomlkit.toml_document import TOMLDocument\n\n\nTOMLKIT_TYPES = [\n    Bool,\n    Comment,\n    InlineTable,\n    Integer,\n    Float,\n    DateTime,\n    Date,\n    Time,\n    Array,\n    KeyType,\n    Key,\n    String,\n    StringType,\n    Table,\n    Trivia,\n    Item,\n    AoT,\n    Null,\n    TOMLDocument,\n]\n\n\ndef assert_not_tomlkit_type(v):\n    for _, tomlkit_type in enumerate(TOMLKIT_TYPES):\n        assert not isinstance(v, tomlkit_type)\n\n\ndef assert_is_ppo(v_unwrapped, unwrapped_type):\n    assert_not_tomlkit_type(v_unwrapped)\n    assert isinstance(v_unwrapped, unwrapped_type)\n\n\ndef elementary_test(v, unwrapped_type):\n    v_unwrapped = v.unwrap()\n    assert_is_ppo(v_unwrapped, unwrapped_type)\n", "tests/test_items.py": "import copy\nimport math\nimport pickle\n\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom datetime import timezone\n\nimport pytest\n\nfrom tests.util import assert_is_ppo\nfrom tests.util import elementary_test\nfrom tomlkit import api\nfrom tomlkit import parse\nfrom tomlkit.exceptions import NonExistentKey\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import Comment\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item\nfrom tomlkit.items import KeyType\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey as Key\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import item\nfrom tomlkit.parser import Parser\n\n\n@pytest.fixture()\ndef tz_pst():\n    try:\n        from datetime import timezone\n\n        return timezone(timedelta(hours=-8), \"PST\")\n    except ImportError:\n        from datetime import tzinfo\n\n        class PST(tzinfo):\n            def utcoffset(self, dt):\n                return timedelta(hours=-8)\n\n            def tzname(self, dt):\n                return \"PST\"\n\n            def dst(self, dt):\n                return timedelta(0)\n\n        return PST()\n\n\n@pytest.fixture()\ndef tz_utc():\n    try:\n        from datetime import timezone\n\n        return timezone.utc\n    except ImportError:\n        from datetime import tzinfo\n\n        class UTC(tzinfo):\n            def utcoffset(self, dt):\n                return timedelta(hours=0)\n\n            def tzname(self, dt):\n                return \"UTC\"\n\n            def dst(self, dt):\n                return timedelta(0)\n\n        return UTC()\n\n\ndef test_item_base_has_no_unwrap():\n    trivia = Trivia(indent=\"\\t\", comment_ws=\" \", comment=\"For unit test\")\n    item = Item(trivia)\n    try:\n        item.unwrap()\n    except NotImplementedError:\n        pass\n    else:\n        raise AssertionError(\"`items.Item` should not implement `unwrap`\")\n\n\ndef test_integer_unwrap():\n    elementary_test(item(666), int)\n\n\ndef test_float_unwrap():\n    elementary_test(item(2.78), float)\n\n\ndef test_false_unwrap():\n    elementary_test(item(False), bool)\n\n\ndef test_true_unwrap():\n    elementary_test(item(True), bool)\n\n\ndef test_datetime_unwrap():\n    dt = datetime.now(tz=timezone.utc)\n    elementary_test(item(dt), datetime)\n\n\ndef test_string_unwrap():\n    elementary_test(item(\"hello\"), str)\n\n\ndef test_null_unwrap():\n    n = Null()\n    elementary_test(n, type(None))\n\n\ndef test_aot_unwrap():\n    d = item([{\"a\": \"A\"}, {\"b\": \"B\"}])\n    unwrapped = d.unwrap()\n    assert_is_ppo(unwrapped, list)\n    for du, _ in zip(unwrapped, d):\n        assert_is_ppo(du, dict)\n        for ku in du:\n            vu = du[ku]\n            assert_is_ppo(ku, str)\n            assert_is_ppo(vu, str)\n\n\ndef test_time_unwrap():\n    t = time(3, 8, 14)\n    elementary_test(item(t), time)\n\n\ndef test_date_unwrap():\n    d = date.today()\n    elementary_test(item(d), date)\n\n\ndef test_array_unwrap():\n    trivia = Trivia(indent=\"\\t\", comment_ws=\" \", comment=\"For unit test\")\n    i = item(666)\n    f = item(2.78)\n    b = item(False)\n    a = Array([i, f, b], trivia)\n    a_unwrapped = a.unwrap()\n    assert_is_ppo(a_unwrapped, list)\n    assert_is_ppo(a_unwrapped[0], int)\n    assert_is_ppo(a_unwrapped[1], float)\n    assert_is_ppo(a_unwrapped[2], bool)\n\n\ndef test_abstract_table_unwrap():\n    table = item({\"foo\": \"bar\"})\n    super_table = item({\"table\": table, \"baz\": \"borg\"})\n\n    table_unwrapped = super_table.unwrap()\n    sub_table = table_unwrapped[\"table\"]\n    assert_is_ppo(table_unwrapped, dict)\n    assert_is_ppo(sub_table, dict)\n    for ku in sub_table:\n        vu = sub_table[ku]\n        assert_is_ppo(ku, str)\n        assert_is_ppo(vu, str)\n\n\ndef test_key_comparison():\n    k = Key(\"foo\")\n\n    assert k == Key(\"foo\")\n    assert k == \"foo\"\n    assert k != \"bar\"\n    assert k != 5\n\n\ndef test_items_can_be_appended_to_and_removed_from_a_table():\n    string = \"\"\"[table]\n\"\"\"\n\n    parser = Parser(string)\n    _, table = parser._parse_table()\n\n    assert isinstance(table, Table)\n    assert table.as_string() == \"\"\n\n    table.append(Key(\"foo\"), String(StringType.SLB, \"bar\", \"bar\", Trivia(trail=\"\\n\")))\n\n    assert table.as_string() == 'foo = \"bar\"\\n'\n\n    table.append(\n        Key(\"baz\"),\n        Integer(34, Trivia(comment_ws=\"   \", comment=\"# Integer\", trail=\"\"), \"34\"),\n    )\n\n    assert table.as_string() == 'foo = \"bar\"\\nbaz = 34   # Integer'\n\n    table.remove(Key(\"baz\"))\n\n    assert table.as_string() == 'foo = \"bar\"\\n'\n\n    table.remove(Key(\"foo\"))\n\n    assert table.as_string() == \"\"\n\n    with pytest.raises(NonExistentKey):\n        table.remove(Key(\"foo\"))\n\n\ndef test_items_can_be_appended_to_and_removed_from_an_inline_table():\n    string = \"\"\"table = {}\n\"\"\"\n\n    parser = Parser(string)\n    _, table = parser._parse_item()\n\n    assert isinstance(table, InlineTable)\n    assert table.as_string() == \"{}\"\n\n    table.append(Key(\"foo\"), String(StringType.SLB, \"bar\", \"bar\", Trivia(trail=\"\")))\n\n    assert table.as_string() == '{foo = \"bar\"}'\n\n    table.append(Key(\"baz\"), Integer(34, Trivia(trail=\"\"), \"34\"))\n\n    assert table.as_string() == '{foo = \"bar\", baz = 34}'\n\n    table.remove(Key(\"baz\"))\n\n    assert table.as_string() == '{foo = \"bar\"}'\n\n    table.remove(Key(\"foo\"))\n\n    assert table.as_string() == \"{}\"\n\n    with pytest.raises(NonExistentKey):\n        table.remove(Key(\"foo\"))\n\n\ndef test_inf_and_nan_are_supported(example):\n    content = example(\"0.5.0\")\n    doc = parse(content)\n\n    assert doc[\"sf1\"] == float(\"inf\")\n    assert doc[\"sf2\"] == float(\"inf\")\n    assert doc[\"sf3\"] == float(\"-inf\")\n\n    assert math.isnan(doc[\"sf4\"])\n    assert math.isnan(doc[\"sf5\"])\n    assert math.isnan(doc[\"sf6\"])\n\n\ndef test_hex_octal_and_bin_integers_are_supported(example):\n    content = example(\"0.5.0\")\n    doc = parse(content)\n\n    assert doc[\"hex1\"] == 3735928559\n    assert doc[\"hex2\"] == 3735928559\n    assert doc[\"hex3\"] == 3735928559\n\n    assert doc[\"oct1\"] == 342391\n    assert doc[\"oct2\"] == 493\n\n    assert doc[\"bin1\"] == 214\n\n\ndef test_key_automatically_sets_proper_string_type_if_not_bare():\n    key = Key(\"foo.bar\")\n\n    assert key.t == KeyType.Basic\n\n    key = Key(\"\")\n    assert key.t == KeyType.Basic\n\n\ndef test_array_behaves_like_a_list():\n    a = item([1, 2])\n\n    assert a == [1, 2]\n    assert a.as_string() == \"[1, 2]\"\n\n    a += [3, 4]\n    assert a == [1, 2, 3, 4]\n    assert a.as_string() == \"[1, 2, 3, 4]\"\n\n    del a[2]\n    assert a == [1, 2, 4]\n    assert a.as_string() == \"[1, 2, 4]\"\n\n    assert a.pop() == 4\n    assert a == [1, 2]\n    assert a.as_string() == \"[1, 2]\"\n\n    a[0] = 4\n    assert a == [4, 2]\n    a[-2] = 0\n    assert a == [0, 2]\n\n    del a[-2]\n    assert a == [2]\n    assert a.as_string() == \"[2]\"\n\n    a.clear()\n    assert a == []\n    assert a.as_string() == \"[]\"\n\n    content = \"\"\"a = [1, 2,] # Comment\n\"\"\"\n    doc = parse(content)\n    assert str(doc[\"a\"]) == \"[1, 2]\"\n\n    assert doc[\"a\"] == [1, 2]\n    doc[\"a\"] += [3, 4]\n    assert doc[\"a\"] == [1, 2, 3, 4]\n    assert (\n        doc.as_string()\n        == \"\"\"a = [1, 2, 3, 4] # Comment\n\"\"\"\n    )\n\n\ndef test_array_multiline():\n    t = item([1, 2, 3, 4, 5, 6, 7, 8])\n    t.multiline(True)\n\n    expected = \"\"\"\\\n[\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n]\"\"\"\n\n    assert expected == t.as_string()\n\n    t = item([])\n    t.multiline(True)\n\n    assert t.as_string() == \"[]\"\n\n\ndef test_array_multiline_modify():\n    doc = parse(\n        \"\"\"\\\na = [\n    \"abc\"\n]\"\"\"\n    )\n    doc[\"a\"].append(\"def\")\n    expected = \"\"\"\\\na = [\n    \"abc\",\n    \"def\"\n]\"\"\"\n    assert expected == doc.as_string()\n    doc[\"a\"].insert(1, \"ghi\")\n    expected = \"\"\"\\\na = [\n    \"abc\",\n    \"ghi\",\n    \"def\"\n]\"\"\"\n    assert expected == doc.as_string()\n\n\ndef test_append_to_empty_array():\n    doc = parse(\"x = [ ]\")\n    doc[\"x\"].append(\"a\")\n    assert doc.as_string() == 'x = [\"a\" ]'\n    doc = parse(\"x = [\\n]\")\n    doc[\"x\"].append(\"a\")\n    assert doc.as_string() == 'x = [\\n    \"a\"\\n]'\n\n\ndef test_modify_array_with_comment():\n    doc = parse(\"x = [ # comment\\n]\")\n    doc[\"x\"].append(\"a\")\n    assert doc.as_string() == 'x = [ # comment\\n    \"a\"\\n]'\n    doc = parse(\n        \"\"\"\\\nx = [\n    \"a\",\n    # comment\n    \"b\"\n]\"\"\"\n    )\n    doc[\"x\"].insert(1, \"c\")\n    expected = \"\"\"\\\nx = [\n    \"a\",\n    # comment\n    \"c\",\n    \"b\"\n]\"\"\"\n    assert doc.as_string() == expected\n    doc = parse(\n        \"\"\"\\\nx = [\n    1  # comment\n]\"\"\"\n    )\n    doc[\"x\"].append(2)\n    assert (\n        doc.as_string()\n        == \"\"\"\\\nx = [\n    1,  # comment\n    2\n]\"\"\"\n    )\n    doc[\"x\"].pop(0)\n    assert doc.as_string() == \"x = [\\n    2\\n]\"\n\n\ndef test_append_to_multiline_array_with_comment():\n    doc = parse(\n        \"\"\"\\\nx = [\n    # Here is a comment\n    1,\n    2\n]\n\"\"\"\n    )\n    doc[\"x\"].multiline(True).append(3)\n    assert (\n        doc.as_string()\n        == \"\"\"\\\nx = [\n    # Here is a comment\n    1,\n    2,\n    3,\n]\n\"\"\"\n    )\n    assert doc[\"x\"].pop() == 3\n    assert (\n        doc.as_string()\n        == \"\"\"\\\nx = [\n    # Here is a comment\n    1,\n    2,\n]\n\"\"\"\n    )\n\n\ndef test_append_dict_to_array():\n    doc = parse(\"x = []\")\n    doc[\"x\"].append({\"name\": \"John Doe\", \"email\": \"john@doe.com\"})\n    expected = 'x = [{name = \"John Doe\",email = \"john@doe.com\"}]'\n    assert doc.as_string() == expected\n    # Make sure the produced string is valid\n    assert parse(doc.as_string()) == doc\n\n\ndef test_dicts_are_converted_to_tables():\n    t = item({\"foo\": {\"bar\": \"baz\"}})\n\n    assert (\n        t.as_string()\n        == \"\"\"[foo]\nbar = \"baz\"\n\"\"\"\n    )\n\n\ndef test_array_add_line():\n    t = api.array()\n    t.add_line(1, 2, 3, comment=\"Line 1\")\n    t.add_line(4, 5, 6, comment=\"Line 2\")\n    t.add_line(7, api.ws(\",\"), api.ws(\" \"), 8, add_comma=False)\n    t.add_line(comment=\"Line 4\")\n    t.add_line(indent=\"\")\n    assert len(t) == 8\n    assert list(t) == [1, 2, 3, 4, 5, 6, 7, 8]\n    assert (\n        t.as_string()\n        == \"\"\"[\n    1, 2, 3, # Line 1\n    4, 5, 6, # Line 2\n    7, 8,\n    # Line 4\n]\"\"\"\n    )\n\n\ndef test_array_add_line_invalid_value():\n    t = api.array()\n    with pytest.raises(ValueError, match=\"is not allowed\"):\n        t.add_line(1, api.ws(\" \"))\n    with pytest.raises(ValueError, match=\"is not allowed\"):\n        t.add_line(Comment(Trivia(\"  \", comment=\"test\")))\n    assert len(t) == 0\n\n\ndef test_dicts_are_converted_to_tables_and_keep_order():\n    t = item(\n        {\n            \"foo\": {\n                \"bar\": \"baz\",\n                \"abc\": 123,\n                \"baz\": [{\"c\": 3, \"b\": 2, \"a\": 1}],\n            },\n        }\n    )\n\n    assert (\n        t.as_string()\n        == \"\"\"[foo]\nbar = \"baz\"\nabc = 123\n\n[[foo.baz]]\nc = 3\nb = 2\na = 1\n\"\"\"\n    )\n\n\ndef test_dicts_are_converted_to_tables_and_are_sorted_if_requested():\n    t = item(\n        {\n            \"foo\": {\n                \"bar\": \"baz\",\n                \"abc\": 123,\n                \"baz\": [{\"c\": 3, \"b\": 2, \"a\": 1}],\n            },\n        },\n        _sort_keys=True,\n    )\n\n    assert (\n        t.as_string()\n        == \"\"\"[foo]\nabc = 123\nbar = \"baz\"\n\n[[foo.baz]]\na = 1\nb = 2\nc = 3\n\"\"\"\n    )\n\n\ndef test_dicts_with_sub_dicts_are_properly_converted():\n    t = item(\n        {\"foo\": {\"bar\": {\"string\": \"baz\"}, \"int\": 34, \"float\": 3.14}}, _sort_keys=True\n    )\n\n    assert (\n        t.as_string()\n        == \"\"\"[foo]\nfloat = 3.14\nint = 34\n\n[foo.bar]\nstring = \"baz\"\n\"\"\"\n    )\n\n\ndef test_item_array_of_dicts_converted_to_aot():\n    a = item({\"foo\": [{\"bar\": \"baz\"}]})\n\n    assert (\n        a.as_string()\n        == \"\"\"[[foo]]\nbar = \"baz\"\n\"\"\"\n    )\n\n\ndef test_add_float_to_int():\n    content = \"[table]\\nmy_int = 2043\"\n    doc = parse(content)\n    doc[\"table\"][\"my_int\"] += 5.0\n    assert doc[\"table\"][\"my_int\"] == 2048.0\n    assert isinstance(doc[\"table\"][\"my_int\"], float)\n\n\ndef test_sub_float_from_int():\n    content = \"[table]\\nmy_int = 2048\"\n    doc = parse(content)\n    doc[\"table\"][\"my_int\"] -= 5.0\n    assert doc[\"table\"][\"my_int\"] == 2043.0\n    assert isinstance(doc[\"table\"][\"my_int\"], float)\n\n\ndef test_sub_int_from_float():\n    content = \"[table]\\nmy_int = 2048.0\"\n    doc = parse(content)\n    doc[\"table\"][\"my_int\"] -= 5\n    assert doc[\"table\"][\"my_int\"] == 2043.0\n\n\ndef test_add_sum_int_with_float():\n    content = \"[table]\\nmy_int = 2048.3\"\n    doc = parse(content)\n    doc[\"table\"][\"my_int\"] += 5\n    assert doc[\"table\"][\"my_int\"] == 2053.3\n\n\ndef test_integers_behave_like_ints():\n    i = item(34)\n\n    assert i == 34\n    assert i.as_string() == \"34\"\n\n    i += 1\n    assert i == 35\n    assert i.as_string() == \"35\"\n\n    i -= 2\n    assert i == 33\n    assert i.as_string() == \"33\"\n\n    i /= 2\n    assert i == 16.5\n    assert i.as_string() == \"16.5\"\n\n    doc = parse(\"int = +34\")\n    doc[\"int\"] += 1\n\n    assert doc.as_string() == \"int = +35\"\n\n\ndef test_floats_behave_like_floats():\n    i = item(34.12)\n\n    assert i == 34.12\n    assert i.as_string() == \"34.12\"\n\n    i += 1\n    assert i == 35.12\n    assert i.as_string() == \"35.12\"\n\n    i -= 2\n    assert i == 33.12\n    assert i.as_string() == \"33.12\"\n\n    doc = parse(\"float = +34.12\")\n    doc[\"float\"] += 1\n\n    assert doc.as_string() == \"float = +35.12\"\n\n\ndef test_datetimes_behave_like_datetimes(tz_utc, tz_pst):\n    i = item(datetime(2018, 7, 22, 12, 34, 56))\n\n    assert i == datetime(2018, 7, 22, 12, 34, 56)\n    assert i.as_string() == \"2018-07-22T12:34:56\"\n\n    i += timedelta(days=1)\n    assert i == datetime(2018, 7, 23, 12, 34, 56)\n    assert i.as_string() == \"2018-07-23T12:34:56\"\n\n    i -= timedelta(days=2)\n    assert i == datetime(2018, 7, 21, 12, 34, 56)\n    assert i.as_string() == \"2018-07-21T12:34:56\"\n\n    i = i.replace(year=2019, tzinfo=tz_utc)\n    assert i == datetime(2019, 7, 21, 12, 34, 56, tzinfo=tz_utc)\n    assert i.as_string() == \"2019-07-21T12:34:56+00:00\"\n\n    i = i.astimezone(tz_pst)\n    assert i == datetime(2019, 7, 21, 4, 34, 56, tzinfo=tz_pst)\n    assert i.as_string() == \"2019-07-21T04:34:56-08:00\"\n\n    doc = parse(\"dt = 2018-07-22T12:34:56-05:00\")\n    doc[\"dt\"] += timedelta(days=1)\n\n    assert doc.as_string() == \"dt = 2018-07-23T12:34:56-05:00\"\n\n\ndef test_dates_behave_like_dates():\n    i = item(date(2018, 7, 22))\n\n    assert i == date(2018, 7, 22)\n    assert i.as_string() == \"2018-07-22\"\n\n    i += timedelta(days=1)\n    assert i == date(2018, 7, 23)\n    assert i.as_string() == \"2018-07-23\"\n\n    i -= timedelta(days=2)\n    assert i == date(2018, 7, 21)\n    assert i.as_string() == \"2018-07-21\"\n\n    i = i.replace(year=2019)\n    assert i == date(2019, 7, 21)\n    assert i.as_string() == \"2019-07-21\"\n\n    doc = parse(\"dt = 2018-07-22 # Comment\")\n    doc[\"dt\"] += timedelta(days=1)\n\n    assert doc.as_string() == \"dt = 2018-07-23 # Comment\"\n\n\ndef test_parse_datetime_followed_by_space():\n    # issue #260\n    doc = parse(\"dt = 2018-07-22 \")\n    assert doc[\"dt\"] == date(2018, 7, 22)\n    assert doc.as_string() == \"dt = 2018-07-22 \"\n\n    doc = parse(\"dt = 2013-01-24 13:48:01.123456 \")\n    assert doc[\"dt\"] == datetime(2013, 1, 24, 13, 48, 1, 123456)\n    assert doc.as_string() == \"dt = 2013-01-24 13:48:01.123456 \"\n\n\ndef test_times_behave_like_times():\n    i = item(time(12, 34, 56))\n\n    assert i == time(12, 34, 56)\n    assert i.as_string() == \"12:34:56\"\n\n    i = i.replace(hour=13)\n    assert i == time(13, 34, 56)\n    assert i.as_string() == \"13:34:56\"\n\n\ndef test_strings_behave_like_strs():\n    i = item(\"foo\")\n\n    assert i == \"foo\"\n    assert i.as_string() == '\"foo\"'\n\n    i += \" bar\"\n    assert i == \"foo bar\"\n    assert i.as_string() == '\"foo bar\"'\n\n    i += \" \u00e9\"\n    assert i == \"foo bar \u00e9\"\n    assert i.as_string() == '\"foo bar \u00e9\"'\n\n    doc = parse('str = \"foo\" # Comment')\n    doc[\"str\"] += \" bar\"\n\n    assert doc.as_string() == 'str = \"foo bar\" # Comment'\n\n\ndef test_string_add_preserve_escapes():\n    i = api.value('\"foo\\\\\"bar\"')\n    i += \" baz\"\n\n    assert i == 'foo\"bar baz'\n    assert i.as_string() == '\"foo\\\\\"bar baz\"'\n\n\ndef test_tables_behave_like_dicts():\n    t = item({\"foo\": \"bar\"})\n\n    assert (\n        t.as_string()\n        == \"\"\"foo = \"bar\"\n\"\"\"\n    )\n\n    t.update({\"bar\": \"baz\"})\n\n    assert (\n        t.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"baz\"\n\"\"\"\n    )\n\n    t.update({\"bar\": \"boom\"})\n\n    assert (\n        t.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"boom\"\n\"\"\"\n    )\n\n    assert t.get(\"bar\") == \"boom\"\n    assert t.setdefault(\"foobar\", \"fuzz\") == \"fuzz\"\n    assert (\n        t.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"boom\"\nfoobar = \"fuzz\"\n\"\"\"\n    )\n\n\ndef test_items_are_pickable():\n    n = item(12)\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"12\"\n\n    n = item(12.34)\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"12.34\"\n\n    n = item(True)\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"true\"\n\n    n = item(datetime(2018, 10, 11, 12, 34, 56, 123456))\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"2018-10-11T12:34:56.123456\"\n\n    n = item(date(2018, 10, 11))\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"2018-10-11\"\n\n    n = item(time(12, 34, 56, 123456))\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"12:34:56.123456\"\n\n    n = item([1, 2, 3])\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == \"[1, 2, 3]\"\n\n    n = item({\"foo\": \"bar\"})\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == 'foo = \"bar\"\\n'\n\n    n = api.inline_table()\n    n[\"foo\"] = \"bar\"\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == '{foo = \"bar\"}'\n\n    n = item(\"foo\")\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == '\"foo\"'\n\n    n = item([{\"foo\": \"bar\"}])\n\n    s = pickle.dumps(n)\n    assert pickle.loads(s).as_string() == 'foo = \"bar\"\\n'\n\n\ndef test_trim_comments_when_building_inline_table():\n    table = api.inline_table()\n    row = parse('foo = \"bar\"  # Comment')\n    table.update(row)\n    assert table.as_string() == '{foo = \"bar\"}'\n    value = item(\"foobaz\")\n    value.comment(\"Another comment\")\n    table.append(\"baz\", value)\n    assert \"# Another comment\" not in table.as_string()\n    assert table.as_string() == '{foo = \"bar\", baz = \"foobaz\"}'\n\n\ndef test_deleting_inline_table_element_does_not_leave_trailing_separator():\n    table = api.inline_table()\n    table[\"foo\"] = \"bar\"\n    table[\"baz\"] = \"boom\"\n\n    assert table.as_string() == '{foo = \"bar\", baz = \"boom\"}'\n\n    del table[\"baz\"]\n\n    assert table.as_string() == '{foo = \"bar\"}'\n\n    table = api.inline_table()\n    table[\"foo\"] = \"bar\"\n\n    del table[\"foo\"]\n\n    table[\"baz\"] = \"boom\"\n\n    assert table.as_string() == '{baz = \"boom\"}'\n\n\ndef test_deleting_inline_table_element_does_not_leave_trailing_separator2():\n    doc = parse('a = {foo = \"bar\", baz = \"boom\"}')\n    table = doc[\"a\"]\n    assert table.as_string() == '{foo = \"bar\", baz = \"boom\"}'\n\n    del table[\"baz\"]\n    assert table.as_string() == '{foo = \"bar\" }'\n\n    del table[\"foo\"]\n    assert table.as_string() == \"{ }\"\n\n    table[\"baz\"] = \"boom\"\n\n    assert table.as_string() == '{ baz = \"boom\"}'\n\n\ndef test_booleans_comparison():\n    boolean = Bool(True, Trivia())\n\n    assert boolean\n\n    boolean = Bool(False, Trivia())\n\n    assert not boolean\n\n    s = \"\"\"[foo]\nvalue = false\n\"\"\"\n\n    content = parse(s)\n\n    assert {\"foo\": {\"value\": False}} == content\n    assert {\"value\": False} == content[\"foo\"]\n\n\ndef test_table_copy():\n    table = item({\"foo\": \"bar\"})\n    table_copy = table.copy()\n    assert isinstance(table_copy, Table)\n    table[\"foo\"] = \"baz\"\n    assert table_copy[\"foo\"] == \"bar\"\n    assert table_copy.as_string() == 'foo = \"bar\"\\n'\n\n\ndef test_copy_copy():\n    result = parse(\n        \"\"\"\n    [tool.poetry]\n    classifiers = [\n    # comment\n        \"a\",\n        \"b\",\n    ]\n    \"\"\"\n    )\n    classifiers = result[\"tool\"][\"poetry\"][\"classifiers\"]\n    new = copy.copy(classifiers)\n    assert new == classifiers\n\n\n@pytest.mark.parametrize(\n    \"key_str,escaped\",\n    [(\"\\\\\", '\"\\\\\\\\\"'), ('\"', '\"\\\\\"\"'), (\"\\t\", '\"\\\\t\"'), (\"\\x10\", '\"\\\\u0010\"')],\n)\ndef test_escape_key(key_str, escaped):\n    assert api.key(key_str).as_string() == escaped\n\n\ndef test_custom_encoders():\n    import decimal\n\n    @api.register_encoder\n    def encode_decimal(obj):\n        if isinstance(obj, decimal.Decimal):\n            return api.float_(str(obj))\n        raise TypeError\n\n    assert api.item(decimal.Decimal(\"1.23\")).as_string() == \"1.23\"\n\n    with pytest.raises(TypeError):\n        api.item(object())\n\n    assert api.dumps({\"foo\": decimal.Decimal(\"1.23\")}) == \"foo = 1.23\\n\"\n    api.unregister_encoder(encode_decimal)\n\n\ndef test_no_extra_minus_sign():\n    doc = parse(\"a = -1\")\n    assert doc.as_string() == \"a = -1\"\n    doc[\"a\"] *= -1\n    assert doc.as_string() == \"a = +1\"\n    doc[\"a\"] *= -1\n    assert doc.as_string() == \"a = -1\"\n\n    doc = parse(\"a = -1.5\")\n    assert doc.as_string() == \"a = -1.5\"\n    doc[\"a\"] *= -1\n    assert doc.as_string() == \"a = +1.5\"\n    doc[\"a\"] *= -1\n    assert doc.as_string() == \"a = -1.5\"\n", "tests/test_build.py": "import datetime\n\nfrom tomlkit import aot\nfrom tomlkit import array\nfrom tomlkit import comment\nfrom tomlkit import document\nfrom tomlkit import item\nfrom tomlkit import nl\nfrom tomlkit import parse\nfrom tomlkit import table\nfrom tomlkit._utils import _utc\n\n\ndef test_build_example(example):\n    content = example(\"example\")\n\n    doc = document()\n    doc.add(comment(\"This is a TOML document. Boom.\"))\n    doc.add(nl())\n    doc.add(\"title\", \"TOML Example\")\n\n    owner = table()\n    owner.add(\"name\", \"Tom Preston-Werner\")\n    owner.add(\"organization\", \"GitHub\")\n    owner.add(\"bio\", \"GitHub Cofounder & CEO\\nLikes tater tots and beer.\")\n    owner.add(\"dob\", datetime.datetime(1979, 5, 27, 7, 32, tzinfo=_utc))\n    owner[\"dob\"].comment(\"First class dates? Why not?\")\n\n    doc.add(\"owner\", owner)\n\n    database = table()\n    database[\"server\"] = \"192.168.1.1\"\n    database[\"ports\"] = [8001, 8001, 8002]\n    database[\"connection_max\"] = 5000\n    database[\"enabled\"] = True\n\n    doc[\"database\"] = database\n\n    servers = table()\n    servers.add(nl())\n    c = comment(\n        \"You can indent as you please. Tabs or spaces. TOML don't care.\"\n    ).indent(2)\n    c.trivia.trail = \"\"\n    servers.add(c)\n    alpha = table()\n    servers.append(\"alpha\", alpha)\n    alpha.indent(2)\n    alpha.add(\"ip\", \"10.0.0.1\")\n    alpha.add(\"dc\", \"eqdc10\")\n\n    beta = table()\n    servers.append(\"beta\", beta)\n    beta.add(\"ip\", \"10.0.0.2\")\n    beta.add(\"dc\", \"eqdc10\")\n    beta.add(\"country\", \"\u4e2d\u56fd\")\n    beta[\"country\"].comment(\"This should be parsed as UTF-8\")\n    beta.indent(2)\n\n    doc[\"servers\"] = servers\n\n    clients = table()\n    doc.add(\"clients\", clients)\n    clients[\"data\"] = item([[\"gamma\", \"delta\"], [1, 2]]).comment(\n        \"just an update to make sure parsers support it\"\n    )\n\n    clients.add(nl())\n    clients.add(comment(\"Line breaks are OK when inside arrays\"))\n    clients[\"hosts\"] = array(\n        \"\"\"[\n  \"alpha\",\n  \"omega\"\n]\"\"\"\n    )\n\n    doc.add(nl())\n    doc.add(comment(\"Products\"))\n\n    products = aot()\n    doc[\"products\"] = products\n\n    hammer = table().indent(2)\n    hammer[\"name\"] = \"Hammer\"\n    hammer[\"sku\"] = 738594937\n\n    nail = table().indent(2)\n    nail[\"name\"] = \"Nail\"\n    nail[\"sku\"] = 284758393\n    nail[\"color\"] = \"gray\"\n\n    products.append(hammer)\n    products.append(nail)\n\n    assert content == doc.as_string()\n\n\ndef test_add_remove():\n    content = \"\"\n\n    doc = parse(content)\n    doc.append(\"foo\", \"bar\")\n\n    assert (\n        doc.as_string()\n        == \"\"\"foo = \"bar\"\n\"\"\"\n    )\n\n    doc.remove(\"foo\")\n\n    assert doc.as_string() == \"\"\n\n\ndef test_append_table_after_multiple_indices():\n    content = \"\"\"\n    [packages]\n    foo = \"*\"\n\n    [settings]\n    enable = false\n\n    [packages.bar]\n    version = \"*\"\n    \"\"\"\n    doc = parse(content)\n    doc.append(\"foobar\", {\"name\": \"John\"})\n\n\ndef test_top_level_keys_are_put_at_the_root_of_the_document():\n    doc = document()\n    doc.add(comment(\"Comment\"))\n    doc[\"foo\"] = {\"name\": \"test\"}\n    doc[\"bar\"] = 1\n\n    expected = \"\"\"\\\n# Comment\nbar = 1\n\n[foo]\nname = \"test\"\n\"\"\"\n\n    assert doc.as_string() == expected\n", "tests/conftest.py": "import os\n\nimport pytest\n\n\n@pytest.fixture\ndef example():\n    def _example(name):\n        with open(\n            os.path.join(os.path.dirname(__file__), \"examples\", name + \".toml\"),\n            encoding=\"utf-8\",\n        ) as f:\n            return f.read()\n\n    return _example\n\n\n@pytest.fixture\ndef json_example():\n    def _example(name):\n        with open(\n            os.path.join(os.path.dirname(__file__), \"examples\", \"json\", name + \".json\"),\n            encoding=\"utf-8\",\n        ) as f:\n            return f.read()\n\n    return _example\n\n\n@pytest.fixture\ndef invalid_example():\n    def _example(name):\n        with open(\n            os.path.join(\n                os.path.dirname(__file__), \"examples\", \"invalid\", name + \".toml\"\n            ),\n            encoding=\"utf-8\",\n        ) as f:\n            return f.read()\n\n    return _example\n\n\nTEST_DIR = os.path.join(os.path.dirname(__file__), \"toml-test\", \"tests\")\nIGNORED_TESTS = {\n    \"valid\": [\n        \"float/inf-and-nan\",  # Can't compare nan\n    ]\n}\n\n\ndef get_tomltest_cases():\n    dirs = sorted(\n        f for f in os.listdir(TEST_DIR) if os.path.isdir(os.path.join(TEST_DIR, f))\n    )\n    assert dirs == [\"invalid\", \"valid\"]\n    rv = {\"invalid_encode\": {}}\n    for d in dirs:\n        rv[d] = {}\n        ignored = IGNORED_TESTS.get(d, [])\n\n        for root, _, files in os.walk(os.path.join(TEST_DIR, d)):\n            relpath = os.path.relpath(root, os.path.join(TEST_DIR, d))\n            if relpath == \".\":\n                relpath = \"\"\n            for f in files:\n                try:\n                    bn, ext = f.rsplit(\".\", 1)\n                except ValueError:\n                    bn, ext = f.rsplit(\"-\", 1)\n                key = f\"{relpath}/{bn}\"\n                if ext == \"multi\":\n                    continue\n                if key in ignored:\n                    continue\n                if d == \"invalid\" and relpath == \"encoding\":\n                    rv[\"invalid_encode\"][bn] = os.path.join(root, f)\n                    continue\n                if key not in rv[d]:\n                    rv[d][key] = {}\n                with open(os.path.join(root, f), encoding=\"utf-8\") as inp:\n                    rv[d][key][ext] = inp.read()\n    return rv\n\n\ndef pytest_generate_tests(metafunc):\n    test_list = get_tomltest_cases()\n    if \"valid_case\" in metafunc.fixturenames:\n        metafunc.parametrize(\n            \"valid_case\",\n            test_list[\"valid\"].values(),\n            ids=list(test_list[\"valid\"].keys()),\n        )\n    elif \"invalid_decode_case\" in metafunc.fixturenames:\n        metafunc.parametrize(\n            \"invalid_decode_case\",\n            test_list[\"invalid\"].values(),\n            ids=list(test_list[\"invalid\"].keys()),\n        )\n    elif \"invalid_encode_case\" in metafunc.fixturenames:\n        metafunc.parametrize(\n            \"invalid_encode_case\",\n            test_list[\"invalid_encode\"].values(),\n            ids=list(test_list[\"invalid_encode\"].keys()),\n        )\n", "tests/test_toml_tests.py": "import json\n\nimport pytest\n\nfrom tomlkit import load\nfrom tomlkit import parse\nfrom tomlkit._compat import decode\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.exceptions import TOMLKitError\n\n\ndef to_bool(s):\n    assert s in [\"true\", \"false\"]\n\n    return s == \"true\"\n\n\nstypes = {\n    \"string\": str,\n    \"bool\": to_bool,\n    \"integer\": int,\n    \"float\": float,\n    \"datetime\": parse_rfc3339,\n    \"datetime-local\": parse_rfc3339,\n    \"date-local\": parse_rfc3339,\n    \"time-local\": parse_rfc3339,\n}\n\n\ndef untag(value):\n    if isinstance(value, list):\n        return [untag(i) for i in value]\n    elif \"type\" in value and \"value\" in value and len(value) == 2:\n        if value[\"type\"] in stypes:\n            val = decode(value[\"value\"])\n\n            return stypes[value[\"type\"]](val)\n        elif value[\"type\"] == \"array\":\n            return [untag(i) for i in value[\"value\"]]\n        else:\n            raise Exception(f'Unsupported type {value[\"type\"]}')\n    else:\n        return {k: untag(v) for k, v in value.items()}\n\n\ndef test_valid_decode(valid_case):\n    json_val = untag(json.loads(valid_case[\"json\"]))\n    toml_val = parse(valid_case[\"toml\"])\n\n    assert toml_val == json_val\n    assert toml_val.as_string() == valid_case[\"toml\"]\n\n\ndef test_invalid_decode(invalid_decode_case):\n    with pytest.raises(TOMLKitError):\n        parse(invalid_decode_case[\"toml\"])\n\n\ndef test_invalid_encode(invalid_encode_case):\n    with pytest.raises((TOMLKitError, UnicodeDecodeError)), open(\n        invalid_encode_case, encoding=\"utf-8\"\n    ) as f:\n        load(f)\n", "tests/test_toml_file.py": "import os\n\nfrom tomlkit.toml_document import TOMLDocument\nfrom tomlkit.toml_file import TOMLFile\n\n\ndef test_toml_file(example):\n    original_content = example(\"example\")\n\n    toml_file = os.path.join(os.path.dirname(__file__), \"examples\", \"example.toml\")\n    toml = TOMLFile(toml_file)\n\n    content = toml.read()\n    assert isinstance(content, TOMLDocument)\n    assert content[\"owner\"][\"organization\"] == \"GitHub\"\n\n    toml.write(content)\n\n    try:\n        with open(toml_file, encoding=\"utf-8\") as f:\n            assert original_content == f.read()\n    finally:\n        with open(toml_file, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n            assert f.write(original_content)\n\n\ndef test_keep_old_eol(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    with open(toml_path, \"wb+\") as f:\n        f.write(b\"a = 1\\r\\nb = 2\\r\\n\")\n\n    f = TOMLFile(toml_path)\n    content = f.read()\n    content[\"b\"] = 3\n    f.write(content)\n\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\\r\\nb = 3\\r\\n\"\n\n\ndef test_keep_old_eol_2(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    with open(toml_path, \"wb+\") as f:\n        f.write(b\"a = 1\\nb = 2\\n\")\n\n    f = TOMLFile(toml_path)\n    content = f.read()\n    content[\"b\"] = 3\n    f.write(content)\n\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\\nb = 3\\n\"\n\n\ndef test_mixed_eol(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    with open(toml_path, \"wb+\") as f:\n        f.write(b\"a = 1\\r\\nrb = 2\\n\")\n\n    f = TOMLFile(toml_path)\n    f.write(f.read())\n\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\\r\\nrb = 2\\n\"\n\n\ndef test_consistent_eol(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    with open(toml_path, \"wb+\") as f:\n        f.write(b\"a = 1\\r\\nb = 2\\r\\n\")\n\n    f = TOMLFile(toml_path)\n    content = f.read()\n    content[\"c\"] = 3\n    f.write(content)\n\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\\r\\nb = 2\\r\\nc = 3\\r\\n\"\n\n\ndef test_consistent_eol_2(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    with open(toml_path, \"wb+\") as f:\n        f.write(b\"a = 1\\nb = 2\\n\")\n\n    f = TOMLFile(toml_path)\n    content = f.read()\n    content[\"c\"] = 3\n    content[\"c\"].trivia.trail = \"\\r\\n\"\n    f.write(content)\n\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\\nb = 2\\nc = 3\\n\"\n\n\ndef test_default_eol_is_os_linesep(tmpdir):\n    toml_path = str(tmpdir / \"pyproject.toml\")\n    f = TOMLFile(toml_path)\n    content = TOMLDocument()\n    content.append(\"a\", 1)\n    content[\"a\"].trivia.trail = \"\\n\"\n    content.append(\"b\", 2)\n    content[\"b\"].trivia.trail = \"\\r\\n\"\n    f.write(content)\n    linesep = os.linesep.encode()\n    with open(toml_path, \"rb\") as f:\n        assert f.read() == b\"a = 1\" + linesep + b\"b = 2\" + linesep\n", "tests/test_api.py": "import io\nimport json\nimport os\n\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom types import MappingProxyType\n\nimport pytest\n\nimport tomlkit\n\nfrom tomlkit import dump\nfrom tomlkit import dumps\nfrom tomlkit import load\nfrom tomlkit import loads\nfrom tomlkit import parse\nfrom tomlkit.exceptions import InvalidCharInStringError\nfrom tomlkit.exceptions import InvalidControlChar\nfrom tomlkit.exceptions import InvalidDateError\nfrom tomlkit.exceptions import InvalidDateTimeError\nfrom tomlkit.exceptions import InvalidNumberError\nfrom tomlkit.exceptions import InvalidStringError\nfrom tomlkit.exceptions import InvalidTimeError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Key\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.toml_document import TOMLDocument\n\n\ndef json_serial(obj):\n    \"\"\"JSON serializer for objects not serializable by default json code\"\"\"\n    if isinstance(obj, (datetime, date, time)):\n        return obj.isoformat()\n\n    raise TypeError(f\"Type {type(obj)} not serializable\")\n\n\n@pytest.mark.parametrize(\n    \"example_name\",\n    [\n        \"example\",\n        \"fruit\",\n        \"hard\",\n        \"sections_with_same_start\",\n        \"pyproject\",\n        \"0.5.0\",\n        \"test\",\n        \"newline_in_strings\",\n        \"preserve_quotes_in_string\",\n        \"string_slash_whitespace_newline\",\n        \"table_names\",\n    ],\n)\ndef test_parse_can_parse_valid_toml_files(example, example_name):\n    assert isinstance(parse(example(example_name)), TOMLDocument)\n    assert isinstance(loads(example(example_name)), TOMLDocument)\n\n\n@pytest.mark.parametrize(\n    \"example_name\",\n    [\n        \"example\",\n        \"fruit\",\n        \"hard\",\n        \"sections_with_same_start\",\n        \"pyproject\",\n        \"0.5.0\",\n        \"test\",\n        \"newline_in_strings\",\n        \"preserve_quotes_in_string\",\n        \"string_slash_whitespace_newline\",\n        \"table_names\",\n    ],\n)\ndef test_load_from_file_object(example_name):\n    with open(\n        os.path.join(os.path.dirname(__file__), \"examples\", example_name + \".toml\"),\n        encoding=\"utf-8\",\n    ) as fp:\n        assert isinstance(load(fp), TOMLDocument)\n\n\n@pytest.mark.parametrize(\"example_name\", [\"0.5.0\", \"pyproject\", \"table_names\"])\ndef test_parsed_document_are_properly_json_representable(\n    example, json_example, example_name\n):\n    doc = json.loads(json.dumps(parse(example(example_name)), default=json_serial))\n    json_doc = json.loads(json_example(example_name))\n\n    assert doc == json_doc\n\n\n@pytest.mark.parametrize(\n    \"example_name,error\",\n    [\n        (\"section_with_trailing_characters\", UnexpectedCharError),\n        (\"key_value_with_trailing_chars\", UnexpectedCharError),\n        (\"array_with_invalid_chars\", UnexpectedCharError),\n        (\"invalid_number\", InvalidNumberError),\n        (\"invalid_date\", InvalidDateError),\n        (\"invalid_time\", InvalidTimeError),\n        (\"invalid_datetime\", InvalidDateTimeError),\n        (\"trailing_comma\", UnexpectedCharError),\n        (\"newline_in_singleline_string\", InvalidControlChar),\n        (\"string_slash_whitespace_char\", InvalidCharInStringError),\n        (\"array_no_comma\", UnexpectedCharError),\n        (\"array_duplicate_comma\", UnexpectedCharError),\n        (\"array_leading_comma\", UnexpectedCharError),\n        (\"inline_table_no_comma\", UnexpectedCharError),\n        (\"inline_table_duplicate_comma\", UnexpectedCharError),\n        (\"inline_table_leading_comma\", UnexpectedCharError),\n        (\"inline_table_trailing_comma\", UnexpectedCharError),\n    ],\n)\ndef test_parse_raises_errors_for_invalid_toml_files(\n    invalid_example, error, example_name\n):\n    with pytest.raises(error):\n        parse(invalid_example(example_name))\n\n\n@pytest.mark.parametrize(\n    \"example_name\",\n    [\n        \"example\",\n        \"fruit\",\n        \"hard\",\n        \"sections_with_same_start\",\n        \"pyproject\",\n        \"0.5.0\",\n        \"test\",\n        \"table_names\",\n    ],\n)\ndef test_original_string_and_dumped_string_are_equal(example, example_name):\n    content = example(example_name)\n    parsed = parse(content)\n\n    assert content == dumps(parsed)\n\n\ndef test_a_raw_dict_can_be_dumped():\n    s = dumps({\"foo\": \"bar\"})\n\n    assert s == 'foo = \"bar\"\\n'\n\n\ndef test_mapping_types_can_be_dumped():\n    x = MappingProxyType({\"foo\": \"bar\"})\n    assert dumps(x) == 'foo = \"bar\"\\n'\n\n\ndef test_dumps_weird_object():\n    with pytest.raises(TypeError):\n        dumps(object())\n\n\ndef test_dump_tuple_value_as_array():\n    x = {\"foo\": (1, 2)}\n    assert dumps(x) == \"foo = [1, 2]\\n\"\n\n    x = {\"foo\": ({\"a\": 1}, {\"a\": 2})}\n    assert dumps(x) == \"[[foo]]\\na = 1\\n\\n[[foo]]\\na = 2\\n\"\n\n\ndef test_dump_to_file_object():\n    doc = {\"foo\": \"bar\"}\n    fp = io.StringIO()\n    dump(doc, fp)\n    assert fp.getvalue() == 'foo = \"bar\"\\n'\n\n\ndef test_integer():\n    i = tomlkit.integer(\"34\")\n\n    assert isinstance(i, Integer)\n\n\ndef test_float():\n    i = tomlkit.float_(\"34.56\")\n\n    assert isinstance(i, Float)\n\n\ndef test_boolean():\n    i = tomlkit.boolean(\"true\")\n\n    assert isinstance(i, Bool)\n\n\ndef test_date():\n    dt = tomlkit.date(\"1979-05-13\")\n\n    assert isinstance(dt, Date)\n\n    with pytest.raises(ValueError):\n        tomlkit.date(\"12:34:56\")\n\n\ndef test_time():\n    dt = tomlkit.time(\"12:34:56\")\n\n    assert isinstance(dt, Time)\n\n    with pytest.raises(ValueError):\n        tomlkit.time(\"1979-05-13\")\n\n\ndef test_datetime():\n    dt = tomlkit.datetime(\"1979-05-13T12:34:56\")\n\n    assert isinstance(dt, DateTime)\n\n    with pytest.raises(ValueError):\n        tomlkit.time(\"1979-05-13\")\n\n\ndef test_array():\n    a = tomlkit.array()\n\n    assert isinstance(a, Array)\n\n    a = tomlkit.array(\"[1,2, 3]\")\n\n    assert isinstance(a, Array)\n\n\ndef test_table():\n    t = tomlkit.table()\n\n    assert isinstance(t, Table)\n\n\ndef test_inline_table():\n    t = tomlkit.inline_table()\n\n    assert isinstance(t, InlineTable)\n\n\ndef test_aot():\n    t = tomlkit.aot()\n\n    assert isinstance(t, AoT)\n\n\ndef test_key():\n    k = tomlkit.key(\"foo\")\n\n    assert isinstance(k, Key)\n\n\ndef test_key_value():\n    k, i = tomlkit.key_value(\"foo = 12\")\n\n    assert isinstance(k, Key)\n    assert isinstance(i, Integer)\n\n\ndef test_string():\n    s = tomlkit.string('foo \"')\n\n    assert s.value == 'foo \"'\n    assert s.as_string() == '\"foo \\\\\"\"'\n\n\ndef test_item_dict_to_table():\n    t = tomlkit.item({\"foo\": {\"bar\": \"baz\"}})\n\n    assert t.value == {\"foo\": {\"bar\": \"baz\"}}\n    assert (\n        t.as_string()\n        == \"\"\"[foo]\nbar = \"baz\"\n\"\"\"\n    )\n\n\ndef test_item_mixed_aray():\n    example = [{\"a\": 3}, \"b\", 42]\n    expected = '[{a = 3}, \"b\", 42]'\n    t = tomlkit.item(example)\n    assert t.as_string().strip() == expected\n    assert dumps({\"x\": {\"y\": example}}).strip() == \"[x]\\ny = \" + expected\n\n\ndef test_build_super_table():\n    doc = tomlkit.document()\n    table = tomlkit.table(True)\n    table.add(\"bar\", {\"x\": 1})\n    doc.add(\"foo\", table)\n    assert doc.as_string() == \"[foo.bar]\\nx = 1\\n\"\n\n\ndef test_add_dotted_key():\n    doc = tomlkit.document()\n    doc.add(tomlkit.key([\"foo\", \"bar\"]), 1)\n    assert doc.as_string() == \"foo.bar = 1\\n\"\n\n    table = tomlkit.table()\n    table.add(tomlkit.key([\"foo\", \"bar\"]), 1)\n    assert table.as_string() == \"foo.bar = 1\\n\"\n\n\n@pytest.mark.parametrize(\n    (\"raw\", \"expected\"),\n    [\n        (\"true\", True),\n        (\"false\", False),\n    ],\n)\ndef test_value_parses_boolean(raw, expected):\n    parsed = tomlkit.value(raw)\n    assert parsed == expected\n\n\n@pytest.mark.parametrize(\n    \"raw\", [\"t\", \"f\", \"tru\", \"fals\", \"test\", \"friend\", \"truthy\", \"falsify\"]\n)\ndef test_value_rejects_values_looking_like_bool_at_start(raw):\n    \"\"\"Reproduces https://github.com/sdispater/tomlkit/issues/165\"\"\"\n    with pytest.raises(tomlkit.exceptions.ParseError):\n        tomlkit.value(raw)\n\n\n@pytest.mark.parametrize(\n    \"raw\",\n    [\n        \"truee\",\n        \"truely\",\n        \"true-thoughts\",\n        \"true_hip_hop\",\n    ],\n)\ndef test_value_rejects_values_having_true_prefix(raw):\n    \"\"\"Values that have ``true`` or ``false`` as prefix but then have additional chars are rejected.\"\"\"\n    with pytest.raises(tomlkit.exceptions.ParseError):\n        tomlkit.value(raw)\n\n\n@pytest.mark.parametrize(\n    \"raw\",\n    [\n        \"falsee\",\n        \"falsely\",\n        \"false-ideas\",\n        \"false_prophet\",\n    ],\n)\ndef test_value_rejects_values_having_false_prefix(raw):\n    \"\"\"Values that have ``true`` or ``false`` as prefix but then have additional chars are rejected.\"\"\"\n    with pytest.raises(tomlkit.exceptions.ParseError):\n        tomlkit.value(raw)\n\n\n@pytest.mark.parametrize(\n    \"raw\",\n    [\n        '\"foo\"1.2',\n        \"truefalse\",\n        \"1.0false\",\n        \"100true\",\n        \"truetrue\",\n        \"falsefalse\",\n        \"1.2.3.4\",\n        \"[][]\",\n        \"{a=[][]}[]\",\n        \"true[]\",\n        \"false{a=1}\",\n    ],\n)\ndef test_value_rejects_values_with_appendage(raw):\n    \"\"\"Values that appear valid at the beginning but leave chars unparsed are rejected.\"\"\"\n    with pytest.raises(tomlkit.exceptions.ParseError):\n        tomlkit.value(raw)\n\n\ndef test_create_super_table_with_table():\n    data = {\"foo\": {\"bar\": {\"a\": 1}}}\n    assert dumps(data) == \"[foo.bar]\\na = 1\\n\"\n\n\ndef test_create_super_table_with_aot():\n    data = {\"foo\": {\"bar\": [{\"a\": 1}]}}\n    assert dumps(data) == \"[[foo.bar]]\\na = 1\\n\"\n\n\n@pytest.mark.parametrize(\n    \"kwargs, example, expected\",\n    [\n        ({}, \"My\\nString\", '\"My\\\\nString\"'),\n        ({\"escape\": False}, \"My String\\t\", '\"My String\\t\"'),\n        ({\"literal\": True}, \"My String\\t\", \"'My String\\t'\"),\n        ({\"escape\": True, \"literal\": True}, \"My String\\t\", \"'My String\\t'\"),\n        ({}, \"My String\\u0001\", '\"My String\\\\u0001\"'),\n        ({}, \"My String\\u000b\", '\"My String\\\\u000b\"'),\n        ({}, \"My String\\x08\", '\"My String\\\\b\"'),\n        ({}, \"My String\\x0c\", '\"My String\\\\f\"'),\n        ({}, \"My String\\x01\", '\"My String\\\\u0001\"'),\n        ({}, \"My String\\x06\", '\"My String\\\\u0006\"'),\n        ({}, \"My String\\x12\", '\"My String\\\\u0012\"'),\n        ({}, \"My String\\x7f\", '\"My String\\\\u007f\"'),\n        ({\"escape\": False}, \"My String\\u0001\", '\"My String\\u0001\"'),\n        ({\"multiline\": True}, \"\\nMy\\nString\\n\", '\"\"\"\\nMy\\nString\\n\"\"\"'),\n        ({\"multiline\": True}, 'My\"String', '\"\"\"My\"String\"\"\"'),\n        ({\"multiline\": True}, 'My\"\"String', '\"\"\"My\"\"String\"\"\"'),\n        ({\"multiline\": True}, 'My\"\"\"String', '\"\"\"My\"\"\\\\\"String\"\"\"'),\n        ({\"multiline\": True}, 'My\"\"\"\"String', '\"\"\"My\"\"\\\\\"\"String\"\"\"'),\n        (\n            {\"multiline\": True},\n            '\"\"\"My\"\"\"Str\"\"\"ing\"\"\"',\n            '\"\"\"\"\"\\\\\"My\"\"\\\\\"Str\"\"\\\\\"ing\"\"\\\\\"\"\"\"',\n        ),\n        ({\"multiline\": True, \"literal\": True}, \"My\\nString\", \"'''My\\nString'''\"),\n        ({\"multiline\": True, \"literal\": True}, \"My'String\", \"'''My'String'''\"),\n        ({\"multiline\": True, \"literal\": True}, \"My\\r\\nString\", \"'''My\\r\\nString'''\"),\n        (\n            {\"literal\": True},\n            r\"C:\\Users\\nodejs\\templates\",\n            r\"'C:\\Users\\nodejs\\templates'\",\n        ),\n        ({\"literal\": True}, r\"<\\i\\c*\\s*>\", r\"'<\\i\\c*\\s*>'\"),\n        (\n            {\"multiline\": True, \"literal\": True},\n            r\"I [dw]on't need \\d{2} apples\",\n            r\"'''I [dw]on't need \\d{2} apples'''\",\n        ),\n    ],\n)\ndef test_create_string(kwargs, example, expected):\n    value = tomlkit.string(example, **kwargs)\n    assert value.as_string() == expected\n\n\n@pytest.mark.parametrize(\n    \"kwargs, example\",\n    [\n        ({\"literal\": True}, \"My'String\"),\n        ({\"literal\": True}, \"My\\nString\"),\n        ({\"literal\": True}, \"My\\r\\nString\"),\n        ({\"literal\": True}, \"My\\bString\"),\n        ({\"literal\": True}, \"My\\x08String\"),\n        ({\"literal\": True}, \"My\\x0cString\"),\n        ({\"literal\": True}, \"My\\x7fString\"),\n        ({\"multiline\": True, \"literal\": True}, \"My'''String\"),\n    ],\n)\ndef test_create_string_with_invalid_characters(kwargs, example):\n    with pytest.raises(InvalidStringError):\n        tomlkit.string(example, **kwargs)\n\n\ndef test_parse_empty_quoted_table_name():\n    content = \"['']\\nx = 1\\n\"\n    parsed = loads(content)\n    assert parsed == {\"\": {\"x\": 1}}\n    assert dumps(parsed) == content\n", "tests/__init__.py": "", "tests/test_toml_document.py": "import copy\nimport json\nimport pickle\n\nfrom datetime import datetime\nfrom textwrap import dedent\n\nimport pytest\n\nimport tomlkit\n\nfrom tests.util import assert_is_ppo\nfrom tomlkit import parse\nfrom tomlkit import ws\nfrom tomlkit._utils import _utc\nfrom tomlkit.api import document\nfrom tomlkit.exceptions import NonExistentKey\n\n\ndef test_document_is_a_dict(example):\n    content = example(\"example\")\n\n    doc = parse(content)\n\n    assert isinstance(doc, dict)\n    assert \"owner\" in doc\n\n    # owner\n    owner = doc[\"owner\"]\n    assert doc.get(\"owner\") == owner\n    assert isinstance(owner, dict)\n    assert \"name\" in owner\n    assert owner[\"name\"] == \"Tom Preston-Werner\"\n    assert owner[\"organization\"] == \"GitHub\"\n    assert owner[\"bio\"] == \"GitHub Cofounder & CEO\\nLikes tater tots and beer.\"\n    assert owner[\"dob\"] == datetime(1979, 5, 27, 7, 32, tzinfo=_utc)\n\n    # database\n    database = doc[\"database\"]\n    assert isinstance(database, dict)\n    assert database[\"server\"] == \"192.168.1.1\"\n    assert database[\"ports\"] == [8001, 8001, 8002]\n    assert database[\"connection_max\"] == 5000\n    assert database[\"enabled\"] is True\n\n    # servers\n    servers = doc[\"servers\"]\n    assert isinstance(servers, dict)\n\n    alpha = servers[\"alpha\"]\n    assert servers.get(\"alpha\") == alpha\n    assert isinstance(alpha, dict)\n    assert alpha[\"ip\"] == \"10.0.0.1\"\n    assert alpha[\"dc\"] == \"eqdc10\"\n\n    beta = servers[\"beta\"]\n    assert isinstance(beta, dict)\n    assert beta[\"ip\"] == \"10.0.0.2\"\n    assert beta[\"dc\"] == \"eqdc10\"\n    assert beta[\"country\"] == \"\u4e2d\u56fd\"\n\n    # clients\n    clients = doc[\"clients\"]\n    assert isinstance(clients, dict)\n\n    data = clients[\"data\"]\n    assert isinstance(data, list)\n    assert data[0] == [\"gamma\", \"delta\"]\n    assert data[1] == [1, 2]\n\n    assert clients[\"hosts\"] == [\"alpha\", \"omega\"]\n\n    # Products\n    products = doc[\"products\"]\n    assert isinstance(products, list)\n\n    hammer = products[0]\n    assert hammer == {\"name\": \"Hammer\", \"sku\": 738594937}\n\n    nail = products[1]\n    assert nail[\"name\"] == \"Nail\"\n    assert nail[\"sku\"] == 284758393\n    assert nail[\"color\"] == \"gray\"\n\n    nail[\"color\"] = \"black\"\n    assert nail[\"color\"] == \"black\"\n    assert doc[\"products\"][1][\"color\"] == \"black\"\n    assert nail.get(\"color\") == \"black\"\n\n    content = \"\"\"foo = \"bar\"\n\"\"\"\n\n    doc = parse(content)\n    doc.update({\"bar\": \"baz\"})\n\n    assert (\n        doc.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"baz\"\n\"\"\"\n    )\n\n    doc.update({\"bar\": \"boom\"})\n\n    assert (\n        doc.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"boom\"\n\"\"\"\n    )\n\n    assert doc.setdefault(\"bar\", \"waldo\") == \"boom\"\n\n    assert (\n        doc.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"boom\"\n\"\"\"\n    )\n\n    assert doc.setdefault(\"thud\", \"waldo\") == \"waldo\"\n\n    assert (\n        doc.as_string()\n        == \"\"\"foo = \"bar\"\nbar = \"boom\"\nthud = \"waldo\"\n\"\"\"\n    )\n\n\ndef test_toml_document_without_super_tables():\n    content = \"\"\"[tool.poetry]\nname = \"foo\"\n\"\"\"\n\n    doc = parse(content)\n    assert \"tool\" in doc\n    assert \"poetry\" in doc[\"tool\"]\n\n    assert doc[\"tool\"][\"poetry\"][\"name\"] == \"foo\"\n\n    doc[\"tool\"][\"poetry\"][\"name\"] = \"bar\"\n\n    assert (\n        doc.as_string()\n        == \"\"\"[tool.poetry]\nname = \"bar\"\n\"\"\"\n    )\n\n    d = {}\n    d.update(doc)\n\n    assert \"tool\" in d\n\n\ndef test_toml_document_unwrap():\n    content = \"\"\"[tool.poetry]\nname = \"foo\"\n\"\"\"\n\n    doc = parse(content)\n    unwrapped = doc.unwrap()\n    assert_is_ppo(unwrapped, dict)\n    assert_is_ppo(next(iter(unwrapped)), str)\n    assert_is_ppo(unwrapped[\"tool\"], dict)\n    assert_is_ppo(next(iter(unwrapped[\"tool\"])), str)\n    assert_is_ppo(unwrapped[\"tool\"][\"poetry\"][\"name\"], str)\n\n\ndef test_toml_document_with_dotted_keys(example):\n    content = example(\"0.5.0\")\n\n    doc = parse(content)\n\n    assert \"physical\" in doc\n    assert \"color\" in doc[\"physical\"]\n    assert \"shape\" in doc[\"physical\"]\n    assert doc[\"physical\"][\"color\"] == \"orange\"\n    assert doc[\"physical\"][\"shape\"] == \"round\"\n\n    assert \"site\" in doc\n    assert \"google.com\" in doc[\"site\"]\n    assert doc[\"site\"][\"google.com\"]\n\n    assert doc[\"a\"][\"b\"][\"c\"] == 1\n    assert doc[\"a\"][\"b\"][\"d\"] == 2\n\n\ndef test_toml_document_super_table_with_different_sub_sections(example):\n    content = example(\"pyproject\")\n\n    doc = parse(content)\n    tool = doc[\"tool\"]\n\n    assert \"poetry\" in tool\n    assert \"black\" in tool\n\n\ndef test_adding_an_element_to_existing_table_with_ws_remove_ws():\n    content = \"\"\"[foo]\n\n[foo.bar]\n\n\"\"\"\n\n    doc = parse(content)\n    doc[\"foo\"][\"int\"] = 34\n\n    expected = \"\"\"[foo]\nint = 34\n\n[foo.bar]\n\n\"\"\"\n\n    assert expected == doc.as_string()\n\n\ndef test_document_with_aot_after_sub_tables():\n    content = \"\"\"[foo.bar]\nname = \"Bar\"\n\n[foo.bar.baz]\nname = \"Baz\"\n\n[[foo.bar.tests]]\nname = \"Test 1\"\n\"\"\"\n\n    doc = parse(content)\n    assert doc[\"foo\"][\"bar\"][\"tests\"][0][\"name\"] == \"Test 1\"\n\n\ndef test_document_with_new_sub_table_after_other_table():\n    content = \"\"\"[foo]\nname = \"Bar\"\n\n[bar]\nname = \"Baz\"\n\n[foo.baz]\nname = \"Test 1\"\n\"\"\"\n\n    doc = parse(content)\n    assert doc[\"foo\"][\"name\"] == \"Bar\"\n    assert doc[\"bar\"][\"name\"] == \"Baz\"\n    assert doc[\"foo\"][\"baz\"][\"name\"] == \"Test 1\"\n\n    assert doc.as_string() == content\n\n\ndef test_document_with_new_sub_table_after_other_table_delete():\n    content = \"\"\"[foo]\nname = \"Bar\"\n\n[bar]\nname = \"Baz\"\n\n[foo.baz]\nname = \"Test 1\"\n\"\"\"\n\n    doc = parse(content)\n\n    del doc[\"foo\"]\n\n    assert (\n        doc.as_string()\n        == \"\"\"[bar]\nname = \"Baz\"\n\n\"\"\"\n    )\n\n\ndef test_document_with_new_sub_table_after_other_table_replace():\n    content = \"\"\"[foo]\nname = \"Bar\"\n\n[bar]\nname = \"Baz\"\n\n[foo.baz]\nname = \"Test 1\"\n\"\"\"\n\n    doc = parse(content)\n\n    doc[\"foo\"] = {\"a\": \"b\"}\n\n    assert (\n        doc.as_string()\n        == \"\"\"[foo]\na = \"b\"\n\n[bar]\nname = \"Baz\"\n\n\"\"\"\n    )\n\n\ndef test_inserting_after_element_with_no_new_line_adds_a_new_line():\n    doc = parse(\"foo = 10\")\n    doc[\"bar\"] = 11\n\n    expected = \"\"\"foo = 10\nbar = 11\n\"\"\"\n\n    assert expected == doc.as_string()\n\n    doc = parse(\"# Comment\")\n    doc[\"bar\"] = 11\n\n    expected = \"\"\"# Comment\nbar = 11\n\"\"\"\n\n    assert expected == doc.as_string()\n\n\ndef test_inserting_after_deletion():\n    doc = parse(\"foo = 10\\n\")\n    del doc[\"foo\"]\n\n    doc[\"bar\"] = 11\n\n    expected = \"\"\"bar = 11\n\"\"\"\n\n    assert expected == doc.as_string()\n\n\ndef test_toml_document_with_dotted_keys_inside_table(example):\n    content = example(\"0.5.0\")\n\n    doc = parse(content)\n    t = doc[\"table\"]\n\n    assert \"a\" in t\n\n    assert t[\"a\"][\"b\"][\"c\"] == 1\n    assert t[\"a\"][\"b\"][\"d\"] == 2\n    assert t[\"a\"][\"c\"] == 3\n\n\ndef test_toml_document_with_super_aot_after_super_table(example):\n    content = example(\"pyproject\")\n\n    doc = parse(content)\n    aot = doc[\"tool\"][\"foo\"]\n\n    assert isinstance(aot, list)\n\n    first = aot[0]\n    assert first[\"name\"] == \"first\"\n\n    second = aot[1]\n    assert second[\"name\"] == \"second\"\n\n\ndef test_toml_document_has_always_a_new_line_after_table_header():\n    content = \"\"\"[section.sub]\"\"\"\n\n    doc = parse(content)\n    assert doc.as_string() == \"\"\"[section.sub]\"\"\"\n\n    doc[\"section\"][\"sub\"][\"foo\"] = \"bar\"\n    assert (\n        doc.as_string()\n        == \"\"\"[section.sub]\nfoo = \"bar\"\n\"\"\"\n    )\n\n    del doc[\"section\"][\"sub\"][\"foo\"]\n\n    assert doc.as_string() == \"\"\"[section.sub]\"\"\"\n\n\ndef test_toml_document_is_pickable(example):\n    content = example(\"example\")\n\n    doc = parse(content)\n    assert pickle.loads(pickle.dumps(doc)).as_string() == content\n\n\ndef test_toml_document_set_super_table_element():\n    content = \"\"\"[site.user]\nname = \"John\"\n\"\"\"\n\n    doc = parse(content)\n    doc[\"site\"][\"user\"] = \"Tom\"\n\n    assert (\n        doc.as_string()\n        == \"\"\"[site]\nuser = \"Tom\"\n\"\"\"\n    )\n\n\ndef test_toml_document_can_be_copied():\n    content = \"[foo]\\nbar=1\"\n\n    doc = parse(content)\n    doc = copy.copy(doc)\n\n    assert (\n        doc.as_string()\n        == \"\"\"[foo]\nbar=1\"\"\"\n    )\n\n    assert doc == {\"foo\": {\"bar\": 1}}\n    assert doc[\"foo\"][\"bar\"] == 1\n    assert json.loads(json.dumps(doc)) == {\"foo\": {\"bar\": 1}}\n\n    doc = parse(content)\n    doc = doc.copy()\n\n    assert (\n        doc.as_string()\n        == \"\"\"[foo]\nbar=1\"\"\"\n    )\n\n    assert doc == {\"foo\": {\"bar\": 1}}\n    assert doc[\"foo\"][\"bar\"] == 1\n    assert json.loads(json.dumps(doc)) == {\"foo\": {\"bar\": 1}}\n\n\ndef test_getting_inline_table_is_still_an_inline_table():\n    content = \"\"\"\\\n[tool.poetry]\nname = \"foo\"\n\n[tool.poetry.dependencies]\n\n[tool.poetry.dev-dependencies]\n\"\"\"\n\n    doc = parse(content)\n    poetry_section = doc[\"tool\"][\"poetry\"]\n    dependencies = poetry_section[\"dependencies\"]\n    dependencies[\"foo\"] = tomlkit.inline_table()\n    dependencies[\"foo\"][\"version\"] = \"^2.0\"\n    dependencies[\"foo\"][\"source\"] = \"local\"\n    dependencies[\"bar\"] = tomlkit.inline_table()\n    dependencies[\"bar\"][\"version\"] = \"^3.0\"\n    dependencies[\"bar\"][\"source\"] = \"remote\"\n    dev_dependencies = poetry_section[\"dev-dependencies\"]\n    dev_dependencies[\"baz\"] = tomlkit.inline_table()\n    dev_dependencies[\"baz\"][\"version\"] = \"^4.0\"\n    dev_dependencies[\"baz\"][\"source\"] = \"other\"\n\n    assert (\n        doc.as_string()\n        == \"\"\"\\\n[tool.poetry]\nname = \"foo\"\n\n[tool.poetry.dependencies]\nfoo = {version = \"^2.0\", source = \"local\"}\nbar = {version = \"^3.0\", source = \"remote\"}\n\n[tool.poetry.dev-dependencies]\nbaz = {version = \"^4.0\", source = \"other\"}\n\"\"\"\n    )\n\n\ndef test_declare_sub_table_with_intermediate_table():\n    content = \"\"\"\n[students]\ntommy = 87\nmary = 66\n\n[subjects]\nmaths = \"maths\"\nenglish = \"english\"\n\n[students.bob]\nscore = 91\n\"\"\"\n\n    doc = parse(content)\n    assert {\"tommy\": 87, \"mary\": 66, \"bob\": {\"score\": 91}} == doc[\"students\"]\n    assert {\"tommy\": 87, \"mary\": 66, \"bob\": {\"score\": 91}} == doc.get(\"students\")\n\n\ndef test_values_can_still_be_set_for_out_of_order_tables():\n    content = \"\"\"\n[a.a]\nkey = \"value\"\n\n[a.b]\n\n[a.a.c]\n\"\"\"\n\n    doc = parse(content)\n    doc[\"a\"][\"a\"][\"key\"] = \"new_value\"\n\n    assert doc[\"a\"][\"a\"][\"key\"] == \"new_value\"\n\n    expected = \"\"\"\n[a.a]\nkey = \"new_value\"\n\n[a.b]\n\n[a.a.c]\n\"\"\"\n\n    assert expected == doc.as_string()\n\n    doc[\"a\"][\"a\"][\"bar\"] = \"baz\"\n\n    expected = \"\"\"\n[a.a]\nkey = \"new_value\"\nbar = \"baz\"\n\n[a.b]\n\n[a.a.c]\n\"\"\"\n\n    assert expected == doc.as_string()\n\n    del doc[\"a\"][\"a\"][\"key\"]\n\n    expected = \"\"\"\n[a.a]\nbar = \"baz\"\n\n[a.b]\n\n[a.a.c]\n\"\"\"\n\n    assert expected == doc.as_string()\n\n    with pytest.raises(NonExistentKey):\n        doc[\"a\"][\"a\"][\"key\"]\n\n    with pytest.raises(NonExistentKey):\n        del doc[\"a\"][\"a\"][\"key\"]\n\n\ndef test_out_of_order_table_can_add_multiple_tables():\n    content = \"\"\"\\\n[a.a.b]\nx = 1\n[foo]\nbar = 1\n[a.a.c]\ny = 1\n[a.a.d]\nz = 1\n\"\"\"\n    doc = parse(content)\n    assert doc.as_string() == content\n    assert doc[\"a\"][\"a\"] == {\"b\": {\"x\": 1}, \"c\": {\"y\": 1}, \"d\": {\"z\": 1}}\n\n\ndef test_out_of_order_tables_are_still_dicts():\n    content = \"\"\"\n[a.a]\nkey = \"value\"\n\n[a.b]\n\n[a.a.c]\n\"\"\"\n\n    doc = parse(content)\n    assert isinstance(doc[\"a\"], dict)\n    assert isinstance(doc[\"a\"][\"a\"], dict)\n\n    table = doc[\"a\"][\"a\"]\n    assert \"key\" in table\n    assert \"c\" in table\n    assert table.get(\"key\") == \"value\"\n    assert {} == table.get(\"c\")\n    assert table.get(\"d\") is None\n    assert table.get(\"d\", \"foo\") == \"foo\"\n\n    assert table.setdefault(\"d\", \"bar\") == \"bar\"\n    assert table[\"d\"] == \"bar\"\n\n    assert table.pop(\"key\") == \"value\"\n    assert \"key\" not in table\n\n    assert table.pop(\"missing\", default=\"baz\") == \"baz\"\n\n    with pytest.raises(KeyError):\n        table.pop(\"missing\")\n\n\ndef test_string_output_order_is_preserved_for_out_of_order_tables():\n    content = \"\"\"\n[tool.poetry]\nname = \"foo\"\n\n[tool.poetry.dependencies]\npython = \"^3.6\"\nbar = \"^1.0\"\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbackend = \"poetry.core.masonry.api\"\n\n\n[tool.other]\na = \"b\"\n\"\"\"\n\n    doc = parse(content)\n    constraint = tomlkit.inline_table()\n    constraint[\"version\"] = \"^1.0\"\n    doc[\"tool\"][\"poetry\"][\"dependencies\"][\"bar\"] = constraint\n\n    assert doc[\"tool\"][\"poetry\"][\"dependencies\"][\"bar\"][\"version\"] == \"^1.0\"\n\n    expected = \"\"\"\n[tool.poetry]\nname = \"foo\"\n\n[tool.poetry.dependencies]\npython = \"^3.6\"\nbar = {version = \"^1.0\"}\n\n\n[build-system]\nrequires = [\"poetry-core\"]\nbackend = \"poetry.core.masonry.api\"\n\n\n[tool.other]\na = \"b\"\n\"\"\"\n\n    assert expected == doc.as_string()\n\n\ndef test_remove_from_out_of_order_table():\n    content = \"\"\"[a]\nx = 1\n\n[c]\nz = 3\n\n[a.b]\ny = 2\n\"\"\"\n    document = parse(content)\n    del document[\"a\"][\"b\"]\n    assert (\n        document.as_string()\n        == \"\"\"[a]\nx = 1\n\n[c]\nz = 3\n\n\"\"\"\n    )\n    assert json.dumps(document) == '{\"a\": {\"x\": 1}, \"c\": {\"z\": 3}}'\n\n\ndef test_updating_nested_value_keeps_correct_indent():\n    content = \"\"\"\n[Key1]\n      [key1.Key2]\n      Value1 = 10\n      Value2 = 30\n\"\"\"\n\n    doc = parse(content)\n    doc[\"key1\"][\"Key2\"][\"Value1\"] = 20\n\n    expected = \"\"\"\n[Key1]\n      [key1.Key2]\n      Value1 = 20\n      Value2 = 30\n\"\"\"\n\n    assert doc.as_string() == expected\n\n\ndef test_repr():\n    content = \"\"\"\nnamespace.key1 = \"value1\"\nnamespace.key2 = \"value2\"\n[tool.poetry.foo]\noption = \"test\"\n[tool.poetry.bar]\noption = \"test\"\ninline = {\"foo\" = \"bar\", \"bar\" = \"baz\"}\n\"\"\"\n\n    doc = parse(content)\n\n    assert (\n        repr(doc)\n        == \"{'namespace': {'key1': 'value1', 'key2': 'value2'}, 'tool': {'poetry': {'foo': {'option': 'test'}, 'bar': {'option': 'test', 'inline': {'foo': 'bar', 'bar': 'baz'}}}}}\"\n    )\n\n    assert (\n        repr(doc[\"tool\"])\n        == \"{'poetry': {'foo': {'option': 'test'}, 'bar': {'option': 'test', 'inline': {'foo': 'bar', 'bar': 'baz'}}}}\"\n    )\n\n    assert repr(doc[\"namespace\"]) == \"{'key1': 'value1', 'key2': 'value2'}\"\n\n\ndef test_deepcopy():\n    content = \"\"\"\n[tool]\nname = \"foo\"\n[tool.project.section]\noption = \"test\"\n\"\"\"\n    doc = parse(content)\n    copied = copy.deepcopy(doc)\n    assert copied == doc\n    assert copied.as_string() == content\n\n\ndef test_move_table():\n    content = \"\"\"a = 1\n[x]\na = 1\n\n[y]\nb = 1\n\"\"\"\n    doc = parse(content)\n    doc[\"a\"] = doc.pop(\"x\")\n    doc[\"z\"] = doc.pop(\"y\")\n    assert (\n        doc.as_string()\n        == \"\"\"[a]\na = 1\n\n[z]\nb = 1\n\"\"\"\n    )\n\n\ndef test_replace_with_table():\n    content = \"\"\"a = 1\nb = 2\nc = 3\n\"\"\"\n    doc = parse(content)\n    doc[\"b\"] = {\"foo\": \"bar\"}\n    assert (\n        doc.as_string()\n        == \"\"\"a = 1\nc = 3\n\n[b]\nfoo = \"bar\"\n\"\"\"\n    )\n\n\ndef test_replace_table_with_value():\n    content = \"\"\"[foo]\na = 1\n\n[bar]\nb = 2\n\"\"\"\n    doc = parse(content)\n    doc[\"bar\"] = 42\n    assert (\n        doc.as_string()\n        == \"\"\"bar = 42\n[foo]\na = 1\n\n\"\"\"\n    )\n\n\ndef test_replace_preserve_sep():\n    content = \"\"\"a   =   1\n\n[foo]\nb  =  \"what\"\n\"\"\"\n    doc = parse(content)\n    doc[\"a\"] = 2\n    doc[\"foo\"][\"b\"] = \"how\"\n    assert (\n        doc.as_string()\n        == \"\"\"a   =   2\n\n[foo]\nb  =  \"how\"\n\"\"\"\n    )\n\n\ndef test_replace_with_table_of_nested():\n    example = \"\"\"\\\n    [a]\n    x = 1\n\n    [a.b]\n    y = 2\n    \"\"\"\n    doc = parse(dedent(example))\n    doc[\"c\"] = doc.pop(\"a\")\n    expected = \"\"\"\\\n    [c]\n    x = 1\n\n    [c.b]\n    y = 2\n    \"\"\"\n    assert doc.as_string().strip() == dedent(expected).strip()\n\n\ndef test_replace_with_aot_of_nested():\n    example = \"\"\"\\\n    [a]\n    x = 1\n\n    [[a.b]]\n    y = 2\n\n    [[a.b]]\n\n    [a.b.c]\n    z = 2\n\n    [[a.b.c.d]]\n    w = 2\n    \"\"\"\n    doc = parse(dedent(example))\n    doc[\"f\"] = doc.pop(\"a\")\n    expected = \"\"\"\\\n    [f]\n    x = 1\n\n    [[f.b]]\n    y = 2\n\n    [[f.b]]\n\n    [f.b.c]\n    z = 2\n\n    [[f.b.c.d]]\n    w = 2\n    \"\"\"\n    assert doc.as_string().strip() == dedent(expected).strip()\n\n\ndef test_replace_with_comment():\n    content = 'a = \"1\"'\n    doc = parse(content)\n    a = tomlkit.item(int(doc[\"a\"]))\n    a.comment(\"`a` should be an int\")\n    doc[\"a\"] = a\n    expected = \"a = 1 # `a` should be an int\"\n    assert doc.as_string() == expected\n\n    content = 'a = \"1, 2, 3\"'\n    doc = parse(content)\n    a = tomlkit.array()\n    a.comment(\"`a` should be an array\")\n    for x in doc[\"a\"].split(\",\"):\n        a.append(int(x.strip()))\n    doc[\"a\"] = a\n    expected = \"a = [1, 2, 3] # `a` should be an array\"\n    assert doc.as_string() == expected\n\n    doc = parse(content)\n    a = tomlkit.inline_table()\n    a.comment(\"`a` should be an inline-table\")\n    for x in doc[\"a\"].split(\",\"):\n        i = int(x.strip())\n        a.append(chr(ord(\"a\") + i - 1), i)\n    doc[\"a\"] = a\n    expected = \"a = {a = 1, b = 2, c = 3} # `a` should be an inline-table\"\n    assert doc.as_string() == expected\n\n\ndef test_no_spurious_whitespaces():\n    content = \"\"\"\\\n    [x]\n    a = 1\n\n    [y]\n    b = 2\n    \"\"\"\n    doc = parse(dedent(content))\n    doc[\"z\"] = doc.pop(\"y\")\n    expected = \"\"\"\\\n    [x]\n    a = 1\n\n    [z]\n    b = 2\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n    doc[\"w\"] = {\"c\": 3}\n    expected = \"\"\"\\\n    [x]\n    a = 1\n\n    [z]\n    b = 2\n\n    [w]\n    c = 3\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n\n    doc = parse(dedent(content))\n    del doc[\"x\"]\n    doc[\"z\"] = {\"c\": 3}\n    expected = \"\"\"\\\n    [y]\n    b = 2\n\n    [z]\n    c = 3\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n\n\ndef test_pop_add_whitespace_and_insert_table_work_togheter():\n    content = \"\"\"\\\n    a = 1\n    b = 2\n    c = 3\n    d = 4\n    \"\"\"\n    doc = parse(dedent(content))\n    doc.pop(\"a\")\n    doc.pop(\"b\")\n    doc.add(ws(\"\\n\"))\n    doc[\"e\"] = {\"foo\": \"bar\"}\n    expected = \"\"\"\\\n    c = 3\n    d = 4\n\n    [e]\n    foo = \"bar\"\n    \"\"\"\n    text = doc.as_string()\n    out = parse(text)\n    assert out[\"d\"] == 4\n    assert \"d\" not in out[\"e\"]\n    assert text == dedent(expected)\n\n\ndef test_add_newline_before_super_table():\n    doc = document()\n    doc[\"a\"] = 1\n    doc[\"b\"] = {\"c\": {}}\n    doc[\"d\"] = {\"e\": {}}\n    expected = \"\"\"\\\n    a = 1\n\n    [b.c]\n\n    [d.e]\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n\n\ndef test_remove_item_from_super_table():\n    content = \"\"\"\\\n    [hello.one]\n    a = 1\n\n    [hello.two]\n    b = 1\n    \"\"\"\n    doc = parse(dedent(content))\n    del doc[\"hello\"][\"two\"]\n    expected = \"\"\"\\\n    [hello.one]\n    a = 1\n\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n\n\ndef test_nested_table_update_display_name():\n    content = \"\"\"\\\n    [parent]\n\n    [parent.foo]\n    x = 1\n    \"\"\"\n\n    doc = parse(dedent(content))\n    sub = \"\"\"\\\n    [foo]\n    y = 2\n\n    [bar]\n    z = 3\n    \"\"\"\n    doc[\"parent\"].update(parse(dedent(sub)))\n    expected = \"\"\"\\\n    [parent]\n\n    [parent.foo]\n    y = 2\n\n    [parent.bar]\n    z = 3\n    \"\"\"\n    assert doc.as_string() == dedent(expected)\n\n\ndef test_build_table_with_dotted_key():\n    doc = tomlkit.document()\n    data = {\n        \"a.b.c\": 1,\n        \"a.b.d\": 2,\n        \"a\": {\"c\": {\"foo\": \"bar\"}},\n        \"a.d.e\": 3,\n    }\n\n    for key, value in data.items():\n        if \".\" not in key:\n            doc.append(key, value)\n        else:\n            doc.append(tomlkit.key(key.split(\".\")), value)\n\n    expected = \"\"\"\\\na.b.c = 1\na.b.d = 2\na.d.e = 3\n\n[a.c]\nfoo = \"bar\"\n\"\"\"\n    assert doc.as_string() == expected\n    assert json.loads(json.dumps(doc)) == {\n        \"a\": {\"b\": {\"c\": 1, \"d\": 2}, \"d\": {\"e\": 3}, \"c\": {\"foo\": \"bar\"}}\n    }\n\n\ndef test_parse_subtables_no_extra_indent():\n    expected = \"\"\"\\\n[a]\n    [a.b.c]\n        foo = 1\n\n    [a.b.d]\n        bar = 2\n\"\"\"\n    doc = parse(expected)\n    assert doc.as_string() == expected\n\n\ndef test_item_preserves_the_order():\n    t = tomlkit.inline_table()\n    t.update({\"a\": 1, \"b\": 2})\n    doc = {\"name\": \"foo\", \"table\": t, \"age\": 42}\n    expected = \"\"\"\\\nname = \"foo\"\ntable = {a = 1, b = 2}\nage = 42\n\"\"\"\n    assert tomlkit.dumps(doc) == expected\n", "tests/test_utils.py": "from datetime import date\nfrom datetime import datetime as dt\nfrom datetime import time\nfrom datetime import timedelta as td\nfrom datetime import timezone as tz\n\nimport pytest\n\nfrom tomlkit._utils import _utc\nfrom tomlkit._utils import parse_rfc3339\n\n\n@pytest.mark.parametrize(\n    \"string, expected\",\n    [\n        (\"1979-05-27T07:32:00\", dt(1979, 5, 27, 7, 32, 0)),\n        (\"1979-05-27T07:32:00Z\", dt(1979, 5, 27, 7, 32, 0, tzinfo=_utc)),\n        (\n            \"1979-05-27T07:32:00-07:00\",\n            dt(1979, 5, 27, 7, 32, 0, tzinfo=tz(td(seconds=-7 * 3600), \"-07:00\")),\n        ),\n        (\n            \"1979-05-27T00:32:00.999999-07:00\",\n            dt(\n                1979,\n                5,\n                27,\n                0,\n                32,\n                0,\n                999999,\n                tzinfo=tz(td(seconds=-7 * 3600), \"-07:00\"),\n            ),\n        ),\n    ],\n)\ndef test_parse_rfc3339_datetime(string, expected):\n    assert parse_rfc3339(string) == expected\n\n\n@pytest.mark.parametrize(\"string, expected\", [(\"1979-05-27\", date(1979, 5, 27))])\ndef test_parse_rfc3339_date(string, expected):\n    assert parse_rfc3339(string) == expected\n\n\n@pytest.mark.parametrize(\n    \"string, expected\",\n    [(\"12:34:56\", time(12, 34, 56)), (\"12:34:56.123456\", time(12, 34, 56, 123456))],\n)\ndef test_parse_rfc3339_time(string, expected):\n    assert parse_rfc3339(string) == expected\n", "tomlkit/exceptions.py": "from __future__ import annotations\n\nfrom typing import Collection\n\n\nclass TOMLKitError(Exception):\n    pass\n\n\nclass ParseError(ValueError, TOMLKitError):\n    \"\"\"\n    This error occurs when the parser encounters a syntax error\n    in the TOML being parsed. The error references the line and\n    location within the line where the error was encountered.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, message: str | None = None) -> None:\n        self._line = line\n        self._col = col\n\n        if message is None:\n            message = \"TOML parse error\"\n\n        super().__init__(f\"{message} at line {self._line} col {self._col}\")\n\n    @property\n    def line(self):\n        return self._line\n\n    @property\n    def col(self):\n        return self._col\n\n\nclass MixedArrayTypesError(ParseError):\n    \"\"\"\n    An array was found that had two or more element types.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Mixed types found in array\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidNumberError(ParseError):\n    \"\"\"\n    A numeric field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidDateTimeError(ParseError):\n    \"\"\"\n    A datetime field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid datetime\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidDateError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid date\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidTimeError(ParseError):\n    \"\"\"\n    A date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid time\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidNumberOrDateError(ParseError):\n    \"\"\"\n    A numeric or date field was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid number or date format\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidUnicodeValueError(ParseError):\n    \"\"\"\n    A unicode code was improperly specified.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Invalid unicode value\"\n\n        super().__init__(line, col, message=message)\n\n\nclass UnexpectedCharError(ParseError):\n    \"\"\"\n    An unexpected character was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Unexpected character: {char!r}\"\n\n        super().__init__(line, col, message=message)\n\n\nclass EmptyKeyError(ParseError):\n    \"\"\"\n    An empty key was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty key\"\n\n        super().__init__(line, col, message=message)\n\n\nclass EmptyTableNameError(ParseError):\n    \"\"\"\n    An empty table name was found during parsing.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Empty table name\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidCharInStringError(ParseError):\n    \"\"\"\n    The string being parsed contains an invalid character.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, char: str) -> None:\n        message = f\"Invalid character {char!r} in string\"\n\n        super().__init__(line, col, message=message)\n\n\nclass UnexpectedEofError(ParseError):\n    \"\"\"\n    The TOML being parsed ended before the end of a statement.\n    \"\"\"\n\n    def __init__(self, line: int, col: int) -> None:\n        message = \"Unexpected end of file\"\n\n        super().__init__(line, col, message=message)\n\n\nclass InternalParserError(ParseError):\n    \"\"\"\n    An error that indicates a bug in the parser.\n    \"\"\"\n\n    def __init__(self, line: int, col: int, message: str | None = None) -> None:\n        msg = \"Internal parser error\"\n        if message:\n            msg += f\" ({message})\"\n\n        super().__init__(line, col, message=msg)\n\n\nclass NonExistentKey(KeyError, TOMLKitError):\n    \"\"\"\n    A non-existent key was used.\n    \"\"\"\n\n    def __init__(self, key):\n        message = f'Key \"{key}\" does not exist.'\n\n        super().__init__(message)\n\n\nclass KeyAlreadyPresent(TOMLKitError):\n    \"\"\"\n    An already present key was used.\n    \"\"\"\n\n    def __init__(self, key):\n        key = getattr(key, \"key\", key)\n        message = f'Key \"{key}\" already exists.'\n\n        super().__init__(message)\n\n\nclass InvalidControlChar(ParseError):\n    def __init__(self, line: int, col: int, char: int, type: str) -> None:\n        display_code = \"\\\\u00\"\n\n        if char < 16:\n            display_code += \"0\"\n\n        display_code += hex(char)[2:]\n\n        message = (\n            \"Control characters (codes less than 0x1f and 0x7f)\"\n            f\" are not allowed in {type}, \"\n            f\"use {display_code} instead\"\n        )\n\n        super().__init__(line, col, message=message)\n\n\nclass InvalidStringError(ValueError, TOMLKitError):\n    def __init__(self, value: str, invalid_sequences: Collection[str], delimiter: str):\n        repr_ = repr(value)[1:-1]\n        super().__init__(\n            f\"Invalid string: {delimiter}{repr_}{delimiter}. \"\n            f\"The character sequences {invalid_sequences} are invalid.\"\n        )\n\n\nclass ConvertError(TypeError, ValueError, TOMLKitError):\n    \"\"\"Raised when item() fails to convert a value.\n    It should be a TypeError, but due to historical reasons\n    it needs to subclass ValueError as well.\n    \"\"\"\n", "tomlkit/source.py": "from __future__ import annotations\n\nfrom copy import copy\nfrom typing import Any\n\nfrom tomlkit.exceptions import ParseError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.toml_char import TOMLChar\n\n\nclass _State:\n    def __init__(\n        self,\n        source: Source,\n        save_marker: bool | None = False,\n        restore: bool | None = False,\n    ) -> None:\n        self._source = source\n        self._save_marker = save_marker\n        self.restore = restore\n\n    def __enter__(self) -> _State:\n        # Entering this context manager - save the state\n        self._chars = copy(self._source._chars)\n        self._idx = self._source._idx\n        self._current = self._source._current\n        self._marker = self._source._marker\n\n        return self\n\n    def __exit__(self, exception_type, exception_val, trace):\n        # Exiting this context manager - restore the prior state\n        if self.restore or exception_type:\n            self._source._chars = self._chars\n            self._source._idx = self._idx\n            self._source._current = self._current\n            if self._save_marker:\n                self._source._marker = self._marker\n\n\nclass _StateHandler:\n    \"\"\"\n    State preserver for the Parser.\n    \"\"\"\n\n    def __init__(self, source: Source) -> None:\n        self._source = source\n        self._states = []\n\n    def __call__(self, *args, **kwargs):\n        return _State(self._source, *args, **kwargs)\n\n    def __enter__(self) -> _State:\n        state = self()\n        self._states.append(state)\n        return state.__enter__()\n\n    def __exit__(self, exception_type, exception_val, trace):\n        state = self._states.pop()\n        return state.__exit__(exception_type, exception_val, trace)\n\n\nclass Source(str):\n    EOF = TOMLChar(\"\\0\")\n\n    def __init__(self, _: str) -> None:\n        super().__init__()\n\n        # Collection of TOMLChars\n        self._chars = iter([(i, TOMLChar(c)) for i, c in enumerate(self)])\n\n        self._idx = 0\n        self._marker = 0\n        self._current = TOMLChar(\"\")\n\n        self._state = _StateHandler(self)\n\n        self.inc()\n\n    def reset(self):\n        # initialize both idx and current\n        self.inc()\n\n        # reset marker\n        self.mark()\n\n    @property\n    def state(self) -> _StateHandler:\n        return self._state\n\n    @property\n    def idx(self) -> int:\n        return self._idx\n\n    @property\n    def current(self) -> TOMLChar:\n        return self._current\n\n    @property\n    def marker(self) -> int:\n        return self._marker\n\n    def extract(self) -> str:\n        \"\"\"\n        Extracts the value between marker and index\n        \"\"\"\n        return self[self._marker : self._idx]\n\n    def inc(self, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser if the end of the input has not been reached.\n        Returns whether or not it was able to advance.\n        \"\"\"\n        try:\n            self._idx, self._current = next(self._chars)\n\n            return True\n        except StopIteration:\n            self._idx = len(self)\n            self._current = self.EOF\n            if exception:\n                raise self.parse_error(exception) from None\n\n            return False\n\n    def inc_n(self, n: int, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser by n characters\n        if the end of the input has not been reached.\n        \"\"\"\n        return all(self.inc(exception=exception) for _ in range(n))\n\n    def consume(self, chars, min=0, max=-1):\n        \"\"\"\n        Consume chars until min/max is satisfied is valid.\n        \"\"\"\n        while self.current in chars and max != 0:\n            min -= 1\n            max -= 1\n            if not self.inc():\n                break\n\n        # failed to consume minimum number of characters\n        if min > 0:\n            raise self.parse_error(UnexpectedCharError, self.current)\n\n    def end(self) -> bool:\n        \"\"\"\n        Returns True if the parser has reached the end of the input.\n        \"\"\"\n        return self._current is self.EOF\n\n    def mark(self) -> None:\n        \"\"\"\n        Sets the marker to the index's current position\n        \"\"\"\n        self._marker = self._idx\n\n    def parse_error(\n        self,\n        exception: type[ParseError] = ParseError,\n        *args: Any,\n        **kwargs: Any,\n    ) -> ParseError:\n        \"\"\"\n        Creates a generic \"parse error\" at the current position.\n        \"\"\"\n        line, col = self._to_linecol()\n\n        return exception(line, col, *args, **kwargs)\n\n    def _to_linecol(self) -> tuple[int, int]:\n        cur = 0\n        for i, line in enumerate(self.splitlines()):\n            if cur + len(line) + 1 > self.idx:\n                return (i + 1, self.idx - cur)\n\n            cur += len(line) + 1\n\n        return len(self.splitlines()), 0\n", "tomlkit/items.py": "from __future__ import annotations\n\nimport abc\nimport copy\nimport dataclasses\nimport math\nimport re\nimport string\nimport sys\n\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import tzinfo\nfrom enum import Enum\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Collection\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Sequence\nfrom typing import TypeVar\nfrom typing import cast\nfrom typing import overload\n\nfrom tomlkit._compat import PY38\nfrom tomlkit._compat import decode\nfrom tomlkit._types import _CustomDict\nfrom tomlkit._types import _CustomFloat\nfrom tomlkit._types import _CustomInt\nfrom tomlkit._types import _CustomList\nfrom tomlkit._types import wrap_method\nfrom tomlkit._utils import CONTROL_CHARS\nfrom tomlkit._utils import escape_string\nfrom tomlkit.exceptions import ConvertError\nfrom tomlkit.exceptions import InvalidStringError\n\n\nif TYPE_CHECKING:\n    from tomlkit import container\n\n\nItemT = TypeVar(\"ItemT\", bound=\"Item\")\nEncoder = Callable[[Any], \"Item\"]\nCUSTOM_ENCODERS: list[Encoder] = []\nAT = TypeVar(\"AT\", bound=\"AbstractTable\")\n\n\n@overload\ndef item(value: bool, _parent: Item | None = ..., _sort_keys: bool = ...) -> Bool: ...\n\n\n@overload\ndef item(value: int, _parent: Item | None = ..., _sort_keys: bool = ...) -> Integer: ...\n\n\n@overload\ndef item(value: float, _parent: Item | None = ..., _sort_keys: bool = ...) -> Float: ...\n\n\n@overload\ndef item(value: str, _parent: Item | None = ..., _sort_keys: bool = ...) -> String: ...\n\n\n@overload\ndef item(\n    value: datetime, _parent: Item | None = ..., _sort_keys: bool = ...\n) -> DateTime: ...\n\n\n@overload\ndef item(value: date, _parent: Item | None = ..., _sort_keys: bool = ...) -> Date: ...\n\n\n@overload\ndef item(value: time, _parent: Item | None = ..., _sort_keys: bool = ...) -> Time: ...\n\n\n@overload\ndef item(\n    value: Sequence[dict], _parent: Item | None = ..., _sort_keys: bool = ...\n) -> AoT: ...\n\n\n@overload\ndef item(\n    value: Sequence, _parent: Item | None = ..., _sort_keys: bool = ...\n) -> Array: ...\n\n\n@overload\ndef item(value: dict, _parent: Array = ..., _sort_keys: bool = ...) -> InlineTable: ...\n\n\n@overload\ndef item(value: dict, _parent: Item | None = ..., _sort_keys: bool = ...) -> Table: ...\n\n\n@overload\ndef item(value: ItemT, _parent: Item | None = ..., _sort_keys: bool = ...) -> ItemT: ...\n\n\ndef item(value: Any, _parent: Item | None = None, _sort_keys: bool = False) -> Item:\n    \"\"\"Create a TOML item from a Python object.\n\n    :Example:\n\n    >>> item(42)\n    42\n    >>> item([1, 2, 3])\n    [1, 2, 3]\n    >>> item({'a': 1, 'b': 2})\n    a = 1\n    b = 2\n    \"\"\"\n\n    from tomlkit.container import Container\n\n    if isinstance(value, Item):\n        return value\n\n    if isinstance(value, bool):\n        return Bool(value, Trivia())\n    elif isinstance(value, int):\n        return Integer(value, Trivia(), str(value))\n    elif isinstance(value, float):\n        return Float(value, Trivia(), str(value))\n    elif isinstance(value, dict):\n        table_constructor = (\n            InlineTable if isinstance(_parent, (Array, InlineTable)) else Table\n        )\n        val = table_constructor(Container(), Trivia(), False)\n        for k, v in sorted(\n            value.items(),\n            key=lambda i: (isinstance(i[1], dict), i[0]) if _sort_keys else 1,\n        ):\n            val[k] = item(v, _parent=val, _sort_keys=_sort_keys)\n\n        return val\n    elif isinstance(value, (list, tuple)):\n        if (\n            value\n            and all(isinstance(v, dict) for v in value)\n            and (_parent is None or isinstance(_parent, Table))\n        ):\n            a = AoT([])\n            table_constructor = Table\n        else:\n            a = Array([], Trivia())\n            table_constructor = InlineTable\n\n        for v in value:\n            if isinstance(v, dict):\n                table = table_constructor(Container(), Trivia(), True)\n\n                for k, _v in sorted(\n                    v.items(),\n                    key=lambda i: (isinstance(i[1], dict), i[0] if _sort_keys else 1),\n                ):\n                    i = item(_v, _parent=table, _sort_keys=_sort_keys)\n                    if isinstance(table, InlineTable):\n                        i.trivia.trail = \"\"\n\n                    table[k] = i\n\n                v = table\n\n            a.append(v)\n\n        return a\n    elif isinstance(value, str):\n        return String.from_raw(value)\n    elif isinstance(value, datetime):\n        return DateTime(\n            value.year,\n            value.month,\n            value.day,\n            value.hour,\n            value.minute,\n            value.second,\n            value.microsecond,\n            value.tzinfo,\n            Trivia(),\n            value.isoformat().replace(\"+00:00\", \"Z\"),\n        )\n    elif isinstance(value, date):\n        return Date(value.year, value.month, value.day, Trivia(), value.isoformat())\n    elif isinstance(value, time):\n        return Time(\n            value.hour,\n            value.minute,\n            value.second,\n            value.microsecond,\n            value.tzinfo,\n            Trivia(),\n            value.isoformat(),\n        )\n    else:\n        for encoder in CUSTOM_ENCODERS:\n            try:\n                rv = encoder(value)\n            except ConvertError:\n                pass\n            else:\n                if not isinstance(rv, Item):\n                    raise ConvertError(\n                        f\"Custom encoder is expected to return an instance of Item, got {type(rv)}\"\n                    )\n                return rv\n\n    raise ConvertError(f\"Unable to convert an object of {type(value)} to a TOML item\")\n\n\nclass StringType(Enum):\n    # Single Line Basic\n    SLB = '\"'\n    # Multi Line Basic\n    MLB = '\"\"\"'\n    # Single Line Literal\n    SLL = \"'\"\n    # Multi Line Literal\n    MLL = \"'''\"\n\n    @classmethod\n    def select(cls, literal=False, multiline=False) -> StringType:\n        return {\n            (False, False): cls.SLB,\n            (False, True): cls.MLB,\n            (True, False): cls.SLL,\n            (True, True): cls.MLL,\n        }[(literal, multiline)]\n\n    @property\n    def escaped_sequences(self) -> Collection[str]:\n        # https://toml.io/en/v1.0.0#string\n        escaped_in_basic = CONTROL_CHARS | {\"\\\\\"}\n        allowed_in_multiline = {\"\\n\", \"\\r\"}\n        return {\n            StringType.SLB: escaped_in_basic | {'\"'},\n            StringType.MLB: (escaped_in_basic | {'\"\"\"'}) - allowed_in_multiline,\n            StringType.SLL: (),\n            StringType.MLL: (),\n        }[self]\n\n    @property\n    def invalid_sequences(self) -> Collection[str]:\n        # https://toml.io/en/v1.0.0#string\n        forbidden_in_literal = CONTROL_CHARS - {\"\\t\"}\n        allowed_in_multiline = {\"\\n\", \"\\r\"}\n        return {\n            StringType.SLB: (),\n            StringType.MLB: (),\n            StringType.SLL: forbidden_in_literal | {\"'\"},\n            StringType.MLL: (forbidden_in_literal | {\"'''\"}) - allowed_in_multiline,\n        }[self]\n\n    @property\n    def unit(self) -> str:\n        return self.value[0]\n\n    def is_basic(self) -> bool:\n        return self in {StringType.SLB, StringType.MLB}\n\n    def is_literal(self) -> bool:\n        return self in {StringType.SLL, StringType.MLL}\n\n    def is_singleline(self) -> bool:\n        return self in {StringType.SLB, StringType.SLL}\n\n    def is_multiline(self) -> bool:\n        return self in {StringType.MLB, StringType.MLL}\n\n    def toggle(self) -> StringType:\n        return {\n            StringType.SLB: StringType.MLB,\n            StringType.MLB: StringType.SLB,\n            StringType.SLL: StringType.MLL,\n            StringType.MLL: StringType.SLL,\n        }[self]\n\n\nclass BoolType(Enum):\n    TRUE = \"true\"\n    FALSE = \"false\"\n\n    def __bool__(self):\n        return {BoolType.TRUE: True, BoolType.FALSE: False}[self]\n\n    def __iter__(self):\n        return iter(self.value)\n\n    def __len__(self):\n        return len(self.value)\n\n\n@dataclasses.dataclass\nclass Trivia:\n    \"\"\"\n    Trivia information (aka metadata).\n    \"\"\"\n\n    # Whitespace before a value.\n    indent: str = \"\"\n    # Whitespace after a value, but before a comment.\n    comment_ws: str = \"\"\n    # Comment, starting with # character, or empty string if no comment.\n    comment: str = \"\"\n    # Trailing newline.\n    trail: str = \"\\n\"\n\n    def copy(self) -> Trivia:\n        return dataclasses.replace(self)\n\n\nclass KeyType(Enum):\n    \"\"\"\n    The type of a Key.\n\n    Keys can be bare (unquoted), or quoted using basic (\"), or literal (')\n    quotes following the same escaping rules as single-line StringType.\n    \"\"\"\n\n    Bare = \"\"\n    Basic = '\"'\n    Literal = \"'\"\n\n\nclass Key(abc.ABC):\n    \"\"\"Base class for a key\"\"\"\n\n    sep: str\n    _original: str\n    _keys: list[SingleKey]\n    _dotted: bool\n    key: str\n\n    @abc.abstractmethod\n    def __hash__(self) -> int:\n        pass\n\n    @abc.abstractmethod\n    def __eq__(self, __o: object) -> bool:\n        pass\n\n    def is_dotted(self) -> bool:\n        \"\"\"If the key is followed by other keys\"\"\"\n        return self._dotted\n\n    def __iter__(self) -> Iterator[SingleKey]:\n        return iter(self._keys)\n\n    def concat(self, other: Key) -> DottedKey:\n        \"\"\"Concatenate keys into a dotted key\"\"\"\n        keys = self._keys + other._keys\n        return DottedKey(keys, sep=self.sep)\n\n    def is_multi(self) -> bool:\n        \"\"\"Check if the key contains multiple keys\"\"\"\n        return len(self._keys) > 1\n\n    def as_string(self) -> str:\n        \"\"\"The TOML representation\"\"\"\n        return self._original\n\n    def __str__(self) -> str:\n        return self.as_string()\n\n    def __repr__(self) -> str:\n        return f\"<Key {self.as_string()}>\"\n\n\nclass SingleKey(Key):\n    \"\"\"A single key\"\"\"\n\n    def __init__(\n        self,\n        k: str,\n        t: KeyType | None = None,\n        sep: str | None = None,\n        original: str | None = None,\n    ) -> None:\n        if t is None:\n            if not k or any(\n                c not in string.ascii_letters + string.digits + \"-\" + \"_\" for c in k\n            ):\n                t = KeyType.Basic\n            else:\n                t = KeyType.Bare\n\n        self.t = t\n        if sep is None:\n            sep = \" = \"\n\n        self.sep = sep\n        self.key = k\n        if original is None:\n            key_str = escape_string(k) if t == KeyType.Basic else k\n            original = f\"{t.value}{key_str}{t.value}\"\n\n        self._original = original\n        self._keys = [self]\n        self._dotted = False\n\n    @property\n    def delimiter(self) -> str:\n        \"\"\"The delimiter: double quote/single quote/none\"\"\"\n        return self.t.value\n\n    def is_bare(self) -> bool:\n        \"\"\"Check if the key is bare\"\"\"\n        return self.t == KeyType.Bare\n\n    def __hash__(self) -> int:\n        return hash(self.key)\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, Key):\n            return isinstance(other, SingleKey) and self.key == other.key\n\n        return self.key == other\n\n\nclass DottedKey(Key):\n    def __init__(\n        self,\n        keys: Iterable[SingleKey],\n        sep: str | None = None,\n        original: str | None = None,\n    ) -> None:\n        self._keys = list(keys)\n        if original is None:\n            original = \".\".join(k.as_string() for k in self._keys)\n\n        self.sep = \" = \" if sep is None else sep\n        self._original = original\n        self._dotted = False\n        self.key = \".\".join(k.key for k in self._keys)\n\n    def __hash__(self) -> int:\n        return hash(tuple(self._keys))\n\n    def __eq__(self, __o: object) -> bool:\n        return isinstance(__o, DottedKey) and self._keys == __o._keys\n\n\nclass Item:\n    \"\"\"\n    An item within a TOML document.\n    \"\"\"\n\n    def __init__(self, trivia: Trivia) -> None:\n        self._trivia = trivia\n\n    @property\n    def trivia(self) -> Trivia:\n        \"\"\"The trivia element associated with this item\"\"\"\n        return self._trivia\n\n    @property\n    def discriminant(self) -> int:\n        raise NotImplementedError()\n\n    def as_string(self) -> str:\n        \"\"\"The TOML representation\"\"\"\n        raise NotImplementedError()\n\n    @property\n    def value(self) -> Any:\n        return self\n\n    def unwrap(self) -> Any:\n        \"\"\"Returns as pure python object (ppo)\"\"\"\n        raise NotImplementedError()\n\n    # Helpers\n\n    def comment(self, comment: str) -> Item:\n        \"\"\"Attach a comment to this item\"\"\"\n        if not comment.strip().startswith(\"#\"):\n            comment = \"# \" + comment\n\n        self._trivia.comment_ws = \" \"\n        self._trivia.comment = comment\n\n        return self\n\n    def indent(self, indent: int) -> Item:\n        \"\"\"Indent this item with given number of spaces\"\"\"\n        if self._trivia.indent.startswith(\"\\n\"):\n            self._trivia.indent = \"\\n\" + \" \" * indent\n        else:\n            self._trivia.indent = \" \" * indent\n\n        return self\n\n    def is_boolean(self) -> bool:\n        return isinstance(self, Bool)\n\n    def is_table(self) -> bool:\n        return isinstance(self, Table)\n\n    def is_inline_table(self) -> bool:\n        return isinstance(self, InlineTable)\n\n    def is_aot(self) -> bool:\n        return isinstance(self, AoT)\n\n    def _getstate(self, protocol=3):\n        return (self._trivia,)\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n\n    def __reduce_ex__(self, protocol):\n        return self.__class__, self._getstate(protocol)\n\n\nclass Whitespace(Item):\n    \"\"\"\n    A whitespace literal.\n    \"\"\"\n\n    def __init__(self, s: str, fixed: bool = False) -> None:\n        self._s = s\n        self._fixed = fixed\n\n    @property\n    def s(self) -> str:\n        return self._s\n\n    @property\n    def value(self) -> str:\n        \"\"\"The wrapped string of the whitespace\"\"\"\n        return self._s\n\n    @property\n    def trivia(self) -> Trivia:\n        raise RuntimeError(\"Called trivia on a Whitespace variant.\")\n\n    @property\n    def discriminant(self) -> int:\n        return 0\n\n    def is_fixed(self) -> bool:\n        \"\"\"If the whitespace is fixed, it can't be merged or discarded from the output.\"\"\"\n        return self._fixed\n\n    def as_string(self) -> str:\n        return self._s\n\n    def __repr__(self) -> str:\n        return f\"<{self.__class__.__name__} {self._s!r}>\"\n\n    def _getstate(self, protocol=3):\n        return self._s, self._fixed\n\n\nclass Comment(Item):\n    \"\"\"\n    A comment literal.\n    \"\"\"\n\n    @property\n    def discriminant(self) -> int:\n        return 1\n\n    def as_string(self) -> str:\n        return (\n            f\"{self._trivia.indent}{decode(self._trivia.comment)}{self._trivia.trail}\"\n        )\n\n    def __str__(self) -> str:\n        return f\"{self._trivia.indent}{decode(self._trivia.comment)}\"\n\n\nclass Integer(Item, _CustomInt):\n    \"\"\"\n    An integer literal.\n    \"\"\"\n\n    def __new__(cls, value: int, trivia: Trivia, raw: str) -> Integer:\n        return int.__new__(cls, value)\n\n    def __init__(self, value: int, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._original = value\n        self._raw = raw\n        self._sign = False\n\n        if re.match(r\"^[+\\-]\\d+$\", raw):\n            self._sign = True\n\n    def unwrap(self) -> int:\n        return self._original\n\n    __int__ = unwrap\n\n    def __hash__(self) -> int:\n        return hash(self.unwrap())\n\n    @property\n    def discriminant(self) -> int:\n        return 2\n\n    @property\n    def value(self) -> int:\n        \"\"\"The wrapped integer value\"\"\"\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def _new(self, result):\n        raw = str(result)\n        if self._sign and result >= 0:\n            raw = f\"+{raw}\"\n\n        return Integer(result, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return int(self), self._trivia, self._raw\n\n    # int methods\n    __abs__ = wrap_method(int.__abs__)\n    __add__ = wrap_method(int.__add__)\n    __and__ = wrap_method(int.__and__)\n    __ceil__ = wrap_method(int.__ceil__)\n    __eq__ = int.__eq__\n    __floor__ = wrap_method(int.__floor__)\n    __floordiv__ = wrap_method(int.__floordiv__)\n    __invert__ = wrap_method(int.__invert__)\n    __le__ = int.__le__\n    __lshift__ = wrap_method(int.__lshift__)\n    __lt__ = int.__lt__\n    __mod__ = wrap_method(int.__mod__)\n    __mul__ = wrap_method(int.__mul__)\n    __neg__ = wrap_method(int.__neg__)\n    __or__ = wrap_method(int.__or__)\n    __pos__ = wrap_method(int.__pos__)\n    __pow__ = wrap_method(int.__pow__)\n    __radd__ = wrap_method(int.__radd__)\n    __rand__ = wrap_method(int.__rand__)\n    __rfloordiv__ = wrap_method(int.__rfloordiv__)\n    __rlshift__ = wrap_method(int.__rlshift__)\n    __rmod__ = wrap_method(int.__rmod__)\n    __rmul__ = wrap_method(int.__rmul__)\n    __ror__ = wrap_method(int.__ror__)\n    __round__ = wrap_method(int.__round__)\n    __rpow__ = wrap_method(int.__rpow__)\n    __rrshift__ = wrap_method(int.__rrshift__)\n    __rshift__ = wrap_method(int.__rshift__)\n    __rxor__ = wrap_method(int.__rxor__)\n    __trunc__ = wrap_method(int.__trunc__)\n    __xor__ = wrap_method(int.__xor__)\n\n    def __rtruediv__(self, other):\n        result = int.__rtruediv__(self, other)\n        if result is NotImplemented:\n            return result\n        return Float._new(self, result)\n\n    def __truediv__(self, other):\n        result = int.__truediv__(self, other)\n        if result is NotImplemented:\n            return result\n        return Float._new(self, result)\n\n\nclass Float(Item, _CustomFloat):\n    \"\"\"\n    A float literal.\n    \"\"\"\n\n    def __new__(cls, value: float, trivia: Trivia, raw: str) -> Float:\n        return float.__new__(cls, value)\n\n    def __init__(self, value: float, trivia: Trivia, raw: str) -> None:\n        super().__init__(trivia)\n        self._original = value\n        self._raw = raw\n        self._sign = False\n\n        if re.match(r\"^[+\\-].+$\", raw):\n            self._sign = True\n\n    def unwrap(self) -> float:\n        return self._original\n\n    __float__ = unwrap\n\n    def __hash__(self) -> int:\n        return hash(self.unwrap())\n\n    @property\n    def discriminant(self) -> int:\n        return 3\n\n    @property\n    def value(self) -> float:\n        \"\"\"The wrapped float value\"\"\"\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def _new(self, result):\n        raw = str(result)\n\n        if self._sign and result >= 0:\n            raw = f\"+{raw}\"\n\n        return Float(result, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return float(self), self._trivia, self._raw\n\n    # float methods\n    __abs__ = wrap_method(float.__abs__)\n    __add__ = wrap_method(float.__add__)\n    __eq__ = float.__eq__\n    __floordiv__ = wrap_method(float.__floordiv__)\n    __le__ = float.__le__\n    __lt__ = float.__lt__\n    __mod__ = wrap_method(float.__mod__)\n    __mul__ = wrap_method(float.__mul__)\n    __neg__ = wrap_method(float.__neg__)\n    __pos__ = wrap_method(float.__pos__)\n    __pow__ = wrap_method(float.__pow__)\n    __radd__ = wrap_method(float.__radd__)\n    __rfloordiv__ = wrap_method(float.__rfloordiv__)\n    __rmod__ = wrap_method(float.__rmod__)\n    __rmul__ = wrap_method(float.__rmul__)\n    __round__ = wrap_method(float.__round__)\n    __rpow__ = wrap_method(float.__rpow__)\n    __rtruediv__ = wrap_method(float.__rtruediv__)\n    __truediv__ = wrap_method(float.__truediv__)\n    __trunc__ = float.__trunc__\n\n    if sys.version_info >= (3, 9):\n        __ceil__ = float.__ceil__\n        __floor__ = float.__floor__\n    else:\n        __ceil__ = math.ceil\n        __floor__ = math.floor\n\n\nclass Bool(Item):\n    \"\"\"\n    A boolean literal.\n    \"\"\"\n\n    def __init__(self, t: int, trivia: Trivia) -> None:\n        super().__init__(trivia)\n\n        self._value = bool(t)\n\n    def unwrap(self) -> bool:\n        return bool(self)\n\n    @property\n    def discriminant(self) -> int:\n        return 4\n\n    @property\n    def value(self) -> bool:\n        \"\"\"The wrapped boolean value\"\"\"\n        return self._value\n\n    def as_string(self) -> str:\n        return str(self._value).lower()\n\n    def _getstate(self, protocol=3):\n        return self._value, self._trivia\n\n    def __bool__(self):\n        return self._value\n\n    __nonzero__ = __bool__\n\n    def __eq__(self, other):\n        if not isinstance(other, bool):\n            return NotImplemented\n\n        return other == self._value\n\n    def __hash__(self):\n        return hash(self._value)\n\n    def __repr__(self):\n        return repr(self._value)\n\n\nclass DateTime(Item, datetime):\n    \"\"\"\n    A datetime literal.\n    \"\"\"\n\n    def __new__(\n        cls,\n        year: int,\n        month: int,\n        day: int,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        *_: Any,\n        **kwargs: Any,\n    ) -> datetime:\n        return datetime.__new__(\n            cls,\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            microsecond,\n            tzinfo=tzinfo,\n            **kwargs,\n        )\n\n    def __init__(\n        self,\n        year: int,\n        month: int,\n        day: int,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        trivia: Trivia | None = None,\n        raw: str | None = None,\n        **kwargs: Any,\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw or self.isoformat()\n\n    def unwrap(self) -> datetime:\n        (\n            year,\n            month,\n            day,\n            hour,\n            minute,\n            second,\n            microsecond,\n            tzinfo,\n            _,\n            _,\n        ) = self._getstate()\n        return datetime(year, month, day, hour, minute, second, microsecond, tzinfo)\n\n    @property\n    def discriminant(self) -> int:\n        return 5\n\n    @property\n    def value(self) -> datetime:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def __add__(self, other):\n        if PY38:\n            result = datetime(\n                self.year,\n                self.month,\n                self.day,\n                self.hour,\n                self.minute,\n                self.second,\n                self.microsecond,\n                self.tzinfo,\n            ).__add__(other)\n        else:\n            result = super().__add__(other)\n\n        return self._new(result)\n\n    def __sub__(self, other):\n        if PY38:\n            result = datetime(\n                self.year,\n                self.month,\n                self.day,\n                self.hour,\n                self.minute,\n                self.second,\n                self.microsecond,\n                self.tzinfo,\n            ).__sub__(other)\n        else:\n            result = super().__sub__(other)\n\n        if isinstance(result, datetime):\n            result = self._new(result)\n\n        return result\n\n    def replace(self, *args: Any, **kwargs: Any) -> datetime:\n        return self._new(super().replace(*args, **kwargs))\n\n    def astimezone(self, tz: tzinfo) -> datetime:\n        result = super().astimezone(tz)\n        if PY38:\n            return result\n        return self._new(result)\n\n    def _new(self, result) -> DateTime:\n        raw = result.isoformat()\n\n        return DateTime(\n            result.year,\n            result.month,\n            result.day,\n            result.hour,\n            result.minute,\n            result.second,\n            result.microsecond,\n            result.tzinfo,\n            self._trivia,\n            raw,\n        )\n\n    def _getstate(self, protocol=3):\n        return (\n            self.year,\n            self.month,\n            self.day,\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n            self.tzinfo,\n            self._trivia,\n            self._raw,\n        )\n\n\nclass Date(Item, date):\n    \"\"\"\n    A date literal.\n    \"\"\"\n\n    def __new__(cls, year: int, month: int, day: int, *_: Any) -> date:\n        return date.__new__(cls, year, month, day)\n\n    def __init__(\n        self,\n        year: int,\n        month: int,\n        day: int,\n        trivia: Trivia | None = None,\n        raw: str = \"\",\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw\n\n    def unwrap(self) -> date:\n        (year, month, day, _, _) = self._getstate()\n        return date(year, month, day)\n\n    @property\n    def discriminant(self) -> int:\n        return 6\n\n    @property\n    def value(self) -> date:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def __add__(self, other):\n        if PY38:\n            result = date(self.year, self.month, self.day).__add__(other)\n        else:\n            result = super().__add__(other)\n\n        return self._new(result)\n\n    def __sub__(self, other):\n        if PY38:\n            result = date(self.year, self.month, self.day).__sub__(other)\n        else:\n            result = super().__sub__(other)\n\n        if isinstance(result, date):\n            result = self._new(result)\n\n        return result\n\n    def replace(self, *args: Any, **kwargs: Any) -> date:\n        return self._new(super().replace(*args, **kwargs))\n\n    def _new(self, result):\n        raw = result.isoformat()\n\n        return Date(result.year, result.month, result.day, self._trivia, raw)\n\n    def _getstate(self, protocol=3):\n        return (self.year, self.month, self.day, self._trivia, self._raw)\n\n\nclass Time(Item, time):\n    \"\"\"\n    A time literal.\n    \"\"\"\n\n    def __new__(\n        cls,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        *_: Any,\n    ) -> time:\n        return time.__new__(cls, hour, minute, second, microsecond, tzinfo)\n\n    def __init__(\n        self,\n        hour: int,\n        minute: int,\n        second: int,\n        microsecond: int,\n        tzinfo: tzinfo | None,\n        trivia: Trivia | None = None,\n        raw: str = \"\",\n    ) -> None:\n        super().__init__(trivia or Trivia())\n\n        self._raw = raw\n\n    def unwrap(self) -> time:\n        (hour, minute, second, microsecond, tzinfo, _, _) = self._getstate()\n        return time(hour, minute, second, microsecond, tzinfo)\n\n    @property\n    def discriminant(self) -> int:\n        return 7\n\n    @property\n    def value(self) -> time:\n        return self\n\n    def as_string(self) -> str:\n        return self._raw\n\n    def replace(self, *args: Any, **kwargs: Any) -> time:\n        return self._new(super().replace(*args, **kwargs))\n\n    def _new(self, result):\n        raw = result.isoformat()\n\n        return Time(\n            result.hour,\n            result.minute,\n            result.second,\n            result.microsecond,\n            result.tzinfo,\n            self._trivia,\n            raw,\n        )\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (\n            self.hour,\n            self.minute,\n            self.second,\n            self.microsecond,\n            self.tzinfo,\n            self._trivia,\n            self._raw,\n        )\n\n\nclass _ArrayItemGroup:\n    __slots__ = (\"value\", \"indent\", \"comma\", \"comment\")\n\n    def __init__(\n        self,\n        value: Item | None = None,\n        indent: Whitespace | None = None,\n        comma: Whitespace | None = None,\n        comment: Comment | None = None,\n    ) -> None:\n        self.value = value\n        self.indent = indent\n        self.comma = comma\n        self.comment = comment\n\n    def __iter__(self) -> Iterator[Item]:\n        return filter(\n            lambda x: x is not None, (self.indent, self.value, self.comma, self.comment)\n        )\n\n    def __repr__(self) -> str:\n        return repr(tuple(self))\n\n    def is_whitespace(self) -> bool:\n        return self.value is None and self.comment is None\n\n    def __bool__(self) -> bool:\n        try:\n            next(iter(self))\n        except StopIteration:\n            return False\n        return True\n\n\nclass Array(Item, _CustomList):\n    \"\"\"\n    An array literal\n    \"\"\"\n\n    def __init__(\n        self, value: list[Item], trivia: Trivia, multiline: bool = False\n    ) -> None:\n        super().__init__(trivia)\n        list.__init__(\n            self,\n            [v for v in value if not isinstance(v, (Whitespace, Comment, Null))],\n        )\n        self._index_map: dict[int, int] = {}\n        self._value = self._group_values(value)\n        self._multiline = multiline\n        self._reindex()\n\n    def _group_values(self, value: list[Item]) -> list[_ArrayItemGroup]:\n        \"\"\"Group the values into (indent, value, comma, comment) tuples\"\"\"\n        groups = []\n        this_group = _ArrayItemGroup()\n        for item in value:\n            if isinstance(item, Whitespace):\n                if \",\" not in item.s:\n                    groups.append(this_group)\n                    this_group = _ArrayItemGroup(indent=item)\n                else:\n                    if this_group.value is None:\n                        # when comma is met and no value is provided, add a dummy Null\n                        this_group.value = Null()\n                    this_group.comma = item\n            elif isinstance(item, Comment):\n                if this_group.value is None:\n                    this_group.value = Null()\n                this_group.comment = item\n            elif this_group.value is None:\n                this_group.value = item\n            else:\n                groups.append(this_group)\n                this_group = _ArrayItemGroup(value=item)\n        groups.append(this_group)\n        return [group for group in groups if group]\n\n    def unwrap(self) -> list[Any]:\n        unwrapped = []\n        for v in self:\n            if hasattr(v, \"unwrap\"):\n                unwrapped.append(v.unwrap())\n            else:\n                unwrapped.append(v)\n        return unwrapped\n\n    @property\n    def discriminant(self) -> int:\n        return 8\n\n    @property\n    def value(self) -> list:\n        return self\n\n    def _iter_items(self) -> Iterator[Item]:\n        for v in self._value:\n            yield from v\n\n    def multiline(self, multiline: bool) -> Array:\n        \"\"\"Change the array to display in multiline or not.\n\n        :Example:\n\n        >>> a = item([1, 2, 3])\n        >>> print(a.as_string())\n        [1, 2, 3]\n        >>> print(a.multiline(True).as_string())\n        [\n            1,\n            2,\n            3,\n        ]\n        \"\"\"\n        self._multiline = multiline\n\n        return self\n\n    def as_string(self) -> str:\n        if not self._multiline or not self._value:\n            return f'[{\"\".join(v.as_string() for v in self._iter_items())}]'\n\n        s = \"[\\n\"\n        s += \"\".join(\n            self.trivia.indent\n            + \" \" * 4\n            + v.value.as_string()\n            + (\",\" if not isinstance(v.value, Null) else \"\")\n            + (v.comment.as_string() if v.comment is not None else \"\")\n            + \"\\n\"\n            for v in self._value\n            if v.value is not None\n        )\n        s += self.trivia.indent + \"]\"\n\n        return s\n\n    def _reindex(self) -> None:\n        self._index_map.clear()\n        index = 0\n        for i, v in enumerate(self._value):\n            if v.value is None or isinstance(v.value, Null):\n                continue\n            self._index_map[index] = i\n            index += 1\n\n    def add_line(\n        self,\n        *items: Any,\n        indent: str = \"    \",\n        comment: str | None = None,\n        add_comma: bool = True,\n        newline: bool = True,\n    ) -> None:\n        \"\"\"Add multiple items in a line to control the format precisely.\n        When add_comma is True, only accept actual values and\n        \", \" will be added between values automatically.\n\n        :Example:\n\n        >>> a = array()\n        >>> a.add_line(1, 2, 3)\n        >>> a.add_line(4, 5, 6)\n        >>> a.add_line(indent=\"\")\n        >>> print(a.as_string())\n        [\n            1, 2, 3,\n            4, 5, 6,\n        ]\n        \"\"\"\n        new_values: list[Item] = []\n        first_indent = f\"\\n{indent}\" if newline else indent\n        if first_indent:\n            new_values.append(Whitespace(first_indent))\n        whitespace = \"\"\n        data_values = []\n        for i, el in enumerate(items):\n            it = item(el, _parent=self)\n            if isinstance(it, Comment) or add_comma and isinstance(el, Whitespace):\n                raise ValueError(f\"item type {type(it)} is not allowed in add_line\")\n            if not isinstance(it, Whitespace):\n                if whitespace:\n                    new_values.append(Whitespace(whitespace))\n                    whitespace = \"\"\n                new_values.append(it)\n                data_values.append(it.value)\n                if add_comma:\n                    new_values.append(Whitespace(\",\"))\n                    if i != len(items) - 1:\n                        new_values.append(Whitespace(\" \"))\n            elif \",\" not in it.s:\n                whitespace += it.s\n            else:\n                new_values.append(it)\n        if whitespace:\n            new_values.append(Whitespace(whitespace))\n        if comment:\n            indent = \" \" if items else \"\"\n            new_values.append(\n                Comment(Trivia(indent=indent, comment=f\"# {comment}\", trail=\"\"))\n            )\n        list.extend(self, data_values)\n        if len(self._value) > 0:\n            last_item = self._value[-1]\n            last_value_item = next(\n                (\n                    v\n                    for v in self._value[::-1]\n                    if v.value is not None and not isinstance(v.value, Null)\n                ),\n                None,\n            )\n            if last_value_item is not None:\n                last_value_item.comma = Whitespace(\",\")\n            if last_item.is_whitespace():\n                self._value[-1:-1] = self._group_values(new_values)\n            else:\n                self._value.extend(self._group_values(new_values))\n        else:\n            self._value.extend(self._group_values(new_values))\n        self._reindex()\n\n    def clear(self) -> None:\n        \"\"\"Clear the array.\"\"\"\n        list.clear(self)\n        self._index_map.clear()\n        self._value.clear()\n\n    def __len__(self) -> int:\n        return list.__len__(self)\n\n    def __getitem__(self, key: int | slice) -> Any:\n        rv = cast(Item, list.__getitem__(self, key))\n        if rv.is_boolean():\n            return bool(rv)\n        return rv\n\n    def __setitem__(self, key: int | slice, value: Any) -> Any:\n        it = item(value, _parent=self)\n        list.__setitem__(self, key, it)\n        if isinstance(key, slice):\n            raise ValueError(\"slice assignment is not supported\")\n        if key < 0:\n            key += len(self)\n        self._value[self._index_map[key]].value = it\n\n    def insert(self, pos: int, value: Any) -> None:\n        it = item(value, _parent=self)\n        length = len(self)\n        if not isinstance(it, (Comment, Whitespace)):\n            list.insert(self, pos, it)\n        if pos < 0:\n            pos += length\n            if pos < 0:\n                pos = 0\n\n        idx = 0  # insert position of the self._value list\n        default_indent = \" \"\n        if pos < length:\n            try:\n                idx = self._index_map[pos]\n            except KeyError as e:\n                raise IndexError(\"list index out of range\") from e\n        else:\n            idx = len(self._value)\n            if idx >= 1 and self._value[idx - 1].is_whitespace():\n                # The last item is a pure whitespace(\\n ), insert before it\n                idx -= 1\n                if (\n                    self._value[idx].indent is not None\n                    and \"\\n\" in self._value[idx].indent.s\n                ):\n                    default_indent = \"\\n    \"\n        indent: Item | None = None\n        comma: Item | None = Whitespace(\",\") if pos < length else None\n        if idx < len(self._value) and not self._value[idx].is_whitespace():\n            # Prefer to copy the indentation from the item after\n            indent = self._value[idx].indent\n        if idx > 0:\n            last_item = self._value[idx - 1]\n            if indent is None:\n                indent = last_item.indent\n            if not isinstance(last_item.value, Null) and \"\\n\" in default_indent:\n                # Copy the comma from the last item if 1) it contains a value and\n                # 2) the array is multiline\n                comma = last_item.comma\n            if last_item.comma is None and not isinstance(last_item.value, Null):\n                # Add comma to the last item to separate it from the following items.\n                last_item.comma = Whitespace(\",\")\n        if indent is None and (idx > 0 or \"\\n\" in default_indent):\n            # apply default indent if it isn't the first item or the array is multiline.\n            indent = Whitespace(default_indent)\n        new_item = _ArrayItemGroup(value=it, indent=indent, comma=comma)\n        self._value.insert(idx, new_item)\n        self._reindex()\n\n    def __delitem__(self, key: int | slice):\n        length = len(self)\n        list.__delitem__(self, key)\n\n        if isinstance(key, slice):\n            indices_to_remove = list(\n                range(key.start or 0, key.stop or length, key.step or 1)\n            )\n        else:\n            indices_to_remove = [length + key if key < 0 else key]\n        for i in sorted(indices_to_remove, reverse=True):\n            try:\n                idx = self._index_map[i]\n            except KeyError as e:\n                if not isinstance(key, slice):\n                    raise IndexError(\"list index out of range\") from e\n            else:\n                del self._value[idx]\n                if (\n                    idx == 0\n                    and len(self._value) > 0\n                    and self._value[idx].indent\n                    and \"\\n\" not in self._value[idx].indent.s\n                ):\n                    # Remove the indentation of the first item if not newline\n                    self._value[idx].indent = None\n        if len(self._value) > 0:\n            v = self._value[-1]\n            if not v.is_whitespace():\n                # remove the comma of the last item\n                v.comma = None\n\n        self._reindex()\n\n    def _getstate(self, protocol=3):\n        return list(self._iter_items()), self._trivia, self._multiline\n\n\nclass AbstractTable(Item, _CustomDict):\n    \"\"\"Common behaviour of both :class:`Table` and :class:`InlineTable`\"\"\"\n\n    def __init__(self, value: container.Container, trivia: Trivia):\n        Item.__init__(self, trivia)\n\n        self._value = value\n\n        for k, v in self._value.body:\n            if k is not None:\n                dict.__setitem__(self, k.key, v)\n\n    def unwrap(self) -> dict[str, Any]:\n        unwrapped = {}\n        for k, v in self.items():\n            if isinstance(k, Key):\n                k = k.key\n            if hasattr(v, \"unwrap\"):\n                v = v.unwrap()\n            unwrapped[k] = v\n\n        return unwrapped\n\n    @property\n    def value(self) -> container.Container:\n        return self._value\n\n    @overload\n    def append(self: AT, key: None, value: Comment | Whitespace) -> AT: ...\n\n    @overload\n    def append(self: AT, key: Key | str, value: Any) -> AT: ...\n\n    def append(self, key, value):\n        raise NotImplementedError\n\n    @overload\n    def add(self: AT, key: Comment | Whitespace) -> AT: ...\n\n    @overload\n    def add(self: AT, key: Key | str, value: Any = ...) -> AT: ...\n\n    def add(self, key, value=None):\n        if value is None:\n            if not isinstance(key, (Comment, Whitespace)):\n                msg = \"Non comment/whitespace items must have an associated key\"\n                raise ValueError(msg)\n\n            key, value = None, key\n\n        return self.append(key, value)\n\n    def remove(self: AT, key: Key | str) -> AT:\n        self._value.remove(key)\n\n        if isinstance(key, Key):\n            key = key.key\n\n        if key is not None:\n            dict.__delitem__(self, key)\n\n        return self\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default)\n        return self[key]\n\n    def __str__(self):\n        return str(self.value)\n\n    def copy(self: AT) -> AT:\n        return copy.copy(self)\n\n    def __repr__(self) -> str:\n        return repr(self.value)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(self._value)\n\n    def __len__(self) -> int:\n        return len(self._value)\n\n    def __delitem__(self, key: Key | str) -> None:\n        self.remove(key)\n\n    def __getitem__(self, key: Key | str) -> Item:\n        return cast(Item, self._value[key])\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if not isinstance(value, Item):\n            value = item(value, _parent=self)\n\n        is_replace = key in self\n        self._value[key] = value\n\n        if key is not None:\n            dict.__setitem__(self, key, value)\n\n        if is_replace:\n            return\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            return\n\n        indent = m.group(1)\n\n        if not isinstance(value, Whitespace):\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", value.trivia.indent)\n            if not m:\n                value.trivia.indent = indent\n            else:\n                value.trivia.indent = m.group(1) + indent + m.group(2)\n\n\nclass Table(AbstractTable):\n    \"\"\"\n    A table literal.\n    \"\"\"\n\n    def __init__(\n        self,\n        value: container.Container,\n        trivia: Trivia,\n        is_aot_element: bool,\n        is_super_table: bool | None = None,\n        name: str | None = None,\n        display_name: str | None = None,\n    ) -> None:\n        super().__init__(value, trivia)\n\n        self.name = name\n        self.display_name = display_name\n        self._is_aot_element = is_aot_element\n        self._is_super_table = is_super_table\n\n    @property\n    def discriminant(self) -> int:\n        return 9\n\n    def __copy__(self) -> Table:\n        return type(self)(\n            self._value.copy(),\n            self._trivia.copy(),\n            self._is_aot_element,\n            self._is_super_table,\n            self.name,\n            self.display_name,\n        )\n\n    def append(self, key: Key | str | None, _item: Any) -> Table:\n        \"\"\"\n        Appends a (key, item) to the table.\n        \"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item, _parent=self)\n\n        self._value.append(key, _item)\n\n        if isinstance(key, Key):\n            key = next(iter(key)).key\n            _item = self._value[key]\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        m = re.match(r\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            return self\n\n        indent = m.group(1)\n\n        if not isinstance(_item, Whitespace):\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", _item.trivia.indent)\n            if not m:\n                _item.trivia.indent = indent\n            else:\n                _item.trivia.indent = m.group(1) + indent + m.group(2)\n\n        return self\n\n    def raw_append(self, key: Key | str | None, _item: Any) -> Table:\n        \"\"\"Similar to :meth:`append` but does not copy indentation.\"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item)\n\n        self._value.append(key, _item, validate=False)\n\n        if isinstance(key, Key):\n            key = next(iter(key)).key\n            _item = self._value[key]\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        return self\n\n    def is_aot_element(self) -> bool:\n        \"\"\"True if the table is the direct child of an AOT element.\"\"\"\n        return self._is_aot_element\n\n    def is_super_table(self) -> bool:\n        \"\"\"A super table is the intermediate parent of a nested table as in [a.b.c].\n        If true, it won't appear in the TOML representation.\"\"\"\n        if self._is_super_table is not None:\n            return self._is_super_table\n        # If the table has only one child and that child is a table, then it is a super table.\n        if len(self) != 1:\n            return False\n        only_child = next(iter(self.values()))\n        return isinstance(only_child, (Table, AoT))\n\n    def as_string(self) -> str:\n        return self._value.as_string()\n\n    # Helpers\n\n    def indent(self, indent: int) -> Table:\n        \"\"\"Indent the table with given number of spaces.\"\"\"\n        super().indent(indent)\n\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if not m:\n            indent_str = \"\"\n        else:\n            indent_str = m.group(1)\n\n        for _, item in self._value.body:\n            if not isinstance(item, Whitespace):\n                item.trivia.indent = indent_str + item.trivia.indent\n\n        return self\n\n    def invalidate_display_name(self):\n        \"\"\"Call ``invalidate_display_name`` on the contained tables\"\"\"\n        self.display_name = None\n\n        for child in self.values():\n            if hasattr(child, \"invalidate_display_name\"):\n                child.invalidate_display_name()\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (\n            self._value,\n            self._trivia,\n            self._is_aot_element,\n            self._is_super_table,\n            self.name,\n            self.display_name,\n        )\n\n\nclass InlineTable(AbstractTable):\n    \"\"\"\n    An inline table literal.\n    \"\"\"\n\n    def __init__(\n        self, value: container.Container, trivia: Trivia, new: bool = False\n    ) -> None:\n        super().__init__(value, trivia)\n\n        self._new = new\n\n    @property\n    def discriminant(self) -> int:\n        return 10\n\n    def append(self, key: Key | str | None, _item: Any) -> InlineTable:\n        \"\"\"\n        Appends a (key, item) to the table.\n        \"\"\"\n        if not isinstance(_item, Item):\n            _item = item(_item, _parent=self)\n\n        if not isinstance(_item, (Whitespace, Comment)):\n            if not _item.trivia.indent and len(self._value) > 0 and not self._new:\n                _item.trivia.indent = \" \"\n            if _item.trivia.comment:\n                _item.trivia.comment = \"\"\n\n        self._value.append(key, _item)\n\n        if isinstance(key, Key):\n            key = key.key\n\n        if key is not None:\n            dict.__setitem__(self, key, _item)\n\n        return self\n\n    def as_string(self) -> str:\n        buf = \"{\"\n        last_item_idx = next(\n            (\n                i\n                for i in range(len(self._value.body) - 1, -1, -1)\n                if self._value.body[i][0] is not None\n            ),\n            None,\n        )\n        for i, (k, v) in enumerate(self._value.body):\n            if k is None:\n                if i == len(self._value.body) - 1:\n                    if self._new:\n                        buf = buf.rstrip(\", \")\n                    else:\n                        buf = buf.rstrip(\",\")\n\n                buf += v.as_string()\n\n                continue\n\n            v_trivia_trail = v.trivia.trail.replace(\"\\n\", \"\")\n            buf += (\n                f\"{v.trivia.indent}\"\n                f'{k.as_string() + (\".\" if k.is_dotted() else \"\")}'\n                f\"{k.sep}\"\n                f\"{v.as_string()}\"\n                f\"{v.trivia.comment}\"\n                f\"{v_trivia_trail}\"\n            )\n\n            if last_item_idx is not None and i < last_item_idx:\n                buf += \",\"\n                if self._new:\n                    buf += \" \"\n\n        buf += \"}\"\n\n        return buf\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if hasattr(value, \"trivia\") and value.trivia.comment:\n            value.trivia.comment = \"\"\n        super().__setitem__(key, value)\n\n    def __copy__(self) -> InlineTable:\n        return type(self)(self._value.copy(), self._trivia.copy(), self._new)\n\n    def _getstate(self, protocol: int = 3) -> tuple:\n        return (self._value, self._trivia)\n\n\nclass String(str, Item):\n    \"\"\"\n    A string literal.\n    \"\"\"\n\n    def __new__(cls, t, value, original, trivia):\n        return super().__new__(cls, value)\n\n    def __init__(self, t: StringType, _: str, original: str, trivia: Trivia) -> None:\n        super().__init__(trivia)\n\n        self._t = t\n        self._original = original\n\n    def unwrap(self) -> str:\n        return str(self)\n\n    @property\n    def discriminant(self) -> int:\n        return 11\n\n    @property\n    def value(self) -> str:\n        return self\n\n    def as_string(self) -> str:\n        return f\"{self._t.value}{decode(self._original)}{self._t.value}\"\n\n    def __add__(self: ItemT, other: str) -> ItemT:\n        if not isinstance(other, str):\n            return NotImplemented\n        result = super().__add__(other)\n        original = self._original + getattr(other, \"_original\", other)\n\n        return self._new(result, original)\n\n    def _new(self, result: str, original: str) -> String:\n        return String(self._t, result, original, self._trivia)\n\n    def _getstate(self, protocol=3):\n        return self._t, str(self), self._original, self._trivia\n\n    @classmethod\n    def from_raw(cls, value: str, type_=StringType.SLB, escape=True) -> String:\n        value = decode(value)\n\n        invalid = type_.invalid_sequences\n        if any(c in value for c in invalid):\n            raise InvalidStringError(value, invalid, type_.value)\n\n        escaped = type_.escaped_sequences\n        string_value = escape_string(value, escaped) if escape and escaped else value\n\n        return cls(type_, decode(value), string_value, Trivia())\n\n\nclass AoT(Item, _CustomList):\n    \"\"\"\n    An array of table literal\n    \"\"\"\n\n    def __init__(\n        self, body: list[Table], name: str | None = None, parsed: bool = False\n    ) -> None:\n        self.name = name\n        self._body: list[Table] = []\n        self._parsed = parsed\n\n        super().__init__(Trivia(trail=\"\"))\n\n        for table in body:\n            self.append(table)\n\n    def unwrap(self) -> list[dict[str, Any]]:\n        unwrapped = []\n        for t in self._body:\n            if hasattr(t, \"unwrap\"):\n                unwrapped.append(t.unwrap())\n            else:\n                unwrapped.append(t)\n        return unwrapped\n\n    @property\n    def body(self) -> list[Table]:\n        return self._body\n\n    @property\n    def discriminant(self) -> int:\n        return 12\n\n    @property\n    def value(self) -> list[dict[Any, Any]]:\n        return [v.value for v in self._body]\n\n    def __len__(self) -> int:\n        return len(self._body)\n\n    @overload\n    def __getitem__(self, key: slice) -> list[Table]: ...\n\n    @overload\n    def __getitem__(self, key: int) -> Table: ...\n\n    def __getitem__(self, key):\n        return self._body[key]\n\n    def __setitem__(self, key: slice | int, value: Any) -> None:\n        raise NotImplementedError\n\n    def __delitem__(self, key: slice | int) -> None:\n        del self._body[key]\n        list.__delitem__(self, key)\n\n    def insert(self, index: int, value: dict) -> None:\n        value = item(value, _parent=self)\n        if not isinstance(value, Table):\n            raise ValueError(f\"Unsupported insert value type: {type(value)}\")\n        length = len(self)\n        if index < 0:\n            index += length\n        if index < 0:\n            index = 0\n        elif index >= length:\n            index = length\n        m = re.match(\"(?s)^[^ ]*([ ]+).*$\", self._trivia.indent)\n        if m:\n            indent = m.group(1)\n\n            m = re.match(\"(?s)^([^ ]*)(.*)$\", value.trivia.indent)\n            if not m:\n                value.trivia.indent = indent\n            else:\n                value.trivia.indent = m.group(1) + indent + m.group(2)\n        prev_table = self._body[index - 1] if 0 < index and length else None\n        next_table = self._body[index + 1] if index < length - 1 else None\n        if not self._parsed:\n            if prev_table and \"\\n\" not in value.trivia.indent:\n                value.trivia.indent = \"\\n\" + value.trivia.indent\n            if next_table and \"\\n\" not in next_table.trivia.indent:\n                next_table.trivia.indent = \"\\n\" + next_table.trivia.indent\n        self._body.insert(index, value)\n        list.insert(self, index, value)\n\n    def invalidate_display_name(self):\n        \"\"\"Call ``invalidate_display_name`` on the contained tables\"\"\"\n        for child in self:\n            if hasattr(child, \"invalidate_display_name\"):\n                child.invalidate_display_name()\n\n    def as_string(self) -> str:\n        b = \"\"\n        for table in self._body:\n            b += table.as_string()\n\n        return b\n\n    def __repr__(self) -> str:\n        return f\"<AoT {self.value}>\"\n\n    def _getstate(self, protocol=3):\n        return self._body, self.name, self._parsed\n\n\nclass Null(Item):\n    \"\"\"\n    A null item.\n    \"\"\"\n\n    def __init__(self) -> None:\n        super().__init__(Trivia(trail=\"\"))\n\n    def unwrap(self) -> None:\n        return None\n\n    @property\n    def discriminant(self) -> int:\n        return -1\n\n    @property\n    def value(self) -> None:\n        return None\n\n    def as_string(self) -> str:\n        return \"\"\n\n    def _getstate(self, protocol=3) -> tuple:\n        return ()\n", "tomlkit/api.py": "from __future__ import annotations\n\nimport contextlib\nimport datetime as _datetime\n\nfrom collections.abc import Mapping\nfrom typing import IO\nfrom typing import Iterable\nfrom typing import TypeVar\n\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.container import Container\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.items import CUSTOM_ENCODERS\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import DottedKey\nfrom tomlkit.items import Encoder\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item as _Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType as _StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.items import item\nfrom tomlkit.parser import Parser\nfrom tomlkit.toml_document import TOMLDocument\n\n\ndef loads(string: str | bytes) -> TOMLDocument:\n    \"\"\"\n    Parses a string into a TOMLDocument.\n\n    Alias for parse().\n    \"\"\"\n    return parse(string)\n\n\ndef dumps(data: Mapping, sort_keys: bool = False) -> str:\n    \"\"\"\n    Dumps a TOMLDocument into a string.\n    \"\"\"\n    if not isinstance(data, Container) and isinstance(data, Mapping):\n        data = item(dict(data), _sort_keys=sort_keys)\n\n    try:\n        # data should be a `Container` (and therefore implement `as_string`)\n        # for all type safe invocations of this function\n        return data.as_string()  # type: ignore[attr-defined]\n    except AttributeError as ex:\n        msg = f\"Expecting Mapping or TOML Container, {type(data)} given\"\n        raise TypeError(msg) from ex\n\n\ndef load(fp: IO[str] | IO[bytes]) -> TOMLDocument:\n    \"\"\"\n    Load toml document from a file-like object.\n    \"\"\"\n    return parse(fp.read())\n\n\ndef dump(data: Mapping, fp: IO[str], *, sort_keys: bool = False) -> None:\n    \"\"\"\n    Dump a TOMLDocument into a writable file stream.\n\n    :param data: a dict-like object to dump\n    :param sort_keys: if true, sort the keys in alphabetic order\n    \"\"\"\n    fp.write(dumps(data, sort_keys=sort_keys))\n\n\ndef parse(string: str | bytes) -> TOMLDocument:\n    \"\"\"\n    Parses a string or bytes into a TOMLDocument.\n    \"\"\"\n    return Parser(string).parse()\n\n\ndef document() -> TOMLDocument:\n    \"\"\"\n    Returns a new TOMLDocument instance.\n    \"\"\"\n    return TOMLDocument()\n\n\n# Items\ndef integer(raw: str | int) -> Integer:\n    \"\"\"Create an integer item from a number or string.\"\"\"\n    return item(int(raw))\n\n\ndef float_(raw: str | float) -> Float:\n    \"\"\"Create an float item from a number or string.\"\"\"\n    return item(float(raw))\n\n\ndef boolean(raw: str) -> Bool:\n    \"\"\"Turn `true` or `false` into a boolean item.\"\"\"\n    return item(raw == \"true\")\n\n\ndef string(\n    raw: str,\n    *,\n    literal: bool = False,\n    multiline: bool = False,\n    escape: bool = True,\n) -> String:\n    \"\"\"Create a string item.\n\n    By default, this function will create *single line basic* strings, but\n    boolean flags (e.g. ``literal=True`` and/or ``multiline=True``)\n    can be used for personalization.\n\n    For more information, please check the spec: `<https://toml.io/en/v1.0.0#string>`__.\n\n    Common escaping rules will be applied for basic strings.\n    This can be controlled by explicitly setting ``escape=False``.\n    Please note that, if you disable escaping, you will have to make sure that\n    the given strings don't contain any forbidden character or sequence.\n    \"\"\"\n    type_ = _StringType.select(literal, multiline)\n    return String.from_raw(raw, type_, escape)\n\n\ndef date(raw: str) -> Date:\n    \"\"\"Create a TOML date.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.date):\n        raise ValueError(\"date() only accepts date strings.\")\n\n    return item(value)\n\n\ndef time(raw: str) -> Time:\n    \"\"\"Create a TOML time.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.time):\n        raise ValueError(\"time() only accepts time strings.\")\n\n    return item(value)\n\n\ndef datetime(raw: str) -> DateTime:\n    \"\"\"Create a TOML datetime.\"\"\"\n    value = parse_rfc3339(raw)\n    if not isinstance(value, _datetime.datetime):\n        raise ValueError(\"datetime() only accepts datetime strings.\")\n\n    return item(value)\n\n\ndef array(raw: str = \"[]\") -> Array:\n    \"\"\"Create an array item for its string representation.\n\n    :Example:\n\n    >>> array(\"[1, 2, 3]\")  # Create from a string\n    [1, 2, 3]\n    >>> a = array()\n    >>> a.extend([1, 2, 3])  # Create from a list\n    >>> a\n    [1, 2, 3]\n    \"\"\"\n    return value(raw)\n\n\ndef table(is_super_table: bool | None = None) -> Table:\n    \"\"\"Create an empty table.\n\n    :param is_super_table: if true, the table is a super table\n\n    :Example:\n\n    >>> doc = document()\n    >>> foo = table(True)\n    >>> bar = table()\n    >>> bar.update({'x': 1})\n    >>> foo.append('bar', bar)\n    >>> doc.append('foo', foo)\n    >>> print(doc.as_string())\n    [foo.bar]\n    x = 1\n    \"\"\"\n    return Table(Container(), Trivia(), False, is_super_table)\n\n\ndef inline_table() -> InlineTable:\n    \"\"\"Create an inline table.\n\n    :Example:\n\n    >>> table = inline_table()\n    >>> table.update({'x': 1, 'y': 2})\n    >>> print(table.as_string())\n    {x = 1, y = 2}\n    \"\"\"\n    return InlineTable(Container(), Trivia(), new=True)\n\n\ndef aot() -> AoT:\n    \"\"\"Create an array of table.\n\n    :Example:\n\n    >>> doc = document()\n    >>> aot = aot()\n    >>> aot.append(item({'x': 1}))\n    >>> doc.append('foo', aot)\n    >>> print(doc.as_string())\n    [[foo]]\n    x = 1\n    \"\"\"\n    return AoT([])\n\n\ndef key(k: str | Iterable[str]) -> Key:\n    \"\"\"Create a key from a string. When a list of string is given,\n    it will create a dotted key.\n\n    :Example:\n\n    >>> doc = document()\n    >>> doc.append(key('foo'), 1)\n    >>> doc.append(key(['bar', 'baz']), 2)\n    >>> print(doc.as_string())\n    foo = 1\n    bar.baz = 2\n    \"\"\"\n    if isinstance(k, str):\n        return SingleKey(k)\n    return DottedKey([key(_k) for _k in k])\n\n\ndef value(raw: str) -> _Item:\n    \"\"\"Parse a simple value from a string.\n\n    :Example:\n\n    >>> value(\"1\")\n    1\n    >>> value(\"true\")\n    True\n    >>> value(\"[1, 2, 3]\")\n    [1, 2, 3]\n    \"\"\"\n    parser = Parser(raw)\n    v = parser._parse_value()\n    if not parser.end():\n        raise parser.parse_error(UnexpectedCharError, char=parser._current)\n    return v\n\n\ndef key_value(src: str) -> tuple[Key, _Item]:\n    \"\"\"Parse a key-value pair from a string.\n\n    :Example:\n\n    >>> key_value(\"foo = 1\")\n    (Key('foo'), 1)\n    \"\"\"\n    return Parser(src)._parse_key_value()\n\n\ndef ws(src: str) -> Whitespace:\n    \"\"\"Create a whitespace from a string.\"\"\"\n    return Whitespace(src, fixed=True)\n\n\ndef nl() -> Whitespace:\n    \"\"\"Create a newline item.\"\"\"\n    return ws(\"\\n\")\n\n\ndef comment(string: str) -> Comment:\n    \"\"\"Create a comment item.\"\"\"\n    return Comment(Trivia(comment_ws=\"  \", comment=\"# \" + string))\n\n\nE = TypeVar(\"E\", bound=Encoder)\n\n\ndef register_encoder(encoder: E) -> E:\n    \"\"\"Add a custom encoder, which should be a function that will be called\n    if the value can't otherwise be converted. It should takes a single value\n    and return a TOMLKit item or raise a ``TypeError``.\n    \"\"\"\n    CUSTOM_ENCODERS.append(encoder)\n    return encoder\n\n\ndef unregister_encoder(encoder: Encoder) -> None:\n    \"\"\"Unregister a custom encoder.\"\"\"\n    with contextlib.suppress(ValueError):\n        CUSTOM_ENCODERS.remove(encoder)\n", "tomlkit/toml_document.py": "from tomlkit.container import Container\n\n\nclass TOMLDocument(Container):\n    \"\"\"\n    A TOML document.\n    \"\"\"\n", "tomlkit/container.py": "from __future__ import annotations\n\nimport copy\n\nfrom typing import Any\nfrom typing import Iterator\n\nfrom tomlkit._compat import decode\nfrom tomlkit._types import _CustomDict\nfrom tomlkit._utils import merge_dicts\nfrom tomlkit.exceptions import KeyAlreadyPresent\nfrom tomlkit.exceptions import NonExistentKey\nfrom tomlkit.exceptions import TOMLKitError\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import Table\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.items import item as _item\n\n\n_NOT_SET = object()\n\n\nclass Container(_CustomDict):\n    \"\"\"\n    A container for items within a TOMLDocument.\n\n    This class implements the `dict` interface with copy/deepcopy protocol.\n    \"\"\"\n\n    def __init__(self, parsed: bool = False) -> None:\n        self._map: dict[SingleKey, int | tuple[int, ...]] = {}\n        self._body: list[tuple[Key | None, Item]] = []\n        self._parsed = parsed\n        self._table_keys = []\n\n    @property\n    def body(self) -> list[tuple[Key | None, Item]]:\n        return self._body\n\n    def unwrap(self) -> dict[str, Any]:\n        \"\"\"Returns as pure python object (ppo)\"\"\"\n        unwrapped = {}\n        for k, v in self.items():\n            if k is None:\n                continue\n\n            if isinstance(k, Key):\n                k = k.key\n\n            if hasattr(v, \"unwrap\"):\n                v = v.unwrap()\n\n            if k in unwrapped:\n                merge_dicts(unwrapped[k], v)\n            else:\n                unwrapped[k] = v\n\n        return unwrapped\n\n    @property\n    def value(self) -> dict[str, Any]:\n        \"\"\"The wrapped dict value\"\"\"\n        d = {}\n        for k, v in self._body:\n            if k is None:\n                continue\n\n            k = k.key\n            v = v.value\n\n            if isinstance(v, Container):\n                v = v.value\n\n            if k in d:\n                merge_dicts(d[k], v)\n            else:\n                d[k] = v\n\n        return d\n\n    def parsing(self, parsing: bool) -> None:\n        self._parsed = parsing\n\n        for _, v in self._body:\n            if isinstance(v, Table):\n                v.value.parsing(parsing)\n            elif isinstance(v, AoT):\n                for t in v.body:\n                    t.value.parsing(parsing)\n\n    def add(self, key: Key | Item | str, item: Item | None = None) -> Container:\n        \"\"\"\n        Adds an item to the current Container.\n\n        :Example:\n\n        >>> # add a key-value pair\n        >>> doc.add('key', 'value')\n        >>> # add a comment or whitespace or newline\n        >>> doc.add(comment('# comment'))\n        \"\"\"\n        if item is None:\n            if not isinstance(key, (Comment, Whitespace)):\n                raise ValueError(\n                    \"Non comment/whitespace items must have an associated key\"\n                )\n\n            key, item = None, key\n\n        return self.append(key, item)\n\n    def _handle_dotted_key(self, key: Key, value: Item) -> None:\n        if isinstance(value, (Table, AoT)):\n            raise TOMLKitError(\"Can't add a table to a dotted key\")\n        name, *mid, last = key\n        name._dotted = True\n        table = current = Table(Container(True), Trivia(), False, is_super_table=True)\n        for _name in mid:\n            _name._dotted = True\n            new_table = Table(Container(True), Trivia(), False, is_super_table=True)\n            current.append(_name, new_table)\n            current = new_table\n\n        last.sep = key.sep\n        current.append(last, value)\n\n        self.append(name, table)\n        return\n\n    def _get_last_index_before_table(self) -> int:\n        last_index = -1\n        for i, (k, v) in enumerate(self._body):\n            if isinstance(v, Null):\n                continue  # Null elements are inserted after deletion\n\n            if isinstance(v, Whitespace) and not v.is_fixed():\n                continue\n\n            if isinstance(v, (Table, AoT)) and not k.is_dotted():\n                break\n            last_index = i\n        return last_index + 1\n\n    def _validate_out_of_order_table(self, key: SingleKey | None = None) -> None:\n        if key is None:\n            for k in self._map:\n                assert k is not None\n                self._validate_out_of_order_table(k)\n            return\n        if key not in self._map or not isinstance(self._map[key], tuple):\n            return\n        OutOfOrderTableProxy(self, self._map[key])\n\n    def append(\n        self, key: Key | str | None, item: Item, validate: bool = True\n    ) -> Container:\n        \"\"\"Similar to :meth:`add` but both key and value must be given.\"\"\"\n        if not isinstance(key, Key) and key is not None:\n            key = SingleKey(key)\n\n        if not isinstance(item, Item):\n            item = _item(item)\n\n        if key is not None and key.is_multi():\n            self._handle_dotted_key(key, item)\n            return self\n\n        if isinstance(item, (AoT, Table)) and item.name is None:\n            item.name = key.key\n\n        prev = self._previous_item()\n        prev_ws = isinstance(prev, Whitespace) or ends_with_whitespace(prev)\n        if isinstance(item, Table):\n            if not self._parsed:\n                item.invalidate_display_name()\n            if (\n                self._body\n                and not (self._parsed or item.trivia.indent or prev_ws)\n                and not key.is_dotted()\n            ):\n                item.trivia.indent = \"\\n\"\n\n        if isinstance(item, AoT) and self._body and not self._parsed:\n            item.invalidate_display_name()\n            if item and not (\"\\n\" in item[0].trivia.indent or prev_ws):\n                item[0].trivia.indent = \"\\n\" + item[0].trivia.indent\n\n        if key is not None and key in self:\n            current_idx = self._map[key]\n            if isinstance(current_idx, tuple):\n                current_body_element = self._body[current_idx[-1]]\n            else:\n                current_body_element = self._body[current_idx]\n\n            current = current_body_element[1]\n\n            if isinstance(item, Table):\n                if not isinstance(current, (Table, AoT)):\n                    raise KeyAlreadyPresent(key)\n\n                if item.is_aot_element():\n                    # New AoT element found later on\n                    # Adding it to the current AoT\n                    if not isinstance(current, AoT):\n                        current = AoT([current, item], parsed=self._parsed)\n\n                        self._replace(key, key, current)\n                    else:\n                        current.append(item)\n\n                    return self\n                elif current.is_aot():\n                    if not item.is_aot_element():\n                        # Tried to define a table after an AoT with the same name.\n                        raise KeyAlreadyPresent(key)\n\n                    current.append(item)\n\n                    return self\n                elif current.is_super_table():\n                    if item.is_super_table():\n                        # We need to merge both super tables\n                        if (\n                            key.is_dotted()\n                            or current_body_element[0].is_dotted()\n                            or self._table_keys[-1] != current_body_element[0]\n                        ):\n                            if key.is_dotted() and not self._parsed:\n                                idx = self._get_last_index_before_table()\n                            else:\n                                idx = len(self._body)\n\n                            if idx < len(self._body):\n                                self._insert_at(idx, key, item)\n                            else:\n                                self._raw_append(key, item)\n\n                            if validate:\n                                self._validate_out_of_order_table(key)\n\n                            return self\n\n                        # Create a new element to replace the old one\n                        current = copy.deepcopy(current)\n                        for k, v in item.value.body:\n                            current.append(k, v)\n                        self._body[\n                            (\n                                current_idx[-1]\n                                if isinstance(current_idx, tuple)\n                                else current_idx\n                            )\n                        ] = (current_body_element[0], current)\n\n                        return self\n                    elif current_body_element[0].is_dotted():\n                        raise TOMLKitError(\"Redefinition of an existing table\")\n                elif not item.is_super_table():\n                    raise KeyAlreadyPresent(key)\n            elif isinstance(item, AoT):\n                if not isinstance(current, AoT):\n                    # Tried to define an AoT after a table with the same name.\n                    raise KeyAlreadyPresent(key)\n\n                for table in item.body:\n                    current.append(table)\n\n                return self\n            else:\n                raise KeyAlreadyPresent(key)\n\n        is_table = isinstance(item, (Table, AoT))\n        if (\n            key is not None\n            and self._body\n            and not self._parsed\n            and (not is_table or key.is_dotted())\n        ):\n            # If there is already at least one table in the current container\n            # and the given item is not a table, we need to find the last\n            # item that is not a table and insert after it\n            # If no such item exists, insert at the top of the table\n            last_index = self._get_last_index_before_table()\n\n            if last_index < len(self._body):\n                return self._insert_at(last_index, key, item)\n            else:\n                previous_item = self._body[-1][1]\n                if not (\n                    isinstance(previous_item, Whitespace)\n                    or ends_with_whitespace(previous_item)\n                    or \"\\n\" in previous_item.trivia.trail\n                ):\n                    previous_item.trivia.trail += \"\\n\"\n\n        self._raw_append(key, item)\n        return self\n\n    def _raw_append(self, key: Key | None, item: Item) -> None:\n        if key in self._map:\n            current_idx = self._map[key]\n            if not isinstance(current_idx, tuple):\n                current_idx = (current_idx,)\n\n            current = self._body[current_idx[-1]][1]\n            if key is not None and not isinstance(current, Table):\n                raise KeyAlreadyPresent(key)\n\n            self._map[key] = (*current_idx, len(self._body))\n        elif key is not None:\n            self._map[key] = len(self._body)\n\n        self._body.append((key, item))\n        if item.is_table():\n            self._table_keys.append(key)\n\n        if key is not None:\n            dict.__setitem__(self, key.key, item.value)\n\n    def _remove_at(self, idx: int) -> None:\n        key = self._body[idx][0]\n        index = self._map.get(key)\n        if index is None:\n            raise NonExistentKey(key)\n        self._body[idx] = (None, Null())\n\n        if isinstance(index, tuple):\n            index = list(index)\n            index.remove(idx)\n            if len(index) == 1:\n                index = index.pop()\n            else:\n                index = tuple(index)\n            self._map[key] = index\n        else:\n            dict.__delitem__(self, key.key)\n            self._map.pop(key)\n\n    def remove(self, key: Key | str) -> Container:\n        \"\"\"Remove a key from the container.\"\"\"\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.pop(key, None)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        if isinstance(idx, tuple):\n            for i in idx:\n                self._body[i] = (None, Null())\n        else:\n            self._body[idx] = (None, Null())\n\n        dict.__delitem__(self, key.key)\n\n        return self\n\n    def _insert_after(\n        self, key: Key | str, other_key: Key | str, item: Any\n    ) -> Container:\n        if key is None:\n            raise ValueError(\"Key cannot be null in insert_after()\")\n\n        if key not in self:\n            raise NonExistentKey(key)\n\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        if not isinstance(other_key, Key):\n            other_key = SingleKey(other_key)\n\n        item = _item(item)\n\n        idx = self._map[key]\n        # Insert after the max index if there are many.\n        if isinstance(idx, tuple):\n            idx = max(idx)\n        current_item = self._body[idx][1]\n        if \"\\n\" not in current_item.trivia.trail:\n            current_item.trivia.trail += \"\\n\"\n\n        # Increment indices after the current index\n        for k, v in self._map.items():\n            if isinstance(v, tuple):\n                new_indices = []\n                for v_ in v:\n                    if v_ > idx:\n                        v_ = v_ + 1\n\n                    new_indices.append(v_)\n\n                self._map[k] = tuple(new_indices)\n            elif v > idx:\n                self._map[k] = v + 1\n\n        self._map[other_key] = idx + 1\n        self._body.insert(idx + 1, (other_key, item))\n\n        if key is not None:\n            dict.__setitem__(self, other_key.key, item.value)\n\n        return self\n\n    def _insert_at(self, idx: int, key: Key | str, item: Any) -> Container:\n        if idx > len(self._body) - 1:\n            raise ValueError(f\"Unable to insert at position {idx}\")\n\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        item = _item(item)\n\n        if idx > 0:\n            previous_item = self._body[idx - 1][1]\n            if not (\n                isinstance(previous_item, Whitespace)\n                or ends_with_whitespace(previous_item)\n                or isinstance(item, (AoT, Table))\n                or \"\\n\" in previous_item.trivia.trail\n            ):\n                previous_item.trivia.trail += \"\\n\"\n\n        # Increment indices after the current index\n        for k, v in self._map.items():\n            if isinstance(v, tuple):\n                new_indices = []\n                for v_ in v:\n                    if v_ >= idx:\n                        v_ = v_ + 1\n\n                    new_indices.append(v_)\n\n                self._map[k] = tuple(new_indices)\n            elif v >= idx:\n                self._map[k] = v + 1\n\n        if key in self._map:\n            current_idx = self._map[key]\n            if not isinstance(current_idx, tuple):\n                current_idx = (current_idx,)\n            self._map[key] = (*current_idx, idx)\n        else:\n            self._map[key] = idx\n        self._body.insert(idx, (key, item))\n\n        dict.__setitem__(self, key.key, item.value)\n\n        return self\n\n    def item(self, key: Key | str) -> Item:\n        \"\"\"Get an item for the given key.\"\"\"\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.get(key)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        if isinstance(idx, tuple):\n            # The item we are getting is an out of order table\n            # so we need a proxy to retrieve the proper objects\n            # from the parent container\n            return OutOfOrderTableProxy(self, idx)\n\n        return self._body[idx][1]\n\n    def last_item(self) -> Item | None:\n        \"\"\"Get the last item.\"\"\"\n        if self._body:\n            return self._body[-1][1]\n\n    def as_string(self) -> str:\n        \"\"\"Render as TOML string.\"\"\"\n        s = \"\"\n        for k, v in self._body:\n            if k is not None:\n                if isinstance(v, Table):\n                    s += self._render_table(k, v)\n                elif isinstance(v, AoT):\n                    s += self._render_aot(k, v)\n                else:\n                    s += self._render_simple_item(k, v)\n            else:\n                s += self._render_simple_item(k, v)\n\n        return s\n\n    def _render_table(self, key: Key, table: Table, prefix: str | None = None) -> str:\n        cur = \"\"\n\n        if table.display_name is not None:\n            _key = table.display_name\n        else:\n            _key = key.as_string()\n\n            if prefix is not None:\n                _key = prefix + \".\" + _key\n\n        if not table.is_super_table() or (\n            any(\n                not isinstance(v, (Table, AoT, Whitespace, Null))\n                for _, v in table.value.body\n            )\n            and not key.is_dotted()\n        ):\n            open_, close = \"[\", \"]\"\n            if table.is_aot_element():\n                open_, close = \"[[\", \"]]\"\n\n            newline_in_table_trivia = (\n                \"\\n\" if \"\\n\" not in table.trivia.trail and len(table.value) > 0 else \"\"\n            )\n            cur += (\n                f\"{table.trivia.indent}\"\n                f\"{open_}\"\n                f\"{decode(_key)}\"\n                f\"{close}\"\n                f\"{table.trivia.comment_ws}\"\n                f\"{decode(table.trivia.comment)}\"\n                f\"{table.trivia.trail}\"\n                f\"{newline_in_table_trivia}\"\n            )\n        elif table.trivia.indent == \"\\n\":\n            cur += table.trivia.indent\n\n        for k, v in table.value.body:\n            if isinstance(v, Table):\n                if v.is_super_table():\n                    if k.is_dotted() and not key.is_dotted():\n                        # Dotted key inside table\n                        cur += self._render_table(k, v)\n                    else:\n                        cur += self._render_table(k, v, prefix=_key)\n                else:\n                    cur += self._render_table(k, v, prefix=_key)\n            elif isinstance(v, AoT):\n                cur += self._render_aot(k, v, prefix=_key)\n            else:\n                cur += self._render_simple_item(\n                    k, v, prefix=_key if key.is_dotted() else None\n                )\n\n        return cur\n\n    def _render_aot(self, key, aot, prefix=None):\n        _key = key.as_string()\n        if prefix is not None:\n            _key = prefix + \".\" + _key\n\n        cur = \"\"\n        _key = decode(_key)\n        for table in aot.body:\n            cur += self._render_aot_table(table, prefix=_key)\n\n        return cur\n\n    def _render_aot_table(self, table: Table, prefix: str | None = None) -> str:\n        cur = \"\"\n        _key = prefix or \"\"\n        open_, close = \"[[\", \"]]\"\n\n        cur += (\n            f\"{table.trivia.indent}\"\n            f\"{open_}\"\n            f\"{decode(_key)}\"\n            f\"{close}\"\n            f\"{table.trivia.comment_ws}\"\n            f\"{decode(table.trivia.comment)}\"\n            f\"{table.trivia.trail}\"\n        )\n\n        for k, v in table.value.body:\n            if isinstance(v, Table):\n                if v.is_super_table():\n                    if k.is_dotted():\n                        # Dotted key inside table\n                        cur += self._render_table(k, v)\n                    else:\n                        cur += self._render_table(k, v, prefix=_key)\n                else:\n                    cur += self._render_table(k, v, prefix=_key)\n            elif isinstance(v, AoT):\n                cur += self._render_aot(k, v, prefix=_key)\n            else:\n                cur += self._render_simple_item(k, v)\n\n        return cur\n\n    def _render_simple_item(self, key, item, prefix=None):\n        if key is None:\n            return item.as_string()\n\n        _key = key.as_string()\n        if prefix is not None:\n            _key = prefix + \".\" + _key\n\n        return (\n            f\"{item.trivia.indent}\"\n            f\"{decode(_key)}\"\n            f\"{key.sep}\"\n            f\"{decode(item.as_string())}\"\n            f\"{item.trivia.comment_ws}\"\n            f\"{decode(item.trivia.comment)}\"\n            f\"{item.trivia.trail}\"\n        )\n\n    def __len__(self) -> int:\n        return dict.__len__(self)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(dict.keys(self))\n\n    # Dictionary methods\n    def __getitem__(self, key: Key | str) -> Item | Container:\n        item = self.item(key)\n        if isinstance(item, Item) and item.is_boolean():\n            return item.value\n\n        return item\n\n    def __setitem__(self, key: Key | str, value: Any) -> None:\n        if key is not None and key in self:\n            old_key = next(filter(lambda k: k == key, self._map))\n            self._replace(old_key, key, value)\n        else:\n            self.append(key, value)\n\n    def __delitem__(self, key: Key | str) -> None:\n        self.remove(key)\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default=default)\n        return self[key]\n\n    def _replace(self, key: Key | str, new_key: Key | str, value: Item) -> None:\n        if not isinstance(key, Key):\n            key = SingleKey(key)\n\n        idx = self._map.get(key)\n        if idx is None:\n            raise NonExistentKey(key)\n\n        self._replace_at(idx, new_key, value)\n\n    def _replace_at(\n        self, idx: int | tuple[int], new_key: Key | str, value: Item\n    ) -> None:\n        value = _item(value)\n\n        if isinstance(idx, tuple):\n            for i in idx[1:]:\n                self._body[i] = (None, Null())\n\n            idx = idx[0]\n\n        k, v = self._body[idx]\n        if not isinstance(new_key, Key):\n            if (\n                isinstance(value, (AoT, Table)) != isinstance(v, (AoT, Table))\n                or new_key != k.key\n            ):\n                new_key = SingleKey(new_key)\n            else:  # Inherit the sep of the old key\n                new_key = k\n\n        del self._map[k]\n        self._map[new_key] = idx\n        if new_key != k:\n            dict.__delitem__(self, k)\n\n        if isinstance(value, (AoT, Table)) != isinstance(v, (AoT, Table)):\n            # new tables should appear after all non-table values\n            self.remove(k)\n            for i in range(idx, len(self._body)):\n                if isinstance(self._body[i][1], (AoT, Table)):\n                    self._insert_at(i, new_key, value)\n                    idx = i\n                    break\n            else:\n                idx = -1\n                self.append(new_key, value)\n        else:\n            # Copying trivia\n            if not isinstance(value, (Whitespace, AoT)):\n                value.trivia.indent = v.trivia.indent\n                value.trivia.comment_ws = value.trivia.comment_ws or v.trivia.comment_ws\n                value.trivia.comment = value.trivia.comment or v.trivia.comment\n                value.trivia.trail = v.trivia.trail\n            self._body[idx] = (new_key, value)\n\n        if hasattr(value, \"invalidate_display_name\"):\n            value.invalidate_display_name()  # type: ignore[attr-defined]\n\n        if isinstance(value, Table):\n            # Insert a cosmetic new line for tables if:\n            # - it does not have it yet OR is not followed by one\n            # - it is not the last item, or\n            # - The table being replaced has a newline\n            last, _ = self._previous_item_with_index()\n            idx = last if idx < 0 else idx\n            has_ws = ends_with_whitespace(value)\n            replace_has_ws = (\n                isinstance(v, Table)\n                and v.value.body\n                and isinstance(v.value.body[-1][1], Whitespace)\n            )\n            next_ws = idx < last and isinstance(self._body[idx + 1][1], Whitespace)\n            if (idx < last or replace_has_ws) and not (next_ws or has_ws):\n                value.append(None, Whitespace(\"\\n\"))\n\n            dict.__setitem__(self, new_key.key, value.value)\n\n    def __str__(self) -> str:\n        return str(self.value)\n\n    def __repr__(self) -> str:\n        return repr(self.value)\n\n    def __eq__(self, other: dict) -> bool:\n        if not isinstance(other, dict):\n            return NotImplemented\n\n        return self.value == other\n\n    def _getstate(self, protocol):\n        return (self._parsed,)\n\n    def __reduce__(self):\n        return self.__reduce_ex__(2)\n\n    def __reduce_ex__(self, protocol):\n        return (\n            self.__class__,\n            self._getstate(protocol),\n            (self._map, self._body, self._parsed, self._table_keys),\n        )\n\n    def __setstate__(self, state):\n        self._map = state[0]\n        self._body = state[1]\n        self._parsed = state[2]\n        self._table_keys = state[3]\n\n        for key, item in self._body:\n            if key is not None:\n                dict.__setitem__(self, key.key, item.value)\n\n    def copy(self) -> Container:\n        return copy.copy(self)\n\n    def __copy__(self) -> Container:\n        c = self.__class__(self._parsed)\n        for k, v in dict.items(self):\n            dict.__setitem__(c, k, v)\n\n        c._body += self.body\n        c._map.update(self._map)\n\n        return c\n\n    def _previous_item_with_index(\n        self, idx: int | None = None, ignore=(Null,)\n    ) -> tuple[int, Item] | None:\n        \"\"\"Find the immediate previous item before index ``idx``\"\"\"\n        if idx is None or idx > len(self._body):\n            idx = len(self._body)\n        for i in range(idx - 1, -1, -1):\n            v = self._body[i][-1]\n            if not isinstance(v, ignore):\n                return i, v\n        return None\n\n    def _previous_item(self, idx: int | None = None, ignore=(Null,)) -> Item | None:\n        \"\"\"Find the immediate previous item before index ``idx``.\n        If ``idx`` is not given, the last item is returned.\n        \"\"\"\n        prev = self._previous_item_with_index(idx, ignore)\n        return prev[-1] if prev else None\n\n\nclass OutOfOrderTableProxy(_CustomDict):\n    def __init__(self, container: Container, indices: tuple[int]) -> None:\n        self._container = container\n        self._internal_container = Container(True)\n        self._tables = []\n        self._tables_map = {}\n\n        for i in indices:\n            _, item = self._container._body[i]\n\n            if isinstance(item, Table):\n                self._tables.append(item)\n                table_idx = len(self._tables) - 1\n                for k, v in item.value.body:\n                    self._internal_container.append(k, v, validate=False)\n                    self._tables_map[k] = table_idx\n                    if k is not None:\n                        dict.__setitem__(self, k.key, v)\n\n        self._internal_container._validate_out_of_order_table()\n\n    def unwrap(self) -> str:\n        return self._internal_container.unwrap()\n\n    @property\n    def value(self):\n        return self._internal_container.value\n\n    def __getitem__(self, key: Key | str) -> Any:\n        if key not in self._internal_container:\n            raise NonExistentKey(key)\n\n        return self._internal_container[key]\n\n    def __setitem__(self, key: Key | str, item: Any) -> None:\n        if key in self._tables_map:\n            table = self._tables[self._tables_map[key]]\n            table[key] = item\n        elif self._tables:\n            table = self._tables[0]\n            table[key] = item\n        else:\n            self._container[key] = item\n\n        self._internal_container[key] = item\n        if key is not None:\n            dict.__setitem__(self, key, item)\n\n    def _remove_table(self, table: Table) -> None:\n        \"\"\"Remove table from the parent container\"\"\"\n        self._tables.remove(table)\n        for idx, item in enumerate(self._container._body):\n            if item[1] is table:\n                self._container._remove_at(idx)\n                break\n\n    def __delitem__(self, key: Key | str) -> None:\n        if key in self._tables_map:\n            table = self._tables[self._tables_map[key]]\n            del table[key]\n            if not table and len(self._tables) > 1:\n                self._remove_table(table)\n            del self._tables_map[key]\n        else:\n            raise NonExistentKey(key)\n\n        del self._internal_container[key]\n        if key is not None:\n            dict.__delitem__(self, key)\n\n    def __iter__(self) -> Iterator[str]:\n        return iter(dict.keys(self))\n\n    def __len__(self) -> int:\n        return dict.__len__(self)\n\n    def setdefault(self, key: Key | str, default: Any) -> Any:\n        super().setdefault(key, default=default)\n        return self[key]\n\n\ndef ends_with_whitespace(it: Any) -> bool:\n    \"\"\"Returns ``True`` if the given item ``it`` is a ``Table`` or ``AoT`` object\n    ending with a ``Whitespace``.\n    \"\"\"\n    return (\n        isinstance(it, Table) and isinstance(it.value._previous_item(), Whitespace)\n    ) or (isinstance(it, AoT) and len(it) > 0 and isinstance(it[-1], Whitespace))\n", "tomlkit/toml_char.py": "import string\n\n\nclass TOMLChar(str):\n    def __init__(self, c):\n        super().__init__()\n\n        if len(self) > 1:\n            raise ValueError(\"A TOML character must be of length 1\")\n\n    BARE = string.ascii_letters + string.digits + \"-_\"\n    KV = \"= \\t\"\n    NUMBER = string.digits + \"+-_.e\"\n    SPACES = \" \\t\"\n    NL = \"\\n\\r\"\n    WS = SPACES + NL\n\n    def is_bare_key_char(self) -> bool:\n        \"\"\"\n        Whether the character is a valid bare key name or not.\n        \"\"\"\n        return self in self.BARE\n\n    def is_kv_sep(self) -> bool:\n        \"\"\"\n        Whether the character is a valid key/value separator or not.\n        \"\"\"\n        return self in self.KV\n\n    def is_int_float_char(self) -> bool:\n        \"\"\"\n        Whether the character if a valid integer or float value character or not.\n        \"\"\"\n        return self in self.NUMBER\n\n    def is_ws(self) -> bool:\n        \"\"\"\n        Whether the character is a whitespace character or not.\n        \"\"\"\n        return self in self.WS\n\n    def is_nl(self) -> bool:\n        \"\"\"\n        Whether the character is a new line character or not.\n        \"\"\"\n        return self in self.NL\n\n    def is_spaces(self) -> bool:\n        \"\"\"\n        Whether the character is a space or not\n        \"\"\"\n        return self in self.SPACES\n", "tomlkit/toml_file.py": "import os\nimport re\n\nfrom typing import TYPE_CHECKING\n\nfrom tomlkit.api import loads\nfrom tomlkit.toml_document import TOMLDocument\n\n\nif TYPE_CHECKING:\n    from _typeshed import StrPath as _StrPath\nelse:\n    from typing import Union\n\n    _StrPath = Union[str, os.PathLike]\n\n\nclass TOMLFile:\n    \"\"\"\n    Represents a TOML file.\n\n    :param path: path to the TOML file\n    \"\"\"\n\n    def __init__(self, path: _StrPath) -> None:\n        self._path = path\n        self._linesep = os.linesep\n\n    def read(self) -> TOMLDocument:\n        \"\"\"Read the file content as a :class:`tomlkit.toml_document.TOMLDocument`.\"\"\"\n        with open(self._path, encoding=\"utf-8\", newline=\"\") as f:\n            content = f.read()\n\n            # check if consistent line endings\n            num_newline = content.count(\"\\n\")\n            if num_newline > 0:\n                num_win_eol = content.count(\"\\r\\n\")\n                if num_win_eol == num_newline:\n                    self._linesep = \"\\r\\n\"\n                elif num_win_eol == 0:\n                    self._linesep = \"\\n\"\n                else:\n                    self._linesep = \"mixed\"\n\n            return loads(content)\n\n    def write(self, data: TOMLDocument) -> None:\n        \"\"\"Write the TOMLDocument to the file.\"\"\"\n        content = data.as_string()\n\n        # apply linesep\n        if self._linesep == \"\\n\":\n            content = content.replace(\"\\r\\n\", \"\\n\")\n        elif self._linesep == \"\\r\\n\":\n            content = re.sub(r\"(?<!\\r)\\n\", \"\\r\\n\", content)\n\n        with open(self._path, \"w\", encoding=\"utf-8\", newline=\"\") as f:\n            f.write(content)\n", "tomlkit/_utils.py": "from __future__ import annotations\n\nimport re\n\nfrom collections.abc import Mapping\nfrom datetime import date\nfrom datetime import datetime\nfrom datetime import time\nfrom datetime import timedelta\nfrom datetime import timezone\nfrom typing import Collection\n\nfrom tomlkit._compat import decode\n\n\nRFC_3339_LOOSE = re.compile(\n    \"^\"\n    r\"(([0-9]+)-(\\d{2})-(\\d{2}))?\"  # Date\n    \"(\"\n    \"([Tt ])?\"  # Separator\n    r\"(\\d{2}):(\\d{2}):(\\d{2})(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \")?\"\n    \"$\"\n)\n\nRFC_3339_DATETIME = re.compile(\n    \"^\"\n    \"([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])\"  # Date\n    \"[Tt ]\"  # Separator\n    r\"([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?\"  # Time\n    r\"(([Zz])|([\\+|\\-]([01][0-9]|2[0-3]):([0-5][0-9])))?\"  # Timezone\n    \"$\"\n)\n\nRFC_3339_DATE = re.compile(\"^([0-9]+)-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01])$\")\n\nRFC_3339_TIME = re.compile(\n    r\"^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.([0-9]+))?$\"\n)\n\n_utc = timezone(timedelta(), \"UTC\")\n\n\ndef parse_rfc3339(string: str) -> datetime | date | time:\n    m = RFC_3339_DATETIME.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n        hour = int(m.group(4))\n        minute = int(m.group(5))\n        second = int(m.group(6))\n        microsecond = 0\n\n        if m.group(7):\n            microsecond = int((f\"{m.group(8):<06s}\")[:6])\n\n        if m.group(9):\n            # Timezone\n            tz = m.group(9)\n            if tz.upper() == \"Z\":\n                tzinfo = _utc\n            else:\n                sign = m.group(11)[0]\n                hour_offset, minute_offset = int(m.group(12)), int(m.group(13))\n                offset = timedelta(seconds=hour_offset * 3600 + minute_offset * 60)\n                if sign == \"-\":\n                    offset = -offset\n\n                tzinfo = timezone(offset, f\"{sign}{m.group(12)}:{m.group(13)}\")\n\n            return datetime(\n                year, month, day, hour, minute, second, microsecond, tzinfo=tzinfo\n            )\n        else:\n            return datetime(year, month, day, hour, minute, second, microsecond)\n\n    m = RFC_3339_DATE.match(string)\n    if m:\n        year = int(m.group(1))\n        month = int(m.group(2))\n        day = int(m.group(3))\n\n        return date(year, month, day)\n\n    m = RFC_3339_TIME.match(string)\n    if m:\n        hour = int(m.group(1))\n        minute = int(m.group(2))\n        second = int(m.group(3))\n        microsecond = 0\n\n        if m.group(4):\n            microsecond = int((f\"{m.group(5):<06s}\")[:6])\n\n        return time(hour, minute, second, microsecond)\n\n    raise ValueError(\"Invalid RFC 339 string\")\n\n\n# https://toml.io/en/v1.0.0#string\nCONTROL_CHARS = frozenset(chr(c) for c in range(0x20)) | {chr(0x7F)}\n_escaped = {\n    \"b\": \"\\b\",\n    \"t\": \"\\t\",\n    \"n\": \"\\n\",\n    \"f\": \"\\f\",\n    \"r\": \"\\r\",\n    '\"': '\"',\n    \"\\\\\": \"\\\\\",\n}\n_compact_escapes = {\n    **{v: f\"\\\\{k}\" for k, v in _escaped.items()},\n    '\"\"\"': '\"\"\\\\\"',\n}\n_basic_escapes = CONTROL_CHARS | {'\"', \"\\\\\"}\n\n\ndef _unicode_escape(seq: str) -> str:\n    return \"\".join(f\"\\\\u{ord(c):04x}\" for c in seq)\n\n\ndef escape_string(s: str, escape_sequences: Collection[str] = _basic_escapes) -> str:\n    s = decode(s)\n\n    res = []\n    start = 0\n\n    def flush(inc=1):\n        if start != i:\n            res.append(s[start:i])\n\n        return i + inc\n\n    found_sequences = {seq for seq in escape_sequences if seq in s}\n\n    i = 0\n    while i < len(s):\n        for seq in found_sequences:\n            seq_len = len(seq)\n            if s[i:].startswith(seq):\n                start = flush(seq_len)\n                res.append(_compact_escapes.get(seq) or _unicode_escape(seq))\n                i += seq_len - 1  # fast-forward escape sequence\n        i += 1\n\n    flush()\n\n    return \"\".join(res)\n\n\ndef merge_dicts(d1: dict, d2: dict) -> dict:\n    for k, v in d2.items():\n        if k in d1 and isinstance(d1[k], dict) and isinstance(v, Mapping):\n            merge_dicts(d1[k], v)\n        else:\n            d1[k] = d2[k]\n", "tomlkit/_types.py": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\nfrom typing import Any\nfrom typing import TypeVar\n\n\nWT = TypeVar(\"WT\", bound=\"WrapperType\")\n\nif TYPE_CHECKING:  # pragma: no cover\n    # Define _CustomList and _CustomDict as a workaround for:\n    # https://github.com/python/mypy/issues/11427\n    #\n    # According to this issue, the typeshed contains a \"lie\"\n    # (it adds MutableSequence to the ancestry of list and MutableMapping to\n    # the ancestry of dict) which completely messes with the type inference for\n    # Table, InlineTable, Array and Container.\n    #\n    # Importing from builtins is preferred over simple assignment, see issues:\n    # https://github.com/python/mypy/issues/8715\n    # https://github.com/python/mypy/issues/10068\n    from builtins import dict as _CustomDict\n    from builtins import float as _CustomFloat\n    from builtins import int as _CustomInt\n    from builtins import list as _CustomList\n    from typing import Callable\n    from typing import Concatenate\n    from typing import ParamSpec\n    from typing import Protocol\n\n    P = ParamSpec(\"P\")\n\n    class WrapperType(Protocol):\n        def _new(self: WT, value: Any) -> WT: ...\n\nelse:\n    from collections.abc import MutableMapping\n    from collections.abc import MutableSequence\n    from numbers import Integral\n    from numbers import Real\n\n    class _CustomList(MutableSequence, list):\n        \"\"\"Adds MutableSequence mixin while pretending to be a builtin list\"\"\"\n\n        def __add__(self, other):\n            new_list = self.copy()\n            new_list.extend(other)\n            return new_list\n\n        def __iadd__(self, other):\n            self.extend(other)\n            return self\n\n    class _CustomDict(MutableMapping, dict):\n        \"\"\"Adds MutableMapping mixin while pretending to be a builtin dict\"\"\"\n\n        def __or__(self, other):\n            new_dict = self.copy()\n            new_dict.update(other)\n            return new_dict\n\n        def __ior__(self, other):\n            self.update(other)\n            return self\n\n    class _CustomInt(Integral, int):\n        \"\"\"Adds Integral mixin while pretending to be a builtin int\"\"\"\n\n    class _CustomFloat(Real, float):\n        \"\"\"Adds Real mixin while pretending to be a builtin float\"\"\"\n\n\ndef wrap_method(\n    original_method: Callable[Concatenate[WT, P], Any],\n) -> Callable[Concatenate[WT, P], Any]:\n    def wrapper(self: WT, *args: P.args, **kwargs: P.kwargs) -> Any:\n        result = original_method(self, *args, **kwargs)\n        if result is NotImplemented:\n            return result\n        return self._new(result)\n\n    return wrapper\n", "tomlkit/_compat.py": "from __future__ import annotations\n\nimport contextlib\nimport sys\n\nfrom typing import Any\n\n\nPY38 = sys.version_info >= (3, 8)\n\n\ndef decode(string: Any, encodings: list[str] | None = None):\n    if not isinstance(string, bytes):\n        return string\n\n    encodings = encodings or [\"utf-8\", \"latin1\", \"ascii\"]\n\n    for encoding in encodings:\n        with contextlib.suppress(UnicodeEncodeError, UnicodeDecodeError):\n            return string.decode(encoding)\n\n    return string.decode(encodings[0], errors=\"ignore\")\n", "tomlkit/__init__.py": "from tomlkit.api import TOMLDocument\nfrom tomlkit.api import aot\nfrom tomlkit.api import array\nfrom tomlkit.api import boolean\nfrom tomlkit.api import comment\nfrom tomlkit.api import date\nfrom tomlkit.api import datetime\nfrom tomlkit.api import document\nfrom tomlkit.api import dump\nfrom tomlkit.api import dumps\nfrom tomlkit.api import float_\nfrom tomlkit.api import inline_table\nfrom tomlkit.api import integer\nfrom tomlkit.api import item\nfrom tomlkit.api import key\nfrom tomlkit.api import key_value\nfrom tomlkit.api import load\nfrom tomlkit.api import loads\nfrom tomlkit.api import nl\nfrom tomlkit.api import parse\nfrom tomlkit.api import register_encoder\nfrom tomlkit.api import string\nfrom tomlkit.api import table\nfrom tomlkit.api import time\nfrom tomlkit.api import unregister_encoder\nfrom tomlkit.api import value\nfrom tomlkit.api import ws\n\n\n__version__ = \"0.12.5\"\n__all__ = [\n    \"aot\",\n    \"array\",\n    \"boolean\",\n    \"comment\",\n    \"date\",\n    \"datetime\",\n    \"document\",\n    \"dump\",\n    \"dumps\",\n    \"float_\",\n    \"inline_table\",\n    \"integer\",\n    \"item\",\n    \"key\",\n    \"key_value\",\n    \"load\",\n    \"loads\",\n    \"nl\",\n    \"parse\",\n    \"string\",\n    \"table\",\n    \"time\",\n    \"TOMLDocument\",\n    \"value\",\n    \"ws\",\n    \"register_encoder\",\n    \"unregister_encoder\",\n]\n", "tomlkit/parser.py": "from __future__ import annotations\n\nimport datetime\nimport re\nimport string\n\nfrom tomlkit._compat import decode\nfrom tomlkit._utils import RFC_3339_LOOSE\nfrom tomlkit._utils import _escaped\nfrom tomlkit._utils import parse_rfc3339\nfrom tomlkit.container import Container\nfrom tomlkit.exceptions import EmptyKeyError\nfrom tomlkit.exceptions import EmptyTableNameError\nfrom tomlkit.exceptions import InternalParserError\nfrom tomlkit.exceptions import InvalidCharInStringError\nfrom tomlkit.exceptions import InvalidControlChar\nfrom tomlkit.exceptions import InvalidDateError\nfrom tomlkit.exceptions import InvalidDateTimeError\nfrom tomlkit.exceptions import InvalidNumberError\nfrom tomlkit.exceptions import InvalidTimeError\nfrom tomlkit.exceptions import InvalidUnicodeValueError\nfrom tomlkit.exceptions import ParseError\nfrom tomlkit.exceptions import UnexpectedCharError\nfrom tomlkit.exceptions import UnexpectedEofError\nfrom tomlkit.items import AoT\nfrom tomlkit.items import Array\nfrom tomlkit.items import Bool\nfrom tomlkit.items import BoolType\nfrom tomlkit.items import Comment\nfrom tomlkit.items import Date\nfrom tomlkit.items import DateTime\nfrom tomlkit.items import Float\nfrom tomlkit.items import InlineTable\nfrom tomlkit.items import Integer\nfrom tomlkit.items import Item\nfrom tomlkit.items import Key\nfrom tomlkit.items import KeyType\nfrom tomlkit.items import Null\nfrom tomlkit.items import SingleKey\nfrom tomlkit.items import String\nfrom tomlkit.items import StringType\nfrom tomlkit.items import Table\nfrom tomlkit.items import Time\nfrom tomlkit.items import Trivia\nfrom tomlkit.items import Whitespace\nfrom tomlkit.source import Source\nfrom tomlkit.toml_char import TOMLChar\nfrom tomlkit.toml_document import TOMLDocument\n\n\nCTRL_I = 0x09  # Tab\nCTRL_J = 0x0A  # Line feed\nCTRL_M = 0x0D  # Carriage return\nCTRL_CHAR_LIMIT = 0x1F\nCHR_DEL = 0x7F\n\n\nclass Parser:\n    \"\"\"\n    Parser for TOML documents.\n    \"\"\"\n\n    def __init__(self, string: str | bytes) -> None:\n        # Input to parse\n        self._src = Source(decode(string))\n\n        self._aot_stack: list[Key] = []\n\n    @property\n    def _state(self):\n        return self._src.state\n\n    @property\n    def _idx(self):\n        return self._src.idx\n\n    @property\n    def _current(self):\n        return self._src.current\n\n    @property\n    def _marker(self):\n        return self._src.marker\n\n    def extract(self) -> str:\n        \"\"\"\n        Extracts the value between marker and index\n        \"\"\"\n        return self._src.extract()\n\n    def inc(self, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser if the end of the input has not been reached.\n        Returns whether or not it was able to advance.\n        \"\"\"\n        return self._src.inc(exception=exception)\n\n    def inc_n(self, n: int, exception: type[ParseError] | None = None) -> bool:\n        \"\"\"\n        Increments the parser by n characters\n        if the end of the input has not been reached.\n        \"\"\"\n        return self._src.inc_n(n=n, exception=exception)\n\n    def consume(self, chars, min=0, max=-1):\n        \"\"\"\n        Consume chars until min/max is satisfied is valid.\n        \"\"\"\n        return self._src.consume(chars=chars, min=min, max=max)\n\n    def end(self) -> bool:\n        \"\"\"\n        Returns True if the parser has reached the end of the input.\n        \"\"\"\n        return self._src.end()\n\n    def mark(self) -> None:\n        \"\"\"\n        Sets the marker to the index's current position\n        \"\"\"\n        self._src.mark()\n\n    def parse_error(self, exception=ParseError, *args, **kwargs):\n        \"\"\"\n        Creates a generic \"parse error\" at the current position.\n        \"\"\"\n        return self._src.parse_error(exception, *args, **kwargs)\n\n    def parse(self) -> TOMLDocument:\n        body = TOMLDocument(True)\n\n        # Take all keyvals outside of tables/AoT's.\n        while not self.end():\n            # Break out if a table is found\n            if self._current == \"[\":\n                break\n\n            # Otherwise, take and append one KV\n            item = self._parse_item()\n            if not item:\n                break\n\n            key, value = item\n            if (key is not None and key.is_multi()) or not self._merge_ws(value, body):\n                # We actually have a table\n                try:\n                    body.append(key, value)\n                except Exception as e:\n                    raise self.parse_error(ParseError, str(e)) from e\n\n            self.mark()\n\n        while not self.end():\n            key, value = self._parse_table()\n            if isinstance(value, Table) and value.is_aot_element():\n                # This is just the first table in an AoT. Parse the rest of the array\n                # along with it.\n                value = self._parse_aot(value, key)\n\n            try:\n                body.append(key, value)\n            except Exception as e:\n                raise self.parse_error(ParseError, str(e)) from e\n\n        body.parsing(False)\n\n        return body\n\n    def _merge_ws(self, item: Item, container: Container) -> bool:\n        \"\"\"\n        Merges the given Item with the last one currently in the given Container if\n        both are whitespace items.\n\n        Returns True if the items were merged.\n        \"\"\"\n        last = container.last_item()\n        if not last:\n            return False\n\n        if not isinstance(item, Whitespace) or not isinstance(last, Whitespace):\n            return False\n\n        start = self._idx - (len(last.s) + len(item.s))\n        container.body[-1] = (\n            container.body[-1][0],\n            Whitespace(self._src[start : self._idx]),\n        )\n\n        return True\n\n    def _is_child(self, parent: Key, child: Key) -> bool:\n        \"\"\"\n        Returns whether a key is strictly a child of another key.\n        AoT siblings are not considered children of one another.\n        \"\"\"\n        parent_parts = tuple(parent)\n        child_parts = tuple(child)\n\n        if parent_parts == child_parts:\n            return False\n\n        return parent_parts == child_parts[: len(parent_parts)]\n\n    def _parse_item(self) -> tuple[Key | None, Item] | None:\n        \"\"\"\n        Attempts to parse the next item and returns it, along with its key\n        if the item is value-like.\n        \"\"\"\n        self.mark()\n        with self._state as state:\n            while True:\n                c = self._current\n                if c == \"\\n\":\n                    # Found a newline; Return all whitespace found up to this point.\n                    self.inc()\n\n                    return None, Whitespace(self.extract())\n                elif c in \" \\t\\r\":\n                    # Skip whitespace.\n                    if not self.inc():\n                        return None, Whitespace(self.extract())\n                elif c == \"#\":\n                    # Found a comment, parse it\n                    indent = self.extract()\n                    cws, comment, trail = self._parse_comment_trail()\n\n                    return None, Comment(Trivia(indent, cws, comment, trail))\n                elif c == \"[\":\n                    # Found a table, delegate to the calling function.\n                    return\n                else:\n                    # Beginning of a KV pair.\n                    # Return to beginning of whitespace so it gets included\n                    # as indentation for the KV about to be parsed.\n                    state.restore = True\n                    break\n\n        return self._parse_key_value(True)\n\n    def _parse_comment_trail(self, parse_trail: bool = True) -> tuple[str, str, str]:\n        \"\"\"\n        Returns (comment_ws, comment, trail)\n        If there is no comment, comment_ws and comment will\n        simply be empty.\n        \"\"\"\n        if self.end():\n            return \"\", \"\", \"\"\n\n        comment = \"\"\n        comment_ws = \"\"\n        self.mark()\n\n        while True:\n            c = self._current\n\n            if c == \"\\n\":\n                break\n            elif c == \"#\":\n                comment_ws = self.extract()\n\n                self.mark()\n                self.inc()  # Skip #\n\n                # The comment itself\n                while not self.end() and not self._current.is_nl():\n                    code = ord(self._current)\n                    if code == CHR_DEL or code <= CTRL_CHAR_LIMIT and code != CTRL_I:\n                        raise self.parse_error(InvalidControlChar, code, \"comments\")\n\n                    if not self.inc():\n                        break\n\n                comment = self.extract()\n                self.mark()\n\n                break\n            elif c in \" \\t\\r\":\n                self.inc()\n            else:\n                raise self.parse_error(UnexpectedCharError, c)\n\n            if self.end():\n                break\n\n        trail = \"\"\n        if parse_trail:\n            while self._current.is_spaces() and self.inc():\n                pass\n\n            if self._current == \"\\r\":\n                self.inc()\n\n            if self._current == \"\\n\":\n                self.inc()\n\n            if self._idx != self._marker or self._current.is_ws():\n                trail = self.extract()\n\n        return comment_ws, comment, trail\n\n    def _parse_key_value(self, parse_comment: bool = False) -> tuple[Key, Item]:\n        # Leading indent\n        self.mark()\n\n        while self._current.is_spaces() and self.inc():\n            pass\n\n        indent = self.extract()\n\n        # Key\n        key = self._parse_key()\n\n        self.mark()\n\n        found_equals = self._current == \"=\"\n        while self._current.is_kv_sep() and self.inc():\n            if self._current == \"=\":\n                if found_equals:\n                    raise self.parse_error(UnexpectedCharError, \"=\")\n                else:\n                    found_equals = True\n        if not found_equals:\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        if not key.sep:\n            key.sep = self.extract()\n        else:\n            key.sep += self.extract()\n\n        # Value\n        val = self._parse_value()\n        # Comment\n        if parse_comment:\n            cws, comment, trail = self._parse_comment_trail()\n            meta = val.trivia\n            if not meta.comment_ws:\n                meta.comment_ws = cws\n\n            meta.comment = comment\n            meta.trail = trail\n        else:\n            val.trivia.trail = \"\"\n\n        val.trivia.indent = indent\n\n        return key, val\n\n    def _parse_key(self) -> Key:\n        \"\"\"\n        Parses a Key at the current position;\n        WS before the key must be exhausted first at the callsite.\n        \"\"\"\n        self.mark()\n        while self._current.is_spaces() and self.inc():\n            # Skip any leading whitespace\n            pass\n        if self._current in \"\\\"'\":\n            return self._parse_quoted_key()\n        else:\n            return self._parse_bare_key()\n\n    def _parse_quoted_key(self) -> Key:\n        \"\"\"\n        Parses a key enclosed in either single or double quotes.\n        \"\"\"\n        # Extract the leading whitespace\n        original = self.extract()\n        quote_style = self._current\n        key_type = next((t for t in KeyType if t.value == quote_style), None)\n\n        if key_type is None:\n            raise RuntimeError(\"Should not have entered _parse_quoted_key()\")\n\n        key_str = self._parse_string(\n            StringType.SLB if key_type == KeyType.Basic else StringType.SLL\n        )\n        if key_str._t.is_multiline():\n            raise self.parse_error(UnexpectedCharError, key_str._t.value)\n        original += key_str.as_string()\n        self.mark()\n        while self._current.is_spaces() and self.inc():\n            pass\n        original += self.extract()\n        key = SingleKey(str(key_str), t=key_type, sep=\"\", original=original)\n        if self._current == \".\":\n            self.inc()\n            key = key.concat(self._parse_key())\n\n        return key\n\n    def _parse_bare_key(self) -> Key:\n        \"\"\"\n        Parses a bare key.\n        \"\"\"\n        while (\n            self._current.is_bare_key_char() or self._current.is_spaces()\n        ) and self.inc():\n            pass\n\n        original = self.extract()\n        key = original.strip()\n        if not key:\n            # Empty key\n            raise self.parse_error(EmptyKeyError)\n\n        if \" \" in key:\n            # Bare key with spaces in it\n            raise self.parse_error(ParseError, f'Invalid key \"{key}\"')\n\n        key = SingleKey(key, KeyType.Bare, \"\", original)\n\n        if self._current == \".\":\n            self.inc()\n            key = key.concat(self._parse_key())\n\n        return key\n\n    def _parse_value(self) -> Item:\n        \"\"\"\n        Attempts to parse a value at the current position.\n        \"\"\"\n        self.mark()\n        c = self._current\n        trivia = Trivia()\n\n        if c == StringType.SLB.value:\n            return self._parse_basic_string()\n        elif c == StringType.SLL.value:\n            return self._parse_literal_string()\n        elif c == BoolType.TRUE.value[0]:\n            return self._parse_true()\n        elif c == BoolType.FALSE.value[0]:\n            return self._parse_false()\n        elif c == \"[\":\n            return self._parse_array()\n        elif c == \"{\":\n            return self._parse_inline_table()\n        elif c in \"+-\" or self._peek(4) in {\n            \"+inf\",\n            \"-inf\",\n            \"inf\",\n            \"+nan\",\n            \"-nan\",\n            \"nan\",\n        }:\n            # Number\n            while self._current not in \" \\t\\n\\r#,]}\" and self.inc():\n                pass\n\n            raw = self.extract()\n\n            item = self._parse_number(raw, trivia)\n            if item is not None:\n                return item\n\n            raise self.parse_error(InvalidNumberError)\n        elif c in string.digits:\n            # Integer, Float, Date, Time or DateTime\n            while self._current not in \" \\t\\n\\r#,]}\" and self.inc():\n                pass\n\n            raw = self.extract()\n\n            m = RFC_3339_LOOSE.match(raw)\n            if m:\n                if m.group(1) and m.group(5):\n                    # datetime\n                    try:\n                        dt = parse_rfc3339(raw)\n                        assert isinstance(dt, datetime.datetime)\n                        return DateTime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            dt.second,\n                            dt.microsecond,\n                            dt.tzinfo,\n                            trivia,\n                            raw,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidDateTimeError) from None\n\n                if m.group(1):\n                    try:\n                        dt = parse_rfc3339(raw)\n                        assert isinstance(dt, datetime.date)\n                        date = Date(dt.year, dt.month, dt.day, trivia, raw)\n                        self.mark()\n                        while self._current not in \"\\t\\n\\r#,]}\" and self.inc():\n                            pass\n\n                        time_raw = self.extract()\n                        time_part = time_raw.rstrip()\n                        trivia.comment_ws = time_raw[len(time_part) :]\n                        if not time_part:\n                            return date\n\n                        dt = parse_rfc3339(raw + time_part)\n                        assert isinstance(dt, datetime.datetime)\n                        return DateTime(\n                            dt.year,\n                            dt.month,\n                            dt.day,\n                            dt.hour,\n                            dt.minute,\n                            dt.second,\n                            dt.microsecond,\n                            dt.tzinfo,\n                            trivia,\n                            raw + time_part,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidDateError) from None\n\n                if m.group(5):\n                    try:\n                        t = parse_rfc3339(raw)\n                        assert isinstance(t, datetime.time)\n                        return Time(\n                            t.hour,\n                            t.minute,\n                            t.second,\n                            t.microsecond,\n                            t.tzinfo,\n                            trivia,\n                            raw,\n                        )\n                    except ValueError:\n                        raise self.parse_error(InvalidTimeError) from None\n\n            item = self._parse_number(raw, trivia)\n            if item is not None:\n                return item\n\n            raise self.parse_error(InvalidNumberError)\n        else:\n            raise self.parse_error(UnexpectedCharError, c)\n\n    def _parse_true(self):\n        return self._parse_bool(BoolType.TRUE)\n\n    def _parse_false(self):\n        return self._parse_bool(BoolType.FALSE)\n\n    def _parse_bool(self, style: BoolType) -> Bool:\n        with self._state:\n            style = BoolType(style)\n\n            # only keep parsing for bool if the characters match the style\n            # try consuming rest of chars in style\n            for c in style:\n                self.consume(c, min=1, max=1)\n\n            return Bool(style, Trivia())\n\n    def _parse_array(self) -> Array:\n        # Consume opening bracket, EOF here is an issue (middle of array)\n        self.inc(exception=UnexpectedEofError)\n\n        elems: list[Item] = []\n        prev_value = None\n        while True:\n            # consume whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES + TOMLChar.NL)\n            indent = self._src[mark : self._idx]\n            newline = set(TOMLChar.NL) & set(indent)\n            if newline:\n                elems.append(Whitespace(indent))\n                continue\n\n            # consume comment\n            if self._current == \"#\":\n                cws, comment, trail = self._parse_comment_trail(parse_trail=False)\n                elems.append(Comment(Trivia(indent, cws, comment, trail)))\n                continue\n\n            # consume indent\n            if indent:\n                elems.append(Whitespace(indent))\n                continue\n\n            # consume value\n            if not prev_value:\n                try:\n                    elems.append(self._parse_value())\n                    prev_value = True\n                    continue\n                except UnexpectedCharError:\n                    pass\n\n            # consume comma\n            if prev_value and self._current == \",\":\n                self.inc(exception=UnexpectedEofError)\n                elems.append(Whitespace(\",\"))\n                prev_value = False\n                continue\n\n            # consume closing bracket\n            if self._current == \"]\":\n                # consume closing bracket, EOF here doesn't matter\n                self.inc()\n                break\n\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        try:\n            res = Array(elems, Trivia())\n        except ValueError:\n            pass\n        else:\n            return res\n\n    def _parse_inline_table(self) -> InlineTable:\n        # consume opening bracket, EOF here is an issue (middle of array)\n        self.inc(exception=UnexpectedEofError)\n\n        elems = Container(True)\n        trailing_comma = None\n        while True:\n            # consume leading whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES)\n            raw = self._src[mark : self._idx]\n            if raw:\n                elems.add(Whitespace(raw))\n\n            if not trailing_comma:\n                # None: empty inline table\n                # False: previous key-value pair was not followed by a comma\n                if self._current == \"}\":\n                    # consume closing bracket, EOF here doesn't matter\n                    self.inc()\n                    break\n\n                if (\n                    trailing_comma is False\n                    or trailing_comma is None\n                    and self._current == \",\"\n                ):\n                    # Either the previous key-value pair was not followed by a comma\n                    # or the table has an unexpected leading comma.\n                    raise self.parse_error(UnexpectedCharError, self._current)\n            else:\n                # True: previous key-value pair was followed by a comma\n                if self._current == \"}\" or self._current == \",\":\n                    raise self.parse_error(UnexpectedCharError, self._current)\n\n            key, val = self._parse_key_value(False)\n            elems.add(key, val)\n\n            # consume trailing whitespace\n            mark = self._idx\n            self.consume(TOMLChar.SPACES)\n            raw = self._src[mark : self._idx]\n            if raw:\n                elems.add(Whitespace(raw))\n\n            # consume trailing comma\n            trailing_comma = self._current == \",\"\n            if trailing_comma:\n                # consume closing bracket, EOF here is an issue (middle of inline table)\n                self.inc(exception=UnexpectedEofError)\n\n        return InlineTable(elems, Trivia())\n\n    def _parse_number(self, raw: str, trivia: Trivia) -> Item | None:\n        # Leading zeros are not allowed\n        sign = \"\"\n        if raw.startswith((\"+\", \"-\")):\n            sign = raw[0]\n            raw = raw[1:]\n\n        if len(raw) > 1 and (\n            raw.startswith(\"0\")\n            and not raw.startswith((\"0.\", \"0o\", \"0x\", \"0b\", \"0e\"))\n            or sign\n            and raw.startswith(\".\")\n        ):\n            return None\n\n        if raw.startswith((\"0o\", \"0x\", \"0b\")) and sign:\n            return None\n\n        digits = \"[0-9]\"\n        base = 10\n        if raw.startswith(\"0b\"):\n            digits = \"[01]\"\n            base = 2\n        elif raw.startswith(\"0o\"):\n            digits = \"[0-7]\"\n            base = 8\n        elif raw.startswith(\"0x\"):\n            digits = \"[0-9a-f]\"\n            base = 16\n\n        # Underscores should be surrounded by digits\n        clean = re.sub(f\"(?i)(?<={digits})_(?={digits})\", \"\", raw).lower()\n\n        if \"_\" in clean:\n            return None\n\n        if (\n            clean.endswith(\".\")\n            or not clean.startswith(\"0x\")\n            and clean.split(\"e\", 1)[0].endswith(\".\")\n        ):\n            return None\n\n        try:\n            return Integer(int(sign + clean, base), trivia, sign + raw)\n        except ValueError:\n            try:\n                return Float(float(sign + clean), trivia, sign + raw)\n            except ValueError:\n                return None\n\n    def _parse_literal_string(self) -> String:\n        with self._state:\n            return self._parse_string(StringType.SLL)\n\n    def _parse_basic_string(self) -> String:\n        with self._state:\n            return self._parse_string(StringType.SLB)\n\n    def _parse_escaped_char(self, multiline):\n        if multiline and self._current.is_ws():\n            # When the last non-whitespace character on a line is\n            # a \\, it will be trimmed along with all whitespace\n            # (including newlines) up to the next non-whitespace\n            # character or closing delimiter.\n            # \"\"\"\\\n            #     hello \\\n            #     world\"\"\"\n            tmp = \"\"\n            while self._current.is_ws():\n                tmp += self._current\n                # consume the whitespace, EOF here is an issue\n                # (middle of string)\n                self.inc(exception=UnexpectedEofError)\n                continue\n\n            # the escape followed by whitespace must have a newline\n            # before any other chars\n            if \"\\n\" not in tmp:\n                raise self.parse_error(InvalidCharInStringError, self._current)\n\n            return \"\"\n\n        if self._current in _escaped:\n            c = _escaped[self._current]\n\n            # consume this char, EOF here is an issue (middle of string)\n            self.inc(exception=UnexpectedEofError)\n\n            return c\n\n        if self._current in {\"u\", \"U\"}:\n            # this needs to be a unicode\n            u, ue = self._peek_unicode(self._current == \"U\")\n            if u is not None:\n                # consume the U char and the unicode value\n                self.inc_n(len(ue) + 1)\n\n                return u\n\n            raise self.parse_error(InvalidUnicodeValueError)\n\n        raise self.parse_error(InvalidCharInStringError, self._current)\n\n    def _parse_string(self, delim: StringType) -> String:\n        # only keep parsing for string if the current character matches the delim\n        if self._current != delim.unit:\n            raise self.parse_error(\n                InternalParserError,\n                f\"Invalid character for string type {delim}\",\n            )\n\n        # consume the opening/first delim, EOF here is an issue\n        # (middle of string or middle of delim)\n        self.inc(exception=UnexpectedEofError)\n\n        if self._current == delim.unit:\n            # consume the closing/second delim, we do not care if EOF occurs as\n            # that would simply imply an empty single line string\n            if not self.inc() or self._current != delim.unit:\n                # Empty string\n                return String(delim, \"\", \"\", Trivia())\n\n            # consume the third delim, EOF here is an issue (middle of string)\n            self.inc(exception=UnexpectedEofError)\n\n            delim = delim.toggle()  # convert delim to multi delim\n\n        self.mark()  # to extract the original string with whitespace and all\n        value = \"\"\n\n        # A newline immediately following the opening delimiter will be trimmed.\n        if delim.is_multiline():\n            if self._current == \"\\n\":\n                # consume the newline, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n            else:\n                cur = self._current\n                with self._state(restore=True):\n                    if self.inc():\n                        cur += self._current\n                if cur == \"\\r\\n\":\n                    self.inc_n(2, exception=UnexpectedEofError)\n\n        escaped = False  # whether the previous key was ESCAPE\n        while True:\n            code = ord(self._current)\n            if (\n                delim.is_singleline()\n                and not escaped\n                and (code == CHR_DEL or code <= CTRL_CHAR_LIMIT and code != CTRL_I)\n            ) or (\n                delim.is_multiline()\n                and not escaped\n                and (\n                    code == CHR_DEL\n                    or code <= CTRL_CHAR_LIMIT\n                    and code not in [CTRL_I, CTRL_J, CTRL_M]\n                )\n            ):\n                raise self.parse_error(InvalidControlChar, code, \"strings\")\n            elif not escaped and self._current == delim.unit:\n                # try to process current as a closing delim\n                original = self.extract()\n\n                close = \"\"\n                if delim.is_multiline():\n                    # Consume the delimiters to see if we are at the end of the string\n                    close = \"\"\n                    while self._current == delim.unit:\n                        close += self._current\n                        self.inc()\n\n                    if len(close) < 3:\n                        # Not a triple quote, leave in result as-is.\n                        # Adding back the characters we already consumed\n                        value += close\n                        continue\n\n                    if len(close) == 3:\n                        # We are at the end of the string\n                        return String(delim, value, original, Trivia())\n\n                    if len(close) >= 6:\n                        raise self.parse_error(InvalidCharInStringError, self._current)\n\n                    value += close[:-3]\n                    original += close[:-3]\n\n                    return String(delim, value, original, Trivia())\n                else:\n                    # consume the closing delim, we do not care if EOF occurs as\n                    # that would simply imply the end of self._src\n                    self.inc()\n\n                return String(delim, value, original, Trivia())\n            elif delim.is_basic() and escaped:\n                # attempt to parse the current char as an escaped value, an exception\n                # is raised if this fails\n                value += self._parse_escaped_char(delim.is_multiline())\n\n                # no longer escaped\n                escaped = False\n            elif delim.is_basic() and self._current == \"\\\\\":\n                # the next char is being escaped\n                escaped = True\n\n                # consume this char, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n            else:\n                # this is either a literal string where we keep everything as is,\n                # or this is not a special escaped char in a basic string\n                value += self._current\n\n                # consume this char, EOF here is an issue (middle of string)\n                self.inc(exception=UnexpectedEofError)\n\n    def _parse_table(\n        self, parent_name: Key | None = None, parent: Table | None = None\n    ) -> tuple[Key, Table | AoT]:\n        \"\"\"\n        Parses a table element.\n        \"\"\"\n        if self._current != \"[\":\n            raise self.parse_error(\n                InternalParserError, \"_parse_table() called on non-bracket character.\"\n            )\n\n        indent = self.extract()\n        self.inc()  # Skip opening bracket\n\n        if self.end():\n            raise self.parse_error(UnexpectedEofError)\n\n        is_aot = False\n        if self._current == \"[\":\n            if not self.inc():\n                raise self.parse_error(UnexpectedEofError)\n\n            is_aot = True\n        try:\n            key = self._parse_key()\n        except EmptyKeyError:\n            raise self.parse_error(EmptyTableNameError) from None\n        if self.end():\n            raise self.parse_error(UnexpectedEofError)\n        elif self._current != \"]\":\n            raise self.parse_error(UnexpectedCharError, self._current)\n\n        key.sep = \"\"\n        full_key = key\n        name_parts = tuple(key)\n        if any(\" \" in part.key.strip() and part.is_bare() for part in name_parts):\n            raise self.parse_error(\n                ParseError, f'Invalid table name \"{full_key.as_string()}\"'\n            )\n\n        missing_table = False\n        if parent_name:\n            parent_name_parts = tuple(parent_name)\n        else:\n            parent_name_parts = ()\n\n        if len(name_parts) > len(parent_name_parts) + 1:\n            missing_table = True\n\n        name_parts = name_parts[len(parent_name_parts) :]\n\n        values = Container(True)\n\n        self.inc()  # Skip closing bracket\n        if is_aot:\n            # TODO: Verify close bracket\n            self.inc()\n\n        cws, comment, trail = self._parse_comment_trail()\n\n        result = Null()\n        table = Table(\n            values,\n            Trivia(indent, cws, comment, trail),\n            is_aot,\n            name=name_parts[0].key if name_parts else key.key,\n            display_name=full_key.as_string(),\n            is_super_table=False,\n        )\n\n        if len(name_parts) > 1:\n            if missing_table:\n                # Missing super table\n                # i.e. a table initialized like this: [foo.bar]\n                # without initializing [foo]\n                #\n                # So we have to create the parent tables\n                table = Table(\n                    Container(True),\n                    Trivia(\"\", cws, comment, trail),\n                    is_aot and name_parts[0] in self._aot_stack,\n                    is_super_table=True,\n                    name=name_parts[0].key,\n                )\n\n            result = table\n            key = name_parts[0]\n\n            for i, _name in enumerate(name_parts[1:]):\n                child = table.get(\n                    _name,\n                    Table(\n                        Container(True),\n                        Trivia(indent, cws, comment, trail),\n                        is_aot and i == len(name_parts) - 2,\n                        is_super_table=i < len(name_parts) - 2,\n                        name=_name.key,\n                        display_name=(\n                            full_key.as_string() if i == len(name_parts) - 2 else None\n                        ),\n                    ),\n                )\n\n                if is_aot and i == len(name_parts) - 2:\n                    table.raw_append(_name, AoT([child], name=table.name, parsed=True))\n                else:\n                    table.raw_append(_name, child)\n\n                table = child\n                values = table.value\n        else:\n            if name_parts:\n                key = name_parts[0]\n\n        while not self.end():\n            item = self._parse_item()\n            if item:\n                _key, item = item\n                if not self._merge_ws(item, values):\n                    table.raw_append(_key, item)\n            else:\n                if self._current == \"[\":\n                    _, key_next = self._peek_table()\n\n                    if self._is_child(full_key, key_next):\n                        key_next, table_next = self._parse_table(full_key, table)\n\n                        table.raw_append(key_next, table_next)\n\n                        # Picking up any sibling\n                        while not self.end():\n                            _, key_next = self._peek_table()\n\n                            if not self._is_child(full_key, key_next):\n                                break\n\n                            key_next, table_next = self._parse_table(full_key, table)\n\n                            table.raw_append(key_next, table_next)\n\n                    break\n                else:\n                    raise self.parse_error(\n                        InternalParserError,\n                        \"_parse_item() returned None on a non-bracket character.\",\n                    )\n        table.value._validate_out_of_order_table()\n        if isinstance(result, Null):\n            result = table\n\n            if is_aot and (not self._aot_stack or full_key != self._aot_stack[-1]):\n                result = self._parse_aot(result, full_key)\n\n        return key, result\n\n    def _peek_table(self) -> tuple[bool, Key]:\n        \"\"\"\n        Peeks ahead non-intrusively by cloning then restoring the\n        initial state of the parser.\n\n        Returns the name of the table about to be parsed,\n        as well as whether it is part of an AoT.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(save_marker=True, restore=True):\n            if self._current != \"[\":\n                raise self.parse_error(\n                    InternalParserError,\n                    \"_peek_table() entered on non-bracket character\",\n                )\n\n            # AoT\n            self.inc()\n            is_aot = False\n            if self._current == \"[\":\n                self.inc()\n                is_aot = True\n            try:\n                return is_aot, self._parse_key()\n            except EmptyKeyError:\n                raise self.parse_error(EmptyTableNameError) from None\n\n    def _parse_aot(self, first: Table, name_first: Key) -> AoT:\n        \"\"\"\n        Parses all siblings of the provided table first and bundles them into\n        an AoT.\n        \"\"\"\n        payload = [first]\n        self._aot_stack.append(name_first)\n        while not self.end():\n            is_aot_next, name_next = self._peek_table()\n            if is_aot_next and name_next == name_first:\n                _, table = self._parse_table(name_first)\n                payload.append(table)\n            else:\n                break\n\n        self._aot_stack.pop()\n\n        return AoT(payload, parsed=True)\n\n    def _peek(self, n: int) -> str:\n        \"\"\"\n        Peeks ahead n characters.\n\n        n is the max number of characters that will be peeked.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(restore=True):\n            buf = \"\"\n            for _ in range(n):\n                if self._current not in \" \\t\\n\\r#,]}\" + self._src.EOF:\n                    buf += self._current\n                    self.inc()\n                    continue\n\n                break\n            return buf\n\n    def _peek_unicode(self, is_long: bool) -> tuple[str | None, str | None]:\n        \"\"\"\n        Peeks ahead non-intrusively by cloning then restoring the\n        initial state of the parser.\n\n        Returns the unicode value is it's a valid one else None.\n        \"\"\"\n        # we always want to restore after exiting this scope\n        with self._state(save_marker=True, restore=True):\n            if self._current not in {\"u\", \"U\"}:\n                raise self.parse_error(\n                    InternalParserError, \"_peek_unicode() entered on non-unicode value\"\n                )\n\n            self.inc()  # Dropping prefix\n            self.mark()\n\n            if is_long:\n                chars = 8\n            else:\n                chars = 4\n\n            if not self.inc_n(chars):\n                value, extracted = None, None\n            else:\n                extracted = self.extract()\n\n                if extracted[0].lower() == \"d\" and extracted[1].strip(\"01234567\"):\n                    return None, None\n\n                try:\n                    value = chr(int(extracted, 16))\n                except (ValueError, OverflowError):\n                    value = None\n\n            return value, extracted\n"}