{"pydantic/functional_validators.py": "\"\"\"This module contains related classes and functions for validation.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport sys\nfrom functools import partialmethod\nfrom types import FunctionType\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, cast, overload\n\nfrom pydantic_core import core_schema\nfrom pydantic_core import core_schema as _core_schema\nfrom typing_extensions import Annotated, Literal, TypeAlias\n\nfrom . import GetCoreSchemaHandler as _GetCoreSchemaHandler\nfrom ._internal import _core_metadata, _decorators, _generics, _internal_dataclass\nfrom .annotated_handlers import GetCoreSchemaHandler\nfrom .errors import PydanticUserError\n\nif sys.version_info < (3, 11):\n    from typing_extensions import Protocol\nelse:\n    from typing import Protocol\n\n_inspect_validator = _decorators.inspect_validator\n\n\n@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\nclass AfterValidator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#annotated-validators\n\n    A metadata class that indicates that a validation should be applied **after** the inner validation logic.\n\n    Attributes:\n        func: The validator function.\n\n    Example:\n        ```py\n        from typing_extensions import Annotated\n\n        from pydantic import AfterValidator, BaseModel, ValidationError\n\n        MyInt = Annotated[int, AfterValidator(lambda v: v + 1)]\n\n        class Model(BaseModel):\n            a: MyInt\n\n        print(Model(a=1).a)\n        #> 2\n\n        try:\n            Model(a='a')\n        except ValidationError as e:\n            print(e.json(indent=2))\n            '''\n            [\n              {\n                \"type\": \"int_parsing\",\n                \"loc\": [\n                  \"a\"\n                ],\n                \"msg\": \"Input should be a valid integer, unable to parse string as an integer\",\n                \"input\": \"a\",\n                \"url\": \"https://errors.pydantic.dev/2/v/int_parsing\"\n              }\n            ]\n            '''\n        ```\n    \"\"\"\n\n    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        schema = handler(source_type)\n        info_arg = _inspect_validator(self.func, 'after')\n        if info_arg:\n            func = cast(core_schema.WithInfoValidatorFunction, self.func)\n            return core_schema.with_info_after_validator_function(func, schema=schema, field_name=handler.field_name)\n        else:\n            func = cast(core_schema.NoInfoValidatorFunction, self.func)\n            return core_schema.no_info_after_validator_function(func, schema=schema)\n\n\n@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\nclass BeforeValidator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#annotated-validators\n\n    A metadata class that indicates that a validation should be applied **before** the inner validation logic.\n\n    Attributes:\n        func: The validator function.\n\n    Example:\n        ```py\n        from typing_extensions import Annotated\n\n        from pydantic import BaseModel, BeforeValidator\n\n        MyInt = Annotated[int, BeforeValidator(lambda v: v + 1)]\n\n        class Model(BaseModel):\n            a: MyInt\n\n        print(Model(a=1).a)\n        #> 2\n\n        try:\n            Model(a='a')\n        except TypeError as e:\n            print(e)\n            #> can only concatenate str (not \"int\") to str\n        ```\n    \"\"\"\n\n    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        schema = handler(source_type)\n        info_arg = _inspect_validator(self.func, 'before')\n        if info_arg:\n            func = cast(core_schema.WithInfoValidatorFunction, self.func)\n            return core_schema.with_info_before_validator_function(func, schema=schema, field_name=handler.field_name)\n        else:\n            func = cast(core_schema.NoInfoValidatorFunction, self.func)\n            return core_schema.no_info_before_validator_function(func, schema=schema)\n\n\n@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\nclass PlainValidator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#annotated-validators\n\n    A metadata class that indicates that a validation should be applied **instead** of the inner validation logic.\n\n    Attributes:\n        func: The validator function.\n\n    Example:\n        ```py\n        from typing_extensions import Annotated\n\n        from pydantic import BaseModel, PlainValidator\n\n        MyInt = Annotated[int, PlainValidator(lambda v: int(v) + 1)]\n\n        class Model(BaseModel):\n            a: MyInt\n\n        print(Model(a='1').a)\n        #> 2\n        ```\n    \"\"\"\n\n    func: core_schema.NoInfoValidatorFunction | core_schema.WithInfoValidatorFunction\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        # Note that for some valid uses of PlainValidator, it is not possible to generate a core schema for the\n        # source_type, so calling `handler(source_type)` will error, which prevents us from generating a proper\n        # serialization schema. To work around this for use cases that will not involve serialization, we simply\n        # catch any PydanticSchemaGenerationError that may be raised while attempting to build the serialization schema\n        # and abort any attempts to handle special serialization.\n        from pydantic import PydanticSchemaGenerationError\n\n        try:\n            schema = handler(source_type)\n            serialization = core_schema.wrap_serializer_function_ser_schema(function=lambda v, h: h(v), schema=schema)\n        except PydanticSchemaGenerationError:\n            serialization = None\n\n        info_arg = _inspect_validator(self.func, 'plain')\n        if info_arg:\n            func = cast(core_schema.WithInfoValidatorFunction, self.func)\n            return core_schema.with_info_plain_validator_function(\n                func, field_name=handler.field_name, serialization=serialization\n            )\n        else:\n            func = cast(core_schema.NoInfoValidatorFunction, self.func)\n            return core_schema.no_info_plain_validator_function(func, serialization=serialization)\n\n\n@dataclasses.dataclass(frozen=True, **_internal_dataclass.slots_true)\nclass WrapValidator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#annotated-validators\n\n    A metadata class that indicates that a validation should be applied **around** the inner validation logic.\n\n    Attributes:\n        func: The validator function.\n\n    ```py\n    from datetime import datetime\n\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, ValidationError, WrapValidator\n\n    def validate_timestamp(v, handler):\n        if v == 'now':\n            # we don't want to bother with further validation, just return the new value\n            return datetime.now()\n        try:\n            return handler(v)\n        except ValidationError:\n            # validation failed, in this case we want to return a default value\n            return datetime(2000, 1, 1)\n\n    MyTimestamp = Annotated[datetime, WrapValidator(validate_timestamp)]\n\n    class Model(BaseModel):\n        a: MyTimestamp\n\n    print(Model(a='now').a)\n    #> 2032-01-02 03:04:05.000006\n    print(Model(a='invalid').a)\n    #> 2000-01-01 00:00:00\n    ```\n    \"\"\"\n\n    func: core_schema.NoInfoWrapValidatorFunction | core_schema.WithInfoWrapValidatorFunction\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: _GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        schema = handler(source_type)\n        info_arg = _inspect_validator(self.func, 'wrap')\n        if info_arg:\n            func = cast(core_schema.WithInfoWrapValidatorFunction, self.func)\n            return core_schema.with_info_wrap_validator_function(func, schema=schema, field_name=handler.field_name)\n        else:\n            func = cast(core_schema.NoInfoWrapValidatorFunction, self.func)\n            return core_schema.no_info_wrap_validator_function(func, schema=schema)\n\n\nif TYPE_CHECKING:\n\n    class _OnlyValueValidatorClsMethod(Protocol):\n        def __call__(self, cls: Any, value: Any, /) -> Any: ...\n\n    class _V2ValidatorClsMethod(Protocol):\n        def __call__(self, cls: Any, value: Any, info: _core_schema.ValidationInfo, /) -> Any: ...\n\n    class _V2WrapValidatorClsMethod(Protocol):\n        def __call__(\n            self,\n            cls: Any,\n            value: Any,\n            handler: _core_schema.ValidatorFunctionWrapHandler,\n            info: _core_schema.ValidationInfo,\n            /,\n        ) -> Any: ...\n\n    _V2Validator = Union[\n        _V2ValidatorClsMethod,\n        _core_schema.WithInfoValidatorFunction,\n        _OnlyValueValidatorClsMethod,\n        _core_schema.NoInfoValidatorFunction,\n    ]\n\n    _V2WrapValidator = Union[\n        _V2WrapValidatorClsMethod,\n        _core_schema.WithInfoWrapValidatorFunction,\n    ]\n\n    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]\n\n    _V2BeforeAfterOrPlainValidatorType = TypeVar(\n        '_V2BeforeAfterOrPlainValidatorType',\n        _V2Validator,\n        _PartialClsOrStaticMethod,\n    )\n    _V2WrapValidatorType = TypeVar('_V2WrapValidatorType', _V2WrapValidator, _PartialClsOrStaticMethod)\n\n\n@overload\ndef field_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['before', 'after', 'plain'] = ...,\n    check_fields: bool | None = ...,\n) -> Callable[[_V2BeforeAfterOrPlainValidatorType], _V2BeforeAfterOrPlainValidatorType]: ...\n\n\n@overload\ndef field_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['wrap'],\n    check_fields: bool | None = ...,\n) -> Callable[[_V2WrapValidatorType], _V2WrapValidatorType]: ...\n\n\nFieldValidatorModes: TypeAlias = Literal['before', 'after', 'wrap', 'plain']\n\n\ndef field_validator(\n    field: str,\n    /,\n    *fields: str,\n    mode: FieldValidatorModes = 'after',\n    check_fields: bool | None = None,\n) -> Callable[[Any], Any]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#field-validators\n\n    Decorate methods on the class indicating that they should be used to validate fields.\n\n    Example usage:\n    ```py\n    from typing import Any\n\n    from pydantic import (\n        BaseModel,\n        ValidationError,\n        field_validator,\n    )\n\n    class Model(BaseModel):\n        a: str\n\n        @field_validator('a')\n        @classmethod\n        def ensure_foobar(cls, v: Any):\n            if 'foobar' not in v:\n                raise ValueError('\"foobar\" not found in a')\n            return v\n\n    print(repr(Model(a='this is foobar good')))\n    #> Model(a='this is foobar good')\n\n    try:\n        Model(a='snap')\n    except ValidationError as exc_info:\n        print(exc_info)\n        '''\n        1 validation error for Model\n        a\n          Value error, \"foobar\" not found in a [type=value_error, input_value='snap', input_type=str]\n        '''\n    ```\n\n    For more in depth examples, see [Field Validators](../concepts/validators.md#field-validators).\n\n    Args:\n        field: The first field the `field_validator` should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one.\n        *fields: Additional field(s) the `field_validator` should be called on.\n        mode: Specifies whether to validate the fields before or after validation.\n        check_fields: Whether to check that the fields actually exist on the model.\n\n    Returns:\n        A decorator that can be used to decorate a function to be used as a field_validator.\n\n    Raises:\n        PydanticUserError:\n            - If `@field_validator` is used bare (with no fields).\n            - If the args passed to `@field_validator` as fields are not strings.\n            - If `@field_validator` applied to instance methods.\n    \"\"\"\n    if isinstance(field, FunctionType):\n        raise PydanticUserError(\n            '`@field_validator` should be used with fields and keyword arguments, not bare. '\n            \"E.g. usage should be `@validator('<field_name>', ...)`\",\n            code='validator-no-fields',\n        )\n    fields = field, *fields\n    if not all(isinstance(field, str) for field in fields):\n        raise PydanticUserError(\n            '`@field_validator` fields should be passed as separate string args. '\n            \"E.g. usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],\n    ) -> _decorators.PydanticDescriptorProxy[Any]:\n        if _decorators.is_instance_method_from_sig(f):\n            raise PydanticUserError(\n                '`@field_validator` cannot be applied to instance methods', code='validator-instance-method'\n            )\n\n        # auto apply the @classmethod decorator\n        f = _decorators.ensure_classmethod_based_on_signature(f)\n\n        dec_info = _decorators.FieldValidatorDecoratorInfo(fields=fields, mode=mode, check_fields=check_fields)\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    return dec\n\n\n_ModelType = TypeVar('_ModelType')\n_ModelTypeCo = TypeVar('_ModelTypeCo', covariant=True)\n\n\nclass ModelWrapValidatorHandler(_core_schema.ValidatorFunctionWrapHandler, Protocol[_ModelTypeCo]):\n    \"\"\"@model_validator decorated function handler argument type. This is used when `mode='wrap'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        value: Any,\n        outer_location: str | int | None = None,\n        /,\n    ) -> _ModelTypeCo:  # pragma: no cover\n        ...\n\n\nclass ModelWrapValidatorWithoutInfo(Protocol[_ModelType]):\n    \"\"\"A @model_validator decorated function signature.\n    This is used when `mode='wrap'` and the function does not have info argument.\n    \"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: type[_ModelType],\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        handler: ModelWrapValidatorHandler[_ModelType],\n        /,\n    ) -> _ModelType: ...\n\n\nclass ModelWrapValidator(Protocol[_ModelType]):\n    \"\"\"A @model_validator decorated function signature. This is used when `mode='wrap'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: type[_ModelType],\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        handler: ModelWrapValidatorHandler[_ModelType],\n        info: _core_schema.ValidationInfo,\n        /,\n    ) -> _ModelType: ...\n\n\nclass FreeModelBeforeValidatorWithoutInfo(Protocol):\n    \"\"\"A @model_validator decorated function signature.\n    This is used when `mode='before'` and the function does not have info argument.\n    \"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        /,\n    ) -> Any: ...\n\n\nclass ModelBeforeValidatorWithoutInfo(Protocol):\n    \"\"\"A @model_validator decorated function signature.\n    This is used when `mode='before'` and the function does not have info argument.\n    \"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: Any,\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        /,\n    ) -> Any: ...\n\n\nclass FreeModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature. This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        info: _core_schema.ValidationInfo,\n        /,\n    ) -> Any: ...\n\n\nclass ModelBeforeValidator(Protocol):\n    \"\"\"A `@model_validator` decorated function signature. This is used when `mode='before'`.\"\"\"\n\n    def __call__(  # noqa: D102\n        self,\n        cls: Any,\n        # this can be a dict, a model instance\n        # or anything else that gets passed to validate_python\n        # thus validators _must_ handle all cases\n        value: Any,\n        info: _core_schema.ValidationInfo,\n        /,\n    ) -> Any: ...\n\n\nModelAfterValidatorWithoutInfo = Callable[[_ModelType], _ModelType]\n\"\"\"A `@model_validator` decorated function signature. This is used when `mode='after'` and the function does not\nhave info argument.\n\"\"\"\n\nModelAfterValidator = Callable[[_ModelType, _core_schema.ValidationInfo], _ModelType]\n\"\"\"A `@model_validator` decorated function signature. This is used when `mode='after'`.\"\"\"\n\n_AnyModelWrapValidator = Union[ModelWrapValidator[_ModelType], ModelWrapValidatorWithoutInfo[_ModelType]]\n_AnyModeBeforeValidator = Union[\n    FreeModelBeforeValidator, ModelBeforeValidator, FreeModelBeforeValidatorWithoutInfo, ModelBeforeValidatorWithoutInfo\n]\n_AnyModelAfterValidator = Union[ModelAfterValidator[_ModelType], ModelAfterValidatorWithoutInfo[_ModelType]]\n\n\n@overload\ndef model_validator(\n    *,\n    mode: Literal['wrap'],\n) -> Callable[\n    [_AnyModelWrapValidator[_ModelType]], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]\n]: ...\n\n\n@overload\ndef model_validator(\n    *,\n    mode: Literal['before'],\n) -> Callable[\n    [_AnyModeBeforeValidator], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]\n]: ...\n\n\n@overload\ndef model_validator(\n    *,\n    mode: Literal['after'],\n) -> Callable[\n    [_AnyModelAfterValidator[_ModelType]], _decorators.PydanticDescriptorProxy[_decorators.ModelValidatorDecoratorInfo]\n]: ...\n\n\ndef model_validator(\n    *,\n    mode: Literal['wrap', 'before', 'after'],\n) -> Any:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validators/#model-validators\n\n    Decorate model methods for validation purposes.\n\n    Example usage:\n    ```py\n    from typing_extensions import Self\n\n    from pydantic import BaseModel, ValidationError, model_validator\n\n    class Square(BaseModel):\n        width: float\n        height: float\n\n        @model_validator(mode='after')\n        def verify_square(self) -> Self:\n            if self.width != self.height:\n                raise ValueError('width and height do not match')\n            return self\n\n    s = Square(width=1, height=1)\n    print(repr(s))\n    #> Square(width=1.0, height=1.0)\n\n    try:\n        Square(width=1, height=2)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Square\n          Value error, width and height do not match [type=value_error, input_value={'width': 1, 'height': 2}, input_type=dict]\n        '''\n    ```\n\n    For more in depth examples, see [Model Validators](../concepts/validators.md#model-validators).\n\n    Args:\n        mode: A required string literal that specifies the validation mode.\n            It can be one of the following: 'wrap', 'before', or 'after'.\n\n    Returns:\n        A decorator that can be used to decorate a function to be used as a model validator.\n    \"\"\"\n\n    def dec(f: Any) -> _decorators.PydanticDescriptorProxy[Any]:\n        # auto apply the @classmethod decorator\n        f = _decorators.ensure_classmethod_based_on_signature(f)\n        dec_info = _decorators.ModelValidatorDecoratorInfo(mode=mode)\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    return dec\n\n\nAnyType = TypeVar('AnyType')\n\n\nif TYPE_CHECKING:\n    # If we add configurable attributes to IsInstance, we'd probably need to stop hiding it from type checkers like this\n    InstanceOf = Annotated[AnyType, ...]  # `IsInstance[Sequence]` will be recognized by type checkers as `Sequence`\n\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class InstanceOf:\n        '''Generic type for annotating a type that is an instance of a given class.\n\n        Example:\n            ```py\n            from pydantic import BaseModel, InstanceOf\n\n            class Foo:\n                ...\n\n            class Bar(BaseModel):\n                foo: InstanceOf[Foo]\n\n            Bar(foo=Foo())\n            try:\n                Bar(foo=42)\n            except ValidationError as e:\n                print(e)\n                \"\"\"\n                [\n                \u2502   {\n                \u2502   \u2502   'type': 'is_instance_of',\n                \u2502   \u2502   'loc': ('foo',),\n                \u2502   \u2502   'msg': 'Input should be an instance of Foo',\n                \u2502   \u2502   'input': 42,\n                \u2502   \u2502   'ctx': {'class': 'Foo'},\n                \u2502   \u2502   'url': 'https://errors.pydantic.dev/0.38.0/v/is_instance_of'\n                \u2502   }\n                ]\n                \"\"\"\n            ```\n        '''\n\n        @classmethod\n        def __class_getitem__(cls, item: AnyType) -> AnyType:\n            return Annotated[item, cls()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n            from pydantic import PydanticSchemaGenerationError\n\n            # use the generic _origin_ as the second argument to isinstance when appropriate\n            instance_of_schema = core_schema.is_instance_schema(_generics.get_origin(source) or source)\n\n            try:\n                # Try to generate the \"standard\" schema, which will be used when loading from JSON\n                original_schema = handler(source)\n            except PydanticSchemaGenerationError:\n                # If that fails, just produce a schema that can validate from python\n                return instance_of_schema\n            else:\n                # Use the \"original\" approach to serialization\n                instance_of_schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(\n                    function=lambda v, h: h(v), schema=original_schema\n                )\n                return core_schema.json_or_python_schema(python_schema=instance_of_schema, json_schema=original_schema)\n\n        __hash__ = object.__hash__\n\n\nif TYPE_CHECKING:\n    SkipValidation = Annotated[AnyType, ...]  # SkipValidation[list[str]] will be treated by type checkers as list[str]\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SkipValidation:\n        \"\"\"If this is applied as an annotation (e.g., via `x: Annotated[int, SkipValidation]`), validation will be\n            skipped. You can also use `SkipValidation[int]` as a shorthand for `Annotated[int, SkipValidation]`.\n\n        This can be useful if you want to use a type annotation for documentation/IDE/type-checking purposes,\n        and know that it is safe to skip validation for one or more of the fields.\n\n        Because this converts the validation schema to `any_schema`, subsequent annotation-applied transformations\n        may not have the expected effects. Therefore, when used, this annotation should generally be the final\n        annotation applied to a type.\n        \"\"\"\n\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SkipValidation()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n            original_schema = handler(source)\n            metadata = _core_metadata.build_metadata_dict(js_annotation_functions=[lambda _c, h: h(original_schema)])\n            return core_schema.any_schema(\n                metadata=metadata,\n                serialization=core_schema.wrap_serializer_function_ser_schema(\n                    function=lambda v, h: h(v), schema=original_schema\n                ),\n            )\n\n        __hash__ = object.__hash__\n", "pydantic/generics.py": "\"\"\"The `generics` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/color.py": "\"\"\"Color definitions are used as per the CSS3\n[CSS Color Module Level 3](http://www.w3.org/TR/css3-color/#svg-color) specification.\n\nA few colors have multiple names referring to the sames colors, eg. `grey` and `gray` or `aqua` and `cyan`.\n\nIn these cases the _last_ color when sorted alphabetically takes preferences,\neg. `Color((0, 255, 255)).as_named() == 'cyan'` because \"cyan\" comes after \"aqua\".\n\nWarning: Deprecated\n    The `Color` class is deprecated, use `pydantic_extra_types` instead.\n    See [`pydantic-extra-types.Color`](../usage/types/extra_types/color_types.md)\n    for more information.\n\"\"\"\n\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import Any, Callable, Optional, Tuple, Type, Union, cast\n\nfrom pydantic_core import CoreSchema, PydanticCustomError, core_schema\nfrom typing_extensions import deprecated\n\nfrom ._internal import _repr\nfrom ._internal._schema_generation_shared import GetJsonSchemaHandler as _GetJsonSchemaHandler\nfrom .json_schema import JsonSchemaValue\nfrom .warnings import PydanticDeprecatedSince20\n\nColorTuple = Union[Tuple[int, int, int], Tuple[int, int, int, float]]\nColorType = Union[ColorTuple, str]\nHslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float, float]]\n\n\nclass RGBA:\n    \"\"\"Internal use only as a representation of a color.\"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.alpha = alpha\n\n        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b, alpha)\n\n    def __getitem__(self, item: Any) -> Any:\n        return self._tuple[item]\n\n\n# these are not compiled here to avoid import slowdown, they'll be compiled the first time they're used, then cached\n_r_255 = r'(\\d{1,3}(?:\\.\\d+)?)'\n_r_comma = r'\\s*,\\s*'\n_r_alpha = r'(\\d(?:\\.\\d+)?|\\.\\d+|\\d{1,2}%)'\n_r_h = r'(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)(deg|rad|turn)?'\n_r_sl = r'(\\d{1,3}(?:\\.\\d+)?)%'\nr_hex_short = r'\\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\\s*'\nr_hex_long = r'\\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\\s*'\n# CSS3 RGB examples: rgb(0, 0, 0), rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 50%)\nr_rgb = rf'\\s*rgba?\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}(?:{_r_comma}{_r_alpha})?\\s*\\)\\s*'\n# CSS3 HSL examples: hsl(270, 60%, 50%), hsla(270, 60%, 50%, 0.5), hsla(270, 60%, 50%, 50%)\nr_hsl = rf'\\s*hsla?\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}(?:{_r_comma}{_r_alpha})?\\s*\\)\\s*'\n# CSS4 RGB examples: rgb(0 0 0), rgb(0 0 0 / 0.5), rgb(0 0 0 / 50%), rgba(0 0 0 / 50%)\nr_rgb_v4_style = rf'\\s*rgba?\\(\\s*{_r_255}\\s+{_r_255}\\s+{_r_255}(?:\\s*/\\s*{_r_alpha})?\\s*\\)\\s*'\n# CSS4 HSL examples: hsl(270 60% 50%), hsl(270 60% 50% / 0.5), hsl(270 60% 50% / 50%), hsla(270 60% 50% / 50%)\nr_hsl_v4_style = rf'\\s*hsla?\\(\\s*{_r_h}\\s+{_r_sl}\\s+{_r_sl}(?:\\s*/\\s*{_r_alpha})?\\s*\\)\\s*'\n\n# colors where the two hex characters are the same, if all colors match this the short version of hex colors can be used\nrepeat_colors = {int(c * 2, 16) for c in '0123456789abcdef'}\nrads = 2 * math.pi\n\n\n@deprecated(\n    'The `Color` class is deprecated, use `pydantic_extra_types` instead. '\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_color/.',\n    category=PydanticDeprecatedSince20,\n)\nclass Color(_repr.Representation):\n    \"\"\"Represents a color.\"\"\"\n\n    __slots__ = '_original', '_rgba'\n\n    def __init__(self, value: ColorType) -> None:\n        self._rgba: RGBA\n        self._original: ColorType\n        if isinstance(value, (tuple, list)):\n            self._rgba = parse_tuple(value)\n        elif isinstance(value, str):\n            self._rgba = parse_str(value)\n        elif isinstance(value, Color):\n            self._rgba = value._rgba\n            value = value._original\n        else:\n            raise PydanticCustomError(\n                'color_error', 'value is not a valid color: value must be a tuple, list or string'\n            )\n\n        # if we've got here value must be a valid color\n        self._original = value\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: core_schema.CoreSchema, handler: _GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = {}\n        field_schema.update(type='string', format='color')\n        return field_schema\n\n    def original(self) -> ColorType:\n        \"\"\"Original value passed to `Color`.\"\"\"\n        return self._original\n\n    def as_named(self, *, fallback: bool = False) -> str:\n        \"\"\"Returns the name of the color if it can be found in `COLORS_BY_VALUE` dictionary,\n        otherwise returns the hexadecimal representation of the color or raises `ValueError`.\n\n        Args:\n            fallback: If True, falls back to returning the hexadecimal representation of\n                the color instead of raising a ValueError when no named color is found.\n\n        Returns:\n            The name of the color, or the hexadecimal representation of the color.\n\n        Raises:\n            ValueError: When no named color is found and fallback is `False`.\n        \"\"\"\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e:\n                if fallback:\n                    return self.as_hex()\n                else:\n                    raise ValueError('no named color found, use fallback=True, as_hex() or as_rgb()') from e\n        else:\n            return self.as_hex()\n\n    def as_hex(self) -> str:\n        \"\"\"Returns the hexadecimal representation of the color.\n\n        Hex string representing the color can be 3, 4, 6, or 8 characters depending on whether the string\n        a \"short\" representation of the color is possible and whether there's an alpha channel.\n\n        Returns:\n            The hexadecimal representation of the color.\n        \"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' for v in values)\n        if all(c in repeat_colors for c in values):\n            as_hex = ''.join(as_hex[c] for c in range(0, len(as_hex), 2))\n        return '#' + as_hex\n\n    def as_rgb(self) -> str:\n        \"\"\"Color as an `rgb(<r>, <g>, <b>)` or `rgba(<r>, <g>, <b>, <a>)` string.\"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n                f'rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, '\n                f'{round(self._alpha_float(), 2)})'\n            )\n\n    def as_rgb_tuple(self, *, alpha: Optional[bool] = None) -> ColorTuple:\n        \"\"\"Returns the color as an RGB or RGBA tuple.\n\n        Args:\n            alpha: Whether to include the alpha channel. There are three options for this input:\n\n                - `None` (default): Include alpha only if it's set. (e.g. not `None`)\n                - `True`: Always include alpha.\n                - `False`: Always omit alpha.\n\n        Returns:\n            A tuple that contains the values of the red, green, and blue channels in the range 0 to 255.\n                If alpha is included, it is in the range 0 to 1.\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                return r, g, b, self._alpha_float()\n        elif alpha:\n            return r, g, b, self._alpha_float()\n        else:\n            # alpha is False\n            return r, g, b\n\n    def as_hsl(self) -> str:\n        \"\"\"Color as an `hsl(<h>, <s>, <l>)` or `hsl(<h>, <s>, <l>, <a>)` string.\"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})'\n\n    def as_hsl_tuple(self, *, alpha: Optional[bool] = None) -> HslColorTuple:\n        \"\"\"Returns the color as an HSL or HSLA tuple.\n\n        Args:\n            alpha: Whether to include the alpha channel.\n\n                - `None` (default): Include the alpha channel only if it's set (e.g. not `None`).\n                - `True`: Always include alpha.\n                - `False`: Always omit alpha.\n\n        Returns:\n            The color as a tuple of hue, saturation, lightness, and alpha (if included).\n                All elements are in the range 0 to 1.\n\n        Note:\n            This is HSL as used in HTML and most other places, not HLS as used in Python's `colorsys`.\n        \"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)  # noqa: E741\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            else:\n                return h, s, l, self._alpha_float()\n        if alpha:\n            return h, s, l, self._alpha_float()\n        else:\n            # alpha is False\n            return h, s, l\n\n    def _alpha_float(self) -> float:\n        return 1 if self._rgba.alpha is None else self._rgba.alpha\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls, source: Type[Any], handler: Callable[[Any], CoreSchema]\n    ) -> core_schema.CoreSchema:\n        return core_schema.with_info_plain_validator_function(\n            cls._validate, serialization=core_schema.to_string_ser_schema()\n        )\n\n    @classmethod\n    def _validate(cls, __input_value: Any, _: Any) -> 'Color':\n        return cls(__input_value)\n\n    def __str__(self) -> str:\n        return self.as_named(fallback=True)\n\n    def __repr_args__(self) -> '_repr.ReprArgs':\n        return [(None, self.as_named(fallback=True))] + [('rgb', self.as_rgb_tuple())]\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, Color) and self.as_rgb_tuple() == other.as_rgb_tuple()\n\n    def __hash__(self) -> int:\n        return hash(self.as_rgb_tuple())\n\n\ndef parse_tuple(value: Tuple[Any, ...]) -> RGBA:\n    \"\"\"Parse a tuple or list to get RGBA values.\n\n    Args:\n        value: A tuple or list.\n\n    Returns:\n        An `RGBA` tuple parsed from the input tuple.\n\n    Raises:\n        PydanticCustomError: If tuple is not valid.\n    \"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[:3])\n        return RGBA(r, g, b, parse_float_alpha(value[3]))\n    else:\n        raise PydanticCustomError('color_error', 'value is not a valid color: tuples must have length 3 or 4')\n\n\ndef parse_str(value: str) -> RGBA:\n    \"\"\"Parse a string representing a color to an RGBA tuple.\n\n    Possible formats for the input string include:\n\n    * named color, see `COLORS_BY_NAME`\n    * hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>)`\n    * `rgba(<r>, <g>, <b>, <a>)`\n\n    Args:\n        value: A string representing a color.\n\n    Returns:\n        An `RGBA` tuple parsed from the input string.\n\n    Raises:\n        ValueError: If the input string cannot be parsed to an RGBA tuple.\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(r_hex_short, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v * 2, 16) for v in rgb)\n        if a:\n            alpha: Optional[float] = int(a * 2, 16) / 255\n        else:\n            alpha = None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_hex_long, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v, 16) for v in rgb)\n        if a:\n            alpha = int(a, 16) / 255\n        else:\n            alpha = None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_rgb, value_lower) or re.fullmatch(r_rgb_v4_style, value_lower)\n    if m:\n        return ints_to_rgba(*m.groups())  # type: ignore\n\n    m = re.fullmatch(r_hsl, value_lower) or re.fullmatch(r_hsl_v4_style, value_lower)\n    if m:\n        return parse_hsl(*m.groups())  # type: ignore\n\n    raise PydanticCustomError('color_error', 'value is not a valid color: string not recognised as a valid color')\n\n\ndef ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str], alpha: Optional[float] = None) -> RGBA:\n    \"\"\"Converts integer or string values for RGB color and an optional alpha value to an `RGBA` object.\n\n    Args:\n        r: An integer or string representing the red color value.\n        g: An integer or string representing the green color value.\n        b: An integer or string representing the blue color value.\n        alpha: A float representing the alpha value. Defaults to None.\n\n    Returns:\n        An instance of the `RGBA` class with the corresponding color and alpha values.\n    \"\"\"\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"Parse the color value provided and return a number between 0 and 1.\n\n    Args:\n        value: An integer or string color value.\n        max_val: Maximum range value. Defaults to 255.\n\n    Raises:\n        PydanticCustomError: If the value is not a valid color.\n\n    Returns:\n        A number between 0 and 1.\n    \"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: color values must be a valid number')\n    if 0 <= color <= max_val:\n        return color / max_val\n    else:\n        raise PydanticCustomError(\n            'color_error',\n            'value is not a valid color: color values must be in the range 0 to {max_val}',\n            {'max_val': max_val},\n        )\n\n\ndef parse_float_alpha(value: Union[None, str, float, int]) -> Optional[float]:\n    \"\"\"Parse an alpha value checking it's a valid float in the range 0 to 1.\n\n    Args:\n        value: The input value to parse.\n\n    Returns:\n        The parsed value as a float, or `None` if the value was None or equal 1.\n\n    Raises:\n        PydanticCustomError: If the input value cannot be successfully parsed as a float in the expected range.\n    \"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(value)\n    except ValueError:\n        raise PydanticCustomError('color_error', 'value is not a valid color: alpha values must be a valid float')\n\n    if math.isclose(alpha, 1):\n        return None\n    elif 0 <= alpha <= 1:\n        return alpha\n    else:\n        raise PydanticCustomError('color_error', 'value is not a valid color: alpha values must be in the range 0 to 1')\n\n\ndef parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[float] = None) -> RGBA:\n    \"\"\"Parse raw hue, saturation, lightness, and alpha values and convert to RGBA.\n\n    Args:\n        h: The hue value.\n        h_units: The unit for hue value.\n        sat: The saturation value.\n        light: The lightness value.\n        alpha: Alpha value.\n\n    Returns:\n        An instance of `RGBA`.\n    \"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units == 'rad':\n        h_value = h_value % rads / rads\n    else:\n        # turns\n        h_value = h_value % 1\n\n    r, g, b = hls_to_rgb(h_value, l_value, s_value)\n    return RGBA(r, g, b, parse_float_alpha(alpha))\n\n\ndef float_to_255(c: float) -> int:\n    \"\"\"Converts a float value between 0 and 1 (inclusive) to an integer between 0 and 255 (inclusive).\n\n    Args:\n        c: The float value to be converted. Must be between 0 and 1 (inclusive).\n\n    Returns:\n        The integer equivalent of the given float value rounded to the nearest whole number.\n\n    Raises:\n        ValueError: If the given float value is outside the acceptable range of 0 to 1 (inclusive).\n    \"\"\"\n    return int(round(c * 255))\n\n\nCOLORS_BY_NAME = {\n    'aliceblue': (240, 248, 255),\n    'antiquewhite': (250, 235, 215),\n    'aqua': (0, 255, 255),\n    'aquamarine': (127, 255, 212),\n    'azure': (240, 255, 255),\n    'beige': (245, 245, 220),\n    'bisque': (255, 228, 196),\n    'black': (0, 0, 0),\n    'blanchedalmond': (255, 235, 205),\n    'blue': (0, 0, 255),\n    'blueviolet': (138, 43, 226),\n    'brown': (165, 42, 42),\n    'burlywood': (222, 184, 135),\n    'cadetblue': (95, 158, 160),\n    'chartreuse': (127, 255, 0),\n    'chocolate': (210, 105, 30),\n    'coral': (255, 127, 80),\n    'cornflowerblue': (100, 149, 237),\n    'cornsilk': (255, 248, 220),\n    'crimson': (220, 20, 60),\n    'cyan': (0, 255, 255),\n    'darkblue': (0, 0, 139),\n    'darkcyan': (0, 139, 139),\n    'darkgoldenrod': (184, 134, 11),\n    'darkgray': (169, 169, 169),\n    'darkgreen': (0, 100, 0),\n    'darkgrey': (169, 169, 169),\n    'darkkhaki': (189, 183, 107),\n    'darkmagenta': (139, 0, 139),\n    'darkolivegreen': (85, 107, 47),\n    'darkorange': (255, 140, 0),\n    'darkorchid': (153, 50, 204),\n    'darkred': (139, 0, 0),\n    'darksalmon': (233, 150, 122),\n    'darkseagreen': (143, 188, 143),\n    'darkslateblue': (72, 61, 139),\n    'darkslategray': (47, 79, 79),\n    'darkslategrey': (47, 79, 79),\n    'darkturquoise': (0, 206, 209),\n    'darkviolet': (148, 0, 211),\n    'deeppink': (255, 20, 147),\n    'deepskyblue': (0, 191, 255),\n    'dimgray': (105, 105, 105),\n    'dimgrey': (105, 105, 105),\n    'dodgerblue': (30, 144, 255),\n    'firebrick': (178, 34, 34),\n    'floralwhite': (255, 250, 240),\n    'forestgreen': (34, 139, 34),\n    'fuchsia': (255, 0, 255),\n    'gainsboro': (220, 220, 220),\n    'ghostwhite': (248, 248, 255),\n    'gold': (255, 215, 0),\n    'goldenrod': (218, 165, 32),\n    'gray': (128, 128, 128),\n    'green': (0, 128, 0),\n    'greenyellow': (173, 255, 47),\n    'grey': (128, 128, 128),\n    'honeydew': (240, 255, 240),\n    'hotpink': (255, 105, 180),\n    'indianred': (205, 92, 92),\n    'indigo': (75, 0, 130),\n    'ivory': (255, 255, 240),\n    'khaki': (240, 230, 140),\n    'lavender': (230, 230, 250),\n    'lavenderblush': (255, 240, 245),\n    'lawngreen': (124, 252, 0),\n    'lemonchiffon': (255, 250, 205),\n    'lightblue': (173, 216, 230),\n    'lightcoral': (240, 128, 128),\n    'lightcyan': (224, 255, 255),\n    'lightgoldenrodyellow': (250, 250, 210),\n    'lightgray': (211, 211, 211),\n    'lightgreen': (144, 238, 144),\n    'lightgrey': (211, 211, 211),\n    'lightpink': (255, 182, 193),\n    'lightsalmon': (255, 160, 122),\n    'lightseagreen': (32, 178, 170),\n    'lightskyblue': (135, 206, 250),\n    'lightslategray': (119, 136, 153),\n    'lightslategrey': (119, 136, 153),\n    'lightsteelblue': (176, 196, 222),\n    'lightyellow': (255, 255, 224),\n    'lime': (0, 255, 0),\n    'limegreen': (50, 205, 50),\n    'linen': (250, 240, 230),\n    'magenta': (255, 0, 255),\n    'maroon': (128, 0, 0),\n    'mediumaquamarine': (102, 205, 170),\n    'mediumblue': (0, 0, 205),\n    'mediumorchid': (186, 85, 211),\n    'mediumpurple': (147, 112, 219),\n    'mediumseagreen': (60, 179, 113),\n    'mediumslateblue': (123, 104, 238),\n    'mediumspringgreen': (0, 250, 154),\n    'mediumturquoise': (72, 209, 204),\n    'mediumvioletred': (199, 21, 133),\n    'midnightblue': (25, 25, 112),\n    'mintcream': (245, 255, 250),\n    'mistyrose': (255, 228, 225),\n    'moccasin': (255, 228, 181),\n    'navajowhite': (255, 222, 173),\n    'navy': (0, 0, 128),\n    'oldlace': (253, 245, 230),\n    'olive': (128, 128, 0),\n    'olivedrab': (107, 142, 35),\n    'orange': (255, 165, 0),\n    'orangered': (255, 69, 0),\n    'orchid': (218, 112, 214),\n    'palegoldenrod': (238, 232, 170),\n    'palegreen': (152, 251, 152),\n    'paleturquoise': (175, 238, 238),\n    'palevioletred': (219, 112, 147),\n    'papayawhip': (255, 239, 213),\n    'peachpuff': (255, 218, 185),\n    'peru': (205, 133, 63),\n    'pink': (255, 192, 203),\n    'plum': (221, 160, 221),\n    'powderblue': (176, 224, 230),\n    'purple': (128, 0, 128),\n    'red': (255, 0, 0),\n    'rosybrown': (188, 143, 143),\n    'royalblue': (65, 105, 225),\n    'saddlebrown': (139, 69, 19),\n    'salmon': (250, 128, 114),\n    'sandybrown': (244, 164, 96),\n    'seagreen': (46, 139, 87),\n    'seashell': (255, 245, 238),\n    'sienna': (160, 82, 45),\n    'silver': (192, 192, 192),\n    'skyblue': (135, 206, 235),\n    'slateblue': (106, 90, 205),\n    'slategray': (112, 128, 144),\n    'slategrey': (112, 128, 144),\n    'snow': (255, 250, 250),\n    'springgreen': (0, 255, 127),\n    'steelblue': (70, 130, 180),\n    'tan': (210, 180, 140),\n    'teal': (0, 128, 128),\n    'thistle': (216, 191, 216),\n    'tomato': (255, 99, 71),\n    'turquoise': (64, 224, 208),\n    'violet': (238, 130, 238),\n    'wheat': (245, 222, 179),\n    'white': (255, 255, 255),\n    'whitesmoke': (245, 245, 245),\n    'yellow': (255, 255, 0),\n    'yellowgreen': (154, 205, 50),\n}\n\nCOLORS_BY_VALUE = {v: k for k, v in COLORS_BY_NAME.items()}\n", "pydantic/config.py": "\"\"\"Configuration for Pydantic models.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Type, TypeVar, Union\n\nfrom typing_extensions import Literal, TypeAlias, TypedDict\n\nfrom ._migration import getattr_migration\nfrom .aliases import AliasGenerator\nfrom .errors import PydanticUserError\n\nif TYPE_CHECKING:\n    from ._internal._generate_schema import GenerateSchema as _GenerateSchema\n    from .fields import ComputedFieldInfo, FieldInfo\n\n__all__ = ('ConfigDict', 'with_config')\n\n\nJsonValue: TypeAlias = Union[int, float, str, bool, None, List['JsonValue'], 'JsonDict']\nJsonDict: TypeAlias = Dict[str, JsonValue]\n\nJsonEncoder = Callable[[Any], Any]\n\nJsonSchemaExtraCallable: TypeAlias = Union[\n    Callable[[JsonDict], None],\n    Callable[[JsonDict, Type[Any]], None],\n]\n\nExtraValues = Literal['allow', 'ignore', 'forbid']\n\n\nclass ConfigDict(TypedDict, total=False):\n    \"\"\"A TypedDict for configuring Pydantic behaviour.\"\"\"\n\n    title: str | None\n    \"\"\"The title for the generated JSON schema, defaults to the model's name\"\"\"\n\n    model_title_generator: Callable[[type], str] | None\n    \"\"\"A callable that takes a model class and returns the title for it. Defaults to `None`.\"\"\"\n\n    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n    \"\"\"A callable that takes a field's name and info and returns title for it. Defaults to `None`.\"\"\"\n\n    str_to_lower: bool\n    \"\"\"Whether to convert all characters to lowercase for str types. Defaults to `False`.\"\"\"\n\n    str_to_upper: bool\n    \"\"\"Whether to convert all characters to uppercase for str types. Defaults to `False`.\"\"\"\n\n    str_strip_whitespace: bool\n    \"\"\"Whether to strip leading and trailing whitespace for str types.\"\"\"\n\n    str_min_length: int\n    \"\"\"The minimum length for str types. Defaults to `None`.\"\"\"\n\n    str_max_length: int | None\n    \"\"\"The maximum length for str types. Defaults to `None`.\"\"\"\n\n    extra: ExtraValues | None\n    \"\"\"\n    Whether to ignore, allow, or forbid extra attributes during model initialization. Defaults to `'ignore'`.\n\n    You can configure how pydantic handles the attributes that are not defined in the model:\n\n    * `allow` - Allow any extra attributes.\n    * `forbid` - Forbid any extra attributes.\n    * `ignore` - Ignore any extra attributes.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(extra='ignore')  # (1)!\n\n        name: str\n\n\n    user = User(name='John Doe', age=20)  # (2)!\n    print(user)\n    #> name='John Doe'\n    ```\n\n    1. This is the default behaviour.\n    2. The `age` argument is ignored.\n\n    Instead, with `extra='allow'`, the `age` argument is included:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(extra='allow')\n\n        name: str\n\n\n    user = User(name='John Doe', age=20)  # (1)!\n    print(user)\n    #> name='John Doe' age=20\n    ```\n\n    1. The `age` argument is included.\n\n    With `extra='forbid'`, an error is raised:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(extra='forbid')\n\n        name: str\n\n\n    try:\n        User(name='John Doe', age=20)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for User\n        age\n        Extra inputs are not permitted [type=extra_forbidden, input_value=20, input_type=int]\n        '''\n    ```\n    \"\"\"\n\n    frozen: bool\n    \"\"\"\n    Whether models are faux-immutable, i.e. whether `__setattr__` is allowed, and also generates\n    a `__hash__()` method for the model. This makes instances of the model potentially hashable if all the\n    attributes are hashable. Defaults to `False`.\n\n    Note:\n        On V1, the inverse of this setting was called `allow_mutation`, and was `True` by default.\n    \"\"\"\n\n    populate_by_name: bool\n    \"\"\"\n    Whether an aliased field may be populated by its name as given by the model\n    attribute, as well as the alias. Defaults to `False`.\n\n    Note:\n        The name of this configuration setting was changed in **v2.0** from\n        `allow_population_by_field_name` to `populate_by_name`.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class User(BaseModel):\n        model_config = ConfigDict(populate_by_name=True)\n\n        name: str = Field(alias='full_name')  # (1)!\n        age: int\n\n\n    user = User(full_name='John Doe', age=20)  # (2)!\n    print(user)\n    #> name='John Doe' age=20\n    user = User(name='John Doe', age=20)  # (3)!\n    print(user)\n    #> name='John Doe' age=20\n    ```\n\n    1. The field `'name'` has an alias `'full_name'`.\n    2. The model is populated by the alias `'full_name'`.\n    3. The model is populated by the field name `'name'`.\n    \"\"\"\n\n    use_enum_values: bool\n    \"\"\"\n    Whether to populate models with the `value` property of enums, rather than the raw enum.\n    This may be useful if you want to serialize `model.model_dump()` later. Defaults to `False`.\n\n    !!! note\n        If you have an `Optional[Enum]` value that you set a default for, you need to use `validate_default=True`\n        for said Field to ensure that the `use_enum_values` flag takes effect on the default, as extracting an\n        enum's value occurs during validation, not serialization.\n\n    ```py\n    from enum import Enum\n    from typing import Optional\n\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class SomeEnum(Enum):\n        FOO = 'foo'\n        BAR = 'bar'\n        BAZ = 'baz'\n\n\n    class SomeModel(BaseModel):\n        model_config = ConfigDict(use_enum_values=True)\n\n        some_enum: SomeEnum\n        another_enum: Optional[SomeEnum] = Field(default=SomeEnum.FOO, validate_default=True)\n\n\n    model1 = SomeModel(some_enum=SomeEnum.BAR)\n    print(model1.model_dump())\n    # {'some_enum': 'bar', 'another_enum': 'foo'}\n\n    model2 = SomeModel(some_enum=SomeEnum.BAR, another_enum=SomeEnum.BAZ)\n    print(model2.model_dump())\n    #> {'some_enum': 'bar', 'another_enum': 'baz'}\n    ```\n    \"\"\"\n\n    validate_assignment: bool\n    \"\"\"\n    Whether to validate the data when the model is changed. Defaults to `False`.\n\n    The default behavior of Pydantic is to validate the data when the model is created.\n\n    In case the user changes the data after the model is created, the model is _not_ revalidated.\n\n    ```py\n    from pydantic import BaseModel\n\n    class User(BaseModel):\n        name: str\n\n    user = User(name='John Doe')  # (1)!\n    print(user)\n    #> name='John Doe'\n    user.name = 123  # (1)!\n    print(user)\n    #> name=123\n    ```\n\n    1. The validation happens only when the model is created.\n    2. The validation does not happen when the data is changed.\n\n    In case you want to revalidate the model when the data is changed, you can use `validate_assignment=True`:\n\n    ```py\n    from pydantic import BaseModel, ValidationError\n\n    class User(BaseModel, validate_assignment=True):  # (1)!\n        name: str\n\n    user = User(name='John Doe')  # (2)!\n    print(user)\n    #> name='John Doe'\n    try:\n        user.name = 123  # (3)!\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for User\n        name\n          Input should be a valid string [type=string_type, input_value=123, input_type=int]\n        '''\n    ```\n\n    1. You can either use class keyword arguments, or `model_config` to set `validate_assignment=True`.\n    2. The validation happens when the model is created.\n    3. The validation _also_ happens when the data is changed.\n    \"\"\"\n\n    arbitrary_types_allowed: bool\n    \"\"\"\n    Whether arbitrary types are allowed for field types. Defaults to `False`.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n    # This is not a pydantic model, it's an arbitrary class\n    class Pet:\n        def __init__(self, name: str):\n            self.name = name\n\n    class Model(BaseModel):\n        model_config = ConfigDict(arbitrary_types_allowed=True)\n\n        pet: Pet\n        owner: str\n\n    pet = Pet(name='Hedwig')\n    # A simple check of instance type is used to validate the data\n    model = Model(owner='Harry', pet=pet)\n    print(model)\n    #> pet=<__main__.Pet object at 0x0123456789ab> owner='Harry'\n    print(model.pet)\n    #> <__main__.Pet object at 0x0123456789ab>\n    print(model.pet.name)\n    #> Hedwig\n    print(type(model.pet))\n    #> <class '__main__.Pet'>\n    try:\n        # If the value is not an instance of the type, it's invalid\n        Model(owner='Harry', pet='Hedwig')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        pet\n          Input should be an instance of Pet [type=is_instance_of, input_value='Hedwig', input_type=str]\n        '''\n\n    # Nothing in the instance of the arbitrary type is checked\n    # Here name probably should have been a str, but it's not validated\n    pet2 = Pet(name=42)\n    model2 = Model(owner='Harry', pet=pet2)\n    print(model2)\n    #> pet=<__main__.Pet object at 0x0123456789ab> owner='Harry'\n    print(model2.pet)\n    #> <__main__.Pet object at 0x0123456789ab>\n    print(model2.pet.name)\n    #> 42\n    print(type(model2.pet))\n    #> <class '__main__.Pet'>\n    ```\n    \"\"\"\n\n    from_attributes: bool\n    \"\"\"\n    Whether to build models and look up discriminators of tagged unions using python object attributes.\n    \"\"\"\n\n    loc_by_alias: bool\n    \"\"\"Whether to use the actual key provided in the data (e.g. alias) for error `loc`s rather than the field's name. Defaults to `True`.\"\"\"\n\n    alias_generator: Callable[[str], str] | AliasGenerator | None\n    \"\"\"\n    A callable that takes a field name and returns an alias for it\n    or an instance of [`AliasGenerator`][pydantic.aliases.AliasGenerator]. Defaults to `None`.\n\n    When using a callable, the alias generator is used for both validation and serialization.\n    If you want to use different alias generators for validation and serialization, you can use\n    [`AliasGenerator`][pydantic.aliases.AliasGenerator] instead.\n\n    If data source field names do not match your code style (e. g. CamelCase fields),\n    you can automatically generate aliases using `alias_generator`. Here's an example with\n    a basic callable:\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n    from pydantic.alias_generators import to_pascal\n\n    class Voice(BaseModel):\n        model_config = ConfigDict(alias_generator=to_pascal)\n\n        name: str\n        language_code: str\n\n    voice = Voice(Name='Filiz', LanguageCode='tr-TR')\n    print(voice.language_code)\n    #> tr-TR\n    print(voice.model_dump(by_alias=True))\n    #> {'Name': 'Filiz', 'LanguageCode': 'tr-TR'}\n    ```\n\n    If you want to use different alias generators for validation and serialization, you can use\n    [`AliasGenerator`][pydantic.aliases.AliasGenerator].\n\n    ```py\n    from pydantic import AliasGenerator, BaseModel, ConfigDict\n    from pydantic.alias_generators import to_camel, to_pascal\n\n    class Athlete(BaseModel):\n        first_name: str\n        last_name: str\n        sport: str\n\n        model_config = ConfigDict(\n            alias_generator=AliasGenerator(\n                validation_alias=to_camel,\n                serialization_alias=to_pascal,\n            )\n        )\n\n    athlete = Athlete(firstName='John', lastName='Doe', sport='track')\n    print(athlete.model_dump(by_alias=True))\n    #> {'FirstName': 'John', 'LastName': 'Doe', 'Sport': 'track'}\n    ```\n\n    Note:\n        Pydantic offers three built-in alias generators: [`to_pascal`][pydantic.alias_generators.to_pascal],\n        [`to_camel`][pydantic.alias_generators.to_camel], and [`to_snake`][pydantic.alias_generators.to_snake].\n    \"\"\"\n\n    ignored_types: tuple[type, ...]\n    \"\"\"A tuple of types that may occur as values of class attributes without annotations. This is\n    typically used for custom descriptors (classes that behave like `property`). If an attribute is set on a\n    class without an annotation and has a type that is not in this tuple (or otherwise recognized by\n    _pydantic_), an error will be raised. Defaults to `()`.\n    \"\"\"\n\n    allow_inf_nan: bool\n    \"\"\"Whether to allow infinity (`+inf` an `-inf`) and NaN values to float fields. Defaults to `True`.\"\"\"\n\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    \"\"\"A dict or callable to provide extra JSON schema properties. Defaults to `None`.\"\"\"\n\n    json_encoders: dict[type[object], JsonEncoder] | None\n    \"\"\"\n    A `dict` of custom JSON encoders for specific types. Defaults to `None`.\n\n    !!! warning \"Deprecated\"\n        This config option is a carryover from v1.\n        We originally planned to remove it in v2 but didn't have a 1:1 replacement so we are keeping it for now.\n        It is still deprecated and will likely be removed in the future.\n    \"\"\"\n\n    # new in V2\n    strict: bool\n    \"\"\"\n    _(new in V2)_ If `True`, strict validation is applied to all fields on the model.\n\n    By default, Pydantic attempts to coerce values to the correct type, when possible.\n\n    There are situations in which you may want to disable this behavior, and instead raise an error if a value's type\n    does not match the field's type annotation.\n\n    To configure strict mode for all fields on a model, you can set `strict=True` on the model.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n\n    class Model(BaseModel):\n        model_config = ConfigDict(strict=True)\n\n        name: str\n        age: int\n    ```\n\n    See [Strict Mode](../concepts/strict_mode.md) for more details.\n\n    See the [Conversion Table](../concepts/conversion_table.md) for more details on how Pydantic converts data in both\n    strict and lax modes.\n    \"\"\"\n    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']\n    \"\"\"\n    When and how to revalidate models and dataclasses during validation. Accepts the string\n    values of `'never'`, `'always'` and `'subclass-instances'`. Defaults to `'never'`.\n\n    - `'never'` will not revalidate models and dataclasses during validation\n    - `'always'` will revalidate models and dataclasses during validation\n    - `'subclass-instances'` will revalidate models and dataclasses during validation if the instance is a\n        subclass of the model or dataclass\n\n    By default, model and dataclass instances are not revalidated during validation.\n\n    ```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='never'):  # (1)!\n        hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n    print(t)\n    #> user=User(hobbies=['reading'])\n\n    my_user.hobbies = [1]  # (2)!\n    t = Transaction(user=my_user)  # (3)!\n    print(t)\n    #> user=User(hobbies=[1])\n\n    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n    t = Transaction(user=my_sub_user)\n    print(t)\n    #> user=SubUser(hobbies=['scuba diving'], sins=['lying'])\n    ```\n\n    1. `revalidate_instances` is set to `'never'` by **default.\n    2. The assignment is not validated, unless you set `validate_assignment` to `True` in the model's config.\n    3. Since `revalidate_instances` is set to `never`, this is not revalidated.\n\n    If you want to revalidate instances during validation, you can set `revalidate_instances` to `'always'`\n    in the model's config.\n\n    ```py\n    from typing import List\n\n    from pydantic import BaseModel, ValidationError\n\n    class User(BaseModel, revalidate_instances='always'):  # (1)!\n        hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n    print(t)\n    #> user=User(hobbies=['reading'])\n\n    my_user.hobbies = [1]\n    try:\n        t = Transaction(user=my_user)  # (2)!\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Transaction\n        user.hobbies.0\n          Input should be a valid string [type=string_type, input_value=1, input_type=int]\n        '''\n\n    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n    t = Transaction(user=my_sub_user)\n    print(t)  # (3)!\n    #> user=User(hobbies=['scuba diving'])\n    ```\n\n    1. `revalidate_instances` is set to `'always'`.\n    2. The model is revalidated, since `revalidate_instances` is set to `'always'`.\n    3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n\n    It's also possible to set `revalidate_instances` to `'subclass-instances'` to only revalidate instances\n    of subclasses of the model.\n\n    ```py\n    from typing import List\n\n    from pydantic import BaseModel\n\n    class User(BaseModel, revalidate_instances='subclass-instances'):  # (1)!\n        hobbies: List[str]\n\n    class SubUser(User):\n        sins: List[str]\n\n    class Transaction(BaseModel):\n        user: User\n\n    my_user = User(hobbies=['reading'])\n    t = Transaction(user=my_user)\n    print(t)\n    #> user=User(hobbies=['reading'])\n\n    my_user.hobbies = [1]\n    t = Transaction(user=my_user)  # (2)!\n    print(t)\n    #> user=User(hobbies=[1])\n\n    my_sub_user = SubUser(hobbies=['scuba diving'], sins=['lying'])\n    t = Transaction(user=my_sub_user)\n    print(t)  # (3)!\n    #> user=User(hobbies=['scuba diving'])\n    ```\n\n    1. `revalidate_instances` is set to `'subclass-instances'`.\n    2. This is not revalidated, since `my_user` is not a subclass of `User`.\n    3. Using `'never'` we would have gotten `user=SubUser(hobbies=['scuba diving'], sins=['lying'])`.\n    \"\"\"\n\n    ser_json_timedelta: Literal['iso8601', 'float']\n    \"\"\"\n    The format of JSON serialized timedeltas. Accepts the string values of `'iso8601'` and\n    `'float'`. Defaults to `'iso8601'`.\n\n    - `'iso8601'` will serialize timedeltas to ISO 8601 durations.\n    - `'float'` will serialize timedeltas to the total number of seconds.\n    \"\"\"\n\n    ser_json_bytes: Literal['utf8', 'base64']\n    \"\"\"\n    The encoding of JSON serialized bytes. Accepts the string values of `'utf8'` and `'base64'`.\n    Defaults to `'utf8'`.\n\n    - `'utf8'` will serialize bytes to UTF-8 strings.\n    - `'base64'` will serialize bytes to URL safe base64 strings.\n    \"\"\"\n\n    ser_json_inf_nan: Literal['null', 'constants']\n    \"\"\"\n    The encoding of JSON serialized infinity and NaN float values. Accepts the string values of `'null'` and `'constants'`.\n    Defaults to `'null'`.\n\n    - `'null'` will serialize infinity and NaN values as `null`.\n    - `'constants'` will serialize infinity and NaN values as `Infinity` and `NaN`.\n    \"\"\"\n\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    \"\"\"Whether to validate default values during validation. Defaults to `False`.\"\"\"\n\n    validate_return: bool\n    \"\"\"whether to validate the return value from call validators. Defaults to `False`.\"\"\"\n\n    protected_namespaces: tuple[str, ...]\n    \"\"\"\n    A `tuple` of strings that prevent model to have field which conflict with them.\n    Defaults to `('model_', )`).\n\n    Pydantic prevents collisions between model attributes and `BaseModel`'s own methods by\n    namespacing them with the prefix `model_`.\n\n    ```py\n    import warnings\n\n    from pydantic import BaseModel\n\n    warnings.filterwarnings('error')  # Raise warnings as errors\n\n    try:\n\n        class Model(BaseModel):\n            model_prefixed_field: str\n\n    except UserWarning as e:\n        print(e)\n        '''\n        Field \"model_prefixed_field\" has conflict with protected namespace \"model_\".\n\n        You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ()`.\n        '''\n    ```\n\n    You can customize this behavior using the `protected_namespaces` setting:\n\n    ```py\n    import warnings\n\n    from pydantic import BaseModel, ConfigDict\n\n    warnings.filterwarnings('error')  # Raise warnings as errors\n\n    try:\n\n        class Model(BaseModel):\n            model_prefixed_field: str\n            also_protect_field: str\n\n            model_config = ConfigDict(\n                protected_namespaces=('protect_me_', 'also_protect_')\n            )\n\n    except UserWarning as e:\n        print(e)\n        '''\n        Field \"also_protect_field\" has conflict with protected namespace \"also_protect_\".\n\n        You may be able to resolve this warning by setting `model_config['protected_namespaces'] = ('protect_me_',)`.\n        '''\n    ```\n\n    While Pydantic will only emit a warning when an item is in a protected namespace but does not actually have a collision,\n    an error _is_ raised if there is an actual collision with an existing attribute:\n\n    ```py\n    from pydantic import BaseModel\n\n    try:\n\n        class Model(BaseModel):\n            model_validate: str\n\n    except NameError as e:\n        print(e)\n        '''\n        Field \"model_validate\" conflicts with member <bound method BaseModel.model_validate of <class 'pydantic.main.BaseModel'>> of protected namespace \"model_\".\n        '''\n    ```\n    \"\"\"\n\n    hide_input_in_errors: bool\n    \"\"\"\n    Whether to hide inputs when printing errors. Defaults to `False`.\n\n    Pydantic shows the input value and type when it raises `ValidationError` during the validation.\n\n    ```py\n    from pydantic import BaseModel, ValidationError\n\n    class Model(BaseModel):\n        a: str\n\n    try:\n        Model(a=123)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        a\n          Input should be a valid string [type=string_type, input_value=123, input_type=int]\n        '''\n    ```\n\n    You can hide the input value and type by setting the `hide_input_in_errors` config to `True`.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n    class Model(BaseModel):\n        a: str\n        model_config = ConfigDict(hide_input_in_errors=True)\n\n    try:\n        Model(a=123)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        a\n          Input should be a valid string [type=string_type]\n        '''\n    ```\n    \"\"\"\n\n    defer_build: bool\n    \"\"\"\n    Whether to defer model validator and serializer construction until the first model validation. Defaults to False.\n\n    This can be useful to avoid the overhead of building models which are only\n    used nested within other models, or when you want to manually define type namespace via\n    [`Model.model_rebuild(_types_namespace=...)`][pydantic.BaseModel.model_rebuild].\n\n    See also [`experimental_defer_build_mode`][pydantic.config.ConfigDict.experimental_defer_build_mode].\n\n    !!! note\n        `defer_build` does not work by default with FastAPI Pydantic models. By default, the validator and serializer\n        for said models is constructed immediately for FastAPI routes. You also need to define\n        [`experimental_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict.experimental_defer_build_mode] with FastAPI\n        models in order for `defer_build=True` to take effect. This additional (experimental) parameter is required for\n        the deferred building due to FastAPI relying on `TypeAdapter`s.\n    \"\"\"\n\n    experimental_defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]\n    \"\"\"\n    Controls when [`defer_build`][pydantic.config.ConfigDict.defer_build] is applicable. Defaults to `('model',)`.\n\n    Due to backwards compatibility reasons [`TypeAdapter`][pydantic.type_adapter.TypeAdapter] does not by default\n    respect `defer_build`. Meaning when `defer_build` is `True` and `experimental_defer_build_mode` is the default `('model',)`\n    then `TypeAdapter` immediately constructs its validator and serializer instead of postponing said construction until\n    the first model validation. Set this to `('model', 'type_adapter')` to make `TypeAdapter` respect the `defer_build`\n    so it postpones validator and serializer construction until the first validation or serialization.\n\n    !!! note\n        The `experimental_defer_build_mode` parameter is named with an underscore to suggest this is an experimental feature. It may\n        be removed or changed in the future in a minor release.\n    \"\"\"\n\n    plugin_settings: dict[str, object] | None\n    \"\"\"A `dict` of settings for plugins. Defaults to `None`.\n\n    See [Pydantic Plugins](../concepts/plugins.md) for details.\n    \"\"\"\n\n    schema_generator: type[_GenerateSchema] | None\n    \"\"\"\n    A custom core schema generator class to use when generating JSON schemas.\n    Useful if you want to change the way types are validated across an entire model/schema. Defaults to `None`.\n\n    The `GenerateSchema` interface is subject to change, currently only the `string_schema` method is public.\n\n    See [#6737](https://github.com/pydantic/pydantic/pull/6737) for details.\n    \"\"\"\n\n    json_schema_serialization_defaults_required: bool\n    \"\"\"\n    Whether fields with default values should be marked as required in the serialization schema. Defaults to `False`.\n\n    This ensures that the serialization schema will reflect the fact a field with a default will always be present\n    when serializing the model, even though it is not required for validation.\n\n    However, there are scenarios where this may be undesirable \u2014 in particular, if you want to share the schema\n    between validation and serialization, and don't mind fields with defaults being marked as not required during\n    serialization. See [#7209](https://github.com/pydantic/pydantic/issues/7209) for more details.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict\n\n    class Model(BaseModel):\n        a: str = 'a'\n\n        model_config = ConfigDict(json_schema_serialization_defaults_required=True)\n\n    print(Model.model_json_schema(mode='validation'))\n    '''\n    {\n        'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n        'title': 'Model',\n        'type': 'object',\n    }\n    '''\n    print(Model.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {'a': {'default': 'a', 'title': 'A', 'type': 'string'}},\n        'required': ['a'],\n        'title': 'Model',\n        'type': 'object',\n    }\n    '''\n    ```\n    \"\"\"\n\n    json_schema_mode_override: Literal['validation', 'serialization', None]\n    \"\"\"\n    If not `None`, the specified mode will be used to generate the JSON schema regardless of what `mode` was passed to\n    the function call. Defaults to `None`.\n\n    This provides a way to force the JSON schema generation to reflect a specific mode, e.g., to always use the\n    validation schema.\n\n    It can be useful when using frameworks (such as FastAPI) that may generate different schemas for validation\n    and serialization that must both be referenced from the same schema; when this happens, we automatically append\n    `-Input` to the definition reference for the validation schema and `-Output` to the definition reference for the\n    serialization schema. By specifying a `json_schema_mode_override` though, this prevents the conflict between\n    the validation and serialization schemas (since both will use the specified schema), and so prevents the suffixes\n    from being added to the definition references.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, Json\n\n    class Model(BaseModel):\n        a: Json[int]  # requires a string to validate, but will dump an int\n\n    print(Model.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {'a': {'title': 'A', 'type': 'integer'}},\n        'required': ['a'],\n        'title': 'Model',\n        'type': 'object',\n    }\n    '''\n\n    class ForceInputModel(Model):\n        # the following ensures that even with mode='serialization', we\n        # will get the schema that would be generated for validation.\n        model_config = ConfigDict(json_schema_mode_override='validation')\n\n    print(ForceInputModel.model_json_schema(mode='serialization'))\n    '''\n    {\n        'properties': {\n            'a': {\n                'contentMediaType': 'application/json',\n                'contentSchema': {'type': 'integer'},\n                'title': 'A',\n                'type': 'string',\n            }\n        },\n        'required': ['a'],\n        'title': 'ForceInputModel',\n        'type': 'object',\n    }\n    '''\n    ```\n    \"\"\"\n\n    coerce_numbers_to_str: bool\n    \"\"\"\n    If `True`, enables automatic coercion of any `Number` type to `str` in \"lax\" (non-strict) mode. Defaults to `False`.\n\n    Pydantic doesn't allow number types (`int`, `float`, `Decimal`) to be coerced as type `str` by default.\n\n    ```py\n    from decimal import Decimal\n\n    from pydantic import BaseModel, ConfigDict, ValidationError\n\n    class Model(BaseModel):\n        value: str\n\n    try:\n        print(Model(value=42))\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        value\n          Input should be a valid string [type=string_type, input_value=42, input_type=int]\n        '''\n\n    class Model(BaseModel):\n        model_config = ConfigDict(coerce_numbers_to_str=True)\n\n        value: str\n\n    repr(Model(value=42).value)\n    #> \"42\"\n    repr(Model(value=42.13).value)\n    #> \"42.13\"\n    repr(Model(value=Decimal('42.13')).value)\n    #> \"42.13\"\n    ```\n    \"\"\"\n\n    regex_engine: Literal['rust-regex', 'python-re']\n    \"\"\"\n    The regex engine to be used for pattern validation.\n    Defaults to `'rust-regex'`.\n\n    - `rust-regex` uses the [`regex`](https://docs.rs/regex) Rust crate,\n      which is non-backtracking and therefore more DDoS resistant, but does not support all regex features.\n    - `python-re` use the [`re`](https://docs.python.org/3/library/re.html) module,\n      which supports all regex features, but may be slower.\n\n    !!! note\n        If you use a compiled regex pattern, the python-re engine will be used regardless of this setting.\n        This is so that flags such as `re.IGNORECASE` are respected.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, Field, ValidationError\n\n    class Model(BaseModel):\n        model_config = ConfigDict(regex_engine='python-re')\n\n        value: str = Field(pattern=r'^abc(?=def)')\n\n    print(Model(value='abcdef').value)\n    #> abcdef\n\n    try:\n        print(Model(value='abxyzcdef'))\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        value\n          String should match pattern '^abc(?=def)' [type=string_pattern_mismatch, input_value='abxyzcdef', input_type=str]\n        '''\n    ```\n    \"\"\"\n\n    validation_error_cause: bool\n    \"\"\"\n    If `True`, Python exceptions that were part of a validation failure will be shown as an exception group as a cause. Can be useful for debugging. Defaults to `False`.\n\n    Note:\n        Python 3.10 and older don't support exception groups natively. <=3.10, backport must be installed: `pip install exceptiongroup`.\n\n    Note:\n        The structure of validation errors are likely to change in future Pydantic versions. Pydantic offers no guarantees about their structure. Should be used for visual traceback debugging only.\n    \"\"\"\n\n    use_attribute_docstrings: bool\n    '''\n    Whether docstrings of attributes (bare string literals immediately following the attribute declaration)\n    should be used for field descriptions. Defaults to `False`.\n\n    Available in Pydantic v2.7+.\n\n    ```py\n    from pydantic import BaseModel, ConfigDict, Field\n\n\n    class Model(BaseModel):\n        model_config = ConfigDict(use_attribute_docstrings=True)\n\n        x: str\n        \"\"\"\n        Example of an attribute docstring\n        \"\"\"\n\n        y: int = Field(description=\"Description in Field\")\n        \"\"\"\n        Description in Field overrides attribute docstring\n        \"\"\"\n\n\n    print(Model.model_fields[\"x\"].description)\n    # > Example of an attribute docstring\n    print(Model.model_fields[\"y\"].description)\n    # > Description in Field\n    ```\n    This requires the source code of the class to be available at runtime.\n\n    !!! warning \"Usage with `TypedDict`\"\n        Due to current limitations, attribute docstrings detection may not work as expected when using `TypedDict`\n        (in particular when multiple `TypedDict` classes have the same name in the same source file). The behavior\n        can be different depending on the Python version used.\n    '''\n\n    cache_strings: bool | Literal['all', 'keys', 'none']\n    \"\"\"\n    Whether to cache strings to avoid constructing new Python objects. Defaults to True.\n\n    Enabling this setting should significantly improve validation performance while increasing memory usage slightly.\n\n    - `True` or `'all'` (the default): cache all strings\n    - `'keys'`: cache only dictionary keys\n    - `False` or `'none'`: no caching\n\n    !!! note\n        `True` or `'all'` is required to cache strings during general validation because\n        validators don't know if they're in a key or a value.\n\n    !!! tip\n        If repeated strings are rare, it's recommended to use `'keys'` or `'none'` to reduce memory usage,\n        as the performance difference is minimal if repeated strings are rare.\n    \"\"\"\n\n\n_TypeT = TypeVar('_TypeT', bound=type)\n\n\ndef with_config(config: ConfigDict) -> Callable[[_TypeT], _TypeT]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/config/#configuration-with-dataclass-from-the-standard-library-or-typeddict\n\n    A convenience decorator to set a [Pydantic configuration](config.md) on a `TypedDict` or a `dataclass` from the standard library.\n\n    Although the configuration can be set using the `__pydantic_config__` attribute, it does not play well with type checkers,\n    especially with `TypedDict`.\n\n    !!! example \"Usage\"\n\n        ```py\n        from typing_extensions import TypedDict\n\n        from pydantic import ConfigDict, TypeAdapter, with_config\n\n        @with_config(ConfigDict(str_to_lower=True))\n        class Model(TypedDict):\n            x: str\n\n        ta = TypeAdapter(Model)\n\n        print(ta.validate_python({'x': 'ABC'}))\n        #> {'x': 'abc'}\n        ```\n    \"\"\"\n\n    def inner(class_: _TypeT, /) -> _TypeT:\n        # Ideally, we would check for `class_` to either be a `TypedDict` or a stdlib dataclass.\n        # However, the `@with_config` decorator can be applied *after* `@dataclass`. To avoid\n        # common mistakes, we at least check for `class_` to not be a Pydantic model.\n        from ._internal._utils import is_model_class\n\n        if is_model_class(class_):\n            raise PydanticUserError(\n                f'Cannot use `with_config` on {class_.__name__} as it is a Pydantic model',\n                code='with-config-on-model',\n            )\n        class_.__pydantic_config__ = config\n        return class_\n\n    return inner\n\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/type_adapter.py": "\"\"\"Type adapter specification.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport sys\nfrom contextlib import contextmanager\nfrom dataclasses import is_dataclass\nfrom functools import cached_property, wraps\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Generic,\n    Iterable,\n    Iterator,\n    Literal,\n    Set,\n    TypeVar,\n    Union,\n    cast,\n    final,\n    overload,\n)\n\nfrom pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator, Some\nfrom typing_extensions import Concatenate, ParamSpec, is_typeddict\n\nfrom pydantic.errors import PydanticUserError\nfrom pydantic.main import BaseModel\n\nfrom ._internal import _config, _generate_schema, _mock_val_ser, _typing_extra, _utils\nfrom .config import ConfigDict\nfrom .json_schema import (\n    DEFAULT_REF_TEMPLATE,\n    GenerateJsonSchema,\n    JsonSchemaKeyT,\n    JsonSchemaMode,\n    JsonSchemaValue,\n)\nfrom .plugin._schema_validator import create_schema_validator\n\nT = TypeVar('T')\nR = TypeVar('R')\nP = ParamSpec('P')\nTypeAdapterT = TypeVar('TypeAdapterT', bound='TypeAdapter')\n\n\nif TYPE_CHECKING:\n    # should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can't cope\n    IncEx = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any]]\n\n\ndef _get_schema(type_: Any, config_wrapper: _config.ConfigWrapper, parent_depth: int) -> CoreSchema:\n    \"\"\"`BaseModel` uses its own `__module__` to find out where it was defined\n    and then looks for symbols to resolve forward references in those globals.\n    On the other hand this function can be called with arbitrary objects,\n    including type aliases, where `__module__` (always `typing.py`) is not useful.\n    So instead we look at the globals in our parent stack frame.\n\n    This works for the case where this function is called in a module that\n    has the target of forward references in its scope, but\n    does not always work for more complex cases.\n\n    For example, take the following:\n\n    a.py\n    ```python\n    from typing import Dict, List\n\n    IntList = List[int]\n    OuterDict = Dict[str, 'IntList']\n    ```\n\n    b.py\n    ```python test=\"skip\"\n    from a import OuterDict\n\n    from pydantic import TypeAdapter\n\n    IntList = int  # replaces the symbol the forward reference is looking for\n    v = TypeAdapter(OuterDict)\n    v({'x': 1})  # should fail but doesn't\n    ```\n\n    If `OuterDict` were a `BaseModel`, this would work because it would resolve\n    the forward reference within the `a.py` namespace.\n    But `TypeAdapter(OuterDict)` can't determine what module `OuterDict` came from.\n\n    In other words, the assumption that _all_ forward references exist in the\n    module we are being called from is not technically always true.\n    Although most of the time it is and it works fine for recursive models and such,\n    `BaseModel`'s behavior isn't perfect either and _can_ break in similar ways,\n    so there is no right or wrong between the two.\n\n    But at the very least this behavior is _subtly_ different from `BaseModel`'s.\n    \"\"\"\n    local_ns = _typing_extra.parent_frame_namespace(parent_depth=parent_depth)\n    global_ns = sys._getframe(max(parent_depth - 1, 1)).f_globals.copy()\n    global_ns.update(local_ns or {})\n    gen = _generate_schema.GenerateSchema(config_wrapper, types_namespace=global_ns, typevars_map={})\n    schema = gen.generate_schema(type_)\n    schema = gen.clean_schema(schema)\n    return schema\n\n\ndef _getattr_no_parents(obj: Any, attribute: str) -> Any:\n    \"\"\"Returns the attribute value without attempting to look up attributes from parent types.\"\"\"\n    if hasattr(obj, '__dict__'):\n        try:\n            return obj.__dict__[attribute]\n        except KeyError:\n            pass\n\n    slots = getattr(obj, '__slots__', None)\n    if slots is not None and attribute in slots:\n        return getattr(obj, attribute)\n    else:\n        raise AttributeError(attribute)\n\n\ndef _type_has_config(type_: Any) -> bool:\n    \"\"\"Returns whether the type has config.\"\"\"\n    type_ = _typing_extra.annotated_type(type_) or type_\n    try:\n        return issubclass(type_, BaseModel) or is_dataclass(type_) or is_typeddict(type_)\n    except TypeError:\n        # type is not a class\n        return False\n\n\n# This is keeping track of the frame depth for the TypeAdapter functions. This is required for _parent_depth used for\n# ForwardRef resolution. We may enter the TypeAdapter schema building via different TypeAdapter functions. Hence, we\n# need to keep track of the frame depth relative to the originally provided _parent_depth.\ndef _frame_depth(\n    depth: int,\n) -> Callable[[Callable[Concatenate[TypeAdapterT, P], R]], Callable[Concatenate[TypeAdapterT, P], R]]:\n    def wrapper(func: Callable[Concatenate[TypeAdapterT, P], R]) -> Callable[Concatenate[TypeAdapterT, P], R]:\n        @wraps(func)\n        def wrapped(self: TypeAdapterT, *args: P.args, **kwargs: P.kwargs) -> R:\n            with self._with_frame_depth(depth + 1):  # depth + 1 for the wrapper function\n                return func(self, *args, **kwargs)\n\n        return wrapped\n\n    return wrapper\n\n\n@final\nclass TypeAdapter(Generic[T]):\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/type_adapter/\n\n    Type adapters provide a flexible way to perform validation and serialization based on a Python type.\n\n    A `TypeAdapter` instance exposes some of the functionality from `BaseModel` instance methods\n    for types that do not have such methods (such as dataclasses, primitive types, and more).\n\n    **Note:** `TypeAdapter` instances are not types, and cannot be used as type annotations for fields.\n\n    **Note:** By default, `TypeAdapter` does not respect the\n    [`defer_build=True`][pydantic.config.ConfigDict.defer_build] setting in the\n    [`model_config`][pydantic.BaseModel.model_config] or in the `TypeAdapter` constructor `config`. You need to also\n    explicitly set [`experimental_defer_build_mode=('model', 'type_adapter')`][pydantic.config.ConfigDict.experimental_defer_build_mode] of the\n    config to defer the model validator and serializer construction. Thus, this feature is opt-in to ensure backwards\n    compatibility.\n\n    Attributes:\n        core_schema: The core schema for the type.\n        validator (SchemaValidator): The schema validator for the type.\n        serializer: The schema serializer for the type.\n    \"\"\"\n\n    @overload\n    def __init__(\n        self,\n        type: type[T],\n        *,\n        config: ConfigDict | None = ...,\n        _parent_depth: int = ...,\n        module: str | None = ...,\n    ) -> None: ...\n\n    # This second overload is for unsupported special forms (such as Annotated, Union, etc.)\n    # Currently there is no way to type this correctly\n    # See https://github.com/python/typing/pull/1618\n    @overload\n    def __init__(\n        self,\n        type: Any,\n        *,\n        config: ConfigDict | None = ...,\n        _parent_depth: int = ...,\n        module: str | None = ...,\n    ) -> None: ...\n\n    def __init__(\n        self,\n        type: Any,\n        *,\n        config: ConfigDict | None = None,\n        _parent_depth: int = 2,\n        module: str | None = None,\n    ) -> None:\n        \"\"\"Initializes the TypeAdapter object.\n\n        Args:\n            type: The type associated with the `TypeAdapter`.\n            config: Configuration for the `TypeAdapter`, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n            _parent_depth: depth at which to search the parent namespace to construct the local namespace.\n            module: The module that passes to plugin if provided.\n\n        !!! note\n            You cannot use the `config` argument when instantiating a `TypeAdapter` if the type you're using has its own\n            config that cannot be overridden (ex: `BaseModel`, `TypedDict`, and `dataclass`). A\n            [`type-adapter-config-unused`](../errors/usage_errors.md#type-adapter-config-unused) error will be raised in this case.\n\n        !!! note\n            The `_parent_depth` argument is named with an underscore to suggest its private nature and discourage use.\n            It may be deprecated in a minor version, so we only recommend using it if you're\n            comfortable with potential change in behavior / support.\n\n        ??? tip \"Compatibility with `mypy`\"\n            Depending on the type used, `mypy` might raise an error when instantiating a `TypeAdapter`. As a workaround, you can explicitly\n            annotate your variable:\n\n            ```py\n            from typing import Union\n\n            from pydantic import TypeAdapter\n\n            ta: TypeAdapter[Union[str, int]] = TypeAdapter(Union[str, int])  # type: ignore[arg-type]\n            ```\n\n        Returns:\n            A type adapter configured for the specified `type`.\n        \"\"\"\n        if _type_has_config(type) and config is not None:\n            raise PydanticUserError(\n                'Cannot use `config` when the type is a BaseModel, dataclass or TypedDict.'\n                ' These types can have their own config and setting the config via the `config`'\n                ' parameter to TypeAdapter will not override it, thus the `config` you passed to'\n                ' TypeAdapter becomes meaningless, which is probably not what you want.',\n                code='type-adapter-config-unused',\n            )\n\n        self._type = type\n        self._config = config\n        self._parent_depth = _parent_depth\n        if module is None:\n            f = sys._getframe(1)\n            self._module_name = cast(str, f.f_globals.get('__name__', ''))\n        else:\n            self._module_name = module\n\n        self._core_schema: CoreSchema | None = None\n        self._validator: SchemaValidator | None = None\n        self._serializer: SchemaSerializer | None = None\n\n        if not self._defer_build():\n            # Immediately initialize the core schema, validator and serializer\n            with self._with_frame_depth(1):  # +1 frame depth for this __init__\n                # Model itself may be using deferred building. For backward compatibility we don't rebuild model mocks\n                # here as part of __init__ even though TypeAdapter itself is not using deferred building.\n                self._init_core_attrs(rebuild_mocks=False)\n\n    @contextmanager\n    def _with_frame_depth(self, depth: int) -> Iterator[None]:\n        self._parent_depth += depth\n        try:\n            yield\n        finally:\n            self._parent_depth -= depth\n\n    @_frame_depth(1)\n    def _init_core_attrs(self, rebuild_mocks: bool) -> None:\n        try:\n            self._core_schema = _getattr_no_parents(self._type, '__pydantic_core_schema__')\n            self._validator = _getattr_no_parents(self._type, '__pydantic_validator__')\n            self._serializer = _getattr_no_parents(self._type, '__pydantic_serializer__')\n        except AttributeError:\n            config_wrapper = _config.ConfigWrapper(self._config)\n            core_config = config_wrapper.core_config(None)\n\n            self._core_schema = _get_schema(self._type, config_wrapper, parent_depth=self._parent_depth)\n            self._validator = create_schema_validator(\n                schema=self._core_schema,\n                schema_type=self._type,\n                schema_type_module=self._module_name,\n                schema_type_name=str(self._type),\n                schema_kind='TypeAdapter',\n                config=core_config,\n                plugin_settings=config_wrapper.plugin_settings,\n            )\n            self._serializer = SchemaSerializer(self._core_schema, core_config)\n\n        if rebuild_mocks and isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n            self._core_schema.rebuild()\n            self._init_core_attrs(rebuild_mocks=False)\n            assert not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n            assert not isinstance(self._validator, _mock_val_ser.MockValSer)\n            assert not isinstance(self._serializer, _mock_val_ser.MockValSer)\n\n    @cached_property\n    @_frame_depth(2)  # +2 for @cached_property and core_schema(self)\n    def core_schema(self) -> CoreSchema:\n        \"\"\"The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\"\"\"\n        if self._core_schema is None or isinstance(self._core_schema, _mock_val_ser.MockCoreSchema):\n            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockCoreSchema from public function\n        assert self._core_schema is not None and not isinstance(self._core_schema, _mock_val_ser.MockCoreSchema)\n        return self._core_schema\n\n    @cached_property\n    @_frame_depth(2)  # +2 for @cached_property + validator(self)\n    def validator(self) -> SchemaValidator:\n        \"\"\"The pydantic-core SchemaValidator used to validate instances of the model.\"\"\"\n        if not isinstance(self._validator, SchemaValidator):\n            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n        assert isinstance(self._validator, SchemaValidator)\n        return self._validator\n\n    @cached_property\n    @_frame_depth(2)  # +2 for @cached_property + serializer(self)\n    def serializer(self) -> SchemaSerializer:\n        \"\"\"The pydantic-core SchemaSerializer used to dump instances of the model.\"\"\"\n        if not isinstance(self._serializer, SchemaSerializer):\n            self._init_core_attrs(rebuild_mocks=True)  # Do not expose MockValSer from public function\n        assert isinstance(self._serializer, SchemaSerializer)\n        return self._serializer\n\n    def _defer_build(self) -> bool:\n        config = self._config if self._config is not None else self._model_config()\n        return self._is_defer_build_config(config) if config is not None else False\n\n    def _model_config(self) -> ConfigDict | None:\n        type_: Any = _typing_extra.annotated_type(self._type) or self._type  # Eg FastAPI heavily uses Annotated\n        if _utils.lenient_issubclass(type_, BaseModel):\n            return type_.model_config\n        return getattr(type_, '__pydantic_config__', None)\n\n    @staticmethod\n    def _is_defer_build_config(config: ConfigDict) -> bool:\n        # TODO reevaluate this logic when we have a better understanding of how defer_build should work with TypeAdapter\n        # Should we drop the special experimental_defer_build_mode check?\n        return config.get('defer_build', False) is True and 'type_adapter' in config.get(\n            'experimental_defer_build_mode', tuple()\n        )\n\n    @_frame_depth(1)\n    def validate_python(\n        self,\n        object: Any,\n        /,\n        *,\n        strict: bool | None = None,\n        from_attributes: bool | None = None,\n        context: dict[str, Any] | None = None,\n    ) -> T:\n        \"\"\"Validate a Python object against the model.\n\n        Args:\n            object: The Python object to validate against the model.\n            strict: Whether to strictly check types.\n            from_attributes: Whether to extract data from object attributes.\n            context: Additional context to pass to the validator.\n\n        !!! note\n            When using `TypeAdapter` with a Pydantic `dataclass`, the use of the `from_attributes`\n            argument is not supported.\n\n        Returns:\n            The validated object.\n        \"\"\"\n        return self.validator.validate_python(object, strict=strict, from_attributes=from_attributes, context=context)\n\n    @_frame_depth(1)\n    def validate_json(\n        self, data: str | bytes, /, *, strict: bool | None = None, context: dict[str, Any] | None = None\n    ) -> T:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-parsing\n\n        Validate a JSON string or bytes against the model.\n\n        Args:\n            data: The JSON data to validate against the model.\n            strict: Whether to strictly check types.\n            context: Additional context to use during validation.\n\n        Returns:\n            The validated object.\n        \"\"\"\n        return self.validator.validate_json(data, strict=strict, context=context)\n\n    @_frame_depth(1)\n    def validate_strings(self, obj: Any, /, *, strict: bool | None = None, context: dict[str, Any] | None = None) -> T:\n        \"\"\"Validate object contains string data against the model.\n\n        Args:\n            obj: The object contains string data to validate.\n            strict: Whether to strictly check types.\n            context: Additional context to use during validation.\n\n        Returns:\n            The validated object.\n        \"\"\"\n        return self.validator.validate_strings(obj, strict=strict, context=context)\n\n    @_frame_depth(1)\n    def get_default_value(self, *, strict: bool | None = None, context: dict[str, Any] | None = None) -> Some[T] | None:\n        \"\"\"Get the default value for the wrapped type.\n\n        Args:\n            strict: Whether to strictly check types.\n            context: Additional context to pass to the validator.\n\n        Returns:\n            The default value wrapped in a `Some` if there is one or None if not.\n        \"\"\"\n        return self.validator.get_default_value(strict=strict, context=context)\n\n    @_frame_depth(1)\n    def dump_python(\n        self,\n        instance: T,\n        /,\n        *,\n        mode: Literal['json', 'python'] = 'python',\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        serialize_as_any: bool = False,\n        context: dict[str, Any] | None = None,\n    ) -> Any:\n        \"\"\"Dump an instance of the adapted type to a Python object.\n\n        Args:\n            instance: The Python object to serialize.\n            mode: The output format.\n            include: Fields to include in the output.\n            exclude: Fields to exclude from the output.\n            by_alias: Whether to use alias names for field names.\n            exclude_unset: Whether to exclude unset fields.\n            exclude_defaults: Whether to exclude fields with default values.\n            exclude_none: Whether to exclude fields with None values.\n            round_trip: Whether to output the serialized data in a way that is compatible with deserialization.\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n            context: Additional context to pass to the serializer.\n\n        Returns:\n            The serialized object.\n        \"\"\"\n        return self.serializer.to_python(\n            instance,\n            mode=mode,\n            by_alias=by_alias,\n            include=include,\n            exclude=exclude,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n            context=context,\n        )\n\n    @_frame_depth(1)\n    def dump_json(\n        self,\n        instance: T,\n        /,\n        *,\n        indent: int | None = None,\n        include: IncEx | None = None,\n        exclude: IncEx | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        serialize_as_any: bool = False,\n        context: dict[str, Any] | None = None,\n    ) -> bytes:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-serialization\n\n        Serialize an instance of the adapted type to JSON.\n\n        Args:\n            instance: The instance to be serialized.\n            indent: Number of spaces for JSON indentation.\n            include: Fields to include.\n            exclude: Fields to exclude.\n            by_alias: Whether to use alias names for field names.\n            exclude_unset: Whether to exclude unset fields.\n            exclude_defaults: Whether to exclude fields with default values.\n            exclude_none: Whether to exclude fields with a value of `None`.\n            round_trip: Whether to serialize and deserialize the instance to ensure round-tripping.\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n            context: Additional context to pass to the serializer.\n\n        Returns:\n            The JSON representation of the given instance as bytes.\n        \"\"\"\n        return self.serializer.to_json(\n            instance,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n            context=context,\n        )\n\n    @_frame_depth(1)\n    def json_schema(\n        self,\n        *,\n        by_alias: bool = True,\n        ref_template: str = DEFAULT_REF_TEMPLATE,\n        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n        mode: JsonSchemaMode = 'validation',\n    ) -> dict[str, Any]:\n        \"\"\"Generate a JSON schema for the adapted type.\n\n        Args:\n            by_alias: Whether to use alias names for field names.\n            ref_template: The format string used for generating $ref strings.\n            schema_generator: The generator class used for creating the schema.\n            mode: The mode to use for schema generation.\n\n        Returns:\n            The JSON schema for the model as a dictionary.\n        \"\"\"\n        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n        return schema_generator_instance.generate(self.core_schema, mode=mode)\n\n    @staticmethod\n    def json_schemas(\n        inputs: Iterable[tuple[JsonSchemaKeyT, JsonSchemaMode, TypeAdapter[Any]]],\n        /,\n        *,\n        by_alias: bool = True,\n        title: str | None = None,\n        description: str | None = None,\n        ref_template: str = DEFAULT_REF_TEMPLATE,\n        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    ) -> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:\n        \"\"\"Generate a JSON schema including definitions from multiple type adapters.\n\n        Args:\n            inputs: Inputs to schema generation. The first two items will form the keys of the (first)\n                output mapping; the type adapters will provide the core schemas that get converted into\n                definitions in the output JSON schema.\n            by_alias: Whether to use alias names.\n            title: The title for the schema.\n            description: The description for the schema.\n            ref_template: The format string used for generating $ref strings.\n            schema_generator: The generator class used for creating the schema.\n\n        Returns:\n            A tuple where:\n\n                - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                    whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a JSON schema containing all definitions referenced in the first returned\n                    element, along with the optional title and description keys.\n\n        \"\"\"\n        schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n\n        inputs_ = []\n        for key, mode, adapter in inputs:\n            with adapter._with_frame_depth(1):  # +1 for json_schemas staticmethod\n                inputs_.append((key, mode, adapter.core_schema))\n\n        json_schemas_map, definitions = schema_generator_instance.generate_definitions(inputs_)\n\n        json_schema: dict[str, Any] = {}\n        if definitions:\n            json_schema['$defs'] = definitions\n        if title:\n            json_schema['title'] = title\n        if description:\n            json_schema['description'] = description\n\n        return json_schemas_map, json_schema\n", "pydantic/env_settings.py": "\"\"\"The `env_settings` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/typing.py": "\"\"\"`typing` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/parse.py": "\"\"\"The `parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/schema.py": "\"\"\"The `schema` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/annotated_handlers.py": "\"\"\"Type annotations to use with `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Union\n\nfrom pydantic_core import core_schema\n\nif TYPE_CHECKING:\n    from .json_schema import JsonSchemaMode, JsonSchemaValue\n\n    CoreSchemaOrField = Union[\n        core_schema.CoreSchema,\n        core_schema.ModelField,\n        core_schema.DataclassField,\n        core_schema.TypedDictField,\n        core_schema.ComputedField,\n    ]\n\n__all__ = 'GetJsonSchemaHandler', 'GetCoreSchemaHandler'\n\n\nclass GetJsonSchemaHandler:\n    \"\"\"Handler to call into the next JSON schema generation function.\n\n    Attributes:\n        mode: Json schema mode, can be `validation` or `serialization`.\n    \"\"\"\n\n    mode: JsonSchemaMode\n\n    def __call__(self, core_schema: CoreSchemaOrField, /) -> JsonSchemaValue:\n        \"\"\"Call the inner handler and get the JsonSchemaValue it returns.\n        This will call the next JSON schema modifying function up until it calls\n        into `pydantic.json_schema.GenerateJsonSchema`, which will raise a\n        `pydantic.errors.PydanticInvalidForJsonSchema` error if it cannot generate\n        a JSON schema.\n\n        Args:\n            core_schema: A `pydantic_core.core_schema.CoreSchema`.\n\n        Returns:\n            JsonSchemaValue: The JSON schema generated by the inner JSON schema modify\n            functions.\n        \"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue, /) -> JsonSchemaValue:\n        \"\"\"Get the real schema for a `{\"$ref\": ...}` schema.\n        If the schema given is not a `$ref` schema, it will be returned as is.\n        This means you don't have to check before calling this function.\n\n        Args:\n            maybe_ref_json_schema: A JsonSchemaValue which may be a `$ref` schema.\n\n        Raises:\n            LookupError: If the ref is not found.\n\n        Returns:\n            JsonSchemaValue: A JsonSchemaValue that has no `$ref`.\n        \"\"\"\n        raise NotImplementedError\n\n\nclass GetCoreSchemaHandler:\n    \"\"\"Handler to call into the next CoreSchema schema generation function.\"\"\"\n\n    def __call__(self, source_type: Any, /) -> core_schema.CoreSchema:\n        \"\"\"Call the inner handler and get the CoreSchema it returns.\n        This will call the next CoreSchema modifying function up until it calls\n        into Pydantic's internal schema generation machinery, which will raise a\n        `pydantic.errors.PydanticSchemaGenerationError` error if it cannot generate\n        a CoreSchema for the given source type.\n\n        Args:\n            source_type: The input type.\n\n        Returns:\n            CoreSchema: The `pydantic-core` CoreSchema generated.\n        \"\"\"\n        raise NotImplementedError\n\n    def generate_schema(self, source_type: Any, /) -> core_schema.CoreSchema:\n        \"\"\"Generate a schema unrelated to the current context.\n        Use this function if e.g. you are handling schema generation for a sequence\n        and want to generate a schema for its items.\n        Otherwise, you may end up doing something like applying a `min_length` constraint\n        that was intended for the sequence itself to its items!\n\n        Args:\n            source_type: The input type.\n\n        Returns:\n            CoreSchema: The `pydantic-core` CoreSchema generated.\n        \"\"\"\n        raise NotImplementedError\n\n    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema, /) -> core_schema.CoreSchema:\n        \"\"\"Get the real schema for a `definition-ref` schema.\n        If the schema given is not a `definition-ref` schema, it will be returned as is.\n        This means you don't have to check before calling this function.\n\n        Args:\n            maybe_ref_schema: A `CoreSchema`, `ref`-based or not.\n\n        Raises:\n            LookupError: If the `ref` is not found.\n\n        Returns:\n            A concrete `CoreSchema`.\n        \"\"\"\n        raise NotImplementedError\n\n    @property\n    def field_name(self) -> str | None:\n        \"\"\"Get the name of the closest field to this validator.\"\"\"\n        raise NotImplementedError\n\n    def _get_types_namespace(self) -> dict[str, Any] | None:\n        \"\"\"Internal method used during type resolution for serializer annotations.\"\"\"\n        raise NotImplementedError\n", "pydantic/utils.py": "\"\"\"The `utils` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/_migration.py": "import sys\nfrom typing import Any, Callable, Dict\n\nfrom .version import version_short\n\nMOVED_IN_V2 = {\n    'pydantic.utils:version_info': 'pydantic.version:version_info',\n    'pydantic.error_wrappers:ValidationError': 'pydantic:ValidationError',\n    'pydantic.utils:to_camel': 'pydantic.alias_generators:to_pascal',\n    'pydantic.utils:to_lower_camel': 'pydantic.alias_generators:to_camel',\n    'pydantic:PyObject': 'pydantic.types:ImportString',\n    'pydantic.types:PyObject': 'pydantic.types:ImportString',\n    'pydantic.generics:GenericModel': 'pydantic.BaseModel',\n}\n\nDEPRECATED_MOVED_IN_V2 = {\n    'pydantic.tools:schema_of': 'pydantic.deprecated.tools:schema_of',\n    'pydantic.tools:parse_obj_as': 'pydantic.deprecated.tools:parse_obj_as',\n    'pydantic.tools:schema_json_of': 'pydantic.deprecated.tools:schema_json_of',\n    'pydantic.json:pydantic_encoder': 'pydantic.deprecated.json:pydantic_encoder',\n    'pydantic:validate_arguments': 'pydantic.deprecated.decorator:validate_arguments',\n    'pydantic.json:custom_pydantic_encoder': 'pydantic.deprecated.json:custom_pydantic_encoder',\n    'pydantic.json:timedelta_isoformat': 'pydantic.deprecated.json:timedelta_isoformat',\n    'pydantic.decorator:validate_arguments': 'pydantic.deprecated.decorator:validate_arguments',\n    'pydantic.class_validators:validator': 'pydantic.deprecated.class_validators:validator',\n    'pydantic.class_validators:root_validator': 'pydantic.deprecated.class_validators:root_validator',\n    'pydantic.config:BaseConfig': 'pydantic.deprecated.config:BaseConfig',\n    'pydantic.config:Extra': 'pydantic.deprecated.config:Extra',\n}\n\nREDIRECT_TO_V1 = {\n    f'pydantic.utils:{obj}': f'pydantic.v1.utils:{obj}'\n    for obj in (\n        'deep_update',\n        'GetterDict',\n        'lenient_issubclass',\n        'lenient_isinstance',\n        'is_valid_field',\n        'update_not_none',\n        'import_string',\n        'Representation',\n        'ROOT_KEY',\n        'smart_deepcopy',\n        'sequence_like',\n    )\n}\n\n\nREMOVED_IN_V2 = {\n    'pydantic:ConstrainedBytes',\n    'pydantic:ConstrainedDate',\n    'pydantic:ConstrainedDecimal',\n    'pydantic:ConstrainedFloat',\n    'pydantic:ConstrainedFrozenSet',\n    'pydantic:ConstrainedInt',\n    'pydantic:ConstrainedList',\n    'pydantic:ConstrainedSet',\n    'pydantic:ConstrainedStr',\n    'pydantic:JsonWrapper',\n    'pydantic:NoneBytes',\n    'pydantic:NoneStr',\n    'pydantic:NoneStrBytes',\n    'pydantic:Protocol',\n    'pydantic:Required',\n    'pydantic:StrBytes',\n    'pydantic:compiled',\n    'pydantic.config:get_config',\n    'pydantic.config:inherit_config',\n    'pydantic.config:prepare_config',\n    'pydantic:create_model_from_namedtuple',\n    'pydantic:create_model_from_typeddict',\n    'pydantic.dataclasses:create_pydantic_model_from_dataclass',\n    'pydantic.dataclasses:make_dataclass_validator',\n    'pydantic.dataclasses:set_validation',\n    'pydantic.datetime_parse:parse_date',\n    'pydantic.datetime_parse:parse_time',\n    'pydantic.datetime_parse:parse_datetime',\n    'pydantic.datetime_parse:parse_duration',\n    'pydantic.error_wrappers:ErrorWrapper',\n    'pydantic.errors:AnyStrMaxLengthError',\n    'pydantic.errors:AnyStrMinLengthError',\n    'pydantic.errors:ArbitraryTypeError',\n    'pydantic.errors:BoolError',\n    'pydantic.errors:BytesError',\n    'pydantic.errors:CallableError',\n    'pydantic.errors:ClassError',\n    'pydantic.errors:ColorError',\n    'pydantic.errors:ConfigError',\n    'pydantic.errors:DataclassTypeError',\n    'pydantic.errors:DateError',\n    'pydantic.errors:DateNotInTheFutureError',\n    'pydantic.errors:DateNotInThePastError',\n    'pydantic.errors:DateTimeError',\n    'pydantic.errors:DecimalError',\n    'pydantic.errors:DecimalIsNotFiniteError',\n    'pydantic.errors:DecimalMaxDigitsError',\n    'pydantic.errors:DecimalMaxPlacesError',\n    'pydantic.errors:DecimalWholeDigitsError',\n    'pydantic.errors:DictError',\n    'pydantic.errors:DurationError',\n    'pydantic.errors:EmailError',\n    'pydantic.errors:EnumError',\n    'pydantic.errors:EnumMemberError',\n    'pydantic.errors:ExtraError',\n    'pydantic.errors:FloatError',\n    'pydantic.errors:FrozenSetError',\n    'pydantic.errors:FrozenSetMaxLengthError',\n    'pydantic.errors:FrozenSetMinLengthError',\n    'pydantic.errors:HashableError',\n    'pydantic.errors:IPv4AddressError',\n    'pydantic.errors:IPv4InterfaceError',\n    'pydantic.errors:IPv4NetworkError',\n    'pydantic.errors:IPv6AddressError',\n    'pydantic.errors:IPv6InterfaceError',\n    'pydantic.errors:IPv6NetworkError',\n    'pydantic.errors:IPvAnyAddressError',\n    'pydantic.errors:IPvAnyInterfaceError',\n    'pydantic.errors:IPvAnyNetworkError',\n    'pydantic.errors:IntEnumError',\n    'pydantic.errors:IntegerError',\n    'pydantic.errors:InvalidByteSize',\n    'pydantic.errors:InvalidByteSizeUnit',\n    'pydantic.errors:InvalidDiscriminator',\n    'pydantic.errors:InvalidLengthForBrand',\n    'pydantic.errors:JsonError',\n    'pydantic.errors:JsonTypeError',\n    'pydantic.errors:ListError',\n    'pydantic.errors:ListMaxLengthError',\n    'pydantic.errors:ListMinLengthError',\n    'pydantic.errors:ListUniqueItemsError',\n    'pydantic.errors:LuhnValidationError',\n    'pydantic.errors:MissingDiscriminator',\n    'pydantic.errors:MissingError',\n    'pydantic.errors:NoneIsAllowedError',\n    'pydantic.errors:NoneIsNotAllowedError',\n    'pydantic.errors:NotDigitError',\n    'pydantic.errors:NotNoneError',\n    'pydantic.errors:NumberNotGeError',\n    'pydantic.errors:NumberNotGtError',\n    'pydantic.errors:NumberNotLeError',\n    'pydantic.errors:NumberNotLtError',\n    'pydantic.errors:NumberNotMultipleError',\n    'pydantic.errors:PathError',\n    'pydantic.errors:PathNotADirectoryError',\n    'pydantic.errors:PathNotAFileError',\n    'pydantic.errors:PathNotExistsError',\n    'pydantic.errors:PatternError',\n    'pydantic.errors:PyObjectError',\n    'pydantic.errors:PydanticTypeError',\n    'pydantic.errors:PydanticValueError',\n    'pydantic.errors:SequenceError',\n    'pydantic.errors:SetError',\n    'pydantic.errors:SetMaxLengthError',\n    'pydantic.errors:SetMinLengthError',\n    'pydantic.errors:StrError',\n    'pydantic.errors:StrRegexError',\n    'pydantic.errors:StrictBoolError',\n    'pydantic.errors:SubclassError',\n    'pydantic.errors:TimeError',\n    'pydantic.errors:TupleError',\n    'pydantic.errors:TupleLengthError',\n    'pydantic.errors:UUIDError',\n    'pydantic.errors:UUIDVersionError',\n    'pydantic.errors:UrlError',\n    'pydantic.errors:UrlExtraError',\n    'pydantic.errors:UrlHostError',\n    'pydantic.errors:UrlHostTldError',\n    'pydantic.errors:UrlPortError',\n    'pydantic.errors:UrlSchemeError',\n    'pydantic.errors:UrlSchemePermittedError',\n    'pydantic.errors:UrlUserInfoError',\n    'pydantic.errors:WrongConstantError',\n    'pydantic.main:validate_model',\n    'pydantic.networks:stricturl',\n    'pydantic:parse_file_as',\n    'pydantic:parse_raw_as',\n    'pydantic:stricturl',\n    'pydantic.tools:parse_file_as',\n    'pydantic.tools:parse_raw_as',\n    'pydantic.types:ConstrainedBytes',\n    'pydantic.types:ConstrainedDate',\n    'pydantic.types:ConstrainedDecimal',\n    'pydantic.types:ConstrainedFloat',\n    'pydantic.types:ConstrainedFrozenSet',\n    'pydantic.types:ConstrainedInt',\n    'pydantic.types:ConstrainedList',\n    'pydantic.types:ConstrainedSet',\n    'pydantic.types:ConstrainedStr',\n    'pydantic.types:JsonWrapper',\n    'pydantic.types:NoneBytes',\n    'pydantic.types:NoneStr',\n    'pydantic.types:NoneStrBytes',\n    'pydantic.types:StrBytes',\n    'pydantic.typing:evaluate_forwardref',\n    'pydantic.typing:AbstractSetIntStr',\n    'pydantic.typing:AnyCallable',\n    'pydantic.typing:AnyClassMethod',\n    'pydantic.typing:CallableGenerator',\n    'pydantic.typing:DictAny',\n    'pydantic.typing:DictIntStrAny',\n    'pydantic.typing:DictStrAny',\n    'pydantic.typing:IntStr',\n    'pydantic.typing:ListStr',\n    'pydantic.typing:MappingIntStrAny',\n    'pydantic.typing:NoArgAnyCallable',\n    'pydantic.typing:NoneType',\n    'pydantic.typing:ReprArgs',\n    'pydantic.typing:SetStr',\n    'pydantic.typing:StrPath',\n    'pydantic.typing:TupleGenerator',\n    'pydantic.typing:WithArgsTypes',\n    'pydantic.typing:all_literal_values',\n    'pydantic.typing:display_as_type',\n    'pydantic.typing:get_all_type_hints',\n    'pydantic.typing:get_args',\n    'pydantic.typing:get_origin',\n    'pydantic.typing:get_sub_types',\n    'pydantic.typing:is_callable_type',\n    'pydantic.typing:is_classvar',\n    'pydantic.typing:is_finalvar',\n    'pydantic.typing:is_literal_type',\n    'pydantic.typing:is_namedtuple',\n    'pydantic.typing:is_new_type',\n    'pydantic.typing:is_none_type',\n    'pydantic.typing:is_typeddict',\n    'pydantic.typing:is_typeddict_special',\n    'pydantic.typing:is_union',\n    'pydantic.typing:new_type_supertype',\n    'pydantic.typing:resolve_annotations',\n    'pydantic.typing:typing_base',\n    'pydantic.typing:update_field_forward_refs',\n    'pydantic.typing:update_model_forward_refs',\n    'pydantic.utils:ClassAttribute',\n    'pydantic.utils:DUNDER_ATTRIBUTES',\n    'pydantic.utils:PyObjectStr',\n    'pydantic.utils:ValueItems',\n    'pydantic.utils:almost_equal_floats',\n    'pydantic.utils:get_discriminator_alias_and_values',\n    'pydantic.utils:get_model',\n    'pydantic.utils:get_unique_discriminator_alias',\n    'pydantic.utils:in_ipython',\n    'pydantic.utils:is_valid_identifier',\n    'pydantic.utils:path_type',\n    'pydantic.utils:validate_field_name',\n    'pydantic:validate_model',\n}\n\n\ndef getattr_migration(module: str) -> Callable[[str], Any]:\n    \"\"\"Implement PEP 562 for objects that were either moved or removed on the migration\n    to V2.\n\n    Args:\n        module: The module name.\n\n    Returns:\n        A callable that will raise an error if the object is not found.\n    \"\"\"\n    # This avoids circular import with errors.py.\n    from .errors import PydanticImportError\n\n    def wrapper(name: str) -> object:\n        \"\"\"Raise an error if the object is not found, or warn if it was moved.\n\n        In case it was moved, it still returns the object.\n\n        Args:\n            name: The object name.\n\n        Returns:\n            The object.\n        \"\"\"\n        if name == '__path__':\n            raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n        import warnings\n\n        from ._internal._validators import import_string\n\n        import_path = f'{module}:{name}'\n        if import_path in MOVED_IN_V2.keys():\n            new_location = MOVED_IN_V2[import_path]\n            warnings.warn(f'`{import_path}` has been moved to `{new_location}`.')\n            return import_string(MOVED_IN_V2[import_path])\n        if import_path in DEPRECATED_MOVED_IN_V2:\n            # skip the warning here because a deprecation warning will be raised elsewhere\n            return import_string(DEPRECATED_MOVED_IN_V2[import_path])\n        if import_path in REDIRECT_TO_V1:\n            new_location = REDIRECT_TO_V1[import_path]\n            warnings.warn(\n                f'`{import_path}` has been removed. We are importing from `{new_location}` instead.'\n                'See the migration guide for more details: https://docs.pydantic.dev/latest/migration/'\n            )\n            return import_string(REDIRECT_TO_V1[import_path])\n        if import_path == 'pydantic:BaseSettings':\n            raise PydanticImportError(\n                '`BaseSettings` has been moved to the `pydantic-settings` package. '\n                f'See https://docs.pydantic.dev/{version_short()}/migration/#basesettings-has-moved-to-pydantic-settings '\n                'for more details.'\n            )\n        if import_path in REMOVED_IN_V2:\n            raise PydanticImportError(f'`{import_path}` has been removed in V2.')\n        globals: Dict[str, Any] = sys.modules[module].__dict__\n        if name in globals:\n            return globals[name]\n        raise AttributeError(f'module {module!r} has no attribute {name!r}')\n\n    return wrapper\n", "pydantic/fields.py": "\"\"\"Defining fields on models.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport inspect\nimport sys\nimport typing\nfrom copy import copy\nfrom dataclasses import Field as DataclassField\nfrom functools import cached_property\nfrom typing import Any, ClassVar\nfrom warnings import warn\n\nimport annotated_types\nimport typing_extensions\nfrom pydantic_core import PydanticUndefined\nfrom typing_extensions import Literal, TypeAlias, Unpack, deprecated\n\nfrom . import types\nfrom ._internal import _decorators, _fields, _generics, _internal_dataclass, _repr, _typing_extra, _utils\nfrom .aliases import AliasChoices, AliasPath\nfrom .config import JsonDict\nfrom .errors import PydanticUserError\nfrom .warnings import PydanticDeprecatedSince20\n\nif typing.TYPE_CHECKING:\n    from ._internal._repr import ReprArgs\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = 'Field', 'PrivateAttr', 'computed_field'\n\n\n_Unset: Any = PydanticUndefined\n\nif sys.version_info >= (3, 13):\n    import warnings\n\n    Deprecated: TypeAlias = warnings.deprecated | deprecated\nelse:\n    Deprecated: TypeAlias = deprecated\n\n\nclass _FromFieldInfoInputs(typing_extensions.TypedDict, total=False):\n    \"\"\"This class exists solely to add type checking for the `**kwargs` in `FieldInfo.from_field`.\"\"\"\n\n    annotation: type[Any] | None\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath | AliasChoices | None\n    serialization_alias: str | None\n    title: str | None\n    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None\n    description: str | None\n    examples: list[Any] | None\n    exclude: bool | None\n    gt: annotated_types.SupportsGt | None\n    ge: annotated_types.SupportsGe | None\n    lt: annotated_types.SupportsLt | None\n    le: annotated_types.SupportsLe | None\n    multiple_of: float | None\n    strict: bool | None\n    min_length: int | None\n    max_length: int | None\n    pattern: str | typing.Pattern[str] | None\n    allow_inf_nan: bool | None\n    max_digits: int | None\n    decimal_places: int | None\n    union_mode: Literal['smart', 'left_to_right'] | None\n    discriminator: str | types.Discriminator | None\n    deprecated: Deprecated | str | bool | None\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None\n    frozen: bool | None\n    validate_default: bool | None\n    repr: bool\n    init: bool | None\n    init_var: bool | None\n    kw_only: bool | None\n    coerce_numbers_to_str: bool | None\n\n\nclass _FieldInfoInputs(_FromFieldInfoInputs, total=False):\n    \"\"\"This class exists solely to add type checking for the `**kwargs` in `FieldInfo.__init__`.\"\"\"\n\n    default: Any\n\n\nclass FieldInfo(_repr.Representation):\n    \"\"\"This class holds information about a field.\n\n    `FieldInfo` is used for any field definition regardless of whether the [`Field()`][pydantic.fields.Field]\n    function is explicitly used.\n\n    !!! warning\n        You generally shouldn't be creating `FieldInfo` directly, you'll only need to use it when accessing\n        [`BaseModel`][pydantic.main.BaseModel] `.model_fields` internals.\n\n    Attributes:\n        annotation: The type annotation of the field.\n        default: The default value of the field.\n        default_factory: The factory function used to construct the default for the field.\n        alias: The alias name of the field.\n        alias_priority: The priority of the field's alias.\n        validation_alias: The validation alias of the field.\n        serialization_alias: The serialization alias of the field.\n        title: The title of the field.\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: The description of the field.\n        examples: List of examples of the field.\n        exclude: Whether to exclude the field from the model serialization.\n        discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        frozen: Whether the field is frozen.\n        validate_default: Whether to validate the default value of the field.\n        repr: Whether to include the field in representation of the model.\n        init: Whether the field should be included in the constructor of the dataclass.\n        init_var: Whether the field should _only_ be included in the constructor of the dataclass, and not stored.\n        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n        metadata: List of metadata constraints.\n    \"\"\"\n\n    annotation: type[Any] | None\n    default: Any\n    default_factory: typing.Callable[[], Any] | None\n    alias: str | None\n    alias_priority: int | None\n    validation_alias: str | AliasPath | AliasChoices | None\n    serialization_alias: str | None\n    title: str | None\n    field_title_generator: typing.Callable[[str, FieldInfo], str] | None\n    description: str | None\n    examples: list[Any] | None\n    exclude: bool | None\n    discriminator: str | types.Discriminator | None\n    deprecated: Deprecated | str | bool | None\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None\n    frozen: bool | None\n    validate_default: bool | None\n    repr: bool\n    init: bool | None\n    init_var: bool | None\n    kw_only: bool | None\n    metadata: list[Any]\n\n    __slots__ = (\n        'annotation',\n        'default',\n        'default_factory',\n        'alias',\n        'alias_priority',\n        'validation_alias',\n        'serialization_alias',\n        'title',\n        'field_title_generator',\n        'description',\n        'examples',\n        'exclude',\n        'discriminator',\n        'deprecated',\n        'json_schema_extra',\n        'frozen',\n        'validate_default',\n        'repr',\n        'init',\n        'init_var',\n        'kw_only',\n        'metadata',\n        '_attributes_set',\n    )\n\n    # used to convert kwargs to metadata/constraints,\n    # None has a special meaning - these items are collected into a `PydanticGeneralMetadata`\n    metadata_lookup: ClassVar[dict[str, typing.Callable[[Any], Any] | None]] = {\n        'strict': types.Strict,\n        'gt': annotated_types.Gt,\n        'ge': annotated_types.Ge,\n        'lt': annotated_types.Lt,\n        'le': annotated_types.Le,\n        'multiple_of': annotated_types.MultipleOf,\n        'min_length': annotated_types.MinLen,\n        'max_length': annotated_types.MaxLen,\n        'pattern': None,\n        'allow_inf_nan': None,\n        'max_digits': None,\n        'decimal_places': None,\n        'union_mode': None,\n        'coerce_numbers_to_str': None,\n    }\n\n    def __init__(self, **kwargs: Unpack[_FieldInfoInputs]) -> None:\n        \"\"\"This class should generally not be initialized directly; instead, use the `pydantic.fields.Field` function\n        or one of the constructor classmethods.\n\n        See the signature of `pydantic.fields.Field` for more details about the expected arguments.\n        \"\"\"\n        self._attributes_set = {k: v for k, v in kwargs.items() if v is not _Unset}\n        kwargs = {k: _DefaultValues.get(k) if v is _Unset else v for k, v in kwargs.items()}  # type: ignore\n        self.annotation, annotation_metadata = self._extract_metadata(kwargs.get('annotation'))\n\n        default = kwargs.pop('default', PydanticUndefined)\n        if default is Ellipsis:\n            self.default = PydanticUndefined\n        else:\n            self.default = default\n\n        self.default_factory = kwargs.pop('default_factory', None)\n\n        if self.default is not PydanticUndefined and self.default_factory is not None:\n            raise TypeError('cannot specify both default and default_factory')\n\n        self.alias = kwargs.pop('alias', None)\n        self.validation_alias = kwargs.pop('validation_alias', None)\n        self.serialization_alias = kwargs.pop('serialization_alias', None)\n        alias_is_set = any(alias is not None for alias in (self.alias, self.validation_alias, self.serialization_alias))\n        self.alias_priority = kwargs.pop('alias_priority', None) or 2 if alias_is_set else None\n        self.title = kwargs.pop('title', None)\n        self.field_title_generator = kwargs.pop('field_title_generator', None)\n        self.description = kwargs.pop('description', None)\n        self.examples = kwargs.pop('examples', None)\n        self.exclude = kwargs.pop('exclude', None)\n        self.discriminator = kwargs.pop('discriminator', None)\n        # For compatibility with FastAPI<=0.110.0, we preserve the existing value if it is not overridden\n        self.deprecated = kwargs.pop('deprecated', getattr(self, 'deprecated', None))\n        self.repr = kwargs.pop('repr', True)\n        self.json_schema_extra = kwargs.pop('json_schema_extra', None)\n        self.validate_default = kwargs.pop('validate_default', None)\n        self.frozen = kwargs.pop('frozen', None)\n        # currently only used on dataclasses\n        self.init = kwargs.pop('init', None)\n        self.init_var = kwargs.pop('init_var', None)\n        self.kw_only = kwargs.pop('kw_only', None)\n\n        self.metadata = self._collect_metadata(kwargs) + annotation_metadata  # type: ignore\n\n    @staticmethod\n    def from_field(default: Any = PydanticUndefined, **kwargs: Unpack[_FromFieldInfoInputs]) -> FieldInfo:\n        \"\"\"Create a new `FieldInfo` object with the `Field` function.\n\n        Args:\n            default: The default value for the field. Defaults to Undefined.\n            **kwargs: Additional arguments dictionary.\n\n        Raises:\n            TypeError: If 'annotation' is passed as a keyword argument.\n\n        Returns:\n            A new FieldInfo object with the given parameters.\n\n        Example:\n            This is how you can create a field with default value like this:\n\n            ```python\n            import pydantic\n\n            class MyModel(pydantic.BaseModel):\n                foo: int = pydantic.Field(4)\n            ```\n        \"\"\"\n        if 'annotation' in kwargs:\n            raise TypeError('\"annotation\" is not permitted as a Field keyword argument')\n        return FieldInfo(default=default, **kwargs)\n\n    @staticmethod\n    def from_annotation(annotation: type[Any]) -> FieldInfo:\n        \"\"\"Creates a `FieldInfo` instance from a bare annotation.\n\n        This function is used internally to create a `FieldInfo` from a bare annotation like this:\n\n        ```python\n        import pydantic\n\n        class MyModel(pydantic.BaseModel):\n            foo: int  # <-- like this\n        ```\n\n        We also account for the case where the annotation can be an instance of `Annotated` and where\n        one of the (not first) arguments in `Annotated` is an instance of `FieldInfo`, e.g.:\n\n        ```python\n        import annotated_types\n        from typing_extensions import Annotated\n\n        import pydantic\n\n        class MyModel(pydantic.BaseModel):\n            foo: Annotated[int, annotated_types.Gt(42)]\n            bar: Annotated[int, pydantic.Field(gt=42)]\n        ```\n\n        Args:\n            annotation: An annotation object.\n\n        Returns:\n            An instance of the field metadata.\n        \"\"\"\n        final = False\n        if _typing_extra.is_finalvar(annotation):\n            final = True\n            if annotation is not typing_extensions.Final:\n                annotation = typing_extensions.get_args(annotation)[0]\n\n        if _typing_extra.is_annotated(annotation):\n            first_arg, *extra_args = typing_extensions.get_args(annotation)\n            if _typing_extra.is_finalvar(first_arg):\n                final = True\n            field_info_annotations = [a for a in extra_args if isinstance(a, FieldInfo)]\n            field_info = FieldInfo.merge_field_infos(*field_info_annotations, annotation=first_arg)\n            if field_info:\n                new_field_info = copy(field_info)\n                new_field_info.annotation = first_arg\n                new_field_info.frozen = final or field_info.frozen\n                metadata: list[Any] = []\n                for a in extra_args:\n                    if _typing_extra.is_deprecated_instance(a):\n                        new_field_info.deprecated = a.message\n                    elif not isinstance(a, FieldInfo):\n                        metadata.append(a)\n                    else:\n                        metadata.extend(a.metadata)\n                new_field_info.metadata = metadata\n                return new_field_info\n\n        return FieldInfo(annotation=annotation, frozen=final or None)  # pyright: ignore[reportArgumentType]\n\n    @staticmethod\n    def from_annotated_attribute(annotation: type[Any], default: Any) -> FieldInfo:\n        \"\"\"Create `FieldInfo` from an annotation with a default value.\n\n        This is used in cases like the following:\n\n        ```python\n        import annotated_types\n        from typing_extensions import Annotated\n\n        import pydantic\n\n        class MyModel(pydantic.BaseModel):\n            foo: int = 4  # <-- like this\n            bar: Annotated[int, annotated_types.Gt(4)] = 4  # <-- or this\n            spam: Annotated[int, pydantic.Field(gt=4)] = 4  # <-- or this\n        ```\n\n        Args:\n            annotation: The type annotation of the field.\n            default: The default value of the field.\n\n        Returns:\n            A field object with the passed values.\n        \"\"\"\n        if annotation is default:\n            raise PydanticUserError(\n                'Error when building FieldInfo from annotated attribute. '\n                \"Make sure you don't have any field name clashing with a type annotation \",\n                code='unevaluable-type-annotation',\n            )\n\n        final = False\n        if _typing_extra.is_finalvar(annotation):\n            final = True\n            if annotation is not typing_extensions.Final:\n                annotation = typing_extensions.get_args(annotation)[0]\n\n        if isinstance(default, FieldInfo):\n            default.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]\n            default.metadata += annotation_metadata\n            default = default.merge_field_infos(\n                *[x for x in annotation_metadata if isinstance(x, FieldInfo)], default, annotation=default.annotation\n            )\n            default.frozen = final or default.frozen\n            return default\n        elif isinstance(default, dataclasses.Field):\n            init_var = False\n            if annotation is dataclasses.InitVar:\n                init_var = True\n                annotation = typing.cast(Any, Any)\n            elif isinstance(annotation, dataclasses.InitVar):\n                init_var = True\n                annotation = annotation.type\n            pydantic_field = FieldInfo._from_dataclass_field(default)\n            pydantic_field.annotation, annotation_metadata = FieldInfo._extract_metadata(annotation)  # pyright: ignore[reportArgumentType]\n            pydantic_field.metadata += annotation_metadata\n            pydantic_field = pydantic_field.merge_field_infos(\n                *[x for x in annotation_metadata if isinstance(x, FieldInfo)],\n                pydantic_field,\n                annotation=pydantic_field.annotation,\n            )\n            pydantic_field.frozen = final or pydantic_field.frozen\n            pydantic_field.init_var = init_var\n            pydantic_field.init = getattr(default, 'init', None)\n            pydantic_field.kw_only = getattr(default, 'kw_only', None)\n            return pydantic_field\n        else:\n            if _typing_extra.is_annotated(annotation):\n                first_arg, *extra_args = typing_extensions.get_args(annotation)\n                field_infos = [a for a in extra_args if isinstance(a, FieldInfo)]\n                field_info = FieldInfo.merge_field_infos(*field_infos, annotation=first_arg, default=default)\n                metadata: list[Any] = []\n                for a in extra_args:\n                    if _typing_extra.is_deprecated_instance(a):\n                        field_info.deprecated = a.message\n                    elif not isinstance(a, FieldInfo):\n                        metadata.append(a)\n                    else:\n                        metadata.extend(a.metadata)\n                field_info.metadata = metadata\n                return field_info\n\n            return FieldInfo(annotation=annotation, default=default, frozen=final or None)  # pyright: ignore[reportArgumentType]\n\n    @staticmethod\n    def merge_field_infos(*field_infos: FieldInfo, **overrides: Any) -> FieldInfo:\n        \"\"\"Merge `FieldInfo` instances keeping only explicitly set attributes.\n\n        Later `FieldInfo` instances override earlier ones.\n\n        Returns:\n            FieldInfo: A merged FieldInfo instance.\n        \"\"\"\n        flattened_field_infos: list[FieldInfo] = []\n        for field_info in field_infos:\n            flattened_field_infos.extend(x for x in field_info.metadata if isinstance(x, FieldInfo))\n            flattened_field_infos.append(field_info)\n        field_infos = tuple(flattened_field_infos)\n        if len(field_infos) == 1:\n            # No merging necessary, but we still need to make a copy and apply the overrides\n            field_info = copy(field_infos[0])\n            field_info._attributes_set.update(overrides)\n\n            default_override = overrides.pop('default', PydanticUndefined)\n            if default_override is Ellipsis:\n                default_override = PydanticUndefined\n            if default_override is not PydanticUndefined:\n                field_info.default = default_override\n\n            for k, v in overrides.items():\n                setattr(field_info, k, v)\n            return field_info  # type: ignore\n\n        new_kwargs: dict[str, Any] = {}\n        metadata = {}\n        for field_info in field_infos:\n            new_kwargs.update(field_info._attributes_set)\n            for x in field_info.metadata:\n                if not isinstance(x, FieldInfo):\n                    metadata[type(x)] = x\n        new_kwargs.update(overrides)\n        field_info = FieldInfo(**new_kwargs)\n        field_info.metadata = list(metadata.values())\n        return field_info\n\n    @staticmethod\n    def _from_dataclass_field(dc_field: DataclassField[Any]) -> FieldInfo:\n        \"\"\"Return a new `FieldInfo` instance from a `dataclasses.Field` instance.\n\n        Args:\n            dc_field: The `dataclasses.Field` instance to convert.\n\n        Returns:\n            The corresponding `FieldInfo` instance.\n\n        Raises:\n            TypeError: If any of the `FieldInfo` kwargs does not match the `dataclass.Field` kwargs.\n        \"\"\"\n        default = dc_field.default\n        if default is dataclasses.MISSING:\n            default = PydanticUndefined\n\n        if dc_field.default_factory is dataclasses.MISSING:\n            default_factory: typing.Callable[[], Any] | None = None\n        else:\n            default_factory = dc_field.default_factory\n\n        # use the `Field` function so in correct kwargs raise the correct `TypeError`\n        dc_field_metadata = {k: v for k, v in dc_field.metadata.items() if k in _FIELD_ARG_NAMES}\n        return Field(default=default, default_factory=default_factory, repr=dc_field.repr, **dc_field_metadata)\n\n    @staticmethod\n    def _extract_metadata(annotation: type[Any] | None) -> tuple[type[Any] | None, list[Any]]:\n        \"\"\"Tries to extract metadata/constraints from an annotation if it uses `Annotated`.\n\n        Args:\n            annotation: The type hint annotation for which metadata has to be extracted.\n\n        Returns:\n            A tuple containing the extracted metadata type and the list of extra arguments.\n        \"\"\"\n        if annotation is not None:\n            if _typing_extra.is_annotated(annotation):\n                first_arg, *extra_args = typing_extensions.get_args(annotation)\n                return first_arg, list(extra_args)\n\n        return annotation, []\n\n    @staticmethod\n    def _collect_metadata(kwargs: dict[str, Any]) -> list[Any]:\n        \"\"\"Collect annotations from kwargs.\n\n        Args:\n            kwargs: Keyword arguments passed to the function.\n\n        Returns:\n            A list of metadata objects - a combination of `annotated_types.BaseMetadata` and\n                `PydanticMetadata`.\n        \"\"\"\n        metadata: list[Any] = []\n        general_metadata = {}\n        for key, value in list(kwargs.items()):\n            try:\n                marker = FieldInfo.metadata_lookup[key]\n            except KeyError:\n                continue\n\n            del kwargs[key]\n            if value is not None:\n                if marker is None:\n                    general_metadata[key] = value\n                else:\n                    metadata.append(marker(value))\n        if general_metadata:\n            metadata.append(_fields.pydantic_general_metadata(**general_metadata))\n        return metadata\n\n    @property\n    def deprecation_message(self) -> str | None:\n        \"\"\"The deprecation message to be emitted, or `None` if not set.\"\"\"\n        if self.deprecated is None:\n            return None\n        if isinstance(self.deprecated, bool):\n            return 'deprecated' if self.deprecated else None\n        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message\n\n    def get_default(self, *, call_default_factory: bool = False) -> Any:\n        \"\"\"Get the default value.\n\n        We expose an option for whether to call the default_factory (if present), as calling it may\n        result in side effects that we want to avoid. However, there are times when it really should\n        be called (namely, when instantiating a model via `model_construct`).\n\n        Args:\n            call_default_factory: Whether to call the default_factory or not. Defaults to `False`.\n\n        Returns:\n            The default value, calling the default factory if requested or `None` if not set.\n        \"\"\"\n        if self.default_factory is None:\n            return _utils.smart_deepcopy(self.default)\n        elif call_default_factory:\n            return self.default_factory()\n        else:\n            return None\n\n    def is_required(self) -> bool:\n        \"\"\"Check if the field is required (i.e., does not have a default value or factory).\n\n        Returns:\n            `True` if the field is required, `False` otherwise.\n        \"\"\"\n        return self.default is PydanticUndefined and self.default_factory is None\n\n    def rebuild_annotation(self) -> Any:\n        \"\"\"Attempts to rebuild the original annotation for use in function signatures.\n\n        If metadata is present, it adds it to the original annotation using\n        `Annotated`. Otherwise, it returns the original annotation as-is.\n\n        Note that because the metadata has been flattened, the original annotation\n        may not be reconstructed exactly as originally provided, e.g. if the original\n        type had unrecognized annotations, or was annotated with a call to `pydantic.Field`.\n\n        Returns:\n            The rebuilt annotation.\n        \"\"\"\n        if not self.metadata:\n            return self.annotation\n        else:\n            # Annotated arguments must be a tuple\n            return typing_extensions.Annotated[(self.annotation, *self.metadata)]  # type: ignore\n\n    def apply_typevars_map(self, typevars_map: dict[Any, Any] | None, types_namespace: dict[str, Any] | None) -> None:\n        \"\"\"Apply a `typevars_map` to the annotation.\n\n        This method is used when analyzing parametrized generic types to replace typevars with their concrete types.\n\n        This method applies the `typevars_map` to the annotation in place.\n\n        Args:\n            typevars_map: A dictionary mapping type variables to their concrete types.\n            types_namespace (dict | None): A dictionary containing related types to the annotated type.\n\n        See Also:\n            pydantic._internal._generics.replace_types is used for replacing the typevars with\n                their concrete types.\n        \"\"\"\n        annotation = _typing_extra.eval_type_lenient(self.annotation, types_namespace)\n        self.annotation = _generics.replace_types(annotation, typevars_map)\n\n    def __repr_args__(self) -> ReprArgs:\n        yield 'annotation', _repr.PlainRepr(_repr.display_as_type(self.annotation))\n        yield 'required', self.is_required()\n\n        for s in self.__slots__:\n            if s == '_attributes_set':\n                continue\n            if s == 'annotation':\n                continue\n            elif s == 'metadata' and not self.metadata:\n                continue\n            elif s == 'repr' and self.repr is True:\n                continue\n            if s == 'frozen' and self.frozen is False:\n                continue\n            if s == 'validation_alias' and self.validation_alias == self.alias:\n                continue\n            if s == 'serialization_alias' and self.serialization_alias == self.alias:\n                continue\n            if s == 'default' and self.default is not PydanticUndefined:\n                yield 'default', self.default\n            elif s == 'default_factory' and self.default_factory is not None:\n                yield 'default_factory', _repr.PlainRepr(_repr.display_as_type(self.default_factory))\n            else:\n                value = getattr(self, s)\n                if value is not None and value is not PydanticUndefined:\n                    yield s, value\n\n\nclass _EmptyKwargs(typing_extensions.TypedDict):\n    \"\"\"This class exists solely to ensure that type checking warns about passing `**extra` in `Field`.\"\"\"\n\n\n_DefaultValues = dict(\n    default=...,\n    default_factory=None,\n    alias=None,\n    alias_priority=None,\n    validation_alias=None,\n    serialization_alias=None,\n    title=None,\n    description=None,\n    examples=None,\n    exclude=None,\n    discriminator=None,\n    json_schema_extra=None,\n    frozen=None,\n    validate_default=None,\n    repr=True,\n    init=None,\n    init_var=None,\n    kw_only=None,\n    pattern=None,\n    strict=None,\n    gt=None,\n    ge=None,\n    lt=None,\n    le=None,\n    multiple_of=None,\n    allow_inf_nan=None,\n    max_digits=None,\n    decimal_places=None,\n    min_length=None,\n    max_length=None,\n    coerce_numbers_to_str=None,\n)\n\n\ndef Field(  # noqa: C901\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: typing.Callable[[], Any] | None = _Unset,\n    alias: str | None = _Unset,\n    alias_priority: int | None = _Unset,\n    validation_alias: str | AliasPath | AliasChoices | None = _Unset,\n    serialization_alias: str | None = _Unset,\n    title: str | None = _Unset,\n    field_title_generator: typing_extensions.Callable[[str, FieldInfo], str] | None = _Unset,\n    description: str | None = _Unset,\n    examples: list[Any] | None = _Unset,\n    exclude: bool | None = _Unset,\n    discriminator: str | types.Discriminator | None = _Unset,\n    deprecated: Deprecated | str | bool | None = _Unset,\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = _Unset,\n    frozen: bool | None = _Unset,\n    validate_default: bool | None = _Unset,\n    repr: bool = _Unset,\n    init: bool | None = _Unset,\n    init_var: bool | None = _Unset,\n    kw_only: bool | None = _Unset,\n    pattern: str | typing.Pattern[str] | None = _Unset,\n    strict: bool | None = _Unset,\n    coerce_numbers_to_str: bool | None = _Unset,\n    gt: annotated_types.SupportsGt | None = _Unset,\n    ge: annotated_types.SupportsGe | None = _Unset,\n    lt: annotated_types.SupportsLt | None = _Unset,\n    le: annotated_types.SupportsLe | None = _Unset,\n    multiple_of: float | None = _Unset,\n    allow_inf_nan: bool | None = _Unset,\n    max_digits: int | None = _Unset,\n    decimal_places: int | None = _Unset,\n    min_length: int | None = _Unset,\n    max_length: int | None = _Unset,\n    union_mode: Literal['smart', 'left_to_right'] = _Unset,\n    **extra: Unpack[_EmptyKwargs],\n) -> Any:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/fields\n\n    Create a field for objects that can be configured.\n\n    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments\n    apply only to number fields (`int`, `float`, `Decimal`) and some apply only to `str`.\n\n    Note:\n        - Any `_Unset` objects will be replaced by the corresponding value defined in the `_DefaultValues` dictionary. If a key for the `_Unset` object is not found in the `_DefaultValues` dictionary, it will default to `None`\n\n    Args:\n        default: Default value if the field is not set.\n        default_factory: A callable to generate the default value, such as :func:`~datetime.utcnow`.\n        alias: The name to use for the attribute when validating or serializing by alias.\n            This is often used for things like converting between snake and camel case.\n        alias_priority: Priority of the alias. This affects whether an alias generator is used.\n        validation_alias: Like `alias`, but only affects validation, not serialization.\n        serialization_alias: Like `alias`, but only affects serialization, not validation.\n        title: Human-readable title.\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: Human-readable description.\n        examples: Example values for this field.\n        exclude: Whether to exclude the field from the model serialization.\n        discriminator: Field name or Discriminator for discriminating the type in a tagged union.\n        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        frozen: Whether the field is frozen. If true, attempts to change the value on an instance will raise an error.\n        validate_default: If `True`, apply validation to the default value every time you create an instance.\n            Otherwise, for performance reasons, the default value of the field is trusted and not validated.\n        repr: A boolean indicating whether to include the field in the `__repr__` output.\n        init: Whether the field should be included in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        init_var: Whether the field should _only_ be included in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        kw_only: Whether the field should be a keyword-only argument in the constructor of the dataclass.\n            (Only applies to dataclasses.)\n        coerce_numbers_to_str: Whether to enable coercion of any `Number` type to `str` (not applicable in `strict` mode).\n        strict: If `True`, strict validation is applied to the field.\n            See [Strict Mode](../concepts/strict_mode.md) for details.\n        gt: Greater than. If set, value must be greater than this. Only applicable to numbers.\n        ge: Greater than or equal. If set, value must be greater than or equal to this. Only applicable to numbers.\n        lt: Less than. If set, value must be less than this. Only applicable to numbers.\n        le: Less than or equal. If set, value must be less than or equal to this. Only applicable to numbers.\n        multiple_of: Value must be a multiple of this. Only applicable to numbers.\n        min_length: Minimum length for iterables.\n        max_length: Maximum length for iterables.\n        pattern: Pattern for strings (a regular expression).\n        allow_inf_nan: Allow `inf`, `-inf`, `nan`. Only applicable to numbers.\n        max_digits: Maximum number of allow digits for strings.\n        decimal_places: Maximum number of decimal places allowed for numbers.\n        union_mode: The strategy to apply when validating a union. Can be `smart` (the default), or `left_to_right`.\n            See [Union Mode](../concepts/unions.md#union-modes) for details.\n        extra: (Deprecated) Extra fields that will be included in the JSON schema.\n\n            !!! warning Deprecated\n                The `extra` kwargs is deprecated. Use `json_schema_extra` instead.\n\n    Returns:\n        A new [`FieldInfo`][pydantic.fields.FieldInfo]. The return annotation is `Any` so `Field` can be used on\n            type-annotated fields without causing a type error.\n    \"\"\"\n    # Check deprecated and removed params from V1. This logic should eventually be removed.\n    const = extra.pop('const', None)  # type: ignore\n    if const is not None:\n        raise PydanticUserError('`const` is removed, use `Literal` instead', code='removed-kwargs')\n\n    min_items = extra.pop('min_items', None)  # type: ignore\n    if min_items is not None:\n        warn('`min_items` is deprecated and will be removed, use `min_length` instead', DeprecationWarning)\n        if min_length in (None, _Unset):\n            min_length = min_items  # type: ignore\n\n    max_items = extra.pop('max_items', None)  # type: ignore\n    if max_items is not None:\n        warn('`max_items` is deprecated and will be removed, use `max_length` instead', DeprecationWarning)\n        if max_length in (None, _Unset):\n            max_length = max_items  # type: ignore\n\n    unique_items = extra.pop('unique_items', None)  # type: ignore\n    if unique_items is not None:\n        raise PydanticUserError(\n            (\n                '`unique_items` is removed, use `Set` instead'\n                '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'\n            ),\n            code='removed-kwargs',\n        )\n\n    allow_mutation = extra.pop('allow_mutation', None)  # type: ignore\n    if allow_mutation is not None:\n        warn('`allow_mutation` is deprecated and will be removed. use `frozen` instead', DeprecationWarning)\n        if allow_mutation is False:\n            frozen = True\n\n    regex = extra.pop('regex', None)  # type: ignore\n    if regex is not None:\n        raise PydanticUserError('`regex` is removed. use `pattern` instead', code='removed-kwargs')\n\n    if extra:\n        warn(\n            'Using extra keyword arguments on `Field` is deprecated and will be removed.'\n            ' Use `json_schema_extra` instead.'\n            f' (Extra keys: {\", \".join(k.__repr__() for k in extra.keys())})',\n            DeprecationWarning,\n        )\n        if not json_schema_extra or json_schema_extra is _Unset:\n            json_schema_extra = extra  # type: ignore\n\n    if (\n        validation_alias\n        and validation_alias is not _Unset\n        and not isinstance(validation_alias, (str, AliasChoices, AliasPath))\n    ):\n        raise TypeError('Invalid `validation_alias` type. it should be `str`, `AliasChoices`, or `AliasPath`')\n\n    if serialization_alias in (_Unset, None) and isinstance(alias, str):\n        serialization_alias = alias\n\n    if validation_alias in (_Unset, None):\n        validation_alias = alias\n\n    include = extra.pop('include', None)  # type: ignore\n    if include is not None:\n        warn('`include` is deprecated and does nothing. It will be removed, use `exclude` instead', DeprecationWarning)\n\n    return FieldInfo.from_field(\n        default,\n        default_factory=default_factory,\n        alias=alias,\n        alias_priority=alias_priority,\n        validation_alias=validation_alias,\n        serialization_alias=serialization_alias,\n        title=title,\n        field_title_generator=field_title_generator,\n        description=description,\n        examples=examples,\n        exclude=exclude,\n        discriminator=discriminator,\n        deprecated=deprecated,\n        json_schema_extra=json_schema_extra,\n        frozen=frozen,\n        pattern=pattern,\n        validate_default=validate_default,\n        repr=repr,\n        init=init,\n        init_var=init_var,\n        kw_only=kw_only,\n        coerce_numbers_to_str=coerce_numbers_to_str,\n        strict=strict,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        min_length=min_length,\n        max_length=max_length,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        union_mode=union_mode,\n    )\n\n\n_FIELD_ARG_NAMES = set(inspect.signature(Field).parameters)\n_FIELD_ARG_NAMES.remove('extra')  # do not include the varkwargs parameter\n\n\nclass ModelPrivateAttr(_repr.Representation):\n    \"\"\"A descriptor for private attributes in class models.\n\n    !!! warning\n        You generally shouldn't be creating `ModelPrivateAttr` instances directly, instead use\n        `pydantic.fields.PrivateAttr`. (This is similar to `FieldInfo` vs. `Field`.)\n\n    Attributes:\n        default: The default value of the attribute if not provided.\n        default_factory: A callable function that generates the default value of the\n            attribute if not provided.\n    \"\"\"\n\n    __slots__ = 'default', 'default_factory'\n\n    def __init__(\n        self, default: Any = PydanticUndefined, *, default_factory: typing.Callable[[], Any] | None = None\n    ) -> None:\n        self.default = default\n        self.default_factory = default_factory\n\n    if not typing.TYPE_CHECKING:\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n\n        def __getattr__(self, item: str) -> Any:\n            \"\"\"This function improves compatibility with custom descriptors by ensuring delegation happens\n            as expected when the default value of a private attribute is a descriptor.\n            \"\"\"\n            if item in {'__get__', '__set__', '__delete__'}:\n                if hasattr(self.default, item):\n                    return getattr(self.default, item)\n            raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n\n    def __set_name__(self, cls: type[Any], name: str) -> None:\n        \"\"\"Preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487.\"\"\"\n        if self.default is PydanticUndefined:\n            return\n        if not hasattr(self.default, '__set_name__'):\n            return\n        set_name = self.default.__set_name__\n        if callable(set_name):\n            set_name(cls, name)\n\n    def get_default(self) -> Any:\n        \"\"\"Retrieve the default value of the object.\n\n        If `self.default_factory` is `None`, the method will return a deep copy of the `self.default` object.\n\n        If `self.default_factory` is not `None`, it will call `self.default_factory` and return the value returned.\n\n        Returns:\n            The default value of the object.\n        \"\"\"\n        return _utils.smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and (self.default, self.default_factory) == (\n            other.default,\n            other.default_factory,\n        )\n\n\ndef PrivateAttr(\n    default: Any = PydanticUndefined,\n    *,\n    default_factory: typing.Callable[[], Any] | None = None,\n    init: Literal[False] = False,\n) -> Any:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#private-model-attributes\n\n    Indicates that an attribute is intended for private use and not handled during normal validation/serialization.\n\n    Private attributes are not validated by Pydantic, so it's up to you to ensure they are used in a type-safe manner.\n\n    Private attributes are stored in `__private_attributes__` on the model.\n\n    Args:\n        default: The attribute's default value. Defaults to Undefined.\n        default_factory: Callable that will be\n            called when a default value is needed for this attribute.\n            If both `default` and `default_factory` are set, an error will be raised.\n        init: Whether the attribute should be included in the constructor of the dataclass. Always `False`.\n\n    Returns:\n        An instance of [`ModelPrivateAttr`][pydantic.fields.ModelPrivateAttr] class.\n\n    Raises:\n        ValueError: If both `default` and `default_factory` are set.\n    \"\"\"\n    if default is not PydanticUndefined and default_factory is not None:\n        raise TypeError('cannot specify both default and default_factory')\n\n    return ModelPrivateAttr(\n        default,\n        default_factory=default_factory,\n    )\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass ComputedFieldInfo:\n    \"\"\"A container for data from `@computed_field` so that we can access it while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@computed_field'.\n        wrapped_property: The wrapped computed field property.\n        return_type: The type of the computed field property's return value.\n        alias: The alias of the property to be used during serialization.\n        alias_priority: The priority of the alias. This affects whether an alias generator is used.\n        title: Title of the computed field to include in the serialization JSON schema.\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: Description of the computed field to include in the serialization JSON schema.\n        deprecated: A deprecation message, an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport,\n            or a boolean. If `True`, a default deprecation message will be emitted when accessing the field.\n        examples: Example values of the computed field to include in the serialization JSON schema.\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        repr: A boolean indicating whether to include the field in the __repr__ output.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@computed_field'\n    wrapped_property: property\n    return_type: Any\n    alias: str | None\n    alias_priority: int | None\n    title: str | None\n    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None\n    description: str | None\n    deprecated: Deprecated | str | bool | None\n    examples: list[Any] | None\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None\n    repr: bool\n\n    @property\n    def deprecation_message(self) -> str | None:\n        \"\"\"The deprecation message to be emitted, or `None` if not set.\"\"\"\n        if self.deprecated is None:\n            return None\n        if isinstance(self.deprecated, bool):\n            return 'deprecated' if self.deprecated else None\n        return self.deprecated if isinstance(self.deprecated, str) else self.deprecated.message\n\n\ndef _wrapped_property_is_private(property_: cached_property | property) -> bool:  # type: ignore\n    \"\"\"Returns true if provided property is private, False otherwise.\"\"\"\n    wrapped_name: str = ''\n\n    if isinstance(property_, property):\n        wrapped_name = getattr(property_.fget, '__name__', '')\n    elif isinstance(property_, cached_property):  # type: ignore\n        wrapped_name = getattr(property_.func, '__name__', '')  # type: ignore\n\n    return wrapped_name.startswith('_') and not wrapped_name.startswith('__')\n\n\n# this should really be `property[T], cached_property[T]` but property is not generic unlike cached_property\n# See https://github.com/python/typing/issues/985 and linked issues\nPropertyT = typing.TypeVar('PropertyT')\n\n\n@typing.overload\ndef computed_field(\n    *,\n    alias: str | None = None,\n    alias_priority: int | None = None,\n    title: str | None = None,\n    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,\n    description: str | None = None,\n    deprecated: Deprecated | str | bool | None = None,\n    examples: list[Any] | None = None,\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,\n    repr: bool = True,\n    return_type: Any = PydanticUndefined,\n) -> typing.Callable[[PropertyT], PropertyT]: ...\n\n\n@typing.overload\ndef computed_field(__func: PropertyT) -> PropertyT: ...\n\n\ndef computed_field(\n    func: PropertyT | None = None,\n    /,\n    *,\n    alias: str | None = None,\n    alias_priority: int | None = None,\n    title: str | None = None,\n    field_title_generator: typing.Callable[[str, ComputedFieldInfo], str] | None = None,\n    description: str | None = None,\n    deprecated: Deprecated | str | bool | None = None,\n    examples: list[Any] | None = None,\n    json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None = None,\n    repr: bool | None = None,\n    return_type: Any = PydanticUndefined,\n) -> PropertyT | typing.Callable[[PropertyT], PropertyT]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/fields#the-computed_field-decorator\n\n    Decorator to include `property` and `cached_property` when serializing models or dataclasses.\n\n    This is useful for fields that are computed from other fields, or for fields that are expensive to compute and should be cached.\n\n    ```py\n    from pydantic import BaseModel, computed_field\n\n    class Rectangle(BaseModel):\n        width: int\n        length: int\n\n        @computed_field\n        @property\n        def area(self) -> int:\n            return self.width * self.length\n\n    print(Rectangle(width=3, length=2).model_dump())\n    #> {'width': 3, 'length': 2, 'area': 6}\n    ```\n\n    If applied to functions not yet decorated with `@property` or `@cached_property`, the function is\n    automatically wrapped with `property`. Although this is more concise, you will lose IntelliSense in your IDE,\n    and confuse static type checkers, thus explicit use of `@property` is recommended.\n\n    !!! warning \"Mypy Warning\"\n        Even with the `@property` or `@cached_property` applied to your function before `@computed_field`,\n        mypy may throw a `Decorated property not supported` error.\n        See [mypy issue #1362](https://github.com/python/mypy/issues/1362), for more information.\n        To avoid this error message, add `# type: ignore[misc]` to the `@computed_field` line.\n\n        [pyright](https://github.com/microsoft/pyright) supports `@computed_field` without error.\n\n    ```py\n    import random\n\n    from pydantic import BaseModel, computed_field\n\n    class Square(BaseModel):\n        width: float\n\n        @computed_field\n        def area(self) -> float:  # converted to a `property` by `computed_field`\n            return round(self.width**2, 2)\n\n        @area.setter\n        def area(self, new_area: float) -> None:\n            self.width = new_area**0.5\n\n        @computed_field(alias='the magic number', repr=False)\n        def random_number(self) -> int:\n            return random.randint(0, 1_000)\n\n    square = Square(width=1.3)\n\n    # `random_number` does not appear in representation\n    print(repr(square))\n    #> Square(width=1.3, area=1.69)\n\n    print(square.random_number)\n    #> 3\n\n    square.area = 4\n\n    print(square.model_dump_json(by_alias=True))\n    #> {\"width\":2.0,\"area\":4.0,\"the magic number\":3}\n    ```\n\n    !!! warning \"Overriding with `computed_field`\"\n        You can't override a field from a parent class with a `computed_field` in the child class.\n        `mypy` complains about this behavior if allowed, and `dataclasses` doesn't allow this pattern either.\n        See the example below:\n\n    ```py\n    from pydantic import BaseModel, computed_field\n\n    class Parent(BaseModel):\n        a: str\n\n    try:\n\n        class Child(Parent):\n            @computed_field\n            @property\n            def a(self) -> str:\n                return 'new a'\n\n    except ValueError as e:\n        print(repr(e))\n        #> ValueError(\"you can't override a field with a computed field\")\n    ```\n\n    Private properties decorated with `@computed_field` have `repr=False` by default.\n\n    ```py\n    from functools import cached_property\n\n    from pydantic import BaseModel, computed_field\n\n    class Model(BaseModel):\n        foo: int\n\n        @computed_field\n        @cached_property\n        def _private_cached_property(self) -> int:\n            return -self.foo\n\n        @computed_field\n        @property\n        def _private_property(self) -> int:\n            return -self.foo\n\n    m = Model(foo=1)\n    print(repr(m))\n    #> M(foo=1)\n    ```\n\n    Args:\n        func: the function to wrap.\n        alias: alias to use when serializing this computed field, only used when `by_alias=True`\n        alias_priority: priority of the alias. This affects whether an alias generator is used\n        title: Title to use when including this computed field in JSON Schema\n        field_title_generator: A callable that takes a field name and returns title for it.\n        description: Description to use when including this computed field in JSON Schema, defaults to the function's\n            docstring\n        deprecated: A deprecation message (or an instance of `warnings.deprecated` or the `typing_extensions.deprecated` backport).\n            to be emitted when accessing the field. Or a boolean. This will automatically be set if the property is decorated with the\n            `deprecated` decorator.\n        examples: Example values to use when including this computed field in JSON Schema\n        json_schema_extra: A dict or callable to provide extra JSON schema properties.\n        repr: whether to include this computed field in model repr.\n            Default is `False` for private properties and `True` for public properties.\n        return_type: optional return for serialization logic to expect when serializing to JSON, if included\n            this must be correct, otherwise a `TypeError` is raised.\n            If you don't include a return type Any is used, which does runtime introspection to handle arbitrary\n            objects.\n\n    Returns:\n        A proxy wrapper for the property.\n    \"\"\"\n\n    def dec(f: Any) -> Any:\n        nonlocal description, deprecated, return_type, alias_priority\n        unwrapped = _decorators.unwrap_wrapped_function(f)\n\n        if description is None and unwrapped.__doc__:\n            description = inspect.cleandoc(unwrapped.__doc__)\n\n        if deprecated is None and hasattr(unwrapped, '__deprecated__'):\n            deprecated = unwrapped.__deprecated__\n\n        # if the function isn't already decorated with `@property` (or another descriptor), then we wrap it now\n        f = _decorators.ensure_property(f)\n        alias_priority = (alias_priority or 2) if alias is not None else None\n\n        if repr is None:\n            repr_: bool = not _wrapped_property_is_private(property_=f)\n        else:\n            repr_ = repr\n\n        dec_info = ComputedFieldInfo(\n            f,\n            return_type,\n            alias,\n            alias_priority,\n            title,\n            field_title_generator,\n            description,\n            deprecated,\n            examples,\n            json_schema_extra,\n            repr_,\n        )\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    if func is None:\n        return dec\n    else:\n        return dec(func)\n", "pydantic/version.py": "\"\"\"The `version` module holds the version information for Pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\n__all__ = 'VERSION', 'version_info'\n\nVERSION = '2.8.0a1'\n\"\"\"The version of Pydantic.\"\"\"\n\n\ndef version_short() -> str:\n    \"\"\"Return the `major.minor` part of Pydantic version.\n\n    It returns '2.1' if Pydantic version is '2.1.1'.\n    \"\"\"\n    return '.'.join(VERSION.split('.')[:2])\n\n\ndef version_info() -> str:\n    \"\"\"Return complete version information for Pydantic and its dependencies.\"\"\"\n    import importlib.metadata as importlib_metadata\n    import os\n    import platform\n    import sys\n    from pathlib import Path\n\n    import pydantic_core._pydantic_core as pdc\n\n    from ._internal import _git as git\n\n    # get data about packages that are closely related to pydantic, use pydantic or often conflict with pydantic\n    package_names = {\n        'email-validator',\n        'fastapi',\n        'mypy',\n        'pydantic-extra-types',\n        'pydantic-settings',\n        'pyright',\n        'typing_extensions',\n    }\n    related_packages = []\n\n    for dist in importlib_metadata.distributions():\n        name = dist.metadata['Name']\n        if name in package_names:\n            related_packages.append(f'{name}-{dist.version}')\n\n    pydantic_dir = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))\n    most_recent_commit = (\n        git.git_revision(pydantic_dir) if git.is_git_repo(pydantic_dir) and git.have_git() else 'unknown'\n    )\n\n    info = {\n        'pydantic version': VERSION,\n        'pydantic-core version': pdc.__version__,\n        'pydantic-core build': getattr(pdc, 'build_info', None) or pdc.build_profile,\n        'install path': Path(__file__).resolve().parent,\n        'python version': sys.version,\n        'platform': platform.platform(),\n        'related packages': ' '.join(related_packages),\n        'commit': most_recent_commit,\n    }\n    return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n\n\ndef parse_mypy_version(version: str) -> tuple[int, ...]:\n    \"\"\"Parse mypy string version to tuple of ints.\n\n    It parses normal version like `0.930` and extra info followed by a `+` sign\n    like `0.940+dev.04cac4b5d911c4f9529e6ce86a27b44f28846f5d.dirty`.\n\n    Args:\n        version: The mypy version string.\n\n    Returns:\n        A tuple of ints. e.g. (0, 930).\n    \"\"\"\n    return tuple(map(int, version.partition('+')[0].split('.')))\n", "pydantic/tools.py": "\"\"\"The `tools` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/root_model.py": "\"\"\"RootModel class and type definitions.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport typing\nfrom copy import copy, deepcopy\n\nfrom pydantic_core import PydanticUndefined\n\nfrom . import PydanticUserError\nfrom ._internal import _model_construction, _repr\nfrom .main import BaseModel, _object_setattr\n\nif typing.TYPE_CHECKING:\n    from typing import Any\n\n    from typing_extensions import Literal, Self, dataclass_transform\n\n    from .fields import Field as PydanticModelField\n    from .fields import PrivateAttr as PydanticModelPrivateAttr\n\n    # dataclass_transform could be applied to RootModel directly, but `ModelMetaclass`'s dataclass_transform\n    # takes priority (at least with pyright). We trick type checkers into thinking we apply dataclass_transform\n    # on a new metaclass.\n    @dataclass_transform(kw_only_default=False, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\n    class _RootModelMetaclass(_model_construction.ModelMetaclass): ...\nelse:\n    _RootModelMetaclass = _model_construction.ModelMetaclass\n\n__all__ = ('RootModel',)\n\nRootModelRootType = typing.TypeVar('RootModelRootType')\n\n\nclass RootModel(BaseModel, typing.Generic[RootModelRootType], metaclass=_RootModelMetaclass):\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#rootmodel-and-custom-root-types\n\n    A Pydantic `BaseModel` for the root object of the model.\n\n    Attributes:\n        root: The root object of the model.\n        __pydantic_root_model__: Whether the model is a RootModel.\n        __pydantic_private__: Private fields in the model.\n        __pydantic_extra__: Extra fields in the model.\n\n    \"\"\"\n\n    __pydantic_root_model__ = True\n    __pydantic_private__ = None\n    __pydantic_extra__ = None\n\n    root: RootModelRootType\n\n    def __init_subclass__(cls, **kwargs):\n        extra = cls.model_config.get('extra')\n        if extra is not None:\n            raise PydanticUserError(\n                \"`RootModel` does not support setting `model_config['extra']`\", code='root-model-extra'\n            )\n        super().__init_subclass__(**kwargs)\n\n    def __init__(self, /, root: RootModelRootType = PydanticUndefined, **data) -> None:  # type: ignore\n        __tracebackhide__ = True\n        if data:\n            if root is not PydanticUndefined:\n                raise ValueError(\n                    '\"RootModel.__init__\" accepts either a single positional argument or arbitrary keyword arguments'\n                )\n            root = data  # type: ignore\n        self.__pydantic_validator__.validate_python(root, self_instance=self)\n\n    __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]\n\n    @classmethod\n    def model_construct(cls, root: RootModelRootType, _fields_set: set[str] | None = None) -> Self:  # type: ignore\n        \"\"\"Create a new model using the provided root object and update fields set.\n\n        Args:\n            root: The root object of the model.\n            _fields_set: The set of fields to be updated.\n\n        Returns:\n            The new model.\n\n        Raises:\n            NotImplemented: If the model is not a subclass of `RootModel`.\n        \"\"\"\n        return super().model_construct(root=root, _fields_set=_fields_set)\n\n    def __getstate__(self) -> dict[Any, Any]:\n        return {\n            '__dict__': self.__dict__,\n            '__pydantic_fields_set__': self.__pydantic_fields_set__,\n        }\n\n    def __setstate__(self, state: dict[Any, Any]) -> None:\n        _object_setattr(self, '__pydantic_fields_set__', state['__pydantic_fields_set__'])\n        _object_setattr(self, '__dict__', state['__dict__'])\n\n    def __copy__(self) -> Self:\n        \"\"\"Returns a shallow copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', copy(self.__dict__))\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n        return m\n\n    def __deepcopy__(self, memo: dict[int, Any] | None = None) -> Self:\n        \"\"\"Returns a deep copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n        # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n        # and attempting a deepcopy would be marginally slower.\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n        return m\n\n    if typing.TYPE_CHECKING:\n\n        def model_dump(  # type: ignore\n            self,\n            *,\n            mode: Literal['json', 'python'] | str = 'python',\n            include: Any = None,\n            exclude: Any = None,\n            context: dict[str, Any] | None = None,\n            by_alias: bool = False,\n            exclude_unset: bool = False,\n            exclude_defaults: bool = False,\n            exclude_none: bool = False,\n            round_trip: bool = False,\n            warnings: bool | Literal['none', 'warn', 'error'] = True,\n            serialize_as_any: bool = False,\n        ) -> Any:\n            \"\"\"This method is included just to get a more accurate return type for type checkers.\n            It is included in this `if TYPE_CHECKING:` block since no override is actually necessary.\n\n            See the documentation of `BaseModel.model_dump` for more details about the arguments.\n\n            Generally, this method will have a return type of `RootModelRootType`, assuming that `RootModelRootType` is\n            not a `BaseModel` subclass. If `RootModelRootType` is a `BaseModel` subclass, then the return\n            type will likely be `dict[str, Any]`, as `model_dump` calls are recursive. The return type could\n            even be something different, in the case of a custom serializer.\n            Thus, `Any` is used here to catch all of these cases.\n            \"\"\"\n            ...\n\n    def __eq__(self, other: Any) -> bool:\n        if not isinstance(other, RootModel):\n            return NotImplemented\n        return self.model_fields['root'].annotation == other.model_fields['root'].annotation and super().__eq__(other)\n\n    def __repr_args__(self) -> _repr.ReprArgs:\n        yield 'root', self.root\n", "pydantic/warnings.py": "\"\"\"Pydantic-specific warnings.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom .version import version_short\n\n__all__ = (\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecationWarning',\n    'PydanticDeprecatedSince26',\n    'PydanticExperimentalWarning',\n)\n\n\nclass PydanticDeprecationWarning(DeprecationWarning):\n    \"\"\"A Pydantic specific deprecation warning.\n\n    This warning is raised when using deprecated functionality in Pydantic. It provides information on when the\n    deprecation was introduced and the expected version in which the corresponding functionality will be removed.\n\n    Attributes:\n        message: Description of the warning.\n        since: Pydantic version in what the deprecation was introduced.\n        expected_removal: Pydantic version in what the corresponding functionality expected to be removed.\n    \"\"\"\n\n    message: str\n    since: tuple[int, int]\n    expected_removal: tuple[int, int]\n\n    def __init__(\n        self, message: str, *args: object, since: tuple[int, int], expected_removal: tuple[int, int] | None = None\n    ) -> None:\n        super().__init__(message, *args)\n        self.message = message.rstrip('.')\n        self.since = since\n        self.expected_removal = expected_removal if expected_removal is not None else (since[0] + 1, 0)\n\n    def __str__(self) -> str:\n        message = (\n            f'{self.message}. Deprecated in Pydantic V{self.since[0]}.{self.since[1]}'\n            f' to be removed in V{self.expected_removal[0]}.{self.expected_removal[1]}.'\n        )\n        if self.since == (2, 0):\n            message += f' See Pydantic V2 Migration Guide at https://errors.pydantic.dev/{version_short()}/migration/'\n        return message\n\n\nclass PydanticDeprecatedSince20(PydanticDeprecationWarning):\n    \"\"\"A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.0.\"\"\"\n\n    def __init__(self, message: str, *args: object) -> None:\n        super().__init__(message, *args, since=(2, 0), expected_removal=(3, 0))\n\n\nclass PydanticDeprecatedSince26(PydanticDeprecationWarning):\n    \"\"\"A specific `PydanticDeprecationWarning` subclass defining functionality deprecated since Pydantic 2.6.\"\"\"\n\n    def __init__(self, message: str, *args: object) -> None:\n        super().__init__(message, *args, since=(2, 0), expected_removal=(3, 0))\n\n\nclass GenericBeforeBaseModelWarning(Warning):\n    pass\n\n\nclass PydanticExperimentalWarning(Warning):\n    \"\"\"A Pydantic specific experimental functionality warning.\n\n    This warning is raised when using experimental functionality in Pydantic.\n    It is raised to warn users that the functionality may change or be removed in future versions of Pydantic.\n    \"\"\"\n", "pydantic/alias_generators.py": "\"\"\"Alias generators for converting between different capitalization conventions.\"\"\"\n\nimport re\n\n__all__ = ('to_pascal', 'to_camel', 'to_snake')\n\n# TODO: in V3, change the argument names to be more descriptive\n# Generally, don't only convert from snake_case, or name the functions\n# more specifically like snake_to_camel.\n\n\ndef to_pascal(snake: str) -> str:\n    \"\"\"Convert a snake_case string to PascalCase.\n\n    Args:\n        snake: The string to convert.\n\n    Returns:\n        The PascalCase string.\n    \"\"\"\n    camel = snake.title()\n    return re.sub('([0-9A-Za-z])_(?=[0-9A-Z])', lambda m: m.group(1), camel)\n\n\ndef to_camel(snake: str) -> str:\n    \"\"\"Convert a snake_case string to camelCase.\n\n    Args:\n        snake: The string to convert.\n\n    Returns:\n        The converted camelCase string.\n    \"\"\"\n    # If the string is already in camelCase and does not contain a digit followed\n    # by a lowercase letter, return it as it is\n    if re.match('^[a-z]+[A-Za-z0-9]*$', snake) and not re.search(r'\\d[a-z]', snake):\n        return snake\n\n    camel = to_pascal(snake)\n    return re.sub('(^_*[A-Z])', lambda m: m.group(1).lower(), camel)\n\n\ndef to_snake(camel: str) -> str:\n    \"\"\"Convert a PascalCase, camelCase, or kebab-case string to snake_case.\n\n    Args:\n        camel: The string to convert.\n\n    Returns:\n        The converted string in snake_case.\n    \"\"\"\n    snake = re.sub(r'([a-zA-Z])([0-9])', lambda m: f'{m.group(1)}_{m.group(2)}', camel)\n    snake = re.sub(r'([a-z0-9])([A-Z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n    snake = re.sub(r'([A-Z]+)([A-Z][a-z])', lambda m: f'{m.group(1)}_{m.group(2)}', snake)\n    # Replace hyphens with underscores to handle kebab-case\n    snake = snake.replace('-', '_')\n    return snake.lower()\n", "pydantic/json_schema.py": "\"\"\"\nUsage docs: https://docs.pydantic.dev/2.5/concepts/json_schema/\n\nThe `json_schema` module contains classes and functions to allow the way [JSON Schema](https://json-schema.org/)\nis generated to be customized.\n\nIn general you shouldn't need to use this module directly; instead, you can use\n[`BaseModel.model_json_schema`][pydantic.BaseModel.model_json_schema] and\n[`TypeAdapter.json_schema`][pydantic.TypeAdapter.json_schema].\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport inspect\nimport math\nimport re\nimport warnings\nfrom collections import defaultdict\nfrom copy import deepcopy\nfrom dataclasses import is_dataclass\nfrom enum import Enum\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Counter,\n    Dict,\n    Hashable,\n    Iterable,\n    NewType,\n    Pattern,\n    Sequence,\n    Tuple,\n    TypeVar,\n    Union,\n    cast,\n)\n\nimport pydantic_core\nfrom pydantic_core import CoreSchema, PydanticOmit, core_schema, to_jsonable_python\nfrom pydantic_core.core_schema import ComputedField\nfrom typing_extensions import Annotated, Literal, TypeAlias, assert_never, deprecated, final\n\nfrom pydantic.warnings import PydanticDeprecatedSince26\n\nfrom ._internal import (\n    _config,\n    _core_metadata,\n    _core_utils,\n    _decorators,\n    _internal_dataclass,\n    _mock_val_ser,\n    _schema_generation_shared,\n    _typing_extra,\n)\nfrom .annotated_handlers import GetJsonSchemaHandler\nfrom .config import JsonDict, JsonSchemaExtraCallable, JsonValue\nfrom .errors import PydanticInvalidForJsonSchema, PydanticSchemaGenerationError, PydanticUserError\n\nif TYPE_CHECKING:\n    from . import ConfigDict\n    from ._internal._core_utils import CoreSchemaField, CoreSchemaOrField\n    from ._internal._dataclasses import PydanticDataclass\n    from ._internal._schema_generation_shared import GetJsonSchemaFunction\n    from .main import BaseModel\n\n\nCoreSchemaOrFieldType = Literal[core_schema.CoreSchemaType, core_schema.CoreSchemaFieldType]\n\"\"\"\nA type alias for defined schema types that represents a union of\n`core_schema.CoreSchemaType` and\n`core_schema.CoreSchemaFieldType`.\n\"\"\"\n\nJsonSchemaValue = Dict[str, Any]\n\"\"\"\nA type alias for a JSON schema value. This is a dictionary of string keys to arbitrary JSON values.\n\"\"\"\n\nJsonSchemaMode = Literal['validation', 'serialization']\n\"\"\"\nA type alias that represents the mode of a JSON schema; either 'validation' or 'serialization'.\n\nFor some types, the inputs to validation differ from the outputs of serialization. For example,\ncomputed fields will only be present when serializing, and should not be provided when\nvalidating. This flag provides a way to indicate whether you want the JSON schema required\nfor validation inputs, or that will be matched by serialization outputs.\n\"\"\"\n\n_MODE_TITLE_MAPPING: dict[JsonSchemaMode, str] = {'validation': 'Input', 'serialization': 'Output'}\n\n\n@deprecated(\n    '`update_json_schema` is deprecated, use a simple `my_dict.update(update_dict)` call instead.',\n    category=None,\n)\ndef update_json_schema(schema: JsonSchemaValue, updates: dict[str, Any]) -> JsonSchemaValue:\n    \"\"\"Update a JSON schema in-place by providing a dictionary of updates.\n\n    This function sets the provided key-value pairs in the schema and returns the updated schema.\n\n    Args:\n        schema: The JSON schema to update.\n        updates: A dictionary of key-value pairs to set in the schema.\n\n    Returns:\n        The updated JSON schema.\n    \"\"\"\n    schema.update(updates)\n    return schema\n\n\nJsonSchemaWarningKind = Literal['skipped-choice', 'non-serializable-default']\n\"\"\"\nA type alias representing the kinds of warnings that can be emitted during JSON schema generation.\n\nSee [`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message]\nfor more details.\n\"\"\"\n\n\nclass PydanticJsonSchemaWarning(UserWarning):\n    \"\"\"This class is used to emit warnings produced during JSON schema generation.\n    See the [`GenerateJsonSchema.emit_warning`][pydantic.json_schema.GenerateJsonSchema.emit_warning] and\n    [`GenerateJsonSchema.render_warning_message`][pydantic.json_schema.GenerateJsonSchema.render_warning_message]\n    methods for more details; these can be overridden to control warning behavior.\n    \"\"\"\n\n\n# ##### JSON Schema Generation #####\nDEFAULT_REF_TEMPLATE = '#/$defs/{model}'\n\"\"\"The default format string used to generate reference names.\"\"\"\n\n# There are three types of references relevant to building JSON schemas:\n#   1. core_schema \"ref\" values; these are not exposed as part of the JSON schema\n#       * these might look like the fully qualified path of a model, its id, or something similar\nCoreRef = NewType('CoreRef', str)\n#   2. keys of the \"definitions\" object that will eventually go into the JSON schema\n#       * by default, these look like \"MyModel\", though may change in the presence of collisions\n#       * eventually, we may want to make it easier to modify the way these names are generated\nDefsRef = NewType('DefsRef', str)\n#   3. the values corresponding to the \"$ref\" key in the schema\n#       * By default, these look like \"#/$defs/MyModel\", as in {\"$ref\": \"#/$defs/MyModel\"}\nJsonRef = NewType('JsonRef', str)\n\nCoreModeRef = Tuple[CoreRef, JsonSchemaMode]\nJsonSchemaKeyT = TypeVar('JsonSchemaKeyT', bound=Hashable)\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass _DefinitionsRemapping:\n    defs_remapping: dict[DefsRef, DefsRef]\n    json_remapping: dict[JsonRef, JsonRef]\n\n    @staticmethod\n    def from_prioritized_choices(\n        prioritized_choices: dict[DefsRef, list[DefsRef]],\n        defs_to_json: dict[DefsRef, JsonRef],\n        definitions: dict[DefsRef, JsonSchemaValue],\n    ) -> _DefinitionsRemapping:\n        \"\"\"\n        This function should produce a remapping that replaces complex DefsRef with the simpler ones from the\n        prioritized_choices such that applying the name remapping would result in an equivalent JSON schema.\n        \"\"\"\n        # We need to iteratively simplify the definitions until we reach a fixed point.\n        # The reason for this is that outer definitions may reference inner definitions that get simplified\n        # into an equivalent reference, and the outer definitions won't be equivalent until we've simplified\n        # the inner definitions.\n        copied_definitions = deepcopy(definitions)\n        definitions_schema = {'$defs': copied_definitions}\n        for _iter in range(100):  # prevent an infinite loop in the case of a bug, 100 iterations should be enough\n            # For every possible remapped DefsRef, collect all schemas that that DefsRef might be used for:\n            schemas_for_alternatives: dict[DefsRef, list[JsonSchemaValue]] = defaultdict(list)\n            for defs_ref in copied_definitions:\n                alternatives = prioritized_choices[defs_ref]\n                for alternative in alternatives:\n                    schemas_for_alternatives[alternative].append(copied_definitions[defs_ref])\n\n            # Deduplicate the schemas for each alternative; the idea is that we only want to remap to a new DefsRef\n            # if it introduces no ambiguity, i.e., there is only one distinct schema for that DefsRef.\n            for defs_ref, schemas in schemas_for_alternatives.items():\n                schemas_for_alternatives[defs_ref] = _deduplicate_schemas(schemas_for_alternatives[defs_ref])\n\n            # Build the remapping\n            defs_remapping: dict[DefsRef, DefsRef] = {}\n            json_remapping: dict[JsonRef, JsonRef] = {}\n            for original_defs_ref in definitions:\n                alternatives = prioritized_choices[original_defs_ref]\n                # Pick the first alternative that has only one schema, since that means there is no collision\n                remapped_defs_ref = next(x for x in alternatives if len(schemas_for_alternatives[x]) == 1)\n                defs_remapping[original_defs_ref] = remapped_defs_ref\n                json_remapping[defs_to_json[original_defs_ref]] = defs_to_json[remapped_defs_ref]\n            remapping = _DefinitionsRemapping(defs_remapping, json_remapping)\n            new_definitions_schema = remapping.remap_json_schema({'$defs': copied_definitions})\n            if definitions_schema == new_definitions_schema:\n                # We've reached the fixed point\n                return remapping\n            definitions_schema = new_definitions_schema\n\n        raise PydanticInvalidForJsonSchema('Failed to simplify the JSON schema definitions')\n\n    def remap_defs_ref(self, ref: DefsRef) -> DefsRef:\n        return self.defs_remapping.get(ref, ref)\n\n    def remap_json_ref(self, ref: JsonRef) -> JsonRef:\n        return self.json_remapping.get(ref, ref)\n\n    def remap_json_schema(self, schema: Any) -> Any:\n        \"\"\"\n        Recursively update the JSON schema replacing all $refs\n        \"\"\"\n        if isinstance(schema, str):\n            # Note: this may not really be a JsonRef; we rely on having no collisions between JsonRefs and other strings\n            return self.remap_json_ref(JsonRef(schema))\n        elif isinstance(schema, list):\n            return [self.remap_json_schema(item) for item in schema]\n        elif isinstance(schema, dict):\n            for key, value in schema.items():\n                if key == '$ref' and isinstance(value, str):\n                    schema['$ref'] = self.remap_json_ref(JsonRef(value))\n                elif key == '$defs':\n                    schema['$defs'] = {\n                        self.remap_defs_ref(DefsRef(key)): self.remap_json_schema(value)\n                        for key, value in schema['$defs'].items()\n                    }\n                else:\n                    schema[key] = self.remap_json_schema(value)\n        return schema\n\n\nclass GenerateJsonSchema:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json_schema/#customizing-the-json-schema-generation-process\n\n    A class for generating JSON schemas.\n\n    This class generates JSON schemas based on configured parameters. The default schema dialect\n    is [https://json-schema.org/draft/2020-12/schema](https://json-schema.org/draft/2020-12/schema).\n    The class uses `by_alias` to configure how fields with\n    multiple names are handled and `ref_template` to format reference names.\n\n    Attributes:\n        schema_dialect: The JSON schema dialect used to generate the schema. See\n            [Declaring a Dialect](https://json-schema.org/understanding-json-schema/reference/schema.html#id4)\n            in the JSON Schema documentation for more information about dialects.\n        ignored_warning_kinds: Warnings to ignore when generating the schema. `self.render_warning_message` will\n            do nothing if its argument `kind` is in `ignored_warning_kinds`;\n            this value can be modified on subclasses to easily control which warnings are emitted.\n        by_alias: Whether to use field aliases when generating the schema.\n        ref_template: The format string used when generating reference names.\n        core_to_json_refs: A mapping of core refs to JSON refs.\n        core_to_defs_refs: A mapping of core refs to definition refs.\n        defs_to_core_refs: A mapping of definition refs to core refs.\n        json_to_defs_refs: A mapping of JSON refs to definition refs.\n        definitions: Definitions in the schema.\n\n    Args:\n        by_alias: Whether to use field aliases in the generated schemas.\n        ref_template: The format string to use when generating reference names.\n\n    Raises:\n        JsonSchemaError: If the instance of the class is inadvertently re-used after generating a schema.\n    \"\"\"\n\n    schema_dialect = 'https://json-schema.org/draft/2020-12/schema'\n\n    # `self.render_warning_message` will do nothing if its argument `kind` is in `ignored_warning_kinds`;\n    # this value can be modified on subclasses to easily control which warnings are emitted\n    ignored_warning_kinds: set[JsonSchemaWarningKind] = {'skipped-choice'}\n\n    def __init__(self, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE):\n        self.by_alias = by_alias\n        self.ref_template = ref_template\n\n        self.core_to_json_refs: dict[CoreModeRef, JsonRef] = {}\n        self.core_to_defs_refs: dict[CoreModeRef, DefsRef] = {}\n        self.defs_to_core_refs: dict[DefsRef, CoreModeRef] = {}\n        self.json_to_defs_refs: dict[JsonRef, DefsRef] = {}\n\n        self.definitions: dict[DefsRef, JsonSchemaValue] = {}\n        self._config_wrapper_stack = _config.ConfigWrapperStack(_config.ConfigWrapper({}))\n\n        self._mode: JsonSchemaMode = 'validation'\n\n        # The following includes a mapping of a fully-unique defs ref choice to a list of preferred\n        # alternatives, which are generally simpler, such as only including the class name.\n        # At the end of schema generation, we use these to produce a JSON schema with more human-readable\n        # definitions, which would also work better in a generated OpenAPI client, etc.\n        self._prioritized_defsref_choices: dict[DefsRef, list[DefsRef]] = {}\n        self._collision_counter: dict[str, int] = defaultdict(int)\n        self._collision_index: dict[str, int] = {}\n\n        self._schema_type_to_method = self.build_schema_type_to_method()\n\n        # When we encounter definitions we need to try to build them immediately\n        # so that they are available schemas that reference them\n        # But it's possible that CoreSchema was never going to be used\n        # (e.g. because the CoreSchema that references short circuits is JSON schema generation without needing\n        #  the reference) so instead of failing altogether if we can't build a definition we\n        # store the error raised and re-throw it if we end up needing that def\n        self._core_defs_invalid_for_json_schema: dict[DefsRef, PydanticInvalidForJsonSchema] = {}\n\n        # This changes to True after generating a schema, to prevent issues caused by accidental re-use\n        # of a single instance of a schema generator\n        self._used = False\n\n    @property\n    def _config(self) -> _config.ConfigWrapper:\n        return self._config_wrapper_stack.tail\n\n    @property\n    def mode(self) -> JsonSchemaMode:\n        if self._config.json_schema_mode_override is not None:\n            return self._config.json_schema_mode_override\n        else:\n            return self._mode\n\n    def build_schema_type_to_method(\n        self,\n    ) -> dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]]:\n        \"\"\"Builds a dictionary mapping fields to methods for generating JSON schemas.\n\n        Returns:\n            A dictionary containing the mapping of `CoreSchemaOrFieldType` to a handler method.\n\n        Raises:\n            TypeError: If no method has been defined for generating a JSON schema for a given pydantic core schema type.\n        \"\"\"\n        mapping: dict[CoreSchemaOrFieldType, Callable[[CoreSchemaOrField], JsonSchemaValue]] = {}\n        core_schema_types: list[CoreSchemaOrFieldType] = _typing_extra.all_literal_values(\n            CoreSchemaOrFieldType  # type: ignore\n        )\n        for key in core_schema_types:\n            method_name = f\"{key.replace('-', '_')}_schema\"\n            try:\n                mapping[key] = getattr(self, method_name)\n            except AttributeError as e:  # pragma: no cover\n                raise TypeError(\n                    f'No method for generating JsonSchema for core_schema.type={key!r} '\n                    f'(expected: {type(self).__name__}.{method_name})'\n                ) from e\n        return mapping\n\n    def generate_definitions(\n        self, inputs: Sequence[tuple[JsonSchemaKeyT, JsonSchemaMode, core_schema.CoreSchema]]\n    ) -> tuple[dict[tuple[JsonSchemaKeyT, JsonSchemaMode], JsonSchemaValue], dict[DefsRef, JsonSchemaValue]]:\n        \"\"\"Generates JSON schema definitions from a list of core schemas, pairing the generated definitions with a\n        mapping that links the input keys to the definition references.\n\n        Args:\n            inputs: A sequence of tuples, where:\n\n                - The first element is a JSON schema key type.\n                - The second element is the JSON mode: either 'validation' or 'serialization'.\n                - The third element is a core schema.\n\n        Returns:\n            A tuple where:\n\n                - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                    whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                    JsonRef references to definitions that are defined in the second returned element.)\n                - The second element is a dictionary whose keys are definition references for the JSON schemas\n                    from the first returned element, and whose values are the actual JSON schema definitions.\n\n        Raises:\n            PydanticUserError: Raised if the JSON schema generator has already been used to generate a JSON schema.\n        \"\"\"\n        if self._used:\n            raise PydanticUserError(\n                'This JSON schema generator has already been used to generate a JSON schema. '\n                f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',\n                code='json-schema-already-used',\n            )\n\n        for key, mode, schema in inputs:\n            self._mode = mode\n            self.generate_inner(schema)\n\n        definitions_remapping = self._build_definitions_remapping()\n\n        json_schemas_map: dict[tuple[JsonSchemaKeyT, JsonSchemaMode], DefsRef] = {}\n        for key, mode, schema in inputs:\n            self._mode = mode\n            json_schema = self.generate_inner(schema)\n            json_schemas_map[(key, mode)] = definitions_remapping.remap_json_schema(json_schema)\n\n        json_schema = {'$defs': self.definitions}\n        json_schema = definitions_remapping.remap_json_schema(json_schema)\n        self._used = True\n        return json_schemas_map, _sort_json_schema(json_schema['$defs'])  # type: ignore\n\n    def generate(self, schema: CoreSchema, mode: JsonSchemaMode = 'validation') -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema for a specified schema in a specified mode.\n\n        Args:\n            schema: A Pydantic model.\n            mode: The mode in which to generate the schema. Defaults to 'validation'.\n\n        Returns:\n            A JSON schema representing the specified schema.\n\n        Raises:\n            PydanticUserError: If the JSON schema generator has already been used to generate a JSON schema.\n        \"\"\"\n        self._mode = mode\n        if self._used:\n            raise PydanticUserError(\n                'This JSON schema generator has already been used to generate a JSON schema. '\n                f'You must create a new instance of {type(self).__name__} to generate a new JSON schema.',\n                code='json-schema-already-used',\n            )\n\n        json_schema: JsonSchemaValue = self.generate_inner(schema)\n        json_ref_counts = self.get_json_ref_counts(json_schema)\n\n        # Remove the top-level $ref if present; note that the _generate method already ensures there are no sibling keys\n        ref = cast(JsonRef, json_schema.get('$ref'))\n        while ref is not None:  # may need to unpack multiple levels\n            ref_json_schema = self.get_schema_from_definitions(ref)\n            if json_ref_counts[ref] > 1 or ref_json_schema is None:\n                # Keep the ref, but use an allOf to remove the top level $ref\n                json_schema = {'allOf': [{'$ref': ref}]}\n            else:\n                # \"Unpack\" the ref since this is the only reference\n                json_schema = ref_json_schema.copy()  # copy to prevent recursive dict reference\n                json_ref_counts[ref] -= 1\n            ref = cast(JsonRef, json_schema.get('$ref'))\n\n        self._garbage_collect_definitions(json_schema)\n        definitions_remapping = self._build_definitions_remapping()\n\n        if self.definitions:\n            json_schema['$defs'] = self.definitions\n\n        json_schema = definitions_remapping.remap_json_schema(json_schema)\n\n        # For now, we will not set the $schema key. However, if desired, this can be easily added by overriding\n        # this method and adding the following line after a call to super().generate(schema):\n        # json_schema['$schema'] = self.schema_dialect\n\n        self._used = True\n        return _sort_json_schema(json_schema)\n\n    def generate_inner(self, schema: CoreSchemaOrField) -> JsonSchemaValue:  # noqa: C901\n        \"\"\"Generates a JSON schema for a given core schema.\n\n        Args:\n            schema: The given core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        # If a schema with the same CoreRef has been handled, just return a reference to it\n        # Note that this assumes that it will _never_ be the case that the same CoreRef is used\n        # on types that should have different JSON schemas\n        if 'ref' in schema:\n            core_ref = CoreRef(schema['ref'])  # type: ignore[typeddict-item]\n            core_mode_ref = (core_ref, self.mode)\n            if core_mode_ref in self.core_to_defs_refs and self.core_to_defs_refs[core_mode_ref] in self.definitions:\n                return {'$ref': self.core_to_json_refs[core_mode_ref]}\n\n        # Generate the JSON schema, accounting for the json_schema_override and core_schema_override\n        metadata_handler = _core_metadata.CoreMetadataHandler(schema)\n\n        def populate_defs(core_schema: CoreSchema, json_schema: JsonSchemaValue) -> JsonSchemaValue:\n            if 'ref' in core_schema:\n                core_ref = CoreRef(core_schema['ref'])  # type: ignore[typeddict-item]\n                defs_ref, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)\n                json_ref = JsonRef(ref_json_schema['$ref'])\n                self.json_to_defs_refs[json_ref] = defs_ref\n                # Replace the schema if it's not a reference to itself\n                # What we want to avoid is having the def be just a ref to itself\n                # which is what would happen if we blindly assigned any\n                if json_schema.get('$ref', None) != json_ref:\n                    self.definitions[defs_ref] = json_schema\n                    self._core_defs_invalid_for_json_schema.pop(defs_ref, None)\n                json_schema = ref_json_schema\n            return json_schema\n\n        def convert_to_all_of(json_schema: JsonSchemaValue) -> JsonSchemaValue:\n            if '$ref' in json_schema and len(json_schema.keys()) > 1:\n                # technically you can't have any other keys next to a \"$ref\"\n                # but it's an easy mistake to make and not hard to correct automatically here\n                json_schema = json_schema.copy()\n                ref = json_schema.pop('$ref')\n                json_schema = {'allOf': [{'$ref': ref}], **json_schema}\n            return json_schema\n\n        def handler_func(schema_or_field: CoreSchemaOrField) -> JsonSchemaValue:\n            \"\"\"Generate a JSON schema based on the input schema.\n\n            Args:\n                schema_or_field: The core schema to generate a JSON schema from.\n\n            Returns:\n                The generated JSON schema.\n\n            Raises:\n                TypeError: If an unexpected schema type is encountered.\n            \"\"\"\n            # Generate the core-schema-type-specific bits of the schema generation:\n            json_schema: JsonSchemaValue | None = None\n            if self.mode == 'serialization' and 'serialization' in schema_or_field:\n                ser_schema = schema_or_field['serialization']  # type: ignore\n                json_schema = self.ser_schema(ser_schema)\n            if json_schema is None:\n                if _core_utils.is_core_schema(schema_or_field) or _core_utils.is_core_schema_field(schema_or_field):\n                    generate_for_schema_type = self._schema_type_to_method[schema_or_field['type']]\n                    json_schema = generate_for_schema_type(schema_or_field)\n                else:\n                    raise TypeError(f'Unexpected schema type: schema={schema_or_field}')\n            if _core_utils.is_core_schema(schema_or_field):\n                json_schema = populate_defs(schema_or_field, json_schema)\n                json_schema = convert_to_all_of(json_schema)\n            return json_schema\n\n        current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, handler_func)\n\n        for js_modify_function in metadata_handler.metadata.get('pydantic_js_functions', ()):\n\n            def new_handler_func(\n                schema_or_field: CoreSchemaOrField,\n                current_handler: GetJsonSchemaHandler = current_handler,\n                js_modify_function: GetJsonSchemaFunction = js_modify_function,\n            ) -> JsonSchemaValue:\n                json_schema = js_modify_function(schema_or_field, current_handler)\n                if _core_utils.is_core_schema(schema_or_field):\n                    json_schema = populate_defs(schema_or_field, json_schema)\n                original_schema = current_handler.resolve_ref_schema(json_schema)\n                ref = json_schema.pop('$ref', None)\n                if ref and json_schema:\n                    original_schema.update(json_schema)\n                return original_schema\n\n            current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)\n\n        for js_modify_function in metadata_handler.metadata.get('pydantic_js_annotation_functions', ()):\n\n            def new_handler_func(\n                schema_or_field: CoreSchemaOrField,\n                current_handler: GetJsonSchemaHandler = current_handler,\n                js_modify_function: GetJsonSchemaFunction = js_modify_function,\n            ) -> JsonSchemaValue:\n                json_schema = js_modify_function(schema_or_field, current_handler)\n                if _core_utils.is_core_schema(schema_or_field):\n                    json_schema = populate_defs(schema_or_field, json_schema)\n                    json_schema = convert_to_all_of(json_schema)\n                return json_schema\n\n            current_handler = _schema_generation_shared.GenerateJsonSchemaHandler(self, new_handler_func)\n\n        json_schema = current_handler(schema)\n        if _core_utils.is_core_schema(schema):\n            json_schema = populate_defs(schema, json_schema)\n            json_schema = convert_to_all_of(json_schema)\n        return json_schema\n\n    # ### Schema generation methods\n    def any_schema(self, schema: core_schema.AnySchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches any value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {}\n\n    def none_schema(self, schema: core_schema.NoneSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches `None`.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {'type': 'null'}\n\n    def bool_schema(self, schema: core_schema.BoolSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a bool value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {'type': 'boolean'}\n\n    def int_schema(self, schema: core_schema.IntSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches an int value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema: dict[str, Any] = {'type': 'integer'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n        json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}\n        return json_schema\n\n    def float_schema(self, schema: core_schema.FloatSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a float value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema: dict[str, Any] = {'type': 'number'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.numeric)\n        json_schema = {k: v for k, v in json_schema.items() if v not in {math.inf, -math.inf}}\n        return json_schema\n\n    def decimal_schema(self, schema: core_schema.DecimalSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a decimal value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = self.str_schema(core_schema.str_schema())\n        if self.mode == 'validation':\n            multiple_of = schema.get('multiple_of')\n            le = schema.get('le')\n            ge = schema.get('ge')\n            lt = schema.get('lt')\n            gt = schema.get('gt')\n            json_schema = {\n                'anyOf': [\n                    self.float_schema(\n                        core_schema.float_schema(\n                            allow_inf_nan=schema.get('allow_inf_nan'),\n                            multiple_of=None if multiple_of is None else float(multiple_of),\n                            le=None if le is None else float(le),\n                            ge=None if ge is None else float(ge),\n                            lt=None if lt is None else float(lt),\n                            gt=None if gt is None else float(gt),\n                        )\n                    ),\n                    json_schema,\n                ],\n            }\n        return json_schema\n\n    def str_schema(self, schema: core_schema.StringSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a string value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = {'type': 'string'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n        if isinstance(json_schema.get('pattern'), Pattern):\n            # TODO: should we add regex flags to the pattern?\n            json_schema['pattern'] = json_schema.get('pattern').pattern  # type: ignore\n        return json_schema\n\n    def bytes_schema(self, schema: core_schema.BytesSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a bytes value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = {'type': 'string', 'format': 'base64url' if self._config.ser_json_bytes == 'base64' else 'binary'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.bytes)\n        return json_schema\n\n    def date_schema(self, schema: core_schema.DateSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a date value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = {'type': 'string', 'format': 'date'}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.date)\n        return json_schema\n\n    def time_schema(self, schema: core_schema.TimeSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a time value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {'type': 'string', 'format': 'time'}\n\n    def datetime_schema(self, schema: core_schema.DatetimeSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a datetime value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {'type': 'string', 'format': 'date-time'}\n\n    def timedelta_schema(self, schema: core_schema.TimedeltaSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a timedelta value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        if self._config.ser_json_timedelta == 'float':\n            return {'type': 'number'}\n        return {'type': 'string', 'format': 'duration'}\n\n    def literal_schema(self, schema: core_schema.LiteralSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a literal value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        expected = [v.value if isinstance(v, Enum) else v for v in schema['expected']]\n        # jsonify the expected values\n        expected = [to_jsonable_python(v) for v in expected]\n\n        result: dict[str, Any] = {'enum': expected}\n        if len(expected) == 1:\n            result['const'] = expected[0]\n\n        types = {type(e) for e in expected}\n        if types == {str}:\n            result['type'] = 'string'\n        elif types == {int}:\n            result['type'] = 'integer'\n        elif types == {float}:\n            result['type'] = 'numeric'\n        elif types == {bool}:\n            result['type'] = 'boolean'\n        elif types == {list}:\n            result['type'] = 'array'\n        elif types == {type(None)}:\n            result['type'] = 'null'\n        return result\n\n    def enum_schema(self, schema: core_schema.EnumSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches an Enum value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        enum_type = schema['cls']\n        description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)\n        if (\n            description == 'An enumeration.'\n        ):  # This is the default value provided by enum.EnumMeta.__new__; don't use it\n            description = None\n        result: dict[str, Any] = {'title': enum_type.__name__, 'description': description}\n        result = {k: v for k, v in result.items() if v is not None}\n\n        expected = [to_jsonable_python(v.value) for v in schema['members']]\n\n        result['enum'] = expected\n        if len(expected) == 1:\n            result['const'] = expected[0]\n\n        types = {type(e) for e in expected}\n        if isinstance(enum_type, str) or types == {str}:\n            result['type'] = 'string'\n        elif isinstance(enum_type, int) or types == {int}:\n            result['type'] = 'integer'\n        elif isinstance(enum_type, float) or types == {float}:\n            result['type'] = 'numeric'\n        elif types == {bool}:\n            result['type'] = 'boolean'\n        elif types == {list}:\n            result['type'] = 'array'\n\n        return result\n\n    def is_instance_schema(self, schema: core_schema.IsInstanceSchema) -> JsonSchemaValue:\n        \"\"\"Handles JSON schema generation for a core schema that checks if a value is an instance of a class.\n\n        Unless overridden in a subclass, this raises an error.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.handle_invalid_for_json_schema(schema, f'core_schema.IsInstanceSchema ({schema[\"cls\"]})')\n\n    def is_subclass_schema(self, schema: core_schema.IsSubclassSchema) -> JsonSchemaValue:\n        \"\"\"Handles JSON schema generation for a core schema that checks if a value is a subclass of a class.\n\n        For backwards compatibility with v1, this does not raise an error, but can be overridden to change this.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        # Note: This is for compatibility with V1; you can override if you want different behavior.\n        return {}\n\n    def callable_schema(self, schema: core_schema.CallableSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a callable value.\n\n        Unless overridden in a subclass, this raises an error.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.handle_invalid_for_json_schema(schema, 'core_schema.CallableSchema')\n\n    def list_schema(self, schema: core_schema.ListSchema) -> JsonSchemaValue:\n        \"\"\"Returns a schema that matches a list schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n        json_schema = {'type': 'array', 'items': items_schema}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n        return json_schema\n\n    @deprecated('`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.', category=None)\n    @final\n    def tuple_positional_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:\n        \"\"\"Replaced by `tuple_schema`.\"\"\"\n        warnings.warn(\n            '`tuple_positional_schema` is deprecated. Use `tuple_schema` instead.',\n            PydanticDeprecatedSince26,\n            stacklevel=2,\n        )\n        return self.tuple_schema(schema)\n\n    @deprecated('`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.', category=None)\n    @final\n    def tuple_variable_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:\n        \"\"\"Replaced by `tuple_schema`.\"\"\"\n        warnings.warn(\n            '`tuple_variable_schema` is deprecated. Use `tuple_schema` instead.',\n            PydanticDeprecatedSince26,\n            stacklevel=2,\n        )\n        return self.tuple_schema(schema)\n\n    def tuple_schema(self, schema: core_schema.TupleSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a tuple schema e.g. `Tuple[int,\n        str, bool]` or `Tuple[int, ...]`.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema: JsonSchemaValue = {'type': 'array'}\n        if 'variadic_item_index' in schema:\n            variadic_item_index = schema['variadic_item_index']\n            if variadic_item_index > 0:\n                json_schema['minItems'] = variadic_item_index\n                json_schema['prefixItems'] = [\n                    self.generate_inner(item) for item in schema['items_schema'][:variadic_item_index]\n                ]\n            if variadic_item_index + 1 == len(schema['items_schema']):\n                # if the variadic item is the last item, then represent it faithfully\n                json_schema['items'] = self.generate_inner(schema['items_schema'][variadic_item_index])\n            else:\n                # otherwise, 'items' represents the schema for the variadic\n                # item plus the suffix, so just allow anything for simplicity\n                # for now\n                json_schema['items'] = True\n        else:\n            prefixItems = [self.generate_inner(item) for item in schema['items_schema']]\n            if prefixItems:\n                json_schema['prefixItems'] = prefixItems\n            json_schema['minItems'] = len(prefixItems)\n            json_schema['maxItems'] = len(prefixItems)\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n        return json_schema\n\n    def set_schema(self, schema: core_schema.SetSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a set schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._common_set_schema(schema)\n\n    def frozenset_schema(self, schema: core_schema.FrozenSetSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a frozenset schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._common_set_schema(schema)\n\n    def _common_set_schema(self, schema: core_schema.SetSchema | core_schema.FrozenSetSchema) -> JsonSchemaValue:\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n        json_schema = {'type': 'array', 'uniqueItems': True, 'items': items_schema}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n        return json_schema\n\n    def generator_schema(self, schema: core_schema.GeneratorSchema) -> JsonSchemaValue:\n        \"\"\"Returns a JSON schema that represents the provided GeneratorSchema.\n\n        Args:\n            schema: The schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        items_schema = {} if 'items_schema' not in schema else self.generate_inner(schema['items_schema'])\n        json_schema = {'type': 'array', 'items': items_schema}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.array)\n        return json_schema\n\n    def dict_schema(self, schema: core_schema.DictSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a dict schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema: JsonSchemaValue = {'type': 'object'}\n\n        keys_schema = self.generate_inner(schema['keys_schema']).copy() if 'keys_schema' in schema else {}\n        keys_pattern = keys_schema.pop('pattern', None)\n\n        values_schema = self.generate_inner(schema['values_schema']).copy() if 'values_schema' in schema else {}\n        values_schema.pop('title', None)  # don't give a title to the additionalProperties\n        if values_schema or keys_pattern is not None:  # don't add additionalProperties if it's empty\n            if keys_pattern is None:\n                json_schema['additionalProperties'] = values_schema\n            else:\n                json_schema['patternProperties'] = {keys_pattern: values_schema}\n\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.object)\n        return json_schema\n\n    def _function_schema(\n        self,\n        schema: _core_utils.AnyFunctionSchema,\n    ) -> JsonSchemaValue:\n        if _core_utils.is_function_with_inner_schema(schema):\n            # This could be wrong if the function's mode is 'before', but in practice will often be right, and when it\n            # isn't, I think it would be hard to automatically infer what the desired schema should be.\n            return self.generate_inner(schema['schema'])\n\n        # function-plain\n        return self.handle_invalid_for_json_schema(\n            schema, f'core_schema.PlainValidatorFunctionSchema ({schema[\"function\"]})'\n        )\n\n    def function_before_schema(self, schema: core_schema.BeforeValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a function-before schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._function_schema(schema)\n\n    def function_after_schema(self, schema: core_schema.AfterValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a function-after schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._function_schema(schema)\n\n    def function_plain_schema(self, schema: core_schema.PlainValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a function-plain schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._function_schema(schema)\n\n    def function_wrap_schema(self, schema: core_schema.WrapValidatorFunctionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a function-wrap schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self._function_schema(schema)\n\n    def default_schema(self, schema: core_schema.WithDefaultSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema with a default value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = self.generate_inner(schema['schema'])\n\n        if 'default' not in schema:\n            return json_schema\n        default = schema['default']\n        # Note: if you want to include the value returned by the default_factory,\n        # override this method and replace the code above with:\n        # if 'default' in schema:\n        #     default = schema['default']\n        # elif 'default_factory' in schema:\n        #     default = schema['default_factory']()\n        # else:\n        #     return json_schema\n\n        # we reflect the application of custom plain, no-info serializers to defaults for\n        # json schemas viewed in serialization mode\n        # TODO: improvements along with https://github.com/pydantic/pydantic/issues/8208\n        # TODO: improve type safety here\n        if self.mode == 'serialization':\n            if (\n                (ser_schema := schema['schema'].get('serialization', {}))\n                and (ser_func := ser_schema.get('function'))\n                and ser_schema.get('type') == 'function-plain'  # type: ignore\n                and ser_schema.get('info_arg') is False  # type: ignore\n            ):\n                default = ser_func(default)  # type: ignore\n\n        try:\n            encoded_default = self.encode_default(default)\n        except pydantic_core.PydanticSerializationError:\n            self.emit_warning(\n                'non-serializable-default',\n                f'Default value {default} is not JSON serializable; excluding default from JSON schema',\n            )\n            # Return the inner schema, as though there was no default\n            return json_schema\n\n        if '$ref' in json_schema:\n            # Since reference schemas do not support child keys, we wrap the reference schema in a single-case allOf:\n            return {'allOf': [json_schema], 'default': encoded_default}\n        else:\n            json_schema['default'] = encoded_default\n            return json_schema\n\n    def nullable_schema(self, schema: core_schema.NullableSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that allows null values.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        null_schema = {'type': 'null'}\n        inner_json_schema = self.generate_inner(schema['schema'])\n\n        if inner_json_schema == null_schema:\n            return null_schema\n        else:\n            # Thanks to the equality check against `null_schema` above, I think 'oneOf' would also be valid here;\n            # I'll use 'anyOf' for now, but it could be changed it if it would work better with some external tooling\n            return self.get_flattened_anyof([inner_json_schema, null_schema])\n\n    def union_schema(self, schema: core_schema.UnionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        generated: list[JsonSchemaValue] = []\n\n        choices = schema['choices']\n        for choice in choices:\n            # choice will be a tuple if an explicit label was provided\n            choice_schema = choice[0] if isinstance(choice, tuple) else choice\n            try:\n                generated.append(self.generate_inner(choice_schema))\n            except PydanticOmit:\n                continue\n            except PydanticInvalidForJsonSchema as exc:\n                self.emit_warning('skipped-choice', exc.message)\n        if len(generated) == 1:\n            return generated[0]\n        return self.get_flattened_anyof(generated)\n\n    def tagged_union_schema(self, schema: core_schema.TaggedUnionSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that allows values matching any of the given schemas, where\n        the schemas are tagged with a discriminator field that indicates which schema should be used to validate\n        the value.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        generated: dict[str, JsonSchemaValue] = {}\n        for k, v in schema['choices'].items():\n            if isinstance(k, Enum):\n                k = k.value\n            try:\n                # Use str(k) since keys must be strings for json; while not technically correct,\n                # it's the closest that can be represented in valid JSON\n                generated[str(k)] = self.generate_inner(v).copy()\n            except PydanticOmit:\n                continue\n            except PydanticInvalidForJsonSchema as exc:\n                self.emit_warning('skipped-choice', exc.message)\n\n        one_of_choices = _deduplicate_schemas(generated.values())\n        json_schema: JsonSchemaValue = {'oneOf': one_of_choices}\n\n        # This reflects the v1 behavior; TODO: we should make it possible to exclude OpenAPI stuff from the JSON schema\n        openapi_discriminator = self._extract_discriminator(schema, one_of_choices)\n        if openapi_discriminator is not None:\n            json_schema['discriminator'] = {\n                'propertyName': openapi_discriminator,\n                'mapping': {k: v.get('$ref', v) for k, v in generated.items()},\n            }\n\n        return json_schema\n\n    def _extract_discriminator(\n        self, schema: core_schema.TaggedUnionSchema, one_of_choices: list[JsonDict]\n    ) -> str | None:\n        \"\"\"Extract a compatible OpenAPI discriminator from the schema and one_of choices that end up in the final\n        schema.\"\"\"\n        openapi_discriminator: str | None = None\n\n        if isinstance(schema['discriminator'], str):\n            return schema['discriminator']\n\n        if isinstance(schema['discriminator'], list):\n            # If the discriminator is a single item list containing a string, that is equivalent to the string case\n            if len(schema['discriminator']) == 1 and isinstance(schema['discriminator'][0], str):\n                return schema['discriminator'][0]\n            # When an alias is used that is different from the field name, the discriminator will be a list of single\n            # str lists, one for the attribute and one for the actual alias. The logic here will work even if there is\n            # more than one possible attribute, and looks for whether a single alias choice is present as a documented\n            # property on all choices. If so, that property will be used as the OpenAPI discriminator.\n            for alias_path in schema['discriminator']:\n                if not isinstance(alias_path, list):\n                    break  # this means that the discriminator is not a list of alias paths\n                if len(alias_path) != 1:\n                    continue  # this means that the \"alias\" does not represent a single field\n                alias = alias_path[0]\n                if not isinstance(alias, str):\n                    continue  # this means that the \"alias\" does not represent a field\n                alias_is_present_on_all_choices = True\n                for choice in one_of_choices:\n                    while '$ref' in choice:\n                        assert isinstance(choice['$ref'], str)\n                        choice = self.get_schema_from_definitions(JsonRef(choice['$ref'])) or {}\n                    properties = choice.get('properties', {})\n                    if not isinstance(properties, dict) or alias not in properties:\n                        alias_is_present_on_all_choices = False\n                        break\n                if alias_is_present_on_all_choices:\n                    openapi_discriminator = alias\n                    break\n        return openapi_discriminator\n\n    def chain_schema(self, schema: core_schema.ChainSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a core_schema.ChainSchema.\n\n        When generating a schema for validation, we return the validation JSON schema for the first step in the chain.\n        For serialization, we return the serialization JSON schema for the last step in the chain.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        step_index = 0 if self.mode == 'validation' else -1  # use first step for validation, last for serialization\n        return self.generate_inner(schema['steps'][step_index])\n\n    def lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that allows values matching either the lax schema or the\n        strict schema.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        # TODO: Need to read the default value off of model config or whatever\n        use_strict = schema.get('strict', False)  # TODO: replace this default False\n        # If your JSON schema fails to generate it is probably\n        # because one of the following two branches failed.\n        if use_strict:\n            return self.generate_inner(schema['strict_schema'])\n        else:\n            return self.generate_inner(schema['lax_schema'])\n\n    def json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that allows values matching either the JSON schema or the\n        Python schema.\n\n        The JSON schema is used instead of the Python schema. If you want to use the Python schema, you should override\n        this method.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['json_schema'])\n\n    def typed_dict_schema(self, schema: core_schema.TypedDictSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a typed dict.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        total = schema.get('total', True)\n        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n            (name, self.field_is_required(field, total), field)\n            for name, field in schema['fields'].items()\n            if self.field_is_present(field)\n        ]\n        if self.mode == 'serialization':\n            named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n        cls = _get_typed_dict_cls(schema)\n        config = _get_typed_dict_config(cls)\n        with self._config_wrapper_stack.push(config):\n            json_schema = self._named_required_fields_schema(named_required_fields)\n\n        json_schema_extra = config.get('json_schema_extra')\n        extra = schema.get('extra_behavior')\n        if extra is None:\n            extra = config.get('extra', 'ignore')\n\n        if cls is not None:\n            title = config.get('title') or cls.__name__\n            json_schema = self._update_class_schema(json_schema, title, extra, cls, json_schema_extra)\n        else:\n            if extra == 'forbid':\n                json_schema['additionalProperties'] = False\n            elif extra == 'allow':\n                json_schema['additionalProperties'] = True\n\n        return json_schema\n\n    @staticmethod\n    def _name_required_computed_fields(\n        computed_fields: list[ComputedField],\n    ) -> list[tuple[str, bool, core_schema.ComputedField]]:\n        return [(field['property_name'], True, field) for field in computed_fields]\n\n    def _named_required_fields_schema(\n        self, named_required_fields: Sequence[tuple[str, bool, CoreSchemaField]]\n    ) -> JsonSchemaValue:\n        properties: dict[str, JsonSchemaValue] = {}\n        required_fields: list[str] = []\n        for name, required, field in named_required_fields:\n            if self.by_alias:\n                name = self._get_alias_name(field, name)\n            try:\n                field_json_schema = self.generate_inner(field).copy()\n            except PydanticOmit:\n                continue\n            if 'title' not in field_json_schema and self.field_title_should_be_set(field):\n                title = self.get_title_from_name(name)\n                field_json_schema['title'] = title\n            field_json_schema = self.handle_ref_overrides(field_json_schema)\n            properties[name] = field_json_schema\n            if required:\n                required_fields.append(name)\n\n        json_schema = {'type': 'object', 'properties': properties}\n        if required_fields:\n            json_schema['required'] = required_fields\n        return json_schema\n\n    def _get_alias_name(self, field: CoreSchemaField, name: str) -> str:\n        if field['type'] == 'computed-field':\n            alias: Any = field.get('alias', name)\n        elif self.mode == 'validation':\n            alias = field.get('validation_alias', name)\n        else:\n            alias = field.get('serialization_alias', name)\n        if isinstance(alias, str):\n            name = alias\n        elif isinstance(alias, list):\n            alias = cast('list[str] | str', alias)\n            for path in alias:\n                if isinstance(path, list) and len(path) == 1 and isinstance(path[0], str):\n                    # Use the first valid single-item string path; the code that constructs the alias array\n                    # should ensure the first such item is what belongs in the JSON schema\n                    name = path[0]\n                    break\n        else:\n            assert_never(alias)\n        return name\n\n    def typed_dict_field_schema(self, schema: core_schema.TypedDictField) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a typed dict field.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def dataclass_field_schema(self, schema: core_schema.DataclassField) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a dataclass field.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def model_field_schema(self, schema: core_schema.ModelField) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a model field.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def computed_field_schema(self, schema: core_schema.ComputedField) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a computed field.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['return_schema'])\n\n    def model_schema(self, schema: core_schema.ModelSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a model.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        # We do not use schema['model'].model_json_schema() here\n        # because it could lead to inconsistent refs handling, etc.\n        cls = cast('type[BaseModel]', schema['cls'])\n        config = cls.model_config\n        title = config.get('title')\n\n        with self._config_wrapper_stack.push(config):\n            json_schema = self.generate_inner(schema['schema'])\n\n        json_schema_extra = config.get('json_schema_extra')\n        if cls.__pydantic_root_model__:\n            root_json_schema_extra = cls.model_fields['root'].json_schema_extra\n            if json_schema_extra and root_json_schema_extra:\n                raise ValueError(\n                    '\"model_config[\\'json_schema_extra\\']\" and \"Field.json_schema_extra\" on \"RootModel.root\"'\n                    ' field must not be set simultaneously'\n                )\n            if root_json_schema_extra:\n                json_schema_extra = root_json_schema_extra\n\n        json_schema = self._update_class_schema(json_schema, title, config.get('extra', None), cls, json_schema_extra)\n\n        return json_schema\n\n    def _update_class_schema(\n        self,\n        json_schema: JsonSchemaValue,\n        title: str | None,\n        extra: Literal['allow', 'ignore', 'forbid'] | None,\n        cls: type[Any],\n        json_schema_extra: JsonDict | JsonSchemaExtraCallable | None,\n    ) -> JsonSchemaValue:\n        if '$ref' in json_schema:\n            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref'])) or json_schema\n        else:\n            schema_to_update = json_schema\n\n        if title is not None:\n            # referenced_schema['title'] = title\n            schema_to_update.setdefault('title', title)\n\n        if 'additionalProperties' not in schema_to_update:\n            if extra == 'allow':\n                schema_to_update['additionalProperties'] = True\n            elif extra == 'forbid':\n                schema_to_update['additionalProperties'] = False\n\n        if isinstance(json_schema_extra, (staticmethod, classmethod)):\n            # In older versions of python, this is necessary to ensure staticmethod/classmethods are callable\n            json_schema_extra = json_schema_extra.__get__(cls)\n\n        if isinstance(json_schema_extra, dict):\n            schema_to_update.update(json_schema_extra)\n        elif callable(json_schema_extra):\n            if len(inspect.signature(json_schema_extra).parameters) > 1:\n                json_schema_extra(schema_to_update, cls)  # type: ignore\n            else:\n                json_schema_extra(schema_to_update)  # type: ignore\n        elif json_schema_extra is not None:\n            raise ValueError(\n                f\"model_config['json_schema_extra']={json_schema_extra} should be a dict, callable, or None\"\n            )\n\n        if hasattr(cls, '__deprecated__'):\n            json_schema['deprecated'] = True\n\n        return json_schema\n\n    def resolve_schema_to_update(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:\n        \"\"\"Resolve a JsonSchemaValue to the non-ref schema if it is a $ref schema.\n\n        Args:\n            json_schema: The schema to resolve.\n\n        Returns:\n            The resolved schema.\n        \"\"\"\n        if '$ref' in json_schema:\n            schema_to_update = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))\n            if schema_to_update is None:\n                raise RuntimeError(f'Cannot update undefined schema for $ref={json_schema[\"$ref\"]}')\n            return self.resolve_schema_to_update(schema_to_update)\n        else:\n            schema_to_update = json_schema\n        return schema_to_update\n\n    def model_fields_schema(self, schema: core_schema.ModelFieldsSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a model's fields.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n            (name, self.field_is_required(field, total=True), field)\n            for name, field in schema['fields'].items()\n            if self.field_is_present(field)\n        ]\n        if self.mode == 'serialization':\n            named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n        json_schema = self._named_required_fields_schema(named_required_fields)\n        extras_schema = schema.get('extras_schema', None)\n        if extras_schema is not None:\n            schema_to_update = self.resolve_schema_to_update(json_schema)\n            schema_to_update['additionalProperties'] = self.generate_inner(extras_schema)\n        return json_schema\n\n    def field_is_present(self, field: CoreSchemaField) -> bool:\n        \"\"\"Whether the field should be included in the generated JSON schema.\n\n        Args:\n            field: The schema for the field itself.\n\n        Returns:\n            `True` if the field should be included in the generated JSON schema, `False` otherwise.\n        \"\"\"\n        if self.mode == 'serialization':\n            # If you still want to include the field in the generated JSON schema,\n            # override this method and return True\n            return not field.get('serialization_exclude')\n        elif self.mode == 'validation':\n            return True\n        else:\n            assert_never(self.mode)\n\n    def field_is_required(\n        self,\n        field: core_schema.ModelField | core_schema.DataclassField | core_schema.TypedDictField,\n        total: bool,\n    ) -> bool:\n        \"\"\"Whether the field should be marked as required in the generated JSON schema.\n        (Note that this is irrelevant if the field is not present in the JSON schema.).\n\n        Args:\n            field: The schema for the field itself.\n            total: Only applies to `TypedDictField`s.\n                Indicates if the `TypedDict` this field belongs to is total, in which case any fields that don't\n                explicitly specify `required=False` are required.\n\n        Returns:\n            `True` if the field should be marked as required in the generated JSON schema, `False` otherwise.\n        \"\"\"\n        if self.mode == 'serialization' and self._config.json_schema_serialization_defaults_required:\n            return not field.get('serialization_exclude')\n        else:\n            if field['type'] == 'typed-dict-field':\n                return field.get('required', total)\n            else:\n                return field['schema']['type'] != 'default'\n\n    def dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a dataclass's constructor arguments.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        named_required_fields: list[tuple[str, bool, CoreSchemaField]] = [\n            (field['name'], self.field_is_required(field, total=True), field)\n            for field in schema['fields']\n            if self.field_is_present(field)\n        ]\n        if self.mode == 'serialization':\n            named_required_fields.extend(self._name_required_computed_fields(schema.get('computed_fields', [])))\n        return self._named_required_fields_schema(named_required_fields)\n\n    def dataclass_schema(self, schema: core_schema.DataclassSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a dataclass.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        cls = schema['cls']\n        config: ConfigDict = getattr(cls, '__pydantic_config__', cast('ConfigDict', {}))\n        title = config.get('title') or cls.__name__\n\n        with self._config_wrapper_stack.push(config):\n            json_schema = self.generate_inner(schema['schema']).copy()\n\n        json_schema_extra = config.get('json_schema_extra')\n        json_schema = self._update_class_schema(json_schema, title, config.get('extra', None), cls, json_schema_extra)\n\n        # Dataclass-specific handling of description\n        if is_dataclass(cls) and not hasattr(cls, '__pydantic_validator__'):\n            # vanilla dataclass; don't use cls.__doc__ as it will contain the class signature by default\n            description = None\n        else:\n            description = None if cls.__doc__ is None else inspect.cleandoc(cls.__doc__)\n        if description:\n            json_schema['description'] = description\n\n        return json_schema\n\n    def arguments_schema(self, schema: core_schema.ArgumentsSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a function's arguments.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        metadata = _core_metadata.CoreMetadataHandler(schema).metadata\n        prefer_positional = metadata.get('pydantic_js_prefer_positional_arguments')\n\n        arguments = schema['arguments_schema']\n        kw_only_arguments = [a for a in arguments if a.get('mode') == 'keyword_only']\n        kw_or_p_arguments = [a for a in arguments if a.get('mode') in {'positional_or_keyword', None}]\n        p_only_arguments = [a for a in arguments if a.get('mode') == 'positional_only']\n        var_args_schema = schema.get('var_args_schema')\n        var_kwargs_schema = schema.get('var_kwargs_schema')\n\n        if prefer_positional:\n            positional_possible = not kw_only_arguments and not var_kwargs_schema\n            if positional_possible:\n                return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)\n\n        keyword_possible = not p_only_arguments and not var_args_schema\n        if keyword_possible:\n            return self.kw_arguments_schema(kw_or_p_arguments + kw_only_arguments, var_kwargs_schema)\n\n        if not prefer_positional:\n            positional_possible = not kw_only_arguments and not var_kwargs_schema\n            if positional_possible:\n                return self.p_arguments_schema(p_only_arguments + kw_or_p_arguments, var_args_schema)\n\n        raise PydanticInvalidForJsonSchema(\n            'Unable to generate JSON schema for arguments validator with positional-only and keyword-only arguments'\n        )\n\n    def kw_arguments_schema(\n        self, arguments: list[core_schema.ArgumentsParameter], var_kwargs_schema: CoreSchema | None\n    ) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a function's keyword arguments.\n\n        Args:\n            arguments: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        properties: dict[str, JsonSchemaValue] = {}\n        required: list[str] = []\n        for argument in arguments:\n            name = self.get_argument_name(argument)\n            argument_schema = self.generate_inner(argument['schema']).copy()\n            argument_schema['title'] = self.get_title_from_name(name)\n            properties[name] = argument_schema\n\n            if argument['schema']['type'] != 'default':\n                # This assumes that if the argument has a default value,\n                # the inner schema must be of type WithDefaultSchema.\n                # I believe this is true, but I am not 100% sure\n                required.append(name)\n\n        json_schema: JsonSchemaValue = {'type': 'object', 'properties': properties}\n        if required:\n            json_schema['required'] = required\n\n        if var_kwargs_schema:\n            additional_properties_schema = self.generate_inner(var_kwargs_schema)\n            if additional_properties_schema:\n                json_schema['additionalProperties'] = additional_properties_schema\n        else:\n            json_schema['additionalProperties'] = False\n        return json_schema\n\n    def p_arguments_schema(\n        self, arguments: list[core_schema.ArgumentsParameter], var_args_schema: CoreSchema | None\n    ) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a function's positional arguments.\n\n        Args:\n            arguments: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        prefix_items: list[JsonSchemaValue] = []\n        min_items = 0\n\n        for argument in arguments:\n            name = self.get_argument_name(argument)\n\n            argument_schema = self.generate_inner(argument['schema']).copy()\n            argument_schema['title'] = self.get_title_from_name(name)\n            prefix_items.append(argument_schema)\n\n            if argument['schema']['type'] != 'default':\n                # This assumes that if the argument has a default value,\n                # the inner schema must be of type WithDefaultSchema.\n                # I believe this is true, but I am not 100% sure\n                min_items += 1\n\n        json_schema: JsonSchemaValue = {'type': 'array', 'prefixItems': prefix_items}\n        if min_items:\n            json_schema['minItems'] = min_items\n\n        if var_args_schema:\n            items_schema = self.generate_inner(var_args_schema)\n            if items_schema:\n                json_schema['items'] = items_schema\n        else:\n            json_schema['maxItems'] = len(prefix_items)\n\n        return json_schema\n\n    def get_argument_name(self, argument: core_schema.ArgumentsParameter) -> str:\n        \"\"\"Retrieves the name of an argument.\n\n        Args:\n            argument: The core schema.\n\n        Returns:\n            The name of the argument.\n        \"\"\"\n        name = argument['name']\n        if self.by_alias:\n            alias = argument.get('alias')\n            if isinstance(alias, str):\n                name = alias\n            else:\n                pass  # might want to do something else?\n        return name\n\n    def call_schema(self, schema: core_schema.CallSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a function call.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['arguments_schema'])\n\n    def custom_error_schema(self, schema: core_schema.CustomErrorSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a custom error.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return self.generate_inner(schema['schema'])\n\n    def json_schema(self, schema: core_schema.JsonSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a JSON object.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        content_core_schema = schema.get('schema') or core_schema.any_schema()\n        content_json_schema = self.generate_inner(content_core_schema)\n        if self.mode == 'validation':\n            return {'type': 'string', 'contentMediaType': 'application/json', 'contentSchema': content_json_schema}\n        else:\n            # self.mode == 'serialization'\n            return content_json_schema\n\n    def url_schema(self, schema: core_schema.UrlSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a URL.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        json_schema = {'type': 'string', 'format': 'uri', 'minLength': 1}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n        return json_schema\n\n    def multi_host_url_schema(self, schema: core_schema.MultiHostUrlSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a URL that can be used with multiple hosts.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        # Note: 'multi-host-uri' is a custom/pydantic-specific format, not part of the JSON Schema spec\n        json_schema = {'type': 'string', 'format': 'multi-host-uri', 'minLength': 1}\n        self.update_with_validations(json_schema, schema, self.ValidationsMapping.string)\n        return json_schema\n\n    def uuid_schema(self, schema: core_schema.UuidSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a UUID.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        return {'type': 'string', 'format': 'uuid'}\n\n    def definitions_schema(self, schema: core_schema.DefinitionsSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that defines a JSON object with definitions.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        for definition in schema['definitions']:\n            try:\n                self.generate_inner(definition)\n            except PydanticInvalidForJsonSchema as e:\n                core_ref: CoreRef = CoreRef(definition['ref'])  # type: ignore\n                self._core_defs_invalid_for_json_schema[self.get_defs_ref((core_ref, self.mode))] = e\n                continue\n        return self.generate_inner(schema['schema'])\n\n    def definition_ref_schema(self, schema: core_schema.DefinitionReferenceSchema) -> JsonSchemaValue:\n        \"\"\"Generates a JSON schema that matches a schema that references a definition.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        core_ref = CoreRef(schema['schema_ref'])\n        _, ref_json_schema = self.get_cache_defs_ref_schema(core_ref)\n        return ref_json_schema\n\n    def ser_schema(\n        self, schema: core_schema.SerSchema | core_schema.IncExSeqSerSchema | core_schema.IncExDictSerSchema\n    ) -> JsonSchemaValue | None:\n        \"\"\"Generates a JSON schema that matches a schema that defines a serialized object.\n\n        Args:\n            schema: The core schema.\n\n        Returns:\n            The generated JSON schema.\n        \"\"\"\n        schema_type = schema['type']\n        if schema_type == 'function-plain' or schema_type == 'function-wrap':\n            # PlainSerializerFunctionSerSchema or WrapSerializerFunctionSerSchema\n            return_schema = schema.get('return_schema')\n            if return_schema is not None:\n                return self.generate_inner(return_schema)\n        elif schema_type == 'format' or schema_type == 'to-string':\n            # FormatSerSchema or ToStringSerSchema\n            return self.str_schema(core_schema.str_schema())\n        elif schema['type'] == 'model':\n            # ModelSerSchema\n            return self.generate_inner(schema['schema'])\n        return None\n\n    # ### Utility methods\n\n    def get_title_from_name(self, name: str) -> str:\n        \"\"\"Retrieves a title from a name.\n\n        Args:\n            name: The name to retrieve a title from.\n\n        Returns:\n            The title.\n        \"\"\"\n        return name.title().replace('_', ' ')\n\n    def field_title_should_be_set(self, schema: CoreSchemaOrField) -> bool:\n        \"\"\"Returns true if a field with the given schema should have a title set based on the field name.\n\n        Intuitively, we want this to return true for schemas that wouldn't otherwise provide their own title\n        (e.g., int, float, str), and false for those that would (e.g., BaseModel subclasses).\n\n        Args:\n            schema: The schema to check.\n\n        Returns:\n            `True` if the field should have a title set, `False` otherwise.\n        \"\"\"\n        if _core_utils.is_core_schema_field(schema):\n            if schema['type'] == 'computed-field':\n                field_schema = schema['return_schema']\n            else:\n                field_schema = schema['schema']\n            return self.field_title_should_be_set(field_schema)\n\n        elif _core_utils.is_core_schema(schema):\n            if schema.get('ref'):  # things with refs, such as models and enums, should not have titles set\n                return False\n            if schema['type'] in {'default', 'nullable', 'definitions'}:\n                return self.field_title_should_be_set(schema['schema'])  # type: ignore[typeddict-item]\n            if _core_utils.is_function_with_inner_schema(schema):\n                return self.field_title_should_be_set(schema['schema'])\n            if schema['type'] == 'definition-ref':\n                # Referenced schemas should not have titles set for the same reason\n                # schemas with refs should not\n                return False\n            return True  # anything else should have title set\n\n        else:\n            raise PydanticInvalidForJsonSchema(f'Unexpected schema type: schema={schema}')  # pragma: no cover\n\n    def normalize_name(self, name: str) -> str:\n        \"\"\"Normalizes a name to be used as a key in a dictionary.\n\n        Args:\n            name: The name to normalize.\n\n        Returns:\n            The normalized name.\n        \"\"\"\n        return re.sub(r'[^a-zA-Z0-9.\\-_]', '_', name).replace('.', '__')\n\n    def get_defs_ref(self, core_mode_ref: CoreModeRef) -> DefsRef:\n        \"\"\"Override this method to change the way that definitions keys are generated from a core reference.\n\n        Args:\n            core_mode_ref: The core reference.\n\n        Returns:\n            The definitions key.\n        \"\"\"\n        # Split the core ref into \"components\"; generic origins and arguments are each separate components\n        core_ref, mode = core_mode_ref\n        components = re.split(r'([\\][,])', core_ref)\n        # Remove IDs from each component\n        components = [x.rsplit(':', 1)[0] for x in components]\n        core_ref_no_id = ''.join(components)\n        # Remove everything before the last period from each \"component\"\n        components = [re.sub(r'(?:[^.[\\]]+\\.)+((?:[^.[\\]]+))', r'\\1', x) for x in components]\n        short_ref = ''.join(components)\n\n        mode_title = _MODE_TITLE_MAPPING[mode]\n\n        # It is important that the generated defs_ref values be such that at least one choice will not\n        # be generated for any other core_ref. Currently, this should be the case because we include\n        # the id of the source type in the core_ref\n        name = DefsRef(self.normalize_name(short_ref))\n        name_mode = DefsRef(self.normalize_name(short_ref) + f'-{mode_title}')\n        module_qualname = DefsRef(self.normalize_name(core_ref_no_id))\n        module_qualname_mode = DefsRef(f'{module_qualname}-{mode_title}')\n        module_qualname_id = DefsRef(self.normalize_name(core_ref))\n        occurrence_index = self._collision_index.get(module_qualname_id)\n        if occurrence_index is None:\n            self._collision_counter[module_qualname] += 1\n            occurrence_index = self._collision_index[module_qualname_id] = self._collision_counter[module_qualname]\n\n        module_qualname_occurrence = DefsRef(f'{module_qualname}__{occurrence_index}')\n        module_qualname_occurrence_mode = DefsRef(f'{module_qualname_mode}__{occurrence_index}')\n\n        self._prioritized_defsref_choices[module_qualname_occurrence_mode] = [\n            name,\n            name_mode,\n            module_qualname,\n            module_qualname_mode,\n            module_qualname_occurrence,\n            module_qualname_occurrence_mode,\n        ]\n\n        return module_qualname_occurrence_mode\n\n    def get_cache_defs_ref_schema(self, core_ref: CoreRef) -> tuple[DefsRef, JsonSchemaValue]:\n        \"\"\"This method wraps the get_defs_ref method with some cache-lookup/population logic,\n        and returns both the produced defs_ref and the JSON schema that will refer to the right definition.\n\n        Args:\n            core_ref: The core reference to get the definitions reference for.\n\n        Returns:\n            A tuple of the definitions reference and the JSON schema that will refer to it.\n        \"\"\"\n        core_mode_ref = (core_ref, self.mode)\n        maybe_defs_ref = self.core_to_defs_refs.get(core_mode_ref)\n        if maybe_defs_ref is not None:\n            json_ref = self.core_to_json_refs[core_mode_ref]\n            return maybe_defs_ref, {'$ref': json_ref}\n\n        defs_ref = self.get_defs_ref(core_mode_ref)\n\n        # populate the ref translation mappings\n        self.core_to_defs_refs[core_mode_ref] = defs_ref\n        self.defs_to_core_refs[defs_ref] = core_mode_ref\n\n        json_ref = JsonRef(self.ref_template.format(model=defs_ref))\n        self.core_to_json_refs[core_mode_ref] = json_ref\n        self.json_to_defs_refs[json_ref] = defs_ref\n        ref_json_schema = {'$ref': json_ref}\n        return defs_ref, ref_json_schema\n\n    def handle_ref_overrides(self, json_schema: JsonSchemaValue) -> JsonSchemaValue:\n        \"\"\"It is not valid for a schema with a top-level $ref to have sibling keys.\n\n        During our own schema generation, we treat sibling keys as overrides to the referenced schema,\n        but this is not how the official JSON schema spec works.\n\n        Because of this, we first remove any sibling keys that are redundant with the referenced schema, then if\n        any remain, we transform the schema from a top-level '$ref' to use allOf to move the $ref out of the top level.\n        (See bottom of https://swagger.io/docs/specification/using-ref/ for a reference about this behavior)\n        \"\"\"\n        if '$ref' in json_schema:\n            # prevent modifications to the input; this copy may be safe to drop if there is significant overhead\n            json_schema = json_schema.copy()\n\n            referenced_json_schema = self.get_schema_from_definitions(JsonRef(json_schema['$ref']))\n            if referenced_json_schema is None:\n                # This can happen when building schemas for models with not-yet-defined references.\n                # It may be a good idea to do a recursive pass at the end of the generation to remove\n                # any redundant override keys.\n                if len(json_schema) > 1:\n                    # Make it an allOf to at least resolve the sibling keys issue\n                    json_schema = json_schema.copy()\n                    json_schema.setdefault('allOf', [])\n                    json_schema['allOf'].append({'$ref': json_schema['$ref']})\n                    del json_schema['$ref']\n\n                return json_schema\n            for k, v in list(json_schema.items()):\n                if k == '$ref':\n                    continue\n                if k in referenced_json_schema and referenced_json_schema[k] == v:\n                    del json_schema[k]  # redundant key\n            if len(json_schema) > 1:\n                # There is a remaining \"override\" key, so we need to move $ref out of the top level\n                json_ref = JsonRef(json_schema['$ref'])\n                del json_schema['$ref']\n                assert 'allOf' not in json_schema  # this should never happen, but just in case\n                json_schema['allOf'] = [{'$ref': json_ref}]\n\n        return json_schema\n\n    def get_schema_from_definitions(self, json_ref: JsonRef) -> JsonSchemaValue | None:\n        def_ref = self.json_to_defs_refs[json_ref]\n        if def_ref in self._core_defs_invalid_for_json_schema:\n            raise self._core_defs_invalid_for_json_schema[def_ref]\n        return self.definitions.get(def_ref, None)\n\n    def encode_default(self, dft: Any) -> Any:\n        \"\"\"Encode a default value to a JSON-serializable value.\n\n        This is used to encode default values for fields in the generated JSON schema.\n\n        Args:\n            dft: The default value to encode.\n\n        Returns:\n            The encoded default value.\n        \"\"\"\n        from .type_adapter import TypeAdapter, _type_has_config\n\n        config = self._config\n        try:\n            default = (\n                dft\n                if _type_has_config(type(dft))\n                else TypeAdapter(type(dft), config=config.config_dict).dump_python(dft, mode='json')\n            )\n        except PydanticSchemaGenerationError:\n            raise pydantic_core.PydanticSerializationError(f'Unable to encode default value {dft}')\n\n        return pydantic_core.to_jsonable_python(\n            default,\n            timedelta_mode=config.ser_json_timedelta,\n            bytes_mode=config.ser_json_bytes,\n        )\n\n    def update_with_validations(\n        self, json_schema: JsonSchemaValue, core_schema: CoreSchema, mapping: dict[str, str]\n    ) -> None:\n        \"\"\"Update the json_schema with the corresponding validations specified in the core_schema,\n        using the provided mapping to translate keys in core_schema to the appropriate keys for a JSON schema.\n\n        Args:\n            json_schema: The JSON schema to update.\n            core_schema: The core schema to get the validations from.\n            mapping: A mapping from core_schema attribute names to the corresponding JSON schema attribute names.\n        \"\"\"\n        for core_key, json_schema_key in mapping.items():\n            if core_key in core_schema:\n                json_schema[json_schema_key] = core_schema[core_key]\n\n    class ValidationsMapping:\n        \"\"\"This class just contains mappings from core_schema attribute names to the corresponding\n        JSON schema attribute names. While I suspect it is unlikely to be necessary, you can in\n        principle override this class in a subclass of GenerateJsonSchema (by inheriting from\n        GenerateJsonSchema.ValidationsMapping) to change these mappings.\n        \"\"\"\n\n        numeric = {\n            'multiple_of': 'multipleOf',\n            'le': 'maximum',\n            'ge': 'minimum',\n            'lt': 'exclusiveMaximum',\n            'gt': 'exclusiveMinimum',\n        }\n        bytes = {\n            'min_length': 'minLength',\n            'max_length': 'maxLength',\n        }\n        string = {\n            'min_length': 'minLength',\n            'max_length': 'maxLength',\n            'pattern': 'pattern',\n        }\n        array = {\n            'min_length': 'minItems',\n            'max_length': 'maxItems',\n        }\n        object = {\n            'min_length': 'minProperties',\n            'max_length': 'maxProperties',\n        }\n        date = {\n            'le': 'maximum',\n            'ge': 'minimum',\n            'lt': 'exclusiveMaximum',\n            'gt': 'exclusiveMinimum',\n        }\n\n    def get_flattened_anyof(self, schemas: list[JsonSchemaValue]) -> JsonSchemaValue:\n        members = []\n        for schema in schemas:\n            if len(schema) == 1 and 'anyOf' in schema:\n                members.extend(schema['anyOf'])\n            else:\n                members.append(schema)\n        members = _deduplicate_schemas(members)\n        if len(members) == 1:\n            return members[0]\n        return {'anyOf': members}\n\n    def get_json_ref_counts(self, json_schema: JsonSchemaValue) -> dict[JsonRef, int]:\n        \"\"\"Get all values corresponding to the key '$ref' anywhere in the json_schema.\"\"\"\n        json_refs: dict[JsonRef, int] = Counter()\n\n        def _add_json_refs(schema: Any) -> None:\n            if isinstance(schema, dict):\n                if '$ref' in schema:\n                    json_ref = JsonRef(schema['$ref'])\n                    if not isinstance(json_ref, str):\n                        return  # in this case, '$ref' might have been the name of a property\n                    already_visited = json_ref in json_refs\n                    json_refs[json_ref] += 1\n                    if already_visited:\n                        return  # prevent recursion on a definition that was already visited\n                    defs_ref = self.json_to_defs_refs[json_ref]\n                    if defs_ref in self._core_defs_invalid_for_json_schema:\n                        raise self._core_defs_invalid_for_json_schema[defs_ref]\n                    _add_json_refs(self.definitions[defs_ref])\n\n                for v in schema.values():\n                    _add_json_refs(v)\n            elif isinstance(schema, list):\n                for v in schema:\n                    _add_json_refs(v)\n\n        _add_json_refs(json_schema)\n        return json_refs\n\n    def handle_invalid_for_json_schema(self, schema: CoreSchemaOrField, error_info: str) -> JsonSchemaValue:\n        raise PydanticInvalidForJsonSchema(f'Cannot generate a JsonSchema for {error_info}')\n\n    def emit_warning(self, kind: JsonSchemaWarningKind, detail: str) -> None:\n        \"\"\"This method simply emits PydanticJsonSchemaWarnings based on handling in the `warning_message` method.\"\"\"\n        message = self.render_warning_message(kind, detail)\n        if message is not None:\n            warnings.warn(message, PydanticJsonSchemaWarning)\n\n    def render_warning_message(self, kind: JsonSchemaWarningKind, detail: str) -> str | None:\n        \"\"\"This method is responsible for ignoring warnings as desired, and for formatting the warning messages.\n\n        You can override the value of `ignored_warning_kinds` in a subclass of GenerateJsonSchema\n        to modify what warnings are generated. If you want more control, you can override this method;\n        just return None in situations where you don't want warnings to be emitted.\n\n        Args:\n            kind: The kind of warning to render. It can be one of the following:\n\n                - 'skipped-choice': A choice field was skipped because it had no valid choices.\n                - 'non-serializable-default': A default value was skipped because it was not JSON-serializable.\n            detail: A string with additional details about the warning.\n\n        Returns:\n            The formatted warning message, or `None` if no warning should be emitted.\n        \"\"\"\n        if kind in self.ignored_warning_kinds:\n            return None\n        return f'{detail} [{kind}]'\n\n    def _build_definitions_remapping(self) -> _DefinitionsRemapping:\n        defs_to_json: dict[DefsRef, JsonRef] = {}\n        for defs_refs in self._prioritized_defsref_choices.values():\n            for defs_ref in defs_refs:\n                json_ref = JsonRef(self.ref_template.format(model=defs_ref))\n                defs_to_json[defs_ref] = json_ref\n\n        return _DefinitionsRemapping.from_prioritized_choices(\n            self._prioritized_defsref_choices, defs_to_json, self.definitions\n        )\n\n    def _garbage_collect_definitions(self, schema: JsonSchemaValue) -> None:\n        visited_defs_refs: set[DefsRef] = set()\n        unvisited_json_refs = _get_all_json_refs(schema)\n        while unvisited_json_refs:\n            next_json_ref = unvisited_json_refs.pop()\n            next_defs_ref = self.json_to_defs_refs[next_json_ref]\n            if next_defs_ref in visited_defs_refs:\n                continue\n            visited_defs_refs.add(next_defs_ref)\n            unvisited_json_refs.update(_get_all_json_refs(self.definitions[next_defs_ref]))\n\n        self.definitions = {k: v for k, v in self.definitions.items() if k in visited_defs_refs}\n\n\n# ##### Start JSON Schema Generation Functions #####\n\n\ndef model_json_schema(\n    cls: type[BaseModel] | type[PydanticDataclass],\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    mode: JsonSchemaMode = 'validation',\n) -> dict[str, Any]:\n    \"\"\"Utility function to generate a JSON Schema for a model.\n\n    Args:\n        cls: The model class to generate a JSON Schema for.\n        by_alias: If `True` (the default), fields will be serialized according to their alias.\n            If `False`, fields will be serialized according to their attribute name.\n        ref_template: The template to use for generating JSON Schema references.\n        schema_generator: The class to use for generating the JSON Schema.\n        mode: The mode to use for generating the JSON Schema. It can be one of the following:\n\n            - 'validation': Generate a JSON Schema for validating data.\n            - 'serialization': Generate a JSON Schema for serializing data.\n\n    Returns:\n        The generated JSON Schema.\n    \"\"\"\n    from .main import BaseModel\n\n    schema_generator_instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n\n    if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):\n        cls.__pydantic_core_schema__.rebuild()\n\n    if cls is BaseModel:\n        raise AttributeError('model_json_schema() must be called on a subclass of BaseModel, not BaseModel itself.')\n\n    assert not isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema), 'this is a bug! please report it'\n    return schema_generator_instance.generate(cls.__pydantic_core_schema__, mode=mode)\n\n\ndef models_json_schema(\n    models: Sequence[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode]],\n    *,\n    by_alias: bool = True,\n    title: str | None = None,\n    description: str | None = None,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n) -> tuple[dict[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode], JsonSchemaValue], JsonSchemaValue]:\n    \"\"\"Utility function to generate a JSON Schema for multiple models.\n\n    Args:\n        models: A sequence of tuples of the form (model, mode).\n        by_alias: Whether field aliases should be used as keys in the generated JSON Schema.\n        title: The title of the generated JSON Schema.\n        description: The description of the generated JSON Schema.\n        ref_template: The reference template to use for generating JSON Schema references.\n        schema_generator: The schema generator to use for generating the JSON Schema.\n\n    Returns:\n        A tuple where:\n            - The first element is a dictionary whose keys are tuples of JSON schema key type and JSON mode, and\n                whose values are the JSON schema corresponding to that pair of inputs. (These schemas may have\n                JsonRef references to definitions that are defined in the second returned element.)\n            - The second element is a JSON schema containing all definitions referenced in the first returned\n                    element, along with the optional title and description keys.\n    \"\"\"\n    for cls, _ in models:\n        if isinstance(cls.__pydantic_core_schema__, _mock_val_ser.MockCoreSchema):\n            cls.__pydantic_core_schema__.rebuild()\n\n    instance = schema_generator(by_alias=by_alias, ref_template=ref_template)\n    inputs: list[tuple[type[BaseModel] | type[PydanticDataclass], JsonSchemaMode, CoreSchema]] = [\n        (m, mode, m.__pydantic_core_schema__) for m, mode in models\n    ]\n    json_schemas_map, definitions = instance.generate_definitions(inputs)\n\n    json_schema: dict[str, Any] = {}\n    if definitions:\n        json_schema['$defs'] = definitions\n    if title:\n        json_schema['title'] = title\n    if description:\n        json_schema['description'] = description\n\n    return json_schemas_map, json_schema\n\n\n# ##### End JSON Schema Generation Functions #####\n\n\n_HashableJsonValue: TypeAlias = Union[\n    int, float, str, bool, None, Tuple['_HashableJsonValue', ...], Tuple[Tuple[str, '_HashableJsonValue'], ...]\n]\n\n\ndef _deduplicate_schemas(schemas: Iterable[JsonDict]) -> list[JsonDict]:\n    return list({_make_json_hashable(schema): schema for schema in schemas}.values())\n\n\ndef _make_json_hashable(value: JsonValue) -> _HashableJsonValue:\n    if isinstance(value, dict):\n        return tuple(sorted((k, _make_json_hashable(v)) for k, v in value.items()))\n    elif isinstance(value, list):\n        return tuple(_make_json_hashable(v) for v in value)\n    else:\n        return value\n\n\ndef _sort_json_schema(value: JsonSchemaValue, parent_key: str | None = None) -> JsonSchemaValue:\n    if isinstance(value, dict):\n        sorted_dict: dict[str, JsonSchemaValue] = {}\n        keys = value.keys()\n        if (parent_key != 'properties') and (parent_key != 'default'):\n            keys = sorted(keys)\n        for key in keys:\n            sorted_dict[key] = _sort_json_schema(value[key], parent_key=key)\n        return sorted_dict\n    elif isinstance(value, list):\n        sorted_list: list[JsonSchemaValue] = []\n        for item in value:  # type: ignore\n            sorted_list.append(_sort_json_schema(item, parent_key))\n        return sorted_list  # type: ignore\n    else:\n        return value\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass WithJsonSchema:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json_schema/#withjsonschema-annotation\n\n    Add this as an annotation on a field to override the (base) JSON schema that would be generated for that field.\n    This provides a way to set a JSON schema for types that would otherwise raise errors when producing a JSON schema,\n    such as Callable, or types that have an is-instance core schema, without needing to go so far as creating a\n    custom subclass of pydantic.json_schema.GenerateJsonSchema.\n    Note that any _modifications_ to the schema that would normally be made (such as setting the title for model fields)\n    will still be performed.\n\n    If `mode` is set this will only apply to that schema generation mode, allowing you\n    to set different json schemas for validation and serialization.\n    \"\"\"\n\n    json_schema: JsonSchemaValue | None\n    mode: Literal['validation', 'serialization'] | None = None\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        mode = self.mode or handler.mode\n        if mode != handler.mode:\n            return handler(core_schema)\n        if self.json_schema is None:\n            # This exception is handled in pydantic.json_schema.GenerateJsonSchema._named_required_fields_schema\n            raise PydanticOmit\n        else:\n            return self.json_schema\n\n    def __hash__(self) -> int:\n        return hash(type(self.mode))\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass Examples:\n    \"\"\"Add examples to a JSON schema.\n\n    Examples should be a map of example names (strings)\n    to example values (any valid JSON).\n\n    If `mode` is set this will only apply to that schema generation mode,\n    allowing you to add different examples for validation and serialization.\n    \"\"\"\n\n    examples: dict[str, Any]\n    mode: Literal['validation', 'serialization'] | None = None\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        mode = self.mode or handler.mode\n        json_schema = handler(core_schema)\n        if mode != handler.mode:\n            return json_schema\n        examples = json_schema.get('examples', {})\n        examples.update(to_jsonable_python(self.examples))\n        json_schema['examples'] = examples\n        return json_schema\n\n    def __hash__(self) -> int:\n        return hash(type(self.mode))\n\n\ndef _get_all_json_refs(item: Any) -> set[JsonRef]:\n    \"\"\"Get all the definitions references from a JSON schema.\"\"\"\n    refs: set[JsonRef] = set()\n    stack = [item]\n\n    while stack:\n        current = stack.pop()\n        if isinstance(current, dict):\n            for key, value in current.items():\n                if key == '$ref' and isinstance(value, str):\n                    refs.add(JsonRef(value))\n                elif isinstance(value, dict):\n                    stack.append(value)\n                elif isinstance(value, list):\n                    stack.extend(value)\n        elif isinstance(current, list):\n            stack.extend(current)\n\n    return refs\n\n\nAnyType = TypeVar('AnyType')\n\nif TYPE_CHECKING:\n    SkipJsonSchema = Annotated[AnyType, ...]\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SkipJsonSchema:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json_schema/#skipjsonschema-annotation\n\n        Add this as an annotation on a field to skip generating a JSON schema for that field.\n\n        Example:\n            ```py\n            from typing import Union\n\n            from pydantic import BaseModel\n            from pydantic.json_schema import SkipJsonSchema\n\n            from pprint import pprint\n\n\n            class Model(BaseModel):\n                a: Union[int, None] = None  # (1)!\n                b: Union[int, SkipJsonSchema[None]] = None  # (2)!\n                c: SkipJsonSchema[Union[int, None]] = None  # (3)!\n\n\n            pprint(Model.model_json_schema())\n            '''\n            {\n                'properties': {\n                    'a': {\n                        'anyOf': [\n                            {'type': 'integer'},\n                            {'type': 'null'}\n                        ],\n                        'default': None,\n                        'title': 'A'\n                    },\n                    'b': {\n                        'default': None,\n                        'title': 'B',\n                        'type': 'integer'\n                    }\n                },\n                'title': 'Model',\n                'type': 'object'\n            }\n            '''\n            ```\n\n            1. The integer and null types are both included in the schema for `a`.\n            2. The integer type is the only type included in the schema for `b`.\n            3. The entirety of the `c` field is omitted from the schema.\n        \"\"\"\n\n        def __class_getitem__(cls, item: AnyType) -> AnyType:\n            return Annotated[item, cls()]\n\n        def __get_pydantic_json_schema__(\n            self, core_schema: CoreSchema, handler: GetJsonSchemaHandler\n        ) -> JsonSchemaValue:\n            raise PydanticOmit\n\n        def __hash__(self) -> int:\n            return hash(type(self))\n\n\ndef _get_typed_dict_cls(schema: core_schema.TypedDictSchema) -> type[Any] | None:\n    metadata = _core_metadata.CoreMetadataHandler(schema).metadata\n    cls = metadata.get('pydantic_typed_dict_cls')\n    return cls\n\n\ndef _get_typed_dict_config(cls: type[Any] | None) -> ConfigDict:\n    if cls is not None:\n        try:\n            return _decorators.get_attribute_from_bases(cls, '__pydantic_config__')\n        except AttributeError:\n            pass\n    return {}\n", "pydantic/functional_serializers.py": "\"\"\"This module contains related classes and functions for serialization.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom functools import partialmethod\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, overload\n\nfrom pydantic_core import PydanticUndefined, core_schema\nfrom pydantic_core import core_schema as _core_schema\nfrom typing_extensions import Annotated, Literal, TypeAlias\n\nfrom . import PydanticUndefinedAnnotation\nfrom ._internal import _decorators, _internal_dataclass\nfrom .annotated_handlers import GetCoreSchemaHandler\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass PlainSerializer:\n    \"\"\"Plain serializers use a function to modify the output of serialization.\n\n    This is particularly helpful when you want to customize the serialization for annotated types.\n    Consider an input of `list`, which will be serialized into a space-delimited string.\n\n    ```python\n    from typing import List\n\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, PlainSerializer\n\n    CustomStr = Annotated[\n        List, PlainSerializer(lambda x: ' '.join(x), return_type=str)\n    ]\n\n    class StudentModel(BaseModel):\n        courses: CustomStr\n\n    student = StudentModel(courses=['Math', 'Chemistry', 'English'])\n    print(student.model_dump())\n    #> {'courses': 'Math Chemistry English'}\n    ```\n\n    Attributes:\n        func: The serializer function.\n        return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.\n    \"\"\"\n\n    func: core_schema.SerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        \"\"\"Gets the Pydantic core schema.\n\n        Args:\n            source_type: The source type.\n            handler: The `GetCoreSchemaHandler` instance.\n\n        Returns:\n            The Pydantic core schema.\n        \"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n            )\n        except NameError as e:\n            raise PydanticUndefinedAnnotation.from_name_error(e) from e\n        return_schema = None if return_type is PydanticUndefined else handler.generate_schema(return_type)\n        schema['serialization'] = core_schema.plain_serializer_function_ser_schema(\n            function=self.func,\n            info_arg=_decorators.inspect_annotated_serializer(self.func, 'plain'),\n            return_schema=return_schema,\n            when_used=self.when_used,\n        )\n        return schema\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass WrapSerializer:\n    \"\"\"Wrap serializers receive the raw inputs along with a handler function that applies the standard serialization\n    logic, and can modify the resulting value before returning it as the final output of serialization.\n\n    For example, here's a scenario in which a wrap serializer transforms timezones to UTC **and** utilizes the existing `datetime` serialization logic.\n\n    ```python\n    from datetime import datetime, timezone\n    from typing import Any, Dict\n\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, WrapSerializer\n\n    class EventDatetime(BaseModel):\n        start: datetime\n        end: datetime\n\n    def convert_to_utc(value: Any, handler, info) -> Dict[str, datetime]:\n        # Note that `helper` can actually help serialize the `value` for further custom serialization in case it's a subclass.\n        partial_result = handler(value, info)\n        if info.mode == 'json':\n            return {\n                k: datetime.fromisoformat(v).astimezone(timezone.utc)\n                for k, v in partial_result.items()\n            }\n        return {k: v.astimezone(timezone.utc) for k, v in partial_result.items()}\n\n    UTCEventDatetime = Annotated[EventDatetime, WrapSerializer(convert_to_utc)]\n\n    class EventModel(BaseModel):\n        event_datetime: UTCEventDatetime\n\n    dt = EventDatetime(\n        start='2024-01-01T07:00:00-08:00', end='2024-01-03T20:00:00+06:00'\n    )\n    event = EventModel(event_datetime=dt)\n    print(event.model_dump())\n    '''\n    {\n        'event_datetime': {\n            'start': datetime.datetime(\n                2024, 1, 1, 15, 0, tzinfo=datetime.timezone.utc\n            ),\n            'end': datetime.datetime(\n                2024, 1, 3, 14, 0, tzinfo=datetime.timezone.utc\n            ),\n        }\n    }\n    '''\n\n    print(event.model_dump_json())\n    '''\n    {\"event_datetime\":{\"start\":\"2024-01-01T15:00:00Z\",\"end\":\"2024-01-03T14:00:00Z\"}}\n    '''\n    ```\n\n    Attributes:\n        func: The serializer function to be wrapped.\n        return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n        when_used: Determines when this serializer should be used. Accepts a string with values `'always'`,\n            `'unless-none'`, `'json'`, and `'json-unless-none'`. Defaults to 'always'.\n    \"\"\"\n\n    func: core_schema.WrapSerializerFunction\n    return_type: Any = PydanticUndefined\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always'\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        \"\"\"This method is used to get the Pydantic core schema of the class.\n\n        Args:\n            source_type: Source type.\n            handler: Core schema handler.\n\n        Returns:\n            The generated core schema of the class.\n        \"\"\"\n        schema = handler(source_type)\n        try:\n            return_type = _decorators.get_function_return_type(\n                self.func, self.return_type, handler._get_types_namespace()\n            )\n        except NameError as e:\n            raise PydanticUndefinedAnnotation.from_name_error(e) from e\n        return_schema = None if return_type is PydanticUndefined else handler.generate_schema(return_type)\n        schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(\n            function=self.func,\n            info_arg=_decorators.inspect_annotated_serializer(self.func, 'wrap'),\n            return_schema=return_schema,\n            when_used=self.when_used,\n        )\n        return schema\n\n\nif TYPE_CHECKING:\n    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]\n    _PlainSerializationFunction = Union[_core_schema.SerializerFunction, _PartialClsOrStaticMethod]\n    _WrapSerializationFunction = Union[_core_schema.WrapSerializerFunction, _PartialClsOrStaticMethod]\n    _PlainSerializeMethodType = TypeVar('_PlainSerializeMethodType', bound=_PlainSerializationFunction)\n    _WrapSerializeMethodType = TypeVar('_WrapSerializeMethodType', bound=_WrapSerializationFunction)\n\n\n@overload\ndef field_serializer(\n    field: str,\n    /,\n    *fields: str,\n    return_type: Any = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = ...,\n    check_fields: bool | None = ...,\n) -> Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]: ...\n\n\n@overload\ndef field_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['plain'],\n    return_type: Any = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = ...,\n    check_fields: bool | None = ...,\n) -> Callable[[_PlainSerializeMethodType], _PlainSerializeMethodType]: ...\n\n\n@overload\ndef field_serializer(\n    field: str,\n    /,\n    *fields: str,\n    mode: Literal['wrap'],\n    return_type: Any = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = ...,\n    check_fields: bool | None = ...,\n) -> Callable[[_WrapSerializeMethodType], _WrapSerializeMethodType]: ...\n\n\ndef field_serializer(\n    *fields: str,\n    mode: Literal['plain', 'wrap'] = 'plain',\n    return_type: Any = PydanticUndefined,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n    check_fields: bool | None = None,\n) -> Callable[[Any], Any]:\n    \"\"\"Decorator that enables custom field serialization.\n\n    In the below example, a field of type `set` is used to mitigate duplication. A `field_serializer` is used to serialize the data as a sorted list.\n\n    ```python\n    from typing import Set\n\n    from pydantic import BaseModel, field_serializer\n\n    class StudentModel(BaseModel):\n        name: str = 'Jane'\n        courses: Set[str]\n\n        @field_serializer('courses', when_used='json')\n        def serialize_courses_in_order(courses: Set[str]):\n            return sorted(courses)\n\n    student = StudentModel(courses={'Math', 'Chemistry', 'English'})\n    print(student.model_dump_json())\n    #> {\"name\":\"Jane\",\"courses\":[\"Chemistry\",\"English\",\"Math\"]}\n    ```\n\n    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\n\n    Four signatures are supported:\n\n    - `(self, value: Any, info: FieldSerializationInfo)`\n    - `(self, value: Any, nxt: SerializerFunctionWrapHandler, info: FieldSerializationInfo)`\n    - `(value: Any, info: SerializationInfo)`\n    - `(value: Any, nxt: SerializerFunctionWrapHandler, info: SerializationInfo)`\n\n    Args:\n        fields: Which field(s) the method should be called on.\n        mode: The serialization mode.\n\n            - `plain` means the function will be called instead of the default serialization logic,\n            - `wrap` means the function will be called with an argument to optionally call the\n               default serialization logic.\n        return_type: Optional return type for the function, if omitted it will be inferred from the type annotation.\n        when_used: Determines the serializer will be used for serialization.\n        check_fields: Whether to check that the fields actually exist on the model.\n\n    Returns:\n        The decorator function.\n    \"\"\"\n\n    def dec(\n        f: Callable[..., Any] | staticmethod[Any, Any] | classmethod[Any, Any, Any],\n    ) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.FieldSerializerDecoratorInfo(\n            fields=fields,\n            mode=mode,\n            return_type=return_type,\n            when_used=when_used,\n            check_fields=check_fields,\n        )\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    return dec\n\n\nFuncType = TypeVar('FuncType', bound=Callable[..., Any])\n\n\n@overload\ndef model_serializer(__f: FuncType) -> FuncType: ...\n\n\n@overload\ndef model_serializer(\n    *,\n    mode: Literal['plain', 'wrap'] = ...,\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n    return_type: Any = ...,\n) -> Callable[[FuncType], FuncType]: ...\n\n\ndef model_serializer(\n    f: Callable[..., Any] | None = None,\n    /,\n    *,\n    mode: Literal['plain', 'wrap'] = 'plain',\n    when_used: Literal['always', 'unless-none', 'json', 'json-unless-none'] = 'always',\n    return_type: Any = PydanticUndefined,\n) -> Callable[[Any], Any]:\n    \"\"\"Decorator that enables custom model serialization.\n\n    This is useful when a model need to be serialized in a customized manner, allowing for flexibility beyond just specific fields.\n\n    An example would be to serialize temperature to the same temperature scale, such as degrees Celsius.\n\n    ```python\n    from typing import Literal\n\n    from pydantic import BaseModel, model_serializer\n\n    class TemperatureModel(BaseModel):\n        unit: Literal['C', 'F']\n        value: int\n\n        @model_serializer()\n        def serialize_model(self):\n            if self.unit == 'F':\n                return {'unit': 'C', 'value': int((self.value - 32) / 1.8)}\n            return {'unit': self.unit, 'value': self.value}\n\n    temperature = TemperatureModel(unit='F', value=212)\n    print(temperature.model_dump())\n    #> {'unit': 'C', 'value': 100}\n    ```\n\n    See [Custom serializers](../concepts/serialization.md#custom-serializers) for more information.\n\n    Args:\n        f: The function to be decorated.\n        mode: The serialization mode.\n\n            - `'plain'` means the function will be called instead of the default serialization logic\n            - `'wrap'` means the function will be called with an argument to optionally call the default\n                serialization logic.\n        when_used: Determines when this serializer should be used.\n        return_type: The return type for the function. If omitted it will be inferred from the type annotation.\n\n    Returns:\n        The decorator function.\n    \"\"\"\n\n    def dec(f: Callable[..., Any]) -> _decorators.PydanticDescriptorProxy[Any]:\n        dec_info = _decorators.ModelSerializerDecoratorInfo(mode=mode, return_type=return_type, when_used=when_used)\n        return _decorators.PydanticDescriptorProxy(f, dec_info)\n\n    if f is None:\n        return dec\n    else:\n        return dec(f)  # type: ignore\n\n\nAnyType = TypeVar('AnyType')\n\n\nif TYPE_CHECKING:\n    SerializeAsAny = Annotated[AnyType, ...]  # SerializeAsAny[list[str]] will be treated by type checkers as list[str]\n    \"\"\"Force serialization to ignore whatever is defined in the schema and instead ask the object\n    itself how it should be serialized.\n    In particular, this means that when model subclasses are serialized, fields present in the subclass\n    but not in the original schema will be included.\n    \"\"\"\nelse:\n\n    @dataclasses.dataclass(**_internal_dataclass.slots_true)\n    class SerializeAsAny:  # noqa: D101\n        def __class_getitem__(cls, item: Any) -> Any:\n            return Annotated[item, SerializeAsAny()]\n\n        def __get_pydantic_core_schema__(\n            self, source_type: Any, handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            schema = handler(source_type)\n            schema_to_update = schema\n            while schema_to_update['type'] == 'definitions':\n                schema_to_update = schema_to_update.copy()\n                schema_to_update = schema_to_update['schema']\n            schema_to_update['serialization'] = core_schema.wrap_serializer_function_ser_schema(\n                lambda x, h: h(x), schema=core_schema.any_schema()\n            )\n            return schema\n\n        __hash__ = object.__hash__\n", "pydantic/error_wrappers.py": "\"\"\"The `error_wrappers` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/validate_call_decorator.py": "\"\"\"Decorator for validating function calls.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, overload\n\nfrom ._internal import _validate_call\n\n__all__ = ('validate_call',)\n\nif TYPE_CHECKING:\n    from .config import ConfigDict\n\n    AnyCallableT = TypeVar('AnyCallableT', bound=Callable[..., Any])\n\n\n@overload\ndef validate_call(\n    *, config: ConfigDict | None = None, validate_return: bool = False\n) -> Callable[[AnyCallableT], AnyCallableT]: ...\n\n\n@overload\ndef validate_call(func: AnyCallableT, /) -> AnyCallableT: ...\n\n\ndef validate_call(\n    func: AnyCallableT | None = None,\n    /,\n    *,\n    config: ConfigDict | None = None,\n    validate_return: bool = False,\n) -> AnyCallableT | Callable[[AnyCallableT], AnyCallableT]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/validation_decorator/\n\n    Returns a decorated wrapper around the function that validates the arguments and, optionally, the return value.\n\n    Usage may be either as a plain decorator `@validate_call` or with arguments `@validate_call(...)`.\n\n    Args:\n        func: The function to be decorated.\n        config: The configuration dictionary.\n        validate_return: Whether to validate the return value.\n\n    Returns:\n        The decorated function.\n    \"\"\"\n\n    def validate(function: AnyCallableT) -> AnyCallableT:\n        if isinstance(function, (classmethod, staticmethod)):\n            name = type(function).__name__\n            raise TypeError(f'The `@{name}` decorator should be applied after `@validate_call` (put `@{name}` on top)')\n        validate_call_wrapper = _validate_call.ValidateCallWrapper(function, config, validate_return)\n\n        @functools.wraps(function)\n        def wrapper_function(*args, **kwargs):\n            return validate_call_wrapper(*args, **kwargs)\n\n        wrapper_function.raw_function = function  # type: ignore\n\n        return wrapper_function  # type: ignore\n\n    if func:\n        return validate(func)\n    else:\n        return validate\n", "pydantic/errors.py": "\"\"\"Pydantic-specific errors.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport re\n\nfrom typing_extensions import Literal, Self\n\nfrom ._migration import getattr_migration\nfrom .version import version_short\n\n__all__ = (\n    'PydanticUserError',\n    'PydanticUndefinedAnnotation',\n    'PydanticImportError',\n    'PydanticSchemaGenerationError',\n    'PydanticInvalidForJsonSchema',\n    'PydanticErrorCodes',\n)\n\n# We use this URL to allow for future flexibility about how we host the docs, while allowing for Pydantic\n# code in the while with \"old\" URLs to still work.\n# 'u' refers to \"user errors\" - e.g. errors caused by developers using pydantic, as opposed to validation errors.\nDEV_ERROR_DOCS_URL = f'https://errors.pydantic.dev/{version_short()}/u/'\nPydanticErrorCodes = Literal[\n    'class-not-fully-defined',\n    'custom-json-schema',\n    'decorator-missing-field',\n    'discriminator-no-field',\n    'discriminator-alias-type',\n    'discriminator-needs-literal',\n    'discriminator-alias',\n    'discriminator-validator',\n    'callable-discriminator-no-tag',\n    'typed-dict-version',\n    'model-field-overridden',\n    'model-field-missing-annotation',\n    'config-both',\n    'removed-kwargs',\n    'invalid-for-json-schema',\n    'json-schema-already-used',\n    'base-model-instantiated',\n    'undefined-annotation',\n    'schema-for-unknown-type',\n    'import-error',\n    'create-model-field-definitions',\n    'create-model-config-base',\n    'validator-no-fields',\n    'validator-invalid-fields',\n    'validator-instance-method',\n    'root-validator-pre-skip',\n    'model-serializer-instance-method',\n    'validator-field-config-info',\n    'validator-v1-signature',\n    'validator-signature',\n    'field-serializer-signature',\n    'model-serializer-signature',\n    'multiple-field-serializers',\n    'invalid_annotated_type',\n    'type-adapter-config-unused',\n    'root-model-extra',\n    'unevaluable-type-annotation',\n    'dataclass-init-false-extra-allow',\n    'clashing-init-and-init-var',\n    'model-config-invalid-field-name',\n    'with-config-on-model',\n    'dataclass-on-model',\n]\n\n\nclass PydanticErrorMixin:\n    \"\"\"A mixin class for common functionality shared by all Pydantic-specific errors.\n\n    Attributes:\n        message: A message describing the error.\n        code: An optional error code from PydanticErrorCodes enum.\n    \"\"\"\n\n    def __init__(self, message: str, *, code: PydanticErrorCodes | None) -> None:\n        self.message = message\n        self.code = code\n\n    def __str__(self) -> str:\n        if self.code is None:\n            return self.message\n        else:\n            return f'{self.message}\\n\\nFor further information visit {DEV_ERROR_DOCS_URL}{self.code}'\n\n\nclass PydanticUserError(PydanticErrorMixin, TypeError):\n    \"\"\"An error raised due to incorrect use of Pydantic.\"\"\"\n\n\nclass PydanticUndefinedAnnotation(PydanticErrorMixin, NameError):\n    \"\"\"A subclass of `NameError` raised when handling undefined annotations during `CoreSchema` generation.\n\n    Attributes:\n        name: Name of the error.\n        message: Description of the error.\n    \"\"\"\n\n    def __init__(self, name: str, message: str) -> None:\n        self.name = name\n        super().__init__(message=message, code='undefined-annotation')\n\n    @classmethod\n    def from_name_error(cls, name_error: NameError) -> Self:\n        \"\"\"Convert a `NameError` to a `PydanticUndefinedAnnotation` error.\n\n        Args:\n            name_error: `NameError` to be converted.\n\n        Returns:\n            Converted `PydanticUndefinedAnnotation` error.\n        \"\"\"\n        try:\n            name = name_error.name  # type: ignore  # python > 3.10\n        except AttributeError:\n            name = re.search(r\".*'(.+?)'\", str(name_error)).group(1)  # type: ignore[union-attr]\n        return cls(name=name, message=str(name_error))\n\n\nclass PydanticImportError(PydanticErrorMixin, ImportError):\n    \"\"\"An error raised when an import fails due to module changes between V1 and V2.\n\n    Attributes:\n        message: Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str) -> None:\n        super().__init__(message, code='import-error')\n\n\nclass PydanticSchemaGenerationError(PydanticUserError):\n    \"\"\"An error raised during failures to generate a `CoreSchema` for some type.\n\n    Attributes:\n        message: Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str) -> None:\n        super().__init__(message, code='schema-for-unknown-type')\n\n\nclass PydanticInvalidForJsonSchema(PydanticUserError):\n    \"\"\"An error raised during failures to generate a JSON schema for some `CoreSchema`.\n\n    Attributes:\n        message: Description of the error.\n    \"\"\"\n\n    def __init__(self, message: str) -> None:\n        super().__init__(message, code='invalid-for-json-schema')\n\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/json.py": "\"\"\"The `json` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/validators.py": "\"\"\"The `validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/types.py": "\"\"\"The types module contains custom types used by pydantic.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport base64\nimport dataclasses as _dataclasses\nimport re\nfrom datetime import date, datetime\nfrom decimal import Decimal\nfrom enum import Enum\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    ClassVar,\n    Dict,\n    FrozenSet,\n    Generic,\n    Hashable,\n    Iterator,\n    List,\n    Pattern,\n    Set,\n    TypeVar,\n    Union,\n    cast,\n    get_args,\n    get_origin,\n)\nfrom uuid import UUID\n\nimport annotated_types\nfrom annotated_types import BaseMetadata, MaxLen, MinLen\nfrom pydantic_core import CoreSchema, PydanticCustomError, core_schema\nfrom typing_extensions import Annotated, Literal, Protocol, TypeAlias, TypeAliasType, deprecated\n\nfrom ._internal import (\n    _core_utils,\n    _fields,\n    _internal_dataclass,\n    _typing_extra,\n    _utils,\n    _validators,\n)\nfrom ._migration import getattr_migration\nfrom .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\nfrom .errors import PydanticUserError\nfrom .json_schema import JsonSchemaValue\nfrom .warnings import PydanticDeprecatedSince20\n\n__all__ = (\n    'Strict',\n    'StrictStr',\n    'conbytes',\n    'conlist',\n    'conset',\n    'confrozenset',\n    'constr',\n    'ImportString',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'condecimal',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'FilePath',\n    'DirectoryPath',\n    'NewPath',\n    'Json',\n    'Secret',\n    'SecretStr',\n    'SecretBytes',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    'PastDatetime',\n    'FutureDatetime',\n    'condate',\n    'AwareDatetime',\n    'NaiveDatetime',\n    'AllowInfNan',\n    'EncoderProtocol',\n    'EncodedBytes',\n    'EncodedStr',\n    'Base64Encoder',\n    'Base64Bytes',\n    'Base64Str',\n    'Base64UrlBytes',\n    'Base64UrlStr',\n    'GetPydanticSchema',\n    'StringConstraints',\n    'Tag',\n    'Discriminator',\n    'JsonValue',\n    'OnErrorOmit',\n)\n\n\nT = TypeVar('T')\n\n\n@_dataclasses.dataclass\nclass Strict(_fields.PydanticMetadata, BaseMetadata):\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/strict_mode/#strict-mode-with-annotated-strict\n\n    A field metadata class to indicate that a field should be validated in strict mode.\n\n    Attributes:\n        strict: Whether to validate the field in strict mode.\n\n    Example:\n        ```python\n        from typing_extensions import Annotated\n\n        from pydantic.types import Strict\n\n        StrictBool = Annotated[bool, Strict()]\n        ```\n    \"\"\"\n\n    strict: bool = True\n\n    def __hash__(self) -> int:\n        return hash(self.strict)\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BOOLEAN TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nStrictBool = Annotated[bool, Strict()]\n\"\"\"A boolean that must be either ``True`` or ``False``.\"\"\"\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\ndef conint(\n    *,\n    strict: bool | None = None,\n    gt: int | None = None,\n    ge: int | None = None,\n    lt: int | None = None,\n    le: int | None = None,\n    multiple_of: int | None = None,\n) -> type[int]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `conint` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, conint\n\n            class Foo(BaseModel):\n                bar: conint(strict=True, gt=0)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```py\n            from typing_extensions import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[int, Field(strict=True, gt=0)]\n            ```\n\n    A wrapper around `int` that allows for additional constraints.\n\n    Args:\n        strict: Whether to validate the integer in strict mode. Defaults to `None`.\n        gt: The value must be greater than this.\n        ge: The value must be greater than or equal to this.\n        lt: The value must be less than this.\n        le: The value must be less than or equal to this.\n        multiple_of: The value must be a multiple of this.\n\n    Returns:\n        The wrapped integer type.\n\n    ```py\n    from pydantic import BaseModel, ValidationError, conint\n\n    class ConstrainedExample(BaseModel):\n        constrained_int: conint(gt=1)\n\n    m = ConstrainedExample(constrained_int=2)\n    print(repr(m))\n    #> ConstrainedExample(constrained_int=2)\n\n    try:\n        ConstrainedExample(constrained_int=0)\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_int',),\n                'msg': 'Input should be greater than 1',\n                'input': 0,\n                'ctx': {'gt': 1},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        int,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n    ]\n\n\nPositiveInt = Annotated[int, annotated_types.Gt(0)]\n\"\"\"An integer that must be greater than zero.\n\n```py\nfrom pydantic import BaseModel, PositiveInt, ValidationError\n\nclass Model(BaseModel):\n    positive_int: PositiveInt\n\nm = Model(positive_int=1)\nprint(repr(m))\n#> Model(positive_int=1)\n\ntry:\n    Model(positive_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_int',),\n            'msg': 'Input should be greater than 0',\n            'input': -1,\n            'ctx': {'gt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```\n\"\"\"\nNegativeInt = Annotated[int, annotated_types.Lt(0)]\n\"\"\"An integer that must be less than zero.\n\n```py\nfrom pydantic import BaseModel, NegativeInt, ValidationError\n\nclass Model(BaseModel):\n    negative_int: NegativeInt\n\nm = Model(negative_int=-1)\nprint(repr(m))\n#> Model(negative_int=-1)\n\ntry:\n    Model(negative_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_int',),\n            'msg': 'Input should be less than 0',\n            'input': 1,\n            'ctx': {'lt': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n```\n\"\"\"\nNonPositiveInt = Annotated[int, annotated_types.Le(0)]\n\"\"\"An integer that must be less than or equal to zero.\n\n```py\nfrom pydantic import BaseModel, NonPositiveInt, ValidationError\n\nclass Model(BaseModel):\n    non_positive_int: NonPositiveInt\n\nm = Model(non_positive_int=0)\nprint(repr(m))\n#> Model(non_positive_int=0)\n\ntry:\n    Model(non_positive_int=1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_int',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1,\n            'ctx': {'le': 0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n```\n\"\"\"\nNonNegativeInt = Annotated[int, annotated_types.Ge(0)]\n\"\"\"An integer that must be greater than or equal to zero.\n\n```py\nfrom pydantic import BaseModel, NonNegativeInt, ValidationError\n\nclass Model(BaseModel):\n    non_negative_int: NonNegativeInt\n\nm = Model(non_negative_int=0)\nprint(repr(m))\n#> Model(non_negative_int=0)\n\ntry:\n    Model(non_negative_int=-1)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_int',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1,\n            'ctx': {'ge': 0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n```\n\"\"\"\nStrictInt = Annotated[int, Strict()]\n\"\"\"An integer that must be validated in strict mode.\n\n```py\nfrom pydantic import BaseModel, StrictInt, ValidationError\n\nclass StrictIntModel(BaseModel):\n    strict_int: StrictInt\n\ntry:\n    StrictIntModel(strict_int=3.14159)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictIntModel\n    strict_int\n      Input should be a valid integer [type=int_type, input_value=3.14159, input_type=float]\n    '''\n```\n\"\"\"\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FLOAT TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n@_dataclasses.dataclass\nclass AllowInfNan(_fields.PydanticMetadata):\n    \"\"\"A field metadata class to indicate that a field should allow ``-inf``, ``inf``, and ``nan``.\"\"\"\n\n    allow_inf_nan: bool = True\n\n    def __hash__(self) -> int:\n        return hash(self.allow_inf_nan)\n\n\ndef confloat(\n    *,\n    strict: bool | None = None,\n    gt: float | None = None,\n    ge: float | None = None,\n    lt: float | None = None,\n    le: float | None = None,\n    multiple_of: float | None = None,\n    allow_inf_nan: bool | None = None,\n) -> type[float]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `confloat` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, confloat\n\n            class Foo(BaseModel):\n                bar: confloat(strict=True, gt=0)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```py\n            from typing_extensions import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[float, Field(strict=True, gt=0)]\n            ```\n\n    A wrapper around `float` that allows for additional constraints.\n\n    Args:\n        strict: Whether to validate the float in strict mode.\n        gt: The value must be greater than this.\n        ge: The value must be greater than or equal to this.\n        lt: The value must be less than this.\n        le: The value must be less than or equal to this.\n        multiple_of: The value must be a multiple of this.\n        allow_inf_nan: Whether to allow `-inf`, `inf`, and `nan`.\n\n    Returns:\n        The wrapped float type.\n\n    ```py\n    from pydantic import BaseModel, ValidationError, confloat\n\n    class ConstrainedExample(BaseModel):\n        constrained_float: confloat(gt=1.0)\n\n    m = ConstrainedExample(constrained_float=1.1)\n    print(repr(m))\n    #> ConstrainedExample(constrained_float=1.1)\n\n    try:\n        ConstrainedExample(constrained_float=0.9)\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_float',),\n                'msg': 'Input should be greater than 1',\n                'input': 0.9,\n                'ctx': {'gt': 1.0},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        float,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,\n    ]\n\n\nPositiveFloat = Annotated[float, annotated_types.Gt(0)]\n\"\"\"A float that must be greater than zero.\n\n```py\nfrom pydantic import BaseModel, PositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    positive_float: PositiveFloat\n\nm = Model(positive_float=1.0)\nprint(repr(m))\n#> Model(positive_float=1.0)\n\ntry:\n    Model(positive_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than',\n            'loc': ('positive_float',),\n            'msg': 'Input should be greater than 0',\n            'input': -1.0,\n            'ctx': {'gt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than',\n        }\n    ]\n    '''\n```\n\"\"\"\nNegativeFloat = Annotated[float, annotated_types.Lt(0)]\n\"\"\"A float that must be less than zero.\n\n```py\nfrom pydantic import BaseModel, NegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    negative_float: NegativeFloat\n\nm = Model(negative_float=-1.0)\nprint(repr(m))\n#> Model(negative_float=-1.0)\n\ntry:\n    Model(negative_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than',\n            'loc': ('negative_float',),\n            'msg': 'Input should be less than 0',\n            'input': 1.0,\n            'ctx': {'lt': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than',\n        }\n    ]\n    '''\n```\n\"\"\"\nNonPositiveFloat = Annotated[float, annotated_types.Le(0)]\n\"\"\"A float that must be less than or equal to zero.\n\n```py\nfrom pydantic import BaseModel, NonPositiveFloat, ValidationError\n\nclass Model(BaseModel):\n    non_positive_float: NonPositiveFloat\n\nm = Model(non_positive_float=0.0)\nprint(repr(m))\n#> Model(non_positive_float=0.0)\n\ntry:\n    Model(non_positive_float=1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'less_than_equal',\n            'loc': ('non_positive_float',),\n            'msg': 'Input should be less than or equal to 0',\n            'input': 1.0,\n            'ctx': {'le': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/less_than_equal',\n        }\n    ]\n    '''\n```\n\"\"\"\nNonNegativeFloat = Annotated[float, annotated_types.Ge(0)]\n\"\"\"A float that must be greater than or equal to zero.\n\n```py\nfrom pydantic import BaseModel, NonNegativeFloat, ValidationError\n\nclass Model(BaseModel):\n    non_negative_float: NonNegativeFloat\n\nm = Model(non_negative_float=0.0)\nprint(repr(m))\n#> Model(non_negative_float=0.0)\n\ntry:\n    Model(non_negative_float=-1.0)\nexcept ValidationError as e:\n    print(e.errors())\n    '''\n    [\n        {\n            'type': 'greater_than_equal',\n            'loc': ('non_negative_float',),\n            'msg': 'Input should be greater than or equal to 0',\n            'input': -1.0,\n            'ctx': {'ge': 0.0},\n            'url': 'https://errors.pydantic.dev/2/v/greater_than_equal',\n        }\n    ]\n    '''\n```\n\"\"\"\nStrictFloat = Annotated[float, Strict(True)]\n\"\"\"A float that must be validated in strict mode.\n\n```py\nfrom pydantic import BaseModel, StrictFloat, ValidationError\n\nclass StrictFloatModel(BaseModel):\n    strict_float: StrictFloat\n\ntry:\n    StrictFloatModel(strict_float='1.0')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for StrictFloatModel\n    strict_float\n      Input should be a valid number [type=float_type, input_value='1.0', input_type=str]\n    '''\n```\n\"\"\"\nFiniteFloat = Annotated[float, AllowInfNan(False)]\n\"\"\"A float that must be finite (not ``-inf``, ``inf``, or ``nan``).\n\n```py\nfrom pydantic import BaseModel, FiniteFloat\n\nclass Model(BaseModel):\n    finite: FiniteFloat\n\nm = Model(finite=1.0)\nprint(m)\n#> finite=1.0\n```\n\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTES TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\ndef conbytes(\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    strict: bool | None = None,\n) -> type[bytes]:\n    \"\"\"A wrapper around `bytes` that allows for additional constraints.\n\n    Args:\n        min_length: The minimum length of the bytes.\n        max_length: The maximum length of the bytes.\n        strict: Whether to validate the bytes in strict mode.\n\n    Returns:\n        The wrapped bytes type.\n    \"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        bytes,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Len(min_length or 0, max_length),\n    ]\n\n\nStrictBytes = Annotated[bytes, Strict()]\n\"\"\"A bytes that must be validated in strict mode.\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ STRING TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n@_dataclasses.dataclass(frozen=True)\nclass StringConstraints(annotated_types.GroupedMetadata):\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/fields/#string-constraints\n\n    Apply constraints to `str` types.\n\n    Attributes:\n        strip_whitespace: Whether to remove leading and trailing whitespace.\n        to_upper: Whether to convert the string to uppercase.\n        to_lower: Whether to convert the string to lowercase.\n        strict: Whether to validate the string in strict mode.\n        min_length: The minimum length of the string.\n        max_length: The maximum length of the string.\n        pattern: A regex pattern that the string must match.\n    \"\"\"\n\n    strip_whitespace: bool | None = None\n    to_upper: bool | None = None\n    to_lower: bool | None = None\n    strict: bool | None = None\n    min_length: int | None = None\n    max_length: int | None = None\n    pattern: str | Pattern[str] | None = None\n\n    def __iter__(self) -> Iterator[BaseMetadata]:\n        if self.min_length is not None:\n            yield MinLen(self.min_length)\n        if self.max_length is not None:\n            yield MaxLen(self.max_length)\n        if self.strict is not None:\n            yield Strict(self.strict)\n        if (\n            self.strip_whitespace is not None\n            or self.pattern is not None\n            or self.to_lower is not None\n            or self.to_upper is not None\n        ):\n            yield _fields.pydantic_general_metadata(\n                strip_whitespace=self.strip_whitespace,\n                to_upper=self.to_upper,\n                to_lower=self.to_lower,\n                pattern=self.pattern,\n            )\n\n\ndef constr(\n    *,\n    strip_whitespace: bool | None = None,\n    to_upper: bool | None = None,\n    to_lower: bool | None = None,\n    strict: bool | None = None,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    pattern: str | Pattern[str] | None = None,\n) -> type[str]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`StringConstraints`][pydantic.types.StringConstraints] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `constr` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, constr\n\n            class Foo(BaseModel):\n                bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```py\n            from typing_extensions import Annotated\n\n            from pydantic import BaseModel, StringConstraints\n\n            class Foo(BaseModel):\n                bar: Annotated[str, StringConstraints(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')]\n            ```\n\n    A wrapper around `str` that allows for additional constraints.\n\n    ```py\n    from pydantic import BaseModel, constr\n\n    class Foo(BaseModel):\n        bar: constr(strip_whitespace=True, to_upper=True, pattern=r'^[A-Z]+$')\n\n\n    foo = Foo(bar='  hello  ')\n    print(foo)\n    #> bar='HELLO'\n    ```\n\n    Args:\n        strip_whitespace: Whether to remove leading and trailing whitespace.\n        to_upper: Whether to turn all characters to uppercase.\n        to_lower: Whether to turn all characters to lowercase.\n        strict: Whether to validate the string in strict mode.\n        min_length: The minimum length of the string.\n        max_length: The maximum length of the string.\n        pattern: A regex pattern to validate the string against.\n\n    Returns:\n        The wrapped string type.\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        str,\n        StringConstraints(\n            strip_whitespace=strip_whitespace,\n            to_upper=to_upper,\n            to_lower=to_lower,\n            strict=strict,\n            min_length=min_length,\n            max_length=max_length,\n            pattern=pattern,\n        ),\n    ]\n\n\nStrictStr = Annotated[str, Strict()]\n\"\"\"A string that must be validated in strict mode.\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~ COLLECTION TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nHashableItemType = TypeVar('HashableItemType', bound=Hashable)\n\n\ndef conset(\n    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None\n) -> type[set[HashableItemType]]:\n    \"\"\"A wrapper around `typing.Set` that allows for additional constraints.\n\n    Args:\n        item_type: The type of the items in the set.\n        min_length: The minimum length of the set.\n        max_length: The maximum length of the set.\n\n    Returns:\n        The wrapped set type.\n    \"\"\"\n    return Annotated[Set[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n\n\ndef confrozenset(\n    item_type: type[HashableItemType], *, min_length: int | None = None, max_length: int | None = None\n) -> type[frozenset[HashableItemType]]:\n    \"\"\"A wrapper around `typing.FrozenSet` that allows for additional constraints.\n\n    Args:\n        item_type: The type of the items in the frozenset.\n        min_length: The minimum length of the frozenset.\n        max_length: The maximum length of the frozenset.\n\n    Returns:\n        The wrapped frozenset type.\n    \"\"\"\n    return Annotated[FrozenSet[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n\n\nAnyItemType = TypeVar('AnyItemType')\n\n\ndef conlist(\n    item_type: type[AnyItemType],\n    *,\n    min_length: int | None = None,\n    max_length: int | None = None,\n    unique_items: bool | None = None,\n) -> type[list[AnyItemType]]:\n    \"\"\"A wrapper around typing.List that adds validation.\n\n    Args:\n        item_type: The type of the items in the list.\n        min_length: The minimum length of the list. Defaults to None.\n        max_length: The maximum length of the list. Defaults to None.\n        unique_items: Whether the items in the list must be unique. Defaults to None.\n            !!! warning Deprecated\n                The `unique_items` parameter is deprecated, use `Set` instead.\n                See [this issue](https://github.com/pydantic/pydantic-core/issues/296) for more details.\n\n    Returns:\n        The wrapped list type.\n    \"\"\"\n    if unique_items is not None:\n        raise PydanticUserError(\n            (\n                '`unique_items` is removed, use `Set` instead'\n                '(this feature is discussed in https://github.com/pydantic/pydantic-core/issues/296)'\n            ),\n            code='removed-kwargs',\n        )\n    return Annotated[List[item_type], annotated_types.Len(min_length or 0, max_length)]  # pyright: ignore[reportReturnType]\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~ IMPORT STRING TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nAnyType = TypeVar('AnyType')\nif TYPE_CHECKING:\n    ImportString = Annotated[AnyType, ...]\nelse:\n\n    class ImportString:\n        \"\"\"A type that can be used to import a type from a string.\n\n        `ImportString` expects a string and loads the Python object importable at that dotted path.\n        Attributes of modules may be separated from the module by `:` or `.`, e.g. if `'math:cos'` was provided,\n        the resulting field value would be the function`cos`. If a `.` is used and both an attribute and submodule\n        are present at the same path, the module will be preferred.\n\n        On model instantiation, pointers will be evaluated and imported. There is\n        some nuance to this behavior, demonstrated in the examples below.\n\n        **Good behavior:**\n        ```py\n        from math import cos\n\n        from pydantic import BaseModel, Field, ImportString, ValidationError\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # A string value will cause an automatic import\n        my_cos = ImportThings(obj='math.cos')\n\n        # You can use the imported function as you would expect\n        cos_of_0 = my_cos.obj(0)\n        assert cos_of_0 == 1\n\n\n        # A string whose value cannot be imported will raise an error\n        try:\n            ImportThings(obj='foo.bar')\n        except ValidationError as e:\n            print(e)\n            '''\n            1 validation error for ImportThings\n            obj\n            Invalid python path: No module named 'foo.bar' [type=import_error, input_value='foo.bar', input_type=str]\n            '''\n\n\n        # Actual python objects can be assigned as well\n        my_cos = ImportThings(obj=cos)\n        my_cos_2 = ImportThings(obj='math.cos')\n        my_cos_3 = ImportThings(obj='math:cos')\n        assert my_cos == my_cos_2 == my_cos_3\n\n\n        # You can set default field value either as Python object:\n        class ImportThingsDefaultPyObj(BaseModel):\n            obj: ImportString = math.cos\n\n\n        # or as a string value (but only if used with `validate_default=True`)\n        class ImportThingsDefaultString(BaseModel):\n            obj: ImportString = Field(default='math.cos', validate_default=True)\n\n\n        my_cos_default1 = ImportThingsDefaultPyObj()\n        my_cos_default2 = ImportThingsDefaultString()\n        assert my_cos_default1.obj == my_cos_default2.obj == math.cos\n\n\n        # note: this will not work!\n        class ImportThingsMissingValidateDefault(BaseModel):\n            obj: ImportString = 'math.cos'\n\n        my_cos_default3 = ImportThingsMissingValidateDefault()\n        assert my_cos_default3.obj == 'math.cos'  # just string, not evaluated\n        ```\n\n        Serializing an `ImportString` type to json is also possible.\n\n        ```py\n        from pydantic import BaseModel, ImportString\n\n\n        class ImportThings(BaseModel):\n            obj: ImportString\n\n\n        # Create an instance\n        m = ImportThings(obj='math.cos')\n        print(m)\n        #> obj=<built-in function cos>\n        print(m.model_dump_json())\n        #> {\"obj\":\"math.cos\"}\n        ```\n        \"\"\"\n\n        @classmethod\n        def __class_getitem__(cls, item: AnyType) -> AnyType:\n            return Annotated[item, cls()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            serializer = core_schema.plain_serializer_function_ser_schema(cls._serialize, when_used='json')\n            if cls is source:\n                # Treat bare usage of ImportString (`schema is None`) as the same as ImportString[Any]\n                return core_schema.no_info_plain_validator_function(\n                    function=_validators.import_string, serialization=serializer\n                )\n            else:\n                return core_schema.no_info_before_validator_function(\n                    function=_validators.import_string, schema=handler(source), serialization=serializer\n                )\n\n        @classmethod\n        def __get_pydantic_json_schema__(cls, cs: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n            return handler(core_schema.str_schema())\n\n        @staticmethod\n        def _serialize(v: Any) -> str:\n            if isinstance(v, ModuleType):\n                return v.__name__\n            elif hasattr(v, '__module__') and hasattr(v, '__name__'):\n                return f'{v.__module__}.{v.__name__}'\n            else:\n                return v\n\n        def __repr__(self) -> str:\n            return 'ImportString'\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DECIMAL TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\ndef condecimal(\n    *,\n    strict: bool | None = None,\n    gt: int | Decimal | None = None,\n    ge: int | Decimal | None = None,\n    lt: int | Decimal | None = None,\n    le: int | Decimal | None = None,\n    multiple_of: int | Decimal | None = None,\n    max_digits: int | None = None,\n    decimal_places: int | None = None,\n    allow_inf_nan: bool | None = None,\n) -> type[Decimal]:\n    \"\"\"\n    !!! warning \"Discouraged\"\n        This function is **discouraged** in favor of using\n        [`Annotated`](https://docs.python.org/3/library/typing.html#typing.Annotated) with\n        [`Field`][pydantic.fields.Field] instead.\n\n        This function will be **deprecated** in Pydantic 3.0.\n\n        The reason is that `condecimal` returns a type, which doesn't play well with static analysis tools.\n\n        === \":x: Don't do this\"\n            ```py\n            from pydantic import BaseModel, condecimal\n\n            class Foo(BaseModel):\n                bar: condecimal(strict=True, allow_inf_nan=True)\n            ```\n\n        === \":white_check_mark: Do this\"\n            ```py\n            from decimal import Decimal\n\n            from typing_extensions import Annotated\n\n            from pydantic import BaseModel, Field\n\n            class Foo(BaseModel):\n                bar: Annotated[Decimal, Field(strict=True, allow_inf_nan=True)]\n            ```\n\n    A wrapper around Decimal that adds validation.\n\n    Args:\n        strict: Whether to validate the value in strict mode. Defaults to `None`.\n        gt: The value must be greater than this. Defaults to `None`.\n        ge: The value must be greater than or equal to this. Defaults to `None`.\n        lt: The value must be less than this. Defaults to `None`.\n        le: The value must be less than or equal to this. Defaults to `None`.\n        multiple_of: The value must be a multiple of this. Defaults to `None`.\n        max_digits: The maximum number of digits. Defaults to `None`.\n        decimal_places: The number of decimal places. Defaults to `None`.\n        allow_inf_nan: Whether to allow infinity and NaN. Defaults to `None`.\n\n    ```py\n    from decimal import Decimal\n\n    from pydantic import BaseModel, ValidationError, condecimal\n\n    class ConstrainedExample(BaseModel):\n        constrained_decimal: condecimal(gt=Decimal('1.0'))\n\n    m = ConstrainedExample(constrained_decimal=Decimal('1.1'))\n    print(repr(m))\n    #> ConstrainedExample(constrained_decimal=Decimal('1.1'))\n\n    try:\n        ConstrainedExample(constrained_decimal=Decimal('0.9'))\n    except ValidationError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'greater_than',\n                'loc': ('constrained_decimal',),\n                'msg': 'Input should be greater than 1.0',\n                'input': Decimal('0.9'),\n                'ctx': {'gt': Decimal('1.0')},\n                'url': 'https://errors.pydantic.dev/2/v/greater_than',\n            }\n        ]\n        '''\n    ```\n    \"\"\"  # noqa: D212\n    return Annotated[  # pyright: ignore[reportReturnType]\n        Decimal,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n        annotated_types.MultipleOf(multiple_of) if multiple_of is not None else None,\n        _fields.pydantic_general_metadata(max_digits=max_digits, decimal_places=decimal_places),\n        AllowInfNan(allow_inf_nan) if allow_inf_nan is not None else None,\n    ]\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UUID TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass UuidVersion:\n    \"\"\"A field metadata class to indicate a [UUID](https://docs.python.org/3/library/uuid.html) version.\"\"\"\n\n    uuid_version: Literal[1, 3, 4, 5]\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.pop('anyOf', None)  # remove the bytes/str union\n        field_schema.update(type='string', format=f'uuid{self.uuid_version}')\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        if isinstance(self, source):\n            # used directly as a type\n            return core_schema.uuid_schema(version=self.uuid_version)\n        else:\n            # update existing schema with self.uuid_version\n            schema = handler(source)\n            _check_annotated_type(schema['type'], 'uuid', self.__class__.__name__)\n            schema['version'] = self.uuid_version  # type: ignore\n            return schema\n\n    def __hash__(self) -> int:\n        return hash(type(self.uuid_version))\n\n\nUUID1 = Annotated[UUID, UuidVersion(1)]\n\"\"\"A [UUID](https://docs.python.org/3/library/uuid.html) that must be version 1.\n\n```py\nimport uuid\n\nfrom pydantic import UUID1, BaseModel\n\nclass Model(BaseModel):\n    uuid1: UUID1\n\nModel(uuid1=uuid.uuid1())\n```\n\"\"\"\nUUID3 = Annotated[UUID, UuidVersion(3)]\n\"\"\"A [UUID](https://docs.python.org/3/library/uuid.html) that must be version 3.\n\n```py\nimport uuid\n\nfrom pydantic import UUID3, BaseModel\n\nclass Model(BaseModel):\n    uuid3: UUID3\n\nModel(uuid3=uuid.uuid3(uuid.NAMESPACE_DNS, 'pydantic.org'))\n```\n\"\"\"\nUUID4 = Annotated[UUID, UuidVersion(4)]\n\"\"\"A [UUID](https://docs.python.org/3/library/uuid.html) that must be version 4.\n\n```py\nimport uuid\n\nfrom pydantic import UUID4, BaseModel\n\nclass Model(BaseModel):\n    uuid4: UUID4\n\nModel(uuid4=uuid.uuid4())\n```\n\"\"\"\nUUID5 = Annotated[UUID, UuidVersion(5)]\n\"\"\"A [UUID](https://docs.python.org/3/library/uuid.html) that must be version 5.\n\n```py\nimport uuid\n\nfrom pydantic import UUID5, BaseModel\n\nclass Model(BaseModel):\n    uuid5: UUID5\n\nModel(uuid5=uuid.uuid5(uuid.NAMESPACE_DNS, 'pydantic.org'))\n```\n\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PATH TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n@_dataclasses.dataclass\nclass PathType:\n    path_type: Literal['file', 'dir', 'new']\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = handler(core_schema)\n        format_conversion = {'file': 'file-path', 'dir': 'directory-path'}\n        field_schema.update(format=format_conversion.get(self.path_type, 'path'), type='string')\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        function_lookup = {\n            'file': cast(core_schema.WithInfoValidatorFunction, self.validate_file),\n            'dir': cast(core_schema.WithInfoValidatorFunction, self.validate_directory),\n            'new': cast(core_schema.WithInfoValidatorFunction, self.validate_new),\n        }\n\n        return core_schema.with_info_after_validator_function(\n            function_lookup[self.path_type],\n            handler(source),\n        )\n\n    @staticmethod\n    def validate_file(path: Path, _: core_schema.ValidationInfo) -> Path:\n        if path.is_file():\n            return path\n        else:\n            raise PydanticCustomError('path_not_file', 'Path does not point to a file')\n\n    @staticmethod\n    def validate_directory(path: Path, _: core_schema.ValidationInfo) -> Path:\n        if path.is_dir():\n            return path\n        else:\n            raise PydanticCustomError('path_not_directory', 'Path does not point to a directory')\n\n    @staticmethod\n    def validate_new(path: Path, _: core_schema.ValidationInfo) -> Path:\n        if path.exists():\n            raise PydanticCustomError('path_exists', 'Path already exists')\n        elif not path.parent.exists():\n            raise PydanticCustomError('parent_does_not_exist', 'Parent directory does not exist')\n        else:\n            return path\n\n    def __hash__(self) -> int:\n        return hash(type(self.path_type))\n\n\nFilePath = Annotated[Path, PathType('file')]\n\"\"\"A path that must point to a file.\n\n```py\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, FilePath, ValidationError\n\nclass Model(BaseModel):\n    f: FilePath\n\npath = Path('text.txt')\npath.touch()\nm = Model(f='text.txt')\nprint(m.model_dump())\n#> {'f': PosixPath('text.txt')}\npath.unlink()\n\npath = Path('directory')\npath.mkdir(exist_ok=True)\ntry:\n    Model(f='directory')  # directory\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='directory', input_type=str]\n    '''\npath.rmdir()\n\ntry:\n    Model(f='not-exists-file')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a file [type=path_not_file, input_value='not-exists-file', input_type=str]\n    '''\n```\n\"\"\"\nDirectoryPath = Annotated[Path, PathType('dir')]\n\"\"\"A path that must point to a directory.\n\n```py\nfrom pathlib import Path\n\nfrom pydantic import BaseModel, DirectoryPath, ValidationError\n\nclass Model(BaseModel):\n    f: DirectoryPath\n\npath = Path('directory/')\npath.mkdir()\nm = Model(f='directory/')\nprint(m.model_dump())\n#> {'f': PosixPath('directory')}\npath.rmdir()\n\npath = Path('file.txt')\npath.touch()\ntry:\n    Model(f='file.txt')  # file\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='file.txt', input_type=str]\n    '''\npath.unlink()\n\ntry:\n    Model(f='not-exists-directory')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    f\n      Path does not point to a directory [type=path_not_directory, input_value='not-exists-directory', input_type=str]\n    '''\n```\n\"\"\"\nNewPath = Annotated[Path, PathType('new')]\n\"\"\"A path for a new file or directory that must not already exist. The parent directory must already exist.\"\"\"\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JSON TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    # Json[list[str]] will be recognized by type checkers as list[str]\n    Json = Annotated[AnyType, ...]\n\nelse:\n\n    class Json:\n        \"\"\"A special type wrapper which loads JSON before parsing.\n\n        You can use the `Json` data type to make Pydantic first load a raw JSON string before\n        validating the loaded data into the parametrized type:\n\n        ```py\n        from typing import Any, List\n\n        from pydantic import BaseModel, Json, ValidationError\n\n\n        class AnyJsonModel(BaseModel):\n            json_obj: Json[Any]\n\n\n        class ConstrainedJsonModel(BaseModel):\n            json_obj: Json[List[int]]\n\n\n        print(AnyJsonModel(json_obj='{\"b\": 1}'))\n        #> json_obj={'b': 1}\n        print(ConstrainedJsonModel(json_obj='[1, 2, 3]'))\n        #> json_obj=[1, 2, 3]\n\n        try:\n            ConstrainedJsonModel(json_obj=12)\n        except ValidationError as e:\n            print(e)\n            '''\n            1 validation error for ConstrainedJsonModel\n            json_obj\n            JSON input should be string, bytes or bytearray [type=json_type, input_value=12, input_type=int]\n            '''\n\n        try:\n            ConstrainedJsonModel(json_obj='[a, b]')\n        except ValidationError as e:\n            print(e)\n            '''\n            1 validation error for ConstrainedJsonModel\n            json_obj\n            Invalid JSON: expected value at line 1 column 2 [type=json_invalid, input_value='[a, b]', input_type=str]\n            '''\n\n        try:\n            ConstrainedJsonModel(json_obj='[\"a\", \"b\"]')\n        except ValidationError as e:\n            print(e)\n            '''\n            2 validation errors for ConstrainedJsonModel\n            json_obj.0\n            Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='a', input_type=str]\n            json_obj.1\n            Input should be a valid integer, unable to parse string as an integer [type=int_parsing, input_value='b', input_type=str]\n            '''\n        ```\n\n        When you dump the model using `model_dump` or `model_dump_json`, the dumped value will be the result of validation,\n        not the original JSON string. However, you can use the argument `round_trip=True` to get the original JSON string back:\n\n        ```py\n        from typing import List\n\n        from pydantic import BaseModel, Json\n\n\n        class ConstrainedJsonModel(BaseModel):\n            json_obj: Json[List[int]]\n\n\n        print(ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json())\n        #> {\"json_obj\":[1,2,3]}\n        print(\n            ConstrainedJsonModel(json_obj='[1, 2, 3]').model_dump_json(round_trip=True)\n        )\n        #> {\"json_obj\":\"[1,2,3]\"}\n        ```\n        \"\"\"\n\n        @classmethod\n        def __class_getitem__(cls, item: AnyType) -> AnyType:\n            return Annotated[item, cls()]\n\n        @classmethod\n        def __get_pydantic_core_schema__(cls, source: Any, handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n            if cls is source:\n                return core_schema.json_schema(None)\n            else:\n                return core_schema.json_schema(handler(source))\n\n        def __repr__(self) -> str:\n            return 'Json'\n\n        def __hash__(self) -> int:\n            return hash(type(self))\n\n        def __eq__(self, other: Any) -> bool:\n            return type(other) == type(self)\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SECRET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nSecretType = TypeVar('SecretType')\n\n\nclass _SecretBase(Generic[SecretType]):\n    def __init__(self, secret_value: SecretType) -> None:\n        self._secret_value: SecretType = secret_value\n\n    def get_secret_value(self) -> SecretType:\n        \"\"\"Get the secret value.\n\n        Returns:\n            The secret value.\n        \"\"\"\n        return self._secret_value\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __hash__(self) -> int:\n        return hash(self.get_secret_value())\n\n    def __str__(self) -> str:\n        return str(self._display())\n\n    def __repr__(self) -> str:\n        return f'{self.__class__.__name__}({self._display()!r})'\n\n    def _display(self) -> str | bytes:\n        raise NotImplementedError\n\n\nclass Secret(_SecretBase[SecretType]):\n    \"\"\"A generic base class used for defining a field with sensitive information that you do not want to be visible in logging or tracebacks.\n\n    You may either directly parametrize `Secret` with a type, or subclass from `Secret` with a parametrized type. The benefit of subclassing\n    is that you can define a custom `_display` method, which will be used for `repr()` and `str()` methods. The examples below demonstrate both\n    ways of using `Secret` to create a new secret type.\n\n    1. Directly parametrizing `Secret` with a type:\n\n    ```py\n    from pydantic import BaseModel, Secret\n\n    SecretBool = Secret[bool]\n\n    class Model(BaseModel):\n        secret_bool: SecretBool\n\n    m = Model(secret_bool=True)\n    print(m.model_dump())\n    #> {'secret_bool': Secret('**********')}\n\n    print(m.model_dump_json())\n    #> {\"secret_bool\":\"**********\"}\n\n    print(m.secret_bool.get_secret_value())\n    #> True\n    ```\n\n    2. Subclassing from parametrized `Secret`:\n\n    ```py\n    from datetime import date\n\n    from pydantic import BaseModel, Secret\n\n    class SecretDate(Secret[date]):\n        def _display(self) -> str:\n            return '****/**/**'\n\n    class Model(BaseModel):\n        secret_date: SecretDate\n\n    m = Model(secret_date=date(2022, 1, 1))\n    print(m.model_dump())\n    #> {'secret_date': SecretDate('****/**/**')}\n\n    print(m.model_dump_json())\n    #> {\"secret_date\":\"****/**/**\"}\n\n    print(m.secret_date.get_secret_value())\n    #> 2022-01-01\n    ```\n\n    The value returned by the `_display` method will be used for `repr()` and `str()`.\n    \"\"\"\n\n    def _display(self) -> str | bytes:\n        return '**********' if self.get_secret_value() else ''\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        inner_type = None\n        # if origin_type is Secret, then cls is a GenericAlias, and we can extract the inner type directly\n        origin_type = get_origin(source)\n        if origin_type is not None:\n            inner_type = get_args(source)[0]\n        # otherwise, we need to get the inner type from the base class\n        else:\n            bases = getattr(cls, '__orig_bases__', getattr(cls, '__bases__', []))\n            for base in bases:\n                if get_origin(base) is Secret:\n                    inner_type = get_args(base)[0]\n            if bases == [] or inner_type is None:\n                raise TypeError(\n                    f\"Can't get secret type from {cls.__name__}. \"\n                    'Please use Secret[<type>], or subclass from Secret[<type>] instead.'\n                )\n\n        inner_schema = handler.generate_schema(inner_type)  # type: ignore\n\n        def validate_secret_value(value, handler) -> Secret[SecretType]:\n            if isinstance(value, Secret):\n                value = value.get_secret_value()\n            validated_inner = handler(value)\n            return cls(validated_inner)\n\n        def serialize(value: Secret[SecretType], info: core_schema.SerializationInfo) -> str | Secret[SecretType]:\n            if info.mode == 'json':\n                return str(value)\n            else:\n                return value\n\n        return core_schema.json_or_python_schema(\n            python_schema=core_schema.no_info_wrap_validator_function(\n                validate_secret_value,\n                inner_schema,\n            ),\n            json_schema=core_schema.no_info_after_validator_function(lambda x: cls(x), inner_schema),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                serialize,\n                info_arg=True,\n                when_used='always',\n            ),\n        )\n\n\ndef _secret_display(value: SecretType) -> str:  # type: ignore\n    return '**********' if value else ''\n\n\nclass _SecretField(_SecretBase[SecretType]):\n    _inner_schema: ClassVar[CoreSchema]\n    _error_kind: ClassVar[str]\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        def serialize(\n            value: _SecretField[SecretType], info: core_schema.SerializationInfo\n        ) -> str | _SecretField[SecretType]:\n            if info.mode == 'json':\n                # we want the output to always be string without the `b'` prefix for bytes,\n                # hence we just use `secret_display`\n                return _secret_display(value.get_secret_value())\n            else:\n                return value\n\n        def get_json_schema(_core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n            json_schema = handler(cls._inner_schema)\n            _utils.update_not_none(\n                json_schema,\n                type='string',\n                writeOnly=True,\n                format='password',\n            )\n            return json_schema\n\n        json_schema = core_schema.no_info_after_validator_function(\n            source,  # construct the type\n            cls._inner_schema,\n        )\n\n        def get_secret_schema(strict: bool) -> CoreSchema:\n            return core_schema.json_or_python_schema(\n                python_schema=core_schema.union_schema(\n                    [\n                        core_schema.is_instance_schema(source),\n                        json_schema,\n                    ],\n                    custom_error_type=cls._error_kind,\n                    strict=strict,\n                ),\n                json_schema=json_schema,\n                serialization=core_schema.plain_serializer_function_ser_schema(\n                    serialize,\n                    info_arg=True,\n                    return_schema=core_schema.str_schema(),\n                    when_used='json',\n                ),\n            )\n\n        return core_schema.lax_or_strict_schema(\n            lax_schema=get_secret_schema(strict=False),\n            strict_schema=get_secret_schema(strict=True),\n            metadata={'pydantic_js_functions': [get_json_schema]},\n        )\n\n\nclass SecretStr(_SecretField[str]):\n    \"\"\"A string used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\n    When the secret value is nonempty, it is displayed as `'**********'` instead of the underlying value in\n    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `''`.\n\n    ```py\n    from pydantic import BaseModel, SecretStr\n\n    class User(BaseModel):\n        username: str\n        password: SecretStr\n\n    user = User(username='scolvin', password='password1')\n\n    print(user)\n    #> username='scolvin' password=SecretStr('**********')\n    print(user.password.get_secret_value())\n    #> password1\n    print((SecretStr('password'), SecretStr('')))\n    #> (SecretStr('**********'), SecretStr(''))\n    ```\n    \"\"\"\n\n    _inner_schema: ClassVar[CoreSchema] = core_schema.str_schema()\n    _error_kind: ClassVar[str] = 'string_type'\n\n    def __len__(self) -> int:\n        return len(self._secret_value)\n\n    def _display(self) -> str:\n        return _secret_display(self._secret_value)\n\n\nclass SecretBytes(_SecretField[bytes]):\n    \"\"\"A bytes used for storing sensitive information that you do not want to be visible in logging or tracebacks.\n\n    It displays `b'**********'` instead of the string value on `repr()` and `str()` calls.\n    When the secret value is nonempty, it is displayed as `b'**********'` instead of the underlying value in\n    calls to `repr()` and `str()`. If the value _is_ empty, it is displayed as `b''`.\n\n    ```py\n    from pydantic import BaseModel, SecretBytes\n\n    class User(BaseModel):\n        username: str\n        password: SecretBytes\n\n    user = User(username='scolvin', password=b'password1')\n    #> username='scolvin' password=SecretBytes(b'**********')\n    print(user.password.get_secret_value())\n    #> b'password1'\n    print((SecretBytes(b'password'), SecretBytes(b'')))\n    #> (SecretBytes(b'**********'), SecretBytes(b''))\n    ```\n    \"\"\"\n\n    _inner_schema: ClassVar[CoreSchema] = core_schema.bytes_schema()\n    _error_kind: ClassVar[str] = 'bytes_type'\n\n    def __len__(self) -> int:\n        return len(self._secret_value)\n\n    def _display(self) -> bytes:\n        return _secret_display(self._secret_value).encode()\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PAYMENT CARD TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass PaymentCardBrand(str, Enum):\n    amex = 'American Express'\n    mastercard = 'Mastercard'\n    visa = 'Visa'\n    other = 'other'\n\n    def __str__(self) -> str:\n        return self.value\n\n\n@deprecated(\n    'The `PaymentCardNumber` class is deprecated, use `pydantic_extra_types` instead. '\n    'See https://docs.pydantic.dev/latest/api/pydantic_extra_types_payment/#pydantic_extra_types.payment.PaymentCardNumber.',\n    category=PydanticDeprecatedSince20,\n)\nclass PaymentCardNumber(str):\n    \"\"\"Based on: https://en.wikipedia.org/wiki/Payment_card_number.\"\"\"\n\n    strip_whitespace: ClassVar[bool] = True\n    min_length: ClassVar[int] = 12\n    max_length: ClassVar[int] = 19\n    bin: str\n    last4: str\n    brand: PaymentCardBrand\n\n    def __init__(self, card_number: str):\n        self.validate_digits(card_number)\n\n        card_number = self.validate_luhn_check_digit(card_number)\n\n        self.bin = card_number[:6]\n        self.last4 = card_number[-4:]\n        self.brand = self.validate_brand(card_number)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            cls.validate,\n            core_schema.str_schema(\n                min_length=cls.min_length, max_length=cls.max_length, strip_whitespace=cls.strip_whitespace\n            ),\n        )\n\n    @classmethod\n    def validate(cls, input_value: str, /, _: core_schema.ValidationInfo) -> PaymentCardNumber:\n        \"\"\"Validate the card number and return a `PaymentCardNumber` instance.\"\"\"\n        return cls(input_value)\n\n    @property\n    def masked(self) -> str:\n        \"\"\"Mask all but the last 4 digits of the card number.\n\n        Returns:\n            A masked card number string.\n        \"\"\"\n        num_masked = len(self) - 10  # len(bin) + len(last4) == 10\n        return f'{self.bin}{\"*\" * num_masked}{self.last4}'\n\n    @classmethod\n    def validate_digits(cls, card_number: str) -> None:\n        \"\"\"Validate that the card number is all digits.\"\"\"\n        if not card_number.isdigit():\n            raise PydanticCustomError('payment_card_number_digits', 'Card number is not all digits')\n\n    @classmethod\n    def validate_luhn_check_digit(cls, card_number: str) -> str:\n        \"\"\"Based on: https://en.wikipedia.org/wiki/Luhn_algorithm.\"\"\"\n        sum_ = int(card_number[-1])\n        length = len(card_number)\n        parity = length % 2\n        for i in range(length - 1):\n            digit = int(card_number[i])\n            if i % 2 == parity:\n                digit *= 2\n            if digit > 9:\n                digit -= 9\n            sum_ += digit\n        valid = sum_ % 10 == 0\n        if not valid:\n            raise PydanticCustomError('payment_card_number_luhn', 'Card number is not luhn valid')\n        return card_number\n\n    @staticmethod\n    def validate_brand(card_number: str) -> PaymentCardBrand:\n        \"\"\"Validate length based on BIN for major brands:\n        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN).\n        \"\"\"\n        if card_number[0] == '4':\n            brand = PaymentCardBrand.visa\n        elif 51 <= int(card_number[:2]) <= 55:\n            brand = PaymentCardBrand.mastercard\n        elif card_number[:2] in {'34', '37'}:\n            brand = PaymentCardBrand.amex\n        else:\n            brand = PaymentCardBrand.other\n\n        required_length: None | int | str = None\n        if brand in PaymentCardBrand.mastercard:\n            required_length = 16\n            valid = len(card_number) == required_length\n        elif brand == PaymentCardBrand.visa:\n            required_length = '13, 16 or 19'\n            valid = len(card_number) in {13, 16, 19}\n        elif brand == PaymentCardBrand.amex:\n            required_length = 15\n            valid = len(card_number) == required_length\n        else:\n            valid = True\n\n        if not valid:\n            raise PydanticCustomError(\n                'payment_card_number_brand',\n                'Length for a {brand} card must be {required_length}',\n                {'brand': brand, 'required_length': required_length},\n            )\n        return brand\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTE SIZE TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ByteSize(int):\n    \"\"\"Converts a string representing a number of bytes with units (such as `'1KB'` or `'11.5MiB'`) into an integer.\n\n    You can use the `ByteSize` data type to (case-insensitively) convert a string representation of a number of bytes into\n    an integer, and also to print out human-readable strings representing a number of bytes.\n\n    In conformance with [IEC 80000-13 Standard](https://en.wikipedia.org/wiki/ISO/IEC_80000) we interpret `'1KB'` to mean 1000 bytes,\n    and `'1KiB'` to mean 1024 bytes. In general, including a middle `'i'` will cause the unit to be interpreted as a power of 2,\n    rather than a power of 10 (so, for example, `'1 MB'` is treated as `1_000_000` bytes, whereas `'1 MiB'` is treated as `1_048_576` bytes).\n\n    !!! info\n        Note that `1b` will be parsed as \"1 byte\" and not \"1 bit\".\n\n    ```py\n    from pydantic import BaseModel, ByteSize\n\n    class MyModel(BaseModel):\n        size: ByteSize\n\n    print(MyModel(size=52000).size)\n    #> 52000\n    print(MyModel(size='3000 KiB').size)\n    #> 3072000\n\n    m = MyModel(size='50 PB')\n    print(m.size.human_readable())\n    #> 44.4PiB\n    print(m.size.human_readable(decimal=True))\n    #> 50.0PB\n    print(m.size.human_readable(separator=' '))\n    #> 44.4 PiB\n\n    print(m.size.to('TiB'))\n    #> 45474.73508864641\n    ```\n    \"\"\"\n\n    byte_sizes = {\n        'b': 1,\n        'kb': 10**3,\n        'mb': 10**6,\n        'gb': 10**9,\n        'tb': 10**12,\n        'pb': 10**15,\n        'eb': 10**18,\n        'kib': 2**10,\n        'mib': 2**20,\n        'gib': 2**30,\n        'tib': 2**40,\n        'pib': 2**50,\n        'eib': 2**60,\n        'bit': 1 / 8,\n        'kbit': 10**3 / 8,\n        'mbit': 10**6 / 8,\n        'gbit': 10**9 / 8,\n        'tbit': 10**12 / 8,\n        'pbit': 10**15 / 8,\n        'ebit': 10**18 / 8,\n        'kibit': 2**10 / 8,\n        'mibit': 2**20 / 8,\n        'gibit': 2**30 / 8,\n        'tibit': 2**40 / 8,\n        'pibit': 2**50 / 8,\n        'eibit': 2**60 / 8,\n    }\n    byte_sizes.update({k.lower()[0]: v for k, v in byte_sizes.items() if 'i' not in k})\n\n    byte_string_pattern = r'^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?'\n    byte_string_re = re.compile(byte_string_pattern, re.IGNORECASE)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            function=cls._validate,\n            schema=core_schema.union_schema(\n                [\n                    core_schema.str_schema(pattern=cls.byte_string_pattern),\n                    core_schema.int_schema(ge=0),\n                ],\n                custom_error_type='byte_size',\n                custom_error_message='could not parse value and unit from byte string',\n            ),\n            serialization=core_schema.plain_serializer_function_ser_schema(\n                int, return_schema=core_schema.int_schema(ge=0)\n            ),\n        )\n\n    @classmethod\n    def _validate(cls, input_value: Any, /, _: core_schema.ValidationInfo) -> ByteSize:\n        try:\n            return cls(int(input_value))\n        except ValueError:\n            pass\n\n        str_match = cls.byte_string_re.match(str(input_value))\n        if str_match is None:\n            raise PydanticCustomError('byte_size', 'could not parse value and unit from byte string')\n\n        scalar, unit = str_match.groups()\n        if unit is None:\n            unit = 'b'\n\n        try:\n            unit_mult = cls.byte_sizes[unit.lower()]\n        except KeyError:\n            raise PydanticCustomError('byte_size_unit', 'could not interpret byte unit: {unit}', {'unit': unit})\n\n        return cls(int(float(scalar) * unit_mult))\n\n    def human_readable(self, decimal: bool = False, separator: str = '') -> str:\n        \"\"\"Converts a byte size to a human readable string.\n\n        Args:\n            decimal: If True, use decimal units (e.g. 1000 bytes per KB). If False, use binary units\n                (e.g. 1024 bytes per KiB).\n            separator: A string used to split the value and unit. Defaults to an empty string ('').\n\n        Returns:\n            A human readable string representation of the byte size.\n        \"\"\"\n        if decimal:\n            divisor = 1000\n            units = 'B', 'KB', 'MB', 'GB', 'TB', 'PB'\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = 'B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'\n            final_unit = 'EiB'\n\n        num = float(self)\n        for unit in units:\n            if abs(num) < divisor:\n                if unit == 'B':\n                    return f'{num:0.0f}{separator}{unit}'\n                else:\n                    return f'{num:0.1f}{separator}{unit}'\n            num /= divisor\n\n        return f'{num:0.1f}{separator}{final_unit}'\n\n    def to(self, unit: str) -> float:\n        \"\"\"Converts a byte size to another unit, including both byte and bit units.\n\n        Args:\n            unit: The unit to convert to. Must be one of the following: B, KB, MB, GB, TB, PB, EB,\n                KiB, MiB, GiB, TiB, PiB, EiB (byte units) and\n                bit, kbit, mbit, gbit, tbit, pbit, ebit,\n                kibit, mibit, gibit, tibit, pibit, eibit (bit units).\n\n        Returns:\n            The byte size in the new unit.\n        \"\"\"\n        try:\n            unit_div = self.byte_sizes[unit.lower()]\n        except KeyError:\n            raise PydanticCustomError('byte_size_unit', 'Could not interpret byte unit: {unit}', {'unit': unit})\n\n        return self / unit_div\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATE TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\ndef _check_annotated_type(annotated_type: str, expected_type: str, annotation: str) -> None:\n    if annotated_type != expected_type:\n        raise PydanticUserError(f\"'{annotation}' cannot annotate '{annotated_type}'.\", code='invalid_annotated_type')\n\n\nif TYPE_CHECKING:\n    PastDate = Annotated[date, ...]\n    FutureDate = Annotated[date, ...]\nelse:\n\n    class PastDate:\n        \"\"\"A date in the past.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.date_schema(now_op='past')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'date', cls.__name__)\n                schema['now_op'] = 'past'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'PastDate'\n\n    class FutureDate:\n        \"\"\"A date in the future.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.date_schema(now_op='future')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'date', cls.__name__)\n                schema['now_op'] = 'future'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'FutureDate'\n\n\ndef condate(\n    *,\n    strict: bool | None = None,\n    gt: date | None = None,\n    ge: date | None = None,\n    lt: date | None = None,\n    le: date | None = None,\n) -> type[date]:\n    \"\"\"A wrapper for date that adds constraints.\n\n    Args:\n        strict: Whether to validate the date value in strict mode. Defaults to `None`.\n        gt: The value must be greater than this. Defaults to `None`.\n        ge: The value must be greater than or equal to this. Defaults to `None`.\n        lt: The value must be less than this. Defaults to `None`.\n        le: The value must be less than or equal to this. Defaults to `None`.\n\n    Returns:\n        A date type with the specified constraints.\n    \"\"\"\n    return Annotated[  # pyright: ignore[reportReturnType]\n        date,\n        Strict(strict) if strict is not None else None,\n        annotated_types.Interval(gt=gt, ge=ge, lt=lt, le=le),\n    ]\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATETIME TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    AwareDatetime = Annotated[datetime, ...]\n    NaiveDatetime = Annotated[datetime, ...]\n    PastDatetime = Annotated[datetime, ...]\n    FutureDatetime = Annotated[datetime, ...]\n\nelse:\n\n    class AwareDatetime:\n        \"\"\"A datetime that requires timezone info.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.datetime_schema(tz_constraint='aware')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n                schema['tz_constraint'] = 'aware'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'AwareDatetime'\n\n    class NaiveDatetime:\n        \"\"\"A datetime that doesn't require timezone info.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.datetime_schema(tz_constraint='naive')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n                schema['tz_constraint'] = 'naive'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'NaiveDatetime'\n\n    class PastDatetime:\n        \"\"\"A datetime that must be in the past.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.datetime_schema(now_op='past')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n                schema['now_op'] = 'past'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'PastDatetime'\n\n    class FutureDatetime:\n        \"\"\"A datetime that must be in the future.\"\"\"\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls, source: type[Any], handler: GetCoreSchemaHandler\n        ) -> core_schema.CoreSchema:\n            if cls is source:\n                # used directly as a type\n                return core_schema.datetime_schema(now_op='future')\n            else:\n                schema = handler(source)\n                _check_annotated_type(schema['type'], 'datetime', cls.__name__)\n                schema['now_op'] = 'future'\n                return schema\n\n        def __repr__(self) -> str:\n            return 'FutureDatetime'\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Encoded TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass EncoderProtocol(Protocol):\n    \"\"\"Protocol for encoding and decoding data to and from bytes.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        \"\"\"Decode the data using the encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        ...\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data using the encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        ...\n\n    @classmethod\n    def get_json_format(cls) -> str:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        ...\n\n\nclass Base64Encoder(EncoderProtocol):\n    \"\"\"Standard (non-URL-safe) Base64 encoder.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        try:\n            return base64.decodebytes(data)\n        except ValueError as e:\n            raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return base64.encodebytes(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64']:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        return 'base64'\n\n\nclass Base64UrlEncoder(EncoderProtocol):\n    \"\"\"URL-safe Base64 encoder.\"\"\"\n\n    @classmethod\n    def decode(cls, data: bytes) -> bytes:\n        \"\"\"Decode the data from base64 encoded bytes to original bytes data.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        try:\n            return base64.urlsafe_b64decode(data)\n        except ValueError as e:\n            raise PydanticCustomError('base64_decode', \"Base64 decoding error: '{error}'\", {'error': str(e)})\n\n    @classmethod\n    def encode(cls, value: bytes) -> bytes:\n        \"\"\"Encode the data from bytes to a base64 encoded bytes.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return base64.urlsafe_b64encode(value)\n\n    @classmethod\n    def get_json_format(cls) -> Literal['base64url']:\n        \"\"\"Get the JSON format for the encoded data.\n\n        Returns:\n            The JSON format for the encoded data.\n        \"\"\"\n        return 'base64url'\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass EncodedBytes:\n    \"\"\"A bytes type that is encoded and decoded using the specified encoder.\n\n    `EncodedBytes` needs an encoder that implements `EncoderProtocol` to operate.\n\n    ```py\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, EncodedBytes, EncoderProtocol, ValidationError\n\n    class MyEncoder(EncoderProtocol):\n        @classmethod\n        def decode(cls, data: bytes) -> bytes:\n            if data == b'**undecodable**':\n                raise ValueError('Cannot decode data')\n            return data[13:]\n\n        @classmethod\n        def encode(cls, value: bytes) -> bytes:\n            return b'**encoded**: ' + value\n\n        @classmethod\n        def get_json_format(cls) -> str:\n            return 'my-encoder'\n\n    MyEncodedBytes = Annotated[bytes, EncodedBytes(encoder=MyEncoder)]\n\n    class Model(BaseModel):\n        my_encoded_bytes: MyEncodedBytes\n\n    # Initialize the model with encoded data\n    m = Model(my_encoded_bytes=b'**encoded**: some bytes')\n\n    # Access decoded value\n    print(m.my_encoded_bytes)\n    #> b'some bytes'\n\n    # Serialize into the encoded form\n    print(m.model_dump())\n    #> {'my_encoded_bytes': b'**encoded**: some bytes'}\n\n    # Validate encoded data\n    try:\n        Model(my_encoded_bytes=b'**undecodable**')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        my_encoded_bytes\n          Value error, Cannot decode data [type=value_error, input_value=b'**undecodable**', input_type=bytes]\n        '''\n    ```\n    \"\"\"\n\n    encoder: type[EncoderProtocol]\n\n    def __get_pydantic_json_schema__(\n        self, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.update(type='string', format=self.encoder.get_json_format())\n        return field_schema\n\n    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            function=self.decode,\n            schema=core_schema.bytes_schema(),\n            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode),\n        )\n\n    def decode(self, data: bytes, _: core_schema.ValidationInfo) -> bytes:\n        \"\"\"Decode the data using the specified encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        return self.encoder.decode(data)\n\n    def encode(self, value: bytes) -> bytes:\n        \"\"\"Encode the data using the specified encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return self.encoder.encode(value)\n\n    def __hash__(self) -> int:\n        return hash(self.encoder)\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass EncodedStr(EncodedBytes):\n    \"\"\"A str type that is encoded and decoded using the specified encoder.\n\n    `EncodedStr` needs an encoder that implements `EncoderProtocol` to operate.\n\n    ```py\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, EncodedStr, EncoderProtocol, ValidationError\n\n    class MyEncoder(EncoderProtocol):\n        @classmethod\n        def decode(cls, data: bytes) -> bytes:\n            if data == b'**undecodable**':\n                raise ValueError('Cannot decode data')\n            return data[13:]\n\n        @classmethod\n        def encode(cls, value: bytes) -> bytes:\n            return b'**encoded**: ' + value\n\n        @classmethod\n        def get_json_format(cls) -> str:\n            return 'my-encoder'\n\n    MyEncodedStr = Annotated[str, EncodedStr(encoder=MyEncoder)]\n\n    class Model(BaseModel):\n        my_encoded_str: MyEncodedStr\n\n    # Initialize the model with encoded data\n    m = Model(my_encoded_str='**encoded**: some str')\n\n    # Access decoded value\n    print(m.my_encoded_str)\n    #> some str\n\n    # Serialize into the encoded form\n    print(m.model_dump())\n    #> {'my_encoded_str': '**encoded**: some str'}\n\n    # Validate encoded data\n    try:\n        Model(my_encoded_str='**undecodable**')\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        my_encoded_str\n          Value error, Cannot decode data [type=value_error, input_value='**undecodable**', input_type=str]\n        '''\n    ```\n    \"\"\"\n\n    def __get_pydantic_core_schema__(self, source: type[Any], handler: GetCoreSchemaHandler) -> core_schema.CoreSchema:\n        return core_schema.with_info_after_validator_function(\n            function=self.decode_str,\n            schema=super(EncodedStr, self).__get_pydantic_core_schema__(source=source, handler=handler),  # noqa: UP008\n            serialization=core_schema.plain_serializer_function_ser_schema(function=self.encode_str),\n        )\n\n    def decode_str(self, data: bytes, _: core_schema.ValidationInfo) -> str:\n        \"\"\"Decode the data using the specified encoder.\n\n        Args:\n            data: The data to decode.\n\n        Returns:\n            The decoded data.\n        \"\"\"\n        return data.decode()\n\n    def encode_str(self, value: str) -> str:\n        \"\"\"Encode the data using the specified encoder.\n\n        Args:\n            value: The data to encode.\n\n        Returns:\n            The encoded data.\n        \"\"\"\n        return super(EncodedStr, self).encode(value=value.encode()).decode()  # noqa: UP008\n\n    def __hash__(self) -> int:\n        return hash(self.encoder)\n\n\nBase64Bytes = Annotated[bytes, EncodedBytes(encoder=Base64Encoder)]\n\"\"\"A bytes type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.\n\nNote:\n    Under the hood, `Base64Bytes` use standard library `base64.encodebytes` and `base64.decodebytes` functions.\n\n    As a result, attempting to decode url-safe base64 data using the `Base64Bytes` type may fail or produce an incorrect\n    decoding.\n\n```py\nfrom pydantic import Base64Bytes, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_bytes: Base64Bytes\n\n# Initialize the model with base64 data\nm = Model(base64_bytes=b'VGhpcyBpcyB0aGUgd2F5')\n\n# Access decoded value\nprint(m.base64_bytes)\n#> b'This is the way'\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#> {'base64_bytes': b'VGhpcyBpcyB0aGUgd2F5\\n'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_bytes=b'undecodable').base64_bytes)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_bytes\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value=b'undecodable', input_type=bytes]\n    '''\n```\n\"\"\"\nBase64Str = Annotated[str, EncodedStr(encoder=Base64Encoder)]\n\"\"\"A str type that is encoded and decoded using the standard (non-URL-safe) base64 encoder.\n\nNote:\n    Under the hood, `Base64Bytes` use standard library `base64.encodebytes` and `base64.decodebytes` functions.\n\n    As a result, attempting to decode url-safe base64 data using the `Base64Str` type may fail or produce an incorrect\n    decoding.\n\n```py\nfrom pydantic import Base64Str, BaseModel, ValidationError\n\nclass Model(BaseModel):\n    base64_str: Base64Str\n\n# Initialize the model with base64 data\nm = Model(base64_str='VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y')\n\n# Access decoded value\nprint(m.base64_str)\n#> These aren't the droids you're looking for\n\n# Serialize into the base64 form\nprint(m.model_dump())\n#> {'base64_str': 'VGhlc2UgYXJlbid0IHRoZSBkcm9pZHMgeW91J3JlIGxvb2tpbmcgZm9y\\n'}\n\n# Validate base64 data\ntry:\n    print(Model(base64_str='undecodable').base64_str)\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for Model\n    base64_str\n      Base64 decoding error: 'Incorrect padding' [type=base64_decode, input_value='undecodable', input_type=str]\n    '''\n```\n\"\"\"\nBase64UrlBytes = Annotated[bytes, EncodedBytes(encoder=Base64UrlEncoder)]\n\"\"\"A bytes type that is encoded and decoded using the URL-safe base64 encoder.\n\nNote:\n    Under the hood, `Base64UrlBytes` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\n    functions.\n\n    As a result, the `Base64UrlBytes` type can be used to faithfully decode \"vanilla\" base64 data\n    (using `'+'` and `'/'`).\n\n```py\nfrom pydantic import Base64UrlBytes, BaseModel\n\nclass Model(BaseModel):\n    base64url_bytes: Base64UrlBytes\n\n# Initialize the model with base64 data\nm = Model(base64url_bytes=b'SHc_dHc-TXc==')\nprint(m)\n#> base64url_bytes=b'Hw?tw>Mw'\n```\n\"\"\"\nBase64UrlStr = Annotated[str, EncodedStr(encoder=Base64UrlEncoder)]\n\"\"\"A str type that is encoded and decoded using the URL-safe base64 encoder.\n\nNote:\n    Under the hood, `Base64UrlStr` use standard library `base64.urlsafe_b64encode` and `base64.urlsafe_b64decode`\n    functions.\n\n    As a result, the `Base64UrlStr` type can be used to faithfully decode \"vanilla\" base64 data (using `'+'` and `'/'`).\n\n```py\nfrom pydantic import Base64UrlStr, BaseModel\n\nclass Model(BaseModel):\n    base64url_str: Base64UrlStr\n\n# Initialize the model with base64 data\nm = Model(base64url_str='SHc_dHc-TXc==')\nprint(m)\n#> base64url_str='Hw?tw>Mw'\n```\n\"\"\"\n\n\n__getattr__ = getattr_migration(__name__)\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass GetPydanticSchema:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/types/#using-getpydanticschema-to-reduce-boilerplate\n\n    A convenience class for creating an annotation that provides pydantic custom type hooks.\n\n    This class is intended to eliminate the need to create a custom \"marker\" which defines the\n     `__get_pydantic_core_schema__` and `__get_pydantic_json_schema__` custom hook methods.\n\n    For example, to have a field treated by type checkers as `int`, but by pydantic as `Any`, you can do:\n    ```python\n    from typing import Any\n\n    from typing_extensions import Annotated\n\n    from pydantic import BaseModel, GetPydanticSchema\n\n    HandleAsAny = GetPydanticSchema(lambda _s, h: h(Any))\n\n    class Model(BaseModel):\n        x: Annotated[int, HandleAsAny]  # pydantic sees `x: Any`\n\n    print(repr(Model(x='abc').x))\n    #> 'abc'\n    ```\n    \"\"\"\n\n    get_pydantic_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema] | None = None\n    get_pydantic_json_schema: Callable[[Any, GetJsonSchemaHandler], JsonSchemaValue] | None = None\n\n    # Note: we may want to consider adding a convenience staticmethod `def for_type(type_: Any) -> GetPydanticSchema:`\n    #   which returns `GetPydanticSchema(lambda _s, h: h(type_))`\n\n    if not TYPE_CHECKING:\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n\n        def __getattr__(self, item: str) -> Any:\n            \"\"\"Use this rather than defining `__get_pydantic_core_schema__` etc. to reduce the number of nested calls.\"\"\"\n            if item == '__get_pydantic_core_schema__' and self.get_pydantic_core_schema:\n                return self.get_pydantic_core_schema\n            elif item == '__get_pydantic_json_schema__' and self.get_pydantic_json_schema:\n                return self.get_pydantic_json_schema\n            else:\n                return object.__getattribute__(self, item)\n\n    __hash__ = object.__hash__\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass Tag:\n    \"\"\"Provides a way to specify the expected tag to use for a case of a (callable) discriminated union.\n\n    Also provides a way to label a union case in error messages.\n\n    When using a callable `Discriminator`, attach a `Tag` to each case in the `Union` to specify the tag that\n    should be used to identify that case. For example, in the below example, the `Tag` is used to specify that\n    if `get_discriminator_value` returns `'apple'`, the input should be validated as an `ApplePie`, and if it\n    returns `'pumpkin'`, the input should be validated as a `PumpkinPie`.\n\n    The primary role of the `Tag` here is to map the return value from the callable `Discriminator` function to\n    the appropriate member of the `Union` in question.\n\n    ```py\n    from typing import Any, Union\n\n    from typing_extensions import Annotated, Literal\n\n    from pydantic import BaseModel, Discriminator, Tag\n\n    class Pie(BaseModel):\n        time_to_cook: int\n        num_ingredients: int\n\n    class ApplePie(Pie):\n        fruit: Literal['apple'] = 'apple'\n\n    class PumpkinPie(Pie):\n        filling: Literal['pumpkin'] = 'pumpkin'\n\n    def get_discriminator_value(v: Any) -> str:\n        if isinstance(v, dict):\n            return v.get('fruit', v.get('filling'))\n        return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n    class ThanksgivingDinner(BaseModel):\n        dessert: Annotated[\n            Union[\n                Annotated[ApplePie, Tag('apple')],\n                Annotated[PumpkinPie, Tag('pumpkin')],\n            ],\n            Discriminator(get_discriminator_value),\n        ]\n\n    apple_variation = ThanksgivingDinner.model_validate(\n        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n    )\n    print(repr(apple_variation))\n    '''\n    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n    '''\n\n    pumpkin_variation = ThanksgivingDinner.model_validate(\n        {\n            'dessert': {\n                'filling': 'pumpkin',\n                'time_to_cook': 40,\n                'num_ingredients': 6,\n            }\n        }\n    )\n    print(repr(pumpkin_variation))\n    '''\n    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n    '''\n    ```\n\n    !!! note\n        You must specify a `Tag` for every case in a `Tag` that is associated with a\n        callable `Discriminator`. Failing to do so will result in a `PydanticUserError` with code\n        [`callable-discriminator-no-tag`](../errors/usage_errors.md#callable-discriminator-no-tag).\n\n    See the [Discriminated Unions] concepts docs for more details on how to use `Tag`s.\n\n    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    tag: str\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        schema = handler(source_type)\n        metadata = schema.setdefault('metadata', {})\n        assert isinstance(metadata, dict)\n        metadata[_core_utils.TAGGED_UNION_TAG_KEY] = self.tag\n        return schema\n\n\n@_dataclasses.dataclass(**_internal_dataclass.slots_true, frozen=True)\nclass Discriminator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/unions/#discriminated-unions-with-callable-discriminator\n\n    Provides a way to use a custom callable as the way to extract the value of a union discriminator.\n\n    This allows you to get validation behavior like you'd get from `Field(discriminator=<field_name>)`,\n    but without needing to have a single shared field across all the union choices. This also makes it\n    possible to handle unions of models and primitive types with discriminated-union-style validation errors.\n    Finally, this allows you to use a custom callable as the way to identify which member of a union a value\n    belongs to, while still seeing all the performance benefits of a discriminated union.\n\n    Consider this example, which is much more performant with the use of `Discriminator` and thus a `TaggedUnion`\n    than it would be as a normal `Union`.\n\n    ```py\n    from typing import Any, Union\n\n    from typing_extensions import Annotated, Literal\n\n    from pydantic import BaseModel, Discriminator, Tag\n\n    class Pie(BaseModel):\n        time_to_cook: int\n        num_ingredients: int\n\n    class ApplePie(Pie):\n        fruit: Literal['apple'] = 'apple'\n\n    class PumpkinPie(Pie):\n        filling: Literal['pumpkin'] = 'pumpkin'\n\n    def get_discriminator_value(v: Any) -> str:\n        if isinstance(v, dict):\n            return v.get('fruit', v.get('filling'))\n        return getattr(v, 'fruit', getattr(v, 'filling', None))\n\n    class ThanksgivingDinner(BaseModel):\n        dessert: Annotated[\n            Union[\n                Annotated[ApplePie, Tag('apple')],\n                Annotated[PumpkinPie, Tag('pumpkin')],\n            ],\n            Discriminator(get_discriminator_value),\n        ]\n\n    apple_variation = ThanksgivingDinner.model_validate(\n        {'dessert': {'fruit': 'apple', 'time_to_cook': 60, 'num_ingredients': 8}}\n    )\n    print(repr(apple_variation))\n    '''\n    ThanksgivingDinner(dessert=ApplePie(time_to_cook=60, num_ingredients=8, fruit='apple'))\n    '''\n\n    pumpkin_variation = ThanksgivingDinner.model_validate(\n        {\n            'dessert': {\n                'filling': 'pumpkin',\n                'time_to_cook': 40,\n                'num_ingredients': 6,\n            }\n        }\n    )\n    print(repr(pumpkin_variation))\n    '''\n    ThanksgivingDinner(dessert=PumpkinPie(time_to_cook=40, num_ingredients=6, filling='pumpkin'))\n    '''\n    ```\n\n    See the [Discriminated Unions] concepts docs for more details on how to use `Discriminator`s.\n\n    [Discriminated Unions]: ../concepts/unions.md#discriminated-unions\n    \"\"\"\n\n    discriminator: str | Callable[[Any], Hashable]\n    \"\"\"The callable or field name for discriminating the type in a tagged union.\n\n    A `Callable` discriminator must extract the value of the discriminator from the input.\n    A `str` discriminator must be the name of a field to discriminate against.\n    \"\"\"\n    custom_error_type: str | None = None\n    \"\"\"Type to use in [custom errors](../errors/errors.md#custom-errors) replacing the standard discriminated union\n    validation errors.\n    \"\"\"\n    custom_error_message: str | None = None\n    \"\"\"Message to use in custom errors.\"\"\"\n    custom_error_context: dict[str, int | str | float] | None = None\n    \"\"\"Context to use in custom errors.\"\"\"\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        origin = _typing_extra.get_origin(source_type)\n        if not origin or not _typing_extra.origin_is_union(origin):\n            raise TypeError(f'{type(self).__name__} must be used with a Union type, not {source_type}')\n\n        if isinstance(self.discriminator, str):\n            from pydantic import Field\n\n            return handler(Annotated[source_type, Field(discriminator=self.discriminator)])\n        else:\n            original_schema = handler(source_type)\n            return self._convert_schema(original_schema)\n\n    def _convert_schema(self, original_schema: core_schema.CoreSchema) -> core_schema.TaggedUnionSchema:\n        if original_schema['type'] != 'union':\n            # This likely indicates that the schema was a single-item union that was simplified.\n            # In this case, we do the same thing we do in\n            # `pydantic._internal._discriminated_union._ApplyInferredDiscriminator._apply_to_root`, namely,\n            # package the generated schema back into a single-item union.\n            original_schema = core_schema.union_schema([original_schema])\n\n        tagged_union_choices = {}\n        for i, choice in enumerate(original_schema['choices']):\n            tag = None\n            if isinstance(choice, tuple):\n                choice, tag = choice\n            metadata = choice.get('metadata')\n            if metadata is not None:\n                metadata_tag = metadata.get(_core_utils.TAGGED_UNION_TAG_KEY)\n                if metadata_tag is not None:\n                    tag = metadata_tag\n            if tag is None:\n                raise PydanticUserError(\n                    f'`Tag` not provided for choice {choice} used with `Discriminator`',\n                    code='callable-discriminator-no-tag',\n                )\n            tagged_union_choices[tag] = choice\n\n        # Have to do these verbose checks to ensure falsy values ('' and {}) don't get ignored\n        custom_error_type = self.custom_error_type\n        if custom_error_type is None:\n            custom_error_type = original_schema.get('custom_error_type')\n\n        custom_error_message = self.custom_error_message\n        if custom_error_message is None:\n            custom_error_message = original_schema.get('custom_error_message')\n\n        custom_error_context = self.custom_error_context\n        if custom_error_context is None:\n            custom_error_context = original_schema.get('custom_error_context')\n\n        custom_error_type = original_schema.get('custom_error_type') if custom_error_type is None else custom_error_type\n        return core_schema.tagged_union_schema(\n            tagged_union_choices,\n            self.discriminator,\n            custom_error_type=custom_error_type,\n            custom_error_message=custom_error_message,\n            custom_error_context=custom_error_context,\n            strict=original_schema.get('strict'),\n            ref=original_schema.get('ref'),\n            metadata=original_schema.get('metadata'),\n            serialization=original_schema.get('serialization'),\n        )\n\n\n_JSON_TYPES = {int, float, str, bool, list, dict, type(None)}\n\n\ndef _get_type_name(x: Any) -> str:\n    type_ = type(x)\n    if type_ in _JSON_TYPES:\n        return type_.__name__\n\n    # Handle proper subclasses; note we don't need to handle None or bool here\n    if isinstance(x, int):\n        return 'int'\n    if isinstance(x, float):\n        return 'float'\n    if isinstance(x, str):\n        return 'str'\n    if isinstance(x, list):\n        return 'list'\n    if isinstance(x, dict):\n        return 'dict'\n\n    # Fail by returning the type's actual name\n    return getattr(type_, '__name__', '<no type name>')\n\n\nclass _AllowAnyJson:\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        python_schema = handler(source_type)\n        return core_schema.json_or_python_schema(json_schema=core_schema.any_schema(), python_schema=python_schema)\n\n\nif TYPE_CHECKING:\n    # This seems to only be necessary for mypy\n    JsonValue: TypeAlias = Union[\n        List['JsonValue'],\n        Dict[str, 'JsonValue'],\n        str,\n        bool,\n        int,\n        float,\n        None,\n    ]\n    \"\"\"A `JsonValue` is used to represent a value that can be serialized to JSON.\n\n    It may be one of:\n\n    * `List['JsonValue']`\n    * `Dict[str, 'JsonValue']`\n    * `str`\n    * `bool`\n    * `int`\n    * `float`\n    * `None`\n\n    The following example demonstrates how to use `JsonValue` to validate JSON data,\n    and what kind of errors to expect when input data is not json serializable.\n\n    ```py\n    import json\n\n    from pydantic import BaseModel, JsonValue, ValidationError\n\n    class Model(BaseModel):\n        j: JsonValue\n\n    valid_json_data = {'j': {'a': {'b': {'c': 1, 'd': [2, None]}}}}\n    invalid_json_data = {'j': {'a': {'b': ...}}}\n\n    print(repr(Model.model_validate(valid_json_data)))\n    #> Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\n    print(repr(Model.model_validate_json(json.dumps(valid_json_data))))\n    #> Model(j={'a': {'b': {'c': 1, 'd': [2, None]}}})\n\n    try:\n        Model.model_validate(invalid_json_data)\n    except ValidationError as e:\n        print(e)\n        '''\n        1 validation error for Model\n        j.dict.a.dict.b\n          input was not a valid JSON value [type=invalid-json-value, input_value=Ellipsis, input_type=ellipsis]\n        '''\n    ```\n    \"\"\"\n\nelse:\n    JsonValue = TypeAliasType(\n        'JsonValue',\n        Annotated[\n            Union[\n                Annotated[List['JsonValue'], Tag('list')],\n                Annotated[Dict[str, 'JsonValue'], Tag('dict')],\n                Annotated[str, Tag('str')],\n                Annotated[bool, Tag('bool')],\n                Annotated[int, Tag('int')],\n                Annotated[float, Tag('float')],\n                Annotated[None, Tag('NoneType')],\n            ],\n            Discriminator(\n                _get_type_name,\n                custom_error_type='invalid-json-value',\n                custom_error_message='input was not a valid JSON value',\n            ),\n            _AllowAnyJson,\n        ],\n    )\n\n\nclass _OnErrorOmit:\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        # there is no actual default value here but we use with_default_schema since it already has the on_error\n        # behavior implemented and it would be no more efficient to implement it on every other validator\n        # or as a standalone validator\n        return core_schema.with_default_schema(schema=handler(source_type), on_error='omit')\n\n\nOnErrorOmit = Annotated[T, _OnErrorOmit]\n\"\"\"\nWhen used as an item in a list, the key type in a dict, optional values of a TypedDict, etc.\nthis annotation omits the item from the iteration if there is any error validating it.\nThat is, instead of a [`ValidationError`][pydantic_core.ValidationError] being propagated up and the entire iterable being discarded\nany invalid items are discarded and the valid ones are returned.\n\"\"\"\n", "pydantic/main.py": "\"\"\"Logic for creating models.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport operator\nimport sys\nimport types\nimport typing\nimport warnings\nfrom copy import copy, deepcopy\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    ClassVar,\n    Dict,\n    Generator,\n    Literal,\n    Set,\n    Tuple,\n    TypeVar,\n    Union,\n    cast,\n    overload,\n)\n\nimport pydantic_core\nimport typing_extensions\nfrom pydantic_core import PydanticUndefined\nfrom typing_extensions import Self, TypeAlias, Unpack\n\nfrom ._internal import (\n    _config,\n    _decorators,\n    _fields,\n    _forward_ref,\n    _generics,\n    _mock_val_ser,\n    _model_construction,\n    _repr,\n    _typing_extra,\n    _utils,\n)\nfrom ._migration import getattr_migration\nfrom .aliases import AliasChoices, AliasPath\nfrom .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\nfrom .config import ConfigDict\nfrom .errors import PydanticUndefinedAnnotation, PydanticUserError\nfrom .json_schema import DEFAULT_REF_TEMPLATE, GenerateJsonSchema, JsonSchemaMode, JsonSchemaValue, model_json_schema\nfrom .warnings import PydanticDeprecatedSince20\n\n# Always define certain types that are needed to resolve method type hints/annotations\n# (even when not type checking) via typing.get_type_hints.\nModelT = TypeVar('ModelT', bound='BaseModel')\nTupleGenerator = Generator[Tuple[str, Any], None, None]\n# should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can't cope\nIncEx: TypeAlias = Union[Set[int], Set[str], Dict[int, Any], Dict[str, Any], None]\n\n\nif TYPE_CHECKING:\n    from inspect import Signature\n    from pathlib import Path\n\n    from pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator\n\n    from ._internal._utils import AbstractSetIntStr, MappingIntStrAny\n    from .deprecated.parse import Protocol as DeprecatedParseProtocol\n    from .fields import ComputedFieldInfo, FieldInfo, ModelPrivateAttr\n    from .fields import PrivateAttr as _PrivateAttr\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = 'BaseModel', 'create_model'\n\n_object_setattr = _model_construction.object_setattr\n\n\nclass BaseModel(metaclass=_model_construction.ModelMetaclass):\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/models/\n\n    A base class for creating Pydantic models.\n\n    Attributes:\n        __class_vars__: The names of classvars defined on the model.\n        __private_attributes__: Metadata about the private attributes of the model.\n        __signature__: The signature for instantiating the model.\n\n        __pydantic_complete__: Whether model building is completed, or if there are still undefined fields.\n        __pydantic_core_schema__: The pydantic-core schema used to build the SchemaValidator and SchemaSerializer.\n        __pydantic_custom_init__: Whether the model has a custom `__init__` function.\n        __pydantic_decorators__: Metadata containing the decorators defined on the model.\n            This replaces `Model.__validators__` and `Model.__root_validators__` from Pydantic V1.\n        __pydantic_generic_metadata__: Metadata for generic models; contains data used for a similar purpose to\n            __args__, __origin__, __parameters__ in typing-module generics. May eventually be replaced by these.\n        __pydantic_parent_namespace__: Parent namespace of the model, used for automatic rebuilding of models.\n        __pydantic_post_init__: The name of the post-init method for the model, if defined.\n        __pydantic_root_model__: Whether the model is a `RootModel`.\n        __pydantic_serializer__: The pydantic-core SchemaSerializer used to dump instances of the model.\n        __pydantic_validator__: The pydantic-core SchemaValidator used to validate instances of the model.\n\n        __pydantic_extra__: An instance attribute with the values of extra fields from validation when\n            `model_config['extra'] == 'allow'`.\n        __pydantic_fields_set__: An instance attribute with the names of fields explicitly set.\n        __pydantic_private__: Instance attribute with the values of private attributes set on the model instance.\n    \"\"\"\n\n    if TYPE_CHECKING:\n        # Here we provide annotations for the attributes of BaseModel.\n        # Many of these are populated by the metaclass, which is why this section is in a `TYPE_CHECKING` block.\n        # However, for the sake of easy review, we have included type annotations of all class and instance attributes\n        # of `BaseModel` here:\n\n        # Class attributes\n        model_config: ClassVar[ConfigDict]\n        \"\"\"\n        Configuration for the model, should be a dictionary conforming to [`ConfigDict`][pydantic.config.ConfigDict].\n        \"\"\"\n\n        model_fields: ClassVar[dict[str, FieldInfo]]\n        \"\"\"\n        Metadata about the fields defined on the model,\n        mapping of field names to [`FieldInfo`][pydantic.fields.FieldInfo].\n\n        This replaces `Model.__fields__` from Pydantic V1.\n        \"\"\"\n\n        model_computed_fields: ClassVar[dict[str, ComputedFieldInfo]]\n        \"\"\"A dictionary of computed field names and their corresponding `ComputedFieldInfo` objects.\"\"\"\n\n        __class_vars__: ClassVar[set[str]]\n        __private_attributes__: ClassVar[dict[str, ModelPrivateAttr]]\n        __signature__: ClassVar[Signature]\n\n        __pydantic_complete__: ClassVar[bool]\n        __pydantic_core_schema__: ClassVar[CoreSchema]\n        __pydantic_custom_init__: ClassVar[bool]\n        __pydantic_decorators__: ClassVar[_decorators.DecoratorInfos]\n        __pydantic_generic_metadata__: ClassVar[_generics.PydanticGenericMetadata]\n        __pydantic_parent_namespace__: ClassVar[dict[str, Any] | None]\n        __pydantic_post_init__: ClassVar[None | Literal['model_post_init']]\n        __pydantic_root_model__: ClassVar[bool]\n        __pydantic_serializer__: ClassVar[SchemaSerializer]\n        __pydantic_validator__: ClassVar[SchemaValidator]\n\n        # Instance attributes\n        __pydantic_extra__: dict[str, Any] | None = _PrivateAttr()\n        __pydantic_fields_set__: set[str] = _PrivateAttr()\n        __pydantic_private__: dict[str, Any] | None = _PrivateAttr()\n\n    else:\n        # `model_fields` and `__pydantic_decorators__` must be set for\n        # pydantic._internal._generate_schema.GenerateSchema.model_schema to work for a plain BaseModel annotation\n        model_fields = {}\n        model_computed_fields = {}\n\n        __pydantic_decorators__ = _decorators.DecoratorInfos()\n        __pydantic_parent_namespace__ = None\n        # Prevent `BaseModel` from being instantiated directly:\n        __pydantic_core_schema__ = _mock_val_ser.MockCoreSchema(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            code='base-model-instantiated',\n        )\n        __pydantic_validator__ = _mock_val_ser.MockValSer(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            val_or_ser='validator',\n            code='base-model-instantiated',\n        )\n        __pydantic_serializer__ = _mock_val_ser.MockValSer(\n            'Pydantic models should inherit from BaseModel, BaseModel cannot be instantiated directly',\n            val_or_ser='serializer',\n            code='base-model-instantiated',\n        )\n\n    __slots__ = '__dict__', '__pydantic_fields_set__', '__pydantic_extra__', '__pydantic_private__'\n\n    model_config = ConfigDict()\n    __pydantic_complete__ = False\n    __pydantic_root_model__ = False\n\n    def __init__(self, /, **data: Any) -> None:  # type: ignore\n        \"\"\"Create a new model by parsing and validating input data from keyword arguments.\n\n        Raises [`ValidationError`][pydantic_core.ValidationError] if the input data cannot be\n        validated to form a valid model.\n\n        `self` is explicitly positional-only to allow `self` as a field name.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        self.__pydantic_validator__.validate_python(data, self_instance=self)\n\n    # The following line sets a flag that we use to determine when `__init__` gets overridden by the user\n    __init__.__pydantic_base_init__ = True  # pyright: ignore[reportFunctionMemberAccess]\n\n    @property\n    def model_extra(self) -> dict[str, Any] | None:\n        \"\"\"Get extra fields set during validation.\n\n        Returns:\n            A dictionary of extra fields, or `None` if `config.extra` is not set to `\"allow\"`.\n        \"\"\"\n        return self.__pydantic_extra__\n\n    @property\n    def model_fields_set(self) -> set[str]:\n        \"\"\"Returns the set of fields that have been explicitly set on this model instance.\n\n        Returns:\n            A set of strings representing the fields that have been set,\n                i.e. that were not filled from defaults.\n        \"\"\"\n        return self.__pydantic_fields_set__\n\n    @classmethod\n    def model_construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: C901\n        \"\"\"Creates a new instance of the `Model` class with validated data.\n\n        Creates a new model setting `__dict__` and `__pydantic_fields_set__` from trusted or pre-validated data.\n        Default values are respected, but no other validation is performed.\n\n        !!! note\n            `model_construct()` generally respects the `model_config.extra` setting on the provided model.\n            That is, if `model_config.extra == 'allow'`, then all extra passed values are added to the model instance's `__dict__`\n            and `__pydantic_extra__` fields. If `model_config.extra == 'ignore'` (the default), then all extra passed values are ignored.\n            Because no validation is performed with a call to `model_construct()`, having `model_config.extra == 'forbid'` does not result in\n            an error if extra values are passed, but they will be ignored.\n\n        Args:\n            _fields_set: The set of field names accepted for the Model instance.\n            values: Trusted or pre-validated data dictionary.\n\n        Returns:\n            A new instance of the `Model` class with validated data.\n        \"\"\"\n        m = cls.__new__(cls)\n        fields_values: dict[str, Any] = {}\n        fields_set = set()\n\n        for name, field in cls.model_fields.items():\n            if field.alias is not None and field.alias in values:\n                fields_values[name] = values.pop(field.alias)\n                fields_set.add(name)\n\n            if (name not in fields_set) and (field.validation_alias is not None):\n                validation_aliases: list[str | AliasPath] = (\n                    field.validation_alias.choices\n                    if isinstance(field.validation_alias, AliasChoices)\n                    else [field.validation_alias]\n                )\n\n                for alias in validation_aliases:\n                    if isinstance(alias, str) and alias in values:\n                        fields_values[name] = values.pop(alias)\n                        fields_set.add(name)\n                        break\n                    elif isinstance(alias, AliasPath):\n                        value = alias.search_dict_for_path(values)\n                        if value is not PydanticUndefined:\n                            fields_values[name] = value\n                            fields_set.add(name)\n                            break\n\n            if name not in fields_set:\n                if name in values:\n                    fields_values[name] = values.pop(name)\n                    fields_set.add(name)\n                elif not field.is_required():\n                    fields_values[name] = field.get_default(call_default_factory=True)\n        if _fields_set is None:\n            _fields_set = fields_set\n\n        _extra: dict[str, Any] | None = (\n            {k: v for k, v in values.items()} if cls.model_config.get('extra') == 'allow' else None\n        )\n        _object_setattr(m, '__dict__', fields_values)\n        _object_setattr(m, '__pydantic_fields_set__', _fields_set)\n        if not cls.__pydantic_root_model__:\n            _object_setattr(m, '__pydantic_extra__', _extra)\n\n        if cls.__pydantic_post_init__:\n            m.model_post_init(None)\n            # update private attributes with values set\n            if hasattr(m, '__pydantic_private__') and m.__pydantic_private__ is not None:\n                for k, v in values.items():\n                    if k in m.__private_attributes__:\n                        m.__pydantic_private__[k] = v\n\n        elif not cls.__pydantic_root_model__:\n            # Note: if there are any private attributes, cls.__pydantic_post_init__ would exist\n            # Since it doesn't, that means that `__pydantic_private__` should be set to None\n            _object_setattr(m, '__pydantic_private__', None)\n\n        return m\n\n    def model_copy(self, *, update: dict[str, Any] | None = None, deep: bool = False) -> Self:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#model_copy\n\n        Returns a copy of the model.\n\n        Args:\n            update: Values to change/add in the new model. Note: the data is not validated\n                before creating the new model. You should trust this data.\n            deep: Set to `True` to make a deep copy of the model.\n\n        Returns:\n            New model instance.\n        \"\"\"\n        copied = self.__deepcopy__() if deep else self.__copy__()\n        if update:\n            if self.model_config.get('extra') == 'allow':\n                for k, v in update.items():\n                    if k in self.model_fields:\n                        copied.__dict__[k] = v\n                    else:\n                        if copied.__pydantic_extra__ is None:\n                            copied.__pydantic_extra__ = {}\n                        copied.__pydantic_extra__[k] = v\n            else:\n                copied.__dict__.update(update)\n            copied.__pydantic_fields_set__.update(update.keys())\n        return copied\n\n    def model_dump(\n        self,\n        *,\n        mode: Literal['json', 'python'] | str = 'python',\n        include: IncEx = None,\n        exclude: IncEx = None,\n        context: Any | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        serialize_as_any: bool = False,\n    ) -> dict[str, Any]:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#modelmodel_dump\n\n        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n        Args:\n            mode: The mode in which `to_python` should run.\n                If mode is 'json', the output will only contain JSON serializable types.\n                If mode is 'python', the output may contain non-JSON-serializable Python objects.\n            include: A set of fields to include in the output.\n            exclude: A set of fields to exclude from the output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to use the field's alias in the dictionary key if defined.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n        Returns:\n            A dictionary representation of the model.\n        \"\"\"\n        return self.__pydantic_serializer__.to_python(\n            self,\n            mode=mode,\n            by_alias=by_alias,\n            include=include,\n            exclude=exclude,\n            context=context,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n        )\n\n    def model_dump_json(\n        self,\n        *,\n        indent: int | None = None,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        context: Any | None = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        round_trip: bool = False,\n        warnings: bool | Literal['none', 'warn', 'error'] = True,\n        serialize_as_any: bool = False,\n    ) -> str:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/serialization/#modelmodel_dump_json\n\n        Generates a JSON representation of the model using Pydantic's `to_json` method.\n\n        Args:\n            indent: Indentation to use in the JSON output. If None is passed, the output will be compact.\n            include: Field(s) to include in the JSON output.\n            exclude: Field(s) to exclude from the JSON output.\n            context: Additional context to pass to the serializer.\n            by_alias: Whether to serialize using field aliases.\n            exclude_unset: Whether to exclude fields that have not been explicitly set.\n            exclude_defaults: Whether to exclude fields that are set to their default value.\n            exclude_none: Whether to exclude fields that have a value of `None`.\n            round_trip: If True, dumped values should be valid as input for non-idempotent types such as Json[T].\n            warnings: How to handle serialization errors. False/\"none\" ignores them, True/\"warn\" logs errors,\n                \"error\" raises a [`PydanticSerializationError`][pydantic_core.PydanticSerializationError].\n            serialize_as_any: Whether to serialize fields with duck-typing serialization behavior.\n\n        Returns:\n            A JSON string representation of the model.\n        \"\"\"\n        return self.__pydantic_serializer__.to_json(\n            self,\n            indent=indent,\n            include=include,\n            exclude=exclude,\n            context=context,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n            round_trip=round_trip,\n            warnings=warnings,\n            serialize_as_any=serialize_as_any,\n        ).decode()\n\n    @classmethod\n    def model_json_schema(\n        cls,\n        by_alias: bool = True,\n        ref_template: str = DEFAULT_REF_TEMPLATE,\n        schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n        mode: JsonSchemaMode = 'validation',\n    ) -> dict[str, Any]:\n        \"\"\"Generates a JSON schema for a model class.\n\n        Args:\n            by_alias: Whether to use attribute aliases or not.\n            ref_template: The reference template.\n            schema_generator: To override the logic used to generate the JSON schema, as a subclass of\n                `GenerateJsonSchema` with your desired modifications\n            mode: The mode in which to generate the schema.\n\n        Returns:\n            The JSON schema for the given model class.\n        \"\"\"\n        return model_json_schema(\n            cls, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator, mode=mode\n        )\n\n    @classmethod\n    def model_parametrized_name(cls, params: tuple[type[Any], ...]) -> str:\n        \"\"\"Compute the class name for parametrizations of generic classes.\n\n        This method can be overridden to achieve a custom naming scheme for generic BaseModels.\n\n        Args:\n            params: Tuple of types of the class. Given a generic class\n                `Model` with 2 type variables and a concrete model `Model[str, int]`,\n                the value `(str, int)` would be passed to `params`.\n\n        Returns:\n            String representing the new class where `params` are passed to `cls` as type variables.\n\n        Raises:\n            TypeError: Raised when trying to generate concrete names for non-generic models.\n        \"\"\"\n        if not issubclass(cls, typing.Generic):\n            raise TypeError('Concrete names should only be generated for generic models.')\n\n        # Any strings received should represent forward references, so we handle them specially below.\n        # If we eventually move toward wrapping them in a ForwardRef in __class_getitem__ in the future,\n        # we may be able to remove this special case.\n        param_names = [param if isinstance(param, str) else _repr.display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_component}]'\n\n    def model_post_init(self, __context: Any) -> None:\n        \"\"\"Override this method to perform additional initialization after `__init__` and `model_construct`.\n        This is useful if you want to do some validation that requires the entire model to be initialized.\n        \"\"\"\n        pass\n\n    @classmethod\n    def model_rebuild(\n        cls,\n        *,\n        force: bool = False,\n        raise_errors: bool = True,\n        _parent_namespace_depth: int = 2,\n        _types_namespace: dict[str, Any] | None = None,\n    ) -> bool | None:\n        \"\"\"Try to rebuild the pydantic-core schema for the model.\n\n        This may be necessary when one of the annotations is a ForwardRef which could not be resolved during\n        the initial attempt to build the schema, and automatic rebuilding fails.\n\n        Args:\n            force: Whether to force the rebuilding of the model schema, defaults to `False`.\n            raise_errors: Whether to raise errors, defaults to `True`.\n            _parent_namespace_depth: The depth level of the parent namespace, defaults to 2.\n            _types_namespace: The types namespace, defaults to `None`.\n\n        Returns:\n            Returns `None` if the schema is already \"complete\" and rebuilding was not required.\n            If rebuilding _was_ required, returns `True` if rebuilding was successful, otherwise `False`.\n        \"\"\"\n        if not force and cls.__pydantic_complete__:\n            return None\n        else:\n            if '__pydantic_core_schema__' in cls.__dict__:\n                delattr(cls, '__pydantic_core_schema__')  # delete cached value to ensure full rebuild happens\n            if _types_namespace is not None:\n                types_namespace: dict[str, Any] | None = _types_namespace.copy()\n            else:\n                if _parent_namespace_depth > 0:\n                    frame_parent_ns = _typing_extra.parent_frame_namespace(parent_depth=_parent_namespace_depth) or {}\n                    cls_parent_ns = (\n                        _model_construction.unpack_lenient_weakvaluedict(cls.__pydantic_parent_namespace__) or {}\n                    )\n                    types_namespace = {**cls_parent_ns, **frame_parent_ns}\n                    cls.__pydantic_parent_namespace__ = _model_construction.build_lenient_weakvaluedict(types_namespace)\n                else:\n                    types_namespace = _model_construction.unpack_lenient_weakvaluedict(\n                        cls.__pydantic_parent_namespace__\n                    )\n\n                types_namespace = _typing_extra.get_cls_types_namespace(cls, types_namespace)\n\n            # manually override defer_build so complete_model_class doesn't skip building the model again\n            config = {**cls.model_config, 'defer_build': False}\n            return _model_construction.complete_model_class(\n                cls,\n                cls.__name__,\n                _config.ConfigWrapper(config, check=False),\n                raise_errors=raise_errors,\n                types_namespace=types_namespace,\n            )\n\n    @classmethod\n    def model_validate(\n        cls,\n        obj: Any,\n        *,\n        strict: bool | None = None,\n        from_attributes: bool | None = None,\n        context: Any | None = None,\n    ) -> Self:\n        \"\"\"Validate a pydantic model instance.\n\n        Args:\n            obj: The object to validate.\n            strict: Whether to enforce types strictly.\n            from_attributes: Whether to extract data from object attributes.\n            context: Additional context to pass to the validator.\n\n        Raises:\n            ValidationError: If the object could not be validated.\n\n        Returns:\n            The validated model instance.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return cls.__pydantic_validator__.validate_python(\n            obj, strict=strict, from_attributes=from_attributes, context=context\n        )\n\n    @classmethod\n    def model_validate_json(\n        cls,\n        json_data: str | bytes | bytearray,\n        *,\n        strict: bool | None = None,\n        context: Any | None = None,\n    ) -> Self:\n        \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/json/#json-parsing\n\n        Validate the given JSON data against the Pydantic model.\n\n        Args:\n            json_data: The JSON data to validate.\n            strict: Whether to enforce types strictly.\n            context: Extra variables to pass to the validator.\n\n        Returns:\n            The validated Pydantic model.\n\n        Raises:\n            ValueError: If `json_data` is not a JSON string.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return cls.__pydantic_validator__.validate_json(json_data, strict=strict, context=context)\n\n    @classmethod\n    def model_validate_strings(\n        cls,\n        obj: Any,\n        *,\n        strict: bool | None = None,\n        context: Any | None = None,\n    ) -> Self:\n        \"\"\"Validate the given object with string data against the Pydantic model.\n\n        Args:\n            obj: The object containing string data to validate.\n            strict: Whether to enforce types strictly.\n            context: Extra variables to pass to the validator.\n\n        Returns:\n            The validated Pydantic model.\n        \"\"\"\n        # `__tracebackhide__` tells pytest and some other tools to omit this function from tracebacks\n        __tracebackhide__ = True\n        return cls.__pydantic_validator__.validate_strings(obj, strict=strict, context=context)\n\n    @classmethod\n    def __get_pydantic_core_schema__(cls, source: type[BaseModel], handler: GetCoreSchemaHandler, /) -> CoreSchema:\n        \"\"\"Hook into generating the model's CoreSchema.\n\n        Args:\n            source: The class we are generating a schema for.\n                This will generally be the same as the `cls` argument if this is a classmethod.\n            handler: A callable that calls into Pydantic's internal CoreSchema generation logic.\n\n        Returns:\n            A `pydantic-core` `CoreSchema`.\n        \"\"\"\n        # Only use the cached value from this _exact_ class; we don't want one from a parent class\n        # This is why we check `cls.__dict__` and don't use `cls.__pydantic_core_schema__` or similar.\n        schema = cls.__dict__.get('__pydantic_core_schema__')\n        if schema is not None and not isinstance(schema, _mock_val_ser.MockCoreSchema):\n            # Due to the way generic classes are built, it's possible that an invalid schema may be temporarily\n            # set on generic classes. I think we could resolve this to ensure that we get proper schema caching\n            # for generics, but for simplicity for now, we just always rebuild if the class has a generic origin.\n            if not cls.__pydantic_generic_metadata__['origin']:\n                return cls.__pydantic_core_schema__\n\n        return handler(source)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls,\n        core_schema: CoreSchema,\n        handler: GetJsonSchemaHandler,\n        /,\n    ) -> JsonSchemaValue:\n        \"\"\"Hook into generating the model's JSON schema.\n\n        Args:\n            core_schema: A `pydantic-core` CoreSchema.\n                You can ignore this argument and call the handler with a new CoreSchema,\n                wrap this CoreSchema (`{'type': 'nullable', 'schema': current_schema}`),\n                or just call the handler with the original schema.\n            handler: Call into Pydantic's internal JSON schema generation.\n                This will raise a `pydantic.errors.PydanticInvalidForJsonSchema` if JSON schema\n                generation fails.\n                Since this gets called by `BaseModel.model_json_schema` you can override the\n                `schema_generator` argument to that function to change JSON schema generation globally\n                for a type.\n\n        Returns:\n            A JSON schema, as a Python object.\n        \"\"\"\n        return handler(core_schema)\n\n    @classmethod\n    def __pydantic_init_subclass__(cls, **kwargs: Any) -> None:\n        \"\"\"This is intended to behave just like `__init_subclass__`, but is called by `ModelMetaclass`\n        only after the class is actually fully initialized. In particular, attributes like `model_fields` will\n        be present when this is called.\n\n        This is necessary because `__init_subclass__` will always be called by `type.__new__`,\n        and it would require a prohibitively large refactor to the `ModelMetaclass` to ensure that\n        `type.__new__` was called in such a manner that the class would already be sufficiently initialized.\n\n        This will receive the same `kwargs` that would be passed to the standard `__init_subclass__`, namely,\n        any kwargs passed to the class definition that aren't used internally by pydantic.\n\n        Args:\n            **kwargs: Any keyword arguments passed to the class definition that aren't used internally\n                by pydantic.\n        \"\"\"\n        pass\n\n    def __class_getitem__(\n        cls, typevar_values: type[Any] | tuple[type[Any], ...]\n    ) -> type[BaseModel] | _forward_ref.PydanticRecursiveRef:\n        cached = _generics.get_cached_generic_type_early(cls, typevar_values)\n        if cached is not None:\n            return cached\n\n        if cls is BaseModel:\n            raise TypeError('Type parameters should be placed on typing.Generic, not BaseModel')\n        if not hasattr(cls, '__parameters__'):\n            raise TypeError(f'{cls} cannot be parametrized because it does not inherit from typing.Generic')\n        if not cls.__pydantic_generic_metadata__['parameters'] and typing.Generic not in cls.__bases__:\n            raise TypeError(f'{cls} is not a generic class')\n\n        if not isinstance(typevar_values, tuple):\n            typevar_values = (typevar_values,)\n        _generics.check_parameters_count(cls, typevar_values)\n\n        # Build map from generic typevars to passed params\n        typevars_map: dict[_typing_extra.TypeVarType, type[Any]] = dict(\n            zip(cls.__pydantic_generic_metadata__['parameters'], typevar_values)\n        )\n\n        if _utils.all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n            submodel = cls  # if arguments are equal to parameters it's the same object\n            _generics.set_cached_generic_type(cls, typevar_values, submodel)\n        else:\n            parent_args = cls.__pydantic_generic_metadata__['args']\n            if not parent_args:\n                args = typevar_values\n            else:\n                args = tuple(_generics.replace_types(arg, typevars_map) for arg in parent_args)\n\n            origin = cls.__pydantic_generic_metadata__['origin'] or cls\n            model_name = origin.model_parametrized_name(args)\n            params = tuple(\n                {param: None for param in _generics.iter_contained_typevars(typevars_map.values())}\n            )  # use dict as ordered set\n\n            with _generics.generic_recursion_self_type(origin, args) as maybe_self_type:\n                if maybe_self_type is not None:\n                    return maybe_self_type\n\n                cached = _generics.get_cached_generic_type_late(cls, typevar_values, origin, args)\n                if cached is not None:\n                    return cached\n\n                # Attempt to rebuild the origin in case new types have been defined\n                try:\n                    # depth 3 gets you above this __class_getitem__ call\n                    origin.model_rebuild(_parent_namespace_depth=3)\n                except PydanticUndefinedAnnotation:\n                    # It's okay if it fails, it just means there are still undefined types\n                    # that could be evaluated later.\n                    # TODO: Make sure validation fails if there are still undefined types, perhaps using MockValidator\n                    pass\n\n                submodel = _generics.create_generic_submodel(model_name, origin, args, params)\n\n                # Update cache\n                _generics.set_cached_generic_type(cls, typevar_values, submodel, origin, args)\n\n        return submodel\n\n    def __copy__(self) -> Self:\n        \"\"\"Returns a shallow copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', copy(self.__dict__))\n        _object_setattr(m, '__pydantic_extra__', copy(self.__pydantic_extra__))\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n        if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n            _object_setattr(m, '__pydantic_private__', None)\n        else:\n            _object_setattr(\n                m,\n                '__pydantic_private__',\n                {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined},\n            )\n\n        return m\n\n    def __deepcopy__(self, memo: dict[int, Any] | None = None) -> Self:\n        \"\"\"Returns a deep copy of the model.\"\"\"\n        cls = type(self)\n        m = cls.__new__(cls)\n        _object_setattr(m, '__dict__', deepcopy(self.__dict__, memo=memo))\n        _object_setattr(m, '__pydantic_extra__', deepcopy(self.__pydantic_extra__, memo=memo))\n        # This next line doesn't need a deepcopy because __pydantic_fields_set__ is a set[str],\n        # and attempting a deepcopy would be marginally slower.\n        _object_setattr(m, '__pydantic_fields_set__', copy(self.__pydantic_fields_set__))\n\n        if not hasattr(self, '__pydantic_private__') or self.__pydantic_private__ is None:\n            _object_setattr(m, '__pydantic_private__', None)\n        else:\n            _object_setattr(\n                m,\n                '__pydantic_private__',\n                deepcopy({k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}, memo=memo),\n            )\n\n        return m\n\n    if not TYPE_CHECKING:\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n        # The same goes for __setattr__ and __delattr__, see: https://github.com/pydantic/pydantic/issues/8643\n\n        def __getattr__(self, item: str) -> Any:\n            private_attributes = object.__getattribute__(self, '__private_attributes__')\n            if item in private_attributes:\n                attribute = private_attributes[item]\n                if hasattr(attribute, '__get__'):\n                    return attribute.__get__(self, type(self))  # type: ignore\n\n                try:\n                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n                    return self.__pydantic_private__[item]  # type: ignore\n                except KeyError as exc:\n                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n            else:\n                # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n                # See `BaseModel.__repr_args__` for more details\n                try:\n                    pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n                except AttributeError:\n                    pydantic_extra = None\n\n                if pydantic_extra:\n                    try:\n                        return pydantic_extra[item]\n                    except KeyError as exc:\n                        raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n                else:\n                    if hasattr(self.__class__, item):\n                        return super().__getattribute__(item)  # Raises AttributeError if appropriate\n                    else:\n                        # this is the current error\n                        raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n\n        def __setattr__(self, name: str, value: Any) -> None:\n            if name in self.__class_vars__:\n                raise AttributeError(\n                    f'{name!r} is a ClassVar of `{self.__class__.__name__}` and cannot be set on an instance. '\n                    f'If you want to set a value on the class, use `{self.__class__.__name__}.{name} = value`.'\n                )\n            elif not _fields.is_valid_field_name(name):\n                if self.__pydantic_private__ is None or name not in self.__private_attributes__:\n                    _object_setattr(self, name, value)\n                else:\n                    attribute = self.__private_attributes__[name]\n                    if hasattr(attribute, '__set__'):\n                        attribute.__set__(self, value)  # type: ignore\n                    else:\n                        self.__pydantic_private__[name] = value\n                return\n\n            self._check_frozen(name, value)\n\n            attr = getattr(self.__class__, name, None)\n            if isinstance(attr, property):\n                attr.__set__(self, value)\n            elif self.model_config.get('validate_assignment', None):\n                self.__pydantic_validator__.validate_assignment(self, name, value)\n            elif self.model_config.get('extra') != 'allow' and name not in self.model_fields:\n                # TODO - matching error\n                raise ValueError(f'\"{self.__class__.__name__}\" object has no field \"{name}\"')\n            elif self.model_config.get('extra') == 'allow' and name not in self.model_fields:\n                if self.model_extra and name in self.model_extra:\n                    self.__pydantic_extra__[name] = value  # type: ignore\n                else:\n                    try:\n                        getattr(self, name)\n                    except AttributeError:\n                        # attribute does not already exist on instance, so put it in extra\n                        self.__pydantic_extra__[name] = value  # type: ignore\n                    else:\n                        # attribute _does_ already exist on instance, and was not in extra, so update it\n                        _object_setattr(self, name, value)\n            else:\n                self.__dict__[name] = value\n                self.__pydantic_fields_set__.add(name)\n\n        def __delattr__(self, item: str) -> Any:\n            if item in self.__private_attributes__:\n                attribute = self.__private_attributes__[item]\n                if hasattr(attribute, '__delete__'):\n                    attribute.__delete__(self)  # type: ignore\n                    return\n\n                try:\n                    # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items\n                    del self.__pydantic_private__[item]  # type: ignore\n                    return\n                except KeyError as exc:\n                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc\n\n            self._check_frozen(item, None)\n\n            if item in self.model_fields:\n                object.__delattr__(self, item)\n            elif self.__pydantic_extra__ is not None and item in self.__pydantic_extra__:\n                del self.__pydantic_extra__[item]\n            else:\n                try:\n                    object.__delattr__(self, item)\n                except AttributeError:\n                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')\n\n    def _check_frozen(self, name: str, value: Any) -> None:\n        if self.model_config.get('frozen', None):\n            typ = 'frozen_instance'\n        elif getattr(self.model_fields.get(name), 'frozen', False):\n            typ = 'frozen_field'\n        else:\n            return\n        error: pydantic_core.InitErrorDetails = {\n            'type': typ,\n            'loc': (name,),\n            'input': value,\n        }\n        raise pydantic_core.ValidationError.from_exception_data(self.__class__.__name__, [error])\n\n    def __getstate__(self) -> dict[Any, Any]:\n        private = self.__pydantic_private__\n        if private:\n            private = {k: v for k, v in private.items() if v is not PydanticUndefined}\n        return {\n            '__dict__': self.__dict__,\n            '__pydantic_extra__': self.__pydantic_extra__,\n            '__pydantic_fields_set__': self.__pydantic_fields_set__,\n            '__pydantic_private__': private,\n        }\n\n    def __setstate__(self, state: dict[Any, Any]) -> None:\n        _object_setattr(self, '__pydantic_fields_set__', state.get('__pydantic_fields_set__', {}))\n        _object_setattr(self, '__pydantic_extra__', state.get('__pydantic_extra__', {}))\n        _object_setattr(self, '__pydantic_private__', state.get('__pydantic_private__', {}))\n        _object_setattr(self, '__dict__', state.get('__dict__', {}))\n\n    if not TYPE_CHECKING:\n\n        def __eq__(self, other: Any) -> bool:\n            if isinstance(other, BaseModel):\n                # When comparing instances of generic types for equality, as long as all field values are equal,\n                # only require their generic origin types to be equal, rather than exact type equality.\n                # This prevents headaches like MyGeneric(x=1) != MyGeneric[Any](x=1).\n                self_type = self.__pydantic_generic_metadata__['origin'] or self.__class__\n                other_type = other.__pydantic_generic_metadata__['origin'] or other.__class__\n\n                # Perform common checks first\n                if not (\n                    self_type == other_type\n                    and getattr(self, '__pydantic_private__', None) == getattr(other, '__pydantic_private__', None)\n                    and self.__pydantic_extra__ == other.__pydantic_extra__\n                ):\n                    return False\n\n                # We only want to compare pydantic fields but ignoring fields is costly.\n                # We'll perform a fast check first, and fallback only when needed\n                # See GH-7444 and GH-7825 for rationale and a performance benchmark\n\n                # First, do the fast (and sometimes faulty) __dict__ comparison\n                if self.__dict__ == other.__dict__:\n                    # If the check above passes, then pydantic fields are equal, we can return early\n                    return True\n\n                # We don't want to trigger unnecessary costly filtering of __dict__ on all unequal objects, so we return\n                # early if there are no keys to ignore (we would just return False later on anyway)\n                model_fields = type(self).model_fields.keys()\n                if self.__dict__.keys() <= model_fields and other.__dict__.keys() <= model_fields:\n                    return False\n\n                # If we reach here, there are non-pydantic-fields keys, mapped to unequal values, that we need to ignore\n                # Resort to costly filtering of the __dict__ objects\n                # We use operator.itemgetter because it is much faster than dict comprehensions\n                # NOTE: Contrary to standard python class and instances, when the Model class has a default value for an\n                # attribute and the model instance doesn't have a corresponding attribute, accessing the missing attribute\n                # raises an error in BaseModel.__getattr__ instead of returning the class attribute\n                # So we can use operator.itemgetter() instead of operator.attrgetter()\n                getter = operator.itemgetter(*model_fields) if model_fields else lambda _: _utils._SENTINEL\n                try:\n                    return getter(self.__dict__) == getter(other.__dict__)\n                except KeyError:\n                    # In rare cases (such as when using the deprecated BaseModel.copy() method),\n                    # the __dict__ may not contain all model fields, which is how we can get here.\n                    # getter(self.__dict__) is much faster than any 'safe' method that accounts\n                    # for missing keys, and wrapping it in a `try` doesn't slow things down much\n                    # in the common case.\n                    self_fields_proxy = _utils.SafeGetItemProxy(self.__dict__)\n                    other_fields_proxy = _utils.SafeGetItemProxy(other.__dict__)\n                    return getter(self_fields_proxy) == getter(other_fields_proxy)\n\n            # other instance is not a BaseModel\n            else:\n                return NotImplemented  # delegate to the other item in the comparison\n\n    if TYPE_CHECKING:\n        # We put `__init_subclass__` in a TYPE_CHECKING block because, even though we want the type-checking benefits\n        # described in the signature of `__init_subclass__` below, we don't want to modify the default behavior of\n        # subclass initialization.\n\n        def __init_subclass__(cls, **kwargs: Unpack[ConfigDict]):\n            \"\"\"This signature is included purely to help type-checkers check arguments to class declaration, which\n            provides a way to conveniently set model_config key/value pairs.\n\n            ```py\n            from pydantic import BaseModel\n\n            class MyModel(BaseModel, extra='allow'):\n                ...\n            ```\n\n            However, this may be deceiving, since the _actual_ calls to `__init_subclass__` will not receive any\n            of the config arguments, and will only receive any keyword arguments passed during class initialization\n            that are _not_ expected keys in ConfigDict. (This is due to the way `ModelMetaclass.__new__` works.)\n\n            Args:\n                **kwargs: Keyword arguments passed to the class definition, which set model_config\n\n            Note:\n                You may want to override `__pydantic_init_subclass__` instead, which behaves similarly but is called\n                *after* the class is fully initialized.\n            \"\"\"\n\n    def __iter__(self) -> TupleGenerator:\n        \"\"\"So `dict(model)` works.\"\"\"\n        yield from [(k, v) for (k, v) in self.__dict__.items() if not k.startswith('_')]\n        extra = self.__pydantic_extra__\n        if extra:\n            yield from extra.items()\n\n    def __repr__(self) -> str:\n        return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n\n    def __repr_args__(self) -> _repr.ReprArgs:\n        for k, v in self.__dict__.items():\n            field = self.model_fields.get(k)\n            if field and field.repr:\n                yield k, v\n\n        # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.\n        # This can happen if a `ValidationError` is raised during initialization and the instance's\n        # repr is generated as part of the exception handling. Therefore, we use `getattr` here\n        # with a fallback, even though the type hints indicate the attribute will always be present.\n        try:\n            pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')\n        except AttributeError:\n            pydantic_extra = None\n\n        if pydantic_extra is not None:\n            yield from ((k, v) for k, v in pydantic_extra.items())\n        yield from ((k, getattr(self, k)) for k, v in self.model_computed_fields.items() if v.repr)\n\n    # take logic from `_repr.Representation` without the side effects of inheritance, see #5740\n    __repr_name__ = _repr.Representation.__repr_name__\n    __repr_str__ = _repr.Representation.__repr_str__\n    __pretty__ = _repr.Representation.__pretty__\n    __rich_repr__ = _repr.Representation.__rich_repr__\n\n    def __str__(self) -> str:\n        return self.__repr_str__(' ')\n\n    # ##### Deprecated methods from v1 #####\n    @property\n    @typing_extensions.deprecated(\n        'The `__fields__` attribute is deprecated, use `model_fields` instead.', category=None\n    )\n    def __fields__(self) -> dict[str, FieldInfo]:\n        warnings.warn(\n            'The `__fields__` attribute is deprecated, use `model_fields` instead.', category=PydanticDeprecatedSince20\n        )\n        return self.model_fields\n\n    @property\n    @typing_extensions.deprecated(\n        'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',\n        category=None,\n    )\n    def __fields_set__(self) -> set[str]:\n        warnings.warn(\n            'The `__fields_set__` attribute is deprecated, use `model_fields_set` instead.',\n            category=PydanticDeprecatedSince20,\n        )\n        return self.__pydantic_fields_set__\n\n    @typing_extensions.deprecated('The `dict` method is deprecated; use `model_dump` instead.', category=None)\n    def dict(  # noqa: D102\n        self,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -> Dict[str, Any]:  # noqa UP006\n        warnings.warn('The `dict` method is deprecated; use `model_dump` instead.', category=PydanticDeprecatedSince20)\n        return self.model_dump(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    @typing_extensions.deprecated('The `json` method is deprecated; use `model_dump_json` instead.', category=None)\n    def json(  # noqa: D102\n        self,\n        *,\n        include: IncEx = None,\n        exclude: IncEx = None,\n        by_alias: bool = False,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        encoder: Callable[[Any], Any] | None = PydanticUndefined,  # type: ignore[assignment]\n        models_as_dict: bool = PydanticUndefined,  # type: ignore[assignment]\n        **dumps_kwargs: Any,\n    ) -> str:\n        warnings.warn(\n            'The `json` method is deprecated; use `model_dump_json` instead.', category=PydanticDeprecatedSince20\n        )\n        if encoder is not PydanticUndefined:\n            raise TypeError('The `encoder` argument is no longer supported; use field serializers instead.')\n        if models_as_dict is not PydanticUndefined:\n            raise TypeError('The `models_as_dict` argument is no longer supported; use a model serializer instead.')\n        if dumps_kwargs:\n            raise TypeError('`dumps_kwargs` keyword arguments are no longer supported.')\n        return self.model_dump_json(\n            include=include,\n            exclude=exclude,\n            by_alias=by_alias,\n            exclude_unset=exclude_unset,\n            exclude_defaults=exclude_defaults,\n            exclude_none=exclude_none,\n        )\n\n    @classmethod\n    @typing_extensions.deprecated('The `parse_obj` method is deprecated; use `model_validate` instead.', category=None)\n    def parse_obj(cls, obj: Any) -> Self:  # noqa: D102\n        warnings.warn(\n            'The `parse_obj` method is deprecated; use `model_validate` instead.', category=PydanticDeprecatedSince20\n        )\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n        'otherwise load the data then use `model_validate` instead.',\n        category=None,\n    )\n    def parse_raw(  # noqa: D102\n        cls,\n        b: str | bytes,\n        *,\n        content_type: str | None = None,\n        encoding: str = 'utf8',\n        proto: DeprecatedParseProtocol | None = None,\n        allow_pickle: bool = False,\n    ) -> Self:  # pragma: no cover\n        warnings.warn(\n            'The `parse_raw` method is deprecated; if your data is JSON use `model_validate_json`, '\n            'otherwise load the data then use `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import parse\n\n        try:\n            obj = parse.load_str_bytes(\n                b,\n                proto=proto,\n                content_type=content_type,\n                encoding=encoding,\n                allow_pickle=allow_pickle,\n            )\n        except (ValueError, TypeError) as exc:\n            import json\n\n            # try to match V1\n            if isinstance(exc, UnicodeDecodeError):\n                type_str = 'value_error.unicodedecode'\n            elif isinstance(exc, json.JSONDecodeError):\n                type_str = 'value_error.jsondecode'\n            elif isinstance(exc, ValueError):\n                type_str = 'value_error'\n            else:\n                type_str = 'type_error'\n\n            # ctx is missing here, but since we've added `input` to the error, we're not pretending it's the same\n            error: pydantic_core.InitErrorDetails = {\n                # The type: ignore on the next line is to ignore the requirement of LiteralString\n                'type': pydantic_core.PydanticCustomError(type_str, str(exc)),  # type: ignore\n                'loc': ('__root__',),\n                'input': b,\n            }\n            raise pydantic_core.ValidationError.from_exception_data(cls.__name__, [error])\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n        'use `model_validate_json`, otherwise `model_validate` instead.',\n        category=None,\n    )\n    def parse_file(  # noqa: D102\n        cls,\n        path: str | Path,\n        *,\n        content_type: str | None = None,\n        encoding: str = 'utf8',\n        proto: DeprecatedParseProtocol | None = None,\n        allow_pickle: bool = False,\n    ) -> Self:\n        warnings.warn(\n            'The `parse_file` method is deprecated; load the data from file, then if your data is JSON '\n            'use `model_validate_json`, otherwise `model_validate` instead.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import parse\n\n        obj = parse.load_file(\n            path,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n        )\n        return cls.parse_obj(obj)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `from_orm` method is deprecated; set '\n        \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n        category=None,\n    )\n    def from_orm(cls, obj: Any) -> Self:  # noqa: D102\n        warnings.warn(\n            'The `from_orm` method is deprecated; set '\n            \"`model_config['from_attributes']=True` and use `model_validate` instead.\",\n            category=PydanticDeprecatedSince20,\n        )\n        if not cls.model_config.get('from_attributes', None):\n            raise PydanticUserError(\n                'You must set the config attribute `from_attributes=True` to use from_orm', code=None\n            )\n        return cls.model_validate(obj)\n\n    @classmethod\n    @typing_extensions.deprecated('The `construct` method is deprecated; use `model_construct` instead.', category=None)\n    def construct(cls, _fields_set: set[str] | None = None, **values: Any) -> Self:  # noqa: D102\n        warnings.warn(\n            'The `construct` method is deprecated; use `model_construct` instead.', category=PydanticDeprecatedSince20\n        )\n        return cls.model_construct(_fields_set=_fields_set, **values)\n\n    @typing_extensions.deprecated(\n        'The `copy` method is deprecated; use `model_copy` instead. '\n        'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n        category=None,\n    )\n    def copy(\n        self,\n        *,\n        include: AbstractSetIntStr | MappingIntStrAny | None = None,\n        exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n        update: Dict[str, Any] | None = None,  # noqa UP006\n        deep: bool = False,\n    ) -> Self:  # pragma: no cover\n        \"\"\"Returns a copy of the model.\n\n        !!! warning \"Deprecated\"\n            This method is now deprecated; use `model_copy` instead.\n\n        If you need `include` or `exclude`, use:\n\n        ```py\n        data = self.model_dump(include=include, exclude=exclude, round_trip=True)\n        data = {**data, **(update or {})}\n        copied = self.model_validate(data)\n        ```\n\n        Args:\n            include: Optional set or mapping specifying which fields to include in the copied model.\n            exclude: Optional set or mapping specifying which fields to exclude in the copied model.\n            update: Optional dictionary of field-value pairs to override field values in the copied model.\n            deep: If True, the values of fields that are Pydantic models will be deep-copied.\n\n        Returns:\n            A copy of the model with included, excluded and updated fields as specified.\n        \"\"\"\n        warnings.warn(\n            'The `copy` method is deprecated; use `model_copy` instead. '\n            'See the docstring of `BaseModel.copy` for details about how to handle `include` and `exclude`.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import copy_internals\n\n        values = dict(\n            copy_internals._iter(\n                self, to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False\n            ),\n            **(update or {}),\n        )\n        if self.__pydantic_private__ is None:\n            private = None\n        else:\n            private = {k: v for k, v in self.__pydantic_private__.items() if v is not PydanticUndefined}\n\n        if self.__pydantic_extra__ is None:\n            extra: dict[str, Any] | None = None\n        else:\n            extra = self.__pydantic_extra__.copy()\n            for k in list(self.__pydantic_extra__):\n                if k not in values:  # k was in the exclude\n                    extra.pop(k)\n            for k in list(values):\n                if k in self.__pydantic_extra__:  # k must have come from extra\n                    extra[k] = values.pop(k)\n\n        # new `__pydantic_fields_set__` can have unset optional fields with a set value in `update` kwarg\n        if update:\n            fields_set = self.__pydantic_fields_set__ | update.keys()\n        else:\n            fields_set = set(self.__pydantic_fields_set__)\n\n        # removing excluded fields from `__pydantic_fields_set__`\n        if exclude:\n            fields_set -= set(exclude)\n\n        return copy_internals._copy_and_set_values(self, values, fields_set, extra, private, deep=deep)\n\n    @classmethod\n    @typing_extensions.deprecated('The `schema` method is deprecated; use `model_json_schema` instead.', category=None)\n    def schema(  # noqa: D102\n        cls, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE\n    ) -> Dict[str, Any]:  # noqa UP006\n        warnings.warn(\n            'The `schema` method is deprecated; use `model_json_schema` instead.', category=PydanticDeprecatedSince20\n        )\n        return cls.model_json_schema(by_alias=by_alias, ref_template=ref_template)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n        category=None,\n    )\n    def schema_json(  # noqa: D102\n        cls, *, by_alias: bool = True, ref_template: str = DEFAULT_REF_TEMPLATE, **dumps_kwargs: Any\n    ) -> str:  # pragma: no cover\n        warnings.warn(\n            'The `schema_json` method is deprecated; use `model_json_schema` and json.dumps instead.',\n            category=PydanticDeprecatedSince20,\n        )\n        import json\n\n        from .deprecated.json import pydantic_encoder\n\n        return json.dumps(\n            cls.model_json_schema(by_alias=by_alias, ref_template=ref_template),\n            default=pydantic_encoder,\n            **dumps_kwargs,\n        )\n\n    @classmethod\n    @typing_extensions.deprecated('The `validate` method is deprecated; use `model_validate` instead.', category=None)\n    def validate(cls, value: Any) -> Self:  # noqa: D102\n        warnings.warn(\n            'The `validate` method is deprecated; use `model_validate` instead.', category=PydanticDeprecatedSince20\n        )\n        return cls.model_validate(value)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n        category=None,\n    )\n    def update_forward_refs(cls, **localns: Any) -> None:  # noqa: D102\n        warnings.warn(\n            'The `update_forward_refs` method is deprecated; use `model_rebuild` instead.',\n            category=PydanticDeprecatedSince20,\n        )\n        if localns:  # pragma: no cover\n            raise TypeError('`localns` arguments are not longer accepted.')\n        cls.model_rebuild(force=True)\n\n    @typing_extensions.deprecated(\n        'The private method `_iter` will be removed and should no longer be used.', category=None\n    )\n    def _iter(self, *args: Any, **kwargs: Any) -> Any:\n        warnings.warn(\n            'The private method `_iter` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._iter(self, *args, **kwargs)\n\n    @typing_extensions.deprecated(\n        'The private method `_copy_and_set_values` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _copy_and_set_values(self, *args: Any, **kwargs: Any) -> Any:\n        warnings.warn(\n            'The private method `_copy_and_set_values` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._copy_and_set_values(self, *args, **kwargs)\n\n    @classmethod\n    @typing_extensions.deprecated(\n        'The private method `_get_value` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _get_value(cls, *args: Any, **kwargs: Any) -> Any:\n        warnings.warn(\n            'The private method `_get_value` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._get_value(cls, *args, **kwargs)\n\n    @typing_extensions.deprecated(\n        'The private method `_calculate_keys` will be removed and should no longer be used.',\n        category=None,\n    )\n    def _calculate_keys(self, *args: Any, **kwargs: Any) -> Any:\n        warnings.warn(\n            'The private method `_calculate_keys` will be removed and should no longer be used.',\n            category=PydanticDeprecatedSince20,\n        )\n        from .deprecated import copy_internals\n\n        return copy_internals._calculate_keys(self, *args, **kwargs)\n\n\n@overload\ndef create_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: None = None,\n    __module__: str = __name__,\n    __validators__: dict[str, Callable[..., Any]] | None = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    **field_definitions: Any,\n) -> type[BaseModel]: ...\n\n\n@overload\ndef create_model(\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: type[ModelT] | tuple[type[ModelT], ...],\n    __module__: str = __name__,\n    __validators__: dict[str, Callable[..., Any]] | None = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    **field_definitions: Any,\n) -> type[ModelT]: ...\n\n\ndef create_model(  # noqa: C901\n    model_name: str,\n    /,\n    *,\n    __config__: ConfigDict | None = None,\n    __doc__: str | None = None,\n    __base__: type[ModelT] | tuple[type[ModelT], ...] | None = None,\n    __module__: str | None = None,\n    __validators__: dict[str, Callable[..., Any]] | None = None,\n    __cls_kwargs__: dict[str, Any] | None = None,\n    __slots__: tuple[str, ...] | None = None,\n    **field_definitions: Any,\n) -> type[ModelT]:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/models/#dynamic-model-creation\n\n    Dynamically creates and returns a new Pydantic model, in other words, `create_model` dynamically creates a\n    subclass of [`BaseModel`][pydantic.BaseModel].\n\n    Args:\n        model_name: The name of the newly created model.\n        __config__: The configuration of the new model.\n        __doc__: The docstring of the new model.\n        __base__: The base class or classes for the new model.\n        __module__: The name of the module that the model belongs to;\n            if `None`, the value is taken from `sys._getframe(1)`\n        __validators__: A dictionary of methods that validate fields. The keys are the names of the validation methods to\n            be added to the model, and the values are the validation methods themselves. You can read more about functional\n            validators [here](https://docs.pydantic.dev/2.8/concepts/validators/#field-validators).\n        __cls_kwargs__: A dictionary of keyword arguments for class creation, such as `metaclass`.\n        __slots__: Deprecated. Should not be passed to `create_model`.\n        **field_definitions: Attributes of the new model. They should be passed in the format:\n            `<name>=(<type>, <default value>)`, `<name>=(<type>, <FieldInfo>)`, or `typing.Annotated[<type>, <FieldInfo>]`.\n            Any additional metadata in `typing.Annotated[<type>, <FieldInfo>, ...]` will be ignored.\n\n    Returns:\n        The new [model][pydantic.BaseModel].\n\n    Raises:\n        PydanticUserError: If `__base__` and `__config__` are both passed.\n    \"\"\"\n    if __slots__ is not None:\n        # __slots__ will be ignored from here on\n        warnings.warn('__slots__ should not be passed to create_model', RuntimeWarning)\n\n    if __base__ is not None:\n        if __config__ is not None:\n            raise PydanticUserError(\n                'to avoid confusion `__config__` and `__base__` cannot be used together',\n                code='create-model-config-base',\n            )\n        if not isinstance(__base__, tuple):\n            __base__ = (__base__,)\n    else:\n        __base__ = (cast('type[ModelT]', BaseModel),)\n\n    __cls_kwargs__ = __cls_kwargs__ or {}\n\n    fields = {}\n    annotations = {}\n\n    for f_name, f_def in field_definitions.items():\n        if not _fields.is_valid_field_name(f_name):\n            warnings.warn(f'fields may not start with an underscore, ignoring \"{f_name}\"', RuntimeWarning)\n        if isinstance(f_def, tuple):\n            f_def = cast('tuple[str, Any]', f_def)\n            try:\n                f_annotation, f_value = f_def\n            except ValueError as e:\n                raise PydanticUserError(\n                    'Field definitions should be a `(<type>, <default>)`.',\n                    code='create-model-field-definitions',\n                ) from e\n\n        elif _typing_extra.is_annotated(f_def):\n            (f_annotation, f_value, *_) = typing_extensions.get_args(\n                f_def\n            )  # first two input are expected from Annotated, refer to https://docs.python.org/3/library/typing.html#typing.Annotated\n            from .fields import FieldInfo\n\n            if not isinstance(f_value, FieldInfo):\n                raise PydanticUserError(\n                    'Field definitions should be a Annotated[<type>, <FieldInfo>]',\n                    code='create-model-field-definitions',\n                )\n\n        else:\n            f_annotation, f_value = None, f_def\n\n        if f_annotation:\n            annotations[f_name] = f_annotation\n        fields[f_name] = f_value\n\n    if __module__ is None:\n        f = sys._getframe(1)\n        __module__ = f.f_globals['__name__']\n\n    namespace: dict[str, Any] = {'__annotations__': annotations, '__module__': __module__}\n    if __doc__:\n        namespace.update({'__doc__': __doc__})\n    if __validators__:\n        namespace.update(__validators__)\n    namespace.update(fields)\n    if __config__:\n        namespace['model_config'] = _config.ConfigWrapper(__config__).config_dict\n    resolved_bases = types.resolve_bases(__base__)\n    meta, ns, kwds = types.prepare_class(model_name, resolved_bases, kwds=__cls_kwargs__)\n    if resolved_bases is not __base__:\n        ns['__orig_bases__'] = __base__\n    namespace.update(ns)\n\n    return meta(\n        model_name,\n        resolved_bases,\n        namespace,\n        __pydantic_reset_parent_namespace__=False,\n        _create_model_module=__module__,\n        **kwds,\n    )\n\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/aliases.py": "\"\"\"Support for alias configurations.\"\"\"\n\nfrom __future__ import annotations\n\nimport dataclasses\nfrom typing import Any, Callable, Literal\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._internal import _internal_dataclass\n\n__all__ = ('AliasGenerator', 'AliasPath', 'AliasChoices')\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass AliasPath:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/alias#aliaspath-and-aliaschoices\n\n    A data class used by `validation_alias` as a convenience to create aliases.\n\n    Attributes:\n        path: A list of string or integer aliases.\n    \"\"\"\n\n    path: list[int | str]\n\n    def __init__(self, first_arg: str, *args: str | int) -> None:\n        self.path = [first_arg] + list(args)\n\n    def convert_to_aliases(self) -> list[str | int]:\n        \"\"\"Converts arguments to a list of string or integer aliases.\n\n        Returns:\n            The list of aliases.\n        \"\"\"\n        return self.path\n\n    def search_dict_for_path(self, d: dict) -> Any:\n        \"\"\"Searches a dictionary for the path specified by the alias.\n\n        Returns:\n            The value at the specified path, or `PydanticUndefined` if the path is not found.\n        \"\"\"\n        v = d\n        for k in self.path:\n            if isinstance(v, str):\n                # disallow indexing into a str, like for AliasPath('x', 0) and x='abc'\n                return PydanticUndefined\n            try:\n                v = v[k]\n            except (KeyError, IndexError, TypeError):\n                return PydanticUndefined\n        return v\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass AliasChoices:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/alias#aliaspath-and-aliaschoices\n\n    A data class used by `validation_alias` as a convenience to create aliases.\n\n    Attributes:\n        choices: A list containing a string or `AliasPath`.\n    \"\"\"\n\n    choices: list[str | AliasPath]\n\n    def __init__(self, first_choice: str | AliasPath, *choices: str | AliasPath) -> None:\n        self.choices = [first_choice] + list(choices)\n\n    def convert_to_aliases(self) -> list[list[str | int]]:\n        \"\"\"Converts arguments to a list of lists containing string or integer aliases.\n\n        Returns:\n            The list of aliases.\n        \"\"\"\n        aliases: list[list[str | int]] = []\n        for c in self.choices:\n            if isinstance(c, AliasPath):\n                aliases.append(c.convert_to_aliases())\n            else:\n                aliases.append([c])\n        return aliases\n\n\n@dataclasses.dataclass(**_internal_dataclass.slots_true)\nclass AliasGenerator:\n    \"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/alias#using-an-aliasgenerator\n\n    A data class used by `alias_generator` as a convenience to create various aliases.\n\n    Attributes:\n        alias: A callable that takes a field name and returns an alias for it.\n        validation_alias: A callable that takes a field name and returns a validation alias for it.\n        serialization_alias: A callable that takes a field name and returns a serialization alias for it.\n    \"\"\"\n\n    alias: Callable[[str], str] | None = None\n    validation_alias: Callable[[str], str | AliasPath | AliasChoices] | None = None\n    serialization_alias: Callable[[str], str] | None = None\n\n    def _generate_alias(\n        self,\n        alias_kind: Literal['alias', 'validation_alias', 'serialization_alias'],\n        allowed_types: tuple[type[str] | type[AliasPath] | type[AliasChoices], ...],\n        field_name: str,\n    ) -> str | AliasPath | AliasChoices | None:\n        \"\"\"Generate an alias of the specified kind. Returns None if the alias generator is None.\n\n        Raises:\n            TypeError: If the alias generator produces an invalid type.\n        \"\"\"\n        alias = None\n        if alias_generator := getattr(self, alias_kind):\n            alias = alias_generator(field_name)\n            if alias and not isinstance(alias, allowed_types):\n                raise TypeError(\n                    f'Invalid `{alias_kind}` type. `{alias_kind}` generator must produce one of `{allowed_types}`'\n                )\n        return alias\n\n    def generate_aliases(self, field_name: str) -> tuple[str | None, str | AliasPath | AliasChoices | None, str | None]:\n        \"\"\"Generate `alias`, `validation_alias`, and `serialization_alias` for a field.\n\n        Returns:\n            A tuple of three aliases - validation, alias, and serialization.\n        \"\"\"\n        alias = self._generate_alias('alias', (str,), field_name)\n        validation_alias = self._generate_alias('validation_alias', (str, AliasChoices, AliasPath), field_name)\n        serialization_alias = self._generate_alias('serialization_alias', (str,), field_name)\n\n        return alias, validation_alias, serialization_alias  # type: ignore\n", "pydantic/class_validators.py": "\"\"\"`class_validators` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/__init__.py": "import typing\n\nfrom ._migration import getattr_migration\nfrom .version import VERSION\n\nif typing.TYPE_CHECKING:\n    # import of virtually everything is supported via `__getattr__` below,\n    # but we need them here for type checking and IDE support\n    import pydantic_core\n    from pydantic_core.core_schema import (\n        FieldSerializationInfo,\n        SerializationInfo,\n        SerializerFunctionWrapHandler,\n        ValidationInfo,\n        ValidatorFunctionWrapHandler,\n    )\n\n    from . import dataclasses\n    from ._internal._generate_schema import GenerateSchema as GenerateSchema\n    from .aliases import AliasChoices, AliasGenerator, AliasPath\n    from .annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\n    from .config import ConfigDict, with_config\n    from .errors import *\n    from .fields import Field, PrivateAttr, computed_field\n    from .functional_serializers import (\n        PlainSerializer,\n        SerializeAsAny,\n        WrapSerializer,\n        field_serializer,\n        model_serializer,\n    )\n    from .functional_validators import (\n        AfterValidator,\n        BeforeValidator,\n        InstanceOf,\n        PlainValidator,\n        SkipValidation,\n        WrapValidator,\n        field_validator,\n        model_validator,\n    )\n    from .json_schema import WithJsonSchema\n    from .main import *\n    from .networks import *\n    from .type_adapter import TypeAdapter\n    from .types import *\n    from .validate_call_decorator import validate_call\n    from .warnings import (\n        PydanticDeprecatedSince20,\n        PydanticDeprecatedSince26,\n        PydanticDeprecationWarning,\n        PydanticExperimentalWarning,\n    )\n\n    # this encourages pycharm to import `ValidationError` from here, not pydantic_core\n    ValidationError = pydantic_core.ValidationError\n    from .deprecated.class_validators import root_validator, validator\n    from .deprecated.config import BaseConfig, Extra\n    from .deprecated.tools import *\n    from .root_model import RootModel\n\n__version__ = VERSION\n__all__ = (\n    # dataclasses\n    'dataclasses',\n    # functional validators\n    'field_validator',\n    'model_validator',\n    'AfterValidator',\n    'BeforeValidator',\n    'PlainValidator',\n    'WrapValidator',\n    'SkipValidation',\n    'InstanceOf',\n    # JSON Schema\n    'WithJsonSchema',\n    # deprecated V1 functional validators, these are imported via `__getattr__` below\n    'root_validator',\n    'validator',\n    # functional serializers\n    'field_serializer',\n    'model_serializer',\n    'PlainSerializer',\n    'SerializeAsAny',\n    'WrapSerializer',\n    # config\n    'ConfigDict',\n    'with_config',\n    # deprecated V1 config, these are imported via `__getattr__` below\n    'BaseConfig',\n    'Extra',\n    # validate_call\n    'validate_call',\n    # errors\n    'PydanticErrorCodes',\n    'PydanticUserError',\n    'PydanticSchemaGenerationError',\n    'PydanticImportError',\n    'PydanticUndefinedAnnotation',\n    'PydanticInvalidForJsonSchema',\n    # fields\n    'Field',\n    'computed_field',\n    'PrivateAttr',\n    # alias\n    'AliasChoices',\n    'AliasGenerator',\n    'AliasPath',\n    # main\n    'BaseModel',\n    'create_model',\n    # network\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'HttpUrl',\n    'FtpUrl',\n    'WebsocketUrl',\n    'AnyWebsocketUrl',\n    'UrlConstraints',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'NatsDsn',\n    'MySQLDsn',\n    'MariaDBDsn',\n    'ClickHouseDsn',\n    'validate_email',\n    # root_model\n    'RootModel',\n    # deprecated tools, these are imported via `__getattr__` below\n    'parse_obj_as',\n    'schema_of',\n    'schema_json_of',\n    # types\n    'Strict',\n    'StrictStr',\n    'conbytes',\n    'conlist',\n    'conset',\n    'confrozenset',\n    'constr',\n    'StringConstraints',\n    'ImportString',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'condecimal',\n    'condate',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'FilePath',\n    'DirectoryPath',\n    'NewPath',\n    'Json',\n    'Secret',\n    'SecretStr',\n    'SecretBytes',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    'PastDatetime',\n    'FutureDatetime',\n    'AwareDatetime',\n    'NaiveDatetime',\n    'AllowInfNan',\n    'EncoderProtocol',\n    'EncodedBytes',\n    'EncodedStr',\n    'Base64Encoder',\n    'Base64Bytes',\n    'Base64Str',\n    'Base64UrlBytes',\n    'Base64UrlStr',\n    'GetPydanticSchema',\n    'Tag',\n    'Discriminator',\n    'JsonValue',\n    # type_adapter\n    'TypeAdapter',\n    # version\n    '__version__',\n    'VERSION',\n    # warnings\n    'PydanticDeprecatedSince20',\n    'PydanticDeprecatedSince26',\n    'PydanticDeprecationWarning',\n    'PydanticExperimentalWarning',\n    # annotated handlers\n    'GetCoreSchemaHandler',\n    'GetJsonSchemaHandler',\n    # generate schema from ._internal\n    'GenerateSchema',\n    # pydantic_core\n    'ValidationError',\n    'ValidationInfo',\n    'SerializationInfo',\n    'ValidatorFunctionWrapHandler',\n    'FieldSerializationInfo',\n    'SerializerFunctionWrapHandler',\n    'OnErrorOmit',\n)\n\n# A mapping of {<member name>: (package, <module name>)} defining dynamic imports\n_dynamic_imports: 'dict[str, tuple[str, str]]' = {\n    'dataclasses': (__spec__.parent, '__module__'),\n    # functional validators\n    'field_validator': (__spec__.parent, '.functional_validators'),\n    'model_validator': (__spec__.parent, '.functional_validators'),\n    'AfterValidator': (__spec__.parent, '.functional_validators'),\n    'BeforeValidator': (__spec__.parent, '.functional_validators'),\n    'PlainValidator': (__spec__.parent, '.functional_validators'),\n    'WrapValidator': (__spec__.parent, '.functional_validators'),\n    'SkipValidation': (__spec__.parent, '.functional_validators'),\n    'InstanceOf': (__spec__.parent, '.functional_validators'),\n    # JSON Schema\n    'WithJsonSchema': (__spec__.parent, '.json_schema'),\n    # functional serializers\n    'field_serializer': (__spec__.parent, '.functional_serializers'),\n    'model_serializer': (__spec__.parent, '.functional_serializers'),\n    'PlainSerializer': (__spec__.parent, '.functional_serializers'),\n    'SerializeAsAny': (__spec__.parent, '.functional_serializers'),\n    'WrapSerializer': (__spec__.parent, '.functional_serializers'),\n    # config\n    'ConfigDict': (__spec__.parent, '.config'),\n    'with_config': (__spec__.parent, '.config'),\n    # validate call\n    'validate_call': (__spec__.parent, '.validate_call_decorator'),\n    # errors\n    'PydanticErrorCodes': (__spec__.parent, '.errors'),\n    'PydanticUserError': (__spec__.parent, '.errors'),\n    'PydanticSchemaGenerationError': (__spec__.parent, '.errors'),\n    'PydanticImportError': (__spec__.parent, '.errors'),\n    'PydanticUndefinedAnnotation': (__spec__.parent, '.errors'),\n    'PydanticInvalidForJsonSchema': (__spec__.parent, '.errors'),\n    # fields\n    'Field': (__spec__.parent, '.fields'),\n    'computed_field': (__spec__.parent, '.fields'),\n    'PrivateAttr': (__spec__.parent, '.fields'),\n    # alias\n    'AliasChoices': (__spec__.parent, '.aliases'),\n    'AliasGenerator': (__spec__.parent, '.aliases'),\n    'AliasPath': (__spec__.parent, '.aliases'),\n    # main\n    'BaseModel': (__spec__.parent, '.main'),\n    'create_model': (__spec__.parent, '.main'),\n    # network\n    'AnyUrl': (__spec__.parent, '.networks'),\n    'AnyHttpUrl': (__spec__.parent, '.networks'),\n    'FileUrl': (__spec__.parent, '.networks'),\n    'HttpUrl': (__spec__.parent, '.networks'),\n    'FtpUrl': (__spec__.parent, '.networks'),\n    'WebsocketUrl': (__spec__.parent, '.networks'),\n    'AnyWebsocketUrl': (__spec__.parent, '.networks'),\n    'UrlConstraints': (__spec__.parent, '.networks'),\n    'EmailStr': (__spec__.parent, '.networks'),\n    'NameEmail': (__spec__.parent, '.networks'),\n    'IPvAnyAddress': (__spec__.parent, '.networks'),\n    'IPvAnyInterface': (__spec__.parent, '.networks'),\n    'IPvAnyNetwork': (__spec__.parent, '.networks'),\n    'PostgresDsn': (__spec__.parent, '.networks'),\n    'CockroachDsn': (__spec__.parent, '.networks'),\n    'AmqpDsn': (__spec__.parent, '.networks'),\n    'RedisDsn': (__spec__.parent, '.networks'),\n    'MongoDsn': (__spec__.parent, '.networks'),\n    'KafkaDsn': (__spec__.parent, '.networks'),\n    'NatsDsn': (__spec__.parent, '.networks'),\n    'MySQLDsn': (__spec__.parent, '.networks'),\n    'MariaDBDsn': (__spec__.parent, '.networks'),\n    'ClickHouseDsn': (__spec__.parent, '.networks'),\n    'validate_email': (__spec__.parent, '.networks'),\n    # root_model\n    'RootModel': (__spec__.parent, '.root_model'),\n    # types\n    'Strict': (__spec__.parent, '.types'),\n    'StrictStr': (__spec__.parent, '.types'),\n    'conbytes': (__spec__.parent, '.types'),\n    'conlist': (__spec__.parent, '.types'),\n    'conset': (__spec__.parent, '.types'),\n    'confrozenset': (__spec__.parent, '.types'),\n    'constr': (__spec__.parent, '.types'),\n    'StringConstraints': (__spec__.parent, '.types'),\n    'ImportString': (__spec__.parent, '.types'),\n    'conint': (__spec__.parent, '.types'),\n    'PositiveInt': (__spec__.parent, '.types'),\n    'NegativeInt': (__spec__.parent, '.types'),\n    'NonNegativeInt': (__spec__.parent, '.types'),\n    'NonPositiveInt': (__spec__.parent, '.types'),\n    'confloat': (__spec__.parent, '.types'),\n    'PositiveFloat': (__spec__.parent, '.types'),\n    'NegativeFloat': (__spec__.parent, '.types'),\n    'NonNegativeFloat': (__spec__.parent, '.types'),\n    'NonPositiveFloat': (__spec__.parent, '.types'),\n    'FiniteFloat': (__spec__.parent, '.types'),\n    'condecimal': (__spec__.parent, '.types'),\n    'condate': (__spec__.parent, '.types'),\n    'UUID1': (__spec__.parent, '.types'),\n    'UUID3': (__spec__.parent, '.types'),\n    'UUID4': (__spec__.parent, '.types'),\n    'UUID5': (__spec__.parent, '.types'),\n    'FilePath': (__spec__.parent, '.types'),\n    'DirectoryPath': (__spec__.parent, '.types'),\n    'NewPath': (__spec__.parent, '.types'),\n    'Json': (__spec__.parent, '.types'),\n    'Secret': (__spec__.parent, '.types'),\n    'SecretStr': (__spec__.parent, '.types'),\n    'SecretBytes': (__spec__.parent, '.types'),\n    'StrictBool': (__spec__.parent, '.types'),\n    'StrictBytes': (__spec__.parent, '.types'),\n    'StrictInt': (__spec__.parent, '.types'),\n    'StrictFloat': (__spec__.parent, '.types'),\n    'PaymentCardNumber': (__spec__.parent, '.types'),\n    'ByteSize': (__spec__.parent, '.types'),\n    'PastDate': (__spec__.parent, '.types'),\n    'FutureDate': (__spec__.parent, '.types'),\n    'PastDatetime': (__spec__.parent, '.types'),\n    'FutureDatetime': (__spec__.parent, '.types'),\n    'AwareDatetime': (__spec__.parent, '.types'),\n    'NaiveDatetime': (__spec__.parent, '.types'),\n    'AllowInfNan': (__spec__.parent, '.types'),\n    'EncoderProtocol': (__spec__.parent, '.types'),\n    'EncodedBytes': (__spec__.parent, '.types'),\n    'EncodedStr': (__spec__.parent, '.types'),\n    'Base64Encoder': (__spec__.parent, '.types'),\n    'Base64Bytes': (__spec__.parent, '.types'),\n    'Base64Str': (__spec__.parent, '.types'),\n    'Base64UrlBytes': (__spec__.parent, '.types'),\n    'Base64UrlStr': (__spec__.parent, '.types'),\n    'GetPydanticSchema': (__spec__.parent, '.types'),\n    'Tag': (__spec__.parent, '.types'),\n    'Discriminator': (__spec__.parent, '.types'),\n    'JsonValue': (__spec__.parent, '.types'),\n    'OnErrorOmit': (__spec__.parent, '.types'),\n    # type_adapter\n    'TypeAdapter': (__spec__.parent, '.type_adapter'),\n    # warnings\n    'PydanticDeprecatedSince20': (__spec__.parent, '.warnings'),\n    'PydanticDeprecatedSince26': (__spec__.parent, '.warnings'),\n    'PydanticDeprecationWarning': (__spec__.parent, '.warnings'),\n    'PydanticExperimentalWarning': (__spec__.parent, '.warnings'),\n    # annotated handlers\n    'GetCoreSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    'GetJsonSchemaHandler': (__spec__.parent, '.annotated_handlers'),\n    # generate schema from ._internal\n    'GenerateSchema': (__spec__.parent, '._internal._generate_schema'),\n    # pydantic_core stuff\n    'ValidationError': ('pydantic_core', '.'),\n    'ValidationInfo': ('pydantic_core', '.core_schema'),\n    'SerializationInfo': ('pydantic_core', '.core_schema'),\n    'ValidatorFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    'FieldSerializationInfo': ('pydantic_core', '.core_schema'),\n    'SerializerFunctionWrapHandler': ('pydantic_core', '.core_schema'),\n    # deprecated, mostly not included in __all__\n    'root_validator': (__spec__.parent, '.deprecated.class_validators'),\n    'validator': (__spec__.parent, '.deprecated.class_validators'),\n    'BaseConfig': (__spec__.parent, '.deprecated.config'),\n    'Extra': (__spec__.parent, '.deprecated.config'),\n    'parse_obj_as': (__spec__.parent, '.deprecated.tools'),\n    'schema_of': (__spec__.parent, '.deprecated.tools'),\n    'schema_json_of': (__spec__.parent, '.deprecated.tools'),\n    'FieldValidationInfo': ('pydantic_core', '.core_schema'),\n}\n\n_getattr_migration = getattr_migration(__name__)\n\n\ndef __getattr__(attr_name: str) -> object:\n    dynamic_attr = _dynamic_imports.get(attr_name)\n    if dynamic_attr is None:\n        return _getattr_migration(attr_name)\n\n    package, module_name = dynamic_attr\n\n    from importlib import import_module\n\n    if module_name == '__module__':\n        return import_module(f'.{attr_name}', package=package)\n    else:\n        module = import_module(module_name, package=package)\n        return getattr(module, attr_name)\n\n\ndef __dir__() -> 'list[str]':\n    return list(__all__)\n", "pydantic/mypy.py": "\"\"\"This module includes classes and functions designed specifically for use with the mypy plugin.\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nfrom configparser import ConfigParser\nfrom typing import Any, Callable, Iterator\n\nfrom mypy.errorcodes import ErrorCode\nfrom mypy.expandtype import expand_type, expand_type_by_instance\nfrom mypy.nodes import (\n    ARG_NAMED,\n    ARG_NAMED_OPT,\n    ARG_OPT,\n    ARG_POS,\n    ARG_STAR2,\n    INVARIANT,\n    MDEF,\n    Argument,\n    AssignmentStmt,\n    Block,\n    CallExpr,\n    ClassDef,\n    Context,\n    Decorator,\n    DictExpr,\n    EllipsisExpr,\n    Expression,\n    FuncDef,\n    IfStmt,\n    JsonDict,\n    MemberExpr,\n    NameExpr,\n    PassStmt,\n    PlaceholderNode,\n    RefExpr,\n    Statement,\n    StrExpr,\n    SymbolTableNode,\n    TempNode,\n    TypeAlias,\n    TypeInfo,\n    Var,\n)\nfrom mypy.options import Options\nfrom mypy.plugin import (\n    CheckerPluginInterface,\n    ClassDefContext,\n    FunctionContext,\n    MethodContext,\n    Plugin,\n    ReportConfigContext,\n    SemanticAnalyzerPluginInterface,\n)\nfrom mypy.plugins import dataclasses\nfrom mypy.plugins.common import (\n    deserialize_and_fixup_type,\n)\nfrom mypy.semanal import set_callable_name\nfrom mypy.server.trigger import make_wildcard_trigger\nfrom mypy.state import state\nfrom mypy.typeops import map_type_from_supertype\nfrom mypy.types import (\n    AnyType,\n    CallableType,\n    Instance,\n    NoneType,\n    Overloaded,\n    Type,\n    TypeOfAny,\n    TypeType,\n    TypeVarType,\n    UnionType,\n    get_proper_type,\n)\nfrom mypy.typevars import fill_typevars\nfrom mypy.util import get_unique_redefinition_name\nfrom mypy.version import __version__ as mypy_version\n\nfrom pydantic._internal import _fields\nfrom pydantic.version import parse_mypy_version\n\ntry:\n    from mypy.types import TypeVarDef  # type: ignore[attr-defined]\nexcept ImportError:  # pragma: no cover\n    # Backward-compatible with TypeVarDef from Mypy 0.930.\n    from mypy.types import TypeVarType as TypeVarDef\n\nCONFIGFILE_KEY = 'pydantic-mypy'\nMETADATA_KEY = 'pydantic-mypy-metadata'\nBASEMODEL_FULLNAME = 'pydantic.main.BaseModel'\nBASESETTINGS_FULLNAME = 'pydantic_settings.main.BaseSettings'\nROOT_MODEL_FULLNAME = 'pydantic.root_model.RootModel'\nMODEL_METACLASS_FULLNAME = 'pydantic._internal._model_construction.ModelMetaclass'\nFIELD_FULLNAME = 'pydantic.fields.Field'\nDATACLASS_FULLNAME = 'pydantic.dataclasses.dataclass'\nMODEL_VALIDATOR_FULLNAME = 'pydantic.functional_validators.model_validator'\nDECORATOR_FULLNAMES = {\n    'pydantic.functional_validators.field_validator',\n    'pydantic.functional_validators.model_validator',\n    'pydantic.functional_serializers.serializer',\n    'pydantic.functional_serializers.model_serializer',\n    'pydantic.deprecated.class_validators.validator',\n    'pydantic.deprecated.class_validators.root_validator',\n}\n\n\nMYPY_VERSION_TUPLE = parse_mypy_version(mypy_version)\nBUILTINS_NAME = 'builtins' if MYPY_VERSION_TUPLE >= (0, 930) else '__builtins__'\n\n# Increment version if plugin changes and mypy caches should be invalidated\n__version__ = 2\n\n\ndef plugin(version: str) -> type[Plugin]:\n    \"\"\"`version` is the mypy version string.\n\n    We might want to use this to print a warning if the mypy version being used is\n    newer, or especially older, than we expect (or need).\n\n    Args:\n        version: The mypy version string.\n\n    Return:\n        The Pydantic mypy plugin type.\n    \"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    \"\"\"The Pydantic mypy plugin.\"\"\"\n\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = self.plugin_config.to_data()\n        super().__init__(options)\n\n    def get_base_class_hook(self, fullname: str) -> Callable[[ClassDefContext], bool] | None:\n        \"\"\"Update Pydantic model class.\"\"\"\n        sym = self.lookup_fully_qualified(fullname)\n        if sym and isinstance(sym.node, TypeInfo):  # pragma: no branch\n            # No branching may occur if the mypy cache has not been cleared\n            if any(base.fullname == BASEMODEL_FULLNAME for base in sym.node.mro):\n                return self._pydantic_model_class_maker_callback\n        return None\n\n    def get_metaclass_hook(self, fullname: str) -> Callable[[ClassDefContext], None] | None:\n        \"\"\"Update Pydantic `ModelMetaclass` definition.\"\"\"\n        if fullname == MODEL_METACLASS_FULLNAME:\n            return self._pydantic_model_metaclass_marker_callback\n        return None\n\n    def get_function_hook(self, fullname: str) -> Callable[[FunctionContext], Type] | None:\n        \"\"\"Adjust the return type of the `Field` function.\"\"\"\n        sym = self.lookup_fully_qualified(fullname)\n        if sym and sym.fullname == FIELD_FULLNAME:\n            return self._pydantic_field_callback\n        return None\n\n    def get_method_hook(self, fullname: str) -> Callable[[MethodContext], Type] | None:\n        \"\"\"Adjust return type of `from_orm` method call.\"\"\"\n        if fullname.endswith('.from_orm'):\n            return from_attributes_callback\n        return None\n\n    def get_class_decorator_hook(self, fullname: str) -> Callable[[ClassDefContext], None] | None:\n        \"\"\"Mark pydantic.dataclasses as dataclass.\n\n        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.\n        \"\"\"\n        if fullname == DATACLASS_FULLNAME and MYPY_VERSION_TUPLE < (1, 1):\n            return dataclasses.dataclass_class_maker_callback  # type: ignore[return-value]\n        return None\n\n    def report_config_data(self, ctx: ReportConfigContext) -> dict[str, Any]:\n        \"\"\"Return all plugin config data.\n\n        Used by mypy to determine if cache needs to be discarded.\n        \"\"\"\n        return self._plugin_data\n\n    def _pydantic_model_class_maker_callback(self, ctx: ClassDefContext) -> bool:\n        transformer = PydanticModelTransformer(ctx.cls, ctx.reason, ctx.api, self.plugin_config)\n        return transformer.transform()\n\n    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext) -> None:\n        \"\"\"Reset dataclass_transform_spec attribute of ModelMetaclass.\n\n        Let the plugin handle it. This behavior can be disabled\n        if 'debug_dataclass_transform' is set to True', for testing purposes.\n        \"\"\"\n        if self.plugin_config.debug_dataclass_transform:\n            return\n        info_metaclass = ctx.cls.info.declared_metaclass\n        assert info_metaclass, \"callback not passed from 'get_metaclass_hook'\"\n        if getattr(info_metaclass.type, 'dataclass_transform_spec', None):\n            info_metaclass.type.dataclass_transform_spec = None\n\n    def _pydantic_field_callback(self, ctx: FunctionContext) -> Type:\n        \"\"\"Extract the type of the `default` argument from the Field function, and use it as the return type.\n\n        In particular:\n        * Check whether the default and default_factory argument is specified.\n        * Output an error if both are specified.\n        * Retrieve the type of the argument which is specified, and use it as return type for the function.\n        \"\"\"\n        default_any_type = ctx.default_return_type\n\n        assert ctx.callee_arg_names[0] == 'default', '\"default\" is no longer first argument in Field()'\n        assert ctx.callee_arg_names[1] == 'default_factory', '\"default_factory\" is no longer second argument in Field()'\n        default_args = ctx.args[0]\n        default_factory_args = ctx.args[1]\n\n        if default_args and default_factory_args:\n            error_default_and_default_factory_specified(ctx.api, ctx.context)\n            return default_any_type\n\n        if default_args:\n            default_type = ctx.arg_types[0][0]\n            default_arg = default_args[0]\n\n            # Fallback to default Any type if the field is required\n            if not isinstance(default_arg, EllipsisExpr):\n                return default_type\n\n        elif default_factory_args:\n            default_factory_type = ctx.arg_types[1][0]\n\n            # Functions which use `ParamSpec` can be overloaded, exposing the callable's types as a parameter\n            # Pydantic calls the default factory without any argument, so we retrieve the first item\n            if isinstance(default_factory_type, Overloaded):\n                default_factory_type = default_factory_type.items[0]\n\n            if isinstance(default_factory_type, CallableType):\n                ret_type = default_factory_type.ret_type\n                # mypy doesn't think `ret_type` has `args`, you'd think mypy should know,\n                # add this check in case it varies by version\n                args = getattr(ret_type, 'args', None)\n                if args:\n                    if all(isinstance(arg, TypeVarType) for arg in args):\n                        # Looks like the default factory is a type like `list` or `dict`, replace all args with `Any`\n                        ret_type.args = tuple(default_any_type for _ in args)  # type: ignore[attr-defined]\n                return ret_type\n\n        return default_any_type\n\n\nclass PydanticPluginConfig:\n    \"\"\"A Pydantic mypy plugin config holder.\n\n    Attributes:\n        init_forbid_extra: Whether to add a `**kwargs` at the end of the generated `__init__` signature.\n        init_typed: Whether to annotate fields in the generated `__init__`.\n        warn_required_dynamic_aliases: Whether to raise required dynamic aliases error.\n        debug_dataclass_transform: Whether to not reset `dataclass_transform_spec` attribute\n            of `ModelMetaclass` for testing purposes.\n    \"\"\"\n\n    __slots__ = (\n        'init_forbid_extra',\n        'init_typed',\n        'warn_required_dynamic_aliases',\n        'debug_dataclass_transform',\n    )\n    init_forbid_extra: bool\n    init_typed: bool\n    warn_required_dynamic_aliases: bool\n    debug_dataclass_transform: bool  # undocumented\n\n    def __init__(self, options: Options) -> None:\n        if options.config_file is None:  # pragma: no cover\n            return\n\n        toml_config = parse_toml(options.config_file)\n        if toml_config is not None:\n            config = toml_config.get('tool', {}).get('pydantic-mypy', {})\n            for key in self.__slots__:\n                setting = config.get(key, False)\n                if not isinstance(setting, bool):\n                    raise ValueError(f'Configuration value must be a boolean for key: {key}')\n                setattr(self, key, setting)\n        else:\n            plugin_config = ConfigParser()\n            plugin_config.read(options.config_file)\n            for key in self.__slots__:\n                setting = plugin_config.getboolean(CONFIGFILE_KEY, key, fallback=False)\n                setattr(self, key, setting)\n\n    def to_data(self) -> dict[str, Any]:\n        \"\"\"Returns a dict of config names to their values.\"\"\"\n        return {key: getattr(self, key) for key in self.__slots__}\n\n\ndef from_attributes_callback(ctx: MethodContext) -> Type:\n    \"\"\"Raise an error if from_attributes is not enabled.\"\"\"\n    model_type: Instance\n    ctx_type = ctx.type\n    if isinstance(ctx_type, TypeType):\n        ctx_type = ctx_type.item\n    if isinstance(ctx_type, CallableType) and isinstance(ctx_type.ret_type, Instance):\n        model_type = ctx_type.ret_type  # called on the class\n    elif isinstance(ctx_type, Instance):\n        model_type = ctx_type  # called on an instance (unusual, but still valid)\n    else:  # pragma: no cover\n        detail = f'ctx.type: {ctx_type} (of type {ctx_type.__class__.__name__})'\n        error_unexpected_behavior(detail, ctx.api, ctx.context)\n        return ctx.default_return_type\n    pydantic_metadata = model_type.type.metadata.get(METADATA_KEY)\n    if pydantic_metadata is None:\n        return ctx.default_return_type\n    from_attributes = pydantic_metadata.get('config', {}).get('from_attributes')\n    if from_attributes is not True:\n        error_from_attributes(model_type.type.name, ctx.api, ctx.context)\n    return ctx.default_return_type\n\n\nclass PydanticModelField:\n    \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        alias: str | None,\n        has_dynamic_alias: bool,\n        has_default: bool,\n        line: int,\n        column: int,\n        type: Type | None,\n        info: TypeInfo,\n    ):\n        self.name = name\n        self.alias = alias\n        self.has_dynamic_alias = has_dynamic_alias\n        self.has_default = has_default\n        self.line = line\n        self.column = column\n        self.type = type\n        self.info = info\n\n    def to_argument(\n        self,\n        current_info: TypeInfo,\n        typed: bool,\n        force_optional: bool,\n        use_alias: bool,\n        api: SemanticAnalyzerPluginInterface,\n        force_typevars_invariant: bool,\n    ) -> Argument:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.to_argument.\"\"\"\n        variable = self.to_var(current_info, api, use_alias, force_typevars_invariant)\n        type_annotation = self.expand_type(current_info, api) if typed else AnyType(TypeOfAny.explicit)\n        return Argument(\n            variable=variable,\n            type_annotation=type_annotation,\n            initializer=None,\n            kind=ARG_NAMED_OPT if force_optional or self.has_default else ARG_NAMED,\n        )\n\n    def expand_type(\n        self, current_info: TypeInfo, api: SemanticAnalyzerPluginInterface, force_typevars_invariant: bool = False\n    ) -> Type | None:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.expand_type.\"\"\"\n        # The getattr in the next line is used to prevent errors in legacy versions of mypy without this attribute\n        if force_typevars_invariant:\n            # In some cases, mypy will emit an error \"Cannot use a covariant type variable as a parameter\"\n            # To prevent that, we add an option to replace typevars with invariant ones while building certain\n            # method signatures (in particular, `__init__`). There may be a better way to do this, if this causes\n            # us problems in the future, we should look into why the dataclasses plugin doesn't have this issue.\n            if isinstance(self.type, TypeVarType):\n                modified_type = self.type.copy_modified()\n                modified_type.variance = INVARIANT\n                self.type = modified_type\n\n        if self.type is not None and getattr(self.info, 'self_type', None) is not None:\n            # In general, it is not safe to call `expand_type()` during semantic analyzis,\n            # however this plugin is called very late, so all types should be fully ready.\n            # Also, it is tricky to avoid eager expansion of Self types here (e.g. because\n            # we serialize attributes).\n            with state.strict_optional_set(api.options.strict_optional):\n                filled_with_typevars = fill_typevars(current_info)\n                if force_typevars_invariant:\n                    for arg in filled_with_typevars.args:\n                        if isinstance(arg, TypeVarType):\n                            arg.variance = INVARIANT\n                return expand_type(self.type, {self.info.self_type.id: filled_with_typevars})\n        return self.type\n\n    def to_var(\n        self,\n        current_info: TypeInfo,\n        api: SemanticAnalyzerPluginInterface,\n        use_alias: bool,\n        force_typevars_invariant: bool = False,\n    ) -> Var:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.to_var.\"\"\"\n        if use_alias and self.alias is not None:\n            name = self.alias\n        else:\n            name = self.name\n\n        return Var(name, self.expand_type(current_info, api, force_typevars_invariant))\n\n    def serialize(self) -> JsonDict:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.\"\"\"\n        assert self.type\n        return {\n            'name': self.name,\n            'alias': self.alias,\n            'has_dynamic_alias': self.has_dynamic_alias,\n            'has_default': self.has_default,\n            'line': self.line,\n            'column': self.column,\n            'type': self.type.serialize(),\n        }\n\n    @classmethod\n    def deserialize(cls, info: TypeInfo, data: JsonDict, api: SemanticAnalyzerPluginInterface) -> PydanticModelField:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.\"\"\"\n        data = data.copy()\n        typ = deserialize_and_fixup_type(data.pop('type'), api)\n        return cls(type=typ, info=info, **data)\n\n    def expand_typevar_from_subtype(self, sub_type: TypeInfo, api: SemanticAnalyzerPluginInterface) -> None:\n        \"\"\"Expands type vars in the context of a subtype when an attribute is inherited\n        from a generic super type.\n        \"\"\"\n        if self.type is not None:\n            with state.strict_optional_set(api.options.strict_optional):\n                self.type = map_type_from_supertype(self.type, sub_type, self.info)\n\n\nclass PydanticModelClassVar:\n    \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.\n\n    ClassVars are ignored by subclasses.\n\n    Attributes:\n        name: the ClassVar name\n    \"\"\"\n\n    def __init__(self, name):\n        self.name = name\n\n    @classmethod\n    def deserialize(cls, data: JsonDict) -> PydanticModelClassVar:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.deserialize.\"\"\"\n        data = data.copy()\n        return cls(**data)\n\n    def serialize(self) -> JsonDict:\n        \"\"\"Based on mypy.plugins.dataclasses.DataclassAttribute.serialize.\"\"\"\n        return {\n            'name': self.name,\n        }\n\n\nclass PydanticModelTransformer:\n    \"\"\"Transform the BaseModel subclass according to the plugin settings.\n\n    Attributes:\n        tracked_config_fields: A set of field configs that the plugin has to track their value.\n    \"\"\"\n\n    tracked_config_fields: set[str] = {\n        'extra',\n        'frozen',\n        'from_attributes',\n        'populate_by_name',\n        'alias_generator',\n    }\n\n    def __init__(\n        self,\n        cls: ClassDef,\n        reason: Expression | Statement,\n        api: SemanticAnalyzerPluginInterface,\n        plugin_config: PydanticPluginConfig,\n    ) -> None:\n        self._cls = cls\n        self._reason = reason\n        self._api = api\n\n        self.plugin_config = plugin_config\n\n    def transform(self) -> bool:\n        \"\"\"Configures the BaseModel subclass according to the plugin settings.\n\n        In particular:\n\n        * determines the model config and fields,\n        * adds a fields-aware signature for the initializer and construct methods\n        * freezes the class if frozen = True\n        * stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses\n        \"\"\"\n        info = self._cls.info\n        is_root_model = any(ROOT_MODEL_FULLNAME in base.fullname for base in info.mro[:-1])\n        config = self.collect_config()\n        fields, class_vars = self.collect_fields_and_class_vars(config, is_root_model)\n        if fields is None or class_vars is None:\n            # Some definitions are not ready. We need another pass.\n            return False\n        for field in fields:\n            if field.type is None:\n                return False\n\n        is_settings = any(base.fullname == BASESETTINGS_FULLNAME for base in info.mro[:-1])\n        self.add_initializer(fields, config, is_settings, is_root_model)\n        if not is_root_model:\n            self.add_model_construct_method(fields, config, is_settings)\n        self.set_frozen(fields, self._api, frozen=config.frozen is True)\n\n        self.adjust_decorator_signatures()\n\n        info.metadata[METADATA_KEY] = {\n            'fields': {field.name: field.serialize() for field in fields},\n            'class_vars': {class_var.name: class_var.serialize() for class_var in class_vars},\n            'config': config.get_values_dict(),\n        }\n\n        return True\n\n    def adjust_decorator_signatures(self) -> None:\n        \"\"\"When we decorate a function `f` with `pydantic.validator(...)`, `pydantic.field_validator`\n        or `pydantic.serializer(...)`, mypy sees `f` as a regular method taking a `self` instance,\n        even though pydantic internally wraps `f` with `classmethod` if necessary.\n\n        Teach mypy this by marking any function whose outermost decorator is a `validator()`,\n        `field_validator()` or `serializer()` call as a `classmethod`.\n        \"\"\"\n        for name, sym in self._cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n                    isinstance(first_dec, CallExpr)\n                    and isinstance(first_dec.callee, NameExpr)\n                    and first_dec.callee.fullname in DECORATOR_FULLNAMES\n                    # @model_validator(mode=\"after\") is an exception, it expects a regular method\n                    and not (\n                        first_dec.callee.fullname == MODEL_VALIDATOR_FULLNAME\n                        and any(\n                            first_dec.arg_names[i] == 'mode' and isinstance(arg, StrExpr) and arg.value == 'after'\n                            for i, arg in enumerate(first_dec.args)\n                        )\n                    )\n                ):\n                    # TODO: Only do this if the first argument of the decorated function is `cls`\n                    sym.node.func.is_class = True\n\n    def collect_config(self) -> ModelConfigData:  # noqa: C901 (ignore complexity)\n        \"\"\"Collects the values of the config attributes that are used by the plugin, accounting for parent classes.\"\"\"\n        cls = self._cls\n        config = ModelConfigData()\n\n        has_config_kwargs = False\n        has_config_from_namespace = False\n\n        # Handle `class MyModel(BaseModel, <name>=<expr>, ...):`\n        for name, expr in cls.keywords.items():\n            config_data = self.get_config_update(name, expr)\n            if config_data:\n                has_config_kwargs = True\n                config.update(config_data)\n\n        # Handle `model_config`\n        stmt: Statement | None = None\n        for stmt in cls.defs.body:\n            if not isinstance(stmt, (AssignmentStmt, ClassDef)):\n                continue\n\n            if isinstance(stmt, AssignmentStmt):\n                lhs = stmt.lvalues[0]\n                if not isinstance(lhs, NameExpr) or lhs.name != 'model_config':\n                    continue\n\n                if isinstance(stmt.rvalue, CallExpr):  # calls to `dict` or `ConfigDict`\n                    for arg_name, arg in zip(stmt.rvalue.arg_names, stmt.rvalue.args):\n                        if arg_name is None:\n                            continue\n                        config.update(self.get_config_update(arg_name, arg, lax_extra=True))\n                elif isinstance(stmt.rvalue, DictExpr):  # dict literals\n                    for key_expr, value_expr in stmt.rvalue.items:\n                        if not isinstance(key_expr, StrExpr):\n                            continue\n                        config.update(self.get_config_update(key_expr.value, value_expr))\n\n            elif isinstance(stmt, ClassDef):\n                if stmt.name != 'Config':  # 'deprecated' Config-class\n                    continue\n                for substmt in stmt.defs.body:\n                    if not isinstance(substmt, AssignmentStmt):\n                        continue\n                    lhs = substmt.lvalues[0]\n                    if not isinstance(lhs, NameExpr):\n                        continue\n                    config.update(self.get_config_update(lhs.name, substmt.rvalue))\n\n            if has_config_kwargs:\n                self._api.fail(\n                    'Specifying config in two places is ambiguous, use either Config attribute or class kwargs',\n                    cls,\n                )\n                break\n\n            has_config_from_namespace = True\n\n        if has_config_kwargs or has_config_from_namespace:\n            if (\n                stmt\n                and config.has_alias_generator\n                and not config.populate_by_name\n                and self.plugin_config.warn_required_dynamic_aliases\n            ):\n                error_required_dynamic_aliases(self._api, stmt)\n\n        for info in cls.info.mro[1:]:  # 0 is the current class\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of fields in its ancestors\n            self._api.add_plugin_dependency(make_wildcard_trigger(info.fullname))\n            for name, value in info.metadata[METADATA_KEY]['config'].items():\n                config.setdefault(name, value)\n        return config\n\n    def collect_fields_and_class_vars(\n        self, model_config: ModelConfigData, is_root_model: bool\n    ) -> tuple[list[PydanticModelField] | None, list[PydanticModelClassVar] | None]:\n        \"\"\"Collects the fields for the model, accounting for parent classes.\"\"\"\n        cls = self._cls\n\n        # First, collect fields and ClassVars belonging to any class in the MRO, ignoring duplicates.\n        #\n        # We iterate through the MRO in reverse because attrs defined in the parent must appear\n        # earlier in the attributes list than attrs defined in the child. See:\n        # https://docs.python.org/3/library/dataclasses.html#inheritance\n        #\n        # However, we also want fields defined in the subtype to override ones defined\n        # in the parent. We can implement this via a dict without disrupting the attr order\n        # because dicts preserve insertion order in Python 3.7+.\n        found_fields: dict[str, PydanticModelField] = {}\n        found_class_vars: dict[str, PydanticModelClassVar] = {}\n        for info in reversed(cls.info.mro[1:-1]):  # 0 is the current class, -2 is BaseModel, -1 is object\n            # if BASEMODEL_METADATA_TAG_KEY in info.metadata and BASEMODEL_METADATA_KEY not in info.metadata:\n            #     # We haven't processed the base class yet. Need another pass.\n            #     return None, None\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of attributes in its dataclass ancestors.\n            self._api.add_plugin_dependency(make_wildcard_trigger(info.fullname))\n\n            for name, data in info.metadata[METADATA_KEY]['fields'].items():\n                field = PydanticModelField.deserialize(info, data, self._api)\n                # (The following comment comes directly from the dataclasses plugin)\n                # TODO: We shouldn't be performing type operations during the main\n                #       semantic analysis pass, since some TypeInfo attributes might\n                #       still be in flux. This should be performed in a later phase.\n                field.expand_typevar_from_subtype(cls.info, self._api)\n                found_fields[name] = field\n\n                sym_node = cls.info.names.get(name)\n                if sym_node and sym_node.node and not isinstance(sym_node.node, Var):\n                    self._api.fail(\n                        'BaseModel field may only be overridden by another field',\n                        sym_node.node,\n                    )\n            # Collect ClassVars\n            for name, data in info.metadata[METADATA_KEY]['class_vars'].items():\n                found_class_vars[name] = PydanticModelClassVar.deserialize(data)\n\n        # Second, collect fields and ClassVars belonging to the current class.\n        current_field_names: set[str] = set()\n        current_class_vars_names: set[str] = set()\n        for stmt in self._get_assignment_statements_from_block(cls.defs):\n            maybe_field = self.collect_field_or_class_var_from_stmt(stmt, model_config, found_class_vars)\n            if isinstance(maybe_field, PydanticModelField):\n                lhs = stmt.lvalues[0]\n                if is_root_model and lhs.name != 'root':\n                    error_extra_fields_on_root_model(self._api, stmt)\n                else:\n                    current_field_names.add(lhs.name)\n                    found_fields[lhs.name] = maybe_field\n            elif isinstance(maybe_field, PydanticModelClassVar):\n                lhs = stmt.lvalues[0]\n                current_class_vars_names.add(lhs.name)\n                found_class_vars[lhs.name] = maybe_field\n\n        return list(found_fields.values()), list(found_class_vars.values())\n\n    def _get_assignment_statements_from_if_statement(self, stmt: IfStmt) -> Iterator[AssignmentStmt]:\n        for body in stmt.body:\n            if not body.is_unreachable:\n                yield from self._get_assignment_statements_from_block(body)\n        if stmt.else_body is not None and not stmt.else_body.is_unreachable:\n            yield from self._get_assignment_statements_from_block(stmt.else_body)\n\n    def _get_assignment_statements_from_block(self, block: Block) -> Iterator[AssignmentStmt]:\n        for stmt in block.body:\n            if isinstance(stmt, AssignmentStmt):\n                yield stmt\n            elif isinstance(stmt, IfStmt):\n                yield from self._get_assignment_statements_from_if_statement(stmt)\n\n    def collect_field_or_class_var_from_stmt(  # noqa C901\n        self, stmt: AssignmentStmt, model_config: ModelConfigData, class_vars: dict[str, PydanticModelClassVar]\n    ) -> PydanticModelField | PydanticModelClassVar | None:\n        \"\"\"Get pydantic model field from statement.\n\n        Args:\n            stmt: The statement.\n            model_config: Configuration settings for the model.\n            class_vars: ClassVars already known to be defined on the model.\n\n        Returns:\n            A pydantic model field if it could find the field in statement. Otherwise, `None`.\n        \"\"\"\n        cls = self._cls\n\n        lhs = stmt.lvalues[0]\n        if not isinstance(lhs, NameExpr) or not _fields.is_valid_field_name(lhs.name) or lhs.name == 'model_config':\n            return None\n\n        if not stmt.new_syntax:\n            if (\n                isinstance(stmt.rvalue, CallExpr)\n                and isinstance(stmt.rvalue.callee, CallExpr)\n                and isinstance(stmt.rvalue.callee.callee, NameExpr)\n                and stmt.rvalue.callee.callee.fullname in DECORATOR_FULLNAMES\n            ):\n                # This is a (possibly-reused) validator or serializer, not a field\n                # In particular, it looks something like: my_validator = validator('my_field')(f)\n                # Eventually, we may want to attempt to respect model_config['ignored_types']\n                return None\n\n            if lhs.name in class_vars:\n                # Class vars are not fields and are not required to be annotated\n                return None\n\n            # The assignment does not have an annotation, and it's not anything else we recognize\n            error_untyped_fields(self._api, stmt)\n            return None\n\n        lhs = stmt.lvalues[0]\n        if not isinstance(lhs, NameExpr):\n            return None\n\n        if not _fields.is_valid_field_name(lhs.name) or lhs.name == 'model_config':\n            return None\n\n        sym = cls.info.names.get(lhs.name)\n        if sym is None:  # pragma: no cover\n            # This is likely due to a star import (see the dataclasses plugin for a more detailed explanation)\n            # This is the same logic used in the dataclasses plugin\n            return None\n\n        node = sym.node\n        if isinstance(node, PlaceholderNode):  # pragma: no cover\n            # See the PlaceholderNode docstring for more detail about how this can occur\n            # Basically, it is an edge case when dealing with complex import logic\n\n            # The dataclasses plugin now asserts this cannot happen, but I'd rather not error if it does..\n            return None\n\n        if isinstance(node, TypeAlias):\n            self._api.fail(\n                'Type aliases inside BaseModel definitions are not supported at runtime',\n                node,\n            )\n            # Skip processing this node. This doesn't match the runtime behaviour,\n            # but the only alternative would be to modify the SymbolTable,\n            # and it's a little hairy to do that in a plugin.\n            return None\n\n        if not isinstance(node, Var):  # pragma: no cover\n            # Don't know if this edge case still happens with the `is_valid_field` check above\n            # but better safe than sorry\n\n            # The dataclasses plugin now asserts this cannot happen, but I'd rather not error if it does..\n            return None\n\n        # x: ClassVar[int] is not a field\n        if node.is_classvar:\n            return PydanticModelClassVar(lhs.name)\n\n        # x: InitVar[int] is not supported in BaseModel\n        node_type = get_proper_type(node.type)\n        if isinstance(node_type, Instance) and node_type.type.fullname == 'dataclasses.InitVar':\n            self._api.fail(\n                'InitVar is not supported in BaseModel',\n                node,\n            )\n\n        has_default = self.get_has_default(stmt)\n\n        if sym.type is None and node.is_final and node.is_inferred:\n            # This follows the logic from the dataclasses plugin. The following comment is taken verbatim:\n            #\n            # This is a special case, assignment like x: Final = 42 is classified\n            # annotated above, but mypy strips the `Final` turning it into x = 42.\n            # We do not support inferred types in dataclasses, so we can try inferring\n            # type for simple literals, and otherwise require an explicit type\n            # argument for Final[...].\n            typ = self._api.analyze_simple_literal_type(stmt.rvalue, is_final=True)\n            if typ:\n                node.type = typ\n            else:\n                self._api.fail(\n                    'Need type argument for Final[...] with non-literal default in BaseModel',\n                    stmt,\n                )\n                node.type = AnyType(TypeOfAny.from_error)\n\n        alias, has_dynamic_alias = self.get_alias_info(stmt)\n        if has_dynamic_alias and not model_config.populate_by_name and self.plugin_config.warn_required_dynamic_aliases:\n            error_required_dynamic_aliases(self._api, stmt)\n\n        init_type = self._infer_dataclass_attr_init_type(sym, lhs.name, stmt)\n        return PydanticModelField(\n            name=lhs.name,\n            has_dynamic_alias=has_dynamic_alias,\n            has_default=has_default,\n            alias=alias,\n            line=stmt.line,\n            column=stmt.column,\n            type=init_type,\n            info=cls.info,\n        )\n\n    def _infer_dataclass_attr_init_type(self, sym: SymbolTableNode, name: str, context: Context) -> Type | None:\n        \"\"\"Infer __init__ argument type for an attribute.\n\n        In particular, possibly use the signature of __set__.\n        \"\"\"\n        default = sym.type\n        if sym.implicit:\n            return default\n        t = get_proper_type(sym.type)\n\n        # Perform a simple-minded inference from the signature of __set__, if present.\n        # We can't use mypy.checkmember here, since this plugin runs before type checking.\n        # We only support some basic scanerios here, which is hopefully sufficient for\n        # the vast majority of use cases.\n        if not isinstance(t, Instance):\n            return default\n        setter = t.type.get('__set__')\n        if setter:\n            if isinstance(setter.node, FuncDef):\n                super_info = t.type.get_containing_type_info('__set__')\n                assert super_info\n                if setter.type:\n                    setter_type = get_proper_type(map_type_from_supertype(setter.type, t.type, super_info))\n                else:\n                    return AnyType(TypeOfAny.unannotated)\n                if isinstance(setter_type, CallableType) and setter_type.arg_kinds == [\n                    ARG_POS,\n                    ARG_POS,\n                    ARG_POS,\n                ]:\n                    return expand_type_by_instance(setter_type.arg_types[2], t)\n                else:\n                    self._api.fail(f'Unsupported signature for \"__set__\" in \"{t.type.name}\"', context)\n            else:\n                self._api.fail(f'Unsupported \"__set__\" in \"{t.type.name}\"', context)\n\n        return default\n\n    def add_initializer(\n        self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool, is_root_model: bool\n    ) -> None:\n        \"\"\"Adds a fields-aware `__init__` method to the class.\n\n        The added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.\n        \"\"\"\n        if '__init__' in self._cls.info.names and not self._cls.info.names['__init__'].plugin_generated:\n            return  # Don't generate an __init__ if one already exists\n\n        typed = self.plugin_config.init_typed\n        use_alias = config.populate_by_name is not True\n        requires_dynamic_aliases = bool(config.has_alias_generator and not config.populate_by_name)\n        args = self.get_field_arguments(\n            fields,\n            typed=typed,\n            requires_dynamic_aliases=requires_dynamic_aliases,\n            use_alias=use_alias,\n            is_settings=is_settings,\n            force_typevars_invariant=True,\n        )\n\n        if is_root_model and MYPY_VERSION_TUPLE <= (1, 0, 1):\n            # convert root argument to positional argument\n            # This is needed because mypy support for `dataclass_transform` isn't complete on 1.0.1\n            args[0].kind = ARG_POS if args[0].kind == ARG_NAMED else ARG_OPT\n\n        if is_settings:\n            base_settings_node = self._api.lookup_fully_qualified(BASESETTINGS_FULLNAME).node\n            if '__init__' in base_settings_node.names:\n                base_settings_init_node = base_settings_node.names['__init__'].node\n                if base_settings_init_node is not None and base_settings_init_node.type is not None:\n                    func_type = base_settings_init_node.type\n                    for arg_idx, arg_name in enumerate(func_type.arg_names):\n                        if arg_name.startswith('__') or not arg_name.startswith('_'):\n                            continue\n                        analyzed_variable_type = self._api.anal_type(func_type.arg_types[arg_idx])\n                        variable = Var(arg_name, analyzed_variable_type)\n                        args.append(Argument(variable, analyzed_variable_type, None, ARG_OPT))\n\n        if not self.should_init_forbid_extra(fields, config):\n            var = Var('kwargs')\n            args.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))\n\n        add_method(self._api, self._cls, '__init__', args=args, return_type=NoneType())\n\n    def add_model_construct_method(\n        self, fields: list[PydanticModelField], config: ModelConfigData, is_settings: bool\n    ) -> None:\n        \"\"\"Adds a fully typed `model_construct` classmethod to the class.\n\n        Similar to the fields-aware __init__ method, but always uses the field names (not aliases),\n        and does not treat settings fields as optional.\n        \"\"\"\n        set_str = self._api.named_type(f'{BUILTINS_NAME}.set', [self._api.named_type(f'{BUILTINS_NAME}.str')])\n        optional_set_str = UnionType([set_str, NoneType()])\n        fields_set_argument = Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)\n        with state.strict_optional_set(self._api.options.strict_optional):\n            args = self.get_field_arguments(\n                fields, typed=True, requires_dynamic_aliases=False, use_alias=False, is_settings=is_settings\n            )\n        if not self.should_init_forbid_extra(fields, config):\n            var = Var('kwargs')\n            args.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))\n\n        args = [fields_set_argument] + args\n\n        add_method(\n            self._api,\n            self._cls,\n            'model_construct',\n            args=args,\n            return_type=fill_typevars(self._cls.info),\n            is_classmethod=True,\n        )\n\n    def set_frozen(self, fields: list[PydanticModelField], api: SemanticAnalyzerPluginInterface, frozen: bool) -> None:\n        \"\"\"Marks all fields as properties so that attempts to set them trigger mypy errors.\n\n        This is the same approach used by the attrs and dataclasses plugins.\n        \"\"\"\n        info = self._cls.info\n        for field in fields:\n            sym_node = info.names.get(field.name)\n            if sym_node is not None:\n                var = sym_node.node\n                if isinstance(var, Var):\n                    var.is_property = frozen\n                elif isinstance(var, PlaceholderNode) and not self._api.final_iteration:\n                    # See https://github.com/pydantic/pydantic/issues/5191 to hit this branch for test coverage\n                    self._api.defer()\n                else:  # pragma: no cover\n                    # I don't know whether it's possible to hit this branch, but I've added it for safety\n                    try:\n                        var_str = str(var)\n                    except TypeError:\n                        # This happens for PlaceholderNode; perhaps it will happen for other types in the future..\n                        var_str = repr(var)\n                    detail = f'sym_node.node: {var_str} (of type {var.__class__})'\n                    error_unexpected_behavior(detail, self._api, self._cls)\n            else:\n                var = field.to_var(info, api, use_alias=False)\n                var.info = info\n                var.is_property = frozen\n                var._fullname = info.fullname + '.' + var.name\n                info.names[var.name] = SymbolTableNode(MDEF, var)\n\n    def get_config_update(self, name: str, arg: Expression, lax_extra: bool = False) -> ModelConfigData | None:\n        \"\"\"Determines the config update due to a single kwarg in the ConfigDict definition.\n\n        Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        if name not in self.tracked_config_fields:\n            return None\n        if name == 'extra':\n            if isinstance(arg, StrExpr):\n                forbid_extra = arg.value == 'forbid'\n            elif isinstance(arg, MemberExpr):\n                forbid_extra = arg.name == 'forbid'\n            else:\n                if not lax_extra:\n                    # Only emit an error for other types of `arg` (e.g., `NameExpr`, `ConditionalExpr`, etc.) when\n                    # reading from a config class, etc. If a ConfigDict is used, then we don't want to emit an error\n                    # because you'll get type checking from the ConfigDict itself.\n                    #\n                    # It would be nice if we could introspect the types better otherwise, but I don't know what the API\n                    # is to evaluate an expr into its type and then check if that type is compatible with the expected\n                    # type. Note that you can still get proper type checking via: `model_config = ConfigDict(...)`, just\n                    # if you don't use an explicit string, the plugin won't be able to infer whether extra is forbidden.\n                    error_invalid_config_value(name, self._api, arg)\n                return None\n            return ModelConfigData(forbid_extra=forbid_extra)\n        if name == 'alias_generator':\n            has_alias_generator = True\n            if isinstance(arg, NameExpr) and arg.fullname == 'builtins.None':\n                has_alias_generator = False\n            return ModelConfigData(has_alias_generator=has_alias_generator)\n        if isinstance(arg, NameExpr) and arg.fullname in ('builtins.True', 'builtins.False'):\n            return ModelConfigData(**{name: arg.fullname == 'builtins.True'})\n        error_invalid_config_value(name, self._api, arg)\n        return None\n\n    @staticmethod\n    def get_has_default(stmt: AssignmentStmt) -> bool:\n        \"\"\"Returns a boolean indicating whether the field defined in `stmt` is a required field.\"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only, so has no default\n            return False\n        if isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME:\n            # The \"default value\" is a call to `Field`; at this point, the field has a default if and only if:\n            # * there is a positional argument that is not `...`\n            # * there is a keyword argument named \"default\" that is not `...`\n            # * there is a \"default_factory\" that is not `None`\n            for arg, name in zip(expr.args, expr.arg_names):\n                # If name is None, then this arg is the default because it is the only positional argument.\n                if name is None or name == 'default':\n                    return arg.__class__ is not EllipsisExpr\n                if name == 'default_factory':\n                    return not (isinstance(arg, NameExpr) and arg.fullname == 'builtins.None')\n            return False\n        # Has no default if the \"default value\" is Ellipsis (i.e., `field_name: Annotation = ...`)\n        return not isinstance(expr, EllipsisExpr)\n\n    @staticmethod\n    def get_alias_info(stmt: AssignmentStmt) -> tuple[str | None, bool]:\n        \"\"\"Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.\n\n        `has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.\n        If `has_dynamic_alias` is True, `alias` will be None.\n        \"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only\n            return None, False\n\n        if not (\n            isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME\n        ):\n            # Assigned value is not a call to pydantic.fields.Field\n            return None, False\n\n        for i, arg_name in enumerate(expr.arg_names):\n            if arg_name != 'alias':\n                continue\n            arg = expr.args[i]\n            if isinstance(arg, StrExpr):\n                return arg.value, False\n            else:\n                return None, True\n        return None, False\n\n    def get_field_arguments(\n        self,\n        fields: list[PydanticModelField],\n        typed: bool,\n        use_alias: bool,\n        requires_dynamic_aliases: bool,\n        is_settings: bool,\n        force_typevars_invariant: bool = False,\n    ) -> list[Argument]:\n        \"\"\"Helper function used during the construction of the `__init__` and `model_construct` method signatures.\n\n        Returns a list of mypy Argument instances for use in the generated signatures.\n        \"\"\"\n        info = self._cls.info\n        arguments = [\n            field.to_argument(\n                info,\n                typed=typed,\n                force_optional=requires_dynamic_aliases or is_settings,\n                use_alias=use_alias,\n                api=self._api,\n                force_typevars_invariant=force_typevars_invariant,\n            )\n            for field in fields\n            if not (use_alias and field.has_dynamic_alias)\n        ]\n        return arguments\n\n    def should_init_forbid_extra(self, fields: list[PydanticModelField], config: ModelConfigData) -> bool:\n        \"\"\"Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature.\n\n        We disallow arbitrary kwargs if the extra config setting is \"forbid\", or if the plugin config says to,\n        *unless* a required dynamic alias is present (since then we can't determine a valid signature).\n        \"\"\"\n        if not config.populate_by_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n            return True\n        return self.plugin_config.init_forbid_extra\n\n    @staticmethod\n    def is_dynamic_alias_present(fields: list[PydanticModelField], has_alias_generator: bool) -> bool:\n        \"\"\"Returns whether any fields on the model have a \"dynamic alias\", i.e., an alias that cannot be\n        determined during static analysis.\n        \"\"\"\n        for field in fields:\n            if field.has_dynamic_alias:\n                return True\n        if has_alias_generator:\n            for field in fields:\n                if field.alias is None:\n                    return True\n        return False\n\n\nclass ModelConfigData:\n    \"\"\"Pydantic mypy plugin model config class.\"\"\"\n\n    def __init__(\n        self,\n        forbid_extra: bool | None = None,\n        frozen: bool | None = None,\n        from_attributes: bool | None = None,\n        populate_by_name: bool | None = None,\n        has_alias_generator: bool | None = None,\n    ):\n        self.forbid_extra = forbid_extra\n        self.frozen = frozen\n        self.from_attributes = from_attributes\n        self.populate_by_name = populate_by_name\n        self.has_alias_generator = has_alias_generator\n\n    def get_values_dict(self) -> dict[str, Any]:\n        \"\"\"Returns a dict of Pydantic model config names to their values.\n\n        It includes the config if config value is not `None`.\n        \"\"\"\n        return {k: v for k, v in self.__dict__.items() if v is not None}\n\n    def update(self, config: ModelConfigData | None) -> None:\n        \"\"\"Update Pydantic model config values.\"\"\"\n        if config is None:\n            return\n        for k, v in config.get_values_dict().items():\n            setattr(self, k, v)\n\n    def setdefault(self, key: str, value: Any) -> None:\n        \"\"\"Set default value for Pydantic model config if config value is `None`.\"\"\"\n        if getattr(self, key) is None:\n            setattr(self, key, value)\n\n\nERROR_ORM = ErrorCode('pydantic-orm', 'Invalid from_attributes call', 'Pydantic')\nERROR_CONFIG = ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')\nERROR_ALIAS = ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')\nERROR_UNEXPECTED = ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')\nERROR_UNTYPED = ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')\nERROR_FIELD_DEFAULTS = ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')\nERROR_EXTRA_FIELD_ROOT_MODEL = ErrorCode('pydantic-field', 'Extra field on RootModel subclass', 'Pydantic')\n\n\ndef error_from_attributes(model_name: str, api: CheckerPluginInterface, context: Context) -> None:\n    \"\"\"Emits an error when the model does not have `from_attributes=True`.\"\"\"\n    api.fail(f'\"{model_name}\" does not have from_attributes=True', context, code=ERROR_ORM)\n\n\ndef error_invalid_config_value(name: str, api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    \"\"\"Emits an error when the config value is invalid.\"\"\"\n    api.fail(f'Invalid value for \"Config.{name}\"', context, code=ERROR_CONFIG)\n\n\ndef error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    \"\"\"Emits required dynamic aliases error.\n\n    This will be called when `warn_required_dynamic_aliases=True`.\n    \"\"\"\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: CheckerPluginInterface | SemanticAnalyzerPluginInterface, context: Context\n) -> None:  # pragma: no cover\n    \"\"\"Emits unexpected behavior error.\"\"\"\n    # Can't think of a good way to test this, but I confirmed it renders as desired by adding to a non-error path\n    link = 'https://github.com/pydantic/pydantic/issues/new/choose'\n    full_message = f'The pydantic mypy plugin ran into unexpected behavior: {detail}\\n'\n    full_message += f'Please consider reporting this bug at {link} so we can try to fix it!'\n    api.fail(full_message, context, code=ERROR_UNEXPECTED)\n\n\ndef error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    \"\"\"Emits an error when there is an untyped field in the model.\"\"\"\n    api.fail('Untyped fields disallowed', context, code=ERROR_UNTYPED)\n\n\ndef error_extra_fields_on_root_model(api: CheckerPluginInterface, context: Context) -> None:\n    \"\"\"Emits an error when there is more than just a root field defined for a subclass of RootModel.\"\"\"\n    api.fail('Only `root` is allowed as a field of a `RootModel`', context, code=ERROR_EXTRA_FIELD_ROOT_MODEL)\n\n\ndef error_default_and_default_factory_specified(api: CheckerPluginInterface, context: Context) -> None:\n    \"\"\"Emits an error when `Field` has both `default` and `default_factory` together.\"\"\"\n    api.fail('Field default and default_factory cannot be specified together', context, code=ERROR_FIELD_DEFAULTS)\n\n\ndef add_method(\n    api: SemanticAnalyzerPluginInterface | CheckerPluginInterface,\n    cls: ClassDef,\n    name: str,\n    args: list[Argument],\n    return_type: Type,\n    self_type: Type | None = None,\n    tvar_def: TypeVarDef | None = None,\n    is_classmethod: bool = False,\n) -> None:\n    \"\"\"Very closely related to `mypy.plugins.common.add_method_to_class`, with a few pydantic-specific changes.\"\"\"\n    info = cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid clashes and problems in the semantic analyzer.\n    if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    if isinstance(api, SemanticAnalyzerPluginInterface):\n        function_type = api.named_type('builtins.function')\n    else:\n        function_type = api.named_generic_type('builtins.function', [])\n\n    if is_classmethod:\n        self_type = self_type or TypeType(fill_typevars(info))\n        first = [Argument(Var('_cls'), self_type, None, ARG_POS, True)]\n    else:\n        self_type = self_type or fill_typevars(info)\n        # `self` is positional *ONLY* here, but this can't be expressed\n        # fully in the mypy internal API. ARG_POS is the closest we can get.\n        # Using ARG_POS will, however, give mypy errors if a `self` field\n        # is present on a model:\n        #\n        #     Name \"self\" already defined (possibly by an import)  [no-redef]\n        #\n        # As a workaround, we give this argument a name that will\n        # never conflict. By its positional nature, this name will not\n        # be used or exposed to users.\n        first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(arg.variable.name)\n        arg_kinds.append(arg.kind)\n\n    signature = CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)\n    if tvar_def:\n        signature.variables = [tvar_def]\n\n    func = FuncDef(name, args, Block([PassStmt()]))\n    func.info = info\n    func.type = set_callable_name(signature, func)\n    func.is_class = is_classmethod\n    func._fullname = info.fullname + '.' + name\n    func.line = info.line\n\n    # NOTE: we would like the plugin generated node to dominate, but we still\n    # need to keep any existing definitions so they get semantically analyzed.\n    if name in info.names:\n        # Get a nice unique name instead.\n        r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    # Add decorator for is_classmethod\n    # The dataclasses plugin claims this is unnecessary for classmethods, but not including it results in a\n    # signature incompatible with the superclass, which causes mypy errors to occur for every subclass of BaseModel.\n    if is_classmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        v.is_classmethod = True\n        dec = Decorator(func, [NameExpr('classmethod')], v)\n        dec.line = info.line\n        sym = SymbolTableNode(MDEF, dec)\n    else:\n        sym = SymbolTableNode(MDEF, func)\n    sym.plugin_generated = True\n    info.names[name] = sym\n\n    info.defn.defs.body.append(func)\n\n\ndef parse_toml(config_file: str) -> dict[str, Any] | None:\n    \"\"\"Returns a dict of config keys to values.\n\n    It reads configs from toml file and returns `None` if the file is not a toml file.\n    \"\"\"\n    if not config_file.endswith('.toml'):\n        return None\n\n    if sys.version_info >= (3, 11):\n        import tomllib as toml_\n    else:\n        try:\n            import tomli as toml_\n        except ImportError:  # pragma: no cover\n            import warnings\n\n            warnings.warn('No TOML parser installed, cannot read configuration from `pyproject.toml`.')\n            return None\n\n    with open(config_file, 'rb') as rf:\n        return toml_.load(rf)\n", "pydantic/networks.py": "\"\"\"The networks module contains types for common network-related fields.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses as _dataclasses\nimport re\nfrom importlib.metadata import version\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom typing import TYPE_CHECKING, Any\n\nfrom pydantic_core import MultiHostUrl, PydanticCustomError, Url, core_schema\nfrom typing_extensions import Annotated, Self, TypeAlias\n\nfrom ._internal import _fields, _repr, _schema_generation_shared\nfrom ._migration import getattr_migration\nfrom .annotated_handlers import GetCoreSchemaHandler\nfrom .json_schema import JsonSchemaValue\n\nif TYPE_CHECKING:\n    import email_validator\n\n    NetworkType: TypeAlias = 'str | bytes | int | tuple[str | bytes | int, str | int]'\n\nelse:\n    email_validator = None\n\n\n__all__ = [\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'FtpUrl',\n    'HttpUrl',\n    'WebsocketUrl',\n    'AnyWebsocketUrl',\n    'UrlConstraints',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'NatsDsn',\n    'validate_email',\n    'MySQLDsn',\n    'MariaDBDsn',\n    'ClickHouseDsn',\n]\n\n\n@_dataclasses.dataclass\nclass UrlConstraints(_fields.PydanticMetadata):\n    \"\"\"Url constraints.\n\n    Attributes:\n        max_length: The maximum length of the url. Defaults to `None`.\n        allowed_schemes: The allowed schemes. Defaults to `None`.\n        host_required: Whether the host is required. Defaults to `None`.\n        default_host: The default host. Defaults to `None`.\n        default_port: The default port. Defaults to `None`.\n        default_path: The default path. Defaults to `None`.\n    \"\"\"\n\n    max_length: int | None = None\n    allowed_schemes: list[str] | None = None\n    host_required: bool | None = None\n    default_host: str | None = None\n    default_port: int | None = None\n    default_path: str | None = None\n\n    def __hash__(self) -> int:\n        return hash(\n            (\n                self.max_length,\n                tuple(self.allowed_schemes) if self.allowed_schemes is not None else None,\n                self.host_required,\n                self.default_host,\n                self.default_port,\n                self.default_path,\n            )\n        )\n\n\nAnyUrl = Url\n\"\"\"Base type for all URLs.\n\n* Any scheme allowed\n* Top-level domain (TLD) not required\n* Host required\n\nAssuming an input URL of `http://samuel:pass@example.com:8000/the/path/?query=here#fragment=is;this=bit`,\nthe types export the following properties:\n\n- `scheme`: the URL scheme (`http`), always set.\n- `host`: the URL host (`example.com`), always set.\n- `username`: optional username if included (`samuel`).\n- `password`: optional password if included (`pass`).\n- `port`: optional port (`8000`).\n- `path`: optional path (`/the/path/`).\n- `query`: optional URL query (for example, `GET` arguments or \"search string\", such as `query=here`).\n- `fragment`: optional fragment (`fragment=is;this=bit`).\n\"\"\"\nAnyHttpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['http', 'https'])]\n\"\"\"A type that will accept any http or https URL.\n\n* TLD not required\n* Host required\n\"\"\"\nHttpUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['http', 'https'])]\n\"\"\"A type that will accept any http or https URL.\n\n* TLD not required\n* Host required\n* Max length 2083\n\n```py\nfrom pydantic import BaseModel, HttpUrl, ValidationError\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')  # (1)!\nprint(m.url)\n#> http://www.example.com/\n\ntry:\n    MyModel(url='ftp://invalid.url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      URL scheme should be 'http' or 'https' [type=url_scheme, input_value='ftp://invalid.url', input_type=str]\n    '''\n\ntry:\n    MyModel(url='not a url')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyModel\n    url\n      Input should be a valid URL, relative URL without a base [type=url_parsing, input_value='not a url', input_type=str]\n    '''\n```\n\n1. Note: mypy would prefer `m = MyModel(url=HttpUrl('http://www.example.com'))`, but Pydantic will convert the string to an HttpUrl instance anyway.\n\n\"International domains\" (e.g. a URL where the host or TLD includes non-ascii characters) will be encoded via\n[punycode](https://en.wikipedia.org/wiki/Punycode) (see\n[this article](https://www.xudongz.com/blog/2017/idn-phishing/) for a good description of why this is important):\n\n```py\nfrom pydantic import BaseModel, HttpUrl\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm1 = MyModel(url='http://puny\u00a3code.com')\nprint(m1.url)\n#> http://xn--punycode-eja.com/\nm2 = MyModel(url='https://www.\u0430\u0440\u0440\u04cf\u0435.com/')\nprint(m2.url)\n#> https://www.xn--80ak6aa92e.com/\nm3 = MyModel(url='https://www.example.\u73e0\u5b9d/')\nprint(m3.url)\n#> https://www.example.xn--pbt977c/\n```\n\n\n!!! warning \"Underscores in Hostnames\"\n    In Pydantic, underscores are allowed in all parts of a domain except the TLD.\n    Technically this might be wrong - in theory the hostname cannot have underscores, but subdomains can.\n\n    To explain this; consider the following two cases:\n\n    - `exam_ple.co.uk`: the hostname is `exam_ple`, which should not be allowed since it contains an underscore.\n    - `foo_bar.example.com` the hostname is `example`, which should be allowed since the underscore is in the subdomain.\n\n    Without having an exhaustive list of TLDs, it would be impossible to differentiate between these two. Therefore\n    underscores are allowed, but you can always do further validation in a validator if desired.\n\n    Also, Chrome, Firefox, and Safari all currently accept `http://exam_ple.com` as a URL, so we're in good\n    (or at least big) company.\n\"\"\"\nAnyWebsocketUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ws', 'wss'])]\n\"\"\"A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host required\n\"\"\"\nWebsocketUrl = Annotated[Url, UrlConstraints(max_length=2083, allowed_schemes=['ws', 'wss'])]\n\"\"\"A type that will accept any ws or wss URL.\n\n* TLD not required\n* Host required\n* Max length 2083\n\"\"\"\nFileUrl = Annotated[Url, UrlConstraints(allowed_schemes=['file'])]\n\"\"\"A type that will accept any file URL.\n\n* Host not required\n\"\"\"\nFtpUrl = Annotated[Url, UrlConstraints(allowed_schemes=['ftp'])]\n\"\"\"A type that will accept ftp URL.\n\n* TLD not required\n* Host required\n\"\"\"\nPostgresDsn = Annotated[\n    MultiHostUrl,\n    UrlConstraints(\n        host_required=True,\n        allowed_schemes=[\n            'postgres',\n            'postgresql',\n            'postgresql+asyncpg',\n            'postgresql+pg8000',\n            'postgresql+psycopg',\n            'postgresql+psycopg2',\n            'postgresql+psycopg2cffi',\n            'postgresql+py-postgresql',\n            'postgresql+pygresql',\n        ],\n    ),\n]\n\"\"\"A type that will accept any Postgres DSN.\n\n* User info required\n* TLD not required\n* Host required\n* Supports multiple hosts\n\nIf further validation is required, these properties can be used by validators to enforce specific behaviour:\n\n```py\nfrom pydantic import (\n    BaseModel,\n    HttpUrl,\n    PostgresDsn,\n    ValidationError,\n    field_validator,\n)\n\nclass MyModel(BaseModel):\n    url: HttpUrl\n\nm = MyModel(url='http://www.example.com')\n\n# the repr() method for a url will display all properties of the url\nprint(repr(m.url))\n#> Url('http://www.example.com/')\nprint(m.url.scheme)\n#> http\nprint(m.url.host)\n#> www.example.com\nprint(m.url.port)\n#> 80\n\nclass MyDatabaseModel(BaseModel):\n    db: PostgresDsn\n\n    @field_validator('db')\n    def check_db_name(cls, v):\n        assert v.path and len(v.path) > 1, 'database must be provided'\n        return v\n\nm = MyDatabaseModel(db='postgres://user:pass@localhost:5432/foobar')\nprint(m.db)\n#> postgres://user:pass@localhost:5432/foobar\n\ntry:\n    MyDatabaseModel(db='postgres://user:pass@localhost:5432')\nexcept ValidationError as e:\n    print(e)\n    '''\n    1 validation error for MyDatabaseModel\n    db\n      Assertion failed, database must be provided\n    assert (None)\n     +  where None = MultiHostUrl('postgres://user:pass@localhost:5432').path [type=assertion_error, input_value='postgres://user:pass@localhost:5432', input_type=str]\n    '''\n```\n\"\"\"\n\nCockroachDsn = Annotated[\n    Url,\n    UrlConstraints(\n        host_required=True,\n        allowed_schemes=[\n            'cockroachdb',\n            'cockroachdb+psycopg2',\n            'cockroachdb+asyncpg',\n        ],\n    ),\n]\n\"\"\"A type that will accept any Cockroach DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\nAmqpDsn = Annotated[Url, UrlConstraints(allowed_schemes=['amqp', 'amqps'])]\n\"\"\"A type that will accept any AMQP DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\nRedisDsn = Annotated[\n    Url,\n    UrlConstraints(allowed_schemes=['redis', 'rediss'], default_host='localhost', default_port=6379, default_path='/0'),\n]\n\"\"\"A type that will accept any Redis DSN.\n\n* User info required\n* TLD not required\n* Host required (e.g., `rediss://:pass@localhost`)\n\"\"\"\nMongoDsn = Annotated[MultiHostUrl, UrlConstraints(allowed_schemes=['mongodb', 'mongodb+srv'], default_port=27017)]\n\"\"\"A type that will accept any MongoDB DSN.\n\n* User info not required\n* Database name not required\n* Port not required\n* User info may be passed without user part (e.g., `mongodb://mongodb0.example.com:27017`).\n\"\"\"\nKafkaDsn = Annotated[Url, UrlConstraints(allowed_schemes=['kafka'], default_host='localhost', default_port=9092)]\n\"\"\"A type that will accept any Kafka DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\nNatsDsn = Annotated[\n    MultiHostUrl, UrlConstraints(allowed_schemes=['nats', 'tls', 'ws'], default_host='localhost', default_port=4222)\n]\n\"\"\"A type that will accept any NATS DSN.\n\nNATS is a connective technology built for the ever increasingly hyper-connected world.\nIt is a single technology that enables applications to securely communicate across\nany combination of cloud vendors, on-premise, edge, web and mobile, and devices.\nMore: https://nats.io\n\"\"\"\nMySQLDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=[\n            'mysql',\n            'mysql+mysqlconnector',\n            'mysql+aiomysql',\n            'mysql+asyncmy',\n            'mysql+mysqldb',\n            'mysql+pymysql',\n            'mysql+cymysql',\n            'mysql+pyodbc',\n        ],\n        default_port=3306,\n    ),\n]\n\"\"\"A type that will accept any MySQL DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\nMariaDBDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['mariadb', 'mariadb+mariadbconnector', 'mariadb+pymysql'],\n        default_port=3306,\n    ),\n]\n\"\"\"A type that will accept any MariaDB DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\nClickHouseDsn = Annotated[\n    Url,\n    UrlConstraints(\n        allowed_schemes=['clickhouse+native', 'clickhouse+asynch'],\n        default_host='localhost',\n        default_port=9000,\n    ),\n]\n\"\"\"A type that will accept any ClickHouse DSN.\n\n* User info required\n* TLD not required\n* Host required\n\"\"\"\n\n\ndef import_email_validator() -> None:\n    global email_validator\n    try:\n        import email_validator\n    except ImportError as e:\n        raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n    if not version('email-validator').partition('.')[0] == '2':\n        raise ImportError('email-validator version >= 2.0 required, run pip install -U email-validator')\n\n\nif TYPE_CHECKING:\n    EmailStr = Annotated[str, ...]\nelse:\n\n    class EmailStr:\n        \"\"\"\n        Info:\n            To use this type, you need to install the optional\n            [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n            ```bash\n            pip install email-validator\n            ```\n\n        Validate email addresses.\n\n        ```py\n        from pydantic import BaseModel, EmailStr\n\n        class Model(BaseModel):\n            email: EmailStr\n\n        print(Model(email='contact@mail.com'))\n        #> email='contact@mail.com'\n        ```\n        \"\"\"  # noqa: D212\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls,\n            _source: type[Any],\n            _handler: GetCoreSchemaHandler,\n        ) -> core_schema.CoreSchema:\n            import_email_validator()\n            return core_schema.no_info_after_validator_function(cls._validate, core_schema.str_schema())\n\n        @classmethod\n        def __get_pydantic_json_schema__(\n            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler\n        ) -> JsonSchemaValue:\n            field_schema = handler(core_schema)\n            field_schema.update(type='string', format='email')\n            return field_schema\n\n        @classmethod\n        def _validate(cls, input_value: str, /) -> str:\n            return validate_email(input_value)[1]\n\n\nclass NameEmail(_repr.Representation):\n    \"\"\"\n    Info:\n        To use this type, you need to install the optional\n        [`email-validator`](https://github.com/JoshData/python-email-validator) package:\n\n        ```bash\n        pip install email-validator\n        ```\n\n    Validate a name and email address combination, as specified by\n    [RFC 5322](https://datatracker.ietf.org/doc/html/rfc5322#section-3.4).\n\n    The `NameEmail` has two properties: `name` and `email`.\n    In case the `name` is not provided, it's inferred from the email address.\n\n    ```py\n    from pydantic import BaseModel, NameEmail\n\n    class User(BaseModel):\n        email: NameEmail\n\n    user = User(email='Fred Bloggs <fred.bloggs@example.com>')\n    print(user.email)\n    #> Fred Bloggs <fred.bloggs@example.com>\n    print(user.email.name)\n    #> Fred Bloggs\n\n    user = User(email='fred.bloggs@example.com')\n    print(user.email)\n    #> fred.bloggs <fred.bloggs@example.com>\n    print(user.email.name)\n    #> fred.bloggs\n    ```\n    \"\"\"  # noqa: D212\n\n    __slots__ = 'name', 'email'\n\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = handler(core_schema)\n        field_schema.update(type='string', format='name-email')\n        return field_schema\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source: type[Any],\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        import_email_validator()\n\n        return core_schema.no_info_after_validator_function(\n            cls._validate,\n            core_schema.json_or_python_schema(\n                json_schema=core_schema.str_schema(),\n                python_schema=core_schema.union_schema(\n                    [core_schema.is_instance_schema(cls), core_schema.str_schema()],\n                    custom_error_type='name_email_type',\n                    custom_error_message='Input is not a valid NameEmail',\n                ),\n                serialization=core_schema.to_string_ser_schema(),\n            ),\n        )\n\n    @classmethod\n    def _validate(cls, input_value: Self | str, /) -> Self:\n        if isinstance(input_value, str):\n            name, email = validate_email(input_value)\n            return cls(name, email)\n        else:\n            return input_value\n\n    def __str__(self) -> str:\n        if '@' in self.name:\n            return f'\"{self.name}\" <{self.email}>'\n\n        return f'{self.name} <{self.email}>'\n\n\nclass IPvAnyAddress:\n    \"\"\"Validate an IPv4 or IPv6 address.\n\n    ```py\n    from pydantic import BaseModel\n    from pydantic.networks import IPvAnyAddress\n\n    class IpModel(BaseModel):\n        ip: IPvAnyAddress\n\n    print(IpModel(ip='127.0.0.1'))\n    #> ip=IPv4Address('127.0.0.1')\n\n    try:\n        IpModel(ip='http://www.example.com')\n    except ValueError as e:\n        print(e.errors())\n        '''\n        [\n            {\n                'type': 'ip_any_address',\n                'loc': ('ip',),\n                'msg': 'value is not a valid IPv4 or IPv6 address',\n                'input': 'http://www.example.com',\n            }\n        ]\n        '''\n    ```\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(cls, value: Any) -> IPv4Address | IPv6Address:\n        \"\"\"Validate an IPv4 or IPv6 address.\"\"\"\n        try:\n            return IPv4Address(value)\n        except ValueError:\n            pass\n\n        try:\n            return IPv6Address(value)\n        except ValueError:\n            raise PydanticCustomError('ip_any_address', 'value is not a valid IPv4 or IPv6 address')\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = {}\n        field_schema.update(type='string', format='ipvanyaddress')\n        return field_schema\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source: type[Any],\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        return core_schema.no_info_plain_validator_function(\n            cls._validate, serialization=core_schema.to_string_ser_schema()\n        )\n\n    @classmethod\n    def _validate(cls, input_value: Any, /) -> IPv4Address | IPv6Address:\n        return cls(input_value)  # type: ignore[return-value]\n\n\nclass IPvAnyInterface:\n    \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"\n\n    __slots__ = ()\n\n    def __new__(cls, value: NetworkType) -> IPv4Interface | IPv6Interface:\n        \"\"\"Validate an IPv4 or IPv6 interface.\"\"\"\n        try:\n            return IPv4Interface(value)\n        except ValueError:\n            pass\n\n        try:\n            return IPv6Interface(value)\n        except ValueError:\n            raise PydanticCustomError('ip_any_interface', 'value is not a valid IPv4 or IPv6 interface')\n\n    @classmethod\n    def __get_pydantic_json_schema__(\n        cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        field_schema = {}\n        field_schema.update(type='string', format='ipvanyinterface')\n        return field_schema\n\n    @classmethod\n    def __get_pydantic_core_schema__(\n        cls,\n        _source: type[Any],\n        _handler: GetCoreSchemaHandler,\n    ) -> core_schema.CoreSchema:\n        return core_schema.no_info_plain_validator_function(\n            cls._validate, serialization=core_schema.to_string_ser_schema()\n        )\n\n    @classmethod\n    def _validate(cls, input_value: NetworkType, /) -> IPv4Interface | IPv6Interface:\n        return cls(input_value)  # type: ignore[return-value]\n\n\nIPvAnyNetworkType: TypeAlias = 'IPv4Network | IPv6Network'\n\nif TYPE_CHECKING:\n    IPvAnyNetwork = IPvAnyNetworkType\nelse:\n\n    class IPvAnyNetwork:\n        \"\"\"Validate an IPv4 or IPv6 network.\"\"\"\n\n        __slots__ = ()\n\n        def __new__(cls, value: NetworkType) -> IPvAnyNetworkType:\n            \"\"\"Validate an IPv4 or IPv6 network.\"\"\"\n            # Assume IP Network is defined with a default value for `strict` argument.\n            # Define your own class if you want to specify network address check strictness.\n            try:\n                return IPv4Network(value)\n            except ValueError:\n                pass\n\n            try:\n                return IPv6Network(value)\n            except ValueError:\n                raise PydanticCustomError('ip_any_network', 'value is not a valid IPv4 or IPv6 network')\n\n        @classmethod\n        def __get_pydantic_json_schema__(\n            cls, core_schema: core_schema.CoreSchema, handler: _schema_generation_shared.GetJsonSchemaHandler\n        ) -> JsonSchemaValue:\n            field_schema = {}\n            field_schema.update(type='string', format='ipvanynetwork')\n            return field_schema\n\n        @classmethod\n        def __get_pydantic_core_schema__(\n            cls,\n            _source: type[Any],\n            _handler: GetCoreSchemaHandler,\n        ) -> core_schema.CoreSchema:\n            return core_schema.no_info_plain_validator_function(\n                cls._validate, serialization=core_schema.to_string_ser_schema()\n            )\n\n        @classmethod\n        def _validate(cls, input_value: NetworkType, /) -> IPvAnyNetworkType:\n            return cls(input_value)  # type: ignore[return-value]\n\n\ndef _build_pretty_email_regex() -> re.Pattern[str]:\n    name_chars = r'[\\w!#$%&\\'*+\\-/=?^_`{|}~]'\n    unquoted_name_group = rf'((?:{name_chars}+\\s+)*{name_chars}+)'\n    quoted_name_group = r'\"((?:[^\"]|\\\")+)\"'\n    email_group = r'<\\s*(.+)\\s*>'\n    return re.compile(rf'\\s*(?:{unquoted_name_group}|{quoted_name_group})?\\s*{email_group}\\s*')\n\n\npretty_email_regex = _build_pretty_email_regex()\n\nMAX_EMAIL_LENGTH = 2048\n\"\"\"Maximum length for an email.\nA somewhat arbitrary but very generous number compared to what is allowed by most implementations.\n\"\"\"\n\n\ndef validate_email(value: str) -> tuple[str, str]:\n    \"\"\"Email address validation using [email-validator](https://pypi.org/project/email-validator/).\n\n    Note:\n        Note that:\n\n        * Raw IP address (literal) domain parts are not allowed.\n        * `\"John Doe <local_part@domain.com>\"` style \"pretty\" email addresses are processed.\n        * Spaces are striped from the beginning and end of addresses, but no error is raised.\n    \"\"\"\n    if email_validator is None:\n        import_email_validator()\n\n    if len(value) > MAX_EMAIL_LENGTH:\n        raise PydanticCustomError(\n            'value_error',\n            'value is not a valid email address: {reason}',\n            {'reason': f'Length must not exceed {MAX_EMAIL_LENGTH} characters'},\n        )\n\n    m = pretty_email_regex.fullmatch(value)\n    name: str | None = None\n    if m:\n        unquoted_name, quoted_name, value = m.groups()\n        name = unquoted_name or quoted_name\n\n    email = value.strip()\n\n    try:\n        parts = email_validator.validate_email(email, check_deliverability=False)\n    except email_validator.EmailNotValidError as e:\n        raise PydanticCustomError(\n            'value_error', 'value is not a valid email address: {reason}', {'reason': str(e.args[0])}\n        ) from e\n\n    email = parts.normalized\n    assert email is not None\n    name = name or parts.local_part\n    return name, email\n\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/decorator.py": "\"\"\"The `decorator` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/datetime_parse.py": "\"\"\"The `datetime_parse` module is a backport module from V1.\"\"\"\n\nfrom ._migration import getattr_migration\n\n__getattr__ = getattr_migration(__name__)\n", "pydantic/experimental/pipeline.py": "\"\"\"Experimental pipeline API functionality. Be careful with this API, it's subject to change.\"\"\"\n\nfrom __future__ import annotations\n\nimport datetime\nimport operator\nimport re\nimport sys\nfrom collections import deque\nfrom collections.abc import Container\nfrom dataclasses import dataclass\nfrom decimal import Decimal\nfrom functools import cached_property, partial\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, Pattern, Protocol, TypeVar, Union, overload\n\nimport annotated_types\nfrom typing_extensions import Annotated\n\nif TYPE_CHECKING:\n    from pydantic_core import core_schema as cs\n\n    from pydantic import GetCoreSchemaHandler\n\nfrom pydantic._internal._internal_dataclass import slots_true as _slots_true\n\nif sys.version_info < (3, 10):\n    EllipsisType = type(Ellipsis)\nelse:\n    from types import EllipsisType\n\n__all__ = ['validate_as', 'validate_as_deferred', 'transform']\n\n_slots_frozen = {**_slots_true, 'frozen': True}\n\n\n@dataclass(**_slots_frozen)\nclass _ValidateAs:\n    tp: type[Any]\n    strict: bool = False\n\n\n@dataclass\nclass _ValidateAsDefer:\n    func: Callable[[], type[Any]]\n\n    @cached_property\n    def tp(self) -> type[Any]:\n        return self.func()\n\n\n@dataclass(**_slots_frozen)\nclass _Transform:\n    func: Callable[[Any], Any]\n\n\n@dataclass(**_slots_frozen)\nclass _PipelineOr:\n    left: _Pipeline[Any, Any]\n    right: _Pipeline[Any, Any]\n\n\n@dataclass(**_slots_frozen)\nclass _PipelineAnd:\n    left: _Pipeline[Any, Any]\n    right: _Pipeline[Any, Any]\n\n\n@dataclass(**_slots_frozen)\nclass _Eq:\n    value: Any\n\n\n@dataclass(**_slots_frozen)\nclass _NotEq:\n    value: Any\n\n\n@dataclass(**_slots_frozen)\nclass _In:\n    values: Container[Any]\n\n\n@dataclass(**_slots_frozen)\nclass _NotIn:\n    values: Container[Any]\n\n\n_ConstraintAnnotation = Union[\n    annotated_types.Le,\n    annotated_types.Ge,\n    annotated_types.Lt,\n    annotated_types.Gt,\n    annotated_types.Len,\n    annotated_types.MultipleOf,\n    annotated_types.Timezone,\n    annotated_types.Interval,\n    annotated_types.Predicate,\n    # common predicates not included in annotated_types\n    _Eq,\n    _NotEq,\n    _In,\n    _NotIn,\n    # regular expressions\n    Pattern[str],\n]\n\n\n@dataclass(**_slots_frozen)\nclass _Constraint:\n    constraint: _ConstraintAnnotation\n\n\n_Step = Union[_ValidateAs, _ValidateAsDefer, _Transform, _PipelineOr, _PipelineAnd, _Constraint]\n\n_InT = TypeVar('_InT')\n_OutT = TypeVar('_OutT')\n_NewOutT = TypeVar('_NewOutT')\n\n\nclass _FieldTypeMarker:\n    pass\n\n\n# TODO: ultimately, make this public, see https://github.com/pydantic/pydantic/pull/9459#discussion_r1628197626\n# Also, make this frozen eventually, but that doesn't work right now because of the generic base\n# Which attempts to modify __orig_base__ and such.\n# We could go with a manual freeze, but that seems overkill for now.\n@dataclass(**_slots_true)\nclass _Pipeline(Generic[_InT, _OutT]):\n    \"\"\"Abstract representation of a chain of validation, transformation, and parsing steps.\"\"\"\n\n    _steps: tuple[_Step, ...]\n\n    def transform(\n        self,\n        func: Callable[[_OutT], _NewOutT],\n    ) -> _Pipeline[_InT, _NewOutT]:\n        \"\"\"Transform the output of the previous step.\n\n        If used as the first step in a pipeline, the type of the field is used.\n        That is, the transformation is applied to after the value is parsed to the field's type.\n        \"\"\"\n        return _Pipeline[_InT, _NewOutT](self._steps + (_Transform(func),))\n\n    @overload\n    def validate_as(self, tp: type[_NewOutT], *, strict: bool = ...) -> _Pipeline[_InT, _NewOutT]: ...\n\n    @overload\n    def validate_as(self, tp: EllipsisType, *, strict: bool = ...) -> _Pipeline[_InT, Any]:  # type: ignore\n        ...\n\n    def validate_as(self, tp: type[_NewOutT] | EllipsisType, *, strict: bool = False) -> _Pipeline[_InT, Any]:  # type: ignore\n        \"\"\"Validate / parse the input into a new type.\n\n        If no type is provided, the type of the field is used.\n\n        Types are parsed in Pydantic's `lax` mode by default,\n        but you can enable `strict` mode by passing `strict=True`.\n        \"\"\"\n        if isinstance(tp, EllipsisType):\n            return _Pipeline[_InT, Any](self._steps + (_ValidateAs(_FieldTypeMarker, strict=strict),))\n        return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAs(tp, strict=strict),))\n\n    def validate_as_deferred(self, func: Callable[[], type[_NewOutT]]) -> _Pipeline[_InT, _NewOutT]:\n        \"\"\"Parse the input into a new type, deferring resolution of the type until the current class\n        is fully defined.\n\n        This is useful when you need to reference the class in it's own type annotations.\n        \"\"\"\n        return _Pipeline[_InT, _NewOutT](self._steps + (_ValidateAsDefer(func),))\n\n    # constraints\n    @overload\n    def constrain(self: _Pipeline[_InT, _NewOutGe], constraint: annotated_types.Ge) -> _Pipeline[_InT, _NewOutGe]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _NewOutGt], constraint: annotated_types.Gt) -> _Pipeline[_InT, _NewOutGt]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _NewOutLe], constraint: annotated_types.Le) -> _Pipeline[_InT, _NewOutLe]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _NewOutLt], constraint: annotated_types.Lt) -> _Pipeline[_InT, _NewOutLt]: ...\n\n    @overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutLen], constraint: annotated_types.Len\n    ) -> _Pipeline[_InT, _NewOutLen]: ...\n\n    @overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutT], constraint: annotated_types.MultipleOf\n    ) -> _Pipeline[_InT, _NewOutT]: ...\n\n    @overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutDatetime], constraint: annotated_types.Timezone\n    ) -> _Pipeline[_InT, _NewOutDatetime]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: annotated_types.Predicate) -> _Pipeline[_InT, _OutT]: ...\n\n    @overload\n    def constrain(\n        self: _Pipeline[_InT, _NewOutInterval], constraint: annotated_types.Interval\n    ) -> _Pipeline[_InT, _NewOutInterval]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _Eq) -> _Pipeline[_InT, _OutT]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotEq) -> _Pipeline[_InT, _OutT]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _In) -> _Pipeline[_InT, _OutT]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _OutT], constraint: _NotIn) -> _Pipeline[_InT, _OutT]: ...\n\n    @overload\n    def constrain(self: _Pipeline[_InT, _NewOutT], constraint: Pattern[str]) -> _Pipeline[_InT, _NewOutT]: ...\n\n    def constrain(self, constraint: _ConstraintAnnotation) -> Any:\n        \"\"\"Constrain a value to meet a certain condition.\n\n        We support most conditions from `annotated_types`, as well as regular expressions.\n\n        Most of the time you'll be calling a shortcut method like `gt`, `lt`, `len`, etc\n        so you don't need to call this directly.\n        \"\"\"\n        return _Pipeline[_InT, _OutT](self._steps + (_Constraint(constraint),))\n\n    def predicate(self: _Pipeline[_InT, _NewOutT], func: Callable[[_NewOutT], bool]) -> _Pipeline[_InT, _NewOutT]:\n        \"\"\"Constrain a value to meet a certain predicate.\"\"\"\n        return self.constrain(annotated_types.Predicate(func))\n\n    def gt(self: _Pipeline[_InT, _NewOutGt], gt: _NewOutGt) -> _Pipeline[_InT, _NewOutGt]:\n        \"\"\"Constrain a value to be greater than a certain value.\"\"\"\n        return self.constrain(annotated_types.Gt(gt))\n\n    def lt(self: _Pipeline[_InT, _NewOutLt], lt: _NewOutLt) -> _Pipeline[_InT, _NewOutLt]:\n        \"\"\"Constrain a value to be less than a certain value.\"\"\"\n        return self.constrain(annotated_types.Lt(lt))\n\n    def ge(self: _Pipeline[_InT, _NewOutGe], ge: _NewOutGe) -> _Pipeline[_InT, _NewOutGe]:\n        \"\"\"Constrain a value to be greater than or equal to a certain value.\"\"\"\n        return self.constrain(annotated_types.Ge(ge))\n\n    def le(self: _Pipeline[_InT, _NewOutLe], le: _NewOutLe) -> _Pipeline[_InT, _NewOutLe]:\n        \"\"\"Constrain a value to be less than or equal to a certain value.\"\"\"\n        return self.constrain(annotated_types.Le(le))\n\n    def len(self: _Pipeline[_InT, _NewOutLen], min_len: int, max_len: int | None = None) -> _Pipeline[_InT, _NewOutLen]:\n        \"\"\"Constrain a value to have a certain length.\"\"\"\n        return self.constrain(annotated_types.Len(min_len, max_len))\n\n    @overload\n    def multiple_of(self: _Pipeline[_InT, _NewOutDiv], multiple_of: _NewOutDiv) -> _Pipeline[_InT, _NewOutDiv]: ...\n\n    @overload\n    def multiple_of(self: _Pipeline[_InT, _NewOutMod], multiple_of: _NewOutMod) -> _Pipeline[_InT, _NewOutMod]: ...\n\n    def multiple_of(self: _Pipeline[_InT, Any], multiple_of: Any) -> _Pipeline[_InT, Any]:\n        \"\"\"Constrain a value to be a multiple of a certain number.\"\"\"\n        return self.constrain(annotated_types.MultipleOf(multiple_of))\n\n    def eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n        \"\"\"Constrain a value to be equal to a certain value.\"\"\"\n        return self.constrain(_Eq(value))\n\n    def not_eq(self: _Pipeline[_InT, _OutT], value: _OutT) -> _Pipeline[_InT, _OutT]:\n        \"\"\"Constrain a value to not be equal to a certain value.\"\"\"\n        return self.constrain(_NotEq(value))\n\n    def in_(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n        \"\"\"Constrain a value to be in a certain set.\"\"\"\n        return self.constrain(_In(values))\n\n    def not_in(self: _Pipeline[_InT, _OutT], values: Container[_OutT]) -> _Pipeline[_InT, _OutT]:\n        \"\"\"Constrain a value to not be in a certain set.\"\"\"\n        return self.constrain(_NotIn(values))\n\n    # timezone methods\n    def datetime_tz_naive(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n        return self.constrain(annotated_types.Timezone(None))\n\n    def datetime_tz_aware(self: _Pipeline[_InT, datetime.datetime]) -> _Pipeline[_InT, datetime.datetime]:\n        return self.constrain(annotated_types.Timezone(...))\n\n    def datetime_tz(\n        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo\n    ) -> _Pipeline[_InT, datetime.datetime]:\n        return self.constrain(annotated_types.Timezone(tz))  # type: ignore\n\n    def datetime_with_tz(\n        self: _Pipeline[_InT, datetime.datetime], tz: datetime.tzinfo | None\n    ) -> _Pipeline[_InT, datetime.datetime]:\n        return self.transform(partial(datetime.datetime.replace, tzinfo=tz))\n\n    # string methods\n    def str_lower(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n        return self.transform(str.lower)\n\n    def str_upper(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n        return self.transform(str.upper)\n\n    def str_title(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n        return self.transform(str.title)\n\n    def str_strip(self: _Pipeline[_InT, str]) -> _Pipeline[_InT, str]:\n        return self.transform(str.strip)\n\n    def str_pattern(self: _Pipeline[_InT, str], pattern: str) -> _Pipeline[_InT, str]:\n        return self.constrain(re.compile(pattern))\n\n    def str_contains(self: _Pipeline[_InT, str], substring: str) -> _Pipeline[_InT, str]:\n        return self.predicate(lambda v: substring in v)\n\n    def str_starts_with(self: _Pipeline[_InT, str], prefix: str) -> _Pipeline[_InT, str]:\n        return self.predicate(lambda v: v.startswith(prefix))\n\n    def str_ends_with(self: _Pipeline[_InT, str], suffix: str) -> _Pipeline[_InT, str]:\n        return self.predicate(lambda v: v.endswith(suffix))\n\n    # operators\n    def otherwise(self, other: _Pipeline[_OtherIn, _OtherOut]) -> _Pipeline[_InT | _OtherIn, _OutT | _OtherOut]:\n        \"\"\"Combine two validation chains, returning the result of the first chain if it succeeds, and the second chain if it fails.\"\"\"\n        return _Pipeline((_PipelineOr(self, other),))\n\n    __or__ = otherwise\n\n    def then(self, other: _Pipeline[_OutT, _OtherOut]) -> _Pipeline[_InT, _OtherOut]:\n        \"\"\"Pipe the result of one validation chain into another.\"\"\"\n        return _Pipeline((_PipelineAnd(self, other),))\n\n    __and__ = then\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> cs.CoreSchema:\n        from pydantic_core import core_schema as cs\n\n        queue = deque(self._steps)\n\n        s = None\n\n        while queue:\n            step = queue.popleft()\n            s = _apply_step(step, s, handler, source_type)\n\n        s = s or cs.any_schema()\n        return s\n\n    def __supports_type__(self, _: _OutT) -> bool:\n        raise NotImplementedError\n\n\nvalidate_as = _Pipeline[Any, Any](()).validate_as\nvalidate_as_deferred = _Pipeline[Any, Any](()).validate_as_deferred\ntransform = _Pipeline[Any, Any]((_ValidateAs(_FieldTypeMarker),)).transform\n\n\ndef _check_func(\n    func: Callable[[Any], bool], predicate_err: str | Callable[[], str], s: cs.CoreSchema | None\n) -> cs.CoreSchema:\n    from pydantic_core import core_schema as cs\n\n    def handler(v: Any) -> Any:\n        if func(v):\n            return v\n        raise ValueError(f'Expected {predicate_err if isinstance(predicate_err, str) else predicate_err()}')\n\n    if s is None:\n        return cs.no_info_plain_validator_function(handler)\n    else:\n        return cs.no_info_after_validator_function(handler, s)\n\n\ndef _apply_step(step: _Step, s: cs.CoreSchema | None, handler: GetCoreSchemaHandler, source_type: Any) -> cs.CoreSchema:\n    from pydantic_core import core_schema as cs\n\n    if isinstance(step, _ValidateAs):\n        s = _apply_parse(s, step.tp, step.strict, handler, source_type)\n    elif isinstance(step, _ValidateAsDefer):\n        s = _apply_parse(s, step.tp, False, handler, source_type)\n    elif isinstance(step, _Transform):\n        s = _apply_transform(s, step.func, handler)\n    elif isinstance(step, _Constraint):\n        s = _apply_constraint(s, step.constraint)\n    elif isinstance(step, _PipelineOr):\n        s = cs.union_schema([handler(step.left), handler(step.right)])\n    else:\n        assert isinstance(step, _PipelineAnd)\n        s = cs.chain_schema([handler(step.left), handler(step.right)])\n    return s\n\n\ndef _apply_parse(\n    s: cs.CoreSchema | None,\n    tp: type[Any],\n    strict: bool,\n    handler: GetCoreSchemaHandler,\n    source_type: Any,\n) -> cs.CoreSchema:\n    from pydantic_core import core_schema as cs\n\n    from pydantic import Strict\n\n    if tp is _FieldTypeMarker:\n        return handler(source_type)\n\n    if strict:\n        tp = Annotated[tp, Strict()]  # type: ignore\n\n    if s and s['type'] == 'any':\n        return handler(tp)\n    else:\n        return cs.chain_schema([s, handler(tp)]) if s else handler(tp)\n\n\ndef _apply_transform(\n    s: cs.CoreSchema | None, func: Callable[[Any], Any], handler: GetCoreSchemaHandler\n) -> cs.CoreSchema:\n    from pydantic_core import core_schema as cs\n\n    if s is None:\n        return cs.no_info_plain_validator_function(func)\n\n    if s['type'] == 'str':\n        if func is str.strip:\n            s = s.copy()\n            s['strip_whitespace'] = True\n            return s\n        elif func is str.lower:\n            s = s.copy()\n            s['to_lower'] = True\n            return s\n        elif func is str.upper:\n            s = s.copy()\n            s['to_upper'] = True\n            return s\n\n    return cs.no_info_after_validator_function(func, s)\n\n\ndef _apply_constraint(  # noqa: C901\n    s: cs.CoreSchema | None, constraint: _ConstraintAnnotation\n) -> cs.CoreSchema:\n    \"\"\"Apply a single constraint to a schema.\"\"\"\n    if isinstance(constraint, annotated_types.Gt):\n        gt = constraint.gt\n        if s and s['type'] in {'int', 'float', 'decimal'}:\n            s = s.copy()\n            if s['type'] == 'int' and isinstance(gt, int):\n                s['gt'] = gt\n            elif s['type'] == 'float' and isinstance(gt, float):\n                s['gt'] = gt\n            elif s['type'] == 'decimal' and isinstance(gt, Decimal):\n                s['gt'] = gt\n        else:\n\n            def check_gt(v: Any) -> bool:\n                return v > gt\n\n            s = _check_func(check_gt, f'> {gt}', s)\n    elif isinstance(constraint, annotated_types.Ge):\n        ge = constraint.ge\n        if s and s['type'] in {'int', 'float', 'decimal'}:\n            s = s.copy()\n            if s['type'] == 'int' and isinstance(ge, int):\n                s['ge'] = ge\n            elif s['type'] == 'float' and isinstance(ge, float):\n                s['ge'] = ge\n            elif s['type'] == 'decimal' and isinstance(ge, Decimal):\n                s['ge'] = ge\n\n        def check_ge(v: Any) -> bool:\n            return v >= ge\n\n        s = _check_func(check_ge, f'>= {ge}', s)\n    elif isinstance(constraint, annotated_types.Lt):\n        lt = constraint.lt\n        if s and s['type'] in {'int', 'float', 'decimal'}:\n            s = s.copy()\n            if s['type'] == 'int' and isinstance(lt, int):\n                s['lt'] = lt\n            elif s['type'] == 'float' and isinstance(lt, float):\n                s['lt'] = lt\n            elif s['type'] == 'decimal' and isinstance(lt, Decimal):\n                s['lt'] = lt\n\n        def check_lt(v: Any) -> bool:\n            return v < lt\n\n        s = _check_func(check_lt, f'< {lt}', s)\n    elif isinstance(constraint, annotated_types.Le):\n        le = constraint.le\n        if s and s['type'] in {'int', 'float', 'decimal'}:\n            s = s.copy()\n            if s['type'] == 'int' and isinstance(le, int):\n                s['le'] = le\n            elif s['type'] == 'float' and isinstance(le, float):\n                s['le'] = le\n            elif s['type'] == 'decimal' and isinstance(le, Decimal):\n                s['le'] = le\n\n        def check_le(v: Any) -> bool:\n            return v <= le\n\n        s = _check_func(check_le, f'<= {le}', s)\n    elif isinstance(constraint, annotated_types.Len):\n        min_len = constraint.min_length\n        max_len = constraint.max_length\n\n        if s and s['type'] in {'str', 'list', 'tuple', 'set', 'frozenset', 'dict'}:\n            assert (\n                s['type'] == 'str'\n                or s['type'] == 'list'\n                or s['type'] == 'tuple'\n                or s['type'] == 'set'\n                or s['type'] == 'dict'\n                or s['type'] == 'frozenset'\n            )\n            s = s.copy()\n            if min_len != 0:\n                s['min_length'] = min_len\n            if max_len is not None:\n                s['max_length'] = max_len\n\n        def check_len(v: Any) -> bool:\n            if max_len is not None:\n                return (min_len <= len(v)) and (len(v) <= max_len)\n            return min_len <= len(v)\n\n        s = _check_func(check_len, f'length >= {min_len} and length <= {max_len}', s)\n    elif isinstance(constraint, annotated_types.MultipleOf):\n        multiple_of = constraint.multiple_of\n        if s and s['type'] in {'int', 'float', 'decimal'}:\n            s = s.copy()\n            if s['type'] == 'int' and isinstance(multiple_of, int):\n                s['multiple_of'] = multiple_of\n            elif s['type'] == 'float' and isinstance(multiple_of, float):\n                s['multiple_of'] = multiple_of\n            elif s['type'] == 'decimal' and isinstance(multiple_of, Decimal):\n                s['multiple_of'] = multiple_of\n\n        def check_multiple_of(v: Any) -> bool:\n            return v % multiple_of == 0\n\n        s = _check_func(check_multiple_of, f'% {multiple_of} == 0', s)\n    elif isinstance(constraint, annotated_types.Timezone):\n        tz = constraint.tz\n\n        if tz is ...:\n            if s and s['type'] == 'datetime':\n                s = s.copy()\n                s['tz_constraint'] = 'aware'\n            else:\n\n                def check_tz_aware(v: object) -> bool:\n                    assert isinstance(v, datetime.datetime)\n                    return v.tzinfo is not None\n\n                s = _check_func(check_tz_aware, 'timezone aware', s)\n        elif tz is None:\n            if s and s['type'] == 'datetime':\n                s = s.copy()\n                s['tz_constraint'] = 'naive'\n            else:\n\n                def check_tz_naive(v: object) -> bool:\n                    assert isinstance(v, datetime.datetime)\n                    return v.tzinfo is None\n\n                s = _check_func(check_tz_naive, 'timezone naive', s)\n        else:\n            raise NotImplementedError('Constraining to a specific timezone is not yet supported')\n    elif isinstance(constraint, annotated_types.Interval):\n        if constraint.ge:\n            s = _apply_constraint(s, annotated_types.Ge(constraint.ge))\n        if constraint.gt:\n            s = _apply_constraint(s, annotated_types.Gt(constraint.gt))\n        if constraint.le:\n            s = _apply_constraint(s, annotated_types.Le(constraint.le))\n        if constraint.lt:\n            s = _apply_constraint(s, annotated_types.Lt(constraint.lt))\n        assert s is not None\n    elif isinstance(constraint, annotated_types.Predicate):\n        func = constraint.func\n\n        if func.__name__ == '<lambda>':\n            # attempt to extract the source code for a lambda function\n            # to use as the function name in error messages\n            # TODO: is there a better way? should we just not do this?\n            import inspect\n\n            try:\n                # remove ')' suffix, can use removesuffix once we drop 3.8\n                source = inspect.getsource(func).strip()\n                if source.endswith(')'):\n                    source = source[:-1]\n                lambda_source_code = '`' + ''.join(''.join(source.split('lambda ')[1:]).split(':')[1:]).strip() + '`'\n            except OSError:\n                # stringified annotations\n                lambda_source_code = 'lambda'\n\n            s = _check_func(func, lambda_source_code, s)\n        else:\n            s = _check_func(func, func.__name__, s)\n    elif isinstance(constraint, _NotEq):\n        value = constraint.value\n\n        def check_not_eq(v: Any) -> bool:\n            return operator.__ne__(v, value)\n\n        s = _check_func(check_not_eq, f'!= {value}', s)\n    elif isinstance(constraint, _Eq):\n        value = constraint.value\n\n        def check_eq(v: Any) -> bool:\n            return operator.__eq__(v, value)\n\n        s = _check_func(check_eq, f'== {value}', s)\n    elif isinstance(constraint, _In):\n        values = constraint.values\n\n        def check_in(v: Any) -> bool:\n            return operator.__contains__(values, v)\n\n        s = _check_func(check_in, f'in {values}', s)\n    elif isinstance(constraint, _NotIn):\n        values = constraint.values\n\n        def check_not_in(v: Any) -> bool:\n            return operator.__not__(operator.__contains__(values, v))\n\n        s = _check_func(check_not_in, f'not in {values}', s)\n    else:\n        assert isinstance(constraint, Pattern)\n        if s and s['type'] == 'str':\n            s = s.copy()\n            s['pattern'] = constraint.pattern\n        else:\n\n            def check_pattern(v: object) -> bool:\n                assert isinstance(v, str)\n                return constraint.match(v) is not None\n\n            s = _check_func(check_pattern, f'~ {constraint.pattern}', s)\n    return s\n\n\nclass _SupportsRange(annotated_types.SupportsLe, annotated_types.SupportsGe, Protocol):\n    pass\n\n\nclass _SupportsLen(Protocol):\n    def __len__(self) -> int: ...\n\n\n_NewOutGt = TypeVar('_NewOutGt', bound=annotated_types.SupportsGt)\n_NewOutGe = TypeVar('_NewOutGe', bound=annotated_types.SupportsGe)\n_NewOutLt = TypeVar('_NewOutLt', bound=annotated_types.SupportsLt)\n_NewOutLe = TypeVar('_NewOutLe', bound=annotated_types.SupportsLe)\n_NewOutLen = TypeVar('_NewOutLen', bound=_SupportsLen)\n_NewOutDiv = TypeVar('_NewOutDiv', bound=annotated_types.SupportsDiv)\n_NewOutMod = TypeVar('_NewOutMod', bound=annotated_types.SupportsMod)\n_NewOutDatetime = TypeVar('_NewOutDatetime', bound=datetime.datetime)\n_NewOutInterval = TypeVar('_NewOutInterval', bound=_SupportsRange)\n_OtherIn = TypeVar('_OtherIn')\n_OtherOut = TypeVar('_OtherOut')\n", "pydantic/experimental/__init__.py": "\"\"\"The \"experimental\" module of pydantic contains potential new features that are subject to change.\"\"\"\n\nimport warnings\n\nfrom pydantic.warnings import PydanticExperimentalWarning\n\nwarnings.warn(\n    'This module is experimental, its contents are subject to change and deprecation.',\n    category=PydanticExperimentalWarning,\n)\n", "pydantic/v1/generics.py": "import sys\nimport types\nimport typing\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    ClassVar,\n    Dict,\n    ForwardRef,\n    Generic,\n    Iterator,\n    List,\n    Mapping,\n    Optional,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n)\nfrom weakref import WeakKeyDictionary, WeakValueDictionary\n\nfrom typing_extensions import Annotated, Literal as ExtLiteral\n\nfrom pydantic.v1.class_validators import gather_all_validators\nfrom pydantic.v1.fields import DeferredType\nfrom pydantic.v1.main import BaseModel, create_model\nfrom pydantic.v1.types import JsonWrapper\nfrom pydantic.v1.typing import display_as_type, get_all_type_hints, get_args, get_origin, typing_base\nfrom pydantic.v1.utils import all_identical, lenient_issubclass\n\nif sys.version_info >= (3, 10):\n    from typing import _UnionGenericAlias\nif sys.version_info >= (3, 8):\n    from typing import Literal\n\nGenericModelT = TypeVar('GenericModelT', bound='GenericModel')\nTypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type\n\nCacheKey = Tuple[Type[Any], Any, Tuple[Any, ...]]\nParametrization = Mapping[TypeVarType, Type[Any]]\n\n# weak dictionaries allow the dynamically created parametrized versions of generic models to get collected\n# once they are no longer referenced by the caller.\nif sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[CacheKey, Type[BaseModel]]\n    AssignedParameters = WeakKeyDictionary[Type[BaseModel], Parametrization]\nelse:\n    GenericTypesCache = WeakValueDictionary\n    AssignedParameters = WeakKeyDictionary\n\n# _generic_types_cache is a Mapping from __class_getitem__ arguments to the parametrized version of generic models.\n# This ensures multiple calls of e.g. A[B] return always the same class.\n_generic_types_cache = GenericTypesCache()\n\n# _assigned_parameters is a Mapping from parametrized version of generic models to assigned types of parametrizations\n# as captured during construction of the class (not instances).\n# E.g., for generic model `Model[A, B]`, when parametrized model `Model[int, str]` is created,\n# `Model[int, str]`: {A: int, B: str}` will be stored in `_assigned_parameters`.\n# (This information is only otherwise available after creation from the class name string).\n_assigned_parameters = AssignedParameters()\n\n\nclass GenericModel(BaseModel):\n    __slots__ = ()\n    __concrete__: ClassVar[bool] = False\n\n    if TYPE_CHECKING:\n        # Putting this in a TYPE_CHECKING block allows us to replace `if Generic not in cls.__bases__` with\n        # `not hasattr(cls, \"__parameters__\")`. This means we don't need to force non-concrete subclasses of\n        # `GenericModel` to also inherit from `Generic`, which would require changes to the use of `create_model` below.\n        __parameters__: ClassVar[Tuple[TypeVarType, ...]]\n\n    # Setting the return type as Type[Any] instead of Type[BaseModel] prevents PyCharm warnings\n    def __class_getitem__(cls: Type[GenericModelT], params: Union[Type[Any], Tuple[Type[Any], ...]]) -> Type[Any]:\n        \"\"\"Instantiates a new class from a generic class `cls` and type variables `params`.\n\n        :param params: Tuple of types the class . Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n        :return: New model class inheriting from `cls` with instantiated\n            types described by `params`. If no parameters are given, `cls` is\n            returned as is.\n\n        \"\"\"\n\n        def _cache_key(_params: Any) -> CacheKey:\n            args = get_args(_params)\n            # python returns a list for Callables, which is not hashable\n            if len(args) == 2 and isinstance(args[0], list):\n                args = (tuple(args[0]), args[1])\n            return cls, _params, args\n\n        cached = _generic_types_cache.get(_cache_key(params))\n        if cached is not None:\n            return cached\n        if cls.__concrete__ and Generic not in cls.__bases__:\n            raise TypeError('Cannot parameterize a concrete instantiation of a generic model')\n        if not isinstance(params, tuple):\n            params = (params,)\n        if cls is GenericModel and any(isinstance(param, TypeVar) for param in params):\n            raise TypeError('Type parameters should be placed on typing.Generic, not GenericModel')\n        if not hasattr(cls, '__parameters__'):\n            raise TypeError(f'Type {cls.__name__} must inherit from typing.Generic before being parameterized')\n\n        check_parameters_count(cls, params)\n        # Build map from generic typevars to passed params\n        typevars_map: Dict[TypeVarType, Type[Any]] = dict(zip(cls.__parameters__, params))\n        if all_identical(typevars_map.keys(), typevars_map.values()) and typevars_map:\n            return cls  # if arguments are equal to parameters it's the same object\n\n        # Create new model with original model as parent inserting fields with DeferredType.\n        model_name = cls.__concrete_name__(params)\n        validators = gather_all_validators(cls)\n\n        type_hints = get_all_type_hints(cls).items()\n        instance_type_hints = {k: v for k, v in type_hints if get_origin(v) is not ClassVar}\n\n        fields = {k: (DeferredType(), cls.__fields__[k].field_info) for k in instance_type_hints if k in cls.__fields__}\n\n        model_module, called_globally = get_caller_frame_info()\n        created_model = cast(\n            Type[GenericModel],  # casting ensures mypy is aware of the __concrete__ and __parameters__ attributes\n            create_model(\n                model_name,\n                __module__=model_module or cls.__module__,\n                __base__=(cls,) + tuple(cls.__parameterized_bases__(typevars_map)),\n                __config__=None,\n                __validators__=validators,\n                __cls_kwargs__=None,\n                **fields,\n            ),\n        )\n\n        _assigned_parameters[created_model] = typevars_map\n\n        if called_globally:  # create global reference and therefore allow pickling\n            object_by_reference = None\n            reference_name = model_name\n            reference_module_globals = sys.modules[created_model.__module__].__dict__\n            while object_by_reference is not created_model:\n                object_by_reference = reference_module_globals.setdefault(reference_name, created_model)\n                reference_name += '_'\n\n        created_model.Config = cls.Config\n\n        # Find any typevars that are still present in the model.\n        # If none are left, the model is fully \"concrete\", otherwise the new\n        # class is a generic class as well taking the found typevars as\n        # parameters.\n        new_params = tuple(\n            {param: None for param in iter_contained_typevars(typevars_map.values())}\n        )  # use dict as ordered set\n        created_model.__concrete__ = not new_params\n        if new_params:\n            created_model.__parameters__ = new_params\n\n        # Save created model in cache so we don't end up creating duplicate\n        # models that should be identical.\n        _generic_types_cache[_cache_key(params)] = created_model\n        if len(params) == 1:\n            _generic_types_cache[_cache_key(params[0])] = created_model\n\n        # Recursively walk class type hints and replace generic typevars\n        # with concrete types that were passed.\n        _prepare_model_fields(created_model, fields, instance_type_hints, typevars_map)\n\n        return created_model\n\n    @classmethod\n    def __concrete_name__(cls: Type[Any], params: Tuple[Type[Any], ...]) -> str:\n        \"\"\"Compute class name for child classes.\n\n        :param params: Tuple of types the class . Given a generic class\n            `Model` with 2 type variables and a concrete model `Model[str, int]`,\n            the value `(str, int)` would be passed to `params`.\n        :return: String representing a the new class where `params` are\n            passed to `cls` as type variables.\n\n        This method can be overridden to achieve a custom naming scheme for GenericModels.\n        \"\"\"\n        param_names = [display_as_type(param) for param in params]\n        params_component = ', '.join(param_names)\n        return f'{cls.__name__}[{params_component}]'\n\n    @classmethod\n    def __parameterized_bases__(cls, typevars_map: Parametrization) -> Iterator[Type[Any]]:\n        \"\"\"\n        Returns unbound bases of cls parameterised to given type variables\n\n        :param typevars_map: Dictionary of type applications for binding subclasses.\n            Given a generic class `Model` with 2 type variables [S, T]\n            and a concrete model `Model[str, int]`,\n            the value `{S: str, T: int}` would be passed to `typevars_map`.\n        :return: an iterator of generic sub classes, parameterised by `typevars_map`\n            and other assigned parameters of `cls`\n\n        e.g.:\n        ```\n        class A(GenericModel, Generic[T]):\n            ...\n\n        class B(A[V], Generic[V]):\n            ...\n\n        assert A[int] in B.__parameterized_bases__({V: int})\n        ```\n        \"\"\"\n\n        def build_base_model(\n            base_model: Type[GenericModel], mapped_types: Parametrization\n        ) -> Iterator[Type[GenericModel]]:\n            base_parameters = tuple(mapped_types[param] for param in base_model.__parameters__)\n            parameterized_base = base_model.__class_getitem__(base_parameters)\n            if parameterized_base is base_model or parameterized_base is cls:\n                # Avoid duplication in MRO\n                return\n            yield parameterized_base\n\n        for base_model in cls.__bases__:\n            if not issubclass(base_model, GenericModel):\n                # not a class that can be meaningfully parameterized\n                continue\n            elif not getattr(base_model, '__parameters__', None):\n                # base_model is \"GenericModel\"  (and has no __parameters__)\n                # or\n                # base_model is already concrete, and will be included transitively via cls.\n                continue\n            elif cls in _assigned_parameters:\n                if base_model in _assigned_parameters:\n                    # cls is partially parameterised but not from base_model\n                    # e.g. cls = B[S], base_model = A[S]\n                    # B[S][int] should subclass A[int],  (and will be transitively via B[int])\n                    # but it's not viable to consistently subclass types with arbitrary construction\n                    # So don't attempt to include A[S][int]\n                    continue\n                else:  # base_model not in _assigned_parameters:\n                    # cls is partially parameterized, base_model is original generic\n                    # e.g.  cls = B[str, T], base_model = B[S, T]\n                    # Need to determine the mapping for the base_model parameters\n                    mapped_types: Parametrization = {\n                        key: typevars_map.get(value, value) for key, value in _assigned_parameters[cls].items()\n                    }\n                    yield from build_base_model(base_model, mapped_types)\n            else:\n                # cls is base generic, so base_class has a distinct base\n                # can construct the Parameterised base model using typevars_map directly\n                yield from build_base_model(base_model, typevars_map)\n\n\ndef replace_types(type_: Any, type_map: Mapping[Any, Any]) -> Any:\n    \"\"\"Return type with all occurrences of `type_map` keys recursively replaced with their values.\n\n    :param type_: Any type, class or generic alias\n    :param type_map: Mapping from `TypeVar` instance to concrete types.\n    :return: New type representing the basic structure of `type_` with all\n        `typevar_map` keys recursively replaced.\n\n    >>> replace_types(Tuple[str, Union[List[str], float]], {str: int})\n    Tuple[int, Union[List[int], float]]\n\n    \"\"\"\n    if not type_map:\n        return type_\n\n    type_args = get_args(type_)\n    origin_type = get_origin(type_)\n\n    if origin_type is Annotated:\n        annotated_type, *annotations = type_args\n        return Annotated[replace_types(annotated_type, type_map), tuple(annotations)]\n\n    if (origin_type is ExtLiteral) or (sys.version_info >= (3, 8) and origin_type is Literal):\n        return type_map.get(type_, type_)\n    # Having type args is a good indicator that this is a typing module\n    # class instantiation or a generic alias of some sort.\n    if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same, there is no need to modify the\n            # type or create a new object at all\n            return type_\n        if (\n            origin_type is not None\n            and isinstance(type_, typing_base)\n            and not isinstance(origin_type, typing_base)\n            and getattr(type_, '_name', None) is not None\n        ):\n            # In python < 3.9 generic aliases don't exist so any of these like `list`,\n            # `type` or `collections.abc.Callable` need to be translated.\n            # See: https://www.python.org/dev/peps/pep-0585\n            origin_type = getattr(typing, type_._name)\n        assert origin_type is not None\n        # PEP-604 syntax (Ex.: list | str) is represented with a types.UnionType object that does not have __getitem__.\n        # We also cannot use isinstance() since we have to compare types.\n        if sys.version_info >= (3, 10) and origin_type is types.UnionType:  # noqa: E721\n            return _UnionGenericAlias(origin_type, resolved_type_args)\n        return origin_type[resolved_type_args]\n\n    # We handle pydantic generic models separately as they don't have the same\n    # semantics as \"typing\" classes or generic aliases\n    if not origin_type and lenient_issubclass(type_, GenericModel) and not type_.__concrete__:\n        type_args = type_.__parameters__\n        resolved_type_args = tuple(replace_types(t, type_map) for t in type_args)\n        if all_identical(type_args, resolved_type_args):\n            return type_\n        return type_[resolved_type_args]\n\n    # Handle special case for typehints that can have lists as arguments.\n    # `typing.Callable[[int, str], int]` is an example for this.\n    if isinstance(type_, (List, list)):\n        resolved_list = list(replace_types(element, type_map) for element in type_)\n        if all_identical(type_, resolved_list):\n            return type_\n        return resolved_list\n\n    # For JsonWrapperValue, need to handle its inner type to allow correct parsing\n    # of generic Json arguments like Json[T]\n    if not origin_type and lenient_issubclass(type_, JsonWrapper):\n        type_.inner_type = replace_types(type_.inner_type, type_map)\n        return type_\n\n    # If all else fails, we try to resolve the type directly and otherwise just\n    # return the input with no modifications.\n    new_type = type_map.get(type_, type_)\n    # Convert string to ForwardRef\n    if isinstance(new_type, str):\n        return ForwardRef(new_type)\n    else:\n        return new_type\n\n\ndef check_parameters_count(cls: Type[GenericModel], parameters: Tuple[Any, ...]) -> None:\n    actual = len(parameters)\n    expected = len(cls.__parameters__)\n    if actual != expected:\n        description = 'many' if actual > expected else 'few'\n        raise TypeError(f'Too {description} parameters for {cls.__name__}; actual {actual}, expected {expected}')\n\n\nDictValues: Type[Any] = {}.values().__class__\n\n\ndef iter_contained_typevars(v: Any) -> Iterator[TypeVarType]:\n    \"\"\"Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.\"\"\"\n    if isinstance(v, TypeVar):\n        yield v\n    elif hasattr(v, '__parameters__') and not get_origin(v) and lenient_issubclass(v, GenericModel):\n        yield from v.__parameters__\n    elif isinstance(v, (DictValues, list)):\n        for var in v:\n            yield from iter_contained_typevars(var)\n    else:\n        args = get_args(v)\n        for arg in args:\n            yield from iter_contained_typevars(arg)\n\n\ndef get_caller_frame_info() -> Tuple[Optional[str], bool]:\n    \"\"\"\n    Used inside a function to check whether it was called globally\n\n    Will only work against non-compiled code, therefore used only in pydantic.generics\n\n    :returns Tuple[module_name, called_globally]\n    \"\"\"\n    try:\n        previous_caller_frame = sys._getframe(2)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except AttributeError:  # sys module does not have _getframe function, so there's nothing we can do about it\n        return None, False\n    frame_globals = previous_caller_frame.f_globals\n    return frame_globals.get('__name__'), previous_caller_frame.f_locals is frame_globals\n\n\ndef _prepare_model_fields(\n    created_model: Type[GenericModel],\n    fields: Mapping[str, Any],\n    instance_type_hints: Mapping[str, type],\n    typevars_map: Mapping[Any, type],\n) -> None:\n    \"\"\"\n    Replace DeferredType fields with concrete type hints and prepare them.\n    \"\"\"\n\n    for key, field in created_model.__fields__.items():\n        if key not in fields:\n            assert field.type_.__class__ is not DeferredType\n            # https://github.com/nedbat/coveragepy/issues/198\n            continue  # pragma: no cover\n\n        assert field.type_.__class__ is DeferredType, field.type_.__class__\n\n        field_type_hint = instance_type_hints[key]\n        concrete_type = replace_types(field_type_hint, typevars_map)\n        field.type_ = concrete_type\n        field.outer_type_ = concrete_type\n        field.prepare()\n        created_model.__annotations__[key] = concrete_type\n", "pydantic/v1/color.py": "\"\"\"\nColor definitions are  used as per CSS3 specification:\nhttp://www.w3.org/TR/css3-color/#svg-color\n\nA few colors have multiple names referring to the sames colors, eg. `grey` and `gray` or `aqua` and `cyan`.\n\nIn these cases the LAST color when sorted alphabetically takes preferences,\neg. Color((0, 255, 255)).as_named() == 'cyan' because \"cyan\" comes after \"aqua\".\n\"\"\"\nimport math\nimport re\nfrom colorsys import hls_to_rgb, rgb_to_hls\nfrom typing import TYPE_CHECKING, Any, Dict, Optional, Tuple, Union, cast\n\nfrom pydantic.v1.errors import ColorError\nfrom pydantic.v1.utils import Representation, almost_equal_floats\n\nif TYPE_CHECKING:\n    from pydantic.v1.typing import CallableGenerator, ReprArgs\n\nColorTuple = Union[Tuple[int, int, int], Tuple[int, int, int, float]]\nColorType = Union[ColorTuple, str]\nHslColorTuple = Union[Tuple[float, float, float], Tuple[float, float, float, float]]\n\n\nclass RGBA:\n    \"\"\"\n    Internal use only as a representation of a color.\n    \"\"\"\n\n    __slots__ = 'r', 'g', 'b', 'alpha', '_tuple'\n\n    def __init__(self, r: float, g: float, b: float, alpha: Optional[float]):\n        self.r = r\n        self.g = g\n        self.b = b\n        self.alpha = alpha\n\n        self._tuple: Tuple[float, float, float, Optional[float]] = (r, g, b, alpha)\n\n    def __getitem__(self, item: Any) -> Any:\n        return self._tuple[item]\n\n\n# these are not compiled here to avoid import slowdown, they'll be compiled the first time they're used, then cached\nr_hex_short = r'\\s*(?:#|0x)?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])?\\s*'\nr_hex_long = r'\\s*(?:#|0x)?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})?\\s*'\n_r_255 = r'(\\d{1,3}(?:\\.\\d+)?)'\n_r_comma = r'\\s*,\\s*'\nr_rgb = fr'\\s*rgb\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}\\)\\s*'\n_r_alpha = r'(\\d(?:\\.\\d+)?|\\.\\d+|\\d{1,2}%)'\nr_rgba = fr'\\s*rgba\\(\\s*{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_255}{_r_comma}{_r_alpha}\\s*\\)\\s*'\n_r_h = r'(-?\\d+(?:\\.\\d+)?|-?\\.\\d+)(deg|rad|turn)?'\n_r_sl = r'(\\d{1,3}(?:\\.\\d+)?)%'\nr_hsl = fr'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}\\s*\\)\\s*'\nr_hsla = fr'\\s*hsl\\(\\s*{_r_h}{_r_comma}{_r_sl}{_r_comma}{_r_sl}{_r_comma}{_r_alpha}\\s*\\)\\s*'\n\n# colors where the two hex characters are the same, if all colors match this the short version of hex colors can be used\nrepeat_colors = {int(c * 2, 16) for c in '0123456789abcdef'}\nrads = 2 * math.pi\n\n\nclass Color(Representation):\n    __slots__ = '_original', '_rgba'\n\n    def __init__(self, value: ColorType) -> None:\n        self._rgba: RGBA\n        self._original: ColorType\n        if isinstance(value, (tuple, list)):\n            self._rgba = parse_tuple(value)\n        elif isinstance(value, str):\n            self._rgba = parse_str(value)\n        elif isinstance(value, Color):\n            self._rgba = value._rgba\n            value = value._original\n        else:\n            raise ColorError(reason='value must be a tuple, list or string')\n\n        # if we've got here value must be a valid color\n        self._original = value\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='color')\n\n    def original(self) -> ColorType:\n        \"\"\"\n        Original value passed to Color\n        \"\"\"\n        return self._original\n\n    def as_named(self, *, fallback: bool = False) -> str:\n        if self._rgba.alpha is None:\n            rgb = cast(Tuple[int, int, int], self.as_rgb_tuple())\n            try:\n                return COLORS_BY_VALUE[rgb]\n            except KeyError as e:\n                if fallback:\n                    return self.as_hex()\n                else:\n                    raise ValueError('no named color found, use fallback=True, as_hex() or as_rgb()') from e\n        else:\n            return self.as_hex()\n\n    def as_hex(self) -> str:\n        \"\"\"\n        Hex string representing the color can be 3, 4, 6 or 8 characters depending on whether the string\n        a \"short\" representation of the color is possible and whether there's an alpha channel.\n        \"\"\"\n        values = [float_to_255(c) for c in self._rgba[:3]]\n        if self._rgba.alpha is not None:\n            values.append(float_to_255(self._rgba.alpha))\n\n        as_hex = ''.join(f'{v:02x}' for v in values)\n        if all(c in repeat_colors for c in values):\n            as_hex = ''.join(as_hex[c] for c in range(0, len(as_hex), 2))\n        return '#' + as_hex\n\n    def as_rgb(self) -> str:\n        \"\"\"\n        Color as an rgb(<r>, <g>, <b>) or rgba(<r>, <g>, <b>, <a>) string.\n        \"\"\"\n        if self._rgba.alpha is None:\n            return f'rgb({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)})'\n        else:\n            return (\n                f'rgba({float_to_255(self._rgba.r)}, {float_to_255(self._rgba.g)}, {float_to_255(self._rgba.b)}, '\n                f'{round(self._alpha_float(), 2)})'\n            )\n\n    def as_rgb_tuple(self, *, alpha: Optional[bool] = None) -> ColorTuple:\n        \"\"\"\n        Color as an RGB or RGBA tuple; red, green and blue are in the range 0 to 255, alpha if included is\n        in the range 0 to 1.\n\n        :param alpha: whether to include the alpha channel, options are\n          None - (default) include alpha only if it's set (e.g. not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        r, g, b = (float_to_255(c) for c in self._rgba[:3])\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return r, g, b\n            else:\n                return r, g, b, self._alpha_float()\n        elif alpha:\n            return r, g, b, self._alpha_float()\n        else:\n            # alpha is False\n            return r, g, b\n\n    def as_hsl(self) -> str:\n        \"\"\"\n        Color as an hsl(<h>, <s>, <l>) or hsl(<h>, <s>, <l>, <a>) string.\n        \"\"\"\n        if self._rgba.alpha is None:\n            h, s, li = self.as_hsl_tuple(alpha=False)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%})'\n        else:\n            h, s, li, a = self.as_hsl_tuple(alpha=True)  # type: ignore\n            return f'hsl({h * 360:0.0f}, {s:0.0%}, {li:0.0%}, {round(a, 2)})'\n\n    def as_hsl_tuple(self, *, alpha: Optional[bool] = None) -> HslColorTuple:\n        \"\"\"\n        Color as an HSL or HSLA tuple, e.g. hue, saturation, lightness and optionally alpha; all elements are in\n        the range 0 to 1.\n\n        NOTE: this is HSL as used in HTML and most other places, not HLS as used in python's colorsys.\n\n        :param alpha: whether to include the alpha channel, options are\n          None - (default) include alpha only if it's set (e.g. not None)\n          True - always include alpha,\n          False - always omit alpha,\n        \"\"\"\n        h, l, s = rgb_to_hls(self._rgba.r, self._rgba.g, self._rgba.b)\n        if alpha is None:\n            if self._rgba.alpha is None:\n                return h, s, l\n            else:\n                return h, s, l, self._alpha_float()\n        if alpha:\n            return h, s, l, self._alpha_float()\n        else:\n            # alpha is False\n            return h, s, l\n\n    def _alpha_float(self) -> float:\n        return 1 if self._rgba.alpha is None else self._rgba.alpha\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls\n\n    def __str__(self) -> str:\n        return self.as_named(fallback=True)\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [(None, self.as_named(fallback=True))] + [('rgb', self.as_rgb_tuple())]  # type: ignore\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, Color) and self.as_rgb_tuple() == other.as_rgb_tuple()\n\n    def __hash__(self) -> int:\n        return hash(self.as_rgb_tuple())\n\n\ndef parse_tuple(value: Tuple[Any, ...]) -> RGBA:\n    \"\"\"\n    Parse a tuple or list as a color.\n    \"\"\"\n    if len(value) == 3:\n        r, g, b = (parse_color_value(v) for v in value)\n        return RGBA(r, g, b, None)\n    elif len(value) == 4:\n        r, g, b = (parse_color_value(v) for v in value[:3])\n        return RGBA(r, g, b, parse_float_alpha(value[3]))\n    else:\n        raise ColorError(reason='tuples must have length 3 or 4')\n\n\ndef parse_str(value: str) -> RGBA:\n    \"\"\"\n    Parse a string to an RGBA tuple, trying the following formats (in this order):\n    * named color, see COLORS_BY_NAME below\n    * hex short eg. `<prefix>fff` (prefix can be `#`, `0x` or nothing)\n    * hex long eg. `<prefix>ffffff` (prefix can be `#`, `0x` or nothing)\n    * `rgb(<r>, <g>, <b>) `\n    * `rgba(<r>, <g>, <b>, <a>)`\n    \"\"\"\n    value_lower = value.lower()\n    try:\n        r, g, b = COLORS_BY_NAME[value_lower]\n    except KeyError:\n        pass\n    else:\n        return ints_to_rgba(r, g, b, None)\n\n    m = re.fullmatch(r_hex_short, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v * 2, 16) for v in rgb)\n        if a:\n            alpha: Optional[float] = int(a * 2, 16) / 255\n        else:\n            alpha = None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_hex_long, value_lower)\n    if m:\n        *rgb, a = m.groups()\n        r, g, b = (int(v, 16) for v in rgb)\n        if a:\n            alpha = int(a, 16) / 255\n        else:\n            alpha = None\n        return ints_to_rgba(r, g, b, alpha)\n\n    m = re.fullmatch(r_rgb, value_lower)\n    if m:\n        return ints_to_rgba(*m.groups(), None)  # type: ignore\n\n    m = re.fullmatch(r_rgba, value_lower)\n    if m:\n        return ints_to_rgba(*m.groups())  # type: ignore\n\n    m = re.fullmatch(r_hsl, value_lower)\n    if m:\n        h, h_units, s, l_ = m.groups()\n        return parse_hsl(h, h_units, s, l_)\n\n    m = re.fullmatch(r_hsla, value_lower)\n    if m:\n        h, h_units, s, l_, a = m.groups()\n        return parse_hsl(h, h_units, s, l_, parse_float_alpha(a))\n\n    raise ColorError(reason='string not recognised as a valid color')\n\n\ndef ints_to_rgba(r: Union[int, str], g: Union[int, str], b: Union[int, str], alpha: Optional[float]) -> RGBA:\n    return RGBA(parse_color_value(r), parse_color_value(g), parse_color_value(b), parse_float_alpha(alpha))\n\n\ndef parse_color_value(value: Union[int, str], max_val: int = 255) -> float:\n    \"\"\"\n    Parse a value checking it's a valid int in the range 0 to max_val and divide by max_val to give a number\n    in the range 0 to 1\n    \"\"\"\n    try:\n        color = float(value)\n    except ValueError:\n        raise ColorError(reason='color values must be a valid number')\n    if 0 <= color <= max_val:\n        return color / max_val\n    else:\n        raise ColorError(reason=f'color values must be in the range 0 to {max_val}')\n\n\ndef parse_float_alpha(value: Union[None, str, float, int]) -> Optional[float]:\n    \"\"\"\n    Parse a value checking it's a valid float in the range 0 to 1\n    \"\"\"\n    if value is None:\n        return None\n    try:\n        if isinstance(value, str) and value.endswith('%'):\n            alpha = float(value[:-1]) / 100\n        else:\n            alpha = float(value)\n    except ValueError:\n        raise ColorError(reason='alpha values must be a valid float')\n\n    if almost_equal_floats(alpha, 1):\n        return None\n    elif 0 <= alpha <= 1:\n        return alpha\n    else:\n        raise ColorError(reason='alpha values must be in the range 0 to 1')\n\n\ndef parse_hsl(h: str, h_units: str, sat: str, light: str, alpha: Optional[float] = None) -> RGBA:\n    \"\"\"\n    Parse raw hue, saturation, lightness and alpha values and convert to RGBA.\n    \"\"\"\n    s_value, l_value = parse_color_value(sat, 100), parse_color_value(light, 100)\n\n    h_value = float(h)\n    if h_units in {None, 'deg'}:\n        h_value = h_value % 360 / 360\n    elif h_units == 'rad':\n        h_value = h_value % rads / rads\n    else:\n        # turns\n        h_value = h_value % 1\n\n    r, g, b = hls_to_rgb(h_value, l_value, s_value)\n    return RGBA(r, g, b, alpha)\n\n\ndef float_to_255(c: float) -> int:\n    return int(round(c * 255))\n\n\nCOLORS_BY_NAME = {\n    'aliceblue': (240, 248, 255),\n    'antiquewhite': (250, 235, 215),\n    'aqua': (0, 255, 255),\n    'aquamarine': (127, 255, 212),\n    'azure': (240, 255, 255),\n    'beige': (245, 245, 220),\n    'bisque': (255, 228, 196),\n    'black': (0, 0, 0),\n    'blanchedalmond': (255, 235, 205),\n    'blue': (0, 0, 255),\n    'blueviolet': (138, 43, 226),\n    'brown': (165, 42, 42),\n    'burlywood': (222, 184, 135),\n    'cadetblue': (95, 158, 160),\n    'chartreuse': (127, 255, 0),\n    'chocolate': (210, 105, 30),\n    'coral': (255, 127, 80),\n    'cornflowerblue': (100, 149, 237),\n    'cornsilk': (255, 248, 220),\n    'crimson': (220, 20, 60),\n    'cyan': (0, 255, 255),\n    'darkblue': (0, 0, 139),\n    'darkcyan': (0, 139, 139),\n    'darkgoldenrod': (184, 134, 11),\n    'darkgray': (169, 169, 169),\n    'darkgreen': (0, 100, 0),\n    'darkgrey': (169, 169, 169),\n    'darkkhaki': (189, 183, 107),\n    'darkmagenta': (139, 0, 139),\n    'darkolivegreen': (85, 107, 47),\n    'darkorange': (255, 140, 0),\n    'darkorchid': (153, 50, 204),\n    'darkred': (139, 0, 0),\n    'darksalmon': (233, 150, 122),\n    'darkseagreen': (143, 188, 143),\n    'darkslateblue': (72, 61, 139),\n    'darkslategray': (47, 79, 79),\n    'darkslategrey': (47, 79, 79),\n    'darkturquoise': (0, 206, 209),\n    'darkviolet': (148, 0, 211),\n    'deeppink': (255, 20, 147),\n    'deepskyblue': (0, 191, 255),\n    'dimgray': (105, 105, 105),\n    'dimgrey': (105, 105, 105),\n    'dodgerblue': (30, 144, 255),\n    'firebrick': (178, 34, 34),\n    'floralwhite': (255, 250, 240),\n    'forestgreen': (34, 139, 34),\n    'fuchsia': (255, 0, 255),\n    'gainsboro': (220, 220, 220),\n    'ghostwhite': (248, 248, 255),\n    'gold': (255, 215, 0),\n    'goldenrod': (218, 165, 32),\n    'gray': (128, 128, 128),\n    'green': (0, 128, 0),\n    'greenyellow': (173, 255, 47),\n    'grey': (128, 128, 128),\n    'honeydew': (240, 255, 240),\n    'hotpink': (255, 105, 180),\n    'indianred': (205, 92, 92),\n    'indigo': (75, 0, 130),\n    'ivory': (255, 255, 240),\n    'khaki': (240, 230, 140),\n    'lavender': (230, 230, 250),\n    'lavenderblush': (255, 240, 245),\n    'lawngreen': (124, 252, 0),\n    'lemonchiffon': (255, 250, 205),\n    'lightblue': (173, 216, 230),\n    'lightcoral': (240, 128, 128),\n    'lightcyan': (224, 255, 255),\n    'lightgoldenrodyellow': (250, 250, 210),\n    'lightgray': (211, 211, 211),\n    'lightgreen': (144, 238, 144),\n    'lightgrey': (211, 211, 211),\n    'lightpink': (255, 182, 193),\n    'lightsalmon': (255, 160, 122),\n    'lightseagreen': (32, 178, 170),\n    'lightskyblue': (135, 206, 250),\n    'lightslategray': (119, 136, 153),\n    'lightslategrey': (119, 136, 153),\n    'lightsteelblue': (176, 196, 222),\n    'lightyellow': (255, 255, 224),\n    'lime': (0, 255, 0),\n    'limegreen': (50, 205, 50),\n    'linen': (250, 240, 230),\n    'magenta': (255, 0, 255),\n    'maroon': (128, 0, 0),\n    'mediumaquamarine': (102, 205, 170),\n    'mediumblue': (0, 0, 205),\n    'mediumorchid': (186, 85, 211),\n    'mediumpurple': (147, 112, 219),\n    'mediumseagreen': (60, 179, 113),\n    'mediumslateblue': (123, 104, 238),\n    'mediumspringgreen': (0, 250, 154),\n    'mediumturquoise': (72, 209, 204),\n    'mediumvioletred': (199, 21, 133),\n    'midnightblue': (25, 25, 112),\n    'mintcream': (245, 255, 250),\n    'mistyrose': (255, 228, 225),\n    'moccasin': (255, 228, 181),\n    'navajowhite': (255, 222, 173),\n    'navy': (0, 0, 128),\n    'oldlace': (253, 245, 230),\n    'olive': (128, 128, 0),\n    'olivedrab': (107, 142, 35),\n    'orange': (255, 165, 0),\n    'orangered': (255, 69, 0),\n    'orchid': (218, 112, 214),\n    'palegoldenrod': (238, 232, 170),\n    'palegreen': (152, 251, 152),\n    'paleturquoise': (175, 238, 238),\n    'palevioletred': (219, 112, 147),\n    'papayawhip': (255, 239, 213),\n    'peachpuff': (255, 218, 185),\n    'peru': (205, 133, 63),\n    'pink': (255, 192, 203),\n    'plum': (221, 160, 221),\n    'powderblue': (176, 224, 230),\n    'purple': (128, 0, 128),\n    'red': (255, 0, 0),\n    'rosybrown': (188, 143, 143),\n    'royalblue': (65, 105, 225),\n    'saddlebrown': (139, 69, 19),\n    'salmon': (250, 128, 114),\n    'sandybrown': (244, 164, 96),\n    'seagreen': (46, 139, 87),\n    'seashell': (255, 245, 238),\n    'sienna': (160, 82, 45),\n    'silver': (192, 192, 192),\n    'skyblue': (135, 206, 235),\n    'slateblue': (106, 90, 205),\n    'slategray': (112, 128, 144),\n    'slategrey': (112, 128, 144),\n    'snow': (255, 250, 250),\n    'springgreen': (0, 255, 127),\n    'steelblue': (70, 130, 180),\n    'tan': (210, 180, 140),\n    'teal': (0, 128, 128),\n    'thistle': (216, 191, 216),\n    'tomato': (255, 99, 71),\n    'turquoise': (64, 224, 208),\n    'violet': (238, 130, 238),\n    'wheat': (245, 222, 179),\n    'white': (255, 255, 255),\n    'whitesmoke': (245, 245, 245),\n    'yellow': (255, 255, 0),\n    'yellowgreen': (154, 205, 50),\n}\n\nCOLORS_BY_VALUE = {v: k for k, v in COLORS_BY_NAME.items()}\n", "pydantic/v1/config.py": "import json\nfrom enum import Enum\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, ForwardRef, Optional, Tuple, Type, Union\n\nfrom typing_extensions import Literal, Protocol\n\nfrom pydantic.v1.typing import AnyArgTCallable, AnyCallable\nfrom pydantic.v1.utils import GetterDict\nfrom pydantic.v1.version import compiled\n\nif TYPE_CHECKING:\n    from typing import overload\n\n    from pydantic.v1.fields import ModelField\n    from pydantic.v1.main import BaseModel\n\n    ConfigType = Type['BaseConfig']\n\n    class SchemaExtraCallable(Protocol):\n        @overload\n        def __call__(self, schema: Dict[str, Any]) -> None:\n            pass\n\n        @overload\n        def __call__(self, schema: Dict[str, Any], model_class: Type[BaseModel]) -> None:\n            pass\n\nelse:\n    SchemaExtraCallable = Callable[..., None]\n\n__all__ = 'BaseConfig', 'ConfigDict', 'get_config', 'Extra', 'inherit_config', 'prepare_config'\n\n\nclass Extra(str, Enum):\n    allow = 'allow'\n    ignore = 'ignore'\n    forbid = 'forbid'\n\n\n# https://github.com/cython/cython/issues/4003\n# Fixed in Cython 3 and Pydantic v1 won't support Cython 3.\n# Pydantic v2 doesn't depend on Cython at all.\nif not compiled:\n    from typing_extensions import TypedDict\n\n    class ConfigDict(TypedDict, total=False):\n        title: Optional[str]\n        anystr_lower: bool\n        anystr_strip_whitespace: bool\n        min_anystr_length: int\n        max_anystr_length: Optional[int]\n        validate_all: bool\n        extra: Extra\n        allow_mutation: bool\n        frozen: bool\n        allow_population_by_field_name: bool\n        use_enum_values: bool\n        fields: Dict[str, Union[str, Dict[str, str]]]\n        validate_assignment: bool\n        error_msg_templates: Dict[str, str]\n        arbitrary_types_allowed: bool\n        orm_mode: bool\n        getter_dict: Type[GetterDict]\n        alias_generator: Optional[Callable[[str], str]]\n        keep_untouched: Tuple[type, ...]\n        schema_extra: Union[Dict[str, object], 'SchemaExtraCallable']\n        json_loads: Callable[[str], object]\n        json_dumps: AnyArgTCallable[str]\n        json_encoders: Dict[Type[object], AnyCallable]\n        underscore_attrs_are_private: bool\n        allow_inf_nan: bool\n        copy_on_model_validation: Literal['none', 'deep', 'shallow']\n        # whether dataclass `__post_init__` should be run after validation\n        post_init_call: Literal['before_validation', 'after_validation']\n\nelse:\n    ConfigDict = dict  # type: ignore\n\n\nclass BaseConfig:\n    title: Optional[str] = None\n    anystr_lower: bool = False\n    anystr_upper: bool = False\n    anystr_strip_whitespace: bool = False\n    min_anystr_length: int = 0\n    max_anystr_length: Optional[int] = None\n    validate_all: bool = False\n    extra: Extra = Extra.ignore\n    allow_mutation: bool = True\n    frozen: bool = False\n    allow_population_by_field_name: bool = False\n    use_enum_values: bool = False\n    fields: Dict[str, Union[str, Dict[str, str]]] = {}\n    validate_assignment: bool = False\n    error_msg_templates: Dict[str, str] = {}\n    arbitrary_types_allowed: bool = False\n    orm_mode: bool = False\n    getter_dict: Type[GetterDict] = GetterDict\n    alias_generator: Optional[Callable[[str], str]] = None\n    keep_untouched: Tuple[type, ...] = ()\n    schema_extra: Union[Dict[str, Any], 'SchemaExtraCallable'] = {}\n    json_loads: Callable[[str], Any] = json.loads\n    json_dumps: Callable[..., str] = json.dumps\n    json_encoders: Dict[Union[Type[Any], str, ForwardRef], AnyCallable] = {}\n    underscore_attrs_are_private: bool = False\n    allow_inf_nan: bool = True\n\n    # whether inherited models as fields should be reconstructed as base model,\n    # and whether such a copy should be shallow or deep\n    copy_on_model_validation: Literal['none', 'deep', 'shallow'] = 'shallow'\n\n    # whether `Union` should check all allowed types before even trying to coerce\n    smart_union: bool = False\n    # whether dataclass `__post_init__` should be run before or after validation\n    post_init_call: Literal['before_validation', 'after_validation'] = 'before_validation'\n\n    @classmethod\n    def get_field_info(cls, name: str) -> Dict[str, Any]:\n        \"\"\"\n        Get properties of FieldInfo from the `fields` property of the config class.\n        \"\"\"\n\n        fields_value = cls.fields.get(name)\n\n        if isinstance(fields_value, str):\n            field_info: Dict[str, Any] = {'alias': fields_value}\n        elif isinstance(fields_value, dict):\n            field_info = fields_value\n        else:\n            field_info = {}\n\n        if 'alias' in field_info:\n            field_info.setdefault('alias_priority', 2)\n\n        if field_info.get('alias_priority', 0) <= 1 and cls.alias_generator:\n            alias = cls.alias_generator(name)\n            if not isinstance(alias, str):\n                raise TypeError(f'Config.alias_generator must return str, not {alias.__class__}')\n            field_info.update(alias=alias, alias_priority=1)\n        return field_info\n\n    @classmethod\n    def prepare_field(cls, field: 'ModelField') -> None:\n        \"\"\"\n        Optional hook to check or modify fields during model creation.\n        \"\"\"\n        pass\n\n\ndef get_config(config: Union[ConfigDict, Type[object], None]) -> Type[BaseConfig]:\n    if config is None:\n        return BaseConfig\n\n    else:\n        config_dict = (\n            config\n            if isinstance(config, dict)\n            else {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}\n        )\n\n        class Config(BaseConfig):\n            ...\n\n        for k, v in config_dict.items():\n            setattr(Config, k, v)\n        return Config\n\n\ndef inherit_config(self_config: 'ConfigType', parent_config: 'ConfigType', **namespace: Any) -> 'ConfigType':\n    if not self_config:\n        base_classes: Tuple['ConfigType', ...] = (parent_config,)\n    elif self_config == parent_config:\n        base_classes = (self_config,)\n    else:\n        base_classes = self_config, parent_config\n\n    namespace['json_encoders'] = {\n        **getattr(parent_config, 'json_encoders', {}),\n        **getattr(self_config, 'json_encoders', {}),\n        **namespace.get('json_encoders', {}),\n    }\n\n    return type('Config', base_classes, namespace)\n\n\ndef prepare_config(config: Type[BaseConfig], cls_name: str) -> None:\n    if not isinstance(config.extra, Extra):\n        try:\n            config.extra = Extra(config.extra)\n        except ValueError:\n            raise ValueError(f'\"{cls_name}\": {config.extra} is not a valid value for \"extra\"')\n", "pydantic/v1/env_settings.py": "import os\nimport warnings\nfrom pathlib import Path\nfrom typing import AbstractSet, Any, Callable, ClassVar, Dict, List, Mapping, Optional, Tuple, Type, Union\n\nfrom pydantic.v1.config import BaseConfig, Extra\nfrom pydantic.v1.fields import ModelField\nfrom pydantic.v1.main import BaseModel\nfrom pydantic.v1.types import JsonWrapper\nfrom pydantic.v1.typing import StrPath, display_as_type, get_origin, is_union\nfrom pydantic.v1.utils import deep_update, lenient_issubclass, path_type, sequence_like\n\nenv_file_sentinel = str(object())\n\nSettingsSourceCallable = Callable[['BaseSettings'], Dict[str, Any]]\nDotenvType = Union[StrPath, List[StrPath], Tuple[StrPath, ...]]\n\n\nclass SettingsError(ValueError):\n    pass\n\n\nclass BaseSettings(BaseModel):\n    \"\"\"\n    Base class for settings, allowing values to be overridden by environment variables.\n\n    This is useful in production for secrets you do not wish to save in code, it plays nicely with docker(-compose),\n    Heroku and any 12 factor app design.\n    \"\"\"\n\n    def __init__(\n        __pydantic_self__,\n        _env_file: Optional[DotenvType] = env_file_sentinel,\n        _env_file_encoding: Optional[str] = None,\n        _env_nested_delimiter: Optional[str] = None,\n        _secrets_dir: Optional[StrPath] = None,\n        **values: Any,\n    ) -> None:\n        # Uses something other than `self` the first arg to allow \"self\" as a settable attribute\n        super().__init__(\n            **__pydantic_self__._build_values(\n                values,\n                _env_file=_env_file,\n                _env_file_encoding=_env_file_encoding,\n                _env_nested_delimiter=_env_nested_delimiter,\n                _secrets_dir=_secrets_dir,\n            )\n        )\n\n    def _build_values(\n        self,\n        init_kwargs: Dict[str, Any],\n        _env_file: Optional[DotenvType] = None,\n        _env_file_encoding: Optional[str] = None,\n        _env_nested_delimiter: Optional[str] = None,\n        _secrets_dir: Optional[StrPath] = None,\n    ) -> Dict[str, Any]:\n        # Configure built-in sources\n        init_settings = InitSettingsSource(init_kwargs=init_kwargs)\n        env_settings = EnvSettingsSource(\n            env_file=(_env_file if _env_file != env_file_sentinel else self.__config__.env_file),\n            env_file_encoding=(\n                _env_file_encoding if _env_file_encoding is not None else self.__config__.env_file_encoding\n            ),\n            env_nested_delimiter=(\n                _env_nested_delimiter if _env_nested_delimiter is not None else self.__config__.env_nested_delimiter\n            ),\n            env_prefix_len=len(self.__config__.env_prefix),\n        )\n        file_secret_settings = SecretsSettingsSource(secrets_dir=_secrets_dir or self.__config__.secrets_dir)\n        # Provide a hook to set built-in sources priority and add / remove sources\n        sources = self.__config__.customise_sources(\n            init_settings=init_settings, env_settings=env_settings, file_secret_settings=file_secret_settings\n        )\n        if sources:\n            return deep_update(*reversed([source(self) for source in sources]))\n        else:\n            # no one should mean to do this, but I think returning an empty dict is marginally preferable\n            # to an informative error and much better than a confusing error\n            return {}\n\n    class Config(BaseConfig):\n        env_prefix: str = ''\n        env_file: Optional[DotenvType] = None\n        env_file_encoding: Optional[str] = None\n        env_nested_delimiter: Optional[str] = None\n        secrets_dir: Optional[StrPath] = None\n        validate_all: bool = True\n        extra: Extra = Extra.forbid\n        arbitrary_types_allowed: bool = True\n        case_sensitive: bool = False\n\n        @classmethod\n        def prepare_field(cls, field: ModelField) -> None:\n            env_names: Union[List[str], AbstractSet[str]]\n            field_info_from_config = cls.get_field_info(field.name)\n\n            env = field_info_from_config.get('env') or field.field_info.extra.get('env')\n            if env is None:\n                if field.has_alias:\n                    warnings.warn(\n                        'aliases are no longer used by BaseSettings to define which environment variables to read. '\n                        'Instead use the \"env\" field setting. '\n                        'See https://pydantic-docs.helpmanual.io/usage/settings/#environment-variable-names',\n                        FutureWarning,\n                    )\n                env_names = {cls.env_prefix + field.name}\n            elif isinstance(env, str):\n                env_names = {env}\n            elif isinstance(env, (set, frozenset)):\n                env_names = env\n            elif sequence_like(env):\n                env_names = list(env)\n            else:\n                raise TypeError(f'invalid field env: {env!r} ({display_as_type(env)}); should be string, list or set')\n\n            if not cls.case_sensitive:\n                env_names = env_names.__class__(n.lower() for n in env_names)\n            field.field_info.extra['env_names'] = env_names\n\n        @classmethod\n        def customise_sources(\n            cls,\n            init_settings: SettingsSourceCallable,\n            env_settings: SettingsSourceCallable,\n            file_secret_settings: SettingsSourceCallable,\n        ) -> Tuple[SettingsSourceCallable, ...]:\n            return init_settings, env_settings, file_secret_settings\n\n        @classmethod\n        def parse_env_var(cls, field_name: str, raw_val: str) -> Any:\n            return cls.json_loads(raw_val)\n\n    # populated by the metaclass using the Config class defined above, annotated here to help IDEs only\n    __config__: ClassVar[Type[Config]]\n\n\nclass InitSettingsSource:\n    __slots__ = ('init_kwargs',)\n\n    def __init__(self, init_kwargs: Dict[str, Any]):\n        self.init_kwargs = init_kwargs\n\n    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:\n        return self.init_kwargs\n\n    def __repr__(self) -> str:\n        return f'InitSettingsSource(init_kwargs={self.init_kwargs!r})'\n\n\nclass EnvSettingsSource:\n    __slots__ = ('env_file', 'env_file_encoding', 'env_nested_delimiter', 'env_prefix_len')\n\n    def __init__(\n        self,\n        env_file: Optional[DotenvType],\n        env_file_encoding: Optional[str],\n        env_nested_delimiter: Optional[str] = None,\n        env_prefix_len: int = 0,\n    ):\n        self.env_file: Optional[DotenvType] = env_file\n        self.env_file_encoding: Optional[str] = env_file_encoding\n        self.env_nested_delimiter: Optional[str] = env_nested_delimiter\n        self.env_prefix_len: int = env_prefix_len\n\n    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:  # noqa C901\n        \"\"\"\n        Build environment variables suitable for passing to the Model.\n        \"\"\"\n        d: Dict[str, Any] = {}\n\n        if settings.__config__.case_sensitive:\n            env_vars: Mapping[str, Optional[str]] = os.environ\n        else:\n            env_vars = {k.lower(): v for k, v in os.environ.items()}\n\n        dotenv_vars = self._read_env_files(settings.__config__.case_sensitive)\n        if dotenv_vars:\n            env_vars = {**dotenv_vars, **env_vars}\n\n        for field in settings.__fields__.values():\n            env_val: Optional[str] = None\n            for env_name in field.field_info.extra['env_names']:\n                env_val = env_vars.get(env_name)\n                if env_val is not None:\n                    break\n\n            is_complex, allow_parse_failure = self.field_is_complex(field)\n            if is_complex:\n                if env_val is None:\n                    # field is complex but no value found so far, try explode_env_vars\n                    env_val_built = self.explode_env_vars(field, env_vars)\n                    if env_val_built:\n                        d[field.alias] = env_val_built\n                else:\n                    # field is complex and there's a value, decode that as JSON, then add explode_env_vars\n                    try:\n                        env_val = settings.__config__.parse_env_var(field.name, env_val)\n                    except ValueError as e:\n                        if not allow_parse_failure:\n                            raise SettingsError(f'error parsing env var \"{env_name}\"') from e\n\n                    if isinstance(env_val, dict):\n                        d[field.alias] = deep_update(env_val, self.explode_env_vars(field, env_vars))\n                    else:\n                        d[field.alias] = env_val\n            elif env_val is not None:\n                # simplest case, field is not complex, we only need to add the value if it was found\n                d[field.alias] = env_val\n\n        return d\n\n    def _read_env_files(self, case_sensitive: bool) -> Dict[str, Optional[str]]:\n        env_files = self.env_file\n        if env_files is None:\n            return {}\n\n        if isinstance(env_files, (str, os.PathLike)):\n            env_files = [env_files]\n\n        dotenv_vars = {}\n        for env_file in env_files:\n            env_path = Path(env_file).expanduser()\n            if env_path.is_file():\n                dotenv_vars.update(\n                    read_env_file(env_path, encoding=self.env_file_encoding, case_sensitive=case_sensitive)\n                )\n\n        return dotenv_vars\n\n    def field_is_complex(self, field: ModelField) -> Tuple[bool, bool]:\n        \"\"\"\n        Find out if a field is complex, and if so whether JSON errors should be ignored\n        \"\"\"\n        if lenient_issubclass(field.annotation, JsonWrapper):\n            return False, False\n\n        if field.is_complex():\n            allow_parse_failure = False\n        elif is_union(get_origin(field.type_)) and field.sub_fields and any(f.is_complex() for f in field.sub_fields):\n            allow_parse_failure = True\n        else:\n            return False, False\n\n        return True, allow_parse_failure\n\n    def explode_env_vars(self, field: ModelField, env_vars: Mapping[str, Optional[str]]) -> Dict[str, Any]:\n        \"\"\"\n        Process env_vars and extract the values of keys containing env_nested_delimiter into nested dictionaries.\n\n        This is applied to a single field, hence filtering by env_var prefix.\n        \"\"\"\n        prefixes = [f'{env_name}{self.env_nested_delimiter}' for env_name in field.field_info.extra['env_names']]\n        result: Dict[str, Any] = {}\n        for env_name, env_val in env_vars.items():\n            if not any(env_name.startswith(prefix) for prefix in prefixes):\n                continue\n            # we remove the prefix before splitting in case the prefix has characters in common with the delimiter\n            env_name_without_prefix = env_name[self.env_prefix_len :]\n            _, *keys, last_key = env_name_without_prefix.split(self.env_nested_delimiter)\n            env_var = result\n            for key in keys:\n                env_var = env_var.setdefault(key, {})\n            env_var[last_key] = env_val\n\n        return result\n\n    def __repr__(self) -> str:\n        return (\n            f'EnvSettingsSource(env_file={self.env_file!r}, env_file_encoding={self.env_file_encoding!r}, '\n            f'env_nested_delimiter={self.env_nested_delimiter!r})'\n        )\n\n\nclass SecretsSettingsSource:\n    __slots__ = ('secrets_dir',)\n\n    def __init__(self, secrets_dir: Optional[StrPath]):\n        self.secrets_dir: Optional[StrPath] = secrets_dir\n\n    def __call__(self, settings: BaseSettings) -> Dict[str, Any]:\n        \"\"\"\n        Build fields from \"secrets\" files.\n        \"\"\"\n        secrets: Dict[str, Optional[str]] = {}\n\n        if self.secrets_dir is None:\n            return secrets\n\n        secrets_path = Path(self.secrets_dir).expanduser()\n\n        if not secrets_path.exists():\n            warnings.warn(f'directory \"{secrets_path}\" does not exist')\n            return secrets\n\n        if not secrets_path.is_dir():\n            raise SettingsError(f'secrets_dir must reference a directory, not a {path_type(secrets_path)}')\n\n        for field in settings.__fields__.values():\n            for env_name in field.field_info.extra['env_names']:\n                path = find_case_path(secrets_path, env_name, settings.__config__.case_sensitive)\n                if not path:\n                    # path does not exist, we currently don't return a warning for this\n                    continue\n\n                if path.is_file():\n                    secret_value = path.read_text().strip()\n                    if field.is_complex():\n                        try:\n                            secret_value = settings.__config__.parse_env_var(field.name, secret_value)\n                        except ValueError as e:\n                            raise SettingsError(f'error parsing env var \"{env_name}\"') from e\n\n                    secrets[field.alias] = secret_value\n                else:\n                    warnings.warn(\n                        f'attempted to load secret file \"{path}\" but found a {path_type(path)} instead.',\n                        stacklevel=4,\n                    )\n        return secrets\n\n    def __repr__(self) -> str:\n        return f'SecretsSettingsSource(secrets_dir={self.secrets_dir!r})'\n\n\ndef read_env_file(\n    file_path: StrPath, *, encoding: str = None, case_sensitive: bool = False\n) -> Dict[str, Optional[str]]:\n    try:\n        from dotenv import dotenv_values\n    except ImportError as e:\n        raise ImportError('python-dotenv is not installed, run `pip install pydantic[dotenv]`') from e\n\n    file_vars: Dict[str, Optional[str]] = dotenv_values(file_path, encoding=encoding or 'utf8')\n    if not case_sensitive:\n        return {k.lower(): v for k, v in file_vars.items()}\n    else:\n        return file_vars\n\n\ndef find_case_path(dir_path: Path, file_name: str, case_sensitive: bool) -> Optional[Path]:\n    \"\"\"\n    Find a file within path's directory matching filename, optionally ignoring case.\n    \"\"\"\n    for f in dir_path.iterdir():\n        if f.name == file_name:\n            return f\n        elif not case_sensitive and f.name.lower() == file_name.lower():\n            return f\n    return None\n", "pydantic/v1/typing.py": "import sys\nimport typing\nfrom collections.abc import Callable\nfrom os import PathLike\nfrom typing import (  # type: ignore\n    TYPE_CHECKING,\n    AbstractSet,\n    Any,\n    Callable as TypingCallable,\n    ClassVar,\n    Dict,\n    ForwardRef,\n    Generator,\n    Iterable,\n    List,\n    Mapping,\n    NewType,\n    Optional,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    _eval_type,\n    cast,\n    get_type_hints,\n)\n\nfrom typing_extensions import (\n    Annotated,\n    Final,\n    Literal,\n    NotRequired as TypedDictNotRequired,\n    Required as TypedDictRequired,\n)\n\ntry:\n    from typing import _TypingBase as typing_base  # type: ignore\nexcept ImportError:\n    from typing import _Final as typing_base  # type: ignore\n\ntry:\n    from typing import GenericAlias as TypingGenericAlias  # type: ignore\nexcept ImportError:\n    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n    TypingGenericAlias = ()\n\ntry:\n    from types import UnionType as TypesUnionType  # type: ignore\nexcept ImportError:\n    # python < 3.10 does not have UnionType (str | int, byte | bool and so on)\n    TypesUnionType = ()\n\n\nif sys.version_info < (3, 9):\n\n    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n        return type_._evaluate(globalns, localns)\n\nelse:\n\n    def evaluate_forwardref(type_: ForwardRef, globalns: Any, localns: Any) -> Any:\n        # Even though it is the right signature for python 3.9, mypy complains with\n        # `error: Too many arguments for \"_evaluate\" of \"ForwardRef\"` hence the cast...\n        # Python 3.13/3.12.4+ made `recursive_guard` a kwarg, so name it explicitly to avoid:\n        # TypeError: ForwardRef._evaluate() missing 1 required keyword-only argument: 'recursive_guard'\n        return cast(Any, type_)._evaluate(globalns, localns, recursive_guard=set())\n\n\nif sys.version_info < (3, 9):\n    # Ensure we always get all the whole `Annotated` hint, not just the annotated type.\n    # For 3.7 to 3.8, `get_type_hints` doesn't recognize `typing_extensions.Annotated`,\n    # so it already returns the full annotation\n    get_all_type_hints = get_type_hints\n\nelse:\n\n    def get_all_type_hints(obj: Any, globalns: Any = None, localns: Any = None) -> Any:\n        return get_type_hints(obj, globalns, localns, include_extras=True)\n\n\n_T = TypeVar('_T')\n\nAnyCallable = TypingCallable[..., Any]\nNoArgAnyCallable = TypingCallable[[], Any]\n\n# workaround for https://github.com/python/mypy/issues/9496\nAnyArgTCallable = TypingCallable[..., _T]\n\n\n# Annotated[...] is implemented by returning an instance of one of these classes, depending on\n# python/typing_extensions version.\nAnnotatedTypeNames = {'AnnotatedMeta', '_AnnotatedAlias'}\n\n\nLITERAL_TYPES: Set[Any] = {Literal}\nif hasattr(typing, 'Literal'):\n    LITERAL_TYPES.add(typing.Literal)\n\n\nif sys.version_info < (3, 8):\n\n    def get_origin(t: Type[Any]) -> Optional[Type[Any]]:\n        if type(t).__name__ in AnnotatedTypeNames:\n            # weirdly this is a runtime requirement, as well as for mypy\n            return cast(Type[Any], Annotated)\n        return getattr(t, '__origin__', None)\n\nelse:\n    from typing import get_origin as _typing_get_origin\n\n    def get_origin(tp: Type[Any]) -> Optional[Type[Any]]:\n        \"\"\"\n        We can't directly use `typing.get_origin` since we need a fallback to support\n        custom generic classes like `ConstrainedList`\n        It should be useless once https://github.com/cython/cython/issues/3537 is\n        solved and https://github.com/pydantic/pydantic/pull/1753 is merged.\n        \"\"\"\n        if type(tp).__name__ in AnnotatedTypeNames:\n            return cast(Type[Any], Annotated)  # mypy complains about _SpecialForm\n        return _typing_get_origin(tp) or getattr(tp, '__origin__', None)\n\n\nif sys.version_info < (3, 8):\n    from typing import _GenericAlias\n\n    def get_args(t: Type[Any]) -> Tuple[Any, ...]:\n        \"\"\"Compatibility version of get_args for python 3.7.\n\n        Mostly compatible with the python 3.8 `typing` module version\n        and able to handle almost all use cases.\n        \"\"\"\n        if type(t).__name__ in AnnotatedTypeNames:\n            return t.__args__ + t.__metadata__\n        if isinstance(t, _GenericAlias):\n            res = t.__args__\n            if t.__origin__ is Callable and res and res[0] is not Ellipsis:\n                res = (list(res[:-1]), res[-1])\n            return res\n        return getattr(t, '__args__', ())\n\nelse:\n    from typing import get_args as _typing_get_args\n\n    def _generic_get_args(tp: Type[Any]) -> Tuple[Any, ...]:\n        \"\"\"\n        In python 3.9, `typing.Dict`, `typing.List`, ...\n        do have an empty `__args__` by default (instead of the generic ~T for example).\n        In order to still support `Dict` for example and consider it as `Dict[Any, Any]`,\n        we retrieve the `_nparams` value that tells us how many parameters it needs.\n        \"\"\"\n        if hasattr(tp, '_nparams'):\n            return (Any,) * tp._nparams\n        # Special case for `tuple[()]`, which used to return ((),) with `typing.Tuple`\n        # in python 3.10- but now returns () for `tuple` and `Tuple`.\n        # This will probably be clarified in pydantic v2\n        try:\n            if tp == Tuple[()] or sys.version_info >= (3, 9) and tp == tuple[()]:  # type: ignore[misc]\n                return ((),)\n        # there is a TypeError when compiled with cython\n        except TypeError:  # pragma: no cover\n            pass\n        return ()\n\n    def get_args(tp: Type[Any]) -> Tuple[Any, ...]:\n        \"\"\"Get type arguments with all substitutions performed.\n\n        For unions, basic simplifications used by Union constructor are performed.\n        Examples::\n            get_args(Dict[str, int]) == (str, int)\n            get_args(int) == ()\n            get_args(Union[int, Union[T, int], str][int]) == (int, str)\n            get_args(Union[int, Tuple[T, int]][str]) == (int, Tuple[str, int])\n            get_args(Callable[[], T][int]) == ([], int)\n        \"\"\"\n        if type(tp).__name__ in AnnotatedTypeNames:\n            return tp.__args__ + tp.__metadata__\n        # the fallback is needed for the same reasons as `get_origin` (see above)\n        return _typing_get_args(tp) or getattr(tp, '__args__', ()) or _generic_get_args(tp)\n\n\nif sys.version_info < (3, 9):\n\n    def convert_generics(tp: Type[Any]) -> Type[Any]:\n        \"\"\"Python 3.9 and older only supports generics from `typing` module.\n        They convert strings to ForwardRef automatically.\n\n        Examples::\n            typing.List['Hero'] == typing.List[ForwardRef('Hero')]\n        \"\"\"\n        return tp\n\nelse:\n    from typing import _UnionGenericAlias  # type: ignore\n\n    from typing_extensions import _AnnotatedAlias\n\n    def convert_generics(tp: Type[Any]) -> Type[Any]:\n        \"\"\"\n        Recursively searches for `str` type hints and replaces them with ForwardRef.\n\n        Examples::\n            convert_generics(list['Hero']) == list[ForwardRef('Hero')]\n            convert_generics(dict['Hero', 'Team']) == dict[ForwardRef('Hero'), ForwardRef('Team')]\n            convert_generics(typing.Dict['Hero', 'Team']) == typing.Dict[ForwardRef('Hero'), ForwardRef('Team')]\n            convert_generics(list[str | 'Hero'] | int) == list[str | ForwardRef('Hero')] | int\n        \"\"\"\n        origin = get_origin(tp)\n        if not origin or not hasattr(tp, '__args__'):\n            return tp\n\n        args = get_args(tp)\n\n        # typing.Annotated needs special treatment\n        if origin is Annotated:\n            return _AnnotatedAlias(convert_generics(args[0]), args[1:])\n\n        # recursively replace `str` instances inside of `GenericAlias` with `ForwardRef(arg)`\n        converted = tuple(\n            ForwardRef(arg) if isinstance(arg, str) and isinstance(tp, TypingGenericAlias) else convert_generics(arg)\n            for arg in args\n        )\n\n        if converted == args:\n            return tp\n        elif isinstance(tp, TypingGenericAlias):\n            return TypingGenericAlias(origin, converted)\n        elif isinstance(tp, TypesUnionType):\n            # recreate types.UnionType (PEP604, Python >= 3.10)\n            return _UnionGenericAlias(origin, converted)\n        else:\n            try:\n                setattr(tp, '__args__', converted)\n            except AttributeError:\n                pass\n            return tp\n\n\nif sys.version_info < (3, 10):\n\n    def is_union(tp: Optional[Type[Any]]) -> bool:\n        return tp is Union\n\n    WithArgsTypes = (TypingGenericAlias,)\n\nelse:\n    import types\n    import typing\n\n    def is_union(tp: Optional[Type[Any]]) -> bool:\n        return tp is Union or tp is types.UnionType  # noqa: E721\n\n    WithArgsTypes = (typing._GenericAlias, types.GenericAlias, types.UnionType)\n\n\nStrPath = Union[str, PathLike]\n\n\nif TYPE_CHECKING:\n    from pydantic.v1.fields import ModelField\n\n    TupleGenerator = Generator[Tuple[str, Any], None, None]\n    DictStrAny = Dict[str, Any]\n    DictAny = Dict[Any, Any]\n    SetStr = Set[str]\n    ListStr = List[str]\n    IntStr = Union[int, str]\n    AbstractSetIntStr = AbstractSet[IntStr]\n    DictIntStrAny = Dict[IntStr, Any]\n    MappingIntStrAny = Mapping[IntStr, Any]\n    CallableGenerator = Generator[AnyCallable, None, None]\n    ReprArgs = Sequence[Tuple[Optional[str], Any]]\n\n    MYPY = False\n    if MYPY:\n        AnyClassMethod = classmethod[Any]\n    else:\n        # classmethod[TargetType, CallableParamSpecType, CallableReturnType]\n        AnyClassMethod = classmethod[Any, Any, Any]\n\n__all__ = (\n    'AnyCallable',\n    'NoArgAnyCallable',\n    'NoneType',\n    'is_none_type',\n    'display_as_type',\n    'resolve_annotations',\n    'is_callable_type',\n    'is_literal_type',\n    'all_literal_values',\n    'is_namedtuple',\n    'is_typeddict',\n    'is_typeddict_special',\n    'is_new_type',\n    'new_type_supertype',\n    'is_classvar',\n    'is_finalvar',\n    'update_field_forward_refs',\n    'update_model_forward_refs',\n    'TupleGenerator',\n    'DictStrAny',\n    'DictAny',\n    'SetStr',\n    'ListStr',\n    'IntStr',\n    'AbstractSetIntStr',\n    'DictIntStrAny',\n    'CallableGenerator',\n    'ReprArgs',\n    'AnyClassMethod',\n    'CallableGenerator',\n    'WithArgsTypes',\n    'get_args',\n    'get_origin',\n    'get_sub_types',\n    'typing_base',\n    'get_all_type_hints',\n    'is_union',\n    'StrPath',\n    'MappingIntStrAny',\n)\n\n\nNoneType = None.__class__\n\n\nNONE_TYPES: Tuple[Any, Any, Any] = (None, NoneType, Literal[None])\n\n\nif sys.version_info < (3, 8):\n    # Even though this implementation is slower, we need it for python 3.7:\n    # In python 3.7 \"Literal\" is not a builtin type and uses a different\n    # mechanism.\n    # for this reason `Literal[None] is Literal[None]` evaluates to `False`,\n    # breaking the faster implementation used for the other python versions.\n\n    def is_none_type(type_: Any) -> bool:\n        return type_ in NONE_TYPES\n\nelif sys.version_info[:2] == (3, 8):\n\n    def is_none_type(type_: Any) -> bool:\n        for none_type in NONE_TYPES:\n            if type_ is none_type:\n                return True\n        # With python 3.8, specifically 3.8.10, Literal \"is\" check sare very flakey\n        # can change on very subtle changes like use of types in other modules,\n        # hopefully this check avoids that issue.\n        if is_literal_type(type_):  # pragma: no cover\n            return all_literal_values(type_) == (None,)\n        return False\n\nelse:\n\n    def is_none_type(type_: Any) -> bool:\n        return type_ in NONE_TYPES\n\n\ndef display_as_type(v: Type[Any]) -> str:\n    if not isinstance(v, typing_base) and not isinstance(v, WithArgsTypes) and not isinstance(v, type):\n        v = v.__class__\n\n    if is_union(get_origin(v)):\n        return f'Union[{\", \".join(map(display_as_type, get_args(v)))}]'\n\n    if isinstance(v, WithArgsTypes):\n        # Generic alias are constructs like `list[int]`\n        return str(v).replace('typing.', '')\n\n    try:\n        return v.__name__\n    except AttributeError:\n        # happens with typing objects\n        return str(v).replace('typing.', '')\n\n\ndef resolve_annotations(raw_annotations: Dict[str, Type[Any]], module_name: Optional[str]) -> Dict[str, Type[Any]]:\n    \"\"\"\n    Partially taken from typing.get_type_hints.\n\n    Resolve string or ForwardRef annotations into type objects if possible.\n    \"\"\"\n    base_globals: Optional[Dict[str, Any]] = None\n    if module_name:\n        try:\n            module = sys.modules[module_name]\n        except KeyError:\n            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n            pass\n        else:\n            base_globals = module.__dict__\n\n    annotations = {}\n    for name, value in raw_annotations.items():\n        if isinstance(value, str):\n            if (3, 10) > sys.version_info >= (3, 9, 8) or sys.version_info >= (3, 10, 1):\n                value = ForwardRef(value, is_argument=False, is_class=True)\n            else:\n                value = ForwardRef(value, is_argument=False)\n        try:\n            value = _eval_type(value, base_globals, None)\n        except NameError:\n            # this is ok, it can be fixed with update_forward_refs\n            pass\n        annotations[name] = value\n    return annotations\n\n\ndef is_callable_type(type_: Type[Any]) -> bool:\n    return type_ is Callable or get_origin(type_) is Callable\n\n\ndef is_literal_type(type_: Type[Any]) -> bool:\n    return Literal is not None and get_origin(type_) in LITERAL_TYPES\n\n\ndef literal_values(type_: Type[Any]) -> Tuple[Any, ...]:\n    return get_args(type_)\n\n\ndef all_literal_values(type_: Type[Any]) -> Tuple[Any, ...]:\n    \"\"\"\n    This method is used to retrieve all Literal values as\n    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)\n    e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`\n    \"\"\"\n    if not is_literal_type(type_):\n        return (type_,)\n\n    values = literal_values(type_)\n    return tuple(x for value in values for x in all_literal_values(value))\n\n\ndef is_namedtuple(type_: Type[Any]) -> bool:\n    \"\"\"\n    Check if a given class is a named tuple.\n    It can be either a `typing.NamedTuple` or `collections.namedtuple`\n    \"\"\"\n    from pydantic.v1.utils import lenient_issubclass\n\n    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')\n\n\ndef is_typeddict(type_: Type[Any]) -> bool:\n    \"\"\"\n    Check if a given class is a typed dict (from `typing` or `typing_extensions`)\n    In 3.10, there will be a public method (https://docs.python.org/3.10/library/typing.html#typing.is_typeddict)\n    \"\"\"\n    from pydantic.v1.utils import lenient_issubclass\n\n    return lenient_issubclass(type_, dict) and hasattr(type_, '__total__')\n\n\ndef _check_typeddict_special(type_: Any) -> bool:\n    return type_ is TypedDictRequired or type_ is TypedDictNotRequired\n\n\ndef is_typeddict_special(type_: Any) -> bool:\n    \"\"\"\n    Check if type is a TypedDict special form (Required or NotRequired).\n    \"\"\"\n    return _check_typeddict_special(type_) or _check_typeddict_special(get_origin(type_))\n\n\ntest_type = NewType('test_type', str)\n\n\ndef is_new_type(type_: Type[Any]) -> bool:\n    \"\"\"\n    Check whether type_ was created using typing.NewType\n    \"\"\"\n    return isinstance(type_, test_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore\n\n\ndef new_type_supertype(type_: Type[Any]) -> Type[Any]:\n    while hasattr(type_, '__supertype__'):\n        type_ = type_.__supertype__\n    return type_\n\n\ndef _check_classvar(v: Optional[Type[Any]]) -> bool:\n    if v is None:\n        return False\n\n    return v.__class__ == ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'\n\n\ndef _check_finalvar(v: Optional[Type[Any]]) -> bool:\n    \"\"\"\n    Check if a given type is a `typing.Final` type.\n    \"\"\"\n    if v is None:\n        return False\n\n    return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')\n\n\ndef is_classvar(ann_type: Type[Any]) -> bool:\n    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):\n        return True\n\n    # this is an ugly workaround for class vars that contain forward references and are therefore themselves\n    # forward references, see #3679\n    if ann_type.__class__ == ForwardRef and ann_type.__forward_arg__.startswith('ClassVar['):\n        return True\n\n    return False\n\n\ndef is_finalvar(ann_type: Type[Any]) -> bool:\n    return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))\n\n\ndef update_field_forward_refs(field: 'ModelField', globalns: Any, localns: Any) -> None:\n    \"\"\"\n    Try to update ForwardRefs on fields based on this ModelField, globalns and localns.\n    \"\"\"\n    prepare = False\n    if field.type_.__class__ == ForwardRef:\n        prepare = True\n        field.type_ = evaluate_forwardref(field.type_, globalns, localns or None)\n    if field.outer_type_.__class__ == ForwardRef:\n        prepare = True\n        field.outer_type_ = evaluate_forwardref(field.outer_type_, globalns, localns or None)\n    if prepare:\n        field.prepare()\n\n    if field.sub_fields:\n        for sub_f in field.sub_fields:\n            update_field_forward_refs(sub_f, globalns=globalns, localns=localns)\n\n    if field.discriminator_key is not None:\n        field.prepare_discriminated_union_sub_fields()\n\n\ndef update_model_forward_refs(\n    model: Type[Any],\n    fields: Iterable['ModelField'],\n    json_encoders: Dict[Union[Type[Any], str, ForwardRef], AnyCallable],\n    localns: 'DictStrAny',\n    exc_to_suppress: Tuple[Type[BaseException], ...] = (),\n) -> None:\n    \"\"\"\n    Try to update model fields ForwardRefs based on model and localns.\n    \"\"\"\n    if model.__module__ in sys.modules:\n        globalns = sys.modules[model.__module__].__dict__.copy()\n    else:\n        globalns = {}\n\n    globalns.setdefault(model.__name__, model)\n\n    for f in fields:\n        try:\n            update_field_forward_refs(f, globalns=globalns, localns=localns)\n        except exc_to_suppress:\n            pass\n\n    for key in set(json_encoders.keys()):\n        if isinstance(key, str):\n            fr: ForwardRef = ForwardRef(key)\n        elif isinstance(key, ForwardRef):\n            fr = key\n        else:\n            continue\n\n        try:\n            new_key = evaluate_forwardref(fr, globalns, localns or None)\n        except exc_to_suppress:  # pragma: no cover\n            continue\n\n        json_encoders[new_key] = json_encoders.pop(key)\n\n\ndef get_class(type_: Type[Any]) -> Union[None, bool, Type[Any]]:\n    \"\"\"\n    Tries to get the class of a Type[T] annotation. Returns True if Type is used\n    without brackets. Otherwise returns None.\n    \"\"\"\n    if type_ is type:\n        return True\n\n    if get_origin(type_) is None:\n        return None\n\n    args = get_args(type_)\n    if not args or not isinstance(args[0], type):\n        return True\n    else:\n        return args[0]\n\n\ndef get_sub_types(tp: Any) -> List[Any]:\n    \"\"\"\n    Return all the types that are allowed by type `tp`\n    `tp` can be a `Union` of allowed types or an `Annotated` type\n    \"\"\"\n    origin = get_origin(tp)\n    if origin is Annotated:\n        return get_sub_types(get_args(tp)[0])\n    elif is_union(origin):\n        return [x for t in get_args(tp) for x in get_sub_types(t)]\n    else:\n        return [tp]\n", "pydantic/v1/parse.py": "import json\nimport pickle\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import Any, Callable, Union\n\nfrom pydantic.v1.types import StrBytes\n\n\nclass Protocol(str, Enum):\n    json = 'json'\n    pickle = 'pickle'\n\n\ndef load_str_bytes(\n    b: StrBytes,\n    *,\n    content_type: str = None,\n    encoding: str = 'utf8',\n    proto: Protocol = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n) -> Any:\n    if proto is None and content_type:\n        if content_type.endswith(('json', 'javascript')):\n            pass\n        elif allow_pickle and content_type.endswith('pickle'):\n            proto = Protocol.pickle\n        else:\n            raise TypeError(f'Unknown content-type: {content_type}')\n\n    proto = proto or Protocol.json\n\n    if proto == Protocol.json:\n        if isinstance(b, bytes):\n            b = b.decode(encoding)\n        return json_loads(b)\n    elif proto == Protocol.pickle:\n        if not allow_pickle:\n            raise RuntimeError('Trying to decode with pickle with allow_pickle=False')\n        bb = b if isinstance(b, bytes) else b.encode()\n        return pickle.loads(bb)\n    else:\n        raise TypeError(f'Unknown protocol: {proto}')\n\n\ndef load_file(\n    path: Union[str, Path],\n    *,\n    content_type: str = None,\n    encoding: str = 'utf8',\n    proto: Protocol = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n) -> Any:\n    path = Path(path)\n    b = path.read_bytes()\n    if content_type is None:\n        if path.suffix in ('.js', '.json'):\n            proto = Protocol.json\n        elif path.suffix == '.pkl':\n            proto = Protocol.pickle\n\n    return load_str_bytes(\n        b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads\n    )\n", "pydantic/v1/schema.py": "import re\nimport warnings\nfrom collections import defaultdict\nfrom dataclasses import is_dataclass\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    ForwardRef,\n    FrozenSet,\n    Generic,\n    Iterable,\n    List,\n    Optional,\n    Pattern,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n)\nfrom uuid import UUID\n\nfrom typing_extensions import Annotated, Literal\n\nfrom pydantic.v1.fields import (\n    MAPPING_LIKE_SHAPES,\n    SHAPE_DEQUE,\n    SHAPE_FROZENSET,\n    SHAPE_GENERIC,\n    SHAPE_ITERABLE,\n    SHAPE_LIST,\n    SHAPE_SEQUENCE,\n    SHAPE_SET,\n    SHAPE_SINGLETON,\n    SHAPE_TUPLE,\n    SHAPE_TUPLE_ELLIPSIS,\n    FieldInfo,\n    ModelField,\n)\nfrom pydantic.v1.json import pydantic_encoder\nfrom pydantic.v1.networks import AnyUrl, EmailStr\nfrom pydantic.v1.types import (\n    ConstrainedDecimal,\n    ConstrainedFloat,\n    ConstrainedFrozenSet,\n    ConstrainedInt,\n    ConstrainedList,\n    ConstrainedSet,\n    ConstrainedStr,\n    SecretBytes,\n    SecretStr,\n    StrictBytes,\n    StrictStr,\n    conbytes,\n    condecimal,\n    confloat,\n    confrozenset,\n    conint,\n    conlist,\n    conset,\n    constr,\n)\nfrom pydantic.v1.typing import (\n    all_literal_values,\n    get_args,\n    get_origin,\n    get_sub_types,\n    is_callable_type,\n    is_literal_type,\n    is_namedtuple,\n    is_none_type,\n    is_union,\n)\nfrom pydantic.v1.utils import ROOT_KEY, get_model, lenient_issubclass\n\nif TYPE_CHECKING:\n    from pydantic.v1.dataclasses import Dataclass\n    from pydantic.v1.main import BaseModel\n\ndefault_prefix = '#/definitions/'\ndefault_ref_template = '#/definitions/{model}'\n\nTypeModelOrEnum = Union[Type['BaseModel'], Type[Enum]]\nTypeModelSet = Set[TypeModelOrEnum]\n\n\ndef _apply_modify_schema(\n    modify_schema: Callable[..., None], field: Optional[ModelField], field_schema: Dict[str, Any]\n) -> None:\n    from inspect import signature\n\n    sig = signature(modify_schema)\n    args = set(sig.parameters.keys())\n    if 'field' in args or 'kwargs' in args:\n        modify_schema(field_schema, field=field)\n    else:\n        modify_schema(field_schema)\n\n\ndef schema(\n    models: Sequence[Union[Type['BaseModel'], Type['Dataclass']]],\n    *,\n    by_alias: bool = True,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    ref_prefix: Optional[str] = None,\n    ref_template: str = default_ref_template,\n) -> Dict[str, Any]:\n    \"\"\"\n    Process a list of models and generate a single JSON Schema with all of them defined in the ``definitions``\n    top-level JSON key, including their sub-models.\n\n    :param models: a list of models to include in the generated JSON Schema\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param title: title for the generated schema that includes the definitions\n    :param description: description for the generated schema\n    :param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the\n      default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere\n      else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the\n      top-level key ``definitions``, so you can extract them from there. But all the references will have the set\n      prefix.\n    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful\n      for references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For\n      a sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n    :return: dict with the JSON Schema with a ``definitions`` top-level key including the schema definitions for\n      the models and sub-models passed in ``models``.\n    \"\"\"\n    clean_models = [get_model(model) for model in models]\n    flat_models = get_flat_models_from_models(clean_models)\n    model_name_map = get_model_name_map(flat_models)\n    definitions = {}\n    output_schema: Dict[str, Any] = {}\n    if title:\n        output_schema['title'] = title\n    if description:\n        output_schema['description'] = description\n    for model in clean_models:\n        m_schema, m_definitions, m_nested_models = model_process_schema(\n            model,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n        )\n        definitions.update(m_definitions)\n        model_name = model_name_map[model]\n        definitions[model_name] = m_schema\n    if definitions:\n        output_schema['definitions'] = definitions\n    return output_schema\n\n\ndef model_schema(\n    model: Union[Type['BaseModel'], Type['Dataclass']],\n    by_alias: bool = True,\n    ref_prefix: Optional[str] = None,\n    ref_template: str = default_ref_template,\n) -> Dict[str, Any]:\n    \"\"\"\n    Generate a JSON Schema for one model. With all the sub-models defined in the ``definitions`` top-level\n    JSON key.\n\n    :param model: a Pydantic model (a class that inherits from BaseModel)\n    :param by_alias: generate the schemas using the aliases defined, if any\n    :param ref_prefix: the JSON Pointer prefix for schema references with ``$ref``, if None, will be set to the\n      default of ``#/definitions/``. Update it if you want the schemas to reference the definitions somewhere\n      else, e.g. for OpenAPI use ``#/components/schemas/``. The resulting generated schemas will still be at the\n      top-level key ``definitions``, so you can extract them from there. But all the references will have the set\n      prefix.\n    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for\n      references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a\n      sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n    :return: dict with the JSON Schema for the passed ``model``\n    \"\"\"\n    model = get_model(model)\n    flat_models = get_flat_models_from_model(model)\n    model_name_map = get_model_name_map(flat_models)\n    model_name = model_name_map[model]\n    m_schema, m_definitions, nested_models = model_process_schema(\n        model, by_alias=by_alias, model_name_map=model_name_map, ref_prefix=ref_prefix, ref_template=ref_template\n    )\n    if model_name in nested_models:\n        # model_name is in Nested models, it has circular references\n        m_definitions[model_name] = m_schema\n        m_schema = get_schema_ref(model_name, ref_prefix, ref_template, False)\n    if m_definitions:\n        m_schema.update({'definitions': m_definitions})\n    return m_schema\n\n\ndef get_field_info_schema(field: ModelField, schema_overrides: bool = False) -> Tuple[Dict[str, Any], bool]:\n    # If no title is explicitly set, we don't set title in the schema for enums.\n    # The behaviour is the same as `BaseModel` reference, where the default title\n    # is in the definitions part of the schema.\n    schema_: Dict[str, Any] = {}\n    if field.field_info.title or not lenient_issubclass(field.type_, Enum):\n        schema_['title'] = field.field_info.title or field.alias.title().replace('_', ' ')\n\n    if field.field_info.title:\n        schema_overrides = True\n\n    if field.field_info.description:\n        schema_['description'] = field.field_info.description\n        schema_overrides = True\n\n    if not field.required and field.default is not None and not is_callable_type(field.outer_type_):\n        schema_['default'] = encode_default(field.default)\n        schema_overrides = True\n\n    return schema_, schema_overrides\n\n\ndef field_schema(\n    field: ModelField,\n    *,\n    by_alias: bool = True,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_prefix: Optional[str] = None,\n    ref_template: str = default_ref_template,\n    known_models: Optional[TypeModelSet] = None,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    Process a Pydantic field and return a tuple with a JSON Schema for it as the first item.\n    Also return a dictionary of definitions with models as keys and their schemas as values. If the passed field\n    is a model and has sub-models, and those sub-models don't have overrides (as ``title``, ``default``, etc), they\n    will be included in the definitions and referenced in the schema instead of included recursively.\n\n    :param field: a Pydantic ``ModelField``\n    :param by_alias: use the defined alias (if any) in the returned schema\n    :param model_name_map: used to generate the JSON Schema references to other models included in the definitions\n    :param ref_prefix: the JSON Pointer prefix to use for references to other schemas, if None, the default of\n      #/definitions/ will be used\n    :param ref_template: Use a ``string.format()`` template for ``$ref`` instead of a prefix. This can be useful for\n      references that cannot be represented by ``ref_prefix`` such as a definition stored in another file. For a\n      sibling json file in a ``/schemas`` directory use ``\"/schemas/${model}.json#\"``.\n    :param known_models: used to solve circular references\n    :return: tuple of the schema for this field and additional definitions\n    \"\"\"\n    s, schema_overrides = get_field_info_schema(field)\n\n    validation_schema = get_field_schema_validations(field)\n    if validation_schema:\n        s.update(validation_schema)\n        schema_overrides = True\n\n    f_schema, f_definitions, f_nested_models = field_type_schema(\n        field,\n        by_alias=by_alias,\n        model_name_map=model_name_map,\n        schema_overrides=schema_overrides,\n        ref_prefix=ref_prefix,\n        ref_template=ref_template,\n        known_models=known_models or set(),\n    )\n\n    # $ref will only be returned when there are no schema_overrides\n    if '$ref' in f_schema:\n        return f_schema, f_definitions, f_nested_models\n    else:\n        s.update(f_schema)\n        return s, f_definitions, f_nested_models\n\n\nnumeric_types = (int, float, Decimal)\n_str_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...] = (\n    ('max_length', numeric_types, 'maxLength'),\n    ('min_length', numeric_types, 'minLength'),\n    ('regex', str, 'pattern'),\n)\n\n_numeric_types_attrs: Tuple[Tuple[str, Union[type, Tuple[type, ...]], str], ...] = (\n    ('gt', numeric_types, 'exclusiveMinimum'),\n    ('lt', numeric_types, 'exclusiveMaximum'),\n    ('ge', numeric_types, 'minimum'),\n    ('le', numeric_types, 'maximum'),\n    ('multiple_of', numeric_types, 'multipleOf'),\n)\n\n\ndef get_field_schema_validations(field: ModelField) -> Dict[str, Any]:\n    \"\"\"\n    Get the JSON Schema validation keywords for a ``field`` with an annotation of\n    a Pydantic ``FieldInfo`` with validation arguments.\n    \"\"\"\n    f_schema: Dict[str, Any] = {}\n\n    if lenient_issubclass(field.type_, Enum):\n        # schema is already updated by `enum_process_schema`; just update with field extra\n        if field.field_info.extra:\n            f_schema.update(field.field_info.extra)\n        return f_schema\n\n    if lenient_issubclass(field.type_, (str, bytes)):\n        for attr_name, t, keyword in _str_types_attrs:\n            attr = getattr(field.field_info, attr_name, None)\n            if isinstance(attr, t):\n                f_schema[keyword] = attr\n    if lenient_issubclass(field.type_, numeric_types) and not issubclass(field.type_, bool):\n        for attr_name, t, keyword in _numeric_types_attrs:\n            attr = getattr(field.field_info, attr_name, None)\n            if isinstance(attr, t):\n                f_schema[keyword] = attr\n    if field.field_info is not None and field.field_info.const:\n        f_schema['const'] = field.default\n    if field.field_info.extra:\n        f_schema.update(field.field_info.extra)\n    modify_schema = getattr(field.outer_type_, '__modify_schema__', None)\n    if modify_schema:\n        _apply_modify_schema(modify_schema, field, f_schema)\n    return f_schema\n\n\ndef get_model_name_map(unique_models: TypeModelSet) -> Dict[TypeModelOrEnum, str]:\n    \"\"\"\n    Process a set of models and generate unique names for them to be used as keys in the JSON Schema\n    definitions. By default the names are the same as the class name. But if two models in different Python\n    modules have the same name (e.g. \"users.Model\" and \"items.Model\"), the generated names will be\n    based on the Python module path for those conflicting models to prevent name collisions.\n\n    :param unique_models: a Python set of models\n    :return: dict mapping models to names\n    \"\"\"\n    name_model_map = {}\n    conflicting_names: Set[str] = set()\n    for model in unique_models:\n        model_name = normalize_name(model.__name__)\n        if model_name in conflicting_names:\n            model_name = get_long_model_name(model)\n            name_model_map[model_name] = model\n        elif model_name in name_model_map:\n            conflicting_names.add(model_name)\n            conflicting_model = name_model_map.pop(model_name)\n            name_model_map[get_long_model_name(conflicting_model)] = conflicting_model\n            name_model_map[get_long_model_name(model)] = model\n        else:\n            name_model_map[model_name] = model\n    return {v: k for k, v in name_model_map.items()}\n\n\ndef get_flat_models_from_model(model: Type['BaseModel'], known_models: Optional[TypeModelSet] = None) -> TypeModelSet:\n    \"\"\"\n    Take a single ``model`` and generate a set with itself and all the sub-models in the tree. I.e. if you pass\n    model ``Foo`` (subclass of Pydantic ``BaseModel``) as ``model``, and it has a field of type ``Bar`` (also\n    subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also subclass of ``BaseModel``),\n    the return value will be ``set([Foo, Bar, Baz])``.\n\n    :param model: a Pydantic ``BaseModel`` subclass\n    :param known_models: used to solve circular references\n    :return: a set with the initial model and all its sub-models\n    \"\"\"\n    known_models = known_models or set()\n    flat_models: TypeModelSet = set()\n    flat_models.add(model)\n    known_models |= flat_models\n    fields = cast(Sequence[ModelField], model.__fields__.values())\n    flat_models |= get_flat_models_from_fields(fields, known_models=known_models)\n    return flat_models\n\n\ndef get_flat_models_from_field(field: ModelField, known_models: TypeModelSet) -> TypeModelSet:\n    \"\"\"\n    Take a single Pydantic ``ModelField`` (from a model) that could have been declared as a subclass of BaseModel\n    (so, it could be a submodel), and generate a set with its model and all the sub-models in the tree.\n    I.e. if you pass a field that was declared to be of type ``Foo`` (subclass of BaseModel) as ``field``, and that\n    model ``Foo`` has a field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of\n    type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n\n    :param field: a Pydantic ``ModelField``\n    :param known_models: used to solve circular references\n    :return: a set with the model used in the declaration for this field, if any, and all its sub-models\n    \"\"\"\n    from pydantic.v1.main import BaseModel\n\n    flat_models: TypeModelSet = set()\n\n    field_type = field.type_\n    if lenient_issubclass(getattr(field_type, '__pydantic_model__', None), BaseModel):\n        field_type = field_type.__pydantic_model__\n\n    if field.sub_fields and not lenient_issubclass(field_type, BaseModel):\n        flat_models |= get_flat_models_from_fields(field.sub_fields, known_models=known_models)\n    elif lenient_issubclass(field_type, BaseModel) and field_type not in known_models:\n        flat_models |= get_flat_models_from_model(field_type, known_models=known_models)\n    elif lenient_issubclass(field_type, Enum):\n        flat_models.add(field_type)\n    return flat_models\n\n\ndef get_flat_models_from_fields(fields: Sequence[ModelField], known_models: TypeModelSet) -> TypeModelSet:\n    \"\"\"\n    Take a list of Pydantic  ``ModelField``s (from a model) that could have been declared as subclasses of ``BaseModel``\n    (so, any of them could be a submodel), and generate a set with their models and all the sub-models in the tree.\n    I.e. if you pass a the fields of a model ``Foo`` (subclass of ``BaseModel``) as ``fields``, and on of them has a\n    field of type ``Bar`` (also subclass of ``BaseModel``) and that model ``Bar`` has a field of type ``Baz`` (also\n    subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n\n    :param fields: a list of Pydantic ``ModelField``s\n    :param known_models: used to solve circular references\n    :return: a set with any model declared in the fields, and all their sub-models\n    \"\"\"\n    flat_models: TypeModelSet = set()\n    for field in fields:\n        flat_models |= get_flat_models_from_field(field, known_models=known_models)\n    return flat_models\n\n\ndef get_flat_models_from_models(models: Sequence[Type['BaseModel']]) -> TypeModelSet:\n    \"\"\"\n    Take a list of ``models`` and generate a set with them and all their sub-models in their trees. I.e. if you pass\n    a list of two models, ``Foo`` and ``Bar``, both subclasses of Pydantic ``BaseModel`` as models, and ``Bar`` has\n    a field of type ``Baz`` (also subclass of ``BaseModel``), the return value will be ``set([Foo, Bar, Baz])``.\n    \"\"\"\n    flat_models: TypeModelSet = set()\n    for model in models:\n        flat_models |= get_flat_models_from_model(model)\n    return flat_models\n\n\ndef get_long_model_name(model: TypeModelOrEnum) -> str:\n    return f'{model.__module__}__{model.__qualname__}'.replace('.', '__')\n\n\ndef field_type_schema(\n    field: ModelField,\n    *,\n    by_alias: bool,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_template: str,\n    schema_overrides: bool = False,\n    ref_prefix: Optional[str] = None,\n    known_models: TypeModelSet,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    Used by ``field_schema()``, you probably should be using that function.\n\n    Take a single ``field`` and generate the schema for its type only, not including additional\n    information as title, etc. Also return additional schema definitions, from sub-models.\n    \"\"\"\n    from pydantic.v1.main import BaseModel  # noqa: F811\n\n    definitions = {}\n    nested_models: Set[str] = set()\n    f_schema: Dict[str, Any]\n    if field.shape in {\n        SHAPE_LIST,\n        SHAPE_TUPLE_ELLIPSIS,\n        SHAPE_SEQUENCE,\n        SHAPE_SET,\n        SHAPE_FROZENSET,\n        SHAPE_ITERABLE,\n        SHAPE_DEQUE,\n    }:\n        items_schema, f_definitions, f_nested_models = field_singleton_schema(\n            field,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n        )\n        definitions.update(f_definitions)\n        nested_models.update(f_nested_models)\n        f_schema = {'type': 'array', 'items': items_schema}\n        if field.shape in {SHAPE_SET, SHAPE_FROZENSET}:\n            f_schema['uniqueItems'] = True\n\n    elif field.shape in MAPPING_LIKE_SHAPES:\n        f_schema = {'type': 'object'}\n        key_field = cast(ModelField, field.key_field)\n        regex = getattr(key_field.type_, 'regex', None)\n        items_schema, f_definitions, f_nested_models = field_singleton_schema(\n            field,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n        )\n        definitions.update(f_definitions)\n        nested_models.update(f_nested_models)\n        if regex:\n            # Dict keys have a regex pattern\n            # items_schema might be a schema or empty dict, add it either way\n            f_schema['patternProperties'] = {ConstrainedStr._get_pattern(regex): items_schema}\n        if items_schema:\n            # The dict values are not simply Any, so they need a schema\n            f_schema['additionalProperties'] = items_schema\n    elif field.shape == SHAPE_TUPLE or (field.shape == SHAPE_GENERIC and not issubclass(field.type_, BaseModel)):\n        sub_schema = []\n        sub_fields = cast(List[ModelField], field.sub_fields)\n        for sf in sub_fields:\n            sf_schema, sf_definitions, sf_nested_models = field_type_schema(\n                sf,\n                by_alias=by_alias,\n                model_name_map=model_name_map,\n                ref_prefix=ref_prefix,\n                ref_template=ref_template,\n                known_models=known_models,\n            )\n            definitions.update(sf_definitions)\n            nested_models.update(sf_nested_models)\n            sub_schema.append(sf_schema)\n\n        sub_fields_len = len(sub_fields)\n        if field.shape == SHAPE_GENERIC:\n            all_of_schemas = sub_schema[0] if sub_fields_len == 1 else {'type': 'array', 'items': sub_schema}\n            f_schema = {'allOf': [all_of_schemas]}\n        else:\n            f_schema = {\n                'type': 'array',\n                'minItems': sub_fields_len,\n                'maxItems': sub_fields_len,\n            }\n            if sub_fields_len >= 1:\n                f_schema['items'] = sub_schema\n    else:\n        assert field.shape in {SHAPE_SINGLETON, SHAPE_GENERIC}, field.shape\n        f_schema, f_definitions, f_nested_models = field_singleton_schema(\n            field,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            schema_overrides=schema_overrides,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n        )\n        definitions.update(f_definitions)\n        nested_models.update(f_nested_models)\n\n    # check field type to avoid repeated calls to the same __modify_schema__ method\n    if field.type_ != field.outer_type_:\n        if field.shape == SHAPE_GENERIC:\n            field_type = field.type_\n        else:\n            field_type = field.outer_type_\n        modify_schema = getattr(field_type, '__modify_schema__', None)\n        if modify_schema:\n            _apply_modify_schema(modify_schema, field, f_schema)\n    return f_schema, definitions, nested_models\n\n\ndef model_process_schema(\n    model: TypeModelOrEnum,\n    *,\n    by_alias: bool = True,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_prefix: Optional[str] = None,\n    ref_template: str = default_ref_template,\n    known_models: Optional[TypeModelSet] = None,\n    field: Optional[ModelField] = None,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    Used by ``model_schema()``, you probably should be using that function.\n\n    Take a single ``model`` and generate its schema. Also return additional schema definitions, from sub-models. The\n    sub-models of the returned schema will be referenced, but their definitions will not be included in the schema. All\n    the definitions are returned as the second value.\n    \"\"\"\n    from inspect import getdoc, signature\n\n    known_models = known_models or set()\n    if lenient_issubclass(model, Enum):\n        model = cast(Type[Enum], model)\n        s = enum_process_schema(model, field=field)\n        return s, {}, set()\n    model = cast(Type['BaseModel'], model)\n    s = {'title': model.__config__.title or model.__name__}\n    doc = getdoc(model)\n    if doc:\n        s['description'] = doc\n    known_models.add(model)\n    m_schema, m_definitions, nested_models = model_type_schema(\n        model,\n        by_alias=by_alias,\n        model_name_map=model_name_map,\n        ref_prefix=ref_prefix,\n        ref_template=ref_template,\n        known_models=known_models,\n    )\n    s.update(m_schema)\n    schema_extra = model.__config__.schema_extra\n    if callable(schema_extra):\n        if len(signature(schema_extra).parameters) == 1:\n            schema_extra(s)\n        else:\n            schema_extra(s, model)\n    else:\n        s.update(schema_extra)\n    return s, m_definitions, nested_models\n\n\ndef model_type_schema(\n    model: Type['BaseModel'],\n    *,\n    by_alias: bool,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_template: str,\n    ref_prefix: Optional[str] = None,\n    known_models: TypeModelSet,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    You probably should be using ``model_schema()``, this function is indirectly used by that function.\n\n    Take a single ``model`` and generate the schema for its type only, not including additional\n    information as title, etc. Also return additional schema definitions, from sub-models.\n    \"\"\"\n    properties = {}\n    required = []\n    definitions: Dict[str, Any] = {}\n    nested_models: Set[str] = set()\n    for k, f in model.__fields__.items():\n        try:\n            f_schema, f_definitions, f_nested_models = field_schema(\n                f,\n                by_alias=by_alias,\n                model_name_map=model_name_map,\n                ref_prefix=ref_prefix,\n                ref_template=ref_template,\n                known_models=known_models,\n            )\n        except SkipField as skip:\n            warnings.warn(skip.message, UserWarning)\n            continue\n        definitions.update(f_definitions)\n        nested_models.update(f_nested_models)\n        if by_alias:\n            properties[f.alias] = f_schema\n            if f.required:\n                required.append(f.alias)\n        else:\n            properties[k] = f_schema\n            if f.required:\n                required.append(k)\n    if ROOT_KEY in properties:\n        out_schema = properties[ROOT_KEY]\n        out_schema['title'] = model.__config__.title or model.__name__\n    else:\n        out_schema = {'type': 'object', 'properties': properties}\n        if required:\n            out_schema['required'] = required\n    if model.__config__.extra == 'forbid':\n        out_schema['additionalProperties'] = False\n    return out_schema, definitions, nested_models\n\n\ndef enum_process_schema(enum: Type[Enum], *, field: Optional[ModelField] = None) -> Dict[str, Any]:\n    \"\"\"\n    Take a single `enum` and generate its schema.\n\n    This is similar to the `model_process_schema` function, but applies to ``Enum`` objects.\n    \"\"\"\n    import inspect\n\n    schema_: Dict[str, Any] = {\n        'title': enum.__name__,\n        # Python assigns all enums a default docstring value of 'An enumeration', so\n        # all enums will have a description field even if not explicitly provided.\n        'description': inspect.cleandoc(enum.__doc__ or 'An enumeration.'),\n        # Add enum values and the enum field type to the schema.\n        'enum': [item.value for item in cast(Iterable[Enum], enum)],\n    }\n\n    add_field_type_to_schema(enum, schema_)\n\n    modify_schema = getattr(enum, '__modify_schema__', None)\n    if modify_schema:\n        _apply_modify_schema(modify_schema, field, schema_)\n\n    return schema_\n\n\ndef field_singleton_sub_fields_schema(\n    field: ModelField,\n    *,\n    by_alias: bool,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_template: str,\n    schema_overrides: bool = False,\n    ref_prefix: Optional[str] = None,\n    known_models: TypeModelSet,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    This function is indirectly used by ``field_schema()``, you probably should be using that function.\n\n    Take a list of Pydantic ``ModelField`` from the declaration of a type with parameters, and generate their\n    schema. I.e., fields used as \"type parameters\", like ``str`` and ``int`` in ``Tuple[str, int]``.\n    \"\"\"\n    sub_fields = cast(List[ModelField], field.sub_fields)\n    definitions = {}\n    nested_models: Set[str] = set()\n    if len(sub_fields) == 1:\n        return field_type_schema(\n            sub_fields[0],\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            schema_overrides=schema_overrides,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n        )\n    else:\n        s: Dict[str, Any] = {}\n        # https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.2.md#discriminator-object\n        field_has_discriminator: bool = field.discriminator_key is not None\n        if field_has_discriminator:\n            assert field.sub_fields_mapping is not None\n\n            discriminator_models_refs: Dict[str, Union[str, Dict[str, Any]]] = {}\n\n            for discriminator_value, sub_field in field.sub_fields_mapping.items():\n                if isinstance(discriminator_value, Enum):\n                    discriminator_value = str(discriminator_value.value)\n                # sub_field is either a `BaseModel` or directly an `Annotated` `Union` of many\n                if is_union(get_origin(sub_field.type_)):\n                    sub_models = get_sub_types(sub_field.type_)\n                    discriminator_models_refs[discriminator_value] = {\n                        model_name_map[sub_model]: get_schema_ref(\n                            model_name_map[sub_model], ref_prefix, ref_template, False\n                        )\n                        for sub_model in sub_models\n                    }\n                else:\n                    sub_field_type = sub_field.type_\n                    if hasattr(sub_field_type, '__pydantic_model__'):\n                        sub_field_type = sub_field_type.__pydantic_model__\n\n                    discriminator_model_name = model_name_map[sub_field_type]\n                    discriminator_model_ref = get_schema_ref(discriminator_model_name, ref_prefix, ref_template, False)\n                    discriminator_models_refs[discriminator_value] = discriminator_model_ref['$ref']\n\n            s['discriminator'] = {\n                'propertyName': field.discriminator_alias,\n                'mapping': discriminator_models_refs,\n            }\n\n        sub_field_schemas = []\n        for sf in sub_fields:\n            sub_schema, sub_definitions, sub_nested_models = field_type_schema(\n                sf,\n                by_alias=by_alias,\n                model_name_map=model_name_map,\n                schema_overrides=schema_overrides,\n                ref_prefix=ref_prefix,\n                ref_template=ref_template,\n                known_models=known_models,\n            )\n            definitions.update(sub_definitions)\n            if schema_overrides and 'allOf' in sub_schema:\n                # if the sub_field is a referenced schema we only need the referenced\n                # object. Otherwise we will end up with several allOf inside anyOf/oneOf.\n                # See https://github.com/pydantic/pydantic/issues/1209\n                sub_schema = sub_schema['allOf'][0]\n\n            if sub_schema.keys() == {'discriminator', 'oneOf'}:\n                # we don't want discriminator information inside oneOf choices, this is dealt with elsewhere\n                sub_schema.pop('discriminator')\n            sub_field_schemas.append(sub_schema)\n            nested_models.update(sub_nested_models)\n        s['oneOf' if field_has_discriminator else 'anyOf'] = sub_field_schemas\n        return s, definitions, nested_models\n\n\n# Order is important, e.g. subclasses of str must go before str\n# this is used only for standard library types, custom types should use __modify_schema__ instead\nfield_class_to_schema: Tuple[Tuple[Any, Dict[str, Any]], ...] = (\n    (Path, {'type': 'string', 'format': 'path'}),\n    (datetime, {'type': 'string', 'format': 'date-time'}),\n    (date, {'type': 'string', 'format': 'date'}),\n    (time, {'type': 'string', 'format': 'time'}),\n    (timedelta, {'type': 'number', 'format': 'time-delta'}),\n    (IPv4Network, {'type': 'string', 'format': 'ipv4network'}),\n    (IPv6Network, {'type': 'string', 'format': 'ipv6network'}),\n    (IPv4Interface, {'type': 'string', 'format': 'ipv4interface'}),\n    (IPv6Interface, {'type': 'string', 'format': 'ipv6interface'}),\n    (IPv4Address, {'type': 'string', 'format': 'ipv4'}),\n    (IPv6Address, {'type': 'string', 'format': 'ipv6'}),\n    (Pattern, {'type': 'string', 'format': 'regex'}),\n    (str, {'type': 'string'}),\n    (bytes, {'type': 'string', 'format': 'binary'}),\n    (bool, {'type': 'boolean'}),\n    (int, {'type': 'integer'}),\n    (float, {'type': 'number'}),\n    (Decimal, {'type': 'number'}),\n    (UUID, {'type': 'string', 'format': 'uuid'}),\n    (dict, {'type': 'object'}),\n    (list, {'type': 'array', 'items': {}}),\n    (tuple, {'type': 'array', 'items': {}}),\n    (set, {'type': 'array', 'items': {}, 'uniqueItems': True}),\n    (frozenset, {'type': 'array', 'items': {}, 'uniqueItems': True}),\n)\n\njson_scheme = {'type': 'string', 'format': 'json-string'}\n\n\ndef add_field_type_to_schema(field_type: Any, schema_: Dict[str, Any]) -> None:\n    \"\"\"\n    Update the given `schema` with the type-specific metadata for the given `field_type`.\n\n    This function looks through `field_class_to_schema` for a class that matches the given `field_type`,\n    and then modifies the given `schema` with the information from that type.\n    \"\"\"\n    for type_, t_schema in field_class_to_schema:\n        # Fallback for `typing.Pattern` and `re.Pattern` as they are not a valid class\n        if lenient_issubclass(field_type, type_) or field_type is type_ is Pattern:\n            schema_.update(t_schema)\n            break\n\n\ndef get_schema_ref(name: str, ref_prefix: Optional[str], ref_template: str, schema_overrides: bool) -> Dict[str, Any]:\n    if ref_prefix:\n        schema_ref = {'$ref': ref_prefix + name}\n    else:\n        schema_ref = {'$ref': ref_template.format(model=name)}\n    return {'allOf': [schema_ref]} if schema_overrides else schema_ref\n\n\ndef field_singleton_schema(  # noqa: C901 (ignore complexity)\n    field: ModelField,\n    *,\n    by_alias: bool,\n    model_name_map: Dict[TypeModelOrEnum, str],\n    ref_template: str,\n    schema_overrides: bool = False,\n    ref_prefix: Optional[str] = None,\n    known_models: TypeModelSet,\n) -> Tuple[Dict[str, Any], Dict[str, Any], Set[str]]:\n    \"\"\"\n    This function is indirectly used by ``field_schema()``, you should probably be using that function.\n\n    Take a single Pydantic ``ModelField``, and return its schema and any additional definitions from sub-models.\n    \"\"\"\n    from pydantic.v1.main import BaseModel\n\n    definitions: Dict[str, Any] = {}\n    nested_models: Set[str] = set()\n    field_type = field.type_\n\n    # Recurse into this field if it contains sub_fields and is NOT a\n    # BaseModel OR that BaseModel is a const\n    if field.sub_fields and (\n        (field.field_info and field.field_info.const) or not lenient_issubclass(field_type, BaseModel)\n    ):\n        return field_singleton_sub_fields_schema(\n            field,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            schema_overrides=schema_overrides,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n        )\n    if field_type is Any or field_type is object or field_type.__class__ == TypeVar or get_origin(field_type) is type:\n        return {}, definitions, nested_models  # no restrictions\n    if is_none_type(field_type):\n        return {'type': 'null'}, definitions, nested_models\n    if is_callable_type(field_type):\n        raise SkipField(f'Callable {field.name} was excluded from schema since JSON schema has no equivalent type.')\n    f_schema: Dict[str, Any] = {}\n    if field.field_info is not None and field.field_info.const:\n        f_schema['const'] = field.default\n\n    if is_literal_type(field_type):\n        values = tuple(x.value if isinstance(x, Enum) else x for x in all_literal_values(field_type))\n\n        if len({v.__class__ for v in values}) > 1:\n            return field_schema(\n                multitypes_literal_field_for_schema(values, field),\n                by_alias=by_alias,\n                model_name_map=model_name_map,\n                ref_prefix=ref_prefix,\n                ref_template=ref_template,\n                known_models=known_models,\n            )\n\n        # All values have the same type\n        field_type = values[0].__class__\n        f_schema['enum'] = list(values)\n        add_field_type_to_schema(field_type, f_schema)\n    elif lenient_issubclass(field_type, Enum):\n        enum_name = model_name_map[field_type]\n        f_schema, schema_overrides = get_field_info_schema(field, schema_overrides)\n        f_schema.update(get_schema_ref(enum_name, ref_prefix, ref_template, schema_overrides))\n        definitions[enum_name] = enum_process_schema(field_type, field=field)\n    elif is_namedtuple(field_type):\n        sub_schema, *_ = model_process_schema(\n            field_type.__pydantic_model__,\n            by_alias=by_alias,\n            model_name_map=model_name_map,\n            ref_prefix=ref_prefix,\n            ref_template=ref_template,\n            known_models=known_models,\n            field=field,\n        )\n        items_schemas = list(sub_schema['properties'].values())\n        f_schema.update(\n            {\n                'type': 'array',\n                'items': items_schemas,\n                'minItems': len(items_schemas),\n                'maxItems': len(items_schemas),\n            }\n        )\n    elif not hasattr(field_type, '__pydantic_model__'):\n        add_field_type_to_schema(field_type, f_schema)\n\n        modify_schema = getattr(field_type, '__modify_schema__', None)\n        if modify_schema:\n            _apply_modify_schema(modify_schema, field, f_schema)\n\n    if f_schema:\n        return f_schema, definitions, nested_models\n\n    # Handle dataclass-based models\n    if lenient_issubclass(getattr(field_type, '__pydantic_model__', None), BaseModel):\n        field_type = field_type.__pydantic_model__\n\n    if issubclass(field_type, BaseModel):\n        model_name = model_name_map[field_type]\n        if field_type not in known_models:\n            sub_schema, sub_definitions, sub_nested_models = model_process_schema(\n                field_type,\n                by_alias=by_alias,\n                model_name_map=model_name_map,\n                ref_prefix=ref_prefix,\n                ref_template=ref_template,\n                known_models=known_models,\n                field=field,\n            )\n            definitions.update(sub_definitions)\n            definitions[model_name] = sub_schema\n            nested_models.update(sub_nested_models)\n        else:\n            nested_models.add(model_name)\n        schema_ref = get_schema_ref(model_name, ref_prefix, ref_template, schema_overrides)\n        return schema_ref, definitions, nested_models\n\n    # For generics with no args\n    args = get_args(field_type)\n    if args is not None and not args and Generic in field_type.__bases__:\n        return f_schema, definitions, nested_models\n\n    raise ValueError(f'Value not declarable with JSON Schema, field: {field}')\n\n\ndef multitypes_literal_field_for_schema(values: Tuple[Any, ...], field: ModelField) -> ModelField:\n    \"\"\"\n    To support `Literal` with values of different types, we split it into multiple `Literal` with same type\n    e.g. `Literal['qwe', 'asd', 1, 2]` becomes `Union[Literal['qwe', 'asd'], Literal[1, 2]]`\n    \"\"\"\n    literal_distinct_types = defaultdict(list)\n    for v in values:\n        literal_distinct_types[v.__class__].append(v)\n    distinct_literals = (Literal[tuple(same_type_values)] for same_type_values in literal_distinct_types.values())\n\n    return ModelField(\n        name=field.name,\n        type_=Union[tuple(distinct_literals)],  # type: ignore\n        class_validators=field.class_validators,\n        model_config=field.model_config,\n        default=field.default,\n        required=field.required,\n        alias=field.alias,\n        field_info=field.field_info,\n    )\n\n\ndef encode_default(dft: Any) -> Any:\n    from pydantic.v1.main import BaseModel\n\n    if isinstance(dft, BaseModel) or is_dataclass(dft):\n        dft = cast('dict[str, Any]', pydantic_encoder(dft))\n\n    if isinstance(dft, dict):\n        return {encode_default(k): encode_default(v) for k, v in dft.items()}\n    elif isinstance(dft, Enum):\n        return dft.value\n    elif isinstance(dft, (int, float, str)):\n        return dft\n    elif isinstance(dft, (list, tuple)):\n        t = dft.__class__\n        seq_args = (encode_default(v) for v in dft)\n        return t(*seq_args) if is_namedtuple(t) else t(seq_args)\n    elif dft is None:\n        return None\n    else:\n        return pydantic_encoder(dft)\n\n\n_map_types_constraint: Dict[Any, Callable[..., type]] = {int: conint, float: confloat, Decimal: condecimal}\n\n\ndef get_annotation_from_field_info(\n    annotation: Any, field_info: FieldInfo, field_name: str, validate_assignment: bool = False\n) -> Type[Any]:\n    \"\"\"\n    Get an annotation with validation implemented for numbers and strings based on the field_info.\n    :param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n    :param field_name: name of the field for use in error messages\n    :param validate_assignment: default False, flag for BaseModel Config value of validate_assignment\n    :return: the same ``annotation`` if unmodified or a new annotation with validation in place\n    \"\"\"\n    constraints = field_info.get_constraints()\n    used_constraints: Set[str] = set()\n    if constraints:\n        annotation, used_constraints = get_annotation_with_constraints(annotation, field_info)\n    if validate_assignment:\n        used_constraints.add('allow_mutation')\n\n    unused_constraints = constraints - used_constraints\n    if unused_constraints:\n        raise ValueError(\n            f'On field \"{field_name}\" the following field constraints are set but not enforced: '\n            f'{\", \".join(unused_constraints)}. '\n            f'\\nFor more details see https://docs.pydantic.dev/usage/schema/#unenforced-field-constraints'\n        )\n\n    return annotation\n\n\ndef get_annotation_with_constraints(annotation: Any, field_info: FieldInfo) -> Tuple[Type[Any], Set[str]]:  # noqa: C901\n    \"\"\"\n    Get an annotation with used constraints implemented for numbers and strings based on the field_info.\n\n    :param annotation: an annotation from a field specification, as ``str``, ``ConstrainedStr``\n    :param field_info: an instance of FieldInfo, possibly with declarations for validations and JSON Schema\n    :return: the same ``annotation`` if unmodified or a new annotation along with the used constraints.\n    \"\"\"\n    used_constraints: Set[str] = set()\n\n    def go(type_: Any) -> Type[Any]:\n        if (\n            is_literal_type(type_)\n            or isinstance(type_, ForwardRef)\n            or lenient_issubclass(type_, (ConstrainedList, ConstrainedSet, ConstrainedFrozenSet))\n        ):\n            return type_\n        origin = get_origin(type_)\n        if origin is not None:\n            args: Tuple[Any, ...] = get_args(type_)\n            if any(isinstance(a, ForwardRef) for a in args):\n                # forward refs cause infinite recursion below\n                return type_\n\n            if origin is Annotated:\n                return go(args[0])\n            if is_union(origin):\n                return Union[tuple(go(a) for a in args)]  # type: ignore\n\n            if issubclass(origin, List) and (\n                field_info.min_items is not None\n                or field_info.max_items is not None\n                or field_info.unique_items is not None\n            ):\n                used_constraints.update({'min_items', 'max_items', 'unique_items'})\n                return conlist(\n                    go(args[0]),\n                    min_items=field_info.min_items,\n                    max_items=field_info.max_items,\n                    unique_items=field_info.unique_items,\n                )\n\n            if issubclass(origin, Set) and (field_info.min_items is not None or field_info.max_items is not None):\n                used_constraints.update({'min_items', 'max_items'})\n                return conset(go(args[0]), min_items=field_info.min_items, max_items=field_info.max_items)\n\n            if issubclass(origin, FrozenSet) and (field_info.min_items is not None or field_info.max_items is not None):\n                used_constraints.update({'min_items', 'max_items'})\n                return confrozenset(go(args[0]), min_items=field_info.min_items, max_items=field_info.max_items)\n\n            for t in (Tuple, List, Set, FrozenSet, Sequence):\n                if issubclass(origin, t):  # type: ignore\n                    return t[tuple(go(a) for a in args)]  # type: ignore\n\n            if issubclass(origin, Dict):\n                return Dict[args[0], go(args[1])]  # type: ignore\n\n        attrs: Optional[Tuple[str, ...]] = None\n        constraint_func: Optional[Callable[..., type]] = None\n        if isinstance(type_, type):\n            if issubclass(type_, (SecretStr, SecretBytes)):\n                attrs = ('max_length', 'min_length')\n\n                def constraint_func(**kw: Any) -> Type[Any]:  # noqa: F811\n                    return type(type_.__name__, (type_,), kw)\n\n            elif issubclass(type_, str) and not issubclass(type_, (EmailStr, AnyUrl)):\n                attrs = ('max_length', 'min_length', 'regex')\n                if issubclass(type_, StrictStr):\n\n                    def constraint_func(**kw: Any) -> Type[Any]:\n                        return type(type_.__name__, (type_,), kw)\n\n                else:\n                    constraint_func = constr\n            elif issubclass(type_, bytes):\n                attrs = ('max_length', 'min_length', 'regex')\n                if issubclass(type_, StrictBytes):\n\n                    def constraint_func(**kw: Any) -> Type[Any]:\n                        return type(type_.__name__, (type_,), kw)\n\n                else:\n                    constraint_func = conbytes\n            elif issubclass(type_, numeric_types) and not issubclass(\n                type_,\n                (\n                    ConstrainedInt,\n                    ConstrainedFloat,\n                    ConstrainedDecimal,\n                    ConstrainedList,\n                    ConstrainedSet,\n                    ConstrainedFrozenSet,\n                    bool,\n                ),\n            ):\n                # Is numeric type\n                attrs = ('gt', 'lt', 'ge', 'le', 'multiple_of')\n                if issubclass(type_, float):\n                    attrs += ('allow_inf_nan',)\n                if issubclass(type_, Decimal):\n                    attrs += ('max_digits', 'decimal_places')\n                numeric_type = next(t for t in numeric_types if issubclass(type_, t))  # pragma: no branch\n                constraint_func = _map_types_constraint[numeric_type]\n\n        if attrs:\n            used_constraints.update(set(attrs))\n            kwargs = {\n                attr_name: attr\n                for attr_name, attr in ((attr_name, getattr(field_info, attr_name)) for attr_name in attrs)\n                if attr is not None\n            }\n            if kwargs:\n                constraint_func = cast(Callable[..., type], constraint_func)\n                return constraint_func(**kwargs)\n        return type_\n\n    return go(annotation), used_constraints\n\n\ndef normalize_name(name: str) -> str:\n    \"\"\"\n    Normalizes the given name. This can be applied to either a model *or* enum.\n    \"\"\"\n    return re.sub(r'[^a-zA-Z0-9.\\-_]', '_', name)\n\n\nclass SkipField(Exception):\n    \"\"\"\n    Utility exception used to exclude fields from schema.\n    \"\"\"\n\n    def __init__(self, message: str) -> None:\n        self.message = message\n", "pydantic/v1/utils.py": "import keyword\nimport warnings\nimport weakref\nfrom collections import OrderedDict, defaultdict, deque\nfrom copy import deepcopy\nfrom itertools import islice, zip_longest\nfrom types import BuiltinFunctionType, CodeType, FunctionType, GeneratorType, LambdaType, ModuleType\nfrom typing import (\n    TYPE_CHECKING,\n    AbstractSet,\n    Any,\n    Callable,\n    Collection,\n    Dict,\n    Generator,\n    Iterable,\n    Iterator,\n    List,\n    Mapping,\n    NoReturn,\n    Optional,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\n\nfrom typing_extensions import Annotated\n\nfrom pydantic.v1.errors import ConfigError\nfrom pydantic.v1.typing import (\n    NoneType,\n    WithArgsTypes,\n    all_literal_values,\n    display_as_type,\n    get_args,\n    get_origin,\n    is_literal_type,\n    is_union,\n)\nfrom pydantic.v1.version import version_info\n\nif TYPE_CHECKING:\n    from inspect import Signature\n    from pathlib import Path\n\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.dataclasses import Dataclass\n    from pydantic.v1.fields import ModelField\n    from pydantic.v1.main import BaseModel\n    from pydantic.v1.typing import AbstractSetIntStr, DictIntStrAny, IntStr, MappingIntStrAny, ReprArgs\n\n    RichReprResult = Iterable[Union[Any, Tuple[Any], Tuple[str, Any], Tuple[str, Any, Any]]]\n\n__all__ = (\n    'import_string',\n    'sequence_like',\n    'validate_field_name',\n    'lenient_isinstance',\n    'lenient_issubclass',\n    'in_ipython',\n    'is_valid_identifier',\n    'deep_update',\n    'update_not_none',\n    'almost_equal_floats',\n    'get_model',\n    'to_camel',\n    'is_valid_field',\n    'smart_deepcopy',\n    'PyObjectStr',\n    'Representation',\n    'GetterDict',\n    'ValueItems',\n    'version_info',  # required here to match behaviour in v1.3\n    'ClassAttribute',\n    'path_type',\n    'ROOT_KEY',\n    'get_unique_discriminator_alias',\n    'get_discriminator_alias_and_values',\n    'DUNDER_ATTRIBUTES',\n)\n\nROOT_KEY = '__root__'\n# these are types that are returned unchanged by deepcopy\nIMMUTABLE_NON_COLLECTIONS_TYPES: Set[Type[Any]] = {\n    int,\n    float,\n    complex,\n    str,\n    bool,\n    bytes,\n    type,\n    NoneType,\n    FunctionType,\n    BuiltinFunctionType,\n    LambdaType,\n    weakref.ref,\n    CodeType,\n    # note: including ModuleType will differ from behaviour of deepcopy by not producing error.\n    # It might be not a good idea in general, but considering that this function used only internally\n    # against default values of fields, this will allow to actually have a field with module as default value\n    ModuleType,\n    NotImplemented.__class__,\n    Ellipsis.__class__,\n}\n\n# these are types that if empty, might be copied with simple copy() instead of deepcopy()\nBUILTIN_COLLECTIONS: Set[Type[Any]] = {\n    list,\n    set,\n    tuple,\n    frozenset,\n    dict,\n    OrderedDict,\n    defaultdict,\n    deque,\n}\n\n\ndef import_string(dotted_path: str) -> Any:\n    \"\"\"\n    Stolen approximately from django. Import a dotted module path and return the attribute/class designated by the\n    last name in the path. Raise ImportError if the import fails.\n    \"\"\"\n    from importlib import import_module\n\n    try:\n        module_path, class_name = dotted_path.strip(' ').rsplit('.', 1)\n    except ValueError as e:\n        raise ImportError(f'\"{dotted_path}\" doesn\\'t look like a module path') from e\n\n    module = import_module(module_path)\n    try:\n        return getattr(module, class_name)\n    except AttributeError as e:\n        raise ImportError(f'Module \"{module_path}\" does not define a \"{class_name}\" attribute') from e\n\n\ndef truncate(v: Union[str], *, max_len: int = 80) -> str:\n    \"\"\"\n    Truncate a value and add a unicode ellipsis (three dots) to the end if it was too long\n    \"\"\"\n    warnings.warn('`truncate` is no-longer used by pydantic and is deprecated', DeprecationWarning)\n    if isinstance(v, str) and len(v) > (max_len - 2):\n        # -3 so quote + string + \u2026 + quote has correct length\n        return (v[: (max_len - 3)] + '\u2026').__repr__()\n    try:\n        v = v.__repr__()\n    except TypeError:\n        v = v.__class__.__repr__(v)  # in case v is a type\n    if len(v) > max_len:\n        v = v[: max_len - 1] + '\u2026'\n    return v\n\n\ndef sequence_like(v: Any) -> bool:\n    return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))\n\n\ndef validate_field_name(bases: List[Type['BaseModel']], field_name: str) -> None:\n    \"\"\"\n    Ensure that the field's name does not shadow an existing attribute of the model.\n    \"\"\"\n    for base in bases:\n        if getattr(base, field_name, None):\n            raise NameError(\n                f'Field name \"{field_name}\" shadows a BaseModel attribute; '\n                f'use a different field name with \"alias=\\'{field_name}\\'\".'\n            )\n\n\ndef lenient_isinstance(o: Any, class_or_tuple: Union[Type[Any], Tuple[Type[Any], ...], None]) -> bool:\n    try:\n        return isinstance(o, class_or_tuple)  # type: ignore[arg-type]\n    except TypeError:\n        return False\n\n\ndef lenient_issubclass(cls: Any, class_or_tuple: Union[Type[Any], Tuple[Type[Any], ...], None]) -> bool:\n    try:\n        return isinstance(cls, type) and issubclass(cls, class_or_tuple)  # type: ignore[arg-type]\n    except TypeError:\n        if isinstance(cls, WithArgsTypes):\n            return False\n        raise  # pragma: no cover\n\n\ndef in_ipython() -> bool:\n    \"\"\"\n    Check whether we're in an ipython environment, including jupyter notebooks.\n    \"\"\"\n    try:\n        eval('__IPYTHON__')\n    except NameError:\n        return False\n    else:  # pragma: no cover\n        return True\n\n\ndef is_valid_identifier(identifier: str) -> bool:\n    \"\"\"\n    Checks that a string is a valid identifier and not a Python keyword.\n    :param identifier: The identifier to test.\n    :return: True if the identifier is valid.\n    \"\"\"\n    return identifier.isidentifier() and not keyword.iskeyword(identifier)\n\n\nKeyType = TypeVar('KeyType')\n\n\ndef deep_update(mapping: Dict[KeyType, Any], *updating_mappings: Dict[KeyType, Any]) -> Dict[KeyType, Any]:\n    updated_mapping = mapping.copy()\n    for updating_mapping in updating_mappings:\n        for k, v in updating_mapping.items():\n            if k in updated_mapping and isinstance(updated_mapping[k], dict) and isinstance(v, dict):\n                updated_mapping[k] = deep_update(updated_mapping[k], v)\n            else:\n                updated_mapping[k] = v\n    return updated_mapping\n\n\ndef update_not_none(mapping: Dict[Any, Any], **update: Any) -> None:\n    mapping.update({k: v for k, v in update.items() if v is not None})\n\n\ndef almost_equal_floats(value_1: float, value_2: float, *, delta: float = 1e-8) -> bool:\n    \"\"\"\n    Return True if two floats are almost equal\n    \"\"\"\n    return abs(value_1 - value_2) <= delta\n\n\ndef generate_model_signature(\n    init: Callable[..., None], fields: Dict[str, 'ModelField'], config: Type['BaseConfig']\n) -> 'Signature':\n    \"\"\"\n    Generate signature for model based on its fields\n    \"\"\"\n    from inspect import Parameter, Signature, signature\n\n    from pydantic.v1.config import Extra\n\n    present_params = signature(init).parameters.values()\n    merged_params: Dict[str, Parameter] = {}\n    var_kw = None\n    use_var_kw = False\n\n    for param in islice(present_params, 1, None):  # skip self arg\n        if param.kind is param.VAR_KEYWORD:\n            var_kw = param\n            continue\n        merged_params[param.name] = param\n\n    if var_kw:  # if custom init has no var_kw, fields which are not declared in it cannot be passed through\n        allow_names = config.allow_population_by_field_name\n        for field_name, field in fields.items():\n            param_name = field.alias\n            if field_name in merged_params or param_name in merged_params:\n                continue\n            elif not is_valid_identifier(param_name):\n                if allow_names and is_valid_identifier(field_name):\n                    param_name = field_name\n                else:\n                    use_var_kw = True\n                    continue\n\n            # TODO: replace annotation with actual expected types once #1055 solved\n            kwargs = {'default': field.default} if not field.required else {}\n            merged_params[param_name] = Parameter(\n                param_name, Parameter.KEYWORD_ONLY, annotation=field.annotation, **kwargs\n            )\n\n    if config.extra is Extra.allow:\n        use_var_kw = True\n\n    if var_kw and use_var_kw:\n        # Make sure the parameter for extra kwargs\n        # does not have the same name as a field\n        default_model_signature = [\n            ('__pydantic_self__', Parameter.POSITIONAL_OR_KEYWORD),\n            ('data', Parameter.VAR_KEYWORD),\n        ]\n        if [(p.name, p.kind) for p in present_params] == default_model_signature:\n            # if this is the standard model signature, use extra_data as the extra args name\n            var_kw_name = 'extra_data'\n        else:\n            # else start from var_kw\n            var_kw_name = var_kw.name\n\n        # generate a name that's definitely unique\n        while var_kw_name in fields:\n            var_kw_name += '_'\n        merged_params[var_kw_name] = var_kw.replace(name=var_kw_name)\n\n    return Signature(parameters=list(merged_params.values()), return_annotation=None)\n\n\ndef get_model(obj: Union[Type['BaseModel'], Type['Dataclass']]) -> Type['BaseModel']:\n    from pydantic.v1.main import BaseModel\n\n    try:\n        model_cls = obj.__pydantic_model__  # type: ignore\n    except AttributeError:\n        model_cls = obj\n\n    if not issubclass(model_cls, BaseModel):\n        raise TypeError('Unsupported type, must be either BaseModel or dataclass')\n    return model_cls\n\n\ndef to_camel(string: str) -> str:\n    return ''.join(word.capitalize() for word in string.split('_'))\n\n\ndef to_lower_camel(string: str) -> str:\n    if len(string) >= 1:\n        pascal_string = to_camel(string)\n        return pascal_string[0].lower() + pascal_string[1:]\n    return string.lower()\n\n\nT = TypeVar('T')\n\n\ndef unique_list(\n    input_list: Union[List[T], Tuple[T, ...]],\n    *,\n    name_factory: Callable[[T], str] = str,\n) -> List[T]:\n    \"\"\"\n    Make a list unique while maintaining order.\n    We update the list if another one with the same name is set\n    (e.g. root validator overridden in subclass)\n    \"\"\"\n    result: List[T] = []\n    result_names: List[str] = []\n    for v in input_list:\n        v_name = name_factory(v)\n        if v_name not in result_names:\n            result_names.append(v_name)\n            result.append(v)\n        else:\n            result[result_names.index(v_name)] = v\n\n    return result\n\n\nclass PyObjectStr(str):\n    \"\"\"\n    String class where repr doesn't include quotes. Useful with Representation when you want to return a string\n    representation of something that valid (or pseudo-valid) python.\n    \"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Representation:\n    \"\"\"\n    Mixin to provide __str__, __repr__, and __pretty__ methods. See #884 for more details.\n\n    __pretty__ is used by [devtools](https://python-devtools.helpmanual.io/) to provide human readable representations\n    of objects.\n    \"\"\"\n\n    __slots__: Tuple[str, ...] = tuple()\n\n    def __repr_args__(self) -> 'ReprArgs':\n        \"\"\"\n        Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\n        Can either return:\n        * name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n        * or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`\n        \"\"\"\n        attrs = ((s, getattr(self, s)) for s in self.__slots__)\n        return [(a, v) for a, v in attrs if v is not None]\n\n    def __repr_name__(self) -> str:\n        \"\"\"\n        Name of the instance's class, used in __repr__.\n        \"\"\"\n        return self.__class__.__name__\n\n    def __repr_str__(self, join_str: str) -> str:\n        return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())\n\n    def __pretty__(self, fmt: Callable[[Any], Any], **kwargs: Any) -> Generator[Any, None, None]:\n        \"\"\"\n        Used by devtools (https://python-devtools.helpmanual.io/) to provide a human readable representations of objects\n        \"\"\"\n        yield self.__repr_name__() + '('\n        yield 1\n        for name, value in self.__repr_args__():\n            if name is not None:\n                yield name + '='\n            yield fmt(value)\n            yield ','\n            yield 0\n        yield -1\n        yield ')'\n\n    def __str__(self) -> str:\n        return self.__repr_str__(' ')\n\n    def __repr__(self) -> str:\n        return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n\n    def __rich_repr__(self) -> 'RichReprResult':\n        \"\"\"Get fields for Rich library\"\"\"\n        for name, field_repr in self.__repr_args__():\n            if name is None:\n                yield field_repr\n            else:\n                yield name, field_repr\n\n\nclass GetterDict(Representation):\n    \"\"\"\n    Hack to make object's smell just enough like dicts for validate_model.\n\n    We can't inherit from Mapping[str, Any] because it upsets cython so we have to implement all methods ourselves.\n    \"\"\"\n\n    __slots__ = ('_obj',)\n\n    def __init__(self, obj: Any):\n        self._obj = obj\n\n    def __getitem__(self, key: str) -> Any:\n        try:\n            return getattr(self._obj, key)\n        except AttributeError as e:\n            raise KeyError(key) from e\n\n    def get(self, key: Any, default: Any = None) -> Any:\n        return getattr(self._obj, key, default)\n\n    def extra_keys(self) -> Set[Any]:\n        \"\"\"\n        We don't want to get any other attributes of obj if the model didn't explicitly ask for them\n        \"\"\"\n        return set()\n\n    def keys(self) -> List[Any]:\n        \"\"\"\n        Keys of the pseudo dictionary, uses a list not set so order information can be maintained like python\n        dictionaries.\n        \"\"\"\n        return list(self)\n\n    def values(self) -> List[Any]:\n        return [self[k] for k in self]\n\n    def items(self) -> Iterator[Tuple[str, Any]]:\n        for k in self:\n            yield k, self.get(k)\n\n    def __iter__(self) -> Iterator[str]:\n        for name in dir(self._obj):\n            if not name.startswith('_'):\n                yield name\n\n    def __len__(self) -> int:\n        return sum(1 for _ in self)\n\n    def __contains__(self, item: Any) -> bool:\n        return item in self.keys()\n\n    def __eq__(self, other: Any) -> bool:\n        return dict(self) == dict(other.items())\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [(None, dict(self))]\n\n    def __repr_name__(self) -> str:\n        return f'GetterDict[{display_as_type(self._obj)}]'\n\n\nclass ValueItems(Representation):\n    \"\"\"\n    Class for more convenient calculation of excluded or included fields on values.\n    \"\"\"\n\n    __slots__ = ('_items', '_type')\n\n    def __init__(self, value: Any, items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> None:\n        items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))\n\n        self._items: 'MappingIntStrAny' = items\n\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"\n        Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    def is_included(self, item: Any) -> bool:\n        \"\"\"\n        Check if value is contained in self._items\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    def for_element(self, e: 'IntStr') -> Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']]:\n        \"\"\"\n        :param e: key or index of element on value\n        :return: raw values for element if self._items is dict and contain needed element\n        \"\"\"\n\n        item = self._items.get(e)\n        return item if not self.is_true(item) else None\n\n    def _normalize_indexes(self, items: 'MappingIntStrAny', v_length: int) -> 'DictIntStrAny':\n        \"\"\"\n        :param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n\n        normalized_items: 'DictIntStrAny' = {}\n        all_items = None\n        for i, v in items.items():\n            if not (isinstance(v, Mapping) or isinstance(v, AbstractSet) or self.is_true(v)):\n                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            if i == '__all__':\n                all_items = self._coerce_value(v)\n                continue\n            if not isinstance(i, int):\n                raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        if not all_items:\n            return normalized_items\n        if self.is_true(all_items):\n            for i in range(v_length):\n                normalized_items.setdefault(i, ...)\n            return normalized_items\n        for i in range(v_length):\n            normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                normalized_items[i] = self.merge(all_items, normalized_item)\n        return normalized_items\n\n    @classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        \"\"\"\n        Merge a ``base`` item with an ``override`` item.\n\n        Both ``base`` and ``override`` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in ``base`` is merged with ``override``,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if ``intersect`` is\n        set to ``False`` (default) and on the intersection of keys if\n        ``intersect`` is set to ``True``.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            return base\n        if cls.is_true(base) or base is None:\n            return override\n        if cls.is_true(override):\n            return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        if intersect:\n            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        else:\n            merge_keys = list(base) + [k for k in override if k not in base]\n\n        merged: 'DictIntStrAny' = {}\n        for k in merge_keys:\n            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                merged[k] = merged_item\n\n        return merged\n\n    @staticmethod\n    def _coerce_items(items: Union['AbstractSetIntStr', 'MappingIntStrAny']) -> 'MappingIntStrAny':\n        if isinstance(items, Mapping):\n            pass\n        elif isinstance(items, AbstractSet):\n            items = dict.fromkeys(items, ...)\n        else:\n            class_name = getattr(items, '__class__', '???')\n            assert_never(\n                items,\n                f'Unexpected type of exclude value {class_name}',\n            )\n        return items\n\n    @classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        if value is None or cls.is_true(value):\n            return value\n        return cls._coerce_items(value)\n\n    @staticmethod\n    def is_true(v: Any) -> bool:\n        return v is True or v is ...\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [(None, self._items)]\n\n\nclass ClassAttribute:\n    \"\"\"\n    Hide class attribute from its instances\n    \"\"\"\n\n    __slots__ = (\n        'name',\n        'value',\n    )\n\n    def __init__(self, name: str, value: Any) -> None:\n        self.name = name\n        self.value = value\n\n    def __get__(self, instance: Any, owner: Type[Any]) -> None:\n        if instance is None:\n            return self.value\n        raise AttributeError(f'{self.name!r} attribute of {owner.__name__!r} is class-only')\n\n\npath_types = {\n    'is_dir': 'directory',\n    'is_file': 'file',\n    'is_mount': 'mount point',\n    'is_symlink': 'symlink',\n    'is_block_device': 'block device',\n    'is_char_device': 'char device',\n    'is_fifo': 'FIFO',\n    'is_socket': 'socket',\n}\n\n\ndef path_type(p: 'Path') -> str:\n    \"\"\"\n    Find out what sort of thing a path is.\n    \"\"\"\n    assert p.exists(), 'path does not exist'\n    for method, name in path_types.items():\n        if getattr(p, method)():\n            return name\n\n    return 'unknown'\n\n\nObj = TypeVar('Obj')\n\n\ndef smart_deepcopy(obj: Obj) -> Obj:\n    \"\"\"\n    Return type as is for immutable built-in types\n    Use obj.copy() for built-in empty collections\n    Use copy.deepcopy() for non-empty collections and unknown objects\n    \"\"\"\n\n    obj_type = obj.__class__\n    if obj_type in IMMUTABLE_NON_COLLECTIONS_TYPES:\n        return obj  # fastest case: obj is immutable and not collection therefore will not be copied anyway\n    try:\n        if not obj and obj_type in BUILTIN_COLLECTIONS:\n            # faster way for empty collections, no need to copy its members\n            return obj if obj_type is tuple else obj.copy()  # type: ignore  # tuple doesn't have copy method\n    except (TypeError, ValueError, RuntimeError):\n        # do we really dare to catch ALL errors? Seems a bit risky\n        pass\n\n    return deepcopy(obj)  # slowest way when we actually might need a deepcopy\n\n\ndef is_valid_field(name: str) -> bool:\n    if not name.startswith('_'):\n        return True\n    return ROOT_KEY == name\n\n\nDUNDER_ATTRIBUTES = {\n    '__annotations__',\n    '__classcell__',\n    '__doc__',\n    '__module__',\n    '__orig_bases__',\n    '__orig_class__',\n    '__qualname__',\n}\n\n\ndef is_valid_private_name(name: str) -> bool:\n    return not is_valid_field(name) and name not in DUNDER_ATTRIBUTES\n\n\n_EMPTY = object()\n\n\ndef all_identical(left: Iterable[Any], right: Iterable[Any]) -> bool:\n    \"\"\"\n    Check that the items of `left` are the same objects as those in `right`.\n\n    >>> a, b = object(), object()\n    >>> all_identical([a, b, a], [a, b, a])\n    True\n    >>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while \"equal\" is not \"identical\"\n    False\n    \"\"\"\n    for left_item, right_item in zip_longest(left, right, fillvalue=_EMPTY):\n        if left_item is not right_item:\n            return False\n    return True\n\n\ndef assert_never(obj: NoReturn, msg: str) -> NoReturn:\n    \"\"\"\n    Helper to make sure that we have covered all possible types.\n\n    This is mostly useful for ``mypy``, docs:\n    https://mypy.readthedocs.io/en/latest/literal_types.html#exhaustive-checks\n    \"\"\"\n    raise TypeError(msg)\n\n\ndef get_unique_discriminator_alias(all_aliases: Collection[str], discriminator_key: str) -> str:\n    \"\"\"Validate that all aliases are the same and if that's the case return the alias\"\"\"\n    unique_aliases = set(all_aliases)\n    if len(unique_aliases) > 1:\n        raise ConfigError(\n            f'Aliases for discriminator {discriminator_key!r} must be the same (got {\", \".join(sorted(all_aliases))})'\n        )\n    return unique_aliases.pop()\n\n\ndef get_discriminator_alias_and_values(tp: Any, discriminator_key: str) -> Tuple[str, Tuple[str, ...]]:\n    \"\"\"\n    Get alias and all valid values in the `Literal` type of the discriminator field\n    `tp` can be a `BaseModel` class or directly an `Annotated` `Union` of many.\n    \"\"\"\n    is_root_model = getattr(tp, '__custom_root_type__', False)\n\n    if get_origin(tp) is Annotated:\n        tp = get_args(tp)[0]\n\n    if hasattr(tp, '__pydantic_model__'):\n        tp = tp.__pydantic_model__\n\n    if is_union(get_origin(tp)):\n        alias, all_values = _get_union_alias_and_all_values(tp, discriminator_key)\n        return alias, tuple(v for values in all_values for v in values)\n    elif is_root_model:\n        union_type = tp.__fields__[ROOT_KEY].type_\n        alias, all_values = _get_union_alias_and_all_values(union_type, discriminator_key)\n\n        if len(set(all_values)) > 1:\n            raise ConfigError(\n                f'Field {discriminator_key!r} is not the same for all submodels of {display_as_type(tp)!r}'\n            )\n\n        return alias, all_values[0]\n\n    else:\n        try:\n            t_discriminator_type = tp.__fields__[discriminator_key].type_\n        except AttributeError as e:\n            raise TypeError(f'Type {tp.__name__!r} is not a valid `BaseModel` or `dataclass`') from e\n        except KeyError as e:\n            raise ConfigError(f'Model {tp.__name__!r} needs a discriminator field for key {discriminator_key!r}') from e\n\n        if not is_literal_type(t_discriminator_type):\n            raise ConfigError(f'Field {discriminator_key!r} of model {tp.__name__!r} needs to be a `Literal`')\n\n        return tp.__fields__[discriminator_key].alias, all_literal_values(t_discriminator_type)\n\n\ndef _get_union_alias_and_all_values(\n    union_type: Type[Any], discriminator_key: str\n) -> Tuple[str, Tuple[Tuple[str, ...], ...]]:\n    zipped_aliases_values = [get_discriminator_alias_and_values(t, discriminator_key) for t in get_args(union_type)]\n    # unzip: [('alias_a',('v1', 'v2)), ('alias_b', ('v3',))] => [('alias_a', 'alias_b'), (('v1', 'v2'), ('v3',))]\n    all_aliases, all_values = zip(*zipped_aliases_values)\n    return get_unique_discriminator_alias(all_aliases, discriminator_key), all_values\n", "pydantic/v1/_hypothesis_plugin.py": "\"\"\"\nRegister Hypothesis strategies for Pydantic custom types.\n\nThis enables fully-automatic generation of test data for most Pydantic classes.\n\nNote that this module has *no* runtime impact on Pydantic itself; instead it\nis registered as a setuptools entry point and Hypothesis will import it if\nPydantic is installed.  See also:\n\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#registering-strategies-via-setuptools-entry-points\nhttps://hypothesis.readthedocs.io/en/latest/data.html#hypothesis.strategies.register_type_strategy\nhttps://hypothesis.readthedocs.io/en/latest/strategies.html#interaction-with-pytest-cov\nhttps://docs.pydantic.dev/usage/types/#pydantic-types\n\nNote that because our motivation is to *improve user experience*, the strategies\nare always sound (never generate invalid data) but sacrifice completeness for\nmaintainability (ie may be unable to generate some tricky but valid data).\n\nFinally, this module makes liberal use of `# type: ignore[<code>]` pragmas.\nThis is because Hypothesis annotates `register_type_strategy()` with\n`(T, SearchStrategy[T])`, but in most cases we register e.g. `ConstrainedInt`\nto generate instances of the builtin `int` type which match the constraints.\n\"\"\"\n\nimport contextlib\nimport datetime\nimport ipaddress\nimport json\nimport math\nfrom fractions import Fraction\nfrom typing import Callable, Dict, Type, Union, cast, overload\n\nimport hypothesis.strategies as st\n\nimport pydantic\nimport pydantic.color\nimport pydantic.types\nfrom pydantic.v1.utils import lenient_issubclass\n\n# FilePath and DirectoryPath are explicitly unsupported, as we'd have to create\n# them on-disk, and that's unsafe in general without being told *where* to do so.\n#\n# URLs are unsupported because it's easy for users to define their own strategy for\n# \"normal\" URLs, and hard for us to define a general strategy which includes \"weird\"\n# URLs but doesn't also have unpredictable performance problems.\n#\n# conlist() and conset() are unsupported for now, because the workarounds for\n# Cython and Hypothesis to handle parametrized generic types are incompatible.\n# We are rethinking Hypothesis compatibility in Pydantic v2.\n\n# Emails\ntry:\n    import email_validator\nexcept ImportError:  # pragma: no cover\n    pass\nelse:\n\n    def is_valid_email(s: str) -> bool:\n        # Hypothesis' st.emails() occasionally generates emails like 0@A0--0.ac\n        # that are invalid according to email-validator, so we filter those out.\n        try:\n            email_validator.validate_email(s, check_deliverability=False)\n            return True\n        except email_validator.EmailNotValidError:  # pragma: no cover\n            return False\n\n    # Note that these strategies deliberately stay away from any tricky Unicode\n    # or other encoding issues; we're just trying to generate *something* valid.\n    st.register_type_strategy(pydantic.EmailStr, st.emails().filter(is_valid_email))  # type: ignore[arg-type]\n    st.register_type_strategy(\n        pydantic.NameEmail,\n        st.builds(\n            '{} <{}>'.format,  # type: ignore[arg-type]\n            st.from_regex('[A-Za-z0-9_]+( [A-Za-z0-9_]+){0,5}', fullmatch=True),\n            st.emails().filter(is_valid_email),\n        ),\n    )\n\n# PyObject - dotted names, in this case taken from the math module.\nst.register_type_strategy(\n    pydantic.PyObject,  # type: ignore[arg-type]\n    st.sampled_from(\n        [cast(pydantic.PyObject, f'math.{name}') for name in sorted(vars(math)) if not name.startswith('_')]\n    ),\n)\n\n# CSS3 Colors; as name, hex, rgb(a) tuples or strings, or hsl strings\n_color_regexes = (\n    '|'.join(\n        (\n            pydantic.color.r_hex_short,\n            pydantic.color.r_hex_long,\n            pydantic.color.r_rgb,\n            pydantic.color.r_rgba,\n            pydantic.color.r_hsl,\n            pydantic.color.r_hsla,\n        )\n    )\n    # Use more precise regex patterns to avoid value-out-of-range errors\n    .replace(pydantic.color._r_sl, r'(?:(\\d\\d?(?:\\.\\d+)?|100(?:\\.0+)?)%)')\n    .replace(pydantic.color._r_alpha, r'(?:(0(?:\\.\\d+)?|1(?:\\.0+)?|\\.\\d+|\\d{1,2}%))')\n    .replace(pydantic.color._r_255, r'(?:((?:\\d|\\d\\d|[01]\\d\\d|2[0-4]\\d|25[0-4])(?:\\.\\d+)?|255(?:\\.0+)?))')\n)\nst.register_type_strategy(\n    pydantic.color.Color,\n    st.one_of(\n        st.sampled_from(sorted(pydantic.color.COLORS_BY_NAME)),\n        st.tuples(\n            st.integers(0, 255),\n            st.integers(0, 255),\n            st.integers(0, 255),\n            st.none() | st.floats(0, 1) | st.floats(0, 100).map('{}%'.format),\n        ),\n        st.from_regex(_color_regexes, fullmatch=True),\n    ),\n)\n\n\n# Card numbers, valid according to the Luhn algorithm\n\n\ndef add_luhn_digit(card_number: str) -> str:\n    # See https://en.wikipedia.org/wiki/Luhn_algorithm\n    for digit in '0123456789':\n        with contextlib.suppress(Exception):\n            pydantic.PaymentCardNumber.validate_luhn_check_digit(card_number + digit)\n            return card_number + digit\n    raise AssertionError('Unreachable')  # pragma: no cover\n\n\ncard_patterns = (\n    # Note that these patterns omit the Luhn check digit; that's added by the function above\n    '4[0-9]{14}',  # Visa\n    '5[12345][0-9]{13}',  # Mastercard\n    '3[47][0-9]{12}',  # American Express\n    '[0-26-9][0-9]{10,17}',  # other (incomplete to avoid overlap)\n)\nst.register_type_strategy(\n    pydantic.PaymentCardNumber,\n    st.from_regex('|'.join(card_patterns), fullmatch=True).map(add_luhn_digit),  # type: ignore[arg-type]\n)\n\n# UUIDs\nst.register_type_strategy(pydantic.UUID1, st.uuids(version=1))\nst.register_type_strategy(pydantic.UUID3, st.uuids(version=3))\nst.register_type_strategy(pydantic.UUID4, st.uuids(version=4))\nst.register_type_strategy(pydantic.UUID5, st.uuids(version=5))\n\n# Secrets\nst.register_type_strategy(pydantic.SecretBytes, st.binary().map(pydantic.SecretBytes))\nst.register_type_strategy(pydantic.SecretStr, st.text().map(pydantic.SecretStr))\n\n# IP addresses, networks, and interfaces\nst.register_type_strategy(pydantic.IPvAnyAddress, st.ip_addresses())  # type: ignore[arg-type]\nst.register_type_strategy(\n    pydantic.IPvAnyInterface,\n    st.from_type(ipaddress.IPv4Interface) | st.from_type(ipaddress.IPv6Interface),  # type: ignore[arg-type]\n)\nst.register_type_strategy(\n    pydantic.IPvAnyNetwork,\n    st.from_type(ipaddress.IPv4Network) | st.from_type(ipaddress.IPv6Network),  # type: ignore[arg-type]\n)\n\n# We hook into the con***() functions and the ConstrainedNumberMeta metaclass,\n# so here we only have to register subclasses for other constrained types which\n# don't go via those mechanisms.  Then there are the registration hooks below.\nst.register_type_strategy(pydantic.StrictBool, st.booleans())\nst.register_type_strategy(pydantic.StrictStr, st.text())\n\n\n# FutureDate, PastDate\nst.register_type_strategy(pydantic.FutureDate, st.dates(min_value=datetime.date.today() + datetime.timedelta(days=1)))\nst.register_type_strategy(pydantic.PastDate, st.dates(max_value=datetime.date.today() - datetime.timedelta(days=1)))\n\n\n# Constrained-type resolver functions\n#\n# For these ones, we actually want to inspect the type in order to work out a\n# satisfying strategy.  First up, the machinery for tracking resolver functions:\n\nRESOLVERS: Dict[type, Callable[[type], st.SearchStrategy]] = {}  # type: ignore[type-arg]\n\n\n@overload\ndef _registered(typ: Type[pydantic.types.T]) -> Type[pydantic.types.T]:\n    pass\n\n\n@overload\ndef _registered(typ: pydantic.types.ConstrainedNumberMeta) -> pydantic.types.ConstrainedNumberMeta:\n    pass\n\n\ndef _registered(\n    typ: Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]\n) -> Union[Type[pydantic.types.T], pydantic.types.ConstrainedNumberMeta]:\n    # This function replaces the version in `pydantic.types`, in order to\n    # effect the registration of new constrained types so that Hypothesis\n    # can generate valid examples.\n    pydantic.types._DEFINED_TYPES.add(typ)\n    for supertype, resolver in RESOLVERS.items():\n        if issubclass(typ, supertype):\n            st.register_type_strategy(typ, resolver(typ))  # type: ignore\n            return typ\n    raise NotImplementedError(f'Unknown type {typ!r} has no resolver to register')  # pragma: no cover\n\n\ndef resolves(\n    typ: Union[type, pydantic.types.ConstrainedNumberMeta]\n) -> Callable[[Callable[..., st.SearchStrategy]], Callable[..., st.SearchStrategy]]:  # type: ignore[type-arg]\n    def inner(f):  # type: ignore\n        assert f not in RESOLVERS\n        RESOLVERS[typ] = f\n        return f\n\n    return inner\n\n\n# Type-to-strategy resolver functions\n\n\n@resolves(pydantic.JsonWrapper)\ndef resolve_json(cls):  # type: ignore[no-untyped-def]\n    try:\n        inner = st.none() if cls.inner_type is None else st.from_type(cls.inner_type)\n    except Exception:  # pragma: no cover\n        finite = st.floats(allow_infinity=False, allow_nan=False)\n        inner = st.recursive(\n            base=st.one_of(st.none(), st.booleans(), st.integers(), finite, st.text()),\n            extend=lambda x: st.lists(x) | st.dictionaries(st.text(), x),  # type: ignore\n        )\n    inner_type = getattr(cls, 'inner_type', None)\n    return st.builds(\n        cls.inner_type.json if lenient_issubclass(inner_type, pydantic.BaseModel) else json.dumps,\n        inner,\n        ensure_ascii=st.booleans(),\n        indent=st.none() | st.integers(0, 16),\n        sort_keys=st.booleans(),\n    )\n\n\n@resolves(pydantic.ConstrainedBytes)\ndef resolve_conbytes(cls):  # type: ignore[no-untyped-def]  # pragma: no cover\n    min_size = cls.min_length or 0\n    max_size = cls.max_length\n    if not cls.strip_whitespace:\n        return st.binary(min_size=min_size, max_size=max_size)\n    # Fun with regex to ensure we neither start nor end with whitespace\n    repeats = '{{{},{}}}'.format(\n        min_size - 2 if min_size > 2 else 0,\n        max_size - 2 if (max_size or 0) > 2 else '',\n    )\n    if min_size >= 2:\n        pattern = rf'\\W.{repeats}\\W'\n    elif min_size == 1:\n        pattern = rf'\\W(.{repeats}\\W)?'\n    else:\n        assert min_size == 0\n        pattern = rf'(\\W(.{repeats}\\W)?)?'\n    return st.from_regex(pattern.encode(), fullmatch=True)\n\n\n@resolves(pydantic.ConstrainedDecimal)\ndef resolve_condecimal(cls):  # type: ignore[no-untyped-def]\n    min_value = cls.ge\n    max_value = cls.le\n    if cls.gt is not None:\n        assert min_value is None, 'Set `gt` or `ge`, but not both'\n        min_value = cls.gt\n    if cls.lt is not None:\n        assert max_value is None, 'Set `lt` or `le`, but not both'\n        max_value = cls.lt\n    s = st.decimals(min_value, max_value, allow_nan=False, places=cls.decimal_places)\n    if cls.lt is not None:\n        s = s.filter(lambda d: d < cls.lt)\n    if cls.gt is not None:\n        s = s.filter(lambda d: cls.gt < d)\n    return s\n\n\n@resolves(pydantic.ConstrainedFloat)\ndef resolve_confloat(cls):  # type: ignore[no-untyped-def]\n    min_value = cls.ge\n    max_value = cls.le\n    exclude_min = False\n    exclude_max = False\n\n    if cls.gt is not None:\n        assert min_value is None, 'Set `gt` or `ge`, but not both'\n        min_value = cls.gt\n        exclude_min = True\n    if cls.lt is not None:\n        assert max_value is None, 'Set `lt` or `le`, but not both'\n        max_value = cls.lt\n        exclude_max = True\n\n    if cls.multiple_of is None:\n        return st.floats(min_value, max_value, exclude_min=exclude_min, exclude_max=exclude_max, allow_nan=False)\n\n    if min_value is not None:\n        min_value = math.ceil(min_value / cls.multiple_of)\n        if exclude_min:\n            min_value = min_value + 1\n    if max_value is not None:\n        assert max_value >= cls.multiple_of, 'Cannot build model with max value smaller than multiple of'\n        max_value = math.floor(max_value / cls.multiple_of)\n        if exclude_max:\n            max_value = max_value - 1\n\n    return st.integers(min_value, max_value).map(lambda x: x * cls.multiple_of)\n\n\n@resolves(pydantic.ConstrainedInt)\ndef resolve_conint(cls):  # type: ignore[no-untyped-def]\n    min_value = cls.ge\n    max_value = cls.le\n    if cls.gt is not None:\n        assert min_value is None, 'Set `gt` or `ge`, but not both'\n        min_value = cls.gt + 1\n    if cls.lt is not None:\n        assert max_value is None, 'Set `lt` or `le`, but not both'\n        max_value = cls.lt - 1\n\n    if cls.multiple_of is None or cls.multiple_of == 1:\n        return st.integers(min_value, max_value)\n\n    # These adjustments and the .map handle integer-valued multiples, while the\n    # .filter handles trickier cases as for confloat.\n    if min_value is not None:\n        min_value = math.ceil(Fraction(min_value) / Fraction(cls.multiple_of))\n    if max_value is not None:\n        max_value = math.floor(Fraction(max_value) / Fraction(cls.multiple_of))\n    return st.integers(min_value, max_value).map(lambda x: x * cls.multiple_of)\n\n\n@resolves(pydantic.ConstrainedDate)\ndef resolve_condate(cls):  # type: ignore[no-untyped-def]\n    if cls.ge is not None:\n        assert cls.gt is None, 'Set `gt` or `ge`, but not both'\n        min_value = cls.ge\n    elif cls.gt is not None:\n        min_value = cls.gt + datetime.timedelta(days=1)\n    else:\n        min_value = datetime.date.min\n    if cls.le is not None:\n        assert cls.lt is None, 'Set `lt` or `le`, but not both'\n        max_value = cls.le\n    elif cls.lt is not None:\n        max_value = cls.lt - datetime.timedelta(days=1)\n    else:\n        max_value = datetime.date.max\n    return st.dates(min_value, max_value)\n\n\n@resolves(pydantic.ConstrainedStr)\ndef resolve_constr(cls):  # type: ignore[no-untyped-def]  # pragma: no cover\n    min_size = cls.min_length or 0\n    max_size = cls.max_length\n\n    if cls.regex is None and not cls.strip_whitespace:\n        return st.text(min_size=min_size, max_size=max_size)\n\n    if cls.regex is not None:\n        strategy = st.from_regex(cls.regex)\n        if cls.strip_whitespace:\n            strategy = strategy.filter(lambda s: s == s.strip())\n    elif cls.strip_whitespace:\n        repeats = '{{{},{}}}'.format(\n            min_size - 2 if min_size > 2 else 0,\n            max_size - 2 if (max_size or 0) > 2 else '',\n        )\n        if min_size >= 2:\n            strategy = st.from_regex(rf'\\W.{repeats}\\W')\n        elif min_size == 1:\n            strategy = st.from_regex(rf'\\W(.{repeats}\\W)?')\n        else:\n            assert min_size == 0\n            strategy = st.from_regex(rf'(\\W(.{repeats}\\W)?)?')\n\n    if min_size == 0 and max_size is None:\n        return strategy\n    elif max_size is None:\n        return strategy.filter(lambda s: min_size <= len(s))\n    return strategy.filter(lambda s: min_size <= len(s) <= max_size)\n\n\n# Finally, register all previously-defined types, and patch in our new function\nfor typ in list(pydantic.types._DEFINED_TYPES):\n    _registered(typ)\npydantic.types._registered = _registered\nst.register_type_strategy(pydantic.Json, resolve_json)\n", "pydantic/v1/fields.py": "import copy\nimport re\nfrom collections import Counter as CollectionCounter, defaultdict, deque\nfrom collections.abc import Callable, Hashable as CollectionsHashable, Iterable as CollectionsIterable\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Counter,\n    DefaultDict,\n    Deque,\n    Dict,\n    ForwardRef,\n    FrozenSet,\n    Generator,\n    Iterable,\n    Iterator,\n    List,\n    Mapping,\n    Optional,\n    Pattern,\n    Sequence,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\n\nfrom typing_extensions import Annotated, Final\n\nfrom pydantic.v1 import errors as errors_\nfrom pydantic.v1.class_validators import Validator, make_generic_validator, prep_validators\nfrom pydantic.v1.error_wrappers import ErrorWrapper\nfrom pydantic.v1.errors import ConfigError, InvalidDiscriminator, MissingDiscriminator, NoneIsNotAllowedError\nfrom pydantic.v1.types import Json, JsonWrapper\nfrom pydantic.v1.typing import (\n    NoArgAnyCallable,\n    convert_generics,\n    display_as_type,\n    get_args,\n    get_origin,\n    is_finalvar,\n    is_literal_type,\n    is_new_type,\n    is_none_type,\n    is_typeddict,\n    is_typeddict_special,\n    is_union,\n    new_type_supertype,\n)\nfrom pydantic.v1.utils import (\n    PyObjectStr,\n    Representation,\n    ValueItems,\n    get_discriminator_alias_and_values,\n    get_unique_discriminator_alias,\n    lenient_isinstance,\n    lenient_issubclass,\n    sequence_like,\n    smart_deepcopy,\n)\nfrom pydantic.v1.validators import constant_validator, dict_validator, find_validators, validate_json\n\nRequired: Any = Ellipsis\n\nT = TypeVar('T')\n\n\nclass UndefinedType:\n    def __repr__(self) -> str:\n        return 'PydanticUndefined'\n\n    def __copy__(self: T) -> T:\n        return self\n\n    def __reduce__(self) -> str:\n        return 'Undefined'\n\n    def __deepcopy__(self: T, _: Any) -> T:\n        return self\n\n\nUndefined = UndefinedType()\n\nif TYPE_CHECKING:\n    from pydantic.v1.class_validators import ValidatorsList\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.error_wrappers import ErrorList\n    from pydantic.v1.types import ModelOrDc\n    from pydantic.v1.typing import AbstractSetIntStr, MappingIntStrAny, ReprArgs\n\n    ValidateReturn = Tuple[Optional[Any], Optional[ErrorList]]\n    LocStr = Union[Tuple[Union[int, str], ...], str]\n    BoolUndefined = Union[bool, UndefinedType]\n\n\nclass FieldInfo(Representation):\n    \"\"\"\n    Captures extra information about a field.\n    \"\"\"\n\n    __slots__ = (\n        'default',\n        'default_factory',\n        'alias',\n        'alias_priority',\n        'title',\n        'description',\n        'exclude',\n        'include',\n        'const',\n        'gt',\n        'ge',\n        'lt',\n        'le',\n        'multiple_of',\n        'allow_inf_nan',\n        'max_digits',\n        'decimal_places',\n        'min_items',\n        'max_items',\n        'unique_items',\n        'min_length',\n        'max_length',\n        'allow_mutation',\n        'repr',\n        'regex',\n        'discriminator',\n        'extra',\n    )\n\n    # field constraints with the default value, it's also used in update_from_config below\n    __field_constraints__ = {\n        'min_length': None,\n        'max_length': None,\n        'regex': None,\n        'gt': None,\n        'lt': None,\n        'ge': None,\n        'le': None,\n        'multiple_of': None,\n        'allow_inf_nan': None,\n        'max_digits': None,\n        'decimal_places': None,\n        'min_items': None,\n        'max_items': None,\n        'unique_items': None,\n        'allow_mutation': True,\n    }\n\n    def __init__(self, default: Any = Undefined, **kwargs: Any) -> None:\n        self.default = default\n        self.default_factory = kwargs.pop('default_factory', None)\n        self.alias = kwargs.pop('alias', None)\n        self.alias_priority = kwargs.pop('alias_priority', 2 if self.alias is not None else None)\n        self.title = kwargs.pop('title', None)\n        self.description = kwargs.pop('description', None)\n        self.exclude = kwargs.pop('exclude', None)\n        self.include = kwargs.pop('include', None)\n        self.const = kwargs.pop('const', None)\n        self.gt = kwargs.pop('gt', None)\n        self.ge = kwargs.pop('ge', None)\n        self.lt = kwargs.pop('lt', None)\n        self.le = kwargs.pop('le', None)\n        self.multiple_of = kwargs.pop('multiple_of', None)\n        self.allow_inf_nan = kwargs.pop('allow_inf_nan', None)\n        self.max_digits = kwargs.pop('max_digits', None)\n        self.decimal_places = kwargs.pop('decimal_places', None)\n        self.min_items = kwargs.pop('min_items', None)\n        self.max_items = kwargs.pop('max_items', None)\n        self.unique_items = kwargs.pop('unique_items', None)\n        self.min_length = kwargs.pop('min_length', None)\n        self.max_length = kwargs.pop('max_length', None)\n        self.allow_mutation = kwargs.pop('allow_mutation', True)\n        self.regex = kwargs.pop('regex', None)\n        self.discriminator = kwargs.pop('discriminator', None)\n        self.repr = kwargs.pop('repr', True)\n        self.extra = kwargs\n\n    def __repr_args__(self) -> 'ReprArgs':\n        field_defaults_to_hide: Dict[str, Any] = {\n            'repr': True,\n            **self.__field_constraints__,\n        }\n\n        attrs = ((s, getattr(self, s)) for s in self.__slots__)\n        return [(a, v) for a, v in attrs if v != field_defaults_to_hide.get(a, None)]\n\n    def get_constraints(self) -> Set[str]:\n        \"\"\"\n        Gets the constraints set on the field by comparing the constraint value with its default value\n\n        :return: the constraints set on field_info\n        \"\"\"\n        return {attr for attr, default in self.__field_constraints__.items() if getattr(self, attr) != default}\n\n    def update_from_config(self, from_config: Dict[str, Any]) -> None:\n        \"\"\"\n        Update this FieldInfo based on a dict from get_field_info, only fields which have not been set are dated.\n        \"\"\"\n        for attr_name, value in from_config.items():\n            try:\n                current_value = getattr(self, attr_name)\n            except AttributeError:\n                # attr_name is not an attribute of FieldInfo, it should therefore be added to extra\n                # (except if extra already has this value!)\n                self.extra.setdefault(attr_name, value)\n            else:\n                if current_value is self.__field_constraints__.get(attr_name, None):\n                    setattr(self, attr_name, value)\n                elif attr_name == 'exclude':\n                    self.exclude = ValueItems.merge(value, current_value)\n                elif attr_name == 'include':\n                    self.include = ValueItems.merge(value, current_value, intersect=True)\n\n    def _validate(self) -> None:\n        if self.default is not Undefined and self.default_factory is not None:\n            raise ValueError('cannot specify both default and default_factory')\n\n\ndef Field(\n    default: Any = Undefined,\n    *,\n    default_factory: Optional[NoArgAnyCallable] = None,\n    alias: Optional[str] = None,\n    title: Optional[str] = None,\n    description: Optional[str] = None,\n    exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny', Any]] = None,\n    include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny', Any]] = None,\n    const: Optional[bool] = None,\n    gt: Optional[float] = None,\n    ge: Optional[float] = None,\n    lt: Optional[float] = None,\n    le: Optional[float] = None,\n    multiple_of: Optional[float] = None,\n    allow_inf_nan: Optional[bool] = None,\n    max_digits: Optional[int] = None,\n    decimal_places: Optional[int] = None,\n    min_items: Optional[int] = None,\n    max_items: Optional[int] = None,\n    unique_items: Optional[bool] = None,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    allow_mutation: bool = True,\n    regex: Optional[str] = None,\n    discriminator: Optional[str] = None,\n    repr: bool = True,\n    **extra: Any,\n) -> Any:\n    \"\"\"\n    Used to provide extra information about a field, either for the model schema or complex validation. Some arguments\n    apply only to number fields (``int``, ``float``, ``Decimal``) and some apply only to ``str``.\n\n    :param default: since this is replacing the field\u2019s default, its first argument is used\n      to set the default, use ellipsis (``...``) to indicate the field is required\n    :param default_factory: callable that will be called when a default value is needed for this field\n      If both `default` and `default_factory` are set, an error is raised.\n    :param alias: the public name of the field\n    :param title: can be any string, used in the schema\n    :param description: can be any string, used in the schema\n    :param exclude: exclude this field while dumping.\n      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.\n    :param include: include this field while dumping.\n      Takes same values as the ``include`` and ``exclude`` arguments on the ``.dict`` method.\n    :param const: this field is required and *must* take it's default value\n    :param gt: only applies to numbers, requires the field to be \"greater than\". The schema\n      will have an ``exclusiveMinimum`` validation keyword\n    :param ge: only applies to numbers, requires the field to be \"greater than or equal to\". The\n      schema will have a ``minimum`` validation keyword\n    :param lt: only applies to numbers, requires the field to be \"less than\". The schema\n      will have an ``exclusiveMaximum`` validation keyword\n    :param le: only applies to numbers, requires the field to be \"less than or equal to\". The\n      schema will have a ``maximum`` validation keyword\n    :param multiple_of: only applies to numbers, requires the field to be \"a multiple of\". The\n      schema will have a ``multipleOf`` validation keyword\n    :param allow_inf_nan: only applies to numbers, allows the field to be NaN or infinity (+inf or -inf),\n        which is a valid Python float. Default True, set to False for compatibility with JSON.\n    :param max_digits: only applies to Decimals, requires the field to have a maximum number\n      of digits within the decimal. It does not include a zero before the decimal point or trailing decimal zeroes.\n    :param decimal_places: only applies to Decimals, requires the field to have at most a number of decimal places\n      allowed. It does not include trailing decimal zeroes.\n    :param min_items: only applies to lists, requires the field to have a minimum number of\n      elements. The schema will have a ``minItems`` validation keyword\n    :param max_items: only applies to lists, requires the field to have a maximum number of\n      elements. The schema will have a ``maxItems`` validation keyword\n    :param unique_items: only applies to lists, requires the field not to have duplicated\n      elements. The schema will have a ``uniqueItems`` validation keyword\n    :param min_length: only applies to strings, requires the field to have a minimum length. The\n      schema will have a ``minLength`` validation keyword\n    :param max_length: only applies to strings, requires the field to have a maximum length. The\n      schema will have a ``maxLength`` validation keyword\n    :param allow_mutation: a boolean which defaults to True. When False, the field raises a TypeError if the field is\n      assigned on an instance.  The BaseModel Config must set validate_assignment to True\n    :param regex: only applies to strings, requires the field match against a regular expression\n      pattern string. The schema will have a ``pattern`` validation keyword\n    :param discriminator: only useful with a (discriminated a.k.a. tagged) `Union` of sub models with a common field.\n      The `discriminator` is the name of this common field to shorten validation and improve generated schema\n    :param repr: show this field in the representation\n    :param **extra: any additional keyword arguments will be added as is to the schema\n    \"\"\"\n    field_info = FieldInfo(\n        default,\n        default_factory=default_factory,\n        alias=alias,\n        title=title,\n        description=description,\n        exclude=exclude,\n        include=include,\n        const=const,\n        gt=gt,\n        ge=ge,\n        lt=lt,\n        le=le,\n        multiple_of=multiple_of,\n        allow_inf_nan=allow_inf_nan,\n        max_digits=max_digits,\n        decimal_places=decimal_places,\n        min_items=min_items,\n        max_items=max_items,\n        unique_items=unique_items,\n        min_length=min_length,\n        max_length=max_length,\n        allow_mutation=allow_mutation,\n        regex=regex,\n        discriminator=discriminator,\n        repr=repr,\n        **extra,\n    )\n    field_info._validate()\n    return field_info\n\n\n# used to be an enum but changed to int's for small performance improvement as less access overhead\nSHAPE_SINGLETON = 1\nSHAPE_LIST = 2\nSHAPE_SET = 3\nSHAPE_MAPPING = 4\nSHAPE_TUPLE = 5\nSHAPE_TUPLE_ELLIPSIS = 6\nSHAPE_SEQUENCE = 7\nSHAPE_FROZENSET = 8\nSHAPE_ITERABLE = 9\nSHAPE_GENERIC = 10\nSHAPE_DEQUE = 11\nSHAPE_DICT = 12\nSHAPE_DEFAULTDICT = 13\nSHAPE_COUNTER = 14\nSHAPE_NAME_LOOKUP = {\n    SHAPE_LIST: 'List[{}]',\n    SHAPE_SET: 'Set[{}]',\n    SHAPE_TUPLE_ELLIPSIS: 'Tuple[{}, ...]',\n    SHAPE_SEQUENCE: 'Sequence[{}]',\n    SHAPE_FROZENSET: 'FrozenSet[{}]',\n    SHAPE_ITERABLE: 'Iterable[{}]',\n    SHAPE_DEQUE: 'Deque[{}]',\n    SHAPE_DICT: 'Dict[{}]',\n    SHAPE_DEFAULTDICT: 'DefaultDict[{}]',\n    SHAPE_COUNTER: 'Counter[{}]',\n}\n\nMAPPING_LIKE_SHAPES: Set[int] = {SHAPE_DEFAULTDICT, SHAPE_DICT, SHAPE_MAPPING, SHAPE_COUNTER}\n\n\nclass ModelField(Representation):\n    __slots__ = (\n        'type_',\n        'outer_type_',\n        'annotation',\n        'sub_fields',\n        'sub_fields_mapping',\n        'key_field',\n        'validators',\n        'pre_validators',\n        'post_validators',\n        'default',\n        'default_factory',\n        'required',\n        'final',\n        'model_config',\n        'name',\n        'alias',\n        'has_alias',\n        'field_info',\n        'discriminator_key',\n        'discriminator_alias',\n        'validate_always',\n        'allow_none',\n        'shape',\n        'class_validators',\n        'parse_json',\n    )\n\n    def __init__(\n        self,\n        *,\n        name: str,\n        type_: Type[Any],\n        class_validators: Optional[Dict[str, Validator]],\n        model_config: Type['BaseConfig'],\n        default: Any = None,\n        default_factory: Optional[NoArgAnyCallable] = None,\n        required: 'BoolUndefined' = Undefined,\n        final: bool = False,\n        alias: Optional[str] = None,\n        field_info: Optional[FieldInfo] = None,\n    ) -> None:\n        self.name: str = name\n        self.has_alias: bool = alias is not None\n        self.alias: str = alias if alias is not None else name\n        self.annotation = type_\n        self.type_: Any = convert_generics(type_)\n        self.outer_type_: Any = type_\n        self.class_validators = class_validators or {}\n        self.default: Any = default\n        self.default_factory: Optional[NoArgAnyCallable] = default_factory\n        self.required: 'BoolUndefined' = required\n        self.final: bool = final\n        self.model_config = model_config\n        self.field_info: FieldInfo = field_info or FieldInfo(default)\n        self.discriminator_key: Optional[str] = self.field_info.discriminator\n        self.discriminator_alias: Optional[str] = self.discriminator_key\n\n        self.allow_none: bool = False\n        self.validate_always: bool = False\n        self.sub_fields: Optional[List[ModelField]] = None\n        self.sub_fields_mapping: Optional[Dict[str, 'ModelField']] = None  # used for discriminated union\n        self.key_field: Optional[ModelField] = None\n        self.validators: 'ValidatorsList' = []\n        self.pre_validators: Optional['ValidatorsList'] = None\n        self.post_validators: Optional['ValidatorsList'] = None\n        self.parse_json: bool = False\n        self.shape: int = SHAPE_SINGLETON\n        self.model_config.prepare_field(self)\n        self.prepare()\n\n    def get_default(self) -> Any:\n        return smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()\n\n    @staticmethod\n    def _get_field_info(\n        field_name: str, annotation: Any, value: Any, config: Type['BaseConfig']\n    ) -> Tuple[FieldInfo, Any]:\n        \"\"\"\n        Get a FieldInfo from a root typing.Annotated annotation, value, or config default.\n\n        The FieldInfo may be set in typing.Annotated or the value, but not both. If neither contain\n        a FieldInfo, a new one will be created using the config.\n\n        :param field_name: name of the field for use in error messages\n        :param annotation: a type hint such as `str` or `Annotated[str, Field(..., min_length=5)]`\n        :param value: the field's assigned value\n        :param config: the model's config object\n        :return: the FieldInfo contained in the `annotation`, the value, or a new one from the config.\n        \"\"\"\n        field_info_from_config = config.get_field_info(field_name)\n\n        field_info = None\n        if get_origin(annotation) is Annotated:\n            field_infos = [arg for arg in get_args(annotation)[1:] if isinstance(arg, FieldInfo)]\n            if len(field_infos) > 1:\n                raise ValueError(f'cannot specify multiple `Annotated` `Field`s for {field_name!r}')\n            field_info = next(iter(field_infos), None)\n            if field_info is not None:\n                field_info = copy.copy(field_info)\n                field_info.update_from_config(field_info_from_config)\n                if field_info.default not in (Undefined, Required):\n                    raise ValueError(f'`Field` default cannot be set in `Annotated` for {field_name!r}')\n                if value is not Undefined and value is not Required:\n                    # check also `Required` because of `validate_arguments` that sets `...` as default value\n                    field_info.default = value\n\n        if isinstance(value, FieldInfo):\n            if field_info is not None:\n                raise ValueError(f'cannot specify `Annotated` and value `Field`s together for {field_name!r}')\n            field_info = value\n            field_info.update_from_config(field_info_from_config)\n        elif field_info is None:\n            field_info = FieldInfo(value, **field_info_from_config)\n        value = None if field_info.default_factory is not None else field_info.default\n        field_info._validate()\n        return field_info, value\n\n    @classmethod\n    def infer(\n        cls,\n        *,\n        name: str,\n        value: Any,\n        annotation: Any,\n        class_validators: Optional[Dict[str, Validator]],\n        config: Type['BaseConfig'],\n    ) -> 'ModelField':\n        from pydantic.v1.schema import get_annotation_from_field_info\n\n        field_info, value = cls._get_field_info(name, annotation, value, config)\n        required: 'BoolUndefined' = Undefined\n        if value is Required:\n            required = True\n            value = None\n        elif value is not Undefined:\n            required = False\n        annotation = get_annotation_from_field_info(annotation, field_info, name, config.validate_assignment)\n\n        return cls(\n            name=name,\n            type_=annotation,\n            alias=field_info.alias,\n            class_validators=class_validators,\n            default=value,\n            default_factory=field_info.default_factory,\n            required=required,\n            model_config=config,\n            field_info=field_info,\n        )\n\n    def set_config(self, config: Type['BaseConfig']) -> None:\n        self.model_config = config\n        info_from_config = config.get_field_info(self.name)\n        config.prepare_field(self)\n        new_alias = info_from_config.get('alias')\n        new_alias_priority = info_from_config.get('alias_priority') or 0\n        if new_alias and new_alias_priority >= (self.field_info.alias_priority or 0):\n            self.field_info.alias = new_alias\n            self.field_info.alias_priority = new_alias_priority\n            self.alias = new_alias\n        new_exclude = info_from_config.get('exclude')\n        if new_exclude is not None:\n            self.field_info.exclude = ValueItems.merge(self.field_info.exclude, new_exclude)\n        new_include = info_from_config.get('include')\n        if new_include is not None:\n            self.field_info.include = ValueItems.merge(self.field_info.include, new_include, intersect=True)\n\n    @property\n    def alt_alias(self) -> bool:\n        return self.name != self.alias\n\n    def prepare(self) -> None:\n        \"\"\"\n        Prepare the field but inspecting self.default, self.type_ etc.\n\n        Note: this method is **not** idempotent (because _type_analysis is not idempotent),\n        e.g. calling it it multiple times may modify the field and configure it incorrectly.\n        \"\"\"\n        self._set_default_and_type()\n        if self.type_.__class__ is ForwardRef or self.type_.__class__ is DeferredType:\n            # self.type_ is currently a ForwardRef and there's nothing we can do now,\n            # user will need to call model.update_forward_refs()\n            return\n\n        self._type_analysis()\n        if self.required is Undefined:\n            self.required = True\n        if self.default is Undefined and self.default_factory is None:\n            self.default = None\n        self.populate_validators()\n\n    def _set_default_and_type(self) -> None:\n        \"\"\"\n        Set the default value, infer the type if needed and check if `None` value is valid.\n        \"\"\"\n        if self.default_factory is not None:\n            if self.type_ is Undefined:\n                raise errors_.ConfigError(\n                    f'you need to set the type of field {self.name!r} when using `default_factory`'\n                )\n            return\n\n        default_value = self.get_default()\n\n        if default_value is not None and self.type_ is Undefined:\n            self.type_ = default_value.__class__\n            self.outer_type_ = self.type_\n            self.annotation = self.type_\n\n        if self.type_ is Undefined:\n            raise errors_.ConfigError(f'unable to infer type for attribute \"{self.name}\"')\n\n        if self.required is False and default_value is None:\n            self.allow_none = True\n\n    def _type_analysis(self) -> None:  # noqa: C901 (ignore complexity)\n        # typing interface is horrible, we have to do some ugly checks\n        if lenient_issubclass(self.type_, JsonWrapper):\n            self.type_ = self.type_.inner_type\n            self.parse_json = True\n        elif lenient_issubclass(self.type_, Json):\n            self.type_ = Any\n            self.parse_json = True\n        elif isinstance(self.type_, TypeVar):\n            if self.type_.__bound__:\n                self.type_ = self.type_.__bound__\n            elif self.type_.__constraints__:\n                self.type_ = Union[self.type_.__constraints__]\n            else:\n                self.type_ = Any\n        elif is_new_type(self.type_):\n            self.type_ = new_type_supertype(self.type_)\n\n        if self.type_ is Any or self.type_ is object:\n            if self.required is Undefined:\n                self.required = False\n            self.allow_none = True\n            return\n        elif self.type_ is Pattern or self.type_ is re.Pattern:\n            # python 3.7 only, Pattern is a typing object but without sub fields\n            return\n        elif is_literal_type(self.type_):\n            return\n        elif is_typeddict(self.type_):\n            return\n\n        if is_finalvar(self.type_):\n            self.final = True\n\n            if self.type_ is Final:\n                self.type_ = Any\n            else:\n                self.type_ = get_args(self.type_)[0]\n\n            self._type_analysis()\n            return\n\n        origin = get_origin(self.type_)\n\n        if origin is Annotated or is_typeddict_special(origin):\n            self.type_ = get_args(self.type_)[0]\n            self._type_analysis()\n            return\n\n        if self.discriminator_key is not None and not is_union(origin):\n            raise TypeError('`discriminator` can only be used with `Union` type with more than one variant')\n\n        # add extra check for `collections.abc.Hashable` for python 3.10+ where origin is not `None`\n        if origin is None or origin is CollectionsHashable:\n            # field is not \"typing\" object eg. Union, Dict, List etc.\n            # allow None for virtual superclasses of NoneType, e.g. Hashable\n            if isinstance(self.type_, type) and isinstance(None, self.type_):\n                self.allow_none = True\n            return\n        elif origin is Callable:\n            return\n        elif is_union(origin):\n            types_ = []\n            for type_ in get_args(self.type_):\n                if is_none_type(type_) or type_ is Any or type_ is object:\n                    if self.required is Undefined:\n                        self.required = False\n                    self.allow_none = True\n                if is_none_type(type_):\n                    continue\n                types_.append(type_)\n\n            if len(types_) == 1:\n                # Optional[]\n                self.type_ = types_[0]\n                # this is the one case where the \"outer type\" isn't just the original type\n                self.outer_type_ = self.type_\n                # re-run to correctly interpret the new self.type_\n                self._type_analysis()\n            else:\n                self.sub_fields = [self._create_sub_type(t, f'{self.name}_{display_as_type(t)}') for t in types_]\n\n                if self.discriminator_key is not None:\n                    self.prepare_discriminated_union_sub_fields()\n            return\n        elif issubclass(origin, Tuple):  # type: ignore\n            # origin == Tuple without item type\n            args = get_args(self.type_)\n            if not args:  # plain tuple\n                self.type_ = Any\n                self.shape = SHAPE_TUPLE_ELLIPSIS\n            elif len(args) == 2 and args[1] is Ellipsis:  # e.g. Tuple[int, ...]\n                self.type_ = args[0]\n                self.shape = SHAPE_TUPLE_ELLIPSIS\n                self.sub_fields = [self._create_sub_type(args[0], f'{self.name}_0')]\n            elif args == ((),):  # Tuple[()] means empty tuple\n                self.shape = SHAPE_TUPLE\n                self.type_ = Any\n                self.sub_fields = []\n            else:\n                self.shape = SHAPE_TUPLE\n                self.sub_fields = [self._create_sub_type(t, f'{self.name}_{i}') for i, t in enumerate(args)]\n            return\n        elif issubclass(origin, List):\n            # Create self validators\n            get_validators = getattr(self.type_, '__get_validators__', None)\n            if get_validators:\n                self.class_validators.update(\n                    {f'list_{i}': Validator(validator, pre=True) for i, validator in enumerate(get_validators())}\n                )\n\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_LIST\n        elif issubclass(origin, Set):\n            # Create self validators\n            get_validators = getattr(self.type_, '__get_validators__', None)\n            if get_validators:\n                self.class_validators.update(\n                    {f'set_{i}': Validator(validator, pre=True) for i, validator in enumerate(get_validators())}\n                )\n\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_SET\n        elif issubclass(origin, FrozenSet):\n            # Create self validators\n            get_validators = getattr(self.type_, '__get_validators__', None)\n            if get_validators:\n                self.class_validators.update(\n                    {f'frozenset_{i}': Validator(validator, pre=True) for i, validator in enumerate(get_validators())}\n                )\n\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_FROZENSET\n        elif issubclass(origin, Deque):\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_DEQUE\n        elif issubclass(origin, Sequence):\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_SEQUENCE\n        # priority to most common mapping: dict\n        elif origin is dict or origin is Dict:\n            self.key_field = self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)\n            self.type_ = get_args(self.type_)[1]\n            self.shape = SHAPE_DICT\n        elif issubclass(origin, DefaultDict):\n            self.key_field = self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)\n            self.type_ = get_args(self.type_)[1]\n            self.shape = SHAPE_DEFAULTDICT\n        elif issubclass(origin, Counter):\n            self.key_field = self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)\n            self.type_ = int\n            self.shape = SHAPE_COUNTER\n        elif issubclass(origin, Mapping):\n            self.key_field = self._create_sub_type(get_args(self.type_)[0], 'key_' + self.name, for_keys=True)\n            self.type_ = get_args(self.type_)[1]\n            self.shape = SHAPE_MAPPING\n        # Equality check as almost everything inherits form Iterable, including str\n        # check for Iterable and CollectionsIterable, as it could receive one even when declared with the other\n        elif origin in {Iterable, CollectionsIterable}:\n            self.type_ = get_args(self.type_)[0]\n            self.shape = SHAPE_ITERABLE\n            self.sub_fields = [self._create_sub_type(self.type_, f'{self.name}_type')]\n        elif issubclass(origin, Type):  # type: ignore\n            return\n        elif hasattr(origin, '__get_validators__') or self.model_config.arbitrary_types_allowed:\n            # Is a Pydantic-compatible generic that handles itself\n            # or we have arbitrary_types_allowed = True\n            self.shape = SHAPE_GENERIC\n            self.sub_fields = [self._create_sub_type(t, f'{self.name}_{i}') for i, t in enumerate(get_args(self.type_))]\n            self.type_ = origin\n            return\n        else:\n            raise TypeError(f'Fields of type \"{origin}\" are not supported.')\n\n        # type_ has been refined eg. as the type of a List and sub_fields needs to be populated\n        self.sub_fields = [self._create_sub_type(self.type_, '_' + self.name)]\n\n    def prepare_discriminated_union_sub_fields(self) -> None:\n        \"\"\"\n        Prepare the mapping <discriminator key> -> <ModelField> and update `sub_fields`\n        Note that this process can be aborted if a `ForwardRef` is encountered\n        \"\"\"\n        assert self.discriminator_key is not None\n\n        if self.type_.__class__ is DeferredType:\n            return\n\n        assert self.sub_fields is not None\n        sub_fields_mapping: Dict[str, 'ModelField'] = {}\n        all_aliases: Set[str] = set()\n\n        for sub_field in self.sub_fields:\n            t = sub_field.type_\n            if t.__class__ is ForwardRef:\n                # Stopping everything...will need to call `update_forward_refs`\n                return\n\n            alias, discriminator_values = get_discriminator_alias_and_values(t, self.discriminator_key)\n            all_aliases.add(alias)\n            for discriminator_value in discriminator_values:\n                sub_fields_mapping[discriminator_value] = sub_field\n\n        self.sub_fields_mapping = sub_fields_mapping\n        self.discriminator_alias = get_unique_discriminator_alias(all_aliases, self.discriminator_key)\n\n    def _create_sub_type(self, type_: Type[Any], name: str, *, for_keys: bool = False) -> 'ModelField':\n        if for_keys:\n            class_validators = None\n        else:\n            # validators for sub items should not have `each_item` as we want to check only the first sublevel\n            class_validators = {\n                k: Validator(\n                    func=v.func,\n                    pre=v.pre,\n                    each_item=False,\n                    always=v.always,\n                    check_fields=v.check_fields,\n                    skip_on_failure=v.skip_on_failure,\n                )\n                for k, v in self.class_validators.items()\n                if v.each_item\n            }\n\n        field_info, _ = self._get_field_info(name, type_, None, self.model_config)\n\n        return self.__class__(\n            type_=type_,\n            name=name,\n            class_validators=class_validators,\n            model_config=self.model_config,\n            field_info=field_info,\n        )\n\n    def populate_validators(self) -> None:\n        \"\"\"\n        Prepare self.pre_validators, self.validators, and self.post_validators based on self.type_'s  __get_validators__\n        and class validators. This method should be idempotent, e.g. it should be safe to call multiple times\n        without mis-configuring the field.\n        \"\"\"\n        self.validate_always = getattr(self.type_, 'validate_always', False) or any(\n            v.always for v in self.class_validators.values()\n        )\n\n        class_validators_ = self.class_validators.values()\n        if not self.sub_fields or self.shape == SHAPE_GENERIC:\n            get_validators = getattr(self.type_, '__get_validators__', None)\n            v_funcs = (\n                *[v.func for v in class_validators_ if v.each_item and v.pre],\n                *(get_validators() if get_validators else list(find_validators(self.type_, self.model_config))),\n                *[v.func for v in class_validators_ if v.each_item and not v.pre],\n            )\n            self.validators = prep_validators(v_funcs)\n\n        self.pre_validators = []\n        self.post_validators = []\n\n        if self.field_info and self.field_info.const:\n            self.post_validators.append(make_generic_validator(constant_validator))\n\n        if class_validators_:\n            self.pre_validators += prep_validators(v.func for v in class_validators_ if not v.each_item and v.pre)\n            self.post_validators += prep_validators(v.func for v in class_validators_ if not v.each_item and not v.pre)\n\n        if self.parse_json:\n            self.pre_validators.append(make_generic_validator(validate_json))\n\n        self.pre_validators = self.pre_validators or None\n        self.post_validators = self.post_validators or None\n\n    def validate(\n        self, v: Any, values: Dict[str, Any], *, loc: 'LocStr', cls: Optional['ModelOrDc'] = None\n    ) -> 'ValidateReturn':\n        assert self.type_.__class__ is not DeferredType\n\n        if self.type_.__class__ is ForwardRef:\n            assert cls is not None\n            raise ConfigError(\n                f'field \"{self.name}\" not yet prepared so type is still a ForwardRef, '\n                f'you might need to call {cls.__name__}.update_forward_refs().'\n            )\n\n        errors: Optional['ErrorList']\n        if self.pre_validators:\n            v, errors = self._apply_validators(v, values, loc, cls, self.pre_validators)\n            if errors:\n                return v, errors\n\n        if v is None:\n            if is_none_type(self.type_):\n                # keep validating\n                pass\n            elif self.allow_none:\n                if self.post_validators:\n                    return self._apply_validators(v, values, loc, cls, self.post_validators)\n                else:\n                    return None, None\n            else:\n                return v, ErrorWrapper(NoneIsNotAllowedError(), loc)\n\n        if self.shape == SHAPE_SINGLETON:\n            v, errors = self._validate_singleton(v, values, loc, cls)\n        elif self.shape in MAPPING_LIKE_SHAPES:\n            v, errors = self._validate_mapping_like(v, values, loc, cls)\n        elif self.shape == SHAPE_TUPLE:\n            v, errors = self._validate_tuple(v, values, loc, cls)\n        elif self.shape == SHAPE_ITERABLE:\n            v, errors = self._validate_iterable(v, values, loc, cls)\n        elif self.shape == SHAPE_GENERIC:\n            v, errors = self._apply_validators(v, values, loc, cls, self.validators)\n        else:\n            #  sequence, list, set, generator, tuple with ellipsis, frozen set\n            v, errors = self._validate_sequence_like(v, values, loc, cls)\n\n        if not errors and self.post_validators:\n            v, errors = self._apply_validators(v, values, loc, cls, self.post_validators)\n        return v, errors\n\n    def _validate_sequence_like(  # noqa: C901 (ignore complexity)\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        \"\"\"\n        Validate sequence-like containers: lists, tuples, sets and generators\n        Note that large if-else blocks are necessary to enable Cython\n        optimization, which is why we disable the complexity check above.\n        \"\"\"\n        if not sequence_like(v):\n            e: errors_.PydanticTypeError\n            if self.shape == SHAPE_LIST:\n                e = errors_.ListError()\n            elif self.shape in (SHAPE_TUPLE, SHAPE_TUPLE_ELLIPSIS):\n                e = errors_.TupleError()\n            elif self.shape == SHAPE_SET:\n                e = errors_.SetError()\n            elif self.shape == SHAPE_FROZENSET:\n                e = errors_.FrozenSetError()\n            else:\n                e = errors_.SequenceError()\n            return v, ErrorWrapper(e, loc)\n\n        loc = loc if isinstance(loc, tuple) else (loc,)\n        result = []\n        errors: List[ErrorList] = []\n        for i, v_ in enumerate(v):\n            v_loc = *loc, i\n            r, ee = self._validate_singleton(v_, values, v_loc, cls)\n            if ee:\n                errors.append(ee)\n            else:\n                result.append(r)\n\n        if errors:\n            return v, errors\n\n        converted: Union[List[Any], Set[Any], FrozenSet[Any], Tuple[Any, ...], Iterator[Any], Deque[Any]] = result\n\n        if self.shape == SHAPE_SET:\n            converted = set(result)\n        elif self.shape == SHAPE_FROZENSET:\n            converted = frozenset(result)\n        elif self.shape == SHAPE_TUPLE_ELLIPSIS:\n            converted = tuple(result)\n        elif self.shape == SHAPE_DEQUE:\n            converted = deque(result, maxlen=getattr(v, 'maxlen', None))\n        elif self.shape == SHAPE_SEQUENCE:\n            if isinstance(v, tuple):\n                converted = tuple(result)\n            elif isinstance(v, set):\n                converted = set(result)\n            elif isinstance(v, Generator):\n                converted = iter(result)\n            elif isinstance(v, deque):\n                converted = deque(result, maxlen=getattr(v, 'maxlen', None))\n        return converted, None\n\n    def _validate_iterable(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        \"\"\"\n        Validate Iterables.\n\n        This intentionally doesn't validate values to allow infinite generators.\n        \"\"\"\n\n        try:\n            iterable = iter(v)\n        except TypeError:\n            return v, ErrorWrapper(errors_.IterableError(), loc)\n        return iterable, None\n\n    def _validate_tuple(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        e: Optional[Exception] = None\n        if not sequence_like(v):\n            e = errors_.TupleError()\n        else:\n            actual_length, expected_length = len(v), len(self.sub_fields)  # type: ignore\n            if actual_length != expected_length:\n                e = errors_.TupleLengthError(actual_length=actual_length, expected_length=expected_length)\n\n        if e:\n            return v, ErrorWrapper(e, loc)\n\n        loc = loc if isinstance(loc, tuple) else (loc,)\n        result = []\n        errors: List[ErrorList] = []\n        for i, (v_, field) in enumerate(zip(v, self.sub_fields)):  # type: ignore\n            v_loc = *loc, i\n            r, ee = field.validate(v_, values, loc=v_loc, cls=cls)\n            if ee:\n                errors.append(ee)\n            else:\n                result.append(r)\n\n        if errors:\n            return v, errors\n        else:\n            return tuple(result), None\n\n    def _validate_mapping_like(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        try:\n            v_iter = dict_validator(v)\n        except TypeError as exc:\n            return v, ErrorWrapper(exc, loc)\n\n        loc = loc if isinstance(loc, tuple) else (loc,)\n        result, errors = {}, []\n        for k, v_ in v_iter.items():\n            v_loc = *loc, '__key__'\n            key_result, key_errors = self.key_field.validate(k, values, loc=v_loc, cls=cls)  # type: ignore\n            if key_errors:\n                errors.append(key_errors)\n                continue\n\n            v_loc = *loc, k\n            value_result, value_errors = self._validate_singleton(v_, values, v_loc, cls)\n            if value_errors:\n                errors.append(value_errors)\n                continue\n\n            result[key_result] = value_result\n        if errors:\n            return v, errors\n        elif self.shape == SHAPE_DICT:\n            return result, None\n        elif self.shape == SHAPE_DEFAULTDICT:\n            return defaultdict(self.type_, result), None\n        elif self.shape == SHAPE_COUNTER:\n            return CollectionCounter(result), None\n        else:\n            return self._get_mapping_value(v, result), None\n\n    def _get_mapping_value(self, original: T, converted: Dict[Any, Any]) -> Union[T, Dict[Any, Any]]:\n        \"\"\"\n        When type is `Mapping[KT, KV]` (or another unsupported mapping), we try to avoid\n        coercing to `dict` unwillingly.\n        \"\"\"\n        original_cls = original.__class__\n\n        if original_cls == dict or original_cls == Dict:\n            return converted\n        elif original_cls in {defaultdict, DefaultDict}:\n            return defaultdict(self.type_, converted)\n        else:\n            try:\n                # Counter, OrderedDict, UserDict, ...\n                return original_cls(converted)  # type: ignore\n            except TypeError:\n                raise RuntimeError(f'Could not convert dictionary to {original_cls.__name__!r}') from None\n\n    def _validate_singleton(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        if self.sub_fields:\n            if self.discriminator_key is not None:\n                return self._validate_discriminated_union(v, values, loc, cls)\n\n            errors = []\n\n            if self.model_config.smart_union and is_union(get_origin(self.type_)):\n                # 1st pass: check if the value is an exact instance of one of the Union types\n                # (e.g. to avoid coercing a bool into an int)\n                for field in self.sub_fields:\n                    if v.__class__ is field.outer_type_:\n                        return v, None\n\n                # 2nd pass: check if the value is an instance of any subclass of the Union types\n                for field in self.sub_fields:\n                    # This whole logic will be improved later on to support more complex `isinstance` checks\n                    # It will probably be done once a strict mode is added and be something like:\n                    # ```\n                    #     value, error = field.validate(v, values, strict=True)\n                    #     if error is None:\n                    #         return value, None\n                    # ```\n                    try:\n                        if isinstance(v, field.outer_type_):\n                            return v, None\n                    except TypeError:\n                        # compound type\n                        if lenient_isinstance(v, get_origin(field.outer_type_)):\n                            value, error = field.validate(v, values, loc=loc, cls=cls)\n                            if not error:\n                                return value, None\n\n            # 1st pass by default or 3rd pass with `smart_union` enabled:\n            # check if the value can be coerced into one of the Union types\n            for field in self.sub_fields:\n                value, error = field.validate(v, values, loc=loc, cls=cls)\n                if error:\n                    errors.append(error)\n                else:\n                    return value, None\n            return v, errors\n        else:\n            return self._apply_validators(v, values, loc, cls, self.validators)\n\n    def _validate_discriminated_union(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc']\n    ) -> 'ValidateReturn':\n        assert self.discriminator_key is not None\n        assert self.discriminator_alias is not None\n\n        try:\n            try:\n                discriminator_value = v[self.discriminator_alias]\n            except KeyError:\n                if self.model_config.allow_population_by_field_name:\n                    discriminator_value = v[self.discriminator_key]\n                else:\n                    raise\n        except KeyError:\n            return v, ErrorWrapper(MissingDiscriminator(discriminator_key=self.discriminator_key), loc)\n        except TypeError:\n            try:\n                # BaseModel or dataclass\n                discriminator_value = getattr(v, self.discriminator_key)\n            except (AttributeError, TypeError):\n                return v, ErrorWrapper(MissingDiscriminator(discriminator_key=self.discriminator_key), loc)\n\n        if self.sub_fields_mapping is None:\n            assert cls is not None\n            raise ConfigError(\n                f'field \"{self.name}\" not yet prepared so type is still a ForwardRef, '\n                f'you might need to call {cls.__name__}.update_forward_refs().'\n            )\n\n        try:\n            sub_field = self.sub_fields_mapping[discriminator_value]\n        except (KeyError, TypeError):\n            # KeyError: `discriminator_value` is not in the dictionary.\n            # TypeError: `discriminator_value` is unhashable.\n            assert self.sub_fields_mapping is not None\n            return v, ErrorWrapper(\n                InvalidDiscriminator(\n                    discriminator_key=self.discriminator_key,\n                    discriminator_value=discriminator_value,\n                    allowed_values=list(self.sub_fields_mapping),\n                ),\n                loc,\n            )\n        else:\n            if not isinstance(loc, tuple):\n                loc = (loc,)\n            return sub_field.validate(v, values, loc=(*loc, display_as_type(sub_field.type_)), cls=cls)\n\n    def _apply_validators(\n        self, v: Any, values: Dict[str, Any], loc: 'LocStr', cls: Optional['ModelOrDc'], validators: 'ValidatorsList'\n    ) -> 'ValidateReturn':\n        for validator in validators:\n            try:\n                v = validator(cls, v, values, self, self.model_config)\n            except (ValueError, TypeError, AssertionError) as exc:\n                return v, ErrorWrapper(exc, loc)\n        return v, None\n\n    def is_complex(self) -> bool:\n        \"\"\"\n        Whether the field is \"complex\" eg. env variables should be parsed as JSON.\n        \"\"\"\n        from pydantic.v1.main import BaseModel\n\n        return (\n            self.shape != SHAPE_SINGLETON\n            or hasattr(self.type_, '__pydantic_model__')\n            or lenient_issubclass(self.type_, (BaseModel, list, set, frozenset, dict))\n        )\n\n    def _type_display(self) -> PyObjectStr:\n        t = display_as_type(self.type_)\n\n        if self.shape in MAPPING_LIKE_SHAPES:\n            t = f'Mapping[{display_as_type(self.key_field.type_)}, {t}]'  # type: ignore\n        elif self.shape == SHAPE_TUPLE:\n            t = 'Tuple[{}]'.format(', '.join(display_as_type(f.type_) for f in self.sub_fields))  # type: ignore\n        elif self.shape == SHAPE_GENERIC:\n            assert self.sub_fields\n            t = '{}[{}]'.format(\n                display_as_type(self.type_), ', '.join(display_as_type(f.type_) for f in self.sub_fields)\n            )\n        elif self.shape != SHAPE_SINGLETON:\n            t = SHAPE_NAME_LOOKUP[self.shape].format(t)\n\n        if self.allow_none and (self.shape != SHAPE_SINGLETON or not self.sub_fields):\n            t = f'Optional[{t}]'\n        return PyObjectStr(t)\n\n    def __repr_args__(self) -> 'ReprArgs':\n        args = [('name', self.name), ('type', self._type_display()), ('required', self.required)]\n\n        if not self.required:\n            if self.default_factory is not None:\n                args.append(('default_factory', f'<function {self.default_factory.__name__}>'))\n            else:\n                args.append(('default', self.default))\n\n        if self.alt_alias:\n            args.append(('alias', self.alias))\n        return args\n\n\nclass ModelPrivateAttr(Representation):\n    __slots__ = ('default', 'default_factory')\n\n    def __init__(self, default: Any = Undefined, *, default_factory: Optional[NoArgAnyCallable] = None) -> None:\n        self.default = default\n        self.default_factory = default_factory\n\n    def get_default(self) -> Any:\n        return smart_deepcopy(self.default) if self.default_factory is None else self.default_factory()\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and (self.default, self.default_factory) == (\n            other.default,\n            other.default_factory,\n        )\n\n\ndef PrivateAttr(\n    default: Any = Undefined,\n    *,\n    default_factory: Optional[NoArgAnyCallable] = None,\n) -> Any:\n    \"\"\"\n    Indicates that attribute is only used internally and never mixed with regular fields.\n\n    Types or values of private attrs are not checked by pydantic and it's up to you to keep them relevant.\n\n    Private attrs are stored in model __slots__.\n\n    :param default: the attribute\u2019s default value\n    :param default_factory: callable that will be called when a default value is needed for this attribute\n      If both `default` and `default_factory` are set, an error is raised.\n    \"\"\"\n    if default is not Undefined and default_factory is not None:\n        raise ValueError('cannot specify both default and default_factory')\n\n    return ModelPrivateAttr(\n        default,\n        default_factory=default_factory,\n    )\n\n\nclass DeferredType:\n    \"\"\"\n    Used to postpone field preparation, while creating recursive generic models.\n    \"\"\"\n\n\ndef is_finalvar_with_default_val(type_: Type[Any], val: Any) -> bool:\n    return is_finalvar(type_) and val is not Undefined and not isinstance(val, FieldInfo)\n", "pydantic/v1/version.py": "__all__ = 'compiled', 'VERSION', 'version_info'\n\nVERSION = '1.10.17'\n\ntry:\n    import cython  # type: ignore\nexcept ImportError:\n    compiled: bool = False\nelse:  # pragma: no cover\n    try:\n        compiled = cython.compiled\n    except AttributeError:\n        compiled = False\n\n\ndef version_info() -> str:\n    import platform\n    import sys\n    from importlib import import_module\n    from pathlib import Path\n\n    optional_deps = []\n    for p in ('devtools', 'dotenv', 'email-validator', 'typing-extensions'):\n        try:\n            import_module(p.replace('-', '_'))\n        except ImportError:\n            continue\n        optional_deps.append(p)\n\n    info = {\n        'pydantic version': VERSION,\n        'pydantic compiled': compiled,\n        'install path': Path(__file__).resolve().parent,\n        'python version': sys.version,\n        'platform': platform.platform(),\n        'optional deps. installed': optional_deps,\n    }\n    return '\\n'.join('{:>30} {}'.format(k + ':', str(v).replace('\\n', ' ')) for k, v in info.items())\n", "pydantic/v1/tools.py": "import json\nfrom functools import lru_cache\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Optional, Type, TypeVar, Union\n\nfrom pydantic.v1.parse import Protocol, load_file, load_str_bytes\nfrom pydantic.v1.types import StrBytes\nfrom pydantic.v1.typing import display_as_type\n\n__all__ = ('parse_file_as', 'parse_obj_as', 'parse_raw_as', 'schema_of', 'schema_json_of')\n\nNameFactory = Union[str, Callable[[Type[Any]], str]]\n\nif TYPE_CHECKING:\n    from pydantic.v1.typing import DictStrAny\n\n\ndef _generate_parsing_type_name(type_: Any) -> str:\n    return f'ParsingModel[{display_as_type(type_)}]'\n\n\n@lru_cache(maxsize=2048)\ndef _get_parsing_type(type_: Any, *, type_name: Optional[NameFactory] = None) -> Any:\n    from pydantic.v1.main import create_model\n\n    if type_name is None:\n        type_name = _generate_parsing_type_name\n    if not isinstance(type_name, str):\n        type_name = type_name(type_)\n    return create_model(type_name, __root__=(type_, ...))\n\n\nT = TypeVar('T')\n\n\ndef parse_obj_as(type_: Type[T], obj: Any, *, type_name: Optional[NameFactory] = None) -> T:\n    model_type = _get_parsing_type(type_, type_name=type_name)  # type: ignore[arg-type]\n    return model_type(__root__=obj).__root__\n\n\ndef parse_file_as(\n    type_: Type[T],\n    path: Union[str, Path],\n    *,\n    content_type: str = None,\n    encoding: str = 'utf8',\n    proto: Protocol = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n    type_name: Optional[NameFactory] = None,\n) -> T:\n    obj = load_file(\n        path,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n        json_loads=json_loads,\n    )\n    return parse_obj_as(type_, obj, type_name=type_name)\n\n\ndef parse_raw_as(\n    type_: Type[T],\n    b: StrBytes,\n    *,\n    content_type: str = None,\n    encoding: str = 'utf8',\n    proto: Protocol = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n    type_name: Optional[NameFactory] = None,\n) -> T:\n    obj = load_str_bytes(\n        b,\n        proto=proto,\n        content_type=content_type,\n        encoding=encoding,\n        allow_pickle=allow_pickle,\n        json_loads=json_loads,\n    )\n    return parse_obj_as(type_, obj, type_name=type_name)\n\n\ndef schema_of(type_: Any, *, title: Optional[NameFactory] = None, **schema_kwargs: Any) -> 'DictStrAny':\n    \"\"\"Generate a JSON schema (as dict) for the passed model or dynamically generated one\"\"\"\n    return _get_parsing_type(type_, type_name=title).schema(**schema_kwargs)\n\n\ndef schema_json_of(type_: Any, *, title: Optional[NameFactory] = None, **schema_json_kwargs: Any) -> str:\n    \"\"\"Generate a JSON schema (as JSON) for the passed model or dynamically generated one\"\"\"\n    return _get_parsing_type(type_, type_name=title).schema_json(**schema_json_kwargs)\n", "pydantic/v1/error_wrappers.py": "import json\nfrom typing import TYPE_CHECKING, Any, Dict, Generator, List, Optional, Sequence, Tuple, Type, Union\n\nfrom pydantic.v1.json import pydantic_encoder\nfrom pydantic.v1.utils import Representation\n\nif TYPE_CHECKING:\n    from typing_extensions import TypedDict\n\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.types import ModelOrDc\n    from pydantic.v1.typing import ReprArgs\n\n    Loc = Tuple[Union[int, str], ...]\n\n    class _ErrorDictRequired(TypedDict):\n        loc: Loc\n        msg: str\n        type: str\n\n    class ErrorDict(_ErrorDictRequired, total=False):\n        ctx: Dict[str, Any]\n\n\n__all__ = 'ErrorWrapper', 'ValidationError'\n\n\nclass ErrorWrapper(Representation):\n    __slots__ = 'exc', '_loc'\n\n    def __init__(self, exc: Exception, loc: Union[str, 'Loc']) -> None:\n        self.exc = exc\n        self._loc = loc\n\n    def loc_tuple(self) -> 'Loc':\n        if isinstance(self._loc, tuple):\n            return self._loc\n        else:\n            return (self._loc,)\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [('exc', self.exc), ('loc', self.loc_tuple())]\n\n\n# ErrorList is something like Union[List[Union[List[ErrorWrapper], ErrorWrapper]], ErrorWrapper]\n# but recursive, therefore just use:\nErrorList = Union[Sequence[Any], ErrorWrapper]\n\n\nclass ValidationError(Representation, ValueError):\n    __slots__ = 'raw_errors', 'model', '_error_cache'\n\n    def __init__(self, errors: Sequence[ErrorList], model: 'ModelOrDc') -> None:\n        self.raw_errors = errors\n        self.model = model\n        self._error_cache: Optional[List['ErrorDict']] = None\n\n    def errors(self) -> List['ErrorDict']:\n        if self._error_cache is None:\n            try:\n                config = self.model.__config__  # type: ignore\n            except AttributeError:\n                config = self.model.__pydantic_model__.__config__  # type: ignore\n            self._error_cache = list(flatten_errors(self.raw_errors, config))\n        return self._error_cache\n\n    def json(self, *, indent: Union[None, int, str] = 2) -> str:\n        return json.dumps(self.errors(), indent=indent, default=pydantic_encoder)\n\n    def __str__(self) -> str:\n        errors = self.errors()\n        no_errors = len(errors)\n        return (\n            f'{no_errors} validation error{\"\" if no_errors == 1 else \"s\"} for {self.model.__name__}\\n'\n            f'{display_errors(errors)}'\n        )\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [('model', self.model.__name__), ('errors', self.errors())]\n\n\ndef display_errors(errors: List['ErrorDict']) -> str:\n    return '\\n'.join(f'{_display_error_loc(e)}\\n  {e[\"msg\"]} ({_display_error_type_and_ctx(e)})' for e in errors)\n\n\ndef _display_error_loc(error: 'ErrorDict') -> str:\n    return ' -> '.join(str(e) for e in error['loc'])\n\n\ndef _display_error_type_and_ctx(error: 'ErrorDict') -> str:\n    t = 'type=' + error['type']\n    ctx = error.get('ctx')\n    if ctx:\n        return t + ''.join(f'; {k}={v}' for k, v in ctx.items())\n    else:\n        return t\n\n\ndef flatten_errors(\n    errors: Sequence[Any], config: Type['BaseConfig'], loc: Optional['Loc'] = None\n) -> Generator['ErrorDict', None, None]:\n    for error in errors:\n        if isinstance(error, ErrorWrapper):\n            if loc:\n                error_loc = loc + error.loc_tuple()\n            else:\n                error_loc = error.loc_tuple()\n\n            if isinstance(error.exc, ValidationError):\n                yield from flatten_errors(error.exc.raw_errors, config, error_loc)\n            else:\n                yield error_dict(error.exc, config, error_loc)\n        elif isinstance(error, list):\n            yield from flatten_errors(error, config, loc=loc)\n        else:\n            raise RuntimeError(f'Unknown error object: {error}')\n\n\ndef error_dict(exc: Exception, config: Type['BaseConfig'], loc: 'Loc') -> 'ErrorDict':\n    type_ = get_exc_type(exc.__class__)\n    msg_template = config.error_msg_templates.get(type_) or getattr(exc, 'msg_template', None)\n    ctx = exc.__dict__\n    if msg_template:\n        msg = msg_template.format(**ctx)\n    else:\n        msg = str(exc)\n\n    d: 'ErrorDict' = {'loc': loc, 'msg': msg, 'type': type_}\n\n    if ctx:\n        d['ctx'] = ctx\n\n    return d\n\n\n_EXC_TYPE_CACHE: Dict[Type[Exception], str] = {}\n\n\ndef get_exc_type(cls: Type[Exception]) -> str:\n    # slightly more efficient than using lru_cache since we don't need to worry about the cache filling up\n    try:\n        return _EXC_TYPE_CACHE[cls]\n    except KeyError:\n        r = _get_exc_type(cls)\n        _EXC_TYPE_CACHE[cls] = r\n        return r\n\n\ndef _get_exc_type(cls: Type[Exception]) -> str:\n    if issubclass(cls, AssertionError):\n        return 'assertion_error'\n\n    base_name = 'type_error' if issubclass(cls, TypeError) else 'value_error'\n    if cls in (TypeError, ValueError):\n        # just TypeError or ValueError, no extra code\n        return base_name\n\n    # if it's not a TypeError or ValueError, we just take the lowercase of the exception name\n    # no chaining or snake case logic, use \"code\" for more complex error types.\n    code = getattr(cls, 'code', None) or cls.__name__.replace('Error', '').lower()\n    return base_name + '.' + code\n", "pydantic/v1/errors.py": "from decimal import Decimal\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable, Sequence, Set, Tuple, Type, Union\n\nfrom pydantic.v1.typing import display_as_type\n\nif TYPE_CHECKING:\n    from pydantic.v1.typing import DictStrAny\n\n# explicitly state exports to avoid \"from pydantic.v1.errors import *\" also importing Decimal, Path etc.\n__all__ = (\n    'PydanticTypeError',\n    'PydanticValueError',\n    'ConfigError',\n    'MissingError',\n    'ExtraError',\n    'NoneIsNotAllowedError',\n    'NoneIsAllowedError',\n    'WrongConstantError',\n    'NotNoneError',\n    'BoolError',\n    'BytesError',\n    'DictError',\n    'EmailError',\n    'UrlError',\n    'UrlSchemeError',\n    'UrlSchemePermittedError',\n    'UrlUserInfoError',\n    'UrlHostError',\n    'UrlHostTldError',\n    'UrlPortError',\n    'UrlExtraError',\n    'EnumError',\n    'IntEnumError',\n    'EnumMemberError',\n    'IntegerError',\n    'FloatError',\n    'PathError',\n    'PathNotExistsError',\n    'PathNotAFileError',\n    'PathNotADirectoryError',\n    'PyObjectError',\n    'SequenceError',\n    'ListError',\n    'SetError',\n    'FrozenSetError',\n    'TupleError',\n    'TupleLengthError',\n    'ListMinLengthError',\n    'ListMaxLengthError',\n    'ListUniqueItemsError',\n    'SetMinLengthError',\n    'SetMaxLengthError',\n    'FrozenSetMinLengthError',\n    'FrozenSetMaxLengthError',\n    'AnyStrMinLengthError',\n    'AnyStrMaxLengthError',\n    'StrError',\n    'StrRegexError',\n    'NumberNotGtError',\n    'NumberNotGeError',\n    'NumberNotLtError',\n    'NumberNotLeError',\n    'NumberNotMultipleError',\n    'DecimalError',\n    'DecimalIsNotFiniteError',\n    'DecimalMaxDigitsError',\n    'DecimalMaxPlacesError',\n    'DecimalWholeDigitsError',\n    'DateTimeError',\n    'DateError',\n    'DateNotInThePastError',\n    'DateNotInTheFutureError',\n    'TimeError',\n    'DurationError',\n    'HashableError',\n    'UUIDError',\n    'UUIDVersionError',\n    'ArbitraryTypeError',\n    'ClassError',\n    'SubclassError',\n    'JsonError',\n    'JsonTypeError',\n    'PatternError',\n    'DataclassTypeError',\n    'CallableError',\n    'IPvAnyAddressError',\n    'IPvAnyInterfaceError',\n    'IPvAnyNetworkError',\n    'IPv4AddressError',\n    'IPv6AddressError',\n    'IPv4NetworkError',\n    'IPv6NetworkError',\n    'IPv4InterfaceError',\n    'IPv6InterfaceError',\n    'ColorError',\n    'StrictBoolError',\n    'NotDigitError',\n    'LuhnValidationError',\n    'InvalidLengthForBrand',\n    'InvalidByteSize',\n    'InvalidByteSizeUnit',\n    'MissingDiscriminator',\n    'InvalidDiscriminator',\n)\n\n\ndef cls_kwargs(cls: Type['PydanticErrorMixin'], ctx: 'DictStrAny') -> 'PydanticErrorMixin':\n    \"\"\"\n    For built-in exceptions like ValueError or TypeError, we need to implement\n    __reduce__ to override the default behaviour (instead of __getstate__/__setstate__)\n    By default pickle protocol 2 calls `cls.__new__(cls, *args)`.\n    Since we only use kwargs, we need a little constructor to change that.\n    Note: the callable can't be a lambda as pickle looks in the namespace to find it\n    \"\"\"\n    return cls(**ctx)\n\n\nclass PydanticErrorMixin:\n    code: str\n    msg_template: str\n\n    def __init__(self, **ctx: Any) -> None:\n        self.__dict__ = ctx\n\n    def __str__(self) -> str:\n        return self.msg_template.format(**self.__dict__)\n\n    def __reduce__(self) -> Tuple[Callable[..., 'PydanticErrorMixin'], Tuple[Type['PydanticErrorMixin'], 'DictStrAny']]:\n        return cls_kwargs, (self.__class__, self.__dict__)\n\n\nclass PydanticTypeError(PydanticErrorMixin, TypeError):\n    pass\n\n\nclass PydanticValueError(PydanticErrorMixin, ValueError):\n    pass\n\n\nclass ConfigError(RuntimeError):\n    pass\n\n\nclass MissingError(PydanticValueError):\n    msg_template = 'field required'\n\n\nclass ExtraError(PydanticValueError):\n    msg_template = 'extra fields not permitted'\n\n\nclass NoneIsNotAllowedError(PydanticTypeError):\n    code = 'none.not_allowed'\n    msg_template = 'none is not an allowed value'\n\n\nclass NoneIsAllowedError(PydanticTypeError):\n    code = 'none.allowed'\n    msg_template = 'value is not none'\n\n\nclass WrongConstantError(PydanticValueError):\n    code = 'const'\n\n    def __str__(self) -> str:\n        permitted = ', '.join(repr(v) for v in self.permitted)  # type: ignore\n        return f'unexpected value; permitted: {permitted}'\n\n\nclass NotNoneError(PydanticTypeError):\n    code = 'not_none'\n    msg_template = 'value is not None'\n\n\nclass BoolError(PydanticTypeError):\n    msg_template = 'value could not be parsed to a boolean'\n\n\nclass BytesError(PydanticTypeError):\n    msg_template = 'byte type expected'\n\n\nclass DictError(PydanticTypeError):\n    msg_template = 'value is not a valid dict'\n\n\nclass EmailError(PydanticValueError):\n    msg_template = 'value is not a valid email address'\n\n\nclass UrlError(PydanticValueError):\n    code = 'url'\n\n\nclass UrlSchemeError(UrlError):\n    code = 'url.scheme'\n    msg_template = 'invalid or missing URL scheme'\n\n\nclass UrlSchemePermittedError(UrlError):\n    code = 'url.scheme'\n    msg_template = 'URL scheme not permitted'\n\n    def __init__(self, allowed_schemes: Set[str]):\n        super().__init__(allowed_schemes=allowed_schemes)\n\n\nclass UrlUserInfoError(UrlError):\n    code = 'url.userinfo'\n    msg_template = 'userinfo required in URL but missing'\n\n\nclass UrlHostError(UrlError):\n    code = 'url.host'\n    msg_template = 'URL host invalid'\n\n\nclass UrlHostTldError(UrlError):\n    code = 'url.host'\n    msg_template = 'URL host invalid, top level domain required'\n\n\nclass UrlPortError(UrlError):\n    code = 'url.port'\n    msg_template = 'URL port invalid, port cannot exceed 65535'\n\n\nclass UrlExtraError(UrlError):\n    code = 'url.extra'\n    msg_template = 'URL invalid, extra characters found after valid URL: {extra!r}'\n\n\nclass EnumMemberError(PydanticTypeError):\n    code = 'enum'\n\n    def __str__(self) -> str:\n        permitted = ', '.join(repr(v.value) for v in self.enum_values)  # type: ignore\n        return f'value is not a valid enumeration member; permitted: {permitted}'\n\n\nclass IntegerError(PydanticTypeError):\n    msg_template = 'value is not a valid integer'\n\n\nclass FloatError(PydanticTypeError):\n    msg_template = 'value is not a valid float'\n\n\nclass PathError(PydanticTypeError):\n    msg_template = 'value is not a valid path'\n\n\nclass _PathValueError(PydanticValueError):\n    def __init__(self, *, path: Path) -> None:\n        super().__init__(path=str(path))\n\n\nclass PathNotExistsError(_PathValueError):\n    code = 'path.not_exists'\n    msg_template = 'file or directory at path \"{path}\" does not exist'\n\n\nclass PathNotAFileError(_PathValueError):\n    code = 'path.not_a_file'\n    msg_template = 'path \"{path}\" does not point to a file'\n\n\nclass PathNotADirectoryError(_PathValueError):\n    code = 'path.not_a_directory'\n    msg_template = 'path \"{path}\" does not point to a directory'\n\n\nclass PyObjectError(PydanticTypeError):\n    msg_template = 'ensure this value contains valid import path or valid callable: {error_message}'\n\n\nclass SequenceError(PydanticTypeError):\n    msg_template = 'value is not a valid sequence'\n\n\nclass IterableError(PydanticTypeError):\n    msg_template = 'value is not a valid iterable'\n\n\nclass ListError(PydanticTypeError):\n    msg_template = 'value is not a valid list'\n\n\nclass SetError(PydanticTypeError):\n    msg_template = 'value is not a valid set'\n\n\nclass FrozenSetError(PydanticTypeError):\n    msg_template = 'value is not a valid frozenset'\n\n\nclass DequeError(PydanticTypeError):\n    msg_template = 'value is not a valid deque'\n\n\nclass TupleError(PydanticTypeError):\n    msg_template = 'value is not a valid tuple'\n\n\nclass TupleLengthError(PydanticValueError):\n    code = 'tuple.length'\n    msg_template = 'wrong tuple length {actual_length}, expected {expected_length}'\n\n    def __init__(self, *, actual_length: int, expected_length: int) -> None:\n        super().__init__(actual_length=actual_length, expected_length=expected_length)\n\n\nclass ListMinLengthError(PydanticValueError):\n    code = 'list.min_items'\n    msg_template = 'ensure this value has at least {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass ListMaxLengthError(PydanticValueError):\n    code = 'list.max_items'\n    msg_template = 'ensure this value has at most {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass ListUniqueItemsError(PydanticValueError):\n    code = 'list.unique_items'\n    msg_template = 'the list has duplicated items'\n\n\nclass SetMinLengthError(PydanticValueError):\n    code = 'set.min_items'\n    msg_template = 'ensure this value has at least {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass SetMaxLengthError(PydanticValueError):\n    code = 'set.max_items'\n    msg_template = 'ensure this value has at most {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass FrozenSetMinLengthError(PydanticValueError):\n    code = 'frozenset.min_items'\n    msg_template = 'ensure this value has at least {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass FrozenSetMaxLengthError(PydanticValueError):\n    code = 'frozenset.max_items'\n    msg_template = 'ensure this value has at most {limit_value} items'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass AnyStrMinLengthError(PydanticValueError):\n    code = 'any_str.min_length'\n    msg_template = 'ensure this value has at least {limit_value} characters'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass AnyStrMaxLengthError(PydanticValueError):\n    code = 'any_str.max_length'\n    msg_template = 'ensure this value has at most {limit_value} characters'\n\n    def __init__(self, *, limit_value: int) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass StrError(PydanticTypeError):\n    msg_template = 'str type expected'\n\n\nclass StrRegexError(PydanticValueError):\n    code = 'str.regex'\n    msg_template = 'string does not match regex \"{pattern}\"'\n\n    def __init__(self, *, pattern: str) -> None:\n        super().__init__(pattern=pattern)\n\n\nclass _NumberBoundError(PydanticValueError):\n    def __init__(self, *, limit_value: Union[int, float, Decimal]) -> None:\n        super().__init__(limit_value=limit_value)\n\n\nclass NumberNotGtError(_NumberBoundError):\n    code = 'number.not_gt'\n    msg_template = 'ensure this value is greater than {limit_value}'\n\n\nclass NumberNotGeError(_NumberBoundError):\n    code = 'number.not_ge'\n    msg_template = 'ensure this value is greater than or equal to {limit_value}'\n\n\nclass NumberNotLtError(_NumberBoundError):\n    code = 'number.not_lt'\n    msg_template = 'ensure this value is less than {limit_value}'\n\n\nclass NumberNotLeError(_NumberBoundError):\n    code = 'number.not_le'\n    msg_template = 'ensure this value is less than or equal to {limit_value}'\n\n\nclass NumberNotFiniteError(PydanticValueError):\n    code = 'number.not_finite_number'\n    msg_template = 'ensure this value is a finite number'\n\n\nclass NumberNotMultipleError(PydanticValueError):\n    code = 'number.not_multiple'\n    msg_template = 'ensure this value is a multiple of {multiple_of}'\n\n    def __init__(self, *, multiple_of: Union[int, float, Decimal]) -> None:\n        super().__init__(multiple_of=multiple_of)\n\n\nclass DecimalError(PydanticTypeError):\n    msg_template = 'value is not a valid decimal'\n\n\nclass DecimalIsNotFiniteError(PydanticValueError):\n    code = 'decimal.not_finite'\n    msg_template = 'value is not a valid decimal'\n\n\nclass DecimalMaxDigitsError(PydanticValueError):\n    code = 'decimal.max_digits'\n    msg_template = 'ensure that there are no more than {max_digits} digits in total'\n\n    def __init__(self, *, max_digits: int) -> None:\n        super().__init__(max_digits=max_digits)\n\n\nclass DecimalMaxPlacesError(PydanticValueError):\n    code = 'decimal.max_places'\n    msg_template = 'ensure that there are no more than {decimal_places} decimal places'\n\n    def __init__(self, *, decimal_places: int) -> None:\n        super().__init__(decimal_places=decimal_places)\n\n\nclass DecimalWholeDigitsError(PydanticValueError):\n    code = 'decimal.whole_digits'\n    msg_template = 'ensure that there are no more than {whole_digits} digits before the decimal point'\n\n    def __init__(self, *, whole_digits: int) -> None:\n        super().__init__(whole_digits=whole_digits)\n\n\nclass DateTimeError(PydanticValueError):\n    msg_template = 'invalid datetime format'\n\n\nclass DateError(PydanticValueError):\n    msg_template = 'invalid date format'\n\n\nclass DateNotInThePastError(PydanticValueError):\n    code = 'date.not_in_the_past'\n    msg_template = 'date is not in the past'\n\n\nclass DateNotInTheFutureError(PydanticValueError):\n    code = 'date.not_in_the_future'\n    msg_template = 'date is not in the future'\n\n\nclass TimeError(PydanticValueError):\n    msg_template = 'invalid time format'\n\n\nclass DurationError(PydanticValueError):\n    msg_template = 'invalid duration format'\n\n\nclass HashableError(PydanticTypeError):\n    msg_template = 'value is not a valid hashable'\n\n\nclass UUIDError(PydanticTypeError):\n    msg_template = 'value is not a valid uuid'\n\n\nclass UUIDVersionError(PydanticValueError):\n    code = 'uuid.version'\n    msg_template = 'uuid version {required_version} expected'\n\n    def __init__(self, *, required_version: int) -> None:\n        super().__init__(required_version=required_version)\n\n\nclass ArbitraryTypeError(PydanticTypeError):\n    code = 'arbitrary_type'\n    msg_template = 'instance of {expected_arbitrary_type} expected'\n\n    def __init__(self, *, expected_arbitrary_type: Type[Any]) -> None:\n        super().__init__(expected_arbitrary_type=display_as_type(expected_arbitrary_type))\n\n\nclass ClassError(PydanticTypeError):\n    code = 'class'\n    msg_template = 'a class is expected'\n\n\nclass SubclassError(PydanticTypeError):\n    code = 'subclass'\n    msg_template = 'subclass of {expected_class} expected'\n\n    def __init__(self, *, expected_class: Type[Any]) -> None:\n        super().__init__(expected_class=display_as_type(expected_class))\n\n\nclass JsonError(PydanticValueError):\n    msg_template = 'Invalid JSON'\n\n\nclass JsonTypeError(PydanticTypeError):\n    code = 'json'\n    msg_template = 'JSON object must be str, bytes or bytearray'\n\n\nclass PatternError(PydanticValueError):\n    code = 'regex_pattern'\n    msg_template = 'Invalid regular expression'\n\n\nclass DataclassTypeError(PydanticTypeError):\n    code = 'dataclass'\n    msg_template = 'instance of {class_name}, tuple or dict expected'\n\n\nclass CallableError(PydanticTypeError):\n    msg_template = '{value} is not callable'\n\n\nclass EnumError(PydanticTypeError):\n    code = 'enum_instance'\n    msg_template = '{value} is not a valid Enum instance'\n\n\nclass IntEnumError(PydanticTypeError):\n    code = 'int_enum_instance'\n    msg_template = '{value} is not a valid IntEnum instance'\n\n\nclass IPvAnyAddressError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 or IPv6 address'\n\n\nclass IPvAnyInterfaceError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 or IPv6 interface'\n\n\nclass IPvAnyNetworkError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 or IPv6 network'\n\n\nclass IPv4AddressError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 address'\n\n\nclass IPv6AddressError(PydanticValueError):\n    msg_template = 'value is not a valid IPv6 address'\n\n\nclass IPv4NetworkError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 network'\n\n\nclass IPv6NetworkError(PydanticValueError):\n    msg_template = 'value is not a valid IPv6 network'\n\n\nclass IPv4InterfaceError(PydanticValueError):\n    msg_template = 'value is not a valid IPv4 interface'\n\n\nclass IPv6InterfaceError(PydanticValueError):\n    msg_template = 'value is not a valid IPv6 interface'\n\n\nclass ColorError(PydanticValueError):\n    msg_template = 'value is not a valid color: {reason}'\n\n\nclass StrictBoolError(PydanticValueError):\n    msg_template = 'value is not a valid boolean'\n\n\nclass NotDigitError(PydanticValueError):\n    code = 'payment_card_number.digits'\n    msg_template = 'card number is not all digits'\n\n\nclass LuhnValidationError(PydanticValueError):\n    code = 'payment_card_number.luhn_check'\n    msg_template = 'card number is not luhn valid'\n\n\nclass InvalidLengthForBrand(PydanticValueError):\n    code = 'payment_card_number.invalid_length_for_brand'\n    msg_template = 'Length for a {brand} card must be {required_length}'\n\n\nclass InvalidByteSize(PydanticValueError):\n    msg_template = 'could not parse value and unit from byte string'\n\n\nclass InvalidByteSizeUnit(PydanticValueError):\n    msg_template = 'could not interpret byte unit: {unit}'\n\n\nclass MissingDiscriminator(PydanticValueError):\n    code = 'discriminated_union.missing_discriminator'\n    msg_template = 'Discriminator {discriminator_key!r} is missing in value'\n\n\nclass InvalidDiscriminator(PydanticValueError):\n    code = 'discriminated_union.invalid_discriminator'\n    msg_template = (\n        'No match for discriminator {discriminator_key!r} and value {discriminator_value!r} '\n        '(allowed values: {allowed_values})'\n    )\n\n    def __init__(self, *, discriminator_key: str, discriminator_value: Any, allowed_values: Sequence[Any]) -> None:\n        super().__init__(\n            discriminator_key=discriminator_key,\n            discriminator_value=discriminator_value,\n            allowed_values=', '.join(map(repr, allowed_values)),\n        )\n", "pydantic/v1/json.py": "import datetime\nfrom collections import deque\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import GeneratorType\nfrom typing import Any, Callable, Dict, Type, Union\nfrom uuid import UUID\n\nfrom pydantic.v1.color import Color\nfrom pydantic.v1.networks import NameEmail\nfrom pydantic.v1.types import SecretBytes, SecretStr\n\n__all__ = 'pydantic_encoder', 'custom_pydantic_encoder', 'timedelta_isoformat'\n\n\ndef isoformat(o: Union[datetime.date, datetime.time]) -> str:\n    return o.isoformat()\n\n\ndef decimal_encoder(dec_value: Decimal) -> Union[int, float]:\n    \"\"\"\n    Encodes a Decimal as int of there's no exponent, otherwise float\n\n    This is useful when we use ConstrainedDecimal to represent Numeric(x,0)\n    where a integer (but not int typed) is used. Encoding this as a float\n    results in failed round-tripping between encode and parse.\n    Our Id type is a prime example of this.\n\n    >>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    if dec_value.as_tuple().exponent >= 0:\n        return int(dec_value)\n    else:\n        return float(dec_value)\n\n\nENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {\n    bytes: lambda o: o.decode(),\n    Color: str,\n    datetime.date: isoformat,\n    datetime.datetime: isoformat,\n    datetime.time: isoformat,\n    datetime.timedelta: lambda td: td.total_seconds(),\n    Decimal: decimal_encoder,\n    Enum: lambda o: o.value,\n    frozenset: list,\n    deque: list,\n    GeneratorType: list,\n    IPv4Address: str,\n    IPv4Interface: str,\n    IPv4Network: str,\n    IPv6Address: str,\n    IPv6Interface: str,\n    IPv6Network: str,\n    NameEmail: str,\n    Path: str,\n    Pattern: lambda o: o.pattern,\n    SecretBytes: str,\n    SecretStr: str,\n    set: list,\n    UUID: str,\n}\n\n\ndef pydantic_encoder(obj: Any) -> Any:\n    from dataclasses import asdict, is_dataclass\n\n    from pydantic.v1.main import BaseModel\n\n    if isinstance(obj, BaseModel):\n        return obj.dict()\n    elif is_dataclass(obj):\n        return asdict(obj)\n\n    # Check the class type and its superclasses for a matching encoder\n    for base in obj.__class__.__mro__[:-1]:\n        try:\n            encoder = ENCODERS_BY_TYPE[base]\n        except KeyError:\n            continue\n        return encoder(obj)\n    else:  # We have exited the for loop without finding a suitable encoder\n        raise TypeError(f\"Object of type '{obj.__class__.__name__}' is not JSON serializable\")\n\n\ndef custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -> Any:\n    # Check the class type and its superclasses for a matching encoder\n    for base in obj.__class__.__mro__[:-1]:\n        try:\n            encoder = type_encoders[base]\n        except KeyError:\n            continue\n\n        return encoder(obj)\n    else:  # We have exited the for loop without finding a suitable encoder\n        return pydantic_encoder(obj)\n\n\ndef timedelta_isoformat(td: datetime.timedelta) -> str:\n    \"\"\"\n    ISO 8601 encoding for Python timedelta object.\n    \"\"\"\n    minutes, seconds = divmod(td.seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f'{\"-\" if td.days < 0 else \"\"}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:06d}S'\n", "pydantic/v1/validators.py": "import math\nimport re\nfrom collections import OrderedDict, deque\nfrom collections.abc import Hashable as CollectionsHashable\nfrom datetime import date, datetime, time, timedelta\nfrom decimal import Decimal, DecimalException\nfrom enum import Enum, IntEnum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Deque,\n    Dict,\n    ForwardRef,\n    FrozenSet,\n    Generator,\n    Hashable,\n    List,\n    NamedTuple,\n    Pattern,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n)\nfrom uuid import UUID\n\nfrom pydantic.v1 import errors\nfrom pydantic.v1.datetime_parse import parse_date, parse_datetime, parse_duration, parse_time\nfrom pydantic.v1.typing import (\n    AnyCallable,\n    all_literal_values,\n    display_as_type,\n    get_class,\n    is_callable_type,\n    is_literal_type,\n    is_namedtuple,\n    is_none_type,\n    is_typeddict,\n)\nfrom pydantic.v1.utils import almost_equal_floats, lenient_issubclass, sequence_like\n\nif TYPE_CHECKING:\n    from typing_extensions import Literal, TypedDict\n\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.fields import ModelField\n    from pydantic.v1.types import ConstrainedDecimal, ConstrainedFloat, ConstrainedInt\n\n    ConstrainedNumber = Union[ConstrainedDecimal, ConstrainedFloat, ConstrainedInt]\n    AnyOrderedDict = OrderedDict[Any, Any]\n    Number = Union[int, float, Decimal]\n    StrBytes = Union[str, bytes]\n\n\ndef str_validator(v: Any) -> Union[str]:\n    if isinstance(v, str):\n        if isinstance(v, Enum):\n            return v.value\n        else:\n            return v\n    elif isinstance(v, (float, int, Decimal)):\n        # is there anything else we want to add here? If you think so, create an issue.\n        return str(v)\n    elif isinstance(v, (bytes, bytearray)):\n        return v.decode()\n    else:\n        raise errors.StrError()\n\n\ndef strict_str_validator(v: Any) -> Union[str]:\n    if isinstance(v, str) and not isinstance(v, Enum):\n        return v\n    raise errors.StrError()\n\n\ndef bytes_validator(v: Any) -> Union[bytes]:\n    if isinstance(v, bytes):\n        return v\n    elif isinstance(v, bytearray):\n        return bytes(v)\n    elif isinstance(v, str):\n        return v.encode()\n    elif isinstance(v, (float, int, Decimal)):\n        return str(v).encode()\n    else:\n        raise errors.BytesError()\n\n\ndef strict_bytes_validator(v: Any) -> Union[bytes]:\n    if isinstance(v, bytes):\n        return v\n    elif isinstance(v, bytearray):\n        return bytes(v)\n    else:\n        raise errors.BytesError()\n\n\nBOOL_FALSE = {0, '0', 'off', 'f', 'false', 'n', 'no'}\nBOOL_TRUE = {1, '1', 'on', 't', 'true', 'y', 'yes'}\n\n\ndef bool_validator(v: Any) -> bool:\n    if v is True or v is False:\n        return v\n    if isinstance(v, bytes):\n        v = v.decode()\n    if isinstance(v, str):\n        v = v.lower()\n    try:\n        if v in BOOL_TRUE:\n            return True\n        if v in BOOL_FALSE:\n            return False\n    except TypeError:\n        raise errors.BoolError()\n    raise errors.BoolError()\n\n\n# matches the default limit cpython, see https://github.com/python/cpython/pull/96500\nmax_str_int = 4_300\n\n\ndef int_validator(v: Any) -> int:\n    if isinstance(v, int) and not (v is True or v is False):\n        return v\n\n    # see https://github.com/pydantic/pydantic/issues/1477 and in turn, https://github.com/python/cpython/issues/95778\n    # this check should be unnecessary once patch releases are out for 3.7, 3.8, 3.9 and 3.10\n    # but better to check here until then.\n    # NOTICE: this does not fully protect user from the DOS risk since the standard library JSON implementation\n    # (and other std lib modules like xml) use `int()` and are likely called before this, the best workaround is to\n    # 1. update to the latest patch release of python once released, 2. use a different JSON library like ujson\n    if isinstance(v, (str, bytes, bytearray)) and len(v) > max_str_int:\n        raise errors.IntegerError()\n\n    try:\n        return int(v)\n    except (TypeError, ValueError, OverflowError):\n        raise errors.IntegerError()\n\n\ndef strict_int_validator(v: Any) -> int:\n    if isinstance(v, int) and not (v is True or v is False):\n        return v\n    raise errors.IntegerError()\n\n\ndef float_validator(v: Any) -> float:\n    if isinstance(v, float):\n        return v\n\n    try:\n        return float(v)\n    except (TypeError, ValueError):\n        raise errors.FloatError()\n\n\ndef strict_float_validator(v: Any) -> float:\n    if isinstance(v, float):\n        return v\n    raise errors.FloatError()\n\n\ndef float_finite_validator(v: 'Number', field: 'ModelField', config: 'BaseConfig') -> 'Number':\n    allow_inf_nan = getattr(field.type_, 'allow_inf_nan', None)\n    if allow_inf_nan is None:\n        allow_inf_nan = config.allow_inf_nan\n\n    if allow_inf_nan is False and (math.isnan(v) or math.isinf(v)):\n        raise errors.NumberNotFiniteError()\n    return v\n\n\ndef number_multiple_validator(v: 'Number', field: 'ModelField') -> 'Number':\n    field_type: ConstrainedNumber = field.type_\n    if field_type.multiple_of is not None:\n        mod = float(v) / float(field_type.multiple_of) % 1\n        if not almost_equal_floats(mod, 0.0) and not almost_equal_floats(mod, 1.0):\n            raise errors.NumberNotMultipleError(multiple_of=field_type.multiple_of)\n    return v\n\n\ndef number_size_validator(v: 'Number', field: 'ModelField') -> 'Number':\n    field_type: ConstrainedNumber = field.type_\n    if field_type.gt is not None and not v > field_type.gt:\n        raise errors.NumberNotGtError(limit_value=field_type.gt)\n    elif field_type.ge is not None and not v >= field_type.ge:\n        raise errors.NumberNotGeError(limit_value=field_type.ge)\n\n    if field_type.lt is not None and not v < field_type.lt:\n        raise errors.NumberNotLtError(limit_value=field_type.lt)\n    if field_type.le is not None and not v <= field_type.le:\n        raise errors.NumberNotLeError(limit_value=field_type.le)\n\n    return v\n\n\ndef constant_validator(v: 'Any', field: 'ModelField') -> 'Any':\n    \"\"\"Validate ``const`` fields.\n\n    The value provided for a ``const`` field must be equal to the default value\n    of the field. This is to support the keyword of the same name in JSON\n    Schema.\n    \"\"\"\n    if v != field.default:\n        raise errors.WrongConstantError(given=v, permitted=[field.default])\n\n    return v\n\n\ndef anystr_length_validator(v: 'StrBytes', config: 'BaseConfig') -> 'StrBytes':\n    v_len = len(v)\n\n    min_length = config.min_anystr_length\n    if v_len < min_length:\n        raise errors.AnyStrMinLengthError(limit_value=min_length)\n\n    max_length = config.max_anystr_length\n    if max_length is not None and v_len > max_length:\n        raise errors.AnyStrMaxLengthError(limit_value=max_length)\n\n    return v\n\n\ndef anystr_strip_whitespace(v: 'StrBytes') -> 'StrBytes':\n    return v.strip()\n\n\ndef anystr_upper(v: 'StrBytes') -> 'StrBytes':\n    return v.upper()\n\n\ndef anystr_lower(v: 'StrBytes') -> 'StrBytes':\n    return v.lower()\n\n\ndef ordered_dict_validator(v: Any) -> 'AnyOrderedDict':\n    if isinstance(v, OrderedDict):\n        return v\n\n    try:\n        return OrderedDict(v)\n    except (TypeError, ValueError):\n        raise errors.DictError()\n\n\ndef dict_validator(v: Any) -> Dict[Any, Any]:\n    if isinstance(v, dict):\n        return v\n\n    try:\n        return dict(v)\n    except (TypeError, ValueError):\n        raise errors.DictError()\n\n\ndef list_validator(v: Any) -> List[Any]:\n    if isinstance(v, list):\n        return v\n    elif sequence_like(v):\n        return list(v)\n    else:\n        raise errors.ListError()\n\n\ndef tuple_validator(v: Any) -> Tuple[Any, ...]:\n    if isinstance(v, tuple):\n        return v\n    elif sequence_like(v):\n        return tuple(v)\n    else:\n        raise errors.TupleError()\n\n\ndef set_validator(v: Any) -> Set[Any]:\n    if isinstance(v, set):\n        return v\n    elif sequence_like(v):\n        return set(v)\n    else:\n        raise errors.SetError()\n\n\ndef frozenset_validator(v: Any) -> FrozenSet[Any]:\n    if isinstance(v, frozenset):\n        return v\n    elif sequence_like(v):\n        return frozenset(v)\n    else:\n        raise errors.FrozenSetError()\n\n\ndef deque_validator(v: Any) -> Deque[Any]:\n    if isinstance(v, deque):\n        return v\n    elif sequence_like(v):\n        return deque(v)\n    else:\n        raise errors.DequeError()\n\n\ndef enum_member_validator(v: Any, field: 'ModelField', config: 'BaseConfig') -> Enum:\n    try:\n        enum_v = field.type_(v)\n    except ValueError:\n        # field.type_ should be an enum, so will be iterable\n        raise errors.EnumMemberError(enum_values=list(field.type_))\n    return enum_v.value if config.use_enum_values else enum_v\n\n\ndef uuid_validator(v: Any, field: 'ModelField') -> UUID:\n    try:\n        if isinstance(v, str):\n            v = UUID(v)\n        elif isinstance(v, (bytes, bytearray)):\n            try:\n                v = UUID(v.decode())\n            except ValueError:\n                # 16 bytes in big-endian order as the bytes argument fail\n                # the above check\n                v = UUID(bytes=v)\n    except ValueError:\n        raise errors.UUIDError()\n\n    if not isinstance(v, UUID):\n        raise errors.UUIDError()\n\n    required_version = getattr(field.type_, '_required_version', None)\n    if required_version and v.version != required_version:\n        raise errors.UUIDVersionError(required_version=required_version)\n\n    return v\n\n\ndef decimal_validator(v: Any) -> Decimal:\n    if isinstance(v, Decimal):\n        return v\n    elif isinstance(v, (bytes, bytearray)):\n        v = v.decode()\n\n    v = str(v).strip()\n\n    try:\n        v = Decimal(v)\n    except DecimalException:\n        raise errors.DecimalError()\n\n    if not v.is_finite():\n        raise errors.DecimalIsNotFiniteError()\n\n    return v\n\n\ndef hashable_validator(v: Any) -> Hashable:\n    if isinstance(v, Hashable):\n        return v\n\n    raise errors.HashableError()\n\n\ndef ip_v4_address_validator(v: Any) -> IPv4Address:\n    if isinstance(v, IPv4Address):\n        return v\n\n    try:\n        return IPv4Address(v)\n    except ValueError:\n        raise errors.IPv4AddressError()\n\n\ndef ip_v6_address_validator(v: Any) -> IPv6Address:\n    if isinstance(v, IPv6Address):\n        return v\n\n    try:\n        return IPv6Address(v)\n    except ValueError:\n        raise errors.IPv6AddressError()\n\n\ndef ip_v4_network_validator(v: Any) -> IPv4Network:\n    \"\"\"\n    Assume IPv4Network initialised with a default ``strict`` argument\n\n    See more:\n    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network\n    \"\"\"\n    if isinstance(v, IPv4Network):\n        return v\n\n    try:\n        return IPv4Network(v)\n    except ValueError:\n        raise errors.IPv4NetworkError()\n\n\ndef ip_v6_network_validator(v: Any) -> IPv6Network:\n    \"\"\"\n    Assume IPv6Network initialised with a default ``strict`` argument\n\n    See more:\n    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network\n    \"\"\"\n    if isinstance(v, IPv6Network):\n        return v\n\n    try:\n        return IPv6Network(v)\n    except ValueError:\n        raise errors.IPv6NetworkError()\n\n\ndef ip_v4_interface_validator(v: Any) -> IPv4Interface:\n    if isinstance(v, IPv4Interface):\n        return v\n\n    try:\n        return IPv4Interface(v)\n    except ValueError:\n        raise errors.IPv4InterfaceError()\n\n\ndef ip_v6_interface_validator(v: Any) -> IPv6Interface:\n    if isinstance(v, IPv6Interface):\n        return v\n\n    try:\n        return IPv6Interface(v)\n    except ValueError:\n        raise errors.IPv6InterfaceError()\n\n\ndef path_validator(v: Any) -> Path:\n    if isinstance(v, Path):\n        return v\n\n    try:\n        return Path(v)\n    except TypeError:\n        raise errors.PathError()\n\n\ndef path_exists_validator(v: Any) -> Path:\n    if not v.exists():\n        raise errors.PathNotExistsError(path=v)\n\n    return v\n\n\ndef callable_validator(v: Any) -> AnyCallable:\n    \"\"\"\n    Perform a simple check if the value is callable.\n\n    Note: complete matching of argument type hints and return types is not performed\n    \"\"\"\n    if callable(v):\n        return v\n\n    raise errors.CallableError(value=v)\n\n\ndef enum_validator(v: Any) -> Enum:\n    if isinstance(v, Enum):\n        return v\n\n    raise errors.EnumError(value=v)\n\n\ndef int_enum_validator(v: Any) -> IntEnum:\n    if isinstance(v, IntEnum):\n        return v\n\n    raise errors.IntEnumError(value=v)\n\n\ndef make_literal_validator(type_: Any) -> Callable[[Any], Any]:\n    permitted_choices = all_literal_values(type_)\n\n    # To have a O(1) complexity and still return one of the values set inside the `Literal`,\n    # we create a dict with the set values (a set causes some problems with the way intersection works).\n    # In some cases the set value and checked value can indeed be different (see `test_literal_validator_str_enum`)\n    allowed_choices = {v: v for v in permitted_choices}\n\n    def literal_validator(v: Any) -> Any:\n        try:\n            return allowed_choices[v]\n        except (KeyError, TypeError):\n            raise errors.WrongConstantError(given=v, permitted=permitted_choices)\n\n    return literal_validator\n\n\ndef constr_length_validator(v: 'StrBytes', field: 'ModelField', config: 'BaseConfig') -> 'StrBytes':\n    v_len = len(v)\n\n    min_length = field.type_.min_length if field.type_.min_length is not None else config.min_anystr_length\n    if v_len < min_length:\n        raise errors.AnyStrMinLengthError(limit_value=min_length)\n\n    max_length = field.type_.max_length if field.type_.max_length is not None else config.max_anystr_length\n    if max_length is not None and v_len > max_length:\n        raise errors.AnyStrMaxLengthError(limit_value=max_length)\n\n    return v\n\n\ndef constr_strip_whitespace(v: 'StrBytes', field: 'ModelField', config: 'BaseConfig') -> 'StrBytes':\n    strip_whitespace = field.type_.strip_whitespace or config.anystr_strip_whitespace\n    if strip_whitespace:\n        v = v.strip()\n\n    return v\n\n\ndef constr_upper(v: 'StrBytes', field: 'ModelField', config: 'BaseConfig') -> 'StrBytes':\n    upper = field.type_.to_upper or config.anystr_upper\n    if upper:\n        v = v.upper()\n\n    return v\n\n\ndef constr_lower(v: 'StrBytes', field: 'ModelField', config: 'BaseConfig') -> 'StrBytes':\n    lower = field.type_.to_lower or config.anystr_lower\n    if lower:\n        v = v.lower()\n    return v\n\n\ndef validate_json(v: Any, config: 'BaseConfig') -> Any:\n    if v is None:\n        # pass None through to other validators\n        return v\n    try:\n        return config.json_loads(v)  # type: ignore\n    except ValueError:\n        raise errors.JsonError()\n    except TypeError:\n        raise errors.JsonTypeError()\n\n\nT = TypeVar('T')\n\n\ndef make_arbitrary_type_validator(type_: Type[T]) -> Callable[[T], T]:\n    def arbitrary_type_validator(v: Any) -> T:\n        if isinstance(v, type_):\n            return v\n        raise errors.ArbitraryTypeError(expected_arbitrary_type=type_)\n\n    return arbitrary_type_validator\n\n\ndef make_class_validator(type_: Type[T]) -> Callable[[Any], Type[T]]:\n    def class_validator(v: Any) -> Type[T]:\n        if lenient_issubclass(v, type_):\n            return v\n        raise errors.SubclassError(expected_class=type_)\n\n    return class_validator\n\n\ndef any_class_validator(v: Any) -> Type[T]:\n    if isinstance(v, type):\n        return v\n    raise errors.ClassError()\n\n\ndef none_validator(v: Any) -> 'Literal[None]':\n    if v is None:\n        return v\n    raise errors.NotNoneError()\n\n\ndef pattern_validator(v: Any) -> Pattern[str]:\n    if isinstance(v, Pattern):\n        return v\n\n    str_value = str_validator(v)\n\n    try:\n        return re.compile(str_value)\n    except re.error:\n        raise errors.PatternError()\n\n\nNamedTupleT = TypeVar('NamedTupleT', bound=NamedTuple)\n\n\ndef make_namedtuple_validator(\n    namedtuple_cls: Type[NamedTupleT], config: Type['BaseConfig']\n) -> Callable[[Tuple[Any, ...]], NamedTupleT]:\n    from pydantic.v1.annotated_types import create_model_from_namedtuple\n\n    NamedTupleModel = create_model_from_namedtuple(\n        namedtuple_cls,\n        __config__=config,\n        __module__=namedtuple_cls.__module__,\n    )\n    namedtuple_cls.__pydantic_model__ = NamedTupleModel  # type: ignore[attr-defined]\n\n    def namedtuple_validator(values: Tuple[Any, ...]) -> NamedTupleT:\n        annotations = NamedTupleModel.__annotations__\n\n        if len(values) > len(annotations):\n            raise errors.ListMaxLengthError(limit_value=len(annotations))\n\n        dict_values: Dict[str, Any] = dict(zip(annotations, values))\n        validated_dict_values: Dict[str, Any] = dict(NamedTupleModel(**dict_values))\n        return namedtuple_cls(**validated_dict_values)\n\n    return namedtuple_validator\n\n\ndef make_typeddict_validator(\n    typeddict_cls: Type['TypedDict'], config: Type['BaseConfig']  # type: ignore[valid-type]\n) -> Callable[[Any], Dict[str, Any]]:\n    from pydantic.v1.annotated_types import create_model_from_typeddict\n\n    TypedDictModel = create_model_from_typeddict(\n        typeddict_cls,\n        __config__=config,\n        __module__=typeddict_cls.__module__,\n    )\n    typeddict_cls.__pydantic_model__ = TypedDictModel  # type: ignore[attr-defined]\n\n    def typeddict_validator(values: 'TypedDict') -> Dict[str, Any]:  # type: ignore[valid-type]\n        return TypedDictModel.parse_obj(values).dict(exclude_unset=True)\n\n    return typeddict_validator\n\n\nclass IfConfig:\n    def __init__(self, validator: AnyCallable, *config_attr_names: str, ignored_value: Any = False) -> None:\n        self.validator = validator\n        self.config_attr_names = config_attr_names\n        self.ignored_value = ignored_value\n\n    def check(self, config: Type['BaseConfig']) -> bool:\n        return any(getattr(config, name) not in {None, self.ignored_value} for name in self.config_attr_names)\n\n\n# order is important here, for example: bool is a subclass of int so has to come first, datetime before date same,\n# IPv4Interface before IPv4Address, etc\n_VALIDATORS: List[Tuple[Type[Any], List[Any]]] = [\n    (IntEnum, [int_validator, enum_member_validator]),\n    (Enum, [enum_member_validator]),\n    (\n        str,\n        [\n            str_validator,\n            IfConfig(anystr_strip_whitespace, 'anystr_strip_whitespace'),\n            IfConfig(anystr_upper, 'anystr_upper'),\n            IfConfig(anystr_lower, 'anystr_lower'),\n            IfConfig(anystr_length_validator, 'min_anystr_length', 'max_anystr_length'),\n        ],\n    ),\n    (\n        bytes,\n        [\n            bytes_validator,\n            IfConfig(anystr_strip_whitespace, 'anystr_strip_whitespace'),\n            IfConfig(anystr_upper, 'anystr_upper'),\n            IfConfig(anystr_lower, 'anystr_lower'),\n            IfConfig(anystr_length_validator, 'min_anystr_length', 'max_anystr_length'),\n        ],\n    ),\n    (bool, [bool_validator]),\n    (int, [int_validator]),\n    (float, [float_validator, IfConfig(float_finite_validator, 'allow_inf_nan', ignored_value=True)]),\n    (Path, [path_validator]),\n    (datetime, [parse_datetime]),\n    (date, [parse_date]),\n    (time, [parse_time]),\n    (timedelta, [parse_duration]),\n    (OrderedDict, [ordered_dict_validator]),\n    (dict, [dict_validator]),\n    (list, [list_validator]),\n    (tuple, [tuple_validator]),\n    (set, [set_validator]),\n    (frozenset, [frozenset_validator]),\n    (deque, [deque_validator]),\n    (UUID, [uuid_validator]),\n    (Decimal, [decimal_validator]),\n    (IPv4Interface, [ip_v4_interface_validator]),\n    (IPv6Interface, [ip_v6_interface_validator]),\n    (IPv4Address, [ip_v4_address_validator]),\n    (IPv6Address, [ip_v6_address_validator]),\n    (IPv4Network, [ip_v4_network_validator]),\n    (IPv6Network, [ip_v6_network_validator]),\n]\n\n\ndef find_validators(  # noqa: C901 (ignore complexity)\n    type_: Type[Any], config: Type['BaseConfig']\n) -> Generator[AnyCallable, None, None]:\n    from pydantic.v1.dataclasses import is_builtin_dataclass, make_dataclass_validator\n\n    if type_ is Any or type_ is object:\n        return\n    type_type = type_.__class__\n    if type_type == ForwardRef or type_type == TypeVar:\n        return\n\n    if is_none_type(type_):\n        yield none_validator\n        return\n    if type_ is Pattern or type_ is re.Pattern:\n        yield pattern_validator\n        return\n    if type_ is Hashable or type_ is CollectionsHashable:\n        yield hashable_validator\n        return\n    if is_callable_type(type_):\n        yield callable_validator\n        return\n    if is_literal_type(type_):\n        yield make_literal_validator(type_)\n        return\n    if is_builtin_dataclass(type_):\n        yield from make_dataclass_validator(type_, config)\n        return\n    if type_ is Enum:\n        yield enum_validator\n        return\n    if type_ is IntEnum:\n        yield int_enum_validator\n        return\n    if is_namedtuple(type_):\n        yield tuple_validator\n        yield make_namedtuple_validator(type_, config)\n        return\n    if is_typeddict(type_):\n        yield make_typeddict_validator(type_, config)\n        return\n\n    class_ = get_class(type_)\n    if class_ is not None:\n        if class_ is not Any and isinstance(class_, type):\n            yield make_class_validator(class_)\n        else:\n            yield any_class_validator\n        return\n\n    for val_type, validators in _VALIDATORS:\n        try:\n            if issubclass(type_, val_type):\n                for v in validators:\n                    if isinstance(v, IfConfig):\n                        if v.check(config):\n                            yield v.validator\n                    else:\n                        yield v\n                return\n        except TypeError:\n            raise RuntimeError(f'error checking inheritance of {type_!r} (type: {display_as_type(type_)})')\n\n    if config.arbitrary_types_allowed:\n        yield make_arbitrary_type_validator(type_)\n    else:\n        raise RuntimeError(f'no validator found for {type_}, see `arbitrary_types_allowed` in Config')\n", "pydantic/v1/types.py": "import abc\nimport math\nimport re\nimport warnings\nfrom datetime import date\nfrom decimal import Decimal, InvalidOperation\nfrom enum import Enum\nfrom pathlib import Path\nfrom types import new_class\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    ClassVar,\n    Dict,\n    FrozenSet,\n    List,\n    Optional,\n    Pattern,\n    Set,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    overload,\n)\nfrom uuid import UUID\nfrom weakref import WeakSet\n\nfrom pydantic.v1 import errors\nfrom pydantic.v1.datetime_parse import parse_date\nfrom pydantic.v1.utils import import_string, update_not_none\nfrom pydantic.v1.validators import (\n    bytes_validator,\n    constr_length_validator,\n    constr_lower,\n    constr_strip_whitespace,\n    constr_upper,\n    decimal_validator,\n    float_finite_validator,\n    float_validator,\n    frozenset_validator,\n    int_validator,\n    list_validator,\n    number_multiple_validator,\n    number_size_validator,\n    path_exists_validator,\n    path_validator,\n    set_validator,\n    str_validator,\n    strict_bytes_validator,\n    strict_float_validator,\n    strict_int_validator,\n    strict_str_validator,\n)\n\n__all__ = [\n    'NoneStr',\n    'NoneBytes',\n    'StrBytes',\n    'NoneStrBytes',\n    'StrictStr',\n    'ConstrainedBytes',\n    'conbytes',\n    'ConstrainedList',\n    'conlist',\n    'ConstrainedSet',\n    'conset',\n    'ConstrainedFrozenSet',\n    'confrozenset',\n    'ConstrainedStr',\n    'constr',\n    'PyObject',\n    'ConstrainedInt',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'ConstrainedFloat',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'ConstrainedDecimal',\n    'condecimal',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'FilePath',\n    'DirectoryPath',\n    'Json',\n    'JsonWrapper',\n    'SecretField',\n    'SecretStr',\n    'SecretBytes',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    'ConstrainedDate',\n    'condate',\n]\n\nNoneStr = Optional[str]\nNoneBytes = Optional[bytes]\nStrBytes = Union[str, bytes]\nNoneStrBytes = Optional[StrBytes]\nOptionalInt = Optional[int]\nOptionalIntFloat = Union[OptionalInt, float]\nOptionalIntFloatDecimal = Union[OptionalIntFloat, Decimal]\nOptionalDate = Optional[date]\nStrIntFloat = Union[str, int, float]\n\nif TYPE_CHECKING:\n    from typing_extensions import Annotated\n\n    from pydantic.v1.dataclasses import Dataclass\n    from pydantic.v1.main import BaseModel\n    from pydantic.v1.typing import CallableGenerator\n\n    ModelOrDc = Type[Union[BaseModel, Dataclass]]\n\nT = TypeVar('T')\n_DEFINED_TYPES: 'WeakSet[type]' = WeakSet()\n\n\n@overload\ndef _registered(typ: Type[T]) -> Type[T]:\n    pass\n\n\n@overload\ndef _registered(typ: 'ConstrainedNumberMeta') -> 'ConstrainedNumberMeta':\n    pass\n\n\ndef _registered(typ: Union[Type[T], 'ConstrainedNumberMeta']) -> Union[Type[T], 'ConstrainedNumberMeta']:\n    # In order to generate valid examples of constrained types, Hypothesis needs\n    # to inspect the type object - so we keep a weakref to each contype object\n    # until it can be registered.  When (or if) our Hypothesis plugin is loaded,\n    # it monkeypatches this function.\n    # If Hypothesis is never used, the total effect is to keep a weak reference\n    # which has minimal memory usage and doesn't even affect garbage collection.\n    _DEFINED_TYPES.add(typ)\n    return typ\n\n\nclass ConstrainedNumberMeta(type):\n    def __new__(cls, name: str, bases: Any, dct: Dict[str, Any]) -> 'ConstrainedInt':  # type: ignore\n        new_cls = cast('ConstrainedInt', type.__new__(cls, name, bases, dct))\n\n        if new_cls.gt is not None and new_cls.ge is not None:\n            raise errors.ConfigError('bounds gt and ge cannot be specified at the same time')\n        if new_cls.lt is not None and new_cls.le is not None:\n            raise errors.ConfigError('bounds lt and le cannot be specified at the same time')\n\n        return _registered(new_cls)  # type: ignore\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BOOLEAN TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    StrictBool = bool\nelse:\n\n    class StrictBool(int):\n        \"\"\"\n        StrictBool to allow for bools which are not type-coerced.\n        \"\"\"\n\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(type='boolean')\n\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: Any) -> bool:\n            \"\"\"\n            Ensure that we only allow bools.\n            \"\"\"\n            if isinstance(value, bool):\n                return value\n\n            raise errors.StrictBoolError()\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ INTEGER TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ConstrainedInt(int, metaclass=ConstrainedNumberMeta):\n    strict: bool = False\n    gt: OptionalInt = None\n    ge: OptionalInt = None\n    lt: OptionalInt = None\n    le: OptionalInt = None\n    multiple_of: OptionalInt = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            exclusiveMinimum=cls.gt,\n            exclusiveMaximum=cls.lt,\n            minimum=cls.ge,\n            maximum=cls.le,\n            multipleOf=cls.multiple_of,\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield strict_int_validator if cls.strict else int_validator\n        yield number_size_validator\n        yield number_multiple_validator\n\n\ndef conint(\n    *,\n    strict: bool = False,\n    gt: Optional[int] = None,\n    ge: Optional[int] = None,\n    lt: Optional[int] = None,\n    le: Optional[int] = None,\n    multiple_of: Optional[int] = None,\n) -> Type[int]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(strict=strict, gt=gt, ge=ge, lt=lt, le=le, multiple_of=multiple_of)\n    return type('ConstrainedIntValue', (ConstrainedInt,), namespace)\n\n\nif TYPE_CHECKING:\n    PositiveInt = int\n    NegativeInt = int\n    NonPositiveInt = int\n    NonNegativeInt = int\n    StrictInt = int\nelse:\n\n    class PositiveInt(ConstrainedInt):\n        gt = 0\n\n    class NegativeInt(ConstrainedInt):\n        lt = 0\n\n    class NonPositiveInt(ConstrainedInt):\n        le = 0\n\n    class NonNegativeInt(ConstrainedInt):\n        ge = 0\n\n    class StrictInt(ConstrainedInt):\n        strict = True\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FLOAT TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ConstrainedFloat(float, metaclass=ConstrainedNumberMeta):\n    strict: bool = False\n    gt: OptionalIntFloat = None\n    ge: OptionalIntFloat = None\n    lt: OptionalIntFloat = None\n    le: OptionalIntFloat = None\n    multiple_of: OptionalIntFloat = None\n    allow_inf_nan: Optional[bool] = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            exclusiveMinimum=cls.gt,\n            exclusiveMaximum=cls.lt,\n            minimum=cls.ge,\n            maximum=cls.le,\n            multipleOf=cls.multiple_of,\n        )\n        # Modify constraints to account for differences between IEEE floats and JSON\n        if field_schema.get('exclusiveMinimum') == -math.inf:\n            del field_schema['exclusiveMinimum']\n        if field_schema.get('minimum') == -math.inf:\n            del field_schema['minimum']\n        if field_schema.get('exclusiveMaximum') == math.inf:\n            del field_schema['exclusiveMaximum']\n        if field_schema.get('maximum') == math.inf:\n            del field_schema['maximum']\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield strict_float_validator if cls.strict else float_validator\n        yield number_size_validator\n        yield number_multiple_validator\n        yield float_finite_validator\n\n\ndef confloat(\n    *,\n    strict: bool = False,\n    gt: float = None,\n    ge: float = None,\n    lt: float = None,\n    le: float = None,\n    multiple_of: float = None,\n    allow_inf_nan: Optional[bool] = None,\n) -> Type[float]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(strict=strict, gt=gt, ge=ge, lt=lt, le=le, multiple_of=multiple_of, allow_inf_nan=allow_inf_nan)\n    return type('ConstrainedFloatValue', (ConstrainedFloat,), namespace)\n\n\nif TYPE_CHECKING:\n    PositiveFloat = float\n    NegativeFloat = float\n    NonPositiveFloat = float\n    NonNegativeFloat = float\n    StrictFloat = float\n    FiniteFloat = float\nelse:\n\n    class PositiveFloat(ConstrainedFloat):\n        gt = 0\n\n    class NegativeFloat(ConstrainedFloat):\n        lt = 0\n\n    class NonPositiveFloat(ConstrainedFloat):\n        le = 0\n\n    class NonNegativeFloat(ConstrainedFloat):\n        ge = 0\n\n    class StrictFloat(ConstrainedFloat):\n        strict = True\n\n    class FiniteFloat(ConstrainedFloat):\n        allow_inf_nan = False\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTES TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ConstrainedBytes(bytes):\n    strip_whitespace = False\n    to_upper = False\n    to_lower = False\n    min_length: OptionalInt = None\n    max_length: OptionalInt = None\n    strict: bool = False\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, minLength=cls.min_length, maxLength=cls.max_length)\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield strict_bytes_validator if cls.strict else bytes_validator\n        yield constr_strip_whitespace\n        yield constr_upper\n        yield constr_lower\n        yield constr_length_validator\n\n\ndef conbytes(\n    *,\n    strip_whitespace: bool = False,\n    to_upper: bool = False,\n    to_lower: bool = False,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    strict: bool = False,\n) -> Type[bytes]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(\n        strip_whitespace=strip_whitespace,\n        to_upper=to_upper,\n        to_lower=to_lower,\n        min_length=min_length,\n        max_length=max_length,\n        strict=strict,\n    )\n    return _registered(type('ConstrainedBytesValue', (ConstrainedBytes,), namespace))\n\n\nif TYPE_CHECKING:\n    StrictBytes = bytes\nelse:\n\n    class StrictBytes(ConstrainedBytes):\n        strict = True\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ STRING TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ConstrainedStr(str):\n    strip_whitespace = False\n    to_upper = False\n    to_lower = False\n    min_length: OptionalInt = None\n    max_length: OptionalInt = None\n    curtail_length: OptionalInt = None\n    regex: Optional[Union[str, Pattern[str]]] = None\n    strict = False\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            minLength=cls.min_length,\n            maxLength=cls.max_length,\n            pattern=cls.regex and cls._get_pattern(cls.regex),\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield strict_str_validator if cls.strict else str_validator\n        yield constr_strip_whitespace\n        yield constr_upper\n        yield constr_lower\n        yield constr_length_validator\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Union[str]) -> Union[str]:\n        if cls.curtail_length and len(value) > cls.curtail_length:\n            value = value[: cls.curtail_length]\n\n        if cls.regex:\n            if not re.match(cls.regex, value):\n                raise errors.StrRegexError(pattern=cls._get_pattern(cls.regex))\n\n        return value\n\n    @staticmethod\n    def _get_pattern(regex: Union[str, Pattern[str]]) -> str:\n        return regex if isinstance(regex, str) else regex.pattern\n\n\ndef constr(\n    *,\n    strip_whitespace: bool = False,\n    to_upper: bool = False,\n    to_lower: bool = False,\n    strict: bool = False,\n    min_length: Optional[int] = None,\n    max_length: Optional[int] = None,\n    curtail_length: Optional[int] = None,\n    regex: Optional[str] = None,\n) -> Type[str]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(\n        strip_whitespace=strip_whitespace,\n        to_upper=to_upper,\n        to_lower=to_lower,\n        strict=strict,\n        min_length=min_length,\n        max_length=max_length,\n        curtail_length=curtail_length,\n        regex=regex and re.compile(regex),\n    )\n    return _registered(type('ConstrainedStrValue', (ConstrainedStr,), namespace))\n\n\nif TYPE_CHECKING:\n    StrictStr = str\nelse:\n\n    class StrictStr(ConstrainedStr):\n        strict = True\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n# This types superclass should be Set[T], but cython chokes on that...\nclass ConstrainedSet(set):  # type: ignore\n    # Needed for pydantic to detect that this is a set\n    __origin__ = set\n    __args__: Set[Type[T]]  # type: ignore\n\n    min_items: Optional[int] = None\n    max_items: Optional[int] = None\n    item_type: Type[T]  # type: ignore\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.set_length_validator\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items)\n\n    @classmethod\n    def set_length_validator(cls, v: 'Optional[Set[T]]') -> 'Optional[Set[T]]':\n        if v is None:\n            return None\n\n        v = set_validator(v)\n        v_len = len(v)\n\n        if cls.min_items is not None and v_len < cls.min_items:\n            raise errors.SetMinLengthError(limit_value=cls.min_items)\n\n        if cls.max_items is not None and v_len > cls.max_items:\n            raise errors.SetMaxLengthError(limit_value=cls.max_items)\n\n        return v\n\n\ndef conset(item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None) -> Type[Set[T]]:\n    # __args__ is needed to conform to typing generics api\n    namespace = {'min_items': min_items, 'max_items': max_items, 'item_type': item_type, '__args__': [item_type]}\n    # We use new_class to be able to deal with Generic types\n    return new_class('ConstrainedSetValue', (ConstrainedSet,), {}, lambda ns: ns.update(namespace))\n\n\n# This types superclass should be FrozenSet[T], but cython chokes on that...\nclass ConstrainedFrozenSet(frozenset):  # type: ignore\n    # Needed for pydantic to detect that this is a set\n    __origin__ = frozenset\n    __args__: FrozenSet[Type[T]]  # type: ignore\n\n    min_items: Optional[int] = None\n    max_items: Optional[int] = None\n    item_type: Type[T]  # type: ignore\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.frozenset_length_validator\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items)\n\n    @classmethod\n    def frozenset_length_validator(cls, v: 'Optional[FrozenSet[T]]') -> 'Optional[FrozenSet[T]]':\n        if v is None:\n            return None\n\n        v = frozenset_validator(v)\n        v_len = len(v)\n\n        if cls.min_items is not None and v_len < cls.min_items:\n            raise errors.FrozenSetMinLengthError(limit_value=cls.min_items)\n\n        if cls.max_items is not None and v_len > cls.max_items:\n            raise errors.FrozenSetMaxLengthError(limit_value=cls.max_items)\n\n        return v\n\n\ndef confrozenset(\n    item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None\n) -> Type[FrozenSet[T]]:\n    # __args__ is needed to conform to typing generics api\n    namespace = {'min_items': min_items, 'max_items': max_items, 'item_type': item_type, '__args__': [item_type]}\n    # We use new_class to be able to deal with Generic types\n    return new_class('ConstrainedFrozenSetValue', (ConstrainedFrozenSet,), {}, lambda ns: ns.update(namespace))\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LIST TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\n# This types superclass should be List[T], but cython chokes on that...\nclass ConstrainedList(list):  # type: ignore\n    # Needed for pydantic to detect that this is a list\n    __origin__ = list\n    __args__: Tuple[Type[T], ...]  # type: ignore\n\n    min_items: Optional[int] = None\n    max_items: Optional[int] = None\n    unique_items: Optional[bool] = None\n    item_type: Type[T]  # type: ignore\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.list_length_validator\n        if cls.unique_items:\n            yield cls.unique_items_validator\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, minItems=cls.min_items, maxItems=cls.max_items, uniqueItems=cls.unique_items)\n\n    @classmethod\n    def list_length_validator(cls, v: 'Optional[List[T]]') -> 'Optional[List[T]]':\n        if v is None:\n            return None\n\n        v = list_validator(v)\n        v_len = len(v)\n\n        if cls.min_items is not None and v_len < cls.min_items:\n            raise errors.ListMinLengthError(limit_value=cls.min_items)\n\n        if cls.max_items is not None and v_len > cls.max_items:\n            raise errors.ListMaxLengthError(limit_value=cls.max_items)\n\n        return v\n\n    @classmethod\n    def unique_items_validator(cls, v: 'Optional[List[T]]') -> 'Optional[List[T]]':\n        if v is None:\n            return None\n\n        for i, value in enumerate(v, start=1):\n            if value in v[i:]:\n                raise errors.ListUniqueItemsError()\n\n        return v\n\n\ndef conlist(\n    item_type: Type[T], *, min_items: Optional[int] = None, max_items: Optional[int] = None, unique_items: bool = None\n) -> Type[List[T]]:\n    # __args__ is needed to conform to typing generics api\n    namespace = dict(\n        min_items=min_items, max_items=max_items, unique_items=unique_items, item_type=item_type, __args__=(item_type,)\n    )\n    # We use new_class to be able to deal with Generic types\n    return new_class('ConstrainedListValue', (ConstrainedList,), {}, lambda ns: ns.update(namespace))\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PYOBJECT TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nif TYPE_CHECKING:\n    PyObject = Callable[..., Any]\nelse:\n\n    class PyObject:\n        validate_always = True\n\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: Any) -> Any:\n            if isinstance(value, Callable):\n                return value\n\n            try:\n                value = str_validator(value)\n            except errors.StrError:\n                raise errors.PyObjectError(error_message='value is neither a valid import path not a valid callable')\n\n            try:\n                return import_string(value)\n            except ImportError as e:\n                raise errors.PyObjectError(error_message=str(e))\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DECIMAL TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass ConstrainedDecimal(Decimal, metaclass=ConstrainedNumberMeta):\n    gt: OptionalIntFloatDecimal = None\n    ge: OptionalIntFloatDecimal = None\n    lt: OptionalIntFloatDecimal = None\n    le: OptionalIntFloatDecimal = None\n    max_digits: OptionalInt = None\n    decimal_places: OptionalInt = None\n    multiple_of: OptionalIntFloatDecimal = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            exclusiveMinimum=cls.gt,\n            exclusiveMaximum=cls.lt,\n            minimum=cls.ge,\n            maximum=cls.le,\n            multipleOf=cls.multiple_of,\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield decimal_validator\n        yield number_size_validator\n        yield number_multiple_validator\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Decimal) -> Decimal:\n        try:\n            normalized_value = value.normalize()\n        except InvalidOperation:\n            normalized_value = value\n        digit_tuple, exponent = normalized_value.as_tuple()[1:]\n        if exponent in {'F', 'n', 'N'}:\n            raise errors.DecimalIsNotFiniteError()\n\n        if exponent >= 0:\n            # A positive exponent adds that many trailing zeros.\n            digits = len(digit_tuple) + exponent\n            decimals = 0\n        else:\n            # If the absolute value of the negative exponent is larger than the\n            # number of digits, then it's the same as the number of digits,\n            # because it'll consume all of the digits in digit_tuple and then\n            # add abs(exponent) - len(digit_tuple) leading zeros after the\n            # decimal point.\n            if abs(exponent) > len(digit_tuple):\n                digits = decimals = abs(exponent)\n            else:\n                digits = len(digit_tuple)\n                decimals = abs(exponent)\n        whole_digits = digits - decimals\n\n        if cls.max_digits is not None and digits > cls.max_digits:\n            raise errors.DecimalMaxDigitsError(max_digits=cls.max_digits)\n\n        if cls.decimal_places is not None and decimals > cls.decimal_places:\n            raise errors.DecimalMaxPlacesError(decimal_places=cls.decimal_places)\n\n        if cls.max_digits is not None and cls.decimal_places is not None:\n            expected = cls.max_digits - cls.decimal_places\n            if whole_digits > expected:\n                raise errors.DecimalWholeDigitsError(whole_digits=expected)\n\n        return value\n\n\ndef condecimal(\n    *,\n    gt: Decimal = None,\n    ge: Decimal = None,\n    lt: Decimal = None,\n    le: Decimal = None,\n    max_digits: Optional[int] = None,\n    decimal_places: Optional[int] = None,\n    multiple_of: Decimal = None,\n) -> Type[Decimal]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(\n        gt=gt, ge=ge, lt=lt, le=le, max_digits=max_digits, decimal_places=decimal_places, multiple_of=multiple_of\n    )\n    return type('ConstrainedDecimalValue', (ConstrainedDecimal,), namespace)\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UUID TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    UUID1 = UUID\n    UUID3 = UUID\n    UUID4 = UUID\n    UUID5 = UUID\nelse:\n\n    class UUID1(UUID):\n        _required_version = 1\n\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(type='string', format=f'uuid{cls._required_version}')\n\n    class UUID3(UUID1):\n        _required_version = 3\n\n    class UUID4(UUID1):\n        _required_version = 4\n\n    class UUID5(UUID1):\n        _required_version = 5\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PATH TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    FilePath = Path\n    DirectoryPath = Path\nelse:\n\n    class FilePath(Path):\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(format='file-path')\n\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield path_validator\n            yield path_exists_validator\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: Path) -> Path:\n            if not value.is_file():\n                raise errors.PathNotAFileError(path=value)\n\n            return value\n\n    class DirectoryPath(Path):\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(format='directory-path')\n\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield path_validator\n            yield path_exists_validator\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: Path) -> Path:\n            if not value.is_dir():\n                raise errors.PathNotADirectoryError(path=value)\n\n            return value\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ JSON TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass JsonWrapper:\n    pass\n\n\nclass JsonMeta(type):\n    def __getitem__(self, t: Type[Any]) -> Type[JsonWrapper]:\n        if t is Any:\n            return Json  # allow Json[Any] to replecate plain Json\n        return _registered(type('JsonWrapperValue', (JsonWrapper,), {'inner_type': t}))\n\n\nif TYPE_CHECKING:\n    Json = Annotated[T, ...]  # Json[list[str]] will be recognized by type checkers as list[str]\n\nelse:\n\n    class Json(metaclass=JsonMeta):\n        @classmethod\n        def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n            field_schema.update(type='string', format='json-string')\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SECRET TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass SecretField(abc.ABC):\n    \"\"\"\n    Note: this should be implemented as a generic like `SecretField(ABC, Generic[T])`,\n          the `__init__()` should be part of the abstract class and the\n          `get_secret_value()` method should use the generic `T` type.\n\n          However Cython doesn't support very well generics at the moment and\n          the generated code fails to be imported (see\n          https://github.com/cython/cython/issues/2753).\n    \"\"\"\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, self.__class__) and self.get_secret_value() == other.get_secret_value()\n\n    def __str__(self) -> str:\n        return '**********' if self.get_secret_value() else ''\n\n    def __hash__(self) -> int:\n        return hash(self.get_secret_value())\n\n    @abc.abstractmethod\n    def get_secret_value(self) -> Any:  # pragma: no cover\n        ...\n\n\nclass SecretStr(SecretField):\n    min_length: OptionalInt = None\n    max_length: OptionalInt = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            type='string',\n            writeOnly=True,\n            format='password',\n            minLength=cls.min_length,\n            maxLength=cls.max_length,\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n        yield constr_length_validator\n\n    @classmethod\n    def validate(cls, value: Any) -> 'SecretStr':\n        if isinstance(value, cls):\n            return value\n        value = str_validator(value)\n        return cls(value)\n\n    def __init__(self, value: str):\n        self._secret_value = value\n\n    def __repr__(self) -> str:\n        return f\"SecretStr('{self}')\"\n\n    def __len__(self) -> int:\n        return len(self._secret_value)\n\n    def display(self) -> str:\n        warnings.warn('`secret_str.display()` is deprecated, use `str(secret_str)` instead', DeprecationWarning)\n        return str(self)\n\n    def get_secret_value(self) -> str:\n        return self._secret_value\n\n\nclass SecretBytes(SecretField):\n    min_length: OptionalInt = None\n    max_length: OptionalInt = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(\n            field_schema,\n            type='string',\n            writeOnly=True,\n            format='password',\n            minLength=cls.min_length,\n            maxLength=cls.max_length,\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n        yield constr_length_validator\n\n    @classmethod\n    def validate(cls, value: Any) -> 'SecretBytes':\n        if isinstance(value, cls):\n            return value\n        value = bytes_validator(value)\n        return cls(value)\n\n    def __init__(self, value: bytes):\n        self._secret_value = value\n\n    def __repr__(self) -> str:\n        return f\"SecretBytes(b'{self}')\"\n\n    def __len__(self) -> int:\n        return len(self._secret_value)\n\n    def display(self) -> str:\n        warnings.warn('`secret_bytes.display()` is deprecated, use `str(secret_bytes)` instead', DeprecationWarning)\n        return str(self)\n\n    def get_secret_value(self) -> bytes:\n        return self._secret_value\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PAYMENT CARD TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n\nclass PaymentCardBrand(str, Enum):\n    # If you add another card type, please also add it to the\n    # Hypothesis strategy in `pydantic._hypothesis_plugin`.\n    amex = 'American Express'\n    mastercard = 'Mastercard'\n    visa = 'Visa'\n    other = 'other'\n\n    def __str__(self) -> str:\n        return self.value\n\n\nclass PaymentCardNumber(str):\n    \"\"\"\n    Based on: https://en.wikipedia.org/wiki/Payment_card_number\n    \"\"\"\n\n    strip_whitespace: ClassVar[bool] = True\n    min_length: ClassVar[int] = 12\n    max_length: ClassVar[int] = 19\n    bin: str\n    last4: str\n    brand: PaymentCardBrand\n\n    def __init__(self, card_number: str):\n        self.bin = card_number[:6]\n        self.last4 = card_number[-4:]\n        self.brand = self._get_brand(card_number)\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield str_validator\n        yield constr_strip_whitespace\n        yield constr_length_validator\n        yield cls.validate_digits\n        yield cls.validate_luhn_check_digit\n        yield cls\n        yield cls.validate_length_for_brand\n\n    @property\n    def masked(self) -> str:\n        num_masked = len(self) - 10  # len(bin) + len(last4) == 10\n        return f'{self.bin}{\"*\" * num_masked}{self.last4}'\n\n    @classmethod\n    def validate_digits(cls, card_number: str) -> str:\n        if not card_number.isdigit():\n            raise errors.NotDigitError\n        return card_number\n\n    @classmethod\n    def validate_luhn_check_digit(cls, card_number: str) -> str:\n        \"\"\"\n        Based on: https://en.wikipedia.org/wiki/Luhn_algorithm\n        \"\"\"\n        sum_ = int(card_number[-1])\n        length = len(card_number)\n        parity = length % 2\n        for i in range(length - 1):\n            digit = int(card_number[i])\n            if i % 2 == parity:\n                digit *= 2\n            if digit > 9:\n                digit -= 9\n            sum_ += digit\n        valid = sum_ % 10 == 0\n        if not valid:\n            raise errors.LuhnValidationError\n        return card_number\n\n    @classmethod\n    def validate_length_for_brand(cls, card_number: 'PaymentCardNumber') -> 'PaymentCardNumber':\n        \"\"\"\n        Validate length based on BIN for major brands:\n        https://en.wikipedia.org/wiki/Payment_card_number#Issuer_identification_number_(IIN)\n        \"\"\"\n        required_length: Union[None, int, str] = None\n        if card_number.brand in PaymentCardBrand.mastercard:\n            required_length = 16\n            valid = len(card_number) == required_length\n        elif card_number.brand == PaymentCardBrand.visa:\n            required_length = '13, 16 or 19'\n            valid = len(card_number) in {13, 16, 19}\n        elif card_number.brand == PaymentCardBrand.amex:\n            required_length = 15\n            valid = len(card_number) == required_length\n        else:\n            valid = True\n        if not valid:\n            raise errors.InvalidLengthForBrand(brand=card_number.brand, required_length=required_length)\n        return card_number\n\n    @staticmethod\n    def _get_brand(card_number: str) -> PaymentCardBrand:\n        if card_number[0] == '4':\n            brand = PaymentCardBrand.visa\n        elif 51 <= int(card_number[:2]) <= 55:\n            brand = PaymentCardBrand.mastercard\n        elif card_number[:2] in {'34', '37'}:\n            brand = PaymentCardBrand.amex\n        else:\n            brand = PaymentCardBrand.other\n        return brand\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BYTE SIZE TYPE ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nBYTE_SIZES = {\n    'b': 1,\n    'kb': 10**3,\n    'mb': 10**6,\n    'gb': 10**9,\n    'tb': 10**12,\n    'pb': 10**15,\n    'eb': 10**18,\n    'kib': 2**10,\n    'mib': 2**20,\n    'gib': 2**30,\n    'tib': 2**40,\n    'pib': 2**50,\n    'eib': 2**60,\n}\nBYTE_SIZES.update({k.lower()[0]: v for k, v in BYTE_SIZES.items() if 'i' not in k})\nbyte_string_re = re.compile(r'^\\s*(\\d*\\.?\\d+)\\s*(\\w+)?', re.IGNORECASE)\n\n\nclass ByteSize(int):\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, v: StrIntFloat) -> 'ByteSize':\n        try:\n            return cls(int(v))\n        except ValueError:\n            pass\n\n        str_match = byte_string_re.match(str(v))\n        if str_match is None:\n            raise errors.InvalidByteSize()\n\n        scalar, unit = str_match.groups()\n        if unit is None:\n            unit = 'b'\n\n        try:\n            unit_mult = BYTE_SIZES[unit.lower()]\n        except KeyError:\n            raise errors.InvalidByteSizeUnit(unit=unit)\n\n        return cls(int(float(scalar) * unit_mult))\n\n    def human_readable(self, decimal: bool = False) -> str:\n        if decimal:\n            divisor = 1000\n            units = ['B', 'KB', 'MB', 'GB', 'TB', 'PB']\n            final_unit = 'EB'\n        else:\n            divisor = 1024\n            units = ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB']\n            final_unit = 'EiB'\n\n        num = float(self)\n        for unit in units:\n            if abs(num) < divisor:\n                return f'{num:0.1f}{unit}'\n            num /= divisor\n\n        return f'{num:0.1f}{final_unit}'\n\n    def to(self, unit: str) -> float:\n        try:\n            unit_div = BYTE_SIZES[unit.lower()]\n        except KeyError:\n            raise errors.InvalidByteSizeUnit(unit=unit)\n\n        return self / unit_div\n\n\n# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DATE TYPES ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\nif TYPE_CHECKING:\n    PastDate = date\n    FutureDate = date\nelse:\n\n    class PastDate(date):\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield parse_date\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: date) -> date:\n            if value >= date.today():\n                raise errors.DateNotInThePastError()\n\n            return value\n\n    class FutureDate(date):\n        @classmethod\n        def __get_validators__(cls) -> 'CallableGenerator':\n            yield parse_date\n            yield cls.validate\n\n        @classmethod\n        def validate(cls, value: date) -> date:\n            if value <= date.today():\n                raise errors.DateNotInTheFutureError()\n\n            return value\n\n\nclass ConstrainedDate(date, metaclass=ConstrainedNumberMeta):\n    gt: OptionalDate = None\n    ge: OptionalDate = None\n    lt: OptionalDate = None\n    le: OptionalDate = None\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, exclusiveMinimum=cls.gt, exclusiveMaximum=cls.lt, minimum=cls.ge, maximum=cls.le)\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield parse_date\n        yield number_size_validator\n\n\ndef condate(\n    *,\n    gt: date = None,\n    ge: date = None,\n    lt: date = None,\n    le: date = None,\n) -> Type[date]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(gt=gt, ge=ge, lt=lt, le=le)\n    return type('ConstrainedDateValue', (ConstrainedDate,), namespace)\n", "pydantic/v1/annotated_types.py": "import sys\nfrom typing import TYPE_CHECKING, Any, Dict, FrozenSet, NamedTuple, Type\n\nfrom pydantic.v1.fields import Required\nfrom pydantic.v1.main import BaseModel, create_model\nfrom pydantic.v1.typing import is_typeddict, is_typeddict_special\n\nif TYPE_CHECKING:\n    from typing_extensions import TypedDict\n\nif sys.version_info < (3, 11):\n\n    def is_legacy_typeddict(typeddict_cls: Type['TypedDict']) -> bool:  # type: ignore[valid-type]\n        return is_typeddict(typeddict_cls) and type(typeddict_cls).__module__ == 'typing'\n\nelse:\n\n    def is_legacy_typeddict(_: Any) -> Any:\n        return False\n\n\ndef create_model_from_typeddict(\n    # Mypy bug: `Type[TypedDict]` is resolved as `Any` https://github.com/python/mypy/issues/11030\n    typeddict_cls: Type['TypedDict'],  # type: ignore[valid-type]\n    **kwargs: Any,\n) -> Type['BaseModel']:\n    \"\"\"\n    Create a `BaseModel` based on the fields of a `TypedDict`.\n    Since `typing.TypedDict` in Python 3.8 does not store runtime information about optional keys,\n    we raise an error if this happens (see https://bugs.python.org/issue38834).\n    \"\"\"\n    field_definitions: Dict[str, Any]\n\n    # Best case scenario: with python 3.9+ or when `TypedDict` is imported from `typing_extensions`\n    if not hasattr(typeddict_cls, '__required_keys__'):\n        raise TypeError(\n            'You should use `typing_extensions.TypedDict` instead of `typing.TypedDict` with Python < 3.9.2. '\n            'Without it, there is no way to differentiate required and optional fields when subclassed.'\n        )\n\n    if is_legacy_typeddict(typeddict_cls) and any(\n        is_typeddict_special(t) for t in typeddict_cls.__annotations__.values()\n    ):\n        raise TypeError(\n            'You should use `typing_extensions.TypedDict` instead of `typing.TypedDict` with Python < 3.11. '\n            'Without it, there is no way to reflect Required/NotRequired keys.'\n        )\n\n    required_keys: FrozenSet[str] = typeddict_cls.__required_keys__  # type: ignore[attr-defined]\n    field_definitions = {\n        field_name: (field_type, Required if field_name in required_keys else None)\n        for field_name, field_type in typeddict_cls.__annotations__.items()\n    }\n\n    return create_model(typeddict_cls.__name__, **kwargs, **field_definitions)\n\n\ndef create_model_from_namedtuple(namedtuple_cls: Type['NamedTuple'], **kwargs: Any) -> Type['BaseModel']:\n    \"\"\"\n    Create a `BaseModel` based on the fields of a named tuple.\n    A named tuple can be created with `typing.NamedTuple` and declared annotations\n    but also with `collections.namedtuple`, in this case we consider all fields\n    to have type `Any`.\n    \"\"\"\n    # With python 3.10+, `__annotations__` always exists but can be empty hence the `getattr... or...` logic\n    namedtuple_annotations: Dict[str, Type[Any]] = getattr(namedtuple_cls, '__annotations__', None) or {\n        k: Any for k in namedtuple_cls._fields\n    }\n    field_definitions: Dict[str, Any] = {\n        field_name: (field_type, Required) for field_name, field_type in namedtuple_annotations.items()\n    }\n    return create_model(namedtuple_cls.__name__, **kwargs, **field_definitions)\n", "pydantic/v1/main.py": "import warnings\nfrom abc import ABCMeta\nfrom copy import deepcopy\nfrom enum import Enum\nfrom functools import partial\nfrom pathlib import Path\nfrom types import FunctionType, prepare_class, resolve_bases\nfrom typing import (\n    TYPE_CHECKING,\n    AbstractSet,\n    Any,\n    Callable,\n    ClassVar,\n    Dict,\n    List,\n    Mapping,\n    Optional,\n    Tuple,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    no_type_check,\n    overload,\n)\n\nfrom typing_extensions import dataclass_transform\n\nfrom pydantic.v1.class_validators import ValidatorGroup, extract_root_validators, extract_validators, inherit_validators\nfrom pydantic.v1.config import BaseConfig, Extra, inherit_config, prepare_config\nfrom pydantic.v1.error_wrappers import ErrorWrapper, ValidationError\nfrom pydantic.v1.errors import ConfigError, DictError, ExtraError, MissingError\nfrom pydantic.v1.fields import (\n    MAPPING_LIKE_SHAPES,\n    Field,\n    ModelField,\n    ModelPrivateAttr,\n    PrivateAttr,\n    Undefined,\n    is_finalvar_with_default_val,\n)\nfrom pydantic.v1.json import custom_pydantic_encoder, pydantic_encoder\nfrom pydantic.v1.parse import Protocol, load_file, load_str_bytes\nfrom pydantic.v1.schema import default_ref_template, model_schema\nfrom pydantic.v1.types import PyObject, StrBytes\nfrom pydantic.v1.typing import (\n    AnyCallable,\n    get_args,\n    get_origin,\n    is_classvar,\n    is_namedtuple,\n    is_union,\n    resolve_annotations,\n    update_model_forward_refs,\n)\nfrom pydantic.v1.utils import (\n    DUNDER_ATTRIBUTES,\n    ROOT_KEY,\n    ClassAttribute,\n    GetterDict,\n    Representation,\n    ValueItems,\n    generate_model_signature,\n    is_valid_field,\n    is_valid_private_name,\n    lenient_issubclass,\n    sequence_like,\n    smart_deepcopy,\n    unique_list,\n    validate_field_name,\n)\n\nif TYPE_CHECKING:\n    from inspect import Signature\n\n    from pydantic.v1.class_validators import ValidatorListDict\n    from pydantic.v1.types import ModelOrDc\n    from pydantic.v1.typing import (\n        AbstractSetIntStr,\n        AnyClassMethod,\n        CallableGenerator,\n        DictAny,\n        DictStrAny,\n        MappingIntStrAny,\n        ReprArgs,\n        SetStr,\n        TupleGenerator,\n    )\n\n    Model = TypeVar('Model', bound='BaseModel')\n\n__all__ = 'BaseModel', 'create_model', 'validate_model'\n\n_T = TypeVar('_T')\n\n\ndef validate_custom_root_type(fields: Dict[str, ModelField]) -> None:\n    if len(fields) > 1:\n        raise ValueError(f'{ROOT_KEY} cannot be mixed with other fields')\n\n\ndef generate_hash_function(frozen: bool) -> Optional[Callable[[Any], int]]:\n    def hash_function(self_: Any) -> int:\n        return hash(self_.__class__) + hash(tuple(self_.__dict__.values()))\n\n    return hash_function if frozen else None\n\n\n# If a field is of type `Callable`, its default value should be a function and cannot to ignored.\nANNOTATED_FIELD_UNTOUCHED_TYPES: Tuple[Any, ...] = (property, type, classmethod, staticmethod)\n# When creating a `BaseModel` instance, we bypass all the methods, properties... added to the model\nUNTOUCHED_TYPES: Tuple[Any, ...] = (FunctionType,) + ANNOTATED_FIELD_UNTOUCHED_TYPES\n# Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we need to add this extra\n# (somewhat hacky) boolean to keep track of whether we've created the `BaseModel` class yet, and therefore whether it's\n# safe to refer to it. If it *hasn't* been created, we assume that the `__new__` call we're in the middle of is for\n# the `BaseModel` class, since that's defined immediately after the metaclass.\n_is_base_model_class_defined = False\n\n\n@dataclass_transform(kw_only_default=True, field_specifiers=(Field,))\nclass ModelMetaclass(ABCMeta):\n    @no_type_check  # noqa C901\n    def __new__(mcs, name, bases, namespace, **kwargs):  # noqa C901\n        fields: Dict[str, ModelField] = {}\n        config = BaseConfig\n        validators: 'ValidatorListDict' = {}\n\n        pre_root_validators, post_root_validators = [], []\n        private_attributes: Dict[str, ModelPrivateAttr] = {}\n        base_private_attributes: Dict[str, ModelPrivateAttr] = {}\n        slots: SetStr = namespace.get('__slots__', ())\n        slots = {slots} if isinstance(slots, str) else set(slots)\n        class_vars: SetStr = set()\n        hash_func: Optional[Callable[[Any], int]] = None\n\n        for base in reversed(bases):\n            if _is_base_model_class_defined and issubclass(base, BaseModel) and base != BaseModel:\n                fields.update(smart_deepcopy(base.__fields__))\n                config = inherit_config(base.__config__, config)\n                validators = inherit_validators(base.__validators__, validators)\n                pre_root_validators += base.__pre_root_validators__\n                post_root_validators += base.__post_root_validators__\n                base_private_attributes.update(base.__private_attributes__)\n                class_vars.update(base.__class_vars__)\n                hash_func = base.__hash__\n\n        resolve_forward_refs = kwargs.pop('__resolve_forward_refs__', True)\n        allowed_config_kwargs: SetStr = {\n            key\n            for key in dir(config)\n            if not (key.startswith('__') and key.endswith('__'))  # skip dunder methods and attributes\n        }\n        config_kwargs = {key: kwargs.pop(key) for key in kwargs.keys() & allowed_config_kwargs}\n        config_from_namespace = namespace.get('Config')\n        if config_kwargs and config_from_namespace:\n            raise TypeError('Specifying config in two places is ambiguous, use either Config attribute or class kwargs')\n        config = inherit_config(config_from_namespace, config, **config_kwargs)\n\n        validators = inherit_validators(extract_validators(namespace), validators)\n        vg = ValidatorGroup(validators)\n\n        for f in fields.values():\n            f.set_config(config)\n            extra_validators = vg.get_validators(f.name)\n            if extra_validators:\n                f.class_validators.update(extra_validators)\n                # re-run prepare to add extra validators\n                f.populate_validators()\n\n        prepare_config(config, name)\n\n        untouched_types = ANNOTATED_FIELD_UNTOUCHED_TYPES\n\n        def is_untouched(v: Any) -> bool:\n            return isinstance(v, untouched_types) or v.__class__.__name__ == 'cython_function_or_method'\n\n        if (namespace.get('__module__'), namespace.get('__qualname__')) != ('pydantic.main', 'BaseModel'):\n            annotations = resolve_annotations(namespace.get('__annotations__', {}), namespace.get('__module__', None))\n            # annotation only fields need to come first in fields\n            for ann_name, ann_type in annotations.items():\n                if is_classvar(ann_type):\n                    class_vars.add(ann_name)\n                elif is_finalvar_with_default_val(ann_type, namespace.get(ann_name, Undefined)):\n                    class_vars.add(ann_name)\n                elif is_valid_field(ann_name):\n                    validate_field_name(bases, ann_name)\n                    value = namespace.get(ann_name, Undefined)\n                    allowed_types = get_args(ann_type) if is_union(get_origin(ann_type)) else (ann_type,)\n                    if (\n                        is_untouched(value)\n                        and ann_type != PyObject\n                        and not any(\n                            lenient_issubclass(get_origin(allowed_type), Type) for allowed_type in allowed_types\n                        )\n                    ):\n                        continue\n                    fields[ann_name] = ModelField.infer(\n                        name=ann_name,\n                        value=value,\n                        annotation=ann_type,\n                        class_validators=vg.get_validators(ann_name),\n                        config=config,\n                    )\n                elif ann_name not in namespace and config.underscore_attrs_are_private:\n                    private_attributes[ann_name] = PrivateAttr()\n\n            untouched_types = UNTOUCHED_TYPES + config.keep_untouched\n            for var_name, value in namespace.items():\n                can_be_changed = var_name not in class_vars and not is_untouched(value)\n                if isinstance(value, ModelPrivateAttr):\n                    if not is_valid_private_name(var_name):\n                        raise NameError(\n                            f'Private attributes \"{var_name}\" must not be a valid field name; '\n                            f'Use sunder or dunder names, e. g. \"_{var_name}\" or \"__{var_name}__\"'\n                        )\n                    private_attributes[var_name] = value\n                elif config.underscore_attrs_are_private and is_valid_private_name(var_name) and can_be_changed:\n                    private_attributes[var_name] = PrivateAttr(default=value)\n                elif is_valid_field(var_name) and var_name not in annotations and can_be_changed:\n                    validate_field_name(bases, var_name)\n                    inferred = ModelField.infer(\n                        name=var_name,\n                        value=value,\n                        annotation=annotations.get(var_name, Undefined),\n                        class_validators=vg.get_validators(var_name),\n                        config=config,\n                    )\n                    if var_name in fields:\n                        if lenient_issubclass(inferred.type_, fields[var_name].type_):\n                            inferred.type_ = fields[var_name].type_\n                        else:\n                            raise TypeError(\n                                f'The type of {name}.{var_name} differs from the new default value; '\n                                f'if you wish to change the type of this field, please use a type annotation'\n                            )\n                    fields[var_name] = inferred\n\n        _custom_root_type = ROOT_KEY in fields\n        if _custom_root_type:\n            validate_custom_root_type(fields)\n        vg.check_for_unused()\n        if config.json_encoders:\n            json_encoder = partial(custom_pydantic_encoder, config.json_encoders)\n        else:\n            json_encoder = pydantic_encoder\n        pre_rv_new, post_rv_new = extract_root_validators(namespace)\n\n        if hash_func is None:\n            hash_func = generate_hash_function(config.frozen)\n\n        exclude_from_namespace = fields | private_attributes.keys() | {'__slots__'}\n        new_namespace = {\n            '__config__': config,\n            '__fields__': fields,\n            '__exclude_fields__': {\n                name: field.field_info.exclude for name, field in fields.items() if field.field_info.exclude is not None\n            }\n            or None,\n            '__include_fields__': {\n                name: field.field_info.include for name, field in fields.items() if field.field_info.include is not None\n            }\n            or None,\n            '__validators__': vg.validators,\n            '__pre_root_validators__': unique_list(\n                pre_root_validators + pre_rv_new,\n                name_factory=lambda v: v.__name__,\n            ),\n            '__post_root_validators__': unique_list(\n                post_root_validators + post_rv_new,\n                name_factory=lambda skip_on_failure_and_v: skip_on_failure_and_v[1].__name__,\n            ),\n            '__schema_cache__': {},\n            '__json_encoder__': staticmethod(json_encoder),\n            '__custom_root_type__': _custom_root_type,\n            '__private_attributes__': {**base_private_attributes, **private_attributes},\n            '__slots__': slots | private_attributes.keys(),\n            '__hash__': hash_func,\n            '__class_vars__': class_vars,\n            **{n: v for n, v in namespace.items() if n not in exclude_from_namespace},\n        }\n\n        cls = super().__new__(mcs, name, bases, new_namespace, **kwargs)\n        # set __signature__ attr only for model class, but not for its instances\n        cls.__signature__ = ClassAttribute('__signature__', generate_model_signature(cls.__init__, fields, config))\n        if resolve_forward_refs:\n            cls.__try_update_forward_refs__()\n\n        # preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487\n        # for attributes not in `new_namespace` (e.g. private attributes)\n        for name, obj in namespace.items():\n            if name not in new_namespace:\n                set_name = getattr(obj, '__set_name__', None)\n                if callable(set_name):\n                    set_name(cls, name)\n\n        return cls\n\n    def __instancecheck__(self, instance: Any) -> bool:\n        \"\"\"\n        Avoid calling ABC _abc_subclasscheck unless we're pretty sure.\n\n        See #3829 and python/cpython#92810\n        \"\"\"\n        return hasattr(instance, '__fields__') and super().__instancecheck__(instance)\n\n\nobject_setattr = object.__setattr__\n\n\nclass BaseModel(Representation, metaclass=ModelMetaclass):\n    if TYPE_CHECKING:\n        # populated by the metaclass, defined here to help IDEs only\n        __fields__: ClassVar[Dict[str, ModelField]] = {}\n        __include_fields__: ClassVar[Optional[Mapping[str, Any]]] = None\n        __exclude_fields__: ClassVar[Optional[Mapping[str, Any]]] = None\n        __validators__: ClassVar[Dict[str, AnyCallable]] = {}\n        __pre_root_validators__: ClassVar[List[AnyCallable]]\n        __post_root_validators__: ClassVar[List[Tuple[bool, AnyCallable]]]\n        __config__: ClassVar[Type[BaseConfig]] = BaseConfig\n        __json_encoder__: ClassVar[Callable[[Any], Any]] = lambda x: x\n        __schema_cache__: ClassVar['DictAny'] = {}\n        __custom_root_type__: ClassVar[bool] = False\n        __signature__: ClassVar['Signature']\n        __private_attributes__: ClassVar[Dict[str, ModelPrivateAttr]]\n        __class_vars__: ClassVar[SetStr]\n        __fields_set__: ClassVar[SetStr] = set()\n\n    Config = BaseConfig\n    __slots__ = ('__dict__', '__fields_set__')\n    __doc__ = ''  # Null out the Representation docstring\n\n    def __init__(__pydantic_self__, **data: Any) -> None:\n        \"\"\"\n        Create a new model by parsing and validating input data from keyword arguments.\n\n        Raises ValidationError if the input data cannot be parsed to form a valid model.\n        \"\"\"\n        # Uses something other than `self` the first arg to allow \"self\" as a settable attribute\n        values, fields_set, validation_error = validate_model(__pydantic_self__.__class__, data)\n        if validation_error:\n            raise validation_error\n        try:\n            object_setattr(__pydantic_self__, '__dict__', values)\n        except TypeError as e:\n            raise TypeError(\n                'Model values must be a dict; you may not have returned a dictionary from a root validator'\n            ) from e\n        object_setattr(__pydantic_self__, '__fields_set__', fields_set)\n        __pydantic_self__._init_private_attributes()\n\n    @no_type_check\n    def __setattr__(self, name, value):  # noqa: C901 (ignore complexity)\n        if name in self.__private_attributes__ or name in DUNDER_ATTRIBUTES:\n            return object_setattr(self, name, value)\n\n        if self.__config__.extra is not Extra.allow and name not in self.__fields__:\n            raise ValueError(f'\"{self.__class__.__name__}\" object has no field \"{name}\"')\n        elif not self.__config__.allow_mutation or self.__config__.frozen:\n            raise TypeError(f'\"{self.__class__.__name__}\" is immutable and does not support item assignment')\n        elif name in self.__fields__ and self.__fields__[name].final:\n            raise TypeError(\n                f'\"{self.__class__.__name__}\" object \"{name}\" field is final and does not support reassignment'\n            )\n        elif self.__config__.validate_assignment:\n            new_values = {**self.__dict__, name: value}\n\n            for validator in self.__pre_root_validators__:\n                try:\n                    new_values = validator(self.__class__, new_values)\n                except (ValueError, TypeError, AssertionError) as exc:\n                    raise ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], self.__class__)\n\n            known_field = self.__fields__.get(name, None)\n            if known_field:\n                # We want to\n                # - make sure validators are called without the current value for this field inside `values`\n                # - keep other values (e.g. submodels) untouched (using `BaseModel.dict()` will change them into dicts)\n                # - keep the order of the fields\n                if not known_field.field_info.allow_mutation:\n                    raise TypeError(f'\"{known_field.name}\" has allow_mutation set to False and cannot be assigned')\n                dict_without_original_value = {k: v for k, v in self.__dict__.items() if k != name}\n                value, error_ = known_field.validate(value, dict_without_original_value, loc=name, cls=self.__class__)\n                if error_:\n                    raise ValidationError([error_], self.__class__)\n                else:\n                    new_values[name] = value\n\n            errors = []\n            for skip_on_failure, validator in self.__post_root_validators__:\n                if skip_on_failure and errors:\n                    continue\n                try:\n                    new_values = validator(self.__class__, new_values)\n                except (ValueError, TypeError, AssertionError) as exc:\n                    errors.append(ErrorWrapper(exc, loc=ROOT_KEY))\n            if errors:\n                raise ValidationError(errors, self.__class__)\n\n            # update the whole __dict__ as other values than just `value`\n            # may be changed (e.g. with `root_validator`)\n            object_setattr(self, '__dict__', new_values)\n        else:\n            self.__dict__[name] = value\n\n        self.__fields_set__.add(name)\n\n    def __getstate__(self) -> 'DictAny':\n        private_attrs = ((k, getattr(self, k, Undefined)) for k in self.__private_attributes__)\n        return {\n            '__dict__': self.__dict__,\n            '__fields_set__': self.__fields_set__,\n            '__private_attribute_values__': {k: v for k, v in private_attrs if v is not Undefined},\n        }\n\n    def __setstate__(self, state: 'DictAny') -> None:\n        object_setattr(self, '__dict__', state['__dict__'])\n        object_setattr(self, '__fields_set__', state['__fields_set__'])\n        for name, value in state.get('__private_attribute_values__', {}).items():\n            object_setattr(self, name, value)\n\n    def _init_private_attributes(self) -> None:\n        for name, private_attr in self.__private_attributes__.items():\n            default = private_attr.get_default()\n            if default is not Undefined:\n                object_setattr(self, name, default)\n\n    def dict(\n        self,\n        *,\n        include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        by_alias: bool = False,\n        skip_defaults: Optional[bool] = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -> 'DictStrAny':\n        \"\"\"\n        Generate a dictionary representation of the model, optionally specifying which fields to include or exclude.\n\n        \"\"\"\n        if skip_defaults is not None:\n            warnings.warn(\n                f'{self.__class__.__name__}.dict(): \"skip_defaults\" is deprecated and replaced by \"exclude_unset\"',\n                DeprecationWarning,\n            )\n            exclude_unset = skip_defaults\n\n        return dict(\n            self._iter(\n                to_dict=True,\n                by_alias=by_alias,\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n        )\n\n    def json(\n        self,\n        *,\n        include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        by_alias: bool = False,\n        skip_defaults: Optional[bool] = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n        encoder: Optional[Callable[[Any], Any]] = None,\n        models_as_dict: bool = True,\n        **dumps_kwargs: Any,\n    ) -> str:\n        \"\"\"\n        Generate a JSON representation of the model, `include` and `exclude` arguments as per `dict()`.\n\n        `encoder` is an optional function to supply as `default` to json.dumps(), other arguments as per `json.dumps()`.\n        \"\"\"\n        if skip_defaults is not None:\n            warnings.warn(\n                f'{self.__class__.__name__}.json(): \"skip_defaults\" is deprecated and replaced by \"exclude_unset\"',\n                DeprecationWarning,\n            )\n            exclude_unset = skip_defaults\n        encoder = cast(Callable[[Any], Any], encoder or self.__json_encoder__)\n\n        # We don't directly call `self.dict()`, which does exactly this with `to_dict=True`\n        # because we want to be able to keep raw `BaseModel` instances and not as `dict`.\n        # This allows users to write custom JSON encoders for given `BaseModel` classes.\n        data = dict(\n            self._iter(\n                to_dict=models_as_dict,\n                by_alias=by_alias,\n                include=include,\n                exclude=exclude,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n        )\n        if self.__custom_root_type__:\n            data = data[ROOT_KEY]\n        return self.__config__.json_dumps(data, default=encoder, **dumps_kwargs)\n\n    @classmethod\n    def _enforce_dict_if_root(cls, obj: Any) -> Any:\n        if cls.__custom_root_type__ and (\n            not (isinstance(obj, dict) and obj.keys() == {ROOT_KEY})\n            and not (isinstance(obj, BaseModel) and obj.__fields__.keys() == {ROOT_KEY})\n            or cls.__fields__[ROOT_KEY].shape in MAPPING_LIKE_SHAPES\n        ):\n            return {ROOT_KEY: obj}\n        else:\n            return obj\n\n    @classmethod\n    def parse_obj(cls: Type['Model'], obj: Any) -> 'Model':\n        obj = cls._enforce_dict_if_root(obj)\n        if not isinstance(obj, dict):\n            try:\n                obj = dict(obj)\n            except (TypeError, ValueError) as e:\n                exc = TypeError(f'{cls.__name__} expected dict not {obj.__class__.__name__}')\n                raise ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], cls) from e\n        return cls(**obj)\n\n    @classmethod\n    def parse_raw(\n        cls: Type['Model'],\n        b: StrBytes,\n        *,\n        content_type: str = None,\n        encoding: str = 'utf8',\n        proto: Protocol = None,\n        allow_pickle: bool = False,\n    ) -> 'Model':\n        try:\n            obj = load_str_bytes(\n                b,\n                proto=proto,\n                content_type=content_type,\n                encoding=encoding,\n                allow_pickle=allow_pickle,\n                json_loads=cls.__config__.json_loads,\n            )\n        except (ValueError, TypeError, UnicodeDecodeError) as e:\n            raise ValidationError([ErrorWrapper(e, loc=ROOT_KEY)], cls)\n        return cls.parse_obj(obj)\n\n    @classmethod\n    def parse_file(\n        cls: Type['Model'],\n        path: Union[str, Path],\n        *,\n        content_type: str = None,\n        encoding: str = 'utf8',\n        proto: Protocol = None,\n        allow_pickle: bool = False,\n    ) -> 'Model':\n        obj = load_file(\n            path,\n            proto=proto,\n            content_type=content_type,\n            encoding=encoding,\n            allow_pickle=allow_pickle,\n            json_loads=cls.__config__.json_loads,\n        )\n        return cls.parse_obj(obj)\n\n    @classmethod\n    def from_orm(cls: Type['Model'], obj: Any) -> 'Model':\n        if not cls.__config__.orm_mode:\n            raise ConfigError('You must have the config attribute orm_mode=True to use from_orm')\n        obj = {ROOT_KEY: obj} if cls.__custom_root_type__ else cls._decompose_class(obj)\n        m = cls.__new__(cls)\n        values, fields_set, validation_error = validate_model(cls, obj)\n        if validation_error:\n            raise validation_error\n        object_setattr(m, '__dict__', values)\n        object_setattr(m, '__fields_set__', fields_set)\n        m._init_private_attributes()\n        return m\n\n    @classmethod\n    def construct(cls: Type['Model'], _fields_set: Optional['SetStr'] = None, **values: Any) -> 'Model':\n        \"\"\"\n        Creates a new model setting __dict__ and __fields_set__ from trusted or pre-validated data.\n        Default values are respected, but no other validation is performed.\n        Behaves as if `Config.extra = 'allow'` was set since it adds all passed values\n        \"\"\"\n        m = cls.__new__(cls)\n        fields_values: Dict[str, Any] = {}\n        for name, field in cls.__fields__.items():\n            if field.alt_alias and field.alias in values:\n                fields_values[name] = values[field.alias]\n            elif name in values:\n                fields_values[name] = values[name]\n            elif not field.required:\n                fields_values[name] = field.get_default()\n        fields_values.update(values)\n        object_setattr(m, '__dict__', fields_values)\n        if _fields_set is None:\n            _fields_set = set(values.keys())\n        object_setattr(m, '__fields_set__', _fields_set)\n        m._init_private_attributes()\n        return m\n\n    def _copy_and_set_values(self: 'Model', values: 'DictStrAny', fields_set: 'SetStr', *, deep: bool) -> 'Model':\n        if deep:\n            # chances of having empty dict here are quite low for using smart_deepcopy\n            values = deepcopy(values)\n\n        cls = self.__class__\n        m = cls.__new__(cls)\n        object_setattr(m, '__dict__', values)\n        object_setattr(m, '__fields_set__', fields_set)\n        for name in self.__private_attributes__:\n            value = getattr(self, name, Undefined)\n            if value is not Undefined:\n                if deep:\n                    value = deepcopy(value)\n                object_setattr(m, name, value)\n\n        return m\n\n    def copy(\n        self: 'Model',\n        *,\n        include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        update: Optional['DictStrAny'] = None,\n        deep: bool = False,\n    ) -> 'Model':\n        \"\"\"\n        Duplicate a model, optionally choose which fields to include, exclude and change.\n\n        :param include: fields to include in new model\n        :param exclude: fields to exclude from new model, as with values this takes precedence over include\n        :param update: values to change/add in the new model. Note: the data is not validated before creating\n            the new model: you should trust this data\n        :param deep: set to `True` to make a deep copy of the model\n        :return: new model instance\n        \"\"\"\n\n        values = dict(\n            self._iter(to_dict=False, by_alias=False, include=include, exclude=exclude, exclude_unset=False),\n            **(update or {}),\n        )\n\n        # new `__fields_set__` can have unset optional fields with a set value in `update` kwarg\n        if update:\n            fields_set = self.__fields_set__ | update.keys()\n        else:\n            fields_set = set(self.__fields_set__)\n\n        return self._copy_and_set_values(values, fields_set, deep=deep)\n\n    @classmethod\n    def schema(cls, by_alias: bool = True, ref_template: str = default_ref_template) -> 'DictStrAny':\n        cached = cls.__schema_cache__.get((by_alias, ref_template))\n        if cached is not None:\n            return cached\n        s = model_schema(cls, by_alias=by_alias, ref_template=ref_template)\n        cls.__schema_cache__[(by_alias, ref_template)] = s\n        return s\n\n    @classmethod\n    def schema_json(\n        cls, *, by_alias: bool = True, ref_template: str = default_ref_template, **dumps_kwargs: Any\n    ) -> str:\n        from pydantic.v1.json import pydantic_encoder\n\n        return cls.__config__.json_dumps(\n            cls.schema(by_alias=by_alias, ref_template=ref_template), default=pydantic_encoder, **dumps_kwargs\n        )\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls: Type['Model'], value: Any) -> 'Model':\n        if isinstance(value, cls):\n            copy_on_model_validation = cls.__config__.copy_on_model_validation\n            # whether to deep or shallow copy the model on validation, None means do not copy\n            deep_copy: Optional[bool] = None\n            if copy_on_model_validation not in {'deep', 'shallow', 'none'}:\n                # Warn about deprecated behavior\n                warnings.warn(\n                    \"`copy_on_model_validation` should be a string: 'deep', 'shallow' or 'none'\", DeprecationWarning\n                )\n                if copy_on_model_validation:\n                    deep_copy = False\n\n            if copy_on_model_validation == 'shallow':\n                # shallow copy\n                deep_copy = False\n            elif copy_on_model_validation == 'deep':\n                # deep copy\n                deep_copy = True\n\n            if deep_copy is None:\n                return value\n            else:\n                return value._copy_and_set_values(value.__dict__, value.__fields_set__, deep=deep_copy)\n\n        value = cls._enforce_dict_if_root(value)\n\n        if isinstance(value, dict):\n            return cls(**value)\n        elif cls.__config__.orm_mode:\n            return cls.from_orm(value)\n        else:\n            try:\n                value_as_dict = dict(value)\n            except (TypeError, ValueError) as e:\n                raise DictError() from e\n            return cls(**value_as_dict)\n\n    @classmethod\n    def _decompose_class(cls: Type['Model'], obj: Any) -> GetterDict:\n        if isinstance(obj, GetterDict):\n            return obj\n        return cls.__config__.getter_dict(obj)\n\n    @classmethod\n    @no_type_check\n    def _get_value(\n        cls,\n        v: Any,\n        to_dict: bool,\n        by_alias: bool,\n        include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']],\n        exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']],\n        exclude_unset: bool,\n        exclude_defaults: bool,\n        exclude_none: bool,\n    ) -> Any:\n        if isinstance(v, BaseModel):\n            if to_dict:\n                v_dict = v.dict(\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    include=include,\n                    exclude=exclude,\n                    exclude_none=exclude_none,\n                )\n                if ROOT_KEY in v_dict:\n                    return v_dict[ROOT_KEY]\n                return v_dict\n            else:\n                return v.copy(include=include, exclude=exclude)\n\n        value_exclude = ValueItems(v, exclude) if exclude else None\n        value_include = ValueItems(v, include) if include else None\n\n        if isinstance(v, dict):\n            return {\n                k_: cls._get_value(\n                    v_,\n                    to_dict=to_dict,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    include=value_include and value_include.for_element(k_),\n                    exclude=value_exclude and value_exclude.for_element(k_),\n                    exclude_none=exclude_none,\n                )\n                for k_, v_ in v.items()\n                if (not value_exclude or not value_exclude.is_excluded(k_))\n                and (not value_include or value_include.is_included(k_))\n            }\n\n        elif sequence_like(v):\n            seq_args = (\n                cls._get_value(\n                    v_,\n                    to_dict=to_dict,\n                    by_alias=by_alias,\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    include=value_include and value_include.for_element(i),\n                    exclude=value_exclude and value_exclude.for_element(i),\n                    exclude_none=exclude_none,\n                )\n                for i, v_ in enumerate(v)\n                if (not value_exclude or not value_exclude.is_excluded(i))\n                and (not value_include or value_include.is_included(i))\n            )\n\n            return v.__class__(*seq_args) if is_namedtuple(v.__class__) else v.__class__(seq_args)\n\n        elif isinstance(v, Enum) and getattr(cls.Config, 'use_enum_values', False):\n            return v.value\n\n        else:\n            return v\n\n    @classmethod\n    def __try_update_forward_refs__(cls, **localns: Any) -> None:\n        \"\"\"\n        Same as update_forward_refs but will not raise exception\n        when forward references are not defined.\n        \"\"\"\n        update_model_forward_refs(cls, cls.__fields__.values(), cls.__config__.json_encoders, localns, (NameError,))\n\n    @classmethod\n    def update_forward_refs(cls, **localns: Any) -> None:\n        \"\"\"\n        Try to update ForwardRefs on fields based on this Model, globalns and localns.\n        \"\"\"\n        update_model_forward_refs(cls, cls.__fields__.values(), cls.__config__.json_encoders, localns)\n\n    def __iter__(self) -> 'TupleGenerator':\n        \"\"\"\n        so `dict(model)` works\n        \"\"\"\n        yield from self.__dict__.items()\n\n    def _iter(\n        self,\n        to_dict: bool = False,\n        by_alias: bool = False,\n        include: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        exclude: Optional[Union['AbstractSetIntStr', 'MappingIntStrAny']] = None,\n        exclude_unset: bool = False,\n        exclude_defaults: bool = False,\n        exclude_none: bool = False,\n    ) -> 'TupleGenerator':\n        # Merge field set excludes with explicit exclude parameter with explicit overriding field set options.\n        # The extra \"is not None\" guards are not logically necessary but optimizes performance for the simple case.\n        if exclude is not None or self.__exclude_fields__ is not None:\n            exclude = ValueItems.merge(self.__exclude_fields__, exclude)\n\n        if include is not None or self.__include_fields__ is not None:\n            include = ValueItems.merge(self.__include_fields__, include, intersect=True)\n\n        allowed_keys = self._calculate_keys(\n            include=include, exclude=exclude, exclude_unset=exclude_unset  # type: ignore\n        )\n        if allowed_keys is None and not (to_dict or by_alias or exclude_unset or exclude_defaults or exclude_none):\n            # huge boost for plain _iter()\n            yield from self.__dict__.items()\n            return\n\n        value_exclude = ValueItems(self, exclude) if exclude is not None else None\n        value_include = ValueItems(self, include) if include is not None else None\n\n        for field_key, v in self.__dict__.items():\n            if (allowed_keys is not None and field_key not in allowed_keys) or (exclude_none and v is None):\n                continue\n\n            if exclude_defaults:\n                model_field = self.__fields__.get(field_key)\n                if not getattr(model_field, 'required', True) and getattr(model_field, 'default', _missing) == v:\n                    continue\n\n            if by_alias and field_key in self.__fields__:\n                dict_key = self.__fields__[field_key].alias\n            else:\n                dict_key = field_key\n\n            if to_dict or value_include or value_exclude:\n                v = self._get_value(\n                    v,\n                    to_dict=to_dict,\n                    by_alias=by_alias,\n                    include=value_include and value_include.for_element(field_key),\n                    exclude=value_exclude and value_exclude.for_element(field_key),\n                    exclude_unset=exclude_unset,\n                    exclude_defaults=exclude_defaults,\n                    exclude_none=exclude_none,\n                )\n            yield dict_key, v\n\n    def _calculate_keys(\n        self,\n        include: Optional['MappingIntStrAny'],\n        exclude: Optional['MappingIntStrAny'],\n        exclude_unset: bool,\n        update: Optional['DictStrAny'] = None,\n    ) -> Optional[AbstractSet[str]]:\n        if include is None and exclude is None and exclude_unset is False:\n            return None\n\n        keys: AbstractSet[str]\n        if exclude_unset:\n            keys = self.__fields_set__.copy()\n        else:\n            keys = self.__dict__.keys()\n\n        if include is not None:\n            keys &= include.keys()\n\n        if update:\n            keys -= update.keys()\n\n        if exclude:\n            keys -= {k for k, v in exclude.items() if ValueItems.is_true(v)}\n\n        return keys\n\n    def __eq__(self, other: Any) -> bool:\n        if isinstance(other, BaseModel):\n            return self.dict() == other.dict()\n        else:\n            return self.dict() == other\n\n    def __repr_args__(self) -> 'ReprArgs':\n        return [\n            (k, v)\n            for k, v in self.__dict__.items()\n            if k not in DUNDER_ATTRIBUTES and (k not in self.__fields__ or self.__fields__[k].field_info.repr)\n        ]\n\n\n_is_base_model_class_defined = True\n\n\n@overload\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: None = None,\n    __module__: str = __name__,\n    __validators__: Dict[str, 'AnyClassMethod'] = None,\n    __cls_kwargs__: Dict[str, Any] = None,\n    **field_definitions: Any,\n) -> Type['BaseModel']:\n    ...\n\n\n@overload\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: Union[Type['Model'], Tuple[Type['Model'], ...]],\n    __module__: str = __name__,\n    __validators__: Dict[str, 'AnyClassMethod'] = None,\n    __cls_kwargs__: Dict[str, Any] = None,\n    **field_definitions: Any,\n) -> Type['Model']:\n    ...\n\n\ndef create_model(\n    __model_name: str,\n    *,\n    __config__: Optional[Type[BaseConfig]] = None,\n    __base__: Union[None, Type['Model'], Tuple[Type['Model'], ...]] = None,\n    __module__: str = __name__,\n    __validators__: Dict[str, 'AnyClassMethod'] = None,\n    __cls_kwargs__: Dict[str, Any] = None,\n    __slots__: Optional[Tuple[str, ...]] = None,\n    **field_definitions: Any,\n) -> Type['Model']:\n    \"\"\"\n    Dynamically create a model.\n    :param __model_name: name of the created model\n    :param __config__: config class to use for the new model\n    :param __base__: base class for the new model to inherit from\n    :param __module__: module of the created model\n    :param __validators__: a dict of method names and @validator class methods\n    :param __cls_kwargs__: a dict for class creation\n    :param __slots__: Deprecated, `__slots__` should not be passed to `create_model`\n    :param field_definitions: fields of the model (or extra fields if a base is supplied)\n        in the format `<name>=(<type>, <default default>)` or `<name>=<default value>, e.g.\n        `foobar=(str, ...)` or `foobar=123`, or, for complex use-cases, in the format\n        `<name>=<Field>` or `<name>=(<type>, <FieldInfo>)`, e.g.\n        `foo=Field(datetime, default_factory=datetime.utcnow, alias='bar')` or\n        `foo=(str, FieldInfo(title='Foo'))`\n    \"\"\"\n    if __slots__ is not None:\n        # __slots__ will be ignored from here on\n        warnings.warn('__slots__ should not be passed to create_model', RuntimeWarning)\n\n    if __base__ is not None:\n        if __config__ is not None:\n            raise ConfigError('to avoid confusion __config__ and __base__ cannot be used together')\n        if not isinstance(__base__, tuple):\n            __base__ = (__base__,)\n    else:\n        __base__ = (cast(Type['Model'], BaseModel),)\n\n    __cls_kwargs__ = __cls_kwargs__ or {}\n\n    fields = {}\n    annotations = {}\n\n    for f_name, f_def in field_definitions.items():\n        if not is_valid_field(f_name):\n            warnings.warn(f'fields may not start with an underscore, ignoring \"{f_name}\"', RuntimeWarning)\n        if isinstance(f_def, tuple):\n            try:\n                f_annotation, f_value = f_def\n            except ValueError as e:\n                raise ConfigError(\n                    'field definitions should either be a tuple of (<type>, <default>) or just a '\n                    'default value, unfortunately this means tuples as '\n                    'default values are not allowed'\n                ) from e\n        else:\n            f_annotation, f_value = None, f_def\n\n        if f_annotation:\n            annotations[f_name] = f_annotation\n        fields[f_name] = f_value\n\n    namespace: 'DictStrAny' = {'__annotations__': annotations, '__module__': __module__}\n    if __validators__:\n        namespace.update(__validators__)\n    namespace.update(fields)\n    if __config__:\n        namespace['Config'] = inherit_config(__config__, BaseConfig)\n    resolved_bases = resolve_bases(__base__)\n    meta, ns, kwds = prepare_class(__model_name, resolved_bases, kwds=__cls_kwargs__)\n    if resolved_bases is not __base__:\n        ns['__orig_bases__'] = __base__\n    namespace.update(ns)\n    return meta(__model_name, resolved_bases, namespace, **kwds)\n\n\n_missing = object()\n\n\ndef validate_model(  # noqa: C901 (ignore complexity)\n    model: Type[BaseModel], input_data: 'DictStrAny', cls: 'ModelOrDc' = None\n) -> Tuple['DictStrAny', 'SetStr', Optional[ValidationError]]:\n    \"\"\"\n    validate data against a model.\n    \"\"\"\n    values = {}\n    errors = []\n    # input_data names, possibly alias\n    names_used = set()\n    # field names, never aliases\n    fields_set = set()\n    config = model.__config__\n    check_extra = config.extra is not Extra.ignore\n    cls_ = cls or model\n\n    for validator in model.__pre_root_validators__:\n        try:\n            input_data = validator(cls_, input_data)\n        except (ValueError, TypeError, AssertionError) as exc:\n            return {}, set(), ValidationError([ErrorWrapper(exc, loc=ROOT_KEY)], cls_)\n\n    for name, field in model.__fields__.items():\n        value = input_data.get(field.alias, _missing)\n        using_name = False\n        if value is _missing and config.allow_population_by_field_name and field.alt_alias:\n            value = input_data.get(field.name, _missing)\n            using_name = True\n\n        if value is _missing:\n            if field.required:\n                errors.append(ErrorWrapper(MissingError(), loc=field.alias))\n                continue\n\n            value = field.get_default()\n\n            if not config.validate_all and not field.validate_always:\n                values[name] = value\n                continue\n        else:\n            fields_set.add(name)\n            if check_extra:\n                names_used.add(field.name if using_name else field.alias)\n\n        v_, errors_ = field.validate(value, values, loc=field.alias, cls=cls_)\n        if isinstance(errors_, ErrorWrapper):\n            errors.append(errors_)\n        elif isinstance(errors_, list):\n            errors.extend(errors_)\n        else:\n            values[name] = v_\n\n    if check_extra:\n        if isinstance(input_data, GetterDict):\n            extra = input_data.extra_keys() - names_used\n        else:\n            extra = input_data.keys() - names_used\n        if extra:\n            fields_set |= extra\n            if config.extra is Extra.allow:\n                for f in extra:\n                    values[f] = input_data[f]\n            else:\n                for f in sorted(extra):\n                    errors.append(ErrorWrapper(ExtraError(), loc=f))\n\n    for skip_on_failure, validator in model.__post_root_validators__:\n        if skip_on_failure and errors:\n            continue\n        try:\n            values = validator(cls_, values)\n        except (ValueError, TypeError, AssertionError) as exc:\n            errors.append(ErrorWrapper(exc, loc=ROOT_KEY))\n\n    if errors:\n        return values, fields_set, ValidationError(errors, cls_)\n    else:\n        return values, fields_set, None\n", "pydantic/v1/class_validators.py": "import warnings\nfrom collections import ChainMap\nfrom functools import partial, partialmethod, wraps\nfrom itertools import chain\nfrom types import FunctionType\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, Iterable, List, Optional, Set, Tuple, Type, Union, overload\n\nfrom pydantic.v1.errors import ConfigError\nfrom pydantic.v1.typing import AnyCallable\nfrom pydantic.v1.utils import ROOT_KEY, in_ipython\n\nif TYPE_CHECKING:\n    from pydantic.v1.typing import AnyClassMethod\n\n\nclass Validator:\n    __slots__ = 'func', 'pre', 'each_item', 'always', 'check_fields', 'skip_on_failure'\n\n    def __init__(\n        self,\n        func: AnyCallable,\n        pre: bool = False,\n        each_item: bool = False,\n        always: bool = False,\n        check_fields: bool = False,\n        skip_on_failure: bool = False,\n    ):\n        self.func = func\n        self.pre = pre\n        self.each_item = each_item\n        self.always = always\n        self.check_fields = check_fields\n        self.skip_on_failure = skip_on_failure\n\n\nif TYPE_CHECKING:\n    from inspect import Signature\n\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.fields import ModelField\n    from pydantic.v1.types import ModelOrDc\n\n    ValidatorCallable = Callable[[Optional[ModelOrDc], Any, Dict[str, Any], ModelField, Type[BaseConfig]], Any]\n    ValidatorsList = List[ValidatorCallable]\n    ValidatorListDict = Dict[str, List[Validator]]\n\n_FUNCS: Set[str] = set()\nVALIDATOR_CONFIG_KEY = '__validator_config__'\nROOT_VALIDATOR_CONFIG_KEY = '__root_validator_config__'\n\n\ndef validator(\n    *fields: str,\n    pre: bool = False,\n    each_item: bool = False,\n    always: bool = False,\n    check_fields: bool = True,\n    whole: Optional[bool] = None,\n    allow_reuse: bool = False,\n) -> Callable[[AnyCallable], 'AnyClassMethod']:\n    \"\"\"\n    Decorate methods on the class indicating that they should be used to validate fields\n    :param fields: which field(s) the method should be called on\n    :param pre: whether or not this validator should be called before the standard validators (else after)\n    :param each_item: for complex objects (sets, lists etc.) whether to validate individual elements rather than the\n      whole object\n    :param always: whether this method and other validators should be called even if the value is missing\n    :param check_fields: whether to check that the fields actually exist on the model\n    :param allow_reuse: whether to track and raise an error if another validator refers to the decorated function\n    \"\"\"\n    if not fields:\n        raise ConfigError('validator with no fields specified')\n    elif isinstance(fields[0], FunctionType):\n        raise ConfigError(\n            \"validators should be used with fields and keyword arguments, not bare. \"  # noqa: Q000\n            \"E.g. usage should be `@validator('<field_name>', ...)`\"\n        )\n    elif not all(isinstance(field, str) for field in fields):\n        raise ConfigError(\n            \"validator fields should be passed as separate string args. \"  # noqa: Q000\n            \"E.g. usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\"\n        )\n\n    if whole is not None:\n        warnings.warn(\n            'The \"whole\" keyword argument is deprecated, use \"each_item\" (inverse meaning, default False) instead',\n            DeprecationWarning,\n        )\n        assert each_item is False, '\"each_item\" and \"whole\" conflict, remove \"whole\"'\n        each_item = not whole\n\n    def dec(f: AnyCallable) -> 'AnyClassMethod':\n        f_cls = _prepare_validator(f, allow_reuse)\n        setattr(\n            f_cls,\n            VALIDATOR_CONFIG_KEY,\n            (\n                fields,\n                Validator(func=f_cls.__func__, pre=pre, each_item=each_item, always=always, check_fields=check_fields),\n            ),\n        )\n        return f_cls\n\n    return dec\n\n\n@overload\ndef root_validator(_func: AnyCallable) -> 'AnyClassMethod':\n    ...\n\n\n@overload\ndef root_validator(\n    *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Callable[[AnyCallable], 'AnyClassMethod']:\n    ...\n\n\ndef root_validator(\n    _func: Optional[AnyCallable] = None, *, pre: bool = False, allow_reuse: bool = False, skip_on_failure: bool = False\n) -> Union['AnyClassMethod', Callable[[AnyCallable], 'AnyClassMethod']]:\n    \"\"\"\n    Decorate methods on a model indicating that they should be used to validate (and perhaps modify) data either\n    before or after standard model parsing/validation is performed.\n    \"\"\"\n    if _func:\n        f_cls = _prepare_validator(_func, allow_reuse)\n        setattr(\n            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_failure)\n        )\n        return f_cls\n\n    def dec(f: AnyCallable) -> 'AnyClassMethod':\n        f_cls = _prepare_validator(f, allow_reuse)\n        setattr(\n            f_cls, ROOT_VALIDATOR_CONFIG_KEY, Validator(func=f_cls.__func__, pre=pre, skip_on_failure=skip_on_failure)\n        )\n        return f_cls\n\n    return dec\n\n\ndef _prepare_validator(function: AnyCallable, allow_reuse: bool) -> 'AnyClassMethod':\n    \"\"\"\n    Avoid validators with duplicated names since without this, validators can be overwritten silently\n    which generally isn't the intended behaviour, don't run in ipython (see #312) or if allow_reuse is False.\n    \"\"\"\n    f_cls = function if isinstance(function, classmethod) else classmethod(function)\n    if not in_ipython() and not allow_reuse:\n        ref = (\n            getattr(f_cls.__func__, '__module__', '<No __module__>')\n            + '.'\n            + getattr(f_cls.__func__, '__qualname__', f'<No __qualname__: id:{id(f_cls.__func__)}>')\n        )\n        if ref in _FUNCS:\n            raise ConfigError(f'duplicate validator function \"{ref}\"; if this is intended, set `allow_reuse=True`')\n        _FUNCS.add(ref)\n    return f_cls\n\n\nclass ValidatorGroup:\n    def __init__(self, validators: 'ValidatorListDict') -> None:\n        self.validators = validators\n        self.used_validators = {'*'}\n\n    def get_validators(self, name: str) -> Optional[Dict[str, Validator]]:\n        self.used_validators.add(name)\n        validators = self.validators.get(name, [])\n        if name != ROOT_KEY:\n            validators += self.validators.get('*', [])\n        if validators:\n            return {getattr(v.func, '__name__', f'<No __name__: id:{id(v.func)}>'): v for v in validators}\n        else:\n            return None\n\n    def check_for_unused(self) -> None:\n        unused_validators = set(\n            chain.from_iterable(\n                (\n                    getattr(v.func, '__name__', f'<No __name__: id:{id(v.func)}>')\n                    for v in self.validators[f]\n                    if v.check_fields\n                )\n                for f in (self.validators.keys() - self.used_validators)\n            )\n        )\n        if unused_validators:\n            fn = ', '.join(unused_validators)\n            raise ConfigError(\n                f\"Validators defined with incorrect fields: {fn} \"  # noqa: Q000\n                f\"(use check_fields=False if you're inheriting from the model and intended this)\"\n            )\n\n\ndef extract_validators(namespace: Dict[str, Any]) -> Dict[str, List[Validator]]:\n    validators: Dict[str, List[Validator]] = {}\n    for var_name, value in namespace.items():\n        validator_config = getattr(value, VALIDATOR_CONFIG_KEY, None)\n        if validator_config:\n            fields, v = validator_config\n            for field in fields:\n                if field in validators:\n                    validators[field].append(v)\n                else:\n                    validators[field] = [v]\n    return validators\n\n\ndef extract_root_validators(namespace: Dict[str, Any]) -> Tuple[List[AnyCallable], List[Tuple[bool, AnyCallable]]]:\n    from inspect import signature\n\n    pre_validators: List[AnyCallable] = []\n    post_validators: List[Tuple[bool, AnyCallable]] = []\n    for name, value in namespace.items():\n        validator_config: Optional[Validator] = getattr(value, ROOT_VALIDATOR_CONFIG_KEY, None)\n        if validator_config:\n            sig = signature(validator_config.func)\n            args = list(sig.parameters.keys())\n            if args[0] == 'self':\n                raise ConfigError(\n                    f'Invalid signature for root validator {name}: {sig}, \"self\" not permitted as first argument, '\n                    f'should be: (cls, values).'\n                )\n            if len(args) != 2:\n                raise ConfigError(f'Invalid signature for root validator {name}: {sig}, should be: (cls, values).')\n            # check function signature\n            if validator_config.pre:\n                pre_validators.append(validator_config.func)\n            else:\n                post_validators.append((validator_config.skip_on_failure, validator_config.func))\n    return pre_validators, post_validators\n\n\ndef inherit_validators(base_validators: 'ValidatorListDict', validators: 'ValidatorListDict') -> 'ValidatorListDict':\n    for field, field_validators in base_validators.items():\n        if field not in validators:\n            validators[field] = []\n        validators[field] += field_validators\n    return validators\n\n\ndef make_generic_validator(validator: AnyCallable) -> 'ValidatorCallable':\n    \"\"\"\n    Make a generic function which calls a validator with the right arguments.\n\n    Unfortunately other approaches (eg. return a partial of a function that builds the arguments) is slow,\n    hence this laborious way of doing things.\n\n    It's done like this so validators don't all need **kwargs in their signature, eg. any combination of\n    the arguments \"values\", \"fields\" and/or \"config\" are permitted.\n    \"\"\"\n    from inspect import signature\n\n    if not isinstance(validator, (partial, partialmethod)):\n        # This should be the default case, so overhead is reduced\n        sig = signature(validator)\n        args = list(sig.parameters.keys())\n    else:\n        # Fix the generated argument lists of partial methods\n        sig = signature(validator.func)\n        args = [\n            k\n            for k in signature(validator.func).parameters.keys()\n            if k not in validator.args | validator.keywords.keys()\n        ]\n\n    first_arg = args.pop(0)\n    if first_arg == 'self':\n        raise ConfigError(\n            f'Invalid signature for validator {validator}: {sig}, \"self\" not permitted as first argument, '\n            f'should be: (cls, value, values, config, field), \"values\", \"config\" and \"field\" are all optional.'\n        )\n    elif first_arg == 'cls':\n        # assume the second argument is value\n        return wraps(validator)(_generic_validator_cls(validator, sig, set(args[1:])))\n    else:\n        # assume the first argument was value which has already been removed\n        return wraps(validator)(_generic_validator_basic(validator, sig, set(args)))\n\n\ndef prep_validators(v_funcs: Iterable[AnyCallable]) -> 'ValidatorsList':\n    return [make_generic_validator(f) for f in v_funcs if f]\n\n\nall_kwargs = {'values', 'field', 'config'}\n\n\ndef _generic_validator_cls(validator: AnyCallable, sig: 'Signature', args: Set[str]) -> 'ValidatorCallable':\n    # assume the first argument is value\n    has_kwargs = False\n    if 'kwargs' in args:\n        has_kwargs = True\n        args -= {'kwargs'}\n\n    if not args.issubset(all_kwargs):\n        raise ConfigError(\n            f'Invalid signature for validator {validator}: {sig}, should be: '\n            f'(cls, value, values, config, field), \"values\", \"config\" and \"field\" are all optional.'\n        )\n\n    if has_kwargs:\n        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field, config=config)\n    elif args == set():\n        return lambda cls, v, values, field, config: validator(cls, v)\n    elif args == {'values'}:\n        return lambda cls, v, values, field, config: validator(cls, v, values=values)\n    elif args == {'field'}:\n        return lambda cls, v, values, field, config: validator(cls, v, field=field)\n    elif args == {'config'}:\n        return lambda cls, v, values, field, config: validator(cls, v, config=config)\n    elif args == {'values', 'field'}:\n        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field)\n    elif args == {'values', 'config'}:\n        return lambda cls, v, values, field, config: validator(cls, v, values=values, config=config)\n    elif args == {'field', 'config'}:\n        return lambda cls, v, values, field, config: validator(cls, v, field=field, config=config)\n    else:\n        # args == {'values', 'field', 'config'}\n        return lambda cls, v, values, field, config: validator(cls, v, values=values, field=field, config=config)\n\n\ndef _generic_validator_basic(validator: AnyCallable, sig: 'Signature', args: Set[str]) -> 'ValidatorCallable':\n    has_kwargs = False\n    if 'kwargs' in args:\n        has_kwargs = True\n        args -= {'kwargs'}\n\n    if not args.issubset(all_kwargs):\n        raise ConfigError(\n            f'Invalid signature for validator {validator}: {sig}, should be: '\n            f'(value, values, config, field), \"values\", \"config\" and \"field\" are all optional.'\n        )\n\n    if has_kwargs:\n        return lambda cls, v, values, field, config: validator(v, values=values, field=field, config=config)\n    elif args == set():\n        return lambda cls, v, values, field, config: validator(v)\n    elif args == {'values'}:\n        return lambda cls, v, values, field, config: validator(v, values=values)\n    elif args == {'field'}:\n        return lambda cls, v, values, field, config: validator(v, field=field)\n    elif args == {'config'}:\n        return lambda cls, v, values, field, config: validator(v, config=config)\n    elif args == {'values', 'field'}:\n        return lambda cls, v, values, field, config: validator(v, values=values, field=field)\n    elif args == {'values', 'config'}:\n        return lambda cls, v, values, field, config: validator(v, values=values, config=config)\n    elif args == {'field', 'config'}:\n        return lambda cls, v, values, field, config: validator(v, field=field, config=config)\n    else:\n        # args == {'values', 'field', 'config'}\n        return lambda cls, v, values, field, config: validator(v, values=values, field=field, config=config)\n\n\ndef gather_all_validators(type_: 'ModelOrDc') -> Dict[str, 'AnyClassMethod']:\n    all_attributes = ChainMap(*[cls.__dict__ for cls in type_.__mro__])  # type: ignore[arg-type,var-annotated]\n    return {\n        k: v\n        for k, v in all_attributes.items()\n        if hasattr(v, VALIDATOR_CONFIG_KEY) or hasattr(v, ROOT_VALIDATOR_CONFIG_KEY)\n    }\n", "pydantic/v1/__init__.py": "# flake8: noqa\nfrom pydantic.v1 import dataclasses\nfrom pydantic.v1.annotated_types import create_model_from_namedtuple, create_model_from_typeddict\nfrom pydantic.v1.class_validators import root_validator, validator\nfrom pydantic.v1.config import BaseConfig, ConfigDict, Extra\nfrom pydantic.v1.decorator import validate_arguments\nfrom pydantic.v1.env_settings import BaseSettings\nfrom pydantic.v1.error_wrappers import ValidationError\nfrom pydantic.v1.errors import *\nfrom pydantic.v1.fields import Field, PrivateAttr, Required\nfrom pydantic.v1.main import *\nfrom pydantic.v1.networks import *\nfrom pydantic.v1.parse import Protocol\nfrom pydantic.v1.tools import *\nfrom pydantic.v1.types import *\nfrom pydantic.v1.version import VERSION, compiled\n\n__version__ = VERSION\n\n# WARNING __all__ from pydantic.errors is not included here, it will be removed as an export here in v2\n# please use \"from pydantic.v1.errors import ...\" instead\n__all__ = [\n    # annotated types utils\n    'create_model_from_namedtuple',\n    'create_model_from_typeddict',\n    # dataclasses\n    'dataclasses',\n    # class_validators\n    'root_validator',\n    'validator',\n    # config\n    'BaseConfig',\n    'ConfigDict',\n    'Extra',\n    # decorator\n    'validate_arguments',\n    # env_settings\n    'BaseSettings',\n    # error_wrappers\n    'ValidationError',\n    # fields\n    'Field',\n    'Required',\n    # main\n    'BaseModel',\n    'create_model',\n    'validate_model',\n    # network\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'HttpUrl',\n    'stricturl',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'validate_email',\n    # parse\n    'Protocol',\n    # tools\n    'parse_file_as',\n    'parse_obj_as',\n    'parse_raw_as',\n    'schema_of',\n    'schema_json_of',\n    # types\n    'NoneStr',\n    'NoneBytes',\n    'StrBytes',\n    'NoneStrBytes',\n    'StrictStr',\n    'ConstrainedBytes',\n    'conbytes',\n    'ConstrainedList',\n    'conlist',\n    'ConstrainedSet',\n    'conset',\n    'ConstrainedFrozenSet',\n    'confrozenset',\n    'ConstrainedStr',\n    'constr',\n    'PyObject',\n    'ConstrainedInt',\n    'conint',\n    'PositiveInt',\n    'NegativeInt',\n    'NonNegativeInt',\n    'NonPositiveInt',\n    'ConstrainedFloat',\n    'confloat',\n    'PositiveFloat',\n    'NegativeFloat',\n    'NonNegativeFloat',\n    'NonPositiveFloat',\n    'FiniteFloat',\n    'ConstrainedDecimal',\n    'condecimal',\n    'ConstrainedDate',\n    'condate',\n    'UUID1',\n    'UUID3',\n    'UUID4',\n    'UUID5',\n    'FilePath',\n    'DirectoryPath',\n    'Json',\n    'JsonWrapper',\n    'SecretField',\n    'SecretStr',\n    'SecretBytes',\n    'StrictBool',\n    'StrictBytes',\n    'StrictInt',\n    'StrictFloat',\n    'PaymentCardNumber',\n    'PrivateAttr',\n    'ByteSize',\n    'PastDate',\n    'FutureDate',\n    # version\n    'compiled',\n    'VERSION',\n]\n", "pydantic/v1/mypy.py": "import sys\nfrom configparser import ConfigParser\nfrom typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type as TypingType, Union\n\nfrom mypy.errorcodes import ErrorCode\nfrom mypy.nodes import (\n    ARG_NAMED,\n    ARG_NAMED_OPT,\n    ARG_OPT,\n    ARG_POS,\n    ARG_STAR2,\n    MDEF,\n    Argument,\n    AssignmentStmt,\n    Block,\n    CallExpr,\n    ClassDef,\n    Context,\n    Decorator,\n    EllipsisExpr,\n    FuncBase,\n    FuncDef,\n    JsonDict,\n    MemberExpr,\n    NameExpr,\n    PassStmt,\n    PlaceholderNode,\n    RefExpr,\n    StrExpr,\n    SymbolNode,\n    SymbolTableNode,\n    TempNode,\n    TypeInfo,\n    TypeVarExpr,\n    Var,\n)\nfrom mypy.options import Options\nfrom mypy.plugin import (\n    CheckerPluginInterface,\n    ClassDefContext,\n    FunctionContext,\n    MethodContext,\n    Plugin,\n    ReportConfigContext,\n    SemanticAnalyzerPluginInterface,\n)\nfrom mypy.plugins import dataclasses\nfrom mypy.semanal import set_callable_name  # type: ignore\nfrom mypy.server.trigger import make_wildcard_trigger\nfrom mypy.types import (\n    AnyType,\n    CallableType,\n    Instance,\n    NoneType,\n    Overloaded,\n    ProperType,\n    Type,\n    TypeOfAny,\n    TypeType,\n    TypeVarId,\n    TypeVarType,\n    UnionType,\n    get_proper_type,\n)\nfrom mypy.typevars import fill_typevars\nfrom mypy.util import get_unique_redefinition_name\nfrom mypy.version import __version__ as mypy_version\n\nfrom pydantic.v1.utils import is_valid_field\n\ntry:\n    from mypy.types import TypeVarDef  # type: ignore[attr-defined]\nexcept ImportError:  # pragma: no cover\n    # Backward-compatible with TypeVarDef from Mypy 0.910.\n    from mypy.types import TypeVarType as TypeVarDef\n\nCONFIGFILE_KEY = 'pydantic-mypy'\nMETADATA_KEY = 'pydantic-mypy-metadata'\n_NAMESPACE = __name__[:-5]  # 'pydantic' in 1.10.X, 'pydantic.v1' in v2.X\nBASEMODEL_FULLNAME = f'{_NAMESPACE}.main.BaseModel'\nBASESETTINGS_FULLNAME = f'{_NAMESPACE}.env_settings.BaseSettings'\nMODEL_METACLASS_FULLNAME = f'{_NAMESPACE}.main.ModelMetaclass'\nFIELD_FULLNAME = f'{_NAMESPACE}.fields.Field'\nDATACLASS_FULLNAME = f'{_NAMESPACE}.dataclasses.dataclass'\n\n\ndef parse_mypy_version(version: str) -> Tuple[int, ...]:\n    return tuple(map(int, version.partition('+')[0].split('.')))\n\n\nMYPY_VERSION_TUPLE = parse_mypy_version(mypy_version)\nBUILTINS_NAME = 'builtins' if MYPY_VERSION_TUPLE >= (0, 930) else '__builtins__'\n\n# Increment version if plugin changes and mypy caches should be invalidated\n__version__ = 2\n\n\ndef plugin(version: str) -> 'TypingType[Plugin]':\n    \"\"\"\n    `version` is the mypy version string\n\n    We might want to use this to print a warning if the mypy version being used is\n    newer, or especially older, than we expect (or need).\n    \"\"\"\n    return PydanticPlugin\n\n\nclass PydanticPlugin(Plugin):\n    def __init__(self, options: Options) -> None:\n        self.plugin_config = PydanticPluginConfig(options)\n        self._plugin_data = self.plugin_config.to_data()\n        super().__init__(options)\n\n    def get_base_class_hook(self, fullname: str) -> 'Optional[Callable[[ClassDefContext], None]]':\n        sym = self.lookup_fully_qualified(fullname)\n        if sym and isinstance(sym.node, TypeInfo):  # pragma: no branch\n            # No branching may occur if the mypy cache has not been cleared\n            if any(get_fullname(base) == BASEMODEL_FULLNAME for base in sym.node.mro):\n                return self._pydantic_model_class_maker_callback\n        return None\n\n    def get_metaclass_hook(self, fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n        if fullname == MODEL_METACLASS_FULLNAME:\n            return self._pydantic_model_metaclass_marker_callback\n        return None\n\n    def get_function_hook(self, fullname: str) -> 'Optional[Callable[[FunctionContext], Type]]':\n        sym = self.lookup_fully_qualified(fullname)\n        if sym and sym.fullname == FIELD_FULLNAME:\n            return self._pydantic_field_callback\n        return None\n\n    def get_method_hook(self, fullname: str) -> Optional[Callable[[MethodContext], Type]]:\n        if fullname.endswith('.from_orm'):\n            return from_orm_callback\n        return None\n\n    def get_class_decorator_hook(self, fullname: str) -> Optional[Callable[[ClassDefContext], None]]:\n        \"\"\"Mark pydantic.dataclasses as dataclass.\n\n        Mypy version 1.1.1 added support for `@dataclass_transform` decorator.\n        \"\"\"\n        if fullname == DATACLASS_FULLNAME and MYPY_VERSION_TUPLE < (1, 1):\n            return dataclasses.dataclass_class_maker_callback  # type: ignore[return-value]\n        return None\n\n    def report_config_data(self, ctx: ReportConfigContext) -> Dict[str, Any]:\n        \"\"\"Return all plugin config data.\n\n        Used by mypy to determine if cache needs to be discarded.\n        \"\"\"\n        return self._plugin_data\n\n    def _pydantic_model_class_maker_callback(self, ctx: ClassDefContext) -> None:\n        transformer = PydanticModelTransformer(ctx, self.plugin_config)\n        transformer.transform()\n\n    def _pydantic_model_metaclass_marker_callback(self, ctx: ClassDefContext) -> None:\n        \"\"\"Reset dataclass_transform_spec attribute of ModelMetaclass.\n\n        Let the plugin handle it. This behavior can be disabled\n        if 'debug_dataclass_transform' is set to True', for testing purposes.\n        \"\"\"\n        if self.plugin_config.debug_dataclass_transform:\n            return\n        info_metaclass = ctx.cls.info.declared_metaclass\n        assert info_metaclass, \"callback not passed from 'get_metaclass_hook'\"\n        if getattr(info_metaclass.type, 'dataclass_transform_spec', None):\n            info_metaclass.type.dataclass_transform_spec = None  # type: ignore[attr-defined]\n\n    def _pydantic_field_callback(self, ctx: FunctionContext) -> 'Type':\n        \"\"\"\n        Extract the type of the `default` argument from the Field function, and use it as the return type.\n\n        In particular:\n        * Check whether the default and default_factory argument is specified.\n        * Output an error if both are specified.\n        * Retrieve the type of the argument which is specified, and use it as return type for the function.\n        \"\"\"\n        default_any_type = ctx.default_return_type\n\n        assert ctx.callee_arg_names[0] == 'default', '\"default\" is no longer first argument in Field()'\n        assert ctx.callee_arg_names[1] == 'default_factory', '\"default_factory\" is no longer second argument in Field()'\n        default_args = ctx.args[0]\n        default_factory_args = ctx.args[1]\n\n        if default_args and default_factory_args:\n            error_default_and_default_factory_specified(ctx.api, ctx.context)\n            return default_any_type\n\n        if default_args:\n            default_type = ctx.arg_types[0][0]\n            default_arg = default_args[0]\n\n            # Fallback to default Any type if the field is required\n            if not isinstance(default_arg, EllipsisExpr):\n                return default_type\n\n        elif default_factory_args:\n            default_factory_type = ctx.arg_types[1][0]\n\n            # Functions which use `ParamSpec` can be overloaded, exposing the callable's types as a parameter\n            # Pydantic calls the default factory without any argument, so we retrieve the first item\n            if isinstance(default_factory_type, Overloaded):\n                if MYPY_VERSION_TUPLE > (0, 910):\n                    default_factory_type = default_factory_type.items[0]\n                else:\n                    # Mypy0.910 exposes the items of overloaded types in a function\n                    default_factory_type = default_factory_type.items()[0]  # type: ignore[operator]\n\n            if isinstance(default_factory_type, CallableType):\n                ret_type = default_factory_type.ret_type\n                # mypy doesn't think `ret_type` has `args`, you'd think mypy should know,\n                # add this check in case it varies by version\n                args = getattr(ret_type, 'args', None)\n                if args:\n                    if all(isinstance(arg, TypeVarType) for arg in args):\n                        # Looks like the default factory is a type like `list` or `dict`, replace all args with `Any`\n                        ret_type.args = tuple(default_any_type for _ in args)  # type: ignore[attr-defined]\n                return ret_type\n\n        return default_any_type\n\n\nclass PydanticPluginConfig:\n    __slots__ = (\n        'init_forbid_extra',\n        'init_typed',\n        'warn_required_dynamic_aliases',\n        'warn_untyped_fields',\n        'debug_dataclass_transform',\n    )\n    init_forbid_extra: bool\n    init_typed: bool\n    warn_required_dynamic_aliases: bool\n    warn_untyped_fields: bool\n    debug_dataclass_transform: bool  # undocumented\n\n    def __init__(self, options: Options) -> None:\n        if options.config_file is None:  # pragma: no cover\n            return\n\n        toml_config = parse_toml(options.config_file)\n        if toml_config is not None:\n            config = toml_config.get('tool', {}).get('pydantic-mypy', {})\n            for key in self.__slots__:\n                setting = config.get(key, False)\n                if not isinstance(setting, bool):\n                    raise ValueError(f'Configuration value must be a boolean for key: {key}')\n                setattr(self, key, setting)\n        else:\n            plugin_config = ConfigParser()\n            plugin_config.read(options.config_file)\n            for key in self.__slots__:\n                setting = plugin_config.getboolean(CONFIGFILE_KEY, key, fallback=False)\n                setattr(self, key, setting)\n\n    def to_data(self) -> Dict[str, Any]:\n        return {key: getattr(self, key) for key in self.__slots__}\n\n\ndef from_orm_callback(ctx: MethodContext) -> Type:\n    \"\"\"\n    Raise an error if orm_mode is not enabled\n    \"\"\"\n    model_type: Instance\n    ctx_type = ctx.type\n    if isinstance(ctx_type, TypeType):\n        ctx_type = ctx_type.item\n    if isinstance(ctx_type, CallableType) and isinstance(ctx_type.ret_type, Instance):\n        model_type = ctx_type.ret_type  # called on the class\n    elif isinstance(ctx_type, Instance):\n        model_type = ctx_type  # called on an instance (unusual, but still valid)\n    else:  # pragma: no cover\n        detail = f'ctx.type: {ctx_type} (of type {ctx_type.__class__.__name__})'\n        error_unexpected_behavior(detail, ctx.api, ctx.context)\n        return ctx.default_return_type\n    pydantic_metadata = model_type.type.metadata.get(METADATA_KEY)\n    if pydantic_metadata is None:\n        return ctx.default_return_type\n    orm_mode = pydantic_metadata.get('config', {}).get('orm_mode')\n    if orm_mode is not True:\n        error_from_orm(get_name(model_type.type), ctx.api, ctx.context)\n    return ctx.default_return_type\n\n\nclass PydanticModelTransformer:\n    tracked_config_fields: Set[str] = {\n        'extra',\n        'allow_mutation',\n        'frozen',\n        'orm_mode',\n        'allow_population_by_field_name',\n        'alias_generator',\n    }\n\n    def __init__(self, ctx: ClassDefContext, plugin_config: PydanticPluginConfig) -> None:\n        self._ctx = ctx\n        self.plugin_config = plugin_config\n\n    def transform(self) -> None:\n        \"\"\"\n        Configures the BaseModel subclass according to the plugin settings.\n\n        In particular:\n        * determines the model config and fields,\n        * adds a fields-aware signature for the initializer and construct methods\n        * freezes the class if allow_mutation = False or frozen = True\n        * stores the fields, config, and if the class is settings in the mypy metadata for access by subclasses\n        \"\"\"\n        ctx = self._ctx\n        info = ctx.cls.info\n\n        self.adjust_validator_signatures()\n        config = self.collect_config()\n        fields = self.collect_fields(config)\n        is_settings = any(get_fullname(base) == BASESETTINGS_FULLNAME for base in info.mro[:-1])\n        self.add_initializer(fields, config, is_settings)\n        self.add_construct_method(fields)\n        self.set_frozen(fields, frozen=config.allow_mutation is False or config.frozen is True)\n        info.metadata[METADATA_KEY] = {\n            'fields': {field.name: field.serialize() for field in fields},\n            'config': config.set_values_dict(),\n        }\n\n    def adjust_validator_signatures(self) -> None:\n        \"\"\"When we decorate a function `f` with `pydantic.validator(...), mypy sees\n        `f` as a regular method taking a `self` instance, even though pydantic\n        internally wraps `f` with `classmethod` if necessary.\n\n        Teach mypy this by marking any function whose outermost decorator is a\n        `validator()` call as a classmethod.\n        \"\"\"\n        for name, sym in self._ctx.cls.info.names.items():\n            if isinstance(sym.node, Decorator):\n                first_dec = sym.node.original_decorators[0]\n                if (\n                    isinstance(first_dec, CallExpr)\n                    and isinstance(first_dec.callee, NameExpr)\n                    and first_dec.callee.fullname == f'{_NAMESPACE}.class_validators.validator'\n                ):\n                    sym.node.func.is_class = True\n\n    def collect_config(self) -> 'ModelConfigData':\n        \"\"\"\n        Collects the values of the config attributes that are used by the plugin, accounting for parent classes.\n        \"\"\"\n        ctx = self._ctx\n        cls = ctx.cls\n        config = ModelConfigData()\n        for stmt in cls.defs.body:\n            if not isinstance(stmt, ClassDef):\n                continue\n            if stmt.name == 'Config':\n                for substmt in stmt.defs.body:\n                    if not isinstance(substmt, AssignmentStmt):\n                        continue\n                    config.update(self.get_config_update(substmt))\n                if (\n                    config.has_alias_generator\n                    and not config.allow_population_by_field_name\n                    and self.plugin_config.warn_required_dynamic_aliases\n                ):\n                    error_required_dynamic_aliases(ctx.api, stmt)\n        for info in cls.info.mro[1:]:  # 0 is the current class\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            # Each class depends on the set of fields in its ancestors\n            ctx.api.add_plugin_dependency(make_wildcard_trigger(get_fullname(info)))\n            for name, value in info.metadata[METADATA_KEY]['config'].items():\n                config.setdefault(name, value)\n        return config\n\n    def collect_fields(self, model_config: 'ModelConfigData') -> List['PydanticModelField']:\n        \"\"\"\n        Collects the fields for the model, accounting for parent classes\n        \"\"\"\n        # First, collect fields belonging to the current class.\n        ctx = self._ctx\n        cls = self._ctx.cls\n        fields = []  # type: List[PydanticModelField]\n        known_fields = set()  # type: Set[str]\n        for stmt in cls.defs.body:\n            if not isinstance(stmt, AssignmentStmt):  # `and stmt.new_syntax` to require annotation\n                continue\n\n            lhs = stmt.lvalues[0]\n            if not isinstance(lhs, NameExpr) or not is_valid_field(lhs.name):\n                continue\n\n            if not stmt.new_syntax and self.plugin_config.warn_untyped_fields:\n                error_untyped_fields(ctx.api, stmt)\n\n            # if lhs.name == '__config__':  # BaseConfig not well handled; I'm not sure why yet\n            #     continue\n\n            sym = cls.info.names.get(lhs.name)\n            if sym is None:  # pragma: no cover\n                # This is likely due to a star import (see the dataclasses plugin for a more detailed explanation)\n                # This is the same logic used in the dataclasses plugin\n                continue\n\n            node = sym.node\n            if isinstance(node, PlaceholderNode):  # pragma: no cover\n                # See the PlaceholderNode docstring for more detail about how this can occur\n                # Basically, it is an edge case when dealing with complex import logic\n                # This is the same logic used in the dataclasses plugin\n                continue\n            if not isinstance(node, Var):  # pragma: no cover\n                # Don't know if this edge case still happens with the `is_valid_field` check above\n                # but better safe than sorry\n                continue\n\n            # x: ClassVar[int] is ignored by dataclasses.\n            if node.is_classvar:\n                continue\n\n            is_required = self.get_is_required(cls, stmt, lhs)\n            alias, has_dynamic_alias = self.get_alias_info(stmt)\n            if (\n                has_dynamic_alias\n                and not model_config.allow_population_by_field_name\n                and self.plugin_config.warn_required_dynamic_aliases\n            ):\n                error_required_dynamic_aliases(ctx.api, stmt)\n            fields.append(\n                PydanticModelField(\n                    name=lhs.name,\n                    is_required=is_required,\n                    alias=alias,\n                    has_dynamic_alias=has_dynamic_alias,\n                    line=stmt.line,\n                    column=stmt.column,\n                )\n            )\n            known_fields.add(lhs.name)\n        all_fields = fields.copy()\n        for info in cls.info.mro[1:]:  # 0 is the current class, -2 is BaseModel, -1 is object\n            if METADATA_KEY not in info.metadata:\n                continue\n\n            superclass_fields = []\n            # Each class depends on the set of fields in its ancestors\n            ctx.api.add_plugin_dependency(make_wildcard_trigger(get_fullname(info)))\n\n            for name, data in info.metadata[METADATA_KEY]['fields'].items():\n                if name not in known_fields:\n                    field = PydanticModelField.deserialize(info, data)\n                    known_fields.add(name)\n                    superclass_fields.append(field)\n                else:\n                    (field,) = (a for a in all_fields if a.name == name)\n                    all_fields.remove(field)\n                    superclass_fields.append(field)\n            all_fields = superclass_fields + all_fields\n        return all_fields\n\n    def add_initializer(self, fields: List['PydanticModelField'], config: 'ModelConfigData', is_settings: bool) -> None:\n        \"\"\"\n        Adds a fields-aware `__init__` method to the class.\n\n        The added `__init__` will be annotated with types vs. all `Any` depending on the plugin settings.\n        \"\"\"\n        ctx = self._ctx\n        typed = self.plugin_config.init_typed\n        use_alias = config.allow_population_by_field_name is not True\n        force_all_optional = is_settings or bool(\n            config.has_alias_generator and not config.allow_population_by_field_name\n        )\n        init_arguments = self.get_field_arguments(\n            fields, typed=typed, force_all_optional=force_all_optional, use_alias=use_alias\n        )\n        if not self.should_init_forbid_extra(fields, config):\n            var = Var('kwargs')\n            init_arguments.append(Argument(var, AnyType(TypeOfAny.explicit), None, ARG_STAR2))\n\n        if '__init__' not in ctx.cls.info.names:\n            add_method(ctx, '__init__', init_arguments, NoneType())\n\n    def add_construct_method(self, fields: List['PydanticModelField']) -> None:\n        \"\"\"\n        Adds a fully typed `construct` classmethod to the class.\n\n        Similar to the fields-aware __init__ method, but always uses the field names (not aliases),\n        and does not treat settings fields as optional.\n        \"\"\"\n        ctx = self._ctx\n        set_str = ctx.api.named_type(f'{BUILTINS_NAME}.set', [ctx.api.named_type(f'{BUILTINS_NAME}.str')])\n        optional_set_str = UnionType([set_str, NoneType()])\n        fields_set_argument = Argument(Var('_fields_set', optional_set_str), optional_set_str, None, ARG_OPT)\n        construct_arguments = self.get_field_arguments(fields, typed=True, force_all_optional=False, use_alias=False)\n        construct_arguments = [fields_set_argument] + construct_arguments\n\n        obj_type = ctx.api.named_type(f'{BUILTINS_NAME}.object')\n        self_tvar_name = '_PydanticBaseModel'  # Make sure it does not conflict with other names in the class\n        tvar_fullname = ctx.cls.fullname + '.' + self_tvar_name\n        if MYPY_VERSION_TUPLE >= (1, 4):\n            tvd = TypeVarType(\n                self_tvar_name,\n                tvar_fullname,\n                TypeVarId(-1),\n                [],\n                obj_type,\n                AnyType(TypeOfAny.from_omitted_generics),  # type: ignore[arg-type]\n            )\n            self_tvar_expr = TypeVarExpr(\n                self_tvar_name,\n                tvar_fullname,\n                [],\n                obj_type,\n                AnyType(TypeOfAny.from_omitted_generics),  # type: ignore[arg-type]\n            )\n        else:\n            tvd = TypeVarDef(self_tvar_name, tvar_fullname, -1, [], obj_type)\n            self_tvar_expr = TypeVarExpr(self_tvar_name, tvar_fullname, [], obj_type)\n        ctx.cls.info.names[self_tvar_name] = SymbolTableNode(MDEF, self_tvar_expr)\n\n        # Backward-compatible with TypeVarDef from Mypy 0.910.\n        if isinstance(tvd, TypeVarType):\n            self_type = tvd\n        else:\n            self_type = TypeVarType(tvd)\n\n        add_method(\n            ctx,\n            'construct',\n            construct_arguments,\n            return_type=self_type,\n            self_type=self_type,\n            tvar_def=tvd,\n            is_classmethod=True,\n        )\n\n    def set_frozen(self, fields: List['PydanticModelField'], frozen: bool) -> None:\n        \"\"\"\n        Marks all fields as properties so that attempts to set them trigger mypy errors.\n\n        This is the same approach used by the attrs and dataclasses plugins.\n        \"\"\"\n        ctx = self._ctx\n        info = ctx.cls.info\n        for field in fields:\n            sym_node = info.names.get(field.name)\n            if sym_node is not None:\n                var = sym_node.node\n                if isinstance(var, Var):\n                    var.is_property = frozen\n                elif isinstance(var, PlaceholderNode) and not ctx.api.final_iteration:\n                    # See https://github.com/pydantic/pydantic/issues/5191 to hit this branch for test coverage\n                    ctx.api.defer()\n                else:  # pragma: no cover\n                    # I don't know whether it's possible to hit this branch, but I've added it for safety\n                    try:\n                        var_str = str(var)\n                    except TypeError:\n                        # This happens for PlaceholderNode; perhaps it will happen for other types in the future..\n                        var_str = repr(var)\n                    detail = f'sym_node.node: {var_str} (of type {var.__class__})'\n                    error_unexpected_behavior(detail, ctx.api, ctx.cls)\n            else:\n                var = field.to_var(info, use_alias=False)\n                var.info = info\n                var.is_property = frozen\n                var._fullname = get_fullname(info) + '.' + get_name(var)\n                info.names[get_name(var)] = SymbolTableNode(MDEF, var)\n\n    def get_config_update(self, substmt: AssignmentStmt) -> Optional['ModelConfigData']:\n        \"\"\"\n        Determines the config update due to a single statement in the Config class definition.\n\n        Warns if a tracked config attribute is set to a value the plugin doesn't know how to interpret (e.g., an int)\n        \"\"\"\n        lhs = substmt.lvalues[0]\n        if not (isinstance(lhs, NameExpr) and lhs.name in self.tracked_config_fields):\n            return None\n        if lhs.name == 'extra':\n            if isinstance(substmt.rvalue, StrExpr):\n                forbid_extra = substmt.rvalue.value == 'forbid'\n            elif isinstance(substmt.rvalue, MemberExpr):\n                forbid_extra = substmt.rvalue.name == 'forbid'\n            else:\n                error_invalid_config_value(lhs.name, self._ctx.api, substmt)\n                return None\n            return ModelConfigData(forbid_extra=forbid_extra)\n        if lhs.name == 'alias_generator':\n            has_alias_generator = True\n            if isinstance(substmt.rvalue, NameExpr) and substmt.rvalue.fullname == 'builtins.None':\n                has_alias_generator = False\n            return ModelConfigData(has_alias_generator=has_alias_generator)\n        if isinstance(substmt.rvalue, NameExpr) and substmt.rvalue.fullname in ('builtins.True', 'builtins.False'):\n            return ModelConfigData(**{lhs.name: substmt.rvalue.fullname == 'builtins.True'})\n        error_invalid_config_value(lhs.name, self._ctx.api, substmt)\n        return None\n\n    @staticmethod\n    def get_is_required(cls: ClassDef, stmt: AssignmentStmt, lhs: NameExpr) -> bool:\n        \"\"\"\n        Returns a boolean indicating whether the field defined in `stmt` is a required field.\n        \"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only, so only non-required if Optional\n            value_type = get_proper_type(cls.info[lhs.name].type)\n            return not PydanticModelTransformer.type_has_implicit_default(value_type)\n        if isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME:\n            # The \"default value\" is a call to `Field`; at this point, the field is\n            # only required if default is Ellipsis (i.e., `field_name: Annotation = Field(...)`) or if default_factory\n            # is specified.\n            for arg, name in zip(expr.args, expr.arg_names):\n                # If name is None, then this arg is the default because it is the only positional argument.\n                if name is None or name == 'default':\n                    return arg.__class__ is EllipsisExpr\n                if name == 'default_factory':\n                    return False\n            # In this case, default and default_factory are not specified, so we need to look at the annotation\n            value_type = get_proper_type(cls.info[lhs.name].type)\n            return not PydanticModelTransformer.type_has_implicit_default(value_type)\n        # Only required if the \"default value\" is Ellipsis (i.e., `field_name: Annotation = ...`)\n        return isinstance(expr, EllipsisExpr)\n\n    @staticmethod\n    def type_has_implicit_default(type_: Optional[ProperType]) -> bool:\n        \"\"\"\n        Returns True if the passed type will be given an implicit default value.\n\n        In pydantic v1, this is the case for Optional types and Any (with default value None).\n        \"\"\"\n        if isinstance(type_, AnyType):\n            # Annotated as Any\n            return True\n        if isinstance(type_, UnionType) and any(\n            isinstance(item, NoneType) or isinstance(item, AnyType) for item in type_.items\n        ):\n            # Annotated as Optional, or otherwise having NoneType or AnyType in the union\n            return True\n        return False\n\n    @staticmethod\n    def get_alias_info(stmt: AssignmentStmt) -> Tuple[Optional[str], bool]:\n        \"\"\"\n        Returns a pair (alias, has_dynamic_alias), extracted from the declaration of the field defined in `stmt`.\n\n        `has_dynamic_alias` is True if and only if an alias is provided, but not as a string literal.\n        If `has_dynamic_alias` is True, `alias` will be None.\n        \"\"\"\n        expr = stmt.rvalue\n        if isinstance(expr, TempNode):\n            # TempNode means annotation-only\n            return None, False\n\n        if not (\n            isinstance(expr, CallExpr) and isinstance(expr.callee, RefExpr) and expr.callee.fullname == FIELD_FULLNAME\n        ):\n            # Assigned value is not a call to pydantic.fields.Field\n            return None, False\n\n        for i, arg_name in enumerate(expr.arg_names):\n            if arg_name != 'alias':\n                continue\n            arg = expr.args[i]\n            if isinstance(arg, StrExpr):\n                return arg.value, False\n            else:\n                return None, True\n        return None, False\n\n    def get_field_arguments(\n        self, fields: List['PydanticModelField'], typed: bool, force_all_optional: bool, use_alias: bool\n    ) -> List[Argument]:\n        \"\"\"\n        Helper function used during the construction of the `__init__` and `construct` method signatures.\n\n        Returns a list of mypy Argument instances for use in the generated signatures.\n        \"\"\"\n        info = self._ctx.cls.info\n        arguments = [\n            field.to_argument(info, typed=typed, force_optional=force_all_optional, use_alias=use_alias)\n            for field in fields\n            if not (use_alias and field.has_dynamic_alias)\n        ]\n        return arguments\n\n    def should_init_forbid_extra(self, fields: List['PydanticModelField'], config: 'ModelConfigData') -> bool:\n        \"\"\"\n        Indicates whether the generated `__init__` should get a `**kwargs` at the end of its signature\n\n        We disallow arbitrary kwargs if the extra config setting is \"forbid\", or if the plugin config says to,\n        *unless* a required dynamic alias is present (since then we can't determine a valid signature).\n        \"\"\"\n        if not config.allow_population_by_field_name:\n            if self.is_dynamic_alias_present(fields, bool(config.has_alias_generator)):\n                return False\n        if config.forbid_extra:\n            return True\n        return self.plugin_config.init_forbid_extra\n\n    @staticmethod\n    def is_dynamic_alias_present(fields: List['PydanticModelField'], has_alias_generator: bool) -> bool:\n        \"\"\"\n        Returns whether any fields on the model have a \"dynamic alias\", i.e., an alias that cannot be\n        determined during static analysis.\n        \"\"\"\n        for field in fields:\n            if field.has_dynamic_alias:\n                return True\n        if has_alias_generator:\n            for field in fields:\n                if field.alias is None:\n                    return True\n        return False\n\n\nclass PydanticModelField:\n    def __init__(\n        self, name: str, is_required: bool, alias: Optional[str], has_dynamic_alias: bool, line: int, column: int\n    ):\n        self.name = name\n        self.is_required = is_required\n        self.alias = alias\n        self.has_dynamic_alias = has_dynamic_alias\n        self.line = line\n        self.column = column\n\n    def to_var(self, info: TypeInfo, use_alias: bool) -> Var:\n        name = self.name\n        if use_alias and self.alias is not None:\n            name = self.alias\n        return Var(name, info[self.name].type)\n\n    def to_argument(self, info: TypeInfo, typed: bool, force_optional: bool, use_alias: bool) -> Argument:\n        if typed and info[self.name].type is not None:\n            type_annotation = info[self.name].type\n        else:\n            type_annotation = AnyType(TypeOfAny.explicit)\n        return Argument(\n            variable=self.to_var(info, use_alias),\n            type_annotation=type_annotation,\n            initializer=None,\n            kind=ARG_NAMED_OPT if force_optional or not self.is_required else ARG_NAMED,\n        )\n\n    def serialize(self) -> JsonDict:\n        return self.__dict__\n\n    @classmethod\n    def deserialize(cls, info: TypeInfo, data: JsonDict) -> 'PydanticModelField':\n        return cls(**data)\n\n\nclass ModelConfigData:\n    def __init__(\n        self,\n        forbid_extra: Optional[bool] = None,\n        allow_mutation: Optional[bool] = None,\n        frozen: Optional[bool] = None,\n        orm_mode: Optional[bool] = None,\n        allow_population_by_field_name: Optional[bool] = None,\n        has_alias_generator: Optional[bool] = None,\n    ):\n        self.forbid_extra = forbid_extra\n        self.allow_mutation = allow_mutation\n        self.frozen = frozen\n        self.orm_mode = orm_mode\n        self.allow_population_by_field_name = allow_population_by_field_name\n        self.has_alias_generator = has_alias_generator\n\n    def set_values_dict(self) -> Dict[str, Any]:\n        return {k: v for k, v in self.__dict__.items() if v is not None}\n\n    def update(self, config: Optional['ModelConfigData']) -> None:\n        if config is None:\n            return\n        for k, v in config.set_values_dict().items():\n            setattr(self, k, v)\n\n    def setdefault(self, key: str, value: Any) -> None:\n        if getattr(self, key) is None:\n            setattr(self, key, value)\n\n\nERROR_ORM = ErrorCode('pydantic-orm', 'Invalid from_orm call', 'Pydantic')\nERROR_CONFIG = ErrorCode('pydantic-config', 'Invalid config value', 'Pydantic')\nERROR_ALIAS = ErrorCode('pydantic-alias', 'Dynamic alias disallowed', 'Pydantic')\nERROR_UNEXPECTED = ErrorCode('pydantic-unexpected', 'Unexpected behavior', 'Pydantic')\nERROR_UNTYPED = ErrorCode('pydantic-field', 'Untyped field disallowed', 'Pydantic')\nERROR_FIELD_DEFAULTS = ErrorCode('pydantic-field', 'Invalid Field defaults', 'Pydantic')\n\n\ndef error_from_orm(model_name: str, api: CheckerPluginInterface, context: Context) -> None:\n    api.fail(f'\"{model_name}\" does not have orm_mode=True', context, code=ERROR_ORM)\n\n\ndef error_invalid_config_value(name: str, api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    api.fail(f'Invalid value for \"Config.{name}\"', context, code=ERROR_CONFIG)\n\n\ndef error_required_dynamic_aliases(api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    api.fail('Required dynamic aliases disallowed', context, code=ERROR_ALIAS)\n\n\ndef error_unexpected_behavior(\n    detail: str, api: Union[CheckerPluginInterface, SemanticAnalyzerPluginInterface], context: Context\n) -> None:  # pragma: no cover\n    # Can't think of a good way to test this, but I confirmed it renders as desired by adding to a non-error path\n    link = 'https://github.com/pydantic/pydantic/issues/new/choose'\n    full_message = f'The pydantic mypy plugin ran into unexpected behavior: {detail}\\n'\n    full_message += f'Please consider reporting this bug at {link} so we can try to fix it!'\n    api.fail(full_message, context, code=ERROR_UNEXPECTED)\n\n\ndef error_untyped_fields(api: SemanticAnalyzerPluginInterface, context: Context) -> None:\n    api.fail('Untyped fields disallowed', context, code=ERROR_UNTYPED)\n\n\ndef error_default_and_default_factory_specified(api: CheckerPluginInterface, context: Context) -> None:\n    api.fail('Field default and default_factory cannot be specified together', context, code=ERROR_FIELD_DEFAULTS)\n\n\ndef add_method(\n    ctx: ClassDefContext,\n    name: str,\n    args: List[Argument],\n    return_type: Type,\n    self_type: Optional[Type] = None,\n    tvar_def: Optional[TypeVarDef] = None,\n    is_classmethod: bool = False,\n    is_new: bool = False,\n    # is_staticmethod: bool = False,\n) -> None:\n    \"\"\"\n    Adds a new method to a class.\n\n    This can be dropped if/when https://github.com/python/mypy/issues/7301 is merged\n    \"\"\"\n    info = ctx.cls.info\n\n    # First remove any previously generated methods with the same name\n    # to avoid clashes and problems in the semantic analyzer.\n    if name in info.names:\n        sym = info.names[name]\n        if sym.plugin_generated and isinstance(sym.node, FuncDef):\n            ctx.cls.defs.body.remove(sym.node)  # pragma: no cover\n\n    self_type = self_type or fill_typevars(info)\n    if is_classmethod or is_new:\n        first = [Argument(Var('_cls'), TypeType.make_normalized(self_type), None, ARG_POS)]\n    # elif is_staticmethod:\n    #     first = []\n    else:\n        self_type = self_type or fill_typevars(info)\n        first = [Argument(Var('__pydantic_self__'), self_type, None, ARG_POS)]\n    args = first + args\n    arg_types, arg_names, arg_kinds = [], [], []\n    for arg in args:\n        assert arg.type_annotation, 'All arguments must be fully typed.'\n        arg_types.append(arg.type_annotation)\n        arg_names.append(get_name(arg.variable))\n        arg_kinds.append(arg.kind)\n\n    function_type = ctx.api.named_type(f'{BUILTINS_NAME}.function')\n    signature = CallableType(arg_types, arg_kinds, arg_names, return_type, function_type)\n    if tvar_def:\n        signature.variables = [tvar_def]\n\n    func = FuncDef(name, args, Block([PassStmt()]))\n    func.info = info\n    func.type = set_callable_name(signature, func)\n    func.is_class = is_classmethod\n    # func.is_static = is_staticmethod\n    func._fullname = get_fullname(info) + '.' + name\n    func.line = info.line\n\n    # NOTE: we would like the plugin generated node to dominate, but we still\n    # need to keep any existing definitions so they get semantically analyzed.\n    if name in info.names:\n        # Get a nice unique name instead.\n        r_name = get_unique_redefinition_name(name, info.names)\n        info.names[r_name] = info.names[name]\n\n    if is_classmethod:  # or is_staticmethod:\n        func.is_decorated = True\n        v = Var(name, func.type)\n        v.info = info\n        v._fullname = func._fullname\n        # if is_classmethod:\n        v.is_classmethod = True\n        dec = Decorator(func, [NameExpr('classmethod')], v)\n        # else:\n        #     v.is_staticmethod = True\n        #     dec = Decorator(func, [NameExpr('staticmethod')], v)\n\n        dec.line = info.line\n        sym = SymbolTableNode(MDEF, dec)\n    else:\n        sym = SymbolTableNode(MDEF, func)\n    sym.plugin_generated = True\n\n    info.names[name] = sym\n    info.defn.defs.body.append(func)\n\n\ndef get_fullname(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.\n    \"\"\"\n    fn = x.fullname\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef get_name(x: Union[FuncBase, SymbolNode]) -> str:\n    \"\"\"\n    Used for compatibility with mypy 0.740; can be dropped once support for 0.740 is dropped.\n    \"\"\"\n    fn = x.name\n    if callable(fn):  # pragma: no cover\n        return fn()\n    return fn\n\n\ndef parse_toml(config_file: str) -> Optional[Dict[str, Any]]:\n    if not config_file.endswith('.toml'):\n        return None\n\n    read_mode = 'rb'\n    if sys.version_info >= (3, 11):\n        import tomllib as toml_\n    else:\n        try:\n            import tomli as toml_\n        except ImportError:\n            # older versions of mypy have toml as a dependency, not tomli\n            read_mode = 'r'\n            try:\n                import toml as toml_  # type: ignore[no-redef]\n            except ImportError:  # pragma: no cover\n                import warnings\n\n                warnings.warn('No TOML parser installed, cannot read configuration from `pyproject.toml`.')\n                return None\n\n    with open(config_file, read_mode) as rf:\n        return toml_.load(rf)  # type: ignore[arg-type]\n", "pydantic/v1/networks.py": "import re\nfrom ipaddress import (\n    IPv4Address,\n    IPv4Interface,\n    IPv4Network,\n    IPv6Address,\n    IPv6Interface,\n    IPv6Network,\n    _BaseAddress,\n    _BaseNetwork,\n)\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Collection,\n    Dict,\n    Generator,\n    List,\n    Match,\n    Optional,\n    Pattern,\n    Set,\n    Tuple,\n    Type,\n    Union,\n    cast,\n    no_type_check,\n)\n\nfrom pydantic.v1 import errors\nfrom pydantic.v1.utils import Representation, update_not_none\nfrom pydantic.v1.validators import constr_length_validator, str_validator\n\nif TYPE_CHECKING:\n    import email_validator\n    from typing_extensions import TypedDict\n\n    from pydantic.v1.config import BaseConfig\n    from pydantic.v1.fields import ModelField\n    from pydantic.v1.typing import AnyCallable\n\n    CallableGenerator = Generator[AnyCallable, None, None]\n\n    class Parts(TypedDict, total=False):\n        scheme: str\n        user: Optional[str]\n        password: Optional[str]\n        ipv4: Optional[str]\n        ipv6: Optional[str]\n        domain: Optional[str]\n        port: Optional[str]\n        path: Optional[str]\n        query: Optional[str]\n        fragment: Optional[str]\n\n    class HostParts(TypedDict, total=False):\n        host: str\n        tld: Optional[str]\n        host_type: Optional[str]\n        port: Optional[str]\n        rebuild: bool\n\nelse:\n    email_validator = None\n\n    class Parts(dict):\n        pass\n\n\nNetworkType = Union[str, bytes, int, Tuple[Union[str, bytes, int], Union[str, int]]]\n\n__all__ = [\n    'AnyUrl',\n    'AnyHttpUrl',\n    'FileUrl',\n    'HttpUrl',\n    'stricturl',\n    'EmailStr',\n    'NameEmail',\n    'IPvAnyAddress',\n    'IPvAnyInterface',\n    'IPvAnyNetwork',\n    'PostgresDsn',\n    'CockroachDsn',\n    'AmqpDsn',\n    'RedisDsn',\n    'MongoDsn',\n    'KafkaDsn',\n    'validate_email',\n]\n\n_url_regex_cache = None\n_multi_host_url_regex_cache = None\n_ascii_domain_regex_cache = None\n_int_domain_regex_cache = None\n_host_regex_cache = None\n\n_host_regex = (\n    r'(?:'\n    r'(?P<ipv4>(?:\\d{1,3}\\.){3}\\d{1,3})(?=$|[/:#?])|'  # ipv4\n    r'(?P<ipv6>\\[[A-F0-9]*:[A-F0-9:]+\\])(?=$|[/:#?])|'  # ipv6\n    r'(?P<domain>[^\\s/:?#]+)'  # domain, validation occurs later\n    r')?'\n    r'(?::(?P<port>\\d+))?'  # port\n)\n_scheme_regex = r'(?:(?P<scheme>[a-z][a-z0-9+\\-.]+)://)?'  # scheme https://tools.ietf.org/html/rfc3986#appendix-A\n_user_info_regex = r'(?:(?P<user>[^\\s:/]*)(?::(?P<password>[^\\s/]*))?@)?'\n_path_regex = r'(?P<path>/[^\\s?#]*)?'\n_query_regex = r'(?:\\?(?P<query>[^\\s#]*))?'\n_fragment_regex = r'(?:#(?P<fragment>[^\\s#]*))?'\n\n\ndef url_regex() -> Pattern[str]:\n    global _url_regex_cache\n    if _url_regex_cache is None:\n        _url_regex_cache = re.compile(\n            rf'{_scheme_regex}{_user_info_regex}{_host_regex}{_path_regex}{_query_regex}{_fragment_regex}',\n            re.IGNORECASE,\n        )\n    return _url_regex_cache\n\n\ndef multi_host_url_regex() -> Pattern[str]:\n    \"\"\"\n    Compiled multi host url regex.\n\n    Additionally to `url_regex` it allows to match multiple hosts.\n    E.g. host1.db.net,host2.db.net\n    \"\"\"\n    global _multi_host_url_regex_cache\n    if _multi_host_url_regex_cache is None:\n        _multi_host_url_regex_cache = re.compile(\n            rf'{_scheme_regex}{_user_info_regex}'\n            r'(?P<hosts>([^/]*))'  # validation occurs later\n            rf'{_path_regex}{_query_regex}{_fragment_regex}',\n            re.IGNORECASE,\n        )\n    return _multi_host_url_regex_cache\n\n\ndef ascii_domain_regex() -> Pattern[str]:\n    global _ascii_domain_regex_cache\n    if _ascii_domain_regex_cache is None:\n        ascii_chunk = r'[_0-9a-z](?:[-_0-9a-z]{0,61}[_0-9a-z])?'\n        ascii_domain_ending = r'(?P<tld>\\.[a-z]{2,63})?\\.?'\n        _ascii_domain_regex_cache = re.compile(\n            fr'(?:{ascii_chunk}\\.)*?{ascii_chunk}{ascii_domain_ending}', re.IGNORECASE\n        )\n    return _ascii_domain_regex_cache\n\n\ndef int_domain_regex() -> Pattern[str]:\n    global _int_domain_regex_cache\n    if _int_domain_regex_cache is None:\n        int_chunk = r'[_0-9a-\\U00040000](?:[-_0-9a-\\U00040000]{0,61}[_0-9a-\\U00040000])?'\n        int_domain_ending = r'(?P<tld>(\\.[^\\W\\d_]{2,63})|(\\.(?:xn--)[_0-9a-z-]{2,63}))?\\.?'\n        _int_domain_regex_cache = re.compile(fr'(?:{int_chunk}\\.)*?{int_chunk}{int_domain_ending}', re.IGNORECASE)\n    return _int_domain_regex_cache\n\n\ndef host_regex() -> Pattern[str]:\n    global _host_regex_cache\n    if _host_regex_cache is None:\n        _host_regex_cache = re.compile(\n            _host_regex,\n            re.IGNORECASE,\n        )\n    return _host_regex_cache\n\n\nclass AnyUrl(str):\n    strip_whitespace = True\n    min_length = 1\n    max_length = 2**16\n    allowed_schemes: Optional[Collection[str]] = None\n    tld_required: bool = False\n    user_required: bool = False\n    host_required: bool = True\n    hidden_parts: Set[str] = set()\n\n    __slots__ = ('scheme', 'user', 'password', 'host', 'tld', 'host_type', 'port', 'path', 'query', 'fragment')\n\n    @no_type_check\n    def __new__(cls, url: Optional[str], **kwargs) -> object:\n        return str.__new__(cls, cls.build(**kwargs) if url is None else url)\n\n    def __init__(\n        self,\n        url: str,\n        *,\n        scheme: str,\n        user: Optional[str] = None,\n        password: Optional[str] = None,\n        host: Optional[str] = None,\n        tld: Optional[str] = None,\n        host_type: str = 'domain',\n        port: Optional[str] = None,\n        path: Optional[str] = None,\n        query: Optional[str] = None,\n        fragment: Optional[str] = None,\n    ) -> None:\n        str.__init__(url)\n        self.scheme = scheme\n        self.user = user\n        self.password = password\n        self.host = host\n        self.tld = tld\n        self.host_type = host_type\n        self.port = port\n        self.path = path\n        self.query = query\n        self.fragment = fragment\n\n    @classmethod\n    def build(\n        cls,\n        *,\n        scheme: str,\n        user: Optional[str] = None,\n        password: Optional[str] = None,\n        host: str,\n        port: Optional[str] = None,\n        path: Optional[str] = None,\n        query: Optional[str] = None,\n        fragment: Optional[str] = None,\n        **_kwargs: str,\n    ) -> str:\n        parts = Parts(\n            scheme=scheme,\n            user=user,\n            password=password,\n            host=host,\n            port=port,\n            path=path,\n            query=query,\n            fragment=fragment,\n            **_kwargs,  # type: ignore[misc]\n        )\n\n        url = scheme + '://'\n        if user:\n            url += user\n        if password:\n            url += ':' + password\n        if user or password:\n            url += '@'\n        url += host\n        if port and ('port' not in cls.hidden_parts or cls.get_default_parts(parts).get('port') != port):\n            url += ':' + port\n        if path:\n            url += path\n        if query:\n            url += '?' + query\n        if fragment:\n            url += '#' + fragment\n        return url\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        update_not_none(field_schema, minLength=cls.min_length, maxLength=cls.max_length, format='uri')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Any, field: 'ModelField', config: 'BaseConfig') -> 'AnyUrl':\n        if value.__class__ == cls:\n            return value\n        value = str_validator(value)\n        if cls.strip_whitespace:\n            value = value.strip()\n        url: str = cast(str, constr_length_validator(value, field, config))\n\n        m = cls._match_url(url)\n        # the regex should always match, if it doesn't please report with details of the URL tried\n        assert m, 'URL regex failed unexpectedly'\n\n        original_parts = cast('Parts', m.groupdict())\n        parts = cls.apply_default_parts(original_parts)\n        parts = cls.validate_parts(parts)\n\n        if m.end() != len(url):\n            raise errors.UrlExtraError(extra=url[m.end() :])\n\n        return cls._build_url(m, url, parts)\n\n    @classmethod\n    def _build_url(cls, m: Match[str], url: str, parts: 'Parts') -> 'AnyUrl':\n        \"\"\"\n        Validate hosts and build the AnyUrl object. Split from `validate` so this method\n        can be altered in `MultiHostDsn`.\n        \"\"\"\n        host, tld, host_type, rebuild = cls.validate_host(parts)\n\n        return cls(\n            None if rebuild else url,\n            scheme=parts['scheme'],\n            user=parts['user'],\n            password=parts['password'],\n            host=host,\n            tld=tld,\n            host_type=host_type,\n            port=parts['port'],\n            path=parts['path'],\n            query=parts['query'],\n            fragment=parts['fragment'],\n        )\n\n    @staticmethod\n    def _match_url(url: str) -> Optional[Match[str]]:\n        return url_regex().match(url)\n\n    @staticmethod\n    def _validate_port(port: Optional[str]) -> None:\n        if port is not None and int(port) > 65_535:\n            raise errors.UrlPortError()\n\n    @classmethod\n    def validate_parts(cls, parts: 'Parts', validate_port: bool = True) -> 'Parts':\n        \"\"\"\n        A method used to validate parts of a URL.\n        Could be overridden to set default values for parts if missing\n        \"\"\"\n        scheme = parts['scheme']\n        if scheme is None:\n            raise errors.UrlSchemeError()\n\n        if cls.allowed_schemes and scheme.lower() not in cls.allowed_schemes:\n            raise errors.UrlSchemePermittedError(set(cls.allowed_schemes))\n\n        if validate_port:\n            cls._validate_port(parts['port'])\n\n        user = parts['user']\n        if cls.user_required and user is None:\n            raise errors.UrlUserInfoError()\n\n        return parts\n\n    @classmethod\n    def validate_host(cls, parts: 'Parts') -> Tuple[str, Optional[str], str, bool]:\n        tld, host_type, rebuild = None, None, False\n        for f in ('domain', 'ipv4', 'ipv6'):\n            host = parts[f]  # type: ignore[literal-required]\n            if host:\n                host_type = f\n                break\n\n        if host is None:\n            if cls.host_required:\n                raise errors.UrlHostError()\n        elif host_type == 'domain':\n            is_international = False\n            d = ascii_domain_regex().fullmatch(host)\n            if d is None:\n                d = int_domain_regex().fullmatch(host)\n                if d is None:\n                    raise errors.UrlHostError()\n                is_international = True\n\n            tld = d.group('tld')\n            if tld is None and not is_international:\n                d = int_domain_regex().fullmatch(host)\n                assert d is not None\n                tld = d.group('tld')\n                is_international = True\n\n            if tld is not None:\n                tld = tld[1:]\n            elif cls.tld_required:\n                raise errors.UrlHostTldError()\n\n            if is_international:\n                host_type = 'int_domain'\n                rebuild = True\n                host = host.encode('idna').decode('ascii')\n                if tld is not None:\n                    tld = tld.encode('idna').decode('ascii')\n\n        return host, tld, host_type, rebuild  # type: ignore\n\n    @staticmethod\n    def get_default_parts(parts: 'Parts') -> 'Parts':\n        return {}\n\n    @classmethod\n    def apply_default_parts(cls, parts: 'Parts') -> 'Parts':\n        for key, value in cls.get_default_parts(parts).items():\n            if not parts[key]:  # type: ignore[literal-required]\n                parts[key] = value  # type: ignore[literal-required]\n        return parts\n\n    def __repr__(self) -> str:\n        extra = ', '.join(f'{n}={getattr(self, n)!r}' for n in self.__slots__ if getattr(self, n) is not None)\n        return f'{self.__class__.__name__}({super().__repr__()}, {extra})'\n\n\nclass AnyHttpUrl(AnyUrl):\n    allowed_schemes = {'http', 'https'}\n\n    __slots__ = ()\n\n\nclass HttpUrl(AnyHttpUrl):\n    tld_required = True\n    # https://stackoverflow.com/questions/417142/what-is-the-maximum-length-of-a-url-in-different-browsers\n    max_length = 2083\n    hidden_parts = {'port'}\n\n    @staticmethod\n    def get_default_parts(parts: 'Parts') -> 'Parts':\n        return {'port': '80' if parts['scheme'] == 'http' else '443'}\n\n\nclass FileUrl(AnyUrl):\n    allowed_schemes = {'file'}\n    host_required = False\n\n    __slots__ = ()\n\n\nclass MultiHostDsn(AnyUrl):\n    __slots__ = AnyUrl.__slots__ + ('hosts',)\n\n    def __init__(self, *args: Any, hosts: Optional[List['HostParts']] = None, **kwargs: Any):\n        super().__init__(*args, **kwargs)\n        self.hosts = hosts\n\n    @staticmethod\n    def _match_url(url: str) -> Optional[Match[str]]:\n        return multi_host_url_regex().match(url)\n\n    @classmethod\n    def validate_parts(cls, parts: 'Parts', validate_port: bool = True) -> 'Parts':\n        return super().validate_parts(parts, validate_port=False)\n\n    @classmethod\n    def _build_url(cls, m: Match[str], url: str, parts: 'Parts') -> 'MultiHostDsn':\n        hosts_parts: List['HostParts'] = []\n        host_re = host_regex()\n        for host in m.groupdict()['hosts'].split(','):\n            d: Parts = host_re.match(host).groupdict()  # type: ignore\n            host, tld, host_type, rebuild = cls.validate_host(d)\n            port = d.get('port')\n            cls._validate_port(port)\n            hosts_parts.append(\n                {\n                    'host': host,\n                    'host_type': host_type,\n                    'tld': tld,\n                    'rebuild': rebuild,\n                    'port': port,\n                }\n            )\n\n        if len(hosts_parts) > 1:\n            return cls(\n                None if any([hp['rebuild'] for hp in hosts_parts]) else url,\n                scheme=parts['scheme'],\n                user=parts['user'],\n                password=parts['password'],\n                path=parts['path'],\n                query=parts['query'],\n                fragment=parts['fragment'],\n                host_type=None,\n                hosts=hosts_parts,\n            )\n        else:\n            # backwards compatibility with single host\n            host_part = hosts_parts[0]\n            return cls(\n                None if host_part['rebuild'] else url,\n                scheme=parts['scheme'],\n                user=parts['user'],\n                password=parts['password'],\n                host=host_part['host'],\n                tld=host_part['tld'],\n                host_type=host_part['host_type'],\n                port=host_part.get('port'),\n                path=parts['path'],\n                query=parts['query'],\n                fragment=parts['fragment'],\n            )\n\n\nclass PostgresDsn(MultiHostDsn):\n    allowed_schemes = {\n        'postgres',\n        'postgresql',\n        'postgresql+asyncpg',\n        'postgresql+pg8000',\n        'postgresql+psycopg',\n        'postgresql+psycopg2',\n        'postgresql+psycopg2cffi',\n        'postgresql+py-postgresql',\n        'postgresql+pygresql',\n    }\n    user_required = True\n\n    __slots__ = ()\n\n\nclass CockroachDsn(AnyUrl):\n    allowed_schemes = {\n        'cockroachdb',\n        'cockroachdb+psycopg2',\n        'cockroachdb+asyncpg',\n    }\n    user_required = True\n\n\nclass AmqpDsn(AnyUrl):\n    allowed_schemes = {'amqp', 'amqps'}\n    host_required = False\n\n\nclass RedisDsn(AnyUrl):\n    __slots__ = ()\n    allowed_schemes = {'redis', 'rediss'}\n    host_required = False\n\n    @staticmethod\n    def get_default_parts(parts: 'Parts') -> 'Parts':\n        return {\n            'domain': 'localhost' if not (parts['ipv4'] or parts['ipv6']) else '',\n            'port': '6379',\n            'path': '/0',\n        }\n\n\nclass MongoDsn(AnyUrl):\n    allowed_schemes = {'mongodb'}\n\n    # TODO: Needed to generic \"Parts\" for \"Replica Set\", \"Sharded Cluster\", and other mongodb deployment modes\n    @staticmethod\n    def get_default_parts(parts: 'Parts') -> 'Parts':\n        return {\n            'port': '27017',\n        }\n\n\nclass KafkaDsn(AnyUrl):\n    allowed_schemes = {'kafka'}\n\n    @staticmethod\n    def get_default_parts(parts: 'Parts') -> 'Parts':\n        return {\n            'domain': 'localhost',\n            'port': '9092',\n        }\n\n\ndef stricturl(\n    *,\n    strip_whitespace: bool = True,\n    min_length: int = 1,\n    max_length: int = 2**16,\n    tld_required: bool = True,\n    host_required: bool = True,\n    allowed_schemes: Optional[Collection[str]] = None,\n) -> Type[AnyUrl]:\n    # use kwargs then define conf in a dict to aid with IDE type hinting\n    namespace = dict(\n        strip_whitespace=strip_whitespace,\n        min_length=min_length,\n        max_length=max_length,\n        tld_required=tld_required,\n        host_required=host_required,\n        allowed_schemes=allowed_schemes,\n    )\n    return type('UrlValue', (AnyUrl,), namespace)\n\n\ndef import_email_validator() -> None:\n    global email_validator\n    try:\n        import email_validator\n    except ImportError as e:\n        raise ImportError('email-validator is not installed, run `pip install pydantic[email]`') from e\n\n\nclass EmailStr(str):\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='email')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        # included here and below so the error happens straight away\n        import_email_validator()\n\n        yield str_validator\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Union[str]) -> str:\n        return validate_email(value)[1]\n\n\nclass NameEmail(Representation):\n    __slots__ = 'name', 'email'\n\n    def __init__(self, name: str, email: str):\n        self.name = name\n        self.email = email\n\n    def __eq__(self, other: Any) -> bool:\n        return isinstance(other, NameEmail) and (self.name, self.email) == (other.name, other.email)\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='name-email')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        import_email_validator()\n\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Any) -> 'NameEmail':\n        if value.__class__ == cls:\n            return value\n        value = str_validator(value)\n        return cls(*validate_email(value))\n\n    def __str__(self) -> str:\n        return f'{self.name} <{self.email}>'\n\n\nclass IPvAnyAddress(_BaseAddress):\n    __slots__ = ()\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='ipvanyaddress')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: Union[str, bytes, int]) -> Union[IPv4Address, IPv6Address]:\n        try:\n            return IPv4Address(value)\n        except ValueError:\n            pass\n\n        try:\n            return IPv6Address(value)\n        except ValueError:\n            raise errors.IPvAnyAddressError()\n\n\nclass IPvAnyInterface(_BaseAddress):\n    __slots__ = ()\n\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='ipvanyinterface')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: NetworkType) -> Union[IPv4Interface, IPv6Interface]:\n        try:\n            return IPv4Interface(value)\n        except ValueError:\n            pass\n\n        try:\n            return IPv6Interface(value)\n        except ValueError:\n            raise errors.IPvAnyInterfaceError()\n\n\nclass IPvAnyNetwork(_BaseNetwork):  # type: ignore\n    @classmethod\n    def __modify_schema__(cls, field_schema: Dict[str, Any]) -> None:\n        field_schema.update(type='string', format='ipvanynetwork')\n\n    @classmethod\n    def __get_validators__(cls) -> 'CallableGenerator':\n        yield cls.validate\n\n    @classmethod\n    def validate(cls, value: NetworkType) -> Union[IPv4Network, IPv6Network]:\n        # Assume IP Network is defined with a default value for ``strict`` argument.\n        # Define your own class if you want to specify network address check strictness.\n        try:\n            return IPv4Network(value)\n        except ValueError:\n            pass\n\n        try:\n            return IPv6Network(value)\n        except ValueError:\n            raise errors.IPvAnyNetworkError()\n\n\npretty_email_regex = re.compile(r'([\\w ]*?) *<(.*)> *')\nMAX_EMAIL_LENGTH = 2048\n\"\"\"Maximum length for an email.\nA somewhat arbitrary but very generous number compared to what is allowed by most implementations.\n\"\"\"\n\n\ndef validate_email(value: Union[str]) -> Tuple[str, str]:\n    \"\"\"\n    Email address validation using https://pypi.org/project/email-validator/\n    Notes:\n    * raw ip address (literal) domain parts are not allowed.\n    * \"John Doe <local_part@domain.com>\" style \"pretty\" email addresses are processed\n    * spaces are striped from the beginning and end of addresses but no error is raised\n    \"\"\"\n    if email_validator is None:\n        import_email_validator()\n\n    if len(value) > MAX_EMAIL_LENGTH:\n        raise errors.EmailError()\n\n    m = pretty_email_regex.fullmatch(value)\n    name: Union[str, None] = None\n    if m:\n        name, value = m.groups()\n    email = value.strip()\n    try:\n        parts = email_validator.validate_email(email, check_deliverability=False)\n    except email_validator.EmailNotValidError as e:\n        raise errors.EmailError from e\n\n    if hasattr(parts, 'normalized'):\n        # email-validator >= 2\n        email = parts.normalized\n        assert email is not None\n        name = name or parts.local_part\n        return name, email\n    else:\n        # email-validator >1, <2\n        at_index = email.index('@')\n        local_part = email[:at_index]  # RFC 5321, local part must be case-sensitive.\n        global_part = email[at_index:].lower()\n\n        return name or local_part, local_part + global_part\n", "pydantic/v1/decorator.py": "from functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom pydantic.v1 import validator\nfrom pydantic.v1.config import Extra\nfrom pydantic.v1.errors import ConfigError\nfrom pydantic.v1.main import BaseModel, create_model\nfrom pydantic.v1.typing import get_all_type_hints\nfrom pydantic.v1.utils import to_camel\n\n__all__ = ('validate_arguments',)\n\nif TYPE_CHECKING:\n    from pydantic.v1.typing import AnyCallable\n\n    AnyCallableT = TypeVar('AnyCallableT', bound=AnyCallable)\n    ConfigType = Union[None, Type[Any], Dict[str, Any]]\n\n\n@overload\ndef validate_arguments(func: None = None, *, config: 'ConfigType' = None) -> Callable[['AnyCallableT'], 'AnyCallableT']:\n    ...\n\n\n@overload\ndef validate_arguments(func: 'AnyCallableT') -> 'AnyCallableT':\n    ...\n\n\ndef validate_arguments(func: Optional['AnyCallableT'] = None, *, config: 'ConfigType' = None) -> Any:\n    \"\"\"\n    Decorator to validate the arguments passed to a function.\n    \"\"\"\n\n    def validate(_func: 'AnyCallable') -> 'AnyCallable':\n        vd = ValidatedFunction(_func, config)\n\n        @wraps(_func)\n        def wrapper_function(*args: Any, **kwargs: Any) -> Any:\n            return vd.call(*args, **kwargs)\n\n        wrapper_function.vd = vd  # type: ignore\n        wrapper_function.validate = vd.init_model_instance  # type: ignore\n        wrapper_function.raw_function = vd.raw_function  # type: ignore\n        wrapper_function.model = vd.model  # type: ignore\n        return wrapper_function\n\n    if func:\n        return validate(func)\n    else:\n        return validate\n\n\nALT_V_ARGS = 'v__args'\nALT_V_KWARGS = 'v__kwargs'\nV_POSITIONAL_ONLY_NAME = 'v__positional_only'\nV_DUPLICATE_KWARGS = 'v__duplicate_kwargs'\n\n\nclass ValidatedFunction:\n    def __init__(self, function: 'AnyCallableT', config: 'ConfigType'):  # noqa C901\n        from inspect import Parameter, signature\n\n        parameters: Mapping[str, Parameter] = signature(function).parameters\n\n        if parameters.keys() & {ALT_V_ARGS, ALT_V_KWARGS, V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:\n            raise ConfigError(\n                f'\"{ALT_V_ARGS}\", \"{ALT_V_KWARGS}\", \"{V_POSITIONAL_ONLY_NAME}\" and \"{V_DUPLICATE_KWARGS}\" '\n                f'are not permitted as argument names when using the \"{validate_arguments.__name__}\" decorator'\n            )\n\n        self.raw_function = function\n        self.arg_mapping: Dict[int, str] = {}\n        self.positional_only_args = set()\n        self.v_args_name = 'args'\n        self.v_kwargs_name = 'kwargs'\n\n        type_hints = get_all_type_hints(function)\n        takes_args = False\n        takes_kwargs = False\n        fields: Dict[str, Tuple[Any, Any]] = {}\n        for i, (name, p) in enumerate(parameters.items()):\n            if p.annotation is p.empty:\n                annotation = Any\n            else:\n                annotation = type_hints[name]\n\n            default = ... if p.default is p.empty else p.default\n            if p.kind == Parameter.POSITIONAL_ONLY:\n                self.arg_mapping[i] = name\n                fields[name] = annotation, default\n                fields[V_POSITIONAL_ONLY_NAME] = List[str], None\n                self.positional_only_args.add(name)\n            elif p.kind == Parameter.POSITIONAL_OR_KEYWORD:\n                self.arg_mapping[i] = name\n                fields[name] = annotation, default\n                fields[V_DUPLICATE_KWARGS] = List[str], None\n            elif p.kind == Parameter.KEYWORD_ONLY:\n                fields[name] = annotation, default\n            elif p.kind == Parameter.VAR_POSITIONAL:\n                self.v_args_name = name\n                fields[name] = Tuple[annotation, ...], None\n                takes_args = True\n            else:\n                assert p.kind == Parameter.VAR_KEYWORD, p.kind\n                self.v_kwargs_name = name\n                fields[name] = Dict[str, annotation], None  # type: ignore\n                takes_kwargs = True\n\n        # these checks avoid a clash between \"args\" and a field with that name\n        if not takes_args and self.v_args_name in fields:\n            self.v_args_name = ALT_V_ARGS\n\n        # same with \"kwargs\"\n        if not takes_kwargs and self.v_kwargs_name in fields:\n            self.v_kwargs_name = ALT_V_KWARGS\n\n        if not takes_args:\n            # we add the field so validation below can raise the correct exception\n            fields[self.v_args_name] = List[Any], None\n\n        if not takes_kwargs:\n            # same with kwargs\n            fields[self.v_kwargs_name] = Dict[Any, Any], None\n\n        self.create_model(fields, takes_args, takes_kwargs, config)\n\n    def init_model_instance(self, *args: Any, **kwargs: Any) -> BaseModel:\n        values = self.build_values(args, kwargs)\n        return self.model(**values)\n\n    def call(self, *args: Any, **kwargs: Any) -> Any:\n        m = self.init_model_instance(*args, **kwargs)\n        return self.execute(m)\n\n    def build_values(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        values: Dict[str, Any] = {}\n        if args:\n            arg_iter = enumerate(args)\n            while True:\n                try:\n                    i, a = next(arg_iter)\n                except StopIteration:\n                    break\n                arg_name = self.arg_mapping.get(i)\n                if arg_name is not None:\n                    values[arg_name] = a\n                else:\n                    values[self.v_args_name] = [a] + [a for _, a in arg_iter]\n                    break\n\n        var_kwargs: Dict[str, Any] = {}\n        wrong_positional_args = []\n        duplicate_kwargs = []\n        fields_alias = [\n            field.alias\n            for name, field in self.model.__fields__.items()\n            if name not in (self.v_args_name, self.v_kwargs_name)\n        ]\n        non_var_fields = set(self.model.__fields__) - {self.v_args_name, self.v_kwargs_name}\n        for k, v in kwargs.items():\n            if k in non_var_fields or k in fields_alias:\n                if k in self.positional_only_args:\n                    wrong_positional_args.append(k)\n                if k in values:\n                    duplicate_kwargs.append(k)\n                values[k] = v\n            else:\n                var_kwargs[k] = v\n\n        if var_kwargs:\n            values[self.v_kwargs_name] = var_kwargs\n        if wrong_positional_args:\n            values[V_POSITIONAL_ONLY_NAME] = wrong_positional_args\n        if duplicate_kwargs:\n            values[V_DUPLICATE_KWARGS] = duplicate_kwargs\n        return values\n\n    def execute(self, m: BaseModel) -> Any:\n        d = {k: v for k, v in m._iter() if k in m.__fields_set__ or m.__fields__[k].default_factory}\n        var_kwargs = d.pop(self.v_kwargs_name, {})\n\n        if self.v_args_name in d:\n            args_: List[Any] = []\n            in_kwargs = False\n            kwargs = {}\n            for name, value in d.items():\n                if in_kwargs:\n                    kwargs[name] = value\n                elif name == self.v_args_name:\n                    args_ += value\n                    in_kwargs = True\n                else:\n                    args_.append(value)\n            return self.raw_function(*args_, **kwargs, **var_kwargs)\n        elif self.positional_only_args:\n            args_ = []\n            kwargs = {}\n            for name, value in d.items():\n                if name in self.positional_only_args:\n                    args_.append(value)\n                else:\n                    kwargs[name] = value\n            return self.raw_function(*args_, **kwargs, **var_kwargs)\n        else:\n            return self.raw_function(**d, **var_kwargs)\n\n    def create_model(self, fields: Dict[str, Any], takes_args: bool, takes_kwargs: bool, config: 'ConfigType') -> None:\n        pos_args = len(self.arg_mapping)\n\n        class CustomConfig:\n            pass\n\n        if not TYPE_CHECKING:  # pragma: no branch\n            if isinstance(config, dict):\n                CustomConfig = type('Config', (), config)  # noqa: F811\n            elif config is not None:\n                CustomConfig = config  # noqa: F811\n\n        if hasattr(CustomConfig, 'fields') or hasattr(CustomConfig, 'alias_generator'):\n            raise ConfigError(\n                'Setting the \"fields\" and \"alias_generator\" property on custom Config for '\n                '@validate_arguments is not yet supported, please remove.'\n            )\n\n        class DecoratorBaseModel(BaseModel):\n            @validator(self.v_args_name, check_fields=False, allow_reuse=True)\n            def check_args(cls, v: Optional[List[Any]]) -> Optional[List[Any]]:\n                if takes_args or v is None:\n                    return v\n\n                raise TypeError(f'{pos_args} positional arguments expected but {pos_args + len(v)} given')\n\n            @validator(self.v_kwargs_name, check_fields=False, allow_reuse=True)\n            def check_kwargs(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:\n                if takes_kwargs or v is None:\n                    return v\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v.keys()))\n                raise TypeError(f'unexpected keyword argument{plural}: {keys}')\n\n            @validator(V_POSITIONAL_ONLY_NAME, check_fields=False, allow_reuse=True)\n            def check_positional_only(cls, v: Optional[List[str]]) -> None:\n                if v is None:\n                    return\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v))\n                raise TypeError(f'positional-only argument{plural} passed as keyword argument{plural}: {keys}')\n\n            @validator(V_DUPLICATE_KWARGS, check_fields=False, allow_reuse=True)\n            def check_duplicate_kwargs(cls, v: Optional[List[str]]) -> None:\n                if v is None:\n                    return\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v))\n                raise TypeError(f'multiple values for argument{plural}: {keys}')\n\n            class Config(CustomConfig):\n                extra = getattr(CustomConfig, 'extra', Extra.forbid)\n\n        self.model = create_model(to_camel(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)\n", "pydantic/v1/datetime_parse.py": "\"\"\"\nFunctions to parse datetime objects.\n\nWe're using regular expressions rather than time.strptime because:\n- They provide both validation and parsing.\n- They're more flexible for datetimes.\n- The date/datetime/time constructors produce friendlier error messages.\n\nStolen from https://raw.githubusercontent.com/django/django/main/django/utils/dateparse.py at\n9718fa2e8abe430c3526a9278dd976443d4ae3c6\n\nChanged to:\n* use standard python datetime types not django.utils.timezone\n* raise ValueError when regex doesn't match rather than returning None\n* support parsing unix timestamps for dates and datetimes\n\"\"\"\nimport re\nfrom datetime import date, datetime, time, timedelta, timezone\nfrom typing import Dict, Optional, Type, Union\n\nfrom pydantic.v1 import errors\n\ndate_expr = r'(?P<year>\\d{4})-(?P<month>\\d{1,2})-(?P<day>\\d{1,2})'\ntime_expr = (\n    r'(?P<hour>\\d{1,2}):(?P<minute>\\d{1,2})'\n    r'(?::(?P<second>\\d{1,2})(?:\\.(?P<microsecond>\\d{1,6})\\d{0,6})?)?'\n    r'(?P<tzinfo>Z|[+-]\\d{2}(?::?\\d{2})?)?$'\n)\n\ndate_re = re.compile(f'{date_expr}$')\ntime_re = re.compile(time_expr)\ndatetime_re = re.compile(f'{date_expr}[T ]{time_expr}')\n\nstandard_duration_re = re.compile(\n    r'^'\n    r'(?:(?P<days>-?\\d+) (days?, )?)?'\n    r'((?:(?P<hours>-?\\d+):)(?=\\d+:\\d+))?'\n    r'(?:(?P<minutes>-?\\d+):)?'\n    r'(?P<seconds>-?\\d+)'\n    r'(?:\\.(?P<microseconds>\\d{1,6})\\d{0,6})?'\n    r'$'\n)\n\n# Support the sections of ISO 8601 date representation that are accepted by timedelta\niso8601_duration_re = re.compile(\n    r'^(?P<sign>[-+]?)'\n    r'P'\n    r'(?:(?P<days>\\d+(.\\d+)?)D)?'\n    r'(?:T'\n    r'(?:(?P<hours>\\d+(.\\d+)?)H)?'\n    r'(?:(?P<minutes>\\d+(.\\d+)?)M)?'\n    r'(?:(?P<seconds>\\d+(.\\d+)?)S)?'\n    r')?'\n    r'$'\n)\n\nEPOCH = datetime(1970, 1, 1)\n# if greater than this, the number is in ms, if less than or equal it's in seconds\n# (in seconds this is 11th October 2603, in ms it's 20th August 1970)\nMS_WATERSHED = int(2e10)\n# slightly more than datetime.max in ns - (datetime.max - EPOCH).total_seconds() * 1e9\nMAX_NUMBER = int(3e20)\nStrBytesIntFloat = Union[str, bytes, int, float]\n\n\ndef get_numeric(value: StrBytesIntFloat, native_expected_type: str) -> Union[None, int, float]:\n    if isinstance(value, (int, float)):\n        return value\n    try:\n        return float(value)\n    except ValueError:\n        return None\n    except TypeError:\n        raise TypeError(f'invalid type; expected {native_expected_type}, string, bytes, int or float')\n\n\ndef from_unix_seconds(seconds: Union[int, float]) -> datetime:\n    if seconds > MAX_NUMBER:\n        return datetime.max\n    elif seconds < -MAX_NUMBER:\n        return datetime.min\n\n    while abs(seconds) > MS_WATERSHED:\n        seconds /= 1000\n    dt = EPOCH + timedelta(seconds=seconds)\n    return dt.replace(tzinfo=timezone.utc)\n\n\ndef _parse_timezone(value: Optional[str], error: Type[Exception]) -> Union[None, int, timezone]:\n    if value == 'Z':\n        return timezone.utc\n    elif value is not None:\n        offset_mins = int(value[-2:]) if len(value) > 3 else 0\n        offset = 60 * int(value[1:3]) + offset_mins\n        if value[0] == '-':\n            offset = -offset\n        try:\n            return timezone(timedelta(minutes=offset))\n        except ValueError:\n            raise error()\n    else:\n        return None\n\n\ndef parse_date(value: Union[date, StrBytesIntFloat]) -> date:\n    \"\"\"\n    Parse a date/int/float/string and return a datetime.date.\n\n    Raise ValueError if the input is well formatted but not a valid date.\n    Raise ValueError if the input isn't well formatted.\n    \"\"\"\n    if isinstance(value, date):\n        if isinstance(value, datetime):\n            return value.date()\n        else:\n            return value\n\n    number = get_numeric(value, 'date')\n    if number is not None:\n        return from_unix_seconds(number).date()\n\n    if isinstance(value, bytes):\n        value = value.decode()\n\n    match = date_re.match(value)  # type: ignore\n    if match is None:\n        raise errors.DateError()\n\n    kw = {k: int(v) for k, v in match.groupdict().items()}\n\n    try:\n        return date(**kw)\n    except ValueError:\n        raise errors.DateError()\n\n\ndef parse_time(value: Union[time, StrBytesIntFloat]) -> time:\n    \"\"\"\n    Parse a time/string and return a datetime.time.\n\n    Raise ValueError if the input is well formatted but not a valid time.\n    Raise ValueError if the input isn't well formatted, in particular if it contains an offset.\n    \"\"\"\n    if isinstance(value, time):\n        return value\n\n    number = get_numeric(value, 'time')\n    if number is not None:\n        if number >= 86400:\n            # doesn't make sense since the time time loop back around to 0\n            raise errors.TimeError()\n        return (datetime.min + timedelta(seconds=number)).time()\n\n    if isinstance(value, bytes):\n        value = value.decode()\n\n    match = time_re.match(value)  # type: ignore\n    if match is None:\n        raise errors.TimeError()\n\n    kw = match.groupdict()\n    if kw['microsecond']:\n        kw['microsecond'] = kw['microsecond'].ljust(6, '0')\n\n    tzinfo = _parse_timezone(kw.pop('tzinfo'), errors.TimeError)\n    kw_: Dict[str, Union[None, int, timezone]] = {k: int(v) for k, v in kw.items() if v is not None}\n    kw_['tzinfo'] = tzinfo\n\n    try:\n        return time(**kw_)  # type: ignore\n    except ValueError:\n        raise errors.TimeError()\n\n\ndef parse_datetime(value: Union[datetime, StrBytesIntFloat]) -> datetime:\n    \"\"\"\n    Parse a datetime/int/float/string and return a datetime.datetime.\n\n    This function supports time zone offsets. When the input contains one,\n    the output uses a timezone with a fixed offset from UTC.\n\n    Raise ValueError if the input is well formatted but not a valid datetime.\n    Raise ValueError if the input isn't well formatted.\n    \"\"\"\n    if isinstance(value, datetime):\n        return value\n\n    number = get_numeric(value, 'datetime')\n    if number is not None:\n        return from_unix_seconds(number)\n\n    if isinstance(value, bytes):\n        value = value.decode()\n\n    match = datetime_re.match(value)  # type: ignore\n    if match is None:\n        raise errors.DateTimeError()\n\n    kw = match.groupdict()\n    if kw['microsecond']:\n        kw['microsecond'] = kw['microsecond'].ljust(6, '0')\n\n    tzinfo = _parse_timezone(kw.pop('tzinfo'), errors.DateTimeError)\n    kw_: Dict[str, Union[None, int, timezone]] = {k: int(v) for k, v in kw.items() if v is not None}\n    kw_['tzinfo'] = tzinfo\n\n    try:\n        return datetime(**kw_)  # type: ignore\n    except ValueError:\n        raise errors.DateTimeError()\n\n\ndef parse_duration(value: StrBytesIntFloat) -> timedelta:\n    \"\"\"\n    Parse a duration int/float/string and return a datetime.timedelta.\n\n    The preferred format for durations in Django is '%d %H:%M:%S.%f'.\n\n    Also supports ISO 8601 representation.\n    \"\"\"\n    if isinstance(value, timedelta):\n        return value\n\n    if isinstance(value, (int, float)):\n        # below code requires a string\n        value = f'{value:f}'\n    elif isinstance(value, bytes):\n        value = value.decode()\n\n    try:\n        match = standard_duration_re.match(value) or iso8601_duration_re.match(value)\n    except TypeError:\n        raise TypeError('invalid type; expected timedelta, string, bytes, int or float')\n\n    if not match:\n        raise errors.DurationError()\n\n    kw = match.groupdict()\n    sign = -1 if kw.pop('sign', '+') == '-' else 1\n    if kw.get('microseconds'):\n        kw['microseconds'] = kw['microseconds'].ljust(6, '0')\n\n    if kw.get('seconds') and kw.get('microseconds') and kw['seconds'].startswith('-'):\n        kw['microseconds'] = '-' + kw['microseconds']\n\n    kw_ = {k: float(v) for k, v in kw.items() if v is not None}\n\n    return sign * timedelta(**kw_)\n", "pydantic/_internal/_git.py": "\"\"\"Git utilities, adopted from mypy's git utilities (https://github.com/python/mypy/blob/master/mypy/git.py).\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport subprocess\n\n\ndef is_git_repo(dir: str) -> bool:\n    \"\"\"Is the given directory version-controlled with git?\"\"\"\n    return os.path.exists(os.path.join(dir, '.git'))\n\n\ndef have_git() -> bool:\n    \"\"\"Can we run the git executable?\"\"\"\n    try:\n        subprocess.check_output(['git', '--help'])\n        return True\n    except subprocess.CalledProcessError:\n        return False\n    except OSError:\n        return False\n\n\ndef git_revision(dir: str) -> str:\n    \"\"\"Get the SHA-1 of the HEAD of a git repository.\"\"\"\n    return subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD'], cwd=dir).decode('utf-8').strip()\n", "pydantic/_internal/_signature.py": "from __future__ import annotations\n\nimport dataclasses\nfrom inspect import Parameter, Signature, signature\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import PydanticUndefined\n\nfrom ._config import ConfigWrapper\nfrom ._utils import is_valid_identifier\n\nif TYPE_CHECKING:\n    from ..fields import FieldInfo\n\n\ndef _field_name_for_signature(field_name: str, field_info: FieldInfo) -> str:\n    \"\"\"Extract the correct name to use for the field when generating a signature.\n\n    Assuming the field has a valid alias, this will return the alias. Otherwise, it will return the field name.\n    First priority is given to the validation_alias, then the alias, then the field name.\n\n    Args:\n        field_name: The name of the field\n        field_info: The corresponding FieldInfo object.\n\n    Returns:\n        The correct name to use when generating a signature.\n    \"\"\"\n\n    def _alias_if_valid(x: Any) -> str | None:\n        \"\"\"Return the alias if it is a valid alias and identifier, else None.\"\"\"\n        return x if isinstance(x, str) and is_valid_identifier(x) else None\n\n    return _alias_if_valid(field_info.alias) or _alias_if_valid(field_info.validation_alias) or field_name\n\n\ndef _process_param_defaults(param: Parameter) -> Parameter:\n    \"\"\"Modify the signature for a parameter in a dataclass where the default value is a FieldInfo instance.\n\n    Args:\n        param (Parameter): The parameter\n\n    Returns:\n        Parameter: The custom processed parameter\n    \"\"\"\n    from ..fields import FieldInfo\n\n    param_default = param.default\n    if isinstance(param_default, FieldInfo):\n        annotation = param.annotation\n        # Replace the annotation if appropriate\n        # inspect does \"clever\" things to show annotations as strings because we have\n        # `from __future__ import annotations` in main, we don't want that\n        if annotation == 'Any':\n            annotation = Any\n\n        # Replace the field default\n        default = param_default.default\n        if default is PydanticUndefined:\n            if param_default.default_factory is PydanticUndefined:\n                default = Signature.empty\n            else:\n                # this is used by dataclasses to indicate a factory exists:\n                default = dataclasses._HAS_DEFAULT_FACTORY  # type: ignore\n        return param.replace(\n            annotation=annotation, name=_field_name_for_signature(param.name, param_default), default=default\n        )\n    return param\n\n\ndef _generate_signature_parameters(  # noqa: C901 (ignore complexity, could use a refactor)\n    init: Callable[..., None],\n    fields: dict[str, FieldInfo],\n    config_wrapper: ConfigWrapper,\n) -> dict[str, Parameter]:\n    \"\"\"Generate a mapping of parameter names to Parameter objects for a pydantic BaseModel or dataclass.\"\"\"\n    from itertools import islice\n\n    present_params = signature(init).parameters.values()\n    merged_params: dict[str, Parameter] = {}\n    var_kw = None\n    use_var_kw = False\n\n    for param in islice(present_params, 1, None):  # skip self arg\n        # inspect does \"clever\" things to show annotations as strings because we have\n        # `from __future__ import annotations` in main, we don't want that\n        if fields.get(param.name):\n            # exclude params with init=False\n            if getattr(fields[param.name], 'init', True) is False:\n                continue\n            param = param.replace(name=_field_name_for_signature(param.name, fields[param.name]))\n        if param.annotation == 'Any':\n            param = param.replace(annotation=Any)\n        if param.kind is param.VAR_KEYWORD:\n            var_kw = param\n            continue\n        merged_params[param.name] = param\n\n    if var_kw:  # if custom init has no var_kw, fields which are not declared in it cannot be passed through\n        allow_names = config_wrapper.populate_by_name\n        for field_name, field in fields.items():\n            # when alias is a str it should be used for signature generation\n            param_name = _field_name_for_signature(field_name, field)\n\n            if field_name in merged_params or param_name in merged_params:\n                continue\n\n            if not is_valid_identifier(param_name):\n                if allow_names:\n                    param_name = field_name\n                else:\n                    use_var_kw = True\n                    continue\n\n            kwargs = {} if field.is_required() else {'default': field.get_default(call_default_factory=False)}\n            merged_params[param_name] = Parameter(\n                param_name, Parameter.KEYWORD_ONLY, annotation=field.rebuild_annotation(), **kwargs\n            )\n\n    if config_wrapper.extra == 'allow':\n        use_var_kw = True\n\n    if var_kw and use_var_kw:\n        # Make sure the parameter for extra kwargs\n        # does not have the same name as a field\n        default_model_signature = [\n            ('self', Parameter.POSITIONAL_ONLY),\n            ('data', Parameter.VAR_KEYWORD),\n        ]\n        if [(p.name, p.kind) for p in present_params] == default_model_signature:\n            # if this is the standard model signature, use extra_data as the extra args name\n            var_kw_name = 'extra_data'\n        else:\n            # else start from var_kw\n            var_kw_name = var_kw.name\n\n        # generate a name that's definitely unique\n        while var_kw_name in fields:\n            var_kw_name += '_'\n        merged_params[var_kw_name] = var_kw.replace(name=var_kw_name)\n\n    return merged_params\n\n\ndef generate_pydantic_signature(\n    init: Callable[..., None], fields: dict[str, FieldInfo], config_wrapper: ConfigWrapper, is_dataclass: bool = False\n) -> Signature:\n    \"\"\"Generate signature for a pydantic BaseModel or dataclass.\n\n    Args:\n        init: The class init.\n        fields: The model fields.\n        config_wrapper: The config wrapper instance.\n        is_dataclass: Whether the model is a dataclass.\n\n    Returns:\n        The dataclass/BaseModel subclass signature.\n    \"\"\"\n    merged_params = _generate_signature_parameters(init, fields, config_wrapper)\n\n    if is_dataclass:\n        merged_params = {k: _process_param_defaults(v) for k, v in merged_params.items()}\n\n    return Signature(parameters=list(merged_params.values()), return_annotation=None)\n", "pydantic/_internal/_std_types_schema.py": "\"\"\"Logic for generating pydantic-core schemas for standard library types.\n\nImport of this module is deferred since it contains imports of many standard library modules.\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport collections\nimport collections.abc\nimport dataclasses\nimport decimal\nimport inspect\nimport os\nimport typing\nfrom enum import Enum\nfrom functools import partial\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom operator import attrgetter\nfrom typing import Any, Callable, Iterable, Literal, Tuple, TypeVar\n\nimport typing_extensions\nfrom pydantic_core import (\n    CoreSchema,\n    MultiHostUrl,\n    PydanticCustomError,\n    PydanticOmit,\n    Url,\n    core_schema,\n)\nfrom typing_extensions import get_args, get_origin\n\nfrom pydantic.errors import PydanticSchemaGenerationError\nfrom pydantic.fields import FieldInfo\nfrom pydantic.types import Strict\n\nfrom ..config import ConfigDict\nfrom ..json_schema import JsonSchemaValue\nfrom . import _known_annotated_metadata, _typing_extra, _validators\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._schema_generation_shared import GetCoreSchemaHandler, GetJsonSchemaHandler\n\nif typing.TYPE_CHECKING:\n    from ._generate_schema import GenerateSchema\n\n    StdSchemaFunction = Callable[[GenerateSchema, type[Any]], core_schema.CoreSchema]\n\n\n@dataclasses.dataclass(**slots_true)\nclass SchemaTransformer:\n    get_core_schema: Callable[[Any, GetCoreSchemaHandler], CoreSchema]\n    get_json_schema: Callable[[CoreSchema, GetJsonSchemaHandler], JsonSchemaValue]\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        return self.get_core_schema(source_type, handler)\n\n    def __get_pydantic_json_schema__(self, schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n        return self.get_json_schema(schema, handler)\n\n\ndef get_enum_core_schema(enum_type: type[Enum], config: ConfigDict) -> CoreSchema:\n    cases: list[Any] = list(enum_type.__members__.values())\n\n    enum_ref = get_type_ref(enum_type)\n    description = None if not enum_type.__doc__ else inspect.cleandoc(enum_type.__doc__)\n    if description == 'An enumeration.':  # This is the default value provided by enum.EnumMeta.__new__; don't use it\n        description = None\n    js_updates = {'title': enum_type.__name__, 'description': description}\n    js_updates = {k: v for k, v in js_updates.items() if v is not None}\n\n    sub_type: Literal['str', 'int', 'float'] | None = None\n    if issubclass(enum_type, int):\n        sub_type = 'int'\n        value_ser_type: core_schema.SerSchema = core_schema.simple_ser_schema('int')\n    elif issubclass(enum_type, str):\n        # this handles `StrEnum` (3.11 only), and also `Foobar(str, Enum)`\n        sub_type = 'str'\n        value_ser_type = core_schema.simple_ser_schema('str')\n    elif issubclass(enum_type, float):\n        sub_type = 'float'\n        value_ser_type = core_schema.simple_ser_schema('float')\n    else:\n        # TODO this is an ugly hack, how do we trigger an Any schema for serialization?\n        value_ser_type = core_schema.plain_serializer_function_ser_schema(lambda x: x)\n\n    if cases:\n\n        def get_json_schema(schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n            json_schema = handler(schema)\n            original_schema = handler.resolve_ref_schema(json_schema)\n            original_schema.update(js_updates)\n            return json_schema\n\n        # we don't want to add the missing to the schema if it's the default one\n        default_missing = getattr(enum_type._missing_, '__func__', None) == Enum._missing_.__func__  # type: ignore\n        enum_schema = core_schema.enum_schema(\n            enum_type,\n            cases,\n            sub_type=sub_type,\n            missing=None if default_missing else enum_type._missing_,\n            ref=enum_ref,\n            metadata={'pydantic_js_functions': [get_json_schema]},\n        )\n\n        if config.get('use_enum_values', False):\n            enum_schema = core_schema.no_info_after_validator_function(\n                attrgetter('value'), enum_schema, serialization=value_ser_type\n            )\n\n        return enum_schema\n\n    else:\n\n        def get_json_schema_no_cases(_, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n            json_schema = handler(core_schema.enum_schema(enum_type, cases, sub_type=sub_type, ref=enum_ref))\n            original_schema = handler.resolve_ref_schema(json_schema)\n            original_schema.update(js_updates)\n            return json_schema\n\n        # Use an isinstance check for enums with no cases.\n        # The most important use case for this is creating TypeVar bounds for generics that should\n        # be restricted to enums. This is more consistent than it might seem at first, since you can only\n        # subclass enum.Enum (or subclasses of enum.Enum) if all parent classes have no cases.\n        # We use the get_json_schema function when an Enum subclass has been declared with no cases\n        # so that we can still generate a valid json schema.\n        return core_schema.is_instance_schema(\n            enum_type,\n            metadata={'pydantic_js_functions': [get_json_schema_no_cases]},\n        )\n\n\n@dataclasses.dataclass(**slots_true)\nclass InnerSchemaValidator:\n    \"\"\"Use a fixed CoreSchema, avoiding interference from outward annotations.\"\"\"\n\n    core_schema: CoreSchema\n    js_schema: JsonSchemaValue | None = None\n    js_core_schema: CoreSchema | None = None\n    js_schema_update: JsonSchemaValue | None = None\n\n    def __get_pydantic_json_schema__(self, _schema: CoreSchema, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n        if self.js_schema is not None:\n            return self.js_schema\n        js_schema = handler(self.js_core_schema or self.core_schema)\n        if self.js_schema_update is not None:\n            js_schema.update(self.js_schema_update)\n        return js_schema\n\n    def __get_pydantic_core_schema__(self, _source_type: Any, _handler: GetCoreSchemaHandler) -> CoreSchema:\n        return self.core_schema\n\n\ndef decimal_prepare_pydantic_annotations(\n    source: Any, annotations: Iterable[Any], config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    if source is not decimal.Decimal:\n        return None\n\n    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n\n    config_allow_inf_nan = config.get('allow_inf_nan')\n    if config_allow_inf_nan is not None:\n        metadata.setdefault('allow_inf_nan', config_allow_inf_nan)\n\n    _known_annotated_metadata.check_metadata(\n        metadata, {*_known_annotated_metadata.FLOAT_CONSTRAINTS, 'max_digits', 'decimal_places'}, decimal.Decimal\n    )\n    return source, [InnerSchemaValidator(core_schema.decimal_schema(**metadata)), *remaining_annotations]\n\n\ndef datetime_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    import datetime\n\n    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n    if source_type is datetime.date:\n        sv = InnerSchemaValidator(core_schema.date_schema(**metadata))\n    elif source_type is datetime.datetime:\n        sv = InnerSchemaValidator(core_schema.datetime_schema(**metadata))\n    elif source_type is datetime.time:\n        sv = InnerSchemaValidator(core_schema.time_schema(**metadata))\n    elif source_type is datetime.timedelta:\n        sv = InnerSchemaValidator(core_schema.timedelta_schema(**metadata))\n    else:\n        return None\n    # check now that we know the source type is correct\n    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.DATE_TIME_CONSTRAINTS, source_type)\n    return (source_type, [sv, *remaining_annotations])\n\n\ndef uuid_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    # UUIDs have no constraints - they are fixed length, constructing a UUID instance checks the length\n\n    from uuid import UUID\n\n    if source_type is not UUID:\n        return None\n\n    return (source_type, [InnerSchemaValidator(core_schema.uuid_schema()), *annotations])\n\n\ndef path_schema_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    import pathlib\n\n    if source_type not in {\n        os.PathLike,\n        pathlib.Path,\n        pathlib.PurePath,\n        pathlib.PosixPath,\n        pathlib.PurePosixPath,\n        pathlib.PureWindowsPath,\n    }:\n        return None\n\n    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.STR_CONSTRAINTS, source_type)\n\n    construct_path = pathlib.PurePath if source_type is os.PathLike else source_type\n\n    def path_validator(input_value: str) -> os.PathLike[Any]:\n        try:\n            return construct_path(input_value)\n        except TypeError as e:\n            raise PydanticCustomError('path_type', 'Input is not a valid path') from e\n\n    constrained_str_schema = core_schema.str_schema(**metadata)\n\n    instance_schema = core_schema.json_or_python_schema(\n        json_schema=core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),\n        python_schema=core_schema.is_instance_schema(source_type),\n    )\n\n    strict: bool | None = None\n    for annotation in annotations:\n        if isinstance(annotation, Strict):\n            strict = annotation.strict\n\n    schema = core_schema.lax_or_strict_schema(\n        lax_schema=core_schema.union_schema(\n            [\n                instance_schema,\n                core_schema.no_info_after_validator_function(path_validator, constrained_str_schema),\n            ],\n            custom_error_type='path_type',\n            custom_error_message='Input is not a valid path',\n            strict=True,\n        ),\n        strict_schema=instance_schema,\n        serialization=core_schema.to_string_ser_schema(),\n        strict=strict,\n    )\n\n    return (\n        source_type,\n        [\n            InnerSchemaValidator(schema, js_core_schema=constrained_str_schema, js_schema_update={'format': 'path'}),\n            *remaining_annotations,\n        ],\n    )\n\n\ndef dequeue_validator(\n    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, maxlen: None | int\n) -> collections.deque[Any]:\n    if isinstance(input_value, collections.deque):\n        maxlens = [v for v in (input_value.maxlen, maxlen) if v is not None]\n        if maxlens:\n            maxlen = min(maxlens)\n        return collections.deque(handler(input_value), maxlen=maxlen)\n    else:\n        return collections.deque(handler(input_value), maxlen=maxlen)\n\n\ndef serialize_sequence_via_list(\n    v: Any, handler: core_schema.SerializerFunctionWrapHandler, info: core_schema.SerializationInfo\n) -> Any:\n    items: list[Any] = []\n\n    mapped_origin = SEQUENCE_ORIGIN_MAP.get(type(v), None)\n    if mapped_origin is None:\n        # we shouldn't hit this branch, should probably add a serialization error or something\n        return v\n\n    for index, item in enumerate(v):\n        try:\n            v = handler(item, index)\n        except PydanticOmit:\n            pass\n        else:\n            items.append(v)\n\n    if info.mode_is_json():\n        return items\n    else:\n        return mapped_origin(items)\n\n\n@dataclasses.dataclass(**slots_true)\nclass SequenceValidator:\n    mapped_origin: type[Any]\n    item_source_type: type[Any]\n    min_length: int | None = None\n    max_length: int | None = None\n    strict: bool | None = None\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        if self.item_source_type is Any:\n            items_schema = None\n        else:\n            items_schema = handler.generate_schema(self.item_source_type)\n\n        metadata = {'min_length': self.min_length, 'max_length': self.max_length, 'strict': self.strict}\n\n        if self.mapped_origin in (list, set, frozenset):\n            if self.mapped_origin is list:\n                constrained_schema = core_schema.list_schema(items_schema, **metadata)\n            elif self.mapped_origin is set:\n                constrained_schema = core_schema.set_schema(items_schema, **metadata)\n            else:\n                assert self.mapped_origin is frozenset  # safety check in case we forget to add a case\n                constrained_schema = core_schema.frozenset_schema(items_schema, **metadata)\n\n            schema = constrained_schema\n        else:\n            # safety check in case we forget to add a case\n            assert self.mapped_origin in (collections.deque, collections.Counter)\n\n            if self.mapped_origin is collections.deque:\n                # if we have a MaxLen annotation might as well set that as the default maxlen on the deque\n                # this lets us re-use existing metadata annotations to let users set the maxlen on a dequeue\n                # that e.g. comes from JSON\n                coerce_instance_wrap = partial(\n                    core_schema.no_info_wrap_validator_function,\n                    partial(dequeue_validator, maxlen=metadata.get('max_length', None)),\n                )\n            else:\n                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)\n\n            # we have to use a lax list schema here, because we need to validate the deque's\n            # items via a list schema, but it's ok if the deque itself is not a list (same for Counter)\n            metadata_with_strict_override = {**metadata, 'strict': False}\n            constrained_schema = core_schema.list_schema(items_schema, **metadata_with_strict_override)\n\n            check_instance = core_schema.json_or_python_schema(\n                json_schema=core_schema.list_schema(),\n                python_schema=core_schema.is_instance_schema(self.mapped_origin),\n            )\n\n            serialization = core_schema.wrap_serializer_function_ser_schema(\n                serialize_sequence_via_list, schema=items_schema or core_schema.any_schema(), info_arg=True\n            )\n\n            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])\n\n            if metadata.get('strict', False):\n                schema = strict\n            else:\n                lax = coerce_instance_wrap(constrained_schema)\n                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)\n            schema['serialization'] = serialization\n\n        return schema\n\n\nSEQUENCE_ORIGIN_MAP: dict[Any, Any] = {\n    typing.Deque: collections.deque,\n    collections.deque: collections.deque,\n    list: list,\n    typing.List: list,\n    set: set,\n    typing.AbstractSet: set,\n    typing.Set: set,\n    frozenset: frozenset,\n    typing.FrozenSet: frozenset,\n    typing.Sequence: list,\n    typing.MutableSequence: list,\n    typing.MutableSet: set,\n    # this doesn't handle subclasses of these\n    # parametrized typing.Set creates one of these\n    collections.abc.MutableSet: set,\n    collections.abc.Set: frozenset,\n}\n\n\ndef identity(s: CoreSchema) -> CoreSchema:\n    return s\n\n\ndef sequence_like_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    origin: Any = get_origin(source_type)\n\n    mapped_origin = SEQUENCE_ORIGIN_MAP.get(origin, None) if origin else SEQUENCE_ORIGIN_MAP.get(source_type, None)\n    if mapped_origin is None:\n        return None\n\n    args = get_args(source_type)\n\n    if not args:\n        args = typing.cast(Tuple[Any], (Any,))\n    elif len(args) != 1:\n        raise ValueError('Expected sequence to have exactly 1 generic parameter')\n\n    item_source_type = args[0]\n\n    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)\n\n    return (source_type, [SequenceValidator(mapped_origin, item_source_type, **metadata), *remaining_annotations])\n\n\nMAPPING_ORIGIN_MAP: dict[Any, Any] = {\n    typing.DefaultDict: collections.defaultdict,\n    collections.defaultdict: collections.defaultdict,\n    collections.OrderedDict: collections.OrderedDict,\n    typing_extensions.OrderedDict: collections.OrderedDict,\n    dict: dict,\n    typing.Dict: dict,\n    collections.Counter: collections.Counter,\n    typing.Counter: collections.Counter,\n    # this doesn't handle subclasses of these\n    typing.Mapping: dict,\n    typing.MutableMapping: dict,\n    # parametrized typing.{Mutable}Mapping creates one of these\n    collections.abc.MutableMapping: dict,\n    collections.abc.Mapping: dict,\n}\n\n\ndef defaultdict_validator(\n    input_value: Any, handler: core_schema.ValidatorFunctionWrapHandler, default_default_factory: Callable[[], Any]\n) -> collections.defaultdict[Any, Any]:\n    if isinstance(input_value, collections.defaultdict):\n        default_factory = input_value.default_factory\n        return collections.defaultdict(default_factory, handler(input_value))\n    else:\n        return collections.defaultdict(default_default_factory, handler(input_value))\n\n\ndef get_defaultdict_default_default_factory(values_source_type: Any) -> Callable[[], Any]:\n    def infer_default() -> Callable[[], Any]:\n        allowed_default_types: dict[Any, Any] = {\n            typing.Tuple: tuple,\n            tuple: tuple,\n            collections.abc.Sequence: tuple,\n            collections.abc.MutableSequence: list,\n            typing.List: list,\n            list: list,\n            typing.Sequence: list,\n            typing.Set: set,\n            set: set,\n            typing.MutableSet: set,\n            collections.abc.MutableSet: set,\n            collections.abc.Set: frozenset,\n            typing.MutableMapping: dict,\n            typing.Mapping: dict,\n            collections.abc.Mapping: dict,\n            collections.abc.MutableMapping: dict,\n            float: float,\n            int: int,\n            str: str,\n            bool: bool,\n        }\n        values_type_origin = get_origin(values_source_type) or values_source_type\n        instructions = 'set using `DefaultDict[..., Annotated[..., Field(default_factory=...)]]`'\n        if isinstance(values_type_origin, TypeVar):\n\n            def type_var_default_factory() -> None:\n                raise RuntimeError(\n                    'Generic defaultdict cannot be used without a concrete value type or an'\n                    ' explicit default factory, ' + instructions\n                )\n\n            return type_var_default_factory\n        elif values_type_origin not in allowed_default_types:\n            # a somewhat subjective set of types that have reasonable default values\n            allowed_msg = ', '.join([t.__name__ for t in set(allowed_default_types.values())])\n            raise PydanticSchemaGenerationError(\n                f'Unable to infer a default factory for keys of type {values_source_type}.'\n                f' Only {allowed_msg} are supported, other types require an explicit default factory'\n                ' ' + instructions\n            )\n        return allowed_default_types[values_type_origin]\n\n    # Assume Annotated[..., Field(...)]\n    if _typing_extra.is_annotated(values_source_type):\n        field_info = next((v for v in get_args(values_source_type) if isinstance(v, FieldInfo)), None)\n    else:\n        field_info = None\n    if field_info and field_info.default_factory:\n        default_default_factory = field_info.default_factory\n    else:\n        default_default_factory = infer_default()\n    return default_default_factory\n\n\n@dataclasses.dataclass(**slots_true)\nclass MappingValidator:\n    mapped_origin: type[Any]\n    keys_source_type: type[Any]\n    values_source_type: type[Any]\n    min_length: int | None = None\n    max_length: int | None = None\n    strict: bool = False\n\n    def serialize_mapping_via_dict(self, v: Any, handler: core_schema.SerializerFunctionWrapHandler) -> Any:\n        return handler(v)\n\n    def __get_pydantic_core_schema__(self, source_type: Any, handler: GetCoreSchemaHandler) -> CoreSchema:\n        if self.keys_source_type is Any:\n            keys_schema = None\n        else:\n            keys_schema = handler.generate_schema(self.keys_source_type)\n        if self.values_source_type is Any:\n            values_schema = None\n        else:\n            values_schema = handler.generate_schema(self.values_source_type)\n\n        metadata = {'min_length': self.min_length, 'max_length': self.max_length, 'strict': self.strict}\n\n        if self.mapped_origin is dict:\n            schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)\n        else:\n            constrained_schema = core_schema.dict_schema(keys_schema, values_schema, **metadata)\n            check_instance = core_schema.json_or_python_schema(\n                json_schema=core_schema.dict_schema(),\n                python_schema=core_schema.is_instance_schema(self.mapped_origin),\n            )\n\n            if self.mapped_origin is collections.defaultdict:\n                default_default_factory = get_defaultdict_default_default_factory(self.values_source_type)\n                coerce_instance_wrap = partial(\n                    core_schema.no_info_wrap_validator_function,\n                    partial(defaultdict_validator, default_default_factory=default_default_factory),\n                )\n            else:\n                coerce_instance_wrap = partial(core_schema.no_info_after_validator_function, self.mapped_origin)\n\n            serialization = core_schema.wrap_serializer_function_ser_schema(\n                self.serialize_mapping_via_dict,\n                schema=core_schema.dict_schema(\n                    keys_schema or core_schema.any_schema(), values_schema or core_schema.any_schema()\n                ),\n                info_arg=False,\n            )\n\n            strict = core_schema.chain_schema([check_instance, coerce_instance_wrap(constrained_schema)])\n\n            if metadata.get('strict', False):\n                schema = strict\n            else:\n                lax = coerce_instance_wrap(constrained_schema)\n                schema = core_schema.lax_or_strict_schema(lax_schema=lax, strict_schema=strict)\n                schema['serialization'] = serialization\n\n        return schema\n\n\ndef mapping_like_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    origin: Any = get_origin(source_type)\n\n    mapped_origin = MAPPING_ORIGIN_MAP.get(origin, None) if origin else MAPPING_ORIGIN_MAP.get(source_type, None)\n    if mapped_origin is None:\n        return None\n\n    args = get_args(source_type)\n\n    if not args:\n        args = typing.cast(Tuple[Any, Any], (Any, Any))\n    elif mapped_origin is collections.Counter:\n        # a single generic\n        if len(args) != 1:\n            raise ValueError('Expected Counter to have exactly 1 generic parameter')\n        args = (args[0], int)  # keys are always an int\n    elif len(args) != 2:\n        raise ValueError('Expected mapping to have exactly 2 generic parameters')\n\n    keys_source_type, values_source_type = args\n\n    metadata, remaining_annotations = _known_annotated_metadata.collect_known_metadata(annotations)\n    _known_annotated_metadata.check_metadata(metadata, _known_annotated_metadata.SEQUENCE_CONSTRAINTS, source_type)\n\n    return (\n        source_type,\n        [\n            MappingValidator(mapped_origin, keys_source_type, values_source_type, **metadata),\n            *remaining_annotations,\n        ],\n    )\n\n\ndef ip_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    def make_strict_ip_schema(tp: type[Any]) -> CoreSchema:\n        return core_schema.json_or_python_schema(\n            json_schema=core_schema.no_info_after_validator_function(tp, core_schema.str_schema()),\n            python_schema=core_schema.is_instance_schema(tp),\n        )\n\n    if source_type is IPv4Address:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_address_validator),\n                    strict_schema=make_strict_ip_schema(IPv4Address),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv4'},\n            ),\n            *annotations,\n        ]\n    if source_type is IPv4Network:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_network_validator),\n                    strict_schema=make_strict_ip_schema(IPv4Network),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv4network'},\n            ),\n            *annotations,\n        ]\n    if source_type is IPv4Interface:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v4_interface_validator),\n                    strict_schema=make_strict_ip_schema(IPv4Interface),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv4interface'},\n            ),\n            *annotations,\n        ]\n\n    if source_type is IPv6Address:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_address_validator),\n                    strict_schema=make_strict_ip_schema(IPv6Address),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv6'},\n            ),\n            *annotations,\n        ]\n    if source_type is IPv6Network:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_network_validator),\n                    strict_schema=make_strict_ip_schema(IPv6Network),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv6network'},\n            ),\n            *annotations,\n        ]\n    if source_type is IPv6Interface:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.lax_or_strict_schema(\n                    lax_schema=core_schema.no_info_plain_validator_function(_validators.ip_v6_interface_validator),\n                    strict_schema=make_strict_ip_schema(IPv6Interface),\n                    serialization=core_schema.to_string_ser_schema(),\n                ),\n                lambda _1, _2: {'type': 'string', 'format': 'ipv6interface'},\n            ),\n            *annotations,\n        ]\n\n    return None\n\n\ndef url_prepare_pydantic_annotations(\n    source_type: Any, annotations: Iterable[Any], _config: ConfigDict\n) -> tuple[Any, list[Any]] | None:\n    if source_type is Url:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.url_schema(),\n                lambda cs, handler: handler(cs),\n            ),\n            *annotations,\n        ]\n    if source_type is MultiHostUrl:\n        return source_type, [\n            SchemaTransformer(\n                lambda _1, _2: core_schema.multi_host_url_schema(),\n                lambda cs, handler: handler(cs),\n            ),\n            *annotations,\n        ]\n\n\nPREPARE_METHODS: tuple[Callable[[Any, Iterable[Any], ConfigDict], tuple[Any, list[Any]] | None], ...] = (\n    decimal_prepare_pydantic_annotations,\n    sequence_like_prepare_pydantic_annotations,\n    datetime_prepare_pydantic_annotations,\n    uuid_prepare_pydantic_annotations,\n    path_schema_prepare_pydantic_annotations,\n    mapping_like_prepare_pydantic_annotations,\n    ip_prepare_pydantic_annotations,\n    url_prepare_pydantic_annotations,\n)\n", "pydantic/_internal/_typing_extra.py": "\"\"\"Logic for interacting with type annotations, mostly extensions, shims and hacks to wrap python's typing module.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport re\nimport sys\nimport types\nimport typing\nimport warnings\nfrom collections.abc import Callable\nfrom functools import partial\nfrom types import GetSetDescriptorType\nfrom typing import TYPE_CHECKING, Any, Final\n\nfrom typing_extensions import Annotated, Literal, TypeAliasType, TypeGuard, deprecated, get_args, get_origin\n\nif TYPE_CHECKING:\n    from ._dataclasses import StandardDataclass\n\ntry:\n    from typing import _TypingBase  # type: ignore[attr-defined]\nexcept ImportError:\n    from typing import _Final as _TypingBase  # type: ignore[attr-defined]\n\ntyping_base = _TypingBase\n\n\nif sys.version_info < (3, 9):\n    # python < 3.9 does not have GenericAlias (list[int], tuple[str, ...] and so on)\n    TypingGenericAlias = ()\nelse:\n    from typing import GenericAlias as TypingGenericAlias  # type: ignore\n\n\nif sys.version_info < (3, 11):\n    from typing_extensions import NotRequired, Required\nelse:\n    from typing import NotRequired, Required  # noqa: F401\n\n\nif sys.version_info < (3, 10):\n\n    def origin_is_union(tp: type[Any] | None) -> bool:\n        return tp is typing.Union\n\n    WithArgsTypes = (TypingGenericAlias,)\n\nelse:\n\n    def origin_is_union(tp: type[Any] | None) -> bool:\n        return tp is typing.Union or tp is types.UnionType\n\n    WithArgsTypes = typing._GenericAlias, types.GenericAlias, types.UnionType  # type: ignore[attr-defined]\n\n\nif sys.version_info < (3, 10):\n    NoneType = type(None)\n    EllipsisType = type(Ellipsis)\nelse:\n    from types import NoneType as NoneType\n\n\nLITERAL_TYPES: set[Any] = {Literal}\nif hasattr(typing, 'Literal'):\n    LITERAL_TYPES.add(typing.Literal)  # type: ignore\n\n# Check if `deprecated` is a type to prevent errors when using typing_extensions < 4.9.0\nDEPRECATED_TYPES: tuple[Any, ...] = (deprecated,) if isinstance(deprecated, type) else ()\nif hasattr(warnings, 'deprecated'):\n    DEPRECATED_TYPES = (*DEPRECATED_TYPES, warnings.deprecated)  # type: ignore\n\nNONE_TYPES: tuple[Any, ...] = (None, NoneType, *(tp[None] for tp in LITERAL_TYPES))\n\n\nTypeVarType = Any  # since mypy doesn't allow the use of TypeVar as a type\n\n\ndef is_none_type(type_: Any) -> bool:\n    return type_ in NONE_TYPES\n\n\ndef is_callable_type(type_: type[Any]) -> bool:\n    return type_ is Callable or get_origin(type_) is Callable\n\n\ndef is_literal_type(type_: type[Any]) -> bool:\n    return Literal is not None and get_origin(type_) in LITERAL_TYPES\n\n\ndef is_deprecated_instance(instance: Any) -> TypeGuard[deprecated]:\n    return isinstance(instance, DEPRECATED_TYPES)\n\n\ndef literal_values(type_: type[Any]) -> tuple[Any, ...]:\n    return get_args(type_)\n\n\ndef all_literal_values(type_: type[Any]) -> list[Any]:\n    \"\"\"This method is used to retrieve all Literal values as\n    Literal can be used recursively (see https://www.python.org/dev/peps/pep-0586)\n    e.g. `Literal[Literal[Literal[1, 2, 3], \"foo\"], 5, None]`.\n    \"\"\"\n    if not is_literal_type(type_):\n        return [type_]\n\n    values = literal_values(type_)\n    return list(x for value in values for x in all_literal_values(value))\n\n\ndef is_annotated(ann_type: Any) -> bool:\n    from ._utils import lenient_issubclass\n\n    origin = get_origin(ann_type)\n    return origin is not None and lenient_issubclass(origin, Annotated)\n\n\ndef annotated_type(type_: Any) -> Any | None:\n    return get_args(type_)[0] if is_annotated(type_) else None\n\n\ndef is_namedtuple(type_: type[Any]) -> bool:\n    \"\"\"Check if a given class is a named tuple.\n    It can be either a `typing.NamedTuple` or `collections.namedtuple`.\n    \"\"\"\n    from ._utils import lenient_issubclass\n\n    return lenient_issubclass(type_, tuple) and hasattr(type_, '_fields')\n\n\ntest_new_type = typing.NewType('test_new_type', str)\n\n\ndef is_new_type(type_: type[Any]) -> bool:\n    \"\"\"Check whether type_ was created using typing.NewType.\n\n    Can't use isinstance because it fails <3.10.\n    \"\"\"\n    return isinstance(type_, test_new_type.__class__) and hasattr(type_, '__supertype__')  # type: ignore[arg-type]\n\n\ndef _check_classvar(v: type[Any] | None) -> bool:\n    if v is None:\n        return False\n\n    return v.__class__ == typing.ClassVar.__class__ and getattr(v, '_name', None) == 'ClassVar'\n\n\ndef is_classvar(ann_type: type[Any]) -> bool:\n    if _check_classvar(ann_type) or _check_classvar(get_origin(ann_type)):\n        return True\n\n    # this is an ugly workaround for class vars that contain forward references and are therefore themselves\n    # forward references, see #3679\n    if ann_type.__class__ == typing.ForwardRef and re.match(\n        r'(\\w+\\.)?ClassVar\\[',\n        ann_type.__forward_arg__,  # type: ignore\n    ):\n        return True\n\n    return False\n\n\ndef _check_finalvar(v: type[Any] | None) -> bool:\n    \"\"\"Check if a given type is a `typing.Final` type.\"\"\"\n    if v is None:\n        return False\n\n    return v.__class__ == Final.__class__ and (sys.version_info < (3, 8) or getattr(v, '_name', None) == 'Final')\n\n\ndef is_finalvar(ann_type: Any) -> bool:\n    return _check_finalvar(ann_type) or _check_finalvar(get_origin(ann_type))\n\n\ndef parent_frame_namespace(*, parent_depth: int = 2) -> dict[str, Any] | None:\n    \"\"\"We allow use of items in parent namespace to get around the issue with `get_type_hints` only looking in the\n    global module namespace. See https://github.com/pydantic/pydantic/issues/2678#issuecomment-1008139014 -> Scope\n    and suggestion at the end of the next comment by @gvanrossum.\n\n    WARNING 1: it matters exactly where this is called. By default, this function will build a namespace from the\n    parent of where it is called.\n\n    WARNING 2: this only looks in the parent namespace, not other parents since (AFAIK) there's no way to collect a\n    dict of exactly what's in scope. Using `f_back` would work sometimes but would be very wrong and confusing in many\n    other cases. See https://discuss.python.org/t/is-there-a-way-to-access-parent-nested-namespaces/20659.\n    \"\"\"\n    frame = sys._getframe(parent_depth)\n    # if f_back is None, it's the global module namespace and we don't need to include it here\n    if frame.f_back is None:\n        return None\n    else:\n        return frame.f_locals\n\n\ndef add_module_globals(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:\n    module_name = getattr(obj, '__module__', None)\n    if module_name:\n        try:\n            module_globalns = sys.modules[module_name].__dict__\n        except KeyError:\n            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n            pass\n        else:\n            if globalns:\n                return {**module_globalns, **globalns}\n            else:\n                # copy module globals to make sure it can't be updated later\n                return module_globalns.copy()\n\n    return globalns or {}\n\n\ndef get_cls_types_namespace(cls: type[Any], parent_namespace: dict[str, Any] | None = None) -> dict[str, Any]:\n    ns = add_module_globals(cls, parent_namespace)\n    ns[cls.__name__] = cls\n    return ns\n\n\ndef get_cls_type_hints_lenient(obj: Any, globalns: dict[str, Any] | None = None) -> dict[str, Any]:\n    \"\"\"Collect annotations from a class, including those from parent classes.\n\n    Unlike `typing.get_type_hints`, this function will not error if a forward reference is not resolvable.\n    \"\"\"\n    hints = {}\n    for base in reversed(obj.__mro__):\n        ann = base.__dict__.get('__annotations__')\n        localns = dict(vars(base))\n        if ann is not None and ann is not GetSetDescriptorType:\n            for name, value in ann.items():\n                hints[name] = eval_type_lenient(value, globalns, localns)\n    return hints\n\n\ndef eval_type_lenient(value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None) -> Any:\n    \"\"\"Behaves like typing._eval_type, except it won't raise an error if a forward reference can't be resolved.\"\"\"\n    if value is None:\n        value = NoneType\n    elif isinstance(value, str):\n        value = _make_forward_ref(value, is_argument=False, is_class=True)\n\n    try:\n        return eval_type_backport(value, globalns, localns)\n    except NameError:\n        # the point of this function is to be tolerant to this case\n        return value\n\n\ndef eval_type_backport(\n    value: Any, globalns: dict[str, Any] | None = None, localns: dict[str, Any] | None = None\n) -> Any:\n    \"\"\"Like `typing._eval_type`, but falls back to the `eval_type_backport` package if it's\n    installed to let older Python versions use newer typing features.\n    Specifically, this transforms `X | Y` into `typing.Union[X, Y]`\n    and `list[X]` into `typing.List[X]` etc. (for all the types made generic in PEP 585)\n    if the original syntax is not supported in the current Python version.\n    \"\"\"\n    try:\n        return typing._eval_type(  # type: ignore\n            value, globalns, localns\n        )\n    except TypeError as e:\n        if not (isinstance(value, typing.ForwardRef) and is_backport_fixable_error(e)):\n            raise\n        try:\n            from eval_type_backport import eval_type_backport\n        except ImportError:\n            raise TypeError(\n                f'You have a type annotation {value.__forward_arg__!r} '\n                f'which makes use of newer typing features than are supported in your version of Python. '\n                f'To handle this error, you should either remove the use of new syntax '\n                f'or install the `eval_type_backport` package.'\n            ) from e\n\n        return eval_type_backport(value, globalns, localns, try_default=False)\n\n\ndef is_backport_fixable_error(e: TypeError) -> bool:\n    msg = str(e)\n    return msg.startswith('unsupported operand type(s) for |: ') or \"' object is not subscriptable\" in msg\n\n\ndef get_function_type_hints(\n    function: Callable[..., Any], *, include_keys: set[str] | None = None, types_namespace: dict[str, Any] | None = None\n) -> dict[str, Any]:\n    \"\"\"Like `typing.get_type_hints`, but doesn't convert `X` to `Optional[X]` if the default value is `None`, also\n    copes with `partial`.\n    \"\"\"\n    try:\n        if isinstance(function, partial):\n            annotations = function.func.__annotations__\n        else:\n            annotations = function.__annotations__\n    except AttributeError:\n        type_hints = get_type_hints(function)\n        if isinstance(function, type):\n            # `type[...]` is a callable, which returns an instance of itself.\n            # At some point, we might even look into the return type of `__new__`\n            # if it returns something else.\n            type_hints.setdefault('return', function)\n        return type_hints\n\n    globalns = add_module_globals(function)\n    type_hints = {}\n    for name, value in annotations.items():\n        if include_keys is not None and name not in include_keys:\n            continue\n        if value is None:\n            value = NoneType\n        elif isinstance(value, str):\n            value = _make_forward_ref(value)\n\n        type_hints[name] = eval_type_backport(value, globalns, types_namespace)\n\n    return type_hints\n\n\nif sys.version_info < (3, 9, 8) or (3, 10) <= sys.version_info < (3, 10, 1):\n\n    def _make_forward_ref(\n        arg: Any,\n        is_argument: bool = True,\n        *,\n        is_class: bool = False,\n    ) -> typing.ForwardRef:\n        \"\"\"Wrapper for ForwardRef that accounts for the `is_class` argument missing in older versions.\n        The `module` argument is omitted as it breaks <3.9.8, =3.10.0 and isn't used in the calls below.\n\n        See https://github.com/python/cpython/pull/28560 for some background.\n        The backport happened on 3.9.8, see:\n        https://github.com/pydantic/pydantic/discussions/6244#discussioncomment-6275458,\n        and on 3.10.1 for the 3.10 branch, see:\n        https://github.com/pydantic/pydantic/issues/6912\n\n        Implemented as EAFP with memory.\n        \"\"\"\n        return typing.ForwardRef(arg, is_argument)\n\nelse:\n    _make_forward_ref = typing.ForwardRef\n\n\nif sys.version_info >= (3, 10):\n    get_type_hints = typing.get_type_hints\n\nelse:\n    \"\"\"\n    For older versions of python, we have a custom implementation of `get_type_hints` which is a close as possible to\n    the implementation in CPython 3.10.8.\n    \"\"\"\n\n    @typing.no_type_check\n    def get_type_hints(  # noqa: C901\n        obj: Any,\n        globalns: dict[str, Any] | None = None,\n        localns: dict[str, Any] | None = None,\n        include_extras: bool = False,\n    ) -> dict[str, Any]:  # pragma: no cover\n        \"\"\"Taken verbatim from python 3.10.8 unchanged, except:\n        * type annotations of the function definition above.\n        * prefixing `typing.` where appropriate\n        * Use `_make_forward_ref` instead of `typing.ForwardRef` to handle the `is_class` argument.\n\n        https://github.com/python/cpython/blob/aaaf5174241496afca7ce4d4584570190ff972fe/Lib/typing.py#L1773-L1875\n\n        DO NOT CHANGE THIS METHOD UNLESS ABSOLUTELY NECESSARY.\n        ======================================================\n\n        Return type hints for an object.\n\n        This is often the same as obj.__annotations__, but it handles\n        forward references encoded as string literals, adds Optional[t] if a\n        default value equal to None is set and recursively replaces all\n        'Annotated[T, ...]' with 'T' (unless 'include_extras=True').\n\n        The argument may be a module, class, method, or function. The annotations\n        are returned as a dictionary. For classes, annotations include also\n        inherited members.\n\n        TypeError is raised if the argument is not of a type that can contain\n        annotations, and an empty dictionary is returned if no annotations are\n        present.\n\n        BEWARE -- the behavior of globalns and localns is counterintuitive\n        (unless you are familiar with how eval() and exec() work).  The\n        search order is locals first, then globals.\n\n        - If no dict arguments are passed, an attempt is made to use the\n          globals from obj (or the respective module's globals for classes),\n          and these are also used as the locals.  If the object does not appear\n          to have globals, an empty dictionary is used.  For classes, the search\n          order is globals first then locals.\n\n        - If one dict argument is passed, it is used for both globals and\n          locals.\n\n        - If two dict arguments are passed, they specify globals and\n          locals, respectively.\n        \"\"\"\n        if getattr(obj, '__no_type_check__', None):\n            return {}\n        # Classes require a special treatment.\n        if isinstance(obj, type):\n            hints = {}\n            for base in reversed(obj.__mro__):\n                if globalns is None:\n                    base_globals = getattr(sys.modules.get(base.__module__, None), '__dict__', {})\n                else:\n                    base_globals = globalns\n                ann = base.__dict__.get('__annotations__', {})\n                if isinstance(ann, types.GetSetDescriptorType):\n                    ann = {}\n                base_locals = dict(vars(base)) if localns is None else localns\n                if localns is None and globalns is None:\n                    # This is surprising, but required.  Before Python 3.10,\n                    # get_type_hints only evaluated the globalns of\n                    # a class.  To maintain backwards compatibility, we reverse\n                    # the globalns and localns order so that eval() looks into\n                    # *base_globals* first rather than *base_locals*.\n                    # This only affects ForwardRefs.\n                    base_globals, base_locals = base_locals, base_globals\n                for name, value in ann.items():\n                    if value is None:\n                        value = type(None)\n                    if isinstance(value, str):\n                        value = _make_forward_ref(value, is_argument=False, is_class=True)\n\n                    value = eval_type_backport(value, base_globals, base_locals)\n                    hints[name] = value\n            if not include_extras and hasattr(typing, '_strip_annotations'):\n                return {\n                    k: typing._strip_annotations(t)  # type: ignore\n                    for k, t in hints.items()\n                }\n            else:\n                return hints\n\n        if globalns is None:\n            if isinstance(obj, types.ModuleType):\n                globalns = obj.__dict__\n            else:\n                nsobj = obj\n                # Find globalns for the unwrapped object.\n                while hasattr(nsobj, '__wrapped__'):\n                    nsobj = nsobj.__wrapped__\n                globalns = getattr(nsobj, '__globals__', {})\n            if localns is None:\n                localns = globalns\n        elif localns is None:\n            localns = globalns\n        hints = getattr(obj, '__annotations__', None)\n        if hints is None:\n            # Return empty annotations for something that _could_ have them.\n            if isinstance(obj, typing._allowed_types):  # type: ignore\n                return {}\n            else:\n                raise TypeError(f'{obj!r} is not a module, class, method, ' 'or function.')\n        defaults = typing._get_defaults(obj)  # type: ignore\n        hints = dict(hints)\n        for name, value in hints.items():\n            if value is None:\n                value = type(None)\n            if isinstance(value, str):\n                # class-level forward refs were handled above, this must be either\n                # a module-level annotation or a function argument annotation\n\n                value = _make_forward_ref(\n                    value,\n                    is_argument=not isinstance(obj, types.ModuleType),\n                    is_class=False,\n                )\n            value = eval_type_backport(value, globalns, localns)\n            if name in defaults and defaults[name] is None:\n                value = typing.Optional[value]\n            hints[name] = value\n        return hints if include_extras else {k: typing._strip_annotations(t) for k, t in hints.items()}  # type: ignore\n\n\ndef is_dataclass(_cls: type[Any]) -> TypeGuard[type[StandardDataclass]]:\n    # The dataclasses.is_dataclass function doesn't seem to provide TypeGuard functionality,\n    # so I created this convenience function\n    return dataclasses.is_dataclass(_cls)\n\n\ndef origin_is_type_alias_type(origin: Any) -> TypeGuard[TypeAliasType]:\n    return isinstance(origin, TypeAliasType)\n\n\nif sys.version_info >= (3, 10):\n\n    def is_generic_alias(type_: type[Any]) -> bool:\n        return isinstance(type_, (types.GenericAlias, typing._GenericAlias))  # type: ignore[attr-defined]\n\nelse:\n\n    def is_generic_alias(type_: type[Any]) -> bool:\n        return isinstance(type_, typing._GenericAlias)  # type: ignore\n\n\ndef is_self_type(tp: Any) -> bool:\n    \"\"\"Check if a given class is a Self type (from `typing` or `typing_extensions`)\"\"\"\n    return isinstance(tp, typing_base) and getattr(tp, '_name', None) == 'Self'\n", "pydantic/_internal/_schema_generation_shared.py": "\"\"\"Types and utility functions used by various other internal tools.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Literal\n\nfrom ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\n\nif TYPE_CHECKING:\n    from ..json_schema import GenerateJsonSchema, JsonSchemaValue\n    from ._core_utils import CoreSchemaOrField\n    from ._generate_schema import GenerateSchema\n\n    GetJsonSchemaFunction = Callable[[CoreSchemaOrField, GetJsonSchemaHandler], JsonSchemaValue]\n    HandlerOverride = Callable[[CoreSchemaOrField], JsonSchemaValue]\n\n\nclass GenerateJsonSchemaHandler(GetJsonSchemaHandler):\n    \"\"\"JsonSchemaHandler implementation that doesn't do ref unwrapping by default.\n\n    This is used for any Annotated metadata so that we don't end up with conflicting\n    modifications to the definition schema.\n\n    Used internally by Pydantic, please do not rely on this implementation.\n    See `GetJsonSchemaHandler` for the handler API.\n    \"\"\"\n\n    def __init__(self, generate_json_schema: GenerateJsonSchema, handler_override: HandlerOverride | None) -> None:\n        self.generate_json_schema = generate_json_schema\n        self.handler = handler_override or generate_json_schema.generate_inner\n        self.mode = generate_json_schema.mode\n\n    def __call__(self, core_schema: CoreSchemaOrField, /) -> JsonSchemaValue:\n        return self.handler(core_schema)\n\n    def resolve_ref_schema(self, maybe_ref_json_schema: JsonSchemaValue) -> JsonSchemaValue:\n        \"\"\"Resolves `$ref` in the json schema.\n\n        This returns the input json schema if there is no `$ref` in json schema.\n\n        Args:\n            maybe_ref_json_schema: The input json schema that may contains `$ref`.\n\n        Returns:\n            Resolved json schema.\n\n        Raises:\n            LookupError: If it can't find the definition for `$ref`.\n        \"\"\"\n        if '$ref' not in maybe_ref_json_schema:\n            return maybe_ref_json_schema\n        ref = maybe_ref_json_schema['$ref']\n        json_schema = self.generate_json_schema.get_schema_from_definitions(ref)\n        if json_schema is None:\n            raise LookupError(\n                f'Could not find a ref for {ref}.'\n                ' Maybe you tried to call resolve_ref_schema from within a recursive model?'\n            )\n        return json_schema\n\n\nclass CallbackGetCoreSchemaHandler(GetCoreSchemaHandler):\n    \"\"\"Wrapper to use an arbitrary function as a `GetCoreSchemaHandler`.\n\n    Used internally by Pydantic, please do not rely on this implementation.\n    See `GetCoreSchemaHandler` for the handler API.\n    \"\"\"\n\n    def __init__(\n        self,\n        handler: Callable[[Any], core_schema.CoreSchema],\n        generate_schema: GenerateSchema,\n        ref_mode: Literal['to-def', 'unpack'] = 'to-def',\n    ) -> None:\n        self._handler = handler\n        self._generate_schema = generate_schema\n        self._ref_mode = ref_mode\n\n    def __call__(self, source_type: Any, /) -> core_schema.CoreSchema:\n        schema = self._handler(source_type)\n        ref = schema.get('ref')\n        if self._ref_mode == 'to-def':\n            if ref is not None:\n                self._generate_schema.defs.definitions[ref] = schema\n                return core_schema.definition_reference_schema(ref)\n            return schema\n        else:  # ref_mode = 'unpack\n            return self.resolve_ref_schema(schema)\n\n    def _get_types_namespace(self) -> dict[str, Any] | None:\n        return self._generate_schema._types_namespace\n\n    def generate_schema(self, source_type: Any, /) -> core_schema.CoreSchema:\n        return self._generate_schema.generate_schema(source_type)\n\n    @property\n    def field_name(self) -> str | None:\n        return self._generate_schema.field_name_stack.get()\n\n    def resolve_ref_schema(self, maybe_ref_schema: core_schema.CoreSchema) -> core_schema.CoreSchema:\n        \"\"\"Resolves reference in the core schema.\n\n        Args:\n            maybe_ref_schema: The input core schema that may contains reference.\n\n        Returns:\n            Resolved core schema.\n\n        Raises:\n            LookupError: If it can't find the definition for reference.\n        \"\"\"\n        if maybe_ref_schema['type'] == 'definition-ref':\n            ref = maybe_ref_schema['schema_ref']\n            if ref not in self._generate_schema.defs.definitions:\n                raise LookupError(\n                    f'Could not find a ref for {ref}.'\n                    ' Maybe you tried to call resolve_ref_schema from within a recursive model?'\n                )\n            return self._generate_schema.defs.definitions[ref]\n        elif maybe_ref_schema['type'] == 'definitions':\n            return self.resolve_ref_schema(maybe_ref_schema['schema'])\n        return maybe_ref_schema\n", "pydantic/_internal/_validators.py": "\"\"\"Validator functions for standard library types.\n\nImport of this module is deferred since it contains imports of many standard library modules.\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport math\nimport re\nimport typing\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom typing import Any\n\nfrom pydantic_core import PydanticCustomError, core_schema\nfrom pydantic_core._pydantic_core import PydanticKnownError\n\n\ndef sequence_validator(\n    input_value: typing.Sequence[Any],\n    /,\n    validator: core_schema.ValidatorFunctionWrapHandler,\n) -> typing.Sequence[Any]:\n    \"\"\"Validator for `Sequence` types, isinstance(v, Sequence) has already been called.\"\"\"\n    value_type = type(input_value)\n\n    # We don't accept any plain string as a sequence\n    # Relevant issue: https://github.com/pydantic/pydantic/issues/5595\n    if issubclass(value_type, (str, bytes)):\n        raise PydanticCustomError(\n            'sequence_str',\n            \"'{type_name}' instances are not allowed as a Sequence value\",\n            {'type_name': value_type.__name__},\n        )\n\n    # TODO: refactor sequence validation to validate with either a list or a tuple\n    # schema, depending on the type of the value.\n    # Additionally, we should be able to remove one of either this validator or the\n    # SequenceValidator in _std_types_schema.py (preferably this one, while porting over some logic).\n    # Effectively, a refactor for sequence validation is needed.\n    if value_type == tuple:\n        input_value = list(input_value)\n\n    v_list = validator(input_value)\n\n    # the rest of the logic is just re-creating the original type from `v_list`\n    if value_type == list:\n        return v_list\n    elif issubclass(value_type, range):\n        # return the list as we probably can't re-create the range\n        return v_list\n    elif value_type == tuple:\n        return tuple(v_list)\n    else:\n        # best guess at how to re-create the original type, more custom construction logic might be required\n        return value_type(v_list)  # type: ignore[call-arg]\n\n\ndef import_string(value: Any) -> Any:\n    if isinstance(value, str):\n        try:\n            return _import_string_logic(value)\n        except ImportError as e:\n            raise PydanticCustomError('import_error', 'Invalid python path: {error}', {'error': str(e)}) from e\n    else:\n        # otherwise we just return the value and let the next validator do the rest of the work\n        return value\n\n\ndef _import_string_logic(dotted_path: str) -> Any:\n    \"\"\"Inspired by uvicorn \u2014 dotted paths should include a colon before the final item if that item is not a module.\n    (This is necessary to distinguish between a submodule and an attribute when there is a conflict.).\n\n    If the dotted path does not include a colon and the final item is not a valid module, importing as an attribute\n    rather than a submodule will be attempted automatically.\n\n    So, for example, the following values of `dotted_path` result in the following returned values:\n    * 'collections': <module 'collections'>\n    * 'collections.abc': <module 'collections.abc'>\n    * 'collections.abc:Mapping': <class 'collections.abc.Mapping'>\n    * `collections.abc.Mapping`: <class 'collections.abc.Mapping'> (though this is a bit slower than the previous line)\n\n    An error will be raised under any of the following scenarios:\n    * `dotted_path` contains more than one colon (e.g., 'collections:abc:Mapping')\n    * the substring of `dotted_path` before the colon is not a valid module in the environment (e.g., '123:Mapping')\n    * the substring of `dotted_path` after the colon is not an attribute of the module (e.g., 'collections:abc123')\n    \"\"\"\n    from importlib import import_module\n\n    components = dotted_path.strip().split(':')\n    if len(components) > 2:\n        raise ImportError(f\"Import strings should have at most one ':'; received {dotted_path!r}\")\n\n    module_path = components[0]\n    if not module_path:\n        raise ImportError(f'Import strings should have a nonempty module name; received {dotted_path!r}')\n\n    try:\n        module = import_module(module_path)\n    except ModuleNotFoundError as e:\n        if '.' in module_path:\n            # Check if it would be valid if the final item was separated from its module with a `:`\n            maybe_module_path, maybe_attribute = dotted_path.strip().rsplit('.', 1)\n            try:\n                return _import_string_logic(f'{maybe_module_path}:{maybe_attribute}')\n            except ImportError:\n                pass\n            raise ImportError(f'No module named {module_path!r}') from e\n        raise e\n\n    if len(components) > 1:\n        attribute = components[1]\n        try:\n            return getattr(module, attribute)\n        except AttributeError as e:\n            raise ImportError(f'cannot import name {attribute!r} from {module_path!r}') from e\n    else:\n        return module\n\n\ndef pattern_either_validator(input_value: Any, /) -> typing.Pattern[Any]:\n    if isinstance(input_value, typing.Pattern):\n        return input_value\n    elif isinstance(input_value, (str, bytes)):\n        # todo strict mode\n        return compile_pattern(input_value)  # type: ignore\n    else:\n        raise PydanticCustomError('pattern_type', 'Input should be a valid pattern')\n\n\ndef pattern_str_validator(input_value: Any, /) -> typing.Pattern[str]:\n    if isinstance(input_value, typing.Pattern):\n        if isinstance(input_value.pattern, str):\n            return input_value\n        else:\n            raise PydanticCustomError('pattern_str_type', 'Input should be a string pattern')\n    elif isinstance(input_value, str):\n        return compile_pattern(input_value)\n    elif isinstance(input_value, bytes):\n        raise PydanticCustomError('pattern_str_type', 'Input should be a string pattern')\n    else:\n        raise PydanticCustomError('pattern_type', 'Input should be a valid pattern')\n\n\ndef pattern_bytes_validator(input_value: Any, /) -> typing.Pattern[bytes]:\n    if isinstance(input_value, typing.Pattern):\n        if isinstance(input_value.pattern, bytes):\n            return input_value\n        else:\n            raise PydanticCustomError('pattern_bytes_type', 'Input should be a bytes pattern')\n    elif isinstance(input_value, bytes):\n        return compile_pattern(input_value)\n    elif isinstance(input_value, str):\n        raise PydanticCustomError('pattern_bytes_type', 'Input should be a bytes pattern')\n    else:\n        raise PydanticCustomError('pattern_type', 'Input should be a valid pattern')\n\n\nPatternType = typing.TypeVar('PatternType', str, bytes)\n\n\ndef compile_pattern(pattern: PatternType) -> typing.Pattern[PatternType]:\n    try:\n        return re.compile(pattern)\n    except re.error:\n        raise PydanticCustomError('pattern_regex', 'Input should be a valid regular expression')\n\n\ndef ip_v4_address_validator(input_value: Any, /) -> IPv4Address:\n    if isinstance(input_value, IPv4Address):\n        return input_value\n\n    try:\n        return IPv4Address(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v4_address', 'Input is not a valid IPv4 address')\n\n\ndef ip_v6_address_validator(input_value: Any, /) -> IPv6Address:\n    if isinstance(input_value, IPv6Address):\n        return input_value\n\n    try:\n        return IPv6Address(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v6_address', 'Input is not a valid IPv6 address')\n\n\ndef ip_v4_network_validator(input_value: Any, /) -> IPv4Network:\n    \"\"\"Assume IPv4Network initialised with a default `strict` argument.\n\n    See more:\n    https://docs.python.org/library/ipaddress.html#ipaddress.IPv4Network\n    \"\"\"\n    if isinstance(input_value, IPv4Network):\n        return input_value\n\n    try:\n        return IPv4Network(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v4_network', 'Input is not a valid IPv4 network')\n\n\ndef ip_v6_network_validator(input_value: Any, /) -> IPv6Network:\n    \"\"\"Assume IPv6Network initialised with a default `strict` argument.\n\n    See more:\n    https://docs.python.org/library/ipaddress.html#ipaddress.IPv6Network\n    \"\"\"\n    if isinstance(input_value, IPv6Network):\n        return input_value\n\n    try:\n        return IPv6Network(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v6_network', 'Input is not a valid IPv6 network')\n\n\ndef ip_v4_interface_validator(input_value: Any, /) -> IPv4Interface:\n    if isinstance(input_value, IPv4Interface):\n        return input_value\n\n    try:\n        return IPv4Interface(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v4_interface', 'Input is not a valid IPv4 interface')\n\n\ndef ip_v6_interface_validator(input_value: Any, /) -> IPv6Interface:\n    if isinstance(input_value, IPv6Interface):\n        return input_value\n\n    try:\n        return IPv6Interface(input_value)\n    except ValueError:\n        raise PydanticCustomError('ip_v6_interface', 'Input is not a valid IPv6 interface')\n\n\ndef greater_than_validator(x: Any, gt: Any) -> Any:\n    if not (x > gt):\n        raise PydanticKnownError('greater_than', {'gt': gt})\n    return x\n\n\ndef greater_than_or_equal_validator(x: Any, ge: Any) -> Any:\n    if not (x >= ge):\n        raise PydanticKnownError('greater_than_equal', {'ge': ge})\n    return x\n\n\ndef less_than_validator(x: Any, lt: Any) -> Any:\n    if not (x < lt):\n        raise PydanticKnownError('less_than', {'lt': lt})\n    return x\n\n\ndef less_than_or_equal_validator(x: Any, le: Any) -> Any:\n    if not (x <= le):\n        raise PydanticKnownError('less_than_equal', {'le': le})\n    return x\n\n\ndef multiple_of_validator(x: Any, multiple_of: Any) -> Any:\n    if not (x % multiple_of == 0):\n        raise PydanticKnownError('multiple_of', {'multiple_of': multiple_of})\n    return x\n\n\ndef min_length_validator(x: Any, min_length: Any) -> Any:\n    if not (len(x) >= min_length):\n        raise PydanticKnownError(\n            'too_short',\n            {'field_type': 'Value', 'min_length': min_length, 'actual_length': len(x)},\n        )\n    return x\n\n\ndef max_length_validator(x: Any, max_length: Any) -> Any:\n    if len(x) > max_length:\n        raise PydanticKnownError(\n            'too_long',\n            {'field_type': 'Value', 'max_length': max_length, 'actual_length': len(x)},\n        )\n    return x\n\n\ndef forbid_inf_nan_check(x: Any) -> Any:\n    if not math.isfinite(x):\n        raise PydanticKnownError('finite_number')\n    return x\n", "pydantic/_internal/_forward_ref.py": "from __future__ import annotations as _annotations\n\nfrom dataclasses import dataclass\nfrom typing import Union\n\n\n@dataclass\nclass PydanticRecursiveRef:\n    type_ref: str\n\n    __name__ = 'PydanticRecursiveRef'\n    __hash__ = object.__hash__\n\n    def __call__(self) -> None:\n        \"\"\"Defining __call__ is necessary for the `typing` module to let you use an instance of\n        this class as the result of resolving a standard ForwardRef.\n        \"\"\"\n\n    def __or__(self, other):\n        return Union[self, other]  # type: ignore\n\n    def __ror__(self, other):\n        return Union[other, self]  # type: ignore\n", "pydantic/_internal/_decorators_v1.py": "\"\"\"Logic for V1 validators, e.g. `@validator` and `@root_validator`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom inspect import Parameter, signature\nfrom typing import Any, Dict, Tuple, Union, cast\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import Protocol\n\nfrom ..errors import PydanticUserError\nfrom ._decorators import can_be_positional\n\n\nclass V1OnlyValueValidator(Protocol):\n    \"\"\"A simple validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any) -> Any: ...\n\n\nclass V1ValidatorWithValues(Protocol):\n    \"\"\"A validator with `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithValuesKwOnly(Protocol):\n    \"\"\"A validator with keyword only `values` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, *, values: dict[str, Any]) -> Any: ...\n\n\nclass V1ValidatorWithKwargs(Protocol):\n    \"\"\"A validator with `kwargs` argument, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, **kwargs: Any) -> Any: ...\n\n\nclass V1ValidatorWithValuesAndKwargs(Protocol):\n    \"\"\"A validator with `values` and `kwargs` arguments, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __value: Any, values: dict[str, Any], **kwargs: Any) -> Any: ...\n\n\nV1Validator = Union[\n    V1ValidatorWithValues, V1ValidatorWithValuesKwOnly, V1ValidatorWithKwargs, V1ValidatorWithValuesAndKwargs\n]\n\n\ndef can_be_keyword(param: Parameter) -> bool:\n    return param.kind in (Parameter.POSITIONAL_OR_KEYWORD, Parameter.KEYWORD_ONLY)\n\n\ndef make_generic_v1_field_validator(validator: V1Validator) -> core_schema.WithInfoValidatorFunction:\n    \"\"\"Wrap a V1 style field validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n\n    Returns:\n        A wrapped V2 style field validator.\n\n    Raises:\n        PydanticUserError: If the signature is not supported or the parameters are\n            not available in Pydantic V2.\n    \"\"\"\n    sig = signature(validator)\n\n    needs_values_kw = False\n\n    for param_num, (param_name, parameter) in enumerate(sig.parameters.items()):\n        if can_be_keyword(parameter) and param_name in ('field', 'config'):\n            raise PydanticUserError(\n                'The `field` and `config` parameters are not available in Pydantic V2, '\n                'please use the `info` parameter instead.',\n                code='validator-field-config-info',\n            )\n        if parameter.kind is Parameter.VAR_KEYWORD:\n            needs_values_kw = True\n        elif can_be_keyword(parameter) and param_name == 'values':\n            needs_values_kw = True\n        elif can_be_positional(parameter) and param_num == 0:\n            # value\n            continue\n        elif parameter.default is Parameter.empty:  # ignore params with defaults e.g. bound by functools.partial\n            raise PydanticUserError(\n                f'Unsupported signature for V1 style validator {validator}: {sig} is not supported.',\n                code='validator-v1-signature',\n            )\n\n    if needs_values_kw:\n        # (v, **kwargs), (v, values, **kwargs), (v, *, values, **kwargs) or (v, *, values)\n        val1 = cast(V1ValidatorWithValues, validator)\n\n        def wrapper1(value: Any, info: core_schema.ValidationInfo) -> Any:\n            return val1(value, values=info.data)\n\n        return wrapper1\n    else:\n        val2 = cast(V1OnlyValueValidator, validator)\n\n        def wrapper2(value: Any, _: core_schema.ValidationInfo) -> Any:\n            return val2(value)\n\n        return wrapper2\n\n\nRootValidatorValues = Dict[str, Any]\n# technically tuple[model_dict, model_extra, fields_set] | tuple[dataclass_dict, init_vars]\nRootValidatorFieldsTuple = Tuple[Any, ...]\n\n\nclass V1RootValidatorFunction(Protocol):\n    \"\"\"A simple root validator, supported for V1 validators and V2 validators.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues) -> RootValidatorValues: ...\n\n\nclass V2CoreBeforeRootValidator(Protocol):\n    \"\"\"V2 validator with mode='before'.\"\"\"\n\n    def __call__(self, __values: RootValidatorValues, __info: core_schema.ValidationInfo) -> RootValidatorValues: ...\n\n\nclass V2CoreAfterRootValidator(Protocol):\n    \"\"\"V2 validator with mode='after'.\"\"\"\n\n    def __call__(\n        self, __fields_tuple: RootValidatorFieldsTuple, __info: core_schema.ValidationInfo\n    ) -> RootValidatorFieldsTuple: ...\n\n\ndef make_v1_generic_root_validator(\n    validator: V1RootValidatorFunction, pre: bool\n) -> V2CoreBeforeRootValidator | V2CoreAfterRootValidator:\n    \"\"\"Wrap a V1 style root validator for V2 compatibility.\n\n    Args:\n        validator: The V1 style field validator.\n        pre: Whether the validator is a pre validator.\n\n    Returns:\n        A wrapped V2 style validator.\n    \"\"\"\n    if pre is True:\n        # mode='before' for pydantic-core\n        def _wrapper1(values: RootValidatorValues, _: core_schema.ValidationInfo) -> RootValidatorValues:\n            return validator(values)\n\n        return _wrapper1\n\n    # mode='after' for pydantic-core\n    def _wrapper2(fields_tuple: RootValidatorFieldsTuple, _: core_schema.ValidationInfo) -> RootValidatorFieldsTuple:\n        if len(fields_tuple) == 2:\n            # dataclass, this is easy\n            values, init_vars = fields_tuple\n            values = validator(values)\n            return values, init_vars\n        else:\n            # ugly hack: to match v1 behaviour, we merge values and model_extra, then split them up based on fields\n            # afterwards\n            model_dict, model_extra, fields_set = fields_tuple\n            if model_extra:\n                fields = set(model_dict.keys())\n                model_dict.update(model_extra)\n                model_dict_new = validator(model_dict)\n                for k in list(model_dict_new.keys()):\n                    if k not in fields:\n                        model_extra[k] = model_dict_new.pop(k)\n            else:\n                model_dict_new = validator(model_dict)\n            return model_dict_new, model_extra, fields_set\n\n    return _wrapper2\n", "pydantic/_internal/_mock_val_ser.py": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any, Callable, Generic, Iterator, Mapping, TypeVar\n\nfrom pydantic_core import CoreSchema, SchemaSerializer, SchemaValidator\nfrom typing_extensions import Literal\n\nfrom ..errors import PydanticErrorCodes, PydanticUserError\n\nif TYPE_CHECKING:\n    from ..dataclasses import PydanticDataclass\n    from ..main import BaseModel\n\n\nValSer = TypeVar('ValSer', SchemaValidator, SchemaSerializer)\nT = TypeVar('T')\n\n\nclass MockCoreSchema(Mapping[str, Any]):\n    \"\"\"Mocker for `pydantic_core.CoreSchema` which optionally attempts to\n    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n    \"\"\"\n\n    __slots__ = '_error_message', '_code', '_attempt_rebuild', '_built_memo'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        attempt_rebuild: Callable[[], CoreSchema | None] | None = None,\n    ) -> None:\n        self._error_message = error_message\n        self._code: PydanticErrorCodes = code\n        self._attempt_rebuild = attempt_rebuild\n        self._built_memo: CoreSchema | None = None\n\n    def __getitem__(self, key: str) -> Any:\n        return self._get_built().__getitem__(key)\n\n    def __len__(self) -> int:\n        return self._get_built().__len__()\n\n    def __iter__(self) -> Iterator[str]:\n        return self._get_built().__iter__()\n\n    def _get_built(self) -> CoreSchema:\n        if self._built_memo is not None:\n            return self._built_memo\n\n        if self._attempt_rebuild:\n            schema = self._attempt_rebuild()\n            if schema is not None:\n                self._built_memo = schema\n                return schema\n        raise PydanticUserError(self._error_message, code=self._code)\n\n    def rebuild(self) -> CoreSchema | None:\n        self._built_memo = None\n        if self._attempt_rebuild:\n            val_ser = self._attempt_rebuild()\n            if val_ser is not None:\n                return val_ser\n            else:\n                raise PydanticUserError(self._error_message, code=self._code)\n        return None\n\n\nclass MockValSer(Generic[ValSer]):\n    \"\"\"Mocker for `pydantic_core.SchemaValidator` or `pydantic_core.SchemaSerializer` which optionally attempts to\n    rebuild the thing it's mocking when one of its methods is accessed and raises an error if that fails.\n    \"\"\"\n\n    __slots__ = '_error_message', '_code', '_val_or_ser', '_attempt_rebuild'\n\n    def __init__(\n        self,\n        error_message: str,\n        *,\n        code: PydanticErrorCodes,\n        val_or_ser: Literal['validator', 'serializer'],\n        attempt_rebuild: Callable[[], ValSer | None] | None = None,\n    ) -> None:\n        self._error_message = error_message\n        self._val_or_ser = SchemaValidator if val_or_ser == 'validator' else SchemaSerializer\n        self._code: PydanticErrorCodes = code\n        self._attempt_rebuild = attempt_rebuild\n\n    def __getattr__(self, item: str) -> None:\n        __tracebackhide__ = True\n        if self._attempt_rebuild:\n            val_ser = self._attempt_rebuild()\n            if val_ser is not None:\n                return getattr(val_ser, item)\n\n        # raise an AttributeError if `item` doesn't exist\n        getattr(self._val_or_ser, item)\n        raise PydanticUserError(self._error_message, code=self._code)\n\n    def rebuild(self) -> ValSer | None:\n        if self._attempt_rebuild:\n            val_ser = self._attempt_rebuild()\n            if val_ser is not None:\n                return val_ser\n            else:\n                raise PydanticUserError(self._error_message, code=self._code)\n        return None\n\n\ndef set_model_mocks(cls: type[BaseModel], cls_name: str, undefined_name: str = 'all referenced types') -> None:\n    \"\"\"Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a model.\n\n    Args:\n        cls: The model class to set the mocks on\n        cls_name: Name of the model class, used in error messages\n        undefined_name: Name of the undefined thing, used in error messages\n    \"\"\"\n    undefined_type_error_message = (\n        f'`{cls_name}` is not fully defined; you should define {undefined_name},'\n        f' then call `{cls_name}.model_rebuild()`.'\n    )\n\n    def attempt_rebuild_fn(attr_fn: Callable[[type[BaseModel]], T]) -> Callable[[], T | None]:\n        def handler() -> T | None:\n            if cls.model_rebuild(raise_errors=False, _parent_namespace_depth=5) is not False:\n                return attr_fn(cls)\n            else:\n                return None\n\n        return handler\n\n    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),\n    )\n    cls.__pydantic_validator__ = MockValSer(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        val_or_ser='validator',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),\n    )\n    cls.__pydantic_serializer__ = MockValSer(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        val_or_ser='serializer',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),\n    )\n\n\ndef set_dataclass_mocks(\n    cls: type[PydanticDataclass], cls_name: str, undefined_name: str = 'all referenced types'\n) -> None:\n    \"\"\"Set `__pydantic_validator__` and `__pydantic_serializer__` to `MockValSer`s on a dataclass.\n\n    Args:\n        cls: The model class to set the mocks on\n        cls_name: Name of the model class, used in error messages\n        undefined_name: Name of the undefined thing, used in error messages\n    \"\"\"\n    from ..dataclasses import rebuild_dataclass\n\n    undefined_type_error_message = (\n        f'`{cls_name}` is not fully defined; you should define {undefined_name},'\n        f' then call `pydantic.dataclasses.rebuild_dataclass({cls_name})`.'\n    )\n\n    def attempt_rebuild_fn(attr_fn: Callable[[type[PydanticDataclass]], T]) -> Callable[[], T | None]:\n        def handler() -> T | None:\n            if rebuild_dataclass(cls, raise_errors=False, _parent_namespace_depth=5) is not False:\n                return attr_fn(cls)\n            else:\n                return None\n\n        return handler\n\n    cls.__pydantic_core_schema__ = MockCoreSchema(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_core_schema__),\n    )\n    cls.__pydantic_validator__ = MockValSer(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        val_or_ser='validator',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_validator__),\n    )\n    cls.__pydantic_serializer__ = MockValSer(  # type: ignore[assignment]\n        undefined_type_error_message,\n        code='class-not-fully-defined',\n        val_or_ser='validator',\n        attempt_rebuild=attempt_rebuild_fn(lambda c: c.__pydantic_serializer__),\n    )\n", "pydantic/_internal/_core_utils.py": "from __future__ import annotations\n\nimport os\nfrom collections import defaultdict\nfrom typing import (\n    Any,\n    Callable,\n    Hashable,\n    TypeVar,\n    Union,\n)\n\nfrom pydantic_core import CoreSchema, core_schema\nfrom pydantic_core import validate_core_schema as _validate_core_schema\nfrom typing_extensions import TypeAliasType, TypeGuard, get_args, get_origin\n\nfrom . import _repr\nfrom ._typing_extra import is_generic_alias\n\nAnyFunctionSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n    core_schema.PlainValidatorFunctionSchema,\n]\n\n\nFunctionSchemaWithInnerSchema = Union[\n    core_schema.AfterValidatorFunctionSchema,\n    core_schema.BeforeValidatorFunctionSchema,\n    core_schema.WrapValidatorFunctionSchema,\n]\n\nCoreSchemaField = Union[\n    core_schema.ModelField, core_schema.DataclassField, core_schema.TypedDictField, core_schema.ComputedField\n]\nCoreSchemaOrField = Union[core_schema.CoreSchema, CoreSchemaField]\n\n_CORE_SCHEMA_FIELD_TYPES = {'typed-dict-field', 'dataclass-field', 'model-field', 'computed-field'}\n_FUNCTION_WITH_INNER_SCHEMA_TYPES = {'function-before', 'function-after', 'function-wrap'}\n_LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES = {'list', 'set', 'frozenset'}\n\nTAGGED_UNION_TAG_KEY = 'pydantic.internal.tagged_union_tag'\n\"\"\"\nUsed in a `Tag` schema to specify the tag used for a discriminated union.\n\"\"\"\nHAS_INVALID_SCHEMAS_METADATA_KEY = 'pydantic.internal.invalid'\n\"\"\"Used to mark a schema that is invalid because it refers to a definition that was not yet defined when the\nschema was first encountered.\n\"\"\"\n\n\ndef is_core_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchema]:\n    return schema['type'] not in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_core_schema_field(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[CoreSchemaField]:\n    return schema['type'] in _CORE_SCHEMA_FIELD_TYPES\n\n\ndef is_function_with_inner_schema(\n    schema: CoreSchemaOrField,\n) -> TypeGuard[FunctionSchemaWithInnerSchema]:\n    return schema['type'] in _FUNCTION_WITH_INNER_SCHEMA_TYPES\n\n\ndef is_list_like_schema_with_items_schema(\n    schema: CoreSchema,\n) -> TypeGuard[core_schema.ListSchema | core_schema.SetSchema | core_schema.FrozenSetSchema]:\n    return schema['type'] in _LIST_LIKE_SCHEMA_WITH_ITEMS_TYPES\n\n\ndef get_type_ref(type_: type[Any], args_override: tuple[type[Any], ...] | None = None) -> str:\n    \"\"\"Produces the ref to be used for this type by pydantic_core's core schemas.\n\n    This `args_override` argument was added for the purpose of creating valid recursive references\n    when creating generic models without needing to create a concrete class.\n    \"\"\"\n    origin = get_origin(type_) or type_\n\n    args = get_args(type_) if is_generic_alias(type_) else (args_override or ())\n    generic_metadata = getattr(type_, '__pydantic_generic_metadata__', None)\n    if generic_metadata:\n        origin = generic_metadata['origin'] or origin\n        args = generic_metadata['args'] or args\n\n    module_name = getattr(origin, '__module__', '<No __module__>')\n    if isinstance(origin, TypeAliasType):\n        type_ref = f'{module_name}.{origin.__name__}:{id(origin)}'\n    else:\n        try:\n            qualname = getattr(origin, '__qualname__', f'<No __qualname__: {origin}>')\n        except Exception:\n            qualname = getattr(origin, '__qualname__', '<No __qualname__>')\n        type_ref = f'{module_name}.{qualname}:{id(origin)}'\n\n    arg_refs: list[str] = []\n    for arg in args:\n        if isinstance(arg, str):\n            # Handle string literals as a special case; we may be able to remove this special handling if we\n            # wrap them in a ForwardRef at some point.\n            arg_ref = f'{arg}:str-{id(arg)}'\n        else:\n            arg_ref = f'{_repr.display_as_type(arg)}:{id(arg)}'\n        arg_refs.append(arg_ref)\n    if arg_refs:\n        type_ref = f'{type_ref}[{\",\".join(arg_refs)}]'\n    return type_ref\n\n\ndef get_ref(s: core_schema.CoreSchema) -> None | str:\n    \"\"\"Get the ref from the schema if it has one.\n    This exists just for type checking to work correctly.\n    \"\"\"\n    return s.get('ref', None)\n\n\ndef collect_definitions(schema: core_schema.CoreSchema) -> dict[str, core_schema.CoreSchema]:\n    defs: dict[str, CoreSchema] = {}\n\n    def _record_valid_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n        ref = get_ref(s)\n        if ref:\n            defs[ref] = s\n        return recurse(s, _record_valid_refs)\n\n    walk_core_schema(schema, _record_valid_refs)\n\n    return defs\n\n\ndef define_expected_missing_refs(\n    schema: core_schema.CoreSchema, allowed_missing_refs: set[str]\n) -> core_schema.CoreSchema | None:\n    if not allowed_missing_refs:\n        # in this case, there are no missing refs to potentially substitute, so there's no need to walk the schema\n        # this is a common case (will be hit for all non-generic models), so it's worth optimizing for\n        return None\n\n    refs = collect_definitions(schema).keys()\n\n    expected_missing_refs = allowed_missing_refs.difference(refs)\n    if expected_missing_refs:\n        definitions: list[core_schema.CoreSchema] = [\n            # TODO: Replace this with a (new) CoreSchema that, if present at any level, makes validation fail\n            #   Issue: https://github.com/pydantic/pydantic-core/issues/619\n            core_schema.none_schema(ref=ref, metadata={HAS_INVALID_SCHEMAS_METADATA_KEY: True})\n            for ref in expected_missing_refs\n        ]\n        return core_schema.definitions_schema(schema, definitions)\n    return None\n\n\ndef collect_invalid_schemas(schema: core_schema.CoreSchema) -> bool:\n    invalid = False\n\n    def _is_schema_valid(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n        nonlocal invalid\n        if 'metadata' in s:\n            metadata = s['metadata']\n            if HAS_INVALID_SCHEMAS_METADATA_KEY in metadata:\n                invalid = metadata[HAS_INVALID_SCHEMAS_METADATA_KEY]\n                return s\n        return recurse(s, _is_schema_valid)\n\n    walk_core_schema(schema, _is_schema_valid)\n    return invalid\n\n\nT = TypeVar('T')\n\n\nRecurse = Callable[[core_schema.CoreSchema, 'Walk'], core_schema.CoreSchema]\nWalk = Callable[[core_schema.CoreSchema, Recurse], core_schema.CoreSchema]\n\n# TODO: Should we move _WalkCoreSchema into pydantic_core proper?\n#   Issue: https://github.com/pydantic/pydantic-core/issues/615\n\n\nclass _WalkCoreSchema:\n    def __init__(self):\n        self._schema_type_to_method = self._build_schema_type_to_method()\n\n    def _build_schema_type_to_method(self) -> dict[core_schema.CoreSchemaType, Recurse]:\n        mapping: dict[core_schema.CoreSchemaType, Recurse] = {}\n        key: core_schema.CoreSchemaType\n        for key in get_args(core_schema.CoreSchemaType):\n            method_name = f\"handle_{key.replace('-', '_')}_schema\"\n            mapping[key] = getattr(self, method_name, self._handle_other_schemas)\n        return mapping\n\n    def walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n        return f(schema, self._walk)\n\n    def _walk(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n        schema = self._schema_type_to_method[schema['type']](schema.copy(), f)\n        ser_schema: core_schema.SerSchema | None = schema.get('serialization')  # type: ignore\n        if ser_schema:\n            schema['serialization'] = self._handle_ser_schemas(ser_schema, f)\n        return schema\n\n    def _handle_other_schemas(self, schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n        sub_schema = schema.get('schema', None)\n        if sub_schema is not None:\n            schema['schema'] = self.walk(sub_schema, f)  # type: ignore\n        return schema\n\n    def _handle_ser_schemas(self, ser_schema: core_schema.SerSchema, f: Walk) -> core_schema.SerSchema:\n        schema: core_schema.CoreSchema | None = ser_schema.get('schema', None)\n        if schema is not None:\n            ser_schema['schema'] = self.walk(schema, f)  # type: ignore\n        return_schema: core_schema.CoreSchema | None = ser_schema.get('return_schema', None)\n        if return_schema is not None:\n            ser_schema['return_schema'] = self.walk(return_schema, f)  # type: ignore\n        return ser_schema\n\n    def handle_definitions_schema(self, schema: core_schema.DefinitionsSchema, f: Walk) -> core_schema.CoreSchema:\n        new_definitions: list[core_schema.CoreSchema] = []\n        for definition in schema['definitions']:\n            if 'schema_ref' in definition and 'ref' in definition:\n                # This indicates a purposely indirect reference\n                # We want to keep such references around for implications related to JSON schema, etc.:\n                new_definitions.append(definition)\n                # However, we still need to walk the referenced definition:\n                self.walk(definition, f)\n                continue\n\n            updated_definition = self.walk(definition, f)\n            if 'ref' in updated_definition:\n                # If the updated definition schema doesn't have a 'ref', it shouldn't go in the definitions\n                # This is most likely to happen due to replacing something with a definition reference, in\n                # which case it should certainly not go in the definitions list\n                new_definitions.append(updated_definition)\n        new_inner_schema = self.walk(schema['schema'], f)\n\n        if not new_definitions and len(schema) == 3:\n            # This means we'd be returning a \"trivial\" definitions schema that just wrapped the inner schema\n            return new_inner_schema\n\n        new_schema = schema.copy()\n        new_schema['schema'] = new_inner_schema\n        new_schema['definitions'] = new_definitions\n        return new_schema\n\n    def handle_list_schema(self, schema: core_schema.ListSchema, f: Walk) -> core_schema.CoreSchema:\n        items_schema = schema.get('items_schema')\n        if items_schema is not None:\n            schema['items_schema'] = self.walk(items_schema, f)\n        return schema\n\n    def handle_set_schema(self, schema: core_schema.SetSchema, f: Walk) -> core_schema.CoreSchema:\n        items_schema = schema.get('items_schema')\n        if items_schema is not None:\n            schema['items_schema'] = self.walk(items_schema, f)\n        return schema\n\n    def handle_frozenset_schema(self, schema: core_schema.FrozenSetSchema, f: Walk) -> core_schema.CoreSchema:\n        items_schema = schema.get('items_schema')\n        if items_schema is not None:\n            schema['items_schema'] = self.walk(items_schema, f)\n        return schema\n\n    def handle_generator_schema(self, schema: core_schema.GeneratorSchema, f: Walk) -> core_schema.CoreSchema:\n        items_schema = schema.get('items_schema')\n        if items_schema is not None:\n            schema['items_schema'] = self.walk(items_schema, f)\n        return schema\n\n    def handle_tuple_schema(self, schema: core_schema.TupleSchema, f: Walk) -> core_schema.CoreSchema:\n        schema['items_schema'] = [self.walk(v, f) for v in schema['items_schema']]\n        return schema\n\n    def handle_dict_schema(self, schema: core_schema.DictSchema, f: Walk) -> core_schema.CoreSchema:\n        keys_schema = schema.get('keys_schema')\n        if keys_schema is not None:\n            schema['keys_schema'] = self.walk(keys_schema, f)\n        values_schema = schema.get('values_schema')\n        if values_schema:\n            schema['values_schema'] = self.walk(values_schema, f)\n        return schema\n\n    def handle_function_schema(self, schema: AnyFunctionSchema, f: Walk) -> core_schema.CoreSchema:\n        if not is_function_with_inner_schema(schema):\n            return schema\n        schema['schema'] = self.walk(schema['schema'], f)\n        return schema\n\n    def handle_union_schema(self, schema: core_schema.UnionSchema, f: Walk) -> core_schema.CoreSchema:\n        new_choices: list[CoreSchema | tuple[CoreSchema, str]] = []\n        for v in schema['choices']:\n            if isinstance(v, tuple):\n                new_choices.append((self.walk(v[0], f), v[1]))\n            else:\n                new_choices.append(self.walk(v, f))\n        schema['choices'] = new_choices\n        return schema\n\n    def handle_tagged_union_schema(self, schema: core_schema.TaggedUnionSchema, f: Walk) -> core_schema.CoreSchema:\n        new_choices: dict[Hashable, core_schema.CoreSchema] = {}\n        for k, v in schema['choices'].items():\n            new_choices[k] = v if isinstance(v, (str, int)) else self.walk(v, f)\n        schema['choices'] = new_choices\n        return schema\n\n    def handle_chain_schema(self, schema: core_schema.ChainSchema, f: Walk) -> core_schema.CoreSchema:\n        schema['steps'] = [self.walk(v, f) for v in schema['steps']]\n        return schema\n\n    def handle_lax_or_strict_schema(self, schema: core_schema.LaxOrStrictSchema, f: Walk) -> core_schema.CoreSchema:\n        schema['lax_schema'] = self.walk(schema['lax_schema'], f)\n        schema['strict_schema'] = self.walk(schema['strict_schema'], f)\n        return schema\n\n    def handle_json_or_python_schema(self, schema: core_schema.JsonOrPythonSchema, f: Walk) -> core_schema.CoreSchema:\n        schema['json_schema'] = self.walk(schema['json_schema'], f)\n        schema['python_schema'] = self.walk(schema['python_schema'], f)\n        return schema\n\n    def handle_model_fields_schema(self, schema: core_schema.ModelFieldsSchema, f: Walk) -> core_schema.CoreSchema:\n        extras_schema = schema.get('extras_schema')\n        if extras_schema is not None:\n            schema['extras_schema'] = self.walk(extras_schema, f)\n        replaced_fields: dict[str, core_schema.ModelField] = {}\n        replaced_computed_fields: list[core_schema.ComputedField] = []\n        for computed_field in schema.get('computed_fields', ()):\n            replaced_field = computed_field.copy()\n            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n            replaced_computed_fields.append(replaced_field)\n        if replaced_computed_fields:\n            schema['computed_fields'] = replaced_computed_fields\n        for k, v in schema['fields'].items():\n            replaced_field = v.copy()\n            replaced_field['schema'] = self.walk(v['schema'], f)\n            replaced_fields[k] = replaced_field\n        schema['fields'] = replaced_fields\n        return schema\n\n    def handle_typed_dict_schema(self, schema: core_schema.TypedDictSchema, f: Walk) -> core_schema.CoreSchema:\n        extras_schema = schema.get('extras_schema')\n        if extras_schema is not None:\n            schema['extras_schema'] = self.walk(extras_schema, f)\n        replaced_computed_fields: list[core_schema.ComputedField] = []\n        for computed_field in schema.get('computed_fields', ()):\n            replaced_field = computed_field.copy()\n            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n            replaced_computed_fields.append(replaced_field)\n        if replaced_computed_fields:\n            schema['computed_fields'] = replaced_computed_fields\n        replaced_fields: dict[str, core_schema.TypedDictField] = {}\n        for k, v in schema['fields'].items():\n            replaced_field = v.copy()\n            replaced_field['schema'] = self.walk(v['schema'], f)\n            replaced_fields[k] = replaced_field\n        schema['fields'] = replaced_fields\n        return schema\n\n    def handle_dataclass_args_schema(self, schema: core_schema.DataclassArgsSchema, f: Walk) -> core_schema.CoreSchema:\n        replaced_fields: list[core_schema.DataclassField] = []\n        replaced_computed_fields: list[core_schema.ComputedField] = []\n        for computed_field in schema.get('computed_fields', ()):\n            replaced_field = computed_field.copy()\n            replaced_field['return_schema'] = self.walk(computed_field['return_schema'], f)\n            replaced_computed_fields.append(replaced_field)\n        if replaced_computed_fields:\n            schema['computed_fields'] = replaced_computed_fields\n        for field in schema['fields']:\n            replaced_field = field.copy()\n            replaced_field['schema'] = self.walk(field['schema'], f)\n            replaced_fields.append(replaced_field)\n        schema['fields'] = replaced_fields\n        return schema\n\n    def handle_arguments_schema(self, schema: core_schema.ArgumentsSchema, f: Walk) -> core_schema.CoreSchema:\n        replaced_arguments_schema: list[core_schema.ArgumentsParameter] = []\n        for param in schema['arguments_schema']:\n            replaced_param = param.copy()\n            replaced_param['schema'] = self.walk(param['schema'], f)\n            replaced_arguments_schema.append(replaced_param)\n        schema['arguments_schema'] = replaced_arguments_schema\n        if 'var_args_schema' in schema:\n            schema['var_args_schema'] = self.walk(schema['var_args_schema'], f)\n        if 'var_kwargs_schema' in schema:\n            schema['var_kwargs_schema'] = self.walk(schema['var_kwargs_schema'], f)\n        return schema\n\n    def handle_call_schema(self, schema: core_schema.CallSchema, f: Walk) -> core_schema.CoreSchema:\n        schema['arguments_schema'] = self.walk(schema['arguments_schema'], f)\n        if 'return_schema' in schema:\n            schema['return_schema'] = self.walk(schema['return_schema'], f)\n        return schema\n\n\n_dispatch = _WalkCoreSchema().walk\n\n\ndef walk_core_schema(schema: core_schema.CoreSchema, f: Walk) -> core_schema.CoreSchema:\n    \"\"\"Recursively traverse a CoreSchema.\n\n    Args:\n        schema (core_schema.CoreSchema): The CoreSchema to process, it will not be modified.\n        f (Walk): A function to apply. This function takes two arguments:\n          1. The current CoreSchema that is being processed\n             (not the same one you passed into this function, one level down).\n          2. The \"next\" `f` to call. This lets you for example use `f=functools.partial(some_method, some_context)`\n             to pass data down the recursive calls without using globals or other mutable state.\n\n    Returns:\n        core_schema.CoreSchema: A processed CoreSchema.\n    \"\"\"\n    return f(schema.copy(), _dispatch)\n\n\ndef simplify_schema_references(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:  # noqa: C901\n    definitions: dict[str, core_schema.CoreSchema] = {}\n    ref_counts: dict[str, int] = defaultdict(int)\n    involved_in_recursion: dict[str, bool] = {}\n    current_recursion_ref_count: dict[str, int] = defaultdict(int)\n\n    def collect_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n        if s['type'] == 'definitions':\n            for definition in s['definitions']:\n                ref = get_ref(definition)\n                assert ref is not None\n                if ref not in definitions:\n                    definitions[ref] = definition\n                recurse(definition, collect_refs)\n            return recurse(s['schema'], collect_refs)\n        else:\n            ref = get_ref(s)\n            if ref is not None:\n                new = recurse(s, collect_refs)\n                new_ref = get_ref(new)\n                if new_ref:\n                    definitions[new_ref] = new\n                return core_schema.definition_reference_schema(schema_ref=ref)\n            else:\n                return recurse(s, collect_refs)\n\n    schema = walk_core_schema(schema, collect_refs)\n\n    def count_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n        if s['type'] != 'definition-ref':\n            return recurse(s, count_refs)\n        ref = s['schema_ref']\n        ref_counts[ref] += 1\n\n        if ref_counts[ref] >= 2:\n            # If this model is involved in a recursion this should be detected\n            # on its second encounter, we can safely stop the walk here.\n            if current_recursion_ref_count[ref] != 0:\n                involved_in_recursion[ref] = True\n            return s\n\n        current_recursion_ref_count[ref] += 1\n        recurse(definitions[ref], count_refs)\n        current_recursion_ref_count[ref] -= 1\n        return s\n\n    schema = walk_core_schema(schema, count_refs)\n\n    assert all(c == 0 for c in current_recursion_ref_count.values()), 'this is a bug! please report it'\n\n    def can_be_inlined(s: core_schema.DefinitionReferenceSchema, ref: str) -> bool:\n        if ref_counts[ref] > 1:\n            return False\n        if involved_in_recursion.get(ref, False):\n            return False\n        if 'serialization' in s:\n            return False\n        if 'metadata' in s:\n            metadata = s['metadata']\n            for k in (\n                'pydantic_js_functions',\n                'pydantic_js_annotation_functions',\n                'pydantic.internal.union_discriminator',\n            ):\n                if k in metadata:\n                    # we need to keep this as a ref\n                    return False\n        return True\n\n    def inline_refs(s: core_schema.CoreSchema, recurse: Recurse) -> core_schema.CoreSchema:\n        if s['type'] == 'definition-ref':\n            ref = s['schema_ref']\n            # Check if the reference is only used once, not involved in recursion and does not have\n            # any extra keys (like 'serialization')\n            if can_be_inlined(s, ref):\n                # Inline the reference by replacing the reference with the actual schema\n                new = definitions.pop(ref)\n                ref_counts[ref] -= 1  # because we just replaced it!\n                # put all other keys that were on the def-ref schema into the inlined version\n                # in particular this is needed for `serialization`\n                if 'serialization' in s:\n                    new['serialization'] = s['serialization']\n                s = recurse(new, inline_refs)\n                return s\n            else:\n                return recurse(s, inline_refs)\n        else:\n            return recurse(s, inline_refs)\n\n    schema = walk_core_schema(schema, inline_refs)\n\n    def_values = [v for v in definitions.values() if ref_counts[v['ref']] > 0]  # type: ignore\n\n    if def_values:\n        schema = core_schema.definitions_schema(schema=schema, definitions=def_values)\n    return schema\n\n\ndef _strip_metadata(schema: CoreSchema) -> CoreSchema:\n    def strip_metadata(s: CoreSchema, recurse: Recurse) -> CoreSchema:\n        s = s.copy()\n        s.pop('metadata', None)\n        if s['type'] == 'model-fields':\n            s = s.copy()\n            s['fields'] = {k: v.copy() for k, v in s['fields'].items()}\n            for field_name, field_schema in s['fields'].items():\n                field_schema.pop('metadata', None)\n                s['fields'][field_name] = field_schema\n            computed_fields = s.get('computed_fields', None)\n            if computed_fields:\n                s['computed_fields'] = [cf.copy() for cf in computed_fields]\n                for cf in computed_fields:\n                    cf.pop('metadata', None)\n            else:\n                s.pop('computed_fields', None)\n        elif s['type'] == 'model':\n            # remove some defaults\n            if s.get('custom_init', True) is False:\n                s.pop('custom_init')\n            if s.get('root_model', True) is False:\n                s.pop('root_model')\n            if {'title'}.issuperset(s.get('config', {}).keys()):\n                s.pop('config', None)\n\n        return recurse(s, strip_metadata)\n\n    return walk_core_schema(schema, strip_metadata)\n\n\ndef pretty_print_core_schema(\n    schema: CoreSchema,\n    include_metadata: bool = False,\n) -> None:\n    \"\"\"Pretty print a CoreSchema using rich.\n    This is intended for debugging purposes.\n\n    Args:\n        schema: The CoreSchema to print.\n        include_metadata: Whether to include metadata in the output. Defaults to `False`.\n    \"\"\"\n    from rich import print  # type: ignore  # install it manually in your dev env\n\n    if not include_metadata:\n        schema = _strip_metadata(schema)\n\n    return print(schema)\n\n\ndef validate_core_schema(schema: CoreSchema) -> CoreSchema:\n    if 'PYDANTIC_SKIP_VALIDATING_CORE_SCHEMAS' in os.environ:\n        return schema\n    return _validate_core_schema(schema)\n", "pydantic/_internal/_generics.py": "from __future__ import annotations\n\nimport sys\nimport types\nimport typing\nfrom collections import ChainMap\nfrom contextlib import contextmanager\nfrom contextvars import ContextVar\nfrom types import prepare_class\nfrom typing import TYPE_CHECKING, Any, Iterator, List, Mapping, MutableMapping, Tuple, TypeVar\nfrom weakref import WeakValueDictionary\n\nimport typing_extensions\n\nfrom ._core_utils import get_type_ref\nfrom ._forward_ref import PydanticRecursiveRef\nfrom ._typing_extra import TypeVarType, typing_base\nfrom ._utils import all_identical, is_model_class\n\nif sys.version_info >= (3, 10):\n    from typing import _UnionGenericAlias  # type: ignore[attr-defined]\n\nif TYPE_CHECKING:\n    from ..main import BaseModel\n\nGenericTypesCacheKey = Tuple[Any, Any, Tuple[Any, ...]]\n\n# Note: We want to remove LimitedDict, but to do this, we'd need to improve the handling of generics caching.\n#   Right now, to handle recursive generics, we some types must remain cached for brief periods without references.\n#   By chaining the WeakValuesDict with a LimitedDict, we have a way to retain caching for all types with references,\n#   while also retaining a limited number of types even without references. This is generally enough to build\n#   specific recursive generic models without losing required items out of the cache.\n\nKT = TypeVar('KT')\nVT = TypeVar('VT')\n_LIMITED_DICT_SIZE = 100\nif TYPE_CHECKING:\n\n    class LimitedDict(dict, MutableMapping[KT, VT]):\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE): ...\n\nelse:\n\n    class LimitedDict(dict):\n        \"\"\"Limit the size/length of a dict used for caching to avoid unlimited increase in memory usage.\n\n        Since the dict is ordered, and we always remove elements from the beginning, this is effectively a FIFO cache.\n        \"\"\"\n\n        def __init__(self, size_limit: int = _LIMITED_DICT_SIZE):\n            self.size_limit = size_limit\n            super().__init__()\n\n        def __setitem__(self, key: Any, value: Any, /) -> None:\n            super().__setitem__(key, value)\n            if len(self) > self.size_limit:\n                excess = len(self) - self.size_limit + self.size_limit // 10\n                to_remove = list(self.keys())[:excess]\n                for k in to_remove:\n                    del self[k]\n\n\n# weak dictionaries allow the dynamically created parametrized versions of generic models to get collected\n# once they are no longer referenced by the caller.\nif sys.version_info >= (3, 9):  # Typing for weak dictionaries available at 3.9\n    GenericTypesCache = WeakValueDictionary[GenericTypesCacheKey, 'type[BaseModel]']\nelse:\n    GenericTypesCache = WeakValueDictionary\n\nif TYPE_CHECKING:\n\n    class DeepChainMap(ChainMap[KT, VT]):  # type: ignore\n        ...\n\nelse:\n\n    class DeepChainMap(ChainMap):\n        \"\"\"Variant of ChainMap that allows direct updates to inner scopes.\n\n        Taken from https://docs.python.org/3/library/collections.html#collections.ChainMap,\n        with some light modifications for this use case.\n        \"\"\"\n\n        def clear(self) -> None:\n            for mapping in self.maps:\n                mapping.clear()\n\n        def __setitem__(self, key: KT, value: VT) -> None:\n            for mapping in self.maps:\n                mapping[key] = value\n\n        def __delitem__(self, key: KT) -> None:\n            hit = False\n            for mapping in self.maps:\n                if key in mapping:\n                    del mapping[key]\n                    hit = True\n            if not hit:\n                raise KeyError(key)\n\n\n# Despite the fact that LimitedDict _seems_ no longer necessary, I'm very nervous to actually remove it\n# and discover later on that we need to re-add all this infrastructure...\n# _GENERIC_TYPES_CACHE = DeepChainMap(GenericTypesCache(), LimitedDict())\n\n_GENERIC_TYPES_CACHE = GenericTypesCache()\n\n\nclass PydanticGenericMetadata(typing_extensions.TypedDict):\n    origin: type[BaseModel] | None  # analogous to typing._GenericAlias.__origin__\n    args: tuple[Any, ...]  # analogous to typing._GenericAlias.__args__\n    parameters: tuple[type[Any], ...]  # analogous to typing.Generic.__parameters__\n\n\ndef create_generic_submodel(\n    model_name: str, origin: type[BaseModel], args: tuple[Any, ...], params: tuple[Any, ...]\n) -> type[BaseModel]:\n    \"\"\"Dynamically create a submodel of a provided (generic) BaseModel.\n\n    This is used when producing concrete parametrizations of generic models. This function\n    only *creates* the new subclass; the schema/validators/serialization must be updated to\n    reflect a concrete parametrization elsewhere.\n\n    Args:\n        model_name: The name of the newly created model.\n        origin: The base class for the new model to inherit from.\n        args: A tuple of generic metadata arguments.\n        params: A tuple of generic metadata parameters.\n\n    Returns:\n        The created submodel.\n    \"\"\"\n    namespace: dict[str, Any] = {'__module__': origin.__module__}\n    bases = (origin,)\n    meta, ns, kwds = prepare_class(model_name, bases)\n    namespace.update(ns)\n    created_model = meta(\n        model_name,\n        bases,\n        namespace,\n        __pydantic_generic_metadata__={\n            'origin': origin,\n            'args': args,\n            'parameters': params,\n        },\n        __pydantic_reset_parent_namespace__=False,\n        **kwds,\n    )\n\n    model_module, called_globally = _get_caller_frame_info(depth=3)\n    if called_globally:  # create global reference and therefore allow pickling\n        object_by_reference = None\n        reference_name = model_name\n        reference_module_globals = sys.modules[created_model.__module__].__dict__\n        while object_by_reference is not created_model:\n            object_by_reference = reference_module_globals.setdefault(reference_name, created_model)\n            reference_name += '_'\n\n    return created_model\n\n\ndef _get_caller_frame_info(depth: int = 2) -> tuple[str | None, bool]:\n    \"\"\"Used inside a function to check whether it was called globally.\n\n    Args:\n        depth: The depth to get the frame.\n\n    Returns:\n        A tuple contains `module_name` and `called_globally`.\n\n    Raises:\n        RuntimeError: If the function is not called inside a function.\n    \"\"\"\n    try:\n        previous_caller_frame = sys._getframe(depth)\n    except ValueError as e:\n        raise RuntimeError('This function must be used inside another function') from e\n    except AttributeError:  # sys module does not have _getframe function, so there's nothing we can do about it\n        return None, False\n    frame_globals = previous_caller_frame.f_globals\n    return frame_globals.get('__name__'), previous_caller_frame.f_locals is frame_globals\n\n\nDictValues: type[Any] = {}.values().__class__\n\n\ndef iter_contained_typevars(v: Any) -> Iterator[TypeVarType]:\n    \"\"\"Recursively iterate through all subtypes and type args of `v` and yield any typevars that are found.\n\n    This is inspired as an alternative to directly accessing the `__parameters__` attribute of a GenericAlias,\n    since __parameters__ of (nested) generic BaseModel subclasses won't show up in that list.\n    \"\"\"\n    if isinstance(v, TypeVar):\n        yield v\n    elif is_model_class(v):\n        yield from v.__pydantic_generic_metadata__['parameters']\n    elif isinstance(v, (DictValues, list)):\n        for var in v:\n            yield from iter_contained_typevars(var)\n    else:\n        args = get_args(v)\n        for arg in args:\n            yield from iter_contained_typevars(arg)\n\n\ndef get_args(v: Any) -> Any:\n    pydantic_generic_metadata: PydanticGenericMetadata | None = getattr(v, '__pydantic_generic_metadata__', None)\n    if pydantic_generic_metadata:\n        return pydantic_generic_metadata.get('args')\n    return typing_extensions.get_args(v)\n\n\ndef get_origin(v: Any) -> Any:\n    pydantic_generic_metadata: PydanticGenericMetadata | None = getattr(v, '__pydantic_generic_metadata__', None)\n    if pydantic_generic_metadata:\n        return pydantic_generic_metadata.get('origin')\n    return typing_extensions.get_origin(v)\n\n\ndef get_standard_typevars_map(cls: type[Any]) -> dict[TypeVarType, Any] | None:\n    \"\"\"Package a generic type's typevars and parametrization (if present) into a dictionary compatible with the\n    `replace_types` function. Specifically, this works with standard typing generics and typing._GenericAlias.\n    \"\"\"\n    origin = get_origin(cls)\n    if origin is None:\n        return None\n    if not hasattr(origin, '__parameters__'):\n        return None\n\n    # In this case, we know that cls is a _GenericAlias, and origin is the generic type\n    # So it is safe to access cls.__args__ and origin.__parameters__\n    args: tuple[Any, ...] = cls.__args__  # type: ignore\n    parameters: tuple[TypeVarType, ...] = origin.__parameters__\n    return dict(zip(parameters, args))\n\n\ndef get_model_typevars_map(cls: type[BaseModel]) -> dict[TypeVarType, Any] | None:\n    \"\"\"Package a generic BaseModel's typevars and concrete parametrization (if present) into a dictionary compatible\n    with the `replace_types` function.\n\n    Since BaseModel.__class_getitem__ does not produce a typing._GenericAlias, and the BaseModel generic info is\n    stored in the __pydantic_generic_metadata__ attribute, we need special handling here.\n    \"\"\"\n    # TODO: This could be unified with `get_standard_typevars_map` if we stored the generic metadata\n    #   in the __origin__, __args__, and __parameters__ attributes of the model.\n    generic_metadata = cls.__pydantic_generic_metadata__\n    origin = generic_metadata['origin']\n    args = generic_metadata['args']\n    return dict(zip(iter_contained_typevars(origin), args))\n\n\ndef replace_types(type_: Any, type_map: Mapping[Any, Any] | None) -> Any:\n    \"\"\"Return type with all occurrences of `type_map` keys recursively replaced with their values.\n\n    Args:\n        type_: The class or generic alias.\n        type_map: Mapping from `TypeVar` instance to concrete types.\n\n    Returns:\n        A new type representing the basic structure of `type_` with all\n        `typevar_map` keys recursively replaced.\n\n    Example:\n        ```py\n        from typing import List, Tuple, Union\n\n        from pydantic._internal._generics import replace_types\n\n        replace_types(Tuple[str, Union[List[str], float]], {str: int})\n        #> Tuple[int, Union[List[int], float]]\n        ```\n    \"\"\"\n    if not type_map:\n        return type_\n\n    type_args = get_args(type_)\n    origin_type = get_origin(type_)\n\n    if origin_type is typing_extensions.Annotated:\n        annotated_type, *annotations = type_args\n        annotated = replace_types(annotated_type, type_map)\n        for annotation in annotations:\n            annotated = typing_extensions.Annotated[annotated, annotation]\n        return annotated\n\n    # Having type args is a good indicator that this is a typing module\n    # class instantiation or a generic alias of some sort.\n    if type_args:\n        resolved_type_args = tuple(replace_types(arg, type_map) for arg in type_args)\n        if all_identical(type_args, resolved_type_args):\n            # If all arguments are the same, there is no need to modify the\n            # type or create a new object at all\n            return type_\n        if (\n            origin_type is not None\n            and isinstance(type_, typing_base)\n            and not isinstance(origin_type, typing_base)\n            and getattr(type_, '_name', None) is not None\n        ):\n            # In python < 3.9 generic aliases don't exist so any of these like `list`,\n            # `type` or `collections.abc.Callable` need to be translated.\n            # See: https://www.python.org/dev/peps/pep-0585\n            origin_type = getattr(typing, type_._name)\n        assert origin_type is not None\n        # PEP-604 syntax (Ex.: list | str) is represented with a types.UnionType object that does not have __getitem__.\n        # We also cannot use isinstance() since we have to compare types.\n        if sys.version_info >= (3, 10) and origin_type is types.UnionType:\n            return _UnionGenericAlias(origin_type, resolved_type_args)\n        # NotRequired[T] and Required[T] don't support tuple type resolved_type_args, hence the condition below\n        return origin_type[resolved_type_args[0] if len(resolved_type_args) == 1 else resolved_type_args]\n\n    # We handle pydantic generic models separately as they don't have the same\n    # semantics as \"typing\" classes or generic aliases\n\n    if not origin_type and is_model_class(type_):\n        parameters = type_.__pydantic_generic_metadata__['parameters']\n        if not parameters:\n            return type_\n        resolved_type_args = tuple(replace_types(t, type_map) for t in parameters)\n        if all_identical(parameters, resolved_type_args):\n            return type_\n        return type_[resolved_type_args]\n\n    # Handle special case for typehints that can have lists as arguments.\n    # `typing.Callable[[int, str], int]` is an example for this.\n    if isinstance(type_, (List, list)):\n        resolved_list = list(replace_types(element, type_map) for element in type_)\n        if all_identical(type_, resolved_list):\n            return type_\n        return resolved_list\n\n    # If all else fails, we try to resolve the type directly and otherwise just\n    # return the input with no modifications.\n    return type_map.get(type_, type_)\n\n\ndef has_instance_in_type(type_: Any, isinstance_target: Any) -> bool:\n    \"\"\"Checks if the type, or any of its arbitrary nested args, satisfy\n    `isinstance(<type>, isinstance_target)`.\n    \"\"\"\n    if isinstance(type_, isinstance_target):\n        return True\n\n    type_args = get_args(type_)\n    origin_type = get_origin(type_)\n\n    if origin_type is typing_extensions.Annotated:\n        annotated_type, *annotations = type_args\n        return has_instance_in_type(annotated_type, isinstance_target)\n\n    # Having type args is a good indicator that this is a typing module\n    # class instantiation or a generic alias of some sort.\n    if any(has_instance_in_type(a, isinstance_target) for a in type_args):\n        return True\n\n    # Handle special case for typehints that can have lists as arguments.\n    # `typing.Callable[[int, str], int]` is an example for this.\n    if isinstance(type_, (List, list)) and not isinstance(type_, typing_extensions.ParamSpec):\n        if any(has_instance_in_type(element, isinstance_target) for element in type_):\n            return True\n\n    return False\n\n\ndef check_parameters_count(cls: type[BaseModel], parameters: tuple[Any, ...]) -> None:\n    \"\"\"Check the generic model parameters count is equal.\n\n    Args:\n        cls: The generic model.\n        parameters: A tuple of passed parameters to the generic model.\n\n    Raises:\n        TypeError: If the passed parameters count is not equal to generic model parameters count.\n    \"\"\"\n    actual = len(parameters)\n    expected = len(cls.__pydantic_generic_metadata__['parameters'])\n    if actual != expected:\n        description = 'many' if actual > expected else 'few'\n        raise TypeError(f'Too {description} parameters for {cls}; actual {actual}, expected {expected}')\n\n\n_generic_recursion_cache: ContextVar[set[str] | None] = ContextVar('_generic_recursion_cache', default=None)\n\n\n@contextmanager\ndef generic_recursion_self_type(\n    origin: type[BaseModel], args: tuple[Any, ...]\n) -> Iterator[PydanticRecursiveRef | None]:\n    \"\"\"This contextmanager should be placed around the recursive calls used to build a generic type,\n    and accept as arguments the generic origin type and the type arguments being passed to it.\n\n    If the same origin and arguments are observed twice, it implies that a self-reference placeholder\n    can be used while building the core schema, and will produce a schema_ref that will be valid in the\n    final parent schema.\n    \"\"\"\n    previously_seen_type_refs = _generic_recursion_cache.get()\n    if previously_seen_type_refs is None:\n        previously_seen_type_refs = set()\n        token = _generic_recursion_cache.set(previously_seen_type_refs)\n    else:\n        token = None\n\n    try:\n        type_ref = get_type_ref(origin, args_override=args)\n        if type_ref in previously_seen_type_refs:\n            self_type = PydanticRecursiveRef(type_ref=type_ref)\n            yield self_type\n        else:\n            previously_seen_type_refs.add(type_ref)\n            yield None\n    finally:\n        if token:\n            _generic_recursion_cache.reset(token)\n\n\ndef recursively_defined_type_refs() -> set[str]:\n    visited = _generic_recursion_cache.get()\n    if not visited:\n        return set()  # not in a generic recursion, so there are no types\n\n    return visited.copy()  # don't allow modifications\n\n\ndef get_cached_generic_type_early(parent: type[BaseModel], typevar_values: Any) -> type[BaseModel] | None:\n    \"\"\"The use of a two-stage cache lookup approach was necessary to have the highest performance possible for\n    repeated calls to `__class_getitem__` on generic types (which may happen in tighter loops during runtime),\n    while still ensuring that certain alternative parametrizations ultimately resolve to the same type.\n\n    As a concrete example, this approach was necessary to make Model[List[T]][int] equal to Model[List[int]].\n    The approach could be modified to not use two different cache keys at different points, but the\n    _early_cache_key is optimized to be as quick to compute as possible (for repeated-access speed), and the\n    _late_cache_key is optimized to be as \"correct\" as possible, so that two types that will ultimately be the\n    same after resolving the type arguments will always produce cache hits.\n\n    If we wanted to move to only using a single cache key per type, we would either need to always use the\n    slower/more computationally intensive logic associated with _late_cache_key, or would need to accept\n    that Model[List[T]][int] is a different type than Model[List[T]][int]. Because we rely on subclass relationships\n    during validation, I think it is worthwhile to ensure that types that are functionally equivalent are actually\n    equal.\n    \"\"\"\n    return _GENERIC_TYPES_CACHE.get(_early_cache_key(parent, typevar_values))\n\n\ndef get_cached_generic_type_late(\n    parent: type[BaseModel], typevar_values: Any, origin: type[BaseModel], args: tuple[Any, ...]\n) -> type[BaseModel] | None:\n    \"\"\"See the docstring of `get_cached_generic_type_early` for more information about the two-stage cache lookup.\"\"\"\n    cached = _GENERIC_TYPES_CACHE.get(_late_cache_key(origin, args, typevar_values))\n    if cached is not None:\n        set_cached_generic_type(parent, typevar_values, cached, origin, args)\n    return cached\n\n\ndef set_cached_generic_type(\n    parent: type[BaseModel],\n    typevar_values: tuple[Any, ...],\n    type_: type[BaseModel],\n    origin: type[BaseModel] | None = None,\n    args: tuple[Any, ...] | None = None,\n) -> None:\n    \"\"\"See the docstring of `get_cached_generic_type_early` for more information about why items are cached with\n    two different keys.\n    \"\"\"\n    _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values)] = type_\n    if len(typevar_values) == 1:\n        _GENERIC_TYPES_CACHE[_early_cache_key(parent, typevar_values[0])] = type_\n    if origin and args:\n        _GENERIC_TYPES_CACHE[_late_cache_key(origin, args, typevar_values)] = type_\n\n\ndef _union_orderings_key(typevar_values: Any) -> Any:\n    \"\"\"This is intended to help differentiate between Union types with the same arguments in different order.\n\n    Thanks to caching internal to the `typing` module, it is not possible to distinguish between\n    List[Union[int, float]] and List[Union[float, int]] (and similarly for other \"parent\" origins besides List)\n    because `typing` considers Union[int, float] to be equal to Union[float, int].\n\n    However, you _can_ distinguish between (top-level) Union[int, float] vs. Union[float, int].\n    Because we parse items as the first Union type that is successful, we get slightly more consistent behavior\n    if we make an effort to distinguish the ordering of items in a union. It would be best if we could _always_\n    get the exact-correct order of items in the union, but that would require a change to the `typing` module itself.\n    (See https://github.com/python/cpython/issues/86483 for reference.)\n    \"\"\"\n    if isinstance(typevar_values, tuple):\n        args_data = []\n        for value in typevar_values:\n            args_data.append(_union_orderings_key(value))\n        return tuple(args_data)\n    elif typing_extensions.get_origin(typevar_values) is typing.Union:\n        return get_args(typevar_values)\n    else:\n        return ()\n\n\ndef _early_cache_key(cls: type[BaseModel], typevar_values: Any) -> GenericTypesCacheKey:\n    \"\"\"This is intended for minimal computational overhead during lookups of cached types.\n\n    Note that this is overly simplistic, and it's possible that two different cls/typevar_values\n    inputs would ultimately result in the same type being created in BaseModel.__class_getitem__.\n    To handle this, we have a fallback _late_cache_key that is checked later if the _early_cache_key\n    lookup fails, and should result in a cache hit _precisely_ when the inputs to __class_getitem__\n    would result in the same type.\n    \"\"\"\n    return cls, typevar_values, _union_orderings_key(typevar_values)\n\n\ndef _late_cache_key(origin: type[BaseModel], args: tuple[Any, ...], typevar_values: Any) -> GenericTypesCacheKey:\n    \"\"\"This is intended for use later in the process of creating a new type, when we have more information\n    about the exact args that will be passed. If it turns out that a different set of inputs to\n    __class_getitem__ resulted in the same inputs to the generic type creation process, we can still\n    return the cached type, and update the cache with the _early_cache_key as well.\n    \"\"\"\n    # The _union_orderings_key is placed at the start here to ensure there cannot be a collision with an\n    # _early_cache_key, as that function will always produce a BaseModel subclass as the first item in the key,\n    # whereas this function will always produce a tuple as the first item in the key.\n    return _union_orderings_key(typevar_values), origin, args\n", "pydantic/_internal/_model_construction.py": "\"\"\"Private logic for creating models.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport builtins\nimport operator\nimport typing\nimport warnings\nimport weakref\nfrom abc import ABCMeta\nfrom functools import partial\nfrom types import FunctionType\nfrom typing import Any, Callable, Generic, NoReturn\n\nimport typing_extensions\nfrom pydantic_core import PydanticUndefined, SchemaSerializer\nfrom typing_extensions import dataclass_transform, deprecated\n\nfrom ..errors import PydanticUndefinedAnnotation, PydanticUserError\nfrom ..plugin._schema_validator import create_schema_validator\nfrom ..warnings import GenericBeforeBaseModelWarning, PydanticDeprecatedSince20\nfrom ._config import ConfigWrapper\nfrom ._decorators import DecoratorInfos, PydanticDescriptorProxy, get_attribute_from_bases, unwrap_wrapped_function\nfrom ._fields import collect_model_fields, is_valid_field_name, is_valid_privateattr_name\nfrom ._generate_schema import GenerateSchema\nfrom ._generics import PydanticGenericMetadata, get_model_typevars_map\nfrom ._mock_val_ser import set_model_mocks\nfrom ._schema_generation_shared import CallbackGetCoreSchemaHandler\nfrom ._signature import generate_pydantic_signature\nfrom ._typing_extra import get_cls_types_namespace, is_annotated, is_classvar, parent_frame_namespace\nfrom ._utils import ClassAttribute, SafeGetItemProxy\nfrom ._validate_call import ValidateCallWrapper\n\nif typing.TYPE_CHECKING:\n    from ..fields import Field as PydanticModelField\n    from ..fields import FieldInfo, ModelPrivateAttr\n    from ..fields import PrivateAttr as PydanticModelPrivateAttr\n    from ..main import BaseModel\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n    PydanticModelField = object()\n    PydanticModelPrivateAttr = object()\n\nobject_setattr = object.__setattr__\n\n\nclass _ModelNamespaceDict(dict):\n    \"\"\"A dictionary subclass that intercepts attribute setting on model classes and\n    warns about overriding of decorators.\n    \"\"\"\n\n    def __setitem__(self, k: str, v: object) -> None:\n        existing: Any = self.get(k, None)\n        if existing and v is not existing and isinstance(existing, PydanticDescriptorProxy):\n            warnings.warn(f'`{k}` overrides an existing Pydantic `{existing.decorator_info.decorator_repr}` decorator')\n\n        return super().__setitem__(k, v)\n\n\n@dataclass_transform(kw_only_default=True, field_specifiers=(PydanticModelField, PydanticModelPrivateAttr))\nclass ModelMetaclass(ABCMeta):\n    def __new__(\n        mcs,\n        cls_name: str,\n        bases: tuple[type[Any], ...],\n        namespace: dict[str, Any],\n        __pydantic_generic_metadata__: PydanticGenericMetadata | None = None,\n        __pydantic_reset_parent_namespace__: bool = True,\n        _create_model_module: str | None = None,\n        **kwargs: Any,\n    ) -> type:\n        \"\"\"Metaclass for creating Pydantic models.\n\n        Args:\n            cls_name: The name of the class to be created.\n            bases: The base classes of the class to be created.\n            namespace: The attribute dictionary of the class to be created.\n            __pydantic_generic_metadata__: Metadata for generic models.\n            __pydantic_reset_parent_namespace__: Reset parent namespace.\n            _create_model_module: The module of the class to be created, if created by `create_model`.\n            **kwargs: Catch-all for any other keyword arguments.\n\n        Returns:\n            The new class created by the metaclass.\n        \"\"\"\n        # Note `ModelMetaclass` refers to `BaseModel`, but is also used to *create* `BaseModel`, so we rely on the fact\n        # that `BaseModel` itself won't have any bases, but any subclass of it will, to determine whether the `__new__`\n        # call we're in the middle of is for the `BaseModel` class.\n        if bases:\n            base_field_names, class_vars, base_private_attributes = mcs._collect_bases_data(bases)\n\n            config_wrapper = ConfigWrapper.for_model(bases, namespace, kwargs)\n            namespace['model_config'] = config_wrapper.config_dict\n            private_attributes = inspect_namespace(\n                namespace, config_wrapper.ignored_types, class_vars, base_field_names\n            )\n            if private_attributes or base_private_attributes:\n                original_model_post_init = get_model_post_init(namespace, bases)\n                if original_model_post_init is not None:\n                    # if there are private_attributes and a model_post_init function, we handle both\n\n                    def wrapped_model_post_init(self: BaseModel, context: Any, /) -> None:\n                        \"\"\"We need to both initialize private attributes and call the user-defined model_post_init\n                        method.\n                        \"\"\"\n                        init_private_attributes(self, context)\n                        original_model_post_init(self, context)\n\n                    namespace['model_post_init'] = wrapped_model_post_init\n                else:\n                    namespace['model_post_init'] = init_private_attributes\n\n            namespace['__class_vars__'] = class_vars\n            namespace['__private_attributes__'] = {**base_private_attributes, **private_attributes}\n\n            cls: type[BaseModel] = super().__new__(mcs, cls_name, bases, namespace, **kwargs)  # type: ignore\n\n            from ..main import BaseModel\n\n            mro = cls.__mro__\n            if Generic in mro and mro.index(Generic) < mro.index(BaseModel):\n                warnings.warn(\n                    GenericBeforeBaseModelWarning(\n                        'Classes should inherit from `BaseModel` before generic classes (e.g. `typing.Generic[T]`) '\n                        'for pydantic generics to work properly.'\n                    ),\n                    stacklevel=2,\n                )\n\n            cls.__pydantic_custom_init__ = not getattr(cls.__init__, '__pydantic_base_init__', False)\n            cls.__pydantic_post_init__ = None if cls.model_post_init is BaseModel.model_post_init else 'model_post_init'\n\n            cls.__pydantic_decorators__ = DecoratorInfos.build(cls)\n\n            # Use the getattr below to grab the __parameters__ from the `typing.Generic` parent class\n            if __pydantic_generic_metadata__:\n                cls.__pydantic_generic_metadata__ = __pydantic_generic_metadata__\n            else:\n                parent_parameters = getattr(cls, '__pydantic_generic_metadata__', {}).get('parameters', ())\n                parameters = getattr(cls, '__parameters__', None) or parent_parameters\n                if parameters and parent_parameters and not all(x in parameters for x in parent_parameters):\n                    from ..root_model import RootModelRootType\n\n                    missing_parameters = tuple(x for x in parameters if x not in parent_parameters)\n                    if RootModelRootType in parent_parameters and RootModelRootType not in parameters:\n                        # This is a special case where the user has subclassed `RootModel`, but has not parametrized\n                        # RootModel with the generic type identifiers being used. Ex:\n                        # class MyModel(RootModel, Generic[T]):\n                        #    root: T\n                        # Should instead just be:\n                        # class MyModel(RootModel[T]):\n                        #   root: T\n                        parameters_str = ', '.join([x.__name__ for x in missing_parameters])\n                        error_message = (\n                            f'{cls.__name__} is a subclass of `RootModel`, but does not include the generic type identifier(s) '\n                            f'{parameters_str} in its parameters. '\n                            f'You should parametrize RootModel directly, e.g., `class {cls.__name__}(RootModel[{parameters_str}]): ...`.'\n                        )\n                    else:\n                        combined_parameters = parent_parameters + missing_parameters\n                        parameters_str = ', '.join([str(x) for x in combined_parameters])\n                        generic_type_label = f'typing.Generic[{parameters_str}]'\n                        error_message = (\n                            f'All parameters must be present on typing.Generic;'\n                            f' you should inherit from {generic_type_label}.'\n                        )\n                        if Generic not in bases:  # pragma: no cover\n                            # We raise an error here not because it is desirable, but because some cases are mishandled.\n                            # It would be nice to remove this error and still have things behave as expected, it's just\n                            # challenging because we are using a custom `__class_getitem__` to parametrize generic models,\n                            # and not returning a typing._GenericAlias from it.\n                            bases_str = ', '.join([x.__name__ for x in bases] + [generic_type_label])\n                            error_message += (\n                                f' Note: `typing.Generic` must go last: `class {cls.__name__}({bases_str}): ...`)'\n                            )\n                    raise TypeError(error_message)\n\n                cls.__pydantic_generic_metadata__ = {\n                    'origin': None,\n                    'args': (),\n                    'parameters': parameters,\n                }\n\n            cls.__pydantic_complete__ = False  # Ensure this specific class gets completed\n\n            # preserve `__set_name__` protocol defined in https://peps.python.org/pep-0487\n            # for attributes not in `new_namespace` (e.g. private attributes)\n            for name, obj in private_attributes.items():\n                obj.__set_name__(cls, name)\n\n            if __pydantic_reset_parent_namespace__:\n                cls.__pydantic_parent_namespace__ = build_lenient_weakvaluedict(parent_frame_namespace())\n            parent_namespace = getattr(cls, '__pydantic_parent_namespace__', None)\n            if isinstance(parent_namespace, dict):\n                parent_namespace = unpack_lenient_weakvaluedict(parent_namespace)\n\n            types_namespace = get_cls_types_namespace(cls, parent_namespace)\n            set_model_fields(cls, bases, config_wrapper, types_namespace)\n\n            if config_wrapper.frozen and '__hash__' not in namespace:\n                set_default_hash_func(cls, bases)\n\n            complete_model_class(\n                cls,\n                cls_name,\n                config_wrapper,\n                raise_errors=False,\n                types_namespace=types_namespace,\n                create_model_module=_create_model_module,\n            )\n\n            # If this is placed before the complete_model_class call above,\n            # the generic computed fields return type is set to PydanticUndefined\n            cls.model_computed_fields = {k: v.info for k, v in cls.__pydantic_decorators__.computed_fields.items()}\n\n            set_deprecated_descriptors(cls)\n\n            # using super(cls, cls) on the next line ensures we only call the parent class's __pydantic_init_subclass__\n            # I believe the `type: ignore` is only necessary because mypy doesn't realize that this code branch is\n            # only hit for _proper_ subclasses of BaseModel\n            super(cls, cls).__pydantic_init_subclass__(**kwargs)  # type: ignore[misc]\n            return cls\n        else:\n            # this is the BaseModel class itself being created, no logic required\n            return super().__new__(mcs, cls_name, bases, namespace, **kwargs)\n\n    if not typing.TYPE_CHECKING:  # pragma: no branch\n        # We put `__getattr__` in a non-TYPE_CHECKING block because otherwise, mypy allows arbitrary attribute access\n\n        def __getattr__(self, item: str) -> Any:\n            \"\"\"This is necessary to keep attribute access working for class attribute access.\"\"\"\n            private_attributes = self.__dict__.get('__private_attributes__')\n            if private_attributes and item in private_attributes:\n                return private_attributes[item]\n            raise AttributeError(item)\n\n    @classmethod\n    def __prepare__(cls, *args: Any, **kwargs: Any) -> dict[str, object]:\n        return _ModelNamespaceDict()\n\n    def __instancecheck__(self, instance: Any) -> bool:\n        \"\"\"Avoid calling ABC _abc_subclasscheck unless we're pretty sure.\n\n        See #3829 and python/cpython#92810\n        \"\"\"\n        return hasattr(instance, '__pydantic_validator__') and super().__instancecheck__(instance)\n\n    @staticmethod\n    def _collect_bases_data(bases: tuple[type[Any], ...]) -> tuple[set[str], set[str], dict[str, ModelPrivateAttr]]:\n        from ..main import BaseModel\n\n        field_names: set[str] = set()\n        class_vars: set[str] = set()\n        private_attributes: dict[str, ModelPrivateAttr] = {}\n        for base in bases:\n            if issubclass(base, BaseModel) and base is not BaseModel:\n                # model_fields might not be defined yet in the case of generics, so we use getattr here:\n                field_names.update(getattr(base, 'model_fields', {}).keys())\n                class_vars.update(base.__class_vars__)\n                private_attributes.update(base.__private_attributes__)\n        return field_names, class_vars, private_attributes\n\n    @property\n    @deprecated('The `__fields__` attribute is deprecated, use `model_fields` instead.', category=None)\n    def __fields__(self) -> dict[str, FieldInfo]:\n        warnings.warn(\n            'The `__fields__` attribute is deprecated, use `model_fields` instead.', PydanticDeprecatedSince20\n        )\n        return self.model_fields  # type: ignore\n\n    def __dir__(self) -> list[str]:\n        attributes = list(super().__dir__())\n        if '__fields__' in attributes:\n            attributes.remove('__fields__')\n        return attributes\n\n\ndef init_private_attributes(self: BaseModel, context: Any, /) -> None:\n    \"\"\"This function is meant to behave like a BaseModel method to initialise private attributes.\n\n    It takes context as an argument since that's what pydantic-core passes when calling it.\n\n    Args:\n        self: The BaseModel instance.\n        context: The context.\n    \"\"\"\n    if getattr(self, '__pydantic_private__', None) is None:\n        pydantic_private = {}\n        for name, private_attr in self.__private_attributes__.items():\n            default = private_attr.get_default()\n            if default is not PydanticUndefined:\n                pydantic_private[name] = default\n        object_setattr(self, '__pydantic_private__', pydantic_private)\n\n\ndef get_model_post_init(namespace: dict[str, Any], bases: tuple[type[Any], ...]) -> Callable[..., Any] | None:\n    \"\"\"Get the `model_post_init` method from the namespace or the class bases, or `None` if not defined.\"\"\"\n    if 'model_post_init' in namespace:\n        return namespace['model_post_init']\n\n    from ..main import BaseModel\n\n    model_post_init = get_attribute_from_bases(bases, 'model_post_init')\n    if model_post_init is not BaseModel.model_post_init:\n        return model_post_init\n\n\ndef inspect_namespace(  # noqa C901\n    namespace: dict[str, Any],\n    ignored_types: tuple[type[Any], ...],\n    base_class_vars: set[str],\n    base_class_fields: set[str],\n) -> dict[str, ModelPrivateAttr]:\n    \"\"\"Iterate over the namespace and:\n    * gather private attributes\n    * check for items which look like fields but are not (e.g. have no annotation) and warn.\n\n    Args:\n        namespace: The attribute dictionary of the class to be created.\n        ignored_types: A tuple of ignore types.\n        base_class_vars: A set of base class class variables.\n        base_class_fields: A set of base class fields.\n\n    Returns:\n        A dict contains private attributes info.\n\n    Raises:\n        TypeError: If there is a `__root__` field in model.\n        NameError: If private attribute name is invalid.\n        PydanticUserError:\n            - If a field does not have a type annotation.\n            - If a field on base class was overridden by a non-annotated attribute.\n    \"\"\"\n    from ..fields import FieldInfo, ModelPrivateAttr, PrivateAttr\n\n    all_ignored_types = ignored_types + default_ignored_types()\n\n    private_attributes: dict[str, ModelPrivateAttr] = {}\n    raw_annotations = namespace.get('__annotations__', {})\n\n    if '__root__' in raw_annotations or '__root__' in namespace:\n        raise TypeError(\"To define root models, use `pydantic.RootModel` rather than a field called '__root__'\")\n\n    ignored_names: set[str] = set()\n    for var_name, value in list(namespace.items()):\n        if var_name == 'model_config' or var_name == '__pydantic_extra__':\n            continue\n        elif (\n            isinstance(value, type)\n            and value.__module__ == namespace['__module__']\n            and '__qualname__' in namespace\n            and value.__qualname__.startswith(namespace['__qualname__'])\n        ):\n            # `value` is a nested type defined in this namespace; don't error\n            continue\n        elif isinstance(value, all_ignored_types) or value.__class__.__module__ == 'functools':\n            ignored_names.add(var_name)\n            continue\n        elif isinstance(value, ModelPrivateAttr):\n            if var_name.startswith('__'):\n                raise NameError(\n                    'Private attributes must not use dunder names;'\n                    f' use a single underscore prefix instead of {var_name!r}.'\n                )\n            elif is_valid_field_name(var_name):\n                raise NameError(\n                    'Private attributes must not use valid field names;'\n                    f' use sunder names, e.g. {\"_\" + var_name!r} instead of {var_name!r}.'\n                )\n            private_attributes[var_name] = value\n            del namespace[var_name]\n        elif isinstance(value, FieldInfo) and not is_valid_field_name(var_name):\n            suggested_name = var_name.lstrip('_') or 'my_field'  # don't suggest '' for all-underscore name\n            raise NameError(\n                f'Fields must not use names with leading underscores;'\n                f' e.g., use {suggested_name!r} instead of {var_name!r}.'\n            )\n\n        elif var_name.startswith('__'):\n            continue\n        elif is_valid_privateattr_name(var_name):\n            if var_name not in raw_annotations or not is_classvar(raw_annotations[var_name]):\n                private_attributes[var_name] = PrivateAttr(default=value)\n                del namespace[var_name]\n        elif var_name in base_class_vars:\n            continue\n        elif var_name not in raw_annotations:\n            if var_name in base_class_fields:\n                raise PydanticUserError(\n                    f'Field {var_name!r} defined on a base class was overridden by a non-annotated attribute. '\n                    f'All field definitions, including overrides, require a type annotation.',\n                    code='model-field-overridden',\n                )\n            elif isinstance(value, FieldInfo):\n                raise PydanticUserError(\n                    f'Field {var_name!r} requires a type annotation', code='model-field-missing-annotation'\n                )\n            else:\n                raise PydanticUserError(\n                    f'A non-annotated attribute was detected: `{var_name} = {value!r}`. All model fields require a '\n                    f'type annotation; if `{var_name}` is not meant to be a field, you may be able to resolve this '\n                    f\"error by annotating it as a `ClassVar` or updating `model_config['ignored_types']`.\",\n                    code='model-field-missing-annotation',\n                )\n\n    for ann_name, ann_type in raw_annotations.items():\n        if (\n            is_valid_privateattr_name(ann_name)\n            and ann_name not in private_attributes\n            and ann_name not in ignored_names\n            and not is_classvar(ann_type)\n            and ann_type not in all_ignored_types\n            and getattr(ann_type, '__module__', None) != 'functools'\n        ):\n            if is_annotated(ann_type):\n                _, *metadata = typing_extensions.get_args(ann_type)\n                private_attr = next((v for v in metadata if isinstance(v, ModelPrivateAttr)), None)\n                if private_attr is not None:\n                    private_attributes[ann_name] = private_attr\n                    continue\n            private_attributes[ann_name] = PrivateAttr()\n\n    return private_attributes\n\n\ndef set_default_hash_func(cls: type[BaseModel], bases: tuple[type[Any], ...]) -> None:\n    base_hash_func = get_attribute_from_bases(bases, '__hash__')\n    new_hash_func = make_hash_func(cls)\n    if base_hash_func in {None, object.__hash__} or getattr(base_hash_func, '__code__', None) == new_hash_func.__code__:\n        # If `__hash__` is some default, we generate a hash function.\n        # It will be `None` if not overridden from BaseModel.\n        # It may be `object.__hash__` if there is another\n        # parent class earlier in the bases which doesn't override `__hash__` (e.g. `typing.Generic`).\n        # It may be a value set by `set_default_hash_func` if `cls` is a subclass of another frozen model.\n        # In the last case we still need a new hash function to account for new `model_fields`.\n        cls.__hash__ = new_hash_func\n\n\ndef make_hash_func(cls: type[BaseModel]) -> Any:\n    getter = operator.itemgetter(*cls.model_fields.keys()) if cls.model_fields else lambda _: 0\n\n    def hash_func(self: Any) -> int:\n        try:\n            return hash(getter(self.__dict__))\n        except KeyError:\n            # In rare cases (such as when using the deprecated copy method), the __dict__ may not contain\n            # all model fields, which is how we can get here.\n            # getter(self.__dict__) is much faster than any 'safe' method that accounts for missing keys,\n            # and wrapping it in a `try` doesn't slow things down much in the common case.\n            return hash(getter(SafeGetItemProxy(self.__dict__)))\n\n    return hash_func\n\n\ndef set_model_fields(\n    cls: type[BaseModel], bases: tuple[type[Any], ...], config_wrapper: ConfigWrapper, types_namespace: dict[str, Any]\n) -> None:\n    \"\"\"Collect and set `cls.model_fields` and `cls.__class_vars__`.\n\n    Args:\n        cls: BaseModel or dataclass.\n        bases: Parents of the class, generally `cls.__bases__`.\n        config_wrapper: The config wrapper instance.\n        types_namespace: Optional extra namespace to look for types in.\n    \"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    fields, class_vars = collect_model_fields(cls, bases, config_wrapper, types_namespace, typevars_map=typevars_map)\n\n    cls.model_fields = fields\n    cls.__class_vars__.update(class_vars)\n\n    for k in class_vars:\n        # Class vars should not be private attributes\n        #     We remove them _here_ and not earlier because we rely on inspecting the class to determine its classvars,\n        #     but private attributes are determined by inspecting the namespace _prior_ to class creation.\n        #     In the case that a classvar with a leading-'_' is defined via a ForwardRef (e.g., when using\n        #     `__future__.annotations`), we want to remove the private attribute which was detected _before_ we knew it\n        #     evaluated to a classvar\n\n        value = cls.__private_attributes__.pop(k, None)\n        if value is not None and value.default is not PydanticUndefined:\n            setattr(cls, k, value.default)\n\n\ndef complete_model_class(\n    cls: type[BaseModel],\n    cls_name: str,\n    config_wrapper: ConfigWrapper,\n    *,\n    raise_errors: bool = True,\n    types_namespace: dict[str, Any] | None,\n    create_model_module: str | None = None,\n) -> bool:\n    \"\"\"Finish building a model class.\n\n    This logic must be called after class has been created since validation functions must be bound\n    and `get_type_hints` requires a class object.\n\n    Args:\n        cls: BaseModel or dataclass.\n        cls_name: The model or dataclass name.\n        config_wrapper: The config wrapper instance.\n        raise_errors: Whether to raise errors.\n        types_namespace: Optional extra namespace to look for types in.\n        create_model_module: The module of the class to be created, if created by `create_model`.\n\n    Returns:\n        `True` if the model is successfully completed, else `False`.\n\n    Raises:\n        PydanticUndefinedAnnotation: If `PydanticUndefinedAnnotation` occurs in`__get_pydantic_core_schema__`\n            and `raise_errors=True`.\n    \"\"\"\n    typevars_map = get_model_typevars_map(cls)\n    gen_schema = GenerateSchema(\n        config_wrapper,\n        types_namespace,\n        typevars_map,\n    )\n\n    handler = CallbackGetCoreSchemaHandler(\n        partial(gen_schema.generate_schema, from_dunder_get_core_schema=False),\n        gen_schema,\n        ref_mode='unpack',\n    )\n\n    if config_wrapper.defer_build and 'model' in config_wrapper.experimental_defer_build_mode:\n        set_model_mocks(cls, cls_name)\n        return False\n\n    try:\n        schema = cls.__get_pydantic_core_schema__(cls, handler)\n    except PydanticUndefinedAnnotation as e:\n        if raise_errors:\n            raise\n        set_model_mocks(cls, cls_name, f'`{e.name}`')\n        return False\n\n    core_config = config_wrapper.core_config(cls)\n\n    try:\n        schema = gen_schema.clean_schema(schema)\n    except gen_schema.CollectedInvalid:\n        set_model_mocks(cls, cls_name)\n        return False\n\n    # debug(schema)\n    cls.__pydantic_core_schema__ = schema\n\n    cls.__pydantic_validator__ = create_schema_validator(\n        schema,\n        cls,\n        create_model_module or cls.__module__,\n        cls.__qualname__,\n        'create_model' if create_model_module else 'BaseModel',\n        core_config,\n        config_wrapper.plugin_settings,\n    )\n    cls.__pydantic_serializer__ = SchemaSerializer(schema, core_config)\n    cls.__pydantic_complete__ = True\n\n    # set __signature__ attr only for model class, but not for its instances\n    cls.__signature__ = ClassAttribute(\n        '__signature__',\n        generate_pydantic_signature(init=cls.__init__, fields=cls.model_fields, config_wrapper=config_wrapper),\n    )\n    return True\n\n\ndef set_deprecated_descriptors(cls: type[BaseModel]) -> None:\n    \"\"\"Set data descriptors on the class for deprecated fields.\"\"\"\n    for field, field_info in cls.model_fields.items():\n        if (msg := field_info.deprecation_message) is not None:\n            desc = _DeprecatedFieldDescriptor(msg)\n            desc.__set_name__(cls, field)\n            setattr(cls, field, desc)\n\n    for field, computed_field_info in cls.model_computed_fields.items():\n        if (\n            (msg := computed_field_info.deprecation_message) is not None\n            # Avoid having two warnings emitted:\n            and not hasattr(unwrap_wrapped_function(computed_field_info.wrapped_property), '__deprecated__')\n        ):\n            desc = _DeprecatedFieldDescriptor(msg, computed_field_info.wrapped_property)\n            desc.__set_name__(cls, field)\n            setattr(cls, field, desc)\n\n\nclass _DeprecatedFieldDescriptor:\n    \"\"\"Data descriptor used to emit a runtime deprecation warning before accessing a deprecated field.\n\n    Attributes:\n        msg: The deprecation message to be emitted.\n        wrapped_property: The property instance if the deprecated field is a computed field, or `None`.\n        field_name: The name of the field being deprecated.\n    \"\"\"\n\n    field_name: str\n\n    def __init__(self, msg: str, wrapped_property: property | None = None) -> None:\n        self.msg = msg\n        self.wrapped_property = wrapped_property\n\n    def __set_name__(self, cls: type[BaseModel], name: str) -> None:\n        self.field_name = name\n\n    def __get__(self, obj: BaseModel | None, obj_type: type[BaseModel] | None = None) -> Any:\n        if obj is None:\n            raise AttributeError(self.field_name)\n\n        warnings.warn(self.msg, builtins.DeprecationWarning, stacklevel=2)\n\n        if self.wrapped_property is not None:\n            return self.wrapped_property.__get__(obj, obj_type)\n        return obj.__dict__[self.field_name]\n\n    # Defined to take precedence over the instance's dictionary\n    # Note that it will not be called when setting a value on a model instance\n    # as `BaseModel.__setattr__` is defined and takes priority.\n    def __set__(self, obj: Any, value: Any) -> NoReturn:\n        raise AttributeError(self.field_name)\n\n\nclass _PydanticWeakRef:\n    \"\"\"Wrapper for `weakref.ref` that enables `pickle` serialization.\n\n    Cloudpickle fails to serialize `weakref.ref` objects due to an arcane error related\n    to abstract base classes (`abc.ABC`). This class works around the issue by wrapping\n    `weakref.ref` instead of subclassing it.\n\n    See https://github.com/pydantic/pydantic/issues/6763 for context.\n\n    Semantics:\n        - If not pickled, behaves the same as a `weakref.ref`.\n        - If pickled along with the referenced object, the same `weakref.ref` behavior\n          will be maintained between them after unpickling.\n        - If pickled without the referenced object, after unpickling the underlying\n          reference will be cleared (`__call__` will always return `None`).\n    \"\"\"\n\n    def __init__(self, obj: Any):\n        if obj is None:\n            # The object will be `None` upon deserialization if the serialized weakref\n            # had lost its underlying object.\n            self._wr = None\n        else:\n            self._wr = weakref.ref(obj)\n\n    def __call__(self) -> Any:\n        if self._wr is None:\n            return None\n        else:\n            return self._wr()\n\n    def __reduce__(self) -> tuple[Callable, tuple[weakref.ReferenceType | None]]:\n        return _PydanticWeakRef, (self(),)\n\n\ndef build_lenient_weakvaluedict(d: dict[str, Any] | None) -> dict[str, Any] | None:\n    \"\"\"Takes an input dictionary, and produces a new value that (invertibly) replaces the values with weakrefs.\n\n    We can't just use a WeakValueDictionary because many types (including int, str, etc.) can't be stored as values\n    in a WeakValueDictionary.\n\n    The `unpack_lenient_weakvaluedict` function can be used to reverse this operation.\n    \"\"\"\n    if d is None:\n        return None\n    result = {}\n    for k, v in d.items():\n        try:\n            proxy = _PydanticWeakRef(v)\n        except TypeError:\n            proxy = v\n        result[k] = proxy\n    return result\n\n\ndef unpack_lenient_weakvaluedict(d: dict[str, Any] | None) -> dict[str, Any] | None:\n    \"\"\"Inverts the transform performed by `build_lenient_weakvaluedict`.\"\"\"\n    if d is None:\n        return None\n\n    result = {}\n    for k, v in d.items():\n        if isinstance(v, _PydanticWeakRef):\n            v = v()\n            if v is not None:\n                result[k] = v\n        else:\n            result[k] = v\n    return result\n\n\ndef default_ignored_types() -> tuple[type[Any], ...]:\n    from ..fields import ComputedFieldInfo\n\n    return (\n        FunctionType,\n        property,\n        classmethod,\n        staticmethod,\n        PydanticDescriptorProxy,\n        ComputedFieldInfo,\n        ValidateCallWrapper,\n    )\n", "pydantic/_internal/_config.py": "from __future__ import annotations as _annotations\n\nimport warnings\nfrom contextlib import contextmanager\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    cast,\n)\n\nfrom pydantic_core import core_schema\nfrom typing_extensions import (\n    Literal,\n    Self,\n)\n\nfrom ..aliases import AliasGenerator\nfrom ..config import ConfigDict, ExtraValues, JsonDict, JsonEncoder, JsonSchemaExtraCallable\nfrom ..errors import PydanticUserError\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\nif TYPE_CHECKING:\n    from .._internal._schema_generation_shared import GenerateSchema\n    from ..fields import ComputedFieldInfo, FieldInfo\n\nDEPRECATION_MESSAGE = 'Support for class-based `config` is deprecated, use ConfigDict instead.'\n\n\nclass ConfigWrapper:\n    \"\"\"Internal wrapper for Config which exposes ConfigDict items as attributes.\"\"\"\n\n    __slots__ = ('config_dict',)\n\n    config_dict: ConfigDict\n\n    # all annotations are copied directly from ConfigDict, and should be kept up to date, a test will fail if they\n    # stop matching\n    title: str | None\n    str_to_lower: bool\n    str_to_upper: bool\n    str_strip_whitespace: bool\n    str_min_length: int\n    str_max_length: int | None\n    extra: ExtraValues | None\n    frozen: bool\n    populate_by_name: bool\n    use_enum_values: bool\n    validate_assignment: bool\n    arbitrary_types_allowed: bool\n    from_attributes: bool\n    # whether to use the actual key provided in the data (e.g. alias or first alias for \"field required\" errors) instead of field_names\n    # to construct error `loc`s, default `True`\n    loc_by_alias: bool\n    alias_generator: Callable[[str], str] | AliasGenerator | None\n    model_title_generator: Callable[[type], str] | None\n    field_title_generator: Callable[[str, FieldInfo | ComputedFieldInfo], str] | None\n    ignored_types: tuple[type, ...]\n    allow_inf_nan: bool\n    json_schema_extra: JsonDict | JsonSchemaExtraCallable | None\n    json_encoders: dict[type[object], JsonEncoder] | None\n\n    # new in V2\n    strict: bool\n    # whether instances of models and dataclasses (including subclass instances) should re-validate, default 'never'\n    revalidate_instances: Literal['always', 'never', 'subclass-instances']\n    ser_json_timedelta: Literal['iso8601', 'float']\n    ser_json_bytes: Literal['utf8', 'base64']\n    ser_json_inf_nan: Literal['null', 'constants']\n    # whether to validate default values during validation, default False\n    validate_default: bool\n    validate_return: bool\n    protected_namespaces: tuple[str, ...]\n    hide_input_in_errors: bool\n    defer_build: bool\n    experimental_defer_build_mode: tuple[Literal['model', 'type_adapter'], ...]\n    plugin_settings: dict[str, object] | None\n    schema_generator: type[GenerateSchema] | None\n    json_schema_serialization_defaults_required: bool\n    json_schema_mode_override: Literal['validation', 'serialization', None]\n    coerce_numbers_to_str: bool\n    regex_engine: Literal['rust-regex', 'python-re']\n    validation_error_cause: bool\n    use_attribute_docstrings: bool\n    cache_strings: bool | Literal['all', 'keys', 'none']\n\n    def __init__(self, config: ConfigDict | dict[str, Any] | type[Any] | None, *, check: bool = True):\n        if check:\n            self.config_dict = prepare_config(config)\n        else:\n            self.config_dict = cast(ConfigDict, config)\n\n    @classmethod\n    def for_model(cls, bases: tuple[type[Any], ...], namespace: dict[str, Any], kwargs: dict[str, Any]) -> Self:\n        \"\"\"Build a new `ConfigWrapper` instance for a `BaseModel`.\n\n        The config wrapper built based on (in descending order of priority):\n        - options from `kwargs`\n        - options from the `namespace`\n        - options from the base classes (`bases`)\n\n        Args:\n            bases: A tuple of base classes.\n            namespace: The namespace of the class being created.\n            kwargs: The kwargs passed to the class being created.\n\n        Returns:\n            A `ConfigWrapper` instance for `BaseModel`.\n        \"\"\"\n        config_new = ConfigDict()\n        for base in bases:\n            config = getattr(base, 'model_config', None)\n            if config:\n                config_new.update(config.copy())\n\n        config_class_from_namespace = namespace.get('Config')\n        config_dict_from_namespace = namespace.get('model_config')\n\n        raw_annotations = namespace.get('__annotations__', {})\n        if raw_annotations.get('model_config') and not config_dict_from_namespace:\n            raise PydanticUserError(\n                '`model_config` cannot be used as a model field name. Use `model_config` for model configuration.',\n                code='model-config-invalid-field-name',\n            )\n\n        if config_class_from_namespace and config_dict_from_namespace:\n            raise PydanticUserError('\"Config\" and \"model_config\" cannot be used together', code='config-both')\n\n        config_from_namespace = config_dict_from_namespace or prepare_config(config_class_from_namespace)\n\n        config_new.update(config_from_namespace)\n\n        for k in list(kwargs.keys()):\n            if k in config_keys:\n                config_new[k] = kwargs.pop(k)\n\n        return cls(config_new)\n\n    # we don't show `__getattr__` to type checkers so missing attributes cause errors\n    if not TYPE_CHECKING:  # pragma: no branch\n\n        def __getattr__(self, name: str) -> Any:\n            try:\n                return self.config_dict[name]\n            except KeyError:\n                try:\n                    return config_defaults[name]\n                except KeyError:\n                    raise AttributeError(f'Config has no attribute {name!r}') from None\n\n    def core_config(self, obj: Any) -> core_schema.CoreConfig:\n        \"\"\"Create a pydantic-core config, `obj` is just used to populate `title` if not set in config.\n\n        Pass `obj=None` if you do not want to attempt to infer the `title`.\n\n        We don't use getattr here since we don't want to populate with defaults.\n\n        Args:\n            obj: An object used to populate `title` if not set in config.\n\n        Returns:\n            A `CoreConfig` object created from config.\n        \"\"\"\n\n        def dict_not_none(**kwargs: Any) -> Any:\n            return {k: v for k, v in kwargs.items() if v is not None}\n\n        core_config = core_schema.CoreConfig(\n            **dict_not_none(\n                title=self.config_dict.get('title') or (obj and obj.__name__),\n                extra_fields_behavior=self.config_dict.get('extra'),\n                allow_inf_nan=self.config_dict.get('allow_inf_nan'),\n                populate_by_name=self.config_dict.get('populate_by_name'),\n                str_strip_whitespace=self.config_dict.get('str_strip_whitespace'),\n                str_to_lower=self.config_dict.get('str_to_lower'),\n                str_to_upper=self.config_dict.get('str_to_upper'),\n                strict=self.config_dict.get('strict'),\n                ser_json_timedelta=self.config_dict.get('ser_json_timedelta'),\n                ser_json_bytes=self.config_dict.get('ser_json_bytes'),\n                ser_json_inf_nan=self.config_dict.get('ser_json_inf_nan'),\n                from_attributes=self.config_dict.get('from_attributes'),\n                loc_by_alias=self.config_dict.get('loc_by_alias'),\n                revalidate_instances=self.config_dict.get('revalidate_instances'),\n                validate_default=self.config_dict.get('validate_default'),\n                str_max_length=self.config_dict.get('str_max_length'),\n                str_min_length=self.config_dict.get('str_min_length'),\n                hide_input_in_errors=self.config_dict.get('hide_input_in_errors'),\n                coerce_numbers_to_str=self.config_dict.get('coerce_numbers_to_str'),\n                regex_engine=self.config_dict.get('regex_engine'),\n                validation_error_cause=self.config_dict.get('validation_error_cause'),\n                cache_strings=self.config_dict.get('cache_strings'),\n            )\n        )\n        return core_config\n\n    def __repr__(self):\n        c = ', '.join(f'{k}={v!r}' for k, v in self.config_dict.items())\n        return f'ConfigWrapper({c})'\n\n\nclass ConfigWrapperStack:\n    \"\"\"A stack of `ConfigWrapper` instances.\"\"\"\n\n    def __init__(self, config_wrapper: ConfigWrapper):\n        self._config_wrapper_stack: list[ConfigWrapper] = [config_wrapper]\n\n    @property\n    def tail(self) -> ConfigWrapper:\n        return self._config_wrapper_stack[-1]\n\n    @contextmanager\n    def push(self, config_wrapper: ConfigWrapper | ConfigDict | None):\n        if config_wrapper is None:\n            yield\n            return\n\n        if not isinstance(config_wrapper, ConfigWrapper):\n            config_wrapper = ConfigWrapper(config_wrapper, check=False)\n\n        self._config_wrapper_stack.append(config_wrapper)\n        try:\n            yield\n        finally:\n            self._config_wrapper_stack.pop()\n\n\nconfig_defaults = ConfigDict(\n    title=None,\n    str_to_lower=False,\n    str_to_upper=False,\n    str_strip_whitespace=False,\n    str_min_length=0,\n    str_max_length=None,\n    # let the model / dataclass decide how to handle it\n    extra=None,\n    frozen=False,\n    populate_by_name=False,\n    use_enum_values=False,\n    validate_assignment=False,\n    arbitrary_types_allowed=False,\n    from_attributes=False,\n    loc_by_alias=True,\n    alias_generator=None,\n    model_title_generator=None,\n    field_title_generator=None,\n    ignored_types=(),\n    allow_inf_nan=True,\n    json_schema_extra=None,\n    strict=False,\n    revalidate_instances='never',\n    ser_json_timedelta='iso8601',\n    ser_json_bytes='utf8',\n    ser_json_inf_nan='null',\n    validate_default=False,\n    validate_return=False,\n    protected_namespaces=('model_',),\n    hide_input_in_errors=False,\n    json_encoders=None,\n    defer_build=False,\n    experimental_defer_build_mode=('model',),\n    plugin_settings=None,\n    schema_generator=None,\n    json_schema_serialization_defaults_required=False,\n    json_schema_mode_override=None,\n    coerce_numbers_to_str=False,\n    regex_engine='rust-regex',\n    validation_error_cause=False,\n    use_attribute_docstrings=False,\n    cache_strings=True,\n)\n\n\ndef prepare_config(config: ConfigDict | dict[str, Any] | type[Any] | None) -> ConfigDict:\n    \"\"\"Create a `ConfigDict` instance from an existing dict, a class (e.g. old class-based config) or None.\n\n    Args:\n        config: The input config.\n\n    Returns:\n        A ConfigDict object created from config.\n    \"\"\"\n    if config is None:\n        return ConfigDict()\n\n    if not isinstance(config, dict):\n        warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)\n        config = {k: getattr(config, k) for k in dir(config) if not k.startswith('__')}\n\n    config_dict = cast(ConfigDict, config)\n    check_deprecated(config_dict)\n    return config_dict\n\n\nconfig_keys = set(ConfigDict.__annotations__.keys())\n\n\nV2_REMOVED_KEYS = {\n    'allow_mutation',\n    'error_msg_templates',\n    'fields',\n    'getter_dict',\n    'smart_union',\n    'underscore_attrs_are_private',\n    'json_loads',\n    'json_dumps',\n    'copy_on_model_validation',\n    'post_init_call',\n}\nV2_RENAMED_KEYS = {\n    'allow_population_by_field_name': 'populate_by_name',\n    'anystr_lower': 'str_to_lower',\n    'anystr_strip_whitespace': 'str_strip_whitespace',\n    'anystr_upper': 'str_to_upper',\n    'keep_untouched': 'ignored_types',\n    'max_anystr_length': 'str_max_length',\n    'min_anystr_length': 'str_min_length',\n    'orm_mode': 'from_attributes',\n    'schema_extra': 'json_schema_extra',\n    'validate_all': 'validate_default',\n}\n\n\ndef check_deprecated(config_dict: ConfigDict) -> None:\n    \"\"\"Check for deprecated config keys and warn the user.\n\n    Args:\n        config_dict: The input config.\n    \"\"\"\n    deprecated_removed_keys = V2_REMOVED_KEYS & config_dict.keys()\n    deprecated_renamed_keys = V2_RENAMED_KEYS.keys() & config_dict.keys()\n    if deprecated_removed_keys or deprecated_renamed_keys:\n        renamings = {k: V2_RENAMED_KEYS[k] for k in sorted(deprecated_renamed_keys)}\n        renamed_bullets = [f'* {k!r} has been renamed to {v!r}' for k, v in renamings.items()]\n        removed_bullets = [f'* {k!r} has been removed' for k in sorted(deprecated_removed_keys)]\n        message = '\\n'.join(['Valid config keys have changed in V2:'] + renamed_bullets + removed_bullets)\n        warnings.warn(message, UserWarning)\n", "pydantic/_internal/_utils.py": "\"\"\"Bucket of reusable internal utilities.\n\nThis should be reduced as much as possible with functions only used in one place, moved to that place.\n\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport keyword\nimport typing\nimport weakref\nfrom collections import OrderedDict, defaultdict, deque\nfrom copy import deepcopy\nfrom itertools import zip_longest\nfrom types import BuiltinFunctionType, CodeType, FunctionType, GeneratorType, LambdaType, ModuleType\nfrom typing import Any, Mapping, TypeVar\n\nfrom typing_extensions import TypeAlias, TypeGuard\n\nfrom . import _repr, _typing_extra\n\nif typing.TYPE_CHECKING:\n    MappingIntStrAny: TypeAlias = 'typing.Mapping[int, Any] | typing.Mapping[str, Any]'\n    AbstractSetIntStr: TypeAlias = 'typing.AbstractSet[int] | typing.AbstractSet[str]'\n    from ..main import BaseModel\n\n\n# these are types that are returned unchanged by deepcopy\nIMMUTABLE_NON_COLLECTIONS_TYPES: set[type[Any]] = {\n    int,\n    float,\n    complex,\n    str,\n    bool,\n    bytes,\n    type,\n    _typing_extra.NoneType,\n    FunctionType,\n    BuiltinFunctionType,\n    LambdaType,\n    weakref.ref,\n    CodeType,\n    # note: including ModuleType will differ from behaviour of deepcopy by not producing error.\n    # It might be not a good idea in general, but considering that this function used only internally\n    # against default values of fields, this will allow to actually have a field with module as default value\n    ModuleType,\n    NotImplemented.__class__,\n    Ellipsis.__class__,\n}\n\n# these are types that if empty, might be copied with simple copy() instead of deepcopy()\nBUILTIN_COLLECTIONS: set[type[Any]] = {\n    list,\n    set,\n    tuple,\n    frozenset,\n    dict,\n    OrderedDict,\n    defaultdict,\n    deque,\n}\n\n\ndef sequence_like(v: Any) -> bool:\n    return isinstance(v, (list, tuple, set, frozenset, GeneratorType, deque))\n\n\ndef lenient_isinstance(o: Any, class_or_tuple: type[Any] | tuple[type[Any], ...] | None) -> bool:  # pragma: no cover\n    try:\n        return isinstance(o, class_or_tuple)  # type: ignore[arg-type]\n    except TypeError:\n        return False\n\n\ndef lenient_issubclass(cls: Any, class_or_tuple: Any) -> bool:  # pragma: no cover\n    try:\n        return isinstance(cls, type) and issubclass(cls, class_or_tuple)\n    except TypeError:\n        if isinstance(cls, _typing_extra.WithArgsTypes):\n            return False\n        raise  # pragma: no cover\n\n\ndef is_model_class(cls: Any) -> TypeGuard[type[BaseModel]]:\n    \"\"\"Returns true if cls is a _proper_ subclass of BaseModel, and provides proper type-checking,\n    unlike raw calls to lenient_issubclass.\n    \"\"\"\n    from ..main import BaseModel\n\n    return lenient_issubclass(cls, BaseModel) and cls is not BaseModel\n\n\ndef is_valid_identifier(identifier: str) -> bool:\n    \"\"\"Checks that a string is a valid identifier and not a Python keyword.\n    :param identifier: The identifier to test.\n    :return: True if the identifier is valid.\n    \"\"\"\n    return identifier.isidentifier() and not keyword.iskeyword(identifier)\n\n\nKeyType = TypeVar('KeyType')\n\n\ndef deep_update(mapping: dict[KeyType, Any], *updating_mappings: dict[KeyType, Any]) -> dict[KeyType, Any]:\n    updated_mapping = mapping.copy()\n    for updating_mapping in updating_mappings:\n        for k, v in updating_mapping.items():\n            if k in updated_mapping and isinstance(updated_mapping[k], dict) and isinstance(v, dict):\n                updated_mapping[k] = deep_update(updated_mapping[k], v)\n            else:\n                updated_mapping[k] = v\n    return updated_mapping\n\n\ndef update_not_none(mapping: dict[Any, Any], **update: Any) -> None:\n    mapping.update({k: v for k, v in update.items() if v is not None})\n\n\nT = TypeVar('T')\n\n\ndef unique_list(\n    input_list: list[T] | tuple[T, ...],\n    *,\n    name_factory: typing.Callable[[T], str] = str,\n) -> list[T]:\n    \"\"\"Make a list unique while maintaining order.\n    We update the list if another one with the same name is set\n    (e.g. model validator overridden in subclass).\n    \"\"\"\n    result: list[T] = []\n    result_names: list[str] = []\n    for v in input_list:\n        v_name = name_factory(v)\n        if v_name not in result_names:\n            result_names.append(v_name)\n            result.append(v)\n        else:\n            result[result_names.index(v_name)] = v\n\n    return result\n\n\nclass ValueItems(_repr.Representation):\n    \"\"\"Class for more convenient calculation of excluded or included fields on values.\"\"\"\n\n    __slots__ = ('_items', '_type')\n\n    def __init__(self, value: Any, items: AbstractSetIntStr | MappingIntStrAny) -> None:\n        items = self._coerce_items(items)\n\n        if isinstance(value, (list, tuple)):\n            items = self._normalize_indexes(items, len(value))  # type: ignore\n\n        self._items: MappingIntStrAny = items  # type: ignore\n\n    def is_excluded(self, item: Any) -> bool:\n        \"\"\"Check if item is fully excluded.\n\n        :param item: key or index of a value\n        \"\"\"\n        return self.is_true(self._items.get(item))\n\n    def is_included(self, item: Any) -> bool:\n        \"\"\"Check if value is contained in self._items.\n\n        :param item: key or index of value\n        \"\"\"\n        return item in self._items\n\n    def for_element(self, e: int | str) -> AbstractSetIntStr | MappingIntStrAny | None:\n        \"\"\":param e: key or index of element on value\n        :return: raw values for element if self._items is dict and contain needed element\n        \"\"\"\n        item = self._items.get(e)  # type: ignore\n        return item if not self.is_true(item) else None\n\n    def _normalize_indexes(self, items: MappingIntStrAny, v_length: int) -> dict[int | str, Any]:\n        \"\"\":param items: dict or set of indexes which will be normalized\n        :param v_length: length of sequence indexes of which will be\n\n        >>> self._normalize_indexes({0: True, -2: True, -1: True}, 4)\n        {0: True, 2: True, 3: True}\n        >>> self._normalize_indexes({'__all__': True}, 4)\n        {0: True, 1: True, 2: True, 3: True}\n        \"\"\"\n        normalized_items: dict[int | str, Any] = {}\n        all_items = None\n        for i, v in items.items():\n            if not (isinstance(v, typing.Mapping) or isinstance(v, typing.AbstractSet) or self.is_true(v)):\n                raise TypeError(f'Unexpected type of exclude value for index \"{i}\" {v.__class__}')\n            if i == '__all__':\n                all_items = self._coerce_value(v)\n                continue\n            if not isinstance(i, int):\n                raise TypeError(\n                    'Excluding fields from a sequence of sub-models or dicts must be performed index-wise: '\n                    'expected integer keys or keyword \"__all__\"'\n                )\n            normalized_i = v_length + i if i < 0 else i\n            normalized_items[normalized_i] = self.merge(v, normalized_items.get(normalized_i))\n\n        if not all_items:\n            return normalized_items\n        if self.is_true(all_items):\n            for i in range(v_length):\n                normalized_items.setdefault(i, ...)\n            return normalized_items\n        for i in range(v_length):\n            normalized_item = normalized_items.setdefault(i, {})\n            if not self.is_true(normalized_item):\n                normalized_items[i] = self.merge(all_items, normalized_item)\n        return normalized_items\n\n    @classmethod\n    def merge(cls, base: Any, override: Any, intersect: bool = False) -> Any:\n        \"\"\"Merge a `base` item with an `override` item.\n\n        Both `base` and `override` are converted to dictionaries if possible.\n        Sets are converted to dictionaries with the sets entries as keys and\n        Ellipsis as values.\n\n        Each key-value pair existing in `base` is merged with `override`,\n        while the rest of the key-value pairs are updated recursively with this function.\n\n        Merging takes place based on the \"union\" of keys if `intersect` is\n        set to `False` (default) and on the intersection of keys if\n        `intersect` is set to `True`.\n        \"\"\"\n        override = cls._coerce_value(override)\n        base = cls._coerce_value(base)\n        if override is None:\n            return base\n        if cls.is_true(base) or base is None:\n            return override\n        if cls.is_true(override):\n            return base if intersect else override\n\n        # intersection or union of keys while preserving ordering:\n        if intersect:\n            merge_keys = [k for k in base if k in override] + [k for k in override if k in base]\n        else:\n            merge_keys = list(base) + [k for k in override if k not in base]\n\n        merged: dict[int | str, Any] = {}\n        for k in merge_keys:\n            merged_item = cls.merge(base.get(k), override.get(k), intersect=intersect)\n            if merged_item is not None:\n                merged[k] = merged_item\n\n        return merged\n\n    @staticmethod\n    def _coerce_items(items: AbstractSetIntStr | MappingIntStrAny) -> MappingIntStrAny:\n        if isinstance(items, typing.Mapping):\n            pass\n        elif isinstance(items, typing.AbstractSet):\n            items = dict.fromkeys(items, ...)  # type: ignore\n        else:\n            class_name = getattr(items, '__class__', '???')\n            raise TypeError(f'Unexpected type of exclude value {class_name}')\n        return items  # type: ignore\n\n    @classmethod\n    def _coerce_value(cls, value: Any) -> Any:\n        if value is None or cls.is_true(value):\n            return value\n        return cls._coerce_items(value)\n\n    @staticmethod\n    def is_true(v: Any) -> bool:\n        return v is True or v is ...\n\n    def __repr_args__(self) -> _repr.ReprArgs:\n        return [(None, self._items)]\n\n\nif typing.TYPE_CHECKING:\n\n    def ClassAttribute(name: str, value: T) -> T: ...\n\nelse:\n\n    class ClassAttribute:\n        \"\"\"Hide class attribute from its instances.\"\"\"\n\n        __slots__ = 'name', 'value'\n\n        def __init__(self, name: str, value: Any) -> None:\n            self.name = name\n            self.value = value\n\n        def __get__(self, instance: Any, owner: type[Any]) -> None:\n            if instance is None:\n                return self.value\n            raise AttributeError(f'{self.name!r} attribute of {owner.__name__!r} is class-only')\n\n\nObj = TypeVar('Obj')\n\n\ndef smart_deepcopy(obj: Obj) -> Obj:\n    \"\"\"Return type as is for immutable built-in types\n    Use obj.copy() for built-in empty collections\n    Use copy.deepcopy() for non-empty collections and unknown objects.\n    \"\"\"\n    obj_type = obj.__class__\n    if obj_type in IMMUTABLE_NON_COLLECTIONS_TYPES:\n        return obj  # fastest case: obj is immutable and not collection therefore will not be copied anyway\n    try:\n        if not obj and obj_type in BUILTIN_COLLECTIONS:\n            # faster way for empty collections, no need to copy its members\n            return obj if obj_type is tuple else obj.copy()  # tuple doesn't have copy method  # type: ignore\n    except (TypeError, ValueError, RuntimeError):\n        # do we really dare to catch ALL errors? Seems a bit risky\n        pass\n\n    return deepcopy(obj)  # slowest way when we actually might need a deepcopy\n\n\n_SENTINEL = object()\n\n\ndef all_identical(left: typing.Iterable[Any], right: typing.Iterable[Any]) -> bool:\n    \"\"\"Check that the items of `left` are the same objects as those in `right`.\n\n    >>> a, b = object(), object()\n    >>> all_identical([a, b, a], [a, b, a])\n    True\n    >>> all_identical([a, b, [a]], [a, b, [a]])  # new list object, while \"equal\" is not \"identical\"\n    False\n    \"\"\"\n    for left_item, right_item in zip_longest(left, right, fillvalue=_SENTINEL):\n        if left_item is not right_item:\n            return False\n    return True\n\n\n@dataclasses.dataclass(frozen=True)\nclass SafeGetItemProxy:\n    \"\"\"Wrapper redirecting `__getitem__` to `get` with a sentinel value as default\n\n    This makes is safe to use in `operator.itemgetter` when some keys may be missing\n    \"\"\"\n\n    # Define __slots__manually for performances\n    # @dataclasses.dataclass() only support slots=True in python>=3.10\n    __slots__ = ('wrapped',)\n\n    wrapped: Mapping[str, Any]\n\n    def __getitem__(self, key: str, /) -> Any:\n        return self.wrapped.get(key, _SENTINEL)\n\n    # required to pass the object to operator.itemgetter() instances due to a quirk of typeshed\n    # https://github.com/python/mypy/issues/13713\n    # https://github.com/python/typeshed/pull/8785\n    # Since this is typing-only, hide it in a typing.TYPE_CHECKING block\n    if typing.TYPE_CHECKING:\n\n        def __contains__(self, key: str, /) -> bool:\n            return self.wrapped.__contains__(key)\n", "pydantic/_internal/_discriminated_union.py": "from __future__ import annotations as _annotations\n\nfrom typing import TYPE_CHECKING, Any, Hashable, Sequence\n\nfrom pydantic_core import CoreSchema, core_schema\n\nfrom ..errors import PydanticUserError\nfrom . import _core_utils\nfrom ._core_utils import (\n    CoreSchemaField,\n    collect_definitions,\n)\n\nif TYPE_CHECKING:\n    from ..types import Discriminator\n\nCORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY = 'pydantic.internal.union_discriminator'\n\n\nclass MissingDefinitionForUnionRef(Exception):\n    \"\"\"Raised when applying a discriminated union discriminator to a schema\n    requires a definition that is not yet defined\n    \"\"\"\n\n    def __init__(self, ref: str) -> None:\n        self.ref = ref\n        super().__init__(f'Missing definition for ref {self.ref!r}')\n\n\ndef set_discriminator_in_metadata(schema: CoreSchema, discriminator: Any) -> None:\n    schema.setdefault('metadata', {})\n    metadata = schema.get('metadata')\n    assert metadata is not None\n    metadata[CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY] = discriminator\n\n\ndef apply_discriminators(schema: core_schema.CoreSchema) -> core_schema.CoreSchema:\n    # We recursively walk through the `schema` passed to `apply_discriminators`, applying discriminators\n    # where necessary at each level. During this recursion, we allow references to be resolved from the definitions\n    # that are originally present on the original, outermost `schema`. Before `apply_discriminators` is called,\n    # `simplify_schema_references` is called on the schema (in the `clean_schema` function),\n    # which often puts the definitions in the outermost schema.\n    global_definitions: dict[str, CoreSchema] = collect_definitions(schema)\n\n    def inner(s: core_schema.CoreSchema, recurse: _core_utils.Recurse) -> core_schema.CoreSchema:\n        nonlocal global_definitions\n\n        s = recurse(s, inner)\n        if s['type'] == 'tagged-union':\n            return s\n\n        metadata = s.get('metadata', {})\n        discriminator = metadata.pop(CORE_SCHEMA_METADATA_DISCRIMINATOR_PLACEHOLDER_KEY, None)\n        if discriminator is not None:\n            s = apply_discriminator(s, discriminator, global_definitions)\n        return s\n\n    return _core_utils.walk_core_schema(schema, inner)\n\n\ndef apply_discriminator(\n    schema: core_schema.CoreSchema,\n    discriminator: str | Discriminator,\n    definitions: dict[str, core_schema.CoreSchema] | None = None,\n) -> core_schema.CoreSchema:\n    \"\"\"Applies the discriminator and returns a new core schema.\n\n    Args:\n        schema: The input schema.\n        discriminator: The name of the field which will serve as the discriminator.\n        definitions: A mapping of schema ref to schema.\n\n    Returns:\n        The new core schema.\n\n    Raises:\n        TypeError:\n            - If `discriminator` is used with invalid union variant.\n            - If `discriminator` is used with `Union` type with one variant.\n            - If `discriminator` value mapped to multiple choices.\n        MissingDefinitionForUnionRef:\n            If the definition for ref is missing.\n        PydanticUserError:\n            - If a model in union doesn't have a discriminator field.\n            - If discriminator field has a non-string alias.\n            - If discriminator fields have different aliases.\n            - If discriminator field not of type `Literal`.\n    \"\"\"\n    from ..types import Discriminator\n\n    if isinstance(discriminator, Discriminator):\n        if isinstance(discriminator.discriminator, str):\n            discriminator = discriminator.discriminator\n        else:\n            return discriminator._convert_schema(schema)\n\n    return _ApplyInferredDiscriminator(discriminator, definitions or {}).apply(schema)\n\n\nclass _ApplyInferredDiscriminator:\n    \"\"\"This class is used to convert an input schema containing a union schema into one where that union is\n    replaced with a tagged-union, with all the associated debugging and performance benefits.\n\n    This is done by:\n    * Validating that the input schema is compatible with the provided discriminator\n    * Introspecting the schema to determine which discriminator values should map to which union choices\n    * Handling various edge cases such as 'definitions', 'default', 'nullable' schemas, and more\n\n    I have chosen to implement the conversion algorithm in this class, rather than a function,\n    to make it easier to maintain state while recursively walking the provided CoreSchema.\n    \"\"\"\n\n    def __init__(self, discriminator: str, definitions: dict[str, core_schema.CoreSchema]):\n        # `discriminator` should be the name of the field which will serve as the discriminator.\n        # It must be the python name of the field, and *not* the field's alias. Note that as of now,\n        # all members of a discriminated union _must_ use a field with the same name as the discriminator.\n        # This may change if/when we expose a way to manually specify the TaggedUnionSchema's choices.\n        self.discriminator = discriminator\n\n        # `definitions` should contain a mapping of schema ref to schema for all schemas which might\n        # be referenced by some choice\n        self.definitions = definitions\n\n        # `_discriminator_alias` will hold the value, if present, of the alias for the discriminator\n        #\n        # Note: following the v1 implementation, we currently disallow the use of different aliases\n        # for different choices. This is not a limitation of pydantic_core, but if we try to handle\n        # this, the inference logic gets complicated very quickly, and could result in confusing\n        # debugging challenges for users making subtle mistakes.\n        #\n        # Rather than trying to do the most powerful inference possible, I think we should eventually\n        # expose a way to more-manually control the way the TaggedUnionSchema is constructed through\n        # the use of a new type which would be placed as an Annotation on the Union type. This would\n        # provide the full flexibility/power of pydantic_core's TaggedUnionSchema where necessary for\n        # more complex cases, without over-complicating the inference logic for the common cases.\n        self._discriminator_alias: str | None = None\n\n        # `_should_be_nullable` indicates whether the converted union has `None` as an allowed value.\n        # If `None` is an acceptable value of the (possibly-wrapped) union, we ignore it while\n        # constructing the TaggedUnionSchema, but set the `_should_be_nullable` attribute to True.\n        # Once we have constructed the TaggedUnionSchema, if `_should_be_nullable` is True, we ensure\n        # that the final schema gets wrapped as a NullableSchema. This has the same semantics on the\n        # python side, but resolves the issue that `None` cannot correspond to any discriminator values.\n        self._should_be_nullable = False\n\n        # `_is_nullable` is used to track if the final produced schema will definitely be nullable;\n        # we set it to True if the input schema is wrapped in a nullable schema that we know will be preserved\n        # as an indication that, even if None is discovered as one of the union choices, we will not need to wrap\n        # the final value in another nullable schema.\n        #\n        # This is more complicated than just checking for the final outermost schema having type 'nullable' thanks\n        # to the possible presence of other wrapper schemas such as DefinitionsSchema, WithDefaultSchema, etc.\n        self._is_nullable = False\n\n        # `_choices_to_handle` serves as a stack of choices to add to the tagged union. Initially, choices\n        # from the union in the wrapped schema will be appended to this list, and the recursive choice-handling\n        # algorithm may add more choices to this stack as (nested) unions are encountered.\n        self._choices_to_handle: list[core_schema.CoreSchema] = []\n\n        # `_tagged_union_choices` is built during the call to `apply`, and will hold the choices to be included\n        # in the output TaggedUnionSchema that will replace the union from the input schema\n        self._tagged_union_choices: dict[Hashable, core_schema.CoreSchema] = {}\n\n        # `_used` is changed to True after applying the discriminator to prevent accidental re-use\n        self._used = False\n\n    def apply(self, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:\n        \"\"\"Return a new CoreSchema based on `schema` that uses a tagged-union with the discriminator provided\n        to this class.\n\n        Args:\n            schema: The input schema.\n\n        Returns:\n            The new core schema.\n\n        Raises:\n            TypeError:\n                - If `discriminator` is used with invalid union variant.\n                - If `discriminator` is used with `Union` type with one variant.\n                - If `discriminator` value mapped to multiple choices.\n            ValueError:\n                If the definition for ref is missing.\n            PydanticUserError:\n                - If a model in union doesn't have a discriminator field.\n                - If discriminator field has a non-string alias.\n                - If discriminator fields have different aliases.\n                - If discriminator field not of type `Literal`.\n        \"\"\"\n        assert not self._used\n        schema = self._apply_to_root(schema)\n        if self._should_be_nullable and not self._is_nullable:\n            schema = core_schema.nullable_schema(schema)\n        self._used = True\n        return schema\n\n    def _apply_to_root(self, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:\n        \"\"\"This method handles the outer-most stage of recursion over the input schema:\n        unwrapping nullable or definitions schemas, and calling the `_handle_choice`\n        method iteratively on the choices extracted (recursively) from the possibly-wrapped union.\n        \"\"\"\n        if schema['type'] == 'nullable':\n            self._is_nullable = True\n            wrapped = self._apply_to_root(schema['schema'])\n            nullable_wrapper = schema.copy()\n            nullable_wrapper['schema'] = wrapped\n            return nullable_wrapper\n\n        if schema['type'] == 'definitions':\n            wrapped = self._apply_to_root(schema['schema'])\n            definitions_wrapper = schema.copy()\n            definitions_wrapper['schema'] = wrapped\n            return definitions_wrapper\n\n        if schema['type'] != 'union':\n            # If the schema is not a union, it probably means it just had a single member and\n            # was flattened by pydantic_core.\n            # However, it still may make sense to apply the discriminator to this schema,\n            # as a way to get discriminated-union-style error messages, so we allow this here.\n            schema = core_schema.union_schema([schema])\n\n        # Reverse the choices list before extending the stack so that they get handled in the order they occur\n        choices_schemas = [v[0] if isinstance(v, tuple) else v for v in schema['choices'][::-1]]\n        self._choices_to_handle.extend(choices_schemas)\n        while self._choices_to_handle:\n            choice = self._choices_to_handle.pop()\n            self._handle_choice(choice)\n\n        if self._discriminator_alias is not None and self._discriminator_alias != self.discriminator:\n            # * We need to annotate `discriminator` as a union here to handle both branches of this conditional\n            # * We need to annotate `discriminator` as list[list[str | int]] and not list[list[str]] due to the\n            #   invariance of list, and because list[list[str | int]] is the type of the discriminator argument\n            #   to tagged_union_schema below\n            # * See the docstring of pydantic_core.core_schema.tagged_union_schema for more details about how to\n            #   interpret the value of the discriminator argument to tagged_union_schema. (The list[list[str]] here\n            #   is the appropriate way to provide a list of fallback attributes to check for a discriminator value.)\n            discriminator: str | list[list[str | int]] = [[self.discriminator], [self._discriminator_alias]]\n        else:\n            discriminator = self.discriminator\n        return core_schema.tagged_union_schema(\n            choices=self._tagged_union_choices,\n            discriminator=discriminator,\n            custom_error_type=schema.get('custom_error_type'),\n            custom_error_message=schema.get('custom_error_message'),\n            custom_error_context=schema.get('custom_error_context'),\n            strict=False,\n            from_attributes=True,\n            ref=schema.get('ref'),\n            metadata=schema.get('metadata'),\n            serialization=schema.get('serialization'),\n        )\n\n    def _handle_choice(self, choice: core_schema.CoreSchema) -> None:\n        \"\"\"This method handles the \"middle\" stage of recursion over the input schema.\n        Specifically, it is responsible for handling each choice of the outermost union\n        (and any \"coalesced\" choices obtained from inner unions).\n\n        Here, \"handling\" entails:\n        * Coalescing nested unions and compatible tagged-unions\n        * Tracking the presence of 'none' and 'nullable' schemas occurring as choices\n        * Validating that each allowed discriminator value maps to a unique choice\n        * Updating the _tagged_union_choices mapping that will ultimately be used to build the TaggedUnionSchema.\n        \"\"\"\n        if choice['type'] == 'definition-ref':\n            if choice['schema_ref'] not in self.definitions:\n                raise MissingDefinitionForUnionRef(choice['schema_ref'])\n\n        if choice['type'] == 'none':\n            self._should_be_nullable = True\n        elif choice['type'] == 'definitions':\n            self._handle_choice(choice['schema'])\n        elif choice['type'] == 'nullable':\n            self._should_be_nullable = True\n            self._handle_choice(choice['schema'])  # unwrap the nullable schema\n        elif choice['type'] == 'union':\n            # Reverse the choices list before extending the stack so that they get handled in the order they occur\n            choices_schemas = [v[0] if isinstance(v, tuple) else v for v in choice['choices'][::-1]]\n            self._choices_to_handle.extend(choices_schemas)\n        elif choice['type'] not in {\n            'model',\n            'typed-dict',\n            'tagged-union',\n            'lax-or-strict',\n            'dataclass',\n            'dataclass-args',\n            'definition-ref',\n        } and not _core_utils.is_function_with_inner_schema(choice):\n            # We should eventually handle 'definition-ref' as well\n            raise TypeError(\n                f'{choice[\"type\"]!r} is not a valid discriminated union variant;'\n                ' should be a `BaseModel` or `dataclass`'\n            )\n        else:\n            if choice['type'] == 'tagged-union' and self._is_discriminator_shared(choice):\n                # In this case, this inner tagged-union is compatible with the outer tagged-union,\n                # and its choices can be coalesced into the outer TaggedUnionSchema.\n                subchoices = [x for x in choice['choices'].values() if not isinstance(x, (str, int))]\n                # Reverse the choices list before extending the stack so that they get handled in the order they occur\n                self._choices_to_handle.extend(subchoices[::-1])\n                return\n\n            inferred_discriminator_values = self._infer_discriminator_values_for_choice(choice, source_name=None)\n            self._set_unique_choice_for_values(choice, inferred_discriminator_values)\n\n    def _is_discriminator_shared(self, choice: core_schema.TaggedUnionSchema) -> bool:\n        \"\"\"This method returns a boolean indicating whether the discriminator for the `choice`\n        is the same as that being used for the outermost tagged union. This is used to\n        determine whether this TaggedUnionSchema choice should be \"coalesced\" into the top level,\n        or whether it should be treated as a separate (nested) choice.\n        \"\"\"\n        inner_discriminator = choice['discriminator']\n        return inner_discriminator == self.discriminator or (\n            isinstance(inner_discriminator, list)\n            and (self.discriminator in inner_discriminator or [self.discriminator] in inner_discriminator)\n        )\n\n    def _infer_discriminator_values_for_choice(  # noqa C901\n        self, choice: core_schema.CoreSchema, source_name: str | None\n    ) -> list[str | int]:\n        \"\"\"This function recurses over `choice`, extracting all discriminator values that should map to this choice.\n\n        `model_name` is accepted for the purpose of producing useful error messages.\n        \"\"\"\n        if choice['type'] == 'definitions':\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=source_name)\n        elif choice['type'] == 'function-plain':\n            raise TypeError(\n                f'{choice[\"type\"]!r} is not a valid discriminated union variant;'\n                ' should be a `BaseModel` or `dataclass`'\n            )\n        elif _core_utils.is_function_with_inner_schema(choice):\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=source_name)\n        elif choice['type'] == 'lax-or-strict':\n            return sorted(\n                set(\n                    self._infer_discriminator_values_for_choice(choice['lax_schema'], source_name=None)\n                    + self._infer_discriminator_values_for_choice(choice['strict_schema'], source_name=None)\n                )\n            )\n\n        elif choice['type'] == 'tagged-union':\n            values: list[str | int] = []\n            # Ignore str/int \"choices\" since these are just references to other choices\n            subchoices = [x for x in choice['choices'].values() if not isinstance(x, (str, int))]\n            for subchoice in subchoices:\n                subchoice_values = self._infer_discriminator_values_for_choice(subchoice, source_name=None)\n                values.extend(subchoice_values)\n            return values\n\n        elif choice['type'] == 'union':\n            values = []\n            for subchoice in choice['choices']:\n                subchoice_schema = subchoice[0] if isinstance(subchoice, tuple) else subchoice\n                subchoice_values = self._infer_discriminator_values_for_choice(subchoice_schema, source_name=None)\n                values.extend(subchoice_values)\n            return values\n\n        elif choice['type'] == 'nullable':\n            self._should_be_nullable = True\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=None)\n\n        elif choice['type'] == 'model':\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=choice['cls'].__name__)\n\n        elif choice['type'] == 'dataclass':\n            return self._infer_discriminator_values_for_choice(choice['schema'], source_name=choice['cls'].__name__)\n\n        elif choice['type'] == 'model-fields':\n            return self._infer_discriminator_values_for_model_choice(choice, source_name=source_name)\n\n        elif choice['type'] == 'dataclass-args':\n            return self._infer_discriminator_values_for_dataclass_choice(choice, source_name=source_name)\n\n        elif choice['type'] == 'typed-dict':\n            return self._infer_discriminator_values_for_typed_dict_choice(choice, source_name=source_name)\n\n        elif choice['type'] == 'definition-ref':\n            schema_ref = choice['schema_ref']\n            if schema_ref not in self.definitions:\n                raise MissingDefinitionForUnionRef(schema_ref)\n            return self._infer_discriminator_values_for_choice(self.definitions[schema_ref], source_name=source_name)\n        else:\n            raise TypeError(\n                f'{choice[\"type\"]!r} is not a valid discriminated union variant;'\n                ' should be a `BaseModel` or `dataclass`'\n            )\n\n    def _infer_discriminator_values_for_typed_dict_choice(\n        self, choice: core_schema.TypedDictSchema, source_name: str | None = None\n    ) -> list[str | int]:\n        \"\"\"This method just extracts the _infer_discriminator_values_for_choice logic specific to TypedDictSchema\n        for the sake of readability.\n        \"\"\"\n        source = 'TypedDict' if source_name is None else f'TypedDict {source_name!r}'\n        field = choice['fields'].get(self.discriminator)\n        if field is None:\n            raise PydanticUserError(\n                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'\n            )\n        return self._infer_discriminator_values_for_field(field, source)\n\n    def _infer_discriminator_values_for_model_choice(\n        self, choice: core_schema.ModelFieldsSchema, source_name: str | None = None\n    ) -> list[str | int]:\n        source = 'ModelFields' if source_name is None else f'Model {source_name!r}'\n        field = choice['fields'].get(self.discriminator)\n        if field is None:\n            raise PydanticUserError(\n                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'\n            )\n        return self._infer_discriminator_values_for_field(field, source)\n\n    def _infer_discriminator_values_for_dataclass_choice(\n        self, choice: core_schema.DataclassArgsSchema, source_name: str | None = None\n    ) -> list[str | int]:\n        source = 'DataclassArgs' if source_name is None else f'Dataclass {source_name!r}'\n        for field in choice['fields']:\n            if field['name'] == self.discriminator:\n                break\n        else:\n            raise PydanticUserError(\n                f'{source} needs a discriminator field for key {self.discriminator!r}', code='discriminator-no-field'\n            )\n        return self._infer_discriminator_values_for_field(field, source)\n\n    def _infer_discriminator_values_for_field(self, field: CoreSchemaField, source: str) -> list[str | int]:\n        if field['type'] == 'computed-field':\n            # This should never occur as a discriminator, as it is only relevant to serialization\n            return []\n        alias = field.get('validation_alias', self.discriminator)\n        if not isinstance(alias, str):\n            raise PydanticUserError(\n                f'Alias {alias!r} is not supported in a discriminated union', code='discriminator-alias-type'\n            )\n        if self._discriminator_alias is None:\n            self._discriminator_alias = alias\n        elif self._discriminator_alias != alias:\n            raise PydanticUserError(\n                f'Aliases for discriminator {self.discriminator!r} must be the same '\n                f'(got {alias}, {self._discriminator_alias})',\n                code='discriminator-alias',\n            )\n        return self._infer_discriminator_values_for_inner_schema(field['schema'], source)\n\n    def _infer_discriminator_values_for_inner_schema(\n        self, schema: core_schema.CoreSchema, source: str\n    ) -> list[str | int]:\n        \"\"\"When inferring discriminator values for a field, we typically extract the expected values from a literal\n        schema. This function does that, but also handles nested unions and defaults.\n        \"\"\"\n        if schema['type'] == 'literal':\n            return schema['expected']\n\n        elif schema['type'] == 'union':\n            # Generally when multiple values are allowed they should be placed in a single `Literal`, but\n            # we add this case to handle the situation where a field is annotated as a `Union` of `Literal`s.\n            # For example, this lets us handle `Union[Literal['key'], Union[Literal['Key'], Literal['KEY']]]`\n            values: list[Any] = []\n            for choice in schema['choices']:\n                choice_schema = choice[0] if isinstance(choice, tuple) else choice\n                choice_values = self._infer_discriminator_values_for_inner_schema(choice_schema, source)\n                values.extend(choice_values)\n            return values\n\n        elif schema['type'] == 'default':\n            # This will happen if the field has a default value; we ignore it while extracting the discriminator values\n            return self._infer_discriminator_values_for_inner_schema(schema['schema'], source)\n\n        elif schema['type'] == 'function-after':\n            # After validators don't affect the discriminator values\n            return self._infer_discriminator_values_for_inner_schema(schema['schema'], source)\n\n        elif schema['type'] in {'function-before', 'function-wrap', 'function-plain'}:\n            validator_type = repr(schema['type'].split('-')[1])\n            raise PydanticUserError(\n                f'Cannot use a mode={validator_type} validator in the'\n                f' discriminator field {self.discriminator!r} of {source}',\n                code='discriminator-validator',\n            )\n\n        else:\n            raise PydanticUserError(\n                f'{source} needs field {self.discriminator!r} to be of type `Literal`',\n                code='discriminator-needs-literal',\n            )\n\n    def _set_unique_choice_for_values(self, choice: core_schema.CoreSchema, values: Sequence[str | int]) -> None:\n        \"\"\"This method updates `self.tagged_union_choices` so that all provided (discriminator) `values` map to the\n        provided `choice`, validating that none of these values already map to another (different) choice.\n        \"\"\"\n        for discriminator_value in values:\n            if discriminator_value in self._tagged_union_choices:\n                # It is okay if `value` is already in tagged_union_choices as long as it maps to the same value.\n                # Because tagged_union_choices may map values to other values, we need to walk the choices dict\n                # until we get to a \"real\" choice, and confirm that is equal to the one assigned.\n                existing_choice = self._tagged_union_choices[discriminator_value]\n                if existing_choice != choice:\n                    raise TypeError(\n                        f'Value {discriminator_value!r} for discriminator '\n                        f'{self.discriminator!r} mapped to multiple choices'\n                    )\n            else:\n                self._tagged_union_choices[discriminator_value] = choice\n", "pydantic/_internal/_generate_schema.py": "\"\"\"Convert python types to pydantic-core schema.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport collections.abc\nimport dataclasses\nimport inspect\nimport re\nimport sys\nimport typing\nimport warnings\nfrom contextlib import ExitStack, contextmanager\nfrom copy import copy, deepcopy\nfrom enum import Enum\nfrom functools import partial\nfrom inspect import Parameter, _ParameterKind, signature\nfrom itertools import chain\nfrom operator import attrgetter\nfrom types import FunctionType, LambdaType, MethodType\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    Dict,\n    Final,\n    ForwardRef,\n    Iterable,\n    Iterator,\n    Mapping,\n    Type,\n    TypeVar,\n    Union,\n    cast,\n    overload,\n)\nfrom warnings import warn\n\nfrom pydantic_core import CoreSchema, PydanticUndefined, core_schema, to_jsonable_python\nfrom typing_extensions import Annotated, Literal, TypeAliasType, TypedDict, get_args, get_origin, is_typeddict\n\nfrom ..aliases import AliasGenerator\nfrom ..annotated_handlers import GetCoreSchemaHandler, GetJsonSchemaHandler\nfrom ..config import ConfigDict, JsonDict, JsonEncoder\nfrom ..errors import PydanticSchemaGenerationError, PydanticUndefinedAnnotation, PydanticUserError\nfrom ..json_schema import JsonSchemaValue\nfrom ..version import version_short\nfrom ..warnings import PydanticDeprecatedSince20\nfrom . import _core_utils, _decorators, _discriminated_union, _known_annotated_metadata, _typing_extra\nfrom ._config import ConfigWrapper, ConfigWrapperStack\nfrom ._core_metadata import CoreMetadataHandler, build_metadata_dict\nfrom ._core_utils import (\n    CoreSchemaOrField,\n    collect_invalid_schemas,\n    define_expected_missing_refs,\n    get_ref,\n    get_type_ref,\n    is_function_with_inner_schema,\n    is_list_like_schema_with_items_schema,\n    simplify_schema_references,\n    validate_core_schema,\n)\nfrom ._decorators import (\n    Decorator,\n    DecoratorInfos,\n    FieldSerializerDecoratorInfo,\n    FieldValidatorDecoratorInfo,\n    ModelSerializerDecoratorInfo,\n    ModelValidatorDecoratorInfo,\n    RootValidatorDecoratorInfo,\n    ValidatorDecoratorInfo,\n    get_attribute_from_bases,\n    inspect_field_serializer,\n    inspect_model_serializer,\n    inspect_validator,\n)\nfrom ._docs_extraction import extract_docstrings_from_cls\nfrom ._fields import collect_dataclass_fields, get_type_hints_infer_globalns\nfrom ._forward_ref import PydanticRecursiveRef\nfrom ._generics import get_standard_typevars_map, has_instance_in_type, recursively_defined_type_refs, replace_types\nfrom ._mock_val_ser import MockCoreSchema\nfrom ._schema_generation_shared import CallbackGetCoreSchemaHandler\nfrom ._typing_extra import is_finalvar, is_self_type\nfrom ._utils import lenient_issubclass\n\nif TYPE_CHECKING:\n    from ..fields import ComputedFieldInfo, FieldInfo\n    from ..main import BaseModel\n    from ..types import Discriminator\n    from ..validators import FieldValidatorModes\n    from ._dataclasses import StandardDataclass\n    from ._schema_generation_shared import GetJsonSchemaFunction\n\n_SUPPORTS_TYPEDDICT = sys.version_info >= (3, 12)\n_AnnotatedType = type(Annotated[int, 123])\n\nFieldDecoratorInfo = Union[ValidatorDecoratorInfo, FieldValidatorDecoratorInfo, FieldSerializerDecoratorInfo]\nFieldDecoratorInfoType = TypeVar('FieldDecoratorInfoType', bound=FieldDecoratorInfo)\nAnyFieldDecorator = Union[\n    Decorator[ValidatorDecoratorInfo],\n    Decorator[FieldValidatorDecoratorInfo],\n    Decorator[FieldSerializerDecoratorInfo],\n]\n\nModifyCoreSchemaWrapHandler = GetCoreSchemaHandler\nGetCoreSchemaFunction = Callable[[Any, ModifyCoreSchemaWrapHandler], core_schema.CoreSchema]\n\nTUPLE_TYPES: list[type] = [tuple, typing.Tuple]\nLIST_TYPES: list[type] = [list, typing.List, collections.abc.MutableSequence]\nSET_TYPES: list[type] = [set, typing.Set, collections.abc.MutableSet]\nFROZEN_SET_TYPES: list[type] = [frozenset, typing.FrozenSet, collections.abc.Set]\nDICT_TYPES: list[type] = [dict, typing.Dict, collections.abc.MutableMapping, collections.abc.Mapping]\n\n\ndef check_validator_fields_against_field_name(\n    info: FieldDecoratorInfo,\n    field: str,\n) -> bool:\n    \"\"\"Check if field name is in validator fields.\n\n    Args:\n        info: The field info.\n        field: The field name to check.\n\n    Returns:\n        `True` if field name is in validator fields, `False` otherwise.\n    \"\"\"\n    if '*' in info.fields:\n        return True\n    for v_field_name in info.fields:\n        if v_field_name == field:\n            return True\n    return False\n\n\ndef check_decorator_fields_exist(decorators: Iterable[AnyFieldDecorator], fields: Iterable[str]) -> None:\n    \"\"\"Check if the defined fields in decorators exist in `fields` param.\n\n    It ignores the check for a decorator if the decorator has `*` as field or `check_fields=False`.\n\n    Args:\n        decorators: An iterable of decorators.\n        fields: An iterable of fields name.\n\n    Raises:\n        PydanticUserError: If one of the field names does not exist in `fields` param.\n    \"\"\"\n    fields = set(fields)\n    for dec in decorators:\n        if '*' in dec.info.fields:\n            continue\n        if dec.info.check_fields is False:\n            continue\n        for field in dec.info.fields:\n            if field not in fields:\n                raise PydanticUserError(\n                    f'Decorators defined with incorrect fields: {dec.cls_ref}.{dec.cls_var_name}'\n                    \" (use check_fields=False if you're inheriting from the model and intended this)\",\n                    code='decorator-missing-field',\n                )\n\n\ndef filter_field_decorator_info_by_field(\n    validator_functions: Iterable[Decorator[FieldDecoratorInfoType]], field: str\n) -> list[Decorator[FieldDecoratorInfoType]]:\n    return [dec for dec in validator_functions if check_validator_fields_against_field_name(dec.info, field)]\n\n\ndef apply_each_item_validators(\n    schema: core_schema.CoreSchema,\n    each_item_validators: list[Decorator[ValidatorDecoratorInfo]],\n    field_name: str | None,\n) -> core_schema.CoreSchema:\n    # This V1 compatibility shim should eventually be removed\n\n    # push down any `each_item=True` validators\n    # note that this won't work for any Annotated types that get wrapped by a function validator\n    # but that's okay because that didn't exist in V1\n    if schema['type'] == 'nullable':\n        schema['schema'] = apply_each_item_validators(schema['schema'], each_item_validators, field_name)\n        return schema\n    elif schema['type'] == 'tuple':\n        if (variadic_item_index := schema.get('variadic_item_index')) is not None:\n            schema['items_schema'][variadic_item_index] = apply_validators(\n                schema['items_schema'][variadic_item_index], each_item_validators, field_name\n            )\n    elif is_list_like_schema_with_items_schema(schema):\n        inner_schema = schema.get('items_schema', None)\n        if inner_schema is None:\n            inner_schema = core_schema.any_schema()\n        schema['items_schema'] = apply_validators(inner_schema, each_item_validators, field_name)\n    elif schema['type'] == 'dict':\n        # push down any `each_item=True` validators onto dict _values_\n        # this is super arbitrary but it's the V1 behavior\n        inner_schema = schema.get('values_schema', None)\n        if inner_schema is None:\n            inner_schema = core_schema.any_schema()\n        schema['values_schema'] = apply_validators(inner_schema, each_item_validators, field_name)\n    elif each_item_validators:\n        raise TypeError(\n            f\"`@validator(..., each_item=True)` cannot be applied to fields with a schema of {schema['type']}\"\n        )\n    return schema\n\n\ndef modify_model_json_schema(\n    schema_or_field: CoreSchemaOrField,\n    handler: GetJsonSchemaHandler,\n    *,\n    cls: Any,\n    title: str | None = None,\n) -> JsonSchemaValue:\n    \"\"\"Add title and description for model-like classes' JSON schema.\n\n    Args:\n        schema_or_field: The schema data to generate a JSON schema from.\n        handler: The `GetCoreSchemaHandler` instance.\n        cls: The model-like class.\n        title: The title to set for the model's schema, defaults to the model's name\n\n    Returns:\n        JsonSchemaValue: The updated JSON schema.\n    \"\"\"\n    from ..dataclasses import is_pydantic_dataclass\n    from ..main import BaseModel\n    from ..root_model import RootModel\n    from ._dataclasses import is_builtin_dataclass\n\n    json_schema = handler(schema_or_field)\n    original_schema = handler.resolve_ref_schema(json_schema)\n    # Preserve the fact that definitions schemas should never have sibling keys:\n    if '$ref' in original_schema:\n        ref = original_schema['$ref']\n        original_schema.clear()\n        original_schema['allOf'] = [{'$ref': ref}]\n    if title is not None:\n        original_schema['title'] = title\n    elif 'title' not in original_schema:\n        original_schema['title'] = cls.__name__\n    # BaseModel + Dataclass; don't use cls.__doc__ as it will contain the verbose class signature by default\n    docstring = None if cls is BaseModel or is_builtin_dataclass(cls) or is_pydantic_dataclass(cls) else cls.__doc__\n    if docstring and 'description' not in original_schema:\n        original_schema['description'] = inspect.cleandoc(docstring)\n    elif issubclass(cls, RootModel) and cls.model_fields['root'].description:\n        original_schema['description'] = cls.model_fields['root'].description\n    return json_schema\n\n\nJsonEncoders = Dict[Type[Any], JsonEncoder]\n\n\ndef _add_custom_serialization_from_json_encoders(\n    json_encoders: JsonEncoders | None, tp: Any, schema: CoreSchema\n) -> CoreSchema:\n    \"\"\"Iterate over the json_encoders and add the first matching encoder to the schema.\n\n    Args:\n        json_encoders: A dictionary of types and their encoder functions.\n        tp: The type to check for a matching encoder.\n        schema: The schema to add the encoder to.\n    \"\"\"\n    if not json_encoders:\n        return schema\n    if 'serialization' in schema:\n        return schema\n    # Check the class type and its superclasses for a matching encoder\n    # Decimal.__class__.__mro__ (and probably other cases) doesn't include Decimal itself\n    # if the type is a GenericAlias (e.g. from list[int]) we need to use __class__ instead of .__mro__\n    for base in (tp, *getattr(tp, '__mro__', tp.__class__.__mro__)[:-1]):\n        encoder = json_encoders.get(base)\n        if encoder is None:\n            continue\n\n        warnings.warn(\n            f'`json_encoders` is deprecated. See https://docs.pydantic.dev/{version_short()}/concepts/serialization/#custom-serializers for alternatives',\n            PydanticDeprecatedSince20,\n        )\n\n        # TODO: in theory we should check that the schema accepts a serialization key\n        schema['serialization'] = core_schema.plain_serializer_function_ser_schema(encoder, when_used='json')\n        return schema\n\n    return schema\n\n\nTypesNamespace = Union[Dict[str, Any], None]\n\n\nclass TypesNamespaceStack:\n    \"\"\"A stack of types namespaces.\"\"\"\n\n    def __init__(self, types_namespace: TypesNamespace):\n        self._types_namespace_stack: list[TypesNamespace] = [types_namespace]\n\n    @property\n    def tail(self) -> TypesNamespace:\n        return self._types_namespace_stack[-1]\n\n    @contextmanager\n    def push(self, for_type: type[Any]):\n        types_namespace = {**_typing_extra.get_cls_types_namespace(for_type), **(self.tail or {})}\n        self._types_namespace_stack.append(types_namespace)\n        try:\n            yield\n        finally:\n            self._types_namespace_stack.pop()\n\n\ndef _get_first_non_null(a: Any, b: Any) -> Any:\n    \"\"\"Return the first argument if it is not None, otherwise return the second argument.\n\n    Use case: serialization_alias (argument a) and alias (argument b) are both defined, and serialization_alias is ''.\n    This function will return serialization_alias, which is the first argument, even though it is an empty string.\n    \"\"\"\n    return a if a is not None else b\n\n\nclass GenerateSchema:\n    \"\"\"Generate core schema for a Pydantic model, dataclass and types like `str`, `datetime`, ... .\"\"\"\n\n    __slots__ = (\n        '_config_wrapper_stack',\n        '_types_namespace_stack',\n        '_typevars_map',\n        'field_name_stack',\n        'model_type_stack',\n        'defs',\n    )\n\n    def __init__(\n        self,\n        config_wrapper: ConfigWrapper,\n        types_namespace: dict[str, Any] | None,\n        typevars_map: dict[Any, Any] | None = None,\n    ) -> None:\n        # we need a stack for recursing into child models\n        self._config_wrapper_stack = ConfigWrapperStack(config_wrapper)\n        self._types_namespace_stack = TypesNamespaceStack(types_namespace)\n        self._typevars_map = typevars_map\n        self.field_name_stack = _FieldNameStack()\n        self.model_type_stack = _ModelTypeStack()\n        self.defs = _Definitions()\n\n    @classmethod\n    def __from_parent(\n        cls,\n        config_wrapper_stack: ConfigWrapperStack,\n        types_namespace_stack: TypesNamespaceStack,\n        model_type_stack: _ModelTypeStack,\n        typevars_map: dict[Any, Any] | None,\n        defs: _Definitions,\n    ) -> GenerateSchema:\n        obj = cls.__new__(cls)\n        obj._config_wrapper_stack = config_wrapper_stack\n        obj._types_namespace_stack = types_namespace_stack\n        obj.model_type_stack = model_type_stack\n        obj._typevars_map = typevars_map\n        obj.field_name_stack = _FieldNameStack()\n        obj.defs = defs\n        return obj\n\n    @property\n    def _config_wrapper(self) -> ConfigWrapper:\n        return self._config_wrapper_stack.tail\n\n    @property\n    def _types_namespace(self) -> dict[str, Any] | None:\n        return self._types_namespace_stack.tail\n\n    @property\n    def _current_generate_schema(self) -> GenerateSchema:\n        cls = self._config_wrapper.schema_generator or GenerateSchema\n        return cls.__from_parent(\n            self._config_wrapper_stack,\n            self._types_namespace_stack,\n            self.model_type_stack,\n            self._typevars_map,\n            self.defs,\n        )\n\n    @property\n    def _arbitrary_types(self) -> bool:\n        return self._config_wrapper.arbitrary_types_allowed\n\n    def str_schema(self) -> CoreSchema:\n        \"\"\"Generate a CoreSchema for `str`\"\"\"\n        return core_schema.str_schema()\n\n    # the following methods can be overridden but should be considered\n    # unstable / private APIs\n    def _list_schema(self, tp: Any, items_type: Any) -> CoreSchema:\n        return core_schema.list_schema(self.generate_schema(items_type))\n\n    def _dict_schema(self, tp: Any, keys_type: Any, values_type: Any) -> CoreSchema:\n        return core_schema.dict_schema(self.generate_schema(keys_type), self.generate_schema(values_type))\n\n    def _set_schema(self, tp: Any, items_type: Any) -> CoreSchema:\n        return core_schema.set_schema(self.generate_schema(items_type))\n\n    def _frozenset_schema(self, tp: Any, items_type: Any) -> CoreSchema:\n        return core_schema.frozenset_schema(self.generate_schema(items_type))\n\n    def _arbitrary_type_schema(self, tp: Any) -> CoreSchema:\n        if not isinstance(tp, type):\n            warn(\n                f'{tp!r} is not a Python type (it may be an instance of an object),'\n                ' Pydantic will allow any object with no validation since we cannot even'\n                ' enforce that the input is an instance of the given type.'\n                ' To get rid of this error wrap the type with `pydantic.SkipValidation`.',\n                UserWarning,\n            )\n            return core_schema.any_schema()\n        return core_schema.is_instance_schema(tp)\n\n    def _unknown_type_schema(self, obj: Any) -> CoreSchema:\n        raise PydanticSchemaGenerationError(\n            f'Unable to generate pydantic-core schema for {obj!r}. '\n            'Set `arbitrary_types_allowed=True` in the model_config to ignore this error'\n            ' or implement `__get_pydantic_core_schema__` on your type to fully support it.'\n            '\\n\\nIf you got this error by calling handler(<some type>) within'\n            ' `__get_pydantic_core_schema__` then you likely need to call'\n            ' `handler.generate_schema(<some type>)` since we do not call'\n            ' `__get_pydantic_core_schema__` on `<some type>` otherwise to avoid infinite recursion.'\n        )\n\n    def _apply_discriminator_to_union(\n        self, schema: CoreSchema, discriminator: str | Discriminator | None\n    ) -> CoreSchema:\n        if discriminator is None:\n            return schema\n        try:\n            return _discriminated_union.apply_discriminator(\n                schema,\n                discriminator,\n            )\n        except _discriminated_union.MissingDefinitionForUnionRef:\n            # defer until defs are resolved\n            _discriminated_union.set_discriminator_in_metadata(\n                schema,\n                discriminator,\n            )\n            return schema\n\n    class CollectedInvalid(Exception):\n        pass\n\n    def clean_schema(self, schema: CoreSchema) -> CoreSchema:\n        schema = self.collect_definitions(schema)\n        schema = simplify_schema_references(schema)\n        if collect_invalid_schemas(schema):\n            raise self.CollectedInvalid()\n        schema = _discriminated_union.apply_discriminators(schema)\n        schema = validate_core_schema(schema)\n        return schema\n\n    def collect_definitions(self, schema: CoreSchema) -> CoreSchema:\n        ref = cast('str | None', schema.get('ref', None))\n        if ref:\n            self.defs.definitions[ref] = schema\n        if 'ref' in schema:\n            schema = core_schema.definition_reference_schema(schema['ref'])\n        return core_schema.definitions_schema(\n            schema,\n            list(self.defs.definitions.values()),\n        )\n\n    def _add_js_function(self, metadata_schema: CoreSchema, js_function: Callable[..., Any]) -> None:\n        metadata = CoreMetadataHandler(metadata_schema).metadata\n        pydantic_js_functions = metadata.setdefault('pydantic_js_functions', [])\n        # because of how we generate core schemas for nested generic models\n        # we can end up adding `BaseModel.__get_pydantic_json_schema__` multiple times\n        # this check may fail to catch duplicates if the function is a `functools.partial`\n        # or something like that\n        # but if it does it'll fail by inserting the duplicate\n        if js_function not in pydantic_js_functions:\n            pydantic_js_functions.append(js_function)\n\n    def generate_schema(\n        self,\n        obj: Any,\n        from_dunder_get_core_schema: bool = True,\n    ) -> core_schema.CoreSchema:\n        \"\"\"Generate core schema.\n\n        Args:\n            obj: The object to generate core schema for.\n            from_dunder_get_core_schema: Whether to generate schema from either the\n                `__get_pydantic_core_schema__` function or `__pydantic_core_schema__` property.\n\n        Returns:\n            The generated core schema.\n\n        Raises:\n            PydanticUndefinedAnnotation:\n                If it is not possible to evaluate forward reference.\n            PydanticSchemaGenerationError:\n                If it is not possible to generate pydantic-core schema.\n            TypeError:\n                - If `alias_generator` returns a disallowed type (must be str, AliasPath or AliasChoices).\n                - If V1 style validator with `each_item=True` applied on a wrong field.\n            PydanticUserError:\n                - If `typing.TypedDict` is used instead of `typing_extensions.TypedDict` on Python < 3.12.\n                - If `__modify_schema__` method is used instead of `__get_pydantic_json_schema__`.\n        \"\"\"\n        schema: CoreSchema | None = None\n\n        if from_dunder_get_core_schema:\n            from_property = self._generate_schema_from_property(obj, obj)\n            if from_property is not None:\n                schema = from_property\n\n        if schema is None:\n            schema = self._generate_schema_inner(obj)\n\n        metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)\n        if metadata_js_function is not None:\n            metadata_schema = resolve_original_schema(schema, self.defs.definitions)\n            if metadata_schema:\n                self._add_js_function(metadata_schema, metadata_js_function)\n\n        schema = _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, obj, schema)\n\n        return schema\n\n    def _model_schema(self, cls: type[BaseModel]) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a Pydantic model.\"\"\"\n        with self.defs.get_schema_or_ref(cls) as (model_ref, maybe_schema):\n            if maybe_schema is not None:\n                return maybe_schema\n\n            fields = cls.model_fields\n            decorators = cls.__pydantic_decorators__\n            computed_fields = decorators.computed_fields\n            check_decorator_fields_exist(\n                chain(\n                    decorators.field_validators.values(),\n                    decorators.field_serializers.values(),\n                    decorators.validators.values(),\n                ),\n                {*fields.keys(), *computed_fields.keys()},\n            )\n            config_wrapper = ConfigWrapper(cls.model_config, check=False)\n            core_config = config_wrapper.core_config(cls)\n            title = self._get_model_title_from_config(cls, config_wrapper)\n            metadata = build_metadata_dict(js_functions=[partial(modify_model_json_schema, cls=cls, title=title)])\n\n            model_validators = decorators.model_validators.values()\n\n            extras_schema = None\n            if core_config.get('extra_fields_behavior') == 'allow':\n                assert cls.__mro__[0] is cls\n                assert cls.__mro__[-1] is object\n                for candidate_cls in cls.__mro__[:-1]:\n                    extras_annotation = getattr(candidate_cls, '__annotations__', {}).get('__pydantic_extra__', None)\n                    if extras_annotation is not None:\n                        if isinstance(extras_annotation, str):\n                            extras_annotation = _typing_extra.eval_type_backport(\n                                _typing_extra._make_forward_ref(extras_annotation, is_argument=False, is_class=True),\n                                self._types_namespace,\n                            )\n                        tp = get_origin(extras_annotation)\n                        if tp not in (Dict, dict):\n                            raise PydanticSchemaGenerationError(\n                                'The type annotation for `__pydantic_extra__` must be `Dict[str, ...]`'\n                            )\n                        extra_items_type = self._get_args_resolving_forward_refs(\n                            extras_annotation,\n                            required=True,\n                        )[1]\n                        if extra_items_type is not Any:\n                            extras_schema = self.generate_schema(extra_items_type)\n                            break\n\n            with self._config_wrapper_stack.push(config_wrapper), self._types_namespace_stack.push(cls):\n                self = self._current_generate_schema\n                if cls.__pydantic_root_model__:\n                    root_field = self._common_field_schema('root', fields['root'], decorators)\n                    inner_schema = root_field['schema']\n                    inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')\n                    model_schema = core_schema.model_schema(\n                        cls,\n                        inner_schema,\n                        custom_init=getattr(cls, '__pydantic_custom_init__', None),\n                        root_model=True,\n                        post_init=getattr(cls, '__pydantic_post_init__', None),\n                        config=core_config,\n                        ref=model_ref,\n                        metadata=metadata,\n                    )\n                else:\n                    fields_schema: core_schema.CoreSchema = core_schema.model_fields_schema(\n                        {k: self._generate_md_field_schema(k, v, decorators) for k, v in fields.items()},\n                        computed_fields=[\n                            self._computed_field_schema(d, decorators.field_serializers)\n                            for d in computed_fields.values()\n                        ],\n                        extras_schema=extras_schema,\n                        model_name=cls.__name__,\n                    )\n                    inner_schema = apply_validators(fields_schema, decorators.root_validators.values(), None)\n                    new_inner_schema = define_expected_missing_refs(inner_schema, recursively_defined_type_refs())\n                    if new_inner_schema is not None:\n                        inner_schema = new_inner_schema\n                    inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')\n\n                    model_schema = core_schema.model_schema(\n                        cls,\n                        inner_schema,\n                        custom_init=getattr(cls, '__pydantic_custom_init__', None),\n                        root_model=False,\n                        post_init=getattr(cls, '__pydantic_post_init__', None),\n                        config=core_config,\n                        ref=model_ref,\n                        metadata=metadata,\n                    )\n\n                schema = self._apply_model_serializers(model_schema, decorators.model_serializers.values())\n                schema = apply_model_validators(schema, model_validators, 'outer')\n                self.defs.definitions[model_ref] = schema\n                return core_schema.definition_reference_schema(model_ref)\n\n    @staticmethod\n    def _get_model_title_from_config(\n        model: type[BaseModel | StandardDataclass], config_wrapper: ConfigWrapper | None = None\n    ) -> str | None:\n        \"\"\"Get the title of a model if `model_title_generator` or `title` are set in the config, else return None\"\"\"\n        if config_wrapper is None:\n            return None\n\n        if config_wrapper.title:\n            return config_wrapper.title\n\n        model_title_generator = config_wrapper.model_title_generator\n        if model_title_generator:\n            title = model_title_generator(model)\n            if not isinstance(title, str):\n                raise TypeError(f'model_title_generator {model_title_generator} must return str, not {title.__class__}')\n            return title\n\n        return None\n\n    def _unpack_refs_defs(self, schema: CoreSchema) -> CoreSchema:\n        \"\"\"Unpack all 'definitions' schemas into `GenerateSchema.defs.definitions`\n        and return the inner schema.\n        \"\"\"\n\n        def get_ref(s: CoreSchema) -> str:\n            return s['ref']  # type: ignore\n\n        if schema['type'] == 'definitions':\n            self.defs.definitions.update({get_ref(s): s for s in schema['definitions']})\n            schema = schema['schema']\n        return schema\n\n    def _generate_schema_from_property(self, obj: Any, source: Any) -> core_schema.CoreSchema | None:\n        \"\"\"Try to generate schema from either the `__get_pydantic_core_schema__` function or\n        `__pydantic_core_schema__` property.\n\n        Note: `__get_pydantic_core_schema__` takes priority so it can\n        decide whether to use a `__pydantic_core_schema__` attribute, or generate a fresh schema.\n        \"\"\"\n        # avoid calling `__get_pydantic_core_schema__` if we've already visited this object\n        if is_self_type(obj):\n            obj = self.model_type_stack.get()\n        with self.defs.get_schema_or_ref(obj) as (_, maybe_schema):\n            if maybe_schema is not None:\n                return maybe_schema\n        if obj is source:\n            ref_mode = 'unpack'\n        else:\n            ref_mode = 'to-def'\n\n        schema: CoreSchema\n\n        if (get_schema := getattr(obj, '__get_pydantic_core_schema__', None)) is not None:\n            if len(inspect.signature(get_schema).parameters) == 1:\n                # (source) -> CoreSchema\n                schema = get_schema(source)\n            else:\n                schema = get_schema(\n                    source, CallbackGetCoreSchemaHandler(self._generate_schema_inner, self, ref_mode=ref_mode)\n                )\n        # fmt: off\n        elif (\n            (existing_schema := getattr(obj, '__pydantic_core_schema__', None)) is not None\n            and not isinstance(existing_schema, MockCoreSchema)\n            and existing_schema.get('cls', None) == obj\n        ):\n            schema = existing_schema\n        # fmt: on\n        elif (validators := getattr(obj, '__get_validators__', None)) is not None:\n            warn(\n                '`__get_validators__` is deprecated and will be removed, use `__get_pydantic_core_schema__` instead.',\n                PydanticDeprecatedSince20,\n            )\n            schema = core_schema.chain_schema([core_schema.with_info_plain_validator_function(v) for v in validators()])\n        else:\n            # we have no existing schema information on the property, exit early so that we can go generate a schema\n            return None\n\n        schema = self._unpack_refs_defs(schema)\n\n        if is_function_with_inner_schema(schema):\n            ref = schema['schema'].pop('ref', None)  # pyright: ignore[reportCallIssue, reportArgumentType]\n            if ref:\n                schema['ref'] = ref\n        else:\n            ref = get_ref(schema)\n\n        if ref:\n            self.defs.definitions[ref] = schema\n            return core_schema.definition_reference_schema(ref)\n\n        return schema\n\n    def _resolve_forward_ref(self, obj: Any) -> Any:\n        # we assume that types_namespace has the target of forward references in its scope,\n        # but this could fail, for example, if calling Validator on an imported type which contains\n        # forward references to other types only defined in the module from which it was imported\n        # `Validator(SomeImportedTypeAliasWithAForwardReference)`\n        # or the equivalent for BaseModel\n        # class Model(BaseModel):\n        #   x: SomeImportedTypeAliasWithAForwardReference\n        try:\n            obj = _typing_extra.eval_type_backport(obj, globalns=self._types_namespace)\n        except NameError as e:\n            raise PydanticUndefinedAnnotation.from_name_error(e) from e\n\n        # if obj is still a ForwardRef, it means we can't evaluate it, raise PydanticUndefinedAnnotation\n        if isinstance(obj, ForwardRef):\n            raise PydanticUndefinedAnnotation(obj.__forward_arg__, f'Unable to evaluate forward reference {obj}')\n\n        if self._typevars_map:\n            obj = replace_types(obj, self._typevars_map)\n\n        return obj\n\n    @overload\n    def _get_args_resolving_forward_refs(self, obj: Any, required: Literal[True]) -> tuple[Any, ...]: ...\n\n    @overload\n    def _get_args_resolving_forward_refs(self, obj: Any) -> tuple[Any, ...] | None: ...\n\n    def _get_args_resolving_forward_refs(self, obj: Any, required: bool = False) -> tuple[Any, ...] | None:\n        args = get_args(obj)\n        if args:\n            args = tuple([self._resolve_forward_ref(a) if isinstance(a, ForwardRef) else a for a in args])\n        elif required:  # pragma: no cover\n            raise TypeError(f'Expected {obj} to have generic parameters but it had none')\n        return args\n\n    def _get_first_arg_or_any(self, obj: Any) -> Any:\n        args = self._get_args_resolving_forward_refs(obj)\n        if not args:\n            return Any\n        return args[0]\n\n    def _get_first_two_args_or_any(self, obj: Any) -> tuple[Any, Any]:\n        args = self._get_args_resolving_forward_refs(obj)\n        if not args:\n            return (Any, Any)\n        if len(args) < 2:\n            origin = get_origin(obj)\n            raise TypeError(f'Expected two type arguments for {origin}, got 1')\n        return args[0], args[1]\n\n    def _generate_schema_inner(self, obj: Any) -> core_schema.CoreSchema:\n        if isinstance(obj, _AnnotatedType):\n            return self._annotated_schema(obj)\n\n        if isinstance(obj, dict):\n            # we assume this is already a valid schema\n            return obj  # type: ignore[return-value]\n\n        if isinstance(obj, str):\n            obj = ForwardRef(obj)\n\n        if isinstance(obj, ForwardRef):\n            return self.generate_schema(self._resolve_forward_ref(obj))\n\n        from ..main import BaseModel\n\n        if lenient_issubclass(obj, BaseModel):\n            with self.model_type_stack.push(obj):\n                return self._model_schema(obj)\n\n        if isinstance(obj, PydanticRecursiveRef):\n            return core_schema.definition_reference_schema(schema_ref=obj.type_ref)\n\n        return self.match_type(obj)\n\n    def match_type(self, obj: Any) -> core_schema.CoreSchema:  # noqa: C901\n        \"\"\"Main mapping of types to schemas.\n\n        The general structure is a series of if statements starting with the simple cases\n        (non-generic primitive types) and then handling generics and other more complex cases.\n\n        Each case either generates a schema directly, calls into a public user-overridable method\n        (like `GenerateSchema.tuple_variable_schema`) or calls into a private method that handles some\n        boilerplate before calling into the user-facing method (e.g. `GenerateSchema._tuple_schema`).\n\n        The idea is that we'll evolve this into adding more and more user facing methods over time\n        as they get requested and we figure out what the right API for them is.\n        \"\"\"\n        if obj is str:\n            return self.str_schema()\n        elif obj is bytes:\n            return core_schema.bytes_schema()\n        elif obj is int:\n            return core_schema.int_schema()\n        elif obj is float:\n            return core_schema.float_schema()\n        elif obj is bool:\n            return core_schema.bool_schema()\n        elif obj is Any or obj is object:\n            return core_schema.any_schema()\n        elif obj is None or obj is _typing_extra.NoneType:\n            return core_schema.none_schema()\n        elif obj in TUPLE_TYPES:\n            return self._tuple_schema(obj)\n        elif obj in LIST_TYPES:\n            return self._list_schema(obj, self._get_first_arg_or_any(obj))\n        elif obj in SET_TYPES:\n            return self._set_schema(obj, self._get_first_arg_or_any(obj))\n        elif obj in FROZEN_SET_TYPES:\n            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))\n        elif obj in DICT_TYPES:\n            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))\n        elif isinstance(obj, TypeAliasType):\n            return self._type_alias_type_schema(obj)\n        elif obj == type:\n            return self._type_schema()\n        elif _typing_extra.is_callable_type(obj):\n            return core_schema.callable_schema()\n        elif _typing_extra.is_literal_type(obj):\n            return self._literal_schema(obj)\n        elif is_typeddict(obj):\n            return self._typed_dict_schema(obj, None)\n        elif _typing_extra.is_namedtuple(obj):\n            return self._namedtuple_schema(obj, None)\n        elif _typing_extra.is_new_type(obj):\n            # NewType, can't use isinstance because it fails <3.10\n            return self.generate_schema(obj.__supertype__)\n        elif obj == re.Pattern:\n            return self._pattern_schema(obj)\n        elif obj is collections.abc.Hashable or obj is typing.Hashable:\n            return self._hashable_schema()\n        elif isinstance(obj, typing.TypeVar):\n            return self._unsubstituted_typevar_schema(obj)\n        elif is_finalvar(obj):\n            if obj is Final:\n                return core_schema.any_schema()\n            return self.generate_schema(\n                self._get_first_arg_or_any(obj),\n            )\n        elif isinstance(obj, (FunctionType, LambdaType, MethodType, partial)):\n            return self._callable_schema(obj)\n        elif inspect.isclass(obj) and issubclass(obj, Enum):\n            from ._std_types_schema import get_enum_core_schema\n\n            return get_enum_core_schema(obj, self._config_wrapper.config_dict)\n\n        if _typing_extra.is_dataclass(obj):\n            return self._dataclass_schema(obj, None)\n        res = self._get_prepare_pydantic_annotations_for_known_type(obj, ())\n        if res is not None:\n            source_type, annotations = res\n            return self._apply_annotations(source_type, annotations)\n\n        origin = get_origin(obj)\n        if origin is not None:\n            return self._match_generic_type(obj, origin)\n\n        if self._arbitrary_types:\n            return self._arbitrary_type_schema(obj)\n        return self._unknown_type_schema(obj)\n\n    def _match_generic_type(self, obj: Any, origin: Any) -> CoreSchema:  # noqa: C901\n        if isinstance(origin, TypeAliasType):\n            return self._type_alias_type_schema(obj)\n\n        # Need to handle generic dataclasses before looking for the schema properties because attribute accesses\n        # on _GenericAlias delegate to the origin type, so lose the information about the concrete parametrization\n        # As a result, currently, there is no way to cache the schema for generic dataclasses. This may be possible\n        # to resolve by modifying the value returned by `Generic.__class_getitem__`, but that is a dangerous game.\n        if _typing_extra.is_dataclass(origin):\n            return self._dataclass_schema(obj, origin)\n        if _typing_extra.is_namedtuple(origin):\n            return self._namedtuple_schema(obj, origin)\n\n        from_property = self._generate_schema_from_property(origin, obj)\n        if from_property is not None:\n            return from_property\n\n        if _typing_extra.origin_is_union(origin):\n            return self._union_schema(obj)\n        elif origin in TUPLE_TYPES:\n            return self._tuple_schema(obj)\n        elif origin in LIST_TYPES:\n            return self._list_schema(obj, self._get_first_arg_or_any(obj))\n        elif origin in SET_TYPES:\n            return self._set_schema(obj, self._get_first_arg_or_any(obj))\n        elif origin in FROZEN_SET_TYPES:\n            return self._frozenset_schema(obj, self._get_first_arg_or_any(obj))\n        elif origin in DICT_TYPES:\n            return self._dict_schema(obj, *self._get_first_two_args_or_any(obj))\n        elif is_typeddict(origin):\n            return self._typed_dict_schema(obj, origin)\n        elif origin in (typing.Type, type):\n            return self._subclass_schema(obj)\n        elif origin in {typing.Sequence, collections.abc.Sequence}:\n            return self._sequence_schema(obj)\n        elif origin in {typing.Iterable, collections.abc.Iterable, typing.Generator, collections.abc.Generator}:\n            return self._iterable_schema(obj)\n        elif origin in (re.Pattern, typing.Pattern):\n            return self._pattern_schema(obj)\n\n        if self._arbitrary_types:\n            return self._arbitrary_type_schema(origin)\n        return self._unknown_type_schema(obj)\n\n    def _generate_td_field_schema(\n        self,\n        name: str,\n        field_info: FieldInfo,\n        decorators: DecoratorInfos,\n        *,\n        required: bool = True,\n    ) -> core_schema.TypedDictField:\n        \"\"\"Prepare a TypedDictField to represent a model or typeddict field.\"\"\"\n        common_field = self._common_field_schema(name, field_info, decorators)\n        return core_schema.typed_dict_field(\n            common_field['schema'],\n            required=False if not field_info.is_required() else required,\n            serialization_exclude=common_field['serialization_exclude'],\n            validation_alias=common_field['validation_alias'],\n            serialization_alias=common_field['serialization_alias'],\n            metadata=common_field['metadata'],\n        )\n\n    def _generate_md_field_schema(\n        self,\n        name: str,\n        field_info: FieldInfo,\n        decorators: DecoratorInfos,\n    ) -> core_schema.ModelField:\n        \"\"\"Prepare a ModelField to represent a model field.\"\"\"\n        common_field = self._common_field_schema(name, field_info, decorators)\n        return core_schema.model_field(\n            common_field['schema'],\n            serialization_exclude=common_field['serialization_exclude'],\n            validation_alias=common_field['validation_alias'],\n            serialization_alias=common_field['serialization_alias'],\n            frozen=common_field['frozen'],\n            metadata=common_field['metadata'],\n        )\n\n    def _generate_dc_field_schema(\n        self,\n        name: str,\n        field_info: FieldInfo,\n        decorators: DecoratorInfos,\n    ) -> core_schema.DataclassField:\n        \"\"\"Prepare a DataclassField to represent the parameter/field, of a dataclass.\"\"\"\n        common_field = self._common_field_schema(name, field_info, decorators)\n        return core_schema.dataclass_field(\n            name,\n            common_field['schema'],\n            init=field_info.init,\n            init_only=field_info.init_var or None,\n            kw_only=None if field_info.kw_only else False,\n            serialization_exclude=common_field['serialization_exclude'],\n            validation_alias=common_field['validation_alias'],\n            serialization_alias=common_field['serialization_alias'],\n            frozen=common_field['frozen'],\n            metadata=common_field['metadata'],\n        )\n\n    @staticmethod\n    def _apply_alias_generator_to_field_info(\n        alias_generator: Callable[[str], str] | AliasGenerator, field_info: FieldInfo, field_name: str\n    ) -> None:\n        \"\"\"Apply an alias_generator to aliases on a FieldInfo instance if appropriate.\n\n        Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance.\n            field_info: The FieldInfo instance to which the alias_generator is (maybe) applied.\n            field_name: The name of the field from which to generate the alias.\n        \"\"\"\n        # Apply an alias_generator if\n        # 1. An alias is not specified\n        # 2. An alias is specified, but the priority is <= 1\n        if (\n            field_info.alias_priority is None\n            or field_info.alias_priority <= 1\n            or field_info.alias is None\n            or field_info.validation_alias is None\n            or field_info.serialization_alias is None\n        ):\n            alias, validation_alias, serialization_alias = None, None, None\n\n            if isinstance(alias_generator, AliasGenerator):\n                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(field_name)\n            elif isinstance(alias_generator, Callable):\n                alias = alias_generator(field_name)\n                if not isinstance(alias, str):\n                    raise TypeError(f'alias_generator {alias_generator} must return str, not {alias.__class__}')\n\n            # if priority is not set, we set to 1\n            # which supports the case where the alias_generator from a child class is used\n            # to generate an alias for a field in a parent class\n            if field_info.alias_priority is None or field_info.alias_priority <= 1:\n                field_info.alias_priority = 1\n\n            # if the priority is 1, then we set the aliases to the generated alias\n            if field_info.alias_priority == 1:\n                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)\n                field_info.validation_alias = _get_first_non_null(validation_alias, alias)\n                field_info.alias = alias\n\n            # if any of the aliases are not set, then we set them to the corresponding generated alias\n            if field_info.alias is None:\n                field_info.alias = alias\n            if field_info.serialization_alias is None:\n                field_info.serialization_alias = _get_first_non_null(serialization_alias, alias)\n            if field_info.validation_alias is None:\n                field_info.validation_alias = _get_first_non_null(validation_alias, alias)\n\n    @staticmethod\n    def _apply_alias_generator_to_computed_field_info(\n        alias_generator: Callable[[str], str] | AliasGenerator,\n        computed_field_info: ComputedFieldInfo,\n        computed_field_name: str,\n    ):\n        \"\"\"Apply an alias_generator to alias on a ComputedFieldInfo instance if appropriate.\n\n        Args:\n            alias_generator: A callable that takes a string and returns a string, or an AliasGenerator instance.\n            computed_field_info: The ComputedFieldInfo instance to which the alias_generator is (maybe) applied.\n            computed_field_name: The name of the computed field from which to generate the alias.\n        \"\"\"\n        # Apply an alias_generator if\n        # 1. An alias is not specified\n        # 2. An alias is specified, but the priority is <= 1\n\n        if (\n            computed_field_info.alias_priority is None\n            or computed_field_info.alias_priority <= 1\n            or computed_field_info.alias is None\n        ):\n            alias, validation_alias, serialization_alias = None, None, None\n\n            if isinstance(alias_generator, AliasGenerator):\n                alias, validation_alias, serialization_alias = alias_generator.generate_aliases(computed_field_name)\n            elif isinstance(alias_generator, Callable):\n                alias = alias_generator(computed_field_name)\n                if not isinstance(alias, str):\n                    raise TypeError(f'alias_generator {alias_generator} must return str, not {alias.__class__}')\n\n            # if priority is not set, we set to 1\n            # which supports the case where the alias_generator from a child class is used\n            # to generate an alias for a field in a parent class\n            if computed_field_info.alias_priority is None or computed_field_info.alias_priority <= 1:\n                computed_field_info.alias_priority = 1\n\n            # if the priority is 1, then we set the aliases to the generated alias\n            # note that we use the serialization_alias with priority over alias, as computed_field\n            # aliases are used for serialization only (not validation)\n            if computed_field_info.alias_priority == 1:\n                computed_field_info.alias = _get_first_non_null(serialization_alias, alias)\n\n    @staticmethod\n    def _apply_field_title_generator_to_field_info(\n        config_wrapper: ConfigWrapper, field_info: FieldInfo | ComputedFieldInfo, field_name: str\n    ) -> None:\n        \"\"\"Apply a field_title_generator on a FieldInfo or ComputedFieldInfo instance if appropriate\n        Args:\n            config_wrapper: The config of the model\n            field_info: The FieldInfo or ComputedField instance to which the title_generator is (maybe) applied.\n            field_name: The name of the field from which to generate the title.\n        \"\"\"\n        field_title_generator = field_info.field_title_generator or config_wrapper.field_title_generator\n\n        if field_title_generator is None:\n            return\n\n        if field_info.title is None:\n            title = field_title_generator(field_name, field_info)  # type: ignore\n            if not isinstance(title, str):\n                raise TypeError(f'field_title_generator {field_title_generator} must return str, not {title.__class__}')\n\n            field_info.title = title\n\n    def _common_field_schema(  # C901\n        self, name: str, field_info: FieldInfo, decorators: DecoratorInfos\n    ) -> _CommonField:\n        # Update FieldInfo annotation if appropriate:\n        from .. import AliasChoices, AliasPath\n        from ..fields import FieldInfo\n\n        if has_instance_in_type(field_info.annotation, (ForwardRef, str)):\n            types_namespace = self._types_namespace\n            if self._typevars_map:\n                types_namespace = (types_namespace or {}).copy()\n                # Ensure that typevars get mapped to their concrete types:\n                types_namespace.update({k.__name__: v for k, v in self._typevars_map.items()})\n\n            evaluated = _typing_extra.eval_type_lenient(field_info.annotation, types_namespace)\n            if evaluated is not field_info.annotation and not has_instance_in_type(evaluated, PydanticRecursiveRef):\n                new_field_info = FieldInfo.from_annotation(evaluated)\n                field_info.annotation = new_field_info.annotation\n\n                # Handle any field info attributes that may have been obtained from now-resolved annotations\n                for k, v in new_field_info._attributes_set.items():\n                    # If an attribute is already set, it means it was set by assigning to a call to Field (or just a\n                    # default value), and that should take the highest priority. So don't overwrite existing attributes.\n                    # We skip over \"attributes\" that are present in the metadata_lookup dict because these won't\n                    # actually end up as attributes of the `FieldInfo` instance.\n                    if k not in field_info._attributes_set and k not in field_info.metadata_lookup:\n                        setattr(field_info, k, v)\n\n                # Finally, ensure the field info also reflects all the `_attributes_set` that are actually metadata.\n                field_info.metadata = [*new_field_info.metadata, *field_info.metadata]\n\n        source_type, annotations = field_info.annotation, field_info.metadata\n\n        def set_discriminator(schema: CoreSchema) -> CoreSchema:\n            schema = self._apply_discriminator_to_union(schema, field_info.discriminator)\n            return schema\n\n        with self.field_name_stack.push(name):\n            if field_info.discriminator is not None:\n                schema = self._apply_annotations(source_type, annotations, transform_inner_schema=set_discriminator)\n            else:\n                schema = self._apply_annotations(\n                    source_type,\n                    annotations,\n                )\n\n        # This V1 compatibility shim should eventually be removed\n        # push down any `each_item=True` validators\n        # note that this won't work for any Annotated types that get wrapped by a function validator\n        # but that's okay because that didn't exist in V1\n        this_field_validators = filter_field_decorator_info_by_field(decorators.validators.values(), name)\n        if _validators_require_validate_default(this_field_validators):\n            field_info.validate_default = True\n        each_item_validators = [v for v in this_field_validators if v.info.each_item is True]\n        this_field_validators = [v for v in this_field_validators if v not in each_item_validators]\n        schema = apply_each_item_validators(schema, each_item_validators, name)\n\n        schema = apply_validators(schema, filter_field_decorator_info_by_field(this_field_validators, name), name)\n        schema = apply_validators(\n            schema, filter_field_decorator_info_by_field(decorators.field_validators.values(), name), name\n        )\n\n        # the default validator needs to go outside of any other validators\n        # so that it is the topmost validator for the field validator\n        # which uses it to check if the field has a default value or not\n        if not field_info.is_required():\n            schema = wrap_default(field_info, schema)\n\n        schema = self._apply_field_serializers(\n            schema, filter_field_decorator_info_by_field(decorators.field_serializers.values(), name)\n        )\n        self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, name)\n\n        json_schema_updates = {\n            'title': field_info.title,\n            'description': field_info.description,\n            'deprecated': bool(field_info.deprecated) or field_info.deprecated == '' or None,\n            'examples': to_jsonable_python(field_info.examples),\n        }\n        json_schema_updates = {k: v for k, v in json_schema_updates.items() if v is not None}\n\n        json_schema_extra = field_info.json_schema_extra\n\n        metadata = build_metadata_dict(\n            js_annotation_functions=[get_json_schema_update_func(json_schema_updates, json_schema_extra)]\n        )\n\n        alias_generator = self._config_wrapper.alias_generator\n        if alias_generator is not None:\n            self._apply_alias_generator_to_field_info(alias_generator, field_info, name)\n\n        if isinstance(field_info.validation_alias, (AliasChoices, AliasPath)):\n            validation_alias = field_info.validation_alias.convert_to_aliases()\n        else:\n            validation_alias = field_info.validation_alias\n\n        return _common_field(\n            schema,\n            serialization_exclude=True if field_info.exclude else None,\n            validation_alias=validation_alias,\n            serialization_alias=field_info.serialization_alias,\n            frozen=field_info.frozen,\n            metadata=metadata,\n        )\n\n    def _union_schema(self, union_type: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a Union.\"\"\"\n        args = self._get_args_resolving_forward_refs(union_type, required=True)\n        choices: list[CoreSchema] = []\n        nullable = False\n        for arg in args:\n            if arg is None or arg is _typing_extra.NoneType:\n                nullable = True\n            else:\n                choices.append(self.generate_schema(arg))\n\n        if len(choices) == 1:\n            s = choices[0]\n        else:\n            choices_with_tags: list[CoreSchema | tuple[CoreSchema, str]] = []\n            for choice in choices:\n                tag = choice.get('metadata', {}).get(_core_utils.TAGGED_UNION_TAG_KEY)\n                if tag is not None:\n                    choices_with_tags.append((choice, tag))\n                else:\n                    choices_with_tags.append(choice)\n            s = core_schema.union_schema(choices_with_tags)\n\n        if nullable:\n            s = core_schema.nullable_schema(s)\n        return s\n\n    def _type_alias_type_schema(\n        self,\n        obj: Any,  # TypeAliasType\n    ) -> CoreSchema:\n        with self.defs.get_schema_or_ref(obj) as (ref, maybe_schema):\n            if maybe_schema is not None:\n                return maybe_schema\n\n            origin = get_origin(obj) or obj\n\n            annotation = origin.__value__\n            typevars_map = get_standard_typevars_map(obj)\n\n            with self._types_namespace_stack.push(origin):\n                annotation = _typing_extra.eval_type_lenient(annotation, self._types_namespace)\n                annotation = replace_types(annotation, typevars_map)\n                schema = self.generate_schema(annotation)\n                assert schema['type'] != 'definitions'\n                schema['ref'] = ref  # type: ignore\n            self.defs.definitions[ref] = schema\n            return core_schema.definition_reference_schema(ref)\n\n    def _literal_schema(self, literal_type: Any) -> CoreSchema:\n        \"\"\"Generate schema for a Literal.\"\"\"\n        expected = _typing_extra.all_literal_values(literal_type)\n        assert expected, f'literal \"expected\" cannot be empty, obj={literal_type}'\n        return core_schema.literal_schema(expected)\n\n    def _typed_dict_schema(self, typed_dict_cls: Any, origin: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a TypedDict.\n\n        It is not possible to track required/optional keys in TypedDict without __required_keys__\n        since TypedDict.__new__ erases the base classes (it replaces them with just `dict`)\n        and thus we can track usage of total=True/False\n        __required_keys__ was added in Python 3.9\n        (https://github.com/miss-islington/cpython/blob/1e9939657dd1f8eb9f596f77c1084d2d351172fc/Doc/library/typing.rst?plain=1#L1546-L1548)\n        however it is buggy\n        (https://github.com/python/typing_extensions/blob/ac52ac5f2cb0e00e7988bae1e2a1b8257ac88d6d/src/typing_extensions.py#L657-L666).\n\n        On 3.11 but < 3.12 TypedDict does not preserve inheritance information.\n\n        Hence to avoid creating validators that do not do what users expect we only\n        support typing.TypedDict on Python >= 3.12 or typing_extension.TypedDict on all versions\n        \"\"\"\n        from ..fields import FieldInfo\n\n        with self.model_type_stack.push(typed_dict_cls), self.defs.get_schema_or_ref(typed_dict_cls) as (\n            typed_dict_ref,\n            maybe_schema,\n        ):\n            if maybe_schema is not None:\n                return maybe_schema\n\n            typevars_map = get_standard_typevars_map(typed_dict_cls)\n            if origin is not None:\n                typed_dict_cls = origin\n\n            if not _SUPPORTS_TYPEDDICT and type(typed_dict_cls).__module__ == 'typing':\n                raise PydanticUserError(\n                    'Please use `typing_extensions.TypedDict` instead of `typing.TypedDict` on Python < 3.12.',\n                    code='typed-dict-version',\n                )\n\n            try:\n                config: ConfigDict | None = get_attribute_from_bases(typed_dict_cls, '__pydantic_config__')\n            except AttributeError:\n                config = None\n\n            with self._config_wrapper_stack.push(config), self._types_namespace_stack.push(typed_dict_cls):\n                core_config = self._config_wrapper.core_config(typed_dict_cls)\n\n                self = self._current_generate_schema\n\n                required_keys: frozenset[str] = typed_dict_cls.__required_keys__\n\n                fields: dict[str, core_schema.TypedDictField] = {}\n\n                decorators = DecoratorInfos.build(typed_dict_cls)\n\n                if self._config_wrapper.use_attribute_docstrings:\n                    field_docstrings = extract_docstrings_from_cls(typed_dict_cls, use_inspect=True)\n                else:\n                    field_docstrings = None\n\n                for field_name, annotation in get_type_hints_infer_globalns(\n                    typed_dict_cls, localns=self._types_namespace, include_extras=True\n                ).items():\n                    annotation = replace_types(annotation, typevars_map)\n                    required = field_name in required_keys\n\n                    if get_origin(annotation) == _typing_extra.Required:\n                        required = True\n                        annotation = self._get_args_resolving_forward_refs(\n                            annotation,\n                            required=True,\n                        )[0]\n                    elif get_origin(annotation) == _typing_extra.NotRequired:\n                        required = False\n                        annotation = self._get_args_resolving_forward_refs(\n                            annotation,\n                            required=True,\n                        )[0]\n\n                    field_info = FieldInfo.from_annotation(annotation)\n                    if (\n                        field_docstrings is not None\n                        and field_info.description is None\n                        and field_name in field_docstrings\n                    ):\n                        field_info.description = field_docstrings[field_name]\n                    self._apply_field_title_generator_to_field_info(self._config_wrapper, field_info, field_name)\n                    fields[field_name] = self._generate_td_field_schema(\n                        field_name, field_info, decorators, required=required\n                    )\n\n                title = self._get_model_title_from_config(typed_dict_cls, ConfigWrapper(config))\n                metadata = build_metadata_dict(\n                    js_functions=[partial(modify_model_json_schema, cls=typed_dict_cls, title=title)],\n                    typed_dict_cls=typed_dict_cls,\n                )\n                td_schema = core_schema.typed_dict_schema(\n                    fields,\n                    computed_fields=[\n                        self._computed_field_schema(d, decorators.field_serializers)\n                        for d in decorators.computed_fields.values()\n                    ],\n                    ref=typed_dict_ref,\n                    metadata=metadata,\n                    config=core_config,\n                )\n\n                schema = self._apply_model_serializers(td_schema, decorators.model_serializers.values())\n                schema = apply_model_validators(schema, decorators.model_validators.values(), 'all')\n                self.defs.definitions[typed_dict_ref] = schema\n                return core_schema.definition_reference_schema(typed_dict_ref)\n\n    def _namedtuple_schema(self, namedtuple_cls: Any, origin: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a NamedTuple.\"\"\"\n        with self.model_type_stack.push(namedtuple_cls), self.defs.get_schema_or_ref(namedtuple_cls) as (\n            namedtuple_ref,\n            maybe_schema,\n        ):\n            if maybe_schema is not None:\n                return maybe_schema\n            typevars_map = get_standard_typevars_map(namedtuple_cls)\n            if origin is not None:\n                namedtuple_cls = origin\n\n            annotations: dict[str, Any] = get_type_hints_infer_globalns(\n                namedtuple_cls, include_extras=True, localns=self._types_namespace\n            )\n            if not annotations:\n                # annotations is empty, happens if namedtuple_cls defined via collections.namedtuple(...)\n                annotations = {k: Any for k in namedtuple_cls._fields}\n\n            if typevars_map:\n                annotations = {\n                    field_name: replace_types(annotation, typevars_map)\n                    for field_name, annotation in annotations.items()\n                }\n\n            arguments_schema = core_schema.arguments_schema(\n                [\n                    self._generate_parameter_schema(\n                        field_name, annotation, default=namedtuple_cls._field_defaults.get(field_name, Parameter.empty)\n                    )\n                    for field_name, annotation in annotations.items()\n                ],\n                metadata=build_metadata_dict(js_prefer_positional_arguments=True),\n            )\n            return core_schema.call_schema(arguments_schema, namedtuple_cls, ref=namedtuple_ref)\n\n    def _generate_parameter_schema(\n        self,\n        name: str,\n        annotation: type[Any],\n        default: Any = Parameter.empty,\n        mode: Literal['positional_only', 'positional_or_keyword', 'keyword_only'] | None = None,\n    ) -> core_schema.ArgumentsParameter:\n        \"\"\"Prepare a ArgumentsParameter to represent a field in a namedtuple or function signature.\"\"\"\n        from ..fields import FieldInfo\n\n        if default is Parameter.empty:\n            field = FieldInfo.from_annotation(annotation)\n        else:\n            field = FieldInfo.from_annotated_attribute(annotation, default)\n        assert field.annotation is not None, 'field.annotation should not be None when generating a schema'\n        source_type, annotations = field.annotation, field.metadata\n        with self.field_name_stack.push(name):\n            schema = self._apply_annotations(source_type, annotations)\n\n        if not field.is_required():\n            schema = wrap_default(field, schema)\n\n        parameter_schema = core_schema.arguments_parameter(name, schema)\n        if mode is not None:\n            parameter_schema['mode'] = mode\n        if field.alias is not None:\n            parameter_schema['alias'] = field.alias\n        else:\n            alias_generator = self._config_wrapper.alias_generator\n            if isinstance(alias_generator, AliasGenerator) and alias_generator.alias is not None:\n                parameter_schema['alias'] = alias_generator.alias(name)\n            elif isinstance(alias_generator, Callable):\n                parameter_schema['alias'] = alias_generator(name)\n        return parameter_schema\n\n    def _tuple_schema(self, tuple_type: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a Tuple, e.g. `tuple[int, str]` or `tuple[int, ...]`.\"\"\"\n        # TODO: do we really need to resolve type vars here?\n        typevars_map = get_standard_typevars_map(tuple_type)\n        params = self._get_args_resolving_forward_refs(tuple_type)\n\n        if typevars_map and params:\n            params = tuple(replace_types(param, typevars_map) for param in params)\n\n        # NOTE: subtle difference: `tuple[()]` gives `params=()`, whereas `typing.Tuple[()]` gives `params=((),)`\n        # This is only true for <3.11, on Python 3.11+ `typing.Tuple[()]` gives `params=()`\n        if not params:\n            if tuple_type in TUPLE_TYPES:\n                return core_schema.tuple_schema([core_schema.any_schema()], variadic_item_index=0)\n            else:\n                # special case for `tuple[()]` which means `tuple[]` - an empty tuple\n                return core_schema.tuple_schema([])\n        elif params[-1] is Ellipsis:\n            if len(params) == 2:\n                return core_schema.tuple_schema([self.generate_schema(params[0])], variadic_item_index=0)\n            else:\n                # TODO: something like https://github.com/pydantic/pydantic/issues/5952\n                raise ValueError('Variable tuples can only have one type')\n        elif len(params) == 1 and params[0] == ():\n            # special case for `Tuple[()]` which means `Tuple[]` - an empty tuple\n            # NOTE: This conditional can be removed when we drop support for Python 3.10.\n            return core_schema.tuple_schema([])\n        else:\n            return core_schema.tuple_schema([self.generate_schema(param) for param in params])\n\n    def _type_schema(self) -> core_schema.CoreSchema:\n        return core_schema.custom_error_schema(\n            core_schema.is_instance_schema(type),\n            custom_error_type='is_type',\n            custom_error_message='Input should be a type',\n        )\n\n    def _union_is_subclass_schema(self, union_type: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for `Type[Union[X, ...]]`.\"\"\"\n        args = self._get_args_resolving_forward_refs(union_type, required=True)\n        return core_schema.union_schema([self.generate_schema(typing.Type[args]) for args in args])\n\n    def _subclass_schema(self, type_: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a Type, e.g. `Type[int]`.\"\"\"\n        type_param = self._get_first_arg_or_any(type_)\n        if type_param == Any:\n            return self._type_schema()\n        elif isinstance(type_param, typing.TypeVar):\n            if type_param.__bound__:\n                if _typing_extra.origin_is_union(get_origin(type_param.__bound__)):\n                    return self._union_is_subclass_schema(type_param.__bound__)\n                return core_schema.is_subclass_schema(type_param.__bound__)\n            elif type_param.__constraints__:\n                return core_schema.union_schema(\n                    [self.generate_schema(typing.Type[c]) for c in type_param.__constraints__]\n                )\n            else:\n                return self._type_schema()\n        elif _typing_extra.origin_is_union(get_origin(type_param)):\n            return self._union_is_subclass_schema(type_param)\n        else:\n            return core_schema.is_subclass_schema(type_param)\n\n    def _sequence_schema(self, sequence_type: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a Sequence, e.g. `Sequence[int]`.\"\"\"\n        from ._std_types_schema import serialize_sequence_via_list\n\n        item_type = self._get_first_arg_or_any(sequence_type)\n        item_type_schema = self.generate_schema(item_type)\n        list_schema = core_schema.list_schema(item_type_schema)\n\n        python_schema = core_schema.is_instance_schema(typing.Sequence, cls_repr='Sequence')\n        if item_type != Any:\n            from ._validators import sequence_validator\n\n            python_schema = core_schema.chain_schema(\n                [python_schema, core_schema.no_info_wrap_validator_function(sequence_validator, list_schema)],\n            )\n\n        serialization = core_schema.wrap_serializer_function_ser_schema(\n            serialize_sequence_via_list, schema=item_type_schema, info_arg=True\n        )\n        return core_schema.json_or_python_schema(\n            json_schema=list_schema, python_schema=python_schema, serialization=serialization\n        )\n\n    def _iterable_schema(self, type_: Any) -> core_schema.GeneratorSchema:\n        \"\"\"Generate a schema for an `Iterable`.\"\"\"\n        item_type = self._get_first_arg_or_any(type_)\n\n        return core_schema.generator_schema(self.generate_schema(item_type))\n\n    def _pattern_schema(self, pattern_type: Any) -> core_schema.CoreSchema:\n        from . import _validators\n\n        metadata = build_metadata_dict(js_functions=[lambda _1, _2: {'type': 'string', 'format': 'regex'}])\n        ser = core_schema.plain_serializer_function_ser_schema(\n            attrgetter('pattern'), when_used='json', return_schema=core_schema.str_schema()\n        )\n        if pattern_type == typing.Pattern or pattern_type == re.Pattern:\n            # bare type\n            return core_schema.no_info_plain_validator_function(\n                _validators.pattern_either_validator, serialization=ser, metadata=metadata\n            )\n\n        param = self._get_args_resolving_forward_refs(\n            pattern_type,\n            required=True,\n        )[0]\n        if param == str:\n            return core_schema.no_info_plain_validator_function(\n                _validators.pattern_str_validator, serialization=ser, metadata=metadata\n            )\n        elif param == bytes:\n            return core_schema.no_info_plain_validator_function(\n                _validators.pattern_bytes_validator, serialization=ser, metadata=metadata\n            )\n        else:\n            raise PydanticSchemaGenerationError(f'Unable to generate pydantic-core schema for {pattern_type!r}.')\n\n    def _hashable_schema(self) -> core_schema.CoreSchema:\n        return core_schema.custom_error_schema(\n            core_schema.is_instance_schema(collections.abc.Hashable),\n            custom_error_type='is_hashable',\n            custom_error_message='Input should be hashable',\n        )\n\n    def _dataclass_schema(\n        self, dataclass: type[StandardDataclass], origin: type[StandardDataclass] | None\n    ) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for a dataclass.\"\"\"\n        with self.model_type_stack.push(dataclass), self.defs.get_schema_or_ref(dataclass) as (\n            dataclass_ref,\n            maybe_schema,\n        ):\n            if maybe_schema is not None:\n                return maybe_schema\n\n            typevars_map = get_standard_typevars_map(dataclass)\n            if origin is not None:\n                dataclass = origin\n\n            with ExitStack() as dataclass_bases_stack:\n                # Pushing a namespace prioritises items already in the stack, so iterate though the MRO forwards\n                for dataclass_base in dataclass.__mro__:\n                    if dataclasses.is_dataclass(dataclass_base):\n                        dataclass_bases_stack.enter_context(self._types_namespace_stack.push(dataclass_base))\n\n                # Pushing a config overwrites the previous config, so iterate though the MRO backwards\n                config = None\n                for dataclass_base in reversed(dataclass.__mro__):\n                    if dataclasses.is_dataclass(dataclass_base):\n                        config = getattr(dataclass_base, '__pydantic_config__', None)\n                        dataclass_bases_stack.enter_context(self._config_wrapper_stack.push(config))\n\n                core_config = self._config_wrapper.core_config(dataclass)\n\n                self = self._current_generate_schema\n\n                from ..dataclasses import is_pydantic_dataclass\n\n                if is_pydantic_dataclass(dataclass):\n                    fields = deepcopy(dataclass.__pydantic_fields__)\n                    if typevars_map:\n                        for field in fields.values():\n                            field.apply_typevars_map(typevars_map, self._types_namespace)\n                else:\n                    fields = collect_dataclass_fields(\n                        dataclass,\n                        self._types_namespace,\n                        typevars_map=typevars_map,\n                    )\n\n                # disallow combination of init=False on a dataclass field and extra='allow' on a dataclass\n                if self._config_wrapper_stack.tail.extra == 'allow':\n                    # disallow combination of init=False on a dataclass field and extra='allow' on a dataclass\n                    for field_name, field in fields.items():\n                        if field.init is False:\n                            raise PydanticUserError(\n                                f'Field {field_name} has `init=False` and dataclass has config setting `extra=\"allow\"`. '\n                                f'This combination is not allowed.',\n                                code='dataclass-init-false-extra-allow',\n                            )\n\n                decorators = dataclass.__dict__.get('__pydantic_decorators__') or DecoratorInfos.build(dataclass)\n                # Move kw_only=False args to the start of the list, as this is how vanilla dataclasses work.\n                # Note that when kw_only is missing or None, it is treated as equivalent to kw_only=True\n                args = sorted(\n                    (self._generate_dc_field_schema(k, v, decorators) for k, v in fields.items()),\n                    key=lambda a: a.get('kw_only') is not False,\n                )\n                has_post_init = hasattr(dataclass, '__post_init__')\n                has_slots = hasattr(dataclass, '__slots__')\n\n                args_schema = core_schema.dataclass_args_schema(\n                    dataclass.__name__,\n                    args,\n                    computed_fields=[\n                        self._computed_field_schema(d, decorators.field_serializers)\n                        for d in decorators.computed_fields.values()\n                    ],\n                    collect_init_only=has_post_init,\n                )\n\n                inner_schema = apply_validators(args_schema, decorators.root_validators.values(), None)\n\n                model_validators = decorators.model_validators.values()\n                inner_schema = apply_model_validators(inner_schema, model_validators, 'inner')\n\n                title = self._get_model_title_from_config(dataclass, ConfigWrapper(config))\n                metadata = build_metadata_dict(\n                    js_functions=[partial(modify_model_json_schema, cls=dataclass, title=title)]\n                )\n\n                dc_schema = core_schema.dataclass_schema(\n                    dataclass,\n                    inner_schema,\n                    post_init=has_post_init,\n                    ref=dataclass_ref,\n                    fields=[field.name for field in dataclasses.fields(dataclass)],\n                    slots=has_slots,\n                    config=core_config,\n                    metadata=metadata,\n                )\n                schema = self._apply_model_serializers(dc_schema, decorators.model_serializers.values())\n                schema = apply_model_validators(schema, model_validators, 'outer')\n                self.defs.definitions[dataclass_ref] = schema\n                return core_schema.definition_reference_schema(dataclass_ref)\n\n            # Type checkers seem to assume ExitStack may suppress exceptions and therefore\n            # control flow can exit the `with` block without returning.\n            assert False, 'Unreachable'\n\n    def _callable_schema(self, function: Callable[..., Any]) -> core_schema.CallSchema:\n        \"\"\"Generate schema for a Callable.\n\n        TODO support functional validators once we support them in Config\n        \"\"\"\n        sig = signature(function)\n\n        type_hints = _typing_extra.get_function_type_hints(function)\n\n        mode_lookup: dict[_ParameterKind, Literal['positional_only', 'positional_or_keyword', 'keyword_only']] = {\n            Parameter.POSITIONAL_ONLY: 'positional_only',\n            Parameter.POSITIONAL_OR_KEYWORD: 'positional_or_keyword',\n            Parameter.KEYWORD_ONLY: 'keyword_only',\n        }\n\n        arguments_list: list[core_schema.ArgumentsParameter] = []\n        var_args_schema: core_schema.CoreSchema | None = None\n        var_kwargs_schema: core_schema.CoreSchema | None = None\n\n        for name, p in sig.parameters.items():\n            if p.annotation is sig.empty:\n                annotation = typing.cast(Any, Any)\n            else:\n                annotation = type_hints[name]\n\n            parameter_mode = mode_lookup.get(p.kind)\n            if parameter_mode is not None:\n                arg_schema = self._generate_parameter_schema(name, annotation, p.default, parameter_mode)\n                arguments_list.append(arg_schema)\n            elif p.kind == Parameter.VAR_POSITIONAL:\n                var_args_schema = self.generate_schema(annotation)\n            else:\n                assert p.kind == Parameter.VAR_KEYWORD, p.kind\n                var_kwargs_schema = self.generate_schema(annotation)\n\n        return_schema: core_schema.CoreSchema | None = None\n        config_wrapper = self._config_wrapper\n        if config_wrapper.validate_return:\n            return_hint = type_hints.get('return')\n            if return_hint is not None:\n                return_schema = self.generate_schema(return_hint)\n\n        return core_schema.call_schema(\n            core_schema.arguments_schema(\n                arguments_list,\n                var_args_schema=var_args_schema,\n                var_kwargs_schema=var_kwargs_schema,\n                populate_by_name=config_wrapper.populate_by_name,\n            ),\n            function,\n            return_schema=return_schema,\n        )\n\n    def _unsubstituted_typevar_schema(self, typevar: typing.TypeVar) -> core_schema.CoreSchema:\n        assert isinstance(typevar, typing.TypeVar)\n\n        bound = typevar.__bound__\n        constraints = typevar.__constraints__\n\n        try:\n            typevar_has_default = typevar.has_default()  # type: ignore\n        except AttributeError:\n            # could still have a default if it's an old version of typing_extensions.TypeVar\n            typevar_has_default = getattr(typevar, '__default__', None) is not None\n\n        if (bound is not None) + (len(constraints) != 0) + typevar_has_default > 1:\n            raise NotImplementedError(\n                'Pydantic does not support mixing more than one of TypeVar bounds, constraints and defaults'\n            )\n\n        if typevar_has_default:\n            return self.generate_schema(typevar.__default__)  # type: ignore\n        elif constraints:\n            return self._union_schema(typing.Union[constraints])  # type: ignore\n        elif bound:\n            schema = self.generate_schema(bound)\n            schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(\n                lambda x, h: h(x), schema=core_schema.any_schema()\n            )\n            return schema\n        else:\n            return core_schema.any_schema()\n\n    def _computed_field_schema(\n        self,\n        d: Decorator[ComputedFieldInfo],\n        field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]],\n    ) -> core_schema.ComputedField:\n        try:\n            return_type = _decorators.get_function_return_type(d.func, d.info.return_type, self._types_namespace)\n        except NameError as e:\n            raise PydanticUndefinedAnnotation.from_name_error(e) from e\n        if return_type is PydanticUndefined:\n            raise PydanticUserError(\n                'Computed field is missing return type annotation or specifying `return_type`'\n                ' to the `@computed_field` decorator (e.g. `@computed_field(return_type=int|str)`)',\n                code='model-field-missing-annotation',\n            )\n\n        return_type = replace_types(return_type, self._typevars_map)\n        # Create a new ComputedFieldInfo so that different type parametrizations of the same\n        # generic model's computed field can have different return types.\n        d.info = dataclasses.replace(d.info, return_type=return_type)\n        return_type_schema = self.generate_schema(return_type)\n        # Apply serializers to computed field if there exist\n        return_type_schema = self._apply_field_serializers(\n            return_type_schema,\n            filter_field_decorator_info_by_field(field_serializers.values(), d.cls_var_name),\n            computed_field=True,\n        )\n\n        alias_generator = self._config_wrapper.alias_generator\n        if alias_generator is not None:\n            self._apply_alias_generator_to_computed_field_info(\n                alias_generator=alias_generator, computed_field_info=d.info, computed_field_name=d.cls_var_name\n            )\n        self._apply_field_title_generator_to_field_info(self._config_wrapper, d.info, d.cls_var_name)\n\n        def set_computed_field_metadata(schema: CoreSchemaOrField, handler: GetJsonSchemaHandler) -> JsonSchemaValue:\n            json_schema = handler(schema)\n\n            json_schema['readOnly'] = True\n\n            title = d.info.title\n            if title is not None:\n                json_schema['title'] = title\n\n            description = d.info.description\n            if description is not None:\n                json_schema['description'] = description\n\n            if d.info.deprecated or d.info.deprecated == '':\n                json_schema['deprecated'] = True\n\n            examples = d.info.examples\n            if examples is not None:\n                json_schema['examples'] = to_jsonable_python(examples)\n\n            json_schema_extra = d.info.json_schema_extra\n            if json_schema_extra is not None:\n                add_json_schema_extra(json_schema, json_schema_extra)\n\n            return json_schema\n\n        metadata = build_metadata_dict(js_annotation_functions=[set_computed_field_metadata])\n        return core_schema.computed_field(\n            d.cls_var_name, return_schema=return_type_schema, alias=d.info.alias, metadata=metadata\n        )\n\n    def _annotated_schema(self, annotated_type: Any) -> core_schema.CoreSchema:\n        \"\"\"Generate schema for an Annotated type, e.g. `Annotated[int, Field(...)]` or `Annotated[int, Gt(0)]`.\"\"\"\n        from ..fields import FieldInfo\n\n        source_type, *annotations = self._get_args_resolving_forward_refs(\n            annotated_type,\n            required=True,\n        )\n        schema = self._apply_annotations(source_type, annotations)\n        # put the default validator last so that TypeAdapter.get_default_value() works\n        # even if there are function validators involved\n        for annotation in annotations:\n            if isinstance(annotation, FieldInfo):\n                schema = wrap_default(annotation, schema)\n        return schema\n\n    def _get_prepare_pydantic_annotations_for_known_type(\n        self, obj: Any, annotations: tuple[Any, ...]\n    ) -> tuple[Any, list[Any]] | None:\n        from ._std_types_schema import PREPARE_METHODS\n\n        # Check for hashability\n        try:\n            hash(obj)\n        except TypeError:\n            # obj is definitely not a known type if this fails\n            return None\n\n        for gen in PREPARE_METHODS:\n            res = gen(obj, annotations, self._config_wrapper.config_dict)\n            if res is not None:\n                return res\n\n        return None\n\n    def _apply_annotations(\n        self,\n        source_type: Any,\n        annotations: list[Any],\n        transform_inner_schema: Callable[[CoreSchema], CoreSchema] = lambda x: x,\n    ) -> CoreSchema:\n        \"\"\"Apply arguments from `Annotated` or from `FieldInfo` to a schema.\n\n        This gets called by `GenerateSchema._annotated_schema` but differs from it in that it does\n        not expect `source_type` to be an `Annotated` object, it expects it to be  the first argument of that\n        (in other words, `GenerateSchema._annotated_schema` just unpacks `Annotated`, this process it).\n        \"\"\"\n        annotations = list(_known_annotated_metadata.expand_grouped_metadata(annotations))\n        res = self._get_prepare_pydantic_annotations_for_known_type(source_type, tuple(annotations))\n        if res is not None:\n            source_type, annotations = res\n\n        pydantic_js_annotation_functions: list[GetJsonSchemaFunction] = []\n\n        def inner_handler(obj: Any) -> CoreSchema:\n            from_property = self._generate_schema_from_property(obj, source_type)\n            if from_property is None:\n                schema = self._generate_schema_inner(obj)\n            else:\n                schema = from_property\n            metadata_js_function = _extract_get_pydantic_json_schema(obj, schema)\n            if metadata_js_function is not None:\n                metadata_schema = resolve_original_schema(schema, self.defs.definitions)\n                if metadata_schema is not None:\n                    self._add_js_function(metadata_schema, metadata_js_function)\n            return transform_inner_schema(schema)\n\n        get_inner_schema = CallbackGetCoreSchemaHandler(inner_handler, self)\n\n        for annotation in annotations:\n            if annotation is None:\n                continue\n            get_inner_schema = self._get_wrapped_inner_schema(\n                get_inner_schema, annotation, pydantic_js_annotation_functions\n            )\n\n        schema = get_inner_schema(source_type)\n        if pydantic_js_annotation_functions:\n            metadata = CoreMetadataHandler(schema).metadata\n            metadata.setdefault('pydantic_js_annotation_functions', []).extend(pydantic_js_annotation_functions)\n        return _add_custom_serialization_from_json_encoders(self._config_wrapper.json_encoders, source_type, schema)\n\n    def _apply_single_annotation(self, schema: core_schema.CoreSchema, metadata: Any) -> core_schema.CoreSchema:\n        from ..fields import FieldInfo\n\n        if isinstance(metadata, FieldInfo):\n            for field_metadata in metadata.metadata:\n                schema = self._apply_single_annotation(schema, field_metadata)\n\n            if metadata.discriminator is not None:\n                schema = self._apply_discriminator_to_union(schema, metadata.discriminator)\n            return schema\n\n        if schema['type'] == 'nullable':\n            # for nullable schemas, metadata is automatically applied to the inner schema\n            inner = schema.get('schema', core_schema.any_schema())\n            inner = self._apply_single_annotation(inner, metadata)\n            if inner:\n                schema['schema'] = inner\n            return schema\n\n        original_schema = schema\n        ref = schema.get('ref', None)\n        if ref is not None:\n            schema = schema.copy()\n            new_ref = ref + f'_{repr(metadata)}'\n            if new_ref in self.defs.definitions:\n                return self.defs.definitions[new_ref]\n            schema['ref'] = new_ref  # type: ignore\n        elif schema['type'] == 'definition-ref':\n            ref = schema['schema_ref']\n            if ref in self.defs.definitions:\n                schema = self.defs.definitions[ref].copy()\n                new_ref = ref + f'_{repr(metadata)}'\n                if new_ref in self.defs.definitions:\n                    return self.defs.definitions[new_ref]\n                schema['ref'] = new_ref  # type: ignore\n\n        maybe_updated_schema = _known_annotated_metadata.apply_known_metadata(metadata, schema.copy())\n\n        if maybe_updated_schema is not None:\n            return maybe_updated_schema\n        return original_schema\n\n    def _apply_single_annotation_json_schema(\n        self, schema: core_schema.CoreSchema, metadata: Any\n    ) -> core_schema.CoreSchema:\n        from ..fields import FieldInfo\n\n        if isinstance(metadata, FieldInfo):\n            for field_metadata in metadata.metadata:\n                schema = self._apply_single_annotation_json_schema(schema, field_metadata)\n            json_schema_update: JsonSchemaValue = {}\n            if metadata.title:\n                json_schema_update['title'] = metadata.title\n            if metadata.description:\n                json_schema_update['description'] = metadata.description\n            if metadata.examples:\n                json_schema_update['examples'] = to_jsonable_python(metadata.examples)\n\n            json_schema_extra = metadata.json_schema_extra\n            if json_schema_update or json_schema_extra:\n                CoreMetadataHandler(schema).metadata.setdefault('pydantic_js_annotation_functions', []).append(\n                    get_json_schema_update_func(json_schema_update, json_schema_extra)\n                )\n        return schema\n\n    def _get_wrapped_inner_schema(\n        self,\n        get_inner_schema: GetCoreSchemaHandler,\n        annotation: Any,\n        pydantic_js_annotation_functions: list[GetJsonSchemaFunction],\n    ) -> CallbackGetCoreSchemaHandler:\n        metadata_get_schema: GetCoreSchemaFunction = getattr(annotation, '__get_pydantic_core_schema__', None) or (\n            lambda source, handler: handler(source)\n        )\n\n        def new_handler(source: Any) -> core_schema.CoreSchema:\n            schema = metadata_get_schema(source, get_inner_schema)\n            schema = self._apply_single_annotation(schema, annotation)\n            schema = self._apply_single_annotation_json_schema(schema, annotation)\n\n            metadata_js_function = _extract_get_pydantic_json_schema(annotation, schema)\n            if metadata_js_function is not None:\n                pydantic_js_annotation_functions.append(metadata_js_function)\n            return schema\n\n        return CallbackGetCoreSchemaHandler(new_handler, self)\n\n    def _apply_field_serializers(\n        self,\n        schema: core_schema.CoreSchema,\n        serializers: list[Decorator[FieldSerializerDecoratorInfo]],\n        computed_field: bool = False,\n    ) -> core_schema.CoreSchema:\n        \"\"\"Apply field serializers to a schema.\"\"\"\n        if serializers:\n            schema = copy(schema)\n            if schema['type'] == 'definitions':\n                inner_schema = schema['schema']\n                schema['schema'] = self._apply_field_serializers(inner_schema, serializers)\n                return schema\n            else:\n                ref = typing.cast('str|None', schema.get('ref', None))\n                if ref is not None:\n                    schema = core_schema.definition_reference_schema(ref)\n\n            # use the last serializer to make it easy to override a serializer set on a parent model\n            serializer = serializers[-1]\n            is_field_serializer, info_arg = inspect_field_serializer(\n                serializer.func, serializer.info.mode, computed_field=computed_field\n            )\n\n            try:\n                return_type = _decorators.get_function_return_type(\n                    serializer.func, serializer.info.return_type, self._types_namespace\n                )\n            except NameError as e:\n                raise PydanticUndefinedAnnotation.from_name_error(e) from e\n\n            if return_type is PydanticUndefined:\n                return_schema = None\n            else:\n                return_schema = self.generate_schema(return_type)\n\n            if serializer.info.mode == 'wrap':\n                schema['serialization'] = core_schema.wrap_serializer_function_ser_schema(\n                    serializer.func,\n                    is_field_serializer=is_field_serializer,\n                    info_arg=info_arg,\n                    return_schema=return_schema,\n                    when_used=serializer.info.when_used,\n                )\n            else:\n                assert serializer.info.mode == 'plain'\n                schema['serialization'] = core_schema.plain_serializer_function_ser_schema(\n                    serializer.func,\n                    is_field_serializer=is_field_serializer,\n                    info_arg=info_arg,\n                    return_schema=return_schema,\n                    when_used=serializer.info.when_used,\n                )\n        return schema\n\n    def _apply_model_serializers(\n        self, schema: core_schema.CoreSchema, serializers: Iterable[Decorator[ModelSerializerDecoratorInfo]]\n    ) -> core_schema.CoreSchema:\n        \"\"\"Apply model serializers to a schema.\"\"\"\n        ref: str | None = schema.pop('ref', None)  # type: ignore\n        if serializers:\n            serializer = list(serializers)[-1]\n            info_arg = inspect_model_serializer(serializer.func, serializer.info.mode)\n\n            try:\n                return_type = _decorators.get_function_return_type(\n                    serializer.func, serializer.info.return_type, self._types_namespace\n                )\n            except NameError as e:\n                raise PydanticUndefinedAnnotation.from_name_error(e) from e\n            if return_type is PydanticUndefined:\n                return_schema = None\n            else:\n                return_schema = self.generate_schema(return_type)\n\n            if serializer.info.mode == 'wrap':\n                ser_schema: core_schema.SerSchema = core_schema.wrap_serializer_function_ser_schema(\n                    serializer.func,\n                    info_arg=info_arg,\n                    return_schema=return_schema,\n                    when_used=serializer.info.when_used,\n                )\n            else:\n                # plain\n                ser_schema = core_schema.plain_serializer_function_ser_schema(\n                    serializer.func,\n                    info_arg=info_arg,\n                    return_schema=return_schema,\n                    when_used=serializer.info.when_used,\n                )\n            schema['serialization'] = ser_schema\n        if ref:\n            schema['ref'] = ref  # type: ignore\n        return schema\n\n\n_VALIDATOR_F_MATCH: Mapping[\n    tuple[FieldValidatorModes, Literal['no-info', 'with-info']],\n    Callable[[Callable[..., Any], core_schema.CoreSchema, str | None], core_schema.CoreSchema],\n] = {\n    ('before', 'no-info'): lambda f, schema, _: core_schema.no_info_before_validator_function(f, schema),\n    ('after', 'no-info'): lambda f, schema, _: core_schema.no_info_after_validator_function(f, schema),\n    ('plain', 'no-info'): lambda f, _1, _2: core_schema.no_info_plain_validator_function(f),\n    ('wrap', 'no-info'): lambda f, schema, _: core_schema.no_info_wrap_validator_function(f, schema),\n    ('before', 'with-info'): lambda f, schema, field_name: core_schema.with_info_before_validator_function(\n        f, schema, field_name=field_name\n    ),\n    ('after', 'with-info'): lambda f, schema, field_name: core_schema.with_info_after_validator_function(\n        f, schema, field_name=field_name\n    ),\n    ('plain', 'with-info'): lambda f, _, field_name: core_schema.with_info_plain_validator_function(\n        f, field_name=field_name\n    ),\n    ('wrap', 'with-info'): lambda f, schema, field_name: core_schema.with_info_wrap_validator_function(\n        f, schema, field_name=field_name\n    ),\n}\n\n\ndef apply_validators(\n    schema: core_schema.CoreSchema,\n    validators: Iterable[Decorator[RootValidatorDecoratorInfo]]\n    | Iterable[Decorator[ValidatorDecoratorInfo]]\n    | Iterable[Decorator[FieldValidatorDecoratorInfo]],\n    field_name: str | None,\n) -> core_schema.CoreSchema:\n    \"\"\"Apply validators to a schema.\n\n    Args:\n        schema: The schema to apply validators on.\n        validators: An iterable of validators.\n        field_name: The name of the field if validators are being applied to a model field.\n\n    Returns:\n        The updated schema.\n    \"\"\"\n    for validator in validators:\n        info_arg = inspect_validator(validator.func, validator.info.mode)\n        val_type = 'with-info' if info_arg else 'no-info'\n\n        schema = _VALIDATOR_F_MATCH[(validator.info.mode, val_type)](validator.func, schema, field_name)\n    return schema\n\n\ndef _validators_require_validate_default(validators: Iterable[Decorator[ValidatorDecoratorInfo]]) -> bool:\n    \"\"\"In v1, if any of the validators for a field had `always=True`, the default value would be validated.\n\n    This serves as an auxiliary function for re-implementing that logic, by looping over a provided\n    collection of (v1-style) ValidatorDecoratorInfo's and checking if any of them have `always=True`.\n\n    We should be able to drop this function and the associated logic calling it once we drop support\n    for v1-style validator decorators. (Or we can extend it and keep it if we add something equivalent\n    to the v1-validator `always` kwarg to `field_validator`.)\n    \"\"\"\n    for validator in validators:\n        if validator.info.always:\n            return True\n    return False\n\n\ndef apply_model_validators(\n    schema: core_schema.CoreSchema,\n    validators: Iterable[Decorator[ModelValidatorDecoratorInfo]],\n    mode: Literal['inner', 'outer', 'all'],\n) -> core_schema.CoreSchema:\n    \"\"\"Apply model validators to a schema.\n\n    If mode == 'inner', only \"before\" validators are applied\n    If mode == 'outer', validators other than \"before\" are applied\n    If mode == 'all', all validators are applied\n\n    Args:\n        schema: The schema to apply validators on.\n        validators: An iterable of validators.\n        mode: The validator mode.\n\n    Returns:\n        The updated schema.\n    \"\"\"\n    ref: str | None = schema.pop('ref', None)  # type: ignore\n    for validator in validators:\n        if mode == 'inner' and validator.info.mode != 'before':\n            continue\n        if mode == 'outer' and validator.info.mode == 'before':\n            continue\n        info_arg = inspect_validator(validator.func, validator.info.mode)\n        if validator.info.mode == 'wrap':\n            if info_arg:\n                schema = core_schema.with_info_wrap_validator_function(function=validator.func, schema=schema)\n            else:\n                schema = core_schema.no_info_wrap_validator_function(function=validator.func, schema=schema)\n        elif validator.info.mode == 'before':\n            if info_arg:\n                schema = core_schema.with_info_before_validator_function(function=validator.func, schema=schema)\n            else:\n                schema = core_schema.no_info_before_validator_function(function=validator.func, schema=schema)\n        else:\n            assert validator.info.mode == 'after'\n            if info_arg:\n                schema = core_schema.with_info_after_validator_function(function=validator.func, schema=schema)\n            else:\n                schema = core_schema.no_info_after_validator_function(function=validator.func, schema=schema)\n    if ref:\n        schema['ref'] = ref  # type: ignore\n    return schema\n\n\ndef wrap_default(field_info: FieldInfo, schema: core_schema.CoreSchema) -> core_schema.CoreSchema:\n    \"\"\"Wrap schema with default schema if default value or `default_factory` are available.\n\n    Args:\n        field_info: The field info object.\n        schema: The schema to apply default on.\n\n    Returns:\n        Updated schema by default value or `default_factory`.\n    \"\"\"\n    if field_info.default_factory:\n        return core_schema.with_default_schema(\n            schema, default_factory=field_info.default_factory, validate_default=field_info.validate_default\n        )\n    elif field_info.default is not PydanticUndefined:\n        return core_schema.with_default_schema(\n            schema, default=field_info.default, validate_default=field_info.validate_default\n        )\n    else:\n        return schema\n\n\ndef _extract_get_pydantic_json_schema(tp: Any, schema: CoreSchema) -> GetJsonSchemaFunction | None:\n    \"\"\"Extract `__get_pydantic_json_schema__` from a type, handling the deprecated `__modify_schema__`.\"\"\"\n    js_modify_function = getattr(tp, '__get_pydantic_json_schema__', None)\n\n    if hasattr(tp, '__modify_schema__'):\n        from pydantic import BaseModel  # circular reference\n\n        has_custom_v2_modify_js_func = (\n            js_modify_function is not None\n            and BaseModel.__get_pydantic_json_schema__.__func__  # type: ignore\n            not in (js_modify_function, getattr(js_modify_function, '__func__', None))\n        )\n\n        if not has_custom_v2_modify_js_func:\n            cls_name = getattr(tp, '__name__', None)\n            raise PydanticUserError(\n                f'The `__modify_schema__` method is not supported in Pydantic v2. '\n                f'Use `__get_pydantic_json_schema__` instead{f\" in class `{cls_name}`\" if cls_name else \"\"}.',\n                code='custom-json-schema',\n            )\n\n    # handle GenericAlias' but ignore Annotated which \"lies\" about its origin (in this case it would be `int`)\n    if hasattr(tp, '__origin__') and not isinstance(tp, type(Annotated[int, 'placeholder'])):\n        return _extract_get_pydantic_json_schema(tp.__origin__, schema)\n\n    if js_modify_function is None:\n        return None\n\n    return js_modify_function\n\n\ndef get_json_schema_update_func(\n    json_schema_update: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None\n) -> GetJsonSchemaFunction:\n    def json_schema_update_func(\n        core_schema_or_field: CoreSchemaOrField, handler: GetJsonSchemaHandler\n    ) -> JsonSchemaValue:\n        json_schema = {**handler(core_schema_or_field), **json_schema_update}\n        add_json_schema_extra(json_schema, json_schema_extra)\n        return json_schema\n\n    return json_schema_update_func\n\n\ndef add_json_schema_extra(\n    json_schema: JsonSchemaValue, json_schema_extra: JsonDict | typing.Callable[[JsonDict], None] | None\n):\n    if isinstance(json_schema_extra, dict):\n        json_schema.update(to_jsonable_python(json_schema_extra))\n    elif callable(json_schema_extra):\n        json_schema_extra(json_schema)\n\n\nclass _CommonField(TypedDict):\n    schema: core_schema.CoreSchema\n    validation_alias: str | list[str | int] | list[list[str | int]] | None\n    serialization_alias: str | None\n    serialization_exclude: bool | None\n    frozen: bool | None\n    metadata: dict[str, Any]\n\n\ndef _common_field(\n    schema: core_schema.CoreSchema,\n    *,\n    validation_alias: str | list[str | int] | list[list[str | int]] | None = None,\n    serialization_alias: str | None = None,\n    serialization_exclude: bool | None = None,\n    frozen: bool | None = None,\n    metadata: Any = None,\n) -> _CommonField:\n    return {\n        'schema': schema,\n        'validation_alias': validation_alias,\n        'serialization_alias': serialization_alias,\n        'serialization_exclude': serialization_exclude,\n        'frozen': frozen,\n        'metadata': metadata,\n    }\n\n\nclass _Definitions:\n    \"\"\"Keeps track of references and definitions.\"\"\"\n\n    def __init__(self) -> None:\n        self.seen: set[str] = set()\n        self.definitions: dict[str, core_schema.CoreSchema] = {}\n\n    @contextmanager\n    def get_schema_or_ref(self, tp: Any) -> Iterator[tuple[str, None] | tuple[str, CoreSchema]]:\n        \"\"\"Get a definition for `tp` if one exists.\n\n        If a definition exists, a tuple of `(ref_string, CoreSchema)` is returned.\n        If no definition exists yet, a tuple of `(ref_string, None)` is returned.\n\n        Note that the returned `CoreSchema` will always be a `DefinitionReferenceSchema`,\n        not the actual definition itself.\n\n        This should be called for any type that can be identified by reference.\n        This includes any recursive types.\n\n        At present the following types can be named/recursive:\n\n        - BaseModel\n        - Dataclasses\n        - TypedDict\n        - TypeAliasType\n        \"\"\"\n        ref = get_type_ref(tp)\n        # return the reference if we're either (1) in a cycle or (2) it was already defined\n        if ref in self.seen or ref in self.definitions:\n            yield (ref, core_schema.definition_reference_schema(ref))\n        else:\n            self.seen.add(ref)\n            try:\n                yield (ref, None)\n            finally:\n                self.seen.discard(ref)\n\n\ndef resolve_original_schema(schema: CoreSchema, definitions: dict[str, CoreSchema]) -> CoreSchema | None:\n    if schema['type'] == 'definition-ref':\n        return definitions.get(schema['schema_ref'], None)\n    elif schema['type'] == 'definitions':\n        return schema['schema']\n    else:\n        return schema\n\n\nclass _FieldNameStack:\n    __slots__ = ('_stack',)\n\n    def __init__(self) -> None:\n        self._stack: list[str] = []\n\n    @contextmanager\n    def push(self, field_name: str) -> Iterator[None]:\n        self._stack.append(field_name)\n        yield\n        self._stack.pop()\n\n    def get(self) -> str | None:\n        if self._stack:\n            return self._stack[-1]\n        else:\n            return None\n\n\nclass _ModelTypeStack:\n    __slots__ = ('_stack',)\n\n    def __init__(self) -> None:\n        self._stack: list[type] = []\n\n    @contextmanager\n    def push(self, type_obj: type) -> Iterator[None]:\n        self._stack.append(type_obj)\n        yield\n        self._stack.pop()\n\n    def get(self) -> type | None:\n        if self._stack:\n            return self._stack[-1]\n        else:\n            return None\n", "pydantic/_internal/__init__.py": "", "pydantic/_internal/_fields.py": "\"\"\"Private logic related to fields (the `Field()` function and `FieldInfo` class), and arguments to `Annotated`.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport dataclasses\nimport sys\nimport warnings\nfrom copy import copy\nfrom functools import lru_cache\nfrom typing import TYPE_CHECKING, Any\n\nfrom pydantic_core import PydanticUndefined\n\nfrom pydantic.errors import PydanticUserError\n\nfrom . import _typing_extra\nfrom ._config import ConfigWrapper\nfrom ._docs_extraction import extract_docstrings_from_cls\nfrom ._repr import Representation\nfrom ._typing_extra import get_cls_type_hints_lenient, get_type_hints, is_classvar, is_finalvar\n\nif TYPE_CHECKING:\n    from annotated_types import BaseMetadata\n\n    from ..fields import FieldInfo\n    from ..main import BaseModel\n    from ._dataclasses import StandardDataclass\n    from ._decorators import DecoratorInfos\n\n\ndef get_type_hints_infer_globalns(\n    obj: Any,\n    localns: dict[str, Any] | None = None,\n    include_extras: bool = False,\n) -> dict[str, Any]:\n    \"\"\"Gets type hints for an object by inferring the global namespace.\n\n    It uses the `typing.get_type_hints`, The only thing that we do here is fetching\n    global namespace from `obj.__module__` if it is not `None`.\n\n    Args:\n        obj: The object to get its type hints.\n        localns: The local namespaces.\n        include_extras: Whether to recursively include annotation metadata.\n\n    Returns:\n        The object type hints.\n    \"\"\"\n    module_name = getattr(obj, '__module__', None)\n    globalns: dict[str, Any] | None = None\n    if module_name:\n        try:\n            globalns = sys.modules[module_name].__dict__\n        except KeyError:\n            # happens occasionally, see https://github.com/pydantic/pydantic/issues/2363\n            pass\n    return get_type_hints(obj, globalns=globalns, localns=localns, include_extras=include_extras)\n\n\nclass PydanticMetadata(Representation):\n    \"\"\"Base class for annotation markers like `Strict`.\"\"\"\n\n    __slots__ = ()\n\n\ndef pydantic_general_metadata(**metadata: Any) -> BaseMetadata:\n    \"\"\"Create a new `_PydanticGeneralMetadata` class with the given metadata.\n\n    Args:\n        **metadata: The metadata to add.\n\n    Returns:\n        The new `_PydanticGeneralMetadata` class.\n    \"\"\"\n    return _general_metadata_cls()(metadata)  # type: ignore\n\n\n@lru_cache(maxsize=None)\ndef _general_metadata_cls() -> type[BaseMetadata]:\n    \"\"\"Do it this way to avoid importing `annotated_types` at import time.\"\"\"\n    from annotated_types import BaseMetadata\n\n    class _PydanticGeneralMetadata(PydanticMetadata, BaseMetadata):\n        \"\"\"Pydantic general metadata like `max_digits`.\"\"\"\n\n        def __init__(self, metadata: Any):\n            self.__dict__ = metadata\n\n    return _PydanticGeneralMetadata  # type: ignore\n\n\ndef _update_fields_from_docstrings(cls: type[Any], fields: dict[str, FieldInfo], config_wrapper: ConfigWrapper) -> None:\n    if config_wrapper.use_attribute_docstrings:\n        fields_docs = extract_docstrings_from_cls(cls)\n        for ann_name, field_info in fields.items():\n            if field_info.description is None and ann_name in fields_docs:\n                field_info.description = fields_docs[ann_name]\n\n\ndef collect_model_fields(  # noqa: C901\n    cls: type[BaseModel],\n    bases: tuple[type[Any], ...],\n    config_wrapper: ConfigWrapper,\n    types_namespace: dict[str, Any] | None,\n    *,\n    typevars_map: dict[Any, Any] | None = None,\n) -> tuple[dict[str, FieldInfo], set[str]]:\n    \"\"\"Collect the fields of a nascent pydantic model.\n\n    Also collect the names of any ClassVars present in the type hints.\n\n    The returned value is a tuple of two items: the fields dict, and the set of ClassVar names.\n\n    Args:\n        cls: BaseModel or dataclass.\n        bases: Parents of the class, generally `cls.__bases__`.\n        config_wrapper: The config wrapper instance.\n        types_namespace: Optional extra namespace to look for types in.\n        typevars_map: A dictionary mapping type variables to their concrete types.\n\n    Returns:\n        A tuple contains fields and class variables.\n\n    Raises:\n        NameError:\n            - If there is a conflict between a field name and protected namespaces.\n            - If there is a field other than `root` in `RootModel`.\n            - If a field shadows an attribute in the parent model.\n    \"\"\"\n    from ..fields import FieldInfo\n\n    type_hints = get_cls_type_hints_lenient(cls, types_namespace)\n\n    # https://docs.python.org/3/howto/annotations.html#accessing-the-annotations-dict-of-an-object-in-python-3-9-and-older\n    # annotations is only used for finding fields in parent classes\n    annotations = cls.__dict__.get('__annotations__', {})\n    fields: dict[str, FieldInfo] = {}\n\n    class_vars: set[str] = set()\n    for ann_name, ann_type in type_hints.items():\n        if ann_name == 'model_config':\n            # We never want to treat `model_config` as a field\n            # Note: we may need to change this logic if/when we introduce a `BareModel` class with no\n            # protected namespaces (where `model_config` might be allowed as a field name)\n            continue\n        for protected_namespace in config_wrapper.protected_namespaces:\n            if ann_name.startswith(protected_namespace):\n                for b in bases:\n                    if hasattr(b, ann_name):\n                        from ..main import BaseModel\n\n                        if not (issubclass(b, BaseModel) and ann_name in b.model_fields):\n                            raise NameError(\n                                f'Field \"{ann_name}\" conflicts with member {getattr(b, ann_name)}'\n                                f' of protected namespace \"{protected_namespace}\".'\n                            )\n                else:\n                    valid_namespaces = tuple(\n                        x for x in config_wrapper.protected_namespaces if not ann_name.startswith(x)\n                    )\n                    warnings.warn(\n                        f'Field \"{ann_name}\" has conflict with protected namespace \"{protected_namespace}\".'\n                        '\\n\\nYou may be able to resolve this warning by setting'\n                        f\" `model_config['protected_namespaces'] = {valid_namespaces}`.\",\n                        UserWarning,\n                    )\n        if is_classvar(ann_type):\n            class_vars.add(ann_name)\n            continue\n        if _is_finalvar_with_default_val(ann_type, getattr(cls, ann_name, PydanticUndefined)):\n            class_vars.add(ann_name)\n            continue\n        if not is_valid_field_name(ann_name):\n            continue\n        if cls.__pydantic_root_model__ and ann_name != 'root':\n            raise NameError(\n                f\"Unexpected field with name {ann_name!r}; only 'root' is allowed as a field of a `RootModel`\"\n            )\n\n        # when building a generic model with `MyModel[int]`, the generic_origin check makes sure we don't get\n        # \"... shadows an attribute\" warnings\n        generic_origin = getattr(cls, '__pydantic_generic_metadata__', {}).get('origin')\n        for base in bases:\n            dataclass_fields = {\n                field.name for field in (dataclasses.fields(base) if dataclasses.is_dataclass(base) else ())\n            }\n            if hasattr(base, ann_name):\n                if base is generic_origin:\n                    # Don't warn when \"shadowing\" of attributes in parametrized generics\n                    continue\n\n                if ann_name in dataclass_fields:\n                    # Don't warn when inheriting stdlib dataclasses whose fields are \"shadowed\" by defaults being set\n                    # on the class instance.\n                    continue\n\n                if ann_name not in annotations:\n                    # Don't warn when a field exists in a parent class but has not been defined in the current class\n                    continue\n\n                warnings.warn(\n                    f'Field name \"{ann_name}\" in \"{cls.__qualname__}\" shadows an attribute in parent '\n                    f'\"{base.__qualname__}\"',\n                    UserWarning,\n                )\n\n        try:\n            default = getattr(cls, ann_name, PydanticUndefined)\n            if default is PydanticUndefined:\n                raise AttributeError\n        except AttributeError:\n            if ann_name in annotations:\n                field_info = FieldInfo.from_annotation(ann_type)\n            else:\n                # if field has no default value and is not in __annotations__ this means that it is\n                # defined in a base class and we can take it from there\n                model_fields_lookup: dict[str, FieldInfo] = {}\n                for x in cls.__bases__[::-1]:\n                    model_fields_lookup.update(getattr(x, 'model_fields', {}))\n                if ann_name in model_fields_lookup:\n                    # The field was present on one of the (possibly multiple) base classes\n                    # copy the field to make sure typevar substitutions don't cause issues with the base classes\n                    field_info = copy(model_fields_lookup[ann_name])\n                else:\n                    # The field was not found on any base classes; this seems to be caused by fields not getting\n                    # generated thanks to models not being fully defined while initializing recursive models.\n                    # Nothing stops us from just creating a new FieldInfo for this type hint, so we do this.\n                    field_info = FieldInfo.from_annotation(ann_type)\n        else:\n            _warn_on_nested_alias_in_annotation(ann_type, ann_name)\n            field_info = FieldInfo.from_annotated_attribute(ann_type, default)\n            # attributes which are fields are removed from the class namespace:\n            # 1. To match the behaviour of annotation-only fields\n            # 2. To avoid false positives in the NameError check above\n            try:\n                delattr(cls, ann_name)\n            except AttributeError:\n                pass  # indicates the attribute was on a parent class\n\n        # Use cls.__dict__['__pydantic_decorators__'] instead of cls.__pydantic_decorators__\n        # to make sure the decorators have already been built for this exact class\n        decorators: DecoratorInfos = cls.__dict__['__pydantic_decorators__']\n        if ann_name in decorators.computed_fields:\n            raise ValueError(\"you can't override a field with a computed field\")\n        fields[ann_name] = field_info\n\n    if typevars_map:\n        for field in fields.values():\n            field.apply_typevars_map(typevars_map, types_namespace)\n\n    _update_fields_from_docstrings(cls, fields, config_wrapper)\n\n    return fields, class_vars\n\n\ndef _warn_on_nested_alias_in_annotation(ann_type: type[Any], ann_name: str):\n    from ..fields import FieldInfo\n\n    if hasattr(ann_type, '__args__'):\n        for anno_arg in ann_type.__args__:\n            if _typing_extra.is_annotated(anno_arg):\n                for anno_type_arg in _typing_extra.get_args(anno_arg):\n                    if isinstance(anno_type_arg, FieldInfo) and anno_type_arg.alias is not None:\n                        warnings.warn(\n                            f'`alias` specification on field \"{ann_name}\" must be set on outermost annotation to take effect.',\n                            UserWarning,\n                        )\n                        break\n\n\ndef _is_finalvar_with_default_val(type_: type[Any], val: Any) -> bool:\n    from ..fields import FieldInfo\n\n    if not is_finalvar(type_):\n        return False\n    elif val is PydanticUndefined:\n        return False\n    elif isinstance(val, FieldInfo) and (val.default is PydanticUndefined and val.default_factory is None):\n        return False\n    else:\n        return True\n\n\ndef collect_dataclass_fields(\n    cls: type[StandardDataclass],\n    types_namespace: dict[str, Any] | None,\n    *,\n    typevars_map: dict[Any, Any] | None = None,\n    config_wrapper: ConfigWrapper | None = None,\n) -> dict[str, FieldInfo]:\n    \"\"\"Collect the fields of a dataclass.\n\n    Args:\n        cls: dataclass.\n        types_namespace: Optional extra namespace to look for types in.\n        typevars_map: A dictionary mapping type variables to their concrete types.\n        config_wrapper: The config wrapper instance.\n\n    Returns:\n        The dataclass fields.\n    \"\"\"\n    from ..fields import FieldInfo\n\n    fields: dict[str, FieldInfo] = {}\n    dataclass_fields: dict[str, dataclasses.Field] = cls.__dataclass_fields__\n    cls_localns = dict(vars(cls))  # this matches get_cls_type_hints_lenient, but all tests pass with `= None` instead\n\n    source_module = sys.modules.get(cls.__module__)\n    if source_module is not None:\n        types_namespace = {**source_module.__dict__, **(types_namespace or {})}\n\n    for ann_name, dataclass_field in dataclass_fields.items():\n        ann_type = _typing_extra.eval_type_lenient(dataclass_field.type, types_namespace, cls_localns)\n        if is_classvar(ann_type):\n            continue\n\n        if (\n            not dataclass_field.init\n            and dataclass_field.default == dataclasses.MISSING\n            and dataclass_field.default_factory == dataclasses.MISSING\n        ):\n            # TODO: We should probably do something with this so that validate_assignment behaves properly\n            #   Issue: https://github.com/pydantic/pydantic/issues/5470\n            continue\n\n        if isinstance(dataclass_field.default, FieldInfo):\n            if dataclass_field.default.init_var:\n                if dataclass_field.default.init is False:\n                    raise PydanticUserError(\n                        f'Dataclass field {ann_name} has init=False and init_var=True, but these are mutually exclusive.',\n                        code='clashing-init-and-init-var',\n                    )\n\n                # TODO: same note as above re validate_assignment\n                continue\n            field_info = FieldInfo.from_annotated_attribute(ann_type, dataclass_field.default)\n        else:\n            field_info = FieldInfo.from_annotated_attribute(ann_type, dataclass_field)\n\n        fields[ann_name] = field_info\n\n        if field_info.default is not PydanticUndefined and isinstance(getattr(cls, ann_name, field_info), FieldInfo):\n            # We need this to fix the default when the \"default\" from __dataclass_fields__ is a pydantic.FieldInfo\n            setattr(cls, ann_name, field_info.default)\n\n    if typevars_map:\n        for field in fields.values():\n            field.apply_typevars_map(typevars_map, types_namespace)\n\n    if config_wrapper is not None:\n        _update_fields_from_docstrings(cls, fields, config_wrapper)\n\n    return fields\n\n\ndef is_valid_field_name(name: str) -> bool:\n    return not name.startswith('_')\n\n\ndef is_valid_privateattr_name(name: str) -> bool:\n    return name.startswith('_') and not name.startswith('__')\n", "pydantic/_internal/_repr.py": "\"\"\"Tools to provide pretty/human-readable display of objects.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nimport types\nimport typing\nfrom typing import Any\n\nimport typing_extensions\n\nfrom . import _typing_extra\n\nif typing.TYPE_CHECKING:\n    ReprArgs: typing_extensions.TypeAlias = 'typing.Iterable[tuple[str | None, Any]]'\n    RichReprResult: typing_extensions.TypeAlias = (\n        'typing.Iterable[Any | tuple[Any] | tuple[str, Any] | tuple[str, Any, Any]]'\n    )\n\n\nclass PlainRepr(str):\n    \"\"\"String class where repr doesn't include quotes. Useful with Representation when you want to return a string\n    representation of something that is valid (or pseudo-valid) python.\n    \"\"\"\n\n    def __repr__(self) -> str:\n        return str(self)\n\n\nclass Representation:\n    # Mixin to provide `__str__`, `__repr__`, and `__pretty__` and `__rich_repr__` methods.\n    # `__pretty__` is used by [devtools](https://python-devtools.helpmanual.io/).\n    # `__rich_repr__` is used by [rich](https://rich.readthedocs.io/en/stable/pretty.html).\n    # (this is not a docstring to avoid adding a docstring to classes which inherit from Representation)\n\n    # we don't want to use a type annotation here as it can break get_type_hints\n    __slots__ = tuple()  # type: typing.Collection[str]\n\n    def __repr_args__(self) -> ReprArgs:\n        \"\"\"Returns the attributes to show in __str__, __repr__, and __pretty__ this is generally overridden.\n\n        Can either return:\n        * name - value pairs, e.g.: `[('foo_name', 'foo'), ('bar_name', ['b', 'a', 'r'])]`\n        * or, just values, e.g.: `[(None, 'foo'), (None, ['b', 'a', 'r'])]`\n        \"\"\"\n        attrs_names = self.__slots__\n        if not attrs_names and hasattr(self, '__dict__'):\n            attrs_names = self.__dict__.keys()\n        attrs = ((s, getattr(self, s)) for s in attrs_names)\n        return [(a, v) for a, v in attrs if v is not None]\n\n    def __repr_name__(self) -> str:\n        \"\"\"Name of the instance's class, used in __repr__.\"\"\"\n        return self.__class__.__name__\n\n    def __repr_str__(self, join_str: str) -> str:\n        return join_str.join(repr(v) if a is None else f'{a}={v!r}' for a, v in self.__repr_args__())\n\n    def __pretty__(self, fmt: typing.Callable[[Any], Any], **kwargs: Any) -> typing.Generator[Any, None, None]:\n        \"\"\"Used by devtools (https://python-devtools.helpmanual.io/) to pretty print objects.\"\"\"\n        yield self.__repr_name__() + '('\n        yield 1\n        for name, value in self.__repr_args__():\n            if name is not None:\n                yield name + '='\n            yield fmt(value)\n            yield ','\n            yield 0\n        yield -1\n        yield ')'\n\n    def __rich_repr__(self) -> RichReprResult:\n        \"\"\"Used by Rich (https://rich.readthedocs.io/en/stable/pretty.html) to pretty print objects.\"\"\"\n        for name, field_repr in self.__repr_args__():\n            if name is None:\n                yield field_repr\n            else:\n                yield name, field_repr\n\n    def __str__(self) -> str:\n        return self.__repr_str__(' ')\n\n    def __repr__(self) -> str:\n        return f'{self.__repr_name__()}({self.__repr_str__(\", \")})'\n\n\ndef display_as_type(obj: Any) -> str:\n    \"\"\"Pretty representation of a type, should be as close as possible to the original type definition string.\n\n    Takes some logic from `typing._type_repr`.\n    \"\"\"\n    if isinstance(obj, types.FunctionType):\n        return obj.__name__\n    elif obj is ...:\n        return '...'\n    elif isinstance(obj, Representation):\n        return repr(obj)\n    elif isinstance(obj, typing_extensions.TypeAliasType):\n        return str(obj)\n\n    if not isinstance(obj, (_typing_extra.typing_base, _typing_extra.WithArgsTypes, type)):\n        obj = obj.__class__\n\n    if _typing_extra.origin_is_union(typing_extensions.get_origin(obj)):\n        args = ', '.join(map(display_as_type, typing_extensions.get_args(obj)))\n        return f'Union[{args}]'\n    elif isinstance(obj, _typing_extra.WithArgsTypes):\n        if typing_extensions.get_origin(obj) == typing_extensions.Literal:\n            args = ', '.join(map(repr, typing_extensions.get_args(obj)))\n        else:\n            args = ', '.join(map(display_as_type, typing_extensions.get_args(obj)))\n        try:\n            return f'{obj.__qualname__}[{args}]'\n        except AttributeError:\n            return str(obj)  # handles TypeAliasType in 3.12\n    elif isinstance(obj, type):\n        return obj.__qualname__\n    else:\n        return repr(obj).replace('typing.', '').replace('typing_extensions.', '')\n", "pydantic/_internal/_decorators.py": "\"\"\"Logic related to validators applied to models etc. via the `@field_validator` and `@model_validator` decorators.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom collections import deque\nfrom dataclasses import dataclass, field\nfrom functools import cached_property, partial, partialmethod\nfrom inspect import Parameter, Signature, isdatadescriptor, ismethoddescriptor, signature\nfrom itertools import islice\nfrom typing import TYPE_CHECKING, Any, Callable, ClassVar, Generic, Iterable, TypeVar, Union\n\nfrom pydantic_core import PydanticUndefined, core_schema\nfrom typing_extensions import Literal, TypeAlias, is_typeddict\n\nfrom ..errors import PydanticUserError\nfrom ._core_utils import get_type_ref\nfrom ._internal_dataclass import slots_true\nfrom ._typing_extra import get_function_type_hints\n\nif TYPE_CHECKING:\n    from ..fields import ComputedFieldInfo\n    from ..functional_validators import FieldValidatorModes\n\n\n@dataclass(**slots_true)\nclass ValidatorDecoratorInfo:\n    \"\"\"A container for data from `@validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        each_item: For complex objects (sets, lists etc.) whether to validate individual\n            elements rather than the whole object.\n        always: Whether this method and other validators should be called even if the value is missing.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@validator'\n\n    fields: tuple[str, ...]\n    mode: Literal['before', 'after']\n    each_item: bool\n    always: bool\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass FieldValidatorDecoratorInfo:\n    \"\"\"A container for data from `@field_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_validator'.\n        fields: A tuple of field names the validator should be called on.\n        mode: The proposed validator mode.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_validator'\n\n    fields: tuple[str, ...]\n    mode: FieldValidatorModes\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass RootValidatorDecoratorInfo:\n    \"\"\"A container for data from `@root_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@root_validator'.\n        mode: The proposed validator mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@root_validator'\n    mode: Literal['before', 'after']\n\n\n@dataclass(**slots_true)\nclass FieldSerializerDecoratorInfo:\n    \"\"\"A container for data from `@field_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@field_serializer'.\n        fields: A tuple of field names the serializer should be called on.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n        check_fields: Whether to check that the fields actually exist on the model.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@field_serializer'\n    fields: tuple[str, ...]\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n    check_fields: bool | None\n\n\n@dataclass(**slots_true)\nclass ModelSerializerDecoratorInfo:\n    \"\"\"A container for data from `@model_serializer` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_serializer'.\n        mode: The proposed serializer mode.\n        return_type: The type of the serializer's return value.\n        when_used: The serialization condition. Accepts a string with values `'always'`, `'unless-none'`, `'json'`,\n            and `'json-unless-none'`.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_serializer'\n    mode: Literal['plain', 'wrap']\n    return_type: Any\n    when_used: core_schema.WhenUsed\n\n\n@dataclass(**slots_true)\nclass ModelValidatorDecoratorInfo:\n    \"\"\"A container for data from `@model_validator` so that we can access it\n    while building the pydantic-core schema.\n\n    Attributes:\n        decorator_repr: A class variable representing the decorator string, '@model_serializer'.\n        mode: The proposed serializer mode.\n    \"\"\"\n\n    decorator_repr: ClassVar[str] = '@model_validator'\n    mode: Literal['wrap', 'before', 'after']\n\n\nDecoratorInfo: TypeAlias = \"\"\"Union[\n    ValidatorDecoratorInfo,\n    FieldValidatorDecoratorInfo,\n    RootValidatorDecoratorInfo,\n    FieldSerializerDecoratorInfo,\n    ModelSerializerDecoratorInfo,\n    ModelValidatorDecoratorInfo,\n    ComputedFieldInfo,\n]\"\"\"\n\nReturnType = TypeVar('ReturnType')\nDecoratedType: TypeAlias = (\n    'Union[classmethod[Any, Any, ReturnType], staticmethod[Any, ReturnType], Callable[..., ReturnType], property]'\n)\n\n\n@dataclass  # can't use slots here since we set attributes on `__post_init__`\nclass PydanticDescriptorProxy(Generic[ReturnType]):\n    \"\"\"Wrap a classmethod, staticmethod, property or unbound function\n    and act as a descriptor that allows us to detect decorated items\n    from the class' attributes.\n\n    This class' __get__ returns the wrapped item's __get__ result,\n    which makes it transparent for classmethods and staticmethods.\n\n    Attributes:\n        wrapped: The decorator that has to be wrapped.\n        decorator_info: The decorator info.\n        shim: A wrapper function to wrap V1 style function.\n    \"\"\"\n\n    wrapped: DecoratedType[ReturnType]\n    decorator_info: DecoratorInfo\n    shim: Callable[[Callable[..., Any]], Callable[..., Any]] | None = None\n\n    def __post_init__(self):\n        for attr in 'setter', 'deleter':\n            if hasattr(self.wrapped, attr):\n                f = partial(self._call_wrapped_attr, name=attr)\n                setattr(self, attr, f)\n\n    def _call_wrapped_attr(self, func: Callable[[Any], None], *, name: str) -> PydanticDescriptorProxy[ReturnType]:\n        self.wrapped = getattr(self.wrapped, name)(func)\n        return self\n\n    def __get__(self, obj: object | None, obj_type: type[object] | None = None) -> PydanticDescriptorProxy[ReturnType]:\n        try:\n            return self.wrapped.__get__(obj, obj_type)\n        except AttributeError:\n            # not a descriptor, e.g. a partial object\n            return self.wrapped  # type: ignore[return-value]\n\n    def __set_name__(self, instance: Any, name: str) -> None:\n        if hasattr(self.wrapped, '__set_name__'):\n            self.wrapped.__set_name__(instance, name)  # pyright: ignore[reportFunctionMemberAccess]\n\n    def __getattr__(self, __name: str) -> Any:\n        \"\"\"Forward checks for __isabstractmethod__ and such.\"\"\"\n        return getattr(self.wrapped, __name)\n\n\nDecoratorInfoType = TypeVar('DecoratorInfoType', bound=DecoratorInfo)\n\n\n@dataclass(**slots_true)\nclass Decorator(Generic[DecoratorInfoType]):\n    \"\"\"A generic container class to join together the decorator metadata\n    (metadata from decorator itself, which we have when the\n    decorator is called but not when we are building the core-schema)\n    and the bound function (which we have after the class itself is created).\n\n    Attributes:\n        cls_ref: The class ref.\n        cls_var_name: The decorated function name.\n        func: The decorated function.\n        shim: A wrapper function to wrap V1 style function.\n        info: The decorator info.\n    \"\"\"\n\n    cls_ref: str\n    cls_var_name: str\n    func: Callable[..., Any]\n    shim: Callable[[Any], Any] | None\n    info: DecoratorInfoType\n\n    @staticmethod\n    def build(\n        cls_: Any,\n        *,\n        cls_var_name: str,\n        shim: Callable[[Any], Any] | None,\n        info: DecoratorInfoType,\n    ) -> Decorator[DecoratorInfoType]:\n        \"\"\"Build a new decorator.\n\n        Args:\n            cls_: The class.\n            cls_var_name: The decorated function name.\n            shim: A wrapper function to wrap V1 style function.\n            info: The decorator info.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        func = get_attribute_from_bases(cls_, cls_var_name)\n        if shim is not None:\n            func = shim(func)\n        func = unwrap_wrapped_function(func, unwrap_partial=False)\n        if not callable(func):\n            # This branch will get hit for classmethod properties\n            attribute = get_attribute_from_base_dicts(cls_, cls_var_name)  # prevents the binding call to `__get__`\n            if isinstance(attribute, PydanticDescriptorProxy):\n                func = unwrap_wrapped_function(attribute.wrapped)\n        return Decorator(\n            cls_ref=get_type_ref(cls_),\n            cls_var_name=cls_var_name,\n            func=func,\n            shim=shim,\n            info=info,\n        )\n\n    def bind_to_cls(self, cls: Any) -> Decorator[DecoratorInfoType]:\n        \"\"\"Bind the decorator to a class.\n\n        Args:\n            cls: the class.\n\n        Returns:\n            The new decorator instance.\n        \"\"\"\n        return self.build(\n            cls,\n            cls_var_name=self.cls_var_name,\n            shim=self.shim,\n            info=self.info,\n        )\n\n\ndef get_bases(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Get the base classes of a class or typeddict.\n\n    Args:\n        tp: The type or class to get the bases.\n\n    Returns:\n        The base classes.\n    \"\"\"\n    if is_typeddict(tp):\n        return tp.__orig_bases__  # type: ignore\n    try:\n        return tp.__bases__\n    except AttributeError:\n        return ()\n\n\ndef mro(tp: type[Any]) -> tuple[type[Any], ...]:\n    \"\"\"Calculate the Method Resolution Order of bases using the C3 algorithm.\n\n    See https://www.python.org/download/releases/2.3/mro/\n    \"\"\"\n    # try to use the existing mro, for performance mainly\n    # but also because it helps verify the implementation below\n    if not is_typeddict(tp):\n        try:\n            return tp.__mro__\n        except AttributeError:\n            # GenericAlias and some other cases\n            pass\n\n    bases = get_bases(tp)\n    return (tp,) + mro_for_bases(bases)\n\n\ndef mro_for_bases(bases: tuple[type[Any], ...]) -> tuple[type[Any], ...]:\n    def merge_seqs(seqs: list[deque[type[Any]]]) -> Iterable[type[Any]]:\n        while True:\n            non_empty = [seq for seq in seqs if seq]\n            if not non_empty:\n                # Nothing left to process, we're done.\n                return\n            candidate: type[Any] | None = None\n            for seq in non_empty:  # Find merge candidates among seq heads.\n                candidate = seq[0]\n                not_head = [s for s in non_empty if candidate in islice(s, 1, None)]\n                if not_head:\n                    # Reject the candidate.\n                    candidate = None\n                else:\n                    break\n            if not candidate:\n                raise TypeError('Inconsistent hierarchy, no C3 MRO is possible')\n            yield candidate\n            for seq in non_empty:\n                # Remove candidate.\n                if seq[0] == candidate:\n                    seq.popleft()\n\n    seqs = [deque(mro(base)) for base in bases] + [deque(bases)]\n    return tuple(merge_seqs(seqs))\n\n\n_sentinel = object()\n\n\ndef get_attribute_from_bases(tp: type[Any] | tuple[type[Any], ...], name: str) -> Any:\n    \"\"\"Get the attribute from the next class in the MRO that has it,\n    aiming to simulate calling the method on the actual class.\n\n    The reason for iterating over the mro instead of just getting\n    the attribute (which would do that for us) is to support TypedDict,\n    which lacks a real __mro__, but can have a virtual one constructed\n    from its bases (as done here).\n\n    Args:\n        tp: The type or class to search for the attribute. If a tuple, this is treated as a set of base classes.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        AttributeError: If the attribute is not found in any class in the MRO.\n    \"\"\"\n    if isinstance(tp, tuple):\n        for base in mro_for_bases(tp):\n            attribute = base.__dict__.get(name, _sentinel)\n            if attribute is not _sentinel:\n                attribute_get = getattr(attribute, '__get__', None)\n                if attribute_get is not None:\n                    return attribute_get(None, tp)\n                return attribute\n        raise AttributeError(f'{name} not found in {tp}')\n    else:\n        try:\n            return getattr(tp, name)\n        except AttributeError:\n            return get_attribute_from_bases(mro(tp), name)\n\n\ndef get_attribute_from_base_dicts(tp: type[Any], name: str) -> Any:\n    \"\"\"Get an attribute out of the `__dict__` following the MRO.\n    This prevents the call to `__get__` on the descriptor, and allows\n    us to get the original function for classmethod properties.\n\n    Args:\n        tp: The type or class to search for the attribute.\n        name: The name of the attribute to retrieve.\n\n    Returns:\n        Any: The attribute value, if found.\n\n    Raises:\n        KeyError: If the attribute is not found in any class's `__dict__` in the MRO.\n    \"\"\"\n    for base in reversed(mro(tp)):\n        if name in base.__dict__:\n            return base.__dict__[name]\n    return tp.__dict__[name]  # raise the error\n\n\n@dataclass(**slots_true)\nclass DecoratorInfos:\n    \"\"\"Mapping of name in the class namespace to decorator info.\n\n    note that the name in the class namespace is the function or attribute name\n    not the field name!\n    \"\"\"\n\n    validators: dict[str, Decorator[ValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_validators: dict[str, Decorator[FieldValidatorDecoratorInfo]] = field(default_factory=dict)\n    root_validators: dict[str, Decorator[RootValidatorDecoratorInfo]] = field(default_factory=dict)\n    field_serializers: dict[str, Decorator[FieldSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_serializers: dict[str, Decorator[ModelSerializerDecoratorInfo]] = field(default_factory=dict)\n    model_validators: dict[str, Decorator[ModelValidatorDecoratorInfo]] = field(default_factory=dict)\n    computed_fields: dict[str, Decorator[ComputedFieldInfo]] = field(default_factory=dict)\n\n    @staticmethod\n    def build(model_dc: type[Any]) -> DecoratorInfos:  # noqa: C901 (ignore complexity)\n        \"\"\"We want to collect all DecFunc instances that exist as\n        attributes in the namespace of the class (a BaseModel or dataclass)\n        that called us\n        But we want to collect these in the order of the bases\n        So instead of getting them all from the leaf class (the class that called us),\n        we traverse the bases from root (the oldest ancestor class) to leaf\n        and collect all of the instances as we go, taking care to replace\n        any duplicate ones with the last one we see to mimic how function overriding\n        works with inheritance.\n        If we do replace any functions we put the replacement into the position\n        the replaced function was in; that is, we maintain the order.\n        \"\"\"\n        # reminder: dicts are ordered and replacement does not alter the order\n        res = DecoratorInfos()\n        for base in reversed(mro(model_dc)[1:]):\n            existing: DecoratorInfos | None = base.__dict__.get('__pydantic_decorators__')\n            if existing is None:\n                existing = DecoratorInfos.build(base)\n            res.validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.validators.items()})\n            res.field_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_validators.items()})\n            res.root_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.root_validators.items()})\n            res.field_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.field_serializers.items()})\n            res.model_serializers.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_serializers.items()})\n            res.model_validators.update({k: v.bind_to_cls(model_dc) for k, v in existing.model_validators.items()})\n            res.computed_fields.update({k: v.bind_to_cls(model_dc) for k, v in existing.computed_fields.items()})\n\n        to_replace: list[tuple[str, Any]] = []\n\n        for var_name, var_value in vars(model_dc).items():\n            if isinstance(var_value, PydanticDescriptorProxy):\n                info = var_value.decorator_info\n                if isinstance(info, ValidatorDecoratorInfo):\n                    res.validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldValidatorDecoratorInfo):\n                    res.field_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, RootValidatorDecoratorInfo):\n                    res.root_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, FieldSerializerDecoratorInfo):\n                    # check whether a serializer function is already registered for fields\n                    for field_serializer_decorator in res.field_serializers.values():\n                        # check that each field has at most one serializer function.\n                        # serializer functions for the same field in subclasses are allowed,\n                        # and are treated as overrides\n                        if field_serializer_decorator.cls_var_name == var_name:\n                            continue\n                        for f in info.fields:\n                            if f in field_serializer_decorator.info.fields:\n                                raise PydanticUserError(\n                                    'Multiple field serializer functions were defined '\n                                    f'for field {f!r}, this is not allowed.',\n                                    code='multiple-field-serializers',\n                                )\n                    res.field_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelValidatorDecoratorInfo):\n                    res.model_validators[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                elif isinstance(info, ModelSerializerDecoratorInfo):\n                    res.model_serializers[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=var_value.shim, info=info\n                    )\n                else:\n                    from ..fields import ComputedFieldInfo\n\n                    isinstance(var_value, ComputedFieldInfo)\n                    res.computed_fields[var_name] = Decorator.build(\n                        model_dc, cls_var_name=var_name, shim=None, info=info\n                    )\n                to_replace.append((var_name, var_value.wrapped))\n        if to_replace:\n            # If we can save `__pydantic_decorators__` on the class we'll be able to check for it above\n            # so then we don't need to re-process the type, which means we can discard our descriptor wrappers\n            # and replace them with the thing they are wrapping (see the other setattr call below)\n            # which allows validator class methods to also function as regular class methods\n            setattr(model_dc, '__pydantic_decorators__', res)\n            for name, value in to_replace:\n                setattr(model_dc, name, value)\n        return res\n\n\ndef inspect_validator(validator: Callable[..., Any], mode: FieldValidatorModes) -> bool:\n    \"\"\"Look at a field or model validator function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        validator: The validator function to inspect.\n        mode: The proposed validator mode.\n\n    Returns:\n        Whether the validator takes an info argument.\n    \"\"\"\n    try:\n        sig = signature(validator)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    n_positional = count_positional_required_params(sig)\n    if mode == 'wrap':\n        if n_positional == 3:\n            return True\n        elif n_positional == 2:\n            return False\n    else:\n        assert mode in {'before', 'after', 'plain'}, f\"invalid mode: {mode!r}, expected 'before', 'after' or 'plain\"\n        if n_positional == 2:\n            return True\n        elif n_positional == 1:\n            return False\n\n    raise PydanticUserError(\n        f'Unrecognized field_validator function signature for {validator} with `mode={mode}`:{sig}',\n        code='validator-signature',\n    )\n\n\ndef inspect_field_serializer(\n    serializer: Callable[..., Any], mode: Literal['plain', 'wrap'], computed_field: bool = False\n) -> tuple[bool, bool]:\n    \"\"\"Look at a field serializer function and determine if it is a field serializer,\n    and whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to inspect.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n        computed_field: When serializer is applied on computed_field. It doesn't require\n            info signature.\n\n    Returns:\n        Tuple of (is_field_serializer, info_arg).\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present and this is not a method:\n        return (False, False)\n\n    first = next(iter(sig.parameters.values()), None)\n    is_field_serializer = first is not None and first.name == 'self'\n\n    n_positional = count_positional_required_params(sig)\n    if is_field_serializer:\n        # -1 to correct for self parameter\n        info_arg = _serializer_info_arg(mode, n_positional - 1)\n    else:\n        info_arg = _serializer_info_arg(mode, n_positional)\n\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n    if info_arg and computed_field:\n        raise PydanticUserError(\n            'field_serializer on computed_field does not use info signature', code='field-serializer-signature'\n        )\n\n    else:\n        return is_field_serializer, info_arg\n\n\ndef inspect_annotated_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a serializer function used via `Annotated` and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        info_arg\n    \"\"\"\n    try:\n        sig = signature(serializer)\n    except (ValueError, TypeError):\n        # `inspect.signature` might not be able to infer a signature, e.g. with C objects.\n        # In this case, we assume no info argument is present:\n        return False\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized field_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='field-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef inspect_model_serializer(serializer: Callable[..., Any], mode: Literal['plain', 'wrap']) -> bool:\n    \"\"\"Look at a model serializer function and determine whether it takes an info argument.\n\n    An error is raised if the function has an invalid signature.\n\n    Args:\n        serializer: The serializer function to check.\n        mode: The serializer mode, either 'plain' or 'wrap'.\n\n    Returns:\n        `info_arg` - whether the function expects an info argument.\n    \"\"\"\n    if isinstance(serializer, (staticmethod, classmethod)) or not is_instance_method_from_sig(serializer):\n        raise PydanticUserError(\n            '`@model_serializer` must be applied to instance methods', code='model-serializer-instance-method'\n        )\n\n    sig = signature(serializer)\n    info_arg = _serializer_info_arg(mode, count_positional_required_params(sig))\n    if info_arg is None:\n        raise PydanticUserError(\n            f'Unrecognized model_serializer function signature for {serializer} with `mode={mode}`:{sig}',\n            code='model-serializer-signature',\n        )\n    else:\n        return info_arg\n\n\ndef _serializer_info_arg(mode: Literal['plain', 'wrap'], n_positional: int) -> bool | None:\n    if mode == 'plain':\n        if n_positional == 1:\n            # (input_value: Any, /) -> Any\n            return False\n        elif n_positional == 2:\n            # (model: Any, input_value: Any, /) -> Any\n            return True\n    else:\n        assert mode == 'wrap', f\"invalid mode: {mode!r}, expected 'plain' or 'wrap'\"\n        if n_positional == 2:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, /) -> Any\n            return False\n        elif n_positional == 3:\n            # (input_value: Any, serializer: SerializerFunctionWrapHandler, info: SerializationInfo, /) -> Any\n            return True\n\n    return None\n\n\nAnyDecoratorCallable: TypeAlias = (\n    'Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any], Callable[..., Any]]'\n)\n\n\ndef is_instance_method_from_sig(function: AnyDecoratorCallable) -> bool:\n    \"\"\"Whether the function is an instance method.\n\n    It will consider a function as instance method if the first parameter of\n    function is `self`.\n\n    Args:\n        function: The function to check.\n\n    Returns:\n        `True` if the function is an instance method, `False` otherwise.\n    \"\"\"\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'self':\n        return True\n    return False\n\n\ndef ensure_classmethod_based_on_signature(function: AnyDecoratorCallable) -> Any:\n    \"\"\"Apply the `@classmethod` decorator on the function.\n\n    Args:\n        function: The function to apply the decorator on.\n\n    Return:\n        The `@classmethod` decorator applied function.\n    \"\"\"\n    if not isinstance(\n        unwrap_wrapped_function(function, unwrap_class_static_method=False), classmethod\n    ) and _is_classmethod_from_sig(function):\n        return classmethod(function)  # type: ignore[arg-type]\n    return function\n\n\ndef _is_classmethod_from_sig(function: AnyDecoratorCallable) -> bool:\n    sig = signature(unwrap_wrapped_function(function))\n    first = next(iter(sig.parameters.values()), None)\n    if first and first.name == 'cls':\n        return True\n    return False\n\n\ndef unwrap_wrapped_function(\n    func: Any,\n    *,\n    unwrap_partial: bool = True,\n    unwrap_class_static_method: bool = True,\n) -> Any:\n    \"\"\"Recursively unwraps a wrapped function until the underlying function is reached.\n    This handles property, functools.partial, functools.partialmethod, staticmethod and classmethod.\n\n    Args:\n        func: The function to unwrap.\n        unwrap_partial: If True (default), unwrap partial and partialmethod decorators, otherwise don't.\n            decorators.\n        unwrap_class_static_method: If True (default), also unwrap classmethod and staticmethod\n            decorators. If False, only unwrap partial and partialmethod decorators.\n\n    Returns:\n        The underlying function of the wrapped function.\n    \"\"\"\n    all: set[Any] = {property, cached_property}\n\n    if unwrap_partial:\n        all.update({partial, partialmethod})\n\n    if unwrap_class_static_method:\n        all.update({staticmethod, classmethod})\n\n    while isinstance(func, tuple(all)):\n        if unwrap_class_static_method and isinstance(func, (classmethod, staticmethod)):\n            func = func.__func__\n        elif isinstance(func, (partial, partialmethod)):\n            func = func.func\n        elif isinstance(func, property):\n            func = func.fget  # arbitrary choice, convenient for computed fields\n        else:\n            # Make coverage happy as it can only get here in the last possible case\n            assert isinstance(func, cached_property)\n            func = func.func  # type: ignore\n\n    return func\n\n\ndef get_function_return_type(\n    func: Any, explicit_return_type: Any, types_namespace: dict[str, Any] | None = None\n) -> Any:\n    \"\"\"Get the function return type.\n\n    It gets the return type from the type annotation if `explicit_return_type` is `None`.\n    Otherwise, it returns `explicit_return_type`.\n\n    Args:\n        func: The function to get its return type.\n        explicit_return_type: The explicit return type.\n        types_namespace: The types namespace, defaults to `None`.\n\n    Returns:\n        The function return type.\n    \"\"\"\n    if explicit_return_type is PydanticUndefined:\n        # try to get it from the type annotation\n        hints = get_function_type_hints(\n            unwrap_wrapped_function(func), include_keys={'return'}, types_namespace=types_namespace\n        )\n        return hints.get('return', PydanticUndefined)\n    else:\n        return explicit_return_type\n\n\ndef count_positional_required_params(sig: Signature) -> int:\n    \"\"\"Get the number of positional (required) arguments of a signature.\n\n    This function should only be used to inspect signatures of validation and serialization functions.\n    The first argument (the value being serialized or validated) is counted as a required argument\n    even if a default value exists.\n\n    Returns:\n        The number of positional arguments of a signature.\n    \"\"\"\n    parameters = list(sig.parameters.values())\n    return sum(\n        1\n        for param in parameters\n        if can_be_positional(param)\n        # First argument is the value being validated/serialized, and can have a default value\n        # (e.g. `float`, which has signature `(x=0, /)`). We assume other parameters (the info arg\n        # for instance) should be required, and thus without any default value.\n        and (param.default is Parameter.empty or param == parameters[0])\n    )\n\n\ndef can_be_positional(param: Parameter) -> bool:\n    return param.kind in (Parameter.POSITIONAL_ONLY, Parameter.POSITIONAL_OR_KEYWORD)\n\n\ndef ensure_property(f: Any) -> Any:\n    \"\"\"Ensure that a function is a `property` or `cached_property`, or is a valid descriptor.\n\n    Args:\n        f: The function to check.\n\n    Returns:\n        The function, or a `property` or `cached_property` instance wrapping the function.\n    \"\"\"\n    if ismethoddescriptor(f) or isdatadescriptor(f):\n        return f\n    else:\n        return property(f)\n", "pydantic/_internal/_validate_call.py": "from __future__ import annotations as _annotations\n\nimport inspect\nfrom functools import partial\nfrom typing import Any, Awaitable, Callable\n\nimport pydantic_core\n\nfrom ..config import ConfigDict\nfrom ..plugin._schema_validator import create_schema_validator\nfrom . import _generate_schema, _typing_extra\nfrom ._config import ConfigWrapper\n\n\nclass ValidateCallWrapper:\n    \"\"\"This is a wrapper around a function that validates the arguments passed to it, and optionally the return value.\"\"\"\n\n    __slots__ = (\n        '__pydantic_validator__',\n        '__name__',\n        '__qualname__',\n        '__annotations__',\n        '__dict__',  # required for __module__\n    )\n\n    def __init__(self, function: Callable[..., Any], config: ConfigDict | None, validate_return: bool):\n        if isinstance(function, partial):\n            func = function.func\n            schema_type = func\n            self.__name__ = f'partial({func.__name__})'\n            self.__qualname__ = f'partial({func.__qualname__})'\n            self.__module__ = func.__module__\n        else:\n            schema_type = function\n            self.__name__ = function.__name__\n            self.__qualname__ = function.__qualname__\n            self.__module__ = function.__module__\n\n        namespace = _typing_extra.add_module_globals(function, None)\n        config_wrapper = ConfigWrapper(config)\n        gen_schema = _generate_schema.GenerateSchema(config_wrapper, namespace)\n        schema = gen_schema.clean_schema(gen_schema.generate_schema(function))\n        core_config = config_wrapper.core_config(self)\n\n        self.__pydantic_validator__ = create_schema_validator(\n            schema,\n            schema_type,\n            self.__module__,\n            self.__qualname__,\n            'validate_call',\n            core_config,\n            config_wrapper.plugin_settings,\n        )\n\n        if validate_return:\n            signature = inspect.signature(function)\n            return_type = signature.return_annotation if signature.return_annotation is not signature.empty else Any\n            gen_schema = _generate_schema.GenerateSchema(config_wrapper, namespace)\n            schema = gen_schema.clean_schema(gen_schema.generate_schema(return_type))\n            validator = create_schema_validator(\n                schema,\n                schema_type,\n                self.__module__,\n                self.__qualname__,\n                'validate_call',\n                core_config,\n                config_wrapper.plugin_settings,\n            )\n            if inspect.iscoroutinefunction(function):\n\n                async def return_val_wrapper(aw: Awaitable[Any]) -> None:\n                    return validator.validate_python(await aw)\n\n                self.__return_pydantic_validator__ = return_val_wrapper\n            else:\n                self.__return_pydantic_validator__ = validator.validate_python\n        else:\n            self.__return_pydantic_validator__ = None\n\n    def __call__(self, *args: Any, **kwargs: Any) -> Any:\n        res = self.__pydantic_validator__.validate_python(pydantic_core.ArgsKwargs(args, kwargs))\n        if self.__return_pydantic_validator__:\n            return self.__return_pydantic_validator__(res)\n        return res\n", "pydantic/deprecated/config.py": "from __future__ import annotations as _annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING, Any\n\nfrom typing_extensions import Literal, deprecated\n\nfrom .._internal import _config\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = 'BaseConfig', 'Extra'\n\n\nclass _ConfigMetaclass(type):\n    def __getattr__(self, item: str) -> Any:\n        try:\n            obj = _config.config_defaults[item]\n            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)\n            return obj\n        except KeyError as exc:\n            raise AttributeError(f\"type object '{self.__name__}' has no attribute {exc}\") from exc\n\n\n@deprecated('BaseConfig is deprecated. Use the `pydantic.ConfigDict` instead.', category=PydanticDeprecatedSince20)\nclass BaseConfig(metaclass=_ConfigMetaclass):\n    \"\"\"This class is only retained for backwards compatibility.\n\n    !!! Warning \"Deprecated\"\n        BaseConfig is deprecated. Use the [`pydantic.ConfigDict`][pydantic.ConfigDict] instead.\n    \"\"\"\n\n    def __getattr__(self, item: str) -> Any:\n        try:\n            obj = super().__getattribute__(item)\n            warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)\n            return obj\n        except AttributeError as exc:\n            try:\n                return getattr(type(self), item)\n            except AttributeError:\n                # re-raising changes the displayed text to reflect that `self` is not a type\n                raise AttributeError(str(exc)) from exc\n\n    def __init_subclass__(cls, **kwargs: Any) -> None:\n        warnings.warn(_config.DEPRECATION_MESSAGE, DeprecationWarning)\n        return super().__init_subclass__(**kwargs)\n\n\nclass _ExtraMeta(type):\n    def __getattribute__(self, __name: str) -> Any:\n        # The @deprecated decorator accesses other attributes, so we only emit a warning for the expected ones\n        if __name in {'allow', 'ignore', 'forbid'}:\n            warnings.warn(\n                \"`pydantic.config.Extra` is deprecated, use literal values instead (e.g. `extra='allow'`)\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n        return super().__getattribute__(__name)\n\n\n@deprecated(\n    \"Extra is deprecated. Use literal values instead (e.g. `extra='allow'`)\", category=PydanticDeprecatedSince20\n)\nclass Extra(metaclass=_ExtraMeta):\n    allow: Literal['allow'] = 'allow'\n    ignore: Literal['ignore'] = 'ignore'\n    forbid: Literal['forbid'] = 'forbid'\n", "pydantic/deprecated/parse.py": "from __future__ import annotations\n\nimport json\nimport pickle\nimport warnings\nfrom enum import Enum\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Callable\n\nfrom typing_extensions import deprecated\n\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n\nclass Protocol(str, Enum):\n    json = 'json'\n    pickle = 'pickle'\n\n\n@deprecated('`load_str_bytes` is deprecated.', category=None)\ndef load_str_bytes(\n    b: str | bytes,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: Protocol | None = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n) -> Any:\n    warnings.warn('`load_str_bytes` is deprecated.', category=PydanticDeprecatedSince20, stacklevel=2)\n    if proto is None and content_type:\n        if content_type.endswith(('json', 'javascript')):\n            pass\n        elif allow_pickle and content_type.endswith('pickle'):\n            proto = Protocol.pickle\n        else:\n            raise TypeError(f'Unknown content-type: {content_type}')\n\n    proto = proto or Protocol.json\n\n    if proto == Protocol.json:\n        if isinstance(b, bytes):\n            b = b.decode(encoding)\n        return json_loads(b)  # type: ignore\n    elif proto == Protocol.pickle:\n        if not allow_pickle:\n            raise RuntimeError('Trying to decode with pickle with allow_pickle=False')\n        bb = b if isinstance(b, bytes) else b.encode()  # type: ignore\n        return pickle.loads(bb)\n    else:\n        raise TypeError(f'Unknown protocol: {proto}')\n\n\n@deprecated('`load_file` is deprecated.', category=None)\ndef load_file(\n    path: str | Path,\n    *,\n    content_type: str | None = None,\n    encoding: str = 'utf8',\n    proto: Protocol | None = None,\n    allow_pickle: bool = False,\n    json_loads: Callable[[str], Any] = json.loads,\n) -> Any:\n    warnings.warn('`load_file` is deprecated.', category=PydanticDeprecatedSince20, stacklevel=2)\n    path = Path(path)\n    b = path.read_bytes()\n    if content_type is None:\n        if path.suffix in ('.js', '.json'):\n            proto = Protocol.json\n        elif path.suffix == '.pkl':\n            proto = Protocol.pickle\n\n    return load_str_bytes(\n        b, proto=proto, content_type=content_type, encoding=encoding, allow_pickle=allow_pickle, json_loads=json_loads\n    )\n", "pydantic/deprecated/tools.py": "from __future__ import annotations\n\nimport json\nimport warnings\nfrom typing import TYPE_CHECKING, Any, Callable, Type, TypeVar, Union\n\nfrom typing_extensions import deprecated\n\nfrom ..json_schema import DEFAULT_REF_TEMPLATE, GenerateJsonSchema\nfrom ..type_adapter import TypeAdapter\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = 'parse_obj_as', 'schema_of', 'schema_json_of'\n\nNameFactory = Union[str, Callable[[Type[Any]], str]]\n\n\nT = TypeVar('T')\n\n\n@deprecated(\n    '`parse_obj_as` is deprecated. Use `pydantic.TypeAdapter.validate_python` instead.',\n    category=None,\n)\ndef parse_obj_as(type_: type[T], obj: Any, type_name: NameFactory | None = None) -> T:\n    warnings.warn(\n        '`parse_obj_as` is deprecated. Use `pydantic.TypeAdapter.validate_python` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    if type_name is not None:  # pragma: no cover\n        warnings.warn(\n            'The type_name parameter is deprecated. parse_obj_as no longer creates temporary models',\n            DeprecationWarning,\n            stacklevel=2,\n        )\n    return TypeAdapter(type_).validate_python(obj)\n\n\n@deprecated(\n    '`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.',\n    category=None,\n)\ndef schema_of(\n    type_: Any,\n    *,\n    title: NameFactory | None = None,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n) -> dict[str, Any]:\n    \"\"\"Generate a JSON schema (as dict) for the passed model or dynamically generated one.\"\"\"\n    warnings.warn(\n        '`schema_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    res = TypeAdapter(type_).json_schema(\n        by_alias=by_alias,\n        schema_generator=schema_generator,\n        ref_template=ref_template,\n    )\n    if title is not None:\n        if isinstance(title, str):\n            res['title'] = title\n        else:\n            warnings.warn(\n                'Passing a callable for the `title` parameter is deprecated and no longer supported',\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            res['title'] = title(type_)\n    return res\n\n\n@deprecated(\n    '`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.',\n    category=None,\n)\ndef schema_json_of(\n    type_: Any,\n    *,\n    title: NameFactory | None = None,\n    by_alias: bool = True,\n    ref_template: str = DEFAULT_REF_TEMPLATE,\n    schema_generator: type[GenerateJsonSchema] = GenerateJsonSchema,\n    **dumps_kwargs: Any,\n) -> str:\n    \"\"\"Generate a JSON schema (as JSON) for the passed model or dynamically generated one.\"\"\"\n    warnings.warn(\n        '`schema_json_of` is deprecated. Use `pydantic.TypeAdapter.json_schema` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    return json.dumps(\n        schema_of(type_, title=title, by_alias=by_alias, ref_template=ref_template, schema_generator=schema_generator),\n        **dumps_kwargs,\n    )\n", "pydantic/deprecated/json.py": "import datetime\nimport warnings\nfrom collections import deque\nfrom decimal import Decimal\nfrom enum import Enum\nfrom ipaddress import IPv4Address, IPv4Interface, IPv4Network, IPv6Address, IPv6Interface, IPv6Network\nfrom pathlib import Path\nfrom re import Pattern\nfrom types import GeneratorType\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, Type, Union\nfrom uuid import UUID\n\nfrom typing_extensions import deprecated\n\nfrom ..color import Color\nfrom ..networks import NameEmail\nfrom ..types import SecretBytes, SecretStr\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = 'pydantic_encoder', 'custom_pydantic_encoder', 'timedelta_isoformat'\n\n\ndef isoformat(o: Union[datetime.date, datetime.time]) -> str:\n    return o.isoformat()\n\n\ndef decimal_encoder(dec_value: Decimal) -> Union[int, float]:\n    \"\"\"Encodes a Decimal as int of there's no exponent, otherwise float.\n\n    This is useful when we use ConstrainedDecimal to represent Numeric(x,0)\n    where a integer (but not int typed) is used. Encoding this as a float\n    results in failed round-tripping between encode and parse.\n    Our Id type is a prime example of this.\n\n    >>> decimal_encoder(Decimal(\"1.0\"))\n    1.0\n\n    >>> decimal_encoder(Decimal(\"1\"))\n    1\n    \"\"\"\n    exponent = dec_value.as_tuple().exponent\n    if isinstance(exponent, int) and exponent >= 0:\n        return int(dec_value)\n    else:\n        return float(dec_value)\n\n\nENCODERS_BY_TYPE: Dict[Type[Any], Callable[[Any], Any]] = {\n    bytes: lambda o: o.decode(),\n    Color: str,\n    datetime.date: isoformat,\n    datetime.datetime: isoformat,\n    datetime.time: isoformat,\n    datetime.timedelta: lambda td: td.total_seconds(),\n    Decimal: decimal_encoder,\n    Enum: lambda o: o.value,\n    frozenset: list,\n    deque: list,\n    GeneratorType: list,\n    IPv4Address: str,\n    IPv4Interface: str,\n    IPv4Network: str,\n    IPv6Address: str,\n    IPv6Interface: str,\n    IPv6Network: str,\n    NameEmail: str,\n    Path: str,\n    Pattern: lambda o: o.pattern,\n    SecretBytes: str,\n    SecretStr: str,\n    set: list,\n    UUID: str,\n}\n\n\n@deprecated(\n    '`pydantic_encoder` is deprecated, use `pydantic_core.to_jsonable_python` instead.',\n    category=None,\n)\ndef pydantic_encoder(obj: Any) -> Any:\n    warnings.warn(\n        '`pydantic_encoder` is deprecated, use `pydantic_core.to_jsonable_python` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    from dataclasses import asdict, is_dataclass\n\n    from ..main import BaseModel\n\n    if isinstance(obj, BaseModel):\n        return obj.model_dump()\n    elif is_dataclass(obj):\n        return asdict(obj)  # type: ignore\n\n    # Check the class type and its superclasses for a matching encoder\n    for base in obj.__class__.__mro__[:-1]:\n        try:\n            encoder = ENCODERS_BY_TYPE[base]\n        except KeyError:\n            continue\n        return encoder(obj)\n    else:  # We have exited the for loop without finding a suitable encoder\n        raise TypeError(f\"Object of type '{obj.__class__.__name__}' is not JSON serializable\")\n\n\n# TODO: Add a suggested migration path once there is a way to use custom encoders\n@deprecated(\n    '`custom_pydantic_encoder` is deprecated, use `BaseModel.model_dump` instead.',\n    category=None,\n)\ndef custom_pydantic_encoder(type_encoders: Dict[Any, Callable[[Type[Any]], Any]], obj: Any) -> Any:\n    warnings.warn(\n        '`custom_pydantic_encoder` is deprecated, use `BaseModel.model_dump` instead.',\n        category=PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n    # Check the class type and its superclasses for a matching encoder\n    for base in obj.__class__.__mro__[:-1]:\n        try:\n            encoder = type_encoders[base]\n        except KeyError:\n            continue\n\n        return encoder(obj)\n    else:  # We have exited the for loop without finding a suitable encoder\n        return pydantic_encoder(obj)\n\n\n@deprecated('`timedelta_isoformat` is deprecated.', category=None)\ndef timedelta_isoformat(td: datetime.timedelta) -> str:\n    \"\"\"ISO 8601 encoding for Python timedelta object.\"\"\"\n    warnings.warn('`timedelta_isoformat` is deprecated.', category=PydanticDeprecatedSince20, stacklevel=2)\n    minutes, seconds = divmod(td.seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    return f'{\"-\" if td.days < 0 else \"\"}P{abs(td.days)}DT{hours:d}H{minutes:d}M{seconds:d}.{td.microseconds:06d}S'\n", "pydantic/deprecated/class_validators.py": "\"\"\"Old `@validator` and `@root_validator` function validators from V1.\"\"\"\n\nfrom __future__ import annotations as _annotations\n\nfrom functools import partial, partialmethod\nfrom types import FunctionType\nfrom typing import TYPE_CHECKING, Any, Callable, TypeVar, Union, overload\nfrom warnings import warn\n\nfrom typing_extensions import Literal, Protocol, TypeAlias, deprecated\n\nfrom .._internal import _decorators, _decorators_v1\nfrom ..errors import PydanticUserError\nfrom ..warnings import PydanticDeprecatedSince20\n\n_ALLOW_REUSE_WARNING_MESSAGE = '`allow_reuse` is deprecated and will be ignored; it should no longer be necessary'\n\n\nif TYPE_CHECKING:\n\n    class _OnlyValueValidatorClsMethod(Protocol):\n        def __call__(self, __cls: Any, __value: Any) -> Any: ...\n\n    class _V1ValidatorWithValuesClsMethod(Protocol):\n        def __call__(self, __cls: Any, __value: Any, values: dict[str, Any]) -> Any: ...\n\n    class _V1ValidatorWithValuesKwOnlyClsMethod(Protocol):\n        def __call__(self, __cls: Any, __value: Any, *, values: dict[str, Any]) -> Any: ...\n\n    class _V1ValidatorWithKwargsClsMethod(Protocol):\n        def __call__(self, __cls: Any, **kwargs: Any) -> Any: ...\n\n    class _V1ValidatorWithValuesAndKwargsClsMethod(Protocol):\n        def __call__(self, __cls: Any, values: dict[str, Any], **kwargs: Any) -> Any: ...\n\n    class _V1RootValidatorClsMethod(Protocol):\n        def __call__(\n            self, __cls: Any, __values: _decorators_v1.RootValidatorValues\n        ) -> _decorators_v1.RootValidatorValues: ...\n\n    V1Validator = Union[\n        _OnlyValueValidatorClsMethod,\n        _V1ValidatorWithValuesClsMethod,\n        _V1ValidatorWithValuesKwOnlyClsMethod,\n        _V1ValidatorWithKwargsClsMethod,\n        _V1ValidatorWithValuesAndKwargsClsMethod,\n        _decorators_v1.V1ValidatorWithValues,\n        _decorators_v1.V1ValidatorWithValuesKwOnly,\n        _decorators_v1.V1ValidatorWithKwargs,\n        _decorators_v1.V1ValidatorWithValuesAndKwargs,\n    ]\n\n    V1RootValidator = Union[\n        _V1RootValidatorClsMethod,\n        _decorators_v1.V1RootValidatorFunction,\n    ]\n\n    _PartialClsOrStaticMethod: TypeAlias = Union[classmethod[Any, Any, Any], staticmethod[Any, Any], partialmethod[Any]]\n\n    # Allow both a V1 (assumed pre=False) or V2 (assumed mode='after') validator\n    # We lie to type checkers and say we return the same thing we get\n    # but in reality we return a proxy object that _mostly_ behaves like the wrapped thing\n    _V1ValidatorType = TypeVar('_V1ValidatorType', V1Validator, _PartialClsOrStaticMethod)\n    _V1RootValidatorFunctionType = TypeVar(\n        '_V1RootValidatorFunctionType',\n        _decorators_v1.V1RootValidatorFunction,\n        _V1RootValidatorClsMethod,\n        _PartialClsOrStaticMethod,\n    )\nelse:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n\n@deprecated(\n    'Pydantic V1 style `@validator` validators are deprecated.'\n    ' You should migrate to Pydantic V2 style `@field_validator` validators,'\n    ' see the migration guide for more details',\n    category=None,\n)\ndef validator(\n    __field: str,\n    *fields: str,\n    pre: bool = False,\n    each_item: bool = False,\n    always: bool = False,\n    check_fields: bool | None = None,\n    allow_reuse: bool = False,\n) -> Callable[[_V1ValidatorType], _V1ValidatorType]:\n    \"\"\"Decorate methods on the class indicating that they should be used to validate fields.\n\n    Args:\n        __field (str): The first field the validator should be called on; this is separate\n            from `fields` to ensure an error is raised if you don't pass at least one.\n        *fields (str): Additional field(s) the validator should be called on.\n        pre (bool, optional): Whether this validator should be called before the standard\n            validators (else after). Defaults to False.\n        each_item (bool, optional): For complex objects (sets, lists etc.) whether to validate\n            individual elements rather than the whole object. Defaults to False.\n        always (bool, optional): Whether this method and other validators should be called even if\n            the value is missing. Defaults to False.\n        check_fields (bool | None, optional): Whether to check that the fields actually exist on the model.\n            Defaults to None.\n        allow_reuse (bool, optional): Whether to track and raise an error if another validator refers to\n            the decorated function. Defaults to False.\n\n    Returns:\n        Callable: A decorator that can be used to decorate a\n            function to be used as a validator.\n    \"\"\"\n    warn(\n        'Pydantic V1 style `@validator` validators are deprecated.'\n        ' You should migrate to Pydantic V2 style `@field_validator` validators,'\n        ' see the migration guide for more details',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    if allow_reuse is True:  # pragma: no cover\n        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning)\n    fields = tuple((__field, *fields))\n    if isinstance(fields[0], FunctionType):\n        raise PydanticUserError(\n            '`@validator` should be used with fields and keyword arguments, not bare. '\n            \"E.g. usage should be `@validator('<field_name>', ...)`\",\n            code='validator-no-fields',\n        )\n    elif not all(isinstance(field, str) for field in fields):\n        raise PydanticUserError(\n            '`@validator` fields should be passed as separate string args. '\n            \"E.g. usage should be `@validator('<field_name_1>', '<field_name_2>', ...)`\",\n            code='validator-invalid-fields',\n        )\n\n    mode: Literal['before', 'after'] = 'before' if pre is True else 'after'\n\n    def dec(f: Any) -> _decorators.PydanticDescriptorProxy[Any]:\n        if _decorators.is_instance_method_from_sig(f):\n            raise PydanticUserError(\n                '`@validator` cannot be applied to instance methods', code='validator-instance-method'\n            )\n        # auto apply the @classmethod decorator\n        f = _decorators.ensure_classmethod_based_on_signature(f)\n        wrap = _decorators_v1.make_generic_v1_field_validator\n        validator_wrapper_info = _decorators.ValidatorDecoratorInfo(\n            fields=fields,\n            mode=mode,\n            each_item=each_item,\n            always=always,\n            check_fields=check_fields,\n        )\n        return _decorators.PydanticDescriptorProxy(f, validator_wrapper_info, shim=wrap)\n\n    return dec  # type: ignore[return-value]\n\n\n@overload\ndef root_validator(\n    *,\n    # if you don't specify `pre` the default is `pre=False`\n    # which means you need to specify `skip_on_failure=True`\n    skip_on_failure: Literal[True],\n    allow_reuse: bool = ...,\n) -> Callable[\n    [_V1RootValidatorFunctionType],\n    _V1RootValidatorFunctionType,\n]: ...\n\n\n@overload\ndef root_validator(\n    *,\n    # if you specify `pre=True` then you don't need to specify\n    # `skip_on_failure`, in fact it is not allowed as an argument!\n    pre: Literal[True],\n    allow_reuse: bool = ...,\n) -> Callable[\n    [_V1RootValidatorFunctionType],\n    _V1RootValidatorFunctionType,\n]: ...\n\n\n@overload\ndef root_validator(\n    *,\n    # if you explicitly specify `pre=False` then you\n    # MUST specify `skip_on_failure=True`\n    pre: Literal[False],\n    skip_on_failure: Literal[True],\n    allow_reuse: bool = ...,\n) -> Callable[\n    [_V1RootValidatorFunctionType],\n    _V1RootValidatorFunctionType,\n]: ...\n\n\n@deprecated(\n    'Pydantic V1 style `@root_validator` validators are deprecated.'\n    ' You should migrate to Pydantic V2 style `@model_validator` validators,'\n    ' see the migration guide for more details',\n    category=None,\n)\ndef root_validator(\n    *__args,\n    pre: bool = False,\n    skip_on_failure: bool = False,\n    allow_reuse: bool = False,\n) -> Any:\n    \"\"\"Decorate methods on a model indicating that they should be used to validate (and perhaps\n    modify) data either before or after standard model parsing/validation is performed.\n\n    Args:\n        pre (bool, optional): Whether this validator should be called before the standard\n            validators (else after). Defaults to False.\n        skip_on_failure (bool, optional): Whether to stop validation and return as soon as a\n            failure is encountered. Defaults to False.\n        allow_reuse (bool, optional): Whether to track and raise an error if another validator\n            refers to the decorated function. Defaults to False.\n\n    Returns:\n        Any: A decorator that can be used to decorate a function to be used as a root_validator.\n    \"\"\"\n    warn(\n        'Pydantic V1 style `@root_validator` validators are deprecated.'\n        ' You should migrate to Pydantic V2 style `@model_validator` validators,'\n        ' see the migration guide for more details',\n        DeprecationWarning,\n        stacklevel=2,\n    )\n\n    if __args:\n        # Ensure a nice error is raised if someone attempts to use the bare decorator\n        return root_validator()(*__args)  # type: ignore\n\n    if allow_reuse is True:  # pragma: no cover\n        warn(_ALLOW_REUSE_WARNING_MESSAGE, DeprecationWarning)\n    mode: Literal['before', 'after'] = 'before' if pre is True else 'after'\n    if pre is False and skip_on_failure is not True:\n        raise PydanticUserError(\n            'If you use `@root_validator` with pre=False (the default) you MUST specify `skip_on_failure=True`.'\n            ' Note that `@root_validator` is deprecated and should be replaced with `@model_validator`.',\n            code='root-validator-pre-skip',\n        )\n\n    wrap = partial(_decorators_v1.make_v1_generic_root_validator, pre=pre)\n\n    def dec(f: Callable[..., Any] | classmethod[Any, Any, Any] | staticmethod[Any, Any]) -> Any:\n        if _decorators.is_instance_method_from_sig(f):\n            raise TypeError('`@root_validator` cannot be applied to instance methods')\n        # auto apply the @classmethod decorator\n        res = _decorators.ensure_classmethod_based_on_signature(f)\n        dec_info = _decorators.RootValidatorDecoratorInfo(mode=mode)\n        return _decorators.PydanticDescriptorProxy(res, dec_info, shim=wrap)\n\n    return dec\n", "pydantic/deprecated/__init__.py": "", "pydantic/deprecated/decorator.py": "import warnings\nfrom functools import wraps\nfrom typing import TYPE_CHECKING, Any, Callable, Dict, List, Mapping, Optional, Tuple, Type, TypeVar, Union, overload\n\nfrom typing_extensions import deprecated\n\nfrom .._internal import _config, _typing_extra\nfrom ..alias_generators import to_pascal\nfrom ..errors import PydanticUserError\nfrom ..functional_validators import field_validator\nfrom ..main import BaseModel, create_model\nfrom ..warnings import PydanticDeprecatedSince20\n\nif not TYPE_CHECKING:\n    # See PyCharm issues https://youtrack.jetbrains.com/issue/PY-21915\n    # and https://youtrack.jetbrains.com/issue/PY-51428\n    DeprecationWarning = PydanticDeprecatedSince20\n\n__all__ = ('validate_arguments',)\n\nif TYPE_CHECKING:\n    AnyCallable = Callable[..., Any]\n\n    AnyCallableT = TypeVar('AnyCallableT', bound=AnyCallable)\n    ConfigType = Union[None, Type[Any], Dict[str, Any]]\n\n\n@overload\ndef validate_arguments(\n    func: None = None, *, config: 'ConfigType' = None\n) -> Callable[['AnyCallableT'], 'AnyCallableT']: ...\n\n\n@overload\ndef validate_arguments(func: 'AnyCallableT') -> 'AnyCallableT': ...\n\n\n@deprecated(\n    'The `validate_arguments` method is deprecated; use `validate_call` instead.',\n    category=None,\n)\ndef validate_arguments(func: Optional['AnyCallableT'] = None, *, config: 'ConfigType' = None) -> Any:\n    \"\"\"Decorator to validate the arguments passed to a function.\"\"\"\n    warnings.warn(\n        'The `validate_arguments` method is deprecated; use `validate_call` instead.',\n        PydanticDeprecatedSince20,\n        stacklevel=2,\n    )\n\n    def validate(_func: 'AnyCallable') -> 'AnyCallable':\n        vd = ValidatedFunction(_func, config)\n\n        @wraps(_func)\n        def wrapper_function(*args: Any, **kwargs: Any) -> Any:\n            return vd.call(*args, **kwargs)\n\n        wrapper_function.vd = vd  # type: ignore\n        wrapper_function.validate = vd.init_model_instance  # type: ignore\n        wrapper_function.raw_function = vd.raw_function  # type: ignore\n        wrapper_function.model = vd.model  # type: ignore\n        return wrapper_function\n\n    if func:\n        return validate(func)\n    else:\n        return validate\n\n\nALT_V_ARGS = 'v__args'\nALT_V_KWARGS = 'v__kwargs'\nV_POSITIONAL_ONLY_NAME = 'v__positional_only'\nV_DUPLICATE_KWARGS = 'v__duplicate_kwargs'\n\n\nclass ValidatedFunction:\n    def __init__(self, function: 'AnyCallable', config: 'ConfigType'):\n        from inspect import Parameter, signature\n\n        parameters: Mapping[str, Parameter] = signature(function).parameters\n\n        if parameters.keys() & {ALT_V_ARGS, ALT_V_KWARGS, V_POSITIONAL_ONLY_NAME, V_DUPLICATE_KWARGS}:\n            raise PydanticUserError(\n                f'\"{ALT_V_ARGS}\", \"{ALT_V_KWARGS}\", \"{V_POSITIONAL_ONLY_NAME}\" and \"{V_DUPLICATE_KWARGS}\" '\n                f'are not permitted as argument names when using the \"{validate_arguments.__name__}\" decorator',\n                code=None,\n            )\n\n        self.raw_function = function\n        self.arg_mapping: Dict[int, str] = {}\n        self.positional_only_args: set[str] = set()\n        self.v_args_name = 'args'\n        self.v_kwargs_name = 'kwargs'\n\n        type_hints = _typing_extra.get_type_hints(function, include_extras=True)\n        takes_args = False\n        takes_kwargs = False\n        fields: Dict[str, Tuple[Any, Any]] = {}\n        for i, (name, p) in enumerate(parameters.items()):\n            if p.annotation is p.empty:\n                annotation = Any\n            else:\n                annotation = type_hints[name]\n\n            default = ... if p.default is p.empty else p.default\n            if p.kind == Parameter.POSITIONAL_ONLY:\n                self.arg_mapping[i] = name\n                fields[name] = annotation, default\n                fields[V_POSITIONAL_ONLY_NAME] = List[str], None\n                self.positional_only_args.add(name)\n            elif p.kind == Parameter.POSITIONAL_OR_KEYWORD:\n                self.arg_mapping[i] = name\n                fields[name] = annotation, default\n                fields[V_DUPLICATE_KWARGS] = List[str], None\n            elif p.kind == Parameter.KEYWORD_ONLY:\n                fields[name] = annotation, default\n            elif p.kind == Parameter.VAR_POSITIONAL:\n                self.v_args_name = name\n                fields[name] = Tuple[annotation, ...], None\n                takes_args = True\n            else:\n                assert p.kind == Parameter.VAR_KEYWORD, p.kind\n                self.v_kwargs_name = name\n                fields[name] = Dict[str, annotation], None\n                takes_kwargs = True\n\n        # these checks avoid a clash between \"args\" and a field with that name\n        if not takes_args and self.v_args_name in fields:\n            self.v_args_name = ALT_V_ARGS\n\n        # same with \"kwargs\"\n        if not takes_kwargs and self.v_kwargs_name in fields:\n            self.v_kwargs_name = ALT_V_KWARGS\n\n        if not takes_args:\n            # we add the field so validation below can raise the correct exception\n            fields[self.v_args_name] = List[Any], None\n\n        if not takes_kwargs:\n            # same with kwargs\n            fields[self.v_kwargs_name] = Dict[Any, Any], None\n\n        self.create_model(fields, takes_args, takes_kwargs, config)\n\n    def init_model_instance(self, *args: Any, **kwargs: Any) -> BaseModel:\n        values = self.build_values(args, kwargs)\n        return self.model(**values)\n\n    def call(self, *args: Any, **kwargs: Any) -> Any:\n        m = self.init_model_instance(*args, **kwargs)\n        return self.execute(m)\n\n    def build_values(self, args: Tuple[Any, ...], kwargs: Dict[str, Any]) -> Dict[str, Any]:\n        values: Dict[str, Any] = {}\n        if args:\n            arg_iter = enumerate(args)\n            while True:\n                try:\n                    i, a = next(arg_iter)\n                except StopIteration:\n                    break\n                arg_name = self.arg_mapping.get(i)\n                if arg_name is not None:\n                    values[arg_name] = a\n                else:\n                    values[self.v_args_name] = [a] + [a for _, a in arg_iter]\n                    break\n\n        var_kwargs: Dict[str, Any] = {}\n        wrong_positional_args = []\n        duplicate_kwargs = []\n        fields_alias = [\n            field.alias\n            for name, field in self.model.model_fields.items()\n            if name not in (self.v_args_name, self.v_kwargs_name)\n        ]\n        non_var_fields = set(self.model.model_fields) - {self.v_args_name, self.v_kwargs_name}\n        for k, v in kwargs.items():\n            if k in non_var_fields or k in fields_alias:\n                if k in self.positional_only_args:\n                    wrong_positional_args.append(k)\n                if k in values:\n                    duplicate_kwargs.append(k)\n                values[k] = v\n            else:\n                var_kwargs[k] = v\n\n        if var_kwargs:\n            values[self.v_kwargs_name] = var_kwargs\n        if wrong_positional_args:\n            values[V_POSITIONAL_ONLY_NAME] = wrong_positional_args\n        if duplicate_kwargs:\n            values[V_DUPLICATE_KWARGS] = duplicate_kwargs\n        return values\n\n    def execute(self, m: BaseModel) -> Any:\n        d = {k: v for k, v in m.__dict__.items() if k in m.__pydantic_fields_set__ or m.model_fields[k].default_factory}\n        var_kwargs = d.pop(self.v_kwargs_name, {})\n\n        if self.v_args_name in d:\n            args_: List[Any] = []\n            in_kwargs = False\n            kwargs = {}\n            for name, value in d.items():\n                if in_kwargs:\n                    kwargs[name] = value\n                elif name == self.v_args_name:\n                    args_ += value\n                    in_kwargs = True\n                else:\n                    args_.append(value)\n            return self.raw_function(*args_, **kwargs, **var_kwargs)\n        elif self.positional_only_args:\n            args_ = []\n            kwargs = {}\n            for name, value in d.items():\n                if name in self.positional_only_args:\n                    args_.append(value)\n                else:\n                    kwargs[name] = value\n            return self.raw_function(*args_, **kwargs, **var_kwargs)\n        else:\n            return self.raw_function(**d, **var_kwargs)\n\n    def create_model(self, fields: Dict[str, Any], takes_args: bool, takes_kwargs: bool, config: 'ConfigType') -> None:\n        pos_args = len(self.arg_mapping)\n\n        config_wrapper = _config.ConfigWrapper(config)\n\n        if config_wrapper.alias_generator:\n            raise PydanticUserError(\n                'Setting the \"alias_generator\" property on custom Config for '\n                '@validate_arguments is not yet supported, please remove.',\n                code=None,\n            )\n        if config_wrapper.extra is None:\n            config_wrapper.config_dict['extra'] = 'forbid'\n\n        class DecoratorBaseModel(BaseModel):\n            @field_validator(self.v_args_name, check_fields=False)\n            @classmethod\n            def check_args(cls, v: Optional[List[Any]]) -> Optional[List[Any]]:\n                if takes_args or v is None:\n                    return v\n\n                raise TypeError(f'{pos_args} positional arguments expected but {pos_args + len(v)} given')\n\n            @field_validator(self.v_kwargs_name, check_fields=False)\n            @classmethod\n            def check_kwargs(cls, v: Optional[Dict[str, Any]]) -> Optional[Dict[str, Any]]:\n                if takes_kwargs or v is None:\n                    return v\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v.keys()))\n                raise TypeError(f'unexpected keyword argument{plural}: {keys}')\n\n            @field_validator(V_POSITIONAL_ONLY_NAME, check_fields=False)\n            @classmethod\n            def check_positional_only(cls, v: Optional[List[str]]) -> None:\n                if v is None:\n                    return\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v))\n                raise TypeError(f'positional-only argument{plural} passed as keyword argument{plural}: {keys}')\n\n            @field_validator(V_DUPLICATE_KWARGS, check_fields=False)\n            @classmethod\n            def check_duplicate_kwargs(cls, v: Optional[List[str]]) -> None:\n                if v is None:\n                    return\n\n                plural = '' if len(v) == 1 else 's'\n                keys = ', '.join(map(repr, v))\n                raise TypeError(f'multiple values for argument{plural}: {keys}')\n\n            model_config = config_wrapper.config_dict\n\n        self.model = create_model(to_pascal(self.raw_function.__name__), __base__=DecoratorBaseModel, **fields)\n", "pydantic/deprecated/copy_internals.py": "from __future__ import annotations as _annotations\n\nimport typing\nfrom copy import deepcopy\nfrom enum import Enum\nfrom typing import Any, Tuple\n\nimport typing_extensions\n\nfrom .._internal import (\n    _model_construction,\n    _typing_extra,\n    _utils,\n)\n\nif typing.TYPE_CHECKING:\n    from .. import BaseModel\n    from .._internal._utils import AbstractSetIntStr, MappingIntStrAny\n\n    AnyClassMethod = classmethod[Any, Any, Any]\n    TupleGenerator = typing.Generator[Tuple[str, Any], None, None]\n    Model = typing.TypeVar('Model', bound='BaseModel')\n    # should be `set[int] | set[str] | dict[int, IncEx] | dict[str, IncEx] | None`, but mypy can't cope\n    IncEx: typing_extensions.TypeAlias = 'set[int] | set[str] | dict[int, Any] | dict[str, Any] | None'\n\n_object_setattr = _model_construction.object_setattr\n\n\ndef _iter(\n    self: BaseModel,\n    to_dict: bool = False,\n    by_alias: bool = False,\n    include: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None = None,\n    exclude_unset: bool = False,\n    exclude_defaults: bool = False,\n    exclude_none: bool = False,\n) -> TupleGenerator:\n    # Merge field set excludes with explicit exclude parameter with explicit overriding field set options.\n    # The extra \"is not None\" guards are not logically necessary but optimizes performance for the simple case.\n    if exclude is not None:\n        exclude = _utils.ValueItems.merge(\n            {k: v.exclude for k, v in self.model_fields.items() if v.exclude is not None}, exclude\n        )\n\n    if include is not None:\n        include = _utils.ValueItems.merge({k: True for k in self.model_fields}, include, intersect=True)\n\n    allowed_keys = _calculate_keys(self, include=include, exclude=exclude, exclude_unset=exclude_unset)  # type: ignore\n    if allowed_keys is None and not (to_dict or by_alias or exclude_unset or exclude_defaults or exclude_none):\n        # huge boost for plain _iter()\n        yield from self.__dict__.items()\n        if self.__pydantic_extra__:\n            yield from self.__pydantic_extra__.items()\n        return\n\n    value_exclude = _utils.ValueItems(self, exclude) if exclude is not None else None\n    value_include = _utils.ValueItems(self, include) if include is not None else None\n\n    if self.__pydantic_extra__ is None:\n        items = self.__dict__.items()\n    else:\n        items = list(self.__dict__.items()) + list(self.__pydantic_extra__.items())\n\n    for field_key, v in items:\n        if (allowed_keys is not None and field_key not in allowed_keys) or (exclude_none and v is None):\n            continue\n\n        if exclude_defaults:\n            try:\n                field = self.model_fields[field_key]\n            except KeyError:\n                pass\n            else:\n                if not field.is_required() and field.default == v:\n                    continue\n\n        if by_alias and field_key in self.model_fields:\n            dict_key = self.model_fields[field_key].alias or field_key\n        else:\n            dict_key = field_key\n\n        if to_dict or value_include or value_exclude:\n            v = _get_value(\n                type(self),\n                v,\n                to_dict=to_dict,\n                by_alias=by_alias,\n                include=value_include and value_include.for_element(field_key),\n                exclude=value_exclude and value_exclude.for_element(field_key),\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                exclude_none=exclude_none,\n            )\n        yield dict_key, v\n\n\ndef _copy_and_set_values(\n    self: Model,\n    values: dict[str, Any],\n    fields_set: set[str],\n    extra: dict[str, Any] | None = None,\n    private: dict[str, Any] | None = None,\n    *,\n    deep: bool,  # UP006\n) -> Model:\n    if deep:\n        # chances of having empty dict here are quite low for using smart_deepcopy\n        values = deepcopy(values)\n        extra = deepcopy(extra)\n        private = deepcopy(private)\n\n    cls = self.__class__\n    m = cls.__new__(cls)\n    _object_setattr(m, '__dict__', values)\n    _object_setattr(m, '__pydantic_extra__', extra)\n    _object_setattr(m, '__pydantic_fields_set__', fields_set)\n    _object_setattr(m, '__pydantic_private__', private)\n\n    return m\n\n\n@typing.no_type_check\ndef _get_value(\n    cls: type[BaseModel],\n    v: Any,\n    to_dict: bool,\n    by_alias: bool,\n    include: AbstractSetIntStr | MappingIntStrAny | None,\n    exclude: AbstractSetIntStr | MappingIntStrAny | None,\n    exclude_unset: bool,\n    exclude_defaults: bool,\n    exclude_none: bool,\n) -> Any:\n    from .. import BaseModel\n\n    if isinstance(v, BaseModel):\n        if to_dict:\n            return v.model_dump(\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                include=include,  # type: ignore\n                exclude=exclude,  # type: ignore\n                exclude_none=exclude_none,\n            )\n        else:\n            return v.copy(include=include, exclude=exclude)\n\n    value_exclude = _utils.ValueItems(v, exclude) if exclude else None\n    value_include = _utils.ValueItems(v, include) if include else None\n\n    if isinstance(v, dict):\n        return {\n            k_: _get_value(\n                cls,\n                v_,\n                to_dict=to_dict,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                include=value_include and value_include.for_element(k_),\n                exclude=value_exclude and value_exclude.for_element(k_),\n                exclude_none=exclude_none,\n            )\n            for k_, v_ in v.items()\n            if (not value_exclude or not value_exclude.is_excluded(k_))\n            and (not value_include or value_include.is_included(k_))\n        }\n\n    elif _utils.sequence_like(v):\n        seq_args = (\n            _get_value(\n                cls,\n                v_,\n                to_dict=to_dict,\n                by_alias=by_alias,\n                exclude_unset=exclude_unset,\n                exclude_defaults=exclude_defaults,\n                include=value_include and value_include.for_element(i),\n                exclude=value_exclude and value_exclude.for_element(i),\n                exclude_none=exclude_none,\n            )\n            for i, v_ in enumerate(v)\n            if (not value_exclude or not value_exclude.is_excluded(i))\n            and (not value_include or value_include.is_included(i))\n        )\n\n        return v.__class__(*seq_args) if _typing_extra.is_namedtuple(v.__class__) else v.__class__(seq_args)\n\n    elif isinstance(v, Enum) and getattr(cls.model_config, 'use_enum_values', False):\n        return v.value\n\n    else:\n        return v\n\n\ndef _calculate_keys(\n    self: BaseModel,\n    include: MappingIntStrAny | None,\n    exclude: MappingIntStrAny | None,\n    exclude_unset: bool,\n    update: typing.Dict[str, Any] | None = None,  # noqa UP006\n) -> typing.AbstractSet[str] | None:\n    if include is None and exclude is None and exclude_unset is False:\n        return None\n\n    keys: typing.AbstractSet[str]\n    if exclude_unset:\n        keys = self.__pydantic_fields_set__.copy()\n    else:\n        keys = set(self.__dict__.keys())\n        keys = keys | (self.__pydantic_extra__ or {}).keys()\n\n    if include is not None:\n        keys &= include.keys()\n\n    if update:\n        keys -= update.keys()\n\n    if exclude:\n        keys -= {k for k, v in exclude.items() if _utils.ValueItems.is_true(v)}\n\n    return keys\n", "pydantic/plugin/_loader.py": "from __future__ import annotations\n\nimport importlib.metadata as importlib_metadata\nimport os\nimport warnings\nfrom typing import TYPE_CHECKING, Final, Iterable\n\nif TYPE_CHECKING:\n    from . import PydanticPluginProtocol\n\n\nPYDANTIC_ENTRY_POINT_GROUP: Final[str] = 'pydantic'\n\n# cache of plugins\n_plugins: dict[str, PydanticPluginProtocol] | None = None\n# return no plugins while loading plugins to avoid recursion and errors while import plugins\n# this means that if plugins use pydantic\n_loading_plugins: bool = False\n\n\ndef get_plugins() -> Iterable[PydanticPluginProtocol]:\n    \"\"\"Load plugins for Pydantic.\n\n    Inspired by: https://github.com/pytest-dev/pluggy/blob/1.3.0/src/pluggy/_manager.py#L376-L402\n    \"\"\"\n    disabled_plugins = os.getenv('PYDANTIC_DISABLE_PLUGINS')\n    global _plugins, _loading_plugins\n    if _loading_plugins:\n        # this happens when plugins themselves use pydantic, we return no plugins\n        return ()\n    elif disabled_plugins in ('__all__', '1', 'true'):\n        return ()\n    elif _plugins is None:\n        _plugins = {}\n        # set _loading_plugins so any plugins that use pydantic don't themselves use plugins\n        _loading_plugins = True\n        try:\n            for dist in importlib_metadata.distributions():\n                for entry_point in dist.entry_points:\n                    if entry_point.group != PYDANTIC_ENTRY_POINT_GROUP:\n                        continue\n                    if entry_point.value in _plugins:\n                        continue\n                    if disabled_plugins is not None and entry_point.name in disabled_plugins.split(','):\n                        continue\n                    try:\n                        _plugins[entry_point.value] = entry_point.load()\n                    except (ImportError, AttributeError) as e:\n                        warnings.warn(\n                            f'{e.__class__.__name__} while loading the `{entry_point.name}` Pydantic plugin, '\n                            f'this plugin will not be installed.\\n\\n{e!r}'\n                        )\n        finally:\n            _loading_plugins = False\n\n    return _plugins.values()\n", "pydantic/plugin/_schema_validator.py": "\"\"\"Pluggable schema validator for pydantic.\"\"\"\n\nfrom __future__ import annotations\n\nimport functools\nfrom typing import TYPE_CHECKING, Any, Callable, Iterable, TypeVar\n\nfrom pydantic_core import CoreConfig, CoreSchema, SchemaValidator, ValidationError\nfrom typing_extensions import Literal, ParamSpec\n\nif TYPE_CHECKING:\n    from . import BaseValidateHandlerProtocol, PydanticPluginProtocol, SchemaKind, SchemaTypePath\n\n\nP = ParamSpec('P')\nR = TypeVar('R')\nEvent = Literal['on_validate_python', 'on_validate_json', 'on_validate_strings']\nevents: list[Event] = list(Event.__args__)  # type: ignore\n\n\ndef create_schema_validator(\n    schema: CoreSchema,\n    schema_type: Any,\n    schema_type_module: str,\n    schema_type_name: str,\n    schema_kind: SchemaKind,\n    config: CoreConfig | None = None,\n    plugin_settings: dict[str, Any] | None = None,\n) -> SchemaValidator:\n    \"\"\"Create a `SchemaValidator` or `PluggableSchemaValidator` if plugins are installed.\n\n    Returns:\n        If plugins are installed then return `PluggableSchemaValidator`, otherwise return `SchemaValidator`.\n    \"\"\"\n    from . import SchemaTypePath\n    from ._loader import get_plugins\n\n    plugins = get_plugins()\n    if plugins:\n        return PluggableSchemaValidator(\n            schema,\n            schema_type,\n            SchemaTypePath(schema_type_module, schema_type_name),\n            schema_kind,\n            config,\n            plugins,\n            plugin_settings or {},\n        )  # type: ignore\n    else:\n        return SchemaValidator(schema, config)\n\n\nclass PluggableSchemaValidator:\n    \"\"\"Pluggable schema validator.\"\"\"\n\n    __slots__ = '_schema_validator', 'validate_json', 'validate_python', 'validate_strings'\n\n    def __init__(\n        self,\n        schema: CoreSchema,\n        schema_type: Any,\n        schema_type_path: SchemaTypePath,\n        schema_kind: SchemaKind,\n        config: CoreConfig | None,\n        plugins: Iterable[PydanticPluginProtocol],\n        plugin_settings: dict[str, Any],\n    ) -> None:\n        self._schema_validator = SchemaValidator(schema, config)\n\n        python_event_handlers: list[BaseValidateHandlerProtocol] = []\n        json_event_handlers: list[BaseValidateHandlerProtocol] = []\n        strings_event_handlers: list[BaseValidateHandlerProtocol] = []\n        for plugin in plugins:\n            try:\n                p, j, s = plugin.new_schema_validator(\n                    schema, schema_type, schema_type_path, schema_kind, config, plugin_settings\n                )\n            except TypeError as e:  # pragma: no cover\n                raise TypeError(f'Error using plugin `{plugin.__module__}:{plugin.__class__.__name__}`: {e}') from e\n            if p is not None:\n                python_event_handlers.append(p)\n            if j is not None:\n                json_event_handlers.append(j)\n            if s is not None:\n                strings_event_handlers.append(s)\n\n        self.validate_python = build_wrapper(self._schema_validator.validate_python, python_event_handlers)\n        self.validate_json = build_wrapper(self._schema_validator.validate_json, json_event_handlers)\n        self.validate_strings = build_wrapper(self._schema_validator.validate_strings, strings_event_handlers)\n\n    def __getattr__(self, name: str) -> Any:\n        return getattr(self._schema_validator, name)\n\n\ndef build_wrapper(func: Callable[P, R], event_handlers: list[BaseValidateHandlerProtocol]) -> Callable[P, R]:\n    if not event_handlers:\n        return func\n    else:\n        on_enters = tuple(h.on_enter for h in event_handlers if filter_handlers(h, 'on_enter'))\n        on_successes = tuple(h.on_success for h in event_handlers if filter_handlers(h, 'on_success'))\n        on_errors = tuple(h.on_error for h in event_handlers if filter_handlers(h, 'on_error'))\n        on_exceptions = tuple(h.on_exception for h in event_handlers if filter_handlers(h, 'on_exception'))\n\n        @functools.wraps(func)\n        def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:\n            for on_enter_handler in on_enters:\n                on_enter_handler(*args, **kwargs)\n\n            try:\n                result = func(*args, **kwargs)\n            except ValidationError as error:\n                for on_error_handler in on_errors:\n                    on_error_handler(error)\n                raise\n            except Exception as exception:\n                for on_exception_handler in on_exceptions:\n                    on_exception_handler(exception)\n                raise\n            else:\n                for on_success_handler in on_successes:\n                    on_success_handler(result)\n                return result\n\n        return wrapper\n\n\ndef filter_handlers(handler_cls: BaseValidateHandlerProtocol, method_name: str) -> bool:\n    \"\"\"Filter out handler methods which are not implemented by the plugin directly - e.g. are missing\n    or are inherited from the protocol.\n    \"\"\"\n    handler = getattr(handler_cls, method_name, None)\n    if handler is None:\n        return False\n    elif handler.__module__ == 'pydantic.plugin':\n        # this is the original handler, from the protocol due to runtime inheritance\n        # we don't want to call it\n        return False\n    else:\n        return True\n", "pydantic/plugin/__init__.py": "\"\"\"Usage docs: https://docs.pydantic.dev/2.8/concepts/plugins#build-a-plugin\n\nPlugin interface for Pydantic plugins, and related types.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import Any, Callable, NamedTuple\n\nfrom pydantic_core import CoreConfig, CoreSchema, ValidationError\nfrom typing_extensions import Literal, Protocol, TypeAlias\n\n__all__ = (\n    'PydanticPluginProtocol',\n    'BaseValidateHandlerProtocol',\n    'ValidatePythonHandlerProtocol',\n    'ValidateJsonHandlerProtocol',\n    'ValidateStringsHandlerProtocol',\n    'NewSchemaReturns',\n    'SchemaTypePath',\n    'SchemaKind',\n)\n\nNewSchemaReturns: TypeAlias = 'tuple[ValidatePythonHandlerProtocol | None, ValidateJsonHandlerProtocol | None, ValidateStringsHandlerProtocol | None]'\n\n\nclass SchemaTypePath(NamedTuple):\n    \"\"\"Path defining where `schema_type` was defined, or where `TypeAdapter` was called.\"\"\"\n\n    module: str\n    name: str\n\n\nSchemaKind: TypeAlias = Literal['BaseModel', 'TypeAdapter', 'dataclass', 'create_model', 'validate_call']\n\n\nclass PydanticPluginProtocol(Protocol):\n    \"\"\"Protocol defining the interface for Pydantic plugins.\"\"\"\n\n    def new_schema_validator(\n        self,\n        schema: CoreSchema,\n        schema_type: Any,\n        schema_type_path: SchemaTypePath,\n        schema_kind: SchemaKind,\n        config: CoreConfig | None,\n        plugin_settings: dict[str, object],\n    ) -> tuple[\n        ValidatePythonHandlerProtocol | None, ValidateJsonHandlerProtocol | None, ValidateStringsHandlerProtocol | None\n    ]:\n        \"\"\"This method is called for each plugin every time a new [`SchemaValidator`][pydantic_core.SchemaValidator]\n        is created.\n\n        It should return an event handler for each of the three validation methods, or `None` if the plugin does not\n        implement that method.\n\n        Args:\n            schema: The schema to validate against.\n            schema_type: The original type which the schema was created from, e.g. the model class.\n            schema_type_path: Path defining where `schema_type` was defined, or where `TypeAdapter` was called.\n            schema_kind: The kind of schema to validate against.\n            config: The config to use for validation.\n            plugin_settings: Any plugin settings.\n\n        Returns:\n            A tuple of optional event handlers for each of the three validation methods -\n                `validate_python`, `validate_json`, `validate_strings`.\n        \"\"\"\n        raise NotImplementedError('Pydantic plugins should implement `new_schema_validator`.')\n\n\nclass BaseValidateHandlerProtocol(Protocol):\n    \"\"\"Base class for plugin callbacks protocols.\n\n    You shouldn't implement this protocol directly, instead use one of the subclasses with adds the correctly\n    typed `on_error` method.\n    \"\"\"\n\n    on_enter: Callable[..., None]\n    \"\"\"`on_enter` is changed to be more specific on all subclasses\"\"\"\n\n    def on_success(self, result: Any) -> None:\n        \"\"\"Callback to be notified of successful validation.\n\n        Args:\n            result: The result of the validation.\n        \"\"\"\n        return\n\n    def on_error(self, error: ValidationError) -> None:\n        \"\"\"Callback to be notified of validation errors.\n\n        Args:\n            error: The validation error.\n        \"\"\"\n        return\n\n    def on_exception(self, exception: Exception) -> None:\n        \"\"\"Callback to be notified of validation exceptions.\n\n        Args:\n            exception: The exception raised during validation.\n        \"\"\"\n        return\n\n\nclass ValidatePythonHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_python`.\"\"\"\n\n    def on_enter(\n        self,\n        input: Any,\n        *,\n        strict: bool | None = None,\n        from_attributes: bool | None = None,\n        context: dict[str, Any] | None = None,\n        self_instance: Any | None = None,\n    ) -> None:\n        \"\"\"Callback to be notified of validation start, and create an instance of the event handler.\n\n        Args:\n            input: The input to be validated.\n            strict: Whether to validate the object in strict mode.\n            from_attributes: Whether to validate objects as inputs by extracting attributes.\n            context: The context to use for validation, this is passed to functional validators.\n            self_instance: An instance of a model to set attributes on from validation, this is used when running\n                validation from the `__init__` method of a model.\n        \"\"\"\n        pass\n\n\nclass ValidateJsonHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_json`.\"\"\"\n\n    def on_enter(\n        self,\n        input: str | bytes | bytearray,\n        *,\n        strict: bool | None = None,\n        context: dict[str, Any] | None = None,\n        self_instance: Any | None = None,\n    ) -> None:\n        \"\"\"Callback to be notified of validation start, and create an instance of the event handler.\n\n        Args:\n            input: The JSON data to be validated.\n            strict: Whether to validate the object in strict mode.\n            context: The context to use for validation, this is passed to functional validators.\n            self_instance: An instance of a model to set attributes on from validation, this is used when running\n                validation from the `__init__` method of a model.\n        \"\"\"\n        pass\n\n\nStringInput: TypeAlias = 'dict[str, StringInput]'\n\n\nclass ValidateStringsHandlerProtocol(BaseValidateHandlerProtocol, Protocol):\n    \"\"\"Event handler for `SchemaValidator.validate_strings`.\"\"\"\n\n    def on_enter(\n        self, input: StringInput, *, strict: bool | None = None, context: dict[str, Any] | None = None\n    ) -> None:\n        \"\"\"Callback to be notified of validation start, and create an instance of the event handler.\n\n        Args:\n            input: The string data to be validated.\n            strict: Whether to validate the object in strict mode.\n            context: The context to use for validation, this is passed to functional validators.\n        \"\"\"\n        pass\n", ".github/actions/people/people.py": "\"\"\"Use the github API to get lists of people who have contributed in various ways to Pydantic.\n\nThis logic is inspired by that of @tiangolo's\n[FastAPI people script](https://github.com/tiangolo/fastapi/blob/master/.github/actions/people/app/main.py).\n\"\"\"\nimport requests\nimport logging\nimport subprocess\nimport sys\nfrom collections import Counter\nfrom datetime import datetime, timedelta, timezone\nfrom pathlib import Path\nfrom typing import Any, Container, Dict, List, Set, Union\n\nimport yaml\nfrom github import Github\nfrom pydantic import BaseModel, SecretStr\nfrom pydantic_settings import BaseSettings\n\ngithub_graphql_url = \"https://api.github.com/graphql\"\n\ndiscussions_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"pydantic\", owner: \"samuelcolvin\") {\n    discussions(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n              isAnswer\n              replies(first: 10) {\n                nodes {\n                  createdAt\n                  author {\n                    login\n                    avatarUrl\n                    url\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nissues_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"pydantic\", owner: \"samuelcolvin\") {\n    issues(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\nprs_query = \"\"\"\nquery Q($after: String) {\n  repository(name: \"pydantic\", owner: \"samuelcolvin\") {\n    pullRequests(first: 100, after: $after) {\n      edges {\n        cursor\n        node {\n          number\n          labels(first: 100) {\n            nodes {\n              name\n            }\n          }\n          author {\n            login\n            avatarUrl\n            url\n          }\n          title\n          createdAt\n          state\n          comments(first: 100) {\n            nodes {\n              createdAt\n              author {\n                login\n                avatarUrl\n                url\n              }\n            }\n          }\n          reviews(first:100) {\n            nodes {\n              author {\n                login\n                avatarUrl\n                url\n              }\n              state\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\"\"\"\n\n\nclass Author(BaseModel):\n    login: str\n    avatarUrl: str\n    url: str\n\n\n# Issues and Discussions\n\n\nclass CommentsNode(BaseModel):\n    createdAt: datetime\n    author: Union[Author, None] = None\n\n\nclass Replies(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass DiscussionsCommentsNode(CommentsNode):\n    replies: Replies\n\n\nclass Comments(BaseModel):\n    nodes: List[CommentsNode]\n\n\nclass DiscussionsComments(BaseModel):\n    nodes: List[DiscussionsCommentsNode]\n\n\nclass IssuesNode(BaseModel):\n    number: int\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n\n\nclass DiscussionsNode(BaseModel):\n    number: int\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    comments: DiscussionsComments\n\n\nclass IssuesEdge(BaseModel):\n    cursor: str\n    node: IssuesNode\n\n\nclass DiscussionsEdge(BaseModel):\n    cursor: str\n    node: DiscussionsNode\n\n\nclass Issues(BaseModel):\n    edges: List[IssuesEdge]\n\n\nclass Discussions(BaseModel):\n    edges: List[DiscussionsEdge]\n\n\nclass IssuesRepository(BaseModel):\n    issues: Issues\n\n\nclass DiscussionsRepository(BaseModel):\n    discussions: Discussions\n\n\nclass IssuesResponseData(BaseModel):\n    repository: IssuesRepository\n\n\nclass DiscussionsResponseData(BaseModel):\n    repository: DiscussionsRepository\n\n\nclass IssuesResponse(BaseModel):\n    data: IssuesResponseData\n\n\nclass DiscussionsResponse(BaseModel):\n    data: DiscussionsResponseData\n\n\n# PRs\n\n\nclass LabelNode(BaseModel):\n    name: str\n\n\nclass Labels(BaseModel):\n    nodes: List[LabelNode]\n\n\nclass ReviewNode(BaseModel):\n    author: Union[Author, None] = None\n    state: str\n\n\nclass Reviews(BaseModel):\n    nodes: List[ReviewNode]\n\n\nclass PullRequestNode(BaseModel):\n    number: int\n    labels: Labels\n    author: Union[Author, None] = None\n    title: str\n    createdAt: datetime\n    state: str\n    comments: Comments\n    reviews: Reviews\n\n\nclass PullRequestEdge(BaseModel):\n    cursor: str\n    node: PullRequestNode\n\n\nclass PullRequests(BaseModel):\n    edges: List[PullRequestEdge]\n\n\nclass PRsRepository(BaseModel):\n    pullRequests: PullRequests\n\n\nclass PRsResponseData(BaseModel):\n    repository: PRsRepository\n\n\nclass PRsResponse(BaseModel):\n    data: PRsResponseData\n\n\nclass Settings(BaseSettings):\n    input_token: SecretStr\n    github_repository: str = \"pydantic/pydantic\"\n    request_timeout: int = 30\n\n\ndef get_graphql_response(\n    *,\n    settings: Settings,\n    query: str,\n    after: Union[str, None] = None,\n) -> Dict[str, Any]:\n    headers = {\"Authorization\": f\"token {settings.input_token.get_secret_value()}\"}\n    variables = {\"after\": after}\n    response = requests.post(\n        github_graphql_url,\n        headers=headers,\n        timeout=settings.request_timeout,\n        json={\"query\": query, \"variables\": variables, \"operationName\": \"Q\"},\n    )\n    if response.status_code != 200:\n        logging.error(\n            f\"Response was not 200, after: {after}\"\n        )\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    data = response.json()\n    if \"errors\" in data:\n        logging.error(f\"Errors in response, after: {after}\")\n        logging.error(data[\"errors\"])\n        logging.error(response.text)\n        raise RuntimeError(response.text)\n    return data\n\n\ndef get_graphql_issue_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=issues_query, after=after)\n    graphql_response = IssuesResponse.model_validate(data)\n    return graphql_response.data.repository.issues.edges\n\n\ndef get_graphql_question_discussion_edges(\n    *,\n    settings: Settings,\n    after: Union[str, None] = None,\n):\n    data = get_graphql_response(\n        settings=settings,\n        query=discussions_query,\n        after=after,\n    )\n    graphql_response = DiscussionsResponse.model_validate(data)\n    return graphql_response.data.repository.discussions.edges\n\n\ndef get_graphql_pr_edges(*, settings: Settings, after: Union[str, None] = None):\n    data = get_graphql_response(settings=settings, query=prs_query, after=after)\n    graphql_response = PRsResponse.model_validate(data)\n    return graphql_response.data.repository.pullRequests.edges\n\n\ndef get_issues_experts(settings: Settings):\n    issue_nodes: List[IssuesNode] = []\n    issue_edges = get_graphql_issue_edges(settings=settings)\n\n    while issue_edges:\n        for edge in issue_edges:\n            issue_nodes.append(edge.node)\n        last_edge = issue_edges[-1]\n        issue_edges = get_graphql_issue_edges(settings=settings, after=last_edge.cursor)\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for issue in issue_nodes:\n        issue_author_name = None\n        if issue.author:\n            authors[issue.author.login] = issue.author\n            issue_author_name = issue.author.login\n        issue_commentors = set()\n        for comment in issue.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login != issue_author_name:\n                    issue_commentors.add(comment.author.login)\n        for author_name in issue_commentors:\n            commentors[author_name] += 1\n            if issue.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n\n    return commentors, last_month_commentors, authors\n\n\ndef get_discussions_experts(settings: Settings):\n    discussion_nodes: List[DiscussionsNode] = []\n    discussion_edges = get_graphql_question_discussion_edges(settings=settings)\n\n    while discussion_edges:\n        for discussion_edge in discussion_edges:\n            discussion_nodes.append(discussion_edge.node)\n        last_edge = discussion_edges[-1]\n        discussion_edges = get_graphql_question_discussion_edges(\n            settings=settings, after=last_edge.cursor\n        )\n\n    commentors = Counter()\n    last_month_commentors = Counter()\n    authors: Dict[str, Author] = {}\n\n    now = datetime.now(tz=timezone.utc)\n    one_month_ago = now - timedelta(days=30)\n\n    for discussion in discussion_nodes:\n        discussion_author_name = None\n        if discussion.author:\n            authors[discussion.author.login] = discussion.author\n            discussion_author_name = discussion.author.login\n        discussion_commentors = set()\n        for comment in discussion.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login != discussion_author_name:\n                    discussion_commentors.add(comment.author.login)\n            for reply in comment.replies.nodes:\n                if reply.author:\n                    authors[reply.author.login] = reply.author\n                    if reply.author.login != discussion_author_name:\n                        discussion_commentors.add(reply.author.login)\n        for author_name in discussion_commentors:\n            commentors[author_name] += 1\n            if discussion.createdAt > one_month_ago:\n                last_month_commentors[author_name] += 1\n    return commentors, last_month_commentors, authors\n\n\ndef get_experts(settings: Settings):\n    # Migrated to only use GitHub Discussions\n    # (\n    #     issues_commentors,\n    #     issues_last_month_commentors,\n    #     issues_authors,\n    # ) = get_issues_experts(settings=settings)\n    (\n        discussions_commentors,\n        discussions_last_month_commentors,\n        discussions_authors,\n    ) = get_discussions_experts(settings=settings)\n    # commentors = issues_commentors + discussions_commentors\n    commentors = discussions_commentors\n    # last_month_commentors = (\n    #     issues_last_month_commentors + discussions_last_month_commentors\n    # )\n    last_month_commentors = discussions_last_month_commentors\n    # authors = {**issues_authors, **discussions_authors}\n    authors = {**discussions_authors}\n    return commentors, last_month_commentors, authors\n\n\ndef get_contributors(settings: Settings):\n    pr_nodes: List[PullRequestNode] = []\n    pr_edges = get_graphql_pr_edges(settings=settings)\n\n    while pr_edges:\n        for edge in pr_edges:\n            pr_nodes.append(edge.node)\n        last_edge = pr_edges[-1]\n        pr_edges = get_graphql_pr_edges(settings=settings, after=last_edge.cursor)\n\n    contributors = Counter()\n    commentors = Counter()\n    reviewers = Counter()\n    authors: Dict[str, Author] = {}\n\n    for pr in pr_nodes:\n        author_name = None\n        if pr.author:\n            authors[pr.author.login] = pr.author\n            author_name = pr.author.login\n        pr_commentors: Set[str] = set()\n        pr_reviewers: Set[str] = set()\n        for comment in pr.comments.nodes:\n            if comment.author:\n                authors[comment.author.login] = comment.author\n                if comment.author.login == author_name:\n                    continue\n                pr_commentors.add(comment.author.login)\n        for author_name in pr_commentors:\n            commentors[author_name] += 1\n        for review in pr.reviews.nodes:\n            if review.author:\n                authors[review.author.login] = review.author\n                pr_reviewers.add(review.author.login)\n        for reviewer in pr_reviewers:\n            reviewers[reviewer] += 1\n        if pr.state == \"MERGED\" and pr.author:\n            contributors[pr.author.login] += 1\n    return contributors, commentors, reviewers, authors\n\n\ndef get_top_users(\n    *,\n    counter: Counter,\n    min_count: int,\n    authors: Dict[str, Author],\n    skip_users: Container[str],\n):\n    users = []\n    for commentor, count in counter.most_common(50):\n        if commentor in skip_users:\n            continue\n        if count >= min_count:\n            author = authors[commentor]\n            users.append(\n                {\n                    \"login\": commentor,\n                    \"count\": count,\n                    \"avatarUrl\": author.avatarUrl,\n                    \"url\": author.url,\n                }\n            )\n    return users\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(level=logging.INFO)\n    settings = Settings()\n    logging.info(f\"Using config: {settings.model_dump_json()}\")\n    g = Github(settings.input_token.get_secret_value())\n    repo = g.get_repo(settings.github_repository)\n    question_commentors, question_last_month_commentors, question_authors = get_experts(\n        settings=settings\n    )\n    contributors, pr_commentors, reviewers, pr_authors = get_contributors(\n        settings=settings\n    )\n    authors = {**question_authors, **pr_authors}\n    maintainers_logins = {'samuelcolvin', 'adriangb', 'dmontagu', 'hramezani', 'Kludex', 'davidhewitt', 'sydney-runkle', 'alexmojaki'}\n    bot_names = {\"codecov\", \"github-actions\", \"pre-commit-ci\", \"dependabot\"}\n    maintainers = []\n    for login in maintainers_logins:\n        user = authors[login]\n        maintainers.append(\n            {\n                \"login\": login,\n                \"answers\": question_commentors[login],\n                \"prs\": contributors[login],\n                \"avatarUrl\": user.avatarUrl,\n                \"url\": user.url,\n            }\n        )\n\n    min_count_expert = 10\n    min_count_last_month = 3\n    min_count_contributor = 4\n    min_count_reviewer = 4\n    skip_users = maintainers_logins | bot_names\n    experts = get_top_users(\n        counter=question_commentors,\n        min_count=min_count_expert,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    last_month_active = get_top_users(\n        counter=question_last_month_commentors,\n        min_count=min_count_last_month,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_contributors = get_top_users(\n        counter=contributors,\n        min_count=min_count_contributor,\n        authors=authors,\n        skip_users=skip_users,\n    )\n    top_reviewers = get_top_users(\n        counter=reviewers,\n        min_count=min_count_reviewer,\n        authors=authors,\n        skip_users=skip_users,\n    )\n\n    extra_experts = [\n        {\n            \"login\": \"ybressler\",\n            \"count\": None,\n            \"avatarUrl\": \"https://avatars.githubusercontent.com/u/40807730?v=4\",\n            \"url\": \"https://github.com/ybressler\"\n        },\n    ]\n    expert_logins = {e[\"login\"] for e in experts}\n    experts.extend([expert for expert in extra_experts if expert[\"login\"] not in expert_logins])\n\n    people = {\n        \"maintainers\": maintainers,\n        \"experts\": experts,\n        \"last_month_active\": last_month_active,\n        \"top_contributors\": top_contributors,\n        \"top_reviewers\": top_reviewers,\n    }\n    people_path = Path(\"./docs/plugins/people.yml\")\n    people_old_content = people_path.read_text(encoding=\"utf-8\")\n    new_people_content = yaml.dump(\n        people, sort_keys=False, width=200, allow_unicode=True\n    )\n    if (\n        people_old_content == new_people_content\n    ):\n        logging.info(\"The Pydantic People data hasn't changed, finishing.\")\n        sys.exit(0)\n    people_path.write_text(new_people_content, encoding=\"utf-8\")\n\n    logging.info(\"Setting up GitHub Actions git user\")\n    subprocess.run([\"git\", \"config\", \"user.name\", \"github-actions\"], check=True)\n    subprocess.run(\n        [\"git\", \"config\", \"user.email\", \"github-actions@github.com\"], check=True\n    )\n\n    branch_name = \"pydantic-people-update\"\n    logging.info(f\"Creating a new branch {branch_name}\")\n    subprocess.run([\"git\", \"checkout\", \"-b\", branch_name], check=True)\n    logging.info(\"Adding updated file\")\n    subprocess.run(\n        [\"git\", \"add\", str(people_path)], check=True\n    )\n    logging.info(\"Committing updated file\")\n    message = \"\ud83d\udc65 Update Pydantic People\"\n    result = subprocess.run([\"git\", \"commit\", \"-m\", message], check=True)\n    logging.info(\"Pushing branch\")\n    subprocess.run([\"git\", \"push\", \"origin\", branch_name], check=True)\n    logging.info(\"Creating PR\")\n    pr = repo.create_pull(title=message, body=message, base=\"main\", head=branch_name)\n    logging.info(f\"Created PR: {pr.number}\")\n    logging.info(\"Finished\")\n", "release/make_history.py": "from __future__ import annotations as _annotations\n\nimport argparse\nimport json\nimport re\nimport subprocess\nimport sys\nfrom datetime import date\nfrom pathlib import Path\n\nimport requests\n\n\ndef main():\n    root_dir = Path(__file__).parent.parent\n\n    parser = argparse.ArgumentParser()\n    # For easier iteration, can generate the release notes without saving\n    parser.add_argument('--preview', help='print preview of release notes to terminal without saving to HISTORY.md')\n    args = parser.parse_args()\n\n    if args.preview:\n        new_version = args.preview\n    else:\n        version_file = root_dir / 'pydantic' / 'version.py'\n        new_version = re.search(r\"VERSION = '(.*)'\", version_file.read_text()).group(1)\n\n    history_path = root_dir / 'HISTORY.md'\n    history_content = history_path.read_text()\n\n    # use ( to avoid matching beta versions\n    if f'## v{new_version} (' in history_content:\n        print(f'WARNING: v{new_version} already in history, stopping')\n        sys.exit(1)\n\n    date_today_str = f'{date.today():%Y-%m-%d}'\n    title = f'v{new_version} ({date_today_str})'\n    notes = get_notes(new_version)\n    new_chunk = (\n        f'## {title}\\n\\n'\n        f'[GitHub release](https://github.com/pydantic/pydantic/releases/tag/v{new_version})\\n\\n'\n        f'{notes}\\n\\n'\n    )\n    if args.preview:\n        print(new_chunk)\n        return\n    history = new_chunk + history_content\n\n    history_path.write_text(history)\n    print(f'\\nSUCCESS: added \"{title}\" section to {history_path.relative_to(root_dir)}')\n\n    citation_path = root_dir / 'CITATION.cff'\n    citation_text = citation_path.read_text()\n    citation_text = re.sub(r'(?<=\\nversion: ).*', f'v{new_version}', citation_text)\n    citation_text = re.sub(r'(?<=date-released: ).*', date_today_str, citation_text)\n    citation_path.write_text(citation_text)\n    print(\n        f'SUCCESS: updated version=v{new_version} and date-released={date_today_str} in {citation_path.relative_to(root_dir)}'\n    )\n\n\ndef get_notes(new_version: str) -> str:\n    last_tag = get_last_tag()\n    auth_token = get_gh_auth_token()\n\n    data = {'target_committish': 'main', 'previous_tag_name': last_tag, 'tag_name': f'v{new_version}'}\n    response = requests.post(\n        'https://api.github.com/repos/pydantic/pydantic/releases/generate-notes',\n        headers={\n            'Accept': 'application/vnd.github+json',\n            'Authorization': f'Bearer {auth_token}',\n            'x-github-api-version': '2022-11-28',\n        },\n        data=json.dumps(data),\n    )\n    response.raise_for_status()\n\n    body = response.json()['body']\n    body = body.replace('<!-- Release notes generated using configuration in .github/release.yml at main -->\\n\\n', '')\n\n    # Add one level to all headers so they match HISTORY.md, and add trailing newline\n    body = re.sub(pattern='^(#+ .+?)$', repl=r'#\\1\\n', string=body, flags=re.MULTILINE)\n\n    # Ensure a blank line before headers\n    body = re.sub(pattern='([^\\n])(\\n#+ .+?\\n)', repl=r'\\1\\n\\2', string=body)\n\n    # Render PR links nicely\n    body = re.sub(\n        pattern='https://github.com/pydantic/pydantic/pull/(\\\\d+)',\n        repl=r'[#\\1](https://github.com/pydantic/pydantic/pull/\\1)',\n        string=body,\n    )\n\n    # Remove \"full changelog\" link\n    body = re.sub(\n        pattern=r'\\*\\*Full Changelog\\*\\*: https://.*$',\n        repl='',\n        string=body,\n    )\n\n    return body.strip()\n\n\ndef get_last_tag():\n    return run('git', 'describe', '--tags', '--abbrev=0')\n\n\ndef get_gh_auth_token():\n    return run('gh', 'auth', 'token')\n\n\ndef run(*args: str) -> str:\n    p = subprocess.run(args, stdout=subprocess.PIPE, check=True, encoding='utf-8')\n    return p.stdout.strip()\n\n\nif __name__ == '__main__':\n    main()\n"}