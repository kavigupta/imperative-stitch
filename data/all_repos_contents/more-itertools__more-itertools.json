{"setup.py": "from setuptools import setup\n\nsetup()\n", "docs/conf.py": "#\n# more-itertools documentation build configuration file, created by\n# sphinx-quickstart on Mon Jun 25 20:42:39 2012.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\nimport sphinx_rtd_theme\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath('..'))\n\nimport more_itertools\n\n# -- Preprocess README.rst -----------------------------------------------------\n# We include README.rst from the root directory. It has absolute links\n# to readthedocs.io for display on github.com, but those links can be\n# relative when being built for Sphinx.\n\nwith open('../README.rst', 'rt') as source:\n    readme_file = source.readlines()\n\nbuild_dir = '_build'\nos.makedirs(build_dir, exist_ok=True)\n\nrtd_path = 'https://more-itertools.readthedocs.io/en/stable/'\ntable_width = 200\nin_table = False\nwith open(os.path.join('.', build_dir, 'README.pprst'), 'wt') as target:\n    for line in readme_file:\n        old_len = len(line)\n        if line.startswith('|') and line.endswith('|\\n'):  # Inside table\n            line = line.replace(rtd_path, '').rstrip(' |\\n')\n            spaces = ' ' * (table_width - len(line) - 1)\n            line = f'{line}{spaces}|\\n'\n\n        target.write(line)\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc', 'sphinx.ext.viewcode']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'toctree'\n\n# General information about the project.\nproject = 'more-itertools'\ncopyright = '2012, Erik Rose'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = more_itertools.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = version\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n# language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [build_dir]\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'sphinx_rtd_theme'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\nhtml_css_files = [\"_static/theme_overrides.css\"]\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'more-itertoolsdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n    (\n        'index',\n        'more-itertools.tex',\n        'more-itertools Documentation',\n        'Erik Rose',\n        'manual',\n    ),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (\n        'index',\n        'more-itertools',\n        'more-itertools Documentation',\n        ['Erik Rose'],\n        1,\n    )\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        'index',\n        'more-itertools',\n        'more-itertools Documentation',\n        'Erik Rose',\n        'more-itertools',\n        'One line description of project.',\n        'Miscellaneous',\n    ),\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n", "tests/test_more.py": "import cmath\nimport warnings\n\nfrom collections import Counter, abc\nfrom collections.abc import Set\nfrom datetime import datetime, timedelta\nfrom decimal import Decimal\nfrom doctest import DocTestSuite\nfrom fractions import Fraction\nfrom functools import partial, reduce\nfrom io import StringIO\nfrom itertools import (\n    accumulate,\n    chain,\n    combinations,\n    combinations_with_replacement,\n    count,\n    cycle,\n    groupby,\n    islice,\n    permutations,\n    product,\n    repeat,\n)\nfrom operator import add, mul, itemgetter\nfrom pickle import loads, dumps\nfrom random import Random, random, randrange, seed\nfrom statistics import mean\nfrom string import ascii_letters\nfrom sys import version_info\nfrom time import sleep\nfrom traceback import format_exc\nfrom unittest import skipIf, TestCase\n\nimport more_itertools as mi\n\n\ndef load_tests(loader, tests, ignore):\n    # Add the doctests\n    tests.addTests(DocTestSuite('more_itertools.more'))\n    return tests\n\n\nclass ChunkedTests(TestCase):\n    \"\"\"Tests for ``chunked()``\"\"\"\n\n    def test_even(self):\n        \"\"\"Test when ``n`` divides evenly into the length of the iterable.\"\"\"\n        self.assertEqual(\n            list(mi.chunked('ABCDEF', 3)), [['A', 'B', 'C'], ['D', 'E', 'F']]\n        )\n\n    def test_odd(self):\n        \"\"\"Test when ``n`` does not divide evenly into the length of the\n        iterable.\n\n        \"\"\"\n        self.assertEqual(\n            list(mi.chunked('ABCDE', 3)), [['A', 'B', 'C'], ['D', 'E']]\n        )\n\n    def test_none(self):\n        \"\"\"Test when ``n`` has the value ``None``.\"\"\"\n        self.assertEqual(\n            list(mi.chunked('ABCDE', None)), [['A', 'B', 'C', 'D', 'E']]\n        )\n\n    def test_strict_false(self):\n        \"\"\"Test when ``n`` does not divide evenly into the length of the\n        iterable and strict is false.\n\n        \"\"\"\n        self.assertEqual(\n            list(mi.chunked('ABCDE', 3, strict=False)),\n            [['A', 'B', 'C'], ['D', 'E']],\n        )\n\n    def test_strict_being_true(self):\n        \"\"\"Test when ``n`` does not divide evenly into the length of the\n        iterable and strict is True (raising an exception).\n\n        \"\"\"\n\n        def f():\n            return list(mi.chunked('ABCDE', 3, strict=True))\n\n        self.assertRaisesRegex(ValueError, \"iterable is not divisible by n\", f)\n        self.assertEqual(\n            list(mi.chunked('ABCDEF', 3, strict=True)),\n            [['A', 'B', 'C'], ['D', 'E', 'F']],\n        )\n\n    def test_strict_being_true_with_size_none(self):\n        \"\"\"Test when ``n`` has value ``None`` and the keyword strict is True\n        (raising an exception).\n\n        \"\"\"\n\n        def f():\n            return list(mi.chunked('ABCDE', None, strict=True))\n\n        self.assertRaisesRegex(\n            ValueError, \"n must not be None when using strict mode.\", f\n        )\n\n\nclass FirstTests(TestCase):\n    def test_many(self):\n        # Also try it on a generator expression to make sure it works on\n        # whatever those return, across Python versions.\n        self.assertEqual(mi.first(x for x in range(4)), 0)\n\n    def test_one(self):\n        self.assertEqual(mi.first([3]), 3)\n\n    def test_empty(self):\n        with self.assertRaises(ValueError):\n            mi.first([])\n\n    def test_default(self):\n        self.assertEqual(mi.first([], 'boo'), 'boo')\n\n\nclass IterOnlyRange:\n    \"\"\"User-defined iterable class which only support __iter__.\n\n    >>> r = IterOnlyRange(5)\n    >>> r[0]\n    AttributeError: IterOnlyRange instance has no attribute '__getitem__'\n\n    Note: In Python 3, ``TypeError`` will be raised because ``object`` is\n    inherited implicitly by default.\n\n    >>> r[0]\n    TypeError: 'IterOnlyRange' object does not support indexing\n    \"\"\"\n\n    def __init__(self, n):\n        \"\"\"Set the length of the range.\"\"\"\n        self.n = n\n\n    def __iter__(self):\n        \"\"\"Works same as range().\"\"\"\n        return iter(range(self.n))\n\n\nclass LastTests(TestCase):\n    def test_basic(self):\n        cases = [\n            (range(4), 3),\n            (iter(range(4)), 3),\n            (range(1), 0),\n            (iter(range(1)), 0),\n            (IterOnlyRange(5), 4),\n            ({n: str(n) for n in range(5)}, 4),\n            ({0: '0', -1: '-1', 2: '-2'}, 2),\n        ]\n\n        for iterable, expected in cases:\n            with self.subTest(iterable=iterable):\n                self.assertEqual(mi.last(iterable), expected)\n\n    def test_default(self):\n        for iterable, default, expected in [\n            (range(1), None, 0),\n            ([], None, None),\n            ({}, None, None),\n            (iter([]), None, None),\n        ]:\n            with self.subTest(args=(iterable, default)):\n                self.assertEqual(mi.last(iterable, default=default), expected)\n\n    def test_empty(self):\n        for iterable in ([], iter(range(0))):\n            with self.subTest(iterable=iterable):\n                with self.assertRaises(ValueError):\n                    mi.last(iterable)\n\n\nclass NthOrLastTests(TestCase):\n    \"\"\"Tests for ``nth_or_last()``\"\"\"\n\n    def test_basic(self):\n        self.assertEqual(mi.nth_or_last(range(3), 1), 1)\n        self.assertEqual(mi.nth_or_last(range(3), 3), 2)\n\n    def test_default_value(self):\n        default = 42\n        self.assertEqual(mi.nth_or_last(range(0), 3, default), default)\n\n    def test_empty_iterable_no_default(self):\n        self.assertRaises(ValueError, lambda: mi.nth_or_last(range(0), 0))\n\n\nclass PeekableMixinTests:\n    \"\"\"Common tests for ``peekable()`` and ``seekable()`` behavior\"\"\"\n\n    cls = None\n\n    def test_passthrough(self):\n        \"\"\"Iterating a peekable without using ``peek()`` or ``prepend()``\n        should just give the underlying iterable's elements (a trivial test but\n        useful to set a baseline in case something goes wrong)\"\"\"\n        expected = [1, 2, 3, 4, 5]\n        actual = list(self.cls(expected))\n        self.assertEqual(actual, expected)\n\n    def test_peek_default(self):\n        \"\"\"Make sure passing a default into ``peek()`` works.\"\"\"\n        p = self.cls([])\n        self.assertEqual(p.peek(7), 7)\n\n    def test_truthiness(self):\n        \"\"\"Make sure a ``peekable`` tests true iff there are items remaining in\n        the iterable.\n\n        \"\"\"\n        p = self.cls([])\n        self.assertFalse(p)\n\n        p = self.cls(range(3))\n        self.assertTrue(p)\n\n    def test_simple_peeking(self):\n        \"\"\"Make sure ``next`` and ``peek`` advance and don't advance the\n        iterator, respectively.\n\n        \"\"\"\n        p = self.cls(range(10))\n        self.assertEqual(next(p), 0)\n        self.assertEqual(p.peek(), 1)\n        self.assertEqual(p.peek(), 1)\n        self.assertEqual(next(p), 1)\n\n\nclass PeekableTests(PeekableMixinTests, TestCase):\n    cls = mi.peekable\n\n    def test_indexing(self):\n        \"\"\"\n        Indexing into the peekable shouldn't advance the iterator.\n        \"\"\"\n        p = mi.peekable('abcdefghijkl')\n\n        # The 0th index is what ``next()`` will return\n        self.assertEqual(p[0], 'a')\n        self.assertEqual(next(p), 'a')\n\n        # Indexing further into the peekable shouldn't advance the iterator\n        self.assertEqual(p[2], 'd')\n        self.assertEqual(next(p), 'b')\n\n        # The 0th index moves up with the iterator; the last index follows\n        self.assertEqual(p[0], 'c')\n        self.assertEqual(p[9], 'l')\n\n        self.assertEqual(next(p), 'c')\n        self.assertEqual(p[8], 'l')\n\n        # Negative indexing should work too\n        self.assertEqual(p[-2], 'k')\n        self.assertEqual(p[-9], 'd')\n        self.assertRaises(IndexError, lambda: p[-10])\n\n    def test_slicing(self):\n        \"\"\"Slicing the peekable shouldn't advance the iterator.\"\"\"\n        seq = list('abcdefghijkl')\n        p = mi.peekable(seq)\n\n        # Slicing the peekable should just be like slicing a re-iterable\n        self.assertEqual(p[1:4], seq[1:4])\n\n        # Advancing the iterator moves the slices up also\n        self.assertEqual(next(p), 'a')\n        self.assertEqual(p[1:4], seq[1:][1:4])\n\n        # Implicit starts and stop should work\n        self.assertEqual(p[:5], seq[1:][:5])\n        self.assertEqual(p[:], seq[1:][:])\n\n        # Indexing past the end should work\n        self.assertEqual(p[:100], seq[1:][:100])\n\n        # Steps should work, including negative\n        self.assertEqual(p[::2], seq[1:][::2])\n        self.assertEqual(p[::-1], seq[1:][::-1])\n\n    def test_slicing_reset(self):\n        \"\"\"Test slicing on a fresh iterable each time\"\"\"\n        iterable = ['0', '1', '2', '3', '4', '5']\n        indexes = list(range(-4, len(iterable) + 4)) + [None]\n        steps = [1, 2, 3, 4, -1, -2, -3, 4]\n        for slice_args in product(indexes, indexes, steps):\n            it = iter(iterable)\n            p = mi.peekable(it)\n            next(p)\n            index = slice(*slice_args)\n            actual = p[index]\n            expected = iterable[1:][index]\n            self.assertEqual(actual, expected, slice_args)\n\n    def test_slicing_error(self):\n        iterable = '01234567'\n        p = mi.peekable(iter(iterable))\n\n        # Prime the cache\n        p.peek()\n        old_cache = list(p._cache)\n\n        # Illegal slice\n        with self.assertRaises(ValueError):\n            p[1:-1:0]\n\n        # Neither the cache nor the iteration should be affected\n        self.assertEqual(old_cache, list(p._cache))\n        self.assertEqual(list(p), list(iterable))\n\n    # prepend() behavior tests\n\n    def test_prepend(self):\n        \"\"\"Tests interspersed ``prepend()`` and ``next()`` calls\"\"\"\n        it = mi.peekable(range(2))\n        actual = []\n\n        # Test prepend() before next()\n        it.prepend(10)\n        actual += [next(it), next(it)]\n\n        # Test prepend() between next()s\n        it.prepend(11)\n        actual += [next(it), next(it)]\n\n        # Test prepend() after source iterable is consumed\n        it.prepend(12)\n        actual += [next(it)]\n\n        expected = [10, 0, 11, 1, 12]\n        self.assertEqual(actual, expected)\n\n    def test_multi_prepend(self):\n        \"\"\"Tests prepending multiple items and getting them in proper order\"\"\"\n        it = mi.peekable(range(5))\n        actual = [next(it), next(it)]\n        it.prepend(10, 11, 12)\n        it.prepend(20, 21)\n        actual += list(it)\n        expected = [0, 1, 20, 21, 10, 11, 12, 2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        \"\"\"Tests prepending in front of an empty iterable\"\"\"\n        it = mi.peekable([])\n        it.prepend(10)\n        actual = list(it)\n        expected = [10]\n        self.assertEqual(actual, expected)\n\n    def test_prepend_truthiness(self):\n        \"\"\"Tests that ``__bool__()`` or ``__nonzero__()`` works properly\n        with ``prepend()``\"\"\"\n        it = mi.peekable(range(5))\n        self.assertTrue(it)\n        actual = list(it)\n        self.assertFalse(it)\n        it.prepend(10)\n        self.assertTrue(it)\n        actual += [next(it)]\n        self.assertFalse(it)\n        expected = [0, 1, 2, 3, 4, 10]\n        self.assertEqual(actual, expected)\n\n    def test_multi_prepend_peek(self):\n        \"\"\"Tests prepending multiple elements and getting them in reverse order\n        while peeking\"\"\"\n        it = mi.peekable(range(5))\n        actual = [next(it), next(it)]\n        self.assertEqual(it.peek(), 2)\n        it.prepend(10, 11, 12)\n        self.assertEqual(it.peek(), 10)\n        it.prepend(20, 21)\n        self.assertEqual(it.peek(), 20)\n        actual += list(it)\n        self.assertFalse(it)\n        expected = [0, 1, 20, 21, 10, 11, 12, 2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_prepend_after_stop(self):\n        \"\"\"Test resuming iteration after a previous exhaustion\"\"\"\n        it = mi.peekable(range(3))\n        self.assertEqual(list(it), [0, 1, 2])\n        self.assertRaises(StopIteration, lambda: next(it))\n        it.prepend(10)\n        self.assertEqual(next(it), 10)\n        self.assertRaises(StopIteration, lambda: next(it))\n\n    def test_prepend_slicing(self):\n        \"\"\"Tests interaction between prepending and slicing\"\"\"\n        seq = list(range(20))\n        p = mi.peekable(seq)\n\n        p.prepend(30, 40, 50)\n        pseq = [30, 40, 50] + seq  # pseq for prepended_seq\n\n        # adapt the specific tests from test_slicing\n        self.assertEqual(p[0], 30)\n        self.assertEqual(p[1:8], pseq[1:8])\n        self.assertEqual(p[1:], pseq[1:])\n        self.assertEqual(p[:5], pseq[:5])\n        self.assertEqual(p[:], pseq[:])\n        self.assertEqual(p[:100], pseq[:100])\n        self.assertEqual(p[::2], pseq[::2])\n        self.assertEqual(p[::-1], pseq[::-1])\n\n    def test_prepend_indexing(self):\n        \"\"\"Tests interaction between prepending and indexing\"\"\"\n        seq = list(range(20))\n        p = mi.peekable(seq)\n\n        p.prepend(30, 40, 50)\n\n        self.assertEqual(p[0], 30)\n        self.assertEqual(next(p), 30)\n        self.assertEqual(p[2], 0)\n        self.assertEqual(next(p), 40)\n        self.assertEqual(p[0], 50)\n        self.assertEqual(p[9], 8)\n        self.assertEqual(next(p), 50)\n        self.assertEqual(p[8], 8)\n        self.assertEqual(p[-2], 18)\n        self.assertEqual(p[-9], 11)\n        self.assertRaises(IndexError, lambda: p[-21])\n\n    def test_prepend_iterable(self):\n        \"\"\"Tests prepending from an iterable\"\"\"\n        it = mi.peekable(range(5))\n        # Don't directly use the range() object to avoid any range-specific\n        # optimizations\n        it.prepend(*(x for x in range(5)))\n        actual = list(it)\n        expected = list(chain(range(5), range(5)))\n        self.assertEqual(actual, expected)\n\n    def test_prepend_many(self):\n        \"\"\"Tests that prepending a huge number of elements works\"\"\"\n        it = mi.peekable(range(5))\n        # Don't directly use the range() object to avoid any range-specific\n        # optimizations\n        it.prepend(*(x for x in range(20000)))\n        actual = list(it)\n        expected = list(chain(range(20000), range(5)))\n        self.assertEqual(actual, expected)\n\n    def test_prepend_reversed(self):\n        \"\"\"Tests prepending from a reversed iterable\"\"\"\n        it = mi.peekable(range(3))\n        it.prepend(*reversed((10, 11, 12)))\n        actual = list(it)\n        expected = [12, 11, 10, 0, 1, 2]\n        self.assertEqual(actual, expected)\n\n\nclass ConsumerTests(TestCase):\n    \"\"\"Tests for ``consumer()``\"\"\"\n\n    def test_consumer(self):\n        @mi.consumer\n        def eater():\n            while True:\n                x = yield  # noqa\n\n        e = eater()\n        e.send('hi')  # without @consumer, would raise TypeError\n\n\nclass DistinctPermutationsTests(TestCase):\n    def test_basic(self):\n        iterable = ['z', 'a', 'a', 'q', 'q', 'q', 'y']\n        actual = list(mi.distinct_permutations(iterable))\n        expected = set(permutations(iterable))\n        self.assertCountEqual(actual, expected)\n\n    def test_r(self):\n        for iterable, r in (\n            ('mississippi', 0),\n            ('mississippi', 1),\n            ('mississippi', 6),\n            ('mississippi', 7),\n            ('mississippi', 12),\n            ([0, 1, 1, 0], 0),\n            ([0, 1, 1, 0], 1),\n            ([0, 1, 1, 0], 2),\n            ([0, 1, 1, 0], 3),\n            ([0, 1, 1, 0], 4),\n            (['a'], 0),\n            (['a'], 1),\n            (['a'], 5),\n            ([], 0),\n            ([], 1),\n            ([], 4),\n        ):\n            with self.subTest(iterable=iterable, r=r):\n                expected = set(permutations(iterable, r))\n                actual = list(mi.distinct_permutations(iter(iterable), r))\n                self.assertCountEqual(actual, expected)\n\n    def test_unsortable(self):\n        iterable = ['1', 2, 2, 3, 3, 3]\n        actual = list(mi.distinct_permutations(iterable))\n        expected = set(permutations(iterable))\n        self.assertCountEqual(actual, expected)\n\n    def test_unsortable_r(self):\n        iterable = ['1', 2, 2, 3, 3, 3]\n        for r in range(len(iterable) + 1):\n            with self.subTest(iterable=iterable, r=r):\n                actual = list(mi.distinct_permutations(iterable, r=r))\n                expected = set(permutations(iterable, r=r))\n                self.assertCountEqual(actual, expected)\n\n    def test_unsorted_equivalent(self):\n        iterable = [1, True, '3']\n        actual = list(mi.distinct_permutations(iterable))\n        expected = set(permutations(iterable))\n        self.assertCountEqual(actual, expected)\n\n    def test_unhashable(self):\n        iterable = ([1], [1], 2)\n        actual = list(mi.distinct_permutations(iterable))\n        expected = list(mi.unique_everseen(permutations(iterable)))\n        self.assertCountEqual(actual, expected)\n\n\nclass IlenTests(TestCase):\n    def test_ilen(self):\n        \"\"\"Sanity-checks for ``ilen()``.\"\"\"\n        # Non-empty\n        self.assertEqual(\n            mi.ilen(filter(lambda x: x % 10 == 0, range(101))), 11\n        )\n\n        # Empty\n        self.assertEqual(mi.ilen(x for x in range(0)), 0)\n\n        # Iterable with __len__\n        self.assertEqual(mi.ilen(list(range(6))), 6)\n\n\nclass MinMaxTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in (\n            # easy case\n            ([0, 1, 2, 3], (0, 3)),\n            # min and max are not in the extremes + we have `int`s and `float`s\n            ([3, 5.5, -1, 2], (-1, 5.5)),\n            # unordered collection\n            ({3, 5.5, -1, 2}, (-1, 5.5)),\n            # with repetitions\n            ([3, 5.5, float('-Inf'), 5.5], (float('-Inf'), 5.5)),\n            # other collections\n            ('banana', ('a', 'n')),\n            ({0: 1, 2: 100, 1: 10}, (0, 2)),\n            (range(3, 14), (3, 13)),\n        ):\n            with self.subTest(iterable=iterable, expected=expected):\n                # check for expected results\n                self.assertTupleEqual(mi.minmax(iterable), expected)\n                # check for equality with built-in `min` and `max`\n                self.assertTupleEqual(\n                    mi.minmax(iterable), (min(iterable), max(iterable))\n                )\n\n    def test_unpacked(self):\n        self.assertTupleEqual(mi.minmax(2, 3, 1), (1, 3))\n        self.assertTupleEqual(mi.minmax(12, 3, 4, key=str), (12, 4))\n\n    def test_iterables(self):\n        self.assertTupleEqual(mi.minmax(x for x in [0, 1, 2, 3]), (0, 3))\n        self.assertTupleEqual(\n            mi.minmax(map(str, [3, 5.5, 'a', 2])), ('2', 'a')\n        )\n        self.assertTupleEqual(\n            mi.minmax(filter(None, [0, 3, '', None, 10])), (3, 10)\n        )\n\n    def test_key(self):\n        self.assertTupleEqual(\n            mi.minmax({(), (1, 4, 2), 'abcde', range(4)}, key=len),\n            ((), 'abcde'),\n        )\n        self.assertTupleEqual(\n            mi.minmax((x for x in [10, 3, 25]), key=str), (10, 3)\n        )\n\n    def test_default(self):\n        with self.assertRaises(ValueError):\n            mi.minmax([])\n\n        self.assertIs(mi.minmax([], default=None), None)\n        self.assertListEqual(mi.minmax([], default=[1, 'a']), [1, 'a'])\n\n\nclass WithIterTests(TestCase):\n    def test_with_iter(self):\n        s = StringIO('One fish\\nTwo fish')\n        initial_words = [line.split()[0] for line in mi.with_iter(s)]\n\n        # Iterable's items should be faithfully represented\n        self.assertEqual(initial_words, ['One', 'Two'])\n        # The file object should be closed\n        self.assertTrue(s.closed)\n\n\nclass OneTests(TestCase):\n    def test_basic(self):\n        it = iter(['item'])\n        self.assertEqual(mi.one(it), 'item')\n\n    def test_too_short(self):\n        it = iter([])\n        for too_short, exc_type in [\n            (None, ValueError),\n            (IndexError, IndexError),\n        ]:\n            with self.subTest(too_short=too_short):\n                try:\n                    mi.one(it, too_short=too_short)\n                except exc_type:\n                    formatted_exc = format_exc()\n                    self.assertIn('StopIteration', formatted_exc)\n                    self.assertIn(\n                        'The above exception was the direct cause',\n                        formatted_exc,\n                    )\n                else:\n                    self.fail()\n\n    def test_too_long(self):\n        it = count()\n        self.assertRaises(ValueError, lambda: mi.one(it))  # burn 0 and 1\n        self.assertEqual(next(it), 2)\n        self.assertRaises(\n            OverflowError, lambda: mi.one(it, too_long=OverflowError)\n        )\n\n    def test_too_long_default_message(self):\n        it = count()\n        self.assertRaisesRegex(\n            ValueError,\n            \"Expected exactly one item in \"\n            \"iterable, but got 0, 1, and \"\n            \"perhaps more.\",\n            lambda: mi.one(it),\n        )\n\n\nclass IntersperseTest(TestCase):\n    \"\"\"Tests for intersperse()\"\"\"\n\n    def test_even(self):\n        iterable = (x for x in '01')\n        self.assertEqual(\n            list(mi.intersperse(None, iterable)), ['0', None, '1']\n        )\n\n    def test_odd(self):\n        iterable = (x for x in '012')\n        self.assertEqual(\n            list(mi.intersperse(None, iterable)), ['0', None, '1', None, '2']\n        )\n\n    def test_nested(self):\n        element = ('a', 'b')\n        iterable = (x for x in '012')\n        actual = list(mi.intersperse(element, iterable))\n        expected = ['0', ('a', 'b'), '1', ('a', 'b'), '2']\n        self.assertEqual(actual, expected)\n\n    def test_not_iterable(self):\n        self.assertRaises(TypeError, lambda: mi.intersperse('x', 1))\n\n    def test_n(self):\n        for n, element, expected in [\n            (1, '_', ['0', '_', '1', '_', '2', '_', '3', '_', '4', '_', '5']),\n            (2, '_', ['0', '1', '_', '2', '3', '_', '4', '5']),\n            (3, '_', ['0', '1', '2', '_', '3', '4', '5']),\n            (4, '_', ['0', '1', '2', '3', '_', '4', '5']),\n            (5, '_', ['0', '1', '2', '3', '4', '_', '5']),\n            (6, '_', ['0', '1', '2', '3', '4', '5']),\n            (7, '_', ['0', '1', '2', '3', '4', '5']),\n            (3, ['a', 'b'], ['0', '1', '2', ['a', 'b'], '3', '4', '5']),\n        ]:\n            iterable = (x for x in '012345')\n            actual = list(mi.intersperse(element, iterable, n=n))\n            self.assertEqual(actual, expected)\n\n    def test_n_zero(self):\n        self.assertRaises(\n            ValueError, lambda: list(mi.intersperse('x', '012', n=0))\n        )\n\n\nclass UniqueToEachTests(TestCase):\n    \"\"\"Tests for ``unique_to_each()``\"\"\"\n\n    def test_all_unique(self):\n        \"\"\"When all the input iterables are unique the output should match\n        the input.\"\"\"\n        iterables = [[1, 2], [3, 4, 5], [6, 7, 8]]\n        self.assertEqual(mi.unique_to_each(*iterables), iterables)\n\n    def test_duplicates(self):\n        \"\"\"When there are duplicates in any of the input iterables that aren't\n        in the rest, those duplicates should be emitted.\"\"\"\n        iterables = [\"mississippi\", \"missouri\"]\n        self.assertEqual(\n            mi.unique_to_each(*iterables), [['p', 'p'], ['o', 'u', 'r']]\n        )\n\n    def test_mixed(self):\n        \"\"\"When the input iterables contain different types the function should\n        still behave properly\"\"\"\n        iterables = ['x', (i for i in range(3)), [1, 2, 3], tuple()]\n        self.assertEqual(mi.unique_to_each(*iterables), [['x'], [0], [3], []])\n\n\nclass WindowedTests(TestCase):\n    def test_basic(self):\n        iterable = [1, 2, 3, 4, 5]\n\n        for n, expected in (\n            (6, [(1, 2, 3, 4, 5, None)]),\n            (5, [(1, 2, 3, 4, 5)]),\n            (4, [(1, 2, 3, 4), (2, 3, 4, 5)]),\n            (3, [(1, 2, 3), (2, 3, 4), (3, 4, 5)]),\n            (2, [(1, 2), (2, 3), (3, 4), (4, 5)]),\n            (1, [(1,), (2,), (3,), (4,), (5,)]),\n            (0, [()]),\n        ):\n            with self.subTest(n=n):\n                actual = list(mi.windowed(iterable, n))\n                self.assertEqual(actual, expected)\n\n    def test_fillvalue(self):\n        actual = list(mi.windowed([1, 2, 3, 4, 5], 6, fillvalue='!'))\n        expected = [(1, 2, 3, 4, 5, '!')]\n        self.assertEqual(actual, expected)\n\n    def test_step(self):\n        iterable = [1, 2, 3, 4, 5, 6, 7]\n        for n, step, expected in [\n            (3, 2, [(1, 2, 3), (3, 4, 5), (5, 6, 7)]),  # n > step\n            (3, 3, [(1, 2, 3), (4, 5, 6), (7, None, None)]),  # n == step\n            (3, 4, [(1, 2, 3), (5, 6, 7)]),  # lines up nicely\n            (3, 5, [(1, 2, 3), (6, 7, None)]),  # off by one\n            (3, 6, [(1, 2, 3), (7, None, None)]),  # off by two\n            (3, 7, [(1, 2, 3)]),  # step past the end\n            (7, 8, [(1, 2, 3, 4, 5, 6, 7)]),  # step > len(iterable)\n        ]:\n            with self.subTest(n=n, step=step):\n                actual = list(mi.windowed(iterable, n, step=step))\n                self.assertEqual(actual, expected)\n\n    def test_invalid_step(self):\n        # Step must be greater than or equal to 1\n        with self.assertRaises(ValueError):\n            list(mi.windowed([1, 2, 3, 4, 5], 3, step=0))\n\n    def test_fillvalue_step(self):\n        actual = list(mi.windowed([1, 2, 3, 4, 5], 3, fillvalue='!', step=3))\n        expected = [(1, 2, 3), (4, 5, '!')]\n        self.assertEqual(actual, expected)\n\n    def test_negative(self):\n        with self.assertRaises(ValueError):\n            list(mi.windowed([1, 2, 3, 4, 5], -1))\n\n    def test_empty_seq(self):\n        actual = list(mi.windowed([], 3))\n        expected = []\n        self.assertEqual(actual, expected)\n\n\nclass SubstringsTests(TestCase):\n    def test_basic(self):\n        iterable = (x for x in range(4))\n        actual = list(mi.substrings(iterable))\n        expected = [\n            (0,),\n            (1,),\n            (2,),\n            (3,),\n            (0, 1),\n            (1, 2),\n            (2, 3),\n            (0, 1, 2),\n            (1, 2, 3),\n            (0, 1, 2, 3),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_strings(self):\n        iterable = 'abc'\n        actual = list(mi.substrings(iterable))\n        expected = [\n            ('a',),\n            ('b',),\n            ('c',),\n            ('a', 'b'),\n            ('b', 'c'),\n            ('a', 'b', 'c'),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        iterable = iter([])\n        actual = list(mi.substrings(iterable))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_order(self):\n        iterable = [2, 0, 1]\n        actual = list(mi.substrings(iterable))\n        expected = [(2,), (0,), (1,), (2, 0), (0, 1), (2, 0, 1)]\n        self.assertEqual(actual, expected)\n\n\nclass SubstringsIndexesTests(TestCase):\n    def test_basic(self):\n        sequence = [x for x in range(4)]\n        actual = list(mi.substrings_indexes(sequence))\n        expected = [\n            ([0], 0, 1),\n            ([1], 1, 2),\n            ([2], 2, 3),\n            ([3], 3, 4),\n            ([0, 1], 0, 2),\n            ([1, 2], 1, 3),\n            ([2, 3], 2, 4),\n            ([0, 1, 2], 0, 3),\n            ([1, 2, 3], 1, 4),\n            ([0, 1, 2, 3], 0, 4),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_strings(self):\n        sequence = 'abc'\n        actual = list(mi.substrings_indexes(sequence))\n        expected = [\n            ('a', 0, 1),\n            ('b', 1, 2),\n            ('c', 2, 3),\n            ('ab', 0, 2),\n            ('bc', 1, 3),\n            ('abc', 0, 3),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        sequence = []\n        actual = list(mi.substrings_indexes(sequence))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_order(self):\n        sequence = [2, 0, 1]\n        actual = list(mi.substrings_indexes(sequence))\n        expected = [\n            ([2], 0, 1),\n            ([0], 1, 2),\n            ([1], 2, 3),\n            ([2, 0], 0, 2),\n            ([0, 1], 1, 3),\n            ([2, 0, 1], 0, 3),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_reverse(self):\n        sequence = [2, 0, 1]\n        actual = list(mi.substrings_indexes(sequence, reverse=True))\n        expected = [\n            ([2, 0, 1], 0, 3),\n            ([2, 0], 0, 2),\n            ([0, 1], 1, 3),\n            ([2], 0, 1),\n            ([0], 1, 2),\n            ([1], 2, 3),\n        ]\n        self.assertEqual(actual, expected)\n\n\nclass BucketTests(TestCase):\n    def test_basic(self):\n        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]\n        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))\n\n        # In-order access\n        self.assertEqual(list(D[10]), [10, 11, 12])\n\n        # Out of order access\n        self.assertEqual(list(D[30]), [30, 31, 33])\n        self.assertEqual(list(D[20]), [20, 21, 22, 23])\n\n        self.assertEqual(list(D[40]), [])  # Nothing in here!\n\n    def test_in(self):\n        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]\n        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))\n\n        self.assertIn(10, D)\n        self.assertNotIn(40, D)\n        self.assertIn(20, D)\n        self.assertNotIn(21, D)\n\n        # Checking in-ness shouldn't advance the iterator\n        self.assertEqual(next(D[10]), 10)\n\n    def test_validator(self):\n        iterable = count(0)\n        key = lambda x: int(str(x)[0])  # First digit of each number\n        validator = lambda x: 0 < x < 10  # No leading zeros\n        D = mi.bucket(iterable, key, validator=validator)\n        self.assertEqual(mi.take(3, D[1]), [1, 10, 11])\n        self.assertNotIn(0, D)  # Non-valid entries don't return True\n        self.assertNotIn(0, D._cache)  # Don't store non-valid entries\n        self.assertEqual(list(D[0]), [])\n\n    def test_list(self):\n        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]\n        D = mi.bucket(iterable, key=lambda x: 10 * (x // 10))\n        self.assertEqual(list(D[10]), [10, 11, 12])\n        self.assertEqual(list(D[20]), [20, 21, 22, 23])\n        self.assertEqual(list(D[30]), [30, 31, 33])\n        self.assertEqual(set(D), {10, 20, 30})\n\n    def test_list_validator(self):\n        iterable = [10, 20, 30, 11, 21, 31, 12, 22, 23, 33]\n        key = lambda x: 10 * (x // 10)\n        validator = lambda x: x != 20\n        D = mi.bucket(iterable, key, validator=validator)\n        self.assertEqual(set(D), {10, 30})\n        self.assertEqual(list(D[10]), [10, 11, 12])\n        self.assertEqual(list(D[20]), [])\n        self.assertEqual(list(D[30]), [30, 31, 33])\n\n\nclass SpyTests(TestCase):\n    \"\"\"Tests for ``spy()``\"\"\"\n\n    def test_basic(self):\n        original_iterable = iter('abcdefg')\n        head, new_iterable = mi.spy(original_iterable)\n        self.assertEqual(head, ['a'])\n        self.assertEqual(\n            list(new_iterable), ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n        )\n\n    def test_unpacking(self):\n        original_iterable = iter('abcdefg')\n        (first, second, third), new_iterable = mi.spy(original_iterable, 3)\n        self.assertEqual(first, 'a')\n        self.assertEqual(second, 'b')\n        self.assertEqual(third, 'c')\n        self.assertEqual(\n            list(new_iterable), ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n        )\n\n    def test_too_many(self):\n        original_iterable = iter('abc')\n        head, new_iterable = mi.spy(original_iterable, 4)\n        self.assertEqual(head, ['a', 'b', 'c'])\n        self.assertEqual(list(new_iterable), ['a', 'b', 'c'])\n\n    def test_zero(self):\n        original_iterable = iter('abc')\n        head, new_iterable = mi.spy(original_iterable, 0)\n        self.assertEqual(head, [])\n        self.assertEqual(list(new_iterable), ['a', 'b', 'c'])\n\n    def test_immutable(self):\n        original_iterable = iter('abcdefg')\n        head, new_iterable = mi.spy(original_iterable, 3)\n        head[0] = 'A'\n        self.assertEqual(head, ['A', 'b', 'c'])\n        self.assertEqual(\n            list(new_iterable), ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n        )\n\n\nclass InterleaveTests(TestCase):\n    def test_even(self):\n        actual = list(mi.interleave([1, 4, 7], [2, 5, 8], [3, 6, 9]))\n        expected = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_short(self):\n        actual = list(mi.interleave([1, 4], [2, 5, 7], [3, 6, 8]))\n        expected = [1, 2, 3, 4, 5, 6]\n        self.assertEqual(actual, expected)\n\n    def test_mixed_types(self):\n        it_list = ['a', 'b', 'c', 'd']\n        it_str = '12345'\n        it_inf = count()\n        actual = list(mi.interleave(it_list, it_str, it_inf))\n        expected = ['a', '1', 0, 'b', '2', 1, 'c', '3', 2, 'd', '4', 3]\n        self.assertEqual(actual, expected)\n\n\nclass InterleaveLongestTests(TestCase):\n    def test_even(self):\n        actual = list(mi.interleave_longest([1, 4, 7], [2, 5, 8], [3, 6, 9]))\n        expected = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_short(self):\n        actual = list(mi.interleave_longest([1, 4], [2, 5, 7], [3, 6, 8]))\n        expected = [1, 2, 3, 4, 5, 6, 7, 8]\n        self.assertEqual(actual, expected)\n\n    def test_mixed_types(self):\n        it_list = ['a', 'b', 'c', 'd']\n        it_str = '12345'\n        it_gen = (x for x in range(3))\n        actual = list(mi.interleave_longest(it_list, it_str, it_gen))\n        expected = ['a', '1', 0, 'b', '2', 1, 'c', '3', 2, 'd', '4', '5']\n        self.assertEqual(actual, expected)\n\n\nclass InterleaveEvenlyTests(TestCase):\n    def test_equal_lengths(self):\n        # when lengths are equal, the relative order shouldn't change\n        a = [1, 2, 3]\n        b = [5, 6, 7]\n        actual = list(mi.interleave_evenly([a, b]))\n        expected = [1, 5, 2, 6, 3, 7]\n        self.assertEqual(actual, expected)\n\n    def test_proportional(self):\n        # easy case where the iterables have proportional length\n        a = [1, 2, 3, 4]\n        b = [5, 6]\n        actual = list(mi.interleave_evenly([a, b]))\n        expected = [1, 2, 5, 3, 4, 6]\n        self.assertEqual(actual, expected)\n\n        # swapping a and b should yield the same result\n        actual_swapped = list(mi.interleave_evenly([b, a]))\n        self.assertEqual(actual_swapped, expected)\n\n    def test_not_proportional(self):\n        a = [1, 2, 3, 4, 5, 6, 7]\n        b = [8, 9, 10]\n        expected = [1, 2, 8, 3, 4, 9, 5, 6, 10, 7]\n        actual = list(mi.interleave_evenly([a, b]))\n        self.assertEqual(actual, expected)\n\n    def test_degenerate_one(self):\n        a = [0, 1, 2, 3, 4]\n        b = [5]\n        expected = [0, 1, 2, 5, 3, 4]\n        actual = list(mi.interleave_evenly([a, b]))\n        self.assertEqual(actual, expected)\n\n    def test_degenerate_empty(self):\n        a = [1, 2, 3]\n        b = []\n        expected = [1, 2, 3]\n        actual = list(mi.interleave_evenly([a, b]))\n        self.assertEqual(actual, expected)\n\n    def test_three_iters(self):\n        a = [\"a1\", \"a2\", \"a3\", \"a4\", \"a5\"]\n        b = [\"b1\", \"b2\", \"b3\"]\n        c = [\"c1\"]\n        actual = list(mi.interleave_evenly([a, b, c]))\n        expected = [\"a1\", \"b1\", \"a2\", \"c1\", \"a3\", \"b2\", \"a4\", \"b3\", \"a5\"]\n        self.assertEqual(actual, expected)\n\n    def test_many_iters(self):\n        # smoke test with many iterables: create iterables with a random\n        # number of elements starting with a character (\"a0\", \"a1\", ...)\n        rng = Random(0)\n        iterables = []\n        for ch in ascii_letters:\n            length = rng.randint(0, 100)\n            iterable = [f\"{ch}{i}\" for i in range(length)]\n            iterables.append(iterable)\n\n        interleaved = list(mi.interleave_evenly(iterables))\n\n        # for each iterable, check that the result contains all its items\n        for iterable, ch_expect in zip(iterables, ascii_letters):\n            interleaved_actual = [\n                e for e in interleaved if e.startswith(ch_expect)\n            ]\n            assert len(set(interleaved_actual)) == len(iterable)\n\n    def test_manual_lengths(self):\n        a = combinations(range(4), 2)\n        len_a = 4 * (4 - 1) // 2  # == 6\n        b = combinations(range(4), 3)\n        len_b = 4\n\n        expected = [\n            (0, 1),\n            (0, 1, 2),\n            (0, 2),\n            (0, 3),\n            (0, 1, 3),\n            (1, 2),\n            (0, 2, 3),\n            (1, 3),\n            (2, 3),\n            (1, 2, 3),\n        ]\n        actual = list(mi.interleave_evenly([a, b], lengths=[len_a, len_b]))\n        self.assertEqual(expected, actual)\n\n    def test_no_length_raises(self):\n        # combinations doesn't have __len__, should trigger ValueError\n        iterables = [range(5), combinations(range(5), 2)]\n        with self.assertRaises(ValueError):\n            list(mi.interleave_evenly(iterables))\n\n    def test_argument_mismatch_raises(self):\n        # pass mismatching number of iterables and lengths\n        iterables = [range(3)]\n        lengths = [3, 4]\n        with self.assertRaises(ValueError):\n            list(mi.interleave_evenly(iterables, lengths=lengths))\n\n\nclass TestCollapse(TestCase):\n    \"\"\"Tests for ``collapse()``\"\"\"\n\n    def test_collapse(self):\n        l = [[1], 2, [[3], 4], [[[5]]]]\n        self.assertEqual(list(mi.collapse(l)), [1, 2, 3, 4, 5])\n\n    def test_collapse_to_string(self):\n        l = [[\"s1\"], \"s2\", [[\"s3\"], \"s4\"], [[[\"s5\"]]]]\n        self.assertEqual(list(mi.collapse(l)), [\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"])\n\n    def test_collapse_to_bytes(self):\n        l = [[b\"s1\"], b\"s2\", [[b\"s3\"], b\"s4\"], [[[b\"s5\"]]]]\n        self.assertEqual(\n            list(mi.collapse(l)), [b\"s1\", b\"s2\", b\"s3\", b\"s4\", b\"s5\"]\n        )\n\n    def test_collapse_flatten(self):\n        l = [[1], [2], [[3], 4], [[[5]]]]\n        self.assertEqual(list(mi.collapse(l, levels=1)), list(mi.flatten(l)))\n\n    def test_collapse_to_level(self):\n        l = [[1], 2, [[3], 4], [[[5]]]]\n        self.assertEqual(list(mi.collapse(l, levels=2)), [1, 2, 3, 4, [5]])\n        self.assertEqual(\n            list(mi.collapse(mi.collapse(l, levels=1), levels=1)),\n            list(mi.collapse(l, levels=2)),\n        )\n\n    def test_collapse_to_list(self):\n        l = (1, [2], (3, [4, (5,)], 'ab'))\n        actual = list(mi.collapse(l, base_type=list))\n        expected = [1, [2], 3, [4, (5,)], 'ab']\n        self.assertEqual(actual, expected)\n\n\nclass SideEffectTests(TestCase):\n    \"\"\"Tests for ``side_effect()``\"\"\"\n\n    def test_individual(self):\n        # The function increments the counter for each call\n        counter = [0]\n\n        def func(arg):\n            counter[0] += 1\n\n        result = list(mi.side_effect(func, range(10)))\n        self.assertEqual(result, list(range(10)))\n        self.assertEqual(counter[0], 10)\n\n    def test_chunked(self):\n        # The function increments the counter for each call\n        counter = [0]\n\n        def func(arg):\n            counter[0] += 1\n\n        result = list(mi.side_effect(func, range(10), 2))\n        self.assertEqual(result, list(range(10)))\n        self.assertEqual(counter[0], 5)\n\n    def test_before_after(self):\n        f = StringIO()\n        collector = []\n\n        def func(item):\n            print(item, file=f)\n            collector.append(f.getvalue())\n\n        def it():\n            yield 'a'\n            yield 'b'\n            raise RuntimeError('kaboom')\n\n        before = lambda: print('HEADER', file=f)\n        after = f.close\n\n        try:\n            mi.consume(mi.side_effect(func, it(), before=before, after=after))\n        except RuntimeError:\n            pass\n\n        # The iterable should have been written to the file\n        self.assertEqual(collector, ['HEADER\\na\\n', 'HEADER\\na\\nb\\n'])\n\n        # The file should be closed even though something bad happened\n        self.assertTrue(f.closed)\n\n    def test_before_fails(self):\n        f = StringIO()\n        func = lambda x: print(x, file=f)\n\n        def before():\n            raise RuntimeError('ouch')\n\n        try:\n            mi.consume(\n                mi.side_effect(func, 'abc', before=before, after=f.close)\n            )\n        except RuntimeError:\n            pass\n\n        # The file should be closed even though something bad happened in the\n        # before function\n        self.assertTrue(f.closed)\n\n\nclass SlicedTests(TestCase):\n    \"\"\"Tests for ``sliced()``\"\"\"\n\n    def test_even(self):\n        \"\"\"Test when the length of the sequence is divisible by *n*\"\"\"\n        seq = 'ABCDEFGHI'\n        self.assertEqual(list(mi.sliced(seq, 3)), ['ABC', 'DEF', 'GHI'])\n\n    def test_odd(self):\n        \"\"\"Test when the length of the sequence is not divisible by *n*\"\"\"\n        seq = 'ABCDEFGHI'\n        self.assertEqual(list(mi.sliced(seq, 4)), ['ABCD', 'EFGH', 'I'])\n\n    def test_not_sliceable(self):\n        seq = (x for x in 'ABCDEFGHI')\n\n        with self.assertRaises(TypeError):\n            list(mi.sliced(seq, 3))\n\n    def test_odd_and_strict(self):\n        seq = [x for x in 'ABCDEFGHI']\n\n        with self.assertRaises(ValueError):\n            list(mi.sliced(seq, 4, strict=True))\n\n    def test_numpy_like_array(self):\n        # Numpy arrays don't behave like Python lists - calling bool()\n        # on them doesn't return False for empty lists and True for non-empty\n        # ones. Emulate that behavior.\n        class FalseList(list):\n            def __getitem__(self, key):\n                ret = super().__getitem__(key)\n                if isinstance(key, slice):\n                    return FalseList(ret)\n\n                return ret\n\n            def __bool__(self):\n                return False\n\n        seq = FalseList(range(9))\n        actual = list(mi.sliced(seq, 3))\n        expected = [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n        self.assertEqual(actual, expected)\n\n\nclass SplitAtTests(TestCase):\n    def test_basic(self):\n        for iterable, separator in [\n            ('a,bb,ccc,dddd', ','),\n            (',a,bb,ccc,dddd', ','),\n            ('a,bb,ccc,dddd,', ','),\n            ('a,bb,ccc,,dddd', ','),\n            ('', ','),\n            (',', ','),\n            ('a,bb,ccc,dddd', ';'),\n        ]:\n            with self.subTest(iterable=iterable, separator=separator):\n                it = iter(iterable)\n                pred = lambda x: x == separator\n                actual = [''.join(x) for x in mi.split_at(it, pred)]\n                expected = iterable.split(separator)\n                self.assertEqual(actual, expected)\n\n    def test_maxsplit(self):\n        iterable = 'a,bb,ccc,dddd'\n        separator = ','\n        pred = lambda x: x == separator\n\n        for maxsplit in range(-1, 4):\n            with self.subTest(maxsplit=maxsplit):\n                it = iter(iterable)\n                result = mi.split_at(it, pred, maxsplit=maxsplit)\n                actual = [''.join(x) for x in result]\n                expected = iterable.split(separator, maxsplit)\n                self.assertEqual(actual, expected)\n\n    def test_keep_separator(self):\n        separator = ','\n        pred = lambda x: x == separator\n\n        for iterable, expected in [\n            ('a,bb,ccc', ['a', ',', 'bb', ',', 'ccc']),\n            (',a,bb,ccc', ['', ',', 'a', ',', 'bb', ',', 'ccc']),\n            ('a,bb,ccc,', ['a', ',', 'bb', ',', 'ccc', ',', '']),\n        ]:\n            with self.subTest(iterable=iterable):\n                it = iter(iterable)\n                result = mi.split_at(it, pred, keep_separator=True)\n                actual = [''.join(x) for x in result]\n                self.assertEqual(actual, expected)\n\n    def test_combination(self):\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n        pred = lambda x: x % 3 == 0\n        actual = list(\n            mi.split_at(iterable, pred, maxsplit=2, keep_separator=True)\n        )\n        expected = [[1, 2], [3], [4, 5], [6], [7, 8, 9, 10]]\n        self.assertEqual(actual, expected)\n\n\nclass SplitBeforeTest(TestCase):\n    \"\"\"Tests for ``split_before()``\"\"\"\n\n    def test_starts_with_sep(self):\n        actual = list(mi.split_before('xooxoo', lambda c: c == 'x'))\n        expected = [['x', 'o', 'o'], ['x', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_ends_with_sep(self):\n        actual = list(mi.split_before('ooxoox', lambda c: c == 'x'))\n        expected = [['o', 'o'], ['x', 'o', 'o'], ['x']]\n        self.assertEqual(actual, expected)\n\n    def test_no_sep(self):\n        actual = list(mi.split_before('ooo', lambda c: c == 'x'))\n        expected = [['o', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_empty_collection(self):\n        actual = list(mi.split_before([], lambda c: bool(c)))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_max_split(self):\n        for args, expected in [\n            (\n                ('a,b,c,d', lambda c: c == ',', -1),\n                [['a'], [',', 'b'], [',', 'c'], [',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 0),\n                [['a', ',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 1),\n                [['a'], [',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 2),\n                [['a'], [',', 'b'], [',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 10),\n                [['a'], [',', 'b'], [',', 'c'], [',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == '@', 2),\n                [['a', ',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c != ',', 2),\n                [['a', ','], ['b', ','], ['c', ',', 'd']],\n            ),\n        ]:\n            actual = list(mi.split_before(*args))\n            self.assertEqual(actual, expected)\n\n\nclass SplitAfterTest(TestCase):\n    \"\"\"Tests for ``split_after()``\"\"\"\n\n    def test_starts_with_sep(self):\n        actual = list(mi.split_after('xooxoo', lambda c: c == 'x'))\n        expected = [['x'], ['o', 'o', 'x'], ['o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_ends_with_sep(self):\n        actual = list(mi.split_after('ooxoox', lambda c: c == 'x'))\n        expected = [['o', 'o', 'x'], ['o', 'o', 'x']]\n        self.assertEqual(actual, expected)\n\n    def test_no_sep(self):\n        actual = list(mi.split_after('ooo', lambda c: c == 'x'))\n        expected = [['o', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_max_split(self):\n        for args, expected in [\n            (\n                ('a,b,c,d', lambda c: c == ',', -1),\n                [['a', ','], ['b', ','], ['c', ','], ['d']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 0),\n                [['a', ',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 1),\n                [['a', ','], ['b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 2),\n                [['a', ','], ['b', ','], ['c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == ',', 10),\n                [['a', ','], ['b', ','], ['c', ','], ['d']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c == '@', 2),\n                [['a', ',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda c: c != ',', 2),\n                [['a'], [',', 'b'], [',', 'c', ',', 'd']],\n            ),\n            (\n                ([1], lambda x: x == 1, 1),\n                [[1]],\n            ),\n        ]:\n            actual = list(mi.split_after(*args))\n            self.assertEqual(actual, expected)\n\n\nclass SplitWhenTests(TestCase):\n    \"\"\"Tests for ``split_when()``\"\"\"\n\n    @staticmethod\n    def _split_when_before(iterable, pred):\n        return mi.split_when(iterable, lambda _, c: pred(c))\n\n    @staticmethod\n    def _split_when_after(iterable, pred):\n        return mi.split_when(iterable, lambda c, _: pred(c))\n\n    # split_before emulation\n    def test_before_emulation_starts_with_sep(self):\n        actual = list(self._split_when_before('xooxoo', lambda c: c == 'x'))\n        expected = [['x', 'o', 'o'], ['x', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_before_emulation_ends_with_sep(self):\n        actual = list(self._split_when_before('ooxoox', lambda c: c == 'x'))\n        expected = [['o', 'o'], ['x', 'o', 'o'], ['x']]\n        self.assertEqual(actual, expected)\n\n    def test_before_emulation_no_sep(self):\n        actual = list(self._split_when_before('ooo', lambda c: c == 'x'))\n        expected = [['o', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    # split_after emulation\n    def test_after_emulation_starts_with_sep(self):\n        actual = list(self._split_when_after('xooxoo', lambda c: c == 'x'))\n        expected = [['x'], ['o', 'o', 'x'], ['o', 'o']]\n        self.assertEqual(actual, expected)\n\n    def test_after_emulation_ends_with_sep(self):\n        actual = list(self._split_when_after('ooxoox', lambda c: c == 'x'))\n        expected = [['o', 'o', 'x'], ['o', 'o', 'x']]\n        self.assertEqual(actual, expected)\n\n    def test_after_emulation_no_sep(self):\n        actual = list(self._split_when_after('ooo', lambda c: c == 'x'))\n        expected = [['o', 'o', 'o']]\n        self.assertEqual(actual, expected)\n\n    # edge cases\n    def test_empty_iterable(self):\n        actual = list(mi.split_when('', lambda a, b: a != b))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_one_element(self):\n        actual = list(mi.split_when('o', lambda a, b: a == b))\n        expected = [['o']]\n        self.assertEqual(actual, expected)\n\n    def test_one_element_is_second_item(self):\n        actual = list(self._split_when_before('x', lambda c: c == 'x'))\n        expected = [['x']]\n        self.assertEqual(actual, expected)\n\n    def test_one_element_is_first_item(self):\n        actual = list(self._split_when_after('x', lambda c: c == 'x'))\n        expected = [['x']]\n        self.assertEqual(actual, expected)\n\n    def test_max_split(self):\n        for args, expected in [\n            (\n                ('a,b,c,d', lambda a, _: a == ',', -1),\n                [['a', ','], ['b', ','], ['c', ','], ['d']],\n            ),\n            (\n                ('a,b,c,d', lambda a, _: a == ',', 0),\n                [['a', ',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda _, b: b == ',', 1),\n                [['a'], [',', 'b', ',', 'c', ',', 'd']],\n            ),\n            (\n                ('a,b,c,d', lambda a, _: a == ',', 2),\n                [['a', ','], ['b', ','], ['c', ',', 'd']],\n            ),\n            (\n                ('0124376', lambda a, b: a > b, -1),\n                [['0', '1', '2', '4'], ['3', '7'], ['6']],\n            ),\n            (\n                ('0124376', lambda a, b: a > b, 0),\n                [['0', '1', '2', '4', '3', '7', '6']],\n            ),\n            (\n                ('0124376', lambda a, b: a > b, 1),\n                [['0', '1', '2', '4'], ['3', '7', '6']],\n            ),\n            (\n                ('0124376', lambda a, b: a > b, 2),\n                [['0', '1', '2', '4'], ['3', '7'], ['6']],\n            ),\n        ]:\n            actual = list(mi.split_when(*args))\n            self.assertEqual(actual, expected, str(args))\n\n\nclass SplitIntoTests(TestCase):\n    \"\"\"Tests for ``split_into()``\"\"\"\n\n    def test_iterable_just_right(self):\n        \"\"\"Size of ``iterable`` equals the sum of ``sizes``.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [2, 3, 4]\n        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_iterable_too_small(self):\n        \"\"\"Size of ``iterable`` is smaller than sum of ``sizes``. Last return\n        list is shorter as a result.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7]\n        sizes = [2, 3, 4]\n        expected = [[1, 2], [3, 4, 5], [6, 7]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_iterable_too_small_extra(self):\n        \"\"\"Size of ``iterable`` is smaller than sum of ``sizes``. Second last\n        return list is shorter and last return list is empty as a result.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7]\n        sizes = [2, 3, 4, 5]\n        expected = [[1, 2], [3, 4, 5], [6, 7], []]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_iterable_too_large(self):\n        \"\"\"Size of ``iterable`` is larger than sum of ``sizes``. Not all\n        items of iterable are returned.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [2, 3, 2]\n        expected = [[1, 2], [3, 4, 5], [6, 7]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_using_none_with_leftover(self):\n        \"\"\"Last item of ``sizes`` is None when items still remain in\n        ``iterable``. Last list returned stretches to fit all remaining items\n        of ``iterable``.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [2, 3, None]\n        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_using_none_without_leftover(self):\n        \"\"\"Last item of ``sizes`` is None when no items remain in\n        ``iterable``. Last list returned is empty.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [2, 3, 4, None]\n        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9], []]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_using_none_mid_sizes(self):\n        \"\"\"None is present in ``sizes`` but is not the last item. Last list\n        returned stretches to fit all remaining items of ``iterable`` but\n        all items in ``sizes`` after None are ignored.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [2, 3, None, 4]\n        expected = [[1, 2], [3, 4, 5], [6, 7, 8, 9]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_iterable_empty(self):\n        \"\"\"``iterable`` argument is empty but ``sizes`` is not. An empty\n        list is returned for each item in ``sizes``.\"\"\"\n        iterable = []\n        sizes = [2, 4, 2]\n        expected = [[], [], []]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_iterable_empty_using_none(self):\n        \"\"\"``iterable`` argument is empty but ``sizes`` is not. An empty\n        list is returned for each item in ``sizes`` that is not after a\n        None item.\"\"\"\n        iterable = []\n        sizes = [2, 4, None, 2]\n        expected = [[], [], []]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_sizes_empty(self):\n        \"\"\"``sizes`` argument is empty but ``iterable`` is not. An empty\n        generator is returned.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = []\n        expected = []\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_both_empty(self):\n        \"\"\"Both ``sizes`` and ``iterable`` arguments are empty. An empty\n        generator is returned.\"\"\"\n        iterable = []\n        sizes = []\n        expected = []\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_bool_in_sizes(self):\n        \"\"\"A bool object is present in ``sizes`` is treated as a 1 or 0 for\n        ``True`` or ``False`` due to bool being an instance of int.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [3, True, 2, False]\n        expected = [[1, 2, 3], [4], [5, 6], []]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_invalid_in_sizes(self):\n        \"\"\"A ValueError is raised if an object in ``sizes`` is neither ``None``\n        or an integer.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [1, [], 3]\n        with self.assertRaises(ValueError):\n            list(mi.split_into(iterable, sizes))\n\n    def test_invalid_in_sizes_after_none(self):\n        \"\"\"A item in ``sizes`` that is invalid will not raise a TypeError if it\n        comes after a ``None`` item.\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = [3, 4, None, []]\n        expected = [[1, 2, 3], [4, 5, 6, 7], [8, 9]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n    def test_generator_iterable_integrity(self):\n        \"\"\"Check that if ``iterable`` is an iterator, it is consumed only by as\n        many items as the sum of ``sizes``.\"\"\"\n        iterable = (i for i in range(10))\n        sizes = [2, 3]\n\n        expected = [[0, 1], [2, 3, 4]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n        iterable_expected = [5, 6, 7, 8, 9]\n        iterable_actual = list(iterable)\n        self.assertEqual(iterable_actual, iterable_expected)\n\n    def test_generator_sizes_integrity(self):\n        \"\"\"Check that if ``sizes`` is an iterator, it is consumed only until a\n        ``None`` item is reached\"\"\"\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        sizes = (i for i in [1, 2, None, 3, 4])\n\n        expected = [[1], [2, 3], [4, 5, 6, 7, 8, 9]]\n        actual = list(mi.split_into(iterable, sizes))\n        self.assertEqual(actual, expected)\n\n        sizes_expected = [3, 4]\n        sizes_actual = list(sizes)\n        self.assertEqual(sizes_actual, sizes_expected)\n\n\nclass PaddedTest(TestCase):\n    \"\"\"Tests for ``padded()``\"\"\"\n\n    def test_no_n(self):\n        seq = [1, 2, 3]\n\n        # No fillvalue\n        self.assertEqual(mi.take(5, mi.padded(seq)), [1, 2, 3, None, None])\n\n        # With fillvalue\n        self.assertEqual(\n            mi.take(5, mi.padded(seq, fillvalue='')), [1, 2, 3, '', '']\n        )\n\n    def test_invalid_n(self):\n        self.assertRaises(ValueError, lambda: list(mi.padded([1, 2, 3], n=-1)))\n        self.assertRaises(ValueError, lambda: list(mi.padded([1, 2, 3], n=0)))\n\n    def test_valid_n(self):\n        seq = [1, 2, 3, 4, 5]\n\n        # No need for padding: len(seq) <= n\n        self.assertEqual(list(mi.padded(seq, n=4)), [1, 2, 3, 4, 5])\n        self.assertEqual(list(mi.padded(seq, n=5)), [1, 2, 3, 4, 5])\n\n        # No fillvalue\n        self.assertEqual(\n            list(mi.padded(seq, n=7)), [1, 2, 3, 4, 5, None, None]\n        )\n\n        # With fillvalue\n        self.assertEqual(\n            list(mi.padded(seq, fillvalue='', n=7)), [1, 2, 3, 4, 5, '', '']\n        )\n\n    def test_next_multiple(self):\n        seq = [1, 2, 3, 4, 5, 6]\n\n        # No need for padding: len(seq) % n == 0\n        self.assertEqual(\n            list(mi.padded(seq, n=3, next_multiple=True)), [1, 2, 3, 4, 5, 6]\n        )\n\n        # Padding needed: len(seq) < n\n        self.assertEqual(\n            list(mi.padded(seq, n=8, next_multiple=True)),\n            [1, 2, 3, 4, 5, 6, None, None],\n        )\n\n        # No padding needed: len(seq) == n\n        self.assertEqual(\n            list(mi.padded(seq, n=6, next_multiple=True)), [1, 2, 3, 4, 5, 6]\n        )\n\n        # Padding needed: len(seq) > n\n        self.assertEqual(\n            list(mi.padded(seq, n=4, next_multiple=True)),\n            [1, 2, 3, 4, 5, 6, None, None],\n        )\n\n        # With fillvalue\n        self.assertEqual(\n            list(mi.padded(seq, fillvalue='', n=4, next_multiple=True)),\n            [1, 2, 3, 4, 5, 6, '', ''],\n        )\n\n\nclass RepeatEachTests(TestCase):\n    \"\"\"Tests for repeat_each()\"\"\"\n\n    def test_default(self):\n        actual = list(mi.repeat_each('ABC'))\n        expected = ['A', 'A', 'B', 'B', 'C', 'C']\n        self.assertEqual(actual, expected)\n\n    def test_basic(self):\n        actual = list(mi.repeat_each('ABC', 3))\n        expected = ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n        self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        actual = list(mi.repeat_each(''))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_no_repeat(self):\n        actual = list(mi.repeat_each('ABC', 0))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_negative_repeat(self):\n        actual = list(mi.repeat_each('ABC', -1))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_infinite_input(self):\n        repeater = mi.repeat_each(cycle('AB'))\n        actual = mi.take(6, repeater)\n        expected = ['A', 'A', 'B', 'B', 'A', 'A']\n        self.assertEqual(actual, expected)\n\n\nclass RepeatLastTests(TestCase):\n    def test_empty_iterable(self):\n        slice_length = 3\n        iterable = iter([])\n        actual = mi.take(slice_length, mi.repeat_last(iterable))\n        expected = [None] * slice_length\n        self.assertEqual(actual, expected)\n\n    def test_default_value(self):\n        slice_length = 3\n        iterable = iter([])\n        default = '3'\n        actual = mi.take(slice_length, mi.repeat_last(iterable, default))\n        expected = ['3'] * slice_length\n        self.assertEqual(actual, expected)\n\n    def test_basic(self):\n        slice_length = 10\n        iterable = (str(x) for x in range(5))\n        actual = mi.take(slice_length, mi.repeat_last(iterable))\n        expected = ['0', '1', '2', '3', '4', '4', '4', '4', '4', '4']\n        self.assertEqual(actual, expected)\n\n\nclass DistributeTest(TestCase):\n    \"\"\"Tests for distribute()\"\"\"\n\n    def test_invalid_n(self):\n        self.assertRaises(ValueError, lambda: mi.distribute(-1, [1, 2, 3]))\n        self.assertRaises(ValueError, lambda: mi.distribute(0, [1, 2, 3]))\n\n    def test_basic(self):\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n        for n, expected in [\n            (1, [iterable]),\n            (2, [[1, 3, 5, 7, 9], [2, 4, 6, 8, 10]]),\n            (3, [[1, 4, 7, 10], [2, 5, 8], [3, 6, 9]]),\n            (10, [[n] for n in range(1, 10 + 1)]),\n        ]:\n            self.assertEqual(\n                [list(x) for x in mi.distribute(n, iterable)], expected\n            )\n\n    def test_large_n(self):\n        iterable = [1, 2, 3, 4]\n        self.assertEqual(\n            [list(x) for x in mi.distribute(6, iterable)],\n            [[1], [2], [3], [4], [], []],\n        )\n\n\nclass StaggerTest(TestCase):\n    \"\"\"Tests for ``stagger()``\"\"\"\n\n    def test_default(self):\n        iterable = [0, 1, 2, 3]\n        actual = list(mi.stagger(iterable))\n        expected = [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        self.assertEqual(actual, expected)\n\n    def test_offsets(self):\n        iterable = [0, 1, 2, 3]\n        for offsets, expected in [\n            ((-2, 0, 2), [('', 0, 2), ('', 1, 3)]),\n            ((-2, -1), [('', ''), ('', 0), (0, 1), (1, 2), (2, 3)]),\n            ((1, 2), [(1, 2), (2, 3)]),\n        ]:\n            all_groups = mi.stagger(iterable, offsets=offsets, fillvalue='')\n            self.assertEqual(list(all_groups), expected)\n\n    def test_longest(self):\n        iterable = [0, 1, 2, 3]\n        for offsets, expected in [\n            (\n                (-1, 0, 1),\n                [('', 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, ''), (3, '', '')],\n            ),\n            ((-2, -1), [('', ''), ('', 0), (0, 1), (1, 2), (2, 3), (3, '')]),\n            ((1, 2), [(1, 2), (2, 3), (3, '')]),\n        ]:\n            all_groups = mi.stagger(\n                iterable, offsets=offsets, fillvalue='', longest=True\n            )\n            self.assertEqual(list(all_groups), expected)\n\n\nclass ZipEqualTest(TestCase):\n    @skipIf(version_info[:2] < (3, 10), 'zip_equal deprecated for 3.10+')\n    def test_deprecation(self):\n        with warnings.catch_warnings(record=True) as caught:\n            warnings.simplefilter('always')\n            self.assertEqual(\n                list(mi.zip_equal([1, 2], [3, 4])), [(1, 3), (2, 4)]\n            )\n\n        (warning,) = caught\n        assert warning.category == DeprecationWarning\n\n    def test_equal(self):\n        lists = [0, 1, 2], [2, 3, 4]\n\n        for iterables in [lists, map(iter, lists)]:\n            actual = list(mi.zip_equal(*iterables))\n            expected = [(0, 2), (1, 3), (2, 4)]\n            self.assertEqual(actual, expected)\n\n    def test_unequal_lists(self):\n        two_items = [0, 1]\n        three_items = [2, 3, 4]\n        four_items = [5, 6, 7, 8]\n\n        # the mismatch is at index 1\n        try:\n            list(mi.zip_equal(two_items, three_items, four_items))\n        except mi.UnequalIterablesError as e:\n            self.assertEqual(\n                e.args[0],\n                (\n                    'Iterables have different lengths: '\n                    'index 0 has length 2; index 1 has length 3'\n                ),\n            )\n\n        # the mismatch is at index 2\n        try:\n            list(mi.zip_equal(two_items, two_items, four_items, four_items))\n        except mi.UnequalIterablesError as e:\n            self.assertEqual(\n                e.args[0],\n                (\n                    'Iterables have different lengths: '\n                    'index 0 has length 2; index 2 has length 4'\n                ),\n            )\n\n        # One without length: delegate to _zip_equal_generator\n        try:\n            list(mi.zip_equal(two_items, iter(two_items), three_items))\n        except mi.UnequalIterablesError as e:\n            self.assertEqual(e.args[0], 'Iterables have different lengths')\n\n\nclass ZipOffsetTest(TestCase):\n    \"\"\"Tests for ``zip_offset()``\"\"\"\n\n    def test_shortest(self):\n        a_1 = [0, 1, 2, 3]\n        a_2 = [0, 1, 2, 3, 4, 5]\n        a_3 = [0, 1, 2, 3, 4, 5, 6, 7]\n        actual = list(\n            mi.zip_offset(a_1, a_2, a_3, offsets=(-1, 0, 1), fillvalue='')\n        )\n        expected = [('', 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, 4), (3, 4, 5)]\n        self.assertEqual(actual, expected)\n\n    def test_longest(self):\n        a_1 = [0, 1, 2, 3]\n        a_2 = [0, 1, 2, 3, 4, 5]\n        a_3 = [0, 1, 2, 3, 4, 5, 6, 7]\n        actual = list(\n            mi.zip_offset(a_1, a_2, a_3, offsets=(-1, 0, 1), longest=True)\n        )\n        expected = [\n            (None, 0, 1),\n            (0, 1, 2),\n            (1, 2, 3),\n            (2, 3, 4),\n            (3, 4, 5),\n            (None, 5, 6),\n            (None, None, 7),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_mismatch(self):\n        iterables = [0, 1, 2], [2, 3, 4]\n        offsets = (-1, 0, 1)\n        self.assertRaises(\n            ValueError,\n            lambda: list(mi.zip_offset(*iterables, offsets=offsets)),\n        )\n\n\nclass UnzipTests(TestCase):\n    \"\"\"Tests for unzip()\"\"\"\n\n    def test_empty_iterable(self):\n        self.assertEqual(list(mi.unzip([])), [])\n        # in reality zip([], [], []) is equivalent to iter([])\n        # but it doesn't hurt to test both\n        self.assertEqual(list(mi.unzip(zip([], [], []))), [])\n\n    def test_length_one_iterable(self):\n        xs, ys, zs = mi.unzip(zip([1], [2], [3]))\n        self.assertEqual(list(xs), [1])\n        self.assertEqual(list(ys), [2])\n        self.assertEqual(list(zs), [3])\n\n    def test_normal_case(self):\n        xs, ys, zs = range(10), range(1, 11), range(2, 12)\n        zipped = zip(xs, ys, zs)\n        xs, ys, zs = mi.unzip(zipped)\n        self.assertEqual(list(xs), list(range(10)))\n        self.assertEqual(list(ys), list(range(1, 11)))\n        self.assertEqual(list(zs), list(range(2, 12)))\n\n    def test_improperly_zipped(self):\n        zipped = iter([(1, 2, 3), (4, 5), (6,)])\n        xs, ys, zs = mi.unzip(zipped)\n        self.assertEqual(list(xs), [1, 4, 6])\n        self.assertEqual(list(ys), [2, 5])\n        self.assertEqual(list(zs), [3])\n\n    def test_increasingly_zipped(self):\n        zipped = iter([(1, 2), (3, 4, 5), (6, 7, 8, 9)])\n        unzipped = mi.unzip(zipped)\n        # from the docstring:\n        # len(first tuple) is the number of iterables zipped\n        self.assertEqual(len(unzipped), 2)\n        xs, ys = unzipped\n        self.assertEqual(list(xs), [1, 3, 6])\n        self.assertEqual(list(ys), [2, 4, 7])\n\n\nclass SortTogetherTest(TestCase):\n    \"\"\"Tests for sort_together()\"\"\"\n\n    def test_key_list(self):\n        \"\"\"tests `key_list` including default, iterables include duplicates\"\"\"\n        iterables = [\n            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],\n            ['May', 'Aug.', 'May', 'June', 'July', 'July'],\n            [97, 20, 100, 70, 100, 20],\n        ]\n\n        self.assertEqual(\n            mi.sort_together(iterables),\n            [\n                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),\n                ('June', 'July', 'July', 'May', 'Aug.', 'May'),\n                (70, 100, 20, 97, 20, 100),\n            ],\n        )\n\n        self.assertEqual(\n            mi.sort_together(iterables, key_list=(0, 1)),\n            [\n                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),\n                ('July', 'July', 'June', 'Aug.', 'May', 'May'),\n                (100, 20, 70, 20, 97, 100),\n            ],\n        )\n\n        self.assertEqual(\n            mi.sort_together(iterables, key_list=(0, 1, 2)),\n            [\n                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),\n                ('July', 'July', 'June', 'Aug.', 'May', 'May'),\n                (20, 100, 70, 20, 97, 100),\n            ],\n        )\n\n        self.assertEqual(\n            mi.sort_together(iterables, key_list=(2,)),\n            [\n                ('GA', 'CT', 'CT', 'GA', 'GA', 'CT'),\n                ('Aug.', 'July', 'June', 'May', 'May', 'July'),\n                (20, 20, 70, 97, 100, 100),\n            ],\n        )\n\n    def test_invalid_key_list(self):\n        \"\"\"tests `key_list` for indexes not available in `iterables`\"\"\"\n        iterables = [\n            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],\n            ['May', 'Aug.', 'May', 'June', 'July', 'July'],\n            [97, 20, 100, 70, 100, 20],\n        ]\n\n        self.assertRaises(\n            IndexError, lambda: mi.sort_together(iterables, key_list=(5,))\n        )\n\n    def test_key_function(self):\n        \"\"\"tests `key` function, including interaction with `key_list`\"\"\"\n        iterables = [\n            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],\n            ['May', 'Aug.', 'May', 'June', 'July', 'July'],\n            [97, 20, 100, 70, 100, 20],\n        ]\n        self.assertEqual(\n            mi.sort_together(iterables, key=lambda x: x),\n            [\n                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),\n                ('June', 'July', 'July', 'May', 'Aug.', 'May'),\n                (70, 100, 20, 97, 20, 100),\n            ],\n        )\n        self.assertEqual(\n            mi.sort_together(iterables, key=lambda x: x[::-1]),\n            [\n                ('GA', 'GA', 'GA', 'CT', 'CT', 'CT'),\n                ('May', 'Aug.', 'May', 'June', 'July', 'July'),\n                (97, 20, 100, 70, 100, 20),\n            ],\n        )\n        self.assertEqual(\n            mi.sort_together(\n                iterables,\n                key_list=(0, 2),\n                key=lambda state, number: (\n                    number if state == 'CT' else 2 * number\n                ),\n            ),\n            [\n                ('CT', 'GA', 'CT', 'CT', 'GA', 'GA'),\n                ('July', 'Aug.', 'June', 'July', 'May', 'May'),\n                (20, 20, 70, 100, 97, 100),\n            ],\n        )\n\n    def test_reverse(self):\n        \"\"\"tests `reverse` to ensure a reverse sort for `key_list` iterables\"\"\"\n        iterables = [\n            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT'],\n            ['May', 'Aug.', 'May', 'June', 'July', 'July'],\n            [97, 20, 100, 70, 100, 20],\n        ]\n\n        self.assertEqual(\n            mi.sort_together(iterables, key_list=(0, 1, 2), reverse=True),\n            [\n                ('GA', 'GA', 'GA', 'CT', 'CT', 'CT'),\n                ('May', 'May', 'Aug.', 'June', 'July', 'July'),\n                (100, 97, 20, 70, 100, 20),\n            ],\n        )\n\n    def test_uneven_iterables(self):\n        \"\"\"tests trimming of iterables to the shortest length before sorting\"\"\"\n        iterables = [\n            ['GA', 'GA', 'GA', 'CT', 'CT', 'CT', 'MA'],\n            ['May', 'Aug.', 'May', 'June', 'July', 'July'],\n            [97, 20, 100, 70, 100, 20, 0],\n        ]\n\n        self.assertEqual(\n            mi.sort_together(iterables),\n            [\n                ('CT', 'CT', 'CT', 'GA', 'GA', 'GA'),\n                ('June', 'July', 'July', 'May', 'Aug.', 'May'),\n                (70, 100, 20, 97, 20, 100),\n            ],\n        )\n\n\nclass DivideTest(TestCase):\n    \"\"\"Tests for divide()\"\"\"\n\n    def test_invalid_n(self):\n        self.assertRaises(ValueError, lambda: mi.divide(-1, [1, 2, 3]))\n        self.assertRaises(ValueError, lambda: mi.divide(0, [1, 2, 3]))\n\n    def test_basic(self):\n        iterable = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n        for n, expected in [\n            (1, [iterable]),\n            (2, [[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]]),\n            (3, [[1, 2, 3, 4], [5, 6, 7], [8, 9, 10]]),\n            (10, [[n] for n in range(1, 10 + 1)]),\n        ]:\n            self.assertEqual(\n                [list(x) for x in mi.divide(n, iterable)], expected\n            )\n\n    def test_large_n(self):\n        self.assertEqual(\n            [list(x) for x in mi.divide(6, iter(range(1, 4 + 1)))],\n            [[1], [2], [3], [4], [], []],\n        )\n\n\nclass TestAlwaysIterable(TestCase):\n    \"\"\"Tests for always_iterable()\"\"\"\n\n    def test_single(self):\n        self.assertEqual(list(mi.always_iterable(1)), [1])\n\n    def test_strings(self):\n        for obj in ['foo', b'bar', 'baz']:\n            actual = list(mi.always_iterable(obj))\n            expected = [obj]\n            self.assertEqual(actual, expected)\n\n    def test_base_type(self):\n        dict_obj = {'a': 1, 'b': 2}\n        str_obj = '123'\n\n        # Default: dicts are iterable like they normally are\n        default_actual = list(mi.always_iterable(dict_obj))\n        default_expected = list(dict_obj)\n        self.assertEqual(default_actual, default_expected)\n\n        # Unitary types set: dicts are not iterable\n        custom_actual = list(mi.always_iterable(dict_obj, base_type=dict))\n        custom_expected = [dict_obj]\n        self.assertEqual(custom_actual, custom_expected)\n\n        # With unitary types set, strings are iterable\n        str_actual = list(mi.always_iterable(str_obj, base_type=None))\n        str_expected = list(str_obj)\n        self.assertEqual(str_actual, str_expected)\n\n        # base_type handles nested tuple (via isinstance).\n        base_type = ((dict,),)\n        custom_actual = list(mi.always_iterable(dict_obj, base_type=base_type))\n        custom_expected = [dict_obj]\n        self.assertEqual(custom_actual, custom_expected)\n\n    def test_iterables(self):\n        self.assertEqual(list(mi.always_iterable([0, 1])), [0, 1])\n        self.assertEqual(\n            list(mi.always_iterable([0, 1], base_type=list)), [[0, 1]]\n        )\n        self.assertEqual(\n            list(mi.always_iterable(iter('foo'))), ['f', 'o', 'o']\n        )\n        self.assertEqual(list(mi.always_iterable([])), [])\n\n    def test_none(self):\n        self.assertEqual(list(mi.always_iterable(None)), [])\n\n    def test_generator(self):\n        def _gen():\n            yield 0\n            yield 1\n\n        self.assertEqual(list(mi.always_iterable(_gen())), [0, 1])\n\n\nclass AdjacentTests(TestCase):\n    def test_typical(self):\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, range(10)))\n        expected = [\n            (True, 0),\n            (True, 1),\n            (False, 2),\n            (False, 3),\n            (True, 4),\n            (True, 5),\n            (True, 6),\n            (False, 7),\n            (False, 8),\n            (False, 9),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_empty_iterable(self):\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, []))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_length_one(self):\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, [0]))\n        expected = [(True, 0)]\n        self.assertEqual(actual, expected)\n\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, [1]))\n        expected = [(False, 1)]\n        self.assertEqual(actual, expected)\n\n    def test_consecutive_true(self):\n        \"\"\"Test that when the predicate matches multiple consecutive elements\n        it doesn't repeat elements in the output\"\"\"\n        actual = list(mi.adjacent(lambda x: x % 5 < 2, range(10)))\n        expected = [\n            (True, 0),\n            (True, 1),\n            (True, 2),\n            (False, 3),\n            (True, 4),\n            (True, 5),\n            (True, 6),\n            (True, 7),\n            (False, 8),\n            (False, 9),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_distance(self):\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, range(10), distance=2))\n        expected = [\n            (True, 0),\n            (True, 1),\n            (True, 2),\n            (True, 3),\n            (True, 4),\n            (True, 5),\n            (True, 6),\n            (True, 7),\n            (False, 8),\n            (False, 9),\n        ]\n        self.assertEqual(actual, expected)\n\n        actual = list(mi.adjacent(lambda x: x % 5 == 0, range(10), distance=3))\n        expected = [\n            (True, 0),\n            (True, 1),\n            (True, 2),\n            (True, 3),\n            (True, 4),\n            (True, 5),\n            (True, 6),\n            (True, 7),\n            (True, 8),\n            (False, 9),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_large_distance(self):\n        \"\"\"Test distance larger than the length of the iterable\"\"\"\n        iterable = range(10)\n        actual = list(mi.adjacent(lambda x: x % 5 == 4, iterable, distance=20))\n        expected = list(zip(repeat(True), iterable))\n        self.assertEqual(actual, expected)\n\n        actual = list(mi.adjacent(lambda x: False, iterable, distance=20))\n        expected = list(zip(repeat(False), iterable))\n        self.assertEqual(actual, expected)\n\n    def test_zero_distance(self):\n        \"\"\"Test that adjacent() reduces to zip+map when distance is 0\"\"\"\n        iterable = range(1000)\n        predicate = lambda x: x % 4 == 2\n        actual = mi.adjacent(predicate, iterable, 0)\n        expected = zip(map(predicate, iterable), iterable)\n        self.assertTrue(all(a == e for a, e in zip(actual, expected)))\n\n    def test_negative_distance(self):\n        \"\"\"Test that adjacent() raises an error with negative distance\"\"\"\n        pred = lambda x: x\n        self.assertRaises(\n            ValueError, lambda: mi.adjacent(pred, range(1000), -1)\n        )\n        self.assertRaises(\n            ValueError, lambda: mi.adjacent(pred, range(10), -10)\n        )\n\n    def test_grouping(self):\n        \"\"\"Test interaction of adjacent() with groupby_transform()\"\"\"\n        iterable = mi.adjacent(lambda x: x % 5 == 0, range(10))\n        grouper = mi.groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        actual = [(k, list(g)) for k, g in grouper]\n        expected = [\n            (True, [0, 1]),\n            (False, [2, 3]),\n            (True, [4, 5, 6]),\n            (False, [7, 8, 9]),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_call_once(self):\n        \"\"\"Test that the predicate is only called once per item.\"\"\"\n        already_seen = set()\n        iterable = range(10)\n\n        def predicate(item):\n            self.assertNotIn(item, already_seen)\n            already_seen.add(item)\n            return True\n\n        actual = list(mi.adjacent(predicate, iterable))\n        expected = [(True, x) for x in iterable]\n        self.assertEqual(actual, expected)\n\n\nclass GroupByTransformTests(TestCase):\n    def assertAllGroupsEqual(self, groupby1, groupby2):\n        for a, b in zip(groupby1, groupby2):\n            key1, group1 = a\n            key2, group2 = b\n            self.assertEqual(key1, key2)\n            self.assertListEqual(list(group1), list(group2))\n        self.assertRaises(StopIteration, lambda: next(groupby1))\n        self.assertRaises(StopIteration, lambda: next(groupby2))\n\n    def test_default_funcs(self):\n        iterable = [(x // 5, x) for x in range(1000)]\n        actual = mi.groupby_transform(iterable)\n        expected = groupby(iterable)\n        self.assertAllGroupsEqual(actual, expected)\n\n    def test_valuefunc(self):\n        iterable = [(int(x / 5), int(x / 3), x) for x in range(10)]\n\n        # Test the standard usage of grouping one iterable using another's keys\n        grouper = mi.groupby_transform(\n            iterable, keyfunc=itemgetter(0), valuefunc=itemgetter(-1)\n        )\n        actual = [(k, list(g)) for k, g in grouper]\n        expected = [(0, [0, 1, 2, 3, 4]), (1, [5, 6, 7, 8, 9])]\n        self.assertEqual(actual, expected)\n\n        grouper = mi.groupby_transform(\n            iterable, keyfunc=itemgetter(1), valuefunc=itemgetter(-1)\n        )\n        actual = [(k, list(g)) for k, g in grouper]\n        expected = [(0, [0, 1, 2]), (1, [3, 4, 5]), (2, [6, 7, 8]), (3, [9])]\n        self.assertEqual(actual, expected)\n\n        # and now for something a little different\n        d = dict(zip(range(10), 'abcdefghij'))\n        grouper = mi.groupby_transform(\n            range(10), keyfunc=lambda x: x // 5, valuefunc=d.get\n        )\n        actual = [(k, ''.join(g)) for k, g in grouper]\n        expected = [(0, 'abcde'), (1, 'fghij')]\n        self.assertEqual(actual, expected)\n\n    def test_no_valuefunc(self):\n        iterable = range(1000)\n\n        def key(x):\n            return x // 5\n\n        actual = mi.groupby_transform(iterable, key, valuefunc=None)\n        expected = groupby(iterable, key)\n        self.assertAllGroupsEqual(actual, expected)\n\n        actual = mi.groupby_transform(iterable, key)  # default valuefunc\n        expected = groupby(iterable, key)\n        self.assertAllGroupsEqual(actual, expected)\n\n    def test_reducefunc(self):\n        iterable = range(50)\n        keyfunc = lambda k: 10 * (k // 10)\n        valuefunc = lambda v: v + 1\n        reducefunc = sum\n        actual = list(\n            mi.groupby_transform(\n                iterable,\n                keyfunc=keyfunc,\n                valuefunc=valuefunc,\n                reducefunc=reducefunc,\n            )\n        )\n        expected = [(0, 55), (10, 155), (20, 255), (30, 355), (40, 455)]\n        self.assertEqual(actual, expected)\n\n\nclass NumericRangeTests(TestCase):\n    def test_basic(self):\n        for args, expected in [\n            ((4,), [0, 1, 2, 3]),\n            ((4.0,), [0.0, 1.0, 2.0, 3.0]),\n            ((1.0, 4), [1.0, 2.0, 3.0]),\n            ((1, 4.0), [1.0, 2.0, 3.0]),\n            ((1.0, 5), [1.0, 2.0, 3.0, 4.0]),\n            ((0, 20, 5), [0, 5, 10, 15]),\n            ((0, 20, 5.0), [0.0, 5.0, 10.0, 15.0]),\n            ((0, 10, 3), [0, 3, 6, 9]),\n            ((0, 10, 3.0), [0.0, 3.0, 6.0, 9.0]),\n            ((0, -5, -1), [0, -1, -2, -3, -4]),\n            ((0.0, -5, -1), [0.0, -1.0, -2.0, -3.0, -4.0]),\n            ((1, 2, Fraction(1, 2)), [Fraction(1, 1), Fraction(3, 2)]),\n            ((0,), []),\n            ((0.0,), []),\n            ((1, 0), []),\n            ((1.0, 0.0), []),\n            ((0.1, 0.30000000000000001, 0.2), [0.1]),  # IEE 754 !\n            (\n                (\n                    Decimal(\"0.1\"),\n                    Decimal(\"0.30000000000000001\"),\n                    Decimal(\"0.2\"),\n                ),\n                [Decimal(\"0.1\"), Decimal(\"0.3\")],\n            ),  # okay with Decimal\n            (\n                (\n                    Fraction(1, 10),\n                    Fraction(30000000000000001, 100000000000000000),\n                    Fraction(2, 10),\n                ),\n                [Fraction(1, 10), Fraction(3, 10)],\n            ),  # okay with Fraction\n            ((Fraction(2, 1),), [Fraction(0, 1), Fraction(1, 1)]),\n            ((Decimal('2.0'),), [Decimal('0.0'), Decimal('1.0')]),\n            (\n                (\n                    datetime(2019, 3, 29, 12, 34, 56),\n                    datetime(2019, 3, 29, 12, 37, 55),\n                    timedelta(minutes=1),\n                ),\n                [\n                    datetime(2019, 3, 29, 12, 34, 56),\n                    datetime(2019, 3, 29, 12, 35, 56),\n                    datetime(2019, 3, 29, 12, 36, 56),\n                ],\n            ),\n        ]:\n            actual = list(mi.numeric_range(*args))\n            self.assertEqual(expected, actual)\n            self.assertTrue(\n                all(type(a) is type(e) for a, e in zip(actual, expected))\n            )\n\n    def test_arg_count(self):\n        for args, message in [\n            ((), 'numeric_range expected at least 1 argument, got 0'),\n            (\n                (0, 1, 2, 3),\n                'numeric_range expected at most 3 arguments, got 4',\n            ),\n        ]:\n            with self.assertRaisesRegex(TypeError, message):\n                mi.numeric_range(*args)\n\n    def test_zero_step(self):\n        for args in [\n            (1, 2, 0),\n            (\n                datetime(2019, 3, 29, 12, 34, 56),\n                datetime(2019, 3, 29, 12, 37, 55),\n                timedelta(minutes=0),\n            ),\n            (1.0, 2.0, 0.0),\n            (Decimal(\"1.0\"), Decimal(\"2.0\"), Decimal(\"0.0\")),\n            (Fraction(2, 2), Fraction(4, 2), Fraction(0, 2)),\n        ]:\n            with self.assertRaises(ValueError):\n                list(mi.numeric_range(*args))\n\n    def test_bool(self):\n        for args, expected in [\n            ((1.0, 3.0, 1.5), True),\n            ((1.0, 2.0, 1.5), True),\n            ((1.0, 1.0, 1.5), False),\n            ((1.0, 0.0, 1.5), False),\n            ((3.0, 1.0, -1.5), True),\n            ((2.0, 1.0, -1.5), True),\n            ((1.0, 1.0, -1.5), False),\n            ((0.0, 1.0, -1.5), False),\n            ((Decimal(\"1.0\"), Decimal(\"2.0\"), Decimal(\"1.5\")), True),\n            ((Decimal(\"1.0\"), Decimal(\"0.0\"), Decimal(\"1.5\")), False),\n            ((Fraction(2, 2), Fraction(4, 2), Fraction(3, 2)), True),\n            ((Fraction(2, 2), Fraction(0, 2), Fraction(3, 2)), False),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=1),\n                ),\n                True,\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 28),\n                    timedelta(hours=1),\n                ),\n                False,\n            ),\n        ]:\n            self.assertEqual(expected, bool(mi.numeric_range(*args)))\n\n    def test_contains(self):\n        for args, expected_in, expected_not_in in [\n            ((10,), range(10), (0.5,)),\n            ((1.0, 9.9, 1.5), (1.0, 2.5, 4.0, 5.5, 7.0, 8.5), (0.9,)),\n            ((9.0, 1.0, -1.5), (1.5, 3.0, 4.5, 6.0, 7.5, 9.0), (0.0, 0.9)),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.9\"), Decimal(\"1.5\")),\n                (\n                    Decimal(\"1.0\"),\n                    Decimal(\"2.5\"),\n                    Decimal(\"4.0\"),\n                    Decimal(\"5.5\"),\n                    Decimal(\"7.0\"),\n                    Decimal(\"8.5\"),\n                ),\n                (Decimal(\"0.9\"),),\n            ),\n            (\n                (Fraction(0, 1), Fraction(5, 1), Fraction(1, 2)),\n                (Fraction(0, 1), Fraction(1, 2), Fraction(9, 2)),\n                (Fraction(10, 2),),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=1),\n                ),\n                (datetime(2019, 3, 29, 15),),\n                (datetime(2019, 3, 29, 15, 30),),\n            ),\n        ]:\n            r = mi.numeric_range(*args)\n            for v in expected_in:\n                self.assertTrue(v in r)\n                self.assertFalse(v not in r)\n\n            for v in expected_not_in:\n                self.assertFalse(v in r)\n                self.assertTrue(v not in r)\n\n    def test_eq(self):\n        for args1, args2 in [\n            ((0, 5, 2), (0, 6, 2)),\n            ((1.0, 9.9, 1.5), (1.0, 8.6, 1.5)),\n            ((8.5, 0.0, -1.5), (8.5, 0.7, -1.5)),\n            ((7.0, 0.0, 1.0), (17.0, 7.0, 0.5)),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.9\"), Decimal(\"1.5\")),\n                (Decimal(\"1.0\"), Decimal(\"8.6\"), Decimal(\"1.5\")),\n            ),\n            (\n                (Fraction(1, 1), Fraction(10, 1), Fraction(3, 2)),\n                (Fraction(1, 1), Fraction(9, 1), Fraction(3, 2)),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30, 1),\n                    timedelta(hours=10),\n                ),\n            ),\n        ]:\n            self.assertEqual(\n                mi.numeric_range(*args1), mi.numeric_range(*args2)\n            )\n\n        for args1, args2 in [\n            ((0, 5, 2), (0, 7, 2)),\n            ((1.0, 9.9, 1.5), (1.2, 9.9, 1.5)),\n            ((1.0, 9.9, 1.5), (1.0, 10.3, 1.5)),\n            ((1.0, 9.9, 1.5), (1.0, 9.9, 1.4)),\n            ((8.5, 0.0, -1.5), (8.4, 0.0, -1.5)),\n            ((8.5, 0.0, -1.5), (8.5, -0.7, -1.5)),\n            ((8.5, 0.0, -1.5), (8.5, 0.0, -1.4)),\n            ((0.0, 7.0, 1.0), (7.0, 0.0, 1.0)),\n            (\n                (Decimal(\"1.0\"), Decimal(\"10.0\"), Decimal(\"1.5\")),\n                (Decimal(\"1.0\"), Decimal(\"10.5\"), Decimal(\"1.5\")),\n            ),\n            (\n                (Fraction(1, 1), Fraction(10, 1), Fraction(3, 2)),\n                (Fraction(1, 1), Fraction(21, 2), Fraction(3, 2)),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30, 15),\n                    timedelta(hours=10),\n                ),\n            ),\n        ]:\n            self.assertNotEqual(\n                mi.numeric_range(*args1), mi.numeric_range(*args2)\n            )\n\n        self.assertNotEqual(mi.numeric_range(7.0), 1)\n        self.assertNotEqual(mi.numeric_range(7.0), \"abc\")\n\n    def test_get_item_by_index(self):\n        for args, index, expected in [\n            ((1, 6), 2, 3),\n            ((1.0, 6.0, 1.5), 0, 1.0),\n            ((1.0, 6.0, 1.5), 1, 2.5),\n            ((1.0, 6.0, 1.5), 2, 4.0),\n            ((1.0, 6.0, 1.5), 3, 5.5),\n            ((1.0, 6.0, 1.5), -1, 5.5),\n            ((1.0, 6.0, 1.5), -2, 4.0),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"1.5\")),\n                -1,\n                Decimal(\"8.5\"),\n            ),\n            (\n                (Fraction(1, 1), Fraction(10, 1), Fraction(3, 2)),\n                2,\n                Fraction(4, 1),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                1,\n                datetime(2019, 3, 29, 10),\n            ),\n        ]:\n            self.assertEqual(expected, mi.numeric_range(*args)[index])\n\n        for args, index in [\n            ((1.0, 6.0, 1.5), 4),\n            ((1.0, 6.0, 1.5), -5),\n            ((6.0, 1.0, 1.5), 0),\n            ((6.0, 1.0, 1.5), -1),\n            ((Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"-1.5\")), -1),\n            ((Fraction(1, 1), Fraction(2, 1), Fraction(3, 2)), 2),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                8,\n            ),\n        ]:\n            with self.assertRaises(IndexError):\n                mi.numeric_range(*args)[index]\n\n    def test_get_item_by_slice(self):\n        for args, sl, expected_args in [\n            ((1.0, 9.0, 1.5), slice(None, None, None), (1.0, 9.0, 1.5)),\n            ((1.0, 9.0, 1.5), slice(None, 1, None), (1.0, 2.5, 1.5)),\n            ((1.0, 9.0, 1.5), slice(None, None, 2), (1.0, 9.0, 3.0)),\n            ((1.0, 9.0, 1.5), slice(None, 2, None), (1.0, 4.0, 1.5)),\n            ((1.0, 9.0, 1.5), slice(1, 2, None), (2.5, 4.0, 1.5)),\n            ((1.0, 9.0, 1.5), slice(1, -1, None), (2.5, 8.5, 1.5)),\n            ((1.0, 9.0, 1.5), slice(10, None, 3), (9.0, 9.0, 4.5)),\n            ((1.0, 9.0, 1.5), slice(-10, None, 3), (1.0, 9.0, 4.5)),\n            ((1.0, 9.0, 1.5), slice(None, -10, 3), (1.0, 1.0, 4.5)),\n            ((1.0, 9.0, 1.5), slice(None, 10, 3), (1.0, 9.0, 4.5)),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"1.5\")),\n                slice(1, -1, None),\n                (Decimal(\"2.5\"), Decimal(\"8.5\"), Decimal(\"1.5\")),\n            ),\n            (\n                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n                slice(1, -1, None),\n                (Fraction(5, 2), Fraction(4, 1), Fraction(3, 2)),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                slice(1, -1, None),\n                (\n                    datetime(2019, 3, 29, 10),\n                    datetime(2019, 3, 29, 20),\n                    timedelta(hours=10),\n                ),\n            ),\n        ]:\n            self.assertEqual(\n                mi.numeric_range(*expected_args), mi.numeric_range(*args)[sl]\n            )\n\n    def test_hash(self):\n        for args, expected in [\n            ((1.0, 6.0, 1.5), hash((1.0, 5.5, 1.5))),\n            ((1.0, 7.0, 1.5), hash((1.0, 5.5, 1.5))),\n            ((1.0, 7.5, 1.5), hash((1.0, 7.0, 1.5))),\n            ((1.0, 1.5, 1.5), hash((1.0, 1.0, 1.5))),\n            ((1.5, 1.0, 1.5), hash(range(0, 0))),\n            ((1.5, 1.5, 1.5), hash(range(0, 0))),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"1.5\")),\n                hash((Decimal(\"1.0\"), Decimal(\"8.5\"), Decimal(\"1.5\"))),\n            ),\n            (\n                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n                hash((Fraction(1, 1), Fraction(4, 1), Fraction(3, 2))),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                hash(\n                    (\n                        datetime(2019, 3, 29),\n                        datetime(2019, 3, 29, 20),\n                        timedelta(hours=10),\n                    )\n                ),\n            ),\n        ]:\n            self.assertEqual(expected, hash(mi.numeric_range(*args)))\n\n    def test_iter_twice(self):\n        r1 = mi.numeric_range(1.0, 9.9, 1.5)\n        r2 = mi.numeric_range(8.5, 0.0, -1.5)\n        self.assertEqual([1.0, 2.5, 4.0, 5.5, 7.0, 8.5], list(r1))\n        self.assertEqual([1.0, 2.5, 4.0, 5.5, 7.0, 8.5], list(r1))\n        self.assertEqual([8.5, 7.0, 5.5, 4.0, 2.5, 1.0], list(r2))\n        self.assertEqual([8.5, 7.0, 5.5, 4.0, 2.5, 1.0], list(r2))\n\n    def test_len(self):\n        for args, expected in [\n            ((1.0, 7.0, 1.5), 4),\n            ((1.0, 7.01, 1.5), 5),\n            ((7.0, 1.0, -1.5), 4),\n            ((7.01, 1.0, -1.5), 5),\n            ((0.1, 0.30000000000000001, 0.2), 1),  # IEE 754 !\n            (\n                (\n                    Decimal(\"0.1\"),\n                    Decimal(\"0.30000000000000001\"),\n                    Decimal(\"0.2\"),\n                ),\n                2,\n            ),  # works with Decimal\n            ((Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"1.5\")), 6),\n            ((Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)), 3),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                3,\n            ),\n        ]:\n            self.assertEqual(expected, len(mi.numeric_range(*args)))\n\n    def test_repr(self):\n        for args, *expected in [\n            ((7.0,), \"numeric_range(0.0, 7.0)\"),\n            ((1.0, 7.0), \"numeric_range(1.0, 7.0)\"),\n            ((7.0, 1.0, -1.5), \"numeric_range(7.0, 1.0, -1.5)\"),\n            (\n                (Decimal(\"1.0\"), Decimal(\"9.0\"), Decimal(\"1.5\")),\n                (\n                    \"numeric_range(Decimal('1.0'), Decimal('9.0'), \"\n                    \"Decimal('1.5'))\"\n                ),\n            ),\n            (\n                (Fraction(7, 7), Fraction(10, 2), Fraction(3, 2)),\n                (\n                    \"numeric_range(Fraction(1, 1), Fraction(5, 1), \"\n                    \"Fraction(3, 2))\"\n                ),\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                \"numeric_range(datetime.datetime(2019, 3, 29, 0, 0), \"\n                \"datetime.datetime(2019, 3, 30, 0, 0), \"\n                \"datetime.timedelta(seconds=36000))\",\n                \"numeric_range(datetime.datetime(2019, 3, 29, 0, 0), \"\n                \"datetime.datetime(2019, 3, 30, 0, 0), \"\n                \"datetime.timedelta(0, 36000))\",\n            ),\n        ]:\n            with self.subTest(args=args):\n                self.assertIn(repr(mi.numeric_range(*args)), expected)\n\n    def test_reversed(self):\n        for args, expected in [\n            ((7.0,), [6.0, 5.0, 4.0, 3.0, 2.0, 1.0, 0.0]),\n            ((1.0, 7.0), [6.0, 5.0, 4.0, 3.0, 2.0, 1.0]),\n            ((7.0, 1.0, -1.5), [2.5, 4.0, 5.5, 7.0]),\n            ((7.0, 0.9, -1.5), [1.0, 2.5, 4.0, 5.5, 7.0]),\n            (\n                (Decimal(\"1.0\"), Decimal(\"5.0\"), Decimal(\"1.5\")),\n                [Decimal('4.0'), Decimal('2.5'), Decimal('1.0')],\n            ),\n            (\n                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n                [Fraction(4, 1), Fraction(5, 2), Fraction(1, 1)],\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                [\n                    datetime(2019, 3, 29, 20),\n                    datetime(2019, 3, 29, 10),\n                    datetime(2019, 3, 29),\n                ],\n            ),\n        ]:\n            self.assertEqual(expected, list(reversed(mi.numeric_range(*args))))\n\n    def test_count(self):\n        for args, v, c in [\n            ((7.0,), 0.0, 1),\n            ((7.0,), 0.5, 0),\n            ((7.0,), 6.0, 1),\n            ((7.0,), 7.0, 0),\n            ((7.0,), 10.0, 0),\n            (\n                (Decimal(\"1.0\"), Decimal(\"5.0\"), Decimal(\"1.5\")),\n                Decimal('4.0'),\n                1,\n            ),\n            (\n                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n                Fraction(5, 2),\n                1,\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                datetime(2019, 3, 29, 20),\n                1,\n            ),\n        ]:\n            self.assertEqual(c, mi.numeric_range(*args).count(v))\n\n    def test_index(self):\n        for args, v, i in [\n            ((7.0,), 0.0, 0),\n            ((7.0,), 6.0, 6),\n            ((7.0, 0.0, -1.0), 7.0, 0),\n            ((7.0, 0.0, -1.0), 1.0, 6),\n            (\n                (Decimal(\"1.0\"), Decimal(\"5.0\"), Decimal(\"1.5\")),\n                Decimal('4.0'),\n                2,\n            ),\n            (\n                (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n                Fraction(5, 2),\n                1,\n            ),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                datetime(2019, 3, 29, 20),\n                2,\n            ),\n        ]:\n            self.assertEqual(i, mi.numeric_range(*args).index(v))\n\n        for args, v in [\n            ((0.7,), 0.5),\n            ((0.7,), 7.0),\n            ((0.7,), 10.0),\n            ((7.0, 0.0, -1.0), 0.5),\n            ((7.0, 0.0, -1.0), 0.0),\n            ((7.0, 0.0, -1.0), 10.0),\n            ((7.0, 0.0), 5.0),\n            ((Decimal(\"1.0\"), Decimal(\"5.0\"), Decimal(\"1.5\")), Decimal('4.5')),\n            ((Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)), Fraction(5, 3)),\n            (\n                (\n                    datetime(2019, 3, 29),\n                    datetime(2019, 3, 30),\n                    timedelta(hours=10),\n                ),\n                datetime(2019, 3, 30),\n            ),\n        ]:\n            with self.assertRaises(ValueError):\n                mi.numeric_range(*args).index(v)\n\n    def test_parent_classes(self):\n        r = mi.numeric_range(7.0)\n        self.assertTrue(isinstance(r, abc.Iterable))\n        self.assertFalse(isinstance(r, abc.Iterator))\n        self.assertTrue(isinstance(r, abc.Sequence))\n        self.assertTrue(isinstance(r, abc.Hashable))\n\n    def test_bad_key(self):\n        r = mi.numeric_range(7.0)\n        for arg, message in [\n            ('a', 'numeric range indices must be integers or slices, not str'),\n            (\n                (),\n                'numeric range indices must be integers or slices, not tuple',\n            ),\n        ]:\n            with self.assertRaisesRegex(TypeError, message):\n                r[arg]\n\n    def test_pickle(self):\n        for args in [\n            (7.0,),\n            (5.0, 7.0),\n            (5.0, 7.0, 3.0),\n            (7.0, 5.0),\n            (7.0, 5.0, 4.0),\n            (7.0, 5.0, -1.0),\n            (Decimal(\"1.0\"), Decimal(\"5.0\"), Decimal(\"1.5\")),\n            (Fraction(1, 1), Fraction(5, 1), Fraction(3, 2)),\n            (datetime(2019, 3, 29), datetime(2019, 3, 30)),\n        ]:\n            r = mi.numeric_range(*args)\n            self.assertTrue(dumps(r))  # assert not empty\n            self.assertEqual(r, loads(dumps(r)))\n\n\nclass CountCycleTests(TestCase):\n    def test_basic(self):\n        expected = [\n            (0, 'a'),\n            (0, 'b'),\n            (0, 'c'),\n            (1, 'a'),\n            (1, 'b'),\n            (1, 'c'),\n            (2, 'a'),\n            (2, 'b'),\n            (2, 'c'),\n        ]\n        for actual in [\n            mi.take(9, mi.count_cycle('abc')),  # n=None\n            list(mi.count_cycle('abc', 3)),  # n=3\n        ]:\n            self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        self.assertEqual(list(mi.count_cycle('')), [])\n        self.assertEqual(list(mi.count_cycle('', 2)), [])\n\n    def test_negative(self):\n        self.assertEqual(list(mi.count_cycle('abc', -3)), [])\n\n\nclass MarkEndsTests(TestCase):\n    def test_basic(self):\n        for size, expected in [\n            (0, []),\n            (1, [(True, True, '0')]),\n            (2, [(True, False, '0'), (False, True, '1')]),\n            (3, [(True, False, '0'), (False, False, '1'), (False, True, '2')]),\n            (\n                4,\n                [\n                    (True, False, '0'),\n                    (False, False, '1'),\n                    (False, False, '2'),\n                    (False, True, '3'),\n                ],\n            ),\n        ]:\n            with self.subTest(size=size):\n                iterable = map(str, range(size))\n                actual = list(mi.mark_ends(iterable))\n                self.assertEqual(actual, expected)\n\n\nclass LocateTests(TestCase):\n    def test_default_pred(self):\n        iterable = [0, 1, 1, 0, 1, 0, 0]\n        actual = list(mi.locate(iterable))\n        expected = [1, 2, 4]\n        self.assertEqual(actual, expected)\n\n    def test_no_matches(self):\n        iterable = [0, 0, 0]\n        actual = list(mi.locate(iterable))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_custom_pred(self):\n        iterable = ['0', 1, 1, '0', 1, '0', '0']\n        pred = lambda x: x == '0'\n        actual = list(mi.locate(iterable, pred))\n        expected = [0, 3, 5, 6]\n        self.assertEqual(actual, expected)\n\n    def test_window_size(self):\n        iterable = ['0', 1, 1, '0', 1, '0', '0']\n        pred = lambda *args: args == ('0', 1)\n        actual = list(mi.locate(iterable, pred, window_size=2))\n        expected = [0, 3]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_large(self):\n        iterable = [1, 2, 3, 4]\n        pred = lambda a, b, c, d, e: True\n        actual = list(mi.locate(iterable, pred, window_size=5))\n        expected = [0]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_zero(self):\n        iterable = [1, 2, 3, 4]\n        pred = lambda: True\n        with self.assertRaises(ValueError):\n            list(mi.locate(iterable, pred, window_size=0))\n\n\nclass StripFunctionTests(TestCase):\n    def test_hashable(self):\n        iterable = list('www.example.com')\n        pred = lambda x: x in set('cmowz.')\n\n        self.assertEqual(list(mi.lstrip(iterable, pred)), list('example.com'))\n        self.assertEqual(list(mi.rstrip(iterable, pred)), list('www.example'))\n        self.assertEqual(list(mi.strip(iterable, pred)), list('example'))\n\n    def test_not_hashable(self):\n        iterable = [\n            list('http://'),\n            list('www'),\n            list('.example'),\n            list('.com'),\n        ]\n        pred = lambda x: x in [list('http://'), list('www'), list('.com')]\n\n        self.assertEqual(list(mi.lstrip(iterable, pred)), iterable[2:])\n        self.assertEqual(list(mi.rstrip(iterable, pred)), iterable[:3])\n        self.assertEqual(list(mi.strip(iterable, pred)), iterable[2:3])\n\n    def test_math(self):\n        iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2]\n        pred = lambda x: x <= 2\n\n        self.assertEqual(list(mi.lstrip(iterable, pred)), iterable[3:])\n        self.assertEqual(list(mi.rstrip(iterable, pred)), iterable[:-3])\n        self.assertEqual(list(mi.strip(iterable, pred)), iterable[3:-3])\n\n\nclass IsliceExtendedTests(TestCase):\n    def test_all(self):\n        iterable = ['0', '1', '2', '3', '4', '5']\n        indexes = [*range(-4, 10), None]\n        steps = [1, 2, 3, 4, -1, -2, -3, -4]\n        for slice_args in product(indexes, indexes, steps):\n            with self.subTest(slice_args=slice_args):\n                actual = list(mi.islice_extended(iterable, *slice_args))\n                expected = iterable[slice(*slice_args)]\n                self.assertEqual(actual, expected, slice_args)\n\n    def test_zero_step(self):\n        with self.assertRaises(ValueError):\n            list(mi.islice_extended([1, 2, 3], 0, 1, 0))\n\n    def test_slicing(self):\n        iterable = map(str, count())\n        first_slice = mi.islice_extended(iterable)[10:]\n        second_slice = mi.islice_extended(first_slice)[:10]\n        third_slice = mi.islice_extended(second_slice)[::2]\n        self.assertEqual(list(third_slice), ['10', '12', '14', '16', '18'])\n\n    def test_slicing_extensive(self):\n        iterable = range(10)\n        options = (None, 1, 2, 7, -1)\n        for start, stop, step in product(options, options, options):\n            with self.subTest(slice_args=(start, stop, step)):\n                sliced_tuple_0 = tuple(\n                    mi.islice_extended(iterable)[start:stop:step]\n                )\n                sliced_tuple_1 = tuple(\n                    mi.islice_extended(iterable, start, stop, step)\n                )\n                sliced_range = tuple(iterable[start:stop:step])\n                self.assertEqual(sliced_tuple_0, sliced_range)\n                self.assertEqual(sliced_tuple_1, sliced_range)\n\n    def test_invalid_slice(self):\n        with self.assertRaises(TypeError):\n            mi.islice_extended(count())[13]\n\n\nclass ConsecutiveGroupsTest(TestCase):\n    def test_numbers(self):\n        iterable = [-10, -8, -7, -6, 1, 2, 4, 5, -1, 7]\n        actual = [list(g) for g in mi.consecutive_groups(iterable)]\n        expected = [[-10], [-8, -7, -6], [1, 2], [4, 5], [-1], [7]]\n        self.assertEqual(actual, expected)\n\n    def test_custom_ordering(self):\n        iterable = ['1', '10', '11', '20', '21', '22', '30', '31']\n        ordering = lambda x: int(x)\n        actual = [list(g) for g in mi.consecutive_groups(iterable, ordering)]\n        expected = [['1'], ['10', '11'], ['20', '21', '22'], ['30', '31']]\n        self.assertEqual(actual, expected)\n\n    def test_exotic_ordering(self):\n        iterable = [\n            ('a', 'b', 'c', 'd'),\n            ('a', 'c', 'b', 'd'),\n            ('a', 'c', 'd', 'b'),\n            ('a', 'd', 'b', 'c'),\n            ('d', 'b', 'c', 'a'),\n            ('d', 'c', 'a', 'b'),\n        ]\n        ordering = list(permutations('abcd')).index\n        actual = [list(g) for g in mi.consecutive_groups(iterable, ordering)]\n        expected = [\n            [('a', 'b', 'c', 'd')],\n            [('a', 'c', 'b', 'd'), ('a', 'c', 'd', 'b'), ('a', 'd', 'b', 'c')],\n            [('d', 'b', 'c', 'a'), ('d', 'c', 'a', 'b')],\n        ]\n        self.assertEqual(actual, expected)\n\n\nclass DifferenceTest(TestCase):\n    def test_normal(self):\n        iterable = [10, 20, 30, 40, 50]\n        actual = list(mi.difference(iterable))\n        expected = [10, 10, 10, 10, 10]\n        self.assertEqual(actual, expected)\n\n    def test_custom(self):\n        iterable = [10, 20, 30, 40, 50]\n        actual = list(mi.difference(iterable, add))\n        expected = [10, 30, 50, 70, 90]\n        self.assertEqual(actual, expected)\n\n    def test_roundtrip(self):\n        original = list(range(100))\n        accumulated = accumulate(original)\n        actual = list(mi.difference(accumulated))\n        self.assertEqual(actual, original)\n\n    def test_one(self):\n        self.assertEqual(list(mi.difference([0])), [0])\n\n    def test_empty(self):\n        self.assertEqual(list(mi.difference([])), [])\n\n    def test_initial(self):\n        original = list(range(100))\n        accumulated = accumulate(original, initial=100)\n        actual = list(mi.difference(accumulated, initial=100))\n        self.assertEqual(actual, original)\n\n\nclass SeekableTest(PeekableMixinTests, TestCase):\n    cls = mi.seekable\n\n    def test_exhaustion_reset(self):\n        iterable = [str(n) for n in range(10)]\n\n        s = mi.seekable(iterable)\n        self.assertEqual(list(s), iterable)  # Normal iteration\n        self.assertEqual(list(s), [])  # Iterable is exhausted\n\n        s.seek(0)\n        self.assertEqual(list(s), iterable)  # Back in action\n\n    def test_partial_reset(self):\n        iterable = [str(n) for n in range(10)]\n\n        s = mi.seekable(iterable)\n        self.assertEqual(mi.take(5, s), iterable[:5])  # Normal iteration\n\n        s.seek(1)\n        self.assertEqual(list(s), iterable[1:])  # Get the rest of the iterable\n\n    def test_forward(self):\n        iterable = [str(n) for n in range(10)]\n\n        s = mi.seekable(iterable)\n        self.assertEqual(mi.take(1, s), iterable[:1])  # Normal iteration\n\n        s.seek(3)  # Skip over index 2\n        self.assertEqual(list(s), iterable[3:])  # Result is similar to slicing\n\n        s.seek(0)  # Back to 0\n        self.assertEqual(list(s), iterable)  # No difference in result\n\n    def test_past_end(self):\n        iterable = [str(n) for n in range(10)]\n\n        s = mi.seekable(iterable)\n        self.assertEqual(mi.take(1, s), iterable[:1])  # Normal iteration\n\n        s.seek(20)\n        self.assertEqual(list(s), [])  # Iterable is exhausted\n\n        s.seek(0)  # Back to 0\n        self.assertEqual(list(s), iterable)  # No difference in result\n\n    def test_elements(self):\n        iterable = map(str, count())\n\n        s = mi.seekable(iterable)\n        mi.take(10, s)\n\n        elements = s.elements()\n        self.assertEqual(\n            [elements[i] for i in range(10)], [str(n) for n in range(10)]\n        )\n        self.assertEqual(len(elements), 10)\n\n        mi.take(10, s)\n        self.assertEqual(list(elements), [str(n) for n in range(20)])\n\n    def test_maxlen(self):\n        iterable = map(str, count())\n\n        s = mi.seekable(iterable, maxlen=4)\n        self.assertEqual(mi.take(10, s), [str(n) for n in range(10)])\n        self.assertEqual(list(s.elements()), ['6', '7', '8', '9'])\n\n        s.seek(0)\n        self.assertEqual(mi.take(14, s), [str(n) for n in range(6, 20)])\n        self.assertEqual(list(s.elements()), ['16', '17', '18', '19'])\n\n    def test_maxlen_zero(self):\n        iterable = [str(x) for x in range(5)]\n        s = mi.seekable(iterable, maxlen=0)\n        self.assertEqual(list(s), iterable)\n        self.assertEqual(list(s.elements()), [])\n\n    def test_relative_seek(self):\n        iterable = [str(x) for x in range(5)]\n        s = mi.seekable(iterable)\n        s.relative_seek(2)\n        self.assertEqual(next(s), '2')\n        s.relative_seek(-2)\n        self.assertEqual(next(s), '1')\n        s.relative_seek(-10)  # Lower bound\n        self.assertEqual(next(s), '0')\n        s.relative_seek(10)  # Lower bound\n        self.assertEqual(list(s.elements()), [str(x) for x in range(5)])\n\n\nclass SequenceViewTests(TestCase):\n    def test_init(self):\n        view = mi.SequenceView((1, 2, 3))\n        self.assertEqual(repr(view), \"SequenceView((1, 2, 3))\")\n        self.assertRaises(TypeError, lambda: mi.SequenceView({}))\n\n    def test_update(self):\n        seq = [1, 2, 3]\n        view = mi.SequenceView(seq)\n        self.assertEqual(len(view), 3)\n        self.assertEqual(repr(view), \"SequenceView([1, 2, 3])\")\n\n        seq.pop()\n        self.assertEqual(len(view), 2)\n        self.assertEqual(repr(view), \"SequenceView([1, 2])\")\n\n    def test_indexing(self):\n        seq = ('a', 'b', 'c', 'd', 'e', 'f')\n        view = mi.SequenceView(seq)\n        for i in range(-len(seq), len(seq)):\n            self.assertEqual(view[i], seq[i])\n\n    def test_slicing(self):\n        seq = ('a', 'b', 'c', 'd', 'e', 'f')\n        view = mi.SequenceView(seq)\n        n = len(seq)\n        indexes = list(range(-n - 1, n + 1)) + [None]\n        steps = list(range(-n, n + 1))\n        steps.remove(0)\n        for slice_args in product(indexes, indexes, steps):\n            i = slice(*slice_args)\n            self.assertEqual(view[i], seq[i])\n\n    def test_abc_methods(self):\n        # collections.Sequence should provide all of this functionality\n        seq = ('a', 'b', 'c', 'd', 'e', 'f', 'f')\n        view = mi.SequenceView(seq)\n\n        # __contains__\n        self.assertIn('b', view)\n        self.assertNotIn('g', view)\n\n        # __iter__\n        self.assertEqual(list(iter(view)), list(seq))\n\n        # __reversed__\n        self.assertEqual(list(reversed(view)), list(reversed(seq)))\n\n        # index\n        self.assertEqual(view.index('b'), 1)\n\n        # count\n        self.assertEqual(seq.count('f'), 2)\n\n\nclass RunLengthTest(TestCase):\n    def test_encode(self):\n        iterable = (int(str(n)[0]) for n in count(800))\n        actual = mi.take(4, mi.run_length.encode(iterable))\n        expected = [(8, 100), (9, 100), (1, 1000), (2, 1000)]\n        self.assertEqual(actual, expected)\n\n    def test_decode(self):\n        iterable = [('d', 4), ('c', 3), ('b', 2), ('a', 1)]\n        actual = ''.join(mi.run_length.decode(iterable))\n        expected = 'ddddcccbba'\n        self.assertEqual(actual, expected)\n\n\nclass ExactlyNTests(TestCase):\n    \"\"\"Tests for ``exactly_n()``\"\"\"\n\n    def test_true(self):\n        \"\"\"Iterable has ``n`` ``True`` elements\"\"\"\n        self.assertTrue(mi.exactly_n([True, False, True], 2))\n        self.assertTrue(mi.exactly_n([1, 1, 1, 0], 3))\n        self.assertTrue(mi.exactly_n([False, False], 0))\n        self.assertTrue(mi.exactly_n(range(100), 10, lambda x: x < 10))\n\n    def test_false(self):\n        \"\"\"Iterable does not have ``n`` ``True`` elements\"\"\"\n        self.assertFalse(mi.exactly_n([True, False, False], 2))\n        self.assertFalse(mi.exactly_n([True, True, False], 1))\n        self.assertFalse(mi.exactly_n([False], 1))\n        self.assertFalse(mi.exactly_n([True], -1))\n        self.assertFalse(mi.exactly_n(repeat(True), 100))\n\n    def test_empty(self):\n        \"\"\"Return ``True`` if the iterable is empty and ``n`` is 0\"\"\"\n        self.assertTrue(mi.exactly_n([], 0))\n        self.assertFalse(mi.exactly_n([], 1))\n\n\nclass AlwaysReversibleTests(TestCase):\n    \"\"\"Tests for ``always_reversible()``\"\"\"\n\n    def test_regular_reversed(self):\n        self.assertEqual(\n            list(reversed(range(10))), list(mi.always_reversible(range(10)))\n        )\n        self.assertEqual(\n            list(reversed([1, 2, 3])), list(mi.always_reversible([1, 2, 3]))\n        )\n        self.assertEqual(\n            reversed([1, 2, 3]).__class__,\n            mi.always_reversible([1, 2, 3]).__class__,\n        )\n\n    def test_nonseq_reversed(self):\n        # Create a non-reversible generator from a sequence\n        with self.assertRaises(TypeError):\n            reversed(x for x in range(10))\n\n        self.assertEqual(\n            list(reversed(range(10))),\n            list(mi.always_reversible(x for x in range(10))),\n        )\n        self.assertEqual(\n            list(reversed([1, 2, 3])),\n            list(mi.always_reversible(x for x in [1, 2, 3])),\n        )\n        self.assertNotEqual(\n            reversed((1, 2)).__class__,\n            mi.always_reversible(x for x in (1, 2)).__class__,\n        )\n\n\nclass CircularShiftsTests(TestCase):\n    def test_empty(self):\n        # empty iterable -> empty list\n        self.assertEqual(list(mi.circular_shifts([])), [])\n\n    def test_simple_circular_shifts(self):\n        # test the a simple iterator case\n        self.assertEqual(\n            mi.circular_shifts(range(4)),\n            [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)],\n        )\n\n    def test_duplicates(self):\n        # test non-distinct entries\n        self.assertEqual(\n            mi.circular_shifts([0, 1, 0, 1]),\n            [(0, 1, 0, 1), (1, 0, 1, 0), (0, 1, 0, 1), (1, 0, 1, 0)],\n        )\n\n\nclass MakeDecoratorTests(TestCase):\n    def test_basic(self):\n        slicer = mi.make_decorator(islice)\n\n        @slicer(1, 10, 2)\n        def user_function(arg_1, arg_2, kwarg_1=None):\n            self.assertEqual(arg_1, 'arg_1')\n            self.assertEqual(arg_2, 'arg_2')\n            self.assertEqual(kwarg_1, 'kwarg_1')\n            return map(str, count())\n\n        it = user_function('arg_1', 'arg_2', kwarg_1='kwarg_1')\n        actual = list(it)\n        expected = ['1', '3', '5', '7', '9']\n        self.assertEqual(actual, expected)\n\n    def test_result_index(self):\n        def stringify(*args, **kwargs):\n            self.assertEqual(args[0], 'arg_0')\n            iterable = args[1]\n            self.assertEqual(args[2], 'arg_2')\n            self.assertEqual(kwargs['kwarg_1'], 'kwarg_1')\n            return map(str, iterable)\n\n        stringifier = mi.make_decorator(stringify, result_index=1)\n\n        @stringifier('arg_0', 'arg_2', kwarg_1='kwarg_1')\n        def user_function(n):\n            return count(n)\n\n        it = user_function(1)\n        actual = mi.take(5, it)\n        expected = ['1', '2', '3', '4', '5']\n        self.assertEqual(actual, expected)\n\n    def test_wrap_class(self):\n        seeker = mi.make_decorator(mi.seekable)\n\n        @seeker()\n        def user_function(n):\n            return map(str, range(n))\n\n        it = user_function(5)\n        self.assertEqual(list(it), ['0', '1', '2', '3', '4'])\n\n        it.seek(0)\n        self.assertEqual(list(it), ['0', '1', '2', '3', '4'])\n\n\nclass MapReduceTests(TestCase):\n    def test_default(self):\n        iterable = (str(x) for x in range(5))\n        keyfunc = lambda x: int(x) // 2\n        actual = sorted(mi.map_reduce(iterable, keyfunc).items())\n        expected = [(0, ['0', '1']), (1, ['2', '3']), (2, ['4'])]\n        self.assertEqual(actual, expected)\n\n    def test_valuefunc(self):\n        iterable = (str(x) for x in range(5))\n        keyfunc = lambda x: int(x) // 2\n        valuefunc = int\n        actual = sorted(mi.map_reduce(iterable, keyfunc, valuefunc).items())\n        expected = [(0, [0, 1]), (1, [2, 3]), (2, [4])]\n        self.assertEqual(actual, expected)\n\n    def test_reducefunc(self):\n        iterable = (str(x) for x in range(5))\n        keyfunc = lambda x: int(x) // 2\n        valuefunc = int\n        reducefunc = lambda value_list: reduce(mul, value_list, 1)\n        actual = sorted(\n            mi.map_reduce(iterable, keyfunc, valuefunc, reducefunc).items()\n        )\n        expected = [(0, 0), (1, 6), (2, 4)]\n        self.assertEqual(actual, expected)\n\n    def test_ret(self):\n        d = mi.map_reduce([1, 0, 2, 0, 1, 0], bool)\n        self.assertEqual(d, {False: [0, 0, 0], True: [1, 2, 1]})\n        self.assertRaises(KeyError, lambda: d[None].append(1))\n\n\nclass RlocateTests(TestCase):\n    def test_default_pred(self):\n        iterable = [0, 1, 1, 0, 1, 0, 0]\n        for it in (iterable[:], iter(iterable)):\n            actual = list(mi.rlocate(it))\n            expected = [4, 2, 1]\n            self.assertEqual(actual, expected)\n\n    def test_no_matches(self):\n        iterable = [0, 0, 0]\n        for it in (iterable[:], iter(iterable)):\n            actual = list(mi.rlocate(it))\n            expected = []\n            self.assertEqual(actual, expected)\n\n    def test_custom_pred(self):\n        iterable = ['0', 1, 1, '0', 1, '0', '0']\n        pred = lambda x: x == '0'\n        for it in (iterable[:], iter(iterable)):\n            actual = list(mi.rlocate(it, pred))\n            expected = [6, 5, 3, 0]\n            self.assertEqual(actual, expected)\n\n    def test_efficient_reversal(self):\n        iterable = range(9**9)  # Is efficiently reversible\n        target = 9**9 - 2\n        pred = lambda x: x == target  # Find-able from the right\n        actual = next(mi.rlocate(iterable, pred))\n        self.assertEqual(actual, target)\n\n    def test_window_size(self):\n        iterable = ['0', 1, 1, '0', 1, '0', '0']\n        pred = lambda *args: args == ('0', 1)\n        for it in (iterable, iter(iterable)):\n            actual = list(mi.rlocate(it, pred, window_size=2))\n            expected = [3, 0]\n            self.assertEqual(actual, expected)\n\n    def test_window_size_large(self):\n        iterable = [1, 2, 3, 4]\n        pred = lambda a, b, c, d, e: True\n        for it in (iterable, iter(iterable)):\n            actual = list(mi.rlocate(iterable, pred, window_size=5))\n            expected = [0]\n            self.assertEqual(actual, expected)\n\n    def test_window_size_zero(self):\n        iterable = [1, 2, 3, 4]\n        pred = lambda: True\n        for it in (iterable, iter(iterable)):\n            with self.assertRaises(ValueError):\n                list(mi.locate(iterable, pred, window_size=0))\n\n\nclass ReplaceTests(TestCase):\n    def test_basic(self):\n        iterable = range(10)\n        pred = lambda x: x % 2 == 0\n        substitutes = []\n        actual = list(mi.replace(iterable, pred, substitutes))\n        expected = [1, 3, 5, 7, 9]\n        self.assertEqual(actual, expected)\n\n    def test_count(self):\n        iterable = range(10)\n        pred = lambda x: x % 2 == 0\n        substitutes = []\n        actual = list(mi.replace(iterable, pred, substitutes, count=4))\n        expected = [1, 3, 5, 7, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_window_size(self):\n        iterable = range(10)\n        pred = lambda *args: args == (0, 1, 2)\n        substitutes = []\n        actual = list(mi.replace(iterable, pred, substitutes, window_size=3))\n        expected = [3, 4, 5, 6, 7, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_end(self):\n        iterable = range(10)\n        pred = lambda *args: args == (7, 8, 9)\n        substitutes = []\n        actual = list(mi.replace(iterable, pred, substitutes, window_size=3))\n        expected = [0, 1, 2, 3, 4, 5, 6]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_count(self):\n        iterable = range(10)\n        pred = lambda *args: (args == (0, 1, 2)) or (args == (7, 8, 9))\n        substitutes = []\n        actual = list(\n            mi.replace(iterable, pred, substitutes, count=1, window_size=3)\n        )\n        expected = [3, 4, 5, 6, 7, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_large(self):\n        iterable = range(4)\n        pred = lambda a, b, c, d, e: True\n        substitutes = [5, 6, 7]\n        actual = list(mi.replace(iterable, pred, substitutes, window_size=5))\n        expected = [5, 6, 7]\n        self.assertEqual(actual, expected)\n\n    def test_window_size_zero(self):\n        iterable = range(10)\n        pred = lambda *args: True\n        substitutes = []\n        with self.assertRaises(ValueError):\n            list(mi.replace(iterable, pred, substitutes, window_size=0))\n\n    def test_iterable_substitutes(self):\n        iterable = range(5)\n        pred = lambda x: x % 2 == 0\n        substitutes = iter('__')\n        actual = list(mi.replace(iterable, pred, substitutes))\n        expected = ['_', '_', 1, '_', '_', 3, '_', '_']\n        self.assertEqual(actual, expected)\n\n\nclass PartitionsTest(TestCase):\n    def test_types(self):\n        for iterable in ['abcd', ['a', 'b', 'c', 'd'], ('a', 'b', 'c', 'd')]:\n            with self.subTest(iterable=iterable):\n                actual = list(mi.partitions(iterable))\n                expected = [\n                    [['a', 'b', 'c', 'd']],\n                    [['a'], ['b', 'c', 'd']],\n                    [['a', 'b'], ['c', 'd']],\n                    [['a', 'b', 'c'], ['d']],\n                    [['a'], ['b'], ['c', 'd']],\n                    [['a'], ['b', 'c'], ['d']],\n                    [['a', 'b'], ['c'], ['d']],\n                    [['a'], ['b'], ['c'], ['d']],\n                ]\n                self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        iterable = []\n        actual = list(mi.partitions(iterable))\n        expected = [[[]]]\n        self.assertEqual(actual, expected)\n\n    def test_order(self):\n        iterable = iter([3, 2, 1])\n        actual = list(mi.partitions(iterable))\n        expected = [[[3, 2, 1]], [[3], [2, 1]], [[3, 2], [1]], [[3], [2], [1]]]\n        self.assertEqual(actual, expected)\n\n    def test_duplicates(self):\n        iterable = [1, 1, 1]\n        actual = list(mi.partitions(iterable))\n        expected = [[[1, 1, 1]], [[1], [1, 1]], [[1, 1], [1]], [[1], [1], [1]]]\n        self.assertEqual(actual, expected)\n\n\nclass _FrozenMultiset(Set):\n    \"\"\"\n    A helper class, useful to compare two lists without reference to the order\n    of elements.\n\n    FrozenMultiset represents a hashable set that allows duplicate elements.\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._collection = frozenset(Counter(iterable).items())\n\n    def __contains__(self, y):\n        \"\"\"\n        >>> (0, 1) in _FrozenMultiset([(0, 1), (2,), (0, 1)])\n        True\n        \"\"\"\n        return any(y == x for x, _ in self._collection)\n\n    def __iter__(self):\n        \"\"\"\n        >>> sorted(_FrozenMultiset([(0, 1), (2,), (0, 1)]))\n        [(0, 1), (0, 1), (2,)]\n        \"\"\"\n        return (x for x, c in self._collection for _ in range(c))\n\n    def __len__(self):\n        \"\"\"\n        >>> len(_FrozenMultiset([(0, 1), (2,), (0, 1)]))\n        3\n        \"\"\"\n        return sum(c for x, c in self._collection)\n\n    def has_duplicates(self):\n        \"\"\"\n        >>> _FrozenMultiset([(0, 1), (2,), (0, 1)]).has_duplicates()\n        True\n        \"\"\"\n        return any(c != 1 for _, c in self._collection)\n\n    def __hash__(self):\n        return hash(self._collection)\n\n    def __repr__(self):\n        return \"FrozenSet([{}]\".format(\", \".join(repr(x) for x in iter(self)))\n\n\nclass SetPartitionsTests(TestCase):\n    @staticmethod\n    def _normalize_partition(p):\n        \"\"\"\n        Return a normalized, hashable, version of a partition using\n        _FrozenMultiset\n        \"\"\"\n        return _FrozenMultiset(_FrozenMultiset(g) for g in p)\n\n    @staticmethod\n    def _normalize_partitions(ps):\n        \"\"\"\n        Return a normalized set of all normalized partitions using\n        _FrozenMultiset\n        \"\"\"\n        return _FrozenMultiset(\n            SetPartitionsTests._normalize_partition(p) for p in ps\n        )\n\n    def test_repeated(self):\n        it = 'aaa'\n        actual = mi.set_partitions(it, 2)\n        expected = [['a', 'aa'], ['a', 'aa'], ['a', 'aa']]\n        self.assertEqual(\n            self._normalize_partitions(expected),\n            self._normalize_partitions(actual),\n        )\n\n    def test_each_correct(self):\n        a = set(range(6))\n        for p in mi.set_partitions(a):\n            total = {e for g in p for e in g}\n            self.assertEqual(a, total)\n\n    def test_duplicates(self):\n        a = set(range(6))\n        for p in mi.set_partitions(a):\n            self.assertFalse(self._normalize_partition(p).has_duplicates())\n\n    def test_found_all(self):\n        \"\"\"small example, hand-checked\"\"\"\n        expected = [\n            [[0], [1], [2, 3, 4]],\n            [[0], [1, 2], [3, 4]],\n            [[0], [2], [1, 3, 4]],\n            [[0], [3], [1, 2, 4]],\n            [[0], [4], [1, 2, 3]],\n            [[0], [1, 3], [2, 4]],\n            [[0], [1, 4], [2, 3]],\n            [[1], [2], [0, 3, 4]],\n            [[1], [3], [0, 2, 4]],\n            [[1], [4], [0, 2, 3]],\n            [[1], [0, 2], [3, 4]],\n            [[1], [0, 3], [2, 4]],\n            [[1], [0, 4], [2, 3]],\n            [[2], [3], [0, 1, 4]],\n            [[2], [4], [0, 1, 3]],\n            [[2], [0, 1], [3, 4]],\n            [[2], [0, 3], [1, 4]],\n            [[2], [0, 4], [1, 3]],\n            [[3], [4], [0, 1, 2]],\n            [[3], [0, 1], [2, 4]],\n            [[3], [0, 2], [1, 4]],\n            [[3], [0, 4], [1, 2]],\n            [[4], [0, 1], [2, 3]],\n            [[4], [0, 2], [1, 3]],\n            [[4], [0, 3], [1, 2]],\n        ]\n        actual = mi.set_partitions(range(5), 3)\n        self.assertEqual(\n            self._normalize_partitions(expected),\n            self._normalize_partitions(actual),\n        )\n\n    def test_stirling_numbers(self):\n        \"\"\"Check against https://en.wikipedia.org/wiki/\n        Stirling_numbers_of_the_second_kind#Table_of_values\"\"\"\n        cardinality_by_k_by_n = [\n            [1],\n            [1, 1],\n            [1, 3, 1],\n            [1, 7, 6, 1],\n            [1, 15, 25, 10, 1],\n            [1, 31, 90, 65, 15, 1],\n        ]\n        for n, cardinality_by_k in enumerate(cardinality_by_k_by_n, 1):\n            for k, cardinality in enumerate(cardinality_by_k, 1):\n                self.assertEqual(\n                    cardinality, len(list(mi.set_partitions(range(n), k)))\n                )\n\n    def test_no_group(self):\n        def helper():\n            list(mi.set_partitions(range(4), -1))\n\n        self.assertRaises(ValueError, helper)\n\n    def test_to_many_groups(self):\n        self.assertEqual([], list(mi.set_partitions(range(4), 5)))\n\n\nclass TimeLimitedTests(TestCase):\n    def test_basic(self):\n        def generator():\n            yield 1\n            yield 2\n            sleep(0.2)\n            yield 3\n\n        iterable = mi.time_limited(0.1, generator())\n        actual = list(iterable)\n        expected = [1, 2]\n        self.assertEqual(actual, expected)\n        self.assertTrue(iterable.timed_out)\n\n    def test_complete(self):\n        iterable = mi.time_limited(2, iter(range(10)))\n        actual = list(iterable)\n        expected = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n        self.assertEqual(actual, expected)\n        self.assertFalse(iterable.timed_out)\n\n    def test_zero_limit(self):\n        iterable = mi.time_limited(0, count())\n        actual = list(iterable)\n        expected = []\n        self.assertEqual(actual, expected)\n        self.assertTrue(iterable.timed_out)\n\n    def test_invalid_limit(self):\n        with self.assertRaises(ValueError):\n            list(mi.time_limited(-0.1, count()))\n\n\nclass OnlyTests(TestCase):\n    def test_defaults(self):\n        self.assertEqual(mi.only([]), None)\n        self.assertEqual(mi.only([1]), 1)\n        self.assertRaises(ValueError, lambda: mi.only([1, 2]))\n\n    def test_custom_value(self):\n        self.assertEqual(mi.only([], default='!'), '!')\n        self.assertEqual(mi.only([1], default='!'), 1)\n        self.assertRaises(ValueError, lambda: mi.only([1, 2], default='!'))\n\n    def test_custom_exception(self):\n        self.assertEqual(mi.only([], too_long=RuntimeError), None)\n        self.assertEqual(mi.only([1], too_long=RuntimeError), 1)\n        self.assertRaises(\n            RuntimeError, lambda: mi.only([1, 2], too_long=RuntimeError)\n        )\n\n    def test_default_exception_message(self):\n        self.assertRaisesRegex(\n            ValueError,\n            \"Expected exactly one item in iterable, \"\n            \"but got 'foo', 'bar', and perhaps more\",\n            lambda: mi.only(['foo', 'bar', 'baz']),\n        )\n\n\nclass IchunkedTests(TestCase):\n    def test_even(self):\n        iterable = (str(x) for x in range(10))\n        actual = [''.join(c) for c in mi.ichunked(iterable, 5)]\n        expected = ['01234', '56789']\n        self.assertEqual(actual, expected)\n\n    def test_odd(self):\n        iterable = (str(x) for x in range(10))\n        actual = [''.join(c) for c in mi.ichunked(iterable, 4)]\n        expected = ['0123', '4567', '89']\n        self.assertEqual(actual, expected)\n\n    def test_zero(self):\n        iterable = []\n        actual = [list(c) for c in mi.ichunked(iterable, 0)]\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_negative(self):\n        iterable = count()\n        with self.assertRaises(ValueError):\n            [list(c) for c in mi.ichunked(iterable, -1)]\n\n    def test_out_of_order(self):\n        iterable = map(str, count())\n        it = mi.ichunked(iterable, 4)\n        chunk_1 = next(it)\n        chunk_2 = next(it)\n        self.assertEqual(''.join(chunk_2), '4567')\n        self.assertEqual(''.join(chunk_1), '0123')\n\n    def test_laziness(self):\n        def gen():\n            yield 0\n            raise RuntimeError\n            yield from count(1)\n\n        it = mi.ichunked(gen(), 4)\n        chunk = next(it)\n        self.assertEqual(next(chunk), 0)\n        self.assertRaises(RuntimeError, next, it)\n\n    def test_memory_in_order(self):\n        gen_numbers = []\n\n        def gen():\n            for gen_number in count():\n                gen_numbers.append(gen_number)\n                yield gen_number\n\n        # No items should be kept in memory when a ichunked is first called\n        all_chunks = mi.ichunked(gen(), 4)\n        self.assertEqual(gen_numbers, [])\n\n        # The first item of each chunk should be generated on chunk generation\n        first_chunk = next(all_chunks)\n        self.assertEqual(gen_numbers, [0])\n\n        # If we don't read a chunk before getting its successor, its contents\n        # will be cached\n        second_chunk = next(all_chunks)\n        self.assertEqual(gen_numbers, [0, 1, 2, 3, 4])\n\n        # Check if we can read in cached values\n        self.assertEqual(list(first_chunk), [0, 1, 2, 3])\n        self.assertEqual(list(second_chunk), [4, 5, 6, 7])\n\n        # Again only the most recent chunk should have an item cached\n        third_chunk = next(all_chunks)\n        self.assertEqual(len(gen_numbers), 9)\n\n        # No new item should be cached when reading past the first number\n        next(third_chunk)\n        self.assertEqual(len(gen_numbers), 9)\n\n        # we should not be able to read spent chunks\n        self.assertEqual(list(first_chunk), [])\n        self.assertEqual(list(second_chunk), [])\n\n\nclass DistinctCombinationsTests(TestCase):\n    def test_basic(self):\n        for iterable in [\n            (1, 2, 2, 3, 3, 3),  # In order\n            range(6),  # All distinct\n            'abbccc',  # Not numbers\n            'cccbba',  # Backward\n            'mississippi',  # No particular order\n        ]:\n            for r in range(len(iterable)):\n                with self.subTest(iterable=iterable, r=r):\n                    actual = list(mi.distinct_combinations(iterable, r))\n                    expected = list(\n                        mi.unique_everseen(combinations(iterable, r))\n                    )\n                    self.assertEqual(actual, expected)\n\n    def test_negative(self):\n        with self.assertRaises(ValueError):\n            list(mi.distinct_combinations([], -1))\n\n    def test_empty(self):\n        self.assertEqual(list(mi.distinct_combinations([], 2)), [])\n\n\nclass FilterExceptTests(TestCase):\n    def test_no_exceptions_pass(self):\n        iterable = '0123'\n        actual = list(mi.filter_except(int, iterable))\n        expected = ['0', '1', '2', '3']\n        self.assertEqual(actual, expected)\n\n    def test_no_exceptions_raise(self):\n        iterable = ['0', '1', 'two', '3']\n        with self.assertRaises(ValueError):\n            list(mi.filter_except(int, iterable))\n\n    def test_raise(self):\n        iterable = ['0', '1' '2', 'three', None]\n        with self.assertRaises(TypeError):\n            list(mi.filter_except(int, iterable, ValueError))\n\n    def test_false(self):\n        # Even if the validator returns false, we pass through\n        validator = lambda x: False\n        iterable = ['0', '1', '2', 'three', None]\n        actual = list(mi.filter_except(validator, iterable, Exception))\n        expected = ['0', '1', '2', 'three', None]\n        self.assertEqual(actual, expected)\n\n    def test_multiple(self):\n        iterable = ['0', '1', '2', 'three', None, '4']\n        actual = list(mi.filter_except(int, iterable, ValueError, TypeError))\n        expected = ['0', '1', '2', '4']\n        self.assertEqual(actual, expected)\n\n\nclass MapExceptTests(TestCase):\n    def test_no_exceptions_pass(self):\n        iterable = '0123'\n        actual = list(mi.map_except(int, iterable))\n        expected = [0, 1, 2, 3]\n        self.assertEqual(actual, expected)\n\n    def test_no_exceptions_raise(self):\n        iterable = ['0', '1', 'two', '3']\n        with self.assertRaises(ValueError):\n            list(mi.map_except(int, iterable))\n\n    def test_raise(self):\n        iterable = ['0', '1' '2', 'three', None]\n        with self.assertRaises(TypeError):\n            list(mi.map_except(int, iterable, ValueError))\n\n    def test_multiple(self):\n        iterable = ['0', '1', '2', 'three', None, '4']\n        actual = list(mi.map_except(int, iterable, ValueError, TypeError))\n        expected = [0, 1, 2, 4]\n        self.assertEqual(actual, expected)\n\n\nclass MapIfTests(TestCase):\n    def test_without_func_else(self):\n        iterable = list(range(-5, 5))\n        actual = list(mi.map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n        expected = [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n        self.assertEqual(actual, expected)\n\n    def test_with_func_else(self):\n        iterable = list(range(-5, 5))\n        actual = list(\n            mi.map_if(\n                iterable, lambda x: x >= 0, lambda x: 'notneg', lambda x: 'neg'\n            )\n        )\n        expected = ['neg'] * 5 + ['notneg'] * 5\n        self.assertEqual(actual, expected)\n\n    def test_empty(self):\n        actual = list(mi.map_if([], lambda x: len(x) > 5, lambda x: None))\n        expected = []\n        self.assertEqual(actual, expected)\n\n\nclass SampleTests(TestCase):\n    def test_unit_case(self):\n        \"\"\"Test against a fixed case by seeding the random module.\"\"\"\n        # Beware that this test really just verifies random.random() behavior.\n        # If the algorithm is changed (e.g. to a more naive implementation)\n        # this test will fail, but the algorithm might be correct.\n        # Also, this test can pass and the algorithm can be completely wrong.\n        data = \"abcdef\"\n        weights = list(range(1, len(data) + 1))\n        seed(123)\n        actual = mi.sample(data, k=2, weights=weights)\n        expected = ['f', 'e']\n        self.assertEqual(actual, expected)\n\n    def test_negative(self):\n        data = [1, 2, 3, 4, 5]\n        with self.assertRaises(ValueError):\n            mi.sample(data, k=-1)\n\n    def test_length(self):\n        \"\"\"Check that *k* elements are sampled.\"\"\"\n        data = [1, 2, 3, 4, 5]\n        for k in [0, 3, 5, 7]:\n            sampled = mi.sample(data, k=k)\n            actual = len(sampled)\n            expected = min(k, len(data))\n            self.assertEqual(actual, expected)\n\n    def test_strict(self):\n        data = ['1', '2', '3', '4', '5']\n        self.assertEqual(set(mi.sample(data, 6, strict=False)), set(data))\n        with self.assertRaises(ValueError):\n            mi.sample(data, 6, strict=True)\n\n    def test_sampling_entire_iterable(self):\n        \"\"\"If k=len(iterable), the sample contains the original elements.\"\"\"\n        data = [\"a\", 2, \"a\", 4, (1, 2, 3)]\n        actual = set(mi.sample(data, k=len(data)))\n        expected = set(data)\n        self.assertEqual(actual, expected)\n\n    def test_scale_invariance_of_weights(self):\n        \"\"\"The probability of choosing element a_i is w_i / sum(weights).\n        Scaling weights should not change the probability or outcome.\"\"\"\n        data = \"abcdef\"\n\n        weights = list(range(1, len(data) + 1))\n        seed(123)\n        first_sample = mi.sample(data, k=2, weights=weights)\n\n        # Scale the weights and sample again\n        weights_scaled = [w / 1e10 for w in weights]\n        seed(123)\n        second_sample = mi.sample(data, k=2, weights=weights_scaled)\n\n        self.assertEqual(first_sample, second_sample)\n\n    def test_invariance_under_permutations_unweighted(self):\n        \"\"\"The order of the data should not matter. This is a stochastic test,\n        but it will fail in less than 1 / 10_000 cases.\"\"\"\n\n        # Create a data set and a reversed data set\n        data = list(range(100))\n        data_rev = list(reversed(data))\n\n        # Sample each data set 10 times\n        data_means = [mean(mi.sample(data, k=50)) for _ in range(10)]\n        data_rev_means = [mean(mi.sample(data_rev, k=50)) for _ in range(10)]\n\n        # The difference in the means should be low, i.e. little bias\n        difference_in_means = abs(mean(data_means) - mean(data_rev_means))\n\n        # The observed largest difference in 10,000 simulations was 5.09599\n        self.assertTrue(difference_in_means < 5.1)\n\n    def test_invariance_under_permutations_weighted(self):\n        \"\"\"The order of the data should not matter. This is a stochastic test,\n        but it will fail in less than 1 / 10_000 cases.\"\"\"\n\n        # Create a data set and a reversed data set\n        data = list(range(1, 101))\n        data_rev = list(reversed(data))\n\n        # Sample each data set 10 times\n        data_means = [\n            mean(mi.sample(data, k=50, weights=data)) for _ in range(10)\n        ]\n        data_rev_means = [\n            mean(mi.sample(data_rev, k=50, weights=data_rev))\n            for _ in range(10)\n        ]\n\n        # The difference in the means should be low, i.e. little bias\n        difference_in_means = abs(mean(data_means) - mean(data_rev_means))\n\n        # The observed largest difference in 10,000 simulations was 4.337999\n        self.assertTrue(difference_in_means < 4.4)\n\n\nclass IsSortedTests(TestCase):\n    def test_basic(self):\n        for iterable, kwargs, expected in [\n            ([], {}, True),\n            ([1], {}, True),\n            ([1, 2, 3], {}, True),\n            ([1, 1, 2, 3], {}, True),\n            ([1, 10, 2, 3], {}, False),\n            (['1', '10', '2', '3'], {}, True),\n            (['1', '10', '2', '3'], {'key': int}, False),\n            ([1, 2, 3], {'reverse': True}, False),\n            ([1, 1, 2, 3], {'reverse': True}, False),\n            ([1, 10, 2, 3], {'reverse': True}, False),\n            (['3', '2', '10', '1'], {'reverse': True}, True),\n            (['3', '2', '10', '1'], {'key': int, 'reverse': True}, False),\n            # strict\n            ([], {'strict': True}, True),\n            ([1], {'strict': True}, True),\n            ([1, 1], {'strict': True}, False),\n            ([1, 2, 3], {'strict': True}, True),\n            ([1, 1, 2, 3], {'strict': True}, False),\n            ([1, 10, 2, 3], {'strict': True}, False),\n            (['1', '10', '2', '3'], {'strict': True}, True),\n            (['1', '10', '2', '3', '3'], {'strict': True}, False),\n            (['1', '10', '2', '3'], {'strict': True, 'key': int}, False),\n            ([1, 2, 3], {'strict': True, 'reverse': True}, False),\n            ([1, 1, 2, 3], {'strict': True, 'reverse': True}, False),\n            ([1, 10, 2, 3], {'strict': True, 'reverse': True}, False),\n            (['3', '2', '10', '1'], {'strict': True, 'reverse': True}, True),\n            (\n                ['3', '2', '10', '10', '1'],\n                {'strict': True, 'reverse': True},\n                False,\n            ),\n            (\n                ['3', '2', '10', '1'],\n                {'strict': True, 'key': int, 'reverse': True},\n                False,\n            ),\n            # We'll do the same weird thing as Python here\n            (['nan', 0, 'nan', 0], {'key': float}, True),\n            ([0, 'nan', 0, 'nan'], {'key': float}, True),\n            (['nan', 0, 'nan', 0], {'key': float, 'reverse': True}, True),\n            ([0, 'nan', 0, 'nan'], {'key': float, 'reverse': True}, True),\n            ([0, 'nan', 0, 'nan'], {'strict': True, 'key': float}, True),\n            (\n                ['nan', 0, 'nan', 0],\n                {'strict': True, 'key': float, 'reverse': True},\n                True,\n            ),\n        ]:\n            key = kwargs.get('key', None)\n            reverse = kwargs.get('reverse', False)\n            strict = kwargs.get('strict', False)\n\n            with self.subTest(\n                iterable=iterable, key=key, reverse=reverse, strict=strict\n            ):\n                mi_result = mi.is_sorted(\n                    iter(iterable), key=key, reverse=reverse, strict=strict\n                )\n\n                sorted_iterable = sorted(iterable, key=key, reverse=reverse)\n                if strict:\n                    sorted_iterable = list(mi.unique_justseen(sorted_iterable))\n\n                py_result = iterable == sorted_iterable\n\n                self.assertEqual(mi_result, expected)\n                self.assertEqual(mi_result, py_result)\n\n\nclass CallbackIterTests(TestCase):\n    def _target(self, cb=None, exc=None, wait=0):\n        total = 0\n        for i, c in enumerate('abc', 1):\n            total += i\n            if wait:\n                sleep(wait)\n            if cb:\n                cb(i, c, intermediate_total=total)\n            if exc:\n                raise exc('error in target')\n\n        return total\n\n    def test_basic(self):\n        func = lambda callback=None: self._target(cb=callback, wait=0.02)\n        with mi.callback_iter(func, wait_seconds=0.01) as it:\n            # Execution doesn't start until we begin iterating\n            self.assertFalse(it.done)\n\n            # Consume everything\n            self.assertEqual(\n                list(it),\n                [\n                    ((1, 'a'), {'intermediate_total': 1}),\n                    ((2, 'b'), {'intermediate_total': 3}),\n                    ((3, 'c'), {'intermediate_total': 6}),\n                ],\n            )\n\n            # After consuming everything the future is done and the\n            # result is available.\n            self.assertTrue(it.done)\n            self.assertEqual(it.result, 6)\n\n        # This examines the internal state of the ThreadPoolExecutor. This\n        # isn't documented, so may break in future Python versions.\n        self.assertTrue(it._executor._shutdown)\n\n    def test_callback_kwd(self):\n        with mi.callback_iter(self._target, callback_kwd='cb') as it:\n            self.assertEqual(\n                list(it),\n                [\n                    ((1, 'a'), {'intermediate_total': 1}),\n                    ((2, 'b'), {'intermediate_total': 3}),\n                    ((3, 'c'), {'intermediate_total': 6}),\n                ],\n            )\n\n    def test_partial_consumption(self):\n        func = lambda callback=None: self._target(cb=callback)\n        with mi.callback_iter(func) as it:\n            self.assertEqual(next(it), ((1, 'a'), {'intermediate_total': 1}))\n\n        self.assertTrue(it._executor._shutdown)\n\n    def test_abort(self):\n        func = lambda callback=None: self._target(cb=callback, wait=0.1)\n        with mi.callback_iter(func) as it:\n            self.assertEqual(next(it), ((1, 'a'), {'intermediate_total': 1}))\n\n        with self.assertRaises(mi.AbortThread):\n            it.result\n\n    def test_no_result(self):\n        func = lambda callback=None: self._target(cb=callback)\n        with mi.callback_iter(func) as it:\n            with self.assertRaises(RuntimeError):\n                it.result\n\n    def test_exception(self):\n        func = lambda callback=None: self._target(cb=callback, exc=ValueError)\n        with mi.callback_iter(func) as it:\n            self.assertEqual(\n                next(it),\n                ((1, 'a'), {'intermediate_total': 1}),\n            )\n\n            with self.assertRaises(ValueError):\n                it.result\n\n\nclass WindowedCompleteTests(TestCase):\n    \"\"\"Tests for ``windowed_complete()``\"\"\"\n\n    def test_basic(self):\n        actual = list(mi.windowed_complete([1, 2, 3, 4, 5], 3))\n        expected = [\n            ((), (1, 2, 3), (4, 5)),\n            ((1,), (2, 3, 4), (5,)),\n            ((1, 2), (3, 4, 5), ()),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_zero_length(self):\n        actual = list(mi.windowed_complete([1, 2, 3], 0))\n        expected = [\n            ((), (), (1, 2, 3)),\n            ((1,), (), (2, 3)),\n            ((1, 2), (), (3,)),\n            ((1, 2, 3), (), ()),\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_wrong_length(self):\n        seq = [1, 2, 3, 4, 5]\n        for n in (-10, -1, len(seq) + 1, len(seq) + 10):\n            with self.subTest(n=n):\n                with self.assertRaises(ValueError):\n                    list(mi.windowed_complete(seq, n))\n\n    def test_every_partition(self):\n        every_partition = lambda seq: chain(\n            *map(partial(mi.windowed_complete, seq), range(len(seq)))\n        )\n\n        seq = 'ABC'\n        actual = list(every_partition(seq))\n        expected = [\n            ((), (), ('A', 'B', 'C')),\n            (('A',), (), ('B', 'C')),\n            (('A', 'B'), (), ('C',)),\n            (('A', 'B', 'C'), (), ()),\n            ((), ('A',), ('B', 'C')),\n            (('A',), ('B',), ('C',)),\n            (('A', 'B'), ('C',), ()),\n            ((), ('A', 'B'), ('C',)),\n            (('A',), ('B', 'C'), ()),\n        ]\n        self.assertEqual(actual, expected)\n\n\nclass AllUniqueTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in [\n            ([], True),\n            ([1, 2, 3], True),\n            ([1, 1], False),\n            ([1, 2, 3, 1], False),\n            ([1, 2, 3, '1'], True),\n        ]:\n            with self.subTest(args=(iterable,)):\n                self.assertEqual(mi.all_unique(iterable), expected)\n\n    def test_non_hashable(self):\n        self.assertEqual(mi.all_unique([[1, 2], [3, 4]]), True)\n        self.assertEqual(mi.all_unique([[1, 2], [3, 4], [1, 2]]), False)\n\n    def test_partially_hashable(self):\n        self.assertEqual(mi.all_unique([[1, 2], [3, 4], (5, 6)]), True)\n        self.assertEqual(\n            mi.all_unique([[1, 2], [3, 4], (5, 6), [1, 2]]), False\n        )\n        self.assertEqual(\n            mi.all_unique([[1, 2], [3, 4], (5, 6), (5, 6)]), False\n        )\n\n    def test_key(self):\n        iterable = ['A', 'B', 'C', 'b']\n        self.assertEqual(mi.all_unique(iterable, lambda x: x), True)\n        self.assertEqual(mi.all_unique(iterable, str.lower), False)\n\n    def test_infinite(self):\n        self.assertEqual(mi.all_unique(mi.prepend(3, count())), False)\n\n\nclass NthProductTests(TestCase):\n    def test_basic(self):\n        iterables = ['ab', 'cdef', 'ghi']\n        for index, expected in enumerate(product(*iterables)):\n            actual = mi.nth_product(index, *iterables)\n            self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.nth_product(1337, range(101), range(22), range(53))\n        expected = (1, 3, 12)\n        self.assertEqual(actual, expected)\n\n    def test_negative(self):\n        iterables = ['abc', 'de', 'fghi']\n        for index, expected in enumerate(product(*iterables)):\n            actual = mi.nth_product(index - 24, *iterables)\n            self.assertEqual(actual, expected)\n\n    def test_invalid_index(self):\n        with self.assertRaises(IndexError):\n            mi.nth_product(24, 'ab', 'cde', 'fghi')\n\n\nclass NthCombinationWithReplacementTests(TestCase):\n    def test_basic(self):\n        iterable = 'abcdefg'\n        r = 4\n        for index, expected in enumerate(\n            combinations_with_replacement(iterable, r)\n        ):\n            actual = mi.nth_combination_with_replacement(iterable, r, index)\n            self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.nth_combination_with_replacement(range(90), 4, 2000000)\n        expected = (22, 65, 68, 81)\n        self.assertEqual(actual, expected)\n\n    def test_invalid_r(self):\n        for r in (-1, 3):\n            with self.assertRaises(ValueError):\n                mi.nth_combination_with_replacement([], r, 0)\n\n    def test_invalid_index(self):\n        with self.assertRaises(IndexError):\n            mi.nth_combination_with_replacement('abcdefg', 3, -85)\n\n\nclass ValueChainTests(TestCase):\n    def test_empty(self):\n        actual = list(mi.value_chain())\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_simple(self):\n        actual = list(mi.value_chain(1, 2.71828, False, 'foo'))\n        expected = [1, 2.71828, False, 'foo']\n        self.assertEqual(actual, expected)\n\n    def test_more(self):\n        actual = list(mi.value_chain(b'bar', [1, 2, 3], 4, {'key': 1}))\n        expected = [b'bar', 1, 2, 3, 4, 'key']\n        self.assertEqual(actual, expected)\n\n    def test_empty_lists(self):\n        actual = list(mi.value_chain(1, 2, [], [3, 4]))\n        expected = [1, 2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_complex(self):\n        obj = object()\n        actual = list(\n            mi.value_chain(\n                (1, (2, (3,))),\n                ['foo', ['bar', ['baz']], 'tic'],\n                {'key': {'foo': 1}},\n                obj,\n            )\n        )\n        expected = [1, (2, (3,)), 'foo', ['bar', ['baz']], 'tic', 'key', obj]\n        self.assertEqual(actual, expected)\n\n\nclass ProductIndexTests(TestCase):\n    def test_basic(self):\n        iterables = ['ab', 'cdef', 'ghi']\n        first_index = {}\n        for index, element in enumerate(product(*iterables)):\n            actual = mi.product_index(element, *iterables)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_multiplicity(self):\n        iterables = ['ab', 'bab', 'cab']\n        first_index = {}\n        for index, element in enumerate(product(*iterables)):\n            actual = mi.product_index(element, *iterables)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.product_index((1, 3, 12), range(101), range(22), range(53))\n        expected = 1337\n        self.assertEqual(actual, expected)\n\n    def test_invalid_empty(self):\n        with self.assertRaises(ValueError):\n            mi.product_index('', 'ab', 'cde', 'fghi')\n\n    def test_invalid_small(self):\n        with self.assertRaises(ValueError):\n            mi.product_index('ac', 'ab', 'cde', 'fghi')\n\n    def test_invalid_large(self):\n        with self.assertRaises(ValueError):\n            mi.product_index('achi', 'ab', 'cde', 'fghi')\n\n    def test_invalid_match(self):\n        with self.assertRaises(ValueError):\n            mi.product_index('axf', 'ab', 'cde', 'fghi')\n\n\nclass CombinationIndexTests(TestCase):\n    def test_r_less_than_n(self):\n        iterable = 'abcdefg'\n        r = 4\n        first_index = {}\n        for index, element in enumerate(combinations(iterable, r)):\n            actual = mi.combination_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_r_equal_to_n(self):\n        iterable = 'abcd'\n        r = len(iterable)\n        first_index = {}\n        for index, element in enumerate(combinations(iterable, r=r)):\n            actual = mi.combination_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_multiplicity(self):\n        iterable = 'abacba'\n        r = 3\n        first_index = {}\n        for index, element in enumerate(combinations(iterable, r)):\n            actual = mi.combination_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_null(self):\n        actual = mi.combination_index(tuple(), [])\n        expected = 0\n        self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.combination_index((2, 12, 35, 126), range(180))\n        expected = 2000000\n        self.assertEqual(actual, expected)\n\n    def test_invalid_order(self):\n        with self.assertRaises(ValueError):\n            mi.combination_index(tuple('acb'), 'abcde')\n\n    def test_invalid_large(self):\n        with self.assertRaises(ValueError):\n            mi.combination_index(tuple('abcdefg'), 'abcdef')\n\n    def test_invalid_match(self):\n        with self.assertRaises(ValueError):\n            mi.combination_index(tuple('axe'), 'abcde')\n\n\nclass CombinationWithReplacementIndexTests(TestCase):\n    def test_r_less_than_n(self):\n        iterable = 'abcdefg'\n        r = 4\n        first_index = {}\n        for index, element in enumerate(\n            combinations_with_replacement(iterable, r)\n        ):\n            actual = mi.combination_with_replacement_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_r_equal_to_n(self):\n        iterable = 'abcd'\n        r = len(iterable)\n        first_index = {}\n        for index, element in enumerate(\n            combinations_with_replacement(iterable, r=r)\n        ):\n            actual = mi.combination_with_replacement_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_multiplicity(self):\n        iterable = 'abacba'\n        r = 3\n        first_index = {}\n        for index, element in enumerate(\n            combinations_with_replacement(iterable, r)\n        ):\n            actual = mi.combination_with_replacement_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_null(self):\n        actual = mi.combination_with_replacement_index(tuple(), [])\n        expected = 0\n        self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.combination_with_replacement_index(\n            (22, 65, 68, 81), range(90)\n        )\n        expected = 2000000\n        self.assertEqual(actual, expected)\n\n    def test_invalid_order(self):\n        with self.assertRaises(ValueError):\n            mi.combination_with_replacement_index(tuple('acb'), 'abcde')\n\n    def test_invalid_large(self):\n        with self.assertRaises(ValueError):\n            mi.combination_with_replacement_index(tuple('abcdefg'), 'abcdef')\n\n    def test_invalid_match(self):\n        with self.assertRaises(ValueError):\n            mi.combination_with_replacement_index(tuple('axe'), 'abcde')\n\n\nclass PermutationIndexTests(TestCase):\n    def test_r_less_than_n(self):\n        iterable = 'abcdefg'\n        r = 4\n        first_index = {}\n        for index, element in enumerate(permutations(iterable, r)):\n            actual = mi.permutation_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_r_equal_to_n(self):\n        iterable = 'abcd'\n        first_index = {}\n        for index, element in enumerate(permutations(iterable)):\n            actual = mi.permutation_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_multiplicity(self):\n        iterable = 'abacba'\n        r = 3\n        first_index = {}\n        for index, element in enumerate(permutations(iterable, r)):\n            actual = mi.permutation_index(element, iterable)\n            expected = first_index.setdefault(element, index)\n            self.assertEqual(actual, expected)\n\n    def test_null(self):\n        actual = mi.permutation_index(tuple(), [])\n        expected = 0\n        self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.permutation_index((2, 12, 35, 126), range(180))\n        expected = 11631678\n        self.assertEqual(actual, expected)\n\n    def test_invalid_large(self):\n        with self.assertRaises(ValueError):\n            mi.permutation_index(tuple('abcdefg'), 'abcdef')\n\n    def test_invalid_match(self):\n        with self.assertRaises(ValueError):\n            mi.permutation_index(tuple('axe'), 'abcde')\n\n\nclass CountableTests(TestCase):\n    def test_empty(self):\n        iterable = []\n        it = mi.countable(iterable)\n        self.assertEqual(it.items_seen, 0)\n        self.assertEqual(list(it), [])\n\n    def test_basic(self):\n        iterable = '0123456789'\n        it = mi.countable(iterable)\n        self.assertEqual(it.items_seen, 0)\n        self.assertEqual(next(it), '0')\n        self.assertEqual(it.items_seen, 1)\n        self.assertEqual(''.join(it), '123456789')\n        self.assertEqual(it.items_seen, 10)\n\n\nclass ChunkedEvenTests(TestCase):\n    \"\"\"Tests for ``chunked_even()``\"\"\"\n\n    def test_0(self):\n        self._test_finite('', 3, [])\n\n    def test_1(self):\n        self._test_finite('A', 1, [['A']])\n\n    def test_4(self):\n        self._test_finite('ABCD', 3, [['A', 'B'], ['C', 'D']])\n\n    def test_5(self):\n        self._test_finite('ABCDE', 3, [['A', 'B', 'C'], ['D', 'E']])\n\n    def test_6(self):\n        self._test_finite('ABCDEF', 3, [['A', 'B', 'C'], ['D', 'E', 'F']])\n\n    def test_7(self):\n        self._test_finite(\n            'ABCDEFG', 3, [['A', 'B', 'C'], ['D', 'E'], ['F', 'G']]\n        )\n\n    def _test_finite(self, seq, n, expected):\n        # Check with and without `len()`\n        self.assertEqual(list(mi.chunked_even(seq, n)), expected)\n        self.assertEqual(list(mi.chunked_even(iter(seq), n)), expected)\n\n    def test_infinite(self):\n        for n in range(1, 5):\n            k = 0\n\n            def count_with_assert():\n                for i in count():\n                    # Look-ahead should be less than n^2\n                    self.assertLessEqual(i, n * k + n * n)\n                    yield i\n\n            ls = mi.chunked_even(count_with_assert(), n)\n            while k < 2:\n                self.assertEqual(next(ls), list(range(k * n, (k + 1) * n)))\n                k += 1\n\n    def test_evenness(self):\n        for N in range(1, 50):\n            for n in range(1, N + 2):\n                lengths = []\n                items = []\n                for l in mi.chunked_even(range(N), n):\n                    L = len(l)\n                    self.assertLessEqual(L, n)\n                    self.assertGreaterEqual(L, 1)\n                    lengths.append(L)\n                    items.extend(l)\n                self.assertEqual(items, list(range(N)))\n                self.assertLessEqual(max(lengths) - min(lengths), 1)\n\n\nclass ZipBroadcastTests(TestCase):\n    def test_zip(self):\n        for objects, zipped, strict_ok in [\n            # Empty\n            ([], [], True),\n            # One argument\n            ([1], [(1,)], True),\n            ([[1]], [(1,)], True),\n            ([[1, 2]], [(1,), (2,)], True),\n            # All scalars\n            ([1, 2], [(1, 2)], True),\n            ([1, 2, 3], [(1, 2, 3)], True),\n            # Iterables with length = 0\n            ([[], 1], [], True),\n            ([1, []], [], True),\n            ([[], []], [], True),\n            ([[], 1, 2], [], True),\n            ([[], 1, []], [], True),\n            ([1, [], 2], [], True),\n            ([1, [], []], [], True),\n            ([[], [], 1], [], True),\n            ([[], [], []], [], True),\n            # Iterables with length = 1\n            ([1, [2]], [(1, 2)], True),\n            ([[1], 2], [(1, 2)], True),\n            ([[1], [2]], [(1, 2)], True),\n            ([1, [2], 3], [(1, 2, 3)], True),\n            ([1, [2], [3]], [(1, 2, 3)], True),\n            ([[1], 2, 3], [(1, 2, 3)], True),\n            ([[1], 2, [3]], [(1, 2, 3)], True),\n            ([[1], [2], 3], [(1, 2, 3)], True),\n            ([[1], [2], [3]], [(1, 2, 3)], True),\n            # Iterables with length > 1\n            ([1, [2, 3]], [(1, 2), (1, 3)], True),\n            ([[1, 2], 3], [(1, 3), (2, 3)], True),\n            ([[1, 2], [3, 4]], [(1, 3), (2, 4)], True),\n            ([1, [2, 3], 4], [(1, 2, 4), (1, 3, 4)], True),\n            ([1, [2, 3], [4, 5]], [(1, 2, 4), (1, 3, 5)], True),\n            ([[1, 2], 3, 4], [(1, 3, 4), (2, 3, 4)], True),\n            ([[1, 2], 3, [4, 5]], [(1, 3, 4), (2, 3, 5)], True),\n            ([[1, 2], [3, 4], 5], [(1, 3, 5), (2, 4, 5)], True),\n            ([[1, 2], [3, 4], [5, 6]], [(1, 3, 5), (2, 4, 6)], True),\n            # Iterables with different lengths\n            ([[], [1]], [], False),\n            ([[1], []], [], False),\n            ([[1], [2, 3]], [(1, 2)], False),\n            ([[1, 2], [3]], [(1, 3)], False),\n            ([[1, 2], [3], [4]], [(1, 3, 4)], False),\n            ([[1], [2, 3], [4]], [(1, 2, 4)], False),\n            ([[1], [2], [3, 4]], [(1, 2, 3)], False),\n            ([[1], [2, 3], [4, 5]], [(1, 2, 4)], False),\n            ([[1, 2], [3], [4, 5]], [(1, 3, 4)], False),\n            ([[1, 2], [3, 4], [5]], [(1, 3, 5)], False),\n            ([1, [2, 3], [4, 5, 6]], [(1, 2, 4), (1, 3, 5)], False),\n            ([[1, 2], 3, [4, 5, 6]], [(1, 3, 4), (2, 3, 5)], False),\n            ([1, [2, 3, 4], [5, 6]], [(1, 2, 5), (1, 3, 6)], False),\n            ([[1, 2, 3], 4, [5, 6]], [(1, 4, 5), (2, 4, 6)], False),\n            ([[1, 2], [3, 4, 5], 6], [(1, 3, 6), (2, 4, 6)], False),\n            ([[1, 2, 3], [4, 5], 6], [(1, 4, 6), (2, 5, 6)], False),\n            # Infinite\n            ([count(), 1, [2]], [(0, 1, 2)], False),\n            ([count(), 1, [2, 3]], [(0, 1, 2), (1, 1, 3)], False),\n            # Miscellaneous\n            (['a', [1, 2], [3, 4, 5]], [('a', 1, 3), ('a', 2, 4)], False),\n        ]:\n            # Truncate by default\n            with self.subTest(objects=objects, strict=False, zipped=zipped):\n                self.assertEqual(list(mi.zip_broadcast(*objects)), zipped)\n\n            # Raise an exception for strict=True\n            with self.subTest(objects=objects, strict=True, zipped=zipped):\n                if strict_ok:\n                    self.assertEqual(\n                        list(mi.zip_broadcast(*objects, strict=True)),\n                        zipped,\n                    )\n                else:\n                    with self.assertRaises(ValueError):\n                        list(mi.zip_broadcast(*objects, strict=True))\n\n    def test_scalar_types(self):\n        # Default: str and bytes are treated as scalar\n        self.assertEqual(\n            list(mi.zip_broadcast('ab', [1, 2, 3])),\n            [('ab', 1), ('ab', 2), ('ab', 3)],\n        )\n        self.assertEqual(\n            list(mi.zip_broadcast(b'ab', [1, 2, 3])),\n            [(b'ab', 1), (b'ab', 2), (b'ab', 3)],\n        )\n        # scalar_types=None allows str and bytes to be treated as iterable\n        self.assertEqual(\n            list(mi.zip_broadcast('abc', [1, 2, 3], scalar_types=None)),\n            [('a', 1), ('b', 2), ('c', 3)],\n        )\n        # Use a custom type\n        self.assertEqual(\n            list(mi.zip_broadcast({'a': 'b'}, [1, 2, 3], scalar_types=dict)),\n            [({'a': 'b'}, 1), ({'a': 'b'}, 2), ({'a': 'b'}, 3)],\n        )\n\n\nclass UniqueInWindowTests(TestCase):\n    def test_invalid_n(self):\n        with self.assertRaises(ValueError):\n            list(mi.unique_in_window([], 0))\n\n    def test_basic(self):\n        for iterable, n, expected in [\n            (range(9), 10, list(range(9))),\n            (range(20), 10, list(range(20))),\n            ([1, 2, 3, 4, 4, 4], 1, [1, 2, 3, 4, 4, 4]),\n            ([1, 2, 3, 4, 4, 4], 2, [1, 2, 3, 4]),\n            ([1, 2, 3, 4, 4, 4], 3, [1, 2, 3, 4]),\n            ([1, 2, 3, 4, 4, 4], 4, [1, 2, 3, 4]),\n            ([1, 2, 3, 4, 4, 4], 5, [1, 2, 3, 4]),\n            (\n                [0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 2, 3, 4, 2],\n                2,\n                [0, 1, 0, 2, 3, 4, 2],\n            ),\n        ]:\n            with self.subTest(expected=expected):\n                actual = list(mi.unique_in_window(iterable, n))\n                self.assertEqual(actual, expected)\n\n    def test_key(self):\n        iterable = [0, 1, 3, 4, 5, 6, 7, 8, 9]\n        n = 3\n        key = lambda x: x // 3\n        actual = list(mi.unique_in_window(iterable, n, key=key))\n        expected = [0, 3, 6, 9]\n        self.assertEqual(actual, expected)\n\n\nclass StrictlyNTests(TestCase):\n    def test_basic(self):\n        iterable = ['a', 'b', 'c', 'd']\n        n = 4\n        actual = list(mi.strictly_n(iter(iterable), n))\n        expected = iterable\n        self.assertEqual(actual, expected)\n\n    def test_too_short_default(self):\n        iterable = ['a', 'b', 'c', 'd']\n        n = 5\n        with self.assertRaises(ValueError) as exc:\n            list(mi.strictly_n(iter(iterable), n))\n\n        self.assertEqual(\n            'Too few items in iterable (got 4)', exc.exception.args[0]\n        )\n\n    def test_too_long_default(self):\n        iterable = ['a', 'b', 'c', 'd']\n        n = 3\n        with self.assertRaises(ValueError) as cm:\n            list(mi.strictly_n(iter(iterable), n))\n\n        self.assertEqual(\n            'Too many items in iterable (got at least 4)',\n            cm.exception.args[0],\n        )\n\n    def test_too_short_custom(self):\n        call_count = 0\n\n        def too_short(item_count):\n            nonlocal call_count\n            call_count += 1\n\n        iterable = ['a', 'b', 'c', 'd']\n        n = 6\n        actual = []\n        for item in mi.strictly_n(iter(iterable), n, too_short=too_short):\n            actual.append(item)\n        expected = ['a', 'b', 'c', 'd']\n        self.assertEqual(actual, expected)\n        self.assertEqual(call_count, 1)\n\n    def test_too_long_custom(self):\n        import logging\n\n        iterable = ['a', 'b', 'c', 'd']\n        n = 2\n        too_long = lambda item_count: logging.warning(\n            'Picked the first %s items', n\n        )\n\n        with self.assertLogs(level='WARNING') as cm:\n            actual = list(mi.strictly_n(iter(iterable), n, too_long=too_long))\n\n        self.assertEqual(actual, ['a', 'b'])\n        self.assertIn('Picked the first 2 items', cm.output[0])\n\n\nclass DuplicatesEverSeenTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in [\n            ([], []),\n            ([1, 2, 3], []),\n            ([1, 1], [1]),\n            ([1, 2, 1, 2], [1, 2]),\n            ([1, 2, 3, '1'], []),\n        ]:\n            with self.subTest(args=(iterable,)):\n                self.assertEqual(\n                    list(mi.duplicates_everseen(iterable)), expected\n                )\n\n    def test_non_hashable(self):\n        self.assertEqual(list(mi.duplicates_everseen([[1, 2], [3, 4]])), [])\n        self.assertEqual(\n            list(mi.duplicates_everseen([[1, 2], [3, 4], [1, 2]])), [[1, 2]]\n        )\n\n    def test_partially_hashable(self):\n        self.assertEqual(\n            list(mi.duplicates_everseen([[1, 2], [3, 4], (5, 6)])), []\n        )\n        self.assertEqual(\n            list(mi.duplicates_everseen([[1, 2], [3, 4], (5, 6), [1, 2]])),\n            [[1, 2]],\n        )\n        self.assertEqual(\n            list(mi.duplicates_everseen([[1, 2], [3, 4], (5, 6), (5, 6)])),\n            [(5, 6)],\n        )\n\n    def test_key_hashable(self):\n        iterable = 'HEheHEhe'\n        self.assertEqual(list(mi.duplicates_everseen(iterable)), list('HEhe'))\n        self.assertEqual(\n            list(mi.duplicates_everseen(iterable, str.lower)),\n            list('heHEhe'),\n        )\n\n    def test_key_non_hashable(self):\n        iterable = [[1, 2], [3, 0], [5, -2], [5, 6]]\n        self.assertEqual(\n            list(mi.duplicates_everseen(iterable, lambda x: x)), []\n        )\n        self.assertEqual(\n            list(mi.duplicates_everseen(iterable, sum)), [[3, 0], [5, -2]]\n        )\n\n    def test_key_partially_hashable(self):\n        iterable = [[1, 2], (1, 2), [1, 2], [5, 6]]\n        self.assertEqual(\n            list(mi.duplicates_everseen(iterable, lambda x: x)), [[1, 2]]\n        )\n        self.assertEqual(\n            list(mi.duplicates_everseen(iterable, list)), [(1, 2), [1, 2]]\n        )\n\n\nclass DuplicatesJustSeenTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in [\n            ([], []),\n            ([1, 2, 3, 3, 2, 2], [3, 2]),\n            ([1, 1], [1]),\n            ([1, 2, 1, 2], []),\n            ([1, 2, 3, '1'], []),\n        ]:\n            with self.subTest(args=(iterable,)):\n                self.assertEqual(\n                    list(mi.duplicates_justseen(iterable)), expected\n                )\n\n    def test_non_hashable(self):\n        self.assertEqual(list(mi.duplicates_justseen([[1, 2], [3, 4]])), [])\n        self.assertEqual(\n            list(\n                mi.duplicates_justseen(\n                    [[1, 2], [3, 4], [3, 4], [3, 4], [1, 2]]\n                )\n            ),\n            [[3, 4], [3, 4]],\n        )\n\n    def test_partially_hashable(self):\n        self.assertEqual(\n            list(mi.duplicates_justseen([[1, 2], [3, 4], (5, 6)])), []\n        )\n        self.assertEqual(\n            list(\n                mi.duplicates_justseen(\n                    [[1, 2], [3, 4], (5, 6), [1, 2], [1, 2]]\n                )\n            ),\n            [[1, 2]],\n        )\n        self.assertEqual(\n            list(\n                mi.duplicates_justseen(\n                    [[1, 2], [3, 4], (5, 6), (5, 6), (5, 6)]\n                )\n            ),\n            [(5, 6), (5, 6)],\n        )\n\n    def test_key_hashable(self):\n        iterable = 'HEheHHHhEheeEe'\n        self.assertEqual(list(mi.duplicates_justseen(iterable)), list('HHe'))\n        self.assertEqual(\n            list(mi.duplicates_justseen(iterable, str.lower)),\n            list('HHheEe'),\n        )\n\n    def test_key_non_hashable(self):\n        iterable = [[1, 2], [3, 0], [5, -2], [5, 6], [1, 2]]\n        self.assertEqual(\n            list(mi.duplicates_justseen(iterable, lambda x: x)), []\n        )\n        self.assertEqual(\n            list(mi.duplicates_justseen(iterable, sum)), [[3, 0], [5, -2]]\n        )\n\n    def test_key_partially_hashable(self):\n        iterable = [[1, 2], (1, 2), [1, 2], [5, 6], [1, 2]]\n        self.assertEqual(\n            list(mi.duplicates_justseen(iterable, lambda x: x)), []\n        )\n        self.assertEqual(\n            list(mi.duplicates_justseen(iterable, list)), [(1, 2), [1, 2]]\n        )\n\n    def test_nested(self):\n        iterable = [[[1, 2], [1, 2]], [5, 6], [5, 6]]\n        self.assertEqual(list(mi.duplicates_justseen(iterable)), [[5, 6]])\n\n\nclass ClassifyUniqueTests(TestCase):\n    def test_basic(self):\n        self.assertEqual(\n            list(mi.classify_unique('mississippi')),\n            [\n                ('m', True, True),\n                ('i', True, True),\n                ('s', True, True),\n                ('s', False, False),\n                ('i', True, False),\n                ('s', True, False),\n                ('s', False, False),\n                ('i', True, False),\n                ('p', True, True),\n                ('p', False, False),\n                ('i', True, False),\n            ],\n        )\n\n    def test_non_hashable(self):\n        self.assertEqual(\n            list(mi.classify_unique([[1, 2], [3, 4], [3, 4], [1, 2]])),\n            [\n                ([1, 2], True, True),\n                ([3, 4], True, True),\n                ([3, 4], False, False),\n                ([1, 2], True, False),\n            ],\n        )\n\n    def test_partially_hashable(self):\n        self.assertEqual(\n            list(\n                mi.classify_unique(\n                    [[1, 2], [3, 4], (5, 6), (5, 6), (3, 4), [1, 2]]\n                )\n            ),\n            [\n                ([1, 2], True, True),\n                ([3, 4], True, True),\n                ((5, 6), True, True),\n                ((5, 6), False, False),\n                ((3, 4), True, True),\n                ([1, 2], True, False),\n            ],\n        )\n\n    def test_key_hashable(self):\n        iterable = 'HEheHHHhEheeEe'\n        self.assertEqual(\n            list(mi.classify_unique(iterable)),\n            [\n                ('H', True, True),\n                ('E', True, True),\n                ('h', True, True),\n                ('e', True, True),\n                ('H', True, False),\n                ('H', False, False),\n                ('H', False, False),\n                ('h', True, False),\n                ('E', True, False),\n                ('h', True, False),\n                ('e', True, False),\n                ('e', False, False),\n                ('E', True, False),\n                ('e', True, False),\n            ],\n        )\n        self.assertEqual(\n            list(mi.classify_unique(iterable, str.lower)),\n            [\n                ('H', True, True),\n                ('E', True, True),\n                ('h', True, False),\n                ('e', True, False),\n                ('H', True, False),\n                ('H', False, False),\n                ('H', False, False),\n                ('h', False, False),\n                ('E', True, False),\n                ('h', True, False),\n                ('e', True, False),\n                ('e', False, False),\n                ('E', False, False),\n                ('e', False, False),\n            ],\n        )\n\n    def test_key_non_hashable(self):\n        iterable = [[1, 2], [3, 0], [5, -2], [5, 6], [1, 2]]\n        self.assertEqual(\n            list(mi.classify_unique(iterable, lambda x: x)),\n            [\n                ([1, 2], True, True),\n                ([3, 0], True, True),\n                ([5, -2], True, True),\n                ([5, 6], True, True),\n                ([1, 2], True, False),\n            ],\n        )\n        self.assertEqual(\n            list(mi.classify_unique(iterable, sum)),\n            [\n                ([1, 2], True, True),\n                ([3, 0], False, False),\n                ([5, -2], False, False),\n                ([5, 6], True, True),\n                ([1, 2], True, False),\n            ],\n        )\n\n    def test_key_partially_hashable(self):\n        iterable = [[1, 2], (1, 2), [1, 2], [5, 6], [1, 2]]\n        self.assertEqual(\n            list(mi.classify_unique(iterable, lambda x: x)),\n            [\n                ([1, 2], True, True),\n                ((1, 2), True, True),\n                ([1, 2], True, False),\n                ([5, 6], True, True),\n                ([1, 2], True, False),\n            ],\n        )\n        self.assertEqual(\n            list(mi.classify_unique(iterable, list)),\n            [\n                ([1, 2], True, True),\n                ((1, 2), False, False),\n                ([1, 2], False, False),\n                ([5, 6], True, True),\n                ([1, 2], True, False),\n            ],\n        )\n\n    def test_vs_unique_everseen(self):\n        input = 'AAAABBBBCCDAABBB'\n        output = [e for e, j, u in mi.classify_unique(input) if u]\n        self.assertEqual(output, ['A', 'B', 'C', 'D'])\n        self.assertEqual(list(mi.unique_everseen(input)), output)\n\n    def test_vs_unique_everseen_key(self):\n        input = 'aAbACCc'\n        output = [e for e, j, u in mi.classify_unique(input, str.lower) if u]\n        self.assertEqual(output, list('abC'))\n        self.assertEqual(list(mi.unique_everseen(input, str.lower)), output)\n\n    def test_vs_unique_justseen(self):\n        input = 'AAAABBBCCDABB'\n        output = [e for e, j, u in mi.classify_unique(input) if j]\n        self.assertEqual(output, list('ABCDAB'))\n        self.assertEqual(list(mi.unique_justseen(input)), output)\n\n    def test_vs_unique_justseen_key(self):\n        input = 'AABCcAD'\n        output = [e for e, j, u in mi.classify_unique(input, str.lower) if j]\n        self.assertEqual(output, list('ABCAD'))\n        self.assertEqual(list(mi.unique_justseen(input, str.lower)), output)\n\n    def test_vs_duplicates_everseen(self):\n        input = [1, 2, 1, 2]\n        output = [e for e, j, u in mi.classify_unique(input) if not u]\n        self.assertEqual(output, [1, 2])\n        self.assertEqual(list(mi.duplicates_everseen(input)), output)\n\n    def test_vs_duplicates_everseen_key(self):\n        input = 'HEheHEhe'\n        output = [\n            e for e, j, u in mi.classify_unique(input, str.lower) if not u\n        ]\n        self.assertEqual(output, list('heHEhe'))\n        self.assertEqual(\n            list(mi.duplicates_everseen(input, str.lower)), output\n        )\n\n    def test_vs_duplicates_justseen(self):\n        input = [1, 2, 3, 3, 2, 2]\n        output = [e for e, j, u in mi.classify_unique(input) if not j]\n        self.assertEqual(output, [3, 2])\n        self.assertEqual(list(mi.duplicates_justseen(input)), output)\n\n    def test_vs_duplicates_justseen_key(self):\n        input = 'HEheHHHhEheeEe'\n        output = [\n            e for e, j, u in mi.classify_unique(input, str.lower) if not j\n        ]\n        self.assertEqual(output, list('HHheEe'))\n        self.assertEqual(\n            list(mi.duplicates_justseen(input, str.lower)), output\n        )\n\n\nclass LongestCommonPrefixTests(TestCase):\n    def test_basic(self):\n        iterables = [[1, 2], [1, 2, 3], [1, 2, 4]]\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [1, 2])\n\n    def test_iterators(self):\n        iterables = iter([iter([1, 2]), iter([1, 2, 3]), iter([1, 2, 4])])\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [1, 2])\n\n    def test_no_iterables(self):\n        iterables = []\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [])\n\n    def test_empty_iterables_only(self):\n        iterables = [[], [], []]\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [])\n\n    def test_includes_empty_iterables(self):\n        iterables = [[1, 2], [1, 2, 3], [1, 2, 4], []]\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [])\n\n    def test_non_hashable(self):\n        # See https://github.com/more-itertools/more-itertools/issues/603\n        iterables = [[[1], [2]], [[1], [2], [3]], [[1], [2], [4]]]\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [[1], [2]])\n\n    def test_prefix_contains_elements_of_the_first_iterable(self):\n        iterables = [[[1], [2]], [[1], [2], [3]], [[1], [2], [4]]]\n        prefix = list(mi.longest_common_prefix(iterables))\n        self.assertIs(prefix[0], iterables[0][0])\n        self.assertIs(prefix[1], iterables[0][1])\n        self.assertIsNot(prefix[0], iterables[1][0])\n        self.assertIsNot(prefix[1], iterables[1][1])\n        self.assertIsNot(prefix[0], iterables[2][0])\n        self.assertIsNot(prefix[1], iterables[2][1])\n\n    def test_infinite_iterables(self):\n        prefix = mi.longest_common_prefix([count(), count()])\n        self.assertEqual(next(prefix), 0)\n        self.assertEqual(next(prefix), 1)\n        self.assertEqual(next(prefix), 2)\n\n    def test_contains_infinite_iterables(self):\n        iterables = [[0, 1, 2], count()]\n        self.assertEqual(list(mi.longest_common_prefix(iterables)), [0, 1, 2])\n\n\nclass IequalsTests(TestCase):\n    def test_basic(self):\n        self.assertTrue(mi.iequals(\"abc\", iter(\"abc\")))\n        self.assertTrue(mi.iequals(range(3), [0, 1, 2]))\n        self.assertFalse(mi.iequals(\"abc\", [0, 1, 2]))\n\n    def test_no_iterables(self):\n        self.assertTrue(mi.iequals())\n\n    def test_one_iterable(self):\n        self.assertTrue(mi.iequals(\"abc\"))\n\n    def test_more_than_two_iterable(self):\n        self.assertTrue(mi.iequals(\"abc\", iter(\"abc\"), ['a', 'b', 'c']))\n        self.assertFalse(mi.iequals(\"abc\", iter(\"abc\"), ['a', 'b', 'd']))\n\n    def test_order_matters(self):\n        self.assertFalse(mi.iequals(\"abc\", \"acb\"))\n\n    def test_not_equal_lengths(self):\n        self.assertFalse(mi.iequals(\"abc\", \"ab\"))\n        self.assertFalse(mi.iequals(\"abc\", \"bc\"))\n        self.assertFalse(mi.iequals(\"aaa\", \"aaaa\"))\n\n    def test_empty_iterables(self):\n        self.assertTrue(mi.iequals([], \"\"))\n\n    def test_none_is_not_a_sentinel(self):\n        # See https://stackoverflow.com/a/900444\n        self.assertFalse(mi.iequals([1, 2], [1, 2, None]))\n        self.assertFalse(mi.iequals([1, 2], [None, 1, 2]))\n\n    def test_not_identical_but_equal(self):\n        self.assertTrue([1, True], [1.0, complex(1, 0)])\n\n\nclass ConstrainedBatchesTests(TestCase):\n    def test_basic(self):\n        zen = [\n            'Beautiful is better than ugly',\n            'Explicit is better than implicit',\n            'Simple is better than complex',\n            'Complex is better than complicated',\n            'Flat is better than nested',\n            'Sparse is better than dense',\n            'Readability counts',\n        ]\n        for size, expected in (\n            (\n                34,\n                [\n                    (zen[0],),\n                    (zen[1],),\n                    (zen[2],),\n                    (zen[3],),\n                    (zen[4],),\n                    (zen[5],),\n                    (zen[6],),\n                ],\n            ),\n            (\n                61,\n                [\n                    (zen[0], zen[1]),\n                    (zen[2],),\n                    (zen[3], zen[4]),\n                    (zen[5], zen[6]),\n                ],\n            ),\n            (\n                90,\n                [\n                    (zen[0], zen[1], zen[2]),\n                    (zen[3], zen[4], zen[5]),\n                    (zen[6],),\n                ],\n            ),\n            (\n                124,\n                [(zen[0], zen[1], zen[2], zen[3]), (zen[4], zen[5], zen[6])],\n            ),\n            (\n                150,\n                [(zen[0], zen[1], zen[2], zen[3], zen[4]), (zen[5], zen[6])],\n            ),\n            (\n                177,\n                [(zen[0], zen[1], zen[2], zen[3], zen[4], zen[5]), (zen[6],)],\n            ),\n        ):\n            with self.subTest(size=size):\n                actual = list(mi.constrained_batches(iter(zen), size))\n                self.assertEqual(actual, expected)\n\n    def test_max_count(self):\n        iterable = ['1', '1', '12345678', '12345', '12345']\n        max_size = 10\n        max_count = 2\n        actual = list(mi.constrained_batches(iterable, max_size, max_count))\n        expected = [('1', '1'), ('12345678',), ('12345', '12345')]\n        self.assertEqual(actual, expected)\n\n    def test_strict(self):\n        iterable = ['1', '123456789', '1']\n        size = 8\n        with self.assertRaises(ValueError):\n            list(mi.constrained_batches(iterable, size))\n\n        actual = list(mi.constrained_batches(iterable, size, strict=False))\n        expected = [('1',), ('123456789',), ('1',)]\n        self.assertEqual(actual, expected)\n\n    def test_get_len(self):\n        class Record(tuple):\n            def total_size(self):\n                return sum(len(x) for x in self)\n\n        record_3 = Record(('1', '23'))\n        record_5 = Record(('1234', '1'))\n        record_10 = Record(('1', '12345678', '1'))\n        record_2 = Record(('1', '1'))\n        iterable = [record_3, record_5, record_10, record_2]\n\n        self.assertEqual(\n            list(\n                mi.constrained_batches(\n                    iterable, 10, get_len=lambda x: x.total_size()\n                )\n            ),\n            [(record_3, record_5), (record_10,), (record_2,)],\n        )\n\n    def test_bad_max(self):\n        with self.assertRaises(ValueError):\n            list(mi.constrained_batches([], 0))\n\n\nclass GrayProductTests(TestCase):\n    def test_basic(self):\n        self.assertEqual(\n            tuple(mi.gray_product(('a', 'b', 'c'), range(1, 3))),\n            ((\"a\", 1), (\"b\", 1), (\"c\", 1), (\"c\", 2), (\"b\", 2), (\"a\", 2)),\n        )\n        out = mi.gray_product(('foo', 'bar'), (3, 4, 5, 6), ['quz', 'baz'])\n        self.assertEqual(next(out), ('foo', 3, 'quz'))\n        self.assertEqual(\n            list(out),\n            [\n                ('bar', 3, 'quz'),\n                ('bar', 4, 'quz'),\n                ('foo', 4, 'quz'),\n                ('foo', 5, 'quz'),\n                ('bar', 5, 'quz'),\n                ('bar', 6, 'quz'),\n                ('foo', 6, 'quz'),\n                ('foo', 6, 'baz'),\n                ('bar', 6, 'baz'),\n                ('bar', 5, 'baz'),\n                ('foo', 5, 'baz'),\n                ('foo', 4, 'baz'),\n                ('bar', 4, 'baz'),\n                ('bar', 3, 'baz'),\n                ('foo', 3, 'baz'),\n            ],\n        )\n        self.assertEqual(tuple(mi.gray_product()), ((),))\n        self.assertEqual(tuple(mi.gray_product((1, 2))), ((1,), (2,)))\n\n    def test_errors(self):\n        with self.assertRaises(ValueError):\n            list(mi.gray_product((1, 2), ()))\n        with self.assertRaises(ValueError):\n            list(mi.gray_product((1, 2), (2,)))\n\n    def test_vs_product(self):\n        iters = (\n            (\"a\", \"b\"),\n            range(3, 6),\n            [None, None],\n            {\"i\", \"j\", \"k\", \"l\"},\n            \"XYZ\",\n        )\n        self.assertEqual(\n            sorted(product(*iters)), sorted(mi.gray_product(*iters))\n        )\n\n\nclass PartialProductTests(TestCase):\n    def test_no_iterables(self):\n        self.assertEqual(tuple(mi.partial_product()), ((),))\n\n    def test_empty_iterable(self):\n        self.assertEqual(tuple(mi.partial_product('AB', '', 'CD')), ())\n\n    def test_one_iterable(self):\n        # a single iterable should pass through\n        self.assertEqual(\n            tuple(mi.partial_product('ABCD')),\n            (\n                ('A',),\n                ('B',),\n                ('C',),\n                ('D',),\n            ),\n        )\n\n    def test_two_iterables(self):\n        self.assertEqual(\n            list(mi.partial_product('ABCD', [1])),\n            [('A', 1), ('B', 1), ('C', 1), ('D', 1)],\n        )\n        expected = [\n            ('A', 1),\n            ('B', 1),\n            ('C', 1),\n            ('D', 1),\n            ('D', 2),\n            ('D', 3),\n            ('D', 4),\n        ]\n        self.assertEqual(\n            list(mi.partial_product('ABCD', [1, 2, 3, 4])), expected\n        )\n\n    def test_basic(self):\n        ones = [1, 2, 3]\n        tens = [10, 20, 30, 40, 50]\n        hundreds = [100, 200]\n\n        expected = [\n            (1, 10, 100),\n            (2, 10, 100),\n            (3, 10, 100),\n            (3, 20, 100),\n            (3, 30, 100),\n            (3, 40, 100),\n            (3, 50, 100),\n            (3, 50, 200),\n        ]\n\n        actual = list(mi.partial_product(ones, tens, hundreds))\n        self.assertEqual(actual, expected)\n\n    def test_uneven_length_iterables(self):\n        # this is also the docstring example\n        expected = [\n            ('A', 'C', 'D'),\n            ('B', 'C', 'D'),\n            ('B', 'C', 'E'),\n            ('B', 'C', 'F'),\n        ]\n\n        self.assertEqual(list(mi.partial_product('AB', 'C', 'DEF')), expected)\n\n\nclass IterateTests(TestCase):\n    def test_basic(self) -> None:\n        result = list(islice(mi.iterate(lambda x: 2 * x, start=1), 10))\n        expected = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n        self.assertEqual(result, expected)\n\n    def test_func_controls_iteration_stop(self) -> None:\n        def func(num):\n            if num > 100:\n                raise StopIteration\n            return num * 2\n\n        result = list(islice(mi.iterate(func, start=1), 10))\n        expected = [1, 2, 4, 8, 16, 32, 64, 128]\n        self.assertEqual(result, expected)\n\n\nclass TakewhileInclusiveTests(TestCase):\n    def test_basic(self) -> None:\n        result = list(mi.takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n        expected = [1, 4, 6]\n        self.assertEqual(result, expected)\n\n    def test_empty_iterator(self) -> None:\n        result = list(mi.takewhile_inclusive(lambda x: True, []))\n        expected = []\n        self.assertEqual(result, expected)\n\n    def test_collatz_sequence(self) -> None:\n        is_even = lambda n: n % 2 == 0\n        start = 11\n        result = list(\n            mi.takewhile_inclusive(\n                lambda n: n != 1,\n                mi.iterate(\n                    lambda n: n // 2 if is_even(n) else 3 * n + 1, start\n                ),\n            )\n        )\n        expected = [11, 34, 17, 52, 26, 13, 40, 20, 10, 5, 16, 8, 4, 2, 1]\n        self.assertEqual(result, expected)\n\n\nclass OuterProductTests(TestCase):\n    def test_basic(self) -> None:\n        greetings = ['Hello', 'Goodbye']\n        names = ['Alice', 'Bob', 'Carol']\n        greet = lambda greeting, name: f'{greeting}, {name}!'\n        result = list(mi.outer_product(greet, greetings, names))\n        expected = [\n            ('Hello, Alice!', 'Hello, Bob!', 'Hello, Carol!'),\n            ('Goodbye, Alice!', 'Goodbye, Bob!', 'Goodbye, Carol!'),\n        ]\n        self.assertEqual(result, expected)\n\n\nclass IterSuppressTests(TestCase):\n    class Producer:\n        def __init__(self, exc, die_early=False):\n            self.exc = exc\n            self.pos = 0\n            self.die_early = die_early\n\n        def __iter__(self):\n            if self.die_early:\n                raise self.exc\n\n            return self\n\n        def __next__(self):\n            ret = self.pos\n            if self.pos >= 5:\n                raise self.exc\n            self.pos += 1\n            return ret\n\n    def test_no_error(self):\n        iterator = range(5)\n        actual = list(mi.iter_suppress(iterator, RuntimeError))\n        expected = [0, 1, 2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_raises_error(self):\n        iterator = self.Producer(ValueError)\n        with self.assertRaises(ValueError):\n            list(mi.iter_suppress(iterator, RuntimeError))\n\n    def test_suppression(self):\n        iterator = self.Producer(ValueError)\n        actual = list(mi.iter_suppress(iterator, RuntimeError, ValueError))\n        expected = [0, 1, 2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_early_suppression(self):\n        iterator = self.Producer(ValueError, die_early=True)\n        actual = list(mi.iter_suppress(iterator, RuntimeError, ValueError))\n        expected = []\n        self.assertEqual(actual, expected)\n\n\nclass FilterMapTests(TestCase):\n    def test_no_iterables(self):\n        actual = list(mi.filter_map(lambda _: None, []))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_filter(self):\n        actual = list(mi.filter_map(lambda _: None, [1, 2, 3]))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_map(self):\n        actual = list(mi.filter_map(lambda x: x + 1, [1, 2, 3]))\n        expected = [2, 3, 4]\n        self.assertEqual(actual, expected)\n\n    def test_filter_map(self):\n        actual = list(\n            mi.filter_map(\n                lambda x: int(x) if x.isnumeric() else None,\n                ['1', 'a', '2', 'b', '3'],\n            )\n        )\n        expected = [1, 2, 3]\n        self.assertEqual(actual, expected)\n\n\nclass PowersetOfSetsTests(TestCase):\n    def test_simple(self):\n        iterable = [0, 1, 2]\n        actual = list(mi.powerset_of_sets(iterable))\n        expected = [set(), {0}, {1}, {2}, {0, 1}, {0, 2}, {1, 2}, {0, 1, 2}]\n        self.assertEqual(actual, expected)\n\n    def test_hash_count(self):\n        hash_count = 0\n\n        class Str(str):\n            def __hash__(true_self):\n                nonlocal hash_count\n                hash_count += 1\n                return super.__hash__(true_self)\n\n        iterable = map(Str, 'ABBBCDD')\n        self.assertEqual(len(list(mi.powerset_of_sets(iterable))), 128)\n        self.assertLessEqual(hash_count, 14)\n\n\nclass JoinMappingTests(TestCase):\n    def test_basic(self):\n        salary_map = {'e1': 12, 'e2': 23, 'e3': 34}\n        dept_map = {'e1': 'eng', 'e2': 'sales', 'e3': 'eng'}\n        service_map = {'e1': 5, 'e2': 9, 'e3': 2}\n        field_to_map = {\n            'salary': salary_map,\n            'dept': dept_map,\n            'service': service_map,\n        }\n        expected = {\n            'e1': {'salary': 12, 'dept': 'eng', 'service': 5},\n            'e2': {'salary': 23, 'dept': 'sales', 'service': 9},\n            'e3': {'salary': 34, 'dept': 'eng', 'service': 2},\n        }\n        self.assertEqual(dict(mi.join_mappings(**field_to_map)), expected)\n\n    def test_empty(self):\n        self.assertEqual(dict(mi.join_mappings()), {})\n\n\nclass DiscreteFourierTransformTests(TestCase):\n    def test_basic(self):\n        # Example calculation from:\n        # https://en.wikipedia.org/wiki/Discrete_Fourier_transform#Example\n        xarr = [1, 2 - 1j, -1j, -1 + 2j]\n        Xarr = [2, -2 - 2j, -2j, 4 + 4j]\n        self.assertTrue(all(map(cmath.isclose, mi.dft(xarr), Xarr)))\n        self.assertTrue(all(map(cmath.isclose, mi.idft(Xarr), xarr)))\n\n    def test_roundtrip(self):\n        for _ in range(1_000):\n            N = randrange(35)\n            xarr = [complex(random(), random()) for i in range(N)]\n            Xarr = list(mi.dft(xarr))\n            assert all(map(cmath.isclose, mi.idft(Xarr), xarr))\n\n\nclass DoubleStarMapTests(TestCase):\n    def test_construction(self):\n        iterable = [{'price': 1.23}, {'price': 42}, {'price': 0.1}]\n        actual = list(mi.doublestarmap('{price:.2f}'.format, iterable))\n        expected = ['1.23', '42.00', '0.10']\n        self.assertEqual(actual, expected)\n\n    def test_identity(self):\n        iterable = [{'x': 1}, {'x': 2}, {'x': 3}]\n        actual = list(mi.doublestarmap(lambda x: x, iterable))\n        expected = [1, 2, 3]\n        self.assertEqual(actual, expected)\n\n    def test_adding(self):\n        iterable = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]\n        actual = list(mi.doublestarmap(lambda a, b: a + b, iterable))\n        expected = [3, 7]\n        self.assertEqual(actual, expected)\n\n    def test_mismatch_function_smaller(self):\n        iterable = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]\n        with self.assertRaises(TypeError):\n            list(mi.doublestarmap(lambda a: a, iterable))\n\n    def test_mismatch_function_different(self):\n        iterable = [{'a': 1}, {'a': 2}]\n        with self.assertRaises(TypeError):\n            list(mi.doublestarmap(lambda x: x, iterable))\n\n    def test_mismatch_function_larger(self):\n        iterable = [{'a': 1}, {'a': 2}]\n        with self.assertRaises(TypeError):\n            list(mi.doublestarmap(lambda a, b: a + b, iterable))\n\n    def test_no_mapping(self):\n        iterable = [1, 2, 3, 4]\n        with self.assertRaises(TypeError):\n            list(mi.doublestarmap(lambda x: x, iterable))\n\n    def test_empty(self):\n        actual = list(mi.doublestarmap(lambda x: x, []))\n        expected = []\n        self.assertEqual(actual, expected)\n", "tests/test_recipes.py": "from decimal import Decimal\nfrom doctest import DocTestSuite\nfrom fractions import Fraction\nfrom functools import reduce\nfrom itertools import combinations, count, permutations\nfrom operator import mul\nfrom math import factorial\nfrom sys import version_info\nfrom unittest import TestCase, skipIf\n\nimport more_itertools as mi\n\n\ndef load_tests(loader, tests, ignore):\n    # Add the doctests\n    tests.addTests(DocTestSuite('more_itertools.recipes'))\n    return tests\n\n\nclass TakeTests(TestCase):\n    \"\"\"Tests for ``take()``\"\"\"\n\n    def test_simple_take(self):\n        \"\"\"Test basic usage\"\"\"\n        t = mi.take(5, range(10))\n        self.assertEqual(t, [0, 1, 2, 3, 4])\n\n    def test_null_take(self):\n        \"\"\"Check the null case\"\"\"\n        t = mi.take(0, range(10))\n        self.assertEqual(t, [])\n\n    def test_negative_take(self):\n        \"\"\"Make sure taking negative items results in a ValueError\"\"\"\n        self.assertRaises(ValueError, lambda: mi.take(-3, range(10)))\n\n    def test_take_too_much(self):\n        \"\"\"Taking more than an iterator has remaining should return what the\n        iterator has remaining.\n\n        \"\"\"\n        t = mi.take(10, range(5))\n        self.assertEqual(t, [0, 1, 2, 3, 4])\n\n\nclass TabulateTests(TestCase):\n    \"\"\"Tests for ``tabulate()``\"\"\"\n\n    def test_simple_tabulate(self):\n        \"\"\"Test the happy path\"\"\"\n        t = mi.tabulate(lambda x: x)\n        f = tuple([next(t) for _ in range(3)])\n        self.assertEqual(f, (0, 1, 2))\n\n    def test_count(self):\n        \"\"\"Ensure tabulate accepts specific count\"\"\"\n        t = mi.tabulate(lambda x: 2 * x, -1)\n        f = (next(t), next(t), next(t))\n        self.assertEqual(f, (-2, 0, 2))\n\n\nclass TailTests(TestCase):\n    \"\"\"Tests for ``tail()``\"\"\"\n\n    def test_iterator_greater(self):\n        \"\"\"Length of iterator is greater than requested tail\"\"\"\n        self.assertEqual(list(mi.tail(3, iter('ABCDEFG'))), list('EFG'))\n\n    def test_iterator_equal(self):\n        \"\"\"Length of iterator is equal to the requested tail\"\"\"\n        self.assertEqual(list(mi.tail(7, iter('ABCDEFG'))), list('ABCDEFG'))\n\n    def test_iterator_less(self):\n        \"\"\"Length of iterator is less than requested tail\"\"\"\n        self.assertEqual(list(mi.tail(8, iter('ABCDEFG'))), list('ABCDEFG'))\n\n    def test_sized_greater(self):\n        \"\"\"Length of sized iterable is greater than requested tail\"\"\"\n        self.assertEqual(list(mi.tail(3, 'ABCDEFG')), list('EFG'))\n\n    def test_sized_equal(self):\n        \"\"\"Length of sized iterable is less than requested tail\"\"\"\n        self.assertEqual(list(mi.tail(7, 'ABCDEFG')), list('ABCDEFG'))\n\n    def test_sized_less(self):\n        \"\"\"Length of sized iterable is less than requested tail\"\"\"\n        self.assertEqual(list(mi.tail(8, 'ABCDEFG')), list('ABCDEFG'))\n\n\nclass ConsumeTests(TestCase):\n    \"\"\"Tests for ``consume()``\"\"\"\n\n    def test_sanity(self):\n        \"\"\"Test basic functionality\"\"\"\n        r = (x for x in range(10))\n        mi.consume(r, 3)\n        self.assertEqual(3, next(r))\n\n    def test_null_consume(self):\n        \"\"\"Check the null case\"\"\"\n        r = (x for x in range(10))\n        mi.consume(r, 0)\n        self.assertEqual(0, next(r))\n\n    def test_negative_consume(self):\n        \"\"\"Check that negative consumption throws an error\"\"\"\n        r = (x for x in range(10))\n        self.assertRaises(ValueError, lambda: mi.consume(r, -1))\n\n    def test_total_consume(self):\n        \"\"\"Check that iterator is totally consumed by default\"\"\"\n        r = (x for x in range(10))\n        mi.consume(r)\n        self.assertRaises(StopIteration, lambda: next(r))\n\n\nclass NthTests(TestCase):\n    \"\"\"Tests for ``nth()``\"\"\"\n\n    def test_basic(self):\n        \"\"\"Make sure the nth item is returned\"\"\"\n        l = range(10)\n        for i, v in enumerate(l):\n            self.assertEqual(mi.nth(l, i), v)\n\n    def test_default(self):\n        \"\"\"Ensure a default value is returned when nth item not found\"\"\"\n        l = range(3)\n        self.assertEqual(mi.nth(l, 100, \"zebra\"), \"zebra\")\n\n    def test_negative_item_raises(self):\n        \"\"\"Ensure asking for a negative item raises an exception\"\"\"\n        self.assertRaises(ValueError, lambda: mi.nth(range(10), -3))\n\n\nclass AllEqualTests(TestCase):\n    def test_true(self):\n        self.assertTrue(mi.all_equal('aaaaaa'))\n        self.assertTrue(mi.all_equal([0, 0, 0, 0]))\n\n    def test_false(self):\n        self.assertFalse(mi.all_equal('aaaaab'))\n        self.assertFalse(mi.all_equal([0, 0, 0, 1]))\n\n    def test_tricky(self):\n        items = [1, complex(1, 0), 1.0]\n        self.assertTrue(mi.all_equal(items))\n\n    def test_empty(self):\n        self.assertTrue(mi.all_equal(''))\n        self.assertTrue(mi.all_equal([]))\n\n    def test_one(self):\n        self.assertTrue(mi.all_equal('0'))\n        self.assertTrue(mi.all_equal([0]))\n\n    def test_key(self):\n        self.assertTrue(mi.all_equal('4\u0664\u0ed4\uff14\u09ea', key=int))\n        self.assertFalse(mi.all_equal('Abc', key=str.casefold))\n\n\nclass QuantifyTests(TestCase):\n    \"\"\"Tests for ``quantify()``\"\"\"\n\n    def test_happy_path(self):\n        \"\"\"Make sure True count is returned\"\"\"\n        q = [True, False, True]\n        self.assertEqual(mi.quantify(q), 2)\n\n    def test_custom_predicate(self):\n        \"\"\"Ensure non-default predicates return as expected\"\"\"\n        q = range(10)\n        self.assertEqual(mi.quantify(q, lambda x: x % 2 == 0), 5)\n\n\nclass PadnoneTests(TestCase):\n    def test_basic(self):\n        iterable = range(2)\n        for func in (mi.pad_none, mi.padnone):\n            with self.subTest(func=func):\n                p = func(iterable)\n                self.assertEqual(\n                    [0, 1, None, None], [next(p) for _ in range(4)]\n                )\n\n\nclass NcyclesTests(TestCase):\n    \"\"\"Tests for ``nyclces()``\"\"\"\n\n    def test_happy_path(self):\n        \"\"\"cycle a sequence three times\"\"\"\n        r = [\"a\", \"b\", \"c\"]\n        n = mi.ncycles(r, 3)\n        self.assertEqual(\n            [\"a\", \"b\", \"c\", \"a\", \"b\", \"c\", \"a\", \"b\", \"c\"], list(n)\n        )\n\n    def test_null_case(self):\n        \"\"\"asking for 0 cycles should return an empty iterator\"\"\"\n        n = mi.ncycles(range(100), 0)\n        self.assertRaises(StopIteration, lambda: next(n))\n\n    def test_pathological_case(self):\n        \"\"\"asking for negative cycles should return an empty iterator\"\"\"\n        n = mi.ncycles(range(100), -10)\n        self.assertRaises(StopIteration, lambda: next(n))\n\n\nclass DotproductTests(TestCase):\n    \"\"\"Tests for ``dotproduct()``'\"\"\"\n\n    def test_happy_path(self):\n        \"\"\"simple dotproduct example\"\"\"\n        self.assertEqual(400, mi.dotproduct([10, 10], [20, 20]))\n\n\nclass FlattenTests(TestCase):\n    \"\"\"Tests for ``flatten()``\"\"\"\n\n    def test_basic_usage(self):\n        \"\"\"ensure list of lists is flattened one level\"\"\"\n        f = [[0, 1, 2], [3, 4, 5]]\n        self.assertEqual(list(range(6)), list(mi.flatten(f)))\n\n    def test_single_level(self):\n        \"\"\"ensure list of lists is flattened only one level\"\"\"\n        f = [[0, [1, 2]], [[3, 4], 5]]\n        self.assertEqual([0, [1, 2], [3, 4], 5], list(mi.flatten(f)))\n\n\nclass RepeatfuncTests(TestCase):\n    \"\"\"Tests for ``repeatfunc()``\"\"\"\n\n    def test_simple_repeat(self):\n        \"\"\"test simple repeated functions\"\"\"\n        r = mi.repeatfunc(lambda: 5)\n        self.assertEqual([5, 5, 5, 5, 5], [next(r) for _ in range(5)])\n\n    def test_finite_repeat(self):\n        \"\"\"ensure limited repeat when times is provided\"\"\"\n        r = mi.repeatfunc(lambda: 5, times=5)\n        self.assertEqual([5, 5, 5, 5, 5], list(r))\n\n    def test_added_arguments(self):\n        \"\"\"ensure arguments are applied to the function\"\"\"\n        r = mi.repeatfunc(lambda x: x, 2, 3)\n        self.assertEqual([3, 3], list(r))\n\n    def test_null_times(self):\n        \"\"\"repeat 0 should return an empty iterator\"\"\"\n        r = mi.repeatfunc(range, 0, 3)\n        self.assertRaises(StopIteration, lambda: next(r))\n\n\nclass PairwiseTests(TestCase):\n    \"\"\"Tests for ``pairwise()``\"\"\"\n\n    def test_base_case(self):\n        \"\"\"ensure an iterable will return pairwise\"\"\"\n        p = mi.pairwise([1, 2, 3])\n        self.assertEqual([(1, 2), (2, 3)], list(p))\n\n    def test_short_case(self):\n        \"\"\"ensure an empty iterator if there's not enough values to pair\"\"\"\n        p = mi.pairwise(\"a\")\n        self.assertRaises(StopIteration, lambda: next(p))\n\n    def test_coverage(self):\n        from more_itertools import recipes\n\n        p = recipes._pairwise([1, 2, 3])\n        self.assertEqual([(1, 2), (2, 3)], list(p))\n\n\nclass GrouperTests(TestCase):\n    def test_basic(self):\n        seq = 'ABCDEF'\n        for n, expected in [\n            (3, [('A', 'B', 'C'), ('D', 'E', 'F')]),\n            (4, [('A', 'B', 'C', 'D'), ('E', 'F', None, None)]),\n            (5, [('A', 'B', 'C', 'D', 'E'), ('F', None, None, None, None)]),\n            (6, [('A', 'B', 'C', 'D', 'E', 'F')]),\n            (7, [('A', 'B', 'C', 'D', 'E', 'F', None)]),\n        ]:\n            with self.subTest(n=n):\n                actual = list(mi.grouper(iter(seq), n))\n                self.assertEqual(actual, expected)\n\n    def test_fill(self):\n        seq = 'ABCDEF'\n        fillvalue = 'x'\n        for n, expected in [\n            (1, ['A', 'B', 'C', 'D', 'E', 'F']),\n            (2, ['AB', 'CD', 'EF']),\n            (3, ['ABC', 'DEF']),\n            (4, ['ABCD', 'EFxx']),\n            (5, ['ABCDE', 'Fxxxx']),\n            (6, ['ABCDEF']),\n            (7, ['ABCDEFx']),\n        ]:\n            with self.subTest(n=n):\n                it = mi.grouper(\n                    iter(seq), n, incomplete='fill', fillvalue=fillvalue\n                )\n                actual = [''.join(x) for x in it]\n                self.assertEqual(actual, expected)\n\n    def test_ignore(self):\n        seq = 'ABCDEF'\n        for n, expected in [\n            (1, ['A', 'B', 'C', 'D', 'E', 'F']),\n            (2, ['AB', 'CD', 'EF']),\n            (3, ['ABC', 'DEF']),\n            (4, ['ABCD']),\n            (5, ['ABCDE']),\n            (6, ['ABCDEF']),\n            (7, []),\n        ]:\n            with self.subTest(n=n):\n                it = mi.grouper(iter(seq), n, incomplete='ignore')\n                actual = [''.join(x) for x in it]\n                self.assertEqual(actual, expected)\n\n    def test_strict(self):\n        seq = 'ABCDEF'\n        for n, expected in [\n            (1, ['A', 'B', 'C', 'D', 'E', 'F']),\n            (2, ['AB', 'CD', 'EF']),\n            (3, ['ABC', 'DEF']),\n            (6, ['ABCDEF']),\n        ]:\n            with self.subTest(n=n):\n                it = mi.grouper(iter(seq), n, incomplete='strict')\n                actual = [''.join(x) for x in it]\n                self.assertEqual(actual, expected)\n\n    def test_strict_fails(self):\n        seq = 'ABCDEF'\n        for n in [4, 5, 7]:\n            with self.subTest(n=n):\n                with self.assertRaises(ValueError):\n                    list(mi.grouper(iter(seq), n, incomplete='strict'))\n\n    def test_invalid_incomplete(self):\n        with self.assertRaises(ValueError):\n            list(mi.grouper('ABCD', 3, incomplete='bogus'))\n\n\nclass RoundrobinTests(TestCase):\n    \"\"\"Tests for ``roundrobin()``\"\"\"\n\n    def test_even_groups(self):\n        \"\"\"Ensure ordered output from evenly populated iterables\"\"\"\n        self.assertEqual(\n            list(mi.roundrobin('ABC', [1, 2, 3], range(3))),\n            ['A', 1, 0, 'B', 2, 1, 'C', 3, 2],\n        )\n\n    def test_uneven_groups(self):\n        \"\"\"Ensure ordered output from unevenly populated iterables\"\"\"\n        self.assertEqual(\n            list(mi.roundrobin('ABCD', [1, 2], range(0))),\n            ['A', 1, 'B', 2, 'C', 'D'],\n        )\n\n\nclass PartitionTests(TestCase):\n    \"\"\"Tests for ``partition()``\"\"\"\n\n    def test_bool(self):\n        lesser, greater = mi.partition(lambda x: x > 5, range(10))\n        self.assertEqual(list(lesser), [0, 1, 2, 3, 4, 5])\n        self.assertEqual(list(greater), [6, 7, 8, 9])\n\n    def test_arbitrary(self):\n        divisibles, remainders = mi.partition(lambda x: x % 3, range(10))\n        self.assertEqual(list(divisibles), [0, 3, 6, 9])\n        self.assertEqual(list(remainders), [1, 2, 4, 5, 7, 8])\n\n    def test_pred_is_none(self):\n        falses, trues = mi.partition(None, range(3))\n        self.assertEqual(list(falses), [0])\n        self.assertEqual(list(trues), [1, 2])\n\n\nclass PowersetTests(TestCase):\n    \"\"\"Tests for ``powerset()``\"\"\"\n\n    def test_combinatorics(self):\n        \"\"\"Ensure a proper enumeration\"\"\"\n        p = mi.powerset([1, 2, 3])\n        self.assertEqual(\n            list(p), [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n        )\n\n\nclass UniqueEverseenTests(TestCase):\n    def test_everseen(self):\n        u = mi.unique_everseen('AAAABBBBCCDAABBB')\n        self.assertEqual(['A', 'B', 'C', 'D'], list(u))\n\n    def test_custom_key(self):\n        u = mi.unique_everseen('aAbACCc', key=str.lower)\n        self.assertEqual(list('abC'), list(u))\n\n    def test_unhashable(self):\n        iterable = ['a', [1, 2, 3], [1, 2, 3], 'a']\n        u = mi.unique_everseen(iterable)\n        self.assertEqual(list(u), ['a', [1, 2, 3]])\n\n    def test_unhashable_key(self):\n        iterable = ['a', [1, 2, 3], [1, 2, 3], 'a']\n        u = mi.unique_everseen(iterable, key=lambda x: x)\n        self.assertEqual(list(u), ['a', [1, 2, 3]])\n\n\nclass UniqueJustseenTests(TestCase):\n    def test_justseen(self):\n        u = mi.unique_justseen('AAAABBBCCDABB')\n        self.assertEqual(list('ABCDAB'), list(u))\n\n    def test_custom_key(self):\n        u = mi.unique_justseen('AABCcAD', str.lower)\n        self.assertEqual(list('ABCAD'), list(u))\n\n\nclass UniqueTests(TestCase):\n    def test_basic(self):\n        iterable = [0, 1, 1, 8, 9, 9, 9, 8, 8, 1, 9, 9]\n        actual = list(mi.unique(iterable))\n        expected = [0, 1, 8, 9]\n        self.assertEqual(actual, expected)\n\n    def test_key(self):\n        iterable = ['1', '1', '10', '10', '2', '2', '20', '20']\n        actual = list(mi.unique(iterable, key=int))\n        expected = ['1', '2', '10', '20']\n        self.assertEqual(actual, expected)\n\n    def test_reverse(self):\n        iterable = ['1', '1', '10', '10', '2', '2', '20', '20']\n        actual = list(mi.unique(iterable, key=int, reverse=True))\n        expected = ['20', '10', '2', '1']\n        self.assertEqual(actual, expected)\n\n\nclass IterExceptTests(TestCase):\n    \"\"\"Tests for ``iter_except()``\"\"\"\n\n    def test_exact_exception(self):\n        \"\"\"ensure the exact specified exception is caught\"\"\"\n        l = [1, 2, 3]\n        i = mi.iter_except(l.pop, IndexError)\n        self.assertEqual(list(i), [3, 2, 1])\n\n    def test_generic_exception(self):\n        \"\"\"ensure the generic exception can be caught\"\"\"\n        l = [1, 2]\n        i = mi.iter_except(l.pop, Exception)\n        self.assertEqual(list(i), [2, 1])\n\n    def test_uncaught_exception_is_raised(self):\n        \"\"\"ensure a non-specified exception is raised\"\"\"\n        l = [1, 2, 3]\n        i = mi.iter_except(l.pop, KeyError)\n        self.assertRaises(IndexError, lambda: list(i))\n\n    def test_first(self):\n        \"\"\"ensure first is run before the function\"\"\"\n        l = [1, 2, 3]\n        f = lambda: 25\n        i = mi.iter_except(l.pop, IndexError, f)\n        self.assertEqual(list(i), [25, 3, 2, 1])\n\n    def test_multiple(self):\n        \"\"\"ensure can catch multiple exceptions\"\"\"\n\n        class Fiz(Exception):\n            pass\n\n        class Buzz(Exception):\n            pass\n\n        i = 0\n\n        def fizbuzz():\n            nonlocal i\n            i += 1\n            if i % 3 == 0:\n                raise Fiz\n            if i % 5 == 0:\n                raise Buzz\n            return i\n\n        expected = ([1, 2], [4], [], [7, 8], [])\n        for x in expected:\n            self.assertEqual(list(mi.iter_except(fizbuzz, (Fiz, Buzz))), x)\n\n\nclass FirstTrueTests(TestCase):\n    \"\"\"Tests for ``first_true()``\"\"\"\n\n    def test_something_true(self):\n        \"\"\"Test with no keywords\"\"\"\n        self.assertEqual(mi.first_true(range(10)), 1)\n\n    def test_nothing_true(self):\n        \"\"\"Test default return value.\"\"\"\n        self.assertIsNone(mi.first_true([0, 0, 0]))\n\n    def test_default(self):\n        \"\"\"Test with a default keyword\"\"\"\n        self.assertEqual(mi.first_true([0, 0, 0], default='!'), '!')\n\n    def test_pred(self):\n        \"\"\"Test with a custom predicate\"\"\"\n        self.assertEqual(\n            mi.first_true([2, 4, 6], pred=lambda x: x % 3 == 0), 6\n        )\n\n\nclass RandomProductTests(TestCase):\n    \"\"\"Tests for ``random_product()``\n\n    Since random.choice() has different results with the same seed across\n    python versions 2.x and 3.x, these tests use highly probably events to\n    create predictable outcomes across platforms.\n    \"\"\"\n\n    def test_simple_lists(self):\n        \"\"\"Ensure that one item is chosen from each list in each pair.\n        Also ensure that each item from each list eventually appears in\n        the chosen combinations.\n\n        Odds are roughly 1 in 7.1 * 10e16 that one item from either list will\n        not be chosen after 100 samplings of one item from each list. Just to\n        be safe, better use a known random seed, too.\n\n        \"\"\"\n        nums = [1, 2, 3]\n        lets = ['a', 'b', 'c']\n        n, m = zip(*[mi.random_product(nums, lets) for _ in range(100)])\n        n, m = set(n), set(m)\n        self.assertEqual(n, set(nums))\n        self.assertEqual(m, set(lets))\n        self.assertEqual(len(n), len(nums))\n        self.assertEqual(len(m), len(lets))\n\n    def test_list_with_repeat(self):\n        \"\"\"ensure multiple items are chosen, and that they appear to be chosen\n        from one list then the next, in proper order.\n\n        \"\"\"\n        nums = [1, 2, 3]\n        lets = ['a', 'b', 'c']\n        r = list(mi.random_product(nums, lets, repeat=100))\n        self.assertEqual(2 * 100, len(r))\n        n, m = set(r[::2]), set(r[1::2])\n        self.assertEqual(n, set(nums))\n        self.assertEqual(m, set(lets))\n        self.assertEqual(len(n), len(nums))\n        self.assertEqual(len(m), len(lets))\n\n\nclass RandomPermutationTests(TestCase):\n    \"\"\"Tests for ``random_permutation()``\"\"\"\n\n    def test_full_permutation(self):\n        \"\"\"ensure every item from the iterable is returned in a new ordering\n\n        15 elements have a 1 in 1.3 * 10e12 of appearing in sorted order, so\n        we fix a seed value just to be sure.\n\n        \"\"\"\n        i = range(15)\n        r = mi.random_permutation(i)\n        self.assertEqual(set(i), set(r))\n        if i == r:\n            raise AssertionError(\"Values were not permuted\")\n\n    def test_partial_permutation(self):\n        \"\"\"ensure all returned items are from the iterable, that the returned\n        permutation is of the desired length, and that all items eventually\n        get returned.\n\n        Sampling 100 permutations of length 5 from a set of 15 leaves a\n        (2/3)^100 chance that an item will not be chosen. Multiplied by 15\n        items, there is a 1 in 2.6e16 chance that at least 1 item will not\n        show up in the resulting output. Using a random seed will fix that.\n\n        \"\"\"\n        items = range(15)\n        item_set = set(items)\n        all_items = set()\n        for _ in range(100):\n            permutation = mi.random_permutation(items, 5)\n            self.assertEqual(len(permutation), 5)\n            permutation_set = set(permutation)\n            self.assertLessEqual(permutation_set, item_set)\n            all_items |= permutation_set\n        self.assertEqual(all_items, item_set)\n\n\nclass RandomCombinationTests(TestCase):\n    \"\"\"Tests for ``random_combination()``\"\"\"\n\n    def test_pseudorandomness(self):\n        \"\"\"ensure different subsets of the iterable get returned over many\n        samplings of random combinations\"\"\"\n        items = range(15)\n        all_items = set()\n        for _ in range(50):\n            combination = mi.random_combination(items, 5)\n            all_items |= set(combination)\n        self.assertEqual(all_items, set(items))\n\n    def test_no_replacement(self):\n        \"\"\"ensure that elements are sampled without replacement\"\"\"\n        items = range(15)\n        for _ in range(50):\n            combination = mi.random_combination(items, len(items))\n            self.assertEqual(len(combination), len(set(combination)))\n        self.assertRaises(\n            ValueError, lambda: mi.random_combination(items, len(items) + 1)\n        )\n\n\nclass RandomCombinationWithReplacementTests(TestCase):\n    \"\"\"Tests for ``random_combination_with_replacement()``\"\"\"\n\n    def test_replacement(self):\n        \"\"\"ensure that elements are sampled with replacement\"\"\"\n        items = range(5)\n        combo = mi.random_combination_with_replacement(items, len(items) * 2)\n        self.assertEqual(2 * len(items), len(combo))\n        if len(set(combo)) == len(combo):\n            raise AssertionError(\"Combination contained no duplicates\")\n\n    def test_pseudorandomness(self):\n        \"\"\"ensure different subsets of the iterable get returned over many\n        samplings of random combinations\"\"\"\n        items = range(15)\n        all_items = set()\n        for _ in range(50):\n            combination = mi.random_combination_with_replacement(items, 5)\n            all_items |= set(combination)\n        self.assertEqual(all_items, set(items))\n\n\nclass NthCombinationTests(TestCase):\n    def test_basic(self):\n        iterable = 'abcdefg'\n        r = 4\n        for index, expected in enumerate(combinations(iterable, r)):\n            actual = mi.nth_combination(iterable, r, index)\n            self.assertEqual(actual, expected)\n\n    def test_long(self):\n        actual = mi.nth_combination(range(180), 4, 2000000)\n        expected = (2, 12, 35, 126)\n        self.assertEqual(actual, expected)\n\n    def test_invalid_r(self):\n        for r in (-1, 3):\n            with self.assertRaises(ValueError):\n                mi.nth_combination([], r, 0)\n\n    def test_invalid_index(self):\n        with self.assertRaises(IndexError):\n            mi.nth_combination('abcdefg', 3, -36)\n\n\nclass NthPermutationTests(TestCase):\n    def test_r_less_than_n(self):\n        iterable = 'abcde'\n        r = 4\n        for index, expected in enumerate(permutations(iterable, r)):\n            actual = mi.nth_permutation(iterable, r, index)\n            self.assertEqual(actual, expected)\n\n    def test_r_equal_to_n(self):\n        iterable = 'abcde'\n        for index, expected in enumerate(permutations(iterable)):\n            actual = mi.nth_permutation(iterable, None, index)\n            self.assertEqual(actual, expected)\n\n    def test_long(self):\n        iterable = tuple(range(180))\n        r = 4\n        index = 1000000\n        actual = mi.nth_permutation(iterable, r, index)\n        expected = mi.nth(permutations(iterable, r), index)\n        self.assertEqual(actual, expected)\n\n    def test_null(self):\n        actual = mi.nth_permutation([], 0, 0)\n        expected = tuple()\n        self.assertEqual(actual, expected)\n\n    def test_negative_index(self):\n        iterable = 'abcde'\n        r = 4\n        n = factorial(len(iterable)) // factorial(len(iterable) - r)\n        for index, expected in enumerate(permutations(iterable, r)):\n            actual = mi.nth_permutation(iterable, r, index - n)\n            self.assertEqual(actual, expected)\n\n    def test_invalid_index(self):\n        iterable = 'abcde'\n        r = 4\n        n = factorial(len(iterable)) // factorial(len(iterable) - r)\n        for index in [-1 - n, n + 1]:\n            with self.assertRaises(IndexError):\n                mi.nth_permutation(iterable, r, index)\n\n    def test_invalid_r(self):\n        iterable = 'abcde'\n        r = 4\n        n = factorial(len(iterable)) // factorial(len(iterable) - r)\n        for r in [-1, n + 1]:\n            with self.assertRaises(ValueError):\n                mi.nth_permutation(iterable, r, 0)\n\n\nclass PrependTests(TestCase):\n    def test_basic(self):\n        value = 'a'\n        iterator = iter('bcdefg')\n        actual = list(mi.prepend(value, iterator))\n        expected = list('abcdefg')\n        self.assertEqual(actual, expected)\n\n    def test_multiple(self):\n        value = 'ab'\n        iterator = iter('cdefg')\n        actual = tuple(mi.prepend(value, iterator))\n        expected = ('ab',) + tuple('cdefg')\n        self.assertEqual(actual, expected)\n\n\nclass Convolvetests(TestCase):\n    def test_moving_average(self):\n        signal = iter([10, 20, 30, 40, 50])\n        kernel = [0.5, 0.5]\n        actual = list(mi.convolve(signal, kernel))\n        expected = [\n            (10 + 0) / 2,\n            (20 + 10) / 2,\n            (30 + 20) / 2,\n            (40 + 30) / 2,\n            (50 + 40) / 2,\n            (0 + 50) / 2,\n        ]\n        self.assertEqual(actual, expected)\n\n    def test_derivative(self):\n        signal = iter([10, 20, 30, 40, 50])\n        kernel = [1, -1]\n        actual = list(mi.convolve(signal, kernel))\n        expected = [10 - 0, 20 - 10, 30 - 20, 40 - 30, 50 - 40, 0 - 50]\n        self.assertEqual(actual, expected)\n\n    def test_infinite_signal(self):\n        signal = count()\n        kernel = [1, -1]\n        actual = mi.take(5, mi.convolve(signal, kernel))\n        expected = [0, 1, 1, 1, 1]\n        self.assertEqual(actual, expected)\n\n\nclass BeforeAndAfterTests(TestCase):\n    def test_empty(self):\n        before, after = mi.before_and_after(bool, [])\n        self.assertEqual(list(before), [])\n        self.assertEqual(list(after), [])\n\n    def test_never_true(self):\n        before, after = mi.before_and_after(bool, [0, False, None, ''])\n        self.assertEqual(list(before), [])\n        self.assertEqual(list(after), [0, False, None, ''])\n\n    def test_never_false(self):\n        before, after = mi.before_and_after(bool, [1, True, Ellipsis, ' '])\n        self.assertEqual(list(before), [1, True, Ellipsis, ' '])\n        self.assertEqual(list(after), [])\n\n    def test_some_true(self):\n        before, after = mi.before_and_after(bool, [1, True, 0, False])\n        self.assertEqual(list(before), [1, True])\n        self.assertEqual(list(after), [0, False])\n\n    @staticmethod\n    def _group_events(events):\n        events = iter(events)\n\n        while True:\n            try:\n                operation = next(events)\n            except StopIteration:\n                break\n            assert operation in [\"SUM\", \"MULTIPLY\"]\n\n            # Here, the remainder `events` is passed into `before_and_after`\n            # again, which would be problematic if the remainder is a\n            # generator function (as in Python 3.10 itertools recipes), since\n            # that creates recursion. `itertools.chain` solves this problem.\n            numbers, events = mi.before_and_after(\n                lambda e: isinstance(e, int), events\n            )\n\n            yield (operation, numbers)\n\n    def test_nested_remainder(self):\n        events = [\"SUM\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] * 1000\n        events += [\"MULTIPLY\", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] * 1000\n\n        for operation, numbers in self._group_events(events):\n            if operation == \"SUM\":\n                res = sum(numbers)\n                self.assertEqual(res, 55)\n            elif operation == \"MULTIPLY\":\n                res = reduce(lambda a, b: a * b, numbers)\n                self.assertEqual(res, 3628800)\n\n\nclass TriplewiseTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in [\n            ([0], []),\n            ([0, 1], []),\n            ([0, 1, 2], [(0, 1, 2)]),\n            ([0, 1, 2, 3], [(0, 1, 2), (1, 2, 3)]),\n            ([0, 1, 2, 3, 4], [(0, 1, 2), (1, 2, 3), (2, 3, 4)]),\n        ]:\n            with self.subTest(expected=expected):\n                actual = list(mi.triplewise(iterable))\n                self.assertEqual(actual, expected)\n\n\nclass SlidingWindowTests(TestCase):\n    def test_basic(self):\n        for iterable, n, expected in [\n            ([], 1, []),\n            ([0], 1, [(0,)]),\n            ([0, 1], 1, [(0,), (1,)]),\n            ([0, 1, 2], 2, [(0, 1), (1, 2)]),\n            ([0, 1, 2], 3, [(0, 1, 2)]),\n            ([0, 1, 2], 4, []),\n            ([0, 1, 2, 3], 4, [(0, 1, 2, 3)]),\n            ([0, 1, 2, 3, 4], 4, [(0, 1, 2, 3), (1, 2, 3, 4)]),\n        ]:\n            with self.subTest(expected=expected):\n                actual = list(mi.sliding_window(iterable, n))\n                self.assertEqual(actual, expected)\n\n\nclass SubslicesTests(TestCase):\n    def test_basic(self):\n        for iterable, expected in [\n            ([], []),\n            ([1], [[1]]),\n            ([1, 2], [[1], [1, 2], [2]]),\n            (iter([1, 2]), [[1], [1, 2], [2]]),\n            ([2, 1], [[2], [2, 1], [1]]),\n            (\n                'ABCD',\n                [\n                    ['A'],\n                    ['A', 'B'],\n                    ['A', 'B', 'C'],\n                    ['A', 'B', 'C', 'D'],\n                    ['B'],\n                    ['B', 'C'],\n                    ['B', 'C', 'D'],\n                    ['C'],\n                    ['C', 'D'],\n                    ['D'],\n                ],\n            ),\n        ]:\n            with self.subTest(expected=expected):\n                actual = list(mi.subslices(iterable))\n                self.assertEqual(actual, expected)\n\n\nclass PolynomialFromRootsTests(TestCase):\n    def test_basic(self):\n        for roots, expected in [\n            ((2, 1, -1), [1, -2, -1, 2]),\n            ((2, 3), [1, -5, 6]),\n            ((1, 2, 3), [1, -6, 11, -6]),\n            ((2, 4, 1), [1, -7, 14, -8]),\n        ]:\n            with self.subTest(roots=roots):\n                actual = mi.polynomial_from_roots(roots)\n                self.assertEqual(actual, expected)\n\n\nclass PolynomialEvalTests(TestCase):\n    def test_basic(self):\n        for coefficients, x, expected in [\n            ([1, -4, -17, 60], 2, 18),\n            ([1, -4, -17, 60], 2.5, 8.125),\n            ([1, -4, -17, 60], Fraction(2, 3), Fraction(1274, 27)),\n            ([1, -4, -17, 60], Decimal('1.75'), Decimal('23.359375')),\n            ([], 2, 0),\n            ([], 2.5, 0.0),\n            ([], Fraction(2, 3), Fraction(0, 1)),\n            ([], Decimal('1.75'), Decimal('0.00')),\n            ([11], 7, 11),\n            ([11, 2], 7, 79),\n        ]:\n            with self.subTest(x=x):\n                actual = mi.polynomial_eval(coefficients, x)\n                self.assertEqual(actual, expected)\n                self.assertEqual(type(actual), type(x))\n\n\nclass IterIndexTests(TestCase):\n    def test_basic(self):\n        iterable = 'AABCADEAF'\n        for wrapper in (list, iter):\n            with self.subTest(wrapper=wrapper):\n                actual = list(mi.iter_index(wrapper(iterable), 'A'))\n                expected = [0, 1, 4, 7]\n                self.assertEqual(actual, expected)\n\n    def test_start(self):\n        for wrapper in (list, iter):\n            with self.subTest(wrapper=wrapper):\n                iterable = 'AABCADEAF'\n                i = -1\n                actual = []\n                while True:\n                    try:\n                        i = next(\n                            mi.iter_index(wrapper(iterable), 'A', start=i + 1)\n                        )\n                    except StopIteration:\n                        break\n                    else:\n                        actual.append(i)\n\n                expected = [0, 1, 4, 7]\n                self.assertEqual(actual, expected)\n\n    def test_stop(self):\n        actual = list(mi.iter_index('AABCADEAF', 'A', stop=7))\n        expected = [0, 1, 4]\n        self.assertEqual(actual, expected)\n\n\nclass SieveTests(TestCase):\n    def test_basic(self):\n        self.assertEqual(\n            list(mi.sieve(67)),\n            [\n                2,\n                3,\n                5,\n                7,\n                11,\n                13,\n                17,\n                19,\n                23,\n                29,\n                31,\n                37,\n                41,\n                43,\n                47,\n                53,\n                59,\n                61,\n            ],\n        )\n        self.assertEqual(list(mi.sieve(68))[-1], 67)\n\n    def test_prime_counts(self):\n        for n, expected in (\n            (100, 25),\n            (1_000, 168),\n            (10_000, 1229),\n            (100_000, 9592),\n            (1_000_000, 78498),\n        ):\n            with self.subTest(n=n):\n                self.assertEqual(mi.ilen(mi.sieve(n)), expected)\n\n    def test_small_numbers(self):\n        with self.assertRaises(ValueError):\n            list(mi.sieve(-1))\n\n        for n in (0, 1, 2):\n            with self.subTest(n=n):\n                self.assertEqual(list(mi.sieve(n)), [])\n\n\nclass BatchedTests(TestCase):\n    def test_basic(self):\n        iterable = range(1, 5 + 1)\n        for n, expected in (\n            (1, [(1,), (2,), (3,), (4,), (5,)]),\n            (2, [(1, 2), (3, 4), (5,)]),\n            (3, [(1, 2, 3), (4, 5)]),\n            (4, [(1, 2, 3, 4), (5,)]),\n            (5, [(1, 2, 3, 4, 5)]),\n            (6, [(1, 2, 3, 4, 5)]),\n        ):\n            with self.subTest(n=n):\n                actual = list(mi.batched(iterable, n))\n                self.assertEqual(actual, expected)\n\n    def test_strict(self):\n        with self.assertRaises(ValueError):\n            list(mi.batched('ABCDEFG', 3, strict=True))\n\n        self.assertEqual(\n            list(mi.batched('ABCDEF', 3, strict=True)),\n            [('A', 'B', 'C'), ('D', 'E', 'F')],\n        )\n\n\nclass TransposeTests(TestCase):\n    def test_empty(self):\n        it = []\n        actual = list(mi.transpose(it))\n        expected = []\n        self.assertEqual(actual, expected)\n\n    def test_basic(self):\n        it = [(10, 11, 12), (20, 21, 22), (30, 31, 32)]\n        actual = list(mi.transpose(it))\n        expected = [(10, 20, 30), (11, 21, 31), (12, 22, 32)]\n        self.assertEqual(actual, expected)\n\n    @skipIf(version_info[:2] < (3, 10), 'strict=True missing on 3.9')\n    def test_incompatible_error(self):\n        it = [(10, 11, 12, 13), (20, 21, 22), (30, 31, 32)]\n        with self.assertRaises(ValueError):\n            list(mi.transpose(it))\n\n    @skipIf(version_info[:2] >= (3, 9), 'strict=True missing on 3.9')\n    def test_incompatible_allow(self):\n        it = [(10, 11, 12, 13), (20, 21, 22), (30, 31, 32)]\n        actual = list(mi.transpose(it))\n        expected = [(10, 20, 30), (11, 21, 31), (12, 22, 32)]\n        self.assertEqual(actual, expected)\n\n\nclass ReshapeTests(TestCase):\n    def test_empty(self):\n        actual = list(mi.reshape([], 3))\n        self.assertEqual(actual, [])\n\n    def test_zero(self):\n        matrix = [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]\n        with self.assertRaises(ValueError):\n            list(mi.reshape(matrix, 0))\n\n    def test_basic(self):\n        matrix = [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]\n        for cols, expected in (\n            (\n                1,\n                [\n                    (0,),\n                    (1,),\n                    (2,),\n                    (3,),\n                    (4,),\n                    (5,),\n                    (6,),\n                    (7,),\n                    (8,),\n                    (9,),\n                    (10,),\n                    (11,),\n                ],\n            ),\n            (2, [(0, 1), (2, 3), (4, 5), (6, 7), (8, 9), (10, 11)]),\n            (3, [(0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11)]),\n            (4, [(0, 1, 2, 3), (4, 5, 6, 7), (8, 9, 10, 11)]),\n            (6, [(0, 1, 2, 3, 4, 5), (6, 7, 8, 9, 10, 11)]),\n            (12, [(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)]),\n        ):\n            with self.subTest(cols=cols):\n                actual = list(mi.reshape(matrix, cols))\n                self.assertEqual(actual, expected)\n\n\nclass MatMulTests(TestCase):\n    def test_n_by_n(self):\n        actual = list(mi.matmul([(7, 5), (3, 5)], [[2, 5], [7, 9]]))\n        expected = [(49, 80), (41, 60)]\n        self.assertEqual(actual, expected)\n\n    def test_m_by_n(self):\n        m1 = [[2, 5], [7, 9], [3, 4]]\n        m2 = [[7, 11, 5, 4, 9], [3, 5, 2, 6, 3]]\n        actual = list(mi.matmul(m1, m2))\n        expected = [\n            (29, 47, 20, 38, 33),\n            (76, 122, 53, 82, 90),\n            (33, 53, 23, 36, 39),\n        ]\n        self.assertEqual(actual, expected)\n\n\nclass FactorTests(TestCase):\n    def test_basic(self):\n        for n, expected in (\n            (0, []),\n            (1, []),\n            (2, [2]),\n            (3, [3]),\n            (4, [2, 2]),\n            (6, [2, 3]),\n            (360, [2, 2, 2, 3, 3, 5]),\n            (128_884_753_939, [128_884_753_939]),\n            (999953 * 999983, [999953, 999983]),\n            (909_909_090_909, [3, 3, 7, 13, 13, 751, 113797]),\n        ):\n            with self.subTest(n=n):\n                actual = list(mi.factor(n))\n                self.assertEqual(actual, expected)\n\n    def test_cross_check(self):\n        prod = lambda x: reduce(mul, x, 1)\n        self.assertTrue(all(prod(mi.factor(n)) == n for n in range(1, 2000)))\n        self.assertTrue(\n            all(set(mi.factor(n)) <= set(mi.sieve(n + 1)) for n in range(2000))\n        )\n        self.assertTrue(\n            all(\n                list(mi.factor(n)) == sorted(mi.factor(n)) for n in range(2000)\n            )\n        )\n\n\nclass SumOfSquaresTests(TestCase):\n    def test_basic(self):\n        for it, expected in (\n            ([], 0),\n            ([1, 2, 3], 1 + 4 + 9),\n            ([2, 4, 6, 8], 4 + 16 + 36 + 64),\n        ):\n            with self.subTest(it=it):\n                actual = mi.sum_of_squares(it)\n                self.assertEqual(actual, expected)\n\n\nclass PolynomialDerivativeTests(TestCase):\n    def test_basic(self):\n        for coefficients, expected in [\n            ([], []),\n            ([1], []),\n            ([1, 2], [1]),\n            ([1, 2, 3], [2, 2]),\n            ([1, 2, 3, 4], [3, 4, 3]),\n            ([1.1, 2, 3, 4], [(1.1 * 3), 4, 3]),\n        ]:\n            with self.subTest(coefficients=coefficients):\n                actual = mi.polynomial_derivative(coefficients)\n                self.assertEqual(actual, expected)\n\n\nclass TotientTests(TestCase):\n    def test_basic(self):\n        for n, expected in (\n            (1, 1),\n            (2, 1),\n            (3, 2),\n            (4, 2),\n            (9, 6),\n            (12, 4),\n            (128_884_753_939, 128_884_753_938),\n            (999953 * 999983, 999952 * 999982),\n            (6**20, 1 * 2**19 * 2 * 3**19),\n        ):\n            with self.subTest(n=n):\n                self.assertEqual(mi.totient(n), expected)\n", "tests/__init__.py": "", "more_itertools/more.py": "import math\nimport warnings\n\nfrom collections import Counter, defaultdict, deque, abc\nfrom collections.abc import Sequence\nfrom functools import cached_property, partial, reduce, wraps\nfrom heapq import heapify, heapreplace\nfrom itertools import (\n    chain,\n    combinations,\n    compress,\n    count,\n    cycle,\n    dropwhile,\n    groupby,\n    islice,\n    repeat,\n    starmap,\n    takewhile,\n    tee,\n    zip_longest,\n    product,\n)\nfrom math import comb, e, exp, factorial, floor, fsum, log, perm, tau\nfrom queue import Empty, Queue\nfrom random import random, randrange, shuffle, uniform\nfrom operator import itemgetter, mul, sub, gt, lt, ge, le\nfrom sys import hexversion, maxsize\nfrom time import monotonic\n\nfrom .recipes import (\n    _marker,\n    _zip_equal,\n    UnequalIterablesError,\n    consume,\n    flatten,\n    pairwise,\n    powerset,\n    take,\n    unique_everseen,\n    all_equal,\n    batched,\n)\n\n__all__ = [\n    'AbortThread',\n    'SequenceView',\n    'UnequalIterablesError',\n    'adjacent',\n    'all_unique',\n    'always_iterable',\n    'always_reversible',\n    'bucket',\n    'callback_iter',\n    'chunked',\n    'chunked_even',\n    'circular_shifts',\n    'collapse',\n    'combination_index',\n    'combination_with_replacement_index',\n    'consecutive_groups',\n    'constrained_batches',\n    'consumer',\n    'count_cycle',\n    'countable',\n    'dft',\n    'difference',\n    'distinct_combinations',\n    'distinct_permutations',\n    'distribute',\n    'divide',\n    'doublestarmap',\n    'duplicates_everseen',\n    'duplicates_justseen',\n    'classify_unique',\n    'exactly_n',\n    'filter_except',\n    'filter_map',\n    'first',\n    'gray_product',\n    'groupby_transform',\n    'ichunked',\n    'iequals',\n    'idft',\n    'ilen',\n    'interleave',\n    'interleave_evenly',\n    'interleave_longest',\n    'intersperse',\n    'is_sorted',\n    'islice_extended',\n    'iterate',\n    'iter_suppress',\n    'join_mappings',\n    'last',\n    'locate',\n    'longest_common_prefix',\n    'lstrip',\n    'make_decorator',\n    'map_except',\n    'map_if',\n    'map_reduce',\n    'mark_ends',\n    'minmax',\n    'nth_or_last',\n    'nth_permutation',\n    'nth_product',\n    'nth_combination_with_replacement',\n    'numeric_range',\n    'one',\n    'only',\n    'outer_product',\n    'padded',\n    'partial_product',\n    'partitions',\n    'peekable',\n    'permutation_index',\n    'powerset_of_sets',\n    'product_index',\n    'raise_',\n    'repeat_each',\n    'repeat_last',\n    'replace',\n    'rlocate',\n    'rstrip',\n    'run_length',\n    'sample',\n    'seekable',\n    'set_partitions',\n    'side_effect',\n    'sliced',\n    'sort_together',\n    'split_after',\n    'split_at',\n    'split_before',\n    'split_into',\n    'split_when',\n    'spy',\n    'stagger',\n    'strip',\n    'strictly_n',\n    'substrings',\n    'substrings_indexes',\n    'takewhile_inclusive',\n    'time_limited',\n    'unique_in_window',\n    'unique_to_each',\n    'unzip',\n    'value_chain',\n    'windowed',\n    'windowed_complete',\n    'with_iter',\n    'zip_broadcast',\n    'zip_equal',\n    'zip_offset',\n]\n\n# math.sumprod is available for Python 3.12+\n_fsumprod = getattr(math, 'sumprod', lambda x, y: fsum(map(mul, x, y)))\n\n\ndef chunked(iterable, n, strict=False):\n    \"\"\"Break *iterable* into lists of length *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6], 3))\n        [[1, 2, 3], [4, 5, 6]]\n\n    By the default, the last yielded list will have fewer than *n* elements\n    if the length of *iterable* is not divisible by *n*:\n\n        >>> list(chunked([1, 2, 3, 4, 5, 6, 7, 8], 3))\n        [[1, 2, 3], [4, 5, 6], [7, 8]]\n\n    To use a fill-in value instead, see the :func:`grouper` recipe.\n\n    If the length of *iterable* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    list is yielded.\n\n    \"\"\"\n    iterator = iter(partial(take, n, iter(iterable)), [])\n    if strict:\n        if n is None:\n            raise ValueError('n must not be None when using strict mode.')\n\n        def ret():\n            for chunk in iterator:\n                if len(chunk) != n:\n                    raise ValueError('iterable is not divisible by n.')\n                yield chunk\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef first(iterable, default=_marker):\n    \"\"\"Return the first item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> first([0, 1, 2, 3])\n        0\n        >>> first([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n\n    :func:`first` is useful when you have a generator of expensive-to-retrieve\n    values and want any arbitrary one. It is marginally shorter than\n    ``next(iter(iterable), default)``.\n\n    \"\"\"\n    for item in iterable:\n        return item\n    if default is _marker:\n        raise ValueError(\n            'first() was called on an empty iterable, and no '\n            'default value was provided.'\n        )\n    return default\n\n\ndef last(iterable, default=_marker):\n    \"\"\"Return the last item of *iterable*, or *default* if *iterable* is\n    empty.\n\n        >>> last([0, 1, 2, 3])\n        3\n        >>> last([], 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    try:\n        if isinstance(iterable, Sequence):\n            return iterable[-1]\n        # Work around https://bugs.python.org/issue38525\n        elif hasattr(iterable, '__reversed__') and (hexversion != 0x030800F0):\n            return next(reversed(iterable))\n        else:\n            return deque(iterable, maxlen=1)[-1]\n    except (IndexError, TypeError, StopIteration):\n        if default is _marker:\n            raise ValueError(\n                'last() was called on an empty iterable, and no default was '\n                'provided.'\n            )\n        return default\n\n\ndef nth_or_last(iterable, n, default=_marker):\n    \"\"\"Return the nth or the last item of *iterable*,\n    or *default* if *iterable* is empty.\n\n        >>> nth_or_last([0, 1, 2, 3], 2)\n        2\n        >>> nth_or_last([0, 1], 2)\n        1\n        >>> nth_or_last([], 0, 'some default')\n        'some default'\n\n    If *default* is not provided and there are no items in the iterable,\n    raise ``ValueError``.\n    \"\"\"\n    return last(islice(iterable, n + 1), default=default)\n\n\nclass peekable:\n    \"\"\"Wrap an iterator to allow lookahead and prepending elements.\n\n    Call :meth:`peek` on the result to get the value that will be returned\n    by :func:`next`. This won't advance the iterator:\n\n        >>> p = peekable(['a', 'b'])\n        >>> p.peek()\n        'a'\n        >>> next(p)\n        'a'\n\n    Pass :meth:`peek` a default value to return that instead of raising\n    ``StopIteration`` when the iterator is exhausted.\n\n        >>> p = peekable([])\n        >>> p.peek('hi')\n        'hi'\n\n    peekables also offer a :meth:`prepend` method, which \"inserts\" items\n    at the head of the iterable:\n\n        >>> p = peekable([1, 2, 3])\n        >>> p.prepend(10, 11, 12)\n        >>> next(p)\n        10\n        >>> p.peek()\n        11\n        >>> list(p)\n        [11, 12, 1, 2, 3]\n\n    peekables can be indexed. Index 0 is the item that will be returned by\n    :func:`next`, index 1 is the item after that, and so on:\n    The values up to the given index will be cached.\n\n        >>> p = peekable(['a', 'b', 'c', 'd'])\n        >>> p[0]\n        'a'\n        >>> p[1]\n        'b'\n        >>> next(p)\n        'a'\n\n    Negative indexes are supported, but be aware that they will cache the\n    remaining items in the source iterator, which may require significant\n    storage.\n\n    To check whether a peekable is exhausted, check its truth value:\n\n        >>> p = peekable(['a', 'b'])\n        >>> if p:  # peekable has items\n        ...     list(p)\n        ['a', 'b']\n        >>> if not p:  # peekable is exhausted\n        ...     list(p)\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self._cache = deque()\n\n    def __iter__(self):\n        return self\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        \"\"\"Return the item that will be next returned from ``next()``.\n\n        Return ``default`` if there are no items left. If ``default`` is not\n        provided, raise ``StopIteration``.\n\n        \"\"\"\n        if not self._cache:\n            try:\n                self._cache.append(next(self._it))\n            except StopIteration:\n                if default is _marker:\n                    raise\n                return default\n        return self._cache[0]\n\n    def prepend(self, *items):\n        \"\"\"Stack up items to be the next ones returned from ``next()`` or\n        ``self.peek()``. The items will be returned in\n        first in, first out order::\n\n            >>> p = peekable([1, 2, 3])\n            >>> p.prepend(10, 11, 12)\n            >>> next(p)\n            10\n            >>> list(p)\n            [11, 12, 1, 2, 3]\n\n        It is possible, by prepending items, to \"resurrect\" a peekable that\n        previously raised ``StopIteration``.\n\n            >>> p = peekable([])\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n            >>> p.prepend(1)\n            >>> next(p)\n            1\n            >>> next(p)\n            Traceback (most recent call last):\n              ...\n            StopIteration\n\n        \"\"\"\n        self._cache.extendleft(reversed(items))\n\n    def __next__(self):\n        if self._cache:\n            return self._cache.popleft()\n\n        return next(self._it)\n\n    def _get_slice(self, index):\n        # Normalize the slice's arguments\n        step = 1 if (index.step is None) else index.step\n        if step > 0:\n            start = 0 if (index.start is None) else index.start\n            stop = maxsize if (index.stop is None) else index.stop\n        elif step < 0:\n            start = -1 if (index.start is None) else index.start\n            stop = (-maxsize - 1) if (index.stop is None) else index.stop\n        else:\n            raise ValueError('slice step cannot be zero')\n\n        # If either the start or stop index is negative, we'll need to cache\n        # the rest of the iterable in order to slice from the right side.\n        if (start < 0) or (stop < 0):\n            self._cache.extend(self._it)\n        # Otherwise we'll need to find the rightmost index and cache to that\n        # point.\n        else:\n            n = min(max(start, stop) + 1, maxsize)\n            cache_len = len(self._cache)\n            if n >= cache_len:\n                self._cache.extend(islice(self._it, n - cache_len))\n\n        return list(self._cache)[index]\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self._get_slice(index)\n\n        cache_len = len(self._cache)\n        if index < 0:\n            self._cache.extend(self._it)\n        elif index >= cache_len:\n            self._cache.extend(islice(self._it, index + 1 - cache_len))\n\n        return self._cache[index]\n\n\ndef consumer(func):\n    \"\"\"Decorator that automatically advances a PEP-342-style \"reverse iterator\"\n    to its first yield point so you don't have to call ``next()`` on it\n    manually.\n\n        >>> @consumer\n        ... def tally():\n        ...     i = 0\n        ...     while True:\n        ...         print('Thing number %s is %s.' % (i, (yield)))\n        ...         i += 1\n        ...\n        >>> t = tally()\n        >>> t.send('red')\n        Thing number 0 is red.\n        >>> t.send('fish')\n        Thing number 1 is fish.\n\n    Without the decorator, you would have to call ``next(t)`` before\n    ``t.send()`` could be used.\n\n    \"\"\"\n\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        gen = func(*args, **kwargs)\n        next(gen)\n        return gen\n\n    return wrapper\n\n\ndef ilen(iterable):\n    \"\"\"Return the number of items in *iterable*.\n\n        >>> ilen(x for x in range(1000000) if x % 3 == 0)\n        333334\n\n    This consumes the iterable, so handle with care.\n\n    \"\"\"\n    # This approach was selected because benchmarks showed it's likely the\n    # fastest of the known implementations at the time of writing.\n    # See GitHub tracker: #236, #230.\n    counter = count()\n    deque(zip(iterable, counter), maxlen=0)\n    return next(counter)\n\n\ndef iterate(func, start):\n    \"\"\"Return ``start``, ``func(start)``, ``func(func(start))``, ...\n\n    >>> from itertools import islice\n    >>> list(islice(iterate(lambda x: 2*x, 1), 10))\n    [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]\n\n    \"\"\"\n    while True:\n        yield start\n        try:\n            start = func(start)\n        except StopIteration:\n            break\n\n\ndef with_iter(context_manager):\n    \"\"\"Wrap an iterable in a ``with`` statement, so it closes once exhausted.\n\n    For example, this will close the file when the iterator is exhausted::\n\n        upper_lines = (line.upper() for line in with_iter(open('foo')))\n\n    Any context manager which returns an iterable is a candidate for\n    ``with_iter``.\n\n    \"\"\"\n    with context_manager as iterable:\n        yield from iterable\n\n\ndef one(iterable, too_short=None, too_long=None):\n    \"\"\"Return the first item from *iterable*, which is expected to contain only\n    that item. Raise an exception if *iterable* is empty or has more than one\n    item.\n\n    :func:`one` is useful for ensuring that an iterable contains only one item.\n    For example, it can be used to retrieve the result of a database query\n    that is expected to return a single row.\n\n    If *iterable* is empty, ``ValueError`` will be raised. You may specify a\n    different exception with the *too_short* keyword:\n\n        >>> it = []\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (expected 1)'\n        >>> too_short = IndexError('too few items')\n        >>> one(it, too_short=too_short)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        IndexError: too few items\n\n    Similarly, if *iterable* contains more than one item, ``ValueError`` will\n    be raised. You may specify a different exception with the *too_long*\n    keyword:\n\n        >>> it = ['too', 'many']\n        >>> one(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: Expected exactly one item in iterable, but got 'too',\n        'many', and perhaps more.\n        >>> too_long = RuntimeError\n        >>> one(it, too_long=too_long)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n    Note that :func:`one` attempts to advance *iterable* twice to ensure there\n    is only one item. See :func:`spy` or :func:`peekable` to check iterable\n    contents less destructively.\n\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        first_value = next(it)\n    except StopIteration as exc:\n        raise (\n            too_short or ValueError('too few items in iterable (expected 1)')\n        ) from exc\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef raise_(exception, *args):\n    raise exception(*args)\n\n\ndef strictly_n(iterable, n, too_short=None, too_long=None):\n    \"\"\"Validate that *iterable* has exactly *n* items and return them if\n    it does. If it has fewer than *n* items, call function *too_short*\n    with those items. If it has more than *n* items, call function\n    *too_long* with the first ``n + 1`` items.\n\n        >>> iterable = ['a', 'b', 'c', 'd']\n        >>> n = 4\n        >>> list(strictly_n(iterable, n))\n        ['a', 'b', 'c', 'd']\n\n    Note that the returned iterable must be consumed in order for the check to\n    be made.\n\n    By default, *too_short* and *too_long* are functions that raise\n    ``ValueError``.\n\n        >>> list(strictly_n('ab', 3))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too few items in iterable (got 2)\n\n        >>> list(strictly_n('abc', 2))  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        ValueError: too many items in iterable (got at least 3)\n\n    You can instead supply functions that do something else.\n    *too_short* will be called with the number of items in *iterable*.\n    *too_long* will be called with `n + 1`.\n\n        >>> def too_short(item_count):\n        ...     raise RuntimeError\n        >>> it = strictly_n('abcd', 6, too_short=too_short)\n        >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        RuntimeError\n\n        >>> def too_long(item_count):\n        ...     print('The boss is going to hear about this')\n        >>> it = strictly_n('abcdef', 4, too_long=too_long)\n        >>> list(it)\n        The boss is going to hear about this\n        ['a', 'b', 'c', 'd']\n\n    \"\"\"\n    if too_short is None:\n        too_short = lambda item_count: raise_(\n            ValueError,\n            'Too few items in iterable (got {})'.format(item_count),\n        )\n\n    if too_long is None:\n        too_long = lambda item_count: raise_(\n            ValueError,\n            'Too many items in iterable (got at least {})'.format(item_count),\n        )\n\n    it = iter(iterable)\n    for i in range(n):\n        try:\n            item = next(it)\n        except StopIteration:\n            too_short(i)\n            return\n        else:\n            yield item\n\n    try:\n        next(it)\n    except StopIteration:\n        pass\n    else:\n        too_long(n + 1)\n\n\ndef distinct_permutations(iterable, r=None):\n    \"\"\"Yield successive distinct permutations of the elements in *iterable*.\n\n        >>> sorted(distinct_permutations([1, 0, 1]))\n        [(0, 1, 1), (1, 0, 1), (1, 1, 0)]\n\n    Equivalent to yielding from ``set(permutations(iterable))``, except\n    duplicates are not generated and thrown away. For larger input sequences\n    this is much more efficient.\n\n    Duplicate permutations arise when there are duplicated elements in the\n    input iterable. The number of items returned is\n    `n! / (x_1! * x_2! * ... * x_n!)`, where `n` is the total number of\n    items input, and each `x_i` is the count of a distinct item in the input\n    sequence.\n\n    If *r* is given, only the *r*-length permutations are yielded.\n\n        >>> sorted(distinct_permutations([1, 0, 1], r=2))\n        [(0, 1), (1, 0), (1, 1)]\n        >>> sorted(distinct_permutations(range(3), r=2))\n        [(0, 1), (0, 2), (1, 0), (1, 2), (2, 0), (2, 1)]\n\n    *iterable* need not be sortable, but note that using equal (``x == y``)\n    but non-identical (``id(x) != id(y)``) elements may produce surprising\n    behavior. For example, ``1`` and ``True`` are equal but non-identical:\n\n        >>> list(distinct_permutations([1, True, '3']))  # doctest: +SKIP\n        [\n            (1, True, '3'),\n            (1, '3', True),\n            ('3', 1, True)\n        ]\n        >>> list(distinct_permutations([1, 2, '3']))  # doctest: +SKIP\n        [\n            (1, 2, '3'),\n            (1, '3', 2),\n            (2, 1, '3'),\n            (2, '3', 1),\n            ('3', 1, 2),\n            ('3', 2, 1)\n        ]\n    \"\"\"\n\n    # Algorithm: https://w.wiki/Qai\n    def _full(A):\n        while True:\n            # Yield the permutation we have\n            yield tuple(A)\n\n            # Find the largest index i such that A[i] < A[i + 1]\n            for i in range(size - 2, -1, -1):\n                if A[i] < A[i + 1]:\n                    break\n            #  If no such index exists, this permutation is the last one\n            else:\n                return\n\n            # Find the largest index j greater than j such that A[i] < A[j]\n            for j in range(size - 1, i, -1):\n                if A[i] < A[j]:\n                    break\n\n            # Swap the value of A[i] with that of A[j], then reverse the\n            # sequence from A[i + 1] to form the new permutation\n            A[i], A[j] = A[j], A[i]\n            A[i + 1 :] = A[: i - size : -1]  # A[i + 1:][::-1]\n\n    # Algorithm: modified from the above\n    def _partial(A, r):\n        # Split A into the first r items and the last r items\n        head, tail = A[:r], A[r:]\n        right_head_indexes = range(r - 1, -1, -1)\n        left_tail_indexes = range(len(tail))\n\n        while True:\n            # Yield the permutation we have\n            yield tuple(head)\n\n            # Starting from the right, find the first index of the head with\n            # value smaller than the maximum value of the tail - call it i.\n            pivot = tail[-1]\n            for i in right_head_indexes:\n                if head[i] < pivot:\n                    break\n                pivot = head[i]\n            else:\n                return\n\n            # Starting from the left, find the first value of the tail\n            # with a value greater than head[i] and swap.\n            for j in left_tail_indexes:\n                if tail[j] > head[i]:\n                    head[i], tail[j] = tail[j], head[i]\n                    break\n            # If we didn't find one, start from the right and find the first\n            # index of the head with a value greater than head[i] and swap.\n            else:\n                for j in right_head_indexes:\n                    if head[j] > head[i]:\n                        head[i], head[j] = head[j], head[i]\n                        break\n\n            # Reverse head[i + 1:] and swap it with tail[:r - (i + 1)]\n            tail += head[: i - r : -1]  # head[i + 1:][::-1]\n            i += 1\n            head[i:], tail[:] = tail[: r - i], tail[r - i :]\n\n    items = list(iterable)\n\n    try:\n        items.sort()\n        sortable = True\n    except TypeError:\n        sortable = False\n\n        indices_dict = defaultdict(list)\n\n        for item in items:\n            indices_dict[items.index(item)].append(item)\n\n        indices = [items.index(item) for item in items]\n        indices.sort()\n\n        equivalent_items = {k: cycle(v) for k, v in indices_dict.items()}\n\n        def permuted_items(permuted_indices):\n            return tuple(\n                next(equivalent_items[index]) for index in permuted_indices\n            )\n\n    size = len(items)\n    if r is None:\n        r = size\n\n    # functools.partial(_partial, ... )\n    algorithm = _full if (r == size) else partial(_partial, r=r)\n\n    if 0 < r <= size:\n        if sortable:\n            return algorithm(items)\n        else:\n            return (\n                permuted_items(permuted_indices)\n                for permuted_indices in algorithm(indices)\n            )\n\n    return iter(() if r else ((),))\n\n\ndef intersperse(e, iterable, n=1):\n    \"\"\"Intersperse filler element *e* among the items in *iterable*, leaving\n    *n* items between each filler element.\n\n        >>> list(intersperse('!', [1, 2, 3, 4, 5]))\n        [1, '!', 2, '!', 3, '!', 4, '!', 5]\n\n        >>> list(intersperse(None, [1, 2, 3, 4, 5], n=2))\n        [1, 2, None, 3, 4, None, 5]\n\n    \"\"\"\n    if n == 0:\n        raise ValueError('n must be > 0')\n    elif n == 1:\n        # interleave(repeat(e), iterable) -> e, x_0, e, x_1, e, x_2...\n        # islice(..., 1, None) -> x_0, e, x_1, e, x_2...\n        return islice(interleave(repeat(e), iterable), 1, None)\n    else:\n        # interleave(filler, chunks) -> [e], [x_0, x_1], [e], [x_2, x_3]...\n        # islice(..., 1, None) -> [x_0, x_1], [e], [x_2, x_3]...\n        # flatten(...) -> x_0, x_1, e, x_2, x_3...\n        filler = repeat([e])\n        chunks = chunked(iterable, n)\n        return flatten(islice(interleave(filler, chunks), 1, None))\n\n\ndef unique_to_each(*iterables):\n    \"\"\"Return the elements from each of the input iterables that aren't in the\n    other input iterables.\n\n    For example, suppose you have a set of packages, each with a set of\n    dependencies::\n\n        {'pkg_1': {'A', 'B'}, 'pkg_2': {'B', 'C'}, 'pkg_3': {'B', 'D'}}\n\n    If you remove one package, which dependencies can also be removed?\n\n    If ``pkg_1`` is removed, then ``A`` is no longer necessary - it is not\n    associated with ``pkg_2`` or ``pkg_3``. Similarly, ``C`` is only needed for\n    ``pkg_2``, and ``D`` is only needed for ``pkg_3``::\n\n        >>> unique_to_each({'A', 'B'}, {'B', 'C'}, {'B', 'D'})\n        [['A'], ['C'], ['D']]\n\n    If there are duplicates in one input iterable that aren't in the others\n    they will be duplicated in the output. Input order is preserved::\n\n        >>> unique_to_each(\"mississippi\", \"missouri\")\n        [['p', 'p'], ['o', 'u', 'r']]\n\n    It is assumed that the elements of each iterable are hashable.\n\n    \"\"\"\n    pool = [list(it) for it in iterables]\n    counts = Counter(chain.from_iterable(map(set, pool)))\n    uniques = {element for element in counts if counts[element] == 1}\n    return [list(filter(uniques.__contains__, it)) for it in pool]\n\n\ndef windowed(seq, n, fillvalue=None, step=1):\n    \"\"\"Return a sliding window of width *n* over the given iterable.\n\n        >>> all_windows = windowed([1, 2, 3, 4, 5], 3)\n        >>> list(all_windows)\n        [(1, 2, 3), (2, 3, 4), (3, 4, 5)]\n\n    When the window is larger than the iterable, *fillvalue* is used in place\n    of missing values:\n\n        >>> list(windowed([1, 2, 3], 4))\n        [(1, 2, 3, None)]\n\n    Each window will advance in increments of *step*:\n\n        >>> list(windowed([1, 2, 3, 4, 5, 6], 3, fillvalue='!', step=2))\n        [(1, 2, 3), (3, 4, 5), (5, 6, '!')]\n\n    To slide into the iterable's items, use :func:`chain` to add filler items\n    to the left:\n\n        >>> iterable = [1, 2, 3, 4]\n        >>> n = 3\n        >>> padding = [None] * (n - 1)\n        >>> list(windowed(chain(padding, iterable), 3))\n        [(None, None, 1), (None, 1, 2), (1, 2, 3), (2, 3, 4)]\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n    if n == 0:\n        yield ()\n        return\n    if step < 1:\n        raise ValueError('step must be >= 1')\n\n    iterable = iter(seq)\n\n    # Generate first window\n    window = deque(islice(iterable, n), maxlen=n)\n\n    # Deal with the first window not being full\n    if not window:\n        return\n    if len(window) < n:\n        yield tuple(window) + ((fillvalue,) * (n - len(window)))\n        return\n    yield tuple(window)\n\n    # Create the filler for the next windows. The padding ensures\n    # we have just enough elements to fill the last window.\n    padding = (fillvalue,) * (n - 1 if step >= n else step - 1)\n    filler = map(window.append, chain(iterable, padding))\n\n    # Generate the rest of the windows\n    for _ in islice(filler, step - 1, None, step):\n        yield tuple(window)\n\n\ndef substrings(iterable):\n    \"\"\"Yield all of the substrings of *iterable*.\n\n        >>> [''.join(s) for s in substrings('more')]\n        ['m', 'o', 'r', 'e', 'mo', 'or', 're', 'mor', 'ore', 'more']\n\n    Note that non-string iterables can also be subdivided.\n\n        >>> list(substrings([0, 1, 2]))\n        [(0,), (1,), (2,), (0, 1), (1, 2), (0, 1, 2)]\n\n    \"\"\"\n    # The length-1 substrings\n    seq = []\n    for item in iter(iterable):\n        seq.append(item)\n        yield (item,)\n    seq = tuple(seq)\n    item_count = len(seq)\n\n    # And the rest\n    for n in range(2, item_count + 1):\n        for i in range(item_count - n + 1):\n            yield seq[i : i + n]\n\n\ndef substrings_indexes(seq, reverse=False):\n    \"\"\"Yield all substrings and their positions in *seq*\n\n    The items yielded will be a tuple of the form ``(substr, i, j)``, where\n    ``substr == seq[i:j]``.\n\n    This function only works for iterables that support slicing, such as\n    ``str`` objects.\n\n    >>> for item in substrings_indexes('more'):\n    ...    print(item)\n    ('m', 0, 1)\n    ('o', 1, 2)\n    ('r', 2, 3)\n    ('e', 3, 4)\n    ('mo', 0, 2)\n    ('or', 1, 3)\n    ('re', 2, 4)\n    ('mor', 0, 3)\n    ('ore', 1, 4)\n    ('more', 0, 4)\n\n    Set *reverse* to ``True`` to yield the same items in the opposite order.\n\n\n    \"\"\"\n    r = range(1, len(seq) + 1)\n    if reverse:\n        r = reversed(r)\n    return (\n        (seq[i : i + L], i, i + L) for L in r for i in range(len(seq) - L + 1)\n    )\n\n\nclass bucket:\n    \"\"\"Wrap *iterable* and return an object that buckets the iterable into\n    child iterables based on a *key* function.\n\n        >>> iterable = ['a1', 'b1', 'c1', 'a2', 'b2', 'c2', 'b3']\n        >>> s = bucket(iterable, key=lambda x: x[0])  # Bucket by 1st character\n        >>> sorted(list(s))  # Get the keys\n        ['a', 'b', 'c']\n        >>> a_iterable = s['a']\n        >>> next(a_iterable)\n        'a1'\n        >>> next(a_iterable)\n        'a2'\n        >>> list(s['b'])\n        ['b1', 'b2', 'b3']\n\n    The original iterable will be advanced and its items will be cached until\n    they are used by the child iterables. This may require significant storage.\n\n    By default, attempting to select a bucket to which no items belong  will\n    exhaust the iterable and cache all values.\n    If you specify a *validator* function, selected buckets will instead be\n    checked against it.\n\n        >>> from itertools import count\n        >>> it = count(1, 2)  # Infinite sequence of odd numbers\n        >>> key = lambda x: x % 10  # Bucket by last digit\n        >>> validator = lambda x: x in {1, 3, 5, 7, 9}  # Odd digits only\n        >>> s = bucket(it, key=key, validator=validator)\n        >>> 2 in s\n        False\n        >>> list(s[2])\n        []\n\n    \"\"\"\n\n    def __init__(self, iterable, key, validator=None):\n        self._it = iter(iterable)\n        self._key = key\n        self._cache = defaultdict(deque)\n        self._validator = validator or (lambda x: True)\n\n    def __contains__(self, value):\n        if not self._validator(value):\n            return False\n\n        try:\n            item = next(self[value])\n        except StopIteration:\n            return False\n        else:\n            self._cache[value].appendleft(item)\n\n        return True\n\n    def _get_values(self, value):\n        \"\"\"\n        Helper to yield items from the parent iterator that match *value*.\n        Items that don't match are stored in the local cache as they\n        are encountered.\n        \"\"\"\n        while True:\n            # If we've cached some items that match the target value, emit\n            # the first one and evict it from the cache.\n            if self._cache[value]:\n                yield self._cache[value].popleft()\n            # Otherwise we need to advance the parent iterator to search for\n            # a matching item, caching the rest.\n            else:\n                while True:\n                    try:\n                        item = next(self._it)\n                    except StopIteration:\n                        return\n                    item_value = self._key(item)\n                    if item_value == value:\n                        yield item\n                        break\n                    elif self._validator(item_value):\n                        self._cache[item_value].append(item)\n\n    def __iter__(self):\n        for item in self._it:\n            item_value = self._key(item)\n            if self._validator(item_value):\n                self._cache[item_value].append(item)\n\n        yield from self._cache.keys()\n\n    def __getitem__(self, value):\n        if not self._validator(value):\n            return iter(())\n\n        return self._get_values(value)\n\n\ndef spy(iterable, n=1):\n    \"\"\"Return a 2-tuple with a list containing the first *n* elements of\n    *iterable*, and an iterator with the same items as *iterable*.\n    This allows you to \"look ahead\" at the items in the iterable without\n    advancing it.\n\n    There is one item in the list by default:\n\n        >>> iterable = 'abcdefg'\n        >>> head, iterable = spy(iterable)\n        >>> head\n        ['a']\n        >>> list(iterable)\n        ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n\n    You may use unpacking to retrieve items instead of lists:\n\n        >>> (head,), iterable = spy('abcdefg')\n        >>> head\n        'a'\n        >>> (first, second), iterable = spy('abcdefg', 2)\n        >>> first\n        'a'\n        >>> second\n        'b'\n\n    The number of items requested can be larger than the number of items in\n    the iterable:\n\n        >>> iterable = [1, 2, 3, 4, 5]\n        >>> head, iterable = spy(iterable, 10)\n        >>> head\n        [1, 2, 3, 4, 5]\n        >>> list(iterable)\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    it = iter(iterable)\n    head = take(n, it)\n\n    return head.copy(), chain(head, it)\n\n\ndef interleave(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    until the shortest is exhausted.\n\n        >>> list(interleave([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7]\n\n    For a version that doesn't terminate after the shortest iterable is\n    exhausted, see :func:`interleave_longest`.\n\n    \"\"\"\n    return chain.from_iterable(zip(*iterables))\n\n\ndef interleave_longest(*iterables):\n    \"\"\"Return a new iterable yielding from each iterable in turn,\n    skipping any that are exhausted.\n\n        >>> list(interleave_longest([1, 2, 3], [4, 5], [6, 7, 8]))\n        [1, 4, 6, 2, 5, 7, 3, 8]\n\n    This function produces the same output as :func:`roundrobin`, but may\n    perform better for some inputs (in particular when the number of iterables\n    is large).\n\n    \"\"\"\n    i = chain.from_iterable(zip_longest(*iterables, fillvalue=_marker))\n    return (x for x in i if x is not _marker)\n\n\ndef interleave_evenly(iterables, lengths=None):\n    \"\"\"\n    Interleave multiple iterables so that their elements are evenly distributed\n    throughout the output sequence.\n\n    >>> iterables = [1, 2, 3, 4, 5], ['a', 'b']\n    >>> list(interleave_evenly(iterables))\n    [1, 2, 'a', 3, 4, 'b', 5]\n\n    >>> iterables = [[1, 2, 3], [4, 5], [6, 7, 8]]\n    >>> list(interleave_evenly(iterables))\n    [1, 6, 4, 2, 7, 3, 8, 5]\n\n    This function requires iterables of known length. Iterables without\n    ``__len__()`` can be used by manually specifying lengths with *lengths*:\n\n    >>> from itertools import combinations, repeat\n    >>> iterables = [combinations(range(4), 2), ['a', 'b', 'c']]\n    >>> lengths = [4 * (4 - 1) // 2, 3]\n    >>> list(interleave_evenly(iterables, lengths=lengths))\n    [(0, 1), (0, 2), 'a', (0, 3), (1, 2), 'b', (1, 3), (2, 3), 'c']\n\n    Based on Bresenham's algorithm.\n    \"\"\"\n    if lengths is None:\n        try:\n            lengths = [len(it) for it in iterables]\n        except TypeError:\n            raise ValueError(\n                'Iterable lengths could not be determined automatically. '\n                'Specify them with the lengths keyword.'\n            )\n    elif len(iterables) != len(lengths):\n        raise ValueError('Mismatching number of iterables and lengths.')\n\n    dims = len(lengths)\n\n    # sort iterables by length, descending\n    lengths_permute = sorted(\n        range(dims), key=lambda i: lengths[i], reverse=True\n    )\n    lengths_desc = [lengths[i] for i in lengths_permute]\n    iters_desc = [iter(iterables[i]) for i in lengths_permute]\n\n    # the longest iterable is the primary one (Bresenham: the longest\n    # distance along an axis)\n    delta_primary, deltas_secondary = lengths_desc[0], lengths_desc[1:]\n    iter_primary, iters_secondary = iters_desc[0], iters_desc[1:]\n    errors = [delta_primary // dims] * len(deltas_secondary)\n\n    to_yield = sum(lengths)\n    while to_yield:\n        yield next(iter_primary)\n        to_yield -= 1\n        # update errors for each secondary iterable\n        errors = [e - delta for e, delta in zip(errors, deltas_secondary)]\n\n        # those iterables for which the error is negative are yielded\n        # (\"diagonal step\" in Bresenham)\n        for i, e_ in enumerate(errors):\n            if e_ < 0:\n                yield next(iters_secondary[i])\n                to_yield -= 1\n                errors[i] += delta_primary\n\n\ndef collapse(iterable, base_type=None, levels=None):\n    \"\"\"Flatten an iterable with multiple levels of nesting (e.g., a list of\n    lists of tuples) into non-iterable types.\n\n        >>> iterable = [(1, 2), ([3, 4], [[5], [6]])]\n        >>> list(collapse(iterable))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and\n    will not be collapsed.\n\n    To avoid collapsing other types, specify *base_type*:\n\n        >>> iterable = ['ab', ('cd', 'ef'), ['gh', 'ij']]\n        >>> list(collapse(iterable, base_type=tuple))\n        ['ab', ('cd', 'ef'), 'gh', 'ij']\n\n    Specify *levels* to stop flattening after a certain level:\n\n    >>> iterable = [('a', ['b']), ('c', ['d'])]\n    >>> list(collapse(iterable))  # Fully flattened\n    ['a', 'b', 'c', 'd']\n    >>> list(collapse(iterable, levels=1))  # Only one level flattened\n    ['a', ['b'], 'c', ['d']]\n\n    \"\"\"\n    stack = deque()\n    # Add our first node group, treat the iterable as a single node\n    stack.appendleft((0, repeat(iterable, 1)))\n\n    while stack:\n        node_group = stack.popleft()\n        level, nodes = node_group\n\n        # Check if beyond max level\n        if levels is not None and level > levels:\n            yield from nodes\n            continue\n\n        for node in nodes:\n            # Check if done iterating\n            if isinstance(node, (str, bytes)) or (\n                (base_type is not None) and isinstance(node, base_type)\n            ):\n                yield node\n            # Otherwise try to create child nodes\n            else:\n                try:\n                    tree = iter(node)\n                except TypeError:\n                    yield node\n                else:\n                    # Save our current location\n                    stack.appendleft(node_group)\n                    # Append the new child node\n                    stack.appendleft((level + 1, tree))\n                    # Break to process child node\n                    break\n\n\ndef side_effect(func, iterable, chunk_size=None, before=None, after=None):\n    \"\"\"Invoke *func* on each item in *iterable* (or on each *chunk_size* group\n    of items) before yielding the item.\n\n    `func` must be a function that takes a single argument. Its return value\n    will be discarded.\n\n    *before* and *after* are optional functions that take no arguments. They\n    will be executed before iteration starts and after it ends, respectively.\n\n    `side_effect` can be used for logging, updating progress bars, or anything\n    that is not functionally \"pure.\"\n\n    Emitting a status message:\n\n        >>> from more_itertools import consume\n        >>> func = lambda item: print('Received {}'.format(item))\n        >>> consume(side_effect(func, range(2)))\n        Received 0\n        Received 1\n\n    Operating on chunks of items:\n\n        >>> pair_sums = []\n        >>> func = lambda chunk: pair_sums.append(sum(chunk))\n        >>> list(side_effect(func, [0, 1, 2, 3, 4, 5], 2))\n        [0, 1, 2, 3, 4, 5]\n        >>> list(pair_sums)\n        [1, 5, 9]\n\n    Writing to a file-like object:\n\n        >>> from io import StringIO\n        >>> from more_itertools import consume\n        >>> f = StringIO()\n        >>> func = lambda x: print(x, file=f)\n        >>> before = lambda: print(u'HEADER', file=f)\n        >>> after = f.close\n        >>> it = [u'a', u'b', u'c']\n        >>> consume(side_effect(func, it, before=before, after=after))\n        >>> f.closed\n        True\n\n    \"\"\"\n    try:\n        if before is not None:\n            before()\n\n        if chunk_size is None:\n            for item in iterable:\n                func(item)\n                yield item\n        else:\n            for chunk in chunked(iterable, chunk_size):\n                func(chunk)\n                yield from chunk\n    finally:\n        if after is not None:\n            after()\n\n\ndef sliced(seq, n, strict=False):\n    \"\"\"Yield slices of length *n* from the sequence *seq*.\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6), 3))\n    [(1, 2, 3), (4, 5, 6)]\n\n    By the default, the last yielded slice will have fewer than *n* elements\n    if the length of *seq* is not divisible by *n*:\n\n    >>> list(sliced((1, 2, 3, 4, 5, 6, 7, 8), 3))\n    [(1, 2, 3), (4, 5, 6), (7, 8)]\n\n    If the length of *seq* is not divisible by *n* and *strict* is\n    ``True``, then ``ValueError`` will be raised before the last\n    slice is yielded.\n\n    This function will only work for iterables that support slicing.\n    For non-sliceable iterables, see :func:`chunked`.\n\n    \"\"\"\n    iterator = takewhile(len, (seq[i : i + n] for i in count(0, n)))\n    if strict:\n\n        def ret():\n            for _slice in iterator:\n                if len(_slice) != n:\n                    raise ValueError(\"seq is not divisible by n.\")\n                yield _slice\n\n        return iter(ret())\n    else:\n        return iterator\n\n\ndef split_at(iterable, pred, maxsplit=-1, keep_separator=False):\n    \"\"\"Yield lists of items from *iterable*, where each list is delimited by\n    an item where callable *pred* returns ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b'))\n        [['a'], ['c', 'd', 'c'], ['a']]\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1))\n        [[0], [2], [4], [6], [8], []]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_at(range(10), lambda n: n % 2 == 1, maxsplit=2))\n        [[0], [2], [4, 5, 6, 7, 8, 9]]\n\n    By default, the delimiting items are not included in the output.\n    To include them, set *keep_separator* to ``True``.\n\n        >>> list(split_at('abcdcba', lambda x: x == 'b', keep_separator=True))\n        [['a'], ['b'], ['c', 'd', 'c'], ['b'], ['a']]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item):\n            yield buf\n            if keep_separator:\n                yield [item]\n            if maxsplit == 1:\n                yield list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        else:\n            buf.append(item)\n    yield buf\n\n\ndef split_before(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends just before\n    an item for which callable *pred* returns ``True``:\n\n        >>> list(split_before('OneTwo', lambda s: s.isupper()))\n        [['O', 'n', 'e'], ['T', 'w', 'o']]\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8], [9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_before(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8, 9]]\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                yield [item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n        buf.append(item)\n    if buf:\n        yield buf\n\n\ndef split_after(iterable, pred, maxsplit=-1):\n    \"\"\"Yield lists of items from *iterable*, where each list ends with an\n    item where callable *pred* returns ``True``:\n\n        >>> list(split_after('one1two2', lambda s: s.isdigit()))\n        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0))\n        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_after(range(10), lambda n: n % 3 == 0, maxsplit=2))\n        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    buf = []\n    it = iter(iterable)\n    for item in it:\n        buf.append(item)\n        if pred(item) and buf:\n            yield buf\n            if maxsplit == 1:\n                buf = list(it)\n                if buf:\n                    yield buf\n                return\n            buf = []\n            maxsplit -= 1\n    if buf:\n        yield buf\n\n\ndef split_when(iterable, pred, maxsplit=-1):\n    \"\"\"Split *iterable* into pieces based on the output of *pred*.\n    *pred* should be a function that takes successive pairs of items and\n    returns ``True`` if the iterable should be split in between them.\n\n    For example, to find runs of increasing numbers, split the iterable when\n    element ``i`` is larger than element ``i + 1``:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2], lambda x, y: x > y))\n        [[1, 2, 3, 3], [2, 5], [2, 4], [2]]\n\n    At most *maxsplit* splits are done. If *maxsplit* is not specified or -1,\n    then there is no limit on the number of splits:\n\n        >>> list(split_when([1, 2, 3, 3, 2, 5, 2, 4, 2],\n        ...                 lambda x, y: x > y, maxsplit=2))\n        [[1, 2, 3, 3], [2, 5], [2, 4, 2]]\n\n    \"\"\"\n    if maxsplit == 0:\n        yield list(iterable)\n        return\n\n    it = iter(iterable)\n    try:\n        cur_item = next(it)\n    except StopIteration:\n        return\n\n    buf = [cur_item]\n    for next_item in it:\n        if pred(cur_item, next_item):\n            yield buf\n            if maxsplit == 1:\n                yield [next_item] + list(it)\n                return\n            buf = []\n            maxsplit -= 1\n\n        buf.append(next_item)\n        cur_item = next_item\n\n    yield buf\n\n\ndef split_into(iterable, sizes):\n    \"\"\"Yield a list of sequential items from *iterable* of length 'n' for each\n    integer 'n' in *sizes*.\n\n        >>> list(split_into([1,2,3,4,5,6], [1,2,3]))\n        [[1], [2, 3], [4, 5, 6]]\n\n    If the sum of *sizes* is smaller than the length of *iterable*, then the\n    remaining items of *iterable* will not be returned.\n\n        >>> list(split_into([1,2,3,4,5,6], [2,3]))\n        [[1, 2], [3, 4, 5]]\n\n    If the sum of *sizes* is larger than the length of *iterable*, fewer items\n    will be returned in the iteration that overruns *iterable* and further\n    lists will be empty:\n\n        >>> list(split_into([1,2,3,4], [1,2,3,4]))\n        [[1], [2, 3], [4], []]\n\n    When a ``None`` object is encountered in *sizes*, the returned list will\n    contain items up to the end of *iterable* the same way that itertools.slice\n    does:\n\n        >>> list(split_into([1,2,3,4,5,6,7,8,9,0], [2,3,None]))\n        [[1, 2], [3, 4, 5], [6, 7, 8, 9, 0]]\n\n    :func:`split_into` can be useful for grouping a series of items where the\n    sizes of the groups are not uniform. An example would be where in a row\n    from a table, multiple columns represent elements of the same feature\n    (e.g. a point represented by x,y,z) but, the format is not the same for\n    all columns.\n    \"\"\"\n    # convert the iterable argument into an iterator so its contents can\n    # be consumed by islice in case it is a generator\n    it = iter(iterable)\n\n    for size in sizes:\n        if size is None:\n            yield list(it)\n            return\n        else:\n            yield list(islice(it, size))\n\n\ndef padded(iterable, fillvalue=None, n=None, next_multiple=False):\n    \"\"\"Yield the elements from *iterable*, followed by *fillvalue*, such that\n    at least *n* items are emitted.\n\n        >>> list(padded([1, 2, 3], '?', 5))\n        [1, 2, 3, '?', '?']\n\n    If *next_multiple* is ``True``, *fillvalue* will be emitted until the\n    number of items emitted is a multiple of *n*:\n\n        >>> list(padded([1, 2, 3, 4], n=3, next_multiple=True))\n        [1, 2, 3, 4, None, None]\n\n    If *n* is ``None``, *fillvalue* will be emitted indefinitely.\n\n    To create an *iterable* of exactly size *n*, you can truncate with\n    :func:`islice`.\n\n        >>> list(islice(padded([1, 2, 3], '?'), 5))\n        [1, 2, 3, '?', '?']\n        >>> list(islice(padded([1, 2, 3, 4, 5, 6, 7, 8], '?'), 5))\n        [1, 2, 3, 4, 5]\n\n    \"\"\"\n    iterable = iter(iterable)\n    iterable_with_repeat = chain(iterable, repeat(fillvalue))\n\n    if n is None:\n        return iterable_with_repeat\n    elif n < 1:\n        raise ValueError('n must be at least 1')\n    elif next_multiple:\n\n        def slice_generator():\n            for first in iterable:\n                yield (first,)\n                yield islice(iterable_with_repeat, n - 1)\n\n        # While elements exist produce slices of size n\n        return chain.from_iterable(slice_generator())\n    else:\n        # Ensure the first batch is at least size n then iterate\n        return chain(islice(iterable_with_repeat, n), iterable)\n\n\ndef repeat_each(iterable, n=2):\n    \"\"\"Repeat each element in *iterable* *n* times.\n\n    >>> list(repeat_each('ABC', 3))\n    ['A', 'A', 'A', 'B', 'B', 'B', 'C', 'C', 'C']\n    \"\"\"\n    return chain.from_iterable(map(repeat, iterable, repeat(n)))\n\n\ndef repeat_last(iterable, default=None):\n    \"\"\"After the *iterable* is exhausted, keep yielding its last element.\n\n        >>> list(islice(repeat_last(range(3)), 5))\n        [0, 1, 2, 2, 2]\n\n    If the iterable is empty, yield *default* forever::\n\n        >>> list(islice(repeat_last(range(0), 42), 5))\n        [42, 42, 42, 42, 42]\n\n    \"\"\"\n    item = _marker\n    for item in iterable:\n        yield item\n    final = default if item is _marker else item\n    yield from repeat(final)\n\n\ndef distribute(n, iterable):\n    \"\"\"Distribute the items from *iterable* among *n* smaller iterables.\n\n        >>> group_1, group_2 = distribute(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 3, 5]\n        >>> list(group_2)\n        [2, 4, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = distribute(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 4, 7], [2, 5], [3, 6]]\n\n    If the length of *iterable* is smaller than *n*, then the last returned\n    iterables will be empty:\n\n        >>> children = distribute(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function uses :func:`itertools.tee` and may require significant\n    storage.\n\n    If you need the order items in the smaller iterables to match the\n    original iterable, see :func:`divide`.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    children = tee(iterable, n)\n    return [islice(it, index, None, n) for index, it in enumerate(children)]\n\n\ndef stagger(iterable, offsets=(-1, 0, 1), longest=False, fillvalue=None):\n    \"\"\"Yield tuples whose elements are offset from *iterable*.\n    The amount by which the `i`-th item in each tuple is offset is given by\n    the `i`-th item in *offsets*.\n\n        >>> list(stagger([0, 1, 2, 3]))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3)]\n        >>> list(stagger(range(8), offsets=(0, 2, 4)))\n        [(0, 2, 4), (1, 3, 5), (2, 4, 6), (3, 5, 7)]\n\n    By default, the sequence will end when the final element of a tuple is the\n    last item in the iterable. To continue until the first element of a tuple\n    is the last item in the iterable, set *longest* to ``True``::\n\n        >>> list(stagger([0, 1, 2, 3], longest=True))\n        [(None, 0, 1), (0, 1, 2), (1, 2, 3), (2, 3, None), (3, None, None)]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    children = tee(iterable, len(offsets))\n\n    return zip_offset(\n        *children, offsets=offsets, longest=longest, fillvalue=fillvalue\n    )\n\n\ndef zip_equal(*iterables):\n    \"\"\"``zip`` the input *iterables* together, but raise\n    ``UnequalIterablesError`` if they aren't all the same length.\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abc')\n        >>> list(zip_equal(it_1, it_2))\n        [(0, 'a'), (1, 'b'), (2, 'c')]\n\n        >>> it_1 = range(3)\n        >>> it_2 = iter('abcd')\n        >>> list(zip_equal(it_1, it_2)) # doctest: +IGNORE_EXCEPTION_DETAIL\n        Traceback (most recent call last):\n        ...\n        more_itertools.more.UnequalIterablesError: Iterables have different\n        lengths\n\n    \"\"\"\n    if hexversion >= 0x30A00A6:\n        warnings.warn(\n            (\n                'zip_equal will be removed in a future version of '\n                'more-itertools. Use the builtin zip function with '\n                'strict=True instead.'\n            ),\n            DeprecationWarning,\n        )\n\n    return _zip_equal(*iterables)\n\n\ndef zip_offset(*iterables, offsets, longest=False, fillvalue=None):\n    \"\"\"``zip`` the input *iterables* together, but offset the `i`-th iterable\n    by the `i`-th item in *offsets*.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1)))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]\n\n    This can be used as a lightweight alternative to SciPy or pandas to analyze\n    data sets in which some series have a lead or lag relationship.\n\n    By default, the sequence will end when the shortest iterable is exhausted.\n    To continue until the longest iterable is exhausted, set *longest* to\n    ``True``.\n\n        >>> list(zip_offset('0123', 'abcdef', offsets=(0, 1), longest=True))\n        [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]\n\n    By default, ``None`` will be used to replace offsets beyond the end of the\n    sequence. Specify *fillvalue* to use some other value.\n\n    \"\"\"\n    if len(iterables) != len(offsets):\n        raise ValueError(\"Number of iterables and offsets didn't match\")\n\n    staggered = []\n    for it, n in zip(iterables, offsets):\n        if n < 0:\n            staggered.append(chain(repeat(fillvalue, -n), it))\n        elif n > 0:\n            staggered.append(islice(it, n, None))\n        else:\n            staggered.append(it)\n\n    if longest:\n        return zip_longest(*staggered, fillvalue=fillvalue)\n\n    return zip(*staggered)\n\n\ndef sort_together(iterables, key_list=(0,), key=None, reverse=False):\n    \"\"\"Return the input iterables sorted together, with *key_list* as the\n    priority for sorting. All iterables are trimmed to the length of the\n    shortest one.\n\n    This can be used like the sorting function in a spreadsheet. If each\n    iterable represents a column of data, the key list determines which\n    columns are used for sorting.\n\n    By default, all iterables are sorted using the ``0``-th iterable::\n\n        >>> iterables = [(4, 3, 2, 1), ('a', 'b', 'c', 'd')]\n        >>> sort_together(iterables)\n        [(1, 2, 3, 4), ('d', 'c', 'b', 'a')]\n\n    Set a different key list to sort according to another iterable.\n    Specifying multiple keys dictates how ties are broken::\n\n        >>> iterables = [(3, 1, 2), (0, 1, 0), ('c', 'b', 'a')]\n        >>> sort_together(iterables, key_list=(1, 2))\n        [(2, 3, 1), (0, 0, 1), ('a', 'c', 'b')]\n\n    To sort by a function of the elements of the iterable, pass a *key*\n    function. Its arguments are the elements of the iterables corresponding to\n    the key list::\n\n        >>> names = ('a', 'b', 'c')\n        >>> lengths = (1, 2, 3)\n        >>> widths = (5, 2, 1)\n        >>> def area(length, width):\n        ...     return length * width\n        >>> sort_together([names, lengths, widths], key_list=(1, 2), key=area)\n        [('c', 'b', 'a'), (3, 2, 1), (1, 2, 5)]\n\n    Set *reverse* to ``True`` to sort in descending order.\n\n        >>> sort_together([(1, 2, 3), ('c', 'b', 'a')], reverse=True)\n        [(3, 2, 1), ('a', 'b', 'c')]\n\n    \"\"\"\n    if key is None:\n        # if there is no key function, the key argument to sorted is an\n        # itemgetter\n        key_argument = itemgetter(*key_list)\n    else:\n        # if there is a key function, call it with the items at the offsets\n        # specified by the key function as arguments\n        key_list = list(key_list)\n        if len(key_list) == 1:\n            # if key_list contains a single item, pass the item at that offset\n            # as the only argument to the key function\n            key_offset = key_list[0]\n            key_argument = lambda zipped_items: key(zipped_items[key_offset])\n        else:\n            # if key_list contains multiple items, use itemgetter to return a\n            # tuple of items, which we pass as *args to the key function\n            get_key_items = itemgetter(*key_list)\n            key_argument = lambda zipped_items: key(\n                *get_key_items(zipped_items)\n            )\n\n    return list(\n        zip(*sorted(zip(*iterables), key=key_argument, reverse=reverse))\n    )\n\n\ndef unzip(iterable):\n    \"\"\"The inverse of :func:`zip`, this function disaggregates the elements\n    of the zipped *iterable*.\n\n    The ``i``-th iterable contains the ``i``-th element from each element\n    of the zipped iterable. The first element is used to determine the\n    length of the remaining elements.\n\n        >>> iterable = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> letters, numbers = unzip(iterable)\n        >>> list(letters)\n        ['a', 'b', 'c', 'd']\n        >>> list(numbers)\n        [1, 2, 3, 4]\n\n    This is similar to using ``zip(*iterable)``, but it avoids reading\n    *iterable* into memory. Note, however, that this function uses\n    :func:`itertools.tee` and thus may require significant storage.\n\n    \"\"\"\n    head, iterable = spy(iter(iterable))\n    if not head:\n        # empty iterable, e.g. zip([], [], [])\n        return ()\n    # spy returns a one-length iterable as head\n    head = head[0]\n    iterables = tee(iterable, len(head))\n\n    def itemgetter(i):\n        def getter(obj):\n            try:\n                return obj[i]\n            except IndexError:\n                # basically if we have an iterable like\n                # iter([(1, 2, 3), (4, 5), (6,)])\n                # the second unzipped iterable would fail at the third tuple\n                # since it would try to access tup[1]\n                # same with the third unzipped iterable and the second tuple\n                # to support these \"improperly zipped\" iterables,\n                # we create a custom itemgetter\n                # which just stops the unzipped iterables\n                # at first length mismatch\n                raise StopIteration\n\n        return getter\n\n    return tuple(map(itemgetter(i), it) for i, it in enumerate(iterables))\n\n\ndef divide(n, iterable):\n    \"\"\"Divide the elements from *iterable* into *n* parts, maintaining\n    order.\n\n        >>> group_1, group_2 = divide(2, [1, 2, 3, 4, 5, 6])\n        >>> list(group_1)\n        [1, 2, 3]\n        >>> list(group_2)\n        [4, 5, 6]\n\n    If the length of *iterable* is not evenly divisible by *n*, then the\n    length of the returned iterables will not be identical:\n\n        >>> children = divide(3, [1, 2, 3, 4, 5, 6, 7])\n        >>> [list(c) for c in children]\n        [[1, 2, 3], [4, 5], [6, 7]]\n\n    If the length of the iterable is smaller than n, then the last returned\n    iterables will be empty:\n\n        >>> children = divide(5, [1, 2, 3])\n        >>> [list(c) for c in children]\n        [[1], [2], [3], [], []]\n\n    This function will exhaust the iterable before returning.\n    If order is not important, see :func:`distribute`, which does not first\n    pull the iterable into memory.\n\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least 1')\n\n    try:\n        iterable[:0]\n    except TypeError:\n        seq = tuple(iterable)\n    else:\n        seq = iterable\n\n    q, r = divmod(len(seq), n)\n\n    ret = []\n    stop = 0\n    for i in range(1, n + 1):\n        start = stop\n        stop += q + 1 if i <= r else q\n        ret.append(iter(seq[start:stop]))\n\n    return ret\n\n\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n\n\ndef adjacent(predicate, iterable, distance=1):\n    \"\"\"Return an iterable over `(bool, item)` tuples where the `item` is\n    drawn from *iterable* and the `bool` indicates whether\n    that item satisfies the *predicate* or is adjacent to an item that does.\n\n    For example, to find whether items are adjacent to a ``3``::\n\n        >>> list(adjacent(lambda x: x == 3, range(6)))\n        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]\n\n    Set *distance* to change what counts as adjacent. For example, to find\n    whether items are two places away from a ``3``:\n\n        >>> list(adjacent(lambda x: x == 3, range(6), distance=2))\n        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]\n\n    This is useful for contextualizing the results of a search function.\n    For example, a code comparison tool might want to identify lines that\n    have changed, but also surrounding lines to give the viewer of the diff\n    context.\n\n    The predicate function will only be called once for each item in the\n    iterable.\n\n    See also :func:`groupby_transform`, which can be used with this function\n    to group ranges of items with the same `bool` value.\n\n    \"\"\"\n    # Allow distance=0 mainly for testing that it reproduces results with map()\n    if distance < 0:\n        raise ValueError('distance must be at least 0')\n\n    i1, i2 = tee(iterable)\n    padding = [False] * distance\n    selected = chain(padding, map(predicate, i1), padding)\n    adjacent_to_selected = map(any, windowed(selected, 2 * distance + 1))\n    return zip(adjacent_to_selected, i2)\n\n\ndef groupby_transform(iterable, keyfunc=None, valuefunc=None, reducefunc=None):\n    \"\"\"An extension of :func:`itertools.groupby` that can apply transformations\n    to the grouped data.\n\n    * *keyfunc* is a function computing a key value for each item in *iterable*\n    * *valuefunc* is a function that transforms the individual items from\n      *iterable* after grouping\n    * *reducefunc* is a function that transforms each group of items\n\n    >>> iterable = 'aAAbBBcCC'\n    >>> keyfunc = lambda k: k.upper()\n    >>> valuefunc = lambda v: v.lower()\n    >>> reducefunc = lambda g: ''.join(g)\n    >>> list(groupby_transform(iterable, keyfunc, valuefunc, reducefunc))\n    [('A', 'aaa'), ('B', 'bbb'), ('C', 'ccc')]\n\n    Each optional argument defaults to an identity function if not specified.\n\n    :func:`groupby_transform` is useful when grouping elements of an iterable\n    using a separate iterable as the key. To do this, :func:`zip` the iterables\n    and pass a *keyfunc* that extracts the first element and a *valuefunc*\n    that extracts the second element::\n\n        >>> from operator import itemgetter\n        >>> keys = [0, 0, 1, 1, 1, 2, 2, 2, 3]\n        >>> values = 'abcdefghi'\n        >>> iterable = zip(keys, values)\n        >>> grouper = groupby_transform(iterable, itemgetter(0), itemgetter(1))\n        >>> [(k, ''.join(g)) for k, g in grouper]\n        [(0, 'ab'), (1, 'cde'), (2, 'fgh'), (3, 'i')]\n\n    Note that the order of items in the iterable is significant.\n    Only adjacent items are grouped together, so if you don't want any\n    duplicate groups, you should sort the iterable by the key function.\n\n    \"\"\"\n    ret = groupby(iterable, keyfunc)\n    if valuefunc:\n        ret = ((k, map(valuefunc, g)) for k, g in ret)\n    if reducefunc:\n        ret = ((k, reducefunc(g)) for k, g in ret)\n\n    return ret\n\n\nclass numeric_range(abc.Sequence, abc.Hashable):\n    \"\"\"An extension of the built-in ``range()`` function whose arguments can\n    be any orderable numeric type.\n\n    With only *stop* specified, *start* defaults to ``0`` and *step*\n    defaults to ``1``. The output items will match the type of *stop*:\n\n        >>> list(numeric_range(3.5))\n        [0.0, 1.0, 2.0, 3.0]\n\n    With only *start* and *stop* specified, *step* defaults to ``1``. The\n    output items will match the type of *start*:\n\n        >>> from decimal import Decimal\n        >>> start = Decimal('2.1')\n        >>> stop = Decimal('5.1')\n        >>> list(numeric_range(start, stop))\n        [Decimal('2.1'), Decimal('3.1'), Decimal('4.1')]\n\n    With *start*, *stop*, and *step*  specified the output items will match\n    the type of ``start + step``:\n\n        >>> from fractions import Fraction\n        >>> start = Fraction(1, 2)  # Start at 1/2\n        >>> stop = Fraction(5, 2)  # End at 5/2\n        >>> step = Fraction(1, 2)  # Count by 1/2\n        >>> list(numeric_range(start, stop, step))\n        [Fraction(1, 2), Fraction(1, 1), Fraction(3, 2), Fraction(2, 1)]\n\n    If *step* is zero, ``ValueError`` is raised. Negative steps are supported:\n\n        >>> list(numeric_range(3, -1, -1.0))\n        [3.0, 2.0, 1.0, 0.0]\n\n    Be aware of the limitations of floating point numbers; the representation\n    of the yielded numbers may be surprising.\n\n    ``datetime.datetime`` objects can be used for *start* and *stop*, if *step*\n    is a ``datetime.timedelta`` object:\n\n        >>> import datetime\n        >>> start = datetime.datetime(2019, 1, 1)\n        >>> stop = datetime.datetime(2019, 1, 3)\n        >>> step = datetime.timedelta(days=1)\n        >>> items = iter(numeric_range(start, stop, step))\n        >>> next(items)\n        datetime.datetime(2019, 1, 1, 0, 0)\n        >>> next(items)\n        datetime.datetime(2019, 1, 2, 0, 0)\n\n    \"\"\"\n\n    _EMPTY_HASH = hash(range(0, 0))\n\n    def __init__(self, *args):\n        argc = len(args)\n        if argc == 1:\n            (self._stop,) = args\n            self._start = type(self._stop)(0)\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 2:\n            self._start, self._stop = args\n            self._step = type(self._stop - self._start)(1)\n        elif argc == 3:\n            self._start, self._stop, self._step = args\n        elif argc == 0:\n            raise TypeError(\n                'numeric_range expected at least '\n                '1 argument, got {}'.format(argc)\n            )\n        else:\n            raise TypeError(\n                'numeric_range expected at most '\n                '3 arguments, got {}'.format(argc)\n            )\n\n        self._zero = type(self._step)(0)\n        if self._step == self._zero:\n            raise ValueError('numeric_range() arg 3 must not be zero')\n        self._growing = self._step > self._zero\n\n    def __bool__(self):\n        if self._growing:\n            return self._start < self._stop\n        else:\n            return self._start > self._stop\n\n    def __contains__(self, elem):\n        if self._growing:\n            if self._start <= elem < self._stop:\n                return (elem - self._start) % self._step == self._zero\n        else:\n            if self._start >= elem > self._stop:\n                return (self._start - elem) % (-self._step) == self._zero\n\n        return False\n\n    def __eq__(self, other):\n        if isinstance(other, numeric_range):\n            empty_self = not bool(self)\n            empty_other = not bool(other)\n            if empty_self or empty_other:\n                return empty_self and empty_other  # True if both empty\n            else:\n                return (\n                    self._start == other._start\n                    and self._step == other._step\n                    and self._get_by_index(-1) == other._get_by_index(-1)\n                )\n        else:\n            return False\n\n    def __getitem__(self, key):\n        if isinstance(key, int):\n            return self._get_by_index(key)\n        elif isinstance(key, slice):\n            step = self._step if key.step is None else key.step * self._step\n\n            if key.start is None or key.start <= -self._len:\n                start = self._start\n            elif key.start >= self._len:\n                start = self._stop\n            else:  # -self._len < key.start < self._len\n                start = self._get_by_index(key.start)\n\n            if key.stop is None or key.stop >= self._len:\n                stop = self._stop\n            elif key.stop <= -self._len:\n                stop = self._start\n            else:  # -self._len < key.stop < self._len\n                stop = self._get_by_index(key.stop)\n\n            return numeric_range(start, stop, step)\n        else:\n            raise TypeError(\n                'numeric range indices must be '\n                'integers or slices, not {}'.format(type(key).__name__)\n            )\n\n    def __hash__(self):\n        if self:\n            return hash((self._start, self._get_by_index(-1), self._step))\n        else:\n            return self._EMPTY_HASH\n\n    def __iter__(self):\n        values = (self._start + (n * self._step) for n in count())\n        if self._growing:\n            return takewhile(partial(gt, self._stop), values)\n        else:\n            return takewhile(partial(lt, self._stop), values)\n\n    def __len__(self):\n        return self._len\n\n    @cached_property\n    def _len(self):\n        if self._growing:\n            start = self._start\n            stop = self._stop\n            step = self._step\n        else:\n            start = self._stop\n            stop = self._start\n            step = -self._step\n        distance = stop - start\n        if distance <= self._zero:\n            return 0\n        else:  # distance > 0 and step > 0: regular euclidean division\n            q, r = divmod(distance, step)\n            return int(q) + int(r != self._zero)\n\n    def __reduce__(self):\n        return numeric_range, (self._start, self._stop, self._step)\n\n    def __repr__(self):\n        if self._step == 1:\n            return \"numeric_range({}, {})\".format(\n                repr(self._start), repr(self._stop)\n            )\n        else:\n            return \"numeric_range({}, {}, {})\".format(\n                repr(self._start), repr(self._stop), repr(self._step)\n            )\n\n    def __reversed__(self):\n        return iter(\n            numeric_range(\n                self._get_by_index(-1), self._start - self._step, -self._step\n            )\n        )\n\n    def count(self, value):\n        return int(value in self)\n\n    def index(self, value):\n        if self._growing:\n            if self._start <= value < self._stop:\n                q, r = divmod(value - self._start, self._step)\n                if r == self._zero:\n                    return int(q)\n        else:\n            if self._start >= value > self._stop:\n                q, r = divmod(self._start - value, -self._step)\n                if r == self._zero:\n                    return int(q)\n\n        raise ValueError(\"{} is not in numeric range\".format(value))\n\n    def _get_by_index(self, i):\n        if i < 0:\n            i += self._len\n        if i < 0 or i >= self._len:\n            raise IndexError(\"numeric range object index out of range\")\n        return self._start + i * self._step\n\n\ndef count_cycle(iterable, n=None):\n    \"\"\"Cycle through the items from *iterable* up to *n* times, yielding\n    the number of completed cycles along with each item. If *n* is omitted the\n    process repeats indefinitely.\n\n    >>> list(count_cycle('AB', 3))\n    [(0, 'A'), (0, 'B'), (1, 'A'), (1, 'B'), (2, 'A'), (2, 'B')]\n\n    \"\"\"\n    iterable = tuple(iterable)\n    if not iterable:\n        return iter(())\n    counter = count() if n is None else range(n)\n    return ((i, item) for i in counter for item in iterable)\n\n\ndef mark_ends(iterable):\n    \"\"\"Yield 3-tuples of the form ``(is_first, is_last, item)``.\n\n    >>> list(mark_ends('ABC'))\n    [(True, False, 'A'), (False, False, 'B'), (False, True, 'C')]\n\n    Use this when looping over an iterable to take special action on its first\n    and/or last items:\n\n    >>> iterable = ['Header', 100, 200, 'Footer']\n    >>> total = 0\n    >>> for is_first, is_last, item in mark_ends(iterable):\n    ...     if is_first:\n    ...         continue  # Skip the header\n    ...     if is_last:\n    ...         continue  # Skip the footer\n    ...     total += item\n    >>> print(total)\n    300\n    \"\"\"\n    it = iter(iterable)\n\n    try:\n        b = next(it)\n    except StopIteration:\n        return\n\n    try:\n        for i in count():\n            a = b\n            b = next(it)\n            yield i == 0, False, a\n\n    except StopIteration:\n        yield i == 0, True, a\n\n\ndef locate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(locate([0, 1, 1, 0, 1, 0, 0]))\n        [1, 2, 4]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item.\n\n        >>> list(locate(['a', 'b', 'c', 'b'], lambda x: x == 'b'))\n        [1, 3]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(locate(iterable, pred=pred, window_size=3))\n        [1, 5, 9]\n\n    Use with :func:`seekable` to find indexes and then retrieve the associated\n    items:\n\n        >>> from itertools import count\n        >>> from more_itertools import seekable\n        >>> source = (3 * n + 1 if (n % 2) else n // 2 for n in count())\n        >>> it = seekable(source)\n        >>> pred = lambda x: x > 100\n        >>> indexes = locate(it, pred=pred)\n        >>> i = next(indexes)\n        >>> it.seek(i)\n        >>> next(it)\n        106\n\n    \"\"\"\n    if window_size is None:\n        return compress(count(), map(pred, iterable))\n\n    if window_size < 1:\n        raise ValueError('window size must be at least 1')\n\n    it = windowed(iterable, window_size, fillvalue=_marker)\n    return compress(count(), starmap(pred, it))\n\n\ndef longest_common_prefix(iterables):\n    \"\"\"Yield elements of the longest common prefix amongst given *iterables*.\n\n    >>> ''.join(longest_common_prefix(['abcd', 'abc', 'abf']))\n    'ab'\n\n    \"\"\"\n    return (c[0] for c in takewhile(all_equal, zip(*iterables)))\n\n\ndef lstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the beginning\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the start of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(lstrip(iterable, pred))\n        [1, 2, None, 3, False, None]\n\n    This function is analogous to to :func:`str.lstrip`, and is essentially\n    an wrapper for :func:`itertools.dropwhile`.\n\n    \"\"\"\n    return dropwhile(pred, iterable)\n\n\ndef rstrip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the end\n    for which *pred* returns ``True``.\n\n    For example, to remove a set of items from the end of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(rstrip(iterable, pred))\n        [None, False, None, 1, 2, None, 3]\n\n    This function is analogous to :func:`str.rstrip`.\n\n    \"\"\"\n    cache = []\n    cache_append = cache.append\n    cache_clear = cache.clear\n    for x in iterable:\n        if pred(x):\n            cache_append(x)\n        else:\n            yield from cache\n            cache_clear()\n            yield x\n\n\ndef strip(iterable, pred):\n    \"\"\"Yield the items from *iterable*, but strip any from the\n    beginning and end for which *pred* returns ``True``.\n\n    For example, to remove a set of items from both ends of an iterable:\n\n        >>> iterable = (None, False, None, 1, 2, None, 3, False, None)\n        >>> pred = lambda x: x in {None, False, ''}\n        >>> list(strip(iterable, pred))\n        [1, 2, None, 3]\n\n    This function is analogous to :func:`str.strip`.\n\n    \"\"\"\n    return rstrip(lstrip(iterable, pred), pred)\n\n\nclass islice_extended:\n    \"\"\"An extension of :func:`itertools.islice` that supports negative values\n    for *stop*, *start*, and *step*.\n\n        >>> iterable = iter('abcdefgh')\n        >>> list(islice_extended(iterable, -4, -1))\n        ['e', 'f', 'g']\n\n    Slices with negative values require some caching of *iterable*, but this\n    function takes care to minimize the amount of memory required.\n\n    For example, you can use a negative step with an infinite iterator:\n\n        >>> from itertools import count\n        >>> list(islice_extended(count(), 110, 99, -2))\n        [110, 108, 106, 104, 102, 100]\n\n    You can also use slice notation directly:\n\n        >>> iterable = map(str, count())\n        >>> it = islice_extended(iterable)[10:20:2]\n        >>> list(it)\n        ['10', '12', '14', '16', '18']\n\n    \"\"\"\n\n    def __init__(self, iterable, *args):\n        it = iter(iterable)\n        if args:\n            self._iterable = _islice_helper(it, slice(*args))\n        else:\n            self._iterable = it\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterable)\n\n    def __getitem__(self, key):\n        if isinstance(key, slice):\n            return islice_extended(_islice_helper(self._iterable, key))\n\n        raise TypeError('islice_extended.__getitem__ argument must be a slice')\n\n\ndef _islice_helper(it, s):\n    start = s.start\n    stop = s.stop\n    if s.step == 0:\n        raise ValueError('step argument must be a non-zero integer or None.')\n    step = s.step or 1\n\n    if step > 0:\n        start = 0 if (start is None) else start\n\n        if start < 0:\n            # Consume all but the last -start items\n            cache = deque(enumerate(it, 1), maxlen=-start)\n            len_iter = cache[-1][0] if cache else 0\n\n            # Adjust start to be positive\n            i = max(len_iter + start, 0)\n\n            # Adjust stop to be positive\n            if stop is None:\n                j = len_iter\n            elif stop >= 0:\n                j = min(stop, len_iter)\n            else:\n                j = max(len_iter + stop, 0)\n\n            # Slice the cache\n            n = j - i\n            if n <= 0:\n                return\n\n            for index, item in islice(cache, 0, n, step):\n                yield item\n        elif (stop is not None) and (stop < 0):\n            # Advance to the start position\n            next(islice(it, start, start), None)\n\n            # When stop is negative, we have to carry -stop items while\n            # iterating\n            cache = deque(islice(it, -stop), maxlen=-stop)\n\n            for index, item in enumerate(it):\n                cached_item = cache.popleft()\n                if index % step == 0:\n                    yield cached_item\n                cache.append(item)\n        else:\n            # When both start and stop are positive we have the normal case\n            yield from islice(it, start, stop, step)\n    else:\n        start = -1 if (start is None) else start\n\n        if (stop is not None) and (stop < 0):\n            # Consume all but the last items\n            n = -stop - 1\n            cache = deque(enumerate(it, 1), maxlen=n)\n            len_iter = cache[-1][0] if cache else 0\n\n            # If start and stop are both negative they are comparable and\n            # we can just slice. Otherwise we can adjust start to be negative\n            # and then slice.\n            if start < 0:\n                i, j = start, stop\n            else:\n                i, j = min(start - len_iter, -1), None\n\n            for index, item in list(cache)[i:j:step]:\n                yield item\n        else:\n            # Advance to the stop position\n            if stop is not None:\n                m = stop + 1\n                next(islice(it, m, m), None)\n\n            # stop is positive, so if start is negative they are not comparable\n            # and we need the rest of the items.\n            if start < 0:\n                i = start\n                n = None\n            # stop is None and start is positive, so we just need items up to\n            # the start index.\n            elif stop is None:\n                i = None\n                n = start + 1\n            # Both stop and start are positive, so they are comparable.\n            else:\n                i = None\n                n = start - stop\n                if n <= 0:\n                    return\n\n            cache = list(islice(it, n))\n\n            yield from cache[i::step]\n\n\ndef always_reversible(iterable):\n    \"\"\"An extension of :func:`reversed` that supports all iterables, not\n    just those which implement the ``Reversible`` or ``Sequence`` protocols.\n\n        >>> print(*always_reversible(x for x in range(3)))\n        2 1 0\n\n    If the iterable is already reversible, this function returns the\n    result of :func:`reversed()`. If the iterable is not reversible,\n    this function will cache the remaining items in the iterable and\n    yield them in reverse order, which may require significant storage.\n    \"\"\"\n    try:\n        return reversed(iterable)\n    except TypeError:\n        return reversed(list(iterable))\n\n\ndef consecutive_groups(iterable, ordering=lambda x: x):\n    \"\"\"Yield groups of consecutive items using :func:`itertools.groupby`.\n    The *ordering* function determines whether two items are adjacent by\n    returning their position.\n\n    By default, the ordering function is the identity function. This is\n    suitable for finding runs of numbers:\n\n        >>> iterable = [1, 10, 11, 12, 20, 30, 31, 32, 33, 40]\n        >>> for group in consecutive_groups(iterable):\n        ...     print(list(group))\n        [1]\n        [10, 11, 12]\n        [20]\n        [30, 31, 32, 33]\n        [40]\n\n    For finding runs of adjacent letters, try using the :meth:`index` method\n    of a string of letters:\n\n        >>> from string import ascii_lowercase\n        >>> iterable = 'abcdfgilmnop'\n        >>> ordering = ascii_lowercase.index\n        >>> for group in consecutive_groups(iterable, ordering):\n        ...     print(list(group))\n        ['a', 'b', 'c', 'd']\n        ['f', 'g']\n        ['i']\n        ['l', 'm', 'n', 'o', 'p']\n\n    Each group of consecutive items is an iterator that shares it source with\n    *iterable*. When an an output group is advanced, the previous group is\n    no longer available unless its elements are copied (e.g., into a ``list``).\n\n        >>> iterable = [1, 2, 11, 12, 21, 22]\n        >>> saved_groups = []\n        >>> for group in consecutive_groups(iterable):\n        ...     saved_groups.append(list(group))  # Copy group elements\n        >>> saved_groups\n        [[1, 2], [11, 12], [21, 22]]\n\n    \"\"\"\n    for k, g in groupby(\n        enumerate(iterable), key=lambda x: x[0] - ordering(x[1])\n    ):\n        yield map(itemgetter(1), g)\n\n\ndef difference(iterable, func=sub, *, initial=None):\n    \"\"\"This function is the inverse of :func:`itertools.accumulate`. By default\n    it will compute the first difference of *iterable* using\n    :func:`operator.sub`:\n\n        >>> from itertools import accumulate\n        >>> iterable = accumulate([0, 1, 2, 3, 4])  # produces 0, 1, 3, 6, 10\n        >>> list(difference(iterable))\n        [0, 1, 2, 3, 4]\n\n    *func* defaults to :func:`operator.sub`, but other functions can be\n    specified. They will be applied as follows::\n\n        A, B, C, D, ... --> A, func(B, A), func(C, B), func(D, C), ...\n\n    For example, to do progressive division:\n\n        >>> iterable = [1, 2, 6, 24, 120]\n        >>> func = lambda x, y: x // y\n        >>> list(difference(iterable, func))\n        [1, 2, 3, 4, 5]\n\n    If the *initial* keyword is set, the first element will be skipped when\n    computing successive differences.\n\n        >>> it = [10, 11, 13, 16]  # from accumulate([1, 2, 3], initial=10)\n        >>> list(difference(it, initial=10))\n        [1, 2, 3]\n\n    \"\"\"\n    a, b = tee(iterable)\n    try:\n        first = [next(b)]\n    except StopIteration:\n        return iter([])\n\n    if initial is not None:\n        first = []\n\n    return chain(first, map(func, b, a))\n\n\nclass SequenceView(Sequence):\n    \"\"\"Return a read-only view of the sequence object *target*.\n\n    :class:`SequenceView` objects are analogous to Python's built-in\n    \"dictionary view\" types. They provide a dynamic view of a sequence's items,\n    meaning that when the sequence updates, so does the view.\n\n        >>> seq = ['0', '1', '2']\n        >>> view = SequenceView(seq)\n        >>> view\n        SequenceView(['0', '1', '2'])\n        >>> seq.append('3')\n        >>> view\n        SequenceView(['0', '1', '2', '3'])\n\n    Sequence views support indexing, slicing, and length queries. They act\n    like the underlying sequence, except they don't allow assignment:\n\n        >>> view[1]\n        '1'\n        >>> view[1:-1]\n        ['1', '2']\n        >>> len(view)\n        4\n\n    Sequence views are useful as an alternative to copying, as they don't\n    require (much) extra storage.\n\n    \"\"\"\n\n    def __init__(self, target):\n        if not isinstance(target, Sequence):\n            raise TypeError\n        self._target = target\n\n    def __getitem__(self, index):\n        return self._target[index]\n\n    def __len__(self):\n        return len(self._target)\n\n    def __repr__(self):\n        return '{}({})'.format(self.__class__.__name__, repr(self._target))\n\n\nclass seekable:\n    \"\"\"Wrap an iterator to allow for seeking backward and forward. This\n    progressively caches the items in the source iterable so they can be\n    re-visited.\n\n    Call :meth:`seek` with an index to seek to that position in the source\n    iterable.\n\n    To \"reset\" an iterator, seek to ``0``:\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> next(it)\n        '3'\n\n    You can also seek forward:\n\n        >>> it = seekable((str(n) for n in range(20)))\n        >>> it.seek(10)\n        >>> next(it)\n        '10'\n        >>> it.relative_seek(-2)  # Seeking relative to the current position\n        >>> next(it)\n        '9'\n        >>> it.seek(20)  # Seeking past the end of the source isn't a problem\n        >>> list(it)\n        []\n        >>> it.seek(0)  # Resetting works even after hitting the end\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n\n    Call :meth:`peek` to look ahead one item without advancing the iterator:\n\n        >>> it = seekable('1234')\n        >>> it.peek()\n        '1'\n        >>> list(it)\n        ['1', '2', '3', '4']\n        >>> it.peek(default='empty')\n        'empty'\n\n    Before the iterator is at its end, calling :func:`bool` on it will return\n    ``True``. After it will return ``False``:\n\n        >>> it = seekable('5678')\n        >>> bool(it)\n        True\n        >>> list(it)\n        ['5', '6', '7', '8']\n        >>> bool(it)\n        False\n\n    You may view the contents of the cache with the :meth:`elements` method.\n    That returns a :class:`SequenceView`, a view that updates automatically:\n\n        >>> it = seekable((str(n) for n in range(10)))\n        >>> next(it), next(it), next(it)\n        ('0', '1', '2')\n        >>> elements = it.elements()\n        >>> elements\n        SequenceView(['0', '1', '2'])\n        >>> next(it)\n        '3'\n        >>> elements\n        SequenceView(['0', '1', '2', '3'])\n\n    By default, the cache grows as the source iterable progresses, so beware of\n    wrapping very large or infinite iterables. Supply *maxlen* to limit the\n    size of the cache (this of course limits how far back you can seek).\n\n        >>> from itertools import count\n        >>> it = seekable((str(n) for n in count()), maxlen=2)\n        >>> next(it), next(it), next(it), next(it)\n        ('0', '1', '2', '3')\n        >>> list(it.elements())\n        ['2', '3']\n        >>> it.seek(0)\n        >>> next(it), next(it), next(it), next(it)\n        ('2', '3', '4', '5')\n        >>> next(it)\n        '6'\n\n    \"\"\"\n\n    def __init__(self, iterable, maxlen=None):\n        self._source = iter(iterable)\n        if maxlen is None:\n            self._cache = []\n        else:\n            self._cache = deque([], maxlen)\n        self._index = None\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self._index is not None:\n            try:\n                item = self._cache[self._index]\n            except IndexError:\n                self._index = None\n            else:\n                self._index += 1\n                return item\n\n        item = next(self._source)\n        self._cache.append(item)\n        return item\n\n    def __bool__(self):\n        try:\n            self.peek()\n        except StopIteration:\n            return False\n        return True\n\n    def peek(self, default=_marker):\n        try:\n            peeked = next(self)\n        except StopIteration:\n            if default is _marker:\n                raise\n            return default\n        if self._index is None:\n            self._index = len(self._cache)\n        self._index -= 1\n        return peeked\n\n    def elements(self):\n        return SequenceView(self._cache)\n\n    def seek(self, index):\n        self._index = index\n        remainder = index - len(self._cache)\n        if remainder > 0:\n            consume(self, remainder)\n\n    def relative_seek(self, count):\n        index = len(self._cache)\n        self.seek(max(index + count, 0))\n\n\nclass run_length:\n    \"\"\"\n    :func:`run_length.encode` compresses an iterable with run-length encoding.\n    It yields groups of repeated items with the count of how many times they\n    were repeated:\n\n        >>> uncompressed = 'abbcccdddd'\n        >>> list(run_length.encode(uncompressed))\n        [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n\n    :func:`run_length.decode` decompresses an iterable that was previously\n    compressed with run-length encoding. It yields the items of the\n    decompressed iterable:\n\n        >>> compressed = [('a', 1), ('b', 2), ('c', 3), ('d', 4)]\n        >>> list(run_length.decode(compressed))\n        ['a', 'b', 'b', 'c', 'c', 'c', 'd', 'd', 'd', 'd']\n\n    \"\"\"\n\n    @staticmethod\n    def encode(iterable):\n        return ((k, ilen(g)) for k, g in groupby(iterable))\n\n    @staticmethod\n    def decode(iterable):\n        return chain.from_iterable(starmap(repeat, iterable))\n\n\ndef exactly_n(iterable, n, predicate=bool):\n    \"\"\"Return ``True`` if exactly ``n`` items in the iterable are ``True``\n    according to the *predicate* function.\n\n        >>> exactly_n([True, True, False], 2)\n        True\n        >>> exactly_n([True, True, False], 1)\n        False\n        >>> exactly_n([0, 1, 2, 3, 4, 5], 3, lambda x: x < 3)\n        True\n\n    The iterable will be advanced until ``n + 1`` truthy items are encountered,\n    so avoid calling it on infinite iterables.\n\n    \"\"\"\n    return len(take(n + 1, filter(predicate, iterable))) == n\n\n\ndef circular_shifts(iterable):\n    \"\"\"Return a list of circular shifts of *iterable*.\n\n    >>> circular_shifts(range(4))\n    [(0, 1, 2, 3), (1, 2, 3, 0), (2, 3, 0, 1), (3, 0, 1, 2)]\n    \"\"\"\n    lst = list(iterable)\n    return take(len(lst), windowed(cycle(lst), len(lst)))\n\n\ndef make_decorator(wrapping_func, result_index=0):\n    \"\"\"Return a decorator version of *wrapping_func*, which is a function that\n    modifies an iterable. *result_index* is the position in that function's\n    signature where the iterable goes.\n\n    This lets you use itertools on the \"production end,\" i.e. at function\n    definition. This can augment what the function returns without changing the\n    function's code.\n\n    For example, to produce a decorator version of :func:`chunked`:\n\n        >>> from more_itertools import chunked\n        >>> chunker = make_decorator(chunked, result_index=0)\n        >>> @chunker(3)\n        ... def iter_range(n):\n        ...     return iter(range(n))\n        ...\n        >>> list(iter_range(9))\n        [[0, 1, 2], [3, 4, 5], [6, 7, 8]]\n\n    To only allow truthy items to be returned:\n\n        >>> truth_serum = make_decorator(filter, result_index=1)\n        >>> @truth_serum(bool)\n        ... def boolean_test():\n        ...     return [0, 1, '', ' ', False, True]\n        ...\n        >>> list(boolean_test())\n        [1, ' ', True]\n\n    The :func:`peekable` and :func:`seekable` wrappers make for practical\n    decorators:\n\n        >>> from more_itertools import peekable\n        >>> peekable_function = make_decorator(peekable)\n        >>> @peekable_function()\n        ... def str_range(*args):\n        ...     return (str(x) for x in range(*args))\n        ...\n        >>> it = str_range(1, 20, 2)\n        >>> next(it), next(it), next(it)\n        ('1', '3', '5')\n        >>> it.peek()\n        '7'\n        >>> next(it)\n        '7'\n\n    \"\"\"\n\n    # See https://sites.google.com/site/bbayles/index/decorator_factory for\n    # notes on how this works.\n    def decorator(*wrapping_args, **wrapping_kwargs):\n        def outer_wrapper(f):\n            def inner_wrapper(*args, **kwargs):\n                result = f(*args, **kwargs)\n                wrapping_args_ = list(wrapping_args)\n                wrapping_args_.insert(result_index, result)\n                return wrapping_func(*wrapping_args_, **wrapping_kwargs)\n\n            return inner_wrapper\n\n        return outer_wrapper\n\n    return decorator\n\n\ndef map_reduce(iterable, keyfunc, valuefunc=None, reducefunc=None):\n    \"\"\"Return a dictionary that maps the items in *iterable* to categories\n    defined by *keyfunc*, transforms them with *valuefunc*, and\n    then summarizes them by category with *reducefunc*.\n\n    *valuefunc* defaults to the identity function if it is unspecified.\n    If *reducefunc* is unspecified, no summarization takes place:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> result = map_reduce('abbccc', keyfunc)\n        >>> sorted(result.items())\n        [('A', ['a']), ('B', ['b', 'b']), ('C', ['c', 'c', 'c'])]\n\n    Specifying *valuefunc* transforms the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc)\n        >>> sorted(result.items())\n        [('A', [1]), ('B', [1, 1]), ('C', [1, 1, 1])]\n\n    Specifying *reducefunc* summarizes the categorized items:\n\n        >>> keyfunc = lambda x: x.upper()\n        >>> valuefunc = lambda x: 1\n        >>> reducefunc = sum\n        >>> result = map_reduce('abbccc', keyfunc, valuefunc, reducefunc)\n        >>> sorted(result.items())\n        [('A', 1), ('B', 2), ('C', 3)]\n\n    You may want to filter the input iterable before applying the map/reduce\n    procedure:\n\n        >>> all_items = range(30)\n        >>> items = [x for x in all_items if 10 <= x <= 20]  # Filter\n        >>> keyfunc = lambda x: x % 2  # Evens map to 0; odds to 1\n        >>> categories = map_reduce(items, keyfunc=keyfunc)\n        >>> sorted(categories.items())\n        [(0, [10, 12, 14, 16, 18, 20]), (1, [11, 13, 15, 17, 19])]\n        >>> summaries = map_reduce(items, keyfunc=keyfunc, reducefunc=sum)\n        >>> sorted(summaries.items())\n        [(0, 90), (1, 75)]\n\n    Note that all items in the iterable are gathered into a list before the\n    summarization step, which may require significant storage.\n\n    The returned object is a :obj:`collections.defaultdict` with the\n    ``default_factory`` set to ``None``, such that it behaves like a normal\n    dictionary.\n\n    \"\"\"\n    valuefunc = (lambda x: x) if (valuefunc is None) else valuefunc\n\n    ret = defaultdict(list)\n    for item in iterable:\n        key = keyfunc(item)\n        value = valuefunc(item)\n        ret[key].append(value)\n\n    if reducefunc is not None:\n        for key, value_list in ret.items():\n            ret[key] = reducefunc(value_list)\n\n    ret.default_factory = None\n    return ret\n\n\ndef rlocate(iterable, pred=bool, window_size=None):\n    \"\"\"Yield the index of each item in *iterable* for which *pred* returns\n    ``True``, starting from the right and moving left.\n\n    *pred* defaults to :func:`bool`, which will select truthy items:\n\n        >>> list(rlocate([0, 1, 1, 0, 1, 0, 0]))  # Truthy at 1, 2, and 4\n        [4, 2, 1]\n\n    Set *pred* to a custom function to, e.g., find the indexes for a particular\n    item:\n\n        >>> iterable = iter('abcb')\n        >>> pred = lambda x: x == 'b'\n        >>> list(rlocate(iterable, pred))\n        [3, 1]\n\n    If *window_size* is given, then the *pred* function will be called with\n    that many items. This enables searching for sub-sequences:\n\n        >>> iterable = [0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3]\n        >>> pred = lambda *args: args == (1, 2, 3)\n        >>> list(rlocate(iterable, pred=pred, window_size=3))\n        [9, 5, 1]\n\n    Beware, this function won't return anything for infinite iterables.\n    If *iterable* is reversible, ``rlocate`` will reverse it and search from\n    the right. Otherwise, it will search from the left and return the results\n    in reverse order.\n\n    See :func:`locate` to for other example applications.\n\n    \"\"\"\n    if window_size is None:\n        try:\n            len_iter = len(iterable)\n            return (len_iter - i - 1 for i in locate(reversed(iterable), pred))\n        except TypeError:\n            pass\n\n    return reversed(list(locate(iterable, pred, window_size)))\n\n\ndef replace(iterable, pred, substitutes, count=None, window_size=1):\n    \"\"\"Yield the items from *iterable*, replacing the items for which *pred*\n    returns ``True`` with the items from the iterable *substitutes*.\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = (2, 3)\n        >>> list(replace(iterable, pred, substitutes))\n        [1, 1, 2, 3, 1, 1, 2, 3, 1, 1]\n\n    If *count* is given, the number of replacements will be limited:\n\n        >>> iterable = [1, 1, 0, 1, 1, 0, 1, 1, 0]\n        >>> pred = lambda x: x == 0\n        >>> substitutes = [None]\n        >>> list(replace(iterable, pred, substitutes, count=2))\n        [1, 1, None, 1, 1, None, 1, 1, 0]\n\n    Use *window_size* to control the number of items passed as arguments to\n    *pred*. This allows for locating and replacing subsequences.\n\n        >>> iterable = [0, 1, 2, 5, 0, 1, 2, 5]\n        >>> window_size = 3\n        >>> pred = lambda *args: args == (0, 1, 2)  # 3 items passed to pred\n        >>> substitutes = [3, 4] # Splice in these items\n        >>> list(replace(iterable, pred, substitutes, window_size=window_size))\n        [3, 4, 5, 3, 4, 5]\n\n    \"\"\"\n    if window_size < 1:\n        raise ValueError('window_size must be at least 1')\n\n    # Save the substitutes iterable, since it's used more than once\n    substitutes = tuple(substitutes)\n\n    # Add padding such that the number of windows matches the length of the\n    # iterable\n    it = chain(iterable, [_marker] * (window_size - 1))\n    windows = windowed(it, window_size)\n\n    n = 0\n    for w in windows:\n        # If the current window matches our predicate (and we haven't hit\n        # our maximum number of replacements), splice in the substitutes\n        # and then consume the following windows that overlap with this one.\n        # For example, if the iterable is (0, 1, 2, 3, 4...)\n        # and the window size is 2, we have (0, 1), (1, 2), (2, 3)...\n        # If the predicate matches on (0, 1), we need to zap (0, 1) and (1, 2)\n        if pred(*w):\n            if (count is None) or (n < count):\n                n += 1\n                yield from substitutes\n                consume(windows, window_size - 1)\n                continue\n\n        # If there was no match (or we've reached the replacement limit),\n        # yield the first item from the window.\n        if w and (w[0] is not _marker):\n            yield w[0]\n\n\ndef partitions(iterable):\n    \"\"\"Yield all possible order-preserving partitions of *iterable*.\n\n    >>> iterable = 'abc'\n    >>> for part in partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['a', 'b', 'c']\n\n    This is unrelated to :func:`partition`.\n\n    \"\"\"\n    sequence = list(iterable)\n    n = len(sequence)\n    for i in powerset(range(1, n)):\n        yield [sequence[i:j] for i, j in zip((0,) + i, i + (n,))]\n\n\ndef set_partitions(iterable, k=None):\n    \"\"\"\n    Yield the set partitions of *iterable* into *k* parts. Set partitions are\n    not order-preserving.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable, 2):\n    ...     print([''.join(p) for p in part])\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n\n\n    If *k* is not given, every set partition is generated.\n\n    >>> iterable = 'abc'\n    >>> for part in set_partitions(iterable):\n    ...     print([''.join(p) for p in part])\n    ['abc']\n    ['a', 'bc']\n    ['ab', 'c']\n    ['b', 'ac']\n    ['a', 'b', 'c']\n\n    \"\"\"\n    L = list(iterable)\n    n = len(L)\n    if k is not None:\n        if k < 1:\n            raise ValueError(\n                \"Can't partition in a negative or zero number of groups\"\n            )\n        elif k > n:\n            return\n\n    def set_partitions_helper(L, k):\n        n = len(L)\n        if k == 1:\n            yield [L]\n        elif n == k:\n            yield [[s] for s in L]\n        else:\n            e, *M = L\n            for p in set_partitions_helper(M, k - 1):\n                yield [[e], *p]\n            for p in set_partitions_helper(M, k):\n                for i in range(len(p)):\n                    yield p[:i] + [[e] + p[i]] + p[i + 1 :]\n\n    if k is None:\n        for k in range(1, n + 1):\n            yield from set_partitions_helper(L, k)\n    else:\n        yield from set_partitions_helper(L, k)\n\n\nclass time_limited:\n    \"\"\"\n    Yield items from *iterable* until *limit_seconds* have passed.\n    If the time limit expires before all items have been yielded, the\n    ``timed_out`` parameter will be set to ``True``.\n\n    >>> from time import sleep\n    >>> def generator():\n    ...     yield 1\n    ...     yield 2\n    ...     sleep(0.2)\n    ...     yield 3\n    >>> iterable = time_limited(0.1, generator())\n    >>> list(iterable)\n    [1, 2]\n    >>> iterable.timed_out\n    True\n\n    Note that the time is checked before each item is yielded, and iteration\n    stops if  the time elapsed is greater than *limit_seconds*. If your time\n    limit is 1 second, but it takes 2 seconds to generate the first item from\n    the iterable, the function will run for 2 seconds and not yield anything.\n    As a special case, when *limit_seconds* is zero, the iterator never\n    returns anything.\n\n    \"\"\"\n\n    def __init__(self, limit_seconds, iterable):\n        if limit_seconds < 0:\n            raise ValueError('limit_seconds must be positive')\n        self.limit_seconds = limit_seconds\n        self._iterable = iter(iterable)\n        self._start_time = monotonic()\n        self.timed_out = False\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if self.limit_seconds == 0:\n            self.timed_out = True\n            raise StopIteration\n        item = next(self._iterable)\n        if monotonic() - self._start_time > self.limit_seconds:\n            self.timed_out = True\n            raise StopIteration\n\n        return item\n\n\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n\n\ndef _ichunk(iterable, n):\n    cache = deque()\n    chunk = islice(iterable, n)\n\n    def generator():\n        while True:\n            if cache:\n                yield cache.popleft()\n            else:\n                try:\n                    item = next(chunk)\n                except StopIteration:\n                    return\n                else:\n                    yield item\n\n    def materialize_next(n=1):\n        # if n not specified materialize everything\n        if n is None:\n            cache.extend(chunk)\n            return len(cache)\n\n        to_cache = n - len(cache)\n\n        # materialize up to n\n        if to_cache > 0:\n            cache.extend(islice(chunk, to_cache))\n\n        # return number materialized up to n\n        return min(n, len(cache))\n\n    return (generator(), materialize_next)\n\n\ndef ichunked(iterable, n):\n    \"\"\"Break *iterable* into sub-iterables with *n* elements each.\n    :func:`ichunked` is like :func:`chunked`, but it yields iterables\n    instead of lists.\n\n    If the sub-iterables are read in order, the elements of *iterable*\n    won't be stored in memory.\n    If they are read out of order, :func:`itertools.tee` is used to cache\n    elements as necessary.\n\n    >>> from itertools import count\n    >>> all_chunks = ichunked(count(), 4)\n    >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)\n    >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been\n    [4, 5, 6, 7]\n    >>> list(c_1)\n    [0, 1, 2, 3]\n    >>> list(c_3)\n    [8, 9, 10, 11]\n\n    \"\"\"\n    iterable = iter(iterable)\n    while True:\n        # Create new chunk\n        chunk, materialize_next = _ichunk(iterable, n)\n\n        # Check to see whether we're at the end of the source iterable\n        if not materialize_next():\n            return\n\n        yield chunk\n\n        # Fill previous chunk's cache\n        materialize_next(None)\n\n\ndef iequals(*iterables):\n    \"\"\"Return ``True`` if all given *iterables* are equal to each other,\n    which means that they contain the same elements in the same order.\n\n    The function is useful for comparing iterables of different data types\n    or iterables that do not support equality checks.\n\n    >>> iequals(\"abc\", ['a', 'b', 'c'], ('a', 'b', 'c'), iter(\"abc\"))\n    True\n\n    >>> iequals(\"abc\", \"acb\")\n    False\n\n    Not to be confused with :func:`all_equal`, which checks whether all\n    elements of iterable are equal to each other.\n\n    \"\"\"\n    return all(map(all_equal, zip_longest(*iterables, fillvalue=object())))\n\n\ndef distinct_combinations(iterable, r):\n    \"\"\"Yield the distinct combinations of *r* items taken from *iterable*.\n\n        >>> list(distinct_combinations([0, 0, 1], 2))\n        [(0, 0), (0, 1)]\n\n    Equivalent to ``set(combinations(iterable))``, except duplicates are not\n    generated and thrown away. For larger input sequences this is much more\n    efficient.\n\n    \"\"\"\n    if r < 0:\n        raise ValueError('r must be non-negative')\n    elif r == 0:\n        yield ()\n        return\n    pool = tuple(iterable)\n    generators = [unique_everseen(enumerate(pool), key=itemgetter(1))]\n    current_combo = [None] * r\n    level = 0\n    while generators:\n        try:\n            cur_idx, p = next(generators[-1])\n        except StopIteration:\n            generators.pop()\n            level -= 1\n            continue\n        current_combo[level] = p\n        if level + 1 == r:\n            yield tuple(current_combo)\n        else:\n            generators.append(\n                unique_everseen(\n                    enumerate(pool[cur_idx + 1 :], cur_idx + 1),\n                    key=itemgetter(1),\n                )\n            )\n            level += 1\n\n\ndef filter_except(validator, iterable, *exceptions):\n    \"\"\"Yield the items from *iterable* for which the *validator* function does\n    not raise one of the specified *exceptions*.\n\n    *validator* is called for each item in *iterable*.\n    It should be a function that accepts one argument and raises an exception\n    if that item is not valid.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(filter_except(int, iterable, ValueError, TypeError))\n    ['1', '2', '4']\n\n    If an exception other than one given by *exceptions* is raised by\n    *validator*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            validator(item)\n        except exceptions:\n            pass\n        else:\n            yield item\n\n\ndef map_except(function, iterable, *exceptions):\n    \"\"\"Transform each item from *iterable* with *function* and yield the\n    result, unless *function* raises one of the specified *exceptions*.\n\n    *function* is called to transform each item in *iterable*.\n    It should accept one argument.\n\n    >>> iterable = ['1', '2', 'three', '4', None]\n    >>> list(map_except(int, iterable, ValueError, TypeError))\n    [1, 2, 4]\n\n    If an exception other than one given by *exceptions* is raised by\n    *function*, it is raised like normal.\n    \"\"\"\n    for item in iterable:\n        try:\n            yield function(item)\n        except exceptions:\n            pass\n\n\ndef map_if(iterable, pred, func, func_else=lambda x: x):\n    \"\"\"Evaluate each item from *iterable* using *pred*. If the result is\n    equivalent to ``True``, transform the item with *func* and yield it.\n    Otherwise, transform the item with *func_else* and yield it.\n\n    *pred*, *func*, and *func_else* should each be functions that accept\n    one argument. By default, *func_else* is the identity function.\n\n    >>> from math import sqrt\n    >>> iterable = list(range(-5, 5))\n    >>> iterable\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]\n    >>> list(map_if(iterable, lambda x: x > 3, lambda x: 'toobig'))\n    [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']\n    >>> list(map_if(iterable, lambda x: x >= 0,\n    ... lambda x: f'{sqrt(x):.2f}', lambda x: None))\n    [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']\n    \"\"\"\n    for item in iterable:\n        yield func(item) if pred(item) else func_else(item)\n\n\ndef _sample_unweighted(iterator, k, strict):\n    # Implementation of \"Algorithm L\" from the 1994 paper by Kim-Hung Li:\n    # \"Reservoir-Sampling Algorithms of Time Complexity O(n(1+log(N/n)))\".\n\n    # Fill up the reservoir (collection of samples) with the first `k` samples\n    reservoir = take(k, iterator)\n    if strict and len(reservoir) < k:\n        raise ValueError('Sample larger than population')\n\n    # Generate random number that's the largest in a sample of k U(0,1) numbers\n    # Largest order statistic: https://en.wikipedia.org/wiki/Order_statistic\n    W = exp(log(random()) / k)\n\n    # The number of elements to skip before changing the reservoir is a random\n    # number with a geometric distribution. Sample it using random() and logs.\n    next_index = k + floor(log(random()) / log(1 - W))\n\n    for index, element in enumerate(iterator, k):\n        if index == next_index:\n            reservoir[randrange(k)] = element\n            # The new W is the largest in a sample of k U(0, `old_W`) numbers\n            W *= exp(log(random()) / k)\n            next_index += floor(log(random()) / log(1 - W)) + 1\n\n    shuffle(reservoir)\n    return reservoir\n\n\ndef _sample_weighted(iterator, k, weights, strict):\n    # Implementation of \"A-ExpJ\" from the 2006 paper by Efraimidis et al. :\n    # \"Weighted random sampling with a reservoir\".\n\n    # Log-transform for numerical stability for weights that are small/large\n    weight_keys = (log(random()) / weight for weight in weights)\n\n    # Fill up the reservoir (collection of samples) with the first `k`\n    # weight-keys and elements, then heapify the list.\n    reservoir = take(k, zip(weight_keys, iterator))\n    if strict and len(reservoir) < k:\n        raise ValueError('Sample larger than population')\n\n    heapify(reservoir)\n\n    # The number of jumps before changing the reservoir is a random variable\n    # with an exponential distribution. Sample it using random() and logs.\n    smallest_weight_key, _ = reservoir[0]\n    weights_to_skip = log(random()) / smallest_weight_key\n\n    for weight, element in zip(weights, iterator):\n        if weight >= weights_to_skip:\n            # The notation here is consistent with the paper, but we store\n            # the weight-keys in log-space for better numerical stability.\n            smallest_weight_key, _ = reservoir[0]\n            t_w = exp(weight * smallest_weight_key)\n            r_2 = uniform(t_w, 1)  # generate U(t_w, 1)\n            weight_key = log(r_2) / weight\n            heapreplace(reservoir, (weight_key, element))\n            smallest_weight_key, _ = reservoir[0]\n            weights_to_skip = log(random()) / smallest_weight_key\n        else:\n            weights_to_skip -= weight\n\n    ret = [element for weight_key, element in reservoir]\n    shuffle(ret)\n    return ret\n\n\ndef sample(iterable, k, weights=None, strict=False):\n    \"\"\"Return a *k*-length list of elements chosen (without replacement)\n    from the *iterable*. Similar to :func:`random.sample`, but works on\n    iterables of unknown length.\n\n    >>> iterable = range(100)\n    >>> sample(iterable, 5)  # doctest: +SKIP\n    [81, 60, 96, 16, 4]\n\n    An iterable with *weights* may also be given:\n\n    >>> iterable = range(100)\n    >>> weights = (i * i + 1 for i in range(100))\n    >>> sampled = sample(iterable, 5, weights=weights)  # doctest: +SKIP\n    [79, 67, 74, 66, 78]\n\n    Weighted selections are made without replacement.\n    After an element is selected, it is removed from the pool and the\n    relative weights of the other elements increase (this\n    does not match the behavior of :func:`random.sample`'s *counts*\n    parameter).\n\n    If the length of *iterable* is less than *k*,\n    ``ValueError`` is raised if *strict* is ``True`` and\n    all elements are returned (in shuffled order) if *strict* is ``False``.\n\n    By default, the `Algorithm L <https://w.wiki/ANrM>`__ reservoir sampling\n    technique is used. When *weights* are provided,\n    `Algorithm A-ExpJ <https://w.wiki/ANrS>`__ is used.\n    \"\"\"\n    if k < 0:\n        raise ValueError('k must be non-negative')\n    if k == 0:\n        return []\n\n    iterator = iter(iterable)\n    if weights is None:\n        return _sample_unweighted(iterator, k, strict)\n    else:\n        weights = iter(weights)\n        return _sample_weighted(iterator, k, weights, strict)\n\n\ndef is_sorted(iterable, key=None, reverse=False, strict=False):\n    \"\"\"Returns ``True`` if the items of iterable are in sorted order, and\n    ``False`` otherwise. *key* and *reverse* have the same meaning that they do\n    in the built-in :func:`sorted` function.\n\n    >>> is_sorted(['1', '2', '3', '4', '5'], key=int)\n    True\n    >>> is_sorted([5, 4, 3, 1, 2], reverse=True)\n    False\n\n    If *strict*, tests for strict sorting, that is, returns ``False`` if equal\n    elements are found:\n\n    >>> is_sorted([1, 2, 2])\n    True\n    >>> is_sorted([1, 2, 2], strict=True)\n    False\n\n    The function returns ``False`` after encountering the first out-of-order\n    item. If there are no out-of-order items, the iterable is exhausted.\n    \"\"\"\n\n    compare = (le if reverse else ge) if strict else (lt if reverse else gt)\n    it = iterable if key is None else map(key, iterable)\n    return not any(starmap(compare, pairwise(it)))\n\n\nclass AbortThread(BaseException):\n    pass\n\n\nclass callback_iter:\n    \"\"\"Convert a function that uses callbacks to an iterator.\n\n    Let *func* be a function that takes a `callback` keyword argument.\n    For example:\n\n    >>> def func(callback=None):\n    ...     for i, c in [(1, 'a'), (2, 'b'), (3, 'c')]:\n    ...         if callback:\n    ...             callback(i, c)\n    ...     return 4\n\n\n    Use ``with callback_iter(func)`` to get an iterator over the parameters\n    that are delivered to the callback.\n\n    >>> with callback_iter(func) as it:\n    ...     for args, kwargs in it:\n    ...         print(args)\n    (1, 'a')\n    (2, 'b')\n    (3, 'c')\n\n    The function will be called in a background thread. The ``done`` property\n    indicates whether it has completed execution.\n\n    >>> it.done\n    True\n\n    If it completes successfully, its return value will be available\n    in the ``result`` property.\n\n    >>> it.result\n    4\n\n    Notes:\n\n    * If the function uses some keyword argument besides ``callback``, supply\n      *callback_kwd*.\n    * If it finished executing, but raised an exception, accessing the\n      ``result`` property will raise the same exception.\n    * If it hasn't finished executing, accessing the ``result``\n      property from within the ``with`` block will raise ``RuntimeError``.\n    * If it hasn't finished executing, accessing the ``result`` property from\n      outside the ``with`` block will raise a\n      ``more_itertools.AbortThread`` exception.\n    * Provide *wait_seconds* to adjust how frequently the it is polled for\n      output.\n\n    \"\"\"\n\n    def __init__(self, func, callback_kwd='callback', wait_seconds=0.1):\n        self._func = func\n        self._callback_kwd = callback_kwd\n        self._aborted = False\n        self._future = None\n        self._wait_seconds = wait_seconds\n        # Lazily import concurrent.future\n        self._executor = __import__(\n            'concurrent.futures'\n        ).futures.ThreadPoolExecutor(max_workers=1)\n        self._iterator = self._reader()\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        self._aborted = True\n        self._executor.shutdown()\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        return next(self._iterator)\n\n    @property\n    def done(self):\n        if self._future is None:\n            return False\n        return self._future.done()\n\n    @property\n    def result(self):\n        if not self.done:\n            raise RuntimeError('Function has not yet completed')\n\n        return self._future.result()\n\n    def _reader(self):\n        q = Queue()\n\n        def callback(*args, **kwargs):\n            if self._aborted:\n                raise AbortThread('canceled by user')\n\n            q.put((args, kwargs))\n\n        self._future = self._executor.submit(\n            self._func, **{self._callback_kwd: callback}\n        )\n\n        while True:\n            try:\n                item = q.get(timeout=self._wait_seconds)\n            except Empty:\n                pass\n            else:\n                q.task_done()\n                yield item\n\n            if self._future.done():\n                break\n\n        remaining = []\n        while True:\n            try:\n                item = q.get_nowait()\n            except Empty:\n                break\n            else:\n                q.task_done()\n                remaining.append(item)\n        q.join()\n        yield from remaining\n\n\ndef windowed_complete(iterable, n):\n    \"\"\"\n    Yield ``(beginning, middle, end)`` tuples, where:\n\n    * Each ``middle`` has *n* items from *iterable*\n    * Each ``beginning`` has the items before the ones in ``middle``\n    * Each ``end`` has the items after the ones in ``middle``\n\n    >>> iterable = range(7)\n    >>> n = 3\n    >>> for beginning, middle, end in windowed_complete(iterable, n):\n    ...     print(beginning, middle, end)\n    () (0, 1, 2) (3, 4, 5, 6)\n    (0,) (1, 2, 3) (4, 5, 6)\n    (0, 1) (2, 3, 4) (5, 6)\n    (0, 1, 2) (3, 4, 5) (6,)\n    (0, 1, 2, 3) (4, 5, 6) ()\n\n    Note that *n* must be at least 0 and most equal to the length of\n    *iterable*.\n\n    This function will exhaust the iterable and may require significant\n    storage.\n    \"\"\"\n    if n < 0:\n        raise ValueError('n must be >= 0')\n\n    seq = tuple(iterable)\n    size = len(seq)\n\n    if n > size:\n        raise ValueError('n must be <= len(seq)')\n\n    for i in range(size - n + 1):\n        beginning = seq[:i]\n        middle = seq[i : i + n]\n        end = seq[i + n :]\n        yield beginning, middle, end\n\n\ndef all_unique(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements of *iterable* are unique (no two\n    elements are equal).\n\n        >>> all_unique('ABCB')\n        False\n\n    If a *key* function is specified, it will be used to make comparisons.\n\n        >>> all_unique('ABCb')\n        True\n        >>> all_unique('ABCb', str.lower)\n        False\n\n    The function returns as soon as the first non-unique element is\n    encountered. Iterables with a mix of hashable and unhashable items can\n    be used, but the function will be slower for unhashable items.\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    for element in map(key, iterable) if key else iterable:\n        try:\n            if element in seenset:\n                return False\n            seenset_add(element)\n        except TypeError:\n            if element in seenlist:\n                return False\n            seenlist_add(element)\n    return True\n\n\ndef nth_product(index, *args):\n    \"\"\"Equivalent to ``list(product(*args))[index]``.\n\n    The products of *args* can be ordered lexicographically.\n    :func:`nth_product` computes the product at sort position *index* without\n    computing the previous products.\n\n        >>> nth_product(8, range(2), range(2), range(2), range(2))\n        (1, 0, 0, 0)\n\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pools = list(map(tuple, reversed(args)))\n    ns = list(map(len, pools))\n\n    c = reduce(mul, ns)\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = []\n    for pool, n in zip(pools, ns):\n        result.append(pool[index % n])\n        index //= n\n\n    return tuple(reversed(result))\n\n\ndef nth_permutation(iterable, r, index):\n    \"\"\"Equivalent to ``list(permutations(iterable, r))[index]```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`nth_permutation`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences.\n\n        >>> nth_permutation('ghijk', 2, 5)\n        ('h', 'i')\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = list(iterable)\n    n = len(pool)\n\n    if r is None or r == n:\n        r, c = n, factorial(n)\n    elif not 0 <= r < n:\n        raise ValueError\n    else:\n        c = perm(n, r)\n    assert c > 0  # factortial(n)>0, and r<n so perm(n,r) is never zero\n\n    if index < 0:\n        index += c\n\n    if not 0 <= index < c:\n        raise IndexError\n\n    result = [0] * r\n    q = index * factorial(n) // c if r < n else index\n    for d in range(1, n + 1):\n        q, i = divmod(q, d)\n        if 0 <= n - d < r:\n            result[n - d] = i\n        if q == 0:\n            break\n\n    return tuple(map(pool.pop, result))\n\n\ndef nth_combination_with_replacement(iterable, r, index):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r))[index]``.\n\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`nth_combination_with_replacement`\n    computes the subsequence at sort position *index* directly, without\n    computing the previous subsequences with replacement.\n\n        >>> nth_combination_with_replacement(range(5), 3, 5)\n        (0, 1, 1)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = comb(n + r - 1, r)\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    i = 0\n    while r:\n        r -= 1\n        while n >= 0:\n            num_combs = comb(n + r - 1, r)\n            if index < num_combs:\n                break\n            n -= 1\n            i += 1\n            index -= num_combs\n        result.append(pool[i])\n\n    return tuple(result)\n\n\ndef value_chain(*args):\n    \"\"\"Yield all arguments passed to the function in the same order in which\n    they were passed. If an argument itself is iterable then iterate over its\n    values.\n\n        >>> list(value_chain(1, 2, 3, [4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n\n    Binary and text strings are not considered iterable and are emitted\n    as-is:\n\n        >>> list(value_chain('12', '34', ['56', '78']))\n        ['12', '34', '56', '78']\n\n    Pre- or postpend a single element to an iterable:\n\n        >>> list(value_chain(1, [2, 3, 4, 5, 6]))\n        [1, 2, 3, 4, 5, 6]\n        >>> list(value_chain([1, 2, 3, 4, 5], 6))\n        [1, 2, 3, 4, 5, 6]\n\n    Multiple levels of nesting are not flattened.\n\n    \"\"\"\n    for value in args:\n        if isinstance(value, (str, bytes)):\n            yield value\n            continue\n        try:\n            yield from value\n        except TypeError:\n            yield value\n\n\ndef product_index(element, *args):\n    \"\"\"Equivalent to ``list(product(*args)).index(element)``\n\n    The products of *args* can be ordered lexicographically.\n    :func:`product_index` computes the first index of *element* without\n    computing the previous products.\n\n        >>> product_index([8, 2], range(10), range(5))\n        42\n\n    ``ValueError`` will be raised if the given *element* isn't in the product\n    of *args*.\n    \"\"\"\n    index = 0\n\n    for x, pool in zip_longest(element, args, fillvalue=_marker):\n        if x is _marker or pool is _marker:\n            raise ValueError('element is not a product of args')\n\n        pool = tuple(pool)\n        index = index * len(pool) + pool.index(x)\n\n    return index\n\n\ndef combination_index(element, iterable):\n    \"\"\"Equivalent to ``list(combinations(iterable, r)).index(element)``\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`combination_index` computes the index of the\n    first *element*, without computing the previous combinations.\n\n        >>> combination_index('adf', 'abcdefg')\n        10\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations of *iterable*.\n    \"\"\"\n    element = enumerate(element)\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = enumerate(iterable)\n    for n, x in pool:\n        if x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n    else:\n        raise ValueError('element is not a combination of iterable')\n\n    n, _ = last(pool, default=(n, None))\n\n    # Python versions below 3.8 don't have math.comb\n    index = 1\n    for i, j in enumerate(reversed(indexes), start=1):\n        j = n - j\n        if i <= j:\n            index += comb(j, i)\n\n    return comb(n + 1, k + 1) - index\n\n\ndef combination_with_replacement_index(element, iterable):\n    \"\"\"Equivalent to\n    ``list(combinations_with_replacement(iterable, r)).index(element)``\n\n    The subsequences with repetition of *iterable* that are of length *r* can\n    be ordered lexicographically. :func:`combination_with_replacement_index`\n    computes the index of the first *element*, without computing the previous\n    combinations with replacement.\n\n        >>> combination_with_replacement_index('adf', 'abcdefg')\n        20\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    combinations with replacement of *iterable*.\n    \"\"\"\n    element = tuple(element)\n    l = len(element)\n    element = enumerate(element)\n\n    k, y = next(element, (None, None))\n    if k is None:\n        return 0\n\n    indexes = []\n    pool = tuple(iterable)\n    for n, x in enumerate(pool):\n        while x == y:\n            indexes.append(n)\n            tmp, y = next(element, (None, None))\n            if tmp is None:\n                break\n            else:\n                k = tmp\n        if y is None:\n            break\n    else:\n        raise ValueError(\n            'element is not a combination with replacement of iterable'\n        )\n\n    n = len(pool)\n    occupations = [0] * n\n    for p in indexes:\n        occupations[p] += 1\n\n    index = 0\n    cumulative_sum = 0\n    for k in range(1, n):\n        cumulative_sum += occupations[k - 1]\n        j = l + n - 1 - k - cumulative_sum\n        i = n - k\n        if i <= j:\n            index += comb(j, i)\n\n    return index\n\n\ndef permutation_index(element, iterable):\n    \"\"\"Equivalent to ``list(permutations(iterable, r)).index(element)```\n\n    The subsequences of *iterable* that are of length *r* where order is\n    important can be ordered lexicographically. :func:`permutation_index`\n    computes the index of the first *element* directly, without computing\n    the previous permutations.\n\n        >>> permutation_index([1, 3, 2], range(5))\n        19\n\n    ``ValueError`` will be raised if the given *element* isn't one of the\n    permutations of *iterable*.\n    \"\"\"\n    index = 0\n    pool = list(iterable)\n    for i, x in zip(range(len(pool), -1, -1), element):\n        r = pool.index(x)\n        index = index * i + r\n        del pool[r]\n\n    return index\n\n\nclass countable:\n    \"\"\"Wrap *iterable* and keep a count of how many items have been consumed.\n\n    The ``items_seen`` attribute starts at ``0`` and increments as the iterable\n    is consumed:\n\n        >>> iterable = map(str, range(10))\n        >>> it = countable(iterable)\n        >>> it.items_seen\n        0\n        >>> next(it), next(it)\n        ('0', '1')\n        >>> list(it)\n        ['2', '3', '4', '5', '6', '7', '8', '9']\n        >>> it.items_seen\n        10\n    \"\"\"\n\n    def __init__(self, iterable):\n        self._it = iter(iterable)\n        self.items_seen = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        item = next(self._it)\n        self.items_seen += 1\n\n        return item\n\n\ndef chunked_even(iterable, n):\n    \"\"\"Break *iterable* into lists of approximately length *n*.\n    Items are distributed such the lengths of the lists differ by at most\n    1 item.\n\n    >>> iterable = [1, 2, 3, 4, 5, 6, 7]\n    >>> n = 3\n    >>> list(chunked_even(iterable, n))  # List lengths: 3, 2, 2\n    [[1, 2, 3], [4, 5], [6, 7]]\n    >>> list(chunked(iterable, n))  # List lengths: 3, 3, 1\n    [[1, 2, 3], [4, 5, 6], [7]]\n\n    \"\"\"\n    iterable = iter(iterable)\n\n    # Initialize a buffer to process the chunks while keeping\n    # some back to fill any underfilled chunks\n    min_buffer = (n - 1) * (n - 2)\n    buffer = list(islice(iterable, min_buffer))\n\n    # Append items until we have a completed chunk\n    for _ in islice(map(buffer.append, iterable), n, None, n):\n        yield buffer[:n]\n        del buffer[:n]\n\n    # Check if any chunks need addition processing\n    if not buffer:\n        return\n    length = len(buffer)\n\n    # Chunks are either size `full_size <= n` or `partial_size = full_size - 1`\n    q, r = divmod(length, n)\n    num_lists = q + (1 if r > 0 else 0)\n    q, r = divmod(length, num_lists)\n    full_size = q + (1 if r > 0 else 0)\n    partial_size = full_size - 1\n    num_full = length - partial_size * num_lists\n\n    # Yield chunks of full size\n    partial_start_idx = num_full * full_size\n    if full_size > 0:\n        for i in range(0, partial_start_idx, full_size):\n            yield buffer[i : i + full_size]\n\n    # Yield chunks of partial size\n    if partial_size > 0:\n        for i in range(partial_start_idx, length, partial_size):\n            yield buffer[i : i + partial_size]\n\n\ndef zip_broadcast(*objects, scalar_types=(str, bytes), strict=False):\n    \"\"\"A version of :func:`zip` that \"broadcasts\" any scalar\n    (i.e., non-iterable) items into output tuples.\n\n    >>> iterable_1 = [1, 2, 3]\n    >>> iterable_2 = ['a', 'b', 'c']\n    >>> scalar = '_'\n    >>> list(zip_broadcast(iterable_1, iterable_2, scalar))\n    [(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]\n\n    The *scalar_types* keyword argument determines what types are considered\n    scalar. It is set to ``(str, bytes)`` by default. Set it to ``None`` to\n    treat strings and byte strings as iterable:\n\n    >>> list(zip_broadcast('abc', 0, 'xyz', scalar_types=None))\n    [('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]\n\n    If the *strict* keyword argument is ``True``, then\n    ``UnequalIterablesError`` will be raised if any of the iterables have\n    different lengths.\n    \"\"\"\n\n    def is_scalar(obj):\n        if scalar_types and isinstance(obj, scalar_types):\n            return True\n        try:\n            iter(obj)\n        except TypeError:\n            return True\n        else:\n            return False\n\n    size = len(objects)\n    if not size:\n        return\n\n    new_item = [None] * size\n    iterables, iterable_positions = [], []\n    for i, obj in enumerate(objects):\n        if is_scalar(obj):\n            new_item[i] = obj\n        else:\n            iterables.append(iter(obj))\n            iterable_positions.append(i)\n\n    if not iterables:\n        yield tuple(objects)\n        return\n\n    zipper = _zip_equal if strict else zip\n    for item in zipper(*iterables):\n        for i, new_item[i] in zip(iterable_positions, item):\n            pass\n        yield tuple(new_item)\n\n\ndef unique_in_window(iterable, n, key=None):\n    \"\"\"Yield the items from *iterable* that haven't been seen recently.\n    *n* is the size of the lookback window.\n\n        >>> iterable = [0, 1, 0, 2, 3, 0]\n        >>> n = 3\n        >>> list(unique_in_window(iterable, n))\n        [0, 1, 2, 3, 0]\n\n    The *key* function, if provided, will be used to determine uniqueness:\n\n        >>> list(unique_in_window('abAcda', 3, key=lambda x: x.lower()))\n        ['a', 'b', 'c', 'd', 'a']\n\n    The items in *iterable* must be hashable.\n\n    \"\"\"\n    if n <= 0:\n        raise ValueError('n must be greater than 0')\n\n    window = deque(maxlen=n)\n    counts = defaultdict(int)\n    use_key = key is not None\n\n    for item in iterable:\n        if len(window) == n:\n            to_discard = window[0]\n            if counts[to_discard] == 1:\n                del counts[to_discard]\n            else:\n                counts[to_discard] -= 1\n\n        k = key(item) if use_key else item\n        if k not in counts:\n            yield item\n        counts[k] += 1\n        window.append(k)\n\n\ndef duplicates_everseen(iterable, key=None):\n    \"\"\"Yield duplicate elements after their first appearance.\n\n    >>> list(duplicates_everseen('mississippi'))\n    ['s', 'i', 's', 's', 'i', 'p', 'i']\n    >>> list(duplicates_everseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'A', 'a', 'a']\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n            else:\n                yield element\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n            else:\n                yield element\n\n\ndef duplicates_justseen(iterable, key=None):\n    \"\"\"Yields serially-duplicate elements after their first appearance.\n\n    >>> list(duplicates_justseen('mississippi'))\n    ['s', 's', 'p']\n    >>> list(duplicates_justseen('AaaBbbCccAaa', str.lower))\n    ['a', 'a', 'b', 'b', 'c', 'c', 'a', 'a']\n\n    This function is analogous to :func:`unique_justseen`.\n\n    \"\"\"\n    return flatten(g for _, g in groupby(iterable, key) for _ in g)\n\n\ndef classify_unique(iterable, key=None):\n    \"\"\"Classify each element in terms of its uniqueness.\n\n    For each element in the input iterable, return a 3-tuple consisting of:\n\n    1. The element itself\n    2. ``False`` if the element is equal to the one preceding it in the input,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_justseen`)\n    3. ``False`` if this element has been seen anywhere in the input before,\n       ``True`` otherwise (i.e. the equivalent of :func:`unique_everseen`)\n\n    >>> list(classify_unique('otto'))    # doctest: +NORMALIZE_WHITESPACE\n    [('o', True,  True),\n     ('t', True,  True),\n     ('t', False, False),\n     ('o', True,  False)]\n\n    This function is analogous to :func:`unique_everseen` and is subject to\n    the same performance considerations.\n\n    \"\"\"\n    seen_set = set()\n    seen_list = []\n    use_key = key is not None\n    previous = None\n\n    for i, element in enumerate(iterable):\n        k = key(element) if use_key else element\n        is_unique_justseen = not i or previous != k\n        previous = k\n        is_unique_everseen = False\n        try:\n            if k not in seen_set:\n                seen_set.add(k)\n                is_unique_everseen = True\n        except TypeError:\n            if k not in seen_list:\n                seen_list.append(k)\n                is_unique_everseen = True\n        yield element, is_unique_justseen, is_unique_everseen\n\n\ndef minmax(iterable_or_value, *others, key=None, default=_marker):\n    \"\"\"Returns both the smallest and largest items in an iterable\n    or the largest of two or more arguments.\n\n        >>> minmax([3, 1, 5])\n        (1, 5)\n\n        >>> minmax(4, 2, 6)\n        (2, 6)\n\n    If a *key* function is provided, it will be used to transform the input\n    items for comparison.\n\n        >>> minmax([5, 30], key=str)  # '30' sorts before '5'\n        (30, 5)\n\n    If a *default* value is provided, it will be returned if there are no\n    input items.\n\n        >>> minmax([], default=(0, 0))\n        (0, 0)\n\n    Otherwise ``ValueError`` is raised.\n\n    This function is based on the\n    `recipe <http://code.activestate.com/recipes/577916/>`__ by\n    Raymond Hettinger and takes care to minimize the number of comparisons\n    performed.\n    \"\"\"\n    iterable = (iterable_or_value, *others) if others else iterable_or_value\n\n    it = iter(iterable)\n\n    try:\n        lo = hi = next(it)\n    except StopIteration as exc:\n        if default is _marker:\n            raise ValueError(\n                '`minmax()` argument is an empty iterable. '\n                'Provide a `default` value to suppress this error.'\n            ) from exc\n        return default\n\n    # Different branches depending on the presence of key. This saves a lot\n    # of unimportant copies which would slow the \"key=None\" branch\n    # significantly down.\n    if key is None:\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            if y < x:\n                x, y = y, x\n            if x < lo:\n                lo = x\n            if hi < y:\n                hi = y\n\n    else:\n        lo_key = hi_key = key(lo)\n\n        for x, y in zip_longest(it, it, fillvalue=lo):\n            x_key, y_key = key(x), key(y)\n\n            if y_key < x_key:\n                x, y, x_key, y_key = y, x, y_key, x_key\n            if x_key < lo_key:\n                lo, lo_key = x, x_key\n            if hi_key < y_key:\n                hi, hi_key = y, y_key\n\n    return lo, hi\n\n\ndef constrained_batches(\n    iterable, max_size, max_count=None, get_len=len, strict=True\n):\n    \"\"\"Yield batches of items from *iterable* with a combined size limited by\n    *max_size*.\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10))\n    [(b'12345', b'123'), (b'12345678', b'1', b'1'), (b'12', b'1')]\n\n    If a *max_count* is supplied, the number of items per batch is also\n    limited:\n\n    >>> iterable = [b'12345', b'123', b'12345678', b'1', b'1', b'12', b'1']\n    >>> list(constrained_batches(iterable, 10, max_count = 2))\n    [(b'12345', b'123'), (b'12345678', b'1'), (b'1', b'12'), (b'1',)]\n\n    If a *get_len* function is supplied, use that instead of :func:`len` to\n    determine item size.\n\n    If *strict* is ``True``, raise ``ValueError`` if any single item is bigger\n    than *max_size*. Otherwise, allow single items to exceed *max_size*.\n    \"\"\"\n    if max_size <= 0:\n        raise ValueError('maximum size must be greater than zero')\n\n    batch = []\n    batch_size = 0\n    batch_count = 0\n    for item in iterable:\n        item_len = get_len(item)\n        if strict and item_len > max_size:\n            raise ValueError('item size exceeds maximum size')\n\n        reached_count = batch_count == max_count\n        reached_size = item_len + batch_size > max_size\n        if batch_count and (reached_size or reached_count):\n            yield tuple(batch)\n            batch.clear()\n            batch_size = 0\n            batch_count = 0\n\n        batch.append(item)\n        batch_size += item_len\n        batch_count += 1\n\n    if batch:\n        yield tuple(batch)\n\n\ndef gray_product(*iterables):\n    \"\"\"Like :func:`itertools.product`, but return tuples in an order such\n    that only one element in the generated tuple changes from one iteration\n    to the next.\n\n        >>> list(gray_product('AB','CD'))\n        [('A', 'C'), ('B', 'C'), ('B', 'D'), ('A', 'D')]\n\n    This function consumes all of the input iterables before producing output.\n    If any of the input iterables have fewer than two items, ``ValueError``\n    is raised.\n\n    For information on the algorithm, see\n    `this section <https://www-cs-faculty.stanford.edu/~knuth/fasc2a.ps.gz>`__\n    of Donald Knuth's *The Art of Computer Programming*.\n    \"\"\"\n    all_iterables = tuple(tuple(x) for x in iterables)\n    iterable_count = len(all_iterables)\n    for iterable in all_iterables:\n        if len(iterable) < 2:\n            raise ValueError(\"each iterable must have two or more items\")\n\n    # This is based on \"Algorithm H\" from section 7.2.1.1, page 20.\n    # a holds the indexes of the source iterables for the n-tuple to be yielded\n    # f is the array of \"focus pointers\"\n    # o is the array of \"directions\"\n    a = [0] * iterable_count\n    f = list(range(iterable_count + 1))\n    o = [1] * iterable_count\n    while True:\n        yield tuple(all_iterables[i][a[i]] for i in range(iterable_count))\n        j = f[0]\n        f[0] = 0\n        if j == iterable_count:\n            break\n        a[j] = a[j] + o[j]\n        if a[j] == 0 or a[j] == len(all_iterables[j]) - 1:\n            o[j] = -o[j]\n            f[j] = f[j + 1]\n            f[j + 1] = j + 1\n\n\ndef partial_product(*iterables):\n    \"\"\"Yields tuples containing one item from each iterator, with subsequent\n    tuples changing a single item at a time by advancing each iterator until it\n    is exhausted. This sequence guarantees every value in each iterable is\n    output at least once without generating all possible combinations.\n\n    This may be useful, for example, when testing an expensive function.\n\n        >>> list(partial_product('AB', 'C', 'DEF'))\n        [('A', 'C', 'D'), ('B', 'C', 'D'), ('B', 'C', 'E'), ('B', 'C', 'F')]\n    \"\"\"\n\n    iterators = list(map(iter, iterables))\n\n    try:\n        prod = [next(it) for it in iterators]\n    except StopIteration:\n        return\n    yield tuple(prod)\n\n    for i, it in enumerate(iterators):\n        for prod[i] in it:\n            yield tuple(prod)\n\n\ndef takewhile_inclusive(predicate, iterable):\n    \"\"\"A variant of :func:`takewhile` that yields one additional element.\n\n        >>> list(takewhile_inclusive(lambda x: x < 5, [1, 4, 6, 4, 1]))\n        [1, 4, 6]\n\n    :func:`takewhile` would return ``[1, 4]``.\n    \"\"\"\n    for x in iterable:\n        yield x\n        if not predicate(x):\n            break\n\n\ndef outer_product(func, xs, ys, *args, **kwargs):\n    \"\"\"A generalized outer product that applies a binary function to all\n    pairs of items. Returns a 2D matrix with ``len(xs)`` rows and ``len(ys)``\n    columns.\n    Also accepts ``*args`` and ``**kwargs`` that are passed to ``func``.\n\n    Multiplication table:\n\n    >>> list(outer_product(mul, range(1, 4), range(1, 6)))\n    [(1, 2, 3, 4, 5), (2, 4, 6, 8, 10), (3, 6, 9, 12, 15)]\n\n    Cross tabulation:\n\n    >>> xs = ['A', 'B', 'A', 'A', 'B', 'B', 'A', 'A', 'B', 'B']\n    >>> ys = ['X', 'X', 'X', 'Y', 'Z', 'Z', 'Y', 'Y', 'Z', 'Z']\n    >>> rows = list(zip(xs, ys))\n    >>> count_rows = lambda x, y: rows.count((x, y))\n    >>> list(outer_product(count_rows, sorted(set(xs)), sorted(set(ys))))\n    [(2, 3, 0), (1, 0, 4)]\n\n    Usage with ``*args`` and ``**kwargs``:\n\n    >>> animals = ['cat', 'wolf', 'mouse']\n    >>> list(outer_product(min, animals, animals, key=len))\n    [('cat', 'cat', 'cat'), ('cat', 'wolf', 'wolf'), ('cat', 'wolf', 'mouse')]\n    \"\"\"\n    ys = tuple(ys)\n    return batched(\n        starmap(lambda x, y: func(x, y, *args, **kwargs), product(xs, ys)),\n        n=len(ys),\n    )\n\n\ndef iter_suppress(iterable, *exceptions):\n    \"\"\"Yield each of the items from *iterable*. If the iteration raises one of\n    the specified *exceptions*, that exception will be suppressed and iteration\n    will stop.\n\n    >>> from itertools import chain\n    >>> def breaks_at_five(x):\n    ...     while True:\n    ...         if x >= 5:\n    ...             raise RuntimeError\n    ...         yield x\n    ...         x += 1\n    >>> it_1 = iter_suppress(breaks_at_five(1), RuntimeError)\n    >>> it_2 = iter_suppress(breaks_at_five(2), RuntimeError)\n    >>> list(chain(it_1, it_2))\n    [1, 2, 3, 4, 2, 3, 4]\n    \"\"\"\n    try:\n        yield from iterable\n    except exceptions:\n        return\n\n\ndef filter_map(func, iterable):\n    \"\"\"Apply *func* to every element of *iterable*, yielding only those which\n    are not ``None``.\n\n    >>> elems = ['1', 'a', '2', 'b', '3']\n    >>> list(filter_map(lambda s: int(s) if s.isnumeric() else None, elems))\n    [1, 2, 3]\n    \"\"\"\n    for x in iterable:\n        y = func(x)\n        if y is not None:\n            yield y\n\n\ndef powerset_of_sets(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset_of_sets([1, 2, 3]))  # doctest: +SKIP\n        [set(), {1}, {2}, {3}, {1, 2}, {1, 3}, {2, 3}, {1, 2, 3}]\n        >>> list(powerset_of_sets([1, 1, 0]))  # doctest: +SKIP\n        [set(), {1}, {0}, {0, 1}]\n\n    :func:`powerset_of_sets` takes care to minimize the number\n    of hash operations performed.\n    \"\"\"\n    sets = tuple(map(set, dict.fromkeys(map(frozenset, zip(iterable)))))\n    for r in range(len(sets) + 1):\n        yield from starmap(set().union, combinations(sets, r))\n\n\ndef join_mappings(**field_to_map):\n    \"\"\"\n    Joins multiple mappings together using their common keys.\n\n    >>> user_scores = {'elliot': 50, 'claris': 60}\n    >>> user_times = {'elliot': 30, 'claris': 40}\n    >>> join_mappings(score=user_scores, time=user_times)\n    {'elliot': {'score': 50, 'time': 30}, 'claris': {'score': 60, 'time': 40}}\n    \"\"\"\n    ret = defaultdict(dict)\n\n    for field_name, mapping in field_to_map.items():\n        for key, value in mapping.items():\n            ret[key][field_name] = value\n\n    return dict(ret)\n\n\ndef _complex_sumprod(v1, v2):\n    \"\"\"High precision sumprod() for complex numbers.\n    Used by :func:`dft` and :func:`idft`.\n    \"\"\"\n\n    r1 = chain((p.real for p in v1), (-p.imag for p in v1))\n    r2 = chain((q.real for q in v2), (q.imag for q in v2))\n    i1 = chain((p.real for p in v1), (p.imag for p in v1))\n    i2 = chain((q.imag for q in v2), (q.real for q in v2))\n    return complex(_fsumprod(r1, r2), _fsumprod(i1, i2))\n\n\ndef dft(xarr):\n    \"\"\"Discrete Fourier Tranform. *xarr* is a sequence of complex numbers.\n    Yields the components of the corresponding transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]\n    >>> all(map(cmath.isclose, dft(xarr), Xarr))\n    True\n\n    See :func:`idft` for the inverse Discrete Fourier Transform.\n    \"\"\"\n    N = len(xarr)\n    roots_of_unity = [e ** (n / N * tau * -1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(xarr, coeffs)\n\n\ndef idft(Xarr):\n    \"\"\"Inverse Discrete Fourier Tranform. *Xarr* is a sequence of\n    complex numbers. Yields the components of the corresponding\n    inverse-transformed output vector.\n\n    >>> import cmath\n    >>> xarr = [1, 2-1j, -1j, -1+2j]\n    >>> Xarr = [2, -2-2j, -2j, 4+4j]\n    >>> all(map(cmath.isclose, idft(Xarr), xarr))\n    True\n\n    See :func:`dft` for the Discrete Fourier Transform.\n    \"\"\"\n    N = len(Xarr)\n    roots_of_unity = [e ** (n / N * tau * 1j) for n in range(N)]\n    for k in range(N):\n        coeffs = [roots_of_unity[k * n % N] for n in range(N)]\n        yield _complex_sumprod(Xarr, coeffs) / N\n\n\ndef doublestarmap(func, iterable):\n    \"\"\"Apply *func* to every item of *iterable* by dictionary unpacking\n    the item into *func*.\n\n    The difference between :func:`itertools.starmap` and :func:`doublestarmap`\n    parallels the distinction between ``func(*a)`` and ``func(**a)``.\n\n    >>> iterable = [{'a': 1, 'b': 2}, {'a': 40, 'b': 60}]\n    >>> list(doublestarmap(lambda a, b: a + b, iterable))\n    [3, 100]\n\n    ``TypeError`` will be raised if *func*'s signature doesn't match the\n    mapping contained in *iterable* or if *iterable* does not contain mappings.\n    \"\"\"\n    for item in iterable:\n        yield func(**item)\n", "more_itertools/recipes.py": "\"\"\"Imported from the recipes section of the itertools documentation.\n\nAll functions taken from the recipes section of the itertools library docs\n[1]_.\nSome backward-compatible usability improvements have been made.\n\n.. [1] http://docs.python.org/library/itertools.html#recipes\n\n\"\"\"\n\nimport math\nimport operator\n\nfrom collections import deque\nfrom collections.abc import Sized\nfrom functools import partial, reduce\nfrom itertools import (\n    chain,\n    combinations,\n    compress,\n    count,\n    cycle,\n    groupby,\n    islice,\n    product,\n    repeat,\n    starmap,\n    tee,\n    zip_longest,\n)\nfrom random import randrange, sample, choice\nfrom sys import hexversion\n\n__all__ = [\n    'all_equal',\n    'batched',\n    'before_and_after',\n    'consume',\n    'convolve',\n    'dotproduct',\n    'first_true',\n    'factor',\n    'flatten',\n    'grouper',\n    'iter_except',\n    'iter_index',\n    'matmul',\n    'ncycles',\n    'nth',\n    'nth_combination',\n    'padnone',\n    'pad_none',\n    'pairwise',\n    'partition',\n    'polynomial_eval',\n    'polynomial_from_roots',\n    'polynomial_derivative',\n    'powerset',\n    'prepend',\n    'quantify',\n    'reshape',\n    'random_combination_with_replacement',\n    'random_combination',\n    'random_permutation',\n    'random_product',\n    'repeatfunc',\n    'roundrobin',\n    'sieve',\n    'sliding_window',\n    'subslices',\n    'sum_of_squares',\n    'tabulate',\n    'tail',\n    'take',\n    'totient',\n    'transpose',\n    'triplewise',\n    'unique',\n    'unique_everseen',\n    'unique_justseen',\n]\n\n_marker = object()\n\n\n# zip with strict is available for Python 3.10+\ntry:\n    zip(strict=True)\nexcept TypeError:\n    _zip_strict = zip\nelse:\n    _zip_strict = partial(zip, strict=True)\n\n# math.sumprod is available for Python 3.12+\n_sumprod = getattr(math, 'sumprod', lambda x, y: dotproduct(x, y))\n\n\ndef take(n, iterable):\n    \"\"\"Return first *n* items of the iterable as a list.\n\n        >>> take(3, range(10))\n        [0, 1, 2]\n\n    If there are fewer than *n* items in the iterable, all of them are\n    returned.\n\n        >>> take(10, range(3))\n        [0, 1, 2]\n\n    \"\"\"\n    return list(islice(iterable, n))\n\n\ndef tabulate(function, start=0):\n    \"\"\"Return an iterator over the results of ``func(start)``,\n    ``func(start + 1)``, ``func(start + 2)``...\n\n    *func* should be a function that accepts one integer argument.\n\n    If *start* is not specified it defaults to 0. It will be incremented each\n    time the iterator is advanced.\n\n        >>> square = lambda x: x ** 2\n        >>> iterator = tabulate(square, -3)\n        >>> take(4, iterator)\n        [9, 4, 1, 0]\n\n    \"\"\"\n    return map(function, count(start))\n\n\ndef tail(n, iterable):\n    \"\"\"Return an iterator over the last *n* items of *iterable*.\n\n    >>> t = tail(3, 'ABCDEFG')\n    >>> list(t)\n    ['E', 'F', 'G']\n\n    \"\"\"\n    # If the given iterable has a length, then we can use islice to get its\n    # final elements. Note that if the iterable is not actually Iterable,\n    # either islice or deque will throw a TypeError. This is why we don't\n    # check if it is Iterable.\n    if isinstance(iterable, Sized):\n        yield from islice(iterable, max(0, len(iterable) - n), None)\n    else:\n        yield from iter(deque(iterable, maxlen=n))\n\n\ndef consume(iterator, n=None):\n    \"\"\"Advance *iterable* by *n* steps. If *n* is ``None``, consume it\n    entirely.\n\n    Efficiently exhausts an iterator without returning values. Defaults to\n    consuming the whole iterator, but an optional second argument may be\n    provided to limit consumption.\n\n        >>> i = (x for x in range(10))\n        >>> next(i)\n        0\n        >>> consume(i, 3)\n        >>> next(i)\n        4\n        >>> consume(i)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    If the iterator has fewer items remaining than the provided limit, the\n    whole iterator will be consumed.\n\n        >>> i = (x for x in range(3))\n        >>> consume(i, 5)\n        >>> next(i)\n        Traceback (most recent call last):\n          File \"<stdin>\", line 1, in <module>\n        StopIteration\n\n    \"\"\"\n    # Use functions that consume iterators at C speed.\n    if n is None:\n        # feed the entire iterator into a zero-length deque\n        deque(iterator, maxlen=0)\n    else:\n        # advance to the empty slice starting at position n\n        next(islice(iterator, n, n), None)\n\n\ndef nth(iterable, n, default=None):\n    \"\"\"Returns the nth item or a default value.\n\n    >>> l = range(10)\n    >>> nth(l, 3)\n    3\n    >>> nth(l, 20, \"zebra\")\n    'zebra'\n\n    \"\"\"\n    return next(islice(iterable, n, None), default)\n\n\ndef all_equal(iterable, key=None):\n    \"\"\"\n    Returns ``True`` if all the elements are equal to each other.\n\n        >>> all_equal('aaaa')\n        True\n        >>> all_equal('aaab')\n        False\n\n    A function that accepts a single argument and returns a transformed version\n    of each input item can be specified with *key*:\n\n        >>> all_equal('AaaA', key=str.casefold)\n        True\n        >>> all_equal([1, 2, 3], key=lambda x: x < 10)\n        True\n\n    \"\"\"\n    return len(list(islice(groupby(iterable, key), 2))) <= 1\n\n\ndef quantify(iterable, pred=bool):\n    \"\"\"Return the how many times the predicate is true.\n\n    >>> quantify([True, False, True])\n    2\n\n    \"\"\"\n    return sum(map(pred, iterable))\n\n\ndef pad_none(iterable):\n    \"\"\"Returns the sequence of elements and then returns ``None`` indefinitely.\n\n        >>> take(5, pad_none(range(3)))\n        [0, 1, 2, None, None]\n\n    Useful for emulating the behavior of the built-in :func:`map` function.\n\n    See also :func:`padded`.\n\n    \"\"\"\n    return chain(iterable, repeat(None))\n\n\npadnone = pad_none\n\n\ndef ncycles(iterable, n):\n    \"\"\"Returns the sequence elements *n* times\n\n    >>> list(ncycles([\"a\", \"b\"], 3))\n    ['a', 'b', 'a', 'b', 'a', 'b']\n\n    \"\"\"\n    return chain.from_iterable(repeat(tuple(iterable), n))\n\n\ndef dotproduct(vec1, vec2):\n    \"\"\"Returns the dot product of the two iterables.\n\n    >>> dotproduct([10, 10], [20, 20])\n    400\n\n    \"\"\"\n    return sum(map(operator.mul, vec1, vec2))\n\n\ndef flatten(listOfLists):\n    \"\"\"Return an iterator flattening one level of nesting in a list of lists.\n\n        >>> list(flatten([[0, 1], [2, 3]]))\n        [0, 1, 2, 3]\n\n    See also :func:`collapse`, which can flatten multiple levels of nesting.\n\n    \"\"\"\n    return chain.from_iterable(listOfLists)\n\n\ndef repeatfunc(func, times=None, *args):\n    \"\"\"Call *func* with *args* repeatedly, returning an iterable over the\n    results.\n\n    If *times* is specified, the iterable will terminate after that many\n    repetitions:\n\n        >>> from operator import add\n        >>> times = 4\n        >>> args = 3, 5\n        >>> list(repeatfunc(add, times, *args))\n        [8, 8, 8, 8]\n\n    If *times* is ``None`` the iterable will not terminate:\n\n        >>> from random import randrange\n        >>> times = None\n        >>> args = 1, 11\n        >>> take(6, repeatfunc(randrange, times, *args))  # doctest:+SKIP\n        [2, 4, 8, 1, 8, 4]\n\n    \"\"\"\n    if times is None:\n        return starmap(func, repeat(args))\n    return starmap(func, repeat(args, times))\n\n\ndef _pairwise(iterable):\n    \"\"\"Returns an iterator of paired items, overlapping, from the original\n\n    >>> take(4, pairwise(count()))\n    [(0, 1), (1, 2), (2, 3), (3, 4)]\n\n    On Python 3.10 and above, this is an alias for :func:`itertools.pairwise`.\n\n    \"\"\"\n    a, b = tee(iterable)\n    next(b, None)\n    return zip(a, b)\n\n\ntry:\n    from itertools import pairwise as itertools_pairwise\nexcept ImportError:\n    pairwise = _pairwise\nelse:\n\n    def pairwise(iterable):\n        return itertools_pairwise(iterable)\n\n    pairwise.__doc__ = _pairwise.__doc__\n\n\nclass UnequalIterablesError(ValueError):\n    def __init__(self, details=None):\n        msg = 'Iterables have different lengths'\n        if details is not None:\n            msg += (': index 0 has length {}; index {} has length {}').format(\n                *details\n            )\n\n        super().__init__(msg)\n\n\ndef _zip_equal_generator(iterables):\n    for combo in zip_longest(*iterables, fillvalue=_marker):\n        for val in combo:\n            if val is _marker:\n                raise UnequalIterablesError()\n        yield combo\n\n\ndef _zip_equal(*iterables):\n    # Check whether the iterables are all the same size.\n    try:\n        first_size = len(iterables[0])\n        for i, it in enumerate(iterables[1:], 1):\n            size = len(it)\n            if size != first_size:\n                raise UnequalIterablesError(details=(first_size, i, size))\n        # All sizes are equal, we can use the built-in zip.\n        return zip(*iterables)\n    # If any one of the iterables didn't have a length, start reading\n    # them until one runs out.\n    except TypeError:\n        return _zip_equal_generator(iterables)\n\n\ndef grouper(iterable, n, incomplete='fill', fillvalue=None):\n    \"\"\"Group elements from *iterable* into fixed-length groups of length *n*.\n\n    >>> list(grouper('ABCDEF', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    The keyword arguments *incomplete* and *fillvalue* control what happens for\n    iterables whose length is not a multiple of *n*.\n\n    When *incomplete* is `'fill'`, the last group will contain instances of\n    *fillvalue*.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='fill', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G', 'x', 'x')]\n\n    When *incomplete* is `'ignore'`, the last group will not be emitted.\n\n    >>> list(grouper('ABCDEFG', 3, incomplete='ignore', fillvalue='x'))\n    [('A', 'B', 'C'), ('D', 'E', 'F')]\n\n    When *incomplete* is `'strict'`, a subclass of `ValueError` will be raised.\n\n    >>> it = grouper('ABCDEFG', 3, incomplete='strict')\n    >>> list(it)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    UnequalIterablesError\n\n    \"\"\"\n    args = [iter(iterable)] * n\n    if incomplete == 'fill':\n        return zip_longest(*args, fillvalue=fillvalue)\n    if incomplete == 'strict':\n        return _zip_equal(*args)\n    if incomplete == 'ignore':\n        return zip(*args)\n    else:\n        raise ValueError('Expected fill, strict, or ignore')\n\n\ndef roundrobin(*iterables):\n    \"\"\"Yields an item from each iterable, alternating between them.\n\n        >>> list(roundrobin('ABC', 'D', 'EF'))\n        ['A', 'D', 'E', 'B', 'F', 'C']\n\n    This function produces the same output as :func:`interleave_longest`, but\n    may perform better for some inputs (in particular when the number of\n    iterables is small).\n\n    \"\"\"\n    # Algorithm credited to George Sakkis\n    iterators = map(iter, iterables)\n    for num_active in range(len(iterables), 0, -1):\n        iterators = cycle(islice(iterators, num_active))\n        yield from map(next, iterators)\n\n\ndef partition(pred, iterable):\n    \"\"\"\n    Returns a 2-tuple of iterables derived from the input iterable.\n    The first yields the items that have ``pred(item) == False``.\n    The second yields the items that have ``pred(item) == True``.\n\n        >>> is_odd = lambda x: x % 2 != 0\n        >>> iterable = range(10)\n        >>> even_items, odd_items = partition(is_odd, iterable)\n        >>> list(even_items), list(odd_items)\n        ([0, 2, 4, 6, 8], [1, 3, 5, 7, 9])\n\n    If *pred* is None, :func:`bool` is used.\n\n        >>> iterable = [0, 1, False, True, '', ' ']\n        >>> false_items, true_items = partition(None, iterable)\n        >>> list(false_items), list(true_items)\n        ([0, False, ''], [1, True, ' '])\n\n    \"\"\"\n    if pred is None:\n        pred = bool\n\n    t1, t2, p = tee(iterable, 3)\n    p1, p2 = tee(map(pred, p))\n    return (compress(t1, map(operator.not_, p1)), compress(t2, p2))\n\n\ndef powerset(iterable):\n    \"\"\"Yields all possible subsets of the iterable.\n\n        >>> list(powerset([1, 2, 3]))\n        [(), (1,), (2,), (3,), (1, 2), (1, 3), (2, 3), (1, 2, 3)]\n\n    :func:`powerset` will operate on iterables that aren't :class:`set`\n    instances, so repeated elements in the input will produce repeated elements\n    in the output.\n\n        >>> seq = [1, 1, 0]\n        >>> list(powerset(seq))\n        [(), (1,), (1,), (0,), (1, 1), (1, 0), (1, 0), (1, 1, 0)]\n\n    For a variant that efficiently yields actual :class:`set` instances, see\n    :func:`powerset_of_sets`.\n    \"\"\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s) + 1))\n\n\ndef unique_everseen(iterable, key=None):\n    \"\"\"\n    Yield unique elements, preserving order.\n\n        >>> list(unique_everseen('AAAABBBCCDAABBB'))\n        ['A', 'B', 'C', 'D']\n        >>> list(unique_everseen('ABBCcAD', str.lower))\n        ['A', 'B', 'C', 'D']\n\n    Sequences with a mix of hashable and unhashable items can be used.\n    The function will be slower (i.e., `O(n^2)`) for unhashable items.\n\n    Remember that ``list`` objects are unhashable - you can use the *key*\n    parameter to transform the list to a tuple (which is hashable) to\n    avoid a slowdown.\n\n        >>> iterable = ([1, 2], [2, 3], [1, 2])\n        >>> list(unique_everseen(iterable))  # Slow\n        [[1, 2], [2, 3]]\n        >>> list(unique_everseen(iterable, key=tuple))  # Faster\n        [[1, 2], [2, 3]]\n\n    Similarly, you may want to convert unhashable ``set`` objects with\n    ``key=frozenset``. For ``dict`` objects,\n    ``key=lambda x: frozenset(x.items())`` can be used.\n\n    \"\"\"\n    seenset = set()\n    seenset_add = seenset.add\n    seenlist = []\n    seenlist_add = seenlist.append\n    use_key = key is not None\n\n    for element in iterable:\n        k = key(element) if use_key else element\n        try:\n            if k not in seenset:\n                seenset_add(k)\n                yield element\n        except TypeError:\n            if k not in seenlist:\n                seenlist_add(k)\n                yield element\n\n\ndef unique_justseen(iterable, key=None):\n    \"\"\"Yields elements in order, ignoring serial duplicates\n\n    >>> list(unique_justseen('AAAABBBCCDAABBB'))\n    ['A', 'B', 'C', 'D', 'A', 'B']\n    >>> list(unique_justseen('ABBCcAD', str.lower))\n    ['A', 'B', 'C', 'A', 'D']\n\n    \"\"\"\n    if key is None:\n        return map(operator.itemgetter(0), groupby(iterable))\n\n    return map(next, map(operator.itemgetter(1), groupby(iterable, key)))\n\n\ndef unique(iterable, key=None, reverse=False):\n    \"\"\"Yields unique elements in sorted order.\n\n    >>> list(unique([[1, 2], [3, 4], [1, 2]]))\n    [[1, 2], [3, 4]]\n\n    *key* and *reverse* are passed to :func:`sorted`.\n\n    >>> list(unique('ABBcCAD', str.casefold))\n    ['A', 'B', 'c', 'D']\n    >>> list(unique('ABBcCAD', str.casefold, reverse=True))\n    ['D', 'c', 'B', 'A']\n\n    The elements in *iterable* need not be hashable, but they must be\n    comparable for sorting to work.\n    \"\"\"\n    return unique_justseen(sorted(iterable, key=key, reverse=reverse), key=key)\n\n\ndef iter_except(func, exception, first=None):\n    \"\"\"Yields results from a function repeatedly until an exception is raised.\n\n    Converts a call-until-exception interface to an iterator interface.\n    Like ``iter(func, sentinel)``, but uses an exception instead of a sentinel\n    to end the loop.\n\n        >>> l = [0, 1, 2]\n        >>> list(iter_except(l.pop, IndexError))\n        [2, 1, 0]\n\n    Multiple exceptions can be specified as a stopping condition:\n\n        >>> l = [1, 2, 3, '...', 4, 5, 6]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [7, 6, 5]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        [4, 3, 2]\n        >>> list(iter_except(lambda: 1 + l.pop(), (IndexError, TypeError)))\n        []\n\n    \"\"\"\n    try:\n        if first is not None:\n            yield first()\n        while 1:\n            yield func()\n    except exception:\n        pass\n\n\ndef first_true(iterable, default=None, pred=None):\n    \"\"\"\n    Returns the first true value in the iterable.\n\n    If no true value is found, returns *default*\n\n    If *pred* is not None, returns the first item for which\n    ``pred(item) == True`` .\n\n        >>> first_true(range(10))\n        1\n        >>> first_true(range(10), pred=lambda x: x > 5)\n        6\n        >>> first_true(range(10), default='missing', pred=lambda x: x > 9)\n        'missing'\n\n    \"\"\"\n    return next(filter(pred, iterable), default)\n\n\ndef random_product(*args, repeat=1):\n    \"\"\"Draw an item at random from each of the input iterables.\n\n        >>> random_product('abc', range(4), 'XYZ')  # doctest:+SKIP\n        ('c', 3, 'Z')\n\n    If *repeat* is provided as a keyword argument, that many items will be\n    drawn from each iterable.\n\n        >>> random_product('abcd', range(4), repeat=2)  # doctest:+SKIP\n        ('a', 2, 'd', 3)\n\n    This equivalent to taking a random selection from\n    ``itertools.product(*args, **kwarg)``.\n\n    \"\"\"\n    pools = [tuple(pool) for pool in args] * repeat\n    return tuple(choice(pool) for pool in pools)\n\n\ndef random_permutation(iterable, r=None):\n    \"\"\"Return a random *r* length permutation of the elements in *iterable*.\n\n    If *r* is not specified or is ``None``, then *r* defaults to the length of\n    *iterable*.\n\n        >>> random_permutation(range(5))  # doctest:+SKIP\n        (3, 4, 0, 1, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.permutations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    r = len(pool) if r is None else r\n    return tuple(sample(pool, r))\n\n\ndef random_combination(iterable, r):\n    \"\"\"Return a random *r* length subsequence of the elements in *iterable*.\n\n        >>> random_combination(range(5), 3)  # doctest:+SKIP\n        (2, 3, 4)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(sample(range(n), r))\n    return tuple(pool[i] for i in indices)\n\n\ndef random_combination_with_replacement(iterable, r):\n    \"\"\"Return a random *r* length subsequence of elements in *iterable*,\n    allowing individual elements to be repeated.\n\n        >>> random_combination_with_replacement(range(3), 5) # doctest:+SKIP\n        (0, 0, 1, 2, 2)\n\n    This equivalent to taking a random selection from\n    ``itertools.combinations_with_replacement(iterable, r)``.\n\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    indices = sorted(randrange(n) for i in range(r))\n    return tuple(pool[i] for i in indices)\n\n\ndef nth_combination(iterable, r, index):\n    \"\"\"Equivalent to ``list(combinations(iterable, r))[index]``.\n\n    The subsequences of *iterable* that are of length *r* can be ordered\n    lexicographically. :func:`nth_combination` computes the subsequence at\n    sort position *index* directly, without computing the previous\n    subsequences.\n\n        >>> nth_combination(range(5), 3, 5)\n        (0, 3, 4)\n\n    ``ValueError`` will be raised If *r* is negative or greater than the length\n    of *iterable*.\n    ``IndexError`` will be raised if the given *index* is invalid.\n    \"\"\"\n    pool = tuple(iterable)\n    n = len(pool)\n    if (r < 0) or (r > n):\n        raise ValueError\n\n    c = 1\n    k = min(r, n - r)\n    for i in range(1, k + 1):\n        c = c * (n - k + i) // i\n\n    if index < 0:\n        index += c\n\n    if (index < 0) or (index >= c):\n        raise IndexError\n\n    result = []\n    while r:\n        c, n, r = c * r // n, n - 1, r - 1\n        while index >= c:\n            index -= c\n            c, n = c * (n - r) // n, n - 1\n        result.append(pool[-1 - n])\n\n    return tuple(result)\n\n\ndef prepend(value, iterator):\n    \"\"\"Yield *value*, followed by the elements in *iterator*.\n\n        >>> value = '0'\n        >>> iterator = ['1', '2', '3']\n        >>> list(prepend(value, iterator))\n        ['0', '1', '2', '3']\n\n    To prepend multiple values, see :func:`itertools.chain`\n    or :func:`value_chain`.\n\n    \"\"\"\n    return chain([value], iterator)\n\n\ndef convolve(signal, kernel):\n    \"\"\"Convolve the iterable *signal* with the iterable *kernel*.\n\n        >>> signal = (1, 2, 3, 4, 5)\n        >>> kernel = [3, 2, 1]\n        >>> list(convolve(signal, kernel))\n        [3, 8, 14, 20, 26, 14, 5]\n\n    Note: the input arguments are not interchangeable, as the *kernel*\n    is immediately consumed and stored.\n\n    \"\"\"\n    # This implementation intentionally doesn't match the one in the itertools\n    # documentation.\n    kernel = tuple(kernel)[::-1]\n    n = len(kernel)\n    window = deque([0], maxlen=n) * n\n    for x in chain(signal, repeat(0, n - 1)):\n        window.append(x)\n        yield _sumprod(kernel, window)\n\n\ndef before_and_after(predicate, it):\n    \"\"\"A variant of :func:`takewhile` that allows complete access to the\n    remainder of the iterator.\n\n         >>> it = iter('ABCdEfGhI')\n         >>> all_upper, remainder = before_and_after(str.isupper, it)\n         >>> ''.join(all_upper)\n         'ABC'\n         >>> ''.join(remainder) # takewhile() would lose the 'd'\n         'dEfGhI'\n\n    Note that the first iterator must be fully consumed before the second\n    iterator can generate valid results.\n    \"\"\"\n    it = iter(it)\n    transition = []\n\n    def true_iterator():\n        for elem in it:\n            if predicate(elem):\n                yield elem\n            else:\n                transition.append(elem)\n                return\n\n    # Note: this is different from itertools recipes to allow nesting\n    # before_and_after remainders into before_and_after again. See tests\n    # for an example.\n    remainder_iterator = chain(transition, it)\n\n    return true_iterator(), remainder_iterator\n\n\ndef triplewise(iterable):\n    \"\"\"Return overlapping triplets from *iterable*.\n\n    >>> list(triplewise('ABCDE'))\n    [('A', 'B', 'C'), ('B', 'C', 'D'), ('C', 'D', 'E')]\n\n    \"\"\"\n    for (a, _), (b, c) in pairwise(pairwise(iterable)):\n        yield a, b, c\n\n\ndef sliding_window(iterable, n):\n    \"\"\"Return a sliding window of width *n* over *iterable*.\n\n        >>> list(sliding_window(range(6), 4))\n        [(0, 1, 2, 3), (1, 2, 3, 4), (2, 3, 4, 5)]\n\n    If *iterable* has fewer than *n* items, then nothing is yielded:\n\n        >>> list(sliding_window(range(3), 4))\n        []\n\n    For a variant with more features, see :func:`windowed`.\n    \"\"\"\n    it = iter(iterable)\n    window = deque(islice(it, n - 1), maxlen=n)\n    for x in it:\n        window.append(x)\n        yield tuple(window)\n\n\ndef subslices(iterable):\n    \"\"\"Return all contiguous non-empty subslices of *iterable*.\n\n        >>> list(subslices('ABC'))\n        [['A'], ['A', 'B'], ['A', 'B', 'C'], ['B'], ['B', 'C'], ['C']]\n\n    This is similar to :func:`substrings`, but emits items in a different\n    order.\n    \"\"\"\n    seq = list(iterable)\n    slices = starmap(slice, combinations(range(len(seq) + 1), 2))\n    return map(operator.getitem, repeat(seq), slices)\n\n\ndef polynomial_from_roots(roots):\n    \"\"\"Compute a polynomial's coefficients from its roots.\n\n    >>> roots = [5, -4, 3]  # (x - 5) * (x + 4) * (x - 3)\n    >>> polynomial_from_roots(roots)  # x^3 - 4 * x^2 - 17 * x + 60\n    [1, -4, -17, 60]\n    \"\"\"\n    factors = zip(repeat(1), map(operator.neg, roots))\n    return list(reduce(convolve, factors, [1]))\n\n\ndef iter_index(iterable, value, start=0, stop=None):\n    \"\"\"Yield the index of each place in *iterable* that *value* occurs,\n    beginning with index *start* and ending before index *stop*.\n\n\n    >>> list(iter_index('AABCADEAF', 'A'))\n    [0, 1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1))  # start index is inclusive\n    [1, 4, 7]\n    >>> list(iter_index('AABCADEAF', 'A', 1, 7))  # stop index is not inclusive\n    [1, 4]\n\n    The behavior for non-scalar *values* matches the built-in Python types.\n\n    >>> list(iter_index('ABCDABCD', 'AB'))\n    [0, 4]\n    >>> list(iter_index([0, 1, 2, 3, 0, 1, 2, 3], [0, 1]))\n    []\n    >>> list(iter_index([[0, 1], [2, 3], [0, 1], [2, 3]], [0, 1]))\n    [0, 2]\n\n    See :func:`locate` for a more general means of finding the indexes\n    associated with particular values.\n\n    \"\"\"\n    seq_index = getattr(iterable, 'index', None)\n    if seq_index is None:\n        # Slow path for general iterables\n        it = islice(iterable, start, stop)\n        for i, element in enumerate(it, start):\n            if element is value or element == value:\n                yield i\n    else:\n        # Fast path for sequences\n        stop = len(iterable) if stop is None else stop\n        i = start - 1\n        try:\n            while True:\n                yield (i := seq_index(value, i + 1, stop))\n        except ValueError:\n            pass\n\n\ndef sieve(n):\n    \"\"\"Yield the primes less than n.\n\n    >>> list(sieve(30))\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    \"\"\"\n    if n > 2:\n        yield 2\n    start = 3\n    data = bytearray((0, 1)) * (n // 2)\n    limit = math.isqrt(n) + 1\n    for p in iter_index(data, 1, start, limit):\n        yield from iter_index(data, 1, start, p * p)\n        data[p * p : n : p + p] = bytes(len(range(p * p, n, p + p)))\n        start = p * p\n    yield from iter_index(data, 1, start)\n\n\ndef _batched(iterable, n, *, strict=False):\n    \"\"\"Batch data into tuples of length *n*. If the number of items in\n    *iterable* is not divisible by *n*:\n    * The last batch will be shorter if *strict* is ``False``.\n    * :exc:`ValueError` will be raised if *strict* is ``True``.\n\n    >>> list(batched('ABCDEFG', 3))\n    [('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]\n\n    On Python 3.13 and above, this is an alias for :func:`itertools.batched`.\n    \"\"\"\n    if n < 1:\n        raise ValueError('n must be at least one')\n    it = iter(iterable)\n    while batch := tuple(islice(it, n)):\n        if strict and len(batch) != n:\n            raise ValueError('batched(): incomplete batch')\n        yield batch\n\n\nif hexversion >= 0x30D00A2:\n    from itertools import batched as itertools_batched\n\n    def batched(iterable, n, *, strict=False):\n        return itertools_batched(iterable, n, strict=strict)\n\nelse:\n    batched = _batched\n\n    batched.__doc__ = _batched.__doc__\n\n\ndef transpose(it):\n    \"\"\"Swap the rows and columns of the input matrix.\n\n    >>> list(transpose([(1, 2, 3), (11, 22, 33)]))\n    [(1, 11), (2, 22), (3, 33)]\n\n    The caller should ensure that the dimensions of the input are compatible.\n    If the input is empty, no output will be produced.\n    \"\"\"\n    return _zip_strict(*it)\n\n\ndef reshape(matrix, cols):\n    \"\"\"Reshape the 2-D input *matrix* to have a column count given by *cols*.\n\n    >>> matrix = [(0, 1), (2, 3), (4, 5)]\n    >>> cols = 3\n    >>> list(reshape(matrix, cols))\n    [(0, 1, 2), (3, 4, 5)]\n    \"\"\"\n    return batched(chain.from_iterable(matrix), cols)\n\n\ndef matmul(m1, m2):\n    \"\"\"Multiply two matrices.\n\n    >>> list(matmul([(7, 5), (3, 5)], [(2, 5), (7, 9)]))\n    [(49, 80), (41, 60)]\n\n    The caller should ensure that the dimensions of the input matrices are\n    compatible with each other.\n    \"\"\"\n    n = len(m2[0])\n    return batched(starmap(_sumprod, product(m1, transpose(m2))), n)\n\n\ndef factor(n):\n    \"\"\"Yield the prime factors of n.\n\n    >>> list(factor(360))\n    [2, 2, 2, 3, 3, 5]\n    \"\"\"\n    for prime in sieve(math.isqrt(n) + 1):\n        while not n % prime:\n            yield prime\n            n //= prime\n            if n == 1:\n                return\n    if n > 1:\n        yield n\n\n\ndef polynomial_eval(coefficients, x):\n    \"\"\"Evaluate a polynomial at a specific value.\n\n    Example: evaluating x^3 - 4 * x^2 - 17 * x + 60 at x = 2.5:\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> x = 2.5\n    >>> polynomial_eval(coefficients, x)\n    8.125\n    \"\"\"\n    n = len(coefficients)\n    if n == 0:\n        return x * 0  # coerce zero to the type of x\n    powers = map(pow, repeat(x), reversed(range(n)))\n    return _sumprod(coefficients, powers)\n\n\ndef sum_of_squares(it):\n    \"\"\"Return the sum of the squares of the input values.\n\n    >>> sum_of_squares([10, 20, 30])\n    1400\n    \"\"\"\n    return _sumprod(*tee(it))\n\n\ndef polynomial_derivative(coefficients):\n    \"\"\"Compute the first derivative of a polynomial.\n\n    Example: evaluating the derivative of x^3 - 4 * x^2 - 17 * x + 60\n\n    >>> coefficients = [1, -4, -17, 60]\n    >>> derivative_coefficients = polynomial_derivative(coefficients)\n    >>> derivative_coefficients\n    [3, -8, -17]\n    \"\"\"\n    n = len(coefficients)\n    powers = reversed(range(1, n))\n    return list(map(operator.mul, coefficients, powers))\n\n\ndef totient(n):\n    \"\"\"Return the count of natural numbers up to *n* that are coprime with *n*.\n\n    >>> totient(9)\n    6\n    >>> totient(12)\n    4\n    \"\"\"\n    for prime in set(factor(n)):\n        n -= n // prime\n    return n\n", "more_itertools/__init__.py": "\"\"\"More routines for operating on iterables, beyond itertools\"\"\"\n\nfrom .more import *  # noqa\nfrom .recipes import *  # noqa\n\n__version__ = '10.3.0'\n"}