{"setup.py": "import os\nimport sys\nimport platform\nimport setuptools\n\n\n# # --- Detect if extensions should be disabled ------------------------------\n\nwrapt_env = os.environ.get('WRAPT_INSTALL_EXTENSIONS')\n\nif wrapt_env is None:\n    wrapt_env = os.environ.get('WRAPT_EXTENSIONS')\n\nif wrapt_env is not None:\n    disable_extensions = wrapt_env.lower() == 'false'\n    force_extensions = wrapt_env.lower() == 'true'\nelse:\n    if platform.system() == 'Windows' and sys.version_info[0] < 3:\n      disable_extensions = True\n      force_extensions = False\n    else:\n      disable_extensions = False\n      force_extensions = False\n\nif platform.python_implementation() != \"CPython\":\n    disable_extensions = True\n\n# --- C extension ------------------------------------------------------------\n\nextensions = [\n    setuptools.Extension(\n        \"wrapt._wrappers\",\n        sources=[\"src/wrapt/_wrappers.c\"],\n        optional=not force_extensions,\n    )\n]\n\n\n# --- Setup ------------------------------------------------------------------\n\nsetuptools.setup(\n    ext_modules=[] if disable_extensions else extensions\n)\n", "src/wrapt/weakrefs.py": "import functools\nimport weakref\n\nfrom .__wrapt__ import ObjectProxy, _FunctionWrapperBase\n\n# A weak function proxy. This will work on instance methods, class\n# methods, static methods and regular functions. Special treatment is\n# needed for the method types because the bound method is effectively a\n# transient object and applying a weak reference to one will immediately\n# result in it being destroyed and the weakref callback called. The weak\n# reference is therefore applied to the instance the method is bound to\n# and the original function. The function is then rebound at the point\n# of a call via the weak function proxy.\n\ndef _weak_function_proxy_callback(ref, proxy, callback):\n    if proxy._self_expired:\n        return\n\n    proxy._self_expired = True\n\n    # This could raise an exception. We let it propagate back and let\n    # the weakref.proxy() deal with it, at which point it generally\n    # prints out a short error message direct to stderr and keeps going.\n\n    if callback is not None:\n        callback(proxy)\n\nclass WeakFunctionProxy(ObjectProxy):\n\n    __slots__ = ('_self_expired', '_self_instance')\n\n    def __init__(self, wrapped, callback=None):\n        # We need to determine if the wrapped function is actually a\n        # bound method. In the case of a bound method, we need to keep a\n        # reference to the original unbound function and the instance.\n        # This is necessary because if we hold a reference to the bound\n        # function, it will be the only reference and given it is a\n        # temporary object, it will almost immediately expire and\n        # the weakref callback triggered. So what is done is that we\n        # hold a reference to the instance and unbound function and\n        # when called bind the function to the instance once again and\n        # then call it. Note that we avoid using a nested function for\n        # the callback here so as not to cause any odd reference cycles.\n\n        _callback = callback and functools.partial(\n                _weak_function_proxy_callback, proxy=self,\n                callback=callback)\n\n        self._self_expired = False\n\n        if isinstance(wrapped, _FunctionWrapperBase):\n            self._self_instance = weakref.ref(wrapped._self_instance,\n                    _callback)\n\n            if wrapped._self_parent is not None:\n                super(WeakFunctionProxy, self).__init__(\n                        weakref.proxy(wrapped._self_parent, _callback))\n\n            else:\n                super(WeakFunctionProxy, self).__init__(\n                        weakref.proxy(wrapped, _callback))\n\n            return\n\n        try:\n            self._self_instance = weakref.ref(wrapped.__self__, _callback)\n\n            super(WeakFunctionProxy, self).__init__(\n                    weakref.proxy(wrapped.__func__, _callback))\n\n        except AttributeError:\n            self._self_instance = None\n\n            super(WeakFunctionProxy, self).__init__(\n                    weakref.proxy(wrapped, _callback))\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # We perform a boolean check here on the instance and wrapped\n        # function as that will trigger the reference error prior to\n        # calling if the reference had expired.\n\n        instance = self._self_instance and self._self_instance()\n        function = self.__wrapped__ and self.__wrapped__\n\n        # If the wrapped function was originally a bound function, for\n        # which we retained a reference to the instance and the unbound\n        # function we need to rebind the function and then call it. If\n        # not just called the wrapped function.\n\n        if instance is None:\n            return self.__wrapped__(*args, **kwargs)\n\n        return function.__get__(instance, type(instance))(*args, **kwargs)\n", "src/wrapt/importer.py": "\"\"\"This module implements a post import hook mechanism styled after what is\ndescribed in PEP-369. Note that it doesn't cope with modules being reloaded.\n\n\"\"\"\n\nimport sys\nimport threading\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\n    find_spec = None\nelse:\n    string_types = str,\n    from importlib.util import find_spec\n\nfrom .__wrapt__ import ObjectProxy\n\n# The dictionary registering any post import hooks to be triggered once\n# the target module has been imported. Once a module has been imported\n# and the hooks fired, the list of hooks recorded against the target\n# module will be truncated but the list left in the dictionary. This\n# acts as a flag to indicate that the module had already been imported.\n\n_post_import_hooks = {}\n_post_import_hooks_init = False\n_post_import_hooks_lock = threading.RLock()\n\n# Register a new post import hook for the target module name. This\n# differs from the PEP-369 implementation in that it also allows the\n# hook function to be specified as a string consisting of the name of\n# the callback in the form 'module:function'. This will result in a\n# proxy callback being registered which will defer loading of the\n# specified module containing the callback function until required.\n\ndef _create_import_hook_from_string(name):\n    def import_hook(module):\n        module_name, function = name.split(':')\n        attrs = function.split('.')\n        __import__(module_name)\n        callback = sys.modules[module_name]\n        for attr in attrs:\n            callback = getattr(callback, attr)\n        return callback(module)\n    return import_hook\n\ndef register_post_import_hook(hook, name):\n    # Create a deferred import hook if hook is a string name rather than\n    # a callable function.\n\n    if isinstance(hook, string_types):\n        hook = _create_import_hook_from_string(hook)\n\n    with _post_import_hooks_lock:\n        # Automatically install the import hook finder if it has not already\n        # been installed.\n\n        global _post_import_hooks_init\n\n        if not _post_import_hooks_init:\n            _post_import_hooks_init = True\n            sys.meta_path.insert(0, ImportHookFinder())\n\n        # Check if the module is already imported. If not, register the hook\n        # to be called after import.\n\n        module = sys.modules.get(name, None)\n\n        if module is None:\n            _post_import_hooks.setdefault(name, []).append(hook)\n\n    # If the module is already imported, we fire the hook right away. Note that\n    # the hook is called outside of the lock to avoid deadlocks if code run as a\n    # consequence of calling the module import hook in turn triggers a separate\n    # thread which tries to register an import hook.\n\n    if module is not None:\n        hook(module)\n\n# Register post import hooks defined as package entry points.\n\ndef _create_import_hook_from_entrypoint(entrypoint):\n    def import_hook(module):\n        __import__(entrypoint.module_name)\n        callback = sys.modules[entrypoint.module_name]\n        for attr in entrypoint.attrs:\n            callback = getattr(callback, attr)\n        return callback(module)\n    return import_hook\n\ndef discover_post_import_hooks(group):\n    try:\n        import pkg_resources\n    except ImportError:\n        return\n\n    for entrypoint in pkg_resources.iter_entry_points(group=group):\n        callback = _create_import_hook_from_entrypoint(entrypoint)\n        register_post_import_hook(callback, entrypoint.name)\n\n# Indicate that a module has been loaded. Any post import hooks which\n# were registered against the target module will be invoked. If an\n# exception is raised in any of the post import hooks, that will cause\n# the import of the target module to fail.\n\ndef notify_module_loaded(module):\n    name = getattr(module, '__name__', None)\n\n    with _post_import_hooks_lock:\n        hooks = _post_import_hooks.pop(name, ())\n\n    # Note that the hook is called outside of the lock to avoid deadlocks if\n    # code run as a consequence of calling the module import hook in turn\n    # triggers a separate thread which tries to register an import hook.\n\n    for hook in hooks:\n        hook(module)\n\n# A custom module import finder. This intercepts attempts to import\n# modules and watches out for attempts to import target modules of\n# interest. When a module of interest is imported, then any post import\n# hooks which are registered will be invoked.\n\nclass _ImportHookLoader:\n\n    def load_module(self, fullname):\n        module = sys.modules[fullname]\n        notify_module_loaded(module)\n\n        return module\n\nclass _ImportHookChainedLoader(ObjectProxy):\n\n    def __init__(self, loader):\n        super(_ImportHookChainedLoader, self).__init__(loader)\n\n        if hasattr(loader, \"load_module\"):\n          self.__self_setattr__('load_module', self._self_load_module)\n        if hasattr(loader, \"create_module\"):\n          self.__self_setattr__('create_module', self._self_create_module)\n        if hasattr(loader, \"exec_module\"):\n          self.__self_setattr__('exec_module', self._self_exec_module)\n\n    def _self_set_loader(self, module):\n        # Set module's loader to self.__wrapped__ unless it's already set to\n        # something else. Import machinery will set it to spec.loader if it is\n        # None, so handle None as well. The module may not support attribute\n        # assignment, in which case we simply skip it. Note that we also deal\n        # with __loader__ not existing at all. This is to future proof things\n        # due to proposal to remove the attribue as described in the GitHub\n        # issue at https://github.com/python/cpython/issues/77458. Also prior\n        # to Python 3.3, the __loader__ attribute was only set if a custom\n        # module loader was used. It isn't clear whether the attribute still\n        # existed in that case or was set to None.\n\n        class UNDEFINED: pass\n\n        if getattr(module, \"__loader__\", UNDEFINED) in (None, self):\n            try:\n                module.__loader__ = self.__wrapped__\n            except AttributeError:\n                pass\n\n        if (getattr(module, \"__spec__\", None) is not None\n                and getattr(module.__spec__, \"loader\", None) is self):\n            module.__spec__.loader = self.__wrapped__\n\n    def _self_load_module(self, fullname):\n        module = self.__wrapped__.load_module(fullname)\n        self._self_set_loader(module)\n        notify_module_loaded(module)\n\n        return module\n\n    # Python 3.4 introduced create_module() and exec_module() instead of\n    # load_module() alone. Splitting the two steps.\n\n    def _self_create_module(self, spec):\n        return self.__wrapped__.create_module(spec)\n\n    def _self_exec_module(self, module):\n        self._self_set_loader(module)\n        self.__wrapped__.exec_module(module)\n        notify_module_loaded(module)\n\nclass ImportHookFinder:\n\n    def __init__(self):\n        self.in_progress = {}\n\n    def find_module(self, fullname, path=None):\n        # If the module being imported is not one we have registered\n        # post import hooks for, we can return immediately. We will\n        # take no further part in the importing of this module.\n\n        with _post_import_hooks_lock:\n            if fullname not in _post_import_hooks:\n                return None\n\n        # When we are interested in a specific module, we will call back\n        # into the import system a second time to defer to the import\n        # finder that is supposed to handle the importing of the module.\n        # We set an in progress flag for the target module so that on\n        # the second time through we don't trigger another call back\n        # into the import system and cause a infinite loop.\n\n        if fullname in self.in_progress:\n            return None\n\n        self.in_progress[fullname] = True\n\n        # Now call back into the import system again.\n\n        try:\n            if not find_spec:\n                # For Python 2 we don't have much choice but to\n                # call back in to __import__(). This will\n                # actually cause the module to be imported. If no\n                # module could be found then ImportError will be\n                # raised. Otherwise we return a loader which\n                # returns the already loaded module and invokes\n                # the post import hooks.\n\n                __import__(fullname)\n\n                return _ImportHookLoader()\n\n            else:\n                # For Python 3 we need to use find_spec().loader\n                # from the importlib.util module. It doesn't actually\n                # import the target module and only finds the\n                # loader. If a loader is found, we need to return\n                # our own loader which will then in turn call the\n                # real loader to import the module and invoke the\n                # post import hooks.\n\n                loader = getattr(find_spec(fullname), \"loader\", None)\n\n                if loader and not isinstance(loader, _ImportHookChainedLoader):\n                    return _ImportHookChainedLoader(loader)\n\n        finally:\n            del self.in_progress[fullname]\n\n    def find_spec(self, fullname, path=None, target=None):\n        # Since Python 3.4, you are meant to implement find_spec() method\n        # instead of find_module() and since Python 3.10 you get deprecation\n        # warnings if you don't define find_spec().\n\n        # If the module being imported is not one we have registered\n        # post import hooks for, we can return immediately. We will\n        # take no further part in the importing of this module.\n\n        with _post_import_hooks_lock:\n            if fullname not in _post_import_hooks:\n                return None\n\n        # When we are interested in a specific module, we will call back\n        # into the import system a second time to defer to the import\n        # finder that is supposed to handle the importing of the module.\n        # We set an in progress flag for the target module so that on\n        # the second time through we don't trigger another call back\n        # into the import system and cause a infinite loop.\n\n        if fullname in self.in_progress:\n            return None\n\n        self.in_progress[fullname] = True\n\n        # Now call back into the import system again.\n\n        try:\n            # This should only be Python 3 so find_spec() should always\n            # exist so don't need to check.\n\n            spec = find_spec(fullname)\n            loader = getattr(spec, \"loader\", None)\n\n            if loader and not isinstance(loader, _ImportHookChainedLoader):\n                spec.loader = _ImportHookChainedLoader(loader)\n\n            return spec\n\n        finally:\n            del self.in_progress[fullname]\n\n# Decorator for marking that a function should be called as a post\n# import hook when the target module is imported.\n\ndef when_imported(name):\n    def register(hook):\n        register_post_import_hook(hook, name)\n        return hook\n    return register\n", "src/wrapt/__wrapt__.py": "import os\n\nfrom .wrappers import (ObjectProxy, CallableObjectProxy,\n        PartialCallableObjectProxy, FunctionWrapper,\n        BoundFunctionWrapper, _FunctionWrapperBase)\n\ntry:\n    if not os.environ.get('WRAPT_DISABLE_EXTENSIONS'):\n        from ._wrappers import (ObjectProxy, CallableObjectProxy,\n            PartialCallableObjectProxy, FunctionWrapper,\n            BoundFunctionWrapper, _FunctionWrapperBase)\n\nexcept ImportError:\n    pass\n", "src/wrapt/wrappers.py": "import sys\nimport operator\nimport inspect\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})\n\nclass _ObjectProxyMethods(object):\n\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself\n    # via a meta class. In that way the properties will always take\n    # precedence.\n\n    @property\n    def __module__(self):\n        return self.__wrapped__.__module__\n\n    @__module__.setter\n    def __module__(self, value):\n        self.__wrapped__.__module__ = value\n\n    @property\n    def __doc__(self):\n        return self.__wrapped__.__doc__\n\n    @__doc__.setter\n    def __doc__(self, value):\n        self.__wrapped__.__doc__ = value\n\n    # We similar use a property for __dict__. We need __dict__ to be\n    # explicit to ensure that vars() works as expected.\n\n    @property\n    def __dict__(self):\n        return self.__wrapped__.__dict__\n\n    # Need to also propagate the special __weakref__ attribute for case\n    # where decorating classes which will define this. If do not define\n    # it and use a function like inspect.getmembers() on a decorator\n    # class it will fail. This can't be in the derived classes.\n\n    @property\n    def __weakref__(self):\n        return self.__wrapped__.__weakref__\n\nclass _ObjectProxyMetaType(type):\n    def __new__(cls, name, bases, dictionary):\n        # Copy our special properties into the class so that they\n        # always take precedence over attributes of the same name added\n        # during construction of a derived class. This is to save\n        # duplicating the implementation for them in all derived classes.\n\n        dictionary.update(vars(_ObjectProxyMethods))\n\n        return type.__new__(cls, name, bases, dictionary)\n\nclass ObjectProxy(with_metaclass(_ObjectProxyMetaType)):\n\n    __slots__ = '__wrapped__'\n\n    def __init__(self, wrapped):\n        object.__setattr__(self, '__wrapped__', wrapped)\n\n        # Python 3.2+ has the __qualname__ attribute, but it does not\n        # allow it to be overridden using a property and it must instead\n        # be an actual string object instead.\n\n        try:\n            object.__setattr__(self, '__qualname__', wrapped.__qualname__)\n        except AttributeError:\n            pass\n\n        # Python 3.10 onwards also does not allow itself to be overridden\n        # using a property and it must instead be set explicitly.\n\n        try:\n            object.__setattr__(self, '__annotations__', wrapped.__annotations__)\n        except AttributeError:\n            pass\n\n    def __self_setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n\n    @property\n    def __name__(self):\n        return self.__wrapped__.__name__\n\n    @__name__.setter\n    def __name__(self, value):\n        self.__wrapped__.__name__ = value\n\n    @property\n    def __class__(self):\n        return self.__wrapped__.__class__\n\n    @__class__.setter\n    def __class__(self, value):\n        self.__wrapped__.__class__ = value\n\n    def __dir__(self):\n        return dir(self.__wrapped__)\n\n    def __str__(self):\n        return str(self.__wrapped__)\n\n    if not PY2:\n        def __bytes__(self):\n            return bytes(self.__wrapped__)\n\n    def __repr__(self):\n        return '<{} at 0x{:x} for {} at 0x{:x}>'.format(\n                type(self).__name__, id(self),\n                type(self.__wrapped__).__name__,\n                id(self.__wrapped__))\n\n    def __reversed__(self):\n        return reversed(self.__wrapped__)\n\n    if not PY2:\n        def __round__(self):\n            return round(self.__wrapped__)\n\n    if sys.hexversion >= 0x03070000:\n        def __mro_entries__(self, bases):\n            return (self.__wrapped__,)\n\n    def __lt__(self, other):\n        return self.__wrapped__ < other\n\n    def __le__(self, other):\n        return self.__wrapped__ <= other\n\n    def __eq__(self, other):\n        return self.__wrapped__ == other\n\n    def __ne__(self, other):\n        return self.__wrapped__ != other\n\n    def __gt__(self, other):\n        return self.__wrapped__ > other\n\n    def __ge__(self, other):\n        return self.__wrapped__ >= other\n\n    def __hash__(self):\n        return hash(self.__wrapped__)\n\n    def __nonzero__(self):\n        return bool(self.__wrapped__)\n\n    def __bool__(self):\n        return bool(self.__wrapped__)\n\n    def __setattr__(self, name, value):\n        if name.startswith('_self_'):\n            object.__setattr__(self, name, value)\n\n        elif name == '__wrapped__':\n            object.__setattr__(self, name, value)\n            try:\n                object.__delattr__(self, '__qualname__')\n            except AttributeError:\n                pass\n            try:\n                object.__setattr__(self, '__qualname__', value.__qualname__)\n            except AttributeError:\n                pass\n            try:\n                object.__delattr__(self, '__annotations__')\n            except AttributeError:\n                pass\n            try:\n                object.__setattr__(self, '__annotations__', value.__annotations__)\n            except AttributeError:\n                pass\n\n        elif name == '__qualname__':\n            setattr(self.__wrapped__, name, value)\n            object.__setattr__(self, name, value)\n\n        elif name == '__annotations__':\n            setattr(self.__wrapped__, name, value)\n            object.__setattr__(self, name, value)\n\n        elif hasattr(type(self), name):\n            object.__setattr__(self, name, value)\n\n        else:\n            setattr(self.__wrapped__, name, value)\n\n    def __getattr__(self, name):\n        # If we are being to lookup '__wrapped__' then the\n        # '__init__()' method cannot have been called.\n\n        if name == '__wrapped__':\n            raise ValueError('wrapper has not been initialised')\n\n        return getattr(self.__wrapped__, name)\n\n    def __delattr__(self, name):\n        if name.startswith('_self_'):\n            object.__delattr__(self, name)\n\n        elif name == '__wrapped__':\n            raise TypeError('__wrapped__ must be an object')\n\n        elif name == '__qualname__':\n            object.__delattr__(self, name)\n            delattr(self.__wrapped__, name)\n\n        elif hasattr(type(self), name):\n            object.__delattr__(self, name)\n\n        else:\n            delattr(self.__wrapped__, name)\n\n    def __add__(self, other):\n        return self.__wrapped__ + other\n\n    def __sub__(self, other):\n        return self.__wrapped__ - other\n\n    def __mul__(self, other):\n        return self.__wrapped__ * other\n\n    def __div__(self, other):\n        return operator.div(self.__wrapped__, other)\n\n    def __truediv__(self, other):\n        return operator.truediv(self.__wrapped__, other)\n\n    def __floordiv__(self, other):\n        return self.__wrapped__ // other\n\n    def __mod__(self, other):\n        return self.__wrapped__ % other\n\n    def __divmod__(self, other):\n        return divmod(self.__wrapped__, other)\n\n    def __pow__(self, other, *args):\n        return pow(self.__wrapped__, other, *args)\n\n    def __lshift__(self, other):\n        return self.__wrapped__ << other\n\n    def __rshift__(self, other):\n        return self.__wrapped__ >> other\n\n    def __and__(self, other):\n        return self.__wrapped__ & other\n\n    def __xor__(self, other):\n        return self.__wrapped__ ^ other\n\n    def __or__(self, other):\n        return self.__wrapped__ | other\n\n    def __radd__(self, other):\n        return other + self.__wrapped__\n\n    def __rsub__(self, other):\n        return other - self.__wrapped__\n\n    def __rmul__(self, other):\n        return other * self.__wrapped__\n\n    def __rdiv__(self, other):\n        return operator.div(other, self.__wrapped__)\n\n    def __rtruediv__(self, other):\n        return operator.truediv(other, self.__wrapped__)\n\n    def __rfloordiv__(self, other):\n        return other // self.__wrapped__\n\n    def __rmod__(self, other):\n        return other % self.__wrapped__\n\n    def __rdivmod__(self, other):\n        return divmod(other, self.__wrapped__)\n\n    def __rpow__(self, other, *args):\n        return pow(other, self.__wrapped__, *args)\n\n    def __rlshift__(self, other):\n        return other << self.__wrapped__\n\n    def __rrshift__(self, other):\n        return other >> self.__wrapped__\n\n    def __rand__(self, other):\n        return other & self.__wrapped__\n\n    def __rxor__(self, other):\n        return other ^ self.__wrapped__\n\n    def __ror__(self, other):\n        return other | self.__wrapped__\n\n    def __iadd__(self, other):\n        self.__wrapped__ += other\n        return self\n\n    def __isub__(self, other):\n        self.__wrapped__ -= other\n        return self\n\n    def __imul__(self, other):\n        self.__wrapped__ *= other\n        return self\n\n    def __idiv__(self, other):\n        self.__wrapped__ = operator.idiv(self.__wrapped__, other)\n        return self\n\n    def __itruediv__(self, other):\n        self.__wrapped__ = operator.itruediv(self.__wrapped__, other)\n        return self\n\n    def __ifloordiv__(self, other):\n        self.__wrapped__ //= other\n        return self\n\n    def __imod__(self, other):\n        self.__wrapped__ %= other\n        return self\n\n    def __ipow__(self, other):\n        self.__wrapped__ **= other\n        return self\n\n    def __ilshift__(self, other):\n        self.__wrapped__ <<= other\n        return self\n\n    def __irshift__(self, other):\n        self.__wrapped__ >>= other\n        return self\n\n    def __iand__(self, other):\n        self.__wrapped__ &= other\n        return self\n\n    def __ixor__(self, other):\n        self.__wrapped__ ^= other\n        return self\n\n    def __ior__(self, other):\n        self.__wrapped__ |= other\n        return self\n\n    def __neg__(self):\n        return -self.__wrapped__\n\n    def __pos__(self):\n        return +self.__wrapped__\n\n    def __abs__(self):\n        return abs(self.__wrapped__)\n\n    def __invert__(self):\n        return ~self.__wrapped__\n\n    def __int__(self):\n        return int(self.__wrapped__)\n\n    def __long__(self):\n        return long(self.__wrapped__)\n\n    def __float__(self):\n        return float(self.__wrapped__)\n\n    def __complex__(self):\n        return complex(self.__wrapped__)\n\n    def __oct__(self):\n        return oct(self.__wrapped__)\n\n    def __hex__(self):\n        return hex(self.__wrapped__)\n\n    def __index__(self):\n        return operator.index(self.__wrapped__)\n\n    def __len__(self):\n        return len(self.__wrapped__)\n\n    def __contains__(self, value):\n        return value in self.__wrapped__\n\n    def __getitem__(self, key):\n        return self.__wrapped__[key]\n\n    def __setitem__(self, key, value):\n        self.__wrapped__[key] = value\n\n    def __delitem__(self, key):\n        del self.__wrapped__[key]\n\n    def __getslice__(self, i, j):\n        return self.__wrapped__[i:j]\n\n    def __setslice__(self, i, j, value):\n        self.__wrapped__[i:j] = value\n\n    def __delslice__(self, i, j):\n        del self.__wrapped__[i:j]\n\n    def __enter__(self):\n        return self.__wrapped__.__enter__()\n\n    def __exit__(self, *args, **kwargs):\n        return self.__wrapped__.__exit__(*args, **kwargs)\n\n    def __iter__(self):\n        return iter(self.__wrapped__)\n\n    def __copy__(self):\n        raise NotImplementedError('object proxy must define __copy__()')\n\n    def __deepcopy__(self, memo):\n        raise NotImplementedError('object proxy must define __deepcopy__()')\n\n    def __reduce__(self):\n        raise NotImplementedError(\n                'object proxy must define __reduce_ex__()')\n\n    def __reduce_ex__(self, protocol):\n        raise NotImplementedError(\n                'object proxy must define __reduce_ex__()')\n\nclass CallableObjectProxy(ObjectProxy):\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        return self.__wrapped__(*args, **kwargs)\n\nclass PartialCallableObjectProxy(ObjectProxy):\n\n    def __init__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        if len(args) < 1:\n            raise TypeError('partial type takes at least one argument')\n\n        wrapped, args = args[0], args[1:]\n\n        if not callable(wrapped):\n            raise TypeError('the first argument must be callable')\n\n        super(PartialCallableObjectProxy, self).__init__(wrapped)\n\n        self._self_args = args\n        self._self_kwargs = kwargs\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n    \n        _args = self._self_args + args\n\n        _kwargs = dict(self._self_kwargs)\n        _kwargs.update(kwargs)\n\n        return self.__wrapped__(*_args, **_kwargs)\n\nclass _FunctionWrapperBase(ObjectProxy):\n\n    __slots__ = ('_self_instance', '_self_wrapper', '_self_enabled',\n            '_self_binding', '_self_parent')\n\n    def __init__(self, wrapped, instance, wrapper, enabled=None,\n            binding='function', parent=None):\n\n        super(_FunctionWrapperBase, self).__init__(wrapped)\n\n        object.__setattr__(self, '_self_instance', instance)\n        object.__setattr__(self, '_self_wrapper', wrapper)\n        object.__setattr__(self, '_self_enabled', enabled)\n        object.__setattr__(self, '_self_binding', binding)\n        object.__setattr__(self, '_self_parent', parent)\n\n    def __get__(self, instance, owner):\n        # This method is actually doing double duty for both unbound and\n        # bound derived wrapper classes. It should possibly be broken up\n        # and the distinct functionality moved into the derived classes.\n        # Can't do that straight away due to some legacy code which is\n        # relying on it being here in this base class.\n        #\n        # The distinguishing attribute which determines whether we are\n        # being called in an unbound or bound wrapper is the parent\n        # attribute. If binding has never occurred, then the parent will\n        # be None.\n        #\n        # First therefore, is if we are called in an unbound wrapper. In\n        # this case we perform the binding.\n        #\n        # We have one special case to worry about here. This is where we\n        # are decorating a nested class. In this case the wrapped class\n        # would not have a __get__() method to call. In that case we\n        # simply return self.\n        #\n        # Note that we otherwise still do binding even if instance is\n        # None and accessing an unbound instance method from a class.\n        # This is because we need to be able to later detect that\n        # specific case as we will need to extract the instance from the\n        # first argument of those passed in.\n\n        if self._self_parent is None:\n            if not inspect.isclass(self.__wrapped__):\n                descriptor = self.__wrapped__.__get__(instance, owner)\n\n                return self.__bound_function_wrapper__(descriptor, instance,\n                        self._self_wrapper, self._self_enabled,\n                        self._self_binding, self)\n\n            return self\n\n        # Now we have the case of binding occurring a second time on what\n        # was already a bound function. In this case we would usually\n        # return ourselves again. This mirrors what Python does.\n        #\n        # The special case this time is where we were originally bound\n        # with an instance of None and we were likely an instance\n        # method. In that case we rebind against the original wrapped\n        # function from the parent again.\n\n        if self._self_instance is None and self._self_binding == 'function':\n            descriptor = self._self_parent.__wrapped__.__get__(\n                    instance, owner)\n\n            return self._self_parent.__bound_function_wrapper__(\n                    descriptor, instance, self._self_wrapper,\n                    self._self_enabled, self._self_binding,\n                    self._self_parent)\n\n        return self\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # If enabled has been specified, then evaluate it at this point\n        # and if the wrapper is not to be executed, then simply return\n        # the bound function rather than a bound wrapper for the bound\n        # function. When evaluating enabled, if it is callable we call\n        # it, otherwise we evaluate it as a boolean.\n\n        if self._self_enabled is not None:\n            if callable(self._self_enabled):\n                if not self._self_enabled():\n                    return self.__wrapped__(*args, **kwargs)\n            elif not self._self_enabled:\n                return self.__wrapped__(*args, **kwargs)\n\n        # This can occur where initial function wrapper was applied to\n        # a function that was already bound to an instance. In that case\n        # we want to extract the instance from the function and use it.\n\n        if self._self_binding in ('function', 'classmethod'):\n            if self._self_instance is None:\n                instance = getattr(self.__wrapped__, '__self__', None)\n                if instance is not None:\n                    return self._self_wrapper(self.__wrapped__, instance,\n                            args, kwargs)\n\n        # This is generally invoked when the wrapped function is being\n        # called as a normal function and is not bound to a class as an\n        # instance method. This is also invoked in the case where the\n        # wrapped function was a method, but this wrapper was in turn\n        # wrapped using the staticmethod decorator.\n\n        return self._self_wrapper(self.__wrapped__, self._self_instance,\n                args, kwargs)\n\n    def __set_name__(self, owner, name):\n        # This is a special method use to supply information to\n        # descriptors about what the name of variable in a class\n        # definition is. Not wanting to add this to ObjectProxy as not\n        # sure of broader implications of doing that. Thus restrict to\n        # FunctionWrapper used by decorators.\n\n        if hasattr(self.__wrapped__, \"__set_name__\"):\n            self.__wrapped__.__set_name__(owner, name)\n\n    def __instancecheck__(self, instance):\n        # This is a special method used by isinstance() to make checks\n        # instance of the `__wrapped__`.\n        return isinstance(instance, self.__wrapped__)\n\n    def __subclasscheck__(self, subclass):\n        # This is a special method used by issubclass() to make checks\n        # about inheritance of classes. We need to upwrap any object\n        # proxy. Not wanting to add this to ObjectProxy as not sure of\n        # broader implications of doing that. Thus restrict to\n        # FunctionWrapper used by decorators.\n\n        if hasattr(subclass, \"__wrapped__\"):\n            return issubclass(subclass.__wrapped__, self.__wrapped__)\n        else:\n            return issubclass(subclass, self.__wrapped__)\n\nclass BoundFunctionWrapper(_FunctionWrapperBase):\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # If enabled has been specified, then evaluate it at this point\n        # and if the wrapper is not to be executed, then simply return\n        # the bound function rather than a bound wrapper for the bound\n        # function. When evaluating enabled, if it is callable we call\n        # it, otherwise we evaluate it as a boolean.\n\n        if self._self_enabled is not None:\n            if callable(self._self_enabled):\n                if not self._self_enabled():\n                    return self.__wrapped__(*args, **kwargs)\n            elif not self._self_enabled:\n                return self.__wrapped__(*args, **kwargs)\n\n        # We need to do things different depending on whether we are\n        # likely wrapping an instance method vs a static method or class\n        # method.\n\n        if self._self_binding == 'function':\n            if self._self_instance is None:\n                # This situation can occur where someone is calling the\n                # instancemethod via the class type and passing the instance\n                # as the first argument. We need to shift the args before\n                # making the call to the wrapper and effectively bind the\n                # instance to the wrapped function using a partial so the\n                # wrapper doesn't see anything as being different.\n\n                if not args:\n                    raise TypeError('missing 1 required positional argument')\n\n                instance, args = args[0], args[1:]\n                wrapped = PartialCallableObjectProxy(self.__wrapped__, instance)\n                return self._self_wrapper(wrapped, instance, args, kwargs)\n\n            return self._self_wrapper(self.__wrapped__, self._self_instance,\n                    args, kwargs)\n\n        else:\n            # As in this case we would be dealing with a classmethod or\n            # staticmethod, then _self_instance will only tell us whether\n            # when calling the classmethod or staticmethod they did it via an\n            # instance of the class it is bound to and not the case where\n            # done by the class type itself. We thus ignore _self_instance\n            # and use the __self__ attribute of the bound function instead.\n            # For a classmethod, this means instance will be the class type\n            # and for a staticmethod it will be None. This is probably the\n            # more useful thing we can pass through even though we loose\n            # knowledge of whether they were called on the instance vs the\n            # class type, as it reflects what they have available in the\n            # decoratored function.\n\n            instance = getattr(self.__wrapped__, '__self__', None)\n\n            return self._self_wrapper(self.__wrapped__, instance, args,\n                    kwargs)\n\nclass FunctionWrapper(_FunctionWrapperBase):\n\n    __bound_function_wrapper__ = BoundFunctionWrapper\n\n    def __init__(self, wrapped, wrapper, enabled=None):\n        # What it is we are wrapping here could be anything. We need to\n        # try and detect specific cases though. In particular, we need\n        # to detect when we are given something that is a method of a\n        # class. Further, we need to know when it is likely an instance\n        # method, as opposed to a class or static method. This can\n        # become problematic though as there isn't strictly a fool proof\n        # method of knowing.\n        #\n        # The situations we could encounter when wrapping a method are:\n        #\n        # 1. The wrapper is being applied as part of a decorator which\n        # is a part of the class definition. In this case what we are\n        # given is the raw unbound function, classmethod or staticmethod\n        # wrapper objects.\n        #\n        # The problem here is that we will not know we are being applied\n        # in the context of the class being set up. This becomes\n        # important later for the case of an instance method, because in\n        # that case we just see it as a raw function and can't\n        # distinguish it from wrapping a normal function outside of\n        # a class context.\n        #\n        # 2. The wrapper is being applied when performing monkey\n        # patching of the class type afterwards and the method to be\n        # wrapped was retrieved direct from the __dict__ of the class\n        # type. This is effectively the same as (1) above.\n        #\n        # 3. The wrapper is being applied when performing monkey\n        # patching of the class type afterwards and the method to be\n        # wrapped was retrieved from the class type. In this case\n        # binding will have been performed where the instance against\n        # which the method is bound will be None at that point.\n        #\n        # This case is a problem because we can no longer tell if the\n        # method was a static method, plus if using Python3, we cannot\n        # tell if it was an instance method as the concept of an\n        # unnbound method no longer exists.\n        #\n        # 4. The wrapper is being applied when performing monkey\n        # patching of an instance of a class. In this case binding will\n        # have been perfomed where the instance was not None.\n        #\n        # This case is a problem because we can no longer tell if the\n        # method was a static method.\n        #\n        # Overall, the best we can do is look at the original type of the\n        # object which was wrapped prior to any binding being done and\n        # see if it is an instance of classmethod or staticmethod. In\n        # the case where other decorators are between us and them, if\n        # they do not propagate the __class__  attribute so that the\n        # isinstance() checks works, then likely this will do the wrong\n        # thing where classmethod and staticmethod are used.\n        #\n        # Since it is likely to be very rare that anyone even puts\n        # decorators around classmethod and staticmethod, likelihood of\n        # that being an issue is very small, so we accept it and suggest\n        # that those other decorators be fixed. It is also only an issue\n        # if a decorator wants to actually do things with the arguments.\n        #\n        # As to not being able to identify static methods properly, we\n        # just hope that that isn't something people are going to want\n        # to wrap, or if they do suggest they do it the correct way by\n        # ensuring that it is decorated in the class definition itself,\n        # or patch it in the __dict__ of the class type.\n        #\n        # So to get the best outcome we can, whenever we aren't sure what\n        # it is, we label it as a 'function'. If it was already bound and\n        # that is rebound later, we assume that it will be an instance\n        # method and try an cope with the possibility that the 'self'\n        # argument it being passed as an explicit argument and shuffle\n        # the arguments around to extract 'self' for use as the instance.\n\n        if isinstance(wrapped, classmethod):\n            binding = 'classmethod'\n\n        elif isinstance(wrapped, staticmethod):\n            binding = 'staticmethod'\n\n        elif hasattr(wrapped, '__self__'):\n            if inspect.isclass(wrapped.__self__):\n                binding = 'classmethod'\n            else:\n                binding = 'function'\n\n        else:\n            binding = 'function'\n\n        super(FunctionWrapper, self).__init__(wrapped, None, wrapper,\n                enabled, binding)\n", "src/wrapt/patches.py": "import inspect\nimport sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n\nfrom .__wrapt__ import FunctionWrapper\n\n# Helper functions for applying wrappers to existing functions.\n\ndef resolve_path(module, name):\n    if isinstance(module, string_types):\n        __import__(module)\n        module = sys.modules[module]\n\n    parent = module\n\n    path = name.split('.')\n    attribute = path[0]\n\n    # We can't just always use getattr() because in doing\n    # that on a class it will cause binding to occur which\n    # will complicate things later and cause some things not\n    # to work. For the case of a class we therefore access\n    # the __dict__ directly. To cope though with the wrong\n    # class being given to us, or a method being moved into\n    # a base class, we need to walk the class hierarchy to\n    # work out exactly which __dict__ the method was defined\n    # in, as accessing it from __dict__ will fail if it was\n    # not actually on the class given. Fallback to using\n    # getattr() if we can't find it. If it truly doesn't\n    # exist, then that will fail.\n\n    def lookup_attribute(parent, attribute):\n        if inspect.isclass(parent):\n            for cls in inspect.getmro(parent):\n                if attribute in vars(cls):\n                    return vars(cls)[attribute]\n            else:\n                return getattr(parent, attribute)\n        else:\n            return getattr(parent, attribute)\n\n    original = lookup_attribute(parent, attribute)\n\n    for attribute in path[1:]:\n        parent = original\n        original = lookup_attribute(parent, attribute)\n\n    return (parent, attribute, original)\n\ndef apply_patch(parent, attribute, replacement):\n    setattr(parent, attribute, replacement)\n\ndef wrap_object(module, name, factory, args=(), kwargs={}):\n    (parent, attribute, original) = resolve_path(module, name)\n    wrapper = factory(original, *args, **kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n\n# Function for applying a proxy object to an attribute of a class\n# instance. The wrapper works by defining an attribute of the same name\n# on the class which is a descriptor and which intercepts access to the\n# instance attribute. Note that this cannot be used on attributes which\n# are themselves defined by a property object.\n\nclass AttributeWrapper(object):\n\n    def __init__(self, attribute, factory, args, kwargs):\n        self.attribute = attribute\n        self.factory = factory\n        self.args = args\n        self.kwargs = kwargs\n\n    def __get__(self, instance, owner):\n        value = instance.__dict__[self.attribute]\n        return self.factory(value, *self.args, **self.kwargs)\n\n    def __set__(self, instance, value):\n        instance.__dict__[self.attribute] = value\n\n    def __delete__(self, instance):\n        del instance.__dict__[self.attribute]\n\ndef wrap_object_attribute(module, name, factory, args=(), kwargs={}):\n    path, attribute = name.rsplit('.', 1)\n    parent = resolve_path(module, path)[2]\n    wrapper = AttributeWrapper(attribute, factory, args, kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n\n# Functions for creating a simple decorator using a FunctionWrapper,\n# plus short cut functions for applying wrappers to functions. These are\n# for use when doing monkey patching. For a more featured way of\n# creating decorators see the decorator decorator instead.\n\ndef function_wrapper(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        target_wrapped = args[0]\n        if instance is None:\n            target_wrapper = wrapper\n        elif inspect.isclass(instance):\n            target_wrapper = wrapper.__get__(None, instance)\n        else:\n            target_wrapper = wrapper.__get__(instance, type(instance))\n        return FunctionWrapper(target_wrapped, target_wrapper)\n    return FunctionWrapper(wrapper, _wrapper)\n\ndef wrap_function_wrapper(module, name, wrapper):\n    return wrap_object(module, name, FunctionWrapper, (wrapper,))\n\ndef patch_function_wrapper(module, name, enabled=None):\n    def _wrapper(wrapper):\n        return wrap_object(module, name, FunctionWrapper, (wrapper, enabled))\n    return _wrapper\n\ndef transient_function_wrapper(module, name):\n    def _decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            target_wrapped = args[0]\n            if instance is None:\n                target_wrapper = wrapper\n            elif inspect.isclass(instance):\n                target_wrapper = wrapper.__get__(None, instance)\n            else:\n                target_wrapper = wrapper.__get__(instance, type(instance))\n            def _execute(wrapped, instance, args, kwargs):\n                (parent, attribute, original) = resolve_path(module, name)\n                replacement = FunctionWrapper(original, target_wrapper)\n                setattr(parent, attribute, replacement)\n                try:\n                    return wrapped(*args, **kwargs)\n                finally:\n                    setattr(parent, attribute, original)\n            return FunctionWrapper(target_wrapped, _execute)\n        return FunctionWrapper(wrapper, _wrapper)\n    return _decorator\n", "src/wrapt/decorators.py": "\"\"\"This module implements decorators for implementing other decorators\nas well as some commonly used decorators.\n\n\"\"\"\n\nimport sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\n\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\nelse:\n    string_types = str,\n\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n    del builtins\n\nfrom functools import partial\nfrom inspect import isclass\nfrom threading import Lock, RLock\n\nfrom .arguments import formatargspec\n\ntry:\n    from inspect import signature\nexcept ImportError:\n    pass\n\nfrom .__wrapt__ import (FunctionWrapper, BoundFunctionWrapper, ObjectProxy,\n    CallableObjectProxy)\n\n# Adapter wrapper for the wrapped function which will overlay certain\n# properties from the adapter function onto the wrapped function so that\n# functions such as inspect.getargspec(), inspect.getfullargspec(),\n# inspect.signature() and inspect.getsource() return the correct results\n# one would expect.\n\nclass _AdapterFunctionCode(CallableObjectProxy):\n\n    def __init__(self, wrapped_code, adapter_code):\n        super(_AdapterFunctionCode, self).__init__(wrapped_code)\n        self._self_adapter_code = adapter_code\n\n    @property\n    def co_argcount(self):\n        return self._self_adapter_code.co_argcount\n\n    @property\n    def co_code(self):\n        return self._self_adapter_code.co_code\n\n    @property\n    def co_flags(self):\n        return self._self_adapter_code.co_flags\n\n    @property\n    def co_kwonlyargcount(self):\n        return self._self_adapter_code.co_kwonlyargcount\n\n    @property\n    def co_varnames(self):\n        return self._self_adapter_code.co_varnames\n\nclass _AdapterFunctionSurrogate(CallableObjectProxy):\n\n    def __init__(self, wrapped, adapter):\n        super(_AdapterFunctionSurrogate, self).__init__(wrapped)\n        self._self_adapter = adapter\n\n    @property\n    def __code__(self):\n        return _AdapterFunctionCode(self.__wrapped__.__code__,\n                self._self_adapter.__code__)\n\n    @property\n    def __defaults__(self):\n        return self._self_adapter.__defaults__\n\n    @property\n    def __kwdefaults__(self):\n        return self._self_adapter.__kwdefaults__\n\n    @property\n    def __signature__(self):\n        if 'signature' not in globals():\n            return self._self_adapter.__signature__\n        else:\n            return signature(self._self_adapter)\n\n    if PY2:\n        func_code = __code__\n        func_defaults = __defaults__\n\nclass _BoundAdapterWrapper(BoundFunctionWrapper):\n\n    @property\n    def __func__(self):\n        return _AdapterFunctionSurrogate(self.__wrapped__.__func__,\n                self._self_parent._self_adapter)\n\n    @property\n    def __signature__(self):\n        if 'signature' not in globals():\n            return self.__wrapped__.__signature__\n        else:\n            return signature(self._self_parent._self_adapter)\n\n    if PY2:\n        im_func = __func__\n\nclass AdapterWrapper(FunctionWrapper):\n\n    __bound_function_wrapper__ = _BoundAdapterWrapper\n\n    def __init__(self, *args, **kwargs):\n        adapter = kwargs.pop('adapter')\n        super(AdapterWrapper, self).__init__(*args, **kwargs)\n        self._self_surrogate = _AdapterFunctionSurrogate(\n                self.__wrapped__, adapter)\n        self._self_adapter = adapter\n\n    @property\n    def __code__(self):\n        return self._self_surrogate.__code__\n\n    @property\n    def __defaults__(self):\n        return self._self_surrogate.__defaults__\n\n    @property\n    def __kwdefaults__(self):\n        return self._self_surrogate.__kwdefaults__\n\n    if PY2:\n        func_code = __code__\n        func_defaults = __defaults__\n\n    @property\n    def __signature__(self):\n        return self._self_surrogate.__signature__\n\nclass AdapterFactory(object):\n    def __call__(self, wrapped):\n        raise NotImplementedError()\n\nclass DelegatedAdapterFactory(AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\n\nadapter_factory = DelegatedAdapterFactory\n\n# Decorator for creating other decorators. This decorator and the\n# wrappers which they use are designed to properly preserve any name\n# attributes, function signatures etc, in addition to the wrappers\n# themselves acting like a transparent proxy for the original wrapped\n# function so the wrapper is effectively indistinguishable from the\n# original wrapped function.\n\ndef decorator(wrapper=None, enabled=None, adapter=None, proxy=FunctionWrapper):\n    # The decorator should be supplied with a single positional argument\n    # which is the wrapper function to be used to implement the\n    # decorator. This may be preceded by a step whereby the keyword\n    # arguments are supplied to customise the behaviour of the\n    # decorator. The 'adapter' argument is used to optionally denote a\n    # separate function which is notionally used by an adapter\n    # decorator. In that case parts of the function '__code__' and\n    # '__defaults__' attributes are used from the adapter function\n    # rather than those of the wrapped function. This allows for the\n    # argument specification from inspect.getfullargspec() and similar\n    # functions to be overridden with a prototype for a different\n    # function than what was wrapped. The 'enabled' argument provides a\n    # way to enable/disable the use of the decorator. If the type of\n    # 'enabled' is a boolean, then it is evaluated immediately and the\n    # wrapper not even applied if it is False. If not a boolean, it will\n    # be evaluated when the wrapper is called for an unbound wrapper,\n    # and when binding occurs for a bound wrapper. When being evaluated,\n    # if 'enabled' is callable it will be called to obtain the value to\n    # be checked. If False, the wrapper will not be called and instead\n    # the original wrapped function will be called directly instead.\n    # The 'proxy' argument provides a way of passing a custom version of\n    # the FunctionWrapper class used in decorating the function.\n\n    if wrapper is not None:\n        # Helper function for creating wrapper of the appropriate\n        # time when we need it down below.\n\n        def _build(wrapped, wrapper, enabled=None, adapter=None):\n            if adapter:\n                if isinstance(adapter, AdapterFactory):\n                    adapter = adapter(wrapped)\n\n                if not callable(adapter):\n                    ns = {}\n\n                    # Check if the signature argument specification has\n                    # annotations. If it does then we need to remember\n                    # it but also drop it when attempting to manufacture\n                    # a standin adapter function. This is necessary else\n                    # it will try and look up any types referenced in\n                    # the annotations in the empty namespace we use,\n                    # which will fail.\n\n                    annotations = {}\n\n                    if not isinstance(adapter, string_types):\n                        if len(adapter) == 7:\n                            annotations = adapter[-1]\n                            adapter = adapter[:-1]\n                        adapter = formatargspec(*adapter)\n\n                    exec_('def adapter{}: pass'.format(adapter), ns, ns)\n                    adapter = ns['adapter']\n\n                    # Override the annotations for the manufactured\n                    # adapter function so they match the original\n                    # adapter signature argument specification.\n\n                    if annotations:\n                        adapter.__annotations__ = annotations\n\n                return AdapterWrapper(wrapped=wrapped, wrapper=wrapper,\n                        enabled=enabled, adapter=adapter)\n\n            return proxy(wrapped=wrapped, wrapper=wrapper, enabled=enabled)\n\n        # The wrapper has been provided so return the final decorator.\n        # The decorator is itself one of our function wrappers so we\n        # can determine when it is applied to functions, instance methods\n        # or class methods. This allows us to bind the instance or class\n        # method so the appropriate self or cls attribute is supplied\n        # when it is finally called.\n\n        def _wrapper(wrapped, instance, args, kwargs):\n            # We first check for the case where the decorator was applied\n            # to a class type.\n            #\n            #     @decorator\n            #     class mydecoratorclass(object):\n            #         def __init__(self, arg=None):\n            #             self.arg = arg\n            #         def __call__(self, wrapped, instance, args, kwargs):\n            #             return wrapped(*args, **kwargs)\n            #\n            #     @mydecoratorclass(arg=1)\n            #     def function():\n            #         pass\n            #\n            # In this case an instance of the class is to be used as the\n            # decorator wrapper function. If args was empty at this point,\n            # then it means that there were optional keyword arguments\n            # supplied to be used when creating an instance of the class\n            # to be used as the wrapper function.\n\n            if instance is None and isclass(wrapped) and not args:\n                # We still need to be passed the target function to be\n                # wrapped as yet, so we need to return a further function\n                # to be able to capture it.\n\n                def _capture(target_wrapped):\n                    # Now have the target function to be wrapped and need\n                    # to create an instance of the class which is to act\n                    # as the decorator wrapper function. Before we do that,\n                    # we need to first check that use of the decorator\n                    # hadn't been disabled by a simple boolean. If it was,\n                    # the target function to be wrapped is returned instead.\n\n                    _enabled = enabled\n                    if type(_enabled) is bool:\n                        if not _enabled:\n                            return target_wrapped\n                        _enabled = None\n\n                    # Now create an instance of the class which is to act\n                    # as the decorator wrapper function. Any arguments had\n                    # to be supplied as keyword only arguments so that is\n                    # all we pass when creating it.\n\n                    target_wrapper = wrapped(**kwargs)\n\n                    # Finally build the wrapper itself and return it.\n\n                    return _build(target_wrapped, target_wrapper,\n                            _enabled, adapter)\n\n                return _capture\n\n            # We should always have the target function to be wrapped at\n            # this point as the first (and only) value in args.\n\n            target_wrapped = args[0]\n\n            # Need to now check that use of the decorator hadn't been\n            # disabled by a simple boolean. If it was, then target\n            # function to be wrapped is returned instead.\n\n            _enabled = enabled\n            if type(_enabled) is bool:\n                if not _enabled:\n                    return target_wrapped\n                _enabled = None\n\n            # We now need to build the wrapper, but there are a couple of\n            # different cases we need to consider.\n\n            if instance is None:\n                if isclass(wrapped):\n                    # In this case the decorator was applied to a class\n                    # type but optional keyword arguments were not supplied\n                    # for initialising an instance of the class to be used\n                    # as the decorator wrapper function.\n                    #\n                    #     @decorator\n                    #     class mydecoratorclass(object):\n                    #         def __init__(self, arg=None):\n                    #             self.arg = arg\n                    #         def __call__(self, wrapped, instance,\n                    #                 args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     @mydecoratorclass\n                    #     def function():\n                    #         pass\n                    #\n                    # We still need to create an instance of the class to\n                    # be used as the decorator wrapper function, but no\n                    # arguments are pass.\n\n                    target_wrapper = wrapped()\n\n                else:\n                    # In this case the decorator was applied to a normal\n                    # function, or possibly a static method of a class.\n                    #\n                    #     @decorator\n                    #     def mydecoratorfuntion(wrapped, instance,\n                    #             args, kwargs):\n                    #         return wrapped(*args, **kwargs)\n                    #\n                    #     @mydecoratorfunction\n                    #     def function():\n                    #         pass\n                    #\n                    # That normal function becomes the decorator wrapper\n                    # function.\n\n                    target_wrapper = wrapper\n\n            else:\n                if isclass(instance):\n                    # In this case the decorator was applied to a class\n                    # method.\n                    #\n                    #     class myclass(object):\n                    #         @decorator\n                    #         @classmethod\n                    #         def decoratorclassmethod(cls, wrapped,\n                    #                 instance, args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     instance = myclass()\n                    #\n                    #     @instance.decoratorclassmethod\n                    #     def function():\n                    #         pass\n                    #\n                    # This one is a bit strange because binding was actually\n                    # performed on the wrapper created by our decorator\n                    # factory. We need to apply that binding to the decorator\n                    # wrapper function that the decorator factory\n                    # was applied to.\n\n                    target_wrapper = wrapper.__get__(None, instance)\n\n                else:\n                    # In this case the decorator was applied to an instance\n                    # method.\n                    #\n                    #     class myclass(object):\n                    #         @decorator\n                    #         def decoratorclassmethod(self, wrapped,\n                    #                 instance, args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     instance = myclass()\n                    #\n                    #     @instance.decoratorclassmethod\n                    #     def function():\n                    #         pass\n                    #\n                    # This one is a bit strange because binding was actually\n                    # performed on the wrapper created by our decorator\n                    # factory. We need to apply that binding to the decorator\n                    # wrapper function that the decorator factory\n                    # was applied to.\n\n                    target_wrapper = wrapper.__get__(instance, type(instance))\n\n            # Finally build the wrapper itself and return it.\n\n            return _build(target_wrapped, target_wrapper, _enabled, adapter)\n\n        # We first return our magic function wrapper here so we can\n        # determine in what context the decorator factory was used. In\n        # other words, it is itself a universal decorator. The decorator\n        # function is used as the adapter so that linters see a signature\n        # corresponding to the decorator and not the wrapper it is being\n        # applied to.\n\n        return _build(wrapper, _wrapper, adapter=decorator)\n\n    else:\n        # The wrapper still has not been provided, so we are just\n        # collecting the optional keyword arguments. Return the\n        # decorator again wrapped in a partial using the collected\n        # arguments.\n\n        return partial(decorator, enabled=enabled, adapter=adapter,\n                proxy=proxy)\n\n# Decorator for implementing thread synchronization. It can be used as a\n# decorator, in which case the synchronization context is determined by\n# what type of function is wrapped, or it can also be used as a context\n# manager, where the user needs to supply the correct synchronization\n# context. It is also possible to supply an object which appears to be a\n# synchronization primitive of some sort, by virtue of having release()\n# and acquire() methods. In that case that will be used directly as the\n# synchronization primitive without creating a separate lock against the\n# derived or supplied context.\n\ndef synchronized(wrapped):\n    # Determine if being passed an object which is a synchronization\n    # primitive. We can't check by type for Lock, RLock, Semaphore etc,\n    # as the means of creating them isn't the type. Therefore use the\n    # existence of acquire() and release() methods. This is more\n    # extensible anyway as it allows custom synchronization mechanisms.\n\n    if hasattr(wrapped, 'acquire') and hasattr(wrapped, 'release'):\n        # We remember what the original lock is and then return a new\n        # decorator which accesses and locks it. When returning the new\n        # decorator we wrap it with an object proxy so we can override\n        # the context manager methods in case it is being used to wrap\n        # synchronized statements with a 'with' statement.\n\n        lock = wrapped\n\n        @decorator\n        def _synchronized(wrapped, instance, args, kwargs):\n            # Execute the wrapped function while the original supplied\n            # lock is held.\n\n            with lock:\n                return wrapped(*args, **kwargs)\n\n        class _PartialDecorator(CallableObjectProxy):\n\n            def __enter__(self):\n                lock.acquire()\n                return lock\n\n            def __exit__(self, *args):\n                lock.release()\n\n        return _PartialDecorator(wrapped=_synchronized)\n\n    # Following only apply when the lock is being created automatically\n    # based on the context of what was supplied. In this case we supply\n    # a final decorator, but need to use FunctionWrapper directly as we\n    # want to derive from it to add context manager methods in case it is\n    # being used to wrap synchronized statements with a 'with' statement.\n\n    def _synchronized_lock(context):\n        # Attempt to retrieve the lock for the specific context.\n\n        lock = vars(context).get('_synchronized_lock', None)\n\n        if lock is None:\n            # There is no existing lock defined for the context we\n            # are dealing with so we need to create one. This needs\n            # to be done in a way to guarantee there is only one\n            # created, even if multiple threads try and create it at\n            # the same time. We can't always use the setdefault()\n            # method on the __dict__ for the context. This is the\n            # case where the context is a class, as __dict__ is\n            # actually a dictproxy. What we therefore do is use a\n            # meta lock on this wrapper itself, to control the\n            # creation and assignment of the lock attribute against\n            # the context.\n\n            with synchronized._synchronized_meta_lock:\n                # We need to check again for whether the lock we want\n                # exists in case two threads were trying to create it\n                # at the same time and were competing to create the\n                # meta lock.\n\n                lock = vars(context).get('_synchronized_lock', None)\n\n                if lock is None:\n                    lock = RLock()\n                    setattr(context, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        # Execute the wrapped function while the lock for the\n        # desired context is held. If instance is None then the\n        # wrapped function is used as the context.\n\n        with _synchronized_lock(instance if instance is not None else wrapped):\n            return wrapped(*args, **kwargs)\n\n    class _FinalDecorator(FunctionWrapper):\n\n        def __enter__(self):\n            self._self_lock = _synchronized_lock(self.__wrapped__)\n            self._self_lock.acquire()\n            return self._self_lock\n\n        def __exit__(self, *args):\n            self._self_lock.release()\n\n    return _FinalDecorator(wrapped=wrapped, wrapper=_synchronized_wrapper)\n\nsynchronized._synchronized_meta_lock = Lock()\n", "src/wrapt/arguments.py": "# The inspect.formatargspec() function was dropped in Python 3.11 but we need\n# need it for when constructing signature changing decorators based on result of\n# inspect.getargspec() or inspect.getfullargspec(). The code here implements\n# inspect.formatargspec() base on Parameter and Signature from inspect module,\n# which were added in Python 3.6. Thanks to Cyril Jouve for the implementation.\n\ntry:\n    from inspect import Parameter, Signature\nexcept ImportError:\n    from inspect import formatargspec\nelse:\n    def formatargspec(args, varargs=None, varkw=None, defaults=None,\n                      kwonlyargs=(), kwonlydefaults={}, annotations={}):\n        if kwonlydefaults is None:\n            kwonlydefaults = {}\n        ndefaults = len(defaults) if defaults else 0\n        parameters = [\n            Parameter(\n                arg,\n                Parameter.POSITIONAL_OR_KEYWORD,\n                default=defaults[i] if i >= 0 else Parameter.empty,\n                annotation=annotations.get(arg, Parameter.empty),\n            ) for i, arg in enumerate(args, ndefaults - len(args))\n        ]\n        if varargs:\n            parameters.append(Parameter(varargs, Parameter.VAR_POSITIONAL))\n        parameters.extend(\n            Parameter(\n                kwonlyarg,\n                Parameter.KEYWORD_ONLY,\n                default=kwonlydefaults.get(kwonlyarg, Parameter.empty),\n                annotation=annotations.get(kwonlyarg, Parameter.empty),\n            ) for kwonlyarg in kwonlyargs\n        )\n        if varkw:\n            parameters.append(Parameter(varkw, Parameter.VAR_KEYWORD))\n        return_annotation = annotations.get('return', Signature.empty)\n        return str(Signature(parameters, return_annotation=return_annotation))", "src/wrapt/__init__.py": "__version_info__ = ('1', '16', '0')\n__version__ = '.'.join(__version_info__)\n\nfrom .__wrapt__ import (ObjectProxy, CallableObjectProxy, FunctionWrapper,\n        BoundFunctionWrapper, PartialCallableObjectProxy)\n\nfrom .patches import (resolve_path, apply_patch, wrap_object, wrap_object_attribute,\n        function_wrapper, wrap_function_wrapper, patch_function_wrapper,\n        transient_function_wrapper)\n\nfrom .weakrefs import WeakFunctionProxy\n\nfrom .decorators import (adapter_factory, AdapterFactory, decorator,\n        synchronized)\n\nfrom .importer import (register_post_import_hook, when_imported,\n        notify_module_loaded, discover_post_import_hooks)\n\n# Import of inspect.getcallargs() included for backward compatibility. An\n# implementation of this was previously bundled and made available here for\n# Python <2.7. Avoid using this in future.\n\nfrom inspect import getcallargs\n\n# Variant of inspect.formatargspec() included here for forward compatibility.\n# This is being done because Python 3.11 dropped inspect.formatargspec() but\n# code for handling signature changing decorators relied on it. Exposing the\n# bundled implementation here in case any user of wrapt was also needing it.\n\nfrom .arguments import formatargspec\n"}