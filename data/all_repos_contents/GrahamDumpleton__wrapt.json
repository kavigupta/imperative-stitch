{"setup.py": "import os\nimport sys\nimport platform\nimport setuptools\n\n\n# # --- Detect if extensions should be disabled ------------------------------\n\nwrapt_env = os.environ.get('WRAPT_INSTALL_EXTENSIONS')\n\nif wrapt_env is None:\n    wrapt_env = os.environ.get('WRAPT_EXTENSIONS')\n\nif wrapt_env is not None:\n    disable_extensions = wrapt_env.lower() == 'false'\n    force_extensions = wrapt_env.lower() == 'true'\nelse:\n    if platform.system() == 'Windows' and sys.version_info[0] < 3:\n      disable_extensions = True\n      force_extensions = False\n    else:\n      disable_extensions = False\n      force_extensions = False\n\nif platform.python_implementation() != \"CPython\":\n    disable_extensions = True\n\n# --- C extension ------------------------------------------------------------\n\nextensions = [\n    setuptools.Extension(\n        \"wrapt._wrappers\",\n        sources=[\"src/wrapt/_wrappers.c\"],\n        optional=not force_extensions,\n    )\n]\n\n\n# --- Setup ------------------------------------------------------------------\n\nsetuptools.setup(\n    ext_modules=[] if disable_extensions else extensions\n)\n", "docs/conf.py": "# -*- coding: utf-8 -*-\n#\n# wrapt documentation build configuration file, created by\n# sphinx-quickstart on Tue Aug 13 20:38:04 2013.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration -----------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = []\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'wrapt'\ncopyright = u'2013-2023, Graham Dumpleton'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '1.16'\n# The full version, including alpha/beta/rc tags.\nrelease = '1.16.0'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nimport sphinx_rtd_theme\nhtml_theme = 'sphinx_rtd_theme'\nhtml_theme_path = [sphinx_rtd_theme.get_html_theme_path()]\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'wraptdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'wrapt.tex', u'wrapt Documentation',\n   u'Graham Dumpleton', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output --------------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'wrapt', u'wrapt Documentation',\n     [u'Graham Dumpleton'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output ------------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'wrapt', u'wrapt Documentation',\n   u'Graham Dumpleton', 'wrapt', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n", "docs/benchmarks.py": "import wrapt  # https://pypi.python.org/pypi/wrapt\nimport decorator  # https://pypi.python.org/pypi/decorator\n\ndef function1():\n    pass\n\ndef wrapper2(func):\n    def _wrapper2(*args, **kwargs):\n        return func(*args, **kwargs)\n    return _wrapper2\n\n@wrapper2\ndef function2():\n    pass\n\n@wrapt.decorator\ndef wrapper3(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\n@wrapper3\ndef function3():\n    pass\n\n@decorator.decorator\ndef wrapper4(wrapped, *args, **kwargs):\n    return wrapped(*args, **kwargs)\n\n@wrapper4\ndef function4():\n    pass\n\nclass Class(object):\n\n    def function1(self):\n        pass\n\n    @classmethod\n    def function1cm(cls):\n        pass\n\n    @staticmethod\n    def function1sm():\n        pass\n\n    @wrapper2\n    def function2(self):\n        pass\n\n    @classmethod\n    @wrapper2\n    def function2cmi(cls):\n        pass\n\n    @staticmethod\n    @wrapper2\n    def function2smi():\n        pass\n\n    @wrapper3\n    def function3(self):\n        pass\n\n    @wrapper3\n    @classmethod\n    def function3cmo(cls):\n        pass\n\n    @classmethod\n    @wrapper3\n    def function3cmi(cls):\n        pass\n\n    @wrapper3\n    @staticmethod\n    def function3smo():\n        pass\n\n    @staticmethod\n    @wrapper3\n    def function3smi():\n        pass\n\n    @wrapper4\n    def function4(self):\n        pass\n\n    @classmethod\n    @wrapper4\n    def function4cmi(cls):\n        pass\n\n    @staticmethod\n    @wrapper4\n    def function4smi():\n        pass\n", "tests/test_instancemethod.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass OldClass1():\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOldClass1o = OldClass1\n\nclass OldClass1():\n    @decorators.passthru_decorator\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOldClass1d = OldClass1\n\nclass TestNamingInstanceMethodOldStyle(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(OldClass1d.function.__name__,\n                OldClass1o.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(OldClass1d().function.__name__,\n                OldClass1o().function.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = OldClass1o.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(OldClass1d.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = OldClass1o().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(OldClass1d().function.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(OldClass1d.function.__module__,\n                OldClass1o.function.__module__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(OldClass1d().function.__module__,\n                OldClass1o().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(OldClass1d.function.__doc__,\n                OldClass1o.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(OldClass1d().function.__doc__,\n                OldClass1o().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(OldClass1o.function)\n        function_argspec = getfullargspec(OldClass1d.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(OldClass1o().function)\n        function_argspec = getfullargspec(OldClass1d().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_getmembers(self):\n        original_members = inspect.getmembers(OldClass1o().function)\n        function_members = inspect.getmembers(OldClass1d().function)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(OldClass1d.function,\n                type(OldClass1o.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(OldClass1d().function,\n                type(OldClass1o().function)))\n\nclass NewClass1(object):\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nNewClass1o = NewClass1\n\nclass NewClass1(object):\n    @decorators.passthru_decorator\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nNewClass1d = NewClass1\n\nclass TestNamingInstanceMethodNewStyle(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(NewClass1d.function.__name__,\n                NewClass1o.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(NewClass1d().function.__name__,\n                NewClass1o().function.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = NewClass1o.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(NewClass1d.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = NewClass1o().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(NewClass1d().function.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(NewClass1d.function.__module__,\n                NewClass1o.function.__module__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(NewClass1d().function.__module__,\n                NewClass1o().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(NewClass1d.function.__doc__,\n                NewClass1o.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(NewClass1d().function.__doc__,\n                NewClass1o().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(NewClass1o.function)\n        function_argspec = getfullargspec(NewClass1d.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(NewClass1o().function)\n        function_argspec = getfullargspec(NewClass1d().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(NewClass1d.function,\n                type(NewClass1o.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(NewClass1d().function,\n                type(NewClass1o().function)))\n\nclass TestCallingInstanceMethodOldStyle(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling instancemethod via class and passing in the class\n        # instance directly.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class():\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*((Class(),)+_args), **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling instancemethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class():\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_call_function_nested(self):\n        # Test calling instancemethod via class and passing in the class\n        # instance directly.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class():\n            @_decorator\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*((Class(),)+_args), **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function_nested(self):\n        # Test calling instancemethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class():\n            @_decorator\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nclass TestCallingInstanceMethodNewStyle(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling instancemethod via class and passing in the class\n        # instance directly.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(Class(), *_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling instancemethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_call_function_nested(self):\n        # Test calling instancemethod via class and passing in the class\n        # instance directly.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(Class(), *_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function_nested(self):\n        # Test calling instancemethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertNotEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            def _function(self, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_memoize.py": "from __future__ import print_function\n\nimport unittest\nimport threading\nimport inspect\n\nimport wrapt\n\n@wrapt.decorator\ndef memoize(wrapped, instance, args, kwargs):\n    if instance is None and inspect.isclass(wrapped):\n        # Wrapped function is a class and we are creating an\n        # instance of the class. Don't support this case, just\n        # return straight away.\n\n        return wrapped(*args, **kwargs)\n\n    # Retrieve the cache, attaching an empty one if none exists.\n\n    cache = wrapped.__dict__.setdefault('_memoize_cache', {})\n\n    # Now see if entry is in the cache and if it isn't then call\n    # the wrapped function to generate it.\n\n    try:\n        key = (args, frozenset(kwargs.items()))\n        return cache[key]\n\n    except KeyError:\n        result = cache[key] = wrapped(*args, **kwargs)\n        return result\n\n@memoize\ndef function1(count, text):\n    return count * text\n\nclass C1(object):\n\n    @memoize\n    def function1(self, count, text):\n        return count * text\n\n    @memoize\n    @classmethod\n    def function2(cls, count, text):\n        return count * text\n\n    @memoize\n    @staticmethod\n    def function3(count, text):\n        return count * text\n\nc1 = C1()\n\nclass TestSynchronized(unittest.TestCase):\n\n    def test_function(self):\n        value1 = function1(10, '0123456789')\n        value2 = function1(10, '0123456789')\n\n        self.assertEqual(value1, value2)\n        self.assertEqual(id(value1), id(value2))\n\n        self.assertTrue(hasattr(function1, '_memoize_cache'))\n\n    def test_instancemethod(self):\n        value1 = c1.function1(10, '0123456789')\n        value2 = c1.function1(10, '0123456789')\n\n        self.assertEqual(value1, value2)\n        self.assertEqual(id(value1), id(value2))\n\n        self.assertTrue(hasattr(C1.function1, '_memoize_cache'))\n\n    def test_classmethod(self):\n        value1 = C1.function2(10, '0123456789')\n        value2 = C1.function2(10, '0123456789')\n\n        self.assertEqual(value1, value2)\n        self.assertEqual(id(value1), id(value2))\n\n        self.assertTrue(hasattr(C1.function2, '_memoize_cache'))\n\n    def test_staticmethod(self):\n        value1 = C1.function3(10, '0123456789')\n        value2 = C1.function3(10, '0123456789')\n\n        self.assertEqual(value1, value2)\n        self.assertEqual(id(value1), id(value2))\n\n        self.assertTrue(hasattr(C1.function3, '_memoize_cache'))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_function_wrapper.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\nclass TestClassInheritence(unittest.TestCase):\n\n    def test_function_type_inheritence(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        self.assertTrue(isinstance(_function, wrapt.FunctionWrapper))\n        self.assertTrue(isinstance(_function, wrapt.ObjectProxy))\n\n    def test_instancemethod_type_inheritence(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @_decorator\n            def function(self, args, **kwargs):\n                return args, kwargs\n\n            self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n            self.assertTrue(isinstance(function, wrapt.ObjectProxy))\n\n        instance = Class()\n\n        self.assertFalse(isinstance(instance.function, wrapt.FunctionWrapper))\n        self.assertTrue(isinstance(instance.function, wrapt.ObjectProxy))\n\n    def test_classmethod_type_inheritence(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @_decorator\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n            self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n            self.assertTrue(isinstance(function, wrapt.ObjectProxy))\n\n        instance = Class()\n\n        self.assertFalse(isinstance(instance.function, wrapt.FunctionWrapper))\n        self.assertTrue(isinstance(instance.function, wrapt.ObjectProxy))\n\n    def test_staticmethod_type_inheritence(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @_decorator\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n            self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n            self.assertTrue(isinstance(function, wrapt.ObjectProxy))\n\n        instance = Class()\n\n        self.assertFalse(isinstance(instance.function, wrapt.FunctionWrapper))\n        self.assertTrue(isinstance(instance.function, wrapt.ObjectProxy))\n\nclass TestAttributeAccess(unittest.TestCase):\n\n    def test_function_attributes(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = decorator2(function1)\n\n        self.assertEqual(function2.__wrapped__, function1)\n        self.assertEqual(function2._self_wrapper, decorator1)\n        self.assertEqual(function2._self_binding, 'function')\n\n    def test_instancemethod_attributes(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            def function1(self, *args, **kwargs):\n                return args, kwargs\n            function2 = decorator2(function1)\n\n            self.assertEqual(function2.__wrapped__, function1)\n            self.assertEqual(function2._self_wrapper, decorator1)\n            self.assertEqual(function2._self_binding, 'function')\n\n        instance = Class()\n\n        self.assertEqual(instance.function2.__wrapped__, instance.function1)\n        self.assertEqual(instance.function2._self_instance, instance)\n        self.assertEqual(instance.function2._self_wrapper, decorator1)\n\n    def test_classmethod_attributes(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @classmethod\n            def function1(cls, *args, **kwargs):\n                return args, kwargs\n            function2 = decorator2(function1)\n\n            self.assertEqual(function2.__wrapped__, function1)\n            self.assertEqual(function2._self_wrapper, decorator1)\n            self.assertEqual(function2._self_binding, 'classmethod')\n\n        instance = Class()\n\n        self.assertEqual(instance.function2.__wrapped__, instance.function1)\n        self.assertEqual(instance.function2._self_instance, instance)\n        self.assertEqual(instance.function2._self_wrapper, decorator1)\n\n    def test_staticmethod_attributes(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @staticmethod\n            def function1(*args, **kwargs):\n                return args, kwargs\n            function2 = decorator2(function1)\n\n            self.assertEqual(function2.__wrapped__, function1)\n            self.assertEqual(function2._self_wrapper, decorator1)\n            self.assertEqual(function2._self_binding, 'staticmethod')\n\n    def test_instancemethod_attributes_external_class(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            def function1(self, *args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class.function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n\n        # We can't identify this as being an instance method in\n        # Python 3 because there is no concept of unbound methods.\n        # We therefore don't try for Python 2 either.\n\n        self.assertEqual(function2._self_binding, 'function')\n\n    def test_classmethod_attributes_external_class(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @classmethod\n            def function1(cls, *args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class.function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n        self.assertEqual(function2._self_binding, 'classmethod')\n\n    def test_staticmethod_attributes_external_class(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @staticmethod\n            def function1(*args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class.function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n\n        # We can't identify this as being a static method because\n        # the binding has resulted in a normal function being returned.\n\n        self.assertEqual(function2._self_binding, 'function')\n\n    def test_instancemethod_attributes_external_instance(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            def function1(self, *args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class().function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n\n        # We can't identify this as being an instance method in\n        # Python 3 when it is a class so have to disable the check\n        # for Python 2. This has flow on effect of not working\n        # in the case of an instance either.\n\n        self.assertEqual(function2._self_binding, 'function')\n\n    def test_classmethod_attributes_external_instance(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @classmethod\n            def function1(cls, *args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class().function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n        self.assertEqual(function2._self_binding, 'classmethod')\n\n    def test_staticmethod_attributes_external_instance(self):\n        def decorator1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n        decorator2 = wrapt.decorator(decorator1)\n\n        class Class(object):\n            @staticmethod\n            def function1(*args, **kwargs):\n                return args, kwargs\n\n        function2 = decorator2(Class().function1)\n\n        self.assertEqual(function2._self_wrapper, decorator2)\n\n        # We can't identify this as being a static method because\n        # the binding has resulted in a normal function being returned.\n\n        self.assertEqual(function2._self_binding, 'function')\n\nclass TestParentReference(unittest.TestCase):\n\n    def test_function_decorator(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def function():\n            pass\n\n        self.assertEqual(function._self_parent, None)\n\n    def test_class_decorator(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        class Class:\n            pass\n\n        self.assertEqual(Class._self_parent, None)\n\n    def test_nested_class_decorator(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class:\n            @_decorator\n            class Nested:\n                pass\n\n        self.assertEqual(Class.Nested._self_parent, None)\n\n    def test_instancemethod(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class:\n            @_decorator\n            def function_im(self):\n                pass\n\n        c = Class()\n\n        self.assertNotEqual(c.function_im._self_parent, None)\n        self.assertNotEqual(Class.function_im._self_parent, None)\n\n    def test_classmethod(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class:\n            @_decorator\n            @classmethod\n            def function_cm(cls):\n                pass\n\n        self.assertNotEqual(Class.function_cm._self_parent, None)\n\n    def test_staticmethod_inner(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class:\n            @_decorator\n            @staticmethod\n            def function_sm_inner():\n                pass\n\n        self.assertNotEqual(Class.function_sm_inner._self_parent, None)\n\nclass TestGuardArgument(unittest.TestCase):\n\n    def test_boolean_false_guard_on_decorator(self):\n        @wrapt.decorator(enabled=False)\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def function():\n            pass\n\n        self.assertFalse(isinstance(function, wrapt.FunctionWrapper))\n\n    def test_boolean_true_guard_on_decorator(self):\n        @wrapt.decorator(enabled=True)\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def function():\n            pass\n\n        self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n\n    def test_boolean_dynamic_guard_on_decorator(self):\n        class Guard(object):\n            value = True\n            def __nonzero__(self):\n                return self.value\n            __bool__ = __nonzero__\n\n        guard = Guard()\n\n        result = []\n\n        @wrapt.decorator(enabled=guard)\n        def _decorator(wrapped, instance, args, kwargs):\n            result.append(1)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def function():\n            pass\n\n        self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n\n        function()\n\n        self.assertNotEqual(len(result), 0)\n\n        result = []\n        guard.value = False\n\n        function()\n\n        self.assertEqual(len(result), 0)\n\n    def test_function_guard_on_decorator(self):\n        value = True\n        def guard():\n            return value\n\n        result = []\n\n        @wrapt.decorator(enabled=guard)\n        def _decorator(wrapped, instance, args, kwargs):\n            result.append(1)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def function():\n            pass\n\n        self.assertTrue(isinstance(function, wrapt.FunctionWrapper))\n\n        function()\n\n        self.assertNotEqual(len(result), 0)\n\n        result = []\n        value = False\n\n        function()\n\n        self.assertEqual(len(result), 0)\n\n    def test_guard_on_instancemethod(self):\n        value = True\n        def guard():\n            return value\n\n        result = []\n\n        @wrapt.decorator(enabled=guard)\n        def _decorator(wrapped, instance, args, kwargs):\n            result.append(1)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @_decorator\n            def function(self):\n                pass\n\n        c = Class()\n\n        self.assertTrue(isinstance(c.function, wrapt.BoundFunctionWrapper))\n\n        c.function()\n\n        self.assertNotEqual(len(result), 0)\n\n        result = []\n        value = False\n\n        self.assertTrue(isinstance(c.function, wrapt.BoundFunctionWrapper))\n\n        c.function()\n\n        self.assertEqual(len(result), 0)\n\nclass TestDerivedFunctionWrapper(unittest.TestCase):\n\n    def test_override_bound_type(self):\n\n        class _BoundFunctionWrapper(wrapt.BoundFunctionWrapper):\n            ATTRIBUTE = 1\n\n        class _FunctionWrapper(wrapt.FunctionWrapper):\n            __bound_function_wrapper__ = _BoundFunctionWrapper\n\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        _wrapper = _FunctionWrapper(function, wrapper)\n\n        self.assertTrue(isinstance(_wrapper, _FunctionWrapper))\n\n        instance = object()\n\n        _bound_wrapper = _wrapper.__get__(instance, type(instance))\n\n        self.assertTrue(isinstance(_bound_wrapper, _BoundFunctionWrapper))\n        self.assertEqual(_bound_wrapper.ATTRIBUTE, 1)\n\nclass TestFunctionBinding(unittest.TestCase):\n\n    def test_double_binding(self):\n\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        _wrapper = wrapt.FunctionWrapper(function, wrapper)\n\n        self.assertTrue(isinstance(_wrapper, wrapt.FunctionWrapper))\n\n        instance = object()\n\n        _bound_wrapper_1 = _wrapper.__get__(instance, type(instance))\n\n        self.assertTrue(_bound_wrapper_1._self_parent is _wrapper)\n\n        self.assertTrue(isinstance(_bound_wrapper_1,\n                wrapt.BoundFunctionWrapper))\n        self.assertEqual(_bound_wrapper_1._self_instance, instance)\n\n        _bound_wrapper_2 = _bound_wrapper_1.__get__(instance, type(instance))\n\n        self.assertTrue(_bound_wrapper_2._self_parent is _wrapper)\n\n        self.assertTrue(isinstance(_bound_wrapper_2,\n                wrapt.BoundFunctionWrapper))\n        self.assertEqual(_bound_wrapper_2._self_instance,\n                _bound_wrapper_1._self_instance)\n\n        self.assertTrue(_bound_wrapper_1 is _bound_wrapper_2)\n\n    def test_re_bind_after_none(self):\n\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        _wrapper = wrapt.FunctionWrapper(function, wrapper)\n\n        self.assertTrue(isinstance(_wrapper, wrapt.FunctionWrapper))\n\n        instance = object()\n\n        _bound_wrapper_1 = _wrapper.__get__(None, type(instance))\n\n        self.assertTrue(_bound_wrapper_1._self_parent is _wrapper)\n\n        self.assertTrue(isinstance(_bound_wrapper_1,\n                wrapt.BoundFunctionWrapper))\n        self.assertEqual(_bound_wrapper_1._self_instance, None)\n\n        _bound_wrapper_2 = _bound_wrapper_1.__get__(instance, type(instance))\n\n        self.assertTrue(_bound_wrapper_2._self_parent is _wrapper)\n\n        self.assertTrue(isinstance(_bound_wrapper_2,\n                wrapt.BoundFunctionWrapper))\n        self.assertEqual(_bound_wrapper_2._self_instance, instance)\n\n        self.assertTrue(_bound_wrapper_1 is not _bound_wrapper_2)\n\nclass TestInvalidWrapper(unittest.TestCase):\n\n    def test_none_for_wrapped(self):\n\n        def run(*args):\n            def _wrapper(wrapped, instance, args, kwargs):\n                return wrapped(*args, **kwargs)\n            wrapper = wrapt.FunctionWrapper(None, _wrapper)\n            wrapper.__get__(list(), list)()\n\n        self.assertRaises(AttributeError, run, ())\n\nclass TestInvalidCalling(unittest.TestCase):\n\n    def test_missing_self_via_class(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @_decorator\n            def method(self):\n                pass\n\n        def run(*args):\n            Class.method()\n\n        self.assertRaises(TypeError, run, ())\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_post_import_hooks.py": "from __future__ import print_function\n\nimport unittest\nimport sys\nimport threading\n\nimport wrapt\nfrom wrapt.importer import _post_import_hooks\n\nfrom compat import PY2, PY3\n\nclass TestPostImportHooks(unittest.TestCase):\n\n    def setUp(self):\n        super(TestPostImportHooks, self).setUp()\n\n        # So we can import 'this' and test post-import hooks multiple times\n        # below in the context of a single Python process, remove 'this' from\n        # sys.modules and post import hooks.\n\n        sys.modules.pop('this', None)\n        _post_import_hooks.pop('this', None)\n\n    def test_before_import(self):\n        invoked = []\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            self.assertEqual(module.__name__, 'this')\n            invoked.append(1)\n\n        self.assertEqual(len(invoked), 0)\n\n        import this\n\n        self.assertEqual(len(invoked), 1)\n\n    def test_after_import(self):\n        invoked = []\n\n        import this\n\n        self.assertEqual(len(invoked), 0)\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            self.assertEqual(module.__name__, 'this')\n            invoked.append(1)\n\n        self.assertEqual(len(invoked), 1)\n\n    def test_before_and_after_import(self):\n        invoked_one = []\n        invoked_two = []\n\n        @wrapt.when_imported('this')\n        def hook_this_one(module):\n            self.assertEqual(module.__name__, 'this')\n            invoked_one.append(1)\n\n        self.assertEqual(len(invoked_one), 0)\n        self.assertEqual(len(invoked_two), 0)\n\n        import this\n\n        self.assertEqual(len(invoked_one), 1)\n        self.assertEqual(len(invoked_two), 0)\n\n        @wrapt.when_imported('this')\n        def hook_this_two(module):\n            self.assertEqual(module.__name__, 'this')\n            invoked_two.append(1)\n\n        self.assertEqual(len(invoked_one), 1)\n        self.assertEqual(len(invoked_two), 1)\n\n    def test_remove_from_sys_modules(self):\n        invoked = []\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            self.assertEqual(module.__name__, 'this')\n            invoked.append(1)\n\n        import this\n        self.assertEqual(len(invoked), 1)\n\n        del sys.modules['this']\n        wrapt.register_post_import_hook(hook_this, 'this')\n        import this\n\n        self.assertEqual(len(invoked), 2)\n\n    def test_import_deadlock_1(self):\n        # This tries to verify that we haven't created a deadlock situation when\n        # code executed from a post module import, for a module that has already\n        # been imported, creates a thread which in turn attempts to register\n        # another import hook.\n\n        import this\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            def worker():\n                @wrapt.when_imported('xxx')\n                def hook_xxx(module):\n                    pass\n\n            thread = threading.Thread(target=worker)\n            thread.start()\n            thread.join(timeout=10)\n\n            self.assertFalse(thread.is_alive())\n\n        del sys.modules['this']\n\n    def test_import_deadlock_2(self):\n        # This tries to verify that we haven't created a deadlock situation when\n        # code executed from a post module import, for a module that has not yet\n        # been imported, creates a thread which in turn attempts to register\n        # another import hook.\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            def worker():\n                @wrapt.when_imported('xxx')\n                def hook_xxx(module):\n                    pass\n\n            thread = threading.Thread(target=worker)\n            thread.start()\n            thread.join(timeout=10)\n\n            self.assertFalse(thread.is_alive())\n\n        import this\n        del sys.modules['this']\n\n    def test_import_deadlock_3(self):\n        # This tries to verify that we haven't created a deadlock situation when\n        # code executed from a post module import hook imports another module.\n\n        # Note that we cannot run this test on Python 2.X as it has a single\n        # global module import lock which means that if a thread runs during\n        # module import and it in turns does an import that it will then block\n        # on the parent thread which holds the global module import lock. This\n        # is a fundamental behaviour of Python and not wrapt. In Python 3.X\n        # there is a module import lock per named module and so we do not have\n        # this problem.\n\n        if PY2:\n          return\n\n        hooks_called = []\n\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            hooks_called.append('this')\n\n            self.assertFalse('wsgiref' in sys.modules)\n    \n            @wrapt.when_imported('wsgiref')\n            def hook_wsgiref(module):\n                hooks_called.append('wsgiref')\n\n            def worker():\n                import wsgiref\n\n            thread = threading.Thread(target=worker)\n            thread.start()\n            thread.join(timeout=10)\n\n            self.assertFalse(thread.is_alive())\n\n        import this\n        del sys.modules['this']\n\n        self.assertEqual(hooks_called, ['this', 'wsgiref'])\n\n    def test_loader(self):\n        @wrapt.when_imported('this')\n        def hook_this(module):\n            pass\n\n        import this\n\n        if sys.version_info[:2] >= (3, 3):\n            from importlib.machinery import SourceFileLoader\n            self.assertIsInstance(this.__loader__, SourceFileLoader)\n            self.assertIsInstance(this.__spec__.loader, SourceFileLoader)\n\n        else:\n            self.assertEqual(hasattr(this, \"__loader__\"), False)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_class_py37.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\nclass TestInheritance(unittest.TestCase):\n\n    def test_single_inheritance(self):\n        @wrapt.decorator\n        def passthru(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @passthru\n        class BaseClass(object):\n            def __init__(self):\n                self.value = 1\n\n        class DerivedClass(BaseClass):\n            def __init__(self):\n                super(DerivedClass, self).__init__()\n                self.value = 2\n\n        base = BaseClass()\n\n        self.assertEqual(type(base), BaseClass.__wrapped__)\n        self.assertTrue(isinstance(base, BaseClass.__wrapped__))\n        self.assertEqual(base.value, 1)\n\n        self.assertEqual(type(base).__mro__, (BaseClass.__wrapped__, object))\n        self.assertEqual(BaseClass.__mro_entries__(()), (BaseClass.__wrapped__,))\n\n        derived = DerivedClass()\n\n        self.assertEqual(type(derived), DerivedClass)\n        self.assertTrue(isinstance(derived, BaseClass.__wrapped__))\n        self.assertTrue(isinstance(derived, DerivedClass))\n        self.assertEqual(derived.value, 2)\n\n        self.assertEqual(type(derived).__mro__, (DerivedClass, BaseClass.__wrapped__, object))\n\n    def test_multiple_inheritance(self):\n        @wrapt.decorator\n        def passthru(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @passthru\n        class BaseClass1(object):\n            pass\n\n        @passthru\n        class BaseClass2(object):\n            pass\n\n        class DerivedClass(BaseClass1, BaseClass2):\n            pass\n\n        derived = DerivedClass()\n\n        self.assertEqual(type(derived), DerivedClass)\n        self.assertTrue(isinstance(derived, BaseClass1.__wrapped__))\n        self.assertTrue(isinstance(derived, BaseClass2.__wrapped__))\n        self.assertTrue(isinstance(derived, DerivedClass))\n\n        self.assertEqual(type(derived).__mro__, (DerivedClass,\n                BaseClass1.__wrapped__, BaseClass2.__wrapped__, object))\n\n    def test_multiple_inheritance_common(self):\n        @wrapt.decorator\n        def passthru(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @passthru\n        class CommonClass(object):\n            pass\n\n        @passthru\n        class BaseClass1(CommonClass):\n            pass\n\n        @passthru\n        class BaseClass2(CommonClass):\n            pass\n\n        class DerivedClass(BaseClass1, BaseClass2):\n            pass\n\n        derived = DerivedClass()\n\n        self.assertEqual(type(derived), DerivedClass)\n        self.assertTrue(isinstance(derived, CommonClass.__wrapped__))\n        self.assertTrue(isinstance(derived, BaseClass1.__wrapped__))\n        self.assertTrue(isinstance(derived, BaseClass2.__wrapped__))\n        self.assertTrue(isinstance(derived, DerivedClass))\n\n        self.assertEqual(type(derived).__mro__, (DerivedClass,\n            BaseClass1.__wrapped__, BaseClass2.__wrapped__,\n            CommonClass.__wrapped__, object))\n", "tests/test_inner_staticmethod.py": "from __future__ import print_function\n\nimport unittest\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass Class(object):\n    @staticmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOriginal = Class\n\nclass Class(object):\n    @decorators.passthru_decorator\n    @staticmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nclass TestNamingInnerStaticMethod(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class.function.__name__,\n                Original.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class().function.__name__,\n                Original().function.__name__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class.function.__module__,\n                Original.function.__module__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class().function.__qualname__, __qualname__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class().function.__module__,\n                Original().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class.function.__doc__,\n                Original.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class().function.__doc__,\n                Original().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original.function)\n        function_argspec = getfullargspec(Class.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original().function)\n        function_argspec = getfullargspec(Class().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class.function,\n                type(Original.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class().function,\n                type(Original().function)))\n\nclass TestCallingInnerStaticMethod(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling staticmethod.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling staticmethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_call_function_nested_decorator(self):\n        # Test calling staticmethod.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function_nested_decorator(self):\n        # Test calling staticmethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_externally_applied_wrapper(self):\n        # Test calling staticmethod via class when\n        # the decorator has been applied from external to\n        # the class using wrapping function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        wrapt.wrap_function_wrapper(Class, \"_function\", _decorator)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_externally_applied_wrapper(self):\n        # Test calling staticmethod via class instance when\n        # the decorator has been applied from external to\n        # the class using wrapping function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            @staticmethod\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        wrapt.wrap_function_wrapper(Class, \"_function\", _decorator)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_outer_staticmethod.py": "from __future__ import print_function\n\nimport unittest\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass Class(object):\n    @staticmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOriginal = Class\n\nclass Class(object):\n    @staticmethod\n    @decorators.passthru_decorator\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nclass TestNamingOuterStaticMethod(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class.function.__name__,\n                Original.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class().function.__name__,\n                Original().function.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class().function.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class.function.__module__,\n                Original.function.__module__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class().function.__module__,\n                Original().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class.function.__doc__,\n                Original.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class().function.__doc__,\n                Original().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original.function)\n        function_argspec = getfullargspec(Class.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original().function)\n        function_argspec = getfullargspec(Class().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class.function,\n                type(Original.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class().function,\n                type(Original().function)))\n\nclass TestCallingOuterStaticMethod(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling staticmethod. The instance and class passed to the\n        # wrapper will both be None because our decorator is surrounded\n        # by the staticmethod decorator. The staticmethod decorator\n        # doesn't bind the method and treats it like a normal function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @staticmethod\n            @_decorator\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling staticmethod via class instance. The instance\n        # and class passed to the wrapper will both be None because our\n        # decorator is surrounded by the staticmethod decorator. The\n        # staticmethod decorator doesn't bind the method and treats it\n        # like a normal function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @staticmethod\n            @_decorator\n            def _function(*args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_adapter_py3.py": "from __future__ import print_function\n\nimport inspect\nimport unittest\nimport types\n\nfrom typing import Iterable\n\nimport wrapt\n\nfrom compat import PY2, exec_\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\nfrom typing import Iterable\n\ndef prototype1(arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n@wrapt.decorator(adapter=prototype1)\ndef adapter1(wrapped, instance, args, kwargs):\n    '''adapter documentation'''\n    return wrapped(*args, **kwargs)\n\ndef prototype2(arg1, arg2, arg3=None, *args, **kwargs) -> int: pass\n@wrapt.decorator(adapter=prototype2)\ndef adapter2(wrapped, instance, args, kwargs):\n    '''adapter documentation'''\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\ndef function1(arg1, arg2) -> Iterable:\n    '''documentation'''\n    return arg1, arg2\n\nfunction1o = function1\n\n@decorators.adapter1\ndef function1(arg1, arg2) -> Iterable:\n    '''documentation'''\n    return arg1, arg2\n\nfunction1d = function1\n\ndef function2(arg1, arg2) -> Iterable:\n    '''documentation'''\n    return arg1, arg2\n\nfunction2o = function2\n\n@decorators.adapter1\ndef function2(arg1, arg2) -> Iterable:\n    '''documentation'''\n    return arg1, arg2\n\nfunction2d = function2\n\nclass TestAdapterAttributesWithAnnotations(unittest.TestCase):\n\n    def test_annotations(self):\n        # Test preservation of function __annotations__ attribute.\n\n        self.assertEqual(function1d.__annotations__, function1o.__annotations__)\n\nclass TestArgumentSpecificationWithAnnotations(unittest.TestCase):\n\n    def test_argspec(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        def _adapter(arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n\n        function1a_argspec = inspect.getfullargspec(_adapter)\n        function1d_argspec = inspect.getfullargspec(function1d)\n        self.assertEqual(function1a_argspec, function1d_argspec)\n\n        # Now bind the function to an instance. The argspec should\n        # still match.\n\n        bound_function1d = function1d.__get__(object(), object)\n        bound_function1d_argspec = inspect.getfullargspec(bound_function1d)\n        self.assertEqual(function1a_argspec, bound_function1d_argspec)\n\n    def test_signature(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        if PY2:\n            return\n\n        def _adapter(arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n\n        function1a_signature = str(inspect.signature(_adapter))\n        function1d_signature = str(inspect.signature(function1d))\n        self.assertEqual(function1a_signature, function1d_signature)\n\n    def test_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(function1d, type(function1o)))\n\nclass TestDynamicAdapterWithAnnotations(unittest.TestCase):\n\n    def test_dynamic_adapter_function(self):\n        def _adapter1(arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n\n        argspec1 = inspect.getfullargspec(_adapter1)\n\n        @wrapt.decorator(adapter=argspec1)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_1\n        def _function_1():\n            pass\n\n        self.assertEqual(inspect.getfullargspec(_function_1), argspec1)\n\n        # Can't use a function signature with adapter factory which has\n        # annotations which reference a non builtin type, so use test\n        # function which returns int rather than Iterable.\n\n        def _adapter2(arg1, arg2, arg3=None, *args, **kwargs) -> int: pass\n\n        argspec2 = inspect.getfullargspec(_adapter2)\n\n        args = '(arg1, arg2, arg3=None, *args, **kwargs) -> int'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_2\n        def _function_2():\n           pass\n\n        self.assertEqual(inspect.getfullargspec(_function_2), argspec2)\n\n    def test_dynamic_adapter_instancemethod(self):\n        def _adapter1(self, arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n\n        argspec1 = inspect.getfullargspec(_adapter1)\n\n        @wrapt.decorator(adapter=argspec1)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class1(object):\n            @_wrapper_1\n            def function(self):\n                pass\n\n        instance1 = Class1()\n\n        self.assertEqual(inspect.getfullargspec(Class1.function), argspec1)\n        self.assertEqual(inspect.getfullargspec(instance1.function), argspec1)\n\n        # Can't use a function signature with adapter factory which has\n        # annotations which reference a non builtin type.\n\n        def _adapter2(self, arg1, arg2, arg3=None, *args, **kwargs) -> int: pass\n\n        argspec2 = inspect.getfullargspec(_adapter2)\n\n        args = '(self, arg1, arg2, arg3=None, *args, **kwargs) -> int'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class2(object):\n            @_wrapper_2\n            def function(self):\n                pass\n\n        instance2 = Class2()\n\n        self.assertEqual(inspect.getfullargspec(Class2.function), argspec2)\n        self.assertEqual(inspect.getfullargspec(instance2.function), argspec2)\n\n    def test_dynamic_adapter_classmethod(self):\n        def _adapter1(cls, arg1, arg2, arg3=None, *args, **kwargs) -> Iterable: pass\n\n        argspec1 = inspect.getfullargspec(_adapter1)\n\n        @wrapt.decorator(adapter=argspec1)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class1(object):\n            @_wrapper_1\n            @classmethod\n            def function(cls):\n                pass\n\n        instance1 = Class1()\n\n        self.assertEqual(inspect.getfullargspec(Class1.function), argspec1)\n        self.assertEqual(inspect.getfullargspec(instance1.function), argspec1)\n\n        # Can't use a function signature with adapter factory which has\n        # annotations which reference a non builtin type.\n\n        def _adapter2(cls, arg1, arg2, arg3=None, *args, **kwargs) -> int: pass\n\n        argspec2 = inspect.getfullargspec(_adapter2)\n\n        args = '(cls, arg1, arg2, arg3=None, *args, **kwargs) -> int'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class2(object):\n            @_wrapper_2\n            @classmethod\n            def function(self):\n                pass\n\n        instance2 = Class2()\n\n        self.assertEqual(inspect.getfullargspec(Class2.function), argspec2)\n        self.assertEqual(inspect.getfullargspec(instance2.function), argspec2)\n\n    def test_adapter_factory(self):\n        def factory(wrapped):\n            argspec = inspect.getfullargspec(wrapped)\n            argspec.args.insert(0, 'arg0')\n            return argspec\n\n        @wrapt.decorator(adapter=wrapt.adapter_factory(factory))\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_1\n        def _function_1(arg1, arg2) -> Iterable:\n            pass\n\n        argspec = inspect.getfullargspec(_function_1)\n\n        self.assertEqual(argspec.args, ['arg0', 'arg1', 'arg2'])\n        self.assertEqual(argspec.annotations, {'return': Iterable})\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_attribute_wrapper.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nclass Class(object):\n    def __init__(self, value):\n        self.value = value\n\nclass TestAttributeProxy(unittest.TestCase):\n\n    def test_wrap_attribute(self):\n        wrapt.wrap_object_attribute(__name__, 'Class.value', wrapt.ObjectProxy)\n\n        instance = Class(1)\n\n        self.assertEqual(instance.value, 1)\n        self.assertTrue(isinstance(instance.value, wrapt.ObjectProxy))\n\n        instance.value = 2\n\n        self.assertEqual(instance.value, 2)\n        self.assertTrue(isinstance(instance.value, wrapt.ObjectProxy))\n", "tests/test_adapter.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import PY2, exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\ndef prototype(arg1, arg2, arg3=None, *args, **kwargs): pass\n@wrapt.decorator(adapter=prototype)\ndef adapter1(wrapped, instance, args, kwargs):\n    '''adapter documentation'''\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\ndef function1(arg1, arg2):\n    '''documentation'''\n    return arg1, arg2\n\nfunction1o = function1\n\n@decorators.adapter1\ndef function1(arg1, arg2):\n    '''documentation'''\n    return arg1, arg2\n\nfunction1d = function1\n\nclass TestAdapterAttributes(unittest.TestCase):\n\n    def test_object_name(self):\n        # Test preservation of function __name__ attribute.\n\n        self.assertEqual(function1d.__name__, function1o.__name__)\n\n    def test_object_qualname(self):\n        # Test preservation of function __qualname__ attribute.\n\n        try:\n            __qualname__ = function1o.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(function1d.__qualname__, __qualname__)\n\n    def test_module_name(self):\n        # Test preservation of function __module__ attribute.\n\n        self.assertEqual(function1d.__module__, __name__)\n\n    def test_doc_string(self):\n        # Test preservation of function __doc__ attribute. It is\n        # still the documentation from the wrapped function, not\n        # of the adapter.\n\n        self.assertEqual(function1d.__doc__, 'documentation')\n\nclass TestArgumentSpecification(unittest.TestCase):\n\n    def test_argspec(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        def _adapter(arg1, arg2, arg3=None, *args, **kwargs): pass\n\n        function1a_argspec = getfullargspec(_adapter)\n        function1d_argspec = getfullargspec(function1d)\n        self.assertEqual(function1a_argspec, function1d_argspec)\n\n        # Now bind the function to an instance. The argspec should\n        # still match.\n\n        bound_function1d = function1d.__get__(object(), object)\n        bound_function1d_argspec = getfullargspec(bound_function1d)\n        self.assertEqual(function1a_argspec, bound_function1d_argspec)\n\n    def test_signature(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        if PY2:\n            return\n\n        def _adapter(arg1, arg2, arg3=None, *args, **kwargs): pass\n\n        function1a_signature = str(inspect.signature(_adapter))\n        function1d_signature = str(inspect.signature(function1d))\n        self.assertEqual(function1a_signature, function1d_signature)\n\n    def test_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(function1d, type(function1o)))\n\nclass TestDynamicAdapter(unittest.TestCase):\n\n    def test_dynamic_adapter_function(self):\n        def _adapter(arg1, arg2, arg3=None, *args, **kwargs): pass\n\n        argspec = getfullargspec(_adapter)\n\n        @wrapt.decorator(adapter=argspec)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_1\n        def _function_1():\n            pass\n\n        self.assertEqual(getfullargspec(_function_1), argspec)\n\n        args = '(arg1, arg2, arg3=None, *args, **kwargs)'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_2\n        def _function_2():\n            pass\n\n        self.assertEqual(getfullargspec(_function_2), argspec)\n\n    def test_dynamic_adapter_instancemethod(self):\n        def _adapter(self, arg1, arg2, arg3=None, *args, **kwargs): pass\n\n        argspec = getfullargspec(_adapter)\n\n        @wrapt.decorator(adapter=argspec)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class1(object):\n            @_wrapper_1\n            def function(self):\n                pass\n\n        instance1 = Class1()\n\n        self.assertEqual(getfullargspec(Class1.function), argspec)\n        self.assertEqual(getfullargspec(instance1.function), argspec)\n\n        args = '(self, arg1, arg2, arg3=None, *args, **kwargs)'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class2(object):\n            @_wrapper_2\n            def function(self):\n                pass\n\n        instance2 = Class2()\n\n        self.assertEqual(getfullargspec(Class2.function), argspec)\n        self.assertEqual(getfullargspec(instance2.function), argspec)\n\n    def test_dynamic_adapter_classmethod(self):\n        def _adapter(cls, arg1, arg2, arg3=None, *args, **kwargs): pass\n\n        argspec = getfullargspec(_adapter)\n\n        @wrapt.decorator(adapter=argspec)\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class1(object):\n            @_wrapper_1\n            @classmethod\n            def function(cls):\n                pass\n\n        instance1 = Class1()\n\n        self.assertEqual(getfullargspec(Class1.function), argspec)\n        self.assertEqual(getfullargspec(instance1.function), argspec)\n\n        args = '(cls, arg1, arg2, arg3=None, *args, **kwargs)'\n\n        @wrapt.decorator(adapter=args)\n        def _wrapper_2(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Class2(object):\n            @_wrapper_2\n            @classmethod\n            def function(self):\n                pass\n\n        instance2 = Class2()\n\n        self.assertEqual(getfullargspec(Class2.function), argspec)\n        self.assertEqual(getfullargspec(instance2.function), argspec)\n\n    def test_adapter_factory(self):\n        def factory(wrapped):\n            argspec = getfullargspec(wrapped)\n            argspec.args.insert(0, 'arg0')\n            return argspec\n\n        @wrapt.decorator(adapter=wrapt.adapter_factory(factory))\n        def _wrapper_1(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_wrapper_1\n        def _function_1(arg1, arg2):\n            pass\n\n        argspec = getfullargspec(_function_1)\n\n        self.assertEqual(argspec.args, ['arg0', 'arg1', 'arg2'])\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_outer_classmethod.py": "from __future__ import print_function\n\nimport unittest\nimport types\n\nimport wrapt\n\nfrom compat import PYXY, exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass Class(object):\n    @classmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOriginal = Class\n\nclass Class(object):\n    @classmethod\n    @decorators.passthru_decorator\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nclass TestNamingOuterClassMethod(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class.function.__name__,\n                Original.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class().function.__name__,\n                Original().function.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class().function.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class.function.__module__,\n                Original.function.__module__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class().function.__module__,\n                Original().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class.function.__doc__,\n                Original.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class().function.__doc__,\n                Original().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original.function)\n        function_argspec = getfullargspec(Class.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original().function)\n        function_argspec = getfullargspec(Class().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class.function,\n                type(Original.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class().function,\n                type(Original().function)))\n\nclass TestCallingOuterClassMethod(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling classmethod. Prior to Python 3.9, the instance\n        # and class passed to the wrapper will both be None because our\n        # decorator is surrounded by the classmethod decorator. The\n        # classmethod decorator doesn't bind the method and treats it\n        # like a normal function, explicitly passing the class as the\n        # first argument with the actual arguments following that. This\n        # was only finally fixed in Python 3.9. For more details see:\n        # https://bugs.python.org/issue19072\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            if PYXY < (3, 9):\n                self.assertEqual(instance, None)\n                self.assertEqual(args, (Class,)+_args)\n            else:\n                self.assertEqual(instance, Class)\n                self.assertEqual(args, _args)\n\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @classmethod\n            @_decorator\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling classmethod via class instance. Prior to Python\n        # 3.9, the instance and class passed to the wrapper will both be\n        # None because our decorator is surrounded by the classmethod\n        # decorator. The classmethod decorator doesn't bind the method\n        # and treats it like a normal function, explicitly passing the\n        # class as the first argument with the actual arguments\n        # following that. This was only finally fixed in Python 3.9. For\n        # more details see: https://bugs.python.org/issue19072\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            if PYXY < (3, 9):\n                self.assertEqual(instance, None)\n                self.assertEqual(args, (Class,)+_args)\n            else:\n                self.assertEqual(instance, Class)\n                self.assertEqual(args, _args)\n\n            self.assertEqual(kwargs, _kwargs)\n            self.assertEqual(wrapped.__module__, _function.__module__)\n            self.assertEqual(wrapped.__name__, _function.__name__)\n\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @classmethod\n            @_decorator\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_monkey_patching.py": "from __future__ import print_function\n\nimport unittest\nimport sys\n\nimport wrapt\n\ndef global_function_1(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_2(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_3(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_3_enabled_literal_false(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_3_enabled_literal_true(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_3_enabled_callable(*args, **kwargs):\n    return args, kwargs\n\ndef global_function_4(*args, **kwargs):\n    return args, kwargs\n\nclass Class_1(object):\n    def method(self, *args, **kwargs):\n        return args, kwargs\n\nclass Class_2(object):\n    @classmethod\n    def method(cls, *args, **kwargs):\n        return cls, args, kwargs\n\nclass Class_2_1(Class_2):\n    pass\n\nclass Class_2_2(Class_2_1):\n    pass\n\nclass Class_3(object):\n    @staticmethod\n    def method(*args, **kwargs):\n        return args, kwargs\n\nclass TestMonkeyPatching(unittest.TestCase):\n\n    def test_function_wrapper(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.function_wrapper\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @wrapper\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_function_wrapper_instance_method(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        _self = self\n\n        class wrapper(object):\n            @wrapt.function_wrapper\n            def __call__(self, wrapped, instance, args, kwargs):\n                _self.assertEqual(type(self), wrapper)\n                called.append((args, kwargs))\n                _self.assertEqual(instance, None)\n                _self.assertEqual(args, _args)\n                _self.assertEqual(kwargs, _kwargs)\n                return wrapped(*args, **kwargs)\n\n        @wrapper()\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_function_wrapper_class_method(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        class wrapper(object):\n            @wrapt.function_wrapper\n            @classmethod\n            def __call__(cls, wrapped, instance, args, kwargs):\n                self.assertEqual(cls, wrapper)\n                called.append((args, kwargs))\n                self.assertEqual(instance, None)\n                self.assertEqual(args, _args)\n                self.assertEqual(kwargs, _kwargs)\n                return wrapped(*args, **kwargs)\n\n        @wrapper()\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_function_module_name(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(__name__, 'global_function_1', wrapper)\n\n        result = global_function_1(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_function_module(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        module = sys.modules[__name__]\n\n        wrapt.wrap_function_wrapper(module, 'global_function_2', wrapper)\n\n        result = global_function_2(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_instance_method_module_name(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        _instance = Class_1()\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, _instance)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(__name__, 'Class_1.method',\n                wrapper)\n\n        result = _instance.method(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_class_method_module_name(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, Class_2)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(__name__, 'Class_2.method',\n                wrapper)\n\n        result = Class_2.method(*_args, **_kwargs)\n\n        self.assertEqual(result, (Class_2, _args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_class_method_inherited(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(__name__, 'Class_2_1.method',\n                wrapper)\n\n        result = Class_2_1.method(*_args, **_kwargs)\n        self.assertEqual(result, (Class_2_1, _args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n        called.pop()\n\n        result = Class_2_2.method(*_args, **_kwargs)\n        self.assertEqual(result, (Class_2_2, _args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_wrap_static_method_module_name(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(__name__, 'Class_3.method',\n                wrapper)\n\n        result = Class_3.method(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_function_module_name(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.patch_function_wrapper(__name__, 'global_function_3')\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        result = global_function_3(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_function_module_name_enabled_literal_false(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.patch_function_wrapper(__name__, 'global_function_3_enabled_literal_false', enabled=False)\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        result = global_function_3_enabled_literal_false(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called, [])\n\n    def test_patch_function_module_name_enabled_literal_true(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.patch_function_wrapper(__name__, 'global_function_3_enabled_literal_true', enabled=True)\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        result = global_function_3_enabled_literal_true(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_function_module_name_enabled_callable(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        enable = False\n\n        def enabled():\n            return enable\n\n        @wrapt.patch_function_wrapper(__name__, 'global_function_3_enabled_callable', enabled=enabled)\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        result = global_function_3_enabled_callable(*_args, **_kwargs)\n\n        enable = True\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called, [])\n\n        result = global_function_3_enabled_callable(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_function_module(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        module = sys.modules[__name__]\n\n        @wrapt.patch_function_wrapper(module, 'global_function_4')\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        result = global_function_4(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def _test_transient_function_wrapper(self, *args, **kwargs):\n        return args, kwargs\n\n    def test_transient_function_wrapper(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.transient_function_wrapper(__name__,\n                'TestMonkeyPatching._test_transient_function_wrapper')\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(wrapped, self._test_transient_function_wrapper)\n            self.assertEqual(instance, self)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @wrapper\n        def function(*args, **kwargs):\n            return self._test_transient_function_wrapper(*args, **kwargs)\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_transient_function_wrapper_instance_method(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        _self = self\n\n        class wrapper(object):\n            @wrapt.transient_function_wrapper(__name__,\n                    'TestMonkeyPatching._test_transient_function_wrapper')\n            def __call__(self, wrapped, instance, args, kwargs):\n                called.append((args, kwargs))\n                _self.assertEqual(wrapped, _self._test_transient_function_wrapper)\n                _self.assertEqual(instance, _self)\n                _self.assertEqual(args, _args)\n                _self.assertEqual(kwargs, _kwargs)\n                return wrapped(*args, **kwargs)\n\n        @wrapper()\n        def function(*args, **kwargs):\n            return self._test_transient_function_wrapper(*args, **kwargs)\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\nclass TestExplicitMonkeyPatching(unittest.TestCase):\n\n    def test_patch_instance_method_class(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.function_wrapper\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, _instance)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        Class.function = wrapper(Class.function)\n\n        _instance = Class()\n\n        result = _instance.function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_instance_method_dict(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.function_wrapper\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, _instance)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        Class.function = wrapper(vars(Class)['function'])\n\n        _instance = Class()\n\n        result = _instance.function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_instance_method_instance(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.function_wrapper\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, _instance)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        _instance = Class()\n\n        _instance.function = wrapper(_instance.function)\n\n        result = _instance.function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\n    def test_patch_instance_method_extracted(self):\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        called = []\n\n        @wrapt.function_wrapper\n        def wrapper(wrapped, instance, args, kwargs):\n            called.append((args, kwargs))\n            self.assertEqual(instance, _instance)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        _instance = Class()\n\n        function = wrapper(_instance.function)\n\n        result = function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(called[0], (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_update_attributes.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\nclass TestUpdateAttributes(unittest.TestCase):\n\n    def test_update_name(self):\n        @passthru_decorator\n        def function():\n            pass\n\n        self.assertEqual(function.__name__, 'function')\n\n        function.__name__ = 'override_name'\n\n        self.assertEqual(function.__name__, 'override_name')\n\n    def test_update_name_modified_on_original(self):\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        instance = wrapt.FunctionWrapper(function, wrapper)\n\n        self.assertEqual(instance.__name__, 'function')\n\n        instance.__name__ = 'override_name'\n\n        self.assertEqual(function.__name__, 'override_name')\n        self.assertEqual(instance.__name__, 'override_name')\n\n    def test_update_qualname(self):\n\n        @passthru_decorator\n        def function():\n            pass\n\n        if PY3:\n            method = self.test_update_qualname\n            self.assertEqual(function.__qualname__,\n                    (method.__qualname__ + '.<locals>.function'))\n\n        function.__qualname__ = 'override_qualname'\n\n        self.assertEqual(function.__qualname__, 'override_qualname')\n\n    def test_update_qualname_modified_on_original(self):\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        instance = wrapt.FunctionWrapper(function, wrapper)\n\n        if PY3:\n            method = self.test_update_qualname_modified_on_original\n            self.assertEqual(instance.__qualname__,\n                    (method.__qualname__ + '.<locals>.function'))\n\n        instance.__qualname__ = 'override_qualname'\n\n        self.assertEqual(function.__qualname__, 'override_qualname')\n        self.assertEqual(instance.__qualname__, 'override_qualname')\n\n    def test_update_module(self):\n        @passthru_decorator\n        def function():\n            pass\n\n        self.assertEqual(function.__module__, __name__)\n\n        function.__module__ = 'override_module'\n\n        self.assertEqual(function.__module__, 'override_module')\n\n    def test_update_module_modified_on_original(self):\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        instance = wrapt.FunctionWrapper(function, wrapper)\n\n        self.assertEqual(instance.__module__, __name__)\n\n        instance.__module__ = 'override_module'\n\n        self.assertEqual(function.__module__, 'override_module')\n        self.assertEqual(instance.__module__, 'override_module')\n\n    def test_update_doc(self):\n        @passthru_decorator\n        def function():\n            \"\"\"documentation\"\"\"\n            pass\n\n        self.assertEqual(function.__doc__, \"documentation\")\n\n        function.__doc__ = 'override_doc'\n\n        self.assertEqual(function.__doc__, 'override_doc')\n\n    def test_update_doc_modified_on_original(self):\n        def function():\n            \"\"\"documentation\"\"\"\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        instance = wrapt.FunctionWrapper(function, wrapper)\n\n        self.assertEqual(instance.__doc__, \"documentation\")\n\n        instance.__doc__ = 'override_doc'\n\n        self.assertEqual(function.__doc__, 'override_doc')\n        self.assertEqual(instance.__doc__, 'override_doc')\n\n    def test_update_annotations(self):\n        @passthru_decorator\n        def function():\n            pass\n\n        if PY3:\n            self.assertEqual(function.__annotations__, {})\n\n        else:\n            def run(*args):\n                function.__annotations__\n\n            self.assertRaises(AttributeError, run, ())\n\n        override_annotations = {'override_annotations': ''}\n        function.__annotations__ = override_annotations\n\n        self.assertEqual(function.__wrapped__.__annotations__, override_annotations)\n        self.assertEqual(function.__annotations__, override_annotations)\n\n    def test_update_annotations_modified_on_original(self):\n        def function():\n            pass\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        instance = wrapt.FunctionWrapper(function, wrapper)\n\n        if PY3:\n            self.assertEqual(instance.__annotations__, {})\n\n        else:\n            def run(*args):\n                instance.__annotations__\n\n            self.assertRaises(AttributeError, run, ())\n\n        override_annotations = {'override_annotations': ''}\n        instance.__annotations__ = override_annotations\n\n        self.assertEqual(function.__annotations__, override_annotations)\n        self.assertEqual(instance.__annotations__, override_annotations)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_pickle.py": "from __future__ import print_function\n\nimport unittest\n\nimport pickle\n\nimport wrapt\n\nclass CustomObjectProxy(wrapt.ObjectProxy):\n\n    def __reduce_ex__(self, proto):\n        return (list, (self.__wrapped__,))\n\nclass TestObjectPickle(unittest.TestCase):\n\n    def test_pickle(self):\n        proxy = wrapt.ObjectProxy([1])\n\n        with self.assertRaises(NotImplementedError) as context:\n            data = pickle.dumps(proxy)\n\n        self.assertTrue(str(context.exception) ==\n                'object proxy must define __reduce_ex__()')\n\n    def test_pickle_proxy(self):\n        proxy1 = CustomObjectProxy([1])\n        pickled = pickle.dumps(proxy1)\n        restored = pickle.loads(pickled)\n\n        self.assertEqual(proxy1.__wrapped__, restored)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_adapter_py33.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\ndef prototype(arg1, arg2, *, arg3=None, **kwargs): pass\n@wrapt.decorator(adapter=prototype)\ndef adapter1(wrapped, instance, args, kwargs):\n    '''adapter documentation'''\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\ndef function1(arg1, arg2):\n    '''documentation'''\n    return arg1, arg2\n\nfunction1o = function1\n\n@decorators.adapter1\ndef function1(arg1, arg2):\n    '''documentation'''\n    return arg1, arg2\n\nfunction1d = function1\n\nclass TestArgumentSpecification(unittest.TestCase):\n\n    def test_getfullargspec(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        def _adapter(arg1, arg2, *, arg3=None, **kwargs): pass\n\n        function1a_argspec = inspect.getfullargspec(_adapter)\n        function1d_argspec = inspect.getfullargspec(function1d)\n        self.assertEqual(function1a_argspec, function1d_argspec)\n\n    def test_signature(self):\n        # Test preservation of function argument specification. It\n        # actually needs to match that of the adapter function the\n        # prototype of which was supplied via the dummy function.\n\n        if PY2:\n            return\n\n        def _adapter(arg1, arg2, *, arg3=None, **kwargs): pass\n\n        function1a_signature = str(inspect.signature(_adapter))\n        function1d_signature = str(inspect.signature(function1d))\n        self.assertEqual(function1a_signature, function1d_signature)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_decorators.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nclass TestDecorator(unittest.TestCase):\n\n    def test_no_parameters(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_method_as_decorator(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Instance(object):\n            def __init__(self):\n                self.count = 0\n            @wrapt.decorator\n            def decorator(self, wrapped, instance, args, kwargs):\n                self.count += 1\n                return wrapped(*args, **kwargs)\n\n        instance = Instance()\n\n        @instance.decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(instance.count, 1)\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(instance.count, 2)\n\n    def test_class_method_as_decorator(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Instance(object):\n            count = 0\n            @wrapt.decorator\n            @classmethod\n            def decorator(cls, wrapped, instance, args, kwargs):\n                cls.count += 1\n                return wrapped(*args, **kwargs)\n\n        @Instance.decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(Instance.count, 1)\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n        self.assertEqual(Instance.count, 2)\n\n    def test_class_type_as_decorator(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        class ClassDecorator(object):\n            def __call__(self, wrapped, instance, args, kwargs):\n                return wrapped(*args, **kwargs)\n\n        @ClassDecorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_type_as_decorator_args(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        class ClassDecorator(object):\n            def __init__(self, arg):\n                assert arg == 1\n            def __call__(self, wrapped, instance, args, kwargs):\n                return wrapped(*args, **kwargs)\n\n        @ClassDecorator(arg=1)\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_copy.py": "from __future__ import print_function\n\nimport unittest\n\nimport copy\n\nimport wrapt\n\nclass CustomObjectProxy(wrapt.ObjectProxy):\n\n    def __copy__(self):\n        return CustomObjectProxy(copy.copy(self.__wrapped__))\n\n    def __deepcopy__(self, memo):\n        return CustomObjectProxy(copy.deepcopy(self.__wrapped__, memo))\n\nclass TestObjectCopy(unittest.TestCase):\n\n    def test_copy(self):\n        proxy1 = wrapt.ObjectProxy([1])\n\n        with self.assertRaises(NotImplementedError) as context:\n            proxy2 = copy.copy(proxy1)\n\n        self.assertTrue(str(context.exception) ==\n                'object proxy must define __copy__()')\n\n    def test_deepcopy(self):\n        proxy1 = wrapt.ObjectProxy([1])\n\n        with self.assertRaises(NotImplementedError) as context:\n            proxy2 = copy.deepcopy(proxy1)\n\n        self.assertTrue(str(context.exception) ==\n                'object proxy must define __deepcopy__()')\n\n    def test_copy_proxy(self):\n        proxy1 = CustomObjectProxy([1])\n        proxy2 = copy.copy(proxy1)\n\n        self.assertTrue(type(proxy1) == type(proxy2))\n        self.assertEqual(proxy1, proxy2)\n        self.assertEqual(proxy1.__wrapped__, proxy2.__wrapped__)\n\n    def test_deepcopy_proxy(self):\n        proxy1 = CustomObjectProxy([1])\n        proxy2 = copy.deepcopy(proxy1)\n\n        self.assertTrue(type(proxy1) == type(proxy2))\n        self.assertEqual(proxy1, proxy2)\n        self.assertEqual(proxy1.__wrapped__, proxy2.__wrapped__)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_synchronized_lock.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nfrom compat import PYXY\n\n@wrapt.synchronized\ndef function():\n    print('function')\n\nclass C1(object):\n\n    @wrapt.synchronized\n    def function1(self):\n        print('function1')\n\n    @wrapt.synchronized\n    @classmethod\n    def function2(cls):\n        print('function2')\n\n    @wrapt.synchronized\n    @staticmethod\n    def function3():\n        print('function3')\n\nc1 = C1()\n\n@wrapt.synchronized\nclass C2(object):\n    pass\n\n@wrapt.synchronized\nclass C3:\n    pass\n\nclass C4(object):\n\n    # Prior to Python 3.9, this yields undesirable results due to how\n    # class method is implemented. The classmethod doesn't bind the\n    # method to the class before calling. As a consequence, the\n    # decorator wrapper function sees the instance as None with the\n    # class being explicitly passed as the first argument. It isn't\n    # possible to detect and correct this. For more details see:\n    # https://bugs.python.org/issue19072\n\n    @classmethod\n    @wrapt.synchronized\n    def function2(cls):\n        print('function2')\n\n    @staticmethod\n    @wrapt.synchronized\n    def function3():\n        print('function3')\n\nc4 = C4()\n\nclass C5(object):\n\n    def __bool__(self):\n        return False\n    __nonzero__=__bool__\n\n    @wrapt.synchronized\n    def function1(self):\n        print('function1')\n\nc5 = C5()\n\nclass TestSynchronized(unittest.TestCase):\n\n    def test_synchronized_function(self):\n        _lock0 = getattr(function, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        function()\n\n        _lock1 = getattr(function, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        function()\n\n        _lock2 = getattr(function, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        function()\n\n        _lock3 = getattr(function, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_inner_staticmethod(self):\n        _lock0 = getattr(C1.function3, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c1.function3()\n\n        _lock1 = getattr(C1.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        C1.function3()\n\n        _lock2 = getattr(C1.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        C1.function3()\n\n        _lock3 = getattr(C1.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_outer_staticmethod(self):\n        _lock0 = getattr(C4.function3, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c4.function3()\n\n        _lock1 = getattr(C4.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        C4.function3()\n\n        _lock2 = getattr(C4.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        C4.function3()\n\n        _lock3 = getattr(C4.function3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_inner_classmethod(self):\n        if hasattr(C1, '_synchronized_lock'):\n            del C1._synchronized_lock\n\n        _lock0 = getattr(C1, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c1.function2()\n\n        _lock1 = getattr(C1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        C1.function2()\n\n        _lock2 = getattr(C1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        C1.function2()\n\n        _lock3 = getattr(C1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_outer_classmethod(self):\n        # Prior to Python 3.9 this isn't detected as a class method\n        # call, as the classmethod decorator doesn't bind the wrapped\n        # function to the class before calling and just calls it direct,\n        # explicitly passing the class as first argument. For more\n        # details see: https://bugs.python.org/issue19072\n\n        if PYXY < (3, 9):\n            _lock0 = getattr(C4.function2, '_synchronized_lock', None)\n        else:\n            _lock0 = getattr(C4, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c4.function2()\n\n        if PYXY < (3, 9):\n            _lock1 = getattr(C4.function2, '_synchronized_lock', None)\n        else:\n            _lock1 = getattr(C4, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        C4.function2()\n\n        if PYXY < (3, 9):\n            _lock2 = getattr(C4.function2, '_synchronized_lock', None)\n        else:\n            _lock2 = getattr(C4, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        C4.function2()\n\n        if PYXY < (3, 9):\n            _lock3 = getattr(C4.function2, '_synchronized_lock', None)\n        else:\n            _lock3 = getattr(C4, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_instancemethod(self):\n        if hasattr(C1, '_synchronized_lock'):\n            del C1._synchronized_lock\n\n        _lock0 = getattr(c1, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        C1.function1(c1)\n\n        _lock1 = getattr(c1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        c1.function1()\n\n        _lock2 = getattr(c1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        c1.function1()\n\n        _lock3 = getattr(c1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n        del c1._synchronized_lock\n\n        C1.function2()\n\n        _lock4 = getattr(C1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock4, None)\n\n        c1.function1()\n\n        _lock5 = getattr(c1, '_synchronized_lock', None)\n        self.assertNotEqual(_lock5, None)\n        self.assertNotEqual(_lock5, _lock4)\n\n    def test_synchronized_type_new_style(self):\n        if hasattr(C2, '_synchronized_lock'):\n            del C2._synchronized_lock\n\n        _lock0 = getattr(C2, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c2 = C2()\n\n        _lock1 = getattr(C2, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        c2 = C2()\n\n        _lock2 = getattr(C2, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        c2 = C2()\n\n        _lock3 = getattr(C2, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_type_old_style(self):\n        if hasattr(C3, '_synchronized_lock'):\n            del C3._synchronized_lock\n\n        _lock0 = getattr(C3, '_synchronized_lock', None)\n        self.assertEqual(_lock0, None)\n\n        c2 = C3()\n\n        _lock1 = getattr(C3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock1, None)\n\n        c2 = C3()\n\n        _lock2 = getattr(C3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n        self.assertEqual(_lock2, _lock1)\n\n        c2 = C3()\n\n        _lock3 = getattr(C3, '_synchronized_lock', None)\n        self.assertNotEqual(_lock3, None)\n        self.assertEqual(_lock3, _lock2)\n\n    def test_synchronized_false_instance(self):\n        c5.function1()\n\n        self.assertEqual(bool(c5), False)\n\n        _lock1 = getattr(C5, '_synchronized_lock', None)\n        self.assertEqual(_lock1, None)\n\n        _lock2 = getattr(c5, '_synchronized_lock', None)\n        self.assertNotEqual(_lock2, None)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_formatargspec_py38.py": "import unittest\nimport sys\nfrom inspect import getfullargspec\n\nfrom wrapt import formatargspec\n\nclass TestFormatargspec38(unittest.TestCase):\n\n    def assertFormatEqual(self, func, ref):\n        formatted = formatargspec(*getfullargspec(func))\n        self.assertEqual(formatted, ref)\n\n    def test_formatargspec(self):\n        # exemples from https://www.python.org/dev/peps/pep-0570/\n        def name1(p1, p2, /, p_or_kw, *, kw): pass\n        self.assertFormatEqual(name1, '(p1, p2, p_or_kw, *, kw)')\n\n        def name2(p1, p2=None, /, p_or_kw=None, *, kw): pass\n        self.assertFormatEqual(name2, '(p1, p2=None, p_or_kw=None, *, kw)')\n\n        def name3(p1, p2=None, /, *, kw): pass\n        self.assertFormatEqual(name3, '(p1, p2=None, *, kw)')\n\n        def name4(p1, p2=None, /): pass\n        self.assertFormatEqual(name4, '(p1, p2=None)')\n\n        def name5(p1, p2, /, p_or_kw): pass\n        self.assertFormatEqual(name5, '(p1, p2, p_or_kw)')\n\n        def name6(p1, p2, /): pass\n        self.assertFormatEqual(name6, '(p1, p2)')\n\n        def name7(p_or_kw, *, kw): pass\n        self.assertFormatEqual(name7, '(p_or_kw, *, kw)')\n\n        def name8(*, kw): pass\n        self.assertFormatEqual(name8, '(*, kw)')\n", "tests/test_descriptors_py36.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nclass TestObjectDescriptors(unittest.TestCase):\n\n    def test_set_name(self):\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        attribute_name = []\n\n        class _descriptor_wrapper:\n            def __init__(self, descriptor):\n                self.__wrapped__ = descriptor\n\n            def __set_name__(self, owner, name):\n                attribute_name.append(name)\n\n            def __get__(self, instance, owner=None):\n                return self.__wrapped__.__get__(instance, owner)\n\n        class Instance(object):\n            @_decorator\n            @_descriptor_wrapper\n            def method(self):\n                return True\n\n        instance = Instance()\n\n        self.assertEqual(attribute_name, [\"method\"])\n        self.assertEqual(instance.method(), True)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_inheritance_py37.py": "from __future__ import print_function\n\nimport unittest\n\nimport abc\nimport _py_abc\n\nimport wrapt\n\nclass TestClassInheritance(unittest.TestCase):\n\n    def test_basic_inheritance(self):\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class B1:\n            def method(self):\n                pass\n\n        @wrapper\n        class C1(B1):\n            def method(self):\n                pass\n\n        class D1(C1):\n            def method(self):\n                pass\n\n        self.assertTrue(issubclass(B1, B1))\n        self.assertTrue(issubclass(C1, B1))\n        self.assertTrue(issubclass(D1, B1))\n\n        self.assertFalse(issubclass(B1, C1))\n        self.assertTrue(issubclass(C1, C1))\n        self.assertTrue(issubclass(D1, C1))\n\n        self.assertFalse(issubclass(B1, D1))\n        self.assertFalse(issubclass(C1, D1))\n        self.assertTrue(issubclass(D1, D1))\n\n        self.assertTrue(issubclass(B1, (B1, C1, D1)))\n        self.assertTrue(issubclass(C1, (B1, C1, D1)))\n        self.assertTrue(issubclass(D1, (B1, C1, D1)))\n\n        self.assertTrue(isinstance(C1(), B1))\n        self.assertTrue(isinstance(C1(), C1))\n        self.assertTrue(isinstance(D1(), B1))\n        self.assertTrue(isinstance(D1(), C1))\n\n        def function():\n            pass\n        class F(wrapt.FunctionWrapper):\n            pass\n        instance = F(function, wrapper)\n        self.assertTrue(isinstance(instance, wrapt.FunctionWrapper))\n\n    def test_abc_inheritance(self):\n        # XXX The checks commented out below all fail because the\n        # helpers for issubclass() via __subclasscheck__() in ABCMeta\n        # base class when C implementation is used does not support duck\n        # typing and will fail if the argument it is given is an object\n        # proxy like wrapt decorator uses. There is no known workaround\n        # for this problem.\n        #\n        #       def __subclasscheck__(cls, subclass):\n        #           \"\"\"Override for issubclass(subclass, cls).\"\"\"\n        #   >       return _abc_subclasscheck(cls, subclass)\n        #   E       TypeError: issubclass() arg 1 must be a class\n\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class A1(metaclass=abc.ABCMeta):\n            @abc.abstractmethod\n            def method(self):\n                pass\n\n        class B1(A1):\n            def method(self):\n                pass\n\n        @wrapper\n        class C1(B1):\n            def method(self):\n                pass\n\n        class D1(C1):\n            def method(self):\n                pass\n\n        self.assertTrue(issubclass(A1, A1))\n        self.assertTrue(issubclass(B1, A1))\n        # self.assertTrue(issubclass(C1, A1))\n        self.assertTrue(issubclass(D1, A1))\n\n        self.assertFalse(issubclass(A1, B1))\n        self.assertTrue(issubclass(B1, B1))\n        # self.assertTrue(issubclass(C1, B1))\n        self.assertTrue(issubclass(D1, B1))\n\n        self.assertFalse(issubclass(A1, C1))\n        self.assertFalse(issubclass(B1, C1))\n        self.assertTrue(issubclass(C1, C1))\n        self.assertTrue(issubclass(D1, C1))\n\n        self.assertFalse(issubclass(A1, D1))\n        self.assertFalse(issubclass(B1, D1))\n        # self.assertFalse(issubclass(C1, D1))\n        self.assertTrue(issubclass(D1, D1))\n\n        self.assertTrue(issubclass(A1, (A1, B1, C1, D1)))\n        self.assertTrue(issubclass(B1, (A1, B1, C1, D1)))\n        # self.assertTrue(issubclass(C1, (A1, B1, C1, D1)))\n        self.assertTrue(issubclass(D1, (A1, B1, C1, D1)))\n\n        self.assertTrue(isinstance(C1(), B1))\n        self.assertTrue(isinstance(C1(), C1))\n        self.assertTrue(isinstance(D1(), B1))\n        self.assertTrue(isinstance(D1(), C1))\n\n    def test_py_abc_inheritance(self):\n        # In contrast to above when C implementation for ABCMeta helpers\n        # are used, these all pass as have use the Python implementation\n        # instead.\n\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class A1(metaclass=_py_abc.ABCMeta):\n            @abc.abstractmethod\n            def method(self):\n                pass\n\n        class B1(A1):\n            def method(self):\n                pass\n\n        @wrapper\n        class C1(B1):\n            def method(self):\n                pass\n\n        class D1(C1):\n            def method(self):\n                pass\n\n        self.assertTrue(issubclass(A1, A1))\n        self.assertTrue(issubclass(B1, A1))\n        self.assertTrue(issubclass(C1, A1))\n        self.assertTrue(issubclass(D1, A1))\n\n        self.assertFalse(issubclass(A1, B1))\n        self.assertTrue(issubclass(B1, B1))\n        self.assertTrue(issubclass(C1, B1))\n        self.assertTrue(issubclass(D1, B1))\n\n        self.assertFalse(issubclass(A1, C1))\n        self.assertFalse(issubclass(B1, C1))\n        self.assertTrue(issubclass(C1, C1))\n        self.assertTrue(issubclass(D1, C1))\n\n        self.assertFalse(issubclass(A1, D1))\n        self.assertFalse(issubclass(B1, D1))\n        self.assertFalse(issubclass(C1, D1))\n        self.assertTrue(issubclass(D1, D1))\n\n        self.assertTrue(issubclass(A1, (A1, B1, C1, D1)))\n        self.assertTrue(issubclass(B1, (A1, B1, C1, D1)))\n        self.assertTrue(issubclass(C1, (A1, B1, C1, D1)))\n        self.assertTrue(issubclass(D1, (A1, B1, C1, D1)))\n\n        self.assertTrue(isinstance(C1(), B1))\n        self.assertTrue(isinstance(C1(), C1))\n        self.assertTrue(isinstance(D1(), B1))\n        self.assertTrue(isinstance(D1(), C1))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_weak_function_proxy.py": "from __future__ import print_function\n\nimport unittest\nimport gc\n\nimport wrapt\n\nclass TestWeakFunctionProxy(unittest.TestCase):\n\n    def test_isinstance(self):\n        def function(a, b):\n            return a, b\n\n        proxy = wrapt.WeakFunctionProxy(function)\n\n        self.assertTrue(isinstance(proxy, type(function)))\n\n    def test_no_callback(self):\n        def function(a, b):\n            return a, b\n\n        proxy = wrapt.WeakFunctionProxy(function)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        function = None\n        gc.collect()\n\n    def test_call_expired(self):\n        def function(a, b):\n            return a, b\n\n        proxy = wrapt.WeakFunctionProxy(function)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        function = None\n        gc.collect()\n\n        def run(*args):\n            proxy()\n\n        self.assertRaises(ReferenceError, run, ())\n\n    def test_function(self):\n        def function(a, b):\n            return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        proxy = wrapt.WeakFunctionProxy(function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        function = None\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_instancemethod_delete_instance(self):\n        class Class(object):\n            def function(self, a, b):\n                return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        c = Class()\n\n        proxy = wrapt.WeakFunctionProxy(c.function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        c = None\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_instancemethod_delete_function(self):\n        class Class(object):\n            def function(self, a, b):\n                return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        c = Class()\n\n        proxy = wrapt.WeakFunctionProxy(c.function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        del c\n        del Class.function\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_instancemethod_delete_function_and_instance(self):\n        class Class(object):\n            def function(self, a, b):\n                return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        c = Class()\n\n        proxy = wrapt.WeakFunctionProxy(c.function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        c = None\n        del Class.function\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_classmethod(self):\n        class Class(object):\n            @classmethod\n            def function(cls, a, b):\n                self.assertEqual(cls, Class)\n                return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        proxy = wrapt.WeakFunctionProxy(Class.function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        Class = None\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_staticmethod(self):\n        class Class(object):\n            @staticmethod\n            def function(a, b):\n                return a, b\n\n        result = []\n\n        def callback(proxy):\n            result.append(id(proxy))\n\n        proxy = wrapt.WeakFunctionProxy(Class.function, callback)\n\n        self.assertEqual(proxy(1, 2), (1, 2))\n\n        Class = None\n        gc.collect()\n\n        self.assertEqual(len(result), 1)\n        self.assertEqual(id(proxy), result[0])\n\n    def test_decorator_method(self):\n        @wrapt.decorator\n        def bark(wrapped, instance, args, kwargs):\n            return 'bark'\n\n        class Animal(object):\n            @bark\n            def squeal(self):\n                return 'squeal'\n\n        animal = Animal()\n\n        self.assertEqual(animal.squeal(), 'bark')\n\n        method = wrapt.WeakFunctionProxy(animal.squeal)\n\n        self.assertEqual(method(), 'bark')\n\nclass TestArgumentUnpackingWeakFunctionProxy(unittest.TestCase):\n\n    def test_self_keyword_argument(self):\n        def function(self, *args, **kwargs):\n            return self, args, kwargs\n\n        proxy = wrapt.WeakFunctionProxy(function)\n\n        self.assertEqual(proxy(self='self', arg1='arg1'), ('self', (), dict(arg1='arg1')))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/conftest.py": "import sys\n\ntry:\n    from pytest import File as FileCollector\nexcept ImportError:\n    from pytest.collect import File as FileCollector\n\nversion = tuple(sys.version_info[:2])\n\nclass DummyCollector(FileCollector):\n    def collect(self):\n        return []\n\ndef construct_dummy(path, parent):\n    if hasattr(DummyCollector, \"from_parent\"):\n        item = DummyCollector.from_parent(parent, fspath=path)\n        return item\n    else:\n        return DummyCollector(path, parent=parent)\n\ndef pytest_pycollect_makemodule(path, parent):\n    if '_py33' in path.basename and version < (3, 3):\n        return construct_dummy(path, parent)\n    if '_py34' in path.basename and version < (3, 4):\n        return construct_dummy(path, parent)\n    if '_py35' in path.basename and version < (3, 5):\n        return construct_dummy(path, parent)\n    if '_py36' in path.basename and version < (3, 6):\n        return construct_dummy(path, parent)\n    if '_py37' in path.basename and version < (3, 7):\n        return construct_dummy(path, parent)\n    if '_py38' in path.basename and version < (3, 8):\n        return construct_dummy(path, parent)\n    if '_py39' in path.basename and version < (3, 9):\n        return construct_dummy(path, parent)\n    if '_py310' in path.basename and version < (3, 10):\n        return construct_dummy(path, parent)\n    if '_py311' in path.basename and version < (3, 11):\n        return construct_dummy(path, parent)\n    if '_py312' in path.basename and version < (3, 12):\n        return construct_dummy(path, parent)\n    if '_py3' in path.basename and version < (3, 0):\n        return construct_dummy(path, parent)\n    if '_py2' in path.basename and version >= (3, 0):\n        return construct_dummy(path, parent)\n", "tests/test_inner_classmethod.py": "from __future__ import print_function\n\nimport unittest\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass Class(object):\n    @classmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nOriginal = Class\n\nclass Class(object):\n    @decorators.passthru_decorator\n    @classmethod\n    def function(self, arg):\n        '''documentation'''\n        return arg\n\nclass TestNamingInnerClassMethod(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class.function.__name__,\n                Original.function.__name__)\n\n    def test_instance_object_name(self):\n        # Test preservation of instance method __name__ attribute.\n\n        self.assertEqual(Class().function.__name__,\n                Original().function.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original.original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class.function.__qualname__, __qualname__)\n\n    def test_instance_object_qualname(self):\n        # Test preservation of instance method __qualname__ attribute.\n\n        try:\n            __qualname__ = Original().original.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(Class().function.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class.function.__module__,\n                Original.function.__module__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance method __module__ attribute.\n\n        self.assertEqual(Class().function.__module__,\n                Original().function.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class.function.__doc__,\n                Original.function.__doc__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance method __doc__ attribute.\n\n        self.assertEqual(Class().function.__doc__,\n                Original().function.__doc__)\n\n    def test_class_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original.function)\n        function_argspec = getfullargspec(Class.function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_instance_argspec(self):\n        # Test preservation of instance method argument specification.\n\n        original_argspec = getfullargspec(Original().function)\n        function_argspec = getfullargspec(Class().function)\n        self.assertEqual(original_argspec, function_argspec)\n\n    def test_class_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class.function,\n                type(Original.function)))\n\n    def test_instance_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(Class().function,\n                type(Original().function)))\n\nclass TestCallingInnerClassMethod(unittest.TestCase):\n\n    def test_class_call_function(self):\n        # Test calling classmethod.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function(self):\n        # Test calling classmethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_call_function_nested_decorators(self):\n        # Test calling classmethod.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_call_function_nested_decorators(self):\n        # Test calling classmethod via class instance.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        class Class(object):\n            @_decorator\n            @_decorator\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_externally_applied_wrapper(self):\n        # Test calling staticmethod via class when\n        # the decorator has been applied from external to\n        # the class using wrapping function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Class(object):\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(Class, \"_function\", _decorator)\n\n        result = Class._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_externally_applied_wrapper(self):\n        # Test calling staticmethod via class instance when\n        # the decorator has been applied from external to\n        # the class using wrapping function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Class(object):\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        wrapt.wrap_function_wrapper(Class, \"_function\", _decorator)\n\n        result = Class()._function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_class_externally_passed_wrapper(self):\n        # Test calling classmethod via class when\n        # the decorator has been applied around reference\n        # to the function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Class(object):\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        _function = _decorator(Class._function)\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instance_externally_passed_wrapper(self):\n        # Test calling classmethod via class instance when\n        # the decorator has been applied around reference\n        # to the function.\n\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        class Class(object):\n            @classmethod\n            def _function(cls, *args, **kwargs):\n                return (args, kwargs)\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, Class)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        _function = _decorator(Class()._function)\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_nested_function.py": "from __future__ import print_function\n\nimport unittest\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\ndef function1():\n    def inner(arg):\n        '''documentation'''\n        return arg\n    return inner\n\nfunction1o = function1\n\ndef function1():\n    @decorators.passthru_decorator\n    def inner(arg):\n        '''documentation'''\n        return arg\n    return inner\n\nfunction1d = function1\n\nclass TestNamingNestedFunction(unittest.TestCase):\n\n    def test_object_name(self):\n        # Test preservation of function __name__ attribute.\n\n        self.assertEqual(function1d().__name__, function1o().__name__)\n\n    def test_object_qualname(self):\n        # Test preservation of function __qualname__ attribute.\n\n        try:\n            __qualname__ = function1o().__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(function1d().__qualname__, __qualname__)\n\n    def test_module_name(self):\n        # Test preservation of function __module__ attribute.\n\n        self.assertEqual(function1d().__module__, __name__)\n\n    def test_doc_string(self):\n        # Test preservation of function __doc__ attribute.\n\n        self.assertEqual(function1d().__doc__, function1o().__doc__)\n\n    def test_argspec(self):\n        # Test preservation of function argument specification.\n\n        function1o_argspec = getfullargspec(function1o())\n        function1d_argspec = getfullargspec(function1d())\n        self.assertEqual(function1o_argspec, function1d_argspec)\n\n    def test_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(function1d(), type(function1o())))\n\nclass TestCallingNestedFunction(unittest.TestCase):\n\n    def test_call_function(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        def _function():\n            @decorators.passthru_decorator\n            def inner(*args, **kwargs):\n                return args, kwargs\n            return inner\n\n        result = _function()(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/module1.py": "import time\ntime.sleep(0.1)  # simulate slow code\n", "tests/test_class.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\nclass class1(object):\n    pass\n\nclass1o = class1\n\nclass1d = decorators.passthru_decorator(class1)\n\nclass TestIntrospection(unittest.TestCase):\n\n    def test_getmembers(self):\n        class1o_members = inspect.getmembers(class1o)\n        class1d_members = inspect.getmembers(class1d)\n\nclass TestInheritance(unittest.TestCase):\n\n    def test_single_inheritance(self):\n        @wrapt.decorator\n        def passthru(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @passthru\n        class BaseClass(object):\n            def __init__(self):\n                self.value = 1\n\n        class DerivedClass(BaseClass.__wrapped__):\n            def __init__(self):\n                super(DerivedClass, self).__init__()\n                self.value = 2\n\n        base = BaseClass()\n\n        self.assertEqual(type(base), BaseClass.__wrapped__)\n        self.assertTrue(isinstance(base, BaseClass.__wrapped__))\n        self.assertEqual(base.value, 1)\n\n        self.assertEqual(type(base).__mro__, (BaseClass.__wrapped__, object))\n\n        derived = DerivedClass()\n\n        self.assertEqual(type(derived), DerivedClass)\n        self.assertTrue(isinstance(derived, BaseClass.__wrapped__))\n        self.assertTrue(isinstance(derived, DerivedClass))\n        self.assertEqual(derived.value, 2)\n\n        self.assertEqual(type(derived).__mro__, (DerivedClass, BaseClass.__wrapped__, object))\n", "tests/module2.py": "import time\ntime.sleep(0.1)  # simulate slow code\n", "tests/test_object_proxy.py": "from __future__ import print_function\n\nimport unittest\nimport types\nimport sys\nimport re\n\nis_pypy = '__pypy__' in sys.builtin_module_names\n\nimport wrapt\n\nfrom compat import PY2, PY3, exec_\n\nOBJECTS_CODE = \"\"\"\nclass TargetBaseClass(object):\n    \"documentation\"\n\nclass Target(TargetBaseClass):\n    \"documentation\"\n\ndef target():\n    \"documentation\"\n    pass\n\"\"\"\n\nobjects = types.ModuleType('objects')\nexec_(OBJECTS_CODE, objects.__dict__, objects.__dict__)\n\nclass TestAttributeAccess(unittest.TestCase):\n\n    def test_init_not_called(self):\n        a = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        b = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            a.__wrapped__\n        except ValueError:\n            pass\n\n        try:\n            a + b\n        except ValueError:\n            pass\n\n    def test_attributes(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        self.assertEqual(function2.__wrapped__, function1)\n\n    def test_get_wrapped(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        self.assertEqual(function2.__wrapped__, function1)\n\n        function3 = wrapt.ObjectProxy(function2)\n\n        self.assertEqual(function3.__wrapped__, function1)\n\n    def test_set_wrapped(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        self.assertEqual(function2, function1)\n        self.assertEqual(function2.__wrapped__, function1)\n        self.assertEqual(function2.__name__, function1.__name__)\n\n        if PY3:\n            self.assertEqual(function2.__qualname__, function1.__qualname__)\n\n        function2.__wrapped__ = None\n\n        self.assertFalse(hasattr(function1, '__wrapped__'))\n\n        self.assertEqual(function2, None)\n        self.assertEqual(function2.__wrapped__, None)\n        self.assertFalse(hasattr(function2, '__name__'))\n\n        if PY3:\n            self.assertFalse(hasattr(function2, '__qualname__'))\n\n        def function3(*args, **kwargs):\n            return args, kwargs\n\n        function2.__wrapped__ = function3\n\n        self.assertEqual(function2, function3)\n        self.assertEqual(function2.__wrapped__, function3)\n        self.assertEqual(function2.__name__, function3.__name__)\n\n        if PY3:\n            self.assertEqual(function2.__qualname__, function3.__qualname__)\n\n    def test_delete_wrapped(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        def run(*args):\n            del function2.__wrapped__\n\n        self.assertRaises(TypeError, run, ())\n\n    def test_proxy_attribute(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        function2._self_variable = True\n\n        self.assertFalse(hasattr(function1, '_self_variable'))\n        self.assertTrue(hasattr(function2, '_self_variable'))\n\n        self.assertEqual(function2._self_variable, True)\n\n        del function2._self_variable\n\n        self.assertFalse(hasattr(function1, '_self_variable'))\n        self.assertFalse(hasattr(function2, '_self_variable'))\n\n        self.assertEqual(getattr(function2, '_self_variable', None), None)\n\n    def test_wrapped_attribute(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        function2.variable = True\n\n        self.assertTrue(hasattr(function1, 'variable'))\n        self.assertTrue(hasattr(function2, 'variable'))\n\n        self.assertEqual(function2.variable, True)\n\n        del function2.variable\n\n        self.assertFalse(hasattr(function1, 'variable'))\n        self.assertFalse(hasattr(function2, 'variable'))\n\n        self.assertEqual(getattr(function2, 'variable', None), None)\n\n    def test_attribute_lookup_modified(self):\n        class Object:\n            @property\n            def value(self):\n                return \"value\"\n\n        class WrappedObject(wrapt.ObjectProxy):\n            @property\n            def value(self):\n                return 2 * self.__wrapped__.value\n\n        WrappedObject(Object()).value == \"valuevalue\"\n\n    def test_attribute_lookup_value_exception(self):\n        class Object:\n            @property\n            def value(self):\n                return \"value\"\n\n        class WrappedObject(wrapt.ObjectProxy):\n            @property\n            def value(self):\n                raise ValueError(\"value-error\")\n\n        try:\n            WrappedObject(Object()).value == \"value\"\n\n        except ValueError as e:\n            pass\n\n        else:\n            raise RuntimeError(\"should not fail here\")\n\n    def test_attribute_lookup_attribute_exception(self):\n        class Object:\n            @property\n            def value(self):\n                return \"value\"\n\n        class WrappedObject(wrapt.ObjectProxy):\n            @property\n            def value(self):\n                raise AttributeError(\"attribute-error\")\n\n        # Raising of an AttributeError in this case is a sort of odd situation\n        # because the exception results in it being determined there was no\n        # wrapper for the value attribute and so it returns the original value\n        # instead and robs the wrapper of the chance to return an alternate\n        # value.\n\n        WrappedObject(Object()).value == \"value\"\n\nclass TestNamingObjectProxy(unittest.TestCase):\n\n    def test_class_object_name(self):\n        # Test preservation of class __name__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__name__, target.__name__)\n\n    def test_class_object_qualname(self):\n        # Test preservation of class __qualname__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        try:\n            __qualname__ = target.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(wrapper.__qualname__, __qualname__)\n\n    def test_class_module_name(self):\n        # Test preservation of class __module__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__module__, target.__module__)\n\n    def test_class_doc_string(self):\n        # Test preservation of class __doc__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__doc__, target.__doc__)\n\n    def test_instance_module_name(self):\n        # Test preservation of instance __module__ attribute.\n\n        target = objects.Target()\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__module__, target.__module__)\n\n    def test_instance_doc_string(self):\n        # Test preservation of instance __doc__ attribute.\n\n        target = objects.Target()\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__doc__, target.__doc__)\n\n    def test_function_object_name(self):\n        # Test preservation of function __name__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__name__, target.__name__)\n\n    def test_function_object_qualname(self):\n        # Test preservation of function __qualname__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        try:\n            __qualname__ = target.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(wrapper.__qualname__, __qualname__)\n\n    def test_function_module_name(self):\n        # Test preservation of function __module__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__module__, target.__module__)\n\n    def test_function_doc_string(self):\n        # Test preservation of function __doc__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__doc__, target.__doc__)\n\nclass TestTypeObjectProxy(unittest.TestCase):\n\n    def test_class_of_class(self):\n        # Test preservation of class __class__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__class__, target.__class__)\n\n        self.assertTrue(isinstance(wrapper, type(target)))\n\n    def test_class_of_instance(self):\n        # Test preservation of instance __class__ attribute.\n\n        target = objects.Target()\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__class__, target.__class__)\n\n        self.assertTrue(isinstance(wrapper, objects.Target))\n        self.assertTrue(isinstance(wrapper, objects.TargetBaseClass))\n\n    def test_class_of_function(self):\n        # Test preservation of function __class__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(wrapper.__class__, target.__class__)\n\n        self.assertTrue(isinstance(wrapper, type(target)))\n\nclass TestDirObjectProxy(unittest.TestCase):\n\n    def test_dir_of_class(self):\n        # Test preservation of class __dir__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(dir(wrapper), dir(target))\n\n    def test_vars_of_class(self):\n        # Test preservation of class __dir__ attribute.\n\n        target = objects.Target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(vars(wrapper), vars(target))\n\n    def test_dir_of_instance(self):\n        # Test preservation of instance __dir__ attribute.\n\n        target = objects.Target()\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(dir(wrapper), dir(target))\n\n    def test_vars_of_instance(self):\n        # Test preservation of instance __dir__ attribute.\n\n        target = objects.Target()\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(vars(wrapper), vars(target))\n\n    def test_dir_of_function(self):\n        # Test preservation of function __dir__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(dir(wrapper), dir(target))\n\n    def test_vars_of_function(self):\n        # Test preservation of function __dir__ attribute.\n\n        target = objects.target\n        wrapper = wrapt.ObjectProxy(target)\n\n        self.assertEqual(vars(wrapper), vars(target))\n\nclass TestCallingObject(unittest.TestCase):\n\n    def test_function_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_function_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_function_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_function_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        def function(*args, **kwargs):\n            return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_via_class_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(Class())\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_via_class_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(Class(), *_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_via_class_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(Class(), **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_instancemethod_via_class_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            def function(self, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(Class(), *_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_via_class_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_via_class_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_via_class_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_classmethod_via_class_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @classmethod\n            def function(cls, *args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class().function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_via_class_no_args(self):\n        _args = ()\n        _kwargs = {}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper()\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_via_class_args(self):\n        _args = (1, 2)\n        _kwargs = {}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(*_args)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_via_class_kwargs(self):\n        _args = ()\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(**_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\n    def test_staticmethod_via_class_args_plus_kwargs(self):\n        _args = (1, 2)\n        _kwargs = {\"one\": 1, \"two\": 2}\n\n        class Class(object):\n            @staticmethod\n            def function(*args, **kwargs):\n                return args, kwargs\n\n        wrapper = wrapt.CallableObjectProxy(Class.function)\n\n        result = wrapper(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nclass TestIterObjectProxy(unittest.TestCase):\n\n    def test_iteration(self):\n        items = [1, 2]\n\n        wrapper = wrapt.ObjectProxy(items)\n\n        result = [x for x in wrapper]\n\n        self.assertEqual(result, items)\n\nclass TestContextManagerObjectProxy(unittest.TestCase):\n\n    def test_context_manager(self):\n        class Class(object):\n            def __enter__(self):\n                return self\n            def __exit__(*args, **kwargs):\n                return\n\n        instance = Class()\n\n        wrapper = wrapt.ObjectProxy(instance)\n\n        with wrapper:\n            pass\n\nclass TestEqualityObjectProxy(unittest.TestCase):\n\n    def test_object_hash(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        self.assertEqual(hash(function2), hash(function1))\n\n    def test_mapping_key(self):\n        def function1(*args, **kwargs):\n            return args, kwargs\n        function2 = wrapt.ObjectProxy(function1)\n\n        table = dict()\n        table[function1] = True\n\n        self.assertTrue(table.get(function2))\n\n        table = dict()\n        table[function2] = True\n\n        self.assertTrue(table.get(function1))\n\n    def test_comparison(self):\n        one = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertTrue(two > 1)\n        self.assertTrue(two >= 1)\n        self.assertTrue(two < 3)\n        self.assertTrue(two <= 3)\n        self.assertTrue(two != 1)\n        self.assertTrue(two == 2)\n        self.assertTrue(two != 3)\n\n        self.assertTrue(2 > one)\n        self.assertTrue(2 >= one)\n        self.assertTrue(2 < three)\n        self.assertTrue(2 <= three)\n        self.assertTrue(2 != one)\n        self.assertTrue(2 == two)\n        self.assertTrue(2 != three)\n\n        self.assertTrue(two > one)\n        self.assertTrue(two >= one)\n        self.assertTrue(two < three)\n        self.assertTrue(two <= three)\n        self.assertTrue(two != one)\n        self.assertTrue(two == two)\n        self.assertTrue(two != three)\n\nclass TestAsNumberObjectProxy(unittest.TestCase):\n\n    def test_nonzero(self):\n        true = wrapt.ObjectProxy(True)\n        false = wrapt.ObjectProxy(False)\n\n        self.assertTrue(true)\n        self.assertFalse(false)\n\n        self.assertTrue(bool(true))\n        self.assertFalse(bool(false))\n\n        self.assertTrue(not false)\n        self.assertFalse(not true)\n\n    def test_int(self):\n        one = wrapt.ObjectProxy(1)\n\n        self.assertEqual(int(one), 1)\n\n        if not PY3:\n            self.assertEqual(long(one), 1)\n\n    def test_float(self):\n        one = wrapt.ObjectProxy(1)\n\n        self.assertEqual(float(one), 1.0)\n\n    def test_add(self):\n        one = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n\n        self.assertEqual(one+two, 1+2)\n        self.assertEqual(1+two, 1+2)\n        self.assertEqual(one+2, 1+2)\n\n    def test_add_uninitialized_args(self):\n        result = object()\n\n        one = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        two = wrapt.ObjectProxy(2)\n\n        try:\n            assert one + two == result\n        except ValueError:\n            pass\n\n        one = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert one + two == result\n        except ValueError:\n            pass\n\n    def test_sub(self):\n        one = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n\n        self.assertEqual(one-two, 1-2)\n        self.assertEqual(1-two, 1-2)\n        self.assertEqual(one-2, 1-2)\n\n    def test_sub_uninitialized_args(self):\n        result = object()\n\n        one = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        two = wrapt.ObjectProxy(2)\n\n        try:\n            assert one - two == result\n        except ValueError:\n            pass\n\n        one = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert one - two == result\n        except ValueError:\n            pass\n\n    def test_mul(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(two*three, 2*3)\n        self.assertEqual(2*three, 2*3)\n        self.assertEqual(two*3, 2*3)\n\n    def test_mul_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert two * three == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert two * three == result\n        except ValueError:\n            pass\n\n    def test_div(self):\n        # On Python 2 this will pick up div and on Python\n        # 3 it will pick up truediv.\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(two/three, 2/3)\n        self.assertEqual(2/three, 2/3)\n        self.assertEqual(two/3, 2/3)\n\n    def test_div_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert two / three == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert two / three == result\n        except ValueError:\n            pass\n\n    def test_floordiv(self):\n        two = wrapt.ObjectProxy(2)\n        four = wrapt.ObjectProxy(4)\n\n        self.assertEqual(four//two, 4//2)\n        self.assertEqual(4//two, 4//2)\n        self.assertEqual(four//2, 4//2)\n\n    def test_floordiv_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        four = wrapt.ObjectProxy(4)\n\n        try:\n            assert two // four == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        four = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert two // four == result\n        except ValueError:\n            pass\n\n    def test_mod(self):\n        two = wrapt.ObjectProxy(2)\n        four = wrapt.ObjectProxy(4)\n\n        self.assertEqual(four % two, 4 % 2)\n        self.assertEqual(4 % two, 4 % 2)\n        self.assertEqual(four % 2, 4 % 2)\n\n    def test_mod_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        four = wrapt.ObjectProxy(4)\n\n        try:\n            assert two % four == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        four = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert two % four == result\n        except ValueError:\n            pass\n\n    def test_divmod(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(divmod(three, two), divmod(3, 2))\n        self.assertEqual(divmod(3, two), divmod(3, 2))\n        self.assertEqual(divmod(three, 2), divmod(3, 2))\n\n    def test_divmod_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert divmod(two, three) == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert divmod(two, three) == result\n        except ValueError:\n            pass\n\n    def test_pow(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three**two, pow(3, 2))\n        self.assertEqual(3**two, pow(3, 2))\n        self.assertEqual(three**2, pow(3, 2))\n\n        self.assertEqual(pow(three, two), pow(3, 2))\n        self.assertEqual(pow(3, two), pow(3, 2))\n        self.assertEqual(pow(three, 2), pow(3, 2))\n\n        # Only PyPy implements __rpow__ for ternary pow().\n        # Note: No longer test for this as pypy 3.9+ seems\n        # to have been updated to not support ternary pow()\n        # in same way.\n\n        # if is_pypy:\n        #     self.assertEqual(pow(three, two, 2), pow(3, 2, 2))\n        #     self.assertEqual(pow(3, two, 2), pow(3, 2, 2))\n\n        self.assertEqual(pow(three, 2, 2), pow(3, 2, 2))\n\n    def test_pow_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three**two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three**two == result\n        except ValueError:\n            pass\n\n    def test_lshift(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three << two, 3 << 2)\n        self.assertEqual(3 << two, 3 << 2)\n        self.assertEqual(three << 2, 3 << 2)\n\n    def test_lshift_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three << two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three << two == result\n        except ValueError:\n            pass\n\n    def test_rshift(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three >> two, 3 >> 2)\n        self.assertEqual(3 >> two, 3 >> 2)\n        self.assertEqual(three >> 2, 3 >> 2)\n\n    def test_rshift_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three >> two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three >> two == result\n        except ValueError:\n            pass\n\n    def test_and(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three & two, 3 & 2)\n        self.assertEqual(3 & two, 3 & 2)\n        self.assertEqual(three & 2, 3 & 2)\n\n    def test_and_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three & two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three & two == result\n        except ValueError:\n            pass\n\n    def test_xor(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three ^ two, 3 ^ 2)\n        self.assertEqual(3 ^ two, 3 ^ 2)\n        self.assertEqual(three ^ 2, 3 ^ 2)\n\n    def test_xor_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three ^ two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three ^ two == result\n        except ValueError:\n            pass\n\n    def test_or(self):\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy(3)\n\n        self.assertEqual(three | two, 3 | 2)\n        self.assertEqual(3 | two, 3 | 2)\n        self.assertEqual(three | 2, 3 | 2)\n\n    def test_or_uninitialized_args(self):\n        result = object()\n\n        two = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n        three = wrapt.ObjectProxy(3)\n\n        try:\n            assert three | two == result\n        except ValueError:\n            pass\n\n        two = wrapt.ObjectProxy(2)\n        three = wrapt.ObjectProxy.__new__(wrapt.ObjectProxy)\n\n        try:\n            assert three | two == result\n        except ValueError:\n            pass\n\n    def test_iadd(self):\n        value = wrapt.ObjectProxy(1)\n        one = wrapt.ObjectProxy(1)\n\n        value += 1\n        self.assertEqual(value, 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value += one\n        self.assertEqual(value, 3)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_isub(self):\n        value = wrapt.ObjectProxy(1)\n        one = wrapt.ObjectProxy(1)\n\n        value -= 1\n        self.assertEqual(value, 0)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value -= one\n        self.assertEqual(value, -1)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_imul(self):\n        value = wrapt.ObjectProxy(2)\n        two = wrapt.ObjectProxy(2)\n\n        value *= 2\n        self.assertEqual(value, 4)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value *= two\n        self.assertEqual(value, 8)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_idiv(self):\n        # On Python 2 this will pick up div and on Python\n        # 3 it will pick up truediv.\n\n        value = wrapt.ObjectProxy(2)\n        two = wrapt.ObjectProxy(2)\n\n        value /= 2\n        self.assertEqual(value, 2/2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value /= two\n        self.assertEqual(value, 2/2/2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ifloordiv(self):\n        value = wrapt.ObjectProxy(2)\n        two = wrapt.ObjectProxy(2)\n\n        value //= 2\n        self.assertEqual(value, 2//2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value //= two\n        self.assertEqual(value, 2//2//2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_imod(self):\n        value = wrapt.ObjectProxy(10)\n        two = wrapt.ObjectProxy(2)\n\n        value %= 2\n        self.assertEqual(value, 10 % 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value %= two\n        self.assertEqual(value, 10 % 2 % 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ipow(self):\n        value = wrapt.ObjectProxy(10)\n        two = wrapt.ObjectProxy(2)\n\n        value **= 2\n        self.assertEqual(value, 10**2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value **= two\n        self.assertEqual(value, 10**2**2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ilshift(self):\n        value = wrapt.ObjectProxy(256)\n        two = wrapt.ObjectProxy(2)\n\n        value <<= 2\n        self.assertEqual(value, 256 << 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value <<= two\n        self.assertEqual(value, 256 << 2 << 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_irshift(self):\n        value = wrapt.ObjectProxy(2)\n        two = wrapt.ObjectProxy(2)\n\n        value >>= 2\n        self.assertEqual(value, 2 >> 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value >>= two\n        self.assertEqual(value, 2 >> 2 >> 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_iand(self):\n        value = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n\n        value &= 2\n        self.assertEqual(value, 1 & 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value &= two\n        self.assertEqual(value, 1 & 2 & 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ixor(self):\n        value = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n\n        value ^= 2\n        self.assertEqual(value, 1 ^ 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value ^= two\n        self.assertEqual(value, 1 ^ 2 ^ 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ior(self):\n        value = wrapt.ObjectProxy(1)\n        two = wrapt.ObjectProxy(2)\n\n        value |= 2\n        self.assertEqual(value, 1 | 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n        value |= two\n        self.assertEqual(value, 1 | 2 | 2)\n\n        self.assertEqual(type(value), wrapt.ObjectProxy)\n\n    def test_ior_list_self(self):\n        value = wrapt.ObjectProxy([])\n\n        try:\n            value |= value\n        except TypeError:\n            pass\n\n    def test_neg(self):\n        value = wrapt.ObjectProxy(1)\n\n        self.assertEqual(-value, -1)\n\n    def test_pos(self):\n        value = wrapt.ObjectProxy(1)\n\n        self.assertEqual(+value, 1)\n\n    def test_abs(self):\n        value = wrapt.ObjectProxy(-1)\n\n        self.assertEqual(abs(value), 1)\n\n    def test_invert(self):\n        value = wrapt.ObjectProxy(1)\n\n        self.assertEqual(~value, ~1)\n\n    def test_oct(self):\n        value = wrapt.ObjectProxy(20)\n\n        self.assertEqual(oct(value), oct(20))\n\n    def test_hex(self):\n        value = wrapt.ObjectProxy(20)\n\n        self.assertEqual(hex(value), hex(20))\n\n    def test_index(self):\n        class Class(object):\n            def __index__(self):\n                return 1\n        value = wrapt.ObjectProxy(Class())\n        items = [0, 1, 2]\n\n        self.assertEqual(items[value], items[1])\n\nclass TestAsSequenceObjectProxy(unittest.TestCase):\n\n    def test_length(self):\n        value = wrapt.ObjectProxy(list(range(3)))\n\n        self.assertEqual(len(value), 3)\n\n    def test_contains(self):\n        value = wrapt.ObjectProxy(list(range(3)))\n\n        self.assertTrue(2 in value)\n        self.assertFalse(-2 in value)\n\n    def test_getitem(self):\n        value = wrapt.ObjectProxy(list(range(3)))\n\n        self.assertEqual(value[1], 1)\n\n    def test_setitem(self):\n        value = wrapt.ObjectProxy(list(range(3)))\n        value[1] = -1\n\n        self.assertEqual(value[1], -1)\n\n    def test_delitem(self):\n        value = wrapt.ObjectProxy(list(range(3)))\n\n        self.assertEqual(len(value), 3)\n\n        del value[1]\n\n        self.assertEqual(len(value), 2)\n        self.assertEqual(value[1], 2)\n\n    def test_getslice(self):\n        value = wrapt.ObjectProxy(list(range(5)))\n\n        self.assertEqual(value[1:4], [1, 2, 3])\n\n    def test_setslice(self):\n        value = wrapt.ObjectProxy(list(range(5)))\n\n        value[1:4] = reversed(value[1:4])\n\n        self.assertEqual(value[1:4], [3, 2, 1])\n\n    def test_delslice(self):\n        value = wrapt.ObjectProxy(list(range(5)))\n\n        del value[1:4]\n\n        self.assertEqual(len(value), 2)\n        self.assertEqual(value, [0, 4])\n\nclass TestAsMappingObjectProxy(unittest.TestCase):\n\n    def test_length(self):\n        value = wrapt.ObjectProxy(dict.fromkeys(range(3), False))\n\n        self.assertEqual(len(value), 3)\n\n    def test_contains(self):\n        value = wrapt.ObjectProxy(dict.fromkeys(range(3), False))\n\n        self.assertTrue(2 in value)\n        self.assertFalse(-2 in value)\n\n    def test_getitem(self):\n        value = wrapt.ObjectProxy(dict.fromkeys(range(3), False))\n\n        self.assertEqual(value[1], False)\n\n    def test_setitem(self):\n        value = wrapt.ObjectProxy(dict.fromkeys(range(3), False))\n        value[1] = True\n\n        self.assertEqual(value[1], True)\n\n    def test_delitem(self):\n        value = wrapt.ObjectProxy(dict.fromkeys(range(3), False))\n\n        self.assertEqual(len(value), 3)\n\n        del value[1]\n\n        self.assertEqual(len(value), 2)\n\nclass TestObjectRepresentationObjectProxy(unittest.TestCase):\n\n    def test_str(self):\n        value = wrapt.ObjectProxy(10)\n\n        self.assertEqual(str(value), str(10))\n\n        value = wrapt.ObjectProxy((10,))\n\n        self.assertEqual(str(value), str((10,)))\n\n        value = wrapt.ObjectProxy([10])\n\n        self.assertEqual(str(value), str([10]))\n\n        value = wrapt.ObjectProxy({10: 10})\n\n        self.assertEqual(str(value), str({10: 10}))\n\n    def test_repr(self):\n        number = 10\n        value = wrapt.ObjectProxy(number)\n\n        self.assertNotEqual(repr(value).find('ObjectProxy at'), -1)\n\nclass TestDerivedClassCreation(unittest.TestCase):\n\n    def test_derived_new(self):\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n\n            def __new__(cls, wrapped):\n                instance = super(DerivedObjectProxy, cls).__new__(cls)\n                instance.__init__(wrapped)\n\n            def __init__(self, wrapped):\n                super(DerivedObjectProxy, self).__init__(wrapped)\n\n        def function():\n            pass\n\n        obj = DerivedObjectProxy(function)\n\n    def test_derived_setattr(self):\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n\n            def __init__(self, wrapped):\n                self._self_attribute = True\n                super(DerivedObjectProxy, self).__init__(wrapped)\n\n        def function():\n            pass\n\n        obj = DerivedObjectProxy(function)\n\n    def test_derived_missing_init(self):\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n\n            def __init__(self, wrapped):\n                self.__wrapped__ = wrapped\n\n        def function():\n            pass\n\n        obj = DerivedObjectProxy(function)\n\n        self.assertEqual(function, obj)\n        self.assertEqual(function, obj.__wrapped__)\n\nclass DerivedClassAttributes(unittest.TestCase):\n\n    def test_setup_class_attributes(self):\n\n        def function():\n            pass\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n            pass\n\n        obj = DerivedObjectProxy(function)\n\n        DerivedObjectProxy.ATTRIBUTE = 1\n\n        self.assertEqual(obj.ATTRIBUTE, 1)\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n        del DerivedObjectProxy.ATTRIBUTE\n\n        self.assertFalse(hasattr(DerivedObjectProxy, 'ATTRIBUTE'))\n        self.assertFalse(hasattr(obj, 'ATTRIBUTE'))\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n    def test_override_class_attributes(self):\n\n        def function():\n            pass\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n            ATTRIBUTE = 1\n\n        obj = DerivedObjectProxy(function)\n\n        self.assertEqual(DerivedObjectProxy.ATTRIBUTE, 1)\n        self.assertEqual(obj.ATTRIBUTE, 1)\n\n        obj.ATTRIBUTE = 2\n\n        self.assertEqual(DerivedObjectProxy.ATTRIBUTE, 1)\n\n        self.assertEqual(obj.ATTRIBUTE, 2)\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n        del DerivedObjectProxy.ATTRIBUTE\n\n        self.assertFalse(hasattr(DerivedObjectProxy, 'ATTRIBUTE'))\n        self.assertEqual(obj.ATTRIBUTE, 2)\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n    def test_class_properties(self):\n\n        def function():\n            pass\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n            def __init__(self, wrapped):\n                super(DerivedObjectProxy, self).__init__(wrapped)\n                self._self_attribute = 1\n            @property\n            def ATTRIBUTE(self):\n                return self._self_attribute\n            @ATTRIBUTE.setter\n            def ATTRIBUTE(self, value):\n                self._self_attribute = value\n            @ATTRIBUTE.deleter\n            def ATTRIBUTE(self):\n                del self._self_attribute\n\n        obj = DerivedObjectProxy(function)\n\n        self.assertEqual(obj.ATTRIBUTE, 1)\n\n        obj.ATTRIBUTE = 2\n\n        self.assertEqual(obj.ATTRIBUTE, 2)\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n        del obj.ATTRIBUTE\n\n        self.assertFalse(hasattr(obj, 'ATTRIBUTE'))\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n        obj.ATTRIBUTE = 1\n\n        self.assertEqual(obj.ATTRIBUTE, 1)\n\n        obj.ATTRIBUTE = 2\n\n        self.assertEqual(obj.ATTRIBUTE, 2)\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\n        del obj.ATTRIBUTE\n\n        self.assertFalse(hasattr(obj, 'ATTRIBUTE'))\n        self.assertFalse(hasattr(function, 'ATTRIBUTE'))\n\nclass OverrideAttributeAccess(unittest.TestCase):\n\n    def test_attr_functions(self):\n\n        def function():\n            pass\n\n        proxy = wrapt.ObjectProxy(function)\n\n        self.assertTrue(hasattr(proxy, '__getattr__'))\n        self.assertTrue(hasattr(proxy, '__setattr__'))\n        self.assertTrue(hasattr(proxy, '__delattr__'))\n\n    def test_override_getattr(self):\n\n        def function():\n            pass\n\n        accessed = []\n\n        class DerivedObjectProxy(wrapt.ObjectProxy):\n            def __getattr__(self, name):\n                accessed.append(name)\n                try:\n                    __getattr__ = super(DerivedObjectProxy, self).__getattr__\n                except AttributeError as e:\n                    raise RuntimeError(str(e))\n                return __getattr__(name)\n\n        function.attribute = 1\n\n        proxy = DerivedObjectProxy(function)\n\n        self.assertEqual(proxy.attribute, 1)\n\n        self.assertTrue('attribute' in accessed)\n\nclass CallableFunction(unittest.TestCase):\n\n    def test_proxy_hasattr_call(self):\n        proxy = wrapt.ObjectProxy(None)\n\n        self.assertFalse(hasattr(proxy, '__call__'))\n\n    def test_proxy_getattr_call(self):\n        proxy = wrapt.ObjectProxy(None)\n\n        self.assertEqual(getattr(proxy, '__call__', None), None)\n\n    def test_proxy_is_callable(self):\n        proxy = wrapt.ObjectProxy(None)\n\n        self.assertFalse(callable(proxy))\n\n    def test_callable_proxy_hasattr_call(self):\n        proxy = wrapt.CallableObjectProxy(None)\n\n        self.assertTrue(hasattr(proxy, '__call__'))\n\n    def test_callable_proxy_getattr_call(self):\n        proxy = wrapt.CallableObjectProxy(None)\n\n        self.assertTrue(getattr(proxy, '__call__', None), None)\n\n    def test_callable_proxy_is_callable(self):\n        proxy = wrapt.CallableObjectProxy(None)\n\n        self.assertTrue(callable(proxy))\n\nclass SpecialMethods(unittest.TestCase):\n\n    def test_class_bytes(self):\n        if PY3:\n            class Class(object):\n                def __bytes__(self):\n                    return b'BYTES'\n            instance = Class()\n\n            proxy = wrapt.ObjectProxy(instance)\n\n            self.assertEqual(bytes(instance), bytes(proxy))\n\n    def test_str_format(self):\n        instance = 'abcd'\n\n        proxy = wrapt.ObjectProxy(instance)\n\n        self.assertEqual(format(instance, ''), format(proxy, ''))\n\n    def test_list_reversed(self):\n        instance = [1, 2]\n\n        proxy = wrapt.ObjectProxy(instance)\n\n        self.assertEqual(list(reversed(instance)), list(reversed(proxy)))\n\n    def test_complex(self):\n        instance = 1.0+2j\n\n        proxy = wrapt.ObjectProxy(instance)\n\n        self.assertEqual(complex(instance), complex(proxy))\n\n    def test_decimal_complex(self):\n        import decimal\n\n        instance = decimal.Decimal(123)\n\n        proxy = wrapt.ObjectProxy(instance)\n\n        self.assertEqual(complex(instance), complex(proxy))\n\n    def test_fractions_round(self):\n        import fractions\n\n        instance = fractions.Fraction('1/2')\n\n        proxy = wrapt.ObjectProxy(instance)\n\n        self.assertEqual(round(instance), round(proxy))\n\nclass TestArgumentUnpacking(unittest.TestCase):\n\n    def test_self_keyword_argument_on_dict(self):\n        # A dict when given self as keyword argument uses it to create item in\n        # the dict and no attempt is made to use a positional argument.\n\n        d = wrapt.CallableObjectProxy(dict)(self='self')\n\n        self.assertEqual(d, dict(self='self'))\n\n    def test_self_positional_argument_on_class_init(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        o = Object('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n        o = wrapt.CallableObjectProxy(Object)('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n    def test_self_keyword_argument_on_class_init_1(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.CallableObjectProxy(Object)(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_2(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.CallableObjectProxy(Object)(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_renamed(self):\n        class Object:\n            def __init__(_self, *args, **kwargs):\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n        o = wrapt.CallableObjectProxy(Object)(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n    def test_self_keyword_argument_on_class_init_overloaded_1(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n        o = wrapt.CallableObjectProxy(Object)(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n    def test_self_keyword_argument_on_class_init_overloaded_2(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.CallableObjectProxy(Object)(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\nclass TestArgumentUnpackingPartial(unittest.TestCase):\n\n    def test_self_keyword_argument_on_dict_1(self):\n        # A dict when given self as keyword argument uses it to create item in\n        # the dict and no attempt is made to use a positional argument.\n\n        wrapper = wrapt.PartialCallableObjectProxy(dict, arg1='arg1')\n\n        d = wrapper(self='self')\n\n        self.assertEqual(d, dict(self='self', arg1='arg1'))\n\n    def test_self_keyword_argument_on_dict_2(self):\n        # A dict when given self as keyword argument uses it to create item in\n        # the dict and no attempt is made to use a positional argument.\n\n        wrapper = wrapt.PartialCallableObjectProxy(dict, self='self')\n\n        d = wrapper(arg1='arg1')\n\n        self.assertEqual(d, dict(self='self', arg1='arg1'))\n\n    def test_self_positional_argument_on_class_init_1(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        o = Object('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, 'arg1')\n\n        o = wrapper()\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n    def test_self_positional_argument_on_class_init_2(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        o = Object('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        o = wrapper('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n    def test_self_keyword_argument_on_class_init_1a(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, self='self')\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper()\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_1b(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_2a(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, arg1='arg1', self='self')\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper()\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_2b(self):\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_renamed_1(self):\n        class Object:\n            def __init__(_self, *args, **kwargs):\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, self='self')\n\n        o = wrapper()\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n    def test_self_keyword_argument_on_class_init_renamed_2(self):\n        class Object:\n            def __init__(_self, *args, **kwargs):\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        o = wrapper(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n    def test_self_keyword_argument_on_class_init_overloaded_1a(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, self='self')\n\n        o = wrapper()\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n    def test_self_keyword_argument_on_class_init_overloaded_1b(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        o = wrapper(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n    def test_self_keyword_argument_on_class_init_overloaded_2a(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object, _self='self')\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper()\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_overloaded_2b(self):\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\n        wrapper = wrapt.PartialCallableObjectProxy(Object)\n\n        with self.assertRaises(TypeError) as e:\n            o = wrapper(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\nclass TestArgumentUnpackingWrapperBase(unittest.TestCase):\n\n    def test_self_keyword_argument_on_dict(self):\n        # A dict when given self as keyword argument uses it to create item in\n        # the dict and no attempt is made to use a positional argument.\n\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        d = wrapt.FunctionWrapper(dict, wrapper)(self='self')\n\n        self.assertEqual(d, dict(self='self'))\n\n    def test_self_positional_argument_on_class_init(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        o = Object('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n        o = wrapt.FunctionWrapper(Object, wrapper)('arg1')\n\n        self.assertEqual(o._args, ('arg1',))\n        self.assertEqual(o._kwargs, {})\n\n    def test_self_keyword_argument_on_class_init_1(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.FunctionWrapper(Object, wrapper)(self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_2(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(self, *args, **kwargs):\n                self._args = args\n                self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.FunctionWrapper(Object, wrapper)(arg1='arg1', self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument 'self'.*\", str(e.exception)), None)\n\n    def test_self_keyword_argument_on_class_init_renamed(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(_self, *args, **kwargs):\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n        o = wrapt.FunctionWrapper(Object, wrapper)(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, dict(self=\"self\"))\n\n    def test_self_keyword_argument_on_class_init_overloaded_1(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        o = Object(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n        o = wrapt.FunctionWrapper(Object, wrapper)(self='self')\n\n        self.assertEqual(o._args, ())\n        self.assertEqual(o._kwargs, {})\n        self.assertEqual(o._self, 'self')\n\n    def test_self_keyword_argument_on_class_init_overloaded_2(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def __init__(_self, self, *args, **kwargs):\n                _self._self = self\n                _self._args = args\n                _self._kwargs = kwargs\n\n        with self.assertRaises(TypeError) as e:\n            Object(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\n        with self.assertRaises(TypeError) as e:\n            wrapt.FunctionWrapper(Object, wrapper)(_self='self')\n\n        self.assertNotEqual(re.match(\".*got multiple values for (keyword )?argument '_self'.*\", str(e.exception)), None)\n\nclass TestArgumentUnpackingBoundFunctionWrapper(unittest.TestCase):\n\n    def test_self_keyword_argument_on_classmethod(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            @classmethod\n            def function(cls, self, *args, **kwargs):\n                return self, args, kwargs\n\n            function = wrapt.FunctionWrapper(function, wrapper)\n\n        result = Object().function(self='self')\n\n        self.assertEqual(result, ('self', (), {}))\n\n    def test_self_keyword_argument_on_instancemethod(self):\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            def function(_self, self, *args, **kwargs):\n                return self, args, kwargs\n\n            function = wrapt.FunctionWrapper(function, wrapper)\n\n        result = Object().function(self='self')\n\n        self.assertEqual(result, ('self', (), {}))\n\nclass TestArgumentUnpackingDecorator(unittest.TestCase):\n\n    def test_self_keyword_argument_on_function(self):\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        @wrapper\n        def function(self, *args, **kwargs):\n            return self, args, kwargs\n\n        result = function(self='self')\n\n        self.assertEqual(result, ('self', (), {}))\n\n        result = function('self')\n\n        self.assertEqual(result, ('self', (), {}))\n\n    def test_self_keyword_argument_on_classmethod(self):\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            @wrapper\n            @classmethod\n            def function(cls, self, *args, **kwargs):\n                return self, args, kwargs\n\n        result = Object().function(self='self')\n\n        self.assertEqual(result, ('self', (), {}))\n\n        result = Object().function('self', arg1='arg1')\n\n        self.assertEqual(result, ('self', (), dict(arg1='arg1')))\n\n    def test_self_keyword_argument_on_instancemethod(self):\n        @wrapt.decorator\n        def wrapper(wrapped, instance, args, kwargs):\n            return wrapped(*args, **kwargs)\n\n        class Object:\n            @wrapper\n            def function(_self, self, *args, **kwargs):\n                return self, args, kwargs\n\n        result = Object().function(self='self', arg1='arg1')\n\n        self.assertEqual(result, ('self', (), dict(arg1='arg1')))\n\n        result = Object().function('self', arg1='arg1')\n\n        self.assertEqual(result, ('self', (), dict(arg1='arg1')))\n\nclass TestOverridingSpecialAttributes(unittest.TestCase):\n\n    def test_overriding_class_attribute(self):\n        class Object1: pass\n        class Object2(Object1): pass\n\n        o1 = Object1()\n\n        self.assertEqual(o1.__class__, type(o1))\n\n        o2 = Object2()\n\n        self.assertEqual(o2.__class__, type(o2))\n\n        o2.__class__ = type(o1)\n\n        self.assertEqual(o2.__class__, type(o1))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/compat.py": "import sys\n\nPY2 = sys.version_info[0] < 3\nPY3 = sys.version_info[0] >= 3\n\nPYXY = tuple(sys.version_info[:2])\n\nif PY3:\n    import builtins\n    exec_ = getattr(builtins, \"exec\")\n    del builtins\n\nelse:\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\n    exec_(\"\"\"def reraise(tp, value, tb=None):\n    raise tp, value, tb\n\"\"\")\n\ntry:\n    from inspect import getfullargspec\nexcept ImportError:\n    from inspect import getargspec as getfullargspec\n", "tests/test_arguments.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nclass TestArguments(unittest.TestCase):\n\n    def test_getcallargs(self):\n        def function(a, b=2, c=3, d=4, e=5, *args, **kwargs):\n            pass\n\n        expected = {'a': 10, 'c': 3, 'b': 20, 'e': 5, 'd': 40,\n                'args': (), 'kwargs': {'f': 50}}\n        calculated = wrapt.getcallargs(function, 10, 20, d=40, f=50)\n\n        self.assertEqual(expected, calculated)\n\n        expected = {'a': 10, 'c': 30, 'b': 20, 'e': 50, 'd': 40,\n                'args': (60,), 'kwargs': {}}\n        calculated = wrapt.getcallargs(function, 10, 20, 30, 40, 50, 60)\n\n        self.assertEqual(expected, calculated)\n\n    def test_unexpected_unicode_keyword(self):\n        def function(a=2):\n            pass\n\n        kwargs = { u'b': 40 }\n        self.assertRaises(TypeError, wrapt.getcallargs, function, **kwargs)\n", "tests/test_function.py": "from __future__ import print_function\n\nimport unittest\nimport inspect\nimport types\n\nimport wrapt\n\nfrom compat import exec_, getfullargspec\n\nDECORATORS_CODE = \"\"\"\nimport wrapt\n\n@wrapt.decorator\ndef passthru_decorator(wrapped, instance, args, kwargs):\n    return wrapped(*args, **kwargs)\n\"\"\"\n\ndecorators = types.ModuleType('decorators')\nexec_(DECORATORS_CODE, decorators.__dict__, decorators.__dict__)\n\ndef function1(arg):\n    '''documentation'''\n    return arg\n\nfunction1o = function1\nfunction1d = decorators.passthru_decorator(function1)\nassert(function1d is not function1o)\n\nclass TestNamingFunction(unittest.TestCase):\n\n    def test_object_name(self):\n        # Test preservation of function __name__ attribute.\n\n        self.assertEqual(function1d.__name__, function1o.__name__)\n\n    def test_object_qualname(self):\n        # Test preservation of function __qualname__ attribute.\n\n        try:\n            __qualname__ = function1o.__qualname__\n        except AttributeError:\n            pass\n        else:\n            self.assertEqual(function1d.__qualname__, __qualname__)\n\n    def test_module_name(self):\n        # Test preservation of function __module__ attribute.\n\n        self.assertEqual(function1d.__module__, __name__)\n\n    def test_doc_string(self):\n        # Test preservation of function __doc__ attribute.\n\n        self.assertEqual(function1d.__doc__, function1o.__doc__)\n\n    def test_argspec(self):\n        # Test preservation of function argument specification.\n\n        function1o_argspec = getfullargspec(function1o)\n        function1d_argspec = getfullargspec(function1d)\n        self.assertEqual(function1o_argspec, function1d_argspec)\n\n    def test_getmembers(self):\n        function1o_members = inspect.getmembers(function1o)\n        function1d_members = inspect.getmembers(function1d)\n\n    def test_isinstance(self):\n        # Test preservation of isinstance() checks.\n\n        self.assertTrue(isinstance(function1d, type(function1o)))\n\nclass TestCallingFunction(unittest.TestCase):\n\n    def test_call_function(self):\n        _args = (1, 2)\n        _kwargs = {'one': 1, 'two': 2}\n\n        @wrapt.decorator\n        def _decorator(wrapped, instance, args, kwargs):\n            self.assertEqual(instance, None)\n            self.assertEqual(args, _args)\n            self.assertEqual(kwargs, _kwargs)\n            return wrapped(*args, **kwargs)\n\n        @_decorator\n        def _function(*args, **kwargs):\n            return args, kwargs\n\n        result = _function(*_args, **_kwargs)\n\n        self.assertEqual(result, (_args, _kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_formatargspec_py35.py": "import unittest\nimport sys\nfrom inspect import getfullargspec\n\nfrom wrapt import formatargspec\n\nclass TestFormatargspec35(unittest.TestCase):\n\n    def assertFormatEqual(self, func, ref):\n        formatted = formatargspec(*getfullargspec(func))\n        self.assertEqual(formatted, ref)\n\n    def test_formatargspec(self):\n        def foo1(): pass\n        self.assertFormatEqual(foo1, '()')\n\n        def foo2(a, b='c'): pass\n        self.assertFormatEqual(foo2, (\"(a, b='c')\"))\n\n        def foo3(a, b, *args, **kwargs): pass\n        self.assertFormatEqual(foo3, '(a, b, *args, **kwargs)')\n\n        def foo4(a: int, b) -> list: pass\n        if sys.version_info[:2] < (3, 7):\n            formatted4 = '(a:int, b) -> list'\n        else:\n            formatted4 = '(a: int, b) -> list'\n        self.assertFormatEqual(foo4, formatted4)\n\n        # examples from https://www.python.org/dev/peps/pep-3102/\n        def sortwords(*wordlist, case_sensitive=False): pass\n        self.assertFormatEqual(sortwords, '(*wordlist, case_sensitive=False)')\n\n        def compare(a, b, *, key=None): pass\n        self.assertFormatEqual(compare, '(a, b, *, key=None)')\n", "tests/test_callable_object_proxy.py": "from __future__ import print_function\n\nimport unittest\n\nimport wrapt\n\nclass TestPartialCallableObjectProxy(unittest.TestCase):\n\n    def test_no_arguments(self):\n        def func0():\n            return ((), {})\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0)\n\n        args, kwargs = (), {}\n\n        self.assertEqual(partial0(), (args, kwargs))\n\n    def test_empty_arguments(self):\n        def func0(*args, **kwargs):\n            return (args, kwargs)\n\n        args, kwargs = (), {}\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0, *args, **kwargs)\n\n        self.assertEqual(partial0(), (args, kwargs))\n\n    def test_1_positional_argument(self):\n        def func0(*args, **kwargs):\n            return (args, kwargs)\n\n        args, kwargs = (1,), {}\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0, *args)\n\n        self.assertEqual(partial0(), (args, kwargs))\n\n    def test_1_keyword_argument(self):\n        def func0(*args, **kwargs):\n            return (args, kwargs)\n\n        args, kwargs = (), {'k1': 1}\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0, **kwargs)\n\n        self.assertEqual(partial0(), (args, kwargs))\n\n    def test_multiple_positional_arguments(self):\n        def func0(*args, **kwargs):\n            return (args, kwargs)\n\n        args, kwargs = (1, 2, 3), {}\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0, *args)\n\n        self.assertEqual(partial0(), (args, kwargs))\n\n    def test_multiple_keyword_arguments(self):\n        def func0(*args, **kwargs):\n            return (args, kwargs)\n\n        args, kwargs = (), {'k1': 1, 'k2': 2, 'k3': 3}\n\n        partial0 = wrapt.PartialCallableObjectProxy(func0, **kwargs)\n\n        self.assertEqual(partial0(), (args, kwargs))\n\nif __name__ == '__main__':\n    unittest.main()\n", "src/wrapt/weakrefs.py": "import functools\nimport weakref\n\nfrom .__wrapt__ import ObjectProxy, _FunctionWrapperBase\n\n# A weak function proxy. This will work on instance methods, class\n# methods, static methods and regular functions. Special treatment is\n# needed for the method types because the bound method is effectively a\n# transient object and applying a weak reference to one will immediately\n# result in it being destroyed and the weakref callback called. The weak\n# reference is therefore applied to the instance the method is bound to\n# and the original function. The function is then rebound at the point\n# of a call via the weak function proxy.\n\ndef _weak_function_proxy_callback(ref, proxy, callback):\n    if proxy._self_expired:\n        return\n\n    proxy._self_expired = True\n\n    # This could raise an exception. We let it propagate back and let\n    # the weakref.proxy() deal with it, at which point it generally\n    # prints out a short error message direct to stderr and keeps going.\n\n    if callback is not None:\n        callback(proxy)\n\nclass WeakFunctionProxy(ObjectProxy):\n\n    __slots__ = ('_self_expired', '_self_instance')\n\n    def __init__(self, wrapped, callback=None):\n        # We need to determine if the wrapped function is actually a\n        # bound method. In the case of a bound method, we need to keep a\n        # reference to the original unbound function and the instance.\n        # This is necessary because if we hold a reference to the bound\n        # function, it will be the only reference and given it is a\n        # temporary object, it will almost immediately expire and\n        # the weakref callback triggered. So what is done is that we\n        # hold a reference to the instance and unbound function and\n        # when called bind the function to the instance once again and\n        # then call it. Note that we avoid using a nested function for\n        # the callback here so as not to cause any odd reference cycles.\n\n        _callback = callback and functools.partial(\n                _weak_function_proxy_callback, proxy=self,\n                callback=callback)\n\n        self._self_expired = False\n\n        if isinstance(wrapped, _FunctionWrapperBase):\n            self._self_instance = weakref.ref(wrapped._self_instance,\n                    _callback)\n\n            if wrapped._self_parent is not None:\n                super(WeakFunctionProxy, self).__init__(\n                        weakref.proxy(wrapped._self_parent, _callback))\n\n            else:\n                super(WeakFunctionProxy, self).__init__(\n                        weakref.proxy(wrapped, _callback))\n\n            return\n\n        try:\n            self._self_instance = weakref.ref(wrapped.__self__, _callback)\n\n            super(WeakFunctionProxy, self).__init__(\n                    weakref.proxy(wrapped.__func__, _callback))\n\n        except AttributeError:\n            self._self_instance = None\n\n            super(WeakFunctionProxy, self).__init__(\n                    weakref.proxy(wrapped, _callback))\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # We perform a boolean check here on the instance and wrapped\n        # function as that will trigger the reference error prior to\n        # calling if the reference had expired.\n\n        instance = self._self_instance and self._self_instance()\n        function = self.__wrapped__ and self.__wrapped__\n\n        # If the wrapped function was originally a bound function, for\n        # which we retained a reference to the instance and the unbound\n        # function we need to rebind the function and then call it. If\n        # not just called the wrapped function.\n\n        if instance is None:\n            return self.__wrapped__(*args, **kwargs)\n\n        return function.__get__(instance, type(instance))(*args, **kwargs)\n", "src/wrapt/importer.py": "\"\"\"This module implements a post import hook mechanism styled after what is\ndescribed in PEP-369. Note that it doesn't cope with modules being reloaded.\n\n\"\"\"\n\nimport sys\nimport threading\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\n    find_spec = None\nelse:\n    string_types = str,\n    from importlib.util import find_spec\n\nfrom .__wrapt__ import ObjectProxy\n\n# The dictionary registering any post import hooks to be triggered once\n# the target module has been imported. Once a module has been imported\n# and the hooks fired, the list of hooks recorded against the target\n# module will be truncated but the list left in the dictionary. This\n# acts as a flag to indicate that the module had already been imported.\n\n_post_import_hooks = {}\n_post_import_hooks_init = False\n_post_import_hooks_lock = threading.RLock()\n\n# Register a new post import hook for the target module name. This\n# differs from the PEP-369 implementation in that it also allows the\n# hook function to be specified as a string consisting of the name of\n# the callback in the form 'module:function'. This will result in a\n# proxy callback being registered which will defer loading of the\n# specified module containing the callback function until required.\n\ndef _create_import_hook_from_string(name):\n    def import_hook(module):\n        module_name, function = name.split(':')\n        attrs = function.split('.')\n        __import__(module_name)\n        callback = sys.modules[module_name]\n        for attr in attrs:\n            callback = getattr(callback, attr)\n        return callback(module)\n    return import_hook\n\ndef register_post_import_hook(hook, name):\n    # Create a deferred import hook if hook is a string name rather than\n    # a callable function.\n\n    if isinstance(hook, string_types):\n        hook = _create_import_hook_from_string(hook)\n\n    with _post_import_hooks_lock:\n        # Automatically install the import hook finder if it has not already\n        # been installed.\n\n        global _post_import_hooks_init\n\n        if not _post_import_hooks_init:\n            _post_import_hooks_init = True\n            sys.meta_path.insert(0, ImportHookFinder())\n\n        # Check if the module is already imported. If not, register the hook\n        # to be called after import.\n\n        module = sys.modules.get(name, None)\n\n        if module is None:\n            _post_import_hooks.setdefault(name, []).append(hook)\n\n    # If the module is already imported, we fire the hook right away. Note that\n    # the hook is called outside of the lock to avoid deadlocks if code run as a\n    # consequence of calling the module import hook in turn triggers a separate\n    # thread which tries to register an import hook.\n\n    if module is not None:\n        hook(module)\n\n# Register post import hooks defined as package entry points.\n\ndef _create_import_hook_from_entrypoint(entrypoint):\n    def import_hook(module):\n        __import__(entrypoint.module_name)\n        callback = sys.modules[entrypoint.module_name]\n        for attr in entrypoint.attrs:\n            callback = getattr(callback, attr)\n        return callback(module)\n    return import_hook\n\ndef discover_post_import_hooks(group):\n    try:\n        import pkg_resources\n    except ImportError:\n        return\n\n    for entrypoint in pkg_resources.iter_entry_points(group=group):\n        callback = _create_import_hook_from_entrypoint(entrypoint)\n        register_post_import_hook(callback, entrypoint.name)\n\n# Indicate that a module has been loaded. Any post import hooks which\n# were registered against the target module will be invoked. If an\n# exception is raised in any of the post import hooks, that will cause\n# the import of the target module to fail.\n\ndef notify_module_loaded(module):\n    name = getattr(module, '__name__', None)\n\n    with _post_import_hooks_lock:\n        hooks = _post_import_hooks.pop(name, ())\n\n    # Note that the hook is called outside of the lock to avoid deadlocks if\n    # code run as a consequence of calling the module import hook in turn\n    # triggers a separate thread which tries to register an import hook.\n\n    for hook in hooks:\n        hook(module)\n\n# A custom module import finder. This intercepts attempts to import\n# modules and watches out for attempts to import target modules of\n# interest. When a module of interest is imported, then any post import\n# hooks which are registered will be invoked.\n\nclass _ImportHookLoader:\n\n    def load_module(self, fullname):\n        module = sys.modules[fullname]\n        notify_module_loaded(module)\n\n        return module\n\nclass _ImportHookChainedLoader(ObjectProxy):\n\n    def __init__(self, loader):\n        super(_ImportHookChainedLoader, self).__init__(loader)\n\n        if hasattr(loader, \"load_module\"):\n          self.__self_setattr__('load_module', self._self_load_module)\n        if hasattr(loader, \"create_module\"):\n          self.__self_setattr__('create_module', self._self_create_module)\n        if hasattr(loader, \"exec_module\"):\n          self.__self_setattr__('exec_module', self._self_exec_module)\n\n    def _self_set_loader(self, module):\n        # Set module's loader to self.__wrapped__ unless it's already set to\n        # something else. Import machinery will set it to spec.loader if it is\n        # None, so handle None as well. The module may not support attribute\n        # assignment, in which case we simply skip it. Note that we also deal\n        # with __loader__ not existing at all. This is to future proof things\n        # due to proposal to remove the attribue as described in the GitHub\n        # issue at https://github.com/python/cpython/issues/77458. Also prior\n        # to Python 3.3, the __loader__ attribute was only set if a custom\n        # module loader was used. It isn't clear whether the attribute still\n        # existed in that case or was set to None.\n\n        class UNDEFINED: pass\n\n        if getattr(module, \"__loader__\", UNDEFINED) in (None, self):\n            try:\n                module.__loader__ = self.__wrapped__\n            except AttributeError:\n                pass\n\n        if (getattr(module, \"__spec__\", None) is not None\n                and getattr(module.__spec__, \"loader\", None) is self):\n            module.__spec__.loader = self.__wrapped__\n\n    def _self_load_module(self, fullname):\n        module = self.__wrapped__.load_module(fullname)\n        self._self_set_loader(module)\n        notify_module_loaded(module)\n\n        return module\n\n    # Python 3.4 introduced create_module() and exec_module() instead of\n    # load_module() alone. Splitting the two steps.\n\n    def _self_create_module(self, spec):\n        return self.__wrapped__.create_module(spec)\n\n    def _self_exec_module(self, module):\n        self._self_set_loader(module)\n        self.__wrapped__.exec_module(module)\n        notify_module_loaded(module)\n\nclass ImportHookFinder:\n\n    def __init__(self):\n        self.in_progress = {}\n\n    def find_module(self, fullname, path=None):\n        # If the module being imported is not one we have registered\n        # post import hooks for, we can return immediately. We will\n        # take no further part in the importing of this module.\n\n        with _post_import_hooks_lock:\n            if fullname not in _post_import_hooks:\n                return None\n\n        # When we are interested in a specific module, we will call back\n        # into the import system a second time to defer to the import\n        # finder that is supposed to handle the importing of the module.\n        # We set an in progress flag for the target module so that on\n        # the second time through we don't trigger another call back\n        # into the import system and cause a infinite loop.\n\n        if fullname in self.in_progress:\n            return None\n\n        self.in_progress[fullname] = True\n\n        # Now call back into the import system again.\n\n        try:\n            if not find_spec:\n                # For Python 2 we don't have much choice but to\n                # call back in to __import__(). This will\n                # actually cause the module to be imported. If no\n                # module could be found then ImportError will be\n                # raised. Otherwise we return a loader which\n                # returns the already loaded module and invokes\n                # the post import hooks.\n\n                __import__(fullname)\n\n                return _ImportHookLoader()\n\n            else:\n                # For Python 3 we need to use find_spec().loader\n                # from the importlib.util module. It doesn't actually\n                # import the target module and only finds the\n                # loader. If a loader is found, we need to return\n                # our own loader which will then in turn call the\n                # real loader to import the module and invoke the\n                # post import hooks.\n\n                loader = getattr(find_spec(fullname), \"loader\", None)\n\n                if loader and not isinstance(loader, _ImportHookChainedLoader):\n                    return _ImportHookChainedLoader(loader)\n\n        finally:\n            del self.in_progress[fullname]\n\n    def find_spec(self, fullname, path=None, target=None):\n        # Since Python 3.4, you are meant to implement find_spec() method\n        # instead of find_module() and since Python 3.10 you get deprecation\n        # warnings if you don't define find_spec().\n\n        # If the module being imported is not one we have registered\n        # post import hooks for, we can return immediately. We will\n        # take no further part in the importing of this module.\n\n        with _post_import_hooks_lock:\n            if fullname not in _post_import_hooks:\n                return None\n\n        # When we are interested in a specific module, we will call back\n        # into the import system a second time to defer to the import\n        # finder that is supposed to handle the importing of the module.\n        # We set an in progress flag for the target module so that on\n        # the second time through we don't trigger another call back\n        # into the import system and cause a infinite loop.\n\n        if fullname in self.in_progress:\n            return None\n\n        self.in_progress[fullname] = True\n\n        # Now call back into the import system again.\n\n        try:\n            # This should only be Python 3 so find_spec() should always\n            # exist so don't need to check.\n\n            spec = find_spec(fullname)\n            loader = getattr(spec, \"loader\", None)\n\n            if loader and not isinstance(loader, _ImportHookChainedLoader):\n                spec.loader = _ImportHookChainedLoader(loader)\n\n            return spec\n\n        finally:\n            del self.in_progress[fullname]\n\n# Decorator for marking that a function should be called as a post\n# import hook when the target module is imported.\n\ndef when_imported(name):\n    def register(hook):\n        register_post_import_hook(hook, name)\n        return hook\n    return register\n", "src/wrapt/__wrapt__.py": "import os\n\nfrom .wrappers import (ObjectProxy, CallableObjectProxy,\n        PartialCallableObjectProxy, FunctionWrapper,\n        BoundFunctionWrapper, _FunctionWrapperBase)\n\ntry:\n    if not os.environ.get('WRAPT_DISABLE_EXTENSIONS'):\n        from ._wrappers import (ObjectProxy, CallableObjectProxy,\n            PartialCallableObjectProxy, FunctionWrapper,\n            BoundFunctionWrapper, _FunctionWrapperBase)\n\nexcept ImportError:\n    pass\n", "src/wrapt/wrappers.py": "import sys\nimport operator\nimport inspect\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n\ndef with_metaclass(meta, *bases):\n    \"\"\"Create a base class with a metaclass.\"\"\"\n    return meta(\"NewBase\", bases, {})\n\nclass _ObjectProxyMethods(object):\n\n    # We use properties to override the values of __module__ and\n    # __doc__. If we add these in ObjectProxy, the derived class\n    # __dict__ will still be setup to have string variants of these\n    # attributes and the rules of descriptors means that they appear to\n    # take precedence over the properties in the base class. To avoid\n    # that, we copy the properties into the derived class type itself\n    # via a meta class. In that way the properties will always take\n    # precedence.\n\n    @property\n    def __module__(self):\n        return self.__wrapped__.__module__\n\n    @__module__.setter\n    def __module__(self, value):\n        self.__wrapped__.__module__ = value\n\n    @property\n    def __doc__(self):\n        return self.__wrapped__.__doc__\n\n    @__doc__.setter\n    def __doc__(self, value):\n        self.__wrapped__.__doc__ = value\n\n    # We similar use a property for __dict__. We need __dict__ to be\n    # explicit to ensure that vars() works as expected.\n\n    @property\n    def __dict__(self):\n        return self.__wrapped__.__dict__\n\n    # Need to also propagate the special __weakref__ attribute for case\n    # where decorating classes which will define this. If do not define\n    # it and use a function like inspect.getmembers() on a decorator\n    # class it will fail. This can't be in the derived classes.\n\n    @property\n    def __weakref__(self):\n        return self.__wrapped__.__weakref__\n\nclass _ObjectProxyMetaType(type):\n    def __new__(cls, name, bases, dictionary):\n        # Copy our special properties into the class so that they\n        # always take precedence over attributes of the same name added\n        # during construction of a derived class. This is to save\n        # duplicating the implementation for them in all derived classes.\n\n        dictionary.update(vars(_ObjectProxyMethods))\n\n        return type.__new__(cls, name, bases, dictionary)\n\nclass ObjectProxy(with_metaclass(_ObjectProxyMetaType)):\n\n    __slots__ = '__wrapped__'\n\n    def __init__(self, wrapped):\n        object.__setattr__(self, '__wrapped__', wrapped)\n\n        # Python 3.2+ has the __qualname__ attribute, but it does not\n        # allow it to be overridden using a property and it must instead\n        # be an actual string object instead.\n\n        try:\n            object.__setattr__(self, '__qualname__', wrapped.__qualname__)\n        except AttributeError:\n            pass\n\n        # Python 3.10 onwards also does not allow itself to be overridden\n        # using a property and it must instead be set explicitly.\n\n        try:\n            object.__setattr__(self, '__annotations__', wrapped.__annotations__)\n        except AttributeError:\n            pass\n\n    def __self_setattr__(self, name, value):\n        object.__setattr__(self, name, value)\n\n    @property\n    def __name__(self):\n        return self.__wrapped__.__name__\n\n    @__name__.setter\n    def __name__(self, value):\n        self.__wrapped__.__name__ = value\n\n    @property\n    def __class__(self):\n        return self.__wrapped__.__class__\n\n    @__class__.setter\n    def __class__(self, value):\n        self.__wrapped__.__class__ = value\n\n    def __dir__(self):\n        return dir(self.__wrapped__)\n\n    def __str__(self):\n        return str(self.__wrapped__)\n\n    if not PY2:\n        def __bytes__(self):\n            return bytes(self.__wrapped__)\n\n    def __repr__(self):\n        return '<{} at 0x{:x} for {} at 0x{:x}>'.format(\n                type(self).__name__, id(self),\n                type(self.__wrapped__).__name__,\n                id(self.__wrapped__))\n\n    def __reversed__(self):\n        return reversed(self.__wrapped__)\n\n    if not PY2:\n        def __round__(self):\n            return round(self.__wrapped__)\n\n    if sys.hexversion >= 0x03070000:\n        def __mro_entries__(self, bases):\n            return (self.__wrapped__,)\n\n    def __lt__(self, other):\n        return self.__wrapped__ < other\n\n    def __le__(self, other):\n        return self.__wrapped__ <= other\n\n    def __eq__(self, other):\n        return self.__wrapped__ == other\n\n    def __ne__(self, other):\n        return self.__wrapped__ != other\n\n    def __gt__(self, other):\n        return self.__wrapped__ > other\n\n    def __ge__(self, other):\n        return self.__wrapped__ >= other\n\n    def __hash__(self):\n        return hash(self.__wrapped__)\n\n    def __nonzero__(self):\n        return bool(self.__wrapped__)\n\n    def __bool__(self):\n        return bool(self.__wrapped__)\n\n    def __setattr__(self, name, value):\n        if name.startswith('_self_'):\n            object.__setattr__(self, name, value)\n\n        elif name == '__wrapped__':\n            object.__setattr__(self, name, value)\n            try:\n                object.__delattr__(self, '__qualname__')\n            except AttributeError:\n                pass\n            try:\n                object.__setattr__(self, '__qualname__', value.__qualname__)\n            except AttributeError:\n                pass\n            try:\n                object.__delattr__(self, '__annotations__')\n            except AttributeError:\n                pass\n            try:\n                object.__setattr__(self, '__annotations__', value.__annotations__)\n            except AttributeError:\n                pass\n\n        elif name == '__qualname__':\n            setattr(self.__wrapped__, name, value)\n            object.__setattr__(self, name, value)\n\n        elif name == '__annotations__':\n            setattr(self.__wrapped__, name, value)\n            object.__setattr__(self, name, value)\n\n        elif hasattr(type(self), name):\n            object.__setattr__(self, name, value)\n\n        else:\n            setattr(self.__wrapped__, name, value)\n\n    def __getattr__(self, name):\n        # If we are being to lookup '__wrapped__' then the\n        # '__init__()' method cannot have been called.\n\n        if name == '__wrapped__':\n            raise ValueError('wrapper has not been initialised')\n\n        return getattr(self.__wrapped__, name)\n\n    def __delattr__(self, name):\n        if name.startswith('_self_'):\n            object.__delattr__(self, name)\n\n        elif name == '__wrapped__':\n            raise TypeError('__wrapped__ must be an object')\n\n        elif name == '__qualname__':\n            object.__delattr__(self, name)\n            delattr(self.__wrapped__, name)\n\n        elif hasattr(type(self), name):\n            object.__delattr__(self, name)\n\n        else:\n            delattr(self.__wrapped__, name)\n\n    def __add__(self, other):\n        return self.__wrapped__ + other\n\n    def __sub__(self, other):\n        return self.__wrapped__ - other\n\n    def __mul__(self, other):\n        return self.__wrapped__ * other\n\n    def __div__(self, other):\n        return operator.div(self.__wrapped__, other)\n\n    def __truediv__(self, other):\n        return operator.truediv(self.__wrapped__, other)\n\n    def __floordiv__(self, other):\n        return self.__wrapped__ // other\n\n    def __mod__(self, other):\n        return self.__wrapped__ % other\n\n    def __divmod__(self, other):\n        return divmod(self.__wrapped__, other)\n\n    def __pow__(self, other, *args):\n        return pow(self.__wrapped__, other, *args)\n\n    def __lshift__(self, other):\n        return self.__wrapped__ << other\n\n    def __rshift__(self, other):\n        return self.__wrapped__ >> other\n\n    def __and__(self, other):\n        return self.__wrapped__ & other\n\n    def __xor__(self, other):\n        return self.__wrapped__ ^ other\n\n    def __or__(self, other):\n        return self.__wrapped__ | other\n\n    def __radd__(self, other):\n        return other + self.__wrapped__\n\n    def __rsub__(self, other):\n        return other - self.__wrapped__\n\n    def __rmul__(self, other):\n        return other * self.__wrapped__\n\n    def __rdiv__(self, other):\n        return operator.div(other, self.__wrapped__)\n\n    def __rtruediv__(self, other):\n        return operator.truediv(other, self.__wrapped__)\n\n    def __rfloordiv__(self, other):\n        return other // self.__wrapped__\n\n    def __rmod__(self, other):\n        return other % self.__wrapped__\n\n    def __rdivmod__(self, other):\n        return divmod(other, self.__wrapped__)\n\n    def __rpow__(self, other, *args):\n        return pow(other, self.__wrapped__, *args)\n\n    def __rlshift__(self, other):\n        return other << self.__wrapped__\n\n    def __rrshift__(self, other):\n        return other >> self.__wrapped__\n\n    def __rand__(self, other):\n        return other & self.__wrapped__\n\n    def __rxor__(self, other):\n        return other ^ self.__wrapped__\n\n    def __ror__(self, other):\n        return other | self.__wrapped__\n\n    def __iadd__(self, other):\n        self.__wrapped__ += other\n        return self\n\n    def __isub__(self, other):\n        self.__wrapped__ -= other\n        return self\n\n    def __imul__(self, other):\n        self.__wrapped__ *= other\n        return self\n\n    def __idiv__(self, other):\n        self.__wrapped__ = operator.idiv(self.__wrapped__, other)\n        return self\n\n    def __itruediv__(self, other):\n        self.__wrapped__ = operator.itruediv(self.__wrapped__, other)\n        return self\n\n    def __ifloordiv__(self, other):\n        self.__wrapped__ //= other\n        return self\n\n    def __imod__(self, other):\n        self.__wrapped__ %= other\n        return self\n\n    def __ipow__(self, other):\n        self.__wrapped__ **= other\n        return self\n\n    def __ilshift__(self, other):\n        self.__wrapped__ <<= other\n        return self\n\n    def __irshift__(self, other):\n        self.__wrapped__ >>= other\n        return self\n\n    def __iand__(self, other):\n        self.__wrapped__ &= other\n        return self\n\n    def __ixor__(self, other):\n        self.__wrapped__ ^= other\n        return self\n\n    def __ior__(self, other):\n        self.__wrapped__ |= other\n        return self\n\n    def __neg__(self):\n        return -self.__wrapped__\n\n    def __pos__(self):\n        return +self.__wrapped__\n\n    def __abs__(self):\n        return abs(self.__wrapped__)\n\n    def __invert__(self):\n        return ~self.__wrapped__\n\n    def __int__(self):\n        return int(self.__wrapped__)\n\n    def __long__(self):\n        return long(self.__wrapped__)\n\n    def __float__(self):\n        return float(self.__wrapped__)\n\n    def __complex__(self):\n        return complex(self.__wrapped__)\n\n    def __oct__(self):\n        return oct(self.__wrapped__)\n\n    def __hex__(self):\n        return hex(self.__wrapped__)\n\n    def __index__(self):\n        return operator.index(self.__wrapped__)\n\n    def __len__(self):\n        return len(self.__wrapped__)\n\n    def __contains__(self, value):\n        return value in self.__wrapped__\n\n    def __getitem__(self, key):\n        return self.__wrapped__[key]\n\n    def __setitem__(self, key, value):\n        self.__wrapped__[key] = value\n\n    def __delitem__(self, key):\n        del self.__wrapped__[key]\n\n    def __getslice__(self, i, j):\n        return self.__wrapped__[i:j]\n\n    def __setslice__(self, i, j, value):\n        self.__wrapped__[i:j] = value\n\n    def __delslice__(self, i, j):\n        del self.__wrapped__[i:j]\n\n    def __enter__(self):\n        return self.__wrapped__.__enter__()\n\n    def __exit__(self, *args, **kwargs):\n        return self.__wrapped__.__exit__(*args, **kwargs)\n\n    def __iter__(self):\n        return iter(self.__wrapped__)\n\n    def __copy__(self):\n        raise NotImplementedError('object proxy must define __copy__()')\n\n    def __deepcopy__(self, memo):\n        raise NotImplementedError('object proxy must define __deepcopy__()')\n\n    def __reduce__(self):\n        raise NotImplementedError(\n                'object proxy must define __reduce_ex__()')\n\n    def __reduce_ex__(self, protocol):\n        raise NotImplementedError(\n                'object proxy must define __reduce_ex__()')\n\nclass CallableObjectProxy(ObjectProxy):\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        return self.__wrapped__(*args, **kwargs)\n\nclass PartialCallableObjectProxy(ObjectProxy):\n\n    def __init__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        if len(args) < 1:\n            raise TypeError('partial type takes at least one argument')\n\n        wrapped, args = args[0], args[1:]\n\n        if not callable(wrapped):\n            raise TypeError('the first argument must be callable')\n\n        super(PartialCallableObjectProxy, self).__init__(wrapped)\n\n        self._self_args = args\n        self._self_kwargs = kwargs\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n    \n        _args = self._self_args + args\n\n        _kwargs = dict(self._self_kwargs)\n        _kwargs.update(kwargs)\n\n        return self.__wrapped__(*_args, **_kwargs)\n\nclass _FunctionWrapperBase(ObjectProxy):\n\n    __slots__ = ('_self_instance', '_self_wrapper', '_self_enabled',\n            '_self_binding', '_self_parent')\n\n    def __init__(self, wrapped, instance, wrapper, enabled=None,\n            binding='function', parent=None):\n\n        super(_FunctionWrapperBase, self).__init__(wrapped)\n\n        object.__setattr__(self, '_self_instance', instance)\n        object.__setattr__(self, '_self_wrapper', wrapper)\n        object.__setattr__(self, '_self_enabled', enabled)\n        object.__setattr__(self, '_self_binding', binding)\n        object.__setattr__(self, '_self_parent', parent)\n\n    def __get__(self, instance, owner):\n        # This method is actually doing double duty for both unbound and\n        # bound derived wrapper classes. It should possibly be broken up\n        # and the distinct functionality moved into the derived classes.\n        # Can't do that straight away due to some legacy code which is\n        # relying on it being here in this base class.\n        #\n        # The distinguishing attribute which determines whether we are\n        # being called in an unbound or bound wrapper is the parent\n        # attribute. If binding has never occurred, then the parent will\n        # be None.\n        #\n        # First therefore, is if we are called in an unbound wrapper. In\n        # this case we perform the binding.\n        #\n        # We have one special case to worry about here. This is where we\n        # are decorating a nested class. In this case the wrapped class\n        # would not have a __get__() method to call. In that case we\n        # simply return self.\n        #\n        # Note that we otherwise still do binding even if instance is\n        # None and accessing an unbound instance method from a class.\n        # This is because we need to be able to later detect that\n        # specific case as we will need to extract the instance from the\n        # first argument of those passed in.\n\n        if self._self_parent is None:\n            if not inspect.isclass(self.__wrapped__):\n                descriptor = self.__wrapped__.__get__(instance, owner)\n\n                return self.__bound_function_wrapper__(descriptor, instance,\n                        self._self_wrapper, self._self_enabled,\n                        self._self_binding, self)\n\n            return self\n\n        # Now we have the case of binding occurring a second time on what\n        # was already a bound function. In this case we would usually\n        # return ourselves again. This mirrors what Python does.\n        #\n        # The special case this time is where we were originally bound\n        # with an instance of None and we were likely an instance\n        # method. In that case we rebind against the original wrapped\n        # function from the parent again.\n\n        if self._self_instance is None and self._self_binding == 'function':\n            descriptor = self._self_parent.__wrapped__.__get__(\n                    instance, owner)\n\n            return self._self_parent.__bound_function_wrapper__(\n                    descriptor, instance, self._self_wrapper,\n                    self._self_enabled, self._self_binding,\n                    self._self_parent)\n\n        return self\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # If enabled has been specified, then evaluate it at this point\n        # and if the wrapper is not to be executed, then simply return\n        # the bound function rather than a bound wrapper for the bound\n        # function. When evaluating enabled, if it is callable we call\n        # it, otherwise we evaluate it as a boolean.\n\n        if self._self_enabled is not None:\n            if callable(self._self_enabled):\n                if not self._self_enabled():\n                    return self.__wrapped__(*args, **kwargs)\n            elif not self._self_enabled:\n                return self.__wrapped__(*args, **kwargs)\n\n        # This can occur where initial function wrapper was applied to\n        # a function that was already bound to an instance. In that case\n        # we want to extract the instance from the function and use it.\n\n        if self._self_binding in ('function', 'classmethod'):\n            if self._self_instance is None:\n                instance = getattr(self.__wrapped__, '__self__', None)\n                if instance is not None:\n                    return self._self_wrapper(self.__wrapped__, instance,\n                            args, kwargs)\n\n        # This is generally invoked when the wrapped function is being\n        # called as a normal function and is not bound to a class as an\n        # instance method. This is also invoked in the case where the\n        # wrapped function was a method, but this wrapper was in turn\n        # wrapped using the staticmethod decorator.\n\n        return self._self_wrapper(self.__wrapped__, self._self_instance,\n                args, kwargs)\n\n    def __set_name__(self, owner, name):\n        # This is a special method use to supply information to\n        # descriptors about what the name of variable in a class\n        # definition is. Not wanting to add this to ObjectProxy as not\n        # sure of broader implications of doing that. Thus restrict to\n        # FunctionWrapper used by decorators.\n\n        if hasattr(self.__wrapped__, \"__set_name__\"):\n            self.__wrapped__.__set_name__(owner, name)\n\n    def __instancecheck__(self, instance):\n        # This is a special method used by isinstance() to make checks\n        # instance of the `__wrapped__`.\n        return isinstance(instance, self.__wrapped__)\n\n    def __subclasscheck__(self, subclass):\n        # This is a special method used by issubclass() to make checks\n        # about inheritance of classes. We need to upwrap any object\n        # proxy. Not wanting to add this to ObjectProxy as not sure of\n        # broader implications of doing that. Thus restrict to\n        # FunctionWrapper used by decorators.\n\n        if hasattr(subclass, \"__wrapped__\"):\n            return issubclass(subclass.__wrapped__, self.__wrapped__)\n        else:\n            return issubclass(subclass, self.__wrapped__)\n\nclass BoundFunctionWrapper(_FunctionWrapperBase):\n\n    def __call__(*args, **kwargs):\n        def _unpack_self(self, *args):\n            return self, args\n\n        self, args = _unpack_self(*args)\n\n        # If enabled has been specified, then evaluate it at this point\n        # and if the wrapper is not to be executed, then simply return\n        # the bound function rather than a bound wrapper for the bound\n        # function. When evaluating enabled, if it is callable we call\n        # it, otherwise we evaluate it as a boolean.\n\n        if self._self_enabled is not None:\n            if callable(self._self_enabled):\n                if not self._self_enabled():\n                    return self.__wrapped__(*args, **kwargs)\n            elif not self._self_enabled:\n                return self.__wrapped__(*args, **kwargs)\n\n        # We need to do things different depending on whether we are\n        # likely wrapping an instance method vs a static method or class\n        # method.\n\n        if self._self_binding == 'function':\n            if self._self_instance is None:\n                # This situation can occur where someone is calling the\n                # instancemethod via the class type and passing the instance\n                # as the first argument. We need to shift the args before\n                # making the call to the wrapper and effectively bind the\n                # instance to the wrapped function using a partial so the\n                # wrapper doesn't see anything as being different.\n\n                if not args:\n                    raise TypeError('missing 1 required positional argument')\n\n                instance, args = args[0], args[1:]\n                wrapped = PartialCallableObjectProxy(self.__wrapped__, instance)\n                return self._self_wrapper(wrapped, instance, args, kwargs)\n\n            return self._self_wrapper(self.__wrapped__, self._self_instance,\n                    args, kwargs)\n\n        else:\n            # As in this case we would be dealing with a classmethod or\n            # staticmethod, then _self_instance will only tell us whether\n            # when calling the classmethod or staticmethod they did it via an\n            # instance of the class it is bound to and not the case where\n            # done by the class type itself. We thus ignore _self_instance\n            # and use the __self__ attribute of the bound function instead.\n            # For a classmethod, this means instance will be the class type\n            # and for a staticmethod it will be None. This is probably the\n            # more useful thing we can pass through even though we loose\n            # knowledge of whether they were called on the instance vs the\n            # class type, as it reflects what they have available in the\n            # decoratored function.\n\n            instance = getattr(self.__wrapped__, '__self__', None)\n\n            return self._self_wrapper(self.__wrapped__, instance, args,\n                    kwargs)\n\nclass FunctionWrapper(_FunctionWrapperBase):\n\n    __bound_function_wrapper__ = BoundFunctionWrapper\n\n    def __init__(self, wrapped, wrapper, enabled=None):\n        # What it is we are wrapping here could be anything. We need to\n        # try and detect specific cases though. In particular, we need\n        # to detect when we are given something that is a method of a\n        # class. Further, we need to know when it is likely an instance\n        # method, as opposed to a class or static method. This can\n        # become problematic though as there isn't strictly a fool proof\n        # method of knowing.\n        #\n        # The situations we could encounter when wrapping a method are:\n        #\n        # 1. The wrapper is being applied as part of a decorator which\n        # is a part of the class definition. In this case what we are\n        # given is the raw unbound function, classmethod or staticmethod\n        # wrapper objects.\n        #\n        # The problem here is that we will not know we are being applied\n        # in the context of the class being set up. This becomes\n        # important later for the case of an instance method, because in\n        # that case we just see it as a raw function and can't\n        # distinguish it from wrapping a normal function outside of\n        # a class context.\n        #\n        # 2. The wrapper is being applied when performing monkey\n        # patching of the class type afterwards and the method to be\n        # wrapped was retrieved direct from the __dict__ of the class\n        # type. This is effectively the same as (1) above.\n        #\n        # 3. The wrapper is being applied when performing monkey\n        # patching of the class type afterwards and the method to be\n        # wrapped was retrieved from the class type. In this case\n        # binding will have been performed where the instance against\n        # which the method is bound will be None at that point.\n        #\n        # This case is a problem because we can no longer tell if the\n        # method was a static method, plus if using Python3, we cannot\n        # tell if it was an instance method as the concept of an\n        # unnbound method no longer exists.\n        #\n        # 4. The wrapper is being applied when performing monkey\n        # patching of an instance of a class. In this case binding will\n        # have been perfomed where the instance was not None.\n        #\n        # This case is a problem because we can no longer tell if the\n        # method was a static method.\n        #\n        # Overall, the best we can do is look at the original type of the\n        # object which was wrapped prior to any binding being done and\n        # see if it is an instance of classmethod or staticmethod. In\n        # the case where other decorators are between us and them, if\n        # they do not propagate the __class__  attribute so that the\n        # isinstance() checks works, then likely this will do the wrong\n        # thing where classmethod and staticmethod are used.\n        #\n        # Since it is likely to be very rare that anyone even puts\n        # decorators around classmethod and staticmethod, likelihood of\n        # that being an issue is very small, so we accept it and suggest\n        # that those other decorators be fixed. It is also only an issue\n        # if a decorator wants to actually do things with the arguments.\n        #\n        # As to not being able to identify static methods properly, we\n        # just hope that that isn't something people are going to want\n        # to wrap, or if they do suggest they do it the correct way by\n        # ensuring that it is decorated in the class definition itself,\n        # or patch it in the __dict__ of the class type.\n        #\n        # So to get the best outcome we can, whenever we aren't sure what\n        # it is, we label it as a 'function'. If it was already bound and\n        # that is rebound later, we assume that it will be an instance\n        # method and try an cope with the possibility that the 'self'\n        # argument it being passed as an explicit argument and shuffle\n        # the arguments around to extract 'self' for use as the instance.\n\n        if isinstance(wrapped, classmethod):\n            binding = 'classmethod'\n\n        elif isinstance(wrapped, staticmethod):\n            binding = 'staticmethod'\n\n        elif hasattr(wrapped, '__self__'):\n            if inspect.isclass(wrapped.__self__):\n                binding = 'classmethod'\n            else:\n                binding = 'function'\n\n        else:\n            binding = 'function'\n\n        super(FunctionWrapper, self).__init__(wrapped, None, wrapper,\n                enabled, binding)\n", "src/wrapt/patches.py": "import inspect\nimport sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\nelse:\n    string_types = str,\n\nfrom .__wrapt__ import FunctionWrapper\n\n# Helper functions for applying wrappers to existing functions.\n\ndef resolve_path(module, name):\n    if isinstance(module, string_types):\n        __import__(module)\n        module = sys.modules[module]\n\n    parent = module\n\n    path = name.split('.')\n    attribute = path[0]\n\n    # We can't just always use getattr() because in doing\n    # that on a class it will cause binding to occur which\n    # will complicate things later and cause some things not\n    # to work. For the case of a class we therefore access\n    # the __dict__ directly. To cope though with the wrong\n    # class being given to us, or a method being moved into\n    # a base class, we need to walk the class hierarchy to\n    # work out exactly which __dict__ the method was defined\n    # in, as accessing it from __dict__ will fail if it was\n    # not actually on the class given. Fallback to using\n    # getattr() if we can't find it. If it truly doesn't\n    # exist, then that will fail.\n\n    def lookup_attribute(parent, attribute):\n        if inspect.isclass(parent):\n            for cls in inspect.getmro(parent):\n                if attribute in vars(cls):\n                    return vars(cls)[attribute]\n            else:\n                return getattr(parent, attribute)\n        else:\n            return getattr(parent, attribute)\n\n    original = lookup_attribute(parent, attribute)\n\n    for attribute in path[1:]:\n        parent = original\n        original = lookup_attribute(parent, attribute)\n\n    return (parent, attribute, original)\n\ndef apply_patch(parent, attribute, replacement):\n    setattr(parent, attribute, replacement)\n\ndef wrap_object(module, name, factory, args=(), kwargs={}):\n    (parent, attribute, original) = resolve_path(module, name)\n    wrapper = factory(original, *args, **kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n\n# Function for applying a proxy object to an attribute of a class\n# instance. The wrapper works by defining an attribute of the same name\n# on the class which is a descriptor and which intercepts access to the\n# instance attribute. Note that this cannot be used on attributes which\n# are themselves defined by a property object.\n\nclass AttributeWrapper(object):\n\n    def __init__(self, attribute, factory, args, kwargs):\n        self.attribute = attribute\n        self.factory = factory\n        self.args = args\n        self.kwargs = kwargs\n\n    def __get__(self, instance, owner):\n        value = instance.__dict__[self.attribute]\n        return self.factory(value, *self.args, **self.kwargs)\n\n    def __set__(self, instance, value):\n        instance.__dict__[self.attribute] = value\n\n    def __delete__(self, instance):\n        del instance.__dict__[self.attribute]\n\ndef wrap_object_attribute(module, name, factory, args=(), kwargs={}):\n    path, attribute = name.rsplit('.', 1)\n    parent = resolve_path(module, path)[2]\n    wrapper = AttributeWrapper(attribute, factory, args, kwargs)\n    apply_patch(parent, attribute, wrapper)\n    return wrapper\n\n# Functions for creating a simple decorator using a FunctionWrapper,\n# plus short cut functions for applying wrappers to functions. These are\n# for use when doing monkey patching. For a more featured way of\n# creating decorators see the decorator decorator instead.\n\ndef function_wrapper(wrapper):\n    def _wrapper(wrapped, instance, args, kwargs):\n        target_wrapped = args[0]\n        if instance is None:\n            target_wrapper = wrapper\n        elif inspect.isclass(instance):\n            target_wrapper = wrapper.__get__(None, instance)\n        else:\n            target_wrapper = wrapper.__get__(instance, type(instance))\n        return FunctionWrapper(target_wrapped, target_wrapper)\n    return FunctionWrapper(wrapper, _wrapper)\n\ndef wrap_function_wrapper(module, name, wrapper):\n    return wrap_object(module, name, FunctionWrapper, (wrapper,))\n\ndef patch_function_wrapper(module, name, enabled=None):\n    def _wrapper(wrapper):\n        return wrap_object(module, name, FunctionWrapper, (wrapper, enabled))\n    return _wrapper\n\ndef transient_function_wrapper(module, name):\n    def _decorator(wrapper):\n        def _wrapper(wrapped, instance, args, kwargs):\n            target_wrapped = args[0]\n            if instance is None:\n                target_wrapper = wrapper\n            elif inspect.isclass(instance):\n                target_wrapper = wrapper.__get__(None, instance)\n            else:\n                target_wrapper = wrapper.__get__(instance, type(instance))\n            def _execute(wrapped, instance, args, kwargs):\n                (parent, attribute, original) = resolve_path(module, name)\n                replacement = FunctionWrapper(original, target_wrapper)\n                setattr(parent, attribute, replacement)\n                try:\n                    return wrapped(*args, **kwargs)\n                finally:\n                    setattr(parent, attribute, original)\n            return FunctionWrapper(target_wrapped, _execute)\n        return FunctionWrapper(wrapper, _wrapper)\n    return _decorator\n", "src/wrapt/decorators.py": "\"\"\"This module implements decorators for implementing other decorators\nas well as some commonly used decorators.\n\n\"\"\"\n\nimport sys\n\nPY2 = sys.version_info[0] == 2\n\nif PY2:\n    string_types = basestring,\n\n    def exec_(_code_, _globs_=None, _locs_=None):\n        \"\"\"Execute code in a namespace.\"\"\"\n        if _globs_ is None:\n            frame = sys._getframe(1)\n            _globs_ = frame.f_globals\n            if _locs_ is None:\n                _locs_ = frame.f_locals\n            del frame\n        elif _locs_ is None:\n            _locs_ = _globs_\n        exec(\"\"\"exec _code_ in _globs_, _locs_\"\"\")\n\nelse:\n    string_types = str,\n\n    import builtins\n\n    exec_ = getattr(builtins, \"exec\")\n    del builtins\n\nfrom functools import partial\nfrom inspect import isclass\nfrom threading import Lock, RLock\n\nfrom .arguments import formatargspec\n\ntry:\n    from inspect import signature\nexcept ImportError:\n    pass\n\nfrom .__wrapt__ import (FunctionWrapper, BoundFunctionWrapper, ObjectProxy,\n    CallableObjectProxy)\n\n# Adapter wrapper for the wrapped function which will overlay certain\n# properties from the adapter function onto the wrapped function so that\n# functions such as inspect.getargspec(), inspect.getfullargspec(),\n# inspect.signature() and inspect.getsource() return the correct results\n# one would expect.\n\nclass _AdapterFunctionCode(CallableObjectProxy):\n\n    def __init__(self, wrapped_code, adapter_code):\n        super(_AdapterFunctionCode, self).__init__(wrapped_code)\n        self._self_adapter_code = adapter_code\n\n    @property\n    def co_argcount(self):\n        return self._self_adapter_code.co_argcount\n\n    @property\n    def co_code(self):\n        return self._self_adapter_code.co_code\n\n    @property\n    def co_flags(self):\n        return self._self_adapter_code.co_flags\n\n    @property\n    def co_kwonlyargcount(self):\n        return self._self_adapter_code.co_kwonlyargcount\n\n    @property\n    def co_varnames(self):\n        return self._self_adapter_code.co_varnames\n\nclass _AdapterFunctionSurrogate(CallableObjectProxy):\n\n    def __init__(self, wrapped, adapter):\n        super(_AdapterFunctionSurrogate, self).__init__(wrapped)\n        self._self_adapter = adapter\n\n    @property\n    def __code__(self):\n        return _AdapterFunctionCode(self.__wrapped__.__code__,\n                self._self_adapter.__code__)\n\n    @property\n    def __defaults__(self):\n        return self._self_adapter.__defaults__\n\n    @property\n    def __kwdefaults__(self):\n        return self._self_adapter.__kwdefaults__\n\n    @property\n    def __signature__(self):\n        if 'signature' not in globals():\n            return self._self_adapter.__signature__\n        else:\n            return signature(self._self_adapter)\n\n    if PY2:\n        func_code = __code__\n        func_defaults = __defaults__\n\nclass _BoundAdapterWrapper(BoundFunctionWrapper):\n\n    @property\n    def __func__(self):\n        return _AdapterFunctionSurrogate(self.__wrapped__.__func__,\n                self._self_parent._self_adapter)\n\n    @property\n    def __signature__(self):\n        if 'signature' not in globals():\n            return self.__wrapped__.__signature__\n        else:\n            return signature(self._self_parent._self_adapter)\n\n    if PY2:\n        im_func = __func__\n\nclass AdapterWrapper(FunctionWrapper):\n\n    __bound_function_wrapper__ = _BoundAdapterWrapper\n\n    def __init__(self, *args, **kwargs):\n        adapter = kwargs.pop('adapter')\n        super(AdapterWrapper, self).__init__(*args, **kwargs)\n        self._self_surrogate = _AdapterFunctionSurrogate(\n                self.__wrapped__, adapter)\n        self._self_adapter = adapter\n\n    @property\n    def __code__(self):\n        return self._self_surrogate.__code__\n\n    @property\n    def __defaults__(self):\n        return self._self_surrogate.__defaults__\n\n    @property\n    def __kwdefaults__(self):\n        return self._self_surrogate.__kwdefaults__\n\n    if PY2:\n        func_code = __code__\n        func_defaults = __defaults__\n\n    @property\n    def __signature__(self):\n        return self._self_surrogate.__signature__\n\nclass AdapterFactory(object):\n    def __call__(self, wrapped):\n        raise NotImplementedError()\n\nclass DelegatedAdapterFactory(AdapterFactory):\n    def __init__(self, factory):\n        super(DelegatedAdapterFactory, self).__init__()\n        self.factory = factory\n    def __call__(self, wrapped):\n        return self.factory(wrapped)\n\nadapter_factory = DelegatedAdapterFactory\n\n# Decorator for creating other decorators. This decorator and the\n# wrappers which they use are designed to properly preserve any name\n# attributes, function signatures etc, in addition to the wrappers\n# themselves acting like a transparent proxy for the original wrapped\n# function so the wrapper is effectively indistinguishable from the\n# original wrapped function.\n\ndef decorator(wrapper=None, enabled=None, adapter=None, proxy=FunctionWrapper):\n    # The decorator should be supplied with a single positional argument\n    # which is the wrapper function to be used to implement the\n    # decorator. This may be preceded by a step whereby the keyword\n    # arguments are supplied to customise the behaviour of the\n    # decorator. The 'adapter' argument is used to optionally denote a\n    # separate function which is notionally used by an adapter\n    # decorator. In that case parts of the function '__code__' and\n    # '__defaults__' attributes are used from the adapter function\n    # rather than those of the wrapped function. This allows for the\n    # argument specification from inspect.getfullargspec() and similar\n    # functions to be overridden with a prototype for a different\n    # function than what was wrapped. The 'enabled' argument provides a\n    # way to enable/disable the use of the decorator. If the type of\n    # 'enabled' is a boolean, then it is evaluated immediately and the\n    # wrapper not even applied if it is False. If not a boolean, it will\n    # be evaluated when the wrapper is called for an unbound wrapper,\n    # and when binding occurs for a bound wrapper. When being evaluated,\n    # if 'enabled' is callable it will be called to obtain the value to\n    # be checked. If False, the wrapper will not be called and instead\n    # the original wrapped function will be called directly instead.\n    # The 'proxy' argument provides a way of passing a custom version of\n    # the FunctionWrapper class used in decorating the function.\n\n    if wrapper is not None:\n        # Helper function for creating wrapper of the appropriate\n        # time when we need it down below.\n\n        def _build(wrapped, wrapper, enabled=None, adapter=None):\n            if adapter:\n                if isinstance(adapter, AdapterFactory):\n                    adapter = adapter(wrapped)\n\n                if not callable(adapter):\n                    ns = {}\n\n                    # Check if the signature argument specification has\n                    # annotations. If it does then we need to remember\n                    # it but also drop it when attempting to manufacture\n                    # a standin adapter function. This is necessary else\n                    # it will try and look up any types referenced in\n                    # the annotations in the empty namespace we use,\n                    # which will fail.\n\n                    annotations = {}\n\n                    if not isinstance(adapter, string_types):\n                        if len(adapter) == 7:\n                            annotations = adapter[-1]\n                            adapter = adapter[:-1]\n                        adapter = formatargspec(*adapter)\n\n                    exec_('def adapter{}: pass'.format(adapter), ns, ns)\n                    adapter = ns['adapter']\n\n                    # Override the annotations for the manufactured\n                    # adapter function so they match the original\n                    # adapter signature argument specification.\n\n                    if annotations:\n                        adapter.__annotations__ = annotations\n\n                return AdapterWrapper(wrapped=wrapped, wrapper=wrapper,\n                        enabled=enabled, adapter=adapter)\n\n            return proxy(wrapped=wrapped, wrapper=wrapper, enabled=enabled)\n\n        # The wrapper has been provided so return the final decorator.\n        # The decorator is itself one of our function wrappers so we\n        # can determine when it is applied to functions, instance methods\n        # or class methods. This allows us to bind the instance or class\n        # method so the appropriate self or cls attribute is supplied\n        # when it is finally called.\n\n        def _wrapper(wrapped, instance, args, kwargs):\n            # We first check for the case where the decorator was applied\n            # to a class type.\n            #\n            #     @decorator\n            #     class mydecoratorclass(object):\n            #         def __init__(self, arg=None):\n            #             self.arg = arg\n            #         def __call__(self, wrapped, instance, args, kwargs):\n            #             return wrapped(*args, **kwargs)\n            #\n            #     @mydecoratorclass(arg=1)\n            #     def function():\n            #         pass\n            #\n            # In this case an instance of the class is to be used as the\n            # decorator wrapper function. If args was empty at this point,\n            # then it means that there were optional keyword arguments\n            # supplied to be used when creating an instance of the class\n            # to be used as the wrapper function.\n\n            if instance is None and isclass(wrapped) and not args:\n                # We still need to be passed the target function to be\n                # wrapped as yet, so we need to return a further function\n                # to be able to capture it.\n\n                def _capture(target_wrapped):\n                    # Now have the target function to be wrapped and need\n                    # to create an instance of the class which is to act\n                    # as the decorator wrapper function. Before we do that,\n                    # we need to first check that use of the decorator\n                    # hadn't been disabled by a simple boolean. If it was,\n                    # the target function to be wrapped is returned instead.\n\n                    _enabled = enabled\n                    if type(_enabled) is bool:\n                        if not _enabled:\n                            return target_wrapped\n                        _enabled = None\n\n                    # Now create an instance of the class which is to act\n                    # as the decorator wrapper function. Any arguments had\n                    # to be supplied as keyword only arguments so that is\n                    # all we pass when creating it.\n\n                    target_wrapper = wrapped(**kwargs)\n\n                    # Finally build the wrapper itself and return it.\n\n                    return _build(target_wrapped, target_wrapper,\n                            _enabled, adapter)\n\n                return _capture\n\n            # We should always have the target function to be wrapped at\n            # this point as the first (and only) value in args.\n\n            target_wrapped = args[0]\n\n            # Need to now check that use of the decorator hadn't been\n            # disabled by a simple boolean. If it was, then target\n            # function to be wrapped is returned instead.\n\n            _enabled = enabled\n            if type(_enabled) is bool:\n                if not _enabled:\n                    return target_wrapped\n                _enabled = None\n\n            # We now need to build the wrapper, but there are a couple of\n            # different cases we need to consider.\n\n            if instance is None:\n                if isclass(wrapped):\n                    # In this case the decorator was applied to a class\n                    # type but optional keyword arguments were not supplied\n                    # for initialising an instance of the class to be used\n                    # as the decorator wrapper function.\n                    #\n                    #     @decorator\n                    #     class mydecoratorclass(object):\n                    #         def __init__(self, arg=None):\n                    #             self.arg = arg\n                    #         def __call__(self, wrapped, instance,\n                    #                 args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     @mydecoratorclass\n                    #     def function():\n                    #         pass\n                    #\n                    # We still need to create an instance of the class to\n                    # be used as the decorator wrapper function, but no\n                    # arguments are pass.\n\n                    target_wrapper = wrapped()\n\n                else:\n                    # In this case the decorator was applied to a normal\n                    # function, or possibly a static method of a class.\n                    #\n                    #     @decorator\n                    #     def mydecoratorfuntion(wrapped, instance,\n                    #             args, kwargs):\n                    #         return wrapped(*args, **kwargs)\n                    #\n                    #     @mydecoratorfunction\n                    #     def function():\n                    #         pass\n                    #\n                    # That normal function becomes the decorator wrapper\n                    # function.\n\n                    target_wrapper = wrapper\n\n            else:\n                if isclass(instance):\n                    # In this case the decorator was applied to a class\n                    # method.\n                    #\n                    #     class myclass(object):\n                    #         @decorator\n                    #         @classmethod\n                    #         def decoratorclassmethod(cls, wrapped,\n                    #                 instance, args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     instance = myclass()\n                    #\n                    #     @instance.decoratorclassmethod\n                    #     def function():\n                    #         pass\n                    #\n                    # This one is a bit strange because binding was actually\n                    # performed on the wrapper created by our decorator\n                    # factory. We need to apply that binding to the decorator\n                    # wrapper function that the decorator factory\n                    # was applied to.\n\n                    target_wrapper = wrapper.__get__(None, instance)\n\n                else:\n                    # In this case the decorator was applied to an instance\n                    # method.\n                    #\n                    #     class myclass(object):\n                    #         @decorator\n                    #         def decoratorclassmethod(self, wrapped,\n                    #                 instance, args, kwargs):\n                    #             return wrapped(*args, **kwargs)\n                    #\n                    #     instance = myclass()\n                    #\n                    #     @instance.decoratorclassmethod\n                    #     def function():\n                    #         pass\n                    #\n                    # This one is a bit strange because binding was actually\n                    # performed on the wrapper created by our decorator\n                    # factory. We need to apply that binding to the decorator\n                    # wrapper function that the decorator factory\n                    # was applied to.\n\n                    target_wrapper = wrapper.__get__(instance, type(instance))\n\n            # Finally build the wrapper itself and return it.\n\n            return _build(target_wrapped, target_wrapper, _enabled, adapter)\n\n        # We first return our magic function wrapper here so we can\n        # determine in what context the decorator factory was used. In\n        # other words, it is itself a universal decorator. The decorator\n        # function is used as the adapter so that linters see a signature\n        # corresponding to the decorator and not the wrapper it is being\n        # applied to.\n\n        return _build(wrapper, _wrapper, adapter=decorator)\n\n    else:\n        # The wrapper still has not been provided, so we are just\n        # collecting the optional keyword arguments. Return the\n        # decorator again wrapped in a partial using the collected\n        # arguments.\n\n        return partial(decorator, enabled=enabled, adapter=adapter,\n                proxy=proxy)\n\n# Decorator for implementing thread synchronization. It can be used as a\n# decorator, in which case the synchronization context is determined by\n# what type of function is wrapped, or it can also be used as a context\n# manager, where the user needs to supply the correct synchronization\n# context. It is also possible to supply an object which appears to be a\n# synchronization primitive of some sort, by virtue of having release()\n# and acquire() methods. In that case that will be used directly as the\n# synchronization primitive without creating a separate lock against the\n# derived or supplied context.\n\ndef synchronized(wrapped):\n    # Determine if being passed an object which is a synchronization\n    # primitive. We can't check by type for Lock, RLock, Semaphore etc,\n    # as the means of creating them isn't the type. Therefore use the\n    # existence of acquire() and release() methods. This is more\n    # extensible anyway as it allows custom synchronization mechanisms.\n\n    if hasattr(wrapped, 'acquire') and hasattr(wrapped, 'release'):\n        # We remember what the original lock is and then return a new\n        # decorator which accesses and locks it. When returning the new\n        # decorator we wrap it with an object proxy so we can override\n        # the context manager methods in case it is being used to wrap\n        # synchronized statements with a 'with' statement.\n\n        lock = wrapped\n\n        @decorator\n        def _synchronized(wrapped, instance, args, kwargs):\n            # Execute the wrapped function while the original supplied\n            # lock is held.\n\n            with lock:\n                return wrapped(*args, **kwargs)\n\n        class _PartialDecorator(CallableObjectProxy):\n\n            def __enter__(self):\n                lock.acquire()\n                return lock\n\n            def __exit__(self, *args):\n                lock.release()\n\n        return _PartialDecorator(wrapped=_synchronized)\n\n    # Following only apply when the lock is being created automatically\n    # based on the context of what was supplied. In this case we supply\n    # a final decorator, but need to use FunctionWrapper directly as we\n    # want to derive from it to add context manager methods in case it is\n    # being used to wrap synchronized statements with a 'with' statement.\n\n    def _synchronized_lock(context):\n        # Attempt to retrieve the lock for the specific context.\n\n        lock = vars(context).get('_synchronized_lock', None)\n\n        if lock is None:\n            # There is no existing lock defined for the context we\n            # are dealing with so we need to create one. This needs\n            # to be done in a way to guarantee there is only one\n            # created, even if multiple threads try and create it at\n            # the same time. We can't always use the setdefault()\n            # method on the __dict__ for the context. This is the\n            # case where the context is a class, as __dict__ is\n            # actually a dictproxy. What we therefore do is use a\n            # meta lock on this wrapper itself, to control the\n            # creation and assignment of the lock attribute against\n            # the context.\n\n            with synchronized._synchronized_meta_lock:\n                # We need to check again for whether the lock we want\n                # exists in case two threads were trying to create it\n                # at the same time and were competing to create the\n                # meta lock.\n\n                lock = vars(context).get('_synchronized_lock', None)\n\n                if lock is None:\n                    lock = RLock()\n                    setattr(context, '_synchronized_lock', lock)\n\n        return lock\n\n    def _synchronized_wrapper(wrapped, instance, args, kwargs):\n        # Execute the wrapped function while the lock for the\n        # desired context is held. If instance is None then the\n        # wrapped function is used as the context.\n\n        with _synchronized_lock(instance if instance is not None else wrapped):\n            return wrapped(*args, **kwargs)\n\n    class _FinalDecorator(FunctionWrapper):\n\n        def __enter__(self):\n            self._self_lock = _synchronized_lock(self.__wrapped__)\n            self._self_lock.acquire()\n            return self._self_lock\n\n        def __exit__(self, *args):\n            self._self_lock.release()\n\n    return _FinalDecorator(wrapped=wrapped, wrapper=_synchronized_wrapper)\n\nsynchronized._synchronized_meta_lock = Lock()\n", "src/wrapt/arguments.py": "# The inspect.formatargspec() function was dropped in Python 3.11 but we need\n# need it for when constructing signature changing decorators based on result of\n# inspect.getargspec() or inspect.getfullargspec(). The code here implements\n# inspect.formatargspec() base on Parameter and Signature from inspect module,\n# which were added in Python 3.6. Thanks to Cyril Jouve for the implementation.\n\ntry:\n    from inspect import Parameter, Signature\nexcept ImportError:\n    from inspect import formatargspec\nelse:\n    def formatargspec(args, varargs=None, varkw=None, defaults=None,\n                      kwonlyargs=(), kwonlydefaults={}, annotations={}):\n        if kwonlydefaults is None:\n            kwonlydefaults = {}\n        ndefaults = len(defaults) if defaults else 0\n        parameters = [\n            Parameter(\n                arg,\n                Parameter.POSITIONAL_OR_KEYWORD,\n                default=defaults[i] if i >= 0 else Parameter.empty,\n                annotation=annotations.get(arg, Parameter.empty),\n            ) for i, arg in enumerate(args, ndefaults - len(args))\n        ]\n        if varargs:\n            parameters.append(Parameter(varargs, Parameter.VAR_POSITIONAL))\n        parameters.extend(\n            Parameter(\n                kwonlyarg,\n                Parameter.KEYWORD_ONLY,\n                default=kwonlydefaults.get(kwonlyarg, Parameter.empty),\n                annotation=annotations.get(kwonlyarg, Parameter.empty),\n            ) for kwonlyarg in kwonlyargs\n        )\n        if varkw:\n            parameters.append(Parameter(varkw, Parameter.VAR_KEYWORD))\n        return_annotation = annotations.get('return', Signature.empty)\n        return str(Signature(parameters, return_annotation=return_annotation))", "src/wrapt/__init__.py": "__version_info__ = ('1', '16', '0')\n__version__ = '.'.join(__version_info__)\n\nfrom .__wrapt__ import (ObjectProxy, CallableObjectProxy, FunctionWrapper,\n        BoundFunctionWrapper, PartialCallableObjectProxy)\n\nfrom .patches import (resolve_path, apply_patch, wrap_object, wrap_object_attribute,\n        function_wrapper, wrap_function_wrapper, patch_function_wrapper,\n        transient_function_wrapper)\n\nfrom .weakrefs import WeakFunctionProxy\n\nfrom .decorators import (adapter_factory, AdapterFactory, decorator,\n        synchronized)\n\nfrom .importer import (register_post_import_hook, when_imported,\n        notify_module_loaded, discover_post_import_hooks)\n\n# Import of inspect.getcallargs() included for backward compatibility. An\n# implementation of this was previously bundled and made available here for\n# Python <2.7. Avoid using this in future.\n\nfrom inspect import getcallargs\n\n# Variant of inspect.formatargspec() included here for forward compatibility.\n# This is being done because Python 3.11 dropped inspect.formatargspec() but\n# code for handling signature changing decorators relied on it. Exposing the\n# bundled implementation here in case any user of wrapt was also needing it.\n\nfrom .arguments import formatargspec\n"}