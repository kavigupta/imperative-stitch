{"importlib_resources/_itertools.py": "# from more_itertools 9.0\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n", "importlib_resources/_common.py": "import os\nimport pathlib\nimport tempfile\nimport functools\nimport contextlib\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport itertools\n\nfrom typing import Union, Optional, cast\nfrom .abc import ResourceReader, Traversable\n\nPackage = Union[types.ModuleType, str]\nAnchor = Package\n\n\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n\n    Other errors should fall through.\n\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n\n    Remove this compatibility in Python 3.14.\n    \"\"\"\n    undefined = object()\n\n    @functools.wraps(func)\n    def wrapper(anchor=undefined, package=undefined):\n        if package is not undefined:\n            if anchor is not undefined:\n                return func(anchor, package)\n            warnings.warn(\n                \"First parameter to files is renamed to 'anchor'\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(package)\n        elif anchor is undefined:\n            return func()\n        return func(anchor)\n\n    return wrapper\n\n\n@package_to_anchor\ndef files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\n\n\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__\n    reader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore\n    if reader is None:\n        return None\n    return reader(spec.name)  # type: ignore\n\n\n@functools.singledispatch\ndef resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n\n\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n\n\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\n\n\ndef _infer_caller():\n    \"\"\"\n    Walk the stack and find the frame of the first caller not in this module.\n    \"\"\"\n\n    def is_this_file(frame_info):\n        return frame_info.filename == __file__\n\n    def is_wrapper(frame_info):\n        return frame_info.function == 'wrapper'\n\n    not_this_file = itertools.filterfalse(is_this_file, inspect.stack())\n    # also exclude 'wrapper' due to singledispatch in the call stack\n    callers = itertools.filterfalse(is_wrapper, not_this_file)\n    return next(callers).frame\n\n\ndef from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n\n    \"\"\"\n    # deferred for performance (python/cpython#109829)\n    from .future.adapters import wrap_spec\n\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n\n\n@contextlib.contextmanager\ndef _tempfile(\n    reader,\n    suffix='',\n    # gh-93353: Keep a reference to call os.remove() in late Python\n    # finalization.\n    *,\n    _os_remove=os.remove,\n):\n    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'\n    # blocks due to the need to close the temporary file to work on Windows\n    # properly.\n    fd, raw_path = tempfile.mkstemp(suffix=suffix)\n    try:\n        try:\n            os.write(fd, reader())\n        finally:\n            os.close(fd)\n        del reader\n        yield pathlib.Path(raw_path)\n    finally:\n        try:\n            _os_remove(raw_path)\n        except FileNotFoundError:\n            pass\n\n\ndef _temp_file(path):\n    return _tempfile(path.read_bytes, suffix=path.name)\n\n\ndef _is_present_dir(path: Traversable) -> bool:\n    \"\"\"\n    Some Traversables implement ``is_dir()`` to raise an\n    exception (i.e. ``FileNotFoundError``) when the\n    directory doesn't exist. This function wraps that call\n    to always return a boolean and only return True\n    if there's a dir and it exists.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        return path.is_dir()\n    return False\n\n\n@functools.singledispatch\ndef as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n\n\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"\n    Degenerate behavior for pathlib.Path objects.\n    \"\"\"\n    yield path\n\n\n@contextlib.contextmanager\ndef _temp_path(dir: tempfile.TemporaryDirectory):\n    \"\"\"\n    Wrap tempfile.TemporyDirectory to return a pathlib object.\n    \"\"\"\n    with dir as result:\n        yield pathlib.Path(result)\n\n\n@contextlib.contextmanager\ndef _temp_dir(path):\n    \"\"\"\n    Given a traversable dir, recursively replicate the whole tree\n    to the file system in a context manager.\n    \"\"\"\n    assert path.is_dir()\n    with _temp_path(tempfile.TemporaryDirectory()) as temp_dir:\n        yield _write_contents(temp_dir, path)\n\n\ndef _write_contents(target, source):\n    child = target.joinpath(source.name)\n    if source.is_dir():\n        child.mkdir()\n        for item in source.iterdir():\n            _write_contents(child, item)\n    else:\n        child.write_bytes(source.read_bytes())\n    return child\n", "importlib_resources/simple.py": "\"\"\"\nInterface adapters for low-level readers.\n\"\"\"\n\nimport abc\nimport io\nimport itertools\nfrom typing import BinaryIO, List\n\nfrom .abc import Traversable, TraversableResources\n\n\nclass SimpleReader(abc.ABC):\n    \"\"\"\n    The minimum, low-level interface required from a resource\n    provider.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def package(self) -> str:\n        \"\"\"\n        The name of the package for which this reader loads resources.\n        \"\"\"\n\n    @abc.abstractmethod\n    def children(self) -> List['SimpleReader']:\n        \"\"\"\n        Obtain an iterable of SimpleReader for available\n        child containers (e.g. directories).\n        \"\"\"\n\n    @abc.abstractmethod\n    def resources(self) -> List[str]:\n        \"\"\"\n        Obtain available named resources for this virtual package.\n        \"\"\"\n\n    @abc.abstractmethod\n    def open_binary(self, resource: str) -> BinaryIO:\n        \"\"\"\n        Obtain a File-like for a named resource.\n        \"\"\"\n\n    @property\n    def name(self):\n        return self.package.split('.')[-1]\n\n\nclass ResourceContainer(Traversable):\n    \"\"\"\n    Traversable container for a package's resources via its reader.\n    \"\"\"\n\n    def __init__(self, reader: SimpleReader):\n        self.reader = reader\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def iterdir(self):\n        files = (ResourceHandle(self, name) for name in self.reader.resources)\n        dirs = map(ResourceContainer, self.reader.children())\n        return itertools.chain(files, dirs)\n\n    def open(self, *args, **kwargs):\n        raise IsADirectoryError()\n\n\nclass ResourceHandle(Traversable):\n    \"\"\"\n    Handle to a named resource in a ResourceReader.\n    \"\"\"\n\n    def __init__(self, parent: ResourceContainer, name: str):\n        self.parent = parent\n        self.name = name  # type: ignore\n\n    def is_file(self):\n        return True\n\n    def is_dir(self):\n        return False\n\n    def open(self, mode='r', *args, **kwargs):\n        stream = self.parent.reader.open_binary(self.name)\n        if 'b' not in mode:\n            stream = io.TextIOWrapper(stream, *args, **kwargs)\n        return stream\n\n    def joinpath(self, name):\n        raise RuntimeError(\"Cannot traverse into a resource\")\n\n\nclass TraversableReader(TraversableResources, SimpleReader):\n    \"\"\"\n    A TraversableResources based on SimpleReader. Resource providers\n    may derive from this class to provide the TraversableResources\n    interface by supplying the SimpleReader interface.\n    \"\"\"\n\n    def files(self):\n        return ResourceContainer(self)\n", "importlib_resources/abc.py": "import abc\nimport io\nimport itertools\nimport pathlib\nfrom typing import Any, BinaryIO, Iterable, Iterator, NoReturn, Text, Optional\nfrom typing import runtime_checkable, Protocol\n\nfrom .compat.py38 import StrPath\n\n\n__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def resource_path(self, resource: Text) -> Text:\n        \"\"\"Return the file system path to the specified resource.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource does not exist on the file system, raise\n        FileNotFoundError.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def is_resource(self, path: Text) -> bool:\n        \"\"\"Return True if the named 'path' is a resource.\n\n        Files are resources, directories are not.\n        \"\"\"\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def contents(self) -> Iterable[str]:\n        \"\"\"Return an iterable of entries in `package`.\"\"\"\n        raise FileNotFoundError\n\n\nclass TraversalError(Exception):\n    pass\n\n\n@runtime_checkable\nclass Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"\n\n    @abc.abstractmethod\n    def iterdir(self) -> Iterator[\"Traversable\"]:\n        \"\"\"\n        Yield Traversable objects in self\n        \"\"\"\n\n    def read_bytes(self) -> bytes:\n        \"\"\"\n        Read contents of self as bytes\n        \"\"\"\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def read_text(self, encoding: Optional[str] = None) -> str:\n        \"\"\"\n        Read contents of self as text\n        \"\"\"\n        with self.open(encoding=encoding) as strm:\n            return strm.read()\n\n    @abc.abstractmethod\n    def is_dir(self) -> bool:\n        \"\"\"\n        Return True if self is a directory\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_file(self) -> bool:\n        \"\"\"\n        Return True if self is a file\n        \"\"\"\n\n    def joinpath(self, *descendants: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable resolved with any descendants applied.\n\n        Each descendant should be a path segment relative to self\n        and each may contain multiple levels separated by\n        ``posixpath.sep`` (``/``).\n        \"\"\"\n        if not descendants:\n            return self\n        names = itertools.chain.from_iterable(\n            path.parts for path in map(pathlib.PurePosixPath, descendants)\n        )\n        target = next(names)\n        matches = (\n            traversable for traversable in self.iterdir() if traversable.name == target\n        )\n        try:\n            match = next(matches)\n        except StopIteration:\n            raise TraversalError(\n                \"Target not found during traversal.\", target, list(names)\n            )\n        return match.joinpath(*names)\n\n    def __truediv__(self, child: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable child in self\n        \"\"\"\n        return self.joinpath(child)\n\n    @abc.abstractmethod\n    def open(self, mode='r', *args, **kwargs):\n        \"\"\"\n        mode may be 'r' or 'rb' to open as text or binary. Return a handle\n        suitable for reading (same as pathlib.Path.open).\n\n        When opening as text, accepts encoding parameters such as those\n        accepted by io.TextIOWrapper.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The base name of this object without any parent references.\n        \"\"\"\n\n\nclass TraversableResources(ResourceReader):\n    \"\"\"\n    The required interface for providing traversable\n    resources.\n    \"\"\"\n\n    @abc.abstractmethod\n    def files(self) -> \"Traversable\":\n        \"\"\"Return a Traversable object for the loaded package.\"\"\"\n\n    def open_resource(self, resource: StrPath) -> io.BufferedReader:\n        return self.files().joinpath(resource).open('rb')\n\n    def resource_path(self, resource: Any) -> NoReturn:\n        raise FileNotFoundError(resource)\n\n    def is_resource(self, path: StrPath) -> bool:\n        return self.files().joinpath(path).is_file()\n\n    def contents(self) -> Iterator[str]:\n        return (item.name for item in self.files().iterdir())\n", "importlib_resources/readers.py": "import collections\nimport contextlib\nimport itertools\nimport pathlib\nimport operator\nimport re\nimport warnings\n\nfrom . import abc\n\nfrom ._itertools import only\nfrom .compat.py39 import ZipPath\n\n\ndef remove_duplicates(items):\n    return iter(collections.OrderedDict.fromkeys(items))\n\n\nclass FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\nclass ZipReader(abc.TraversableResources):\n    def __init__(self, loader, module):\n        _, _, name = module.rpartition('.')\n        self.prefix = loader.prefix.replace('\\\\', '/') + name + '/'\n        self.archive = loader.archive\n\n    def open_resource(self, resource):\n        try:\n            return super().open_resource(resource)\n        except KeyError as exc:\n            raise FileNotFoundError(exc.args[0])\n\n    def is_resource(self, path):\n        \"\"\"\n        Workaround for `zipfile.Path.is_file` returning true\n        for non-existent paths.\n        \"\"\"\n        target = self.files().joinpath(path)\n        return target.is_file() and target.exists()\n\n    def files(self):\n        return ZipPath(self.archive, self.prefix)\n\n\nclass MultiplexedPath(abc.Traversable):\n    \"\"\"\n    Given a series of Traversable objects, implement a merged\n    version of the interface across all objects. Useful for\n    namespace packages which may be multihomed at a single\n    name.\n    \"\"\"\n\n    def __init__(self, *paths):\n        self._paths = list(map(_ensure_traversable, remove_duplicates(paths)))\n        if not self._paths:\n            message = 'MultiplexedPath must contain at least one path'\n            raise FileNotFoundError(message)\n        if not all(path.is_dir() for path in self._paths):\n            raise NotADirectoryError('MultiplexedPath only supports directories')\n\n    def iterdir(self):\n        children = (child for path in self._paths for child in path.iterdir())\n        by_name = operator.attrgetter('name')\n        groups = itertools.groupby(sorted(children, key=by_name), key=by_name)\n        return map(self._follow, (locs for name, locs in groups))\n\n    def read_bytes(self):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def read_text(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def joinpath(self, *descendants):\n        try:\n            return super().joinpath(*descendants)\n        except abc.TraversalError:\n            # One of the paths did not resolve (a directory does not exist).\n            # Just return something that will not exist.\n            return self._paths[0].joinpath(*descendants)\n\n    @classmethod\n    def _follow(cls, children):\n        \"\"\"\n        Construct a MultiplexedPath if needed.\n\n        If children contains a sole element, return it.\n        Otherwise, return a MultiplexedPath of the items.\n        Unless one of the items is not a Directory, then return the first.\n        \"\"\"\n        subdirs, one_dir, one_file = itertools.tee(children, 3)\n\n        try:\n            return only(one_dir)\n        except ValueError:\n            try:\n                return cls(*subdirs)\n            except NotADirectoryError:\n                return next(one_file)\n\n    def open(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    @property\n    def name(self):\n        return self._paths[0].name\n\n    def __repr__(self):\n        paths = ', '.join(f\"'{path}'\" for path in self._paths)\n        return f'MultiplexedPath({paths})'\n\n\nclass NamespaceReader(abc.TraversableResources):\n    def __init__(self, namespace_path):\n        if 'NamespacePath' not in str(namespace_path):\n            raise ValueError('Invalid path')\n        self.path = MultiplexedPath(*map(self._resolve, namespace_path))\n\n    @classmethod\n    def _resolve(cls, path_str) -> abc.Traversable:\n        r\"\"\"\n        Given an item from a namespace path, resolve it to a Traversable.\n\n        path_str might be a directory on the filesystem or a path to a\n        zipfile plus the path within the zipfile, e.g. ``/foo/bar`` or\n        ``/foo/baz.zip/inner_dir`` or ``foo\\baz.zip\\inner_dir\\sub``.\n        \"\"\"\n        (dir,) = (cand for cand in cls._candidate_paths(path_str) if cand.is_dir())\n        return dir\n\n    @classmethod\n    def _candidate_paths(cls, path_str):\n        yield pathlib.Path(path_str)\n        yield from cls._resolve_zip_path(path_str)\n\n    @staticmethod\n    def _resolve_zip_path(path_str):\n        for match in reversed(list(re.finditer(r'[\\\\/]', path_str))):\n            with contextlib.suppress(\n                FileNotFoundError,\n                IsADirectoryError,\n                NotADirectoryError,\n                PermissionError,\n            ):\n                inner = path_str[match.end() :].replace('\\\\', '/') + '/'\n                yield ZipPath(path_str[: match.start()], inner.lstrip('/'))\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\ndef _ensure_traversable(path):\n    \"\"\"\n    Convert deprecated string arguments to traversables (pathlib.Path).\n\n    Remove with Python 3.15.\n    \"\"\"\n    if not isinstance(path, str):\n        return path\n\n    warnings.warn(\n        \"String arguments are deprecated. Pass a Traversable instead.\",\n        DeprecationWarning,\n        stacklevel=3,\n    )\n\n    return pathlib.Path(path)\n", "importlib_resources/functional.py": "\"\"\"Simplified function-based API for importlib.resources\"\"\"\n\nimport warnings\n\nfrom ._common import files, as_file\n\n\n_MISSING = object()\n\n\ndef open_binary(anchor, *path_names):\n    \"\"\"Open for binary reading the *resource* within *package*.\"\"\"\n    return _get_resource(anchor, path_names).open('rb')\n\n\ndef open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Open for text reading the *resource* within *package*.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.open('r', encoding=encoding, errors=errors)\n\n\ndef read_binary(anchor, *path_names):\n    \"\"\"Read and return contents of *resource* within *package* as bytes.\"\"\"\n    return _get_resource(anchor, path_names).read_bytes()\n\n\ndef read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Read and return contents of *resource* within *package* as str.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.read_text(encoding=encoding, errors=errors)\n\n\ndef path(anchor, *path_names):\n    \"\"\"Return the path to the *resource* as an actual file system path.\"\"\"\n    return as_file(_get_resource(anchor, path_names))\n\n\ndef is_resource(anchor, *path_names):\n    \"\"\"Return ``True`` if there is a resource named *name* in the package,\n\n    Otherwise returns ``False``.\n    \"\"\"\n    return _get_resource(anchor, path_names).is_file()\n\n\ndef contents(anchor, *path_names):\n    \"\"\"Return an iterable over the named resources within the package.\n\n    The iterable returns :class:`str` resources (e.g. files).\n    The iterable does not recurse into subdirectories.\n    \"\"\"\n    warnings.warn(\n        \"importlib.resources.contents is deprecated. \"\n        \"Use files(anchor).iterdir() instead.\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    return (resource.name for resource in _get_resource(anchor, path_names).iterdir())\n\n\ndef _get_encoding_arg(path_names, encoding):\n    # For compatibility with versions where *encoding* was a positional\n    # argument, it needs to be given explicitly when there are multiple\n    # *path_names*.\n    # This limitation can be removed in Python 3.15.\n    if encoding is _MISSING:\n        if len(path_names) > 1:\n            raise TypeError(\n                \"'encoding' argument required with multiple path names\",\n            )\n        else:\n            return 'utf-8'\n    return encoding\n\n\ndef _get_resource(anchor, path_names):\n    if anchor is None:\n        raise TypeError(\"anchor must be module or string, got None\")\n    return files(anchor).joinpath(*path_names)\n", "importlib_resources/_adapters.py": "from contextlib import suppress\nfrom io import TextIOWrapper\n\nfrom . import abc\n\n\nclass SpecLoaderAdapter:\n    \"\"\"\n    Adapt a package spec to adapt the underlying loader.\n    \"\"\"\n\n    def __init__(self, spec, adapter=lambda spec: spec.loader):\n        self.spec = spec\n        self.loader = adapter(spec)\n\n    def __getattr__(self, name):\n        return getattr(self.spec, name)\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt a loader to provide TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    def get_resource_reader(self, name):\n        return CompatibilityFiles(self.spec)._native()\n\n\ndef _io_wrapper(file, mode='r', *args, **kwargs):\n    if mode == 'r':\n        return TextIOWrapper(file, *args, **kwargs)\n    elif mode == 'rb':\n        return file\n    raise ValueError(f\"Invalid mode value '{mode}', only 'r' and 'rb' are supported\")\n\n\nclass CompatibilityFiles:\n    \"\"\"\n    Adapter for an existing or non-existent resource reader\n    to provide a compatibility .files().\n    \"\"\"\n\n    class SpecPath(abc.Traversable):\n        \"\"\"\n        Path tied to a module spec.\n        Can be read and exposes the resource reader children.\n        \"\"\"\n\n        def __init__(self, spec, reader):\n            self._spec = spec\n            self._reader = reader\n\n        def iterdir(self):\n            if not self._reader:\n                return iter(())\n            return iter(\n                CompatibilityFiles.ChildPath(self._reader, path)\n                for path in self._reader.contents()\n            )\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            if not self._reader:\n                return CompatibilityFiles.OrphanPath(other)\n            return CompatibilityFiles.ChildPath(self._reader, other)\n\n        @property\n        def name(self):\n            return self._spec.name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(self._reader.open_resource(None), mode, *args, **kwargs)\n\n    class ChildPath(abc.Traversable):\n        \"\"\"\n        Path tied to a resource reader child.\n        Can be read but doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, reader, name):\n            self._reader = reader\n            self._name = name\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return self._reader.is_resource(self.name)\n\n        def is_dir(self):\n            return not self.is_file()\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(self.name, other)\n\n        @property\n        def name(self):\n            return self._name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(\n                self._reader.open_resource(self.name), mode, *args, **kwargs\n            )\n\n    class OrphanPath(abc.Traversable):\n        \"\"\"\n        Orphan path, not tied to a module spec or resource reader.\n        Can't be read and doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, *path_parts):\n            if len(path_parts) < 1:\n                raise ValueError('Need at least one path part to construct a path')\n            self._path = path_parts\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(*self._path, other)\n\n        @property\n        def name(self):\n            return self._path[-1]\n\n        def open(self, mode='r', *args, **kwargs):\n            raise FileNotFoundError(\"Can't open orphan path\")\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def _reader(self):\n        with suppress(AttributeError):\n            return self.spec.loader.get_resource_reader(self.spec.name)\n\n    def _native(self):\n        \"\"\"\n        Return the native reader if it supports files().\n        \"\"\"\n        reader = self._reader\n        return reader if hasattr(reader, 'files') else self\n\n    def __getattr__(self, attr):\n        return getattr(self._reader, attr)\n\n    def files(self):\n        return CompatibilityFiles.SpecPath(self.spec, self._reader)\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n    \"\"\"\n    return SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "importlib_resources/__init__.py": "\"\"\"Read resources contained within a package.\"\"\"\n\nfrom ._common import (\n    as_file,\n    files,\n    Package,\n    Anchor,\n)\n\nfrom .functional import (\n    contents,\n    is_resource,\n    open_binary,\n    open_text,\n    path,\n    read_binary,\n    read_text,\n)\n\nfrom .abc import ResourceReader\n\n\n__all__ = [\n    'Package',\n    'Anchor',\n    'ResourceReader',\n    'as_file',\n    'files',\n    'contents',\n    'is_resource',\n    'open_binary',\n    'open_text',\n    'path',\n    'read_binary',\n    'read_text',\n]\n", "importlib_resources/compat/py38.py": "import os\nimport sys\n\nfrom typing import Union\n\n\nif sys.version_info >= (3, 9):\n    StrPath = Union[str, os.PathLike[str]]\nelse:\n    # PathLike is only subscriptable at runtime in 3.9+\n    StrPath = Union[str, \"os.PathLike[str]\"]\n", "importlib_resources/compat/py39.py": "import sys\n\n\n__all__ = ['ZipPath']\n\n\nif sys.version_info >= (3, 10):\n    from zipfile import Path as ZipPath  # type: ignore\nelse:\n    from zipp import Path as ZipPath  # type: ignore\n", "importlib_resources/compat/__init__.py": "", "importlib_resources/future/adapters.py": "import functools\nimport pathlib\nfrom contextlib import suppress\nfrom types import SimpleNamespace\n\nfrom .. import readers, _adapters\n\n\ndef _block_standard(reader_getter):\n    \"\"\"\n    Wrap _adapters.TraversableResourcesLoader.get_resource_reader\n    and intercept any standard library readers.\n    \"\"\"\n\n    @functools.wraps(reader_getter)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        If the reader is from the standard library, return None to allow\n        allow likely newer implementations in this library to take precedence.\n        \"\"\"\n        try:\n            reader = reader_getter(*args, **kwargs)\n        except NotADirectoryError:\n            # MultiplexedPath may fail on zip subdirectory\n            return\n        # Python 3.10+\n        mod_name = reader.__class__.__module__\n        if mod_name.startswith('importlib.') and mod_name.endswith('readers'):\n            return\n        # Python 3.8, 3.9\n        if isinstance(reader, _adapters.CompatibilityFiles) and (\n            reader.spec.loader.__class__.__module__.startswith('zipimport')\n            or reader.spec.loader.__class__.__module__.startswith(\n                '_frozen_importlib_external'\n            )\n        ):\n            return\n        return reader\n\n    return wrapper\n\n\ndef _skip_degenerate(reader):\n    \"\"\"\n    Mask any degenerate reader. Ref #298.\n    \"\"\"\n    is_degenerate = (\n        isinstance(reader, _adapters.CompatibilityFiles) and not reader._reader\n    )\n    return reader if not is_degenerate else None\n\n\nclass TraversableResourcesLoader(_adapters.TraversableResourcesLoader):\n    \"\"\"\n    Adapt loaders to provide TraversableResources and other\n    compatibility.\n\n    Ensures the readers from importlib_resources are preferred\n    over stdlib readers.\n    \"\"\"\n\n    def get_resource_reader(self, name):\n        return (\n            _skip_degenerate(_block_standard(super().get_resource_reader)(name))\n            or self._standard_reader()\n            or super().get_resource_reader(name)\n        )\n\n    def _standard_reader(self):\n        return self._zip_reader() or self._namespace_reader() or self._file_reader()\n\n    def _zip_reader(self):\n        with suppress(AttributeError):\n            return readers.ZipReader(self.spec.loader, self.spec.name)\n\n    def _namespace_reader(self):\n        with suppress(AttributeError, ValueError):\n            return readers.NamespaceReader(self.spec.submodule_search_locations)\n\n    def _file_reader(self):\n        try:\n            path = pathlib.Path(self.spec.origin)\n        except TypeError:\n            return None\n        if path.exists():\n            return readers.FileReader(SimpleNamespace(path=path))\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Override _adapters.wrap_spec to use TraversableResourcesLoader\n    from above. Ensures that future behavior is always available on older\n    Pythons.\n    \"\"\"\n    return _adapters.SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "importlib_resources/future/__init__.py": ""}