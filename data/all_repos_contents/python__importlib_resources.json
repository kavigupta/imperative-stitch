{"docs/conf.py": "extensions = [\n    'sphinx.ext.autodoc',\n    'jaraco.packaging.sphinx',\n]\n\nmaster_doc = \"index\"\nhtml_theme = \"furo\"\n\n# Link dates and other references in the changelog\nextensions += ['rst.linker']\nlink_files = {\n    '../NEWS.rst': dict(\n        using=dict(GH='https://github.com'),\n        replace=[\n            dict(\n                pattern=r'(Issue #|\\B#)(?P<issue>\\d+)',\n                url='{package_url}/issues/{issue}',\n            ),\n            dict(\n                pattern=r'(?m:^((?P<scm_version>v?\\d+(\\.\\d+){1,2}))\\n[-=]+\\n)',\n                with_scm='{text}\\n{rev[timestamp]:%d %b %Y}\\n',\n            ),\n            dict(\n                pattern=r'PEP[- ](?P<pep_number>\\d+)',\n                url='https://peps.python.org/pep-{pep_number:0>4}/',\n            ),\n            dict(\n                pattern=r'(python/cpython#|Python #|bpo-)(?P<python>\\d+)',\n                url='http://bugs.python.org/issue{python}',\n            ),\n        ],\n    ),\n}\n\n# Be strict about any broken references\nnitpicky = True\nnitpick_ignore = []\n\n# Include Python intersphinx mapping to prevent failures\n# jaraco/skeleton#51\nextensions += ['sphinx.ext.intersphinx']\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/3', None),\n}\n\n# Preserve authored syntax for defaults\nautodoc_preserve_defaults = True\n\nextensions += ['jaraco.tidelift']\n\nnitpick_ignore.extend([\n    ('py:class', 'module'),\n    ('py:class', '_io.BufferedReader'),\n])\n", "importlib_resources/_itertools.py": "# from more_itertools 9.0\ndef only(iterable, default=None, too_long=None):\n    \"\"\"If *iterable* has only one item, return it.\n    If it has zero items, return *default*.\n    If it has more than one item, raise the exception given by *too_long*,\n    which is ``ValueError`` by default.\n    >>> only([], default='missing')\n    'missing'\n    >>> only([1])\n    1\n    >>> only([1, 2])  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    ValueError: Expected exactly one item in iterable, but got 1, 2,\n     and perhaps more.'\n    >>> only([1, 2], too_long=TypeError)  # doctest: +IGNORE_EXCEPTION_DETAIL\n    Traceback (most recent call last):\n    ...\n    TypeError\n    Note that :func:`only` attempts to advance *iterable* twice to ensure there\n    is only one item.  See :func:`spy` or :func:`peekable` to check\n    iterable contents less destructively.\n    \"\"\"\n    it = iter(iterable)\n    first_value = next(it, default)\n\n    try:\n        second_value = next(it)\n    except StopIteration:\n        pass\n    else:\n        msg = (\n            'Expected exactly one item in iterable, but got {!r}, {!r}, '\n            'and perhaps more.'.format(first_value, second_value)\n        )\n        raise too_long or ValueError(msg)\n\n    return first_value\n", "importlib_resources/_common.py": "import os\nimport pathlib\nimport tempfile\nimport functools\nimport contextlib\nimport types\nimport importlib\nimport inspect\nimport warnings\nimport itertools\n\nfrom typing import Union, Optional, cast\nfrom .abc import ResourceReader, Traversable\n\nPackage = Union[types.ModuleType, str]\nAnchor = Package\n\n\ndef package_to_anchor(func):\n    \"\"\"\n    Replace 'package' parameter as 'anchor' and warn about the change.\n\n    Other errors should fall through.\n\n    >>> files('a', 'b')\n    Traceback (most recent call last):\n    TypeError: files() takes from 0 to 1 positional arguments but 2 were given\n\n    Remove this compatibility in Python 3.14.\n    \"\"\"\n    undefined = object()\n\n    @functools.wraps(func)\n    def wrapper(anchor=undefined, package=undefined):\n        if package is not undefined:\n            if anchor is not undefined:\n                return func(anchor, package)\n            warnings.warn(\n                \"First parameter to files is renamed to 'anchor'\",\n                DeprecationWarning,\n                stacklevel=2,\n            )\n            return func(package)\n        elif anchor is undefined:\n            return func()\n        return func(anchor)\n\n    return wrapper\n\n\n@package_to_anchor\ndef files(anchor: Optional[Anchor] = None) -> Traversable:\n    \"\"\"\n    Get a Traversable resource for an anchor.\n    \"\"\"\n    return from_package(resolve(anchor))\n\n\ndef get_resource_reader(package: types.ModuleType) -> Optional[ResourceReader]:\n    \"\"\"\n    Return the package's loader if it's a ResourceReader.\n    \"\"\"\n    # We can't use\n    # a issubclass() check here because apparently abc.'s __subclasscheck__()\n    # hook wants to create a weak reference to the object, but\n    # zipimport.zipimporter does not support weak references, resulting in a\n    # TypeError.  That seems terrible.\n    spec = package.__spec__\n    reader = getattr(spec.loader, 'get_resource_reader', None)  # type: ignore\n    if reader is None:\n        return None\n    return reader(spec.name)  # type: ignore\n\n\n@functools.singledispatch\ndef resolve(cand: Optional[Anchor]) -> types.ModuleType:\n    return cast(types.ModuleType, cand)\n\n\n@resolve.register\ndef _(cand: str) -> types.ModuleType:\n    return importlib.import_module(cand)\n\n\n@resolve.register\ndef _(cand: None) -> types.ModuleType:\n    return resolve(_infer_caller().f_globals['__name__'])\n\n\ndef _infer_caller():\n    \"\"\"\n    Walk the stack and find the frame of the first caller not in this module.\n    \"\"\"\n\n    def is_this_file(frame_info):\n        return frame_info.filename == __file__\n\n    def is_wrapper(frame_info):\n        return frame_info.function == 'wrapper'\n\n    not_this_file = itertools.filterfalse(is_this_file, inspect.stack())\n    # also exclude 'wrapper' due to singledispatch in the call stack\n    callers = itertools.filterfalse(is_wrapper, not_this_file)\n    return next(callers).frame\n\n\ndef from_package(package: types.ModuleType):\n    \"\"\"\n    Return a Traversable object for the given package.\n\n    \"\"\"\n    # deferred for performance (python/cpython#109829)\n    from .future.adapters import wrap_spec\n\n    spec = wrap_spec(package)\n    reader = spec.loader.get_resource_reader(spec.name)\n    return reader.files()\n\n\n@contextlib.contextmanager\ndef _tempfile(\n    reader,\n    suffix='',\n    # gh-93353: Keep a reference to call os.remove() in late Python\n    # finalization.\n    *,\n    _os_remove=os.remove,\n):\n    # Not using tempfile.NamedTemporaryFile as it leads to deeper 'try'\n    # blocks due to the need to close the temporary file to work on Windows\n    # properly.\n    fd, raw_path = tempfile.mkstemp(suffix=suffix)\n    try:\n        try:\n            os.write(fd, reader())\n        finally:\n            os.close(fd)\n        del reader\n        yield pathlib.Path(raw_path)\n    finally:\n        try:\n            _os_remove(raw_path)\n        except FileNotFoundError:\n            pass\n\n\ndef _temp_file(path):\n    return _tempfile(path.read_bytes, suffix=path.name)\n\n\ndef _is_present_dir(path: Traversable) -> bool:\n    \"\"\"\n    Some Traversables implement ``is_dir()`` to raise an\n    exception (i.e. ``FileNotFoundError``) when the\n    directory doesn't exist. This function wraps that call\n    to always return a boolean and only return True\n    if there's a dir and it exists.\n    \"\"\"\n    with contextlib.suppress(FileNotFoundError):\n        return path.is_dir()\n    return False\n\n\n@functools.singledispatch\ndef as_file(path):\n    \"\"\"\n    Given a Traversable object, return that object as a\n    path on the local file system in a context manager.\n    \"\"\"\n    return _temp_dir(path) if _is_present_dir(path) else _temp_file(path)\n\n\n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n    \"\"\"\n    Degenerate behavior for pathlib.Path objects.\n    \"\"\"\n    yield path\n\n\n@contextlib.contextmanager\ndef _temp_path(dir: tempfile.TemporaryDirectory):\n    \"\"\"\n    Wrap tempfile.TemporyDirectory to return a pathlib object.\n    \"\"\"\n    with dir as result:\n        yield pathlib.Path(result)\n\n\n@contextlib.contextmanager\ndef _temp_dir(path):\n    \"\"\"\n    Given a traversable dir, recursively replicate the whole tree\n    to the file system in a context manager.\n    \"\"\"\n    assert path.is_dir()\n    with _temp_path(tempfile.TemporaryDirectory()) as temp_dir:\n        yield _write_contents(temp_dir, path)\n\n\ndef _write_contents(target, source):\n    child = target.joinpath(source.name)\n    if source.is_dir():\n        child.mkdir()\n        for item in source.iterdir():\n            _write_contents(child, item)\n    else:\n        child.write_bytes(source.read_bytes())\n    return child\n", "importlib_resources/simple.py": "\"\"\"\nInterface adapters for low-level readers.\n\"\"\"\n\nimport abc\nimport io\nimport itertools\nfrom typing import BinaryIO, List\n\nfrom .abc import Traversable, TraversableResources\n\n\nclass SimpleReader(abc.ABC):\n    \"\"\"\n    The minimum, low-level interface required from a resource\n    provider.\n    \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def package(self) -> str:\n        \"\"\"\n        The name of the package for which this reader loads resources.\n        \"\"\"\n\n    @abc.abstractmethod\n    def children(self) -> List['SimpleReader']:\n        \"\"\"\n        Obtain an iterable of SimpleReader for available\n        child containers (e.g. directories).\n        \"\"\"\n\n    @abc.abstractmethod\n    def resources(self) -> List[str]:\n        \"\"\"\n        Obtain available named resources for this virtual package.\n        \"\"\"\n\n    @abc.abstractmethod\n    def open_binary(self, resource: str) -> BinaryIO:\n        \"\"\"\n        Obtain a File-like for a named resource.\n        \"\"\"\n\n    @property\n    def name(self):\n        return self.package.split('.')[-1]\n\n\nclass ResourceContainer(Traversable):\n    \"\"\"\n    Traversable container for a package's resources via its reader.\n    \"\"\"\n\n    def __init__(self, reader: SimpleReader):\n        self.reader = reader\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def iterdir(self):\n        files = (ResourceHandle(self, name) for name in self.reader.resources)\n        dirs = map(ResourceContainer, self.reader.children())\n        return itertools.chain(files, dirs)\n\n    def open(self, *args, **kwargs):\n        raise IsADirectoryError()\n\n\nclass ResourceHandle(Traversable):\n    \"\"\"\n    Handle to a named resource in a ResourceReader.\n    \"\"\"\n\n    def __init__(self, parent: ResourceContainer, name: str):\n        self.parent = parent\n        self.name = name  # type: ignore\n\n    def is_file(self):\n        return True\n\n    def is_dir(self):\n        return False\n\n    def open(self, mode='r', *args, **kwargs):\n        stream = self.parent.reader.open_binary(self.name)\n        if 'b' not in mode:\n            stream = io.TextIOWrapper(stream, *args, **kwargs)\n        return stream\n\n    def joinpath(self, name):\n        raise RuntimeError(\"Cannot traverse into a resource\")\n\n\nclass TraversableReader(TraversableResources, SimpleReader):\n    \"\"\"\n    A TraversableResources based on SimpleReader. Resource providers\n    may derive from this class to provide the TraversableResources\n    interface by supplying the SimpleReader interface.\n    \"\"\"\n\n    def files(self):\n        return ResourceContainer(self)\n", "importlib_resources/abc.py": "import abc\nimport io\nimport itertools\nimport pathlib\nfrom typing import Any, BinaryIO, Iterable, Iterator, NoReturn, Text, Optional\nfrom typing import runtime_checkable, Protocol\n\nfrom .compat.py38 import StrPath\n\n\n__all__ = [\"ResourceReader\", \"Traversable\", \"TraversableResources\"]\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for loaders to provide resource reading support.\"\"\"\n\n    @abc.abstractmethod\n    def open_resource(self, resource: Text) -> BinaryIO:\n        \"\"\"Return an opened, file-like object for binary reading.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource cannot be found, FileNotFoundError is raised.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def resource_path(self, resource: Text) -> Text:\n        \"\"\"Return the file system path to the specified resource.\n\n        The 'resource' argument is expected to represent only a file name.\n        If the resource does not exist on the file system, raise\n        FileNotFoundError.\n        \"\"\"\n        # This deliberately raises FileNotFoundError instead of\n        # NotImplementedError so that if this method is accidentally called,\n        # it'll still do the right thing.\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def is_resource(self, path: Text) -> bool:\n        \"\"\"Return True if the named 'path' is a resource.\n\n        Files are resources, directories are not.\n        \"\"\"\n        raise FileNotFoundError\n\n    @abc.abstractmethod\n    def contents(self) -> Iterable[str]:\n        \"\"\"Return an iterable of entries in `package`.\"\"\"\n        raise FileNotFoundError\n\n\nclass TraversalError(Exception):\n    pass\n\n\n@runtime_checkable\nclass Traversable(Protocol):\n    \"\"\"\n    An object with a subset of pathlib.Path methods suitable for\n    traversing directories and opening files.\n\n    Any exceptions that occur when accessing the backing resource\n    may propagate unaltered.\n    \"\"\"\n\n    @abc.abstractmethod\n    def iterdir(self) -> Iterator[\"Traversable\"]:\n        \"\"\"\n        Yield Traversable objects in self\n        \"\"\"\n\n    def read_bytes(self) -> bytes:\n        \"\"\"\n        Read contents of self as bytes\n        \"\"\"\n        with self.open('rb') as strm:\n            return strm.read()\n\n    def read_text(self, encoding: Optional[str] = None) -> str:\n        \"\"\"\n        Read contents of self as text\n        \"\"\"\n        with self.open(encoding=encoding) as strm:\n            return strm.read()\n\n    @abc.abstractmethod\n    def is_dir(self) -> bool:\n        \"\"\"\n        Return True if self is a directory\n        \"\"\"\n\n    @abc.abstractmethod\n    def is_file(self) -> bool:\n        \"\"\"\n        Return True if self is a file\n        \"\"\"\n\n    def joinpath(self, *descendants: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable resolved with any descendants applied.\n\n        Each descendant should be a path segment relative to self\n        and each may contain multiple levels separated by\n        ``posixpath.sep`` (``/``).\n        \"\"\"\n        if not descendants:\n            return self\n        names = itertools.chain.from_iterable(\n            path.parts for path in map(pathlib.PurePosixPath, descendants)\n        )\n        target = next(names)\n        matches = (\n            traversable for traversable in self.iterdir() if traversable.name == target\n        )\n        try:\n            match = next(matches)\n        except StopIteration:\n            raise TraversalError(\n                \"Target not found during traversal.\", target, list(names)\n            )\n        return match.joinpath(*names)\n\n    def __truediv__(self, child: StrPath) -> \"Traversable\":\n        \"\"\"\n        Return Traversable child in self\n        \"\"\"\n        return self.joinpath(child)\n\n    @abc.abstractmethod\n    def open(self, mode='r', *args, **kwargs):\n        \"\"\"\n        mode may be 'r' or 'rb' to open as text or binary. Return a handle\n        suitable for reading (same as pathlib.Path.open).\n\n        When opening as text, accepts encoding parameters such as those\n        accepted by io.TextIOWrapper.\n        \"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self) -> str:\n        \"\"\"\n        The base name of this object without any parent references.\n        \"\"\"\n\n\nclass TraversableResources(ResourceReader):\n    \"\"\"\n    The required interface for providing traversable\n    resources.\n    \"\"\"\n\n    @abc.abstractmethod\n    def files(self) -> \"Traversable\":\n        \"\"\"Return a Traversable object for the loaded package.\"\"\"\n\n    def open_resource(self, resource: StrPath) -> io.BufferedReader:\n        return self.files().joinpath(resource).open('rb')\n\n    def resource_path(self, resource: Any) -> NoReturn:\n        raise FileNotFoundError(resource)\n\n    def is_resource(self, path: StrPath) -> bool:\n        return self.files().joinpath(path).is_file()\n\n    def contents(self) -> Iterator[str]:\n        return (item.name for item in self.files().iterdir())\n", "importlib_resources/readers.py": "import collections\nimport contextlib\nimport itertools\nimport pathlib\nimport operator\nimport re\nimport warnings\n\nfrom . import abc\n\nfrom ._itertools import only\nfrom .compat.py39 import ZipPath\n\n\ndef remove_duplicates(items):\n    return iter(collections.OrderedDict.fromkeys(items))\n\n\nclass FileReader(abc.TraversableResources):\n    def __init__(self, loader):\n        self.path = pathlib.Path(loader.path).parent\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\nclass ZipReader(abc.TraversableResources):\n    def __init__(self, loader, module):\n        _, _, name = module.rpartition('.')\n        self.prefix = loader.prefix.replace('\\\\', '/') + name + '/'\n        self.archive = loader.archive\n\n    def open_resource(self, resource):\n        try:\n            return super().open_resource(resource)\n        except KeyError as exc:\n            raise FileNotFoundError(exc.args[0])\n\n    def is_resource(self, path):\n        \"\"\"\n        Workaround for `zipfile.Path.is_file` returning true\n        for non-existent paths.\n        \"\"\"\n        target = self.files().joinpath(path)\n        return target.is_file() and target.exists()\n\n    def files(self):\n        return ZipPath(self.archive, self.prefix)\n\n\nclass MultiplexedPath(abc.Traversable):\n    \"\"\"\n    Given a series of Traversable objects, implement a merged\n    version of the interface across all objects. Useful for\n    namespace packages which may be multihomed at a single\n    name.\n    \"\"\"\n\n    def __init__(self, *paths):\n        self._paths = list(map(_ensure_traversable, remove_duplicates(paths)))\n        if not self._paths:\n            message = 'MultiplexedPath must contain at least one path'\n            raise FileNotFoundError(message)\n        if not all(path.is_dir() for path in self._paths):\n            raise NotADirectoryError('MultiplexedPath only supports directories')\n\n    def iterdir(self):\n        children = (child for path in self._paths for child in path.iterdir())\n        by_name = operator.attrgetter('name')\n        groups = itertools.groupby(sorted(children, key=by_name), key=by_name)\n        return map(self._follow, (locs for name, locs in groups))\n\n    def read_bytes(self):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def read_text(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    def is_dir(self):\n        return True\n\n    def is_file(self):\n        return False\n\n    def joinpath(self, *descendants):\n        try:\n            return super().joinpath(*descendants)\n        except abc.TraversalError:\n            # One of the paths did not resolve (a directory does not exist).\n            # Just return something that will not exist.\n            return self._paths[0].joinpath(*descendants)\n\n    @classmethod\n    def _follow(cls, children):\n        \"\"\"\n        Construct a MultiplexedPath if needed.\n\n        If children contains a sole element, return it.\n        Otherwise, return a MultiplexedPath of the items.\n        Unless one of the items is not a Directory, then return the first.\n        \"\"\"\n        subdirs, one_dir, one_file = itertools.tee(children, 3)\n\n        try:\n            return only(one_dir)\n        except ValueError:\n            try:\n                return cls(*subdirs)\n            except NotADirectoryError:\n                return next(one_file)\n\n    def open(self, *args, **kwargs):\n        raise FileNotFoundError(f'{self} is not a file')\n\n    @property\n    def name(self):\n        return self._paths[0].name\n\n    def __repr__(self):\n        paths = ', '.join(f\"'{path}'\" for path in self._paths)\n        return f'MultiplexedPath({paths})'\n\n\nclass NamespaceReader(abc.TraversableResources):\n    def __init__(self, namespace_path):\n        if 'NamespacePath' not in str(namespace_path):\n            raise ValueError('Invalid path')\n        self.path = MultiplexedPath(*map(self._resolve, namespace_path))\n\n    @classmethod\n    def _resolve(cls, path_str) -> abc.Traversable:\n        r\"\"\"\n        Given an item from a namespace path, resolve it to a Traversable.\n\n        path_str might be a directory on the filesystem or a path to a\n        zipfile plus the path within the zipfile, e.g. ``/foo/bar`` or\n        ``/foo/baz.zip/inner_dir`` or ``foo\\baz.zip\\inner_dir\\sub``.\n        \"\"\"\n        (dir,) = (cand for cand in cls._candidate_paths(path_str) if cand.is_dir())\n        return dir\n\n    @classmethod\n    def _candidate_paths(cls, path_str):\n        yield pathlib.Path(path_str)\n        yield from cls._resolve_zip_path(path_str)\n\n    @staticmethod\n    def _resolve_zip_path(path_str):\n        for match in reversed(list(re.finditer(r'[\\\\/]', path_str))):\n            with contextlib.suppress(\n                FileNotFoundError,\n                IsADirectoryError,\n                NotADirectoryError,\n                PermissionError,\n            ):\n                inner = path_str[match.end() :].replace('\\\\', '/') + '/'\n                yield ZipPath(path_str[: match.start()], inner.lstrip('/'))\n\n    def resource_path(self, resource):\n        \"\"\"\n        Return the file system path to prevent\n        `resources.path()` from creating a temporary\n        copy.\n        \"\"\"\n        return str(self.path.joinpath(resource))\n\n    def files(self):\n        return self.path\n\n\ndef _ensure_traversable(path):\n    \"\"\"\n    Convert deprecated string arguments to traversables (pathlib.Path).\n\n    Remove with Python 3.15.\n    \"\"\"\n    if not isinstance(path, str):\n        return path\n\n    warnings.warn(\n        \"String arguments are deprecated. Pass a Traversable instead.\",\n        DeprecationWarning,\n        stacklevel=3,\n    )\n\n    return pathlib.Path(path)\n", "importlib_resources/functional.py": "\"\"\"Simplified function-based API for importlib.resources\"\"\"\n\nimport warnings\n\nfrom ._common import files, as_file\n\n\n_MISSING = object()\n\n\ndef open_binary(anchor, *path_names):\n    \"\"\"Open for binary reading the *resource* within *package*.\"\"\"\n    return _get_resource(anchor, path_names).open('rb')\n\n\ndef open_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Open for text reading the *resource* within *package*.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.open('r', encoding=encoding, errors=errors)\n\n\ndef read_binary(anchor, *path_names):\n    \"\"\"Read and return contents of *resource* within *package* as bytes.\"\"\"\n    return _get_resource(anchor, path_names).read_bytes()\n\n\ndef read_text(anchor, *path_names, encoding=_MISSING, errors='strict'):\n    \"\"\"Read and return contents of *resource* within *package* as str.\"\"\"\n    encoding = _get_encoding_arg(path_names, encoding)\n    resource = _get_resource(anchor, path_names)\n    return resource.read_text(encoding=encoding, errors=errors)\n\n\ndef path(anchor, *path_names):\n    \"\"\"Return the path to the *resource* as an actual file system path.\"\"\"\n    return as_file(_get_resource(anchor, path_names))\n\n\ndef is_resource(anchor, *path_names):\n    \"\"\"Return ``True`` if there is a resource named *name* in the package,\n\n    Otherwise returns ``False``.\n    \"\"\"\n    return _get_resource(anchor, path_names).is_file()\n\n\ndef contents(anchor, *path_names):\n    \"\"\"Return an iterable over the named resources within the package.\n\n    The iterable returns :class:`str` resources (e.g. files).\n    The iterable does not recurse into subdirectories.\n    \"\"\"\n    warnings.warn(\n        \"importlib.resources.contents is deprecated. \"\n        \"Use files(anchor).iterdir() instead.\",\n        DeprecationWarning,\n        stacklevel=1,\n    )\n    return (resource.name for resource in _get_resource(anchor, path_names).iterdir())\n\n\ndef _get_encoding_arg(path_names, encoding):\n    # For compatibility with versions where *encoding* was a positional\n    # argument, it needs to be given explicitly when there are multiple\n    # *path_names*.\n    # This limitation can be removed in Python 3.15.\n    if encoding is _MISSING:\n        if len(path_names) > 1:\n            raise TypeError(\n                \"'encoding' argument required with multiple path names\",\n            )\n        else:\n            return 'utf-8'\n    return encoding\n\n\ndef _get_resource(anchor, path_names):\n    if anchor is None:\n        raise TypeError(\"anchor must be module or string, got None\")\n    return files(anchor).joinpath(*path_names)\n", "importlib_resources/_adapters.py": "from contextlib import suppress\nfrom io import TextIOWrapper\n\nfrom . import abc\n\n\nclass SpecLoaderAdapter:\n    \"\"\"\n    Adapt a package spec to adapt the underlying loader.\n    \"\"\"\n\n    def __init__(self, spec, adapter=lambda spec: spec.loader):\n        self.spec = spec\n        self.loader = adapter(spec)\n\n    def __getattr__(self, name):\n        return getattr(self.spec, name)\n\n\nclass TraversableResourcesLoader:\n    \"\"\"\n    Adapt a loader to provide TraversableResources.\n    \"\"\"\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    def get_resource_reader(self, name):\n        return CompatibilityFiles(self.spec)._native()\n\n\ndef _io_wrapper(file, mode='r', *args, **kwargs):\n    if mode == 'r':\n        return TextIOWrapper(file, *args, **kwargs)\n    elif mode == 'rb':\n        return file\n    raise ValueError(f\"Invalid mode value '{mode}', only 'r' and 'rb' are supported\")\n\n\nclass CompatibilityFiles:\n    \"\"\"\n    Adapter for an existing or non-existent resource reader\n    to provide a compatibility .files().\n    \"\"\"\n\n    class SpecPath(abc.Traversable):\n        \"\"\"\n        Path tied to a module spec.\n        Can be read and exposes the resource reader children.\n        \"\"\"\n\n        def __init__(self, spec, reader):\n            self._spec = spec\n            self._reader = reader\n\n        def iterdir(self):\n            if not self._reader:\n                return iter(())\n            return iter(\n                CompatibilityFiles.ChildPath(self._reader, path)\n                for path in self._reader.contents()\n            )\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            if not self._reader:\n                return CompatibilityFiles.OrphanPath(other)\n            return CompatibilityFiles.ChildPath(self._reader, other)\n\n        @property\n        def name(self):\n            return self._spec.name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(self._reader.open_resource(None), mode, *args, **kwargs)\n\n    class ChildPath(abc.Traversable):\n        \"\"\"\n        Path tied to a resource reader child.\n        Can be read but doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, reader, name):\n            self._reader = reader\n            self._name = name\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return self._reader.is_resource(self.name)\n\n        def is_dir(self):\n            return not self.is_file()\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(self.name, other)\n\n        @property\n        def name(self):\n            return self._name\n\n        def open(self, mode='r', *args, **kwargs):\n            return _io_wrapper(\n                self._reader.open_resource(self.name), mode, *args, **kwargs\n            )\n\n    class OrphanPath(abc.Traversable):\n        \"\"\"\n        Orphan path, not tied to a module spec or resource reader.\n        Can't be read and doesn't expose any meaningful children.\n        \"\"\"\n\n        def __init__(self, *path_parts):\n            if len(path_parts) < 1:\n                raise ValueError('Need at least one path part to construct a path')\n            self._path = path_parts\n\n        def iterdir(self):\n            return iter(())\n\n        def is_file(self):\n            return False\n\n        is_dir = is_file\n\n        def joinpath(self, other):\n            return CompatibilityFiles.OrphanPath(*self._path, other)\n\n        @property\n        def name(self):\n            return self._path[-1]\n\n        def open(self, mode='r', *args, **kwargs):\n            raise FileNotFoundError(\"Can't open orphan path\")\n\n    def __init__(self, spec):\n        self.spec = spec\n\n    @property\n    def _reader(self):\n        with suppress(AttributeError):\n            return self.spec.loader.get_resource_reader(self.spec.name)\n\n    def _native(self):\n        \"\"\"\n        Return the native reader if it supports files().\n        \"\"\"\n        reader = self._reader\n        return reader if hasattr(reader, 'files') else self\n\n    def __getattr__(self, attr):\n        return getattr(self._reader, attr)\n\n    def files(self):\n        return CompatibilityFiles.SpecPath(self.spec, self._reader)\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Construct a package spec with traversable compatibility\n    on the spec/loader/reader.\n    \"\"\"\n    return SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "importlib_resources/__init__.py": "\"\"\"Read resources contained within a package.\"\"\"\n\nfrom ._common import (\n    as_file,\n    files,\n    Package,\n    Anchor,\n)\n\nfrom .functional import (\n    contents,\n    is_resource,\n    open_binary,\n    open_text,\n    path,\n    read_binary,\n    read_text,\n)\n\nfrom .abc import ResourceReader\n\n\n__all__ = [\n    'Package',\n    'Anchor',\n    'ResourceReader',\n    'as_file',\n    'files',\n    'contents',\n    'is_resource',\n    'open_binary',\n    'open_text',\n    'path',\n    'read_binary',\n    'read_text',\n]\n", "importlib_resources/compat/py38.py": "import os\nimport sys\n\nfrom typing import Union\n\n\nif sys.version_info >= (3, 9):\n    StrPath = Union[str, os.PathLike[str]]\nelse:\n    # PathLike is only subscriptable at runtime in 3.9+\n    StrPath = Union[str, \"os.PathLike[str]\"]\n", "importlib_resources/compat/py39.py": "import sys\n\n\n__all__ = ['ZipPath']\n\n\nif sys.version_info >= (3, 10):\n    from zipfile import Path as ZipPath  # type: ignore\nelse:\n    from zipp import Path as ZipPath  # type: ignore\n", "importlib_resources/compat/__init__.py": "", "importlib_resources/tests/test_read.py": "import unittest\nimport importlib_resources as resources\n\nfrom . import data01\nfrom . import util\nfrom importlib import import_module\n\n\nclass CommonBinaryTests(util.CommonTests, unittest.TestCase):\n    def execute(self, package, path):\n        resources.files(package).joinpath(path).read_bytes()\n\n\nclass CommonTextTests(util.CommonTests, unittest.TestCase):\n    def execute(self, package, path):\n        resources.files(package).joinpath(path).read_text(encoding='utf-8')\n\n\nclass ReadTests:\n    def test_read_bytes(self):\n        result = resources.files(self.data).joinpath('binary.file').read_bytes()\n        self.assertEqual(result, bytes(range(4)))\n\n    def test_read_text_default_encoding(self):\n        result = (\n            resources.files(self.data)\n            .joinpath('utf-8.file')\n            .read_text(encoding='utf-8')\n        )\n        self.assertEqual(result, 'Hello, UTF-8 world!\\n')\n\n    def test_read_text_given_encoding(self):\n        result = (\n            resources.files(self.data)\n            .joinpath('utf-16.file')\n            .read_text(encoding='utf-16')\n        )\n        self.assertEqual(result, 'Hello, UTF-16 world!\\n')\n\n    def test_read_text_with_errors(self):\n        \"\"\"\n        Raises UnicodeError without the 'errors' argument.\n        \"\"\"\n        target = resources.files(self.data) / 'utf-16.file'\n        self.assertRaises(UnicodeError, target.read_text, encoding='utf-8')\n        result = target.read_text(encoding='utf-8', errors='ignore')\n        self.assertEqual(\n            result,\n            'H\\x00e\\x00l\\x00l\\x00o\\x00,\\x00 '\n            '\\x00U\\x00T\\x00F\\x00-\\x001\\x006\\x00 '\n            '\\x00w\\x00o\\x00r\\x00l\\x00d\\x00!\\x00\\n\\x00',\n        )\n\n\nclass ReadDiskTests(ReadTests, unittest.TestCase):\n    data = data01\n\n\nclass ReadZipTests(ReadTests, util.ZipSetup, unittest.TestCase):\n    def test_read_submodule_resource(self):\n        submodule = import_module('data01.subdirectory')\n        result = resources.files(submodule).joinpath('binary.file').read_bytes()\n        self.assertEqual(result, bytes(range(4, 8)))\n\n    def test_read_submodule_resource_by_name(self):\n        result = (\n            resources.files('data01.subdirectory').joinpath('binary.file').read_bytes()\n        )\n        self.assertEqual(result, bytes(range(4, 8)))\n\n\nclass ReadNamespaceTests(ReadTests, unittest.TestCase):\n    def setUp(self):\n        from . import namespacedata01\n\n        self.data = namespacedata01\n\n\nclass ReadNamespaceZipTests(ReadTests, util.ZipSetup, unittest.TestCase):\n    ZIP_MODULE = 'namespacedata01'\n\n    def test_read_submodule_resource(self):\n        submodule = import_module('namespacedata01.subdirectory')\n        result = resources.files(submodule).joinpath('binary.file').read_bytes()\n        self.assertEqual(result, bytes(range(12, 16)))\n\n    def test_read_submodule_resource_by_name(self):\n        result = (\n            resources.files('namespacedata01.subdirectory')\n            .joinpath('binary.file')\n            .read_bytes()\n        )\n        self.assertEqual(result, bytes(range(12, 16)))\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/test_custom.py": "import unittest\nimport contextlib\nimport pathlib\n\nimport importlib_resources as resources\nfrom .. import abc\nfrom ..abc import TraversableResources, ResourceReader\nfrom . import util\nfrom .compat.py39 import os_helper\n\n\nclass SimpleLoader:\n    \"\"\"\n    A simple loader that only implements a resource reader.\n    \"\"\"\n\n    def __init__(self, reader: ResourceReader):\n        self.reader = reader\n\n    def get_resource_reader(self, package):\n        return self.reader\n\n\nclass MagicResources(TraversableResources):\n    \"\"\"\n    Magically returns the resources at path.\n    \"\"\"\n\n    def __init__(self, path: pathlib.Path):\n        self.path = path\n\n    def files(self):\n        return self.path\n\n\nclass CustomTraversableResourcesTests(unittest.TestCase):\n    def setUp(self):\n        self.fixtures = contextlib.ExitStack()\n        self.addCleanup(self.fixtures.close)\n\n    def test_custom_loader(self):\n        temp_dir = pathlib.Path(self.fixtures.enter_context(os_helper.temp_dir()))\n        loader = SimpleLoader(MagicResources(temp_dir))\n        pkg = util.create_package_from_loader(loader)\n        files = resources.files(pkg)\n        assert isinstance(files, abc.Traversable)\n        assert list(files.iterdir()) == []\n", "importlib_resources/tests/test_path.py": "import io\nimport pathlib\nimport unittest\n\nimport importlib_resources as resources\nfrom . import data01\nfrom . import util\n\n\nclass CommonTests(util.CommonTests, unittest.TestCase):\n    def execute(self, package, path):\n        with resources.as_file(resources.files(package).joinpath(path)):\n            pass\n\n\nclass PathTests:\n    def test_reading(self):\n        \"\"\"\n        Path should be readable and a pathlib.Path instance.\n        \"\"\"\n        target = resources.files(self.data) / 'utf-8.file'\n        with resources.as_file(target) as path:\n            self.assertIsInstance(path, pathlib.Path)\n            self.assertTrue(path.name.endswith(\"utf-8.file\"), repr(path))\n            self.assertEqual('Hello, UTF-8 world!\\n', path.read_text(encoding='utf-8'))\n\n\nclass PathDiskTests(PathTests, unittest.TestCase):\n    data = data01\n\n    def test_natural_path(self):\n        \"\"\"\n        Guarantee the internal implementation detail that\n        file-system-backed resources do not get the tempdir\n        treatment.\n        \"\"\"\n        target = resources.files(self.data) / 'utf-8.file'\n        with resources.as_file(target) as path:\n            assert 'data' in str(path)\n\n\nclass PathMemoryTests(PathTests, unittest.TestCase):\n    def setUp(self):\n        file = io.BytesIO(b'Hello, UTF-8 world!\\n')\n        self.addCleanup(file.close)\n        self.data = util.create_package(\n            file=file, path=FileNotFoundError(\"package exists only in memory\")\n        )\n        self.data.__spec__.origin = None\n        self.data.__spec__.has_location = False\n\n\nclass PathZipTests(PathTests, util.ZipSetup, unittest.TestCase):\n    def test_remove_in_context_manager(self):\n        \"\"\"\n        It is not an error if the file that was temporarily stashed on the\n        file system is removed inside the `with` stanza.\n        \"\"\"\n        target = resources.files(self.data) / 'utf-8.file'\n        with resources.as_file(target) as path:\n            path.unlink()\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/test_functional.py": "import unittest\nimport os\nimport contextlib\n\ntry:\n    from test.support.warnings_helper import ignore_warnings, check_warnings\nexcept ImportError:\n    # older Python versions\n    from test.support import ignore_warnings, check_warnings\n\nimport importlib_resources as resources\n\n# Since the functional API forwards to Traversable, we only test\n# filesystem resources here -- not zip files, namespace packages etc.\n# We do test for two kinds of Anchor, though.\n\n\nclass StringAnchorMixin:\n    anchor01 = 'importlib_resources.tests.data01'\n    anchor02 = 'importlib_resources.tests.data02'\n\n\nclass ModuleAnchorMixin:\n    from . import data01 as anchor01\n    from . import data02 as anchor02\n\n\nclass FunctionalAPIBase:\n    def _gen_resourcetxt_path_parts(self):\n        \"\"\"Yield various names of a text file in anchor02, each in a subTest\"\"\"\n        for path_parts in (\n            ('subdirectory', 'subsubdir', 'resource.txt'),\n            ('subdirectory/subsubdir/resource.txt',),\n            ('subdirectory/subsubdir', 'resource.txt'),\n        ):\n            with self.subTest(path_parts=path_parts):\n                yield path_parts\n\n    def test_read_text(self):\n        self.assertEqual(\n            resources.read_text(self.anchor01, 'utf-8.file'),\n            'Hello, UTF-8 world!\\n',\n        )\n        self.assertEqual(\n            resources.read_text(\n                self.anchor02,\n                'subdirectory',\n                'subsubdir',\n                'resource.txt',\n                encoding='utf-8',\n            ),\n            'a resource',\n        )\n        for path_parts in self._gen_resourcetxt_path_parts():\n            self.assertEqual(\n                resources.read_text(\n                    self.anchor02,\n                    *path_parts,\n                    encoding='utf-8',\n                ),\n                'a resource',\n            )\n        # Use generic OSError, since e.g. attempting to read a directory can\n        # fail with PermissionError rather than IsADirectoryError\n        with self.assertRaises(OSError):\n            resources.read_text(self.anchor01)\n        with self.assertRaises(OSError):\n            resources.read_text(self.anchor01, 'no-such-file')\n        with self.assertRaises(UnicodeDecodeError):\n            resources.read_text(self.anchor01, 'utf-16.file')\n        self.assertEqual(\n            resources.read_text(\n                self.anchor01,\n                'binary.file',\n                encoding='latin1',\n            ),\n            '\\x00\\x01\\x02\\x03',\n        )\n        self.assertEqual(\n            resources.read_text(\n                self.anchor01,\n                'utf-16.file',\n                errors='backslashreplace',\n            ),\n            'Hello, UTF-16 world!\\n'.encode('utf-16').decode(\n                errors='backslashreplace',\n            ),\n        )\n\n    def test_read_binary(self):\n        self.assertEqual(\n            resources.read_binary(self.anchor01, 'utf-8.file'),\n            b'Hello, UTF-8 world!\\n',\n        )\n        for path_parts in self._gen_resourcetxt_path_parts():\n            self.assertEqual(\n                resources.read_binary(self.anchor02, *path_parts),\n                b'a resource',\n            )\n\n    def test_open_text(self):\n        with resources.open_text(self.anchor01, 'utf-8.file') as f:\n            self.assertEqual(f.read(), 'Hello, UTF-8 world!\\n')\n        for path_parts in self._gen_resourcetxt_path_parts():\n            with resources.open_text(\n                self.anchor02,\n                *path_parts,\n                encoding='utf-8',\n            ) as f:\n                self.assertEqual(f.read(), 'a resource')\n        # Use generic OSError, since e.g. attempting to read a directory can\n        # fail with PermissionError rather than IsADirectoryError\n        with self.assertRaises(OSError):\n            resources.open_text(self.anchor01)\n        with self.assertRaises(OSError):\n            resources.open_text(self.anchor01, 'no-such-file')\n        with resources.open_text(self.anchor01, 'utf-16.file') as f:\n            with self.assertRaises(UnicodeDecodeError):\n                f.read()\n        with resources.open_text(\n            self.anchor01,\n            'binary.file',\n            encoding='latin1',\n        ) as f:\n            self.assertEqual(f.read(), '\\x00\\x01\\x02\\x03')\n        with resources.open_text(\n            self.anchor01,\n            'utf-16.file',\n            errors='backslashreplace',\n        ) as f:\n            self.assertEqual(\n                f.read(),\n                'Hello, UTF-16 world!\\n'.encode('utf-16').decode(\n                    errors='backslashreplace',\n                ),\n            )\n\n    def test_open_binary(self):\n        with resources.open_binary(self.anchor01, 'utf-8.file') as f:\n            self.assertEqual(f.read(), b'Hello, UTF-8 world!\\n')\n        for path_parts in self._gen_resourcetxt_path_parts():\n            with resources.open_binary(\n                self.anchor02,\n                *path_parts,\n            ) as f:\n                self.assertEqual(f.read(), b'a resource')\n\n    def test_path(self):\n        with resources.path(self.anchor01, 'utf-8.file') as path:\n            with open(str(path), encoding='utf-8') as f:\n                self.assertEqual(f.read(), 'Hello, UTF-8 world!\\n')\n        with resources.path(self.anchor01) as path:\n            with open(os.path.join(path, 'utf-8.file'), encoding='utf-8') as f:\n                self.assertEqual(f.read(), 'Hello, UTF-8 world!\\n')\n\n    def test_is_resource(self):\n        is_resource = resources.is_resource\n        self.assertTrue(is_resource(self.anchor01, 'utf-8.file'))\n        self.assertFalse(is_resource(self.anchor01, 'no_such_file'))\n        self.assertFalse(is_resource(self.anchor01))\n        self.assertFalse(is_resource(self.anchor01, 'subdirectory'))\n        for path_parts in self._gen_resourcetxt_path_parts():\n            self.assertTrue(is_resource(self.anchor02, *path_parts))\n\n    def test_contents(self):\n        with check_warnings((\".*contents.*\", DeprecationWarning)):\n            c = resources.contents(self.anchor01)\n        self.assertGreaterEqual(\n            set(c),\n            {'utf-8.file', 'utf-16.file', 'binary.file', 'subdirectory'},\n        )\n        with contextlib.ExitStack() as cm:\n            cm.enter_context(self.assertRaises(OSError))\n            cm.enter_context(check_warnings((\".*contents.*\", DeprecationWarning)))\n\n            list(resources.contents(self.anchor01, 'utf-8.file'))\n\n        for path_parts in self._gen_resourcetxt_path_parts():\n            with contextlib.ExitStack() as cm:\n                cm.enter_context(self.assertRaises(OSError))\n                cm.enter_context(check_warnings((\".*contents.*\", DeprecationWarning)))\n\n                list(resources.contents(self.anchor01, *path_parts))\n        with check_warnings((\".*contents.*\", DeprecationWarning)):\n            c = resources.contents(self.anchor01, 'subdirectory')\n        self.assertGreaterEqual(\n            set(c),\n            {'binary.file'},\n        )\n\n    @ignore_warnings(category=DeprecationWarning)\n    def test_common_errors(self):\n        for func in (\n            resources.read_text,\n            resources.read_binary,\n            resources.open_text,\n            resources.open_binary,\n            resources.path,\n            resources.is_resource,\n            resources.contents,\n        ):\n            with self.subTest(func=func):\n                # Rejecting None anchor\n                with self.assertRaises(TypeError):\n                    func(None)\n                # Rejecting invalid anchor type\n                with self.assertRaises((TypeError, AttributeError)):\n                    func(1234)\n                # Unknown module\n                with self.assertRaises(ModuleNotFoundError):\n                    func('$missing module$')\n\n    def test_text_errors(self):\n        for func in (\n            resources.read_text,\n            resources.open_text,\n        ):\n            with self.subTest(func=func):\n                # Multiple path arguments need explicit encoding argument.\n                with self.assertRaises(TypeError):\n                    func(\n                        self.anchor02,\n                        'subdirectory',\n                        'subsubdir',\n                        'resource.txt',\n                    )\n\n\nclass FunctionalAPITest_StringAnchor(\n    unittest.TestCase,\n    FunctionalAPIBase,\n    StringAnchorMixin,\n):\n    pass\n\n\nclass FunctionalAPITest_ModuleAnchor(\n    unittest.TestCase,\n    FunctionalAPIBase,\n    ModuleAnchorMixin,\n):\n    pass\n", "importlib_resources/tests/util.py": "import abc\nimport importlib\nimport io\nimport sys\nimport types\nimport pathlib\nimport contextlib\n\nfrom . import data01\nfrom ..abc import ResourceReader\nfrom .compat.py39 import import_helper, os_helper\nfrom . import zip as zip_\n\n\nfrom importlib.machinery import ModuleSpec\n\n\nclass Reader(ResourceReader):\n    def __init__(self, **kwargs):\n        vars(self).update(kwargs)\n\n    def get_resource_reader(self, package):\n        return self\n\n    def open_resource(self, path):\n        self._path = path\n        if isinstance(self.file, Exception):\n            raise self.file\n        return self.file\n\n    def resource_path(self, path_):\n        self._path = path_\n        if isinstance(self.path, Exception):\n            raise self.path\n        return self.path\n\n    def is_resource(self, path_):\n        self._path = path_\n        if isinstance(self.path, Exception):\n            raise self.path\n\n        def part(entry):\n            return entry.split('/')\n\n        return any(\n            len(parts) == 1 and parts[0] == path_ for parts in map(part, self._contents)\n        )\n\n    def contents(self):\n        if isinstance(self.path, Exception):\n            raise self.path\n        yield from self._contents\n\n\ndef create_package_from_loader(loader, is_package=True):\n    name = 'testingpackage'\n    module = types.ModuleType(name)\n    spec = ModuleSpec(name, loader, origin='does-not-exist', is_package=is_package)\n    module.__spec__ = spec\n    module.__loader__ = loader\n    return module\n\n\ndef create_package(file=None, path=None, is_package=True, contents=()):\n    return create_package_from_loader(\n        Reader(file=file, path=path, _contents=contents),\n        is_package,\n    )\n\n\nclass CommonTests(metaclass=abc.ABCMeta):\n    \"\"\"\n    Tests shared by test_open, test_path, and test_read.\n    \"\"\"\n\n    @abc.abstractmethod\n    def execute(self, package, path):\n        \"\"\"\n        Call the pertinent legacy API function (e.g. open_text, path)\n        on package and path.\n        \"\"\"\n\n    def test_package_name(self):\n        \"\"\"\n        Passing in the package name should succeed.\n        \"\"\"\n        self.execute(data01.__name__, 'utf-8.file')\n\n    def test_package_object(self):\n        \"\"\"\n        Passing in the package itself should succeed.\n        \"\"\"\n        self.execute(data01, 'utf-8.file')\n\n    def test_string_path(self):\n        \"\"\"\n        Passing in a string for the path should succeed.\n        \"\"\"\n        path = 'utf-8.file'\n        self.execute(data01, path)\n\n    def test_pathlib_path(self):\n        \"\"\"\n        Passing in a pathlib.PurePath object for the path should succeed.\n        \"\"\"\n        path = pathlib.PurePath('utf-8.file')\n        self.execute(data01, path)\n\n    def test_importing_module_as_side_effect(self):\n        \"\"\"\n        The anchor package can already be imported.\n        \"\"\"\n        del sys.modules[data01.__name__]\n        self.execute(data01.__name__, 'utf-8.file')\n\n    def test_missing_path(self):\n        \"\"\"\n        Attempting to open or read or request the path for a\n        non-existent path should succeed if open_resource\n        can return a viable data stream.\n        \"\"\"\n        bytes_data = io.BytesIO(b'Hello, world!')\n        package = create_package(file=bytes_data, path=FileNotFoundError())\n        self.execute(package, 'utf-8.file')\n        self.assertEqual(package.__loader__._path, 'utf-8.file')\n\n    def test_extant_path(self):\n        # Attempting to open or read or request the path when the\n        # path does exist should still succeed. Does not assert\n        # anything about the result.\n        bytes_data = io.BytesIO(b'Hello, world!')\n        # any path that exists\n        path = __file__\n        package = create_package(file=bytes_data, path=path)\n        self.execute(package, 'utf-8.file')\n        self.assertEqual(package.__loader__._path, 'utf-8.file')\n\n    def test_useless_loader(self):\n        package = create_package(file=FileNotFoundError(), path=FileNotFoundError())\n        with self.assertRaises(FileNotFoundError):\n            self.execute(package, 'utf-8.file')\n\n\nclass ZipSetupBase:\n    ZIP_MODULE = 'data01'\n\n    def setUp(self):\n        self.fixtures = contextlib.ExitStack()\n        self.addCleanup(self.fixtures.close)\n\n        self.fixtures.enter_context(import_helper.isolated_modules())\n\n        temp_dir = self.fixtures.enter_context(os_helper.temp_dir())\n        modules = pathlib.Path(temp_dir) / 'zipped modules.zip'\n        src_path = pathlib.Path(__file__).parent.joinpath(self.ZIP_MODULE)\n        self.fixtures.enter_context(\n            import_helper.DirsOnSysPath(str(zip_.make_zip_file(src_path, modules)))\n        )\n\n        self.data = importlib.import_module(self.ZIP_MODULE)\n\n\nclass ZipSetup(ZipSetupBase):\n    pass\n", "importlib_resources/tests/test_compatibilty_files.py": "import io\nimport unittest\n\nimport importlib_resources as resources\n\nfrom importlib_resources._adapters import (\n    CompatibilityFiles,\n    wrap_spec,\n)\n\nfrom . import util\n\n\nclass CompatibilityFilesTests(unittest.TestCase):\n    @property\n    def package(self):\n        bytes_data = io.BytesIO(b'Hello, world!')\n        return util.create_package(\n            file=bytes_data,\n            path='some_path',\n            contents=('a', 'b', 'c'),\n        )\n\n    @property\n    def files(self):\n        return resources.files(self.package)\n\n    def test_spec_path_iter(self):\n        self.assertEqual(\n            sorted(path.name for path in self.files.iterdir()),\n            ['a', 'b', 'c'],\n        )\n\n    def test_child_path_iter(self):\n        self.assertEqual(list((self.files / 'a').iterdir()), [])\n\n    def test_orphan_path_iter(self):\n        self.assertEqual(list((self.files / 'a' / 'a').iterdir()), [])\n        self.assertEqual(list((self.files / 'a' / 'a' / 'a').iterdir()), [])\n\n    def test_spec_path_is(self):\n        self.assertFalse(self.files.is_file())\n        self.assertFalse(self.files.is_dir())\n\n    def test_child_path_is(self):\n        self.assertTrue((self.files / 'a').is_file())\n        self.assertFalse((self.files / 'a').is_dir())\n\n    def test_orphan_path_is(self):\n        self.assertFalse((self.files / 'a' / 'a').is_file())\n        self.assertFalse((self.files / 'a' / 'a').is_dir())\n        self.assertFalse((self.files / 'a' / 'a' / 'a').is_file())\n        self.assertFalse((self.files / 'a' / 'a' / 'a').is_dir())\n\n    def test_spec_path_name(self):\n        self.assertEqual(self.files.name, 'testingpackage')\n\n    def test_child_path_name(self):\n        self.assertEqual((self.files / 'a').name, 'a')\n\n    def test_orphan_path_name(self):\n        self.assertEqual((self.files / 'a' / 'b').name, 'b')\n        self.assertEqual((self.files / 'a' / 'b' / 'c').name, 'c')\n\n    def test_spec_path_open(self):\n        self.assertEqual(self.files.read_bytes(), b'Hello, world!')\n        self.assertEqual(self.files.read_text(encoding='utf-8'), 'Hello, world!')\n\n    def test_child_path_open(self):\n        self.assertEqual((self.files / 'a').read_bytes(), b'Hello, world!')\n        self.assertEqual(\n            (self.files / 'a').read_text(encoding='utf-8'), 'Hello, world!'\n        )\n\n    def test_orphan_path_open(self):\n        with self.assertRaises(FileNotFoundError):\n            (self.files / 'a' / 'b').read_bytes()\n        with self.assertRaises(FileNotFoundError):\n            (self.files / 'a' / 'b' / 'c').read_bytes()\n\n    def test_open_invalid_mode(self):\n        with self.assertRaises(ValueError):\n            self.files.open('0')\n\n    def test_orphan_path_invalid(self):\n        with self.assertRaises(ValueError):\n            CompatibilityFiles.OrphanPath()\n\n    def test_wrap_spec(self):\n        spec = wrap_spec(self.package)\n        self.assertIsInstance(spec.loader.get_resource_reader(None), CompatibilityFiles)\n\n\nclass CompatibilityFilesNoReaderTests(unittest.TestCase):\n    @property\n    def package(self):\n        return util.create_package_from_loader(None)\n\n    @property\n    def files(self):\n        return resources.files(self.package)\n\n    def test_spec_path_joinpath(self):\n        self.assertIsInstance(self.files / 'a', CompatibilityFiles.OrphanPath)\n", "importlib_resources/tests/test_reader.py": "import os.path\nimport sys\nimport pathlib\nimport unittest\n\nfrom importlib import import_module\nfrom importlib_resources.readers import MultiplexedPath, NamespaceReader\n\n\nclass MultiplexedPathTest(unittest.TestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.folder = pathlib.Path(__file__).parent / 'namespacedata01'\n\n    def test_init_no_paths(self):\n        with self.assertRaises(FileNotFoundError):\n            MultiplexedPath()\n\n    def test_init_file(self):\n        with self.assertRaises(NotADirectoryError):\n            MultiplexedPath(self.folder / 'binary.file')\n\n    def test_iterdir(self):\n        contents = {path.name for path in MultiplexedPath(self.folder).iterdir()}\n        try:\n            contents.remove('__pycache__')\n        except (KeyError, ValueError):\n            pass\n        self.assertEqual(\n            contents, {'subdirectory', 'binary.file', 'utf-16.file', 'utf-8.file'}\n        )\n\n    def test_iterdir_duplicate(self):\n        data01 = pathlib.Path(__file__).parent.joinpath('data01')\n        contents = {\n            path.name for path in MultiplexedPath(self.folder, data01).iterdir()\n        }\n        for remove in ('__pycache__', '__init__.pyc'):\n            try:\n                contents.remove(remove)\n            except (KeyError, ValueError):\n                pass\n        self.assertEqual(\n            contents,\n            {'__init__.py', 'binary.file', 'subdirectory', 'utf-16.file', 'utf-8.file'},\n        )\n\n    def test_is_dir(self):\n        self.assertEqual(MultiplexedPath(self.folder).is_dir(), True)\n\n    def test_is_file(self):\n        self.assertEqual(MultiplexedPath(self.folder).is_file(), False)\n\n    def test_open_file(self):\n        path = MultiplexedPath(self.folder)\n        with self.assertRaises(FileNotFoundError):\n            path.read_bytes()\n        with self.assertRaises(FileNotFoundError):\n            path.read_text()\n        with self.assertRaises(FileNotFoundError):\n            path.open()\n\n    def test_join_path(self):\n        data01 = pathlib.Path(__file__).parent.joinpath('data01')\n        prefix = str(data01.parent)\n        path = MultiplexedPath(self.folder, data01)\n        self.assertEqual(\n            str(path.joinpath('binary.file'))[len(prefix) + 1 :],\n            os.path.join('namespacedata01', 'binary.file'),\n        )\n        sub = path.joinpath('subdirectory')\n        assert isinstance(sub, MultiplexedPath)\n        assert 'namespacedata01' in str(sub)\n        assert 'data01' in str(sub)\n        self.assertEqual(\n            str(path.joinpath('imaginary'))[len(prefix) + 1 :],\n            os.path.join('namespacedata01', 'imaginary'),\n        )\n        self.assertEqual(path.joinpath(), path)\n\n    def test_join_path_compound(self):\n        path = MultiplexedPath(self.folder)\n        assert not path.joinpath('imaginary/foo.py').exists()\n\n    def test_join_path_common_subdir(self):\n        data01 = pathlib.Path(__file__).parent.joinpath('data01')\n        data02 = pathlib.Path(__file__).parent.joinpath('data02')\n        prefix = str(data01.parent)\n        path = MultiplexedPath(data01, data02)\n        self.assertIsInstance(path.joinpath('subdirectory'), MultiplexedPath)\n        self.assertEqual(\n            str(path.joinpath('subdirectory', 'subsubdir'))[len(prefix) + 1 :],\n            os.path.join('data02', 'subdirectory', 'subsubdir'),\n        )\n\n    def test_repr(self):\n        self.assertEqual(\n            repr(MultiplexedPath(self.folder)),\n            f\"MultiplexedPath('{self.folder}')\",\n        )\n\n    def test_name(self):\n        self.assertEqual(\n            MultiplexedPath(self.folder).name,\n            os.path.basename(self.folder),\n        )\n\n\nclass NamespaceReaderTest(unittest.TestCase):\n    site_dir = str(pathlib.Path(__file__).parent)\n\n    @classmethod\n    def setUpClass(cls):\n        sys.path.append(cls.site_dir)\n\n    @classmethod\n    def tearDownClass(cls):\n        sys.path.remove(cls.site_dir)\n\n    def test_init_error(self):\n        with self.assertRaises(ValueError):\n            NamespaceReader(['path1', 'path2'])\n\n    def test_resource_path(self):\n        namespacedata01 = import_module('namespacedata01')\n        reader = NamespaceReader(namespacedata01.__spec__.submodule_search_locations)\n\n        root = os.path.abspath(os.path.join(__file__, '..', 'namespacedata01'))\n        self.assertEqual(\n            reader.resource_path('binary.file'), os.path.join(root, 'binary.file')\n        )\n        self.assertEqual(\n            reader.resource_path('imaginary'), os.path.join(root, 'imaginary')\n        )\n\n    def test_files(self):\n        namespacedata01 = import_module('namespacedata01')\n        reader = NamespaceReader(namespacedata01.__spec__.submodule_search_locations)\n        root = os.path.abspath(os.path.join(__file__, '..', 'namespacedata01'))\n        self.assertIsInstance(reader.files(), MultiplexedPath)\n        self.assertEqual(repr(reader.files()), f\"MultiplexedPath('{root}')\")\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/_path.py": "import pathlib\nimport functools\n\nfrom typing import Dict, Union\n\n\n####\n# from jaraco.path 3.4.1\n\nFilesSpec = Dict[str, Union[str, bytes, 'FilesSpec']]  # type: ignore\n\n\ndef build(spec: FilesSpec, prefix=pathlib.Path()):\n    \"\"\"\n    Build a set of files/directories, as described by the spec.\n\n    Each key represents a pathname, and the value represents\n    the content. Content may be a nested directory.\n\n    >>> spec = {\n    ...     'README.txt': \"A README file\",\n    ...     \"foo\": {\n    ...         \"__init__.py\": \"\",\n    ...         \"bar\": {\n    ...             \"__init__.py\": \"\",\n    ...         },\n    ...         \"baz.py\": \"# Some code\",\n    ...     }\n    ... }\n    >>> target = getfixture('tmp_path')\n    >>> build(spec, target)\n    >>> target.joinpath('foo/baz.py').read_text(encoding='utf-8')\n    '# Some code'\n    \"\"\"\n    for name, contents in spec.items():\n        create(contents, pathlib.Path(prefix) / name)\n\n\n@functools.singledispatch\ndef create(content: Union[str, bytes, FilesSpec], path):\n    path.mkdir(exist_ok=True)\n    build(content, prefix=path)  # type: ignore\n\n\n@create.register\ndef _(content: bytes, path):\n    path.write_bytes(content)\n\n\n@create.register\ndef _(content: str, path):\n    path.write_text(content, encoding='utf-8')\n\n\n# end from jaraco.path\n####\n", "importlib_resources/tests/test_open.py": "import unittest\n\nimport importlib_resources as resources\nfrom . import data01\nfrom . import util\n\n\nclass CommonBinaryTests(util.CommonTests, unittest.TestCase):\n    def execute(self, package, path):\n        target = resources.files(package).joinpath(path)\n        with target.open('rb'):\n            pass\n\n\nclass CommonTextTests(util.CommonTests, unittest.TestCase):\n    def execute(self, package, path):\n        target = resources.files(package).joinpath(path)\n        with target.open(encoding='utf-8'):\n            pass\n\n\nclass OpenTests:\n    def test_open_binary(self):\n        target = resources.files(self.data) / 'binary.file'\n        with target.open('rb') as fp:\n            result = fp.read()\n            self.assertEqual(result, bytes(range(4)))\n\n    def test_open_text_default_encoding(self):\n        target = resources.files(self.data) / 'utf-8.file'\n        with target.open(encoding='utf-8') as fp:\n            result = fp.read()\n            self.assertEqual(result, 'Hello, UTF-8 world!\\n')\n\n    def test_open_text_given_encoding(self):\n        target = resources.files(self.data) / 'utf-16.file'\n        with target.open(encoding='utf-16', errors='strict') as fp:\n            result = fp.read()\n        self.assertEqual(result, 'Hello, UTF-16 world!\\n')\n\n    def test_open_text_with_errors(self):\n        \"\"\"\n        Raises UnicodeError without the 'errors' argument.\n        \"\"\"\n        target = resources.files(self.data) / 'utf-16.file'\n        with target.open(encoding='utf-8', errors='strict') as fp:\n            self.assertRaises(UnicodeError, fp.read)\n        with target.open(encoding='utf-8', errors='ignore') as fp:\n            result = fp.read()\n        self.assertEqual(\n            result,\n            'H\\x00e\\x00l\\x00l\\x00o\\x00,\\x00 '\n            '\\x00U\\x00T\\x00F\\x00-\\x001\\x006\\x00 '\n            '\\x00w\\x00o\\x00r\\x00l\\x00d\\x00!\\x00\\n\\x00',\n        )\n\n    def test_open_binary_FileNotFoundError(self):\n        target = resources.files(self.data) / 'does-not-exist'\n        with self.assertRaises(FileNotFoundError):\n            target.open('rb')\n\n    def test_open_text_FileNotFoundError(self):\n        target = resources.files(self.data) / 'does-not-exist'\n        with self.assertRaises(FileNotFoundError):\n            target.open(encoding='utf-8')\n\n\nclass OpenDiskTests(OpenTests, unittest.TestCase):\n    def setUp(self):\n        self.data = data01\n\n\nclass OpenDiskNamespaceTests(OpenTests, unittest.TestCase):\n    def setUp(self):\n        from . import namespacedata01\n\n        self.data = namespacedata01\n\n\nclass OpenZipTests(OpenTests, util.ZipSetup, unittest.TestCase):\n    pass\n\n\nclass OpenNamespaceZipTests(OpenTests, util.ZipSetup, unittest.TestCase):\n    ZIP_MODULE = 'namespacedata01'\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/__init__.py": "", "importlib_resources/tests/zip.py": "\"\"\"\nGenerate zip test data files.\n\"\"\"\n\nimport contextlib\nimport os\nimport pathlib\nimport zipfile\n\nimport zipp\n\n\ndef make_zip_file(src, dst):\n    \"\"\"\n    Zip the files in src into a new zipfile at dst.\n    \"\"\"\n    with zipfile.ZipFile(dst, 'w') as zf:\n        for src_path, rel in walk(src):\n            dst_name = src.name / pathlib.PurePosixPath(rel.as_posix())\n            zf.write(src_path, dst_name)\n        zipp.CompleteDirs.inject(zf)\n    return dst\n\n\ndef walk(datapath):\n    for dirpath, dirnames, filenames in os.walk(datapath):\n        with contextlib.suppress(ValueError):\n            dirnames.remove('__pycache__')\n        for filename in filenames:\n            res = pathlib.Path(dirpath) / filename\n            rel = res.relative_to(datapath)\n            yield res, rel\n", "importlib_resources/tests/test_files.py": "import textwrap\nimport unittest\nimport warnings\nimport importlib\nimport contextlib\n\nimport importlib_resources as resources\nfrom ..abc import Traversable\nfrom . import data01\nfrom . import util\nfrom . import _path\nfrom .compat.py39 import os_helper\nfrom .compat.py312 import import_helper\n\n\n@contextlib.contextmanager\ndef suppress_known_deprecation():\n    with warnings.catch_warnings(record=True) as ctx:\n        warnings.simplefilter('default', category=DeprecationWarning)\n        yield ctx\n\n\nclass FilesTests:\n    def test_read_bytes(self):\n        files = resources.files(self.data)\n        actual = files.joinpath('utf-8.file').read_bytes()\n        assert actual == b'Hello, UTF-8 world!\\n'\n\n    def test_read_text(self):\n        files = resources.files(self.data)\n        actual = files.joinpath('utf-8.file').read_text(encoding='utf-8')\n        assert actual == 'Hello, UTF-8 world!\\n'\n\n    def test_traversable(self):\n        assert isinstance(resources.files(self.data), Traversable)\n\n    def test_joinpath_with_multiple_args(self):\n        files = resources.files(self.data)\n        binfile = files.joinpath('subdirectory', 'binary.file')\n        self.assertTrue(binfile.is_file())\n\n    def test_old_parameter(self):\n        \"\"\"\n        Files used to take a 'package' parameter. Make sure anyone\n        passing by name is still supported.\n        \"\"\"\n        with suppress_known_deprecation():\n            resources.files(package=self.data)\n\n\nclass OpenDiskTests(FilesTests, unittest.TestCase):\n    def setUp(self):\n        self.data = data01\n\n\nclass OpenZipTests(FilesTests, util.ZipSetup, unittest.TestCase):\n    pass\n\n\nclass OpenNamespaceTests(FilesTests, unittest.TestCase):\n    def setUp(self):\n        from . import namespacedata01\n\n        self.data = namespacedata01\n\n\nclass OpenNamespaceZipTests(FilesTests, util.ZipSetup, unittest.TestCase):\n    ZIP_MODULE = 'namespacedata01'\n\n\nclass SiteDir:\n    def setUp(self):\n        self.fixtures = contextlib.ExitStack()\n        self.addCleanup(self.fixtures.close)\n        self.site_dir = self.fixtures.enter_context(os_helper.temp_dir())\n        self.fixtures.enter_context(import_helper.DirsOnSysPath(self.site_dir))\n        self.fixtures.enter_context(import_helper.isolated_modules())\n\n\nclass ModulesFilesTests(SiteDir, unittest.TestCase):\n    def test_module_resources(self):\n        \"\"\"\n        A module can have resources found adjacent to the module.\n        \"\"\"\n        spec = {\n            'mod.py': '',\n            'res.txt': 'resources are the best',\n        }\n        _path.build(spec, self.site_dir)\n        import mod\n\n        actual = resources.files(mod).joinpath('res.txt').read_text(encoding='utf-8')\n        assert actual == spec['res.txt']\n\n\nclass ImplicitContextFilesTests(SiteDir, unittest.TestCase):\n    def test_implicit_files(self):\n        \"\"\"\n        Without any parameter, files() will infer the location as the caller.\n        \"\"\"\n        spec = {\n            'somepkg': {\n                '__init__.py': textwrap.dedent(\n                    \"\"\"\n                    import importlib_resources as res\n                    val = res.files().joinpath('res.txt').read_text(encoding='utf-8')\n                    \"\"\"\n                ),\n                'res.txt': 'resources are the best',\n            },\n        }\n        _path.build(spec, self.site_dir)\n        assert importlib.import_module('somepkg').val == 'resources are the best'\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/test_resource.py": "import sys\nimport unittest\nimport importlib_resources as resources\nimport pathlib\n\nfrom . import data01\nfrom . import util\nfrom importlib import import_module\n\n\nclass ResourceTests:\n    # Subclasses are expected to set the `data` attribute.\n\n    def test_is_file_exists(self):\n        target = resources.files(self.data) / 'binary.file'\n        self.assertTrue(target.is_file())\n\n    def test_is_file_missing(self):\n        target = resources.files(self.data) / 'not-a-file'\n        self.assertFalse(target.is_file())\n\n    def test_is_dir(self):\n        target = resources.files(self.data) / 'subdirectory'\n        self.assertFalse(target.is_file())\n        self.assertTrue(target.is_dir())\n\n\nclass ResourceDiskTests(ResourceTests, unittest.TestCase):\n    def setUp(self):\n        self.data = data01\n\n\nclass ResourceZipTests(ResourceTests, util.ZipSetup, unittest.TestCase):\n    pass\n\n\ndef names(traversable):\n    return {item.name for item in traversable.iterdir()}\n\n\nclass ResourceLoaderTests(unittest.TestCase):\n    def test_resource_contents(self):\n        package = util.create_package(\n            file=data01, path=data01.__file__, contents=['A', 'B', 'C']\n        )\n        self.assertEqual(names(resources.files(package)), {'A', 'B', 'C'})\n\n    def test_is_file(self):\n        package = util.create_package(\n            file=data01, path=data01.__file__, contents=['A', 'B', 'C', 'D/E', 'D/F']\n        )\n        self.assertTrue(resources.files(package).joinpath('B').is_file())\n\n    def test_is_dir(self):\n        package = util.create_package(\n            file=data01, path=data01.__file__, contents=['A', 'B', 'C', 'D/E', 'D/F']\n        )\n        self.assertTrue(resources.files(package).joinpath('D').is_dir())\n\n    def test_resource_missing(self):\n        package = util.create_package(\n            file=data01, path=data01.__file__, contents=['A', 'B', 'C', 'D/E', 'D/F']\n        )\n        self.assertFalse(resources.files(package).joinpath('Z').is_file())\n\n\nclass ResourceCornerCaseTests(unittest.TestCase):\n    def test_package_has_no_reader_fallback(self):\n        \"\"\"\n        Test odd ball packages which:\n        # 1. Do not have a ResourceReader as a loader\n        # 2. Are not on the file system\n        # 3. Are not in a zip file\n        \"\"\"\n        module = util.create_package(\n            file=data01, path=data01.__file__, contents=['A', 'B', 'C']\n        )\n        # Give the module a dummy loader.\n        module.__loader__ = object()\n        # Give the module a dummy origin.\n        module.__file__ = '/path/which/shall/not/be/named'\n        module.__spec__.loader = module.__loader__\n        module.__spec__.origin = module.__file__\n        self.assertFalse(resources.files(module).joinpath('A').is_file())\n\n\nclass ResourceFromZipsTest01(util.ZipSetupBase, unittest.TestCase):\n    ZIP_MODULE = 'data01'\n\n    def test_is_submodule_resource(self):\n        submodule = import_module('data01.subdirectory')\n        self.assertTrue(resources.files(submodule).joinpath('binary.file').is_file())\n\n    def test_read_submodule_resource_by_name(self):\n        self.assertTrue(\n            resources.files('data01.subdirectory').joinpath('binary.file').is_file()\n        )\n\n    def test_submodule_contents(self):\n        submodule = import_module('data01.subdirectory')\n        self.assertEqual(\n            names(resources.files(submodule)), {'__init__.py', 'binary.file'}\n        )\n\n    def test_submodule_contents_by_name(self):\n        self.assertEqual(\n            names(resources.files('data01.subdirectory')),\n            {'__init__.py', 'binary.file'},\n        )\n\n    def test_as_file_directory(self):\n        with resources.as_file(resources.files('data01')) as data:\n            assert data.name == 'data01'\n            assert data.is_dir()\n            assert data.joinpath('subdirectory').is_dir()\n            assert len(list(data.iterdir()))\n        assert not data.parent.exists()\n\n\nclass ResourceFromZipsTest02(util.ZipSetupBase, unittest.TestCase):\n    ZIP_MODULE = 'data02'\n\n    def test_unrelated_contents(self):\n        \"\"\"\n        Test thata zip with two unrelated subpackages return\n        distinct resources. Ref python/importlib_resources#44.\n        \"\"\"\n        self.assertEqual(\n            names(resources.files('data02.one')),\n            {'__init__.py', 'resource1.txt'},\n        )\n        self.assertEqual(\n            names(resources.files('data02.two')),\n            {'__init__.py', 'resource2.txt'},\n        )\n\n\nclass DeletingZipsTest(util.ZipSetupBase, unittest.TestCase):\n    \"\"\"Having accessed resources in a zip file should not keep an open\n    reference to the zip.\n    \"\"\"\n\n    def test_iterdir_does_not_keep_open(self):\n        [item.name for item in resources.files('data01').iterdir()]\n\n    def test_is_file_does_not_keep_open(self):\n        resources.files('data01').joinpath('binary.file').is_file()\n\n    def test_is_file_failure_does_not_keep_open(self):\n        resources.files('data01').joinpath('not-present').is_file()\n\n    @unittest.skip(\"Desired but not supported.\")\n    def test_as_file_does_not_keep_open(self):  # pragma: no cover\n        resources.as_file(resources.files('data01') / 'binary.file')\n\n    def test_entered_path_does_not_keep_open(self):\n        \"\"\"\n        Mimic what certifi does on import to make its bundle\n        available for the process duration.\n        \"\"\"\n        resources.as_file(resources.files('data01') / 'binary.file').__enter__()\n\n    def test_read_binary_does_not_keep_open(self):\n        resources.files('data01').joinpath('binary.file').read_bytes()\n\n    def test_read_text_does_not_keep_open(self):\n        resources.files('data01').joinpath('utf-8.file').read_text(encoding='utf-8')\n\n\nclass ResourceFromNamespaceTests:\n    def test_is_submodule_resource(self):\n        self.assertTrue(\n            resources.files(import_module('namespacedata01'))\n            .joinpath('binary.file')\n            .is_file()\n        )\n\n    def test_read_submodule_resource_by_name(self):\n        self.assertTrue(\n            resources.files('namespacedata01').joinpath('binary.file').is_file()\n        )\n\n    def test_submodule_contents(self):\n        contents = names(resources.files(import_module('namespacedata01')))\n        try:\n            contents.remove('__pycache__')\n        except KeyError:\n            pass\n        self.assertEqual(\n            contents, {'subdirectory', 'binary.file', 'utf-8.file', 'utf-16.file'}\n        )\n\n    def test_submodule_contents_by_name(self):\n        contents = names(resources.files('namespacedata01'))\n        try:\n            contents.remove('__pycache__')\n        except KeyError:\n            pass\n        self.assertEqual(\n            contents, {'subdirectory', 'binary.file', 'utf-8.file', 'utf-16.file'}\n        )\n\n    def test_submodule_sub_contents(self):\n        contents = names(resources.files(import_module('namespacedata01.subdirectory')))\n        try:\n            contents.remove('__pycache__')\n        except KeyError:\n            pass\n        self.assertEqual(contents, {'binary.file'})\n\n    def test_submodule_sub_contents_by_name(self):\n        contents = names(resources.files('namespacedata01.subdirectory'))\n        try:\n            contents.remove('__pycache__')\n        except KeyError:\n            pass\n        self.assertEqual(contents, {'binary.file'})\n\n\nclass ResourceFromNamespaceDiskTests(ResourceFromNamespaceTests, unittest.TestCase):\n    site_dir = str(pathlib.Path(__file__).parent)\n\n    @classmethod\n    def setUpClass(cls):\n        sys.path.append(cls.site_dir)\n\n    @classmethod\n    def tearDownClass(cls):\n        sys.path.remove(cls.site_dir)\n\n\nclass ResourceFromNamespaceZipTests(\n    util.ZipSetupBase,\n    ResourceFromNamespaceTests,\n    unittest.TestCase,\n):\n    ZIP_MODULE = 'namespacedata01'\n\n\nif __name__ == '__main__':\n    unittest.main()\n", "importlib_resources/tests/test_contents.py": "import unittest\nimport importlib_resources as resources\n\nfrom . import data01\nfrom . import util\n\n\nclass ContentsTests:\n    expected = {\n        '__init__.py',\n        'binary.file',\n        'subdirectory',\n        'utf-16.file',\n        'utf-8.file',\n    }\n\n    def test_contents(self):\n        contents = {path.name for path in resources.files(self.data).iterdir()}\n        assert self.expected <= contents\n\n\nclass ContentsDiskTests(ContentsTests, unittest.TestCase):\n    def setUp(self):\n        self.data = data01\n\n\nclass ContentsZipTests(ContentsTests, util.ZipSetup, unittest.TestCase):\n    pass\n\n\nclass ContentsNamespaceTests(ContentsTests, unittest.TestCase):\n    expected = {\n        # no __init__ because of namespace design\n        'binary.file',\n        'subdirectory',\n        'utf-16.file',\n        'utf-8.file',\n    }\n\n    def setUp(self):\n        from . import namespacedata01\n\n        self.data = namespacedata01\n", "importlib_resources/tests/data02/__init__.py": "", "importlib_resources/tests/data02/two/__init__.py": "", "importlib_resources/tests/data02/one/__init__.py": "", "importlib_resources/tests/compat/py312.py": "import contextlib\n\nfrom .py39 import import_helper\n\n\n@contextlib.contextmanager\ndef isolated_modules():\n    \"\"\"\n    Save modules on entry and cleanup on exit.\n    \"\"\"\n    (saved,) = import_helper.modules_setup()\n    try:\n        yield\n    finally:\n        import_helper.modules_cleanup(saved)\n\n\nvars(import_helper).setdefault('isolated_modules', isolated_modules)\n", "importlib_resources/tests/compat/py39.py": "\"\"\"\nBackward-compatability shims to support Python 3.9 and earlier.\n\"\"\"\n\nfrom jaraco.test.cpython import from_test_support, try_import\n\nimport_helper = try_import('import_helper') or from_test_support(\n    'modules_setup', 'modules_cleanup', 'DirsOnSysPath'\n)\nos_helper = try_import('os_helper') or from_test_support('temp_dir')\n", "importlib_resources/tests/compat/__init__.py": "", "importlib_resources/tests/data01/__init__.py": "", "importlib_resources/tests/data01/subdirectory/__init__.py": "", "importlib_resources/future/adapters.py": "import functools\nimport pathlib\nfrom contextlib import suppress\nfrom types import SimpleNamespace\n\nfrom .. import readers, _adapters\n\n\ndef _block_standard(reader_getter):\n    \"\"\"\n    Wrap _adapters.TraversableResourcesLoader.get_resource_reader\n    and intercept any standard library readers.\n    \"\"\"\n\n    @functools.wraps(reader_getter)\n    def wrapper(*args, **kwargs):\n        \"\"\"\n        If the reader is from the standard library, return None to allow\n        allow likely newer implementations in this library to take precedence.\n        \"\"\"\n        try:\n            reader = reader_getter(*args, **kwargs)\n        except NotADirectoryError:\n            # MultiplexedPath may fail on zip subdirectory\n            return\n        # Python 3.10+\n        mod_name = reader.__class__.__module__\n        if mod_name.startswith('importlib.') and mod_name.endswith('readers'):\n            return\n        # Python 3.8, 3.9\n        if isinstance(reader, _adapters.CompatibilityFiles) and (\n            reader.spec.loader.__class__.__module__.startswith('zipimport')\n            or reader.spec.loader.__class__.__module__.startswith(\n                '_frozen_importlib_external'\n            )\n        ):\n            return\n        return reader\n\n    return wrapper\n\n\ndef _skip_degenerate(reader):\n    \"\"\"\n    Mask any degenerate reader. Ref #298.\n    \"\"\"\n    is_degenerate = (\n        isinstance(reader, _adapters.CompatibilityFiles) and not reader._reader\n    )\n    return reader if not is_degenerate else None\n\n\nclass TraversableResourcesLoader(_adapters.TraversableResourcesLoader):\n    \"\"\"\n    Adapt loaders to provide TraversableResources and other\n    compatibility.\n\n    Ensures the readers from importlib_resources are preferred\n    over stdlib readers.\n    \"\"\"\n\n    def get_resource_reader(self, name):\n        return (\n            _skip_degenerate(_block_standard(super().get_resource_reader)(name))\n            or self._standard_reader()\n            or super().get_resource_reader(name)\n        )\n\n    def _standard_reader(self):\n        return self._zip_reader() or self._namespace_reader() or self._file_reader()\n\n    def _zip_reader(self):\n        with suppress(AttributeError):\n            return readers.ZipReader(self.spec.loader, self.spec.name)\n\n    def _namespace_reader(self):\n        with suppress(AttributeError, ValueError):\n            return readers.NamespaceReader(self.spec.submodule_search_locations)\n\n    def _file_reader(self):\n        try:\n            path = pathlib.Path(self.spec.origin)\n        except TypeError:\n            return None\n        if path.exists():\n            return readers.FileReader(SimpleNamespace(path=path))\n\n\ndef wrap_spec(package):\n    \"\"\"\n    Override _adapters.wrap_spec to use TraversableResourcesLoader\n    from above. Ensures that future behavior is always available on older\n    Pythons.\n    \"\"\"\n    return _adapters.SpecLoaderAdapter(package.__spec__, TraversableResourcesLoader)\n", "importlib_resources/future/__init__.py": ""}